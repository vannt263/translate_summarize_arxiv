{
  "article_text": [
    "a great range of techniques and tools have been developed and studied for the prediction of program behaviours without actually running the program @xcite .",
    "one of them , originating from type inference in functional programming languages , is the type and effect discipline @xcite . as a refinement of type systems in programming languages ,",
    "types are annotated with information characterizing dynamic behaviours of programs _ effects_. as a result , a well - typed program satisfies some properties regarding its side - effects as well .",
    "this type - based technique has been used for all kinds of static analysis of programs , e.g. flow analysis @xcite , dependency analysis @xcite , resource allocation analysis @xcite , and amortised analysis @xcite , etc .",
    "in particular , a type and effect system was developed by grabowski et al .",
    "@xcite to verify that a particular programming guideline for secure web - programming has been adhered to .",
    "generalizing from this , one could model a programming guideline as a property of traces that a program might have , where traces are sequences of events that are issued by a certain instrumentation of the program with special event - issuing operations",
    ". this instrumentation would be part of the formalised guideline .",
    "a finite state machine would then be used to specify the set of acceptable traces .",
    "most policies involve safety properties which can be assessed by examining finite portions of traces . in some cases",
    ", however , properties pertaining to liveness and fairness @xcite can become relevant .",
    "for instance , a guideline could be that calls to appropriate logging functions must be made again and again or that event ( sic ! ) handlers should not become stuck , e.g.  in the java swing framework .",
    "this motivated us to investigate the possibility of using type systems in this situation as well .",
    "our aim is not to offer new algorithms for deciding certain temporal properties or indeed to compete with the existing methods which are numerous @xcite , but to extend the reach of type systems .",
    "our solution goes , however , beyond a simple reformulation of an existing algorithm ; the abstract domain based bchi automata may well be useful in its on right and is an original contribution of this work .    for the sake of simplicity , we introduce and study a small language consisting of recursive first - order procedures and non - deterministic choices .",
    "the language explicitly allows infinite recursions . in this language , except for primitive procedures which have events as arguments , other procedures have no inputs .",
    "we define _ trace semantics _ which formalize finite and infinite traces generated by programs in this language .",
    "we also remark that in essence our language is the same as the _ pushdown systems _ that have been studied in detail by a number of authors @xcite .",
    "similar trace semantics were also studied by the cousots @xcite as a specific case of abstract interpretation .",
    "once a satisfactory type system for such a simple language has been found , it can be combined with known techniques @xcite to scale to a type system for a large fragment of java or similar languages .",
    "alternatively , one can use our simple language as a target of a preliminary abstraction step .",
    "then , we develop the bchi type and effect system to capture correctly finite and infinite traces .",
    "since branching is non - deterministic in our language , we can even establish a completeness result .",
    "completeness , of course , will be lost , once we re - introduce data - dependent branching .    as a demonstration",
    ", we extend the bchi type and effect system for this small language to a bchi type and effect system for featherweight java with field update @xcite .",
    "the main technical contribution of this paper is the design of an abstract domain in the sense of abstract interpretation @xcite based on bchi automata or rather a mild extension of those allowing infinite as well as finite words .",
    "the proofs of soundness and completeness of the type system are based on clear - cut lattice - theoretic properties of this abstraction .    as in the finitary case ,",
    "this _ bchi abstraction _ is based on equivalence relations on finite words generated by the policy bchi automaton .",
    "abstracted effects are no longer sets of such equivalence classes , but rather sets of pairs of the form @xmath0 with @xmath1 , @xmath2 classes and representing the infinitary language @xmath3 .",
    "while such pairs appear in bchi s original complementation construction for bchi automata @xcite and have subsequently been used by a number of authors @xcite , they have never been used in the context of type systems and abstract interpretation .",
    "as already mentioned , our language is equivalent to pushdown systems for which model - checking of temporal properties has been extensively studied @xcite .",
    "pushdown systems , on the other hand , are special cases of higher - order recursion systems introduced by knapik et al . @xcite and",
    "extensively studied by ong and his collaborators , e.g. @xcite .",
    "the latter work @xcite also casts model checking into the form of a type system and is thus quite closely related to our result .",
    "more precisely , from an alternating parity automaton a type system for higher - order recursion schemes is derived such that a scheme is typable iff its evaluation tree would be accepted by the automaton . in this way , in particular all mu - calculus definable properties of the evaluation tree become expressible .",
    "regarding trace languages as opposed to tree properties alternating parity automata are equivalent to bchi automata since both capture the ( @xmath4)regular languages .",
    "thus for the trace language of interest here the system from loc.cit .",
    "is equal in expressive power to our type system .",
    "the difference is that kobayashi and ong s system has a much more semantic flavour not unlike the intersection type systems used to characterise strong normalisation .",
    "more concretely , the well - formedness condition for recursions in that system requires the solution of a parity game whose size is proportional to the size of the program ( number of function symbols to be precise ) which is known to be equivalent to model checking trees against mu - calculus formulas .",
    "our type system , on the other hand , deviates from the standard type systems used in programming and program analysis only very slightly ; instead of the usual recursion rule ( which is clearly unsound in the context of liveness ) we use a rule involving a type variable .",
    "no further semantic conditions need to be checked once of course the given bchi automaton has been analysed and preprocessed .",
    "we can also mention that our method and approach are rather different . while",
    "_ loc.cit .",
    "_ uses games and automata we rely on the recently re - popularised @xcite ramseyian approach to the study of @xmath5-regular language and automata .",
    "another recent work on the use of types for properties of infinite traces is @xcite which embeds formulas of linear temporal logic into types in the context of functional reactive programming .",
    "this work , however , relies on an encoding of linear temporal logic in first - order logic with integers , e.g. , one models `` the event @xmath6 occurs infinitely often '' as a formula like @xmath7 where @xmath8 refers to that the event @xmath6 issues at the time @xmath9 .",
    "dependent types are being used to turn this into a type system , but questions of inference and decidability are not considered .",
    "the discussed works @xcite are  to our knowledge  the only attempts at extending the range of typing beyond safety properties .      in the next section",
    "we define a simple first - order language with parameterless recursive procedures and non - deterministic branching ( meant , of course , to abstract ordinary conditionals ) .",
    "an alphabet of events @xmath10 is assumed and for each event @xmath11 a primitive procedure @xmath12 is available that outputs @xmath13 and has no effect on control flow or state .",
    "programs are toplevel mutually recursive definitions of parameterless procedures comparable to the c - language .",
    "given a program , any expression then admits a set of finite and infinite words over @xmath10the traces of terminating and nonterminating computations of the program .",
    "we distinguish finite traces stemming from terminating execution from finite traces stemming from nonterminating but `` unproductive '' executions .",
    "thus , for every expression @xmath14 ( relative to a well - formed program ) and trace @xmath15 we define a judgement @xmath16 meaning that @xmath14 admits a terminating execution with trace @xmath17 ( necessarily @xmath18 then ) and another judgement @xmath19 meaning that @xmath14 admits a nonterminating computation with trace @xmath17 . in this case both @xmath18 and @xmath20 are possible .",
    "formally , this is defined by introducing @xmath21 events that are repeatedly issued so that any nonterminating computation will have an infinite trace _ with _",
    "@xmath21 events .",
    "the official trace semantics ( @xmath22 and @xmath23 ) is then defined by discarding these @xmath21 events .",
    "we then discuss alternative ways for defining the trace semantics and emphasize that it is merely meant to formalize the intuitively clear notion of event trace occurring during a computation .    in section  [ sec - e ]",
    "we then define a type - and - effect system whose effects are pairs @xmath0 with @xmath24 and @xmath25 .",
    "semantically , an expression has effect @xmath0 when @xmath22 implies @xmath26 and @xmath23 implies @xmath27 .",
    "the typing rules are given in figure  [ fig - e ] .",
    "we notice here that for the @xmath1-part ( terminating computation ) the typing rules are as usual ; one `` guesses '' a type for a recursively defined procedure and justifies it for its body .",
    "the rule for the nonterminating `` @xmath2-part '' is different .",
    "one assumes a type ( and effect ) variable for the recursive calls , typechecks the body and then takes the greatest fixpoint of the resulting type - and - effect equation .    with an ordinary recursive typing rule it would be possible to infer an effect like @xmath28 ( `` infinitely often @xmath29 '' ) for the program @xmath30 which is unsound .",
    "we then establish soundness ( theorem  [ thm - a ] ) and completeness ( theorem  [ thm - ca ] ) for this type - and - effect system .",
    "in particular , this shows that the proposed handling of recursive definitions does indeed work .",
    "the type system is at this level , however , of limited use since the effects are infinitary objects .",
    "therefore , in section  [ sec - q ] we introduce an abstraction of this type - and - effect system where effects are taken from a fixed finite set .",
    "this finite set is calculated from an a priori given bchi automaton and effects still denote pairs of finite and possibly infinite languages , but no longer is any such pair denotable",
    ".    our main result theorem  [ thm - cb ] then asserts that if the set of all traces of an expression is accepted by the given bchi automaton then this is provable in the abstracted type - and - effect system .",
    "so , no precision is lost in this sense .",
    "of course , we also have an accompanying soundness theorem ( theorem  [ thm - c ] ) for the abstract type - and - effect system .",
    "these results can be modularly deduced from soundness and completeness for the infinitary type - and - effect system ( thms  [ thm - a ] and [ thm - ca ] ) with the help of lattice - theoretic properties of the abstraction that are established in section  [ ba ] . in particular",
    ", we have a galois connection between the lattice of all languages and the lattice of language denotations in the abstract type system and all operations needed in the typing rules , in particular least and greatest fixpoints can be correctly rendered on the level of the abstractions .",
    "the crucial building block is the ability to compute abstractions of greatest fixpoints needed for recursive definitions entirely on the level of the abstracted types .",
    "this requires the combination of a combinatorial lemma ( lemma [ krit ] ) with known covering properties ( lemma  [ lem - d ] ) of the abstractions which follow from ramsey s theorem .",
    "section  [ xx ] and section  [ ba ] contain these lattice - theoretic results .",
    "we consider the discovery of this abstract lattice obtained from a bchi automaton an important result of independent interest .",
    "section  [ bet ] then contains the actual definition of the abstracted type - and - effect system and its soundness and completeness theorems which , as already mentioned , then are direct consequences of earlier results .",
    "section  [ compl ] discusses automatic type inference and its complexity .",
    "an appendix contains several worked out examples that did not fit into the main text and omitted proofs .",
    "we also sketch there , as a demonstration , a combination of an existing region - based type and effect system for featherweight java with field update @xcite with bchi types .",
    "the syntax of expressions is given by @xmath31 where @xmath12 is the only primitive procedure which generates an event @xmath13 taken from a fixed alphabet @xmath10 of events and @xmath32 ranges over procedures defined by expressions .",
    "parentheses are used to eliminate ambiguity .",
    "we assume that the operator @xmath33 is right - associative and has higher priority than the operator @xmath34 . as an example",
    ", we can define procedures @xmath32 and @xmath35 as : @xmath36 and @xmath37 .",
    "formally , thus a _ program _ consists of a finite set of procedure identifiers @xmath38 and for each @xmath39 an expression @xmath40 defining @xmath32 where calls to procedures from @xmath38 are allowed and in particular , @xmath32 may occur recursively in @xmath40 .    from now on ,",
    "we fix such a program @xmath41 and call an expression @xmath14 _ well - formed _ if it uses calls to procedures from @xmath38 only .",
    "since the operator @xmath34 is non - deterministic and non - primitive procedures have no arguments , stacks and heaps are not needed at this level of abstraction .",
    "let @xmath42 be the set of all finite and infinite sequences generated from the set @xmath10 of primitive events .",
    "we call an element @xmath17 in @xmath42 a _ trace_. given traces @xmath17 and @xmath43 , we define the concatenation @xmath44 as : @xmath45 if @xmath46 and @xmath17 if @xmath47 where @xmath48 and @xmath49 are respectively sets of all finite and infinite sequences over @xmath10 .",
    "so , @xmath50 and @xmath51 . as usual , we may write @xmath45 instead of @xmath44 . we are concerned with finite prefixes of the trace generated by a given expression .",
    "we call them _ observed traces_. notice that all observed traces are in @xmath48 .",
    "let @xmath40 be the definition ( a well - formed expression ) of @xmath32 .",
    "the observed trace semantics is given in figure [ fig - a ] .",
    "@xmath52 { } { o(a ) \\downarrow a } \\quad \\inferrule*%[left={prim - b } ] { } { o(a ) \\uparrow a } \\quad \\inferrule*%[left={epsilon } ] { } { e \\uparrow \\epsilon } \\quad \\inferrule*%[left={call - a } ] { e_f \\downarrow w } { f \\downarrow w } \\quad \\inferrule*%[left={call - b } ] { e_f \\uparrow w } { f \\uparrow w } \\inferrule*%[left={seq - a } ] { e_1 \\downarrow w\\qquad e_2 \\downarrow u } { e_1\\,;\\ , e_2 \\downarrow w \\cdot u } \\quad \\inferrule*%[left={seq - b } ] { e_1 \\downarrow w\\qquad e_2 \\uparrow u } { e_1\\,;\\,e_2 \\uparrow w \\cdot u}\\]]@xmath53 { e_1 \\uparrow w } { e_1\\,;\\,e_2 \\uparrow w } \\inferrule*%[left={if - a } ] { e_1 \\downarrow w } { e_1\\,?\\,e_2 \\downarrow w } \\quad \\inferrule*%[left={if - b } ] { e_2 \\downarrow w } { e_1\\,?\\,e_2 \\downarrow w } \\quad \\inferrule*%[left={if - c } ] { e_1 \\uparrow w } { e_1\\,?\\,e_2 \\uparrow w } \\quad \\inferrule*%[left={if - d } ] { e_2 \\uparrow w } { e_1\\,?\\,e_2 \\uparrow w}\\ ] ]    we write @xmath16 to mean that the finite trace generated by @xmath14 is @xmath17 .",
    "in particular , @xmath14 terminates .",
    "we write @xmath19 to mean that @xmath17 is a finite prefix of the trace generated by @xmath14 .",
    "let the notation @xmath54 denote that @xmath43 is a finite prefix of @xmath17 .",
    "we have : if @xmath55 or @xmath19 , then for all @xmath56 , @xmath57 .",
    "we now turn to define infinite traces of non - terminating programs .",
    "unfortunately , the observed trace semantics does not contain enough information for this .",
    "let us consider the following definitions : @xmath58 , @xmath59 , and @xmath60 .",
    "notice that the observed traces of @xmath32 and @xmath35 are exactly the same .",
    "however , the procedure @xmath35 has a path leading to an unproductive infinite recursion @xmath61 while @xmath32 is non - recursive . in order to fix this problem ,",
    "let us introduce the extended set @xmath62 of events and use @xmath63 for the set of all _ extended traces_. the _ observed extended trace semantics _ is same as the observed trace semantics except for the rule for function application in which a @xmath21-event is automatically generated .",
    "that is , @xmath64 { e_f \\uparrow w } { f \\uparrow \\checkmark\\cdot w } $ ] .",
    "the specific symbol @xmath21 is added to the beginning of trace @xmath17 of @xmath40 . by doing this",
    ", unproductive infinite recursions can be distinguished from productive cases by observed extended traces @xmath65 .",
    "for all observed extended traces @xmath17 , let @xmath66 denote the trace obtained from @xmath17 by removing all @xmath21s . based on the observed extended trace semantics , we define trace semantics as follows .    for all expressions @xmath14 and extended traces @xmath17 in @xmath67 , @xmath68 we say @xmath17 is a trace of @xmath14 if @xmath22 or @xmath23 .    notice that if @xmath22 , then @xmath17 is in @xmath48 and all executions of @xmath14 terminate .",
    "if @xmath23 , then @xmath17 is in @xmath69 and all executions of @xmath14 do not terminate . in our definition of trace semantics , the symbol @xmath21 is introduced to distinguish finite traces generated by terminating programs and non - terminating programs . when the trace semantics is well - defined , we remove all @xmath21s .",
    "we remark that this way of defining the semantics is one of several possibilities ; alternatives would consist of using a small step operational semantics or a coinductive definition .",
    "for instance , cousot et al @xcite define a generalization of structured operational semantics ( g@xmath70sos ) , is used to describe the finite and infinite executions of programs . at the end of the day we need to define the two judgements @xmath22 meaning that @xmath14 terminates with trace @xmath17 so , necessarily @xmath18 and @xmath23 meaning that @xmath14 does not terminate ( runs forever ) and its trace is @xmath17 . in this case",
    ", @xmath17 may either be an infinite word ( @xmath20 ) or a finite word ( @xmath71 ) in which case @xmath14 s evaluation gets stuck in an infinite loop but @xmath14 does not output events during this loop .",
    "an important fine point is that at our level of abstraction programs have a finite store which means that by knig s lemma `` arbitrarily long '' and `` infinitely long '' coincide . in a language allowing the nondeterministic selection of integers we could write a program that admits traces ( outputting @xmath13s ) of any finite length but not having an infinite trace .",
    "then , our trace semantics would erroneously ascribe the trace @xmath72 to such a program .",
    "but , fortunately , in our situation this does not occur . as a result ,",
    "for some language extensions , one may need to consider more complicated formal definitions of trace semantics .",
    "this would , however , have no influence on the type system we define and only very little influence on correctness proofs .",
    "in this section , we develop a type and effect system that captures the set of finite and infinite traces of a program .",
    "we also prove that this system is sound and complete .",
    "this system uses arbitrary languages for effect annotations and as such is not yet suitable for practical use let alone automatic inference .",
    "later , in section  [ sec - q ] we define a finitary abstraction of this system which still allows one to check soundly and completely whether the traces of a given program are accepted by a fixed bchi automaton .",
    "let @xmath1 be a subset of @xmath48 and @xmath2 be a subset of @xmath69 .",
    "an effect of a given expression @xmath14 is a pair @xmath73 satisfying : ( a ) if @xmath22 , then @xmath17 is in @xmath1 ; ( b ) if @xmath23 , then @xmath17 is in @xmath2 .",
    "we use the notation @xmath74 to denote that @xmath0 is an effect of @xmath14 .",
    "let @xmath75 be a set of variables .",
    "let @xmath76 range over expressions of the form : @xmath77 with @xmath78 and @xmath79 .",
    "we abbreviate @xmath80 by @xmath81 and thus use the notation @xmath82 to denote expressions of the form : @xmath83 .",
    "we use the symbol @xmath84 itself for the expression where @xmath85 , @xmath86 , and @xmath87 for all @xmath88 in @xmath81 .",
    "we define the following operations on these expressions : @xmath89 and @xmath90 where @xmath91 is a subset of @xmath48 . given an assignment function @xmath92 that assigns a set of traces to each variable @xmath84 in @xmath75 , we obtain for each expression @xmath76 a language @xmath93 by substituting @xmath94 for each variable @xmath84 .",
    "we define @xmath95 as the set of all words of the form @xmath96 where @xmath97 .",
    "note that @xmath98 .",
    "let @xmath99 be an _ environment _ that is a set of expressions of the form : @xmath100 with @xmath32 a non - primitive procedure , @xmath1 a subset of @xmath48 , and @xmath84 a variable in @xmath75 such that if @xmath101 and @xmath102 both occur in @xmath99 then @xmath103 . with the above definitions , we define the _ type - and - effect system _ in figure [ fig - e ] .    @xmath104 { } { \\delta\\vdash o(a)\\ \\&\\ ( \\{a\\ } , \\emptyset)}\\quad   \\inferrule*%[left={e - seq } ] { { \\delta\\vdash e_1\\ \\&\\",
    "( u_1 , v_1(\\mathfrak{x}))}\\qquad { \\delta\\vdash e_2\\ \\&\\ ( u_2 , v_2(\\mathfrak{x } ) ) } } { \\delta\\vdash e_1\\,;\\,e_2\\ \\&\\",
    "( u_1\\cdot u_2 , v_1(\\mathfrak{x } ) \\cup u_1\\cdot v_2(\\mathfrak{x}))}\\ ] ] @xmath105 { { \\delta\\vdash e_1\\ \\&\\ ( u_1 , v_1(\\mathfrak{x}))}\\qquad { \\delta\\vdash e_2\\ \\&\\ ( u_2 , v_2(\\mathfrak{x } ) ) } } { \\delta\\vdash e_1\\,?\\,e_2\\ \\&\\",
    "( u_1\\cup u_2 , v_1(\\mathfrak{x})\\cup v_2(\\mathfrak{x } ) ) } \\quad \\inferrule*%[left={e - call - a } ] { } { \\delta , f\\ \\&\\ (",
    "u , x)\\vdash f\\ \\&\\ ( u , x)}\\ ] ] @xmath106 { { \\delta , f\\ \\&\\ ( u , x)\\vdash e_f\\ \\&\\ ( u , a\\cdot x \\cup v(\\mathfrak{x}-x ) ) } } { \\delta\\vdash f\\ \\&\\ ( u , a^*\\cdot v(\\mathfrak{x}-x)\\cup a^\\omega)}\\ ] ]    an environment @xmath99 is justified if for all @xmath100 in @xmath99 one has @xmath107 for some @xmath91 , @xmath82 .",
    "a justified environment can be extended as follows :    [ lem - a ] given a justified environment @xmath99 such that @xmath108 , then the extended environment @xmath109 is also justified    an assignment function @xmath110 _ satifies _ an environment @xmath99 if whenever @xmath100 in @xmath99 and @xmath111 then @xmath112 .",
    "let us use the notation @xmath113 to denote that the environment @xmath99 is justified and that the assignment function @xmath110 satisfies @xmath99 .",
    "[ lem - b ] given an environment @xmath99 and an assignment function @xmath110 satisfying that @xmath113 , let @xmath114 be an extension @xmath115 $ ] of @xmath110 such that @xmath111 implies @xmath27 for all traces @xmath17 .",
    "if we have the derivation : @xmath116 , then @xmath117 .",
    "[ thm - a ] given an environment @xmath99 and an assignment function @xmath110 satisfying that @xmath113 , for all derivations : @xmath118 of an expression @xmath14 , we have : @xmath22 implies @xmath119 and @xmath23 implies @xmath120 .",
    "the only interesting case is that for the last rule in figure [ fig - e ] which relies on lemma [ lem - b ] . for more details , see appendix [ a - p ] .",
    "[ cor - a ] for all derivations @xmath121 of an expression @xmath14 , we have : @xmath122 implies @xmath26 and @xmath123 implies @xmath27 .",
    "fix for each non - primitive procedure @xmath39 a unique variable @xmath124 .",
    "if @xmath125 is a family of languages with @xmath126 define the corresponding environment @xmath127 as to contain the bindings @xmath128 .",
    "for each function body @xmath40 we can now derive using the rules except the last one a unique typing @xmath129 .",
    "the passage from @xmath130 to @xmath131 defines a monotone operator @xmath132 on the lattice @xmath133 .",
    "if @xmath134 is the least fixpoint of this operator then @xmath135 is justified and we get the judgements @xmath136 .",
    "successive application of the last rule then gives judgements @xmath137 and a direct induction shows that in fact @xmath138 and @xmath139 .",
    "we have thus shown :    [ thm - ca ] the judgements @xmath140 are derivable for each @xmath32 .",
    "we have kept the proof of this theorem in the running text since the monotone operator @xmath132 is still needed later .",
    "based on equivalence relations on finite words defined by the policy bchi automata , we introduce an abstraction of languages of finite and infinite words : the bchi abstraction .",
    "we place this abstraction into the framework of abstract interpretation and show that crucial operations , namely concatenation , least fixpoint , and infinite iteration ( @xmath141 ) can be computed on the level of the abstraction .",
    "we also show that the abstraction does not lose any information as far as acceptance by the fixed policy automaton is concerned .",
    "this then allows us to replace the infinitary effects in the previous type system by their finite abstraction and thus to obtain a type - and - effect system which is decidable with low complexity ( in the program size ) and yet complete .",
    "the soundness and completeness of this system follow directly from lattice - theoretic properties of this bchi abstraction ( lemma  [ lem - d ] and theorem  [ prese ] ) .",
    "given an expression @xmath14 , our goal is to verify that the set @xmath142 of all traces generated by @xmath14 satisfies some property .",
    "we use a mild extension of the standard bchi automata which we call _ extended bchi automata _ :    an extended bchi automaton is a quadruple @xmath143 where @xmath144 is a finite set of states , @xmath10 is an alphabet ; hereafter always required to be equal to the fixed alphabet of events ; @xmath145 the transition function , the initial state @xmath146 , and the set @xmath147 of final states .",
    "the language @xmath148 of @xmath149 is defined as : the set of all finite words by which a final state can be reached from the initial state and all infinite words for which there is a path which starts from the initial state and goes through final states infinitely often .",
    "thus , @xmath148 is the union of @xmath149 s language when understood as a traditional nfa and its language when understood as a traditional bchi automaton .",
    "following bchi s original works we use equivalence relations defined by extended bchi automata themselves to obtain finite representations of @xmath1 and @xmath2 .",
    "we write @xmath150 to mean that the state @xmath151 is reachable from the state @xmath152 by using the finite word @xmath17 .",
    "let @xmath153 denote that by using the finite word @xmath17 , the state @xmath151 can be reached from the state @xmath152 in such a way that a final state is visited on the way . in particular , @xmath154 with @xmath155 or @xmath156 implies @xmath153 .",
    "formally , we have @xmath153 iff there exists @xmath157 and @xmath158 such that @xmath159 and @xmath160 and @xmath161 .    for nonempty words",
    "@xmath162 we define @xmath163 we write @xmath164 $ ] for the equivalence class of @xmath165 and additionally let @xmath166 $ ] stand for @xmath167 . we write @xmath168 for @xmath169\\}$ ] .",
    "thus @xmath168 comprises the @xmath170-equivalence classes and a special class for the empty word .",
    "we notice that if @xmath171 and @xmath172 then @xmath173 .",
    "as a result concatenation is well - defined on equivalence classes , thus @xmath174 becomes a semigroup and @xmath168 a monoid .",
    "the following lemma is a straightforward consequence of standard results about bchi automata @xcite .",
    "[ lem - d ] fix an extended bchi automaton @xmath175 ,    * @xmath168 is finite and its elements are regular languages ; * for all classes @xmath176 in @xmath168 , @xmath177 implies @xmath178 ; * for all classes @xmath176 and @xmath179 in @xmath168 , @xmath180 implies @xmath181 ; * for every word @xmath182 there exist classes @xmath183 so that @xmath184 and @xmath185 and @xmath186 .",
    "the sets @xmath187 ( with @xmath185 and @xmath186 ) thus behave almost like classes themselves , but an important difference is that they may nontrivially overlap . if @xmath188 then in general one can not conclude @xmath189 .",
    "we also remark that ramsey s theorem is used in the proof of ( d ) .",
    "lemma  [ lem - d ] shows that given an extended bchi automaton @xmath149 , without affecting property checking , we can use sets of classes in @xmath168 to represent languages over @xmath48 and sets of pairs of classes @xmath190 such that @xmath185 and @xmath186 to represent languages over @xmath69 .",
    "let us write @xmath191 .",
    "let us define the pre - abstraction function @xmath192 and the pre - concretization function @xmath193 as : @xmath194 and @xmath195 respectively .",
    "a set @xmath196 is _ closed _",
    ", if @xmath197 .",
    "explicitly , @xmath198 is closed if whenever @xmath199 for some @xmath200 and @xmath201 then already @xmath202 .",
    "clearly , for every set @xmath203 there is a least closed superset and it is given by applying the _ closure _ function : @xmath204 which is defined as : @xmath205 .",
    "we write @xmath206 for the set such closed subsets .",
    "the elements of @xmath207 will serve as abstractions of languages over @xmath69 .",
    "we also define explicitly @xmath208 to represent languages over @xmath48 but note that via the embedding @xmath209 we could identify @xmath210 with a subset of @xmath207 .",
    "[ lem - in ] both @xmath210 and @xmath207 are complete lattices with respect to inclusion .",
    "from now on we call @xmath211 and @xmath212 the _ concrete domains _ and @xmath210 and @xmath207 the",
    "_ abstract domains_. we introduce the following _ abstraction functions _ : @xmath213 and @xmath214 , which are respectively defined as : @xmath215 and @xmath216 .",
    "we also introduce the following _ concretization functions _ : @xmath217 and @xmath218 , which are respectively defined as : @xmath219 and @xmath220 .",
    "[ lem - galois ] the abstraction and concretization functions are monotone and form galois connections , that is : @xmath221 iff @xmath222 , and @xmath223 iff @xmath224 .",
    "moreover , @xmath225 and @xmath226 so we have in fact a galois _",
    "injection_. furthermore , both abstraction and concretization functions preserve unions , least and greatest elements .",
    "the concretization functions also preserve intersections .",
    "the next lemma shows that the abstraction is sufficiently fine for our purposes .",
    "it is a direct consequence of the galois connection and the fact that @xmath148 itself is closed which in turn is direct from lemma  [ lem - d ] ( b ) and ( c ) .",
    "[ compless ] let @xmath227 .",
    "if @xmath228 then @xmath229 iff @xmath230 .",
    "we now turn to define some new operators for the abstract domains .",
    "we have a concatenation operation on @xmath210 given pointwise , i.e.  for @xmath231 , we define @xmath232 .",
    "we also define a concatenation @xmath233 as follows : @xmath234 .",
    "note that @xmath235 .",
    "[ lem - con ] if @xmath236 and @xmath237 then @xmath238 .",
    "[ prese ] the preservation properties listed in table  [ tab - a ] are valid .",
    "most of these properties are direct and folklore or have been asserted earlier . in the clause about least fixpoints denoted by @xmath239 the operators @xmath132 and @xmath240 are supposed to be monotone operators on @xmath241 and @xmath242 for some @xmath243 .",
    "the clause is then validated by straightforward application of lattice - theoretic principles .",
    "only preservation of @xmath141 is a nontrivial and original result ; it requires the following lemma .",
    "ll @xmath213 & @xmath214 + @xmath244 & @xmath245 + @xmath246 & @xmath247 + @xmath248 & @xmath249 + @xmath250 & @xmath251 + @xmath252 & @xmath253 +    [ krit ] let @xmath254 be a family of classes ( from @xmath168 ) and put @xmath255 , i.e. , @xmath256 comprises finite or infinite words of the form @xmath257 where @xmath258 for @xmath259 .",
    "there exist classes @xmath260 where @xmath261 such that @xmath262 .",
    "let @xmath263 and write @xmath264 where @xmath258 . if @xmath17 is a finite word then there exists @xmath243 such that @xmath265 ( and @xmath266 $ ] ) for @xmath267 and we can choose @xmath268 and @xmath269 $ ] . otherwise , use ramsey",
    "s theorem as in the proof of lemma  [ lem - d ] to obtain a sequence of indices @xmath270 and classes @xmath271 where @xmath272 $ ] and @xmath273 , @xmath274 such that @xmath275 , @xmath276 and @xmath277 and so on .",
    "it follows that @xmath278 and @xmath279 for @xmath280 and thus @xmath281 as required .",
    "it only remains to prove preservation of @xmath141 .",
    "so , fix @xmath282 .",
    "we want to show that @xmath283 .",
    "note that @xmath284 .",
    "the direction `` @xmath285 '' is obvious from monotonicity ; towards proving `` @xmath286 '' assume @xmath287 .",
    "since @xmath288 is closed , we may without loss of generality assume that @xmath289 .",
    "pick @xmath290 and decompose @xmath291 where @xmath292 .",
    "define @xmath293 $ ] and apply lemma  [ krit ] to obtain @xmath294 with @xmath295 .",
    "note that , since @xmath296 , we have @xmath297 .    now , since @xmath298 , by the definition of @xmath299 , we must have that @xmath300 .",
    "choose @xmath301 .",
    "the word @xmath302 is then contained in @xmath303 , so @xmath304 and , finally , @xmath305 since @xmath288 is closed and @xmath297 .    [ bet ]    let @xmath306 be an element in @xmath210 and @xmath198 be an element in @xmath207 .",
    "the pair @xmath307 is a bchi effect of a given expression @xmath14 if it satisfies : ( a ) if @xmath122 , then @xmath308 ; ( b ) if @xmath123 , then @xmath309 .",
    "let @xmath310 range over expressions of the form : @xmath311 with @xmath312 and @xmath313 .",
    "we define the notation @xmath314 and operations on these expressions in the same way as we have done for expressions in the type and effect system in section [ sec - e ] .",
    "the definitions of justifiedness and satisfaction of environments and assignments are adapted to the bchi type system mutatis mutandis .",
    "that is , @xmath99 is justified if for all @xmath315 in @xmath99 one has @xmath316 .",
    "it is satisfied by @xmath110 if @xmath315 in @xmath99 and @xmath111 implies @xmath317 .    with the above definitions",
    ", we introduce the bchi type and effect system in figure [ fig - f ] .",
    "@xmath318 { } { \\delta \\vdash_{\\mathfrak{a } } o(a)\\ \\&\\ ( \\alpha_*(\\{a\\}),\\emptyset ) } \\quad   \\inferrule%*[left={$\\mathfrak{a}$-seq } ] { { \\delta \\vdash_{\\mathfrak{a } } e_1\\ \\&\\",
    "( \\mathcal{u}_1 , \\mathcal{v}_1(\\mathfrak{x}))}\\qquad { \\delta \\vdash_{\\mathfrak{a } } e_2\\ \\&\\ ( \\mathcal{u}_2 , \\mathcal{v}_2(\\mathfrak{x } ) ) } } { \\delta \\vdash_{\\mathfrak{a } } e_1\\,;\\,e_2\\ \\&\\ ( \\mathcal{u}_1\\cdot \\mathcal{u}_2 , \\mathcal{v}_1(\\mathfrak{x } ) \\cup \\mathcal{u}_1\\cdot \\mathcal{v}_2(\\mathfrak{x}))}\\]]@xmath319 { { \\delta \\vdash_{\\mathfrak{a } } e_1\\ \\&\\ ( \\mathcal{u}_1 , \\mathcal{v}_1(\\mathfrak{x}))}\\qquad { \\delta \\vdash_{\\mathfrak{a } } e_2\\ \\&\\ ( \\mathcal{u}_2 , \\mathcal{v}_2(\\mathfrak{x } ) ) } } { \\delta \\vdash_{\\mathfrak{a } } e_1\\,?\\,e_2\\ \\&\\ ( \\mathcal{u}_1\\cup \\mathcal{u}_2 , \\mathcal{v}_1(\\mathfrak{x})\\cup \\mathcal{v}_2(\\mathfrak{x } ) ) } \\quad \\inferrule%*[left={$\\mathfrak{a}$-call - a } ] { } { \\delta , f\\ \\&\\ ( \\mathcal{u},x ) \\vdash_{\\mathfrak{a } } f\\ \\&\\ ( \\mathcal{u},x)}\\]]@xmath320 { { \\delta , f\\ \\&\\ ( \\mathcal{u } , x ) \\vdash_{\\mathfrak{a } } e_f\\ \\&\\ ( \\mathcal{u } , \\mathcal{a}\\cdot x\\cup \\mathcal{v}(\\mathfrak{x}-x ) ) } } { \\delta \\vdash_{\\mathfrak{a } } f\\ \\&\\ ( \\mathcal{u } , \\mathcal{a}^*\\cdot \\mathcal{v}(\\mathfrak{x}-x)\\cup \\mathcal{a}^\\omega)}\\ ] ]    by using properties of the bchi abstraction in table [ tab - a ] , from theorems [ thm - a ] and [ thm - ca ] , we have that this system is sound and complete .",
    "[ thm - c ] given an environment @xmath99 and an assignment function @xmath110 satisfying that @xmath321 , for all derivations : @xmath322 of an expression @xmath14 , we have : @xmath22 implies @xmath323 and @xmath23 implies @xmath324 .",
    "it follows from the galois connections in lemma [ lem - galois ] .",
    "in particular , @xmath325 and @xmath326 .",
    "[ thm - cb ] given a non - primitive procedure @xmath32 ,",
    "let @xmath327 be the set of all traces generated by @xmath32 .",
    "there is a derivation @xmath328 such that @xmath329 if and only if @xmath330 .",
    "recall the monotone operator @xmath132 from the proof of theorem  [ thm - ca ] .",
    "since @xmath132 is built up from concatenation and union there is an abstract operator @xmath240 such that @xmath331 .",
    "thus @xmath332 and therefore , the judgements @xmath333 ( again in keeping with the notation of that proof ) are derivable in the bchi type system . using the preservation of @xmath141 repeatedly ,",
    "we then obtain the judgements @xmath334 where @xmath138 and @xmath139 . letting @xmath335 and",
    "@xmath336 the claim then follows using lemma  [ compless ] .",
    "given that the abstract lattices and thus the set of types is finite , type inference is a standard application of well - known techniques .",
    "we therefore just sketch it here to give an idea of the complexity .    from a given program we can construct in linear time a skeleton typing derivation for the finitary effect annotations .",
    "the skeleton typing derivation contains variables in place of actual effect annotations ; the number of these variables is linear in the program size .",
    "the side conditions of the typing rules then become constraints on these variables and any solution will yield a valid typing derivation . in quadratic time",
    "( assuming that @xmath207 has constant size ) we can then compute the least solution of these constraints using the usual iteration algorithms known from abstract interpretation .",
    "once we have in this way obtained the finitary effect annotations we can then ( in linear time ) derive the infinitary ones using the @xmath141 and infinitary concatenation operators on @xmath207 .",
    "once the type of an expression has been found one can then check ( in constant time ) whether the language denoted by it is accepted by the policy automaton .",
    "if we are interested in complexity as a function of the size of the policy automaton the situation is of course different .",
    "the important parameter here is the size of the abstract lattices since the number of iterations as well as the runtime of the algorithms for computing the abstractions of concatenation , union , infinite iteration are linear in this parameter . if @xmath243 is the number of states of the policy automaton then the number of classes can be bounded by @xmath337 since each class is characterised by two sets of pairs of states .",
    "the resulting exponential in @xmath243 runtime of our algorithms is no surprise since the pspace - complete problem of universality of bchi automata is easily reduced to type checking .",
    "we believe that by clever space management our algorithms can be implemented in polynomial space but we have not verified this .    on a positive note",
    "we remark that for a small policy automaton the set of classes is manageable as we see in the examples below .",
    "we also note that once the classes have been computed and the abstract functions tabulated one can then analyse many programs of arbitrary size .",
    "we have developed a type - and - effect system for capturing possibly infinite traces of recursively defined first - order procedures .",
    "the type - and - effect system is sound and complete with respect to inclusion of traces in a given bchi ( `` policy '' ) automaton .",
    "the effect annotations are from a finite set that can be effectively computed from the bchi automaton .",
    "type inference using constraint solving is thus possible .",
    "we emphasize that the resulting ability to decide satisfaction of temporal properties of traces is not claimed as a new result here ; since it has long been known in the context of model checking .",
    "the novelty lies in the presentation as a type and effect system that follows the standard pattern of such systems .",
    "as we explain below , this opens the way for smooth integration with existing type - theoretic technology .",
    "the proofs of soundness and completeness are organised in a modular fashion and decomposed into a type - theoretic part expressed in the form of an infinitary system ( section  [ sec - e ] ) and a lattice - theoretic part ( section  [ ba ] ) . concretely",
    ", this section defines an abstract domain from any given bchi automaton and derives crucial properties of this abstraction .",
    "we consider a contribution of independent interest .",
    "the finite part of this abstraction , i.e. , @xmath210 , is akin to the abstract domain proposed by cousot et al @xcite which also has finite abstraction values and its abstraction function preserves the least fixed point as well .",
    "the infinite part @xmath207 is a new abstract domain with its abstraction function preserving not only least fixed points but also the new operator @xmath141 .",
    "we remark here that the abstraction function does not preserve greatest fixed points so that the introduction of the @xmath141 operator on the abstract domain is a necessary device .",
    "this extension makes the bchi type and effect system powerful enough to capture and reason about infinitary properties like liveness and fairness .",
    "we have sketched a combination of our simple type system with a generic type and effect system for class - based object - oriented languages .",
    "other possible extensions are in the direction of effectful functional programming .",
    "the standard notation for type - and - effect systems as described e.g.  in henglein and niss survey @xcite could be used for our effect system mutatis mutandis leading in particular to function types like @xmath338 where @xmath339 are types and @xmath340 is a bchi effect ( element of our abstract lattice ) describing the latent effect of a function . assuming that we only allow first - order recursive definitions the design of such a type system would be completely standard . for higher - order recursion",
    "some extra technical work would be needed to lift the last rule from fig .",
    "[ fig - e ] and its corresponding abstraction to this case .",
    "it is this option of integration with expressive type systems that makes our abstraction so attractive and superior ( in this context ! ) to classical methods based on model checking .",
    "10    martn abadi , anindya banerjee , nevin heintze , and jon  g. riecke . a core calculus of dependency .",
    ", pages 147160 .",
    "acm , 1999 .",
    "parosh  aziz abdulla , et al . advanced ramsey - based bchi automata inclusion testing .",
    ", lncs 6901 , pp 187202 .",
    "springer , 2011 .",
    "klaus aehlig , jolie  g. de  miranda , and c .- h .",
    "the monadic second order theory of trees given by arbitrary level - two recursion schemes is decidable .",
    ", lncs 3461 pp 3954 .",
    "springer , 2005 .",
    "bowen alpen and fred  b. schneider . recognizing safety and liveness . , 2(3):117126 , 1987 .",
    "lennart beringer , robert grabowski , and martin hofmann . verifying pointer and string analyses with region type systems .",
    "comlan , 2013 .    ahmed bouajjani , et al .",
    "reachability analysis of pushdown automata : application to model - checking .",
    ", lncs 1243 , pp 135150 .",
    "springer , 1997 .    j.  r. bchi . on a decision method in restricted second order arithmetic",
    ". in _ logic , method , and philosophy of science _ , stanford university press , 1962",
    ".    olaf burkart and bernhard steffen .",
    "model checking the full modal mu - calculus for infinite sequential processes .",
    ", 221(1 - 2):251270 , 1999 .",
    "edmund  m. clarke , et al .",
    "counterexample - guided abstraction refinement .",
    ", lncs 1855 , pages 154169 .",
    "springer , 2000 .",
    "patrick cousot and radhia cousot .",
    "abstract interpretation .",
    ", pages 238252 .",
    "acm , 1977 .",
    "patrick cousot and radhia cousot .",
    "abstract interpretation frameworks . , 2(4):511547 , 1992 .",
    "patrick cousot and radhia cousot .",
    "inductive definitions , semantics and abstract interpretation . in ravi sethi , editor , _",
    "popl _ , pages 8394 .",
    "acm press , 1992 .",
    "patrick cousot and radhia cousot .",
    "formal language , grammar and set - constraint - based program analysis by abstract interpretation . in _",
    "fpca _ , pages 170181 , 1995 .",
    "christian dax , martin hofmann , and martin lange . a proof system for the linear time @xmath341-calculus .",
    ", lncs 4337 , pages 273284 .",
    "springer , 2006 .",
    "e.  allen emerson and edmund  m. clarke . characterizing correctness properties of parallel programs using fixpoints .",
    ", lncs 85 , pp 169181 .",
    "springer , 1980 .",
    "javier esparza , et al efficient algorithms for model checking pushdown systems .",
    ", lncs 1855 , pp 232247 .",
    "springer , 2000 .",
    "seth fogarty and moshe  y. vardi .",
    "bchi complementation and size - change termination . , 8(1 ) , 2012 .",
    "robert grabowski et al .",
    "type - based enforcement of secure programming guidelines - code injection prevention at sap .",
    ", lncs 7140 , pp 182197 .",
    "springer , 2011 .",
    "m. heizmann , n. jones , and a. podelski .",
    "size - change termination and transition invariants .",
    ", lncs 6337 , pp 2250 .",
    "springer , 2010 .",
    "martin hofmann and steffen jost .",
    "type - based amortised heap - space analysis .",
    ", lncs 3924 , pp 2237 .",
    "springer , 2006 .",
    "martin hofmann and dulma rodriguez .",
    "automatic type inference for amortised heap - space analysis .",
    ", lncs 7792 , pp 593613 .",
    "springer , 2013 .",
    "alan jeffrey .",
    "ltl types frp : linear - time temporal logic propositions as types , proofs as functional reactive programs . , pages 4960 .",
    "acm , 2012 .",
    "teodor knapik , damian niwinski , and pawel urzyczyn .",
    "higher - order pushdown trees are easy .",
    ", lncs 2303 pp 205222 .",
    "springer , 2002 .",
    "naoki kobayashi and c .- h .",
    "luke ong . a type system equivalent to the modal mu - calculus model checking of hors . in _",
    "lics _ , pages 179188 .",
    "ieee , 2009 .",
    "john  m. lucassen and david  k. gifford .",
    "polymorphic effect systems . in jeanne ferrante and p.  mager , editors ,",
    "_ popl _ , pages 4757 .",
    "acm press , 1988 .",
    "kenneth  l. mcmillan . .",
    "kluwer , 1993 .",
    "christian mossin .",
    "higher - order value flow graphs .",
    ", lncs 1292 , pp 159173 .",
    "springer , 1997 .",
    "flemming nielson , hanne  riis nielson , and chris hankin . .",
    "springer , 2005 .",
    "benjamin  c. pierce . .",
    "the mit press , 2004 .",
    "stefan schwoon . .",
    "phd thesis , technische universitt mnchen , 2002 .",
    "a.  prasad sistla , et al .",
    "the complementation problem for bchi automata with appplications to temporal logic .",
    ", 49:217237 , 1987 .",
    "peter thiemann . formalizing resource allocation in a compiler .",
    ", lncs 1473 , pp .",
    "springer , 1998 .",
    "w.  thomas .",
    "languages , automata and logic . in a.",
    "salomaa and g.  rozenberg , editors , _ handbook of formal languages _ , vol 3 .",
    "springer , 1997 .",
    "igor walukiewicz .",
    "pushdown processes : games and model checking .",
    ", lncs 1102 , pp 6274 .",
    "springer , 1996 .",
    "consider the following definition : @xmath342 suppose that we want to verify the property :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ every finite trace generated by @xmath32 ends with @xmath29 .",
    "every infinite trace generated by @xmath32 contains infinite many @xmath29s .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we can use the following extended bchi automaton @xmath149 to formalize this property . @xmath343 & * + + [ o][f]{0 } \\ar@(ur , ul)_{a}\\ar@/^/[r]^b   &   * + + [ o][f=]{1 } \\ar@(ur , ul)_{b}\\ar@/^/[l]^a}\\end{aligned}\\ ] ] we have : @xmath344 by the definition of @xmath170 , we have that @xmath168 consists of four equivalence classes : the set of empty word ( @xmath166 = \\{\\epsilon\\}$ ] ) , the set of non - empty words consists of @xmath13 ( @xmath345 = a^+$ ] ) , the set of words ending with @xmath13 and containing at least one @xmath29 ( @xmath346 = ( a+b)^*a - a^+ = ( a+b)^*b(a+b)^*a$ ] ) , the set of words ending with @xmath29 ( @xmath347 = ( a+b)^*b$ ] ) .",
    "further , the set @xmath348 is as follows : @xmath349 , [ \\epsilon ] ) , ( [ a ] , [ \\epsilon ] ) , ( [ a ] , [ a ] ) , ( [ b ] , [ \\epsilon ] ) , \\\\ & & \\ \\   ( [ b ] , [ b ] ) , ( [ ba ] , [ \\epsilon ] ) , ( [ ba ] , [ a ] ) , ( [ ba ] , [ ba ] ) \\}\\end{aligned}\\ ] ] and abstractions of @xmath148 are : @xmath350\\}\\in",
    "\\mathcal{m}_*\\\\ & & \\mathcal{v}_l = \\ { ( [ b],[\\epsilon ] ) , ( [ b],[b ] ) , ( [ ba],[ba ] ) \\}\\in \\mathcal{m}_{\\leq\\omega}\\ .\\end{aligned}\\ ] ] by using the bchi type and effect system defined in figure [ fig - f ] , we have that @xmath351\\})^\\omega)$ ] is a bchi effect of @xmath32 .",
    "further , @xmath352\\}))^\\omega ) & = & \\{([b ] , [ b ] ) , ( [ ba ] , [ ba])\\}\\ .\\end{aligned}\\ ] ] so , @xmath353 . that is ,",
    "all traces generated by @xmath32 satisfy the target property .",
    "this coincides with our observation that @xmath32 does not generate any finite traces and the only infinite trace generated by @xmath32 is @xmath354 which contains infinite many @xmath29s .",
    "consider the following c - like program :    .... 0    # define timeout 65536   1    while ( true ) {   2      i = 0 ; 3      while ( i++ < timeout & & s ! = 0 ) { 4        unsigned int s = auth ( ) ; / * o(a ) ; * / 5      }   / * o(c ) ; * / 6      work ( ) ; / * o(b ) ; * / 7    } ....    we would like to verify that line 6 is executed infinitely often under the fairness assumption that the while loop 3 always terminates .",
    "to this end , we can annotate the above program by uncommenting the event - issuing commands and abstract the so annotated program as the definition : @xmath355 we are then interested in the property `` infinitely many @xmath29 '' assuming that `` infinitely often @xmath356 '' ( fairness ) or equivalently : `` infinitely many @xmath29 or finitely many @xmath356 . ''",
    "this property can be readily expressed as the following bchi automaton    @xmath357\\\\\\mathfrak{a } : & * + + [ o][f=]{2}\\ar@(ur , ul)_{a , b}&*++[o][f]{0}\\ar[l]_{a , b , c}\\ar@(dr , dl)^{a , b , c}\\ar@/^/[r]^b & * + + [ o][f=]{1 } \\ar@/^/[l]^{a , b , c}&}\\ ] ] by the definition of @xmath170 , we have that the set @xmath168 consists of the following equivalence classes : @xmath358 = \\{\\epsilon\\}\\qquad [ a ] = \\{a\\}\\qquad [ b ] = \\{b\\}\\qquad [ c ] = \\{c\\ } \\\\ & & [ aa ] = a^+a \\qquad\\qquad \\qquad \\quad [ ba ] = ( a+b)^+a - [ aa]\\\\ & & [ ab ] = a^+b \\qquad\\qquad \\qquad \\quad\\,[bb ] = ( a+b)^+b - [ ab]\\\\ & & [ cb ] = ( a+c)^*c(a+c)^*b\\\\ & & [ bcb ] = ( a+b+c)^*c(a+b+c)^*b - [ cb]\\\\ & & [ cca ] = ( a+c)^+c\\ \\cup\\ ( a+c)^ * c ( a+c)^*a\\\\ & & [ bca ] = ( a+b+c)^+c\\ \\cup\\ \\\\   & & \\qquad\\quad\\ \\ ( a+b+c)^",
    "* c ( a+b+c)^*a - [ cca]\\ .\\end{aligned}\\ ] ] further , the set @xmath359 consists of the following pairs : @xmath360,[\\epsilon])\\ \\   \\quad\\quad([a],[\\epsilon])\\ \\   o\\quad\\quad([b],[\\epsilon])\\ \\",
    "\\quad\\ \\ \\ \\ , ( [ c],[\\epsilon ] ) \\\\ & & ( [ aa],[\\epsilon])\\ \\   \\quad \\ \\ , ( [ ba],[\\epsilon])\\ \\   \\quad \\ \\ , ( [ ab],[\\epsilon])\\",
    "\\   \\quad \\ \\ ( [ bb],[\\epsilon ] ) \\\\ & & ( [ cb],[\\epsilon])\\quad\\ \\ \\,\\ \\   ( [ bcb],[\\epsilon])\\quad\\ \\   ( [ cca],[\\epsilon])\\quad\\ , \\ \\   ( [ bca],[\\epsilon ] ) \\\\ & & ( [ aa],[aa])\\ \\ \\ \\ \\   ( [ ba],[aa])\\ \\ \\,\\ \\   ( [ ba],[ba])\\ \\ \\ \\ \\,\\ \\   ( [ bb],[bb ] )   \\\\ & & ( [ bcb],[bb])\\ \\ \\ \\ \\   ( [ bcb],[bcb])\\,\\ \\   ( [ cca],[aa])\\ \\ , \\ \\",
    "( [ cca],[cca])\\ ,   \\\\ & & ( [ bca],[aa])\\ \\ \\ \\   ( [ bca],[ba])\\ \\ \\   ( [ bca],[cca])\\   \\ \\   ( [ bca],[bca])\\end{aligned}\\ ] ] then , the abstractions of @xmath148 are as follows : @xmath361\\}\\in \\mathcal{m}_*\\\\ & & \\mathcal{v}_l = \\mathcal{c}- \\ { ( [ \\epsilon],[\\epsilon ] ) , ( [ cca],[cca ] ) , ( [ bca],[cca ] ) \\}\\in \\mathcal{m}_{\\leq\\omega}\\ .\\end{aligned}\\ ] ] by using the bchi type and effect system , we get the effect of @xmath35 as the pair : @xmath362 , [ cca]\\ } , \\ { ( [ aa ] , [ aa])\\ } ) \\ .\\ ] ] then , the effect of @xmath32 is the pair @xmath363 given as follows : @xmath364,[aa ] ) , ( [ bca],[aa ] ) , ( [ bcb],[bcb ] ) , ( [ bca],[bca ] ) \\})\\ .\\ ] ] since @xmath365 and @xmath366 , we have that the program satisfies the property .",
    "( of theorem [ thm - a ] ) we proceed by induction on the structure of the type and effect system .",
    "the only interesting case is that for the last rule in figure [ fig - e ] .",
    "let us show that if @xmath367 then @xmath17 is in @xmath368 .",
    "we introduce the assignment functions : @xmath369 & \\mbox{\\quad if\\ \\ $ n = 0$}\\ ; \\\\ \\eta[x\\mapsto a \\cdot x_{\\eta_{n-1 } } \\cup\\ v(\\eta ) ] & \\mbox{\\quad if\\ \\ $ n\\geq 1$}\\ .",
    "\\end{array } \\right.\\end{aligned}\\ ] ] from lemma [ lem - b ] , @xmath370 .",
    "assume that @xmath371 . by inductive hypothesis",
    ", we have that for all @xmath372 , @xmath17 is in @xmath373 further , by lemma [ lem - b ] , @xmath374 . by mathematical induction",
    ", we have that @xmath371 for all natural numbers @xmath243 .",
    "define @xmath375 as @xmath376\\ .\\end{aligned}\\ ] ] we get @xmath377 .",
    "notice that @xmath378 is equal to @xmath379 . by the definition of @xmath380 , @xmath17 is in @xmath381 .",
    "( of lemma [ lem - d ] ) a ) and b ) are obvious from the definition .",
    "property c ) coincides with b ) when @xmath382 .",
    "otherwise , let @xmath383 .",
    "decompose @xmath384 and @xmath385 so that @xmath386 and @xmath387 for @xmath388 .",
    "we have @xmath389 for all @xmath390 so any accepting run for @xmath17 yields an accepting run for @xmath391 by the definition of @xmath170 .",
    "property d ) is again trivial when @xmath18 ( choose @xmath392 $ ] and @xmath382 ) and otherwise appears already in bchi s work . for the record , write @xmath393 with @xmath394 and `` colour '' the set @xmath395 with @xmath396 with the @xmath170-class of @xmath397 . by ramsey s theorem",
    "there exists an infinite set of indices @xmath398 and a class @xmath179 so that @xmath399=d$ ] for all @xmath400 .",
    "the claim follows with @xmath401 $ ] .",
    "( proof of lemma [ lem - in ] ) this is trivial for @xmath210 which is a powerset lattice . as for @xmath207",
    ", one must show that unions and intersections of closed sets are again closed .",
    "so , let @xmath402 be a family of closed sets . to argue that the union of this family is closed , suppose that @xmath403 for some @xmath190 contained in that union . then , @xmath404 for some @xmath390 , so @xmath405 .",
    "since @xmath406 is closed , @xmath0 is contained in the union . as for the intersection ,",
    "suppose that @xmath407 for some @xmath190 contained in the intersection .",
    "then , @xmath404 for all @xmath390 , so @xmath405 for all @xmath390 .",
    "since each @xmath406 is closed , @xmath0 is contained in the intersection , too .",
    "( proof of lemma [ lem - con ] ) we need to show that @xmath408 is closed so suppose that @xmath409 where @xmath410 and @xmath200 .",
    "we may assume that @xmath272 $ ] for otherwise the claim is trivial .",
    "decomposing the witnessing word , we get finite words @xmath411 where @xmath412 and @xmath413 .",
    "note that @xmath274 .",
    "thus , @xmath414 with @xmath88 the class of @xmath415 . as a result , @xmath416 ,",
    "so @xmath417 by closedness and finally , @xmath418 since @xmath419 .",
    "in order to make the bchi type and effect system given in section [ bet ] more functional and effective in programming practices , by integrating with region types @xcite , we extend it to a region - based bchi type and effect system for featherweight java with field update . based on this , the future goal is to develop and implement a powerful type system for java - like languages in which ( @xmath5)-regular properties of traces can be properly characterized for verification purposes .",
    "the syntax of an expression @xmath14 in featherweight java with field update is given as follows : @xmath420 -0.5 cm @xmath421 for the sake of simplicity , we omit primitive types and casting and assume that every expression is in let normal form . in the definition of the * if*-*then*-*else * expression , the expression @xmath422 denotes an unusual judgement between objects which is independent on booleans .",
    "the notation @xmath423 denotes a sequence of variables .",
    "additionally , the expression @xmath424 is used to produce appealing events .",
    "it is a global primitive procedure which is not part of featherweight java with filed update .",
    "it is added as annotations to programs for the purposes of property characterization .",
    "let @xmath425 be the subclass relation between classes .",
    "let @xmath426 and @xmath427 be mappings from a class to its fields and methods respectively .",
    "we use @xmath428 to denote the method table which assigns to each method its definition , i.e. , its formal parameters ( a sequence of variables ) and its body ( an expression ) . with these definitions , a program @xmath256 is given as follows : @xmath429 usual well - formedness conditions on methods",
    "are assumed to ensure the inheritance relation between same methods from different classes .",
    "we use @xmath430 to denote that the evaluation of @xmath14 terminates and the value is @xmath431 .",
    "the notation @xmath432 means that the evaluation of @xmath14 does nt terminate .",
    "a value @xmath433 of an expression is a location @xmath434 or @xmath435 .",
    "a state @xmath436 is consisted of a stack @xmath437 which is a partial function assigning to each variable a value and a heap @xmath438 which is a partial function assigning to each location a pair of a class and values assigned to fields of this class .",
    "in addition , as side effects , an infinite or a finite trace @xmath17 which is generated from the set @xmath10 of events by ordinary concatenations is attached to each evaluation .",
    "the whole operational semantics is given as follows : @xmath439 { } { ( s , h)\\vdash { \\bf",
    "o}(a ) \\downarrow null , h\\ \\&\\ a}\\]]@xmath440 { } { ( s , h)\\vdash null \\downarrow null , h\\ \\&\\ \\epsilon } \\qquad\\qquad\\qquad   \\inferrule*[left={var } ] { } { ( s , h)\\vdash x \\downarrow s(x ) , h\\ \\&\\ \\epsilon}\\]]@xmath441 { l \\not\\in dom(h)\\qquad f = [ f\\mapsto null]_{f\\in fields(c ) } } { ( s , h)\\vdash { \\bf new}\\ c \\downarrow l , h[l\\mapsto ( c , f)]\\ \\&\\ \\epsilon}\\]]@xmath442 { s(x ) = l\\qquad h(l ) = ( c , f ) } { ( s , h)\\vdash x.f \\downarrow f(f ) , h\\ \\&\\ \\epsilon}\\]]@xmath443 { s(x ) = l\\qquad h(l ) = ( c , f)\\\\\\\\   h ' = h[l\\mapsto ( c , f[f\\mapsto s(y ) ] ) ] } { ( s , h)\\vdash x.f : = y \\downarrow s(y ) , h'\\ \\&\\ \\epsilon}\\]]@xmath444 { s(x ) = l\\qquad h(l ) = ( c , f)\\\\\\\\ mtable(c , m ) = ( \\overline{x } , e ) \\qquad |\\overline{x}| = |\\overline{y}| = n\\\\\\\\ s ' = [ this\\mapsto l]\\cup[x_i\\mapsto s(y_i)]_{i\\in\\{1,2,\\dots , n\\}}\\\\\\\\ ( s',h)\\vdash e \\downarrow v , h'\\ \\&\\ w } { ( s , h)\\vdash x.m(\\overline{y } ) \\downarrow v , h'\\ \\&\\",
    "w}\\]]@xmath445 { ( s , h)\\vdash e_1 \\downarrow v_1 , h_1\\ \\&\\",
    "w_1\\\\\\\\ ( s[x\\mapsto v_1],h_1)\\vdash e_2 \\downarrow v_2 , h_2\\ \\&\\",
    "w_2 } { ( s , h)\\vdash { \\bf let}\\ x = e_1\\ { \\bf in}\\ e_2 \\downarrow v_2 , h_2\\ \\&\\ w_1\\cdot w_2}\\]]@xmath446 { s(x ) = s(y)\\qquad ( s , h)\\vdash e_1 \\downarrow v , h'\\ \\&\\ w } { ( s , h)\\vdash { \\bf if}\\ x = y\\ { \\bf then}\\ e_1\\ { \\bf else}\\ e_2 \\downarrow v , h'\\ \\&\\ w}\\]]@xmath447 { s(x ) \\neq s(y)\\qquad ( s , h)\\vdash e_2 \\downarrow v , h'\\ \\&\\ w } { ( s , h)\\vdash { \\bf if}\\ x = y\\ { \\bf then}\\ e_1\\ { \\bf else}\\ e_2 \\downarrow v , h'\\ \\&\\ w}\\]]@xmath448 { } { ( s , h)\\vdash e \\uparrow \\ \\&\\ \\epsilon } \\qquad\\qquad\\qquad \\inferrule*[left={prim - b } ] { } { ( s , h)\\vdash { \\bf",
    "o}(a ) \\uparrow \\ \\&\\ a}\\]]@xmath449 { s(x ) = l\\qquad h(l ) = ( c , f)\\\\\\\\ mtable(c , m ) = ( \\overline{x } , e ) \\qquad |\\overline{x}| = |\\overline{y}| = n\\\\\\\\ s ' = [ this\\mapsto l]\\cup[x_i\\mapsto s(y_i)]_{i\\in\\{1,2,\\dots , n\\}}\\\\\\\\ ( s',h)\\vdash e \\uparrow \\ \\&\\ w } { ( s , h)\\vdash x.m(\\overline{y } ) \\uparrow\\ \\&\\ w}\\]]@xmath450 { ( s , h)\\vdash e_1 \\downarrow v_1 , h_1\\ \\&\\ w_1\\\\\\\\ ( s[x\\mapsto v_1],h_1)\\vdash e_2 \\uparrow \\ \\&\\ w_2 } { ( s , h)\\vdash { \\bf let}\\ x = e_1\\ { \\bf in}\\ e_2 \\uparrow \\ \\&\\ w_1\\cdot w_2}\\]]@xmath451 { ( s , h)\\vdash e_1 \\uparrow \\ \\&\\ w } { ( s , h)\\vdash { \\bf let}\\ x = e_1\\ { \\bf in}\\ e_2 \\uparrow \\ \\&\\ w}\\]]@xmath452 { s(x ) = s(y)\\qquad ( s , h)\\vdash e_1 \\uparrow \\ \\&\\ w } { ( s , h)\\vdash { \\bf if}\\ x = y\\ { \\bf then}\\ e_1\\ { \\bf else}\\ e_2 \\uparrow \\ \\&\\ w}\\]]@xmath453 { s(x ) \\neq s(y)\\qquad ( s , h)\\vdash e_2 \\uparrow\\ \\&\\ w } { ( s , h)\\vdash { \\bf if}\\ x = y\\ { \\bf then}\\ e_1\\ { \\bf else}\\ e_2 \\uparrow \\ \\&\\ w}\\ ] ]        we now sketch an integration of the bchi type and effect system with the region type system for java given by beringer et al @xcite .",
    "let us first explain why this integration is interesting and useful by an example .",
    "considering the following fragment of java - like code :          then , an object ` o ` typed ` c@r ` expects a ` string@x ` as argument to ` f ` and ` o.f ( ) ` will exhibit a ` ( u , v ) ` effect .",
    "an object ` o1 ` typed ` c@r ` expects a ` string@x ` as argument to ` f ` and ` o1.f ( ) ` will exhibit a ` ( u,v ) ` effect . in this particular case , regions denote locations at which effects are produced .    generally , a region @xmath454 is a static abstraction of concrete locations which can be considered as a set of concrete locations .",
    "a class type @xmath176 can then be equipped with a set @xmath455 of regions , yielding a refined type @xmath456 that places the constraint that its members belong to one of the regions in @xmath455 .",
    "we summarize these definitions and introduce new varaiabls as follows : @xmath457 here , the @xmath458 type is introduced for typing the expression @xmath459 .",
    "it is easy to define the subtype relation between region - based types : @xmath460 if and only if @xmath461 . and to extend this definition to sequences of types as follows : @xmath462    with respect to the subtype relation , the following field typings : @xmath463 assign to each field in each region - annotated class respectively a set - type which is a contravariant type for data written to the field and a get - type which is a covariant type for data read from the field .",
    "the following well - formedness conditions on @xmath464 and @xmath465 are imposed : @xmath466 and if @xmath467 , then @xmath468    given a bchi automaton @xmath149 , let @xmath210 and @xmath207 be the bchi abstractions for @xmath48 and @xmath69 respectively , as defined in section [ ba ] .",
    "we define effects as : @xmath469 . then , the following typing rule : @xmath470 assigns to each method in each region - annotated class a functional type with an effect .",
    "the subtype relation @xmath471 between effect annotated functional types is defined as : @xmath472 that is , the input type is contravariant and the output type is covariant .",
    "the well - formedness condition on @xmath473 is : @xmath474 for all classes , regions , and methods .    with the above definitions , combinined with the type and effect system given in section [ ba ] , we arrive at the region - based bchi type and effect system as follows : @xmath475 { \\gamma \\vdash_\\mathfrak{a } e : \\tau \\ \\&\\ ( \\mathcal{u } , \\mathcal{v}(\\mathfrak{x } ) ) \\\\\\\\",
    ": \\tau'\\qquad\\qquad \\mathcal{u}\\subseteq \\mathcal{u'}\\qquad\\qquad \\mathcal{v}(\\mathfrak{x } ) \\sqsubseteq \\mathcal{v'}(\\mathfrak{x } ) } { \\gamma \\vdash_\\mathfrak{a } e:\\tau ' \\ \\&\\ ( \\mathcal{u ' } , \\mathcal{v'}(\\mathfrak{x}))}\\]]@xmath476 { } { \\gamma \\vdash_\\mathfrak{a } { \\bf o}(a ) : unit \\ \\&\\ ( \\alpha_*(\\{a\\ } ) , \\emptyset)}\\]]@xmath477 { } { \\gamma \\vdash_\\mathfrak{a } null : c_\\emptyset \\ \\&\\ ( \\alpha_*(\\{\\epsilon\\ } ) , \\emptyset)}\\]]@xmath478 { } { \\gamma , x:\\tau \\vdash_\\mathfrak{a } x:\\tau \\ \\&\\ ( \\alpha_*(\\{\\epsilon\\ } ) , \\emptyset)}\\]]@xmath479 { } { \\gamma \\vdash_\\mathfrak{a } { \\bf new}\\ c : c_{\\{r\\ } } \\ \\&\\ ( \\alpha_*(\\{\\epsilon\\ } ) ,",
    "\\emptyset)}\\]]@xmath480 { \\forall r\\in r\\,.\\,a^{get}(c , r , f ) < : \\tau } { \\gamma , x : c_r \\vdash_\\mathfrak{a } x.f : \\tau \\ \\&\\ ( \\alpha_*(\\{\\epsilon\\ } ) , \\emptyset)}\\]]@xmath481 { \\forall r\\in r\\,.\\,\\tau <",
    ": a^{set}(c , r , f ) } { \\gamma , x : c_r , y : \\tau \\vdash_\\mathfrak{a } x.f : = y : \\tau \\ \\&\\ ( \\alpha_*(\\{\\epsilon\\ } ) , \\emptyset)}\\]]@xmath482 { \\overline{\\sigma}_r\\stackrel{(\\mathcal{u}_r , \\mathcal{v}_r)}{\\longrightarrow } \\tau_r = m(c , r , m ) \\\\\\\\",
    "\\forall r\\in r\\,.\\ , \\overline{\\sigma}_r\\stackrel{(\\mathcal{u}_r , \\mathcal{v}_r)}{\\longrightarrow } \\tau_r\\ \\ < : \\ \\ \\overline{\\sigma}\\stackrel{(\\mathcal{u } , \\mathcal{v})}{\\longrightarrow } \\tau } { \\gamma ,",
    "x : c_r , \\overline{y}:\\overline{\\sigma } \\vdash_\\mathfrak{a } x.m(\\overline{y } ) : \\tau \\ \\&\\ ( \\mathcal{u } , \\cup_{r\\in r}\\{x_r\\})}\\]]@xmath483 % { mtable(c , m)=(\\overline{x},e)\\\\\\\\ \\gamma , x : c_r , this : c_r , \\overline{x}:\\overline{\\sigma } , [ c_r.m : ( \\overline{\\sigma}_r,\\tau_r)]_{r\\in r},\\delta , [ c_r.m\\ \\&\\ ( u_r , x_r)]_{r\\in r } \\vdash e : \\tau\\ \\&\\ ( u , \\cup_{r\\in r}(a_r\\cdot x_r ) \\cup v(\\mathfrak{x}-\\cup_{r\\in r}x_r ) ) % } % { \\gamma , x : c_r , \\overline{y}:\\overline{\\sigma } , \\delta \\vdash x.m(\\overline{y } ) : \\tau \\ \\&\\ ( u , ( \\cup_{r\\in r}a_r)^*\\cdot v(\\mathfrak{x}-\\cup_{r\\in r}x_r)\\cup ( \\cup_{r\\in r}a)^\\omega ) } % \\]]@xmath484@xmath485 { \\gamma \\vdash_\\mathfrak{a } e_1 : \\tau_1\\ \\&\\ ( \\mathcal{u}_1 , \\mathcal{v}_1(\\mathfrak{x}))\\\\\\\\ \\gamma , x:\\tau_1 \\vdash_\\mathfrak{a } e_2 : \\tau_2\\ \\&\\ ( \\mathcal{u}_2 , \\mathcal{v}_2(\\mathfrak{x } ) ) } { \\gamma \\vdash_\\mathfrak{a } { \\bf let}\\ x = e_1\\ { \\bf in}\\ e_2 : \\tau_2 \\ \\&\\ ( \\mathcal{u}_1\\cdot \\mathcal{u}_2 , \\mathcal{v}_1(\\mathfrak{x})\\cup \\mathcal{u}_1\\cdot \\mathcal{v}_2(\\mathfrak{x}))}\\]]@xmath486 { \\gamma , x : c_{r\\cap s } , y : d_{r\\cap s } \\vdash_\\mathfrak{a } e_1 : \\tau\\ \\&\\",
    "( \\mathcal{u}_1 , \\mathcal{v}_1(\\mathfrak{x}))\\\\\\\\ \\gamma , x : c_r , y : d_s \\vdash_\\mathfrak{a } e_2 : \\tau\\ \\&\\ ( \\mathcal{u}_2 , \\mathcal{v}_2(\\mathfrak{x } ) ) } { \\gamma , x : c_r , y : d_s \\vdash_\\mathfrak{a } \\\\ { \\bf if}\\ x = y\\ { \\bf then}\\ e_1\\ { \\bf else}\\   e_2 : \\tau \\ \\&\\",
    "( \\mathcal{u}_1\\cup \\mathcal{u}_2 , \\mathcal{v}_1(\\mathfrak{x})\\cup \\mathcal{v}_2(\\mathfrak{x}))}\\ ] ] the typing judgement for expressions @xmath14 is    with @xmath487 the type environment , @xmath149 the policy bchi automaton , @xmath488 the type of @xmath14 , @xmath306 the set of finite traces , and @xmath310 the expression for infinite traces . among the typing rules , is the following rule :    where @xmath489 notice that in section [ ba ] , there are two typing rules for function calls .",
    "that is , one rule is used to directly get the effect if the effect has been assumed in the environment and another rule is used to derive the effect with an effect assumption added into the environment . however , in order to integrate with region - based type systems , in our region - based bchi type and effect system , we only use the following rule :      further , a program @xmath256 is well - typed if and only if for all classes @xmath176 , regions @xmath491 , and methods @xmath492 such that @xmath493 the following typing : @xmath494 is derivable and there is an assignment @xmath495 satisfying : @xmath496 that is , a program is well - typed if and only if the constraints produced by the region - based bchi type and effect system are satisfiable with respect to region - based type and effect declarations for all classes , all regions and all methods defined in this program ."
  ],
  "abstract_text": [
    "<S> we develop a new type and effect system based on bchi automata to capture finite and infinite traces produced by programs in a small language which allows non - deterministic choices and infinite recursions . </S>",
    "<S> there are two key technical contributions : ( a ) an abstraction based on equivalence relations defined by the policy bchi automata , the bchi abstraction ; ( b ) a novel type and effect system to correctly capture infinite traces . </S>",
    "<S> we show how the bchi abstraction fits into the abstract interpretation framework and show soundness and completeness . </S>"
  ]
}