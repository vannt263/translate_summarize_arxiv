{
  "article_text": [
    "the complexity of distributed real - time systems is growing rapidly ; model - based development tools are used to accelerate the development process and increase the quality of the produced code .",
    "in addition , it is possible to integrate formal verification as analysis technique into these tools .",
    "currently , the standard verification process is achieved by first translating system models into verification models , followed by verifying relevant properties by verification engines using special algorithms . in the verification community , researchers focus on tighter theoretical complexity bounds or computationally faster algorithms to reduce the required time for verification .",
    "nevertheless , if it comes to verification of complex systems , an efficient model reflecting the properties of the system under consideration becomes essential . by _",
    "efficient model _ , we refer to a model containing `` just - enough '' information of the system behavior regarding these properties .",
    "in fact , an inefficient modeling with irrelevant details can simply render the verification intractable .    within this paper ,",
    "we introduce an approach for the construction of such an efficient model for the verification of timing assumptions and constraints .",
    "the approach is presented in , but not restricted to , the context of ftos  @xcite , a model - based development tool for the design of fault - tolerant systems .    in our presentation , we first introduce ftos , mention insights regarding differences in comparison to other development tools , and propose our two - phase verification methodology ( sec .  [ sec.motivating.examples ] ) . then based on ftos and timed automata  @xcite",
    ", we describe the model construction process , focusing on the aspects concerning expressiveness , modification , and efficiency .    * * ( expressiveness ) * we give observations regarding restrictions of timed automata to construct models of real - time systems ( sec .",
    "[ sec.network.finite.capacities ] ,  [ sec.task.element.finite.precision ] ,  [ sec.dispatcher ] ) ; these observations are valid not only in the context of ftos , but apply also for other systems . * * ( modification ) * we formulate mathematical representations how to perform model modification to derive verification models from system models ( sec .",
    "[ sec.job.processing.element ] ) . * * ( efficiency ) * with the understanding of ( 1 ) complexities of verification and ( 2 ) our problem structure , we propose some theoretical criteria regarding how to construct an efficient model , such that it is possible for existing model checkers to generate results within reasonable time ( sec .",
    "[ sec.invocation.faults.events ] ) .",
    "at last , we report our preliminary implementation ( sec .",
    "[ sec.implementation ] ) , mention related work ( sec .",
    "[ sec.related.work ] ) , and conclude this paper ( sec .  [ sec.conclusion ] ) .",
    "ftos is a model - based development tool for the development of fault - tolerant real - time systems , that alleviates designers burden by offering code generation for non - functional aspects with high extensibility .",
    "the conceptual modeling in ftos uses multi - aspect techniques comprising four different perspectives :    * hardware model * : the hardware model specifies the hardware used , including specifications of _ electronic control units _ ( ecus ) and the interconnecting _ network_.    * software model * : the underlying model of computation in ftos shares large similarities with that of giotto @xcite , which is based on the concept of logical execution times .",
    "a designer should specify _ tasks _ , _ ports _ , _ inputs _ , _ outputs _ , and _",
    "jobs_.    * fault model * : the fault model specifies the _ fault hypothesis _ of the system , which includes the set of _ fault containment units _ ( fcus ) ( possible faults concerning locations , types , durations ) , and the set of _ fault configurations _ ( possible simultaneously activating fcus ) .",
    "examples for the fault hypothesis are :    1 .",
    "a network link can have message lost ( fault type : ` msgloss ` ) with minimum interval between consecutive occurrences equal to @xmath0 milliseconds",
    "a software task can produce errors ( fault type : ` wrongresult ` ) due to a fault within an associated sensor ; once happened , it will not be corrected unless explicitly done by the user or the fault - tolerant mechanism .",
    "the minimum interval for the correct operation between two consecutive faults of the sensor is expected to be @xmath1 milliseconds .",
    "* fault - tolerance model * : the fault - tolerance model specifies methods to detect errors and to repair and restore the system .    during code generation , ftos selects , adapts and combines pre - implemented code templates based on model features .",
    "a detailed description of ftos can be found in @xcite .",
    "the concepts presented in this paper do not only apply for ftos , but also a range of other related projects , such as giotto @xcite or event - driven tasks with fixed deadlines .",
    "figure [ fig : mapping ] shows the different models of execution .",
    "an aperiodic or sporadic function is event driven ; when such an event happens , a deadline is assigned to the task handling the event .",
    "giotto functions are functions that interact synchronously at macro step level ( logical level ) , while at micro step level the execution is asynchronous",
    ". for detailed description of giotto and the concept of logical execution time , see @xcite .",
    "ftos functions are extensions of giotto functions . intuitively they are equipped with fault - tolerance abilities such that the system can resist faults defined by the fault model . in fig .",
    "[ fig : mapping ] , three redundant copies ( @xmath2 , @xmath3 , @xmath4 ) are deployed on the three machines ( @xmath5 , @xmath6 , @xmath7 ) .",
    "the figure also shows the necessity of a mapping the behavioral model ( in ftos : software model ) to the architecture model ( in ftos : hardware model ) .",
    "note that in general a design space exploration is needed for finding such a mapping . for details",
    ", we refer readers to articles regarding platform - based design @xcite .",
    "since this mapping is specified in ftos by the developer , our analysis can start from a given selection of hardware and software settings .",
    "the main property of fault - tolerant systems that needs to be verified is the ability to withstand the assumed faults .",
    "the fault assumptions are summarized in the fault hypothesis ( in ftos : fault model ) that defines faults regarding its location , effect , and frequency .",
    "the verification of such systems is hindered by two aspects : deadline violations and non - determinism due to e.g. imperfect synchronization of redundant units .    1 .   in ordinary systems ,",
    "correctness relies on the assumption that a scheduling never leads to deadline violations ( without loss of generality , we assume that deadlines specified in our model are hard ) . nevertheless , in fault - tolerant systems , the constraint can be loosened . due to replication , a deadline violation of one unit might be tolerated .",
    "in fact , the violation of the deadline can be categorized as an occurrence of a fault defined in the fault model .",
    "this brings dramatic differences between fault - tolerant systems and ordinary systems , i.e. , deadline violation is feasible or acceptable provided that there exists a fault - tolerance mechanism such that the effect of fault can be eliminated .",
    "2 .   on the other hand",
    ", replication also introduces further difficulties . in ordinary giotto systems ,",
    "internal determinism is guaranteed , meaning that two deployments having the same relative ordering in the micro step level will have the same behavior , irrelevent of the absolute timing .",
    "unfortunately , internal determinism will not be maintained if no constraints are added additionally on ftos functions .",
    "consider fig .",
    "[ fig : nondeterminism ] , where @xmath8 , @xmath9 and @xmath10 are three deployments .",
    "the send action will broadcast messages to other machines regarding its liveness . ideally , when no error happens , then each machine should conceive a consistent view of the system .",
    "however , when the scheduling of @xmath10 changes to that of @xmath11 , with zero time transmission , the result will be an inconsistent view at @xmath8 and @xmath9 .",
    "this brings semantic incompatibility between different deployments .    to solve these problems",
    ", we thus propose the concept called _ deterministic assumption _",
    "intuitively , the goal is to assume that the implementation of fault tolerance mechanisms will always provide a consistent view for all correct machines regardless of deadline violation and scheduling issues . in practice",
    ", this will place constraints regarding the earliest and latest arrival time between messages sent , which need to be verified .        for above purpose",
    ", we adapt a two - phase verification process in our tool ftos - verify :    * ( phase 1 : verification on the platform independent layer )",
    "* we first assume that the deterministic assumption holds in all deployments .",
    "based on this assumption , we construct a verification model . the model is an abstract machine ( closed model ) where injection of faults is regulated based on the fault model .",
    "the model offers precision by revealing detailed mechanisms of fault - tolerance .",
    "our theoretical foundation enables us to construct a concise model with huge benefits . for this phase",
    ", the mathematical formulation and the proof of theorems are stated in @xcite ; it will not be the focus of this paper .    *",
    "( phase 2 : validity checking of the behavior - architectural mappings ) * in this phase , we have to focus on two aspects .",
    "first , we have to check whether the deterministic assumption holds in the platform .",
    "second , we have to check if there exists possibilities where deadlines are violated , and the violation exceeds the constraint specified and regulated in the fault model . note that since the correctness of the data and mechanisms are checked in the first phase , in the latter phase only protocol checking ( timing ) is needed .",
    "this will be the focus and the main contribution of the paper .",
    "for the analysis of the temporal behavior , we transform the models in ftos to communicating timed automata ( cta ) . in the following sections",
    ", we will describe our observations , relevant parts of the construction process , and theoretical criteria for model efficiency . by using a generalized view ,",
    "the results are applicable not only in the context of ftos , but can be used for verifying temporal behavior for generic distributed real - time systems .",
    "we use an extended format of communicating timed automata ( cta )  @xcite using variables of finite domain to express the features of the behavioral model .",
    "it is important to mention that this extended format does not change the expressiveness of cta .",
    "a system of communicating timed automata is a tuple @xmath12 , where @xmath13 @xmath14 is an automaton with the following constraints .",
    "@xmath15 is a finite set of _ modes _ ( _ locations _ ) .",
    "@xmath16 is the set of finite - domain integer variables .",
    "@xmath17 is the set of _ clock variables_.    @xmath18 is the set of _ synchronizers _ ; each synchronizer @xmath19 is of the format @xmath20 where elements in @xmath21 represent synchronizer symbols .",
    "conceptually , @xmath22 represents receiving , and @xmath23 represents sending .",
    "@xmath24 is the _ initial location _ of the automaton .",
    "@xmath25 is the jump from mode to mode .    1 .   @xmath26 is the conjunction of inequalities of the form @xmath27 or @xmath28 , where @xmath29 , @xmath30 , @xmath31 , and @xmath32 .",
    "@xmath33 is the set of assignments of the form @xmath34 or @xmath35 , where @xmath29 , @xmath36 , and @xmath37 .",
    "@xmath38 is the set of mode invariants mapping a mode to a subspace of @xmath39 indicating the possible clock values to maintain in the mode .    in the following ,",
    "we summarize required components of the verification model and outline our observations .          to model the network of the distributed system , an appropriate level of detail must be selected . in general , for a network with message delay and @xmath40 junction points , we have to model such a network with @xmath41 automata to handle point - to - point communication .",
    "[ fig : ta.p2p ] is the template ( defined in uppaal @xcite ) of a timed automaton which models the point - to - point transmission with storage capacity equal to @xmath42 , and one overflow location .",
    "the function @xmath43 is used to return the index of the channel .",
    "for modeling of network components , only finite capacity can be reached .",
    "furthermore , the number of controlled locations grows exponentially as the number of allowed storage increases , because the variable delay ( due to the fault model ) or the routing scheme may lead to an arbitrary ordering of arrived messages .      for giotto - like mocs , tasks are units which perform dedicated computations .",
    "modeling the task execution can vary based depending on whether the applied scheduling is preemptive .",
    "[ fig : ta.task ] shows a timed automaton representing the task execution with potential context switches .",
    "since context switch and preemption can occur , the task should keep the record for the remaining time ( portion ) to finish the task .",
    "the variable ` percentage ` represents the progress of execution and ` increment ` reflects the minimal advance related to the time accuracy used during verification .",
    "the constraints regarding time accuracy imply finite precision in the model .",
    "modeling of tasks can only be achieved with finite precision , since with context switch , we need to record the portion of executed tasks .",
    "this also brings issues between expressiveness and complexity ; a better accuracy regarding the timing behavior of the context switch ( with finer time unit ) leads to increasing complexity of the resulting model since it depends on the biggest integer used in the system .          the task of the job processing element is to manage the execution of tasks and to implement the inter - task communication .",
    "the construction in timed automata may vary due to the concrete application .",
    "however , for ftos , a fixed sequence of atomic actions is defined in the software model .",
    "each atomic action can be represented by a similar model as used for the task model described previously .",
    "the main difference is that the models of the atomic actions are linked together instead of having a closed loop in the automaton representing the job processing element .",
    "here we omit the detailed construction process for the original model , but focus on the transformation into the according verification model .",
    "we give two motivating examples .    * in order to model the effect of faults , we need to add additional edges on the original model to represent the occurrence of faults .",
    "* to observe deadline violation , additional clocks that reflect the time progress since event occurrence , locations that represent the deadlines , and jumps are required to annotate the original model .    for these purposes",
    ", we define this annotation as a sequence of edit - operations over a labeled graph @xcite ; this facilitates the mathematical formulation how we transform between models .",
    "define five atomic edit actions as follows .    1",
    ".   * clock add * : given a clock variable @xmath44 , @xmath45 is an operation that adds a clock to @xmath46 .",
    "formally speaking , given @xmath47 , the result of @xmath48 is a new timed automaton @xmath49 .",
    "2 .   * variable add * : given a variable @xmath50 , @xmath51 is an operation that adds a variable to @xmath46 . formally speaking , given @xmath52 @xmath53 ,",
    "the result of @xmath54 is a new timed automaton @xmath55 .",
    "* location add * given a location @xmath56 and an invariant @xmath57 , where @xmath57 is the conjunction of inequalities of the form @xmath27 with clock @xmath58 , @xmath59 , and @xmath32 , @xmath60 is an operation that adds a location to @xmath46 with invariant condition @xmath57 . formally speaking ,",
    "let @xmath47 , the result of @xmath61 is a new timed automaton @xmath62 .",
    "* jump add * : given two locations @xmath63 with guard @xmath64 , assignment @xmath65 , and set of synchronizers @xmath19 , where 1 .",
    "@xmath64 is the conjunction of inequalities of the form @xmath27 or @xmath28 , where @xmath58 is a clock , @xmath66 is a variable , @xmath31 , and @xmath32 .",
    "@xmath65 is the set of assignments of the form @xmath34 or @xmath35 , where @xmath58 is a clock , @xmath67 is a variable , and @xmath37 .",
    "+ let @xmath47 , then the result of @xmath68 is a new timed automaton @xmath69 by adding an arc @xmath70 to @xmath71 . 5 .",
    "* jump edit * : given two locations @xmath63 with guards @xmath72 , assignments @xmath73 , and sets of synchronizers @xmath74",
    "@xmath75 are conjunctions of inequalities of the form @xmath27 or @xmath28 , where @xmath58 is a clock , @xmath66 is a variable , @xmath31 , and @xmath32 .",
    "2 .   @xmath76 are sets of assignments of the form @xmath34 or @xmath35 , where @xmath58 is a clock , @xmath67 is a variable , and @xmath37 .",
    "+ let @xmath47 , then the result of @xmath77 is a new timed automaton @xmath78 by changing the arc @xmath70 to @xmath79 in @xmath71 .",
    "note that in our formulations , we assume due to simplification reasons that the added element is not identical to any elements in the original set , and every newly added location or jump is well defined ( e.g. , to add @xmath80 a new location with invariants using clock @xmath44 , @xmath44 should have been defined in @xmath80 ) .",
    "let an edit sequence be @xmath81 , where @xmath82",
    "are edit actions .",
    "define the result of @xmath83 on @xmath84 , in symbols @xmath85 inductively as follows .",
    "* @xmath86 where @xmath87 is the null sequence .",
    "* @xmath88 , @xmath89 @xmath90 . *",
    "@xmath91 , @xmath92 . *",
    "@xmath93 , @xmath94 . *",
    "@xmath95 , @xmath96 . * @xmath97 , @xmath98 @xmath99 @xmath100 .",
    "starting from the textual description of the fault model , we can construct the set of _ deadline requirements _",
    "@xmath101 for the system model @xmath102 .",
    "intuitively this means that for all runs entering the location @xmath103 , it must subsequently enter @xmath104 within at most @xmath105 time units . based on above definitions ,",
    "we sketch the algorithm , @xmath103 is not reentered before entering @xmath104 because actions in the job processing element are chained . ] how to generate the verification model from the system model as follows :    ' '' ''    * algorithm * : ` genverificationmodelpart ( ) ` + \\ {   + / * input : original system model @xmath12 * /   + / * output : verification model @xmath106 * /   + * * let * * @xmath107 .   + * * forall * * deadline requirements @xmath108 ,   + / * add new clock and new variable for testing * /   + @xmath109",
    ".   + @xmath110 .",
    "+ / * @xmath111 is the location for deadline violation * /   + @xmath112 .   + * * forall * * incoming jumps @xmath113 of @xmath103 ,   + @xmath114 ,   + where @xmath115 .   + * * endfor * *   + * * forall * * incoming jumps @xmath116 of @xmath104 ,   + @xmath117 ,   + where @xmath118 .   + * * endfor * *   + * * forall * * reachable locations @xmath56 from @xmath103 ,   + @xmath119 .   + where @xmath64 is defined as @xmath120 .   + * * endfor * *   + * * endfor * *   + * * return * * @xmath121 .",
    "/ * apply changes in @xmath83 * / + }    ' '' ''    for the property of deterministic assumption mentioned in section  [ subsec.verification.goals ] , similar algorithms can be applied to annotate clocks , locations , and jumps ; the problem for checking deterministic assumption in ftos turns to be a reachability problem in timed automata .",
    "with respect to the operating system , we have to model the dispatcher explicitly .",
    "the modeled dispatcher merely captures the scheme for the execution of threads ; deadline violation , fault - tolerance or error handling is modeled in the job processing element .",
    "therefore , it can be used in arbitrary settings and not only in ftos . due to different scheduling algorithms",
    ", the model of the dispatcher differs dramatically regarding actual verifiability . for our analysis",
    ", we use priority based dispatchers modeling either fifo or round - robin techniques .",
    "nevertheless , as context switch of tasks / threads occurs , we have the following observation .    using a round - robin dispatcher leads to exponential increase of possible behaviors compared to a fifo - based dispatcher with the number of parallel tasks , if no assumptions on the task behavior can be made .",
    "in summary , this section gave insight in the main components of the verification model and their construction .",
    "besides the job processing element , all components and related observations can be directly applied for arbitrary real - time systems . for the job processing element",
    ", we described a generic way to use annotations to construct a model to use for verifying the absence of deadline violations . in the next section ,",
    "we point out how aperiodic behavior introduced by faults or events can be considered .",
    "to perform verification , modeling the arrival of faults or aperiodic events is necessary to establish a closed model , and in this section we consider its effect . in ftos",
    ", the probability of faults is implicitly reflected by the concept called _ least time between faults _ ( ltbf ) . in our analysis , the invocation of aperiodic tasks can be done similarly - the least time between occurrences of events for aperiodic tasks is defined as _ least time between arrivals _ ( ltba ) . with ltba or ltbf",
    ", we can augment the original model with a timed automaton producing the event ( called _ event agent _ ) similar to fig .",
    "[ fig : ta.event.agent ] .",
    "however , since ltbf ( or ltba ) is an integer which might be relatively large , and the complexity of verification in timed systems is related to this integer to @xmath122 , intuitively the execution time can increase by the factor of @xmath123 , where @xmath124 . ] , the use of ltbf ( or ltba ) may hinder the practicability of model checking .",
    "thus we propose some methods to effectively reduce the value of ltbf ( or ltba ) with equivalence criterion . for simplicity reasons ,",
    "the following theorems are all discussed using event - triggered aperiodic functions with ltba without loss of generality .",
    "[ simple ] let system @xmath125 have one ftos function with periodic deadline @xmath126 and one event - triggered aperiodic function .    w.l.o.g .",
    ", let @xmath127 be the timed automaton of the event agent , where @xmath128 be the least time between two consecutive aperiodic events .",
    "let @xmath129 be the maximal time interval for the system to finish processing the event ( called deadline interval from now on ) be the time for the event arrival . if the system can not finish processing this event within time @xmath130 , then the system violates the deadline . ] . if @xmath131 , then consider another system @xmath132 , where @xmath133 , i.e. , the only difference is to change @xmath134 from @xmath135 to @xmath136 .",
    "then both systems are equivalent regarding their behavior concerning deadline violation .",
    "that is , for @xmath125 and @xmath132 , either they both satisfy the deadline , or they both miss the deadline .    an intuitive argument for the bound @xmath137 can be derived using fig .",
    "[ fig : proof.explanation ] . tasks and events influence the execution of each other .",
    "the execution of an arriving event is influenced by the currently running task . during the deadline interval of the event ,",
    "this and all preceding tasks are influenced as well .",
    "the chain of influence can only be stopped if the execution is decoupled . since",
    "preceding tasks are decoupled by definition , two events with a minimal bound of @xmath137 can not influence the execution of the same task . in fig .",
    "[ fig : proof.explanation ] , we call a time point @xmath138 _ decoupling point _ if two consecutive tasks immediately before and after @xmath138 are not mutually influenced due to the occurrence of an event .",
    "we consider four possible cases in @xmath132 :    1 .",
    "consider the case where in @xmath132 , it is proven that no deadline is violated . when the verification engine proofs that the deadline is never violated with @xmath139 in @xmath132 , the deadline of the ftos function in @xmath125 will never be violated because @xmath140 ; the verification engine has already considered all cases in @xmath125 .",
    "2 .   consider the case where in @xmath132 , the counter - example indicates that the @xmath141-th aperiodic task violates the deadline .",
    "we further split the discussion in subjects whether it is the first time for @xmath132 to process the event .",
    "our goal is to construct a counter - example for deadline violation in @xmath125 from the counter - example in @xmath132 . + . ]",
    "1 .   if @xmath142 , i.e. , it is the first time for @xmath132 to execute the aperiodic task , then this deadline violation can also occur in @xmath125 , since no constraints are made for the first occurrence of events in @xmath125 or @xmath132 .",
    "2 .   if @xmath143 , consider the @xmath144-th aperiodic execution which does not violate the deadline .",
    "let the time for the coming of event @xmath144-th be @xmath145 , and let the interval between the @xmath144-th and the @xmath141-th event be @xmath146 .",
    "the system should finish the @xmath144-th processing before time @xmath147 . since @xmath148 , from time @xmath147 to @xmath149",
    ", ftos function should finish one of its execution and proceed a new one .",
    "let the time for the start of that cycle be @xmath138 .",
    "if we change the counter - example time trace such that no event has happened before @xmath138 , we still get a counter - example trace in @xmath132 .",
    "this new counter - example trace is also a counter - example trace in @xmath125 .",
    "3 .   consider the case where in @xmath132 , the counter - example indicates that the ftos function violates the deadline .",
    "let the time which violates the deadline be @xmath145 ( note that @xmath145 is the multiple of @xmath126 ) .",
    "let the occurrence of the nearest event be @xmath150 ( if there exists no such event , then both @xmath125 and @xmath132 can deadlock ) .",
    "if @xmath151 , then the event is processed before time @xmath152 , the starting of the period which violates the deadline . in this way , the system violates the deadline with only the existence of ftos function , thus in @xmath125 , the deadline will also be violated .",
    "if @xmath153 , we consider whether the event is the first one being processed",
    "if yes , then the counter - example in @xmath132 is also a counter - example in @xmath125 .",
    "2 .   if not , then consider the time where the previous event occurs , and let the time be @xmath154 .",
    "since @xmath155 , we can find a decoupling point @xmath138 , where @xmath156 , where at @xmath138 it starts a new period . in this way",
    ", we can perform the same technique stated in ( 2-b ) before @xmath138 .",
    "4 .   consider the case where in @xmath132 , the counter - example indicates that both the @xmath141-th aperiodic task and the ftos function violate the deadline .",
    "let the time which violates the deadline be @xmath145 ( note that @xmath145 is the multiple of @xmath126 ) , then the event occurs in time @xmath157 . by an argumentation similar to point 3-b , a counter - example trace in @xmath125 can be established .",
    "remark : ( 1 ) proposition  [ simple ] formulates the insight that previous events occurred long before can not influence the current processing and scheduling , and therefore , are not the root cause of deadline violation . in other words , we could also construct a counter example with a single event as root cause . ( 2 ) the introduction of faults can be viewed analogously . for faults , in ftos ( or similar fault - tolerant systems )",
    "the value of @xmath158 is much smaller then @xmath135 ( ltbf ) , and this brings significant advantages for construction of a model with smaller state space .",
    "proposition  [ simple ] can only be used for very simple systems with only one task and one event . in the following",
    ", we will generalize the result to systems consisting of one periodic function with period @xmath126 and several aperiodic functions .",
    "[ more.events ] let @xmath125 be a system with @xmath40 aperiodic functions .",
    "each function with index @xmath141 , where @xmath159 , is associated with a pair @xmath160 describing the ltba and deadline interval .",
    "consider another system @xmath132 , where the only difference is to perform the following change : if for all @xmath159 , @xmath161 , then we change @xmath162 to @xmath163 .",
    "both systems @xmath125 and @xmath132 are equivalent regarding their behavior concerning deadline violation .",
    "we consider the following cases .    1 .",
    "if @xmath132 does not violate the deadline , then so does @xmath125 .",
    "2 .   consider the case where in @xmath132 , the counter - example indicates that the @xmath141-th aperiodic task of type @xmath164 violates the deadline",
    ". 1 .   if @xmath143 , let the time for the @xmath141-th and @xmath144-th arrival of type-@xmath164 events be @xmath145 and @xmath150 .",
    "our goal is to find the decoupling point @xmath138 such that we can overlook all previously happened events .",
    "+ since @xmath165 , then within @xmath166 $ ] the periodic function is executed at least @xmath167 times .",
    "consider the worst case where it is only executed @xmath168 times . within @xmath166",
    "$ ] , there are @xmath169 potential decoupling points @xmath170 , where @xmath171 , @xmath172",
    ". + due to the sparsity of events , each type of event arrives at most once within @xmath166 $ ] . for each type @xmath173 ,",
    "the according event with deadline interval @xmath174 will overlap in worst case at most @xmath175 of these potential decoupling points . thus the total number of overlapped points is at most @xmath176 , which is less than the number of points among @xmath177 .",
    "therefore , there exists at least one point @xmath178 such that it is not overlapped by any deadline interval .",
    "thus we can set the decoupling point @xmath138 as @xmath179 . as a result",
    ", we can construct an equivalent counter - example where no event has happened before @xmath138 .",
    "this new counter - example trace is also a counter - example trace in @xmath125 .",
    "2 .   if @xmath180 , let the time for the @xmath141-th arrival of type-@xmath164 events be @xmath145 . 1 .",
    "if for all type of events , the according events occurred at most once before @xmath145 , then the counter - example is also a counter - example in @xmath125 .",
    "if there exists some type of events occurred more than once : let @xmath181 for type @xmath173 be the total number of events occurred in the counter - example and @xmath182 be the latest event arrival time .",
    "choose @xmath183 such that @xmath184 and @xmath185 , @xmath186 .",
    "then we can find the decoupling point between the @xmath187-th and @xmath188-th arrival of event with type @xmath183 , similar to the argument in case 2-a .",
    "3 .   consider cases where the deadlock happens in the ftos function . 1 .",
    "if in the counter - example no event has occurred , then both @xmath125 and @xmath132 can deadlock .",
    "2 .   otherwise",
    ", first we try to pick an event based on arguments in 2-b - ii . if possible",
    ", then the decoupling point can be found , and the counter - example for @xmath125 can be established . if selection based on 2-b - ii is not possible , it follows the statement of 2-b - i that the counter example for @xmath132 is also a counter - example in @xmath125 .",
    "lastly , we discuss the most general case .",
    "[ more.tasks ] let system @xmath125 have @xmath173 periodic ftos / giotto functions with periodic deadline @xmath189 , where @xmath190 , and @xmath40 aperiodic functions .",
    "each function with index @xmath164 , where @xmath191 , is associated with a pair @xmath192 describing the ltba and deadline interval .",
    "consider another system @xmath132 , where the only difference is to perform the following change : if for all @xmath159 , @xmath193 , where @xmath146 is the least common multiple of @xmath189 , then we change @xmath162 to @xmath194 .",
    "both systems @xmath125 and @xmath132 are equivalent regarding their behavior concerning deadline violation .",
    "the main difference to the previous case is that periodic functions with different tasks might influence each other .",
    "potential decoupling points occur only at points in time , where all tasks start together .",
    "the proof idea is to view multiple periodic functions as a whole by taking the least common multiple .",
    "here we omit the detailed proof .",
    "for implementation , we extend the functionality of ftos - verify to test the applicability .",
    "the verification model is constructed in a format acceptable by uppaal  @xcite .",
    "note that templates in uppaal are not completely suitable for our usage , since they only represent a fixed behavior with configurable parameters .",
    "therefore , algorithms to automatically generate timed automata based on ftos models are needed .",
    "we have implemented our automated m2 m transformation tool using openarchitecturewareunder the eclipse modeling framework .    as use case",
    ", we apply the verification in the context of our balanced - rod example , where the control functions are replicated on three redundant machines to guarantee fault - tolerance .",
    "all components mentioned previously are generated by our automatic conversion technique ; the resulting uppaal system has @xmath195 communicating timed automata .",
    "as timing information for the different components , we use currently user - specified assumptions .",
    "an integration of wcet - analyzers is foreseen .",
    "one desired property specified is the guarantee for the absence of deadline violation , which turns to be the reachability property in uppaal .",
    "the overall execution time varies from @xmath42 to @xmath195 minutes depending on the accuracy of the verification model on a intel 2.33 ghz machine using a fifo - based priority - driven scheduler .",
    "the memory consumption can reach up to @xmath196 mb .",
    "the verification of using a round - robin based scheduler showed to be too memory comsuming .",
    "we mention related work , but constrain ourselves in works regarding the analysis of giotto - like systems ; for techniques applying formal verification in real - time analysis , we refer readers to the survey paper by wang @xcite . in giotto , the giotto - compiler will perform hardware mapping and apply analysis techniques to check schedulability .",
    "many design tools with giotto - like mocs apply similar approaches , for example , tdl  @xcite or htl  @xcite , but analysis techniques are not explicitly mentioned .",
    "one interesting work comes from comdes - ii project  @xcite , which is also based on the concept of logical execution time ; here , researchers apply model transformation from system models to verification models .",
    "nevertheless , as we focus on fault - tolerant systems , our work differs from the above works with the following facts .",
    "first , we encounter a harder problem ; by applying software fault - tolerance , modeling the communication between multiple deployed units is required , and this is not required by other giotto - like mocs . for those mocs , scheduling analysis developed in real - time community could be enough without the use of model checking .",
    "furthermore , by proposing the similarity between aperiodic events and fault occurrences , our theoretical criteria is powerful to reduce dramatically the complexity of the model ( not the verification algorithm ) .",
    "this is based on our understanding regarding constituents for the complexity of timed verification .",
    "in this paper , we discussed the issue of constructing a model to verify timing assumptions in the context of ftos using timed automata .",
    "however , due to our general approach , the results can be applied to arbitrary distributed real - time systems .      1 .",
    "we give observations concerning modeling of general distributed real - time systems using timed automata and formulate our verification model construction process .",
    "2 .   with the context of systems consisting of periodic and aperiodic tasks , we give theoretical criteria how to reduce the size of the verification model , which is particularly useful for our approach .",
    "the change of the maximum integer used in the system decreases the required time for verification with exponential scale .",
    "a prototype software for the conversion process is constructed with preliminary experiments .",
    "our work is currently based on user - specified assumptions regarding the timing of involved components .",
    "the next step will be the integration of wcet analyzing tools to have a faithful verification result .",
    "gerd behrmann , alexandre david , and kim  g. larsen . a tutorial on uppaal . in marco bernardo and flavio corradini , editors , _ formal methods for the design of real - time systems : 4th international school on formal methods for the design of computer , communication , and software systems ( sfm - rt04 ) _ , number 3185 in lncs , pages 200236 .",
    "verlag , september 2004 .",
    "a.  ghosal , a.  sangiovanni - vincentelli , c.m .",
    "kirsch , t.a .",
    "henzinger , and d.  iercan . .",
    "in _ proceedings of the 6th acm & ieee international conference on embedded software ( emsoft06 ) _ , pages 132141 .",
    "acm new york , ny , usa , 2006 .",
    "thomas  a. henzinger , benjamin horowitz , and christoph  m. kirsch .",
    "giotto : a time - triggered language for embedded programming . in _ proceedings of the first international workshop on embedded software ( emsoft01 ) _ , pages 166184 .",
    "springer - verlag , 2001 .",
    "x.  ke , p.  pettersson , k.  sierszecki , and c.  angelov . .",
    "in _ proceedings of the 14th ieee international conference on embedded and real - time computing systems and applications ( rtcsa08 ) _ , pages 153160 .",
    "ieee computer society washington , dc , usa , 2008 .",
    "f.  wang and c.h .",
    "in _ proceedings of the 28th ifip wg 6.1 international conference on formal techniques for networked and distributed systems ( forte08 ) _ , volume 5048 of _ lncs _ , pages 185200 . springer ",
    "verlag , 2008 ."
  ],
  "abstract_text": [
    "<S> the increasing use of model - based tools enables further use of formal verification techniques in the context of distributed real - time systems . to avoid state explosion , </S>",
    "<S> it is necessary to construct verification models that focus on the aspects under consideration .    in this paper , we discuss how we construct a verification model for timing analysis in distributed real - time systems . </S>",
    "<S> we ( 1 ) give observations concerning restrictions of timed automata to model these systems , ( 2 ) formulate mathematical representations on how to perform model - to - model transformation to derive verification models from system models , and ( 3 ) propose some theoretical criteria how to reduce the model size . </S>",
    "<S> the latter is in particular important , as for the verification of complex systems , an efficient model reflecting the properties of the system under consideration is equally important to the verification algorithm itself . </S>",
    "<S> finally , we present an extension of the model - based development tool ftos , designed to develop fault - tolerant systems , to demonstrate our approach . </S>"
  ]
}