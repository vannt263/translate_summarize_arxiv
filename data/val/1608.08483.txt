{
  "article_text": [
    "managing and operating traditional computer networks is known to be a challenging , manual and error - prone process . given the critical role computer networks play today , not only in the context of the wide - area internet but also of enterprise and data center networks , this is worrisome .",
    "software - defined networks ( sdns ) in general and the openflow standard in particular , promise to overcome these problems by enabling automation , formal reasoning and verification , as well as by defining open standards for vendors .",
    "indeed , there is also a wide consensus that formal verifiability is one of the key advantages of sdn over past attempts to innovate computer networks , e.g. , in the context of active networking  @xcite .",
    "accordingly , sdn / openflow is seen as a promising paradigm toward more dependable computer networks .    at the core of the software - defined networking paradigm",
    "lies the desire to program the network . in a nutshell ,",
    "in an sdn , a general - purpose computer manages a set of programmable switches , by installing rules ( e.g. , for forwarding ) and reacting to events ( e.g. , newly arriving flows or link failures ) .",
    "in particular , openflow follows a match - action paradigm : the controller installs rules which define , using a _ match _ pattern ( expressed over the _ packet header fields _ , and defining a _ flow _ ) , which packets ( of a flow ) are subject to which _ actions _",
    "( e.g. , forwarding to a certain port ) .",
    "while the openflow api is simple and allows to manipulate hardware configurations in flexible ways , it is very low level and not well - suited as a language for human programmers .",
    "accordingly , over the last years , several more high - level and expressive domain - specific sdn languages have been developed , especially within the frenetic project  @xcite .",
    "these languages can also be used to express fundamental network queries , for example related to _",
    "reachability _ : they help administrators answer questions such as _ `` can a given host  @xmath2 reach host  @xmath3 ? '' _ or",
    "_ `` is traffic between hosts  @xmath2 and  @xmath3 isolated from traffic between hosts  @xmath4 and  @xmath5?''_.    what is missing today however is a domain - specific language which allows to describe the important _ weighted aspects _ of networking .",
    "e.g. , real networks naturally come with capacity constraints , and especially in the wide - area network ( wan ) as well as in data centers , bandwidth is a precious resource .",
    "similarly , networks come with latency and/or monetary costs : transmitting a packet over a wide - area link , or over a highly utilized link , may entail a non - trivial latency , and inter - isp links may also be attributed with monetary costs .",
    "= [ fill = white , draw , text = black ] = [ thick , decoration = markings , mark = at position 1 with , double distance=1.4pt , shorten > = 5.5pt , preaction = decorate , postaction = draw , line width=1.4pt , white , shorten > = 4.5pt ] = [ semithick , white , line width=1.4pt , shorten > = 4.5pt ] ( s ) at ( 0,1 ) @xmath6 ; ( f1 ) at ( 3,2 ) @xmath7 ; ( e ) at ( 3,0 ) @xmath8 ; ( f2 - 1 ) at ( 6,2 ) @xmath9 ; ( f2 - 2 ) at ( 6,0 ) @xmath10 ; ( t ) at ( 9,1 ) @xmath11 ;    \\(s )  ( f1 ) ; at ( 1.5,1.6 ) @xmath12 ;    \\(s )  ( e ) ; at ( 1.5,-0.1 ) @xmath13 ;    ( f1 )  ( f2 - 1 ) ; at ( 4.5,2 ) @xmath14 ;    \\(e )  ( f2 - 2 ) ; at ( 4.5,-.6 ) @xmath15 ;    ( f2 - 1 )  ( t ) ; at ( 7.5,1.6 ) @xmath16 ;    ( f2 - 2 )  ( t ) ; at ( 7.5,-0.1 ) @xmath17 ;    ( f1 )  ( f2 - 2 ) ; at ( 3.5,1 ) @xmath18 ;    \\(e )  ( f2 - 1 ) ; at ( 3.5,0.4 ) @xmath19 ;    [ fig : sc ]    weights may not be limited to links only , but also nodes ( switches or routers ) have capacities and costs e.g. , related to the packet rate .",
    "what is more , today s computer networks provide a wide spectrum of in - network functions related to security ( e.g. , firewalls ) and performance ( e.g. , caches , wan optimizers ) .",
    "to give an example , today , the number of so - called _ middleboxes _ in enterprise networks can be in the same order of magnitude as the number of routers  @xcite .",
    "a domain specific language for sdns should be expressive enough to account for middleboxes which can change ( e.g. , compress or increase ) the rate of the traffic passing through them .",
    "moreover , a network language should be able to define that traffic must pass through these middleboxes in the first place , i.e. , that routing policies fulfill waypointing invariants  @xcite . with the advent of more virtualized middleboxes , and the _ network function virtualization _ paradigm ,",
    "short _ nfv _ , ( virtualized ) middleboxes may also be _ composed _ to form more complex network services .",
    "for example , sdn traffic engineering flexibilities can be used to steer traffic through a series of middleboxes , concatenating the individual functions into so - called _ service chains _  @xcite .",
    "for instance , a network operator might want to ensure that all traffic from @xmath6 to  @xmath11 should first be routed through a firewall  @xmath20 , and then through a wan optimizer @xmath21 , before eventually reaching  @xmath11 : the operator can do so by defining a service chain @xmath22 .",
    "* a motivating example .",
    "* let us consider a more detailed example , see the network in figure  [ fig : sc ] : the network hosts two types of ( virtualized ) functions @xmath7 and  @xmath23 : possible network functions may include , e.g. , a firewall , a nat , a proxy , a tunnel endpoint , a wan optimizer ( and its counterpart ) , a header decompressor , etc . in this example , function  @xmath23 is instantiated at two locations .",
    "functions  @xmath7 and  @xmath23 may not be flow - preserving , but may _ decrease _ the traffic rate ( e.g. , in case of a proxy , wan optimizer , etc . ) or _ increase _ it : e.g. , a tunnel entry - point may add an extra header , a security box may add a watermark to the packet , the counterpart of the wan optimizer may decompress the packet , etc .",
    "links come with a certain cost ( say latency ) and a certain capacity ( in terms of bandwidth ) .",
    "accordingly , we may annotate links with two weights : the tuple  @xmath24 denotes that the link cost is 2 and the link capacity 3 .",
    "we would like to be able to ask questions such as : _ can source  @xmath6 emit traffic into the service chain at rate  @xmath25 without overloading the network ? _ or _ can we embed a service chain of cost ( e.g. , end - to - end latency ) at most  @xmath25?_.    * contributions .",
    "* this paper initiates the study of weighted network languages for programming and reasoning about sdn networks , which go beyond topological aspects but account for actual resource availabilities , capacities , or costs .",
    "in particular , we present  @xmath0 , an extension of the _ netkat _  @xcite algebra .    for example ,  @xmath0 supports a natural generalization of the reachibility concepts used in classic network programming languages , such as _ cost - aware _ or _ capacity - aware reachability_. in particular ,  @xmath0 allows to answer questions of the form : _ can host  @xmath2 reach host  @xmath3 at cost / bandwidth / latency  @xmath25 ? _    we demonstrate applications of  @xmath0 for a number of practical use cases related to performance , quality - of - service , fairness , and costs .",
    "these applications are not only useful in the context of both splittable and unsplittable routing models , where flows need to travel from a source @xmath6 to a destination  @xmath11 , but also in the context of more complex models with waypointing requirements ( e.g. , service chains ) .",
    "the weighted extension of netkat is non - trivial , as capacity constraints introduce dependencies between flows , and arithmetic operations such as _ addition _ ( e.g. , in case of latency ) or _ minimum _ ( e.g. , in case of bandwidth to compute the end - to - end delay ) have to be supported along the paths .",
    "therefore , we extend the syntax of netkat toward weighted packet- and switch - variables , as well as queues , and provide a semantics accordingly .",
    "in particular , one contribution of our work is to show for which weighted aspects and use cases which language extensions are required .",
    "we also show the relation between wnetkat expressions and weighted finite automata  @xcite  an important operational model for weighted programs .",
    "this leads to the undeciability of wnetkat equivalence problem .",
    "however , leveraging this relation we also succeed to prove the decidability of whether an expression equals to 0 : for many practical scenarios a sufficient and relevant solution .",
    "moreover , this paper initiates the discussion of identifying decidable subsets of the whole language .",
    "* related work .",
    "* most modern domain - specific sdn languages enable automated tools for verifying network properties  @xcite .",
    "especially reachability properties , which are also the focus in our paper , have been studied intensively in the literature  @xcite .",
    "indeed , the formal verifiability of the openflow match - action interface  @xcite constitutes a key advantage of the paradigm over previous innovation efforts  @xcite .",
    "existing expressive languages use sat formulas  @xcite , graph - based representations  @xcite , or higher - order logic  @xcite to describe network topologies and policies .",
    "our work builds upon netkat , a new framework based on kleene algebra with tests for specifying , programming , and reasoning about networks and policies .",
    "netkat respresents a more principled approach compared to prior work , and is also motivated by the observation that end - to - end functionality is determined not only by the behavior of the switches and but also by the structure of the network topology .",
    "netkat in turn is based on earlier efforts performed in the context of netcore  @xcite , pyretic  @xcite and frenetic  @xcite .",
    "it has recently been extended to a probabilistic setting  @xcite .",
    "the kleene algebra with tests was developed by kozen  @xcite .    however , to the best of our knowledge , there is prior work on weighted versions of netkat .",
    "* organization . *",
    "the rest of this paper is organized as follows .",
    "section  [ sec : background ] provides the necessary background on sdn and netkat .",
    "section  [ sec : wnetkat ] introduces  @xmath0 , our weighted version of netkat .",
    "section  [ sec : applications ] demonstrates the usefulness of our extensions in a number of applications .",
    "section  [ sec : deci ] and section  [ sec : compilation ] discuss complexity and implementation aspects .",
    "section  [ sec : conclusion ] concludes our contribution .",
    "we first provide a more detailed introduction to openflow , and then describe the programming language netkat , which compiles to openflow .",
    "* sdn and openflow . * a software - defined network ( sdn ) outsources and consolidates the control over data plane elements to a logically centralized control plane implemented in software .",
    "arguably , software - defined networking in general , and its de facto standard , openflow , are about programmability , verifiability and generality  @xcite : a software - defined network allows programmers to write network applications ( for example for traffic engineering ) in software .",
    "the behavior of an openflow switch is defined by its configuration : a list of prioritized _ ( flow ) rules _ stored in the switch flow table , which are used to classify , filter , and modify packets based on their _ header fields_. in particular , openflow follows a simple match - action paradigm : the match parts of the flow rules ( expressed over the header fields ) specify which packets belong to a certain flow ( e.g. , depending on the ip destination address ) , and the action parts define how these packets should be processed ( e.g. , forward to a certain port ) .",
    "openflow supports a rather general packet processing : it allows to match and process packets based on their layer-2 ( e.g. , mac addresses ) , layer-3 ( e.g. , ip addresses ) , and layer-4 header fields ( e.g. , tcp ports ) , or even in a protocol - independent manner , using arbitrary bitmasking  @xcite .",
    "for example , an openflow router may forward packets destined to http ports differently from traffic destined to ftp ports . in other words ,",
    "an openflow switch blurs the difference between switches and routers ( the two terms are used interchangeably in this paper ) , and even supports some basic middlebox functionality .",
    "openflow also readily supports quantitative aspects , e.g. , the selection of queues annotated with different round robin weights ( the standard approach to implement quality - of - service guarantees in networks today ) , or meters ( measuring the bandwidth of a flow ) .",
    "moreover , we currently witness a trend toward more flexible and stateful programmable switches and packet processors , featuring group tables , counters , and beyond  @xcite .",
    "* netkat . * the formal framework developed in this paper is based on netkat  @xcite . here",
    "we briefly review the main concepts underlying netkat , and discuss how they relate to openflow .",
    "netkat is a high - level algebra for reasoning about network programs .",
    "it is based on _ kleene algebra with tests ( kat ) _ , and uses an equational theory combining the axioms of kat and network - specific axioms that describe transformations on packets ( as performed by openflow switch rules ) .",
    "these axioms facilitate reasoning about local switch processing functionality ( needed during compilation and for optimization ) as well as global network behavior ( needed to check reachability and traffic isolation properties ) . basically , an atomic netkat policy ( a function from packet headers to sets of packet headers : essentially the per - switch openflow rules discussed above ) can be used to filter or modify packets .",
    "policy combinators ( @xmath26 ) allow to build larger policies out of smaller policies .",
    "there is also a sequential composition combinator to apply functions consecutively .",
    "besides the _ policy _ , modeling the per - switch openflow rules , a network programming language needs to be able to describe the network",
    "_ topology_. netkat models the network topology as a directed graph : nodes ( hosts , routers , switches ) are connected via edges ( links ) using ( switch ) _",
    "ports_. netkat simply describes the topology as the union of smaller policies that encode the behavior of each link . to model the effect of sending a packet across a link",
    ", netkat employs the sequential composition of a filter that retains packets located at one end of the link , and a modification that updates the switch and port fields to the location at the other end of the link .",
    "note that the netkat topology and the netkat policy are hence to be seen as two independent concepts . succinctly :    a _ kleene algebra _",
    "( ka ) is any structure  @xmath27 , where  @xmath28 is a set ,  @xmath26 and  @xmath29 are binary operations on  @xmath28 ,  @xmath30 is a unary operation on  @xmath28 , and  @xmath31 and  @xmath32 are constants , satisfying the following axioms , where we define  @xmath33 iff  @xmath34 .",
    "+    @xmath35    a _ kleene algebra with tests _ ( kat ) is a two - sorted structure  @xmath36 , where  @xmath37 and + @xmath38 @xmath27 is a kleene algebra ; + @xmath38 @xmath39 is a boolean algebra ; + @xmath38 @xmath40 is a subalgebra of  @xmath41 .",
    "the elements of  @xmath3 are called _",
    "tests_. the axioms of boolean algebra are : +    @xmath42    netkat is a version of kat in which the atoms ( elements in @xmath28 ) are defined over header fields  @xmath43 ( variables ) and values  @xmath44 : + @xmath38 @xmath45 ( `` assign a value  @xmath44 to header field  @xmath43 '' ) + @xmath38 @xmath46 ( `` test the value of a header field '' ) + @xmath38 ( `` duplicate the packet '' )    the set of all possible values of @xmath43 is denoted @xmath47 . for readability ,",
    "we use  @xmath48 and  @xmath49 to denote  @xmath32 and  @xmath31 , respectively .",
    "the netkat axioms consist of the following equations , in addition to the kat axioms on the commutativity and redundancy of different actions and tests , and enforcing that the field has exactly one value : +    @xmath50    in terms of semantics , netkat uses _ packet histories _ to record the state of each packet on its path from switch to switch through the network .",
    "the notation @xmath51 is used to describe a history with elements  @xmath52 being packets ; @xmath53 is used to denote a history with one element and  @xmath54 to denote the history constructed by prepending  @xmath55 on to  @xmath56 . by convention ,",
    "the first element of a history is the current packet ( the `` head '' ) .",
    "a netkat expression denotes a function @xmath57 , where  @xmath58 is the set of packet histories .",
    "histories are only needed for reasoning : policies only inspect or modify the first ( current ) packet in the history . succinctly : +    @xmath59::h\\}\\\\ \\llbracket f=\\omega\\rrbracket(pk::h)&=&\\left\\{\\begin{array}{lcl } \\{pk::h\\}&\\phantom{ef}&\\text{if } pk(f)=\\omega\\\\\\emptyset&&\\text{otherwise } \\end{array}\\right.\\\\ \\llbracket\\text{\\small\\sf dup}\\rrbracket(pk::h)&=&\\{pk::pk::h\\}\\\\ \\llbracket p+q\\rrbracket(h)&=&\\llbracket p\\rrbracket(h)\\cup\\llbracket q\\rrbracket(h)\\\\ \\llbracket pq\\rrbracket(h)&=&\\bigcup_{h'\\in\\llbracket p\\rrbracket(h)}{\\llbracket q\\rrbracket(h')}\\\\ \\llbracket p^\\ast\\rrbracket(h)&=&\\bigcup_{n}{\\llbracket p^n\\rrbracket(h)}\\\\ \\llbracket 0\\rrbracket(h)&=&\\emptyset\\\\ \\llbracket 1\\rrbracket(h)&=&\\{h\\}\\\\ \\llbracket\\overline{a}\\rrbracket(h)&=&\\left\\{\\begin{array}{lcl } \\{h\\}&\\phantom{ef}&\\text{if } \\llbracket a\\rrbracket(h)=\\emptyset\\\\\\emptyset&&\\text{if } \\llbracket a\\rrbracket(h)=\\{h\\ } \\end{array}\\right .",
    "\\end{array}$ ]    consider the network in figure  [ fig : sc ] .",
    "netkat can be used to specify the topology as follows , where the field  @xmath60 stores the current location ( switch ) of the packet : +    @xmath61    the first line of the above netkat expression specifies that if the packet is at  @xmath6 , then it will be sent to  @xmath7 or  @xmath8 .",
    "analogously for the other cases . in openflow",
    ", this policy can be implemented using openflow rules , whose match part applies to packets arriving at @xmath6 , and whose action part assigns the packets to the respective forwarding ports .",
    "@xmath62    however , one can observe that with netkat it is not possible to specify or reason about the important quantitative aspects in figure  [ fig : sc ] , e.g. , the cost and capacity along the links or the function of @xmath23 which changes the rate of the flow .",
    "to do these , a weighted extension of netkat is needed .",
    "on a high level , a computer network can be described as a set of nodes ( hosts or routers ) which are interconnected by a set of links , hence defining the network topology . while this high - level view is sufficient for many purposes , for example for reasoning about reachability , in practice , the situation is often more complex : both nodes and links come with capacity constraints ( e.g. , in terms of buffers , cpu , and bandwidth ) and may be attributed with costs ( e.g. , monetary or in terms of performance ) . in order to reason about performance , cost , and fairness aspects , it is therefore important to take these dimensions into account",
    ".    the challenge of extending netkat to weighted scenarios lies in the fact that in a weighted network , traffic flows can no longer be considered independently , but they may _ interfere _ : their packets compete for the shared resource .",
    "moreover , packets of a given flow may not necessarily be propagated along a unique path , but may be split and distributed among multiple paths ( in the so - called _ multi - path routing _ or _ splittable flow _",
    "variant ) .",
    "accordingly , a weighted extension of netkat must be able to deal with `` inter - packet states '' .",
    "we in this paper will think of the network as a weighted ( directed ) graph  @xmath63 . here ,  @xmath64 denotes the set of switches ( or equivalently routers , and henceforth often simply called nodes )",
    ",  @xmath65 is the set of links ( connected to the switches by _ ports _ ) , and @xmath66 is a weight function .",
    "the weight function  @xmath66 applies to both nodes  @xmath64 as well as links  @xmath65 .",
    "moreover , a node and a link may be characterized by _ a vector of weights _ and also combine _ multiple resources _ : for example , a list of capacities ( e.g. , cpu and memory on nodes , or bandwidth on links ) and a list of costs ( e.g. , performance , energy , or monetary costs ) .    in order to specify the quantitative aspects , we propose in this paper a weighted extension of netkat : @xmath0 .",
    "in addition to netkat :    * @xmath0 includes a set of _ quantitative packet - variables _ to specify the quantitative information carried in the packet , in addition to the regular ( non - quantitative ) packet - variables of netkat ( called _ fields _ in netkat ) : e.g. , regular variables are used to describe locations , such as switch and port , or priorities , while quantitative variables are used to specify latency or energy .",
    "the set of all packet - variables is denoted by @xmath67 .",
    "* @xmath0 also includes a set of _ switch - variables _ , denoted by  @xmath68 , to specify the configurations at the switch .",
    "switch variables can either be quantitative ( e.g. , counters , meters , meta - rules  @xcite ) or non - quantitative ( e.g. , location related ) , as it is the case of the packet - variables .",
    "_ remarks : _ the set of quantitative ( packet- and switch- ) variables is denoted by @xmath69 and these variables range over the natural numbers  @xmath70 ( e.g. , normalized rational numbers ) .",
    "the set of non - quantitative ( packet- and switch- ) variables is denoted @xmath71 and the set of the possible values is denoted @xmath47 .",
    "note that  @xmath72 and  @xmath73 .",
    "@xmath62    in addition to introducing quantitative variables , we also need to extend the atomic actions and tests of netkat .",
    "concretely ,  @xmath0 first supports non - quantitative assignments and non - quantitative tests on the non - quantitative switch - variables , similar to those on the packet - variables in netkat .",
    "moreover , @xmath0 also allows for _ quantitative assignments _ and _ quantitative tests _ , defined as follows , where  @xmath74 , @xmath75 ,  @xmath76 ,  @xmath77 :    * * quantitative assignment *  @xmath78 : read the current values of the variables in  @xmath79 and add them to  @xmath80 , then assign this result to  @xmath25 . * * quantitative test *  @xmath81 : read the current value of the variables in  @xmath79 and add them to  @xmath80 , then compare this result to the current value of  @xmath25 .    _",
    "remarks : _ 1 . in the quantitative assignment and test , only addition is allowed .",
    "however , an extension to other arithmetic operations ( e.g. , linear combinations ) is straightfoward .",
    "moreover , calculating  _ minimum _ or  _ maximum _ may be useful in practice : e.g. , the throughput of a flow often depends on the weakest link ( of minimal bandwidth ) along a path .",
    "note that these operations can actually be implemented with quantitative assignments and tests , i.e. , by comparing every variable to another and determining the smallest .",
    "e.g. , for @xmath74 and  @xmath82 or  @xmath70 , +    @xmath83     + 2 . in quantitative assignment and test",
    ", @xmath25 might be in @xmath79 .",
    "we use  @xmath26 to denote the arithmetic operation over numbers .",
    "therefore , we will use  @xmath84 \" in  @xmath0 to denote the ",
    "@xmath26 \" operator of kleene algebra , which is also used in  @xcite .",
    "@xmath62    given the set of switches @xmath64 , a _ switch - variable valuation _ is a partial function @xmath85 . it associates , for each switch and each switch - variable , a integer or a value from  @xmath47 .",
    "we emphasize that  @xmath86 is a partial function , as some variables may not be defined at some switches .",
    "a _ wnetkat_expression denotes a function @xmath87 , where  @xmath58 is the set of packet histories .",
    "the semantics of  @xmath0 is defined in table  [ sem-1 ] , where @xmath88 ,  @xmath76 and  @xmath89 .",
    "@xmath90::h\\}&\\phantom{ef}&\\text{if } x\\in{\\mathcal{v}}_p \\\\ \\{\\rho(v)[\\omega / x],\\ pk::h\\}&&\\text{if } x\\in{\\mathcal{v}}_s\\text { and } pk(sw)=v \\\\ \\end{array } \\right .",
    "\\hfill ( 1 )   \\\\   \\\\",
    "\\llbracket x=\\omega\\rrbracket(\\rho,\\ pk::h)&=&\\left\\{\\begin{array}{lcl } \\{\\rho,\\ pk::h\\}&\\phantom{ef}&\\text{if } x\\in{\\mathcal{v}}_p\\text { and } pk(x)=\\omega \\\\ & \\phantom{ef}&\\text { or if } x\\in{\\mathcal{v}}_s , pk(sw)=v\\text { and } \\rho(v , x)=\\omega \\\\ \\emptyset&&\\text{otherwise } \\end{array}\\right .",
    "\\hfill ( 2 ) \\\\ \\\\",
    "\\llbracket y\\leftarrow ( \\displaystyle\\sigma_{y'\\in{\\mathcal{v}}'}{y'}+r)\\rrbracket(\\rho,\\ pk::h)&\\phantom{e}=\\phantom{e}&\\left\\{\\begin{array}{lcl } \\{\\rho,\\ pk[r'/x]::h\\}&\\phantom{ef}&\\text{if } x\\in{\\mathcal{v}}_p \\\\",
    "\\{\\rho(v)[r'/x],\\ pk::h\\}&&\\text{if } x\\in{\\mathcal{v}}_s\\text { and } pk(sw)=v \\\\ \\end{array } \\right.\\hfill ( 3)\\\\ & \\multicolumn{2}{l}{\\text{where } r'=\\sigma_{y_p\\in{\\mathcal{v}}'\\cap{\\mathcal{v}}_p}pk(y_p)+\\sigma_{y_s\\in{\\mathcal{v}}'\\cap{\\mathcal{v}}_q}\\rho(v , y_s)+r } \\\\ \\\\",
    "\\llbracket y=(\\sigma_{y'\\in{\\mathcal{v}}'}{y'}+r)\\rrbracket(\\rho,\\ pk::h)&=&\\left\\{\\begin{array}{lcl } \\{\\rho,\\ pk::h\\}&\\phantom{ef}&\\text{if } x\\in{\\mathcal{v}}_p\\text { and } pk(x)=r'\\\\ & \\phantom{ef}&\\text { or } x\\in{\\mathcal{v}}_s , pk(sw)=v\\text { and } \\rho(v , x)=r'\\\\ \\emptyset&&\\text{otherwise } \\end{array}\\right .",
    "\\hfill ( 4)\\\\ & \\multicolumn{2}{l}{\\text{where } r'=\\sigma_{y_p\\in{\\mathcal{v}}'\\cap{\\mathcal{v}}_p}pk(y_p)+\\sigma_{y_s\\in{\\mathcal{v}}'\\cap{\\mathcal{v}}_q}\\rho(v , y_s)+r } \\end{array}\\ ] ]    _ remarks : _ @xmath38 equations ( 1 ) and ( 3 ) update the corresponding header field if  @xmath25 is a packet - variable , or they update the corresponding switch information of the current switch if  @xmath25 is a switch - variable .",
    "equation  ( 1 ) updates the non - quantitative variables and equation  ( 3 ) the quantitative ones .",
    "@xmath38 equations ( 2 ) and ( 4 ) test the non - quantitative and quantitative variables respectively , using the current packet- and switch - variables .",
    "@xmath62    [ exm - sem ] consider again the network in figure  [ fig : sc ] .",
    "the topology of the network can be characterized with the following  @xmath0 formula  @xmath11 , where  @xmath60 specifies the current location ( switch ) of the packet ,  @xmath91 specifies the cost , and  @xmath92 specifies the capacity along the links .",
    "@xmath93    the variable  @xmath91 accumulates the costs along the path , and the variable  @xmath92 records the smallest capacity along the path .",
    "notice that  @xmath92 is just a packet - variable used to record the capacity of the path ; it does not represent the capacity used by this packet ( the latter is assumed to be negligible ) .",
    "assume that function  @xmath7 is flow conserving ( e.g. , a nat ) , while @xmath23 increases the flow rate by an additive constant @xmath94 ( e.g. , a security related function , adding a watermark or an ipsec header ) .",
    "the policy of @xmath23 can be specified as :    @xmath95  @xmath62    _ remarks : _ note that this simple example required only ( non - quantitative and quantitative ) packet - variables .",
    "however , as we will see in section [ sec : applications ] , to model more complex aspects of networking , such as splittable flows , additonal concepts of @xmath0 will be needed .",
    "the weighted extensions introduced by  @xmath0 come with a number of interesting applications . in this section , we show that the notions of reachability frequently discussed in prior work , find natural extensions in the world of weighted networks , and discuss applications in the context of service chains , fairness , and quality - of - service . in the appendix ,",
    "additional details are provided for some of these use cases .",
    "especially data center networks but also wide - area networks , and to some extent enterprise networks , feature a certain _ path diversity _",
    "@xcite : there exist multiple routes between two endpoints ( e.g. , hosts ) .",
    "this path diversity is not only a prerequisite for fault - tolerance , but also introduces traffic engineering flexibilities .",
    "in particular , different paths or routes depend on different links , whose cost can vary . for example , links may be attributed with monetary costs : a peering link may be free of charge , while an up- or down - link is not .",
    "links cost can also be performance related , and may for example vary in terms of latency , for example due to the use of different technologies  @xcite , or simply because of different physical distances .",
    "the monetary and performance costs are often related : for example , in the context of stock markets , lower latency links come at a higher price  @xcite .",
    "it is therefore natural to ask questions such as : _ `` can a reach b at cost at most  @xmath96?''_. we will refer to this type of questions as _ cost reachability questions_.    [ exm - cr ] consider the network in figure  [ fig : b4 ] .",
    "the topology roughly describes the north american data centers interconnected by google b4 , according to  @xcite .",
    "= [ fill = white , draw , text = black ] = [ thick , decoration = markings , mark = at position 1 with , double distance=1.4pt , shorten > = 5.5pt , preaction = decorate , postaction = draw , line width=1.4pt , white , shorten > = 4.5pt ] = [ semithick , white , line width=1.4pt , shorten > = 4.5pt ] ( dc1 ) at ( 0,0 ) @xmath97 ; at ( 0.55,0.1 )  @xmath32 ; at ( 0.15,-0.55 )  @xmath98 ;    ( dc2 ) at ( 2,-.5 ) @xmath99 ; at ( 2.54,-0.6 )  @xmath32 ; at ( 2.12,-0.78 )  @xmath98 ; at ( 1.85,-0.98 )  @xmath100 ; at ( 1.45,-0.55 )  @xmath101 ;    ( dc3 ) at ( 2,-2 ) @xmath102 ; at ( 2.3,-2.48 )  @xmath98 ; at ( 2.15,-1.47 )  @xmath32 ;    ( dc4 ) at ( 2.5,-4 ) @xmath103 ; at ( 2.05,-3.65 )  @xmath32 ; at ( 2.5,-3.42 )  @xmath98 ; at ( 2.95,-3.65 )  @xmath100 ; at ( 2.85,-4.4 )  @xmath101 ;    ( dc5 ) at ( 6,-3 ) @xmath104 ; at ( 5.8,-3.55 )  @xmath32 ; at ( 5.45,-2.95 )  @xmath98 ; at ( 5.6,-2.56 )  @xmath100 ;    ( dc6 ) at ( 4.5,-5 ) @xmath105 ; at ( 3.95,-4.92 )  @xmath32 ; at ( 4.35,-4.45 )  @xmath98 ; at ( 4.95,-4.7 )  @xmath100 ;    ( dc1 )  ( dc2 ) ; at ( 1,-0.25 ) @xmath101 ;    ( dc2 )  ( dc3 ) ; at ( 2,-1.25 ) @xmath98 ;    ( dc3 )  ( dc4 ) ; at ( 2.25,-2.9 ) @xmath98 ;    ( dc1 )  ( dc4 ) ; at ( 1.2,-2 ) @xmath106 ;    ( dc2 )  ( dc5 ) ; at ( 4.1,-1.75 ) @xmath100 ;    ( dc2 )  ( dc6 ) ; at ( 3.35,-2.75 ) @xmath101 ;    ( dc4 )  ( dc5 ) ; at ( 4.15,-3.5 ) @xmath107 ;    ( dc4 )  ( dc6 ) ; at ( 3.57,-4.5 ) @xmath98 ;    ( dc5 )  ( dc6 ) ; at ( 5.25,-4.15 ) @xmath98 ;    in order to reason about network latencies , we not only need information about the switch at which the packet is currently located ( as in our earlier examples ) , but also the _ port of the switch _ needs to be specified .",
    "we introduce the packet - variable  @xmath108 .",
    "we can then specify this network topology in  @xmath0 .",
    "the link from  @xmath97 to  @xmath99 ( latency  @xmath101 units ) represented by the port  @xmath32 at @xmath97 and the port  @xmath101 at  @xmath99 is specified as follows , where we use packet - variable  @xmath60 to denote the current switch , @xmath108 to specify the current port , and  @xmath109 to specify the latency of the path the packet traverses ,    @xmath110    analogously , the entire network topology can be modeled with  @xmath0 , henceforth denoted by  @xmath11 .",
    "the policy of the network determines the functionality of each switch ( the openflow rules ) , e.g. , in  @xmath99 , packets from @xmath97 to @xmath104 arriving at port  @xmath101 are always sent out through port  @xmath32 or port  @xmath100 .",
    "this can be specified as : +    @xmath111    analogously , the entire network policy can be modeled with  @xmath0 , henceforth denoted by  @xmath112 .    to answer the cost reachability question",
    ", one can check whether the following  @xmath0 expression is equal to  @xmath49 .",
    "+    @xmath113    if it is equal to  @xmath49 , then  @xmath3 can not be reached from  @xmath2 at latency at most  @xmath96 ; otherwise , it can .",
    "@xmath62    _ remarks : _ for ease of presentation , in the above example , we considered only one weight .",
    "however , @xmath0 readily supports multiple weights : we can simply use multiple variables accordingly .",
    "moreover , while the computational problem complexity can increase with the number of considered weights  @xcite , the multi - constrained path selection does not affect the general asymptotic complexity of @xmath0 .",
    "@xmath62      especially in the wide - area network , but also in data centers , link capacities are a scarce resource : indeed , wide - area traffic is one of the fastest growing traffic aggregates  @xcite . however , also the routers themselves come with capacity constraints , both in terms of memory ( size of tcam ) as well as cpu : for example , the cpu utilization has been shown to depend on the packet rate  @xcite . accordingly , a natural question to ask is : _ can a communicate at rate at least  @xmath114 to b ? _ we will refer to this type of questions as _ capacitated reachability questions_.    there are two problem variants :    * _ unsplittable flows : _ the capacity needs to be computed along a single path ( e.g. , an mpls tunnel ) . * _ splittable flows : _ the capacity needs to be computed along multiple paths ( e.g. , mptcp , ecmp ) .",
    "we will assume links of higher capacity are chosen first .    for both variants , to find out the capacity of paths between two nodes , a _",
    "test packet will be sent to explore the network and record the bandwidth / capacity with a packet - variable in the packet .",
    "we assume that the bandwidth consumed by this packet is negligibile .",
    "also , only once the packet has traversed and determined the bandwidth , e.g. , the actual ( large ) flows are allocated accordingly ( by the sdn controller ) .",
    "consider the network in figure  [ fig : b4 ] again , but assume that the labels are the capacities rather than latency .",
    "* unsplittable flow scenario : * the switch policies are exactly the same as in example  [ exm - cr ] , while the topology will be specified similarly using packet - variable  @xmath96 to record the capacity of the link .",
    "e.g. , the link between  @xmath97 and  @xmath99 can be specified as : +    @xmath115    the unsplittable capacitated reachability question can be answered by checking whether the following expression is equal to  @xmath49 , +    @xmath116    if the above formula does not equal  @xmath49 , then  @xmath2 can communicate at rate at least  @xmath114 to  @xmath3 .",
    "another ( possibly ) more efficient approach is not to update  @xmath96 while the bandwidth is smaller than  @xmath114 ( meaning that a flow of size  @xmath114 can not go through this link ) . in this case , one can specify the topology as follows , where  @xmath96 is not used to record the capacity along the path anymore , but rather to test whether this link is wide enough : +    @xmath117    the above  @xmath0 expression only tests whether  @xmath96 is less than or equal to  @xmath101 .",
    "it makes sure that the value of  @xmath96 ( which is  @xmath114 ) does not exceed the capacity of the following link .",
    "if it exceeds the capacity of the link , then a flow of rate  @xmath114 can not use this link .",
    "therefore , the test packet is dropped already . the capacitated reachability question",
    "can then be answered by checking whether the following expression is equal to  @xmath49 : +    @xmath118    if the above formula does not equal  @xmath49 , then  @xmath2 can communicate at rate at least  @xmath114 to  @xmath3 .",
    "* splittable flow scenario : * for the splittable scenario , the situation is far more complicated .",
    "for example , in  @xmath99 , packets arriving at port  @xmath101 are sent out through port  @xmath32 or port  @xmath98 , and port  @xmath98 prioritizes port  @xmath32 .",
    "that is , if the incoming traffic has rate  @xmath101 , then a share of @xmath100 units will be sent out through port  @xmath98 , and a  @xmath32 share through port  @xmath32 . note",
    "that also here , still only one _ single _ test packet will be sent to collect the capacity information .",
    "this information will be stored in the packet - variable  @xmath96 as well . however ,",
    "when the test packet arrives at a switch where a flow can be split , copies of the packet are sent ( after updating the  @xmath96 according to the bandwidth of each path ) to all possible paths , to record the capacity along all other paths .",
    "this exploits the fact that  @xmath0 ( netkat ) treats the  @xmath84 operator as _ conjunction _ in the sense that both operations are performed , rather than _ disjunction _ , where one of the two operations would be chosen non - deterministically ( according to the usual kleene interpretation ) .",
    "again , we emphasize that we will refer to  @xmath96 stored in one _ single _ test packet , and not the actual real data flow . now",
    "the topology will update @xmath96 as in the unsplittable case .",
    "however , the policy needs to not only decide which ports the packets go to , but also update  @xmath96 according to the split policy .",
    "e.g. , , at  @xmath99 , the data flow from  @xmath97 to  @xmath104 at rate  @xmath101 is sent out through port  @xmath32 at rate  @xmath100 , and the port  @xmath100 at  @xmath32 . and",
    "if the rate is smaller than or equal to  @xmath100 , e.g. ,  @xmath98 , then the whole flow of rate  @xmath98 will be sent out through port  @xmath32 .",
    "the following  @xmath0 formula specifies this behavior : +    @xmath119    the test  @xmath120 ensures that the flow does not exceed the capacity of both paths .",
    "notice that even when the size of the flow is small enough for one path , a copy of the test packet with  @xmath121 will still be sent to the other .",
    "this ensures that sufficient information is available at the switch where flows merge .",
    "that is , the switch collects the weights the packets carry ( @xmath96 in our example ) .",
    "the switch will only push packets to the right out - ports after all expected packets have arrived .",
    "this will happen before the switch sends the packet to the right out - ports .",
    "for example , at  @xmath103 , the flow from  @xmath97 to  @xmath104 might arrive in from ports  @xmath32 and  @xmath98 and will be sent out through port  @xmath100 . in order to record the capacity of both links , switch - variables  @xmath4 and  @xmath122",
    "are introduced , for each possible merge .",
    "for example , the following table provides the merging rules for the switch at  @xmath103 , where  @xmath122 is the counter for the merge , and  @xmath4 stores the current capacity of the arriving test packets .",
    "initially ,  @xmath122 is set to the number of in - ports for the merge , and  @xmath4 is set to 0 .",
    "@xmath123    the first line of the rules in the table can be specified in  @xmath0 as follows :    @xmath124     when a packet from  @xmath97 to  @xmath104 arrives at port  @xmath32 or  @xmath98 of  @xmath103 , first the switch collects the value of  @xmath96 and adds it to the switch - variable  @xmath4 , then decrements  @xmath122 to record that one packet arrived .",
    "afterwards , we test whether all expected packets arrived ( @xmath125 ) . if not , the current one is dropped ; if yes , we send the current packet out to port  @xmath100 .",
    "the reason that we can drop all packets except for the last , is that all those packets carry exactly the same values .",
    "therefore , we eventually only need to include the merged capacity ( @xmath4 ) in the last packet , and propagate it .    combining the split and merge cases , the policy of the switch can be defined .",
    "for example , the second line of the merging rule table can be specified as follows , by first merging from port  @xmath100 and  @xmath101 , and then splitting to port  @xmath32 and  @xmath98 :    @xmath126    then the splittable capacited reachability question can be answered by checking whether the following expression evaluates to  @xmath49 : +    @xmath127    if the above formula does not equal  @xmath49 , then  @xmath2 can communicate at rate at least  @xmath114 to  @xmath3 .",
    "the virtualization and programmability trend is not limited to the network , but is currently also discussed intensively for network functions in the context of the network function virtualization ( nfv ) paradigm .",
    "sdn and nfv nicely complement each other , enabling innovative new network services such as _ service chains _",
    "@xcite : network functions which are traversed in a particular order ( e.g. , first firewall , then cache , then wide - area network optimizer ) .",
    "our language allows to reason about questions such as _ are sequences of network functions traversed in a particular order , without violating node and link capacities ? _ @xmath0 can easily be used to describe weighted aspects also in the context of service chains .",
    "in particular , network functions may both _ increase _",
    "( e.g. , due to addition of an encapsulation header , or a watermark ) or _ decrease _ ( e.g. , a wan optimizer , or a cache ) the traffic rate , both _ additively _",
    "( e.g. , adding a header ) or _ multiplicatively _ ( e.g. , wan optimizer ) .",
    "let us go back to figure  [ fig : sc ] , and consider a service chain of the form  @xmath128 : traffic from @xmath6 to  @xmath11 should first traverse a function  @xmath7 and then a function  @xmath23 , before reaching  @xmath11 .",
    "for example ,  @xmath7 may be a firewall or proxy and  @xmath23 is a wan optimizer .",
    "the virtualized functions  @xmath7 and @xmath23 may be allocated redundantly and may change the traffic volume . using  @xmath0 , we can ask questions such as : _ what is the maximal rate at which  @xmath6 can transmit traffic into the service chain ? _ or _ can we realize a service chain of cost ( e.g. , latency ) at most  @xmath25?_. let us consider the following example : the question _ `` can  @xmath6 reach  @xmath11 at cost / latency at most  @xmath129 and/or at rate / bandwidth at least  @xmath114 , via the service chain functions  @xmath7 and  @xmath23 ? '' _ , can be formulated by combining the reachability problems above and the waypointing technique in  @xcite .",
    "for example , in case of cost reachability , we can ask if the following  @xmath0 formula equals  @xmath49 . +    @xmath130    note that in this example , we considered an unsplittable scenario . for the splittable scenario",
    ", we can extend the splittable capacitated reachability use case above analogously .",
    "related to quality - of - service is the question of fairness .",
    "for example , a natural question to ask is : _ `` does the current flow allocation satisfy network neutrality requirements ? '' _",
    "@xcite , or more specifically , _",
    "`` is the network max - min fair ? '' _",
    "@xcite    for example , consider the network in figure  [ fig - fair ] .",
    "the numbers on the links specify the bandwidth capacity .",
    "suppose that there are three flows :  @xmath131 embedded in this network .",
    "suppose the rates of these three flows are  @xmath132 , respectively . in a max - min fair allocation ,",
    "we aim to maximize the minimal flow allocated to any of these three flows , subject to capacity constraints .",
    "for example , the minimum flow @xmath133 receives a fair share here : the flow is naturally limited by the first link of capacity 1 .",
    "however , the next smallest rate , @xmath134 , may be increased to @xmath135 , by reducing the flow @xmath136 accordingly .",
    "= [ fill = white , draw , text = black ] = [ thick , decoration = markings , mark = at position 1 with , double distance=1.4pt , shorten > = 5.5pt , preaction = decorate , postaction = draw , line width=1.4pt , white , shorten > = 4.5pt ] = [ semithick , white , line width=1.4pt , shorten > = 4.5pt ] ( s1 ) at ( 0,0 ) @xmath137 ; ( s2 ) at ( 0,-2 ) @xmath138 ; ( b1 ) at ( 2,-1 ) @xmath139 ; ( b2 ) at ( 4.3,-1 ) @xmath140 ; ( e1 ) at ( 6.3,0 ) @xmath141 ; ( e2 ) at ( 6.3,-2 ) @xmath142 ; ( s1 ) edge node[midway , above ] @xmath143 ( b1 ) ( s2 ) edge node[midway , above ] @xmath32 ( b1 ) ( b1 ) edge node[midway , above ] @xmath144 ( b2 ) ( b2 ) edge node[midway , above ] @xmath100 ( e1 ) edge node[midway , above ] @xmath101 ( e2 ) ; ( pt1 ) at ( 0.5,-0.1 ) _ 1 _ ; ( pt1 ) at ( 1.63,-0.63 ) _ 1 _ ; ( pt2 ) at ( 0.5,-1.9 ) _ 1 _ ; ( pt2 ) at ( 1.58,-1.4 ) _ 2 _ ; ( pt3 ) at ( 2.48,-1.15 ) _ 3 _ ; ( pt3 ) at ( 3.75,-1.15 ) _ 1 _ ; ( pt4 ) at ( 4.72,-0.65 ) _ 2 _ ; ( pt5 ) at ( 4.69,-1.38 ) _ 3 _ ; ( pt4 ) at ( 5.77,-0.09 ) _ 1 _ ; ( pt5 ) at ( 5.78,-1.93 ) _ 1 _ ;    consider the network and the flows mentioned earlier in figure  [ fig - fair ] . in order to specify whether the given rates for the flows are max - min fair , we send three test packets along the three flows respectively .",
    "the topology of this network can be specified in  @xmath0 as before , which only takes care of forwarding packets .",
    "e.g. , the link between  @xmath137 and  @xmath139 is specified as follows , where  @xmath96 specifies the capacity : +    @xmath145    the switches not only put incoming packets to the right outgoing ports , but also assign the bandwidth of the out - going links to different flows .",
    "this will be recorded in the test packets as a packet - variable , denoted by  @xmath146 .",
    "moreover , three packet - variables  @xmath147 are used to represent the rates of the flows that are supposed to be checked for max - min fairness .",
    "e.g. , the policy of  @xmath139 can be specified as follows .",
    "+    @xmath148    the first line specifies that the packets arriving at port  @xmath32 or  @xmath98 will be sent out through port  @xmath100 .",
    "the following lines update  @xmath146 of the test packets , according the rates of the flows that share the link . in order to test max - min fairness , we first order the given rates increasingly . for example , to check whether the following flow rates are max - min fair , +    @xmath149    we represent them as  @xmath150 . then , we check them one - by - one , by verifying whether the following  @xmath0 expressions are equal to  @xmath49 or not .",
    "+    @xmath151    while checking whether  @xmath152 is max - min fair , one does not need to consider  @xmath153 ( can be modified if not fair ) , because  @xmath152 is the minimum ; therefore ,  @xmath153 are set to  @xmath31 .",
    "while checking  @xmath154 , it is already known that  @xmath152 is fair .",
    "therefore the value of  @xmath152 can not be changed even if  @xmath154 is not fair ; this is why  @xmath152 is set to  @xmath32 , and  @xmath155 is  @xmath31 in  @xmath156 .",
    "similarly for  @xmath155 .    if all of the above formulas are not equal to drop , then the given rates are max - min fair .",
    "e.g. , the above rates  @xmath157 are not max - min fair because  @xmath156 equals  @xmath49 .",
    "this matches our discussion above .    moreover , the results of the above tests can also help develop more fair rates .",
    "e.g. ,  @xmath156 is the first list entry to equal  @xmath49 , this means that  @xmath154 is not fairly allocated .",
    "however ,  @xmath152 must be fair as @xmath158 does not equal  @xmath49 .",
    "therefore , to ensure max - min fairness in this network , one should keep the rate of the flow  @xmath133 , and adjust the rate of  @xmath134 and that of  @xmath136 .",
    "we have already shown how to specify and reason about a number of relevant use cases for weighted networks .",
    "an additional important motivation for weighted models concerns the ability to express and verify _ quality - of - service _ guarantees .",
    "for example , in a computer network ( providing limited resources ) , it can be useful to prioritize a certain flow ( e.g. , a voip call ) over another ( e.g. , a dropbox synchronization ) .",
    "[ exm - qos ] consider the switch in figure [ fig - qos ] .",
    "= [ fill = white , draw , text = black ] = [ thick , decoration = markings , mark = at position 1 with , double distance=1.4pt , shorten > = 5.5pt , preaction = decorate , postaction = draw , line width=1.4pt , white , shorten > = 4.5pt ] = [ semithick , white , line width=1.4pt , shorten > = 4.5pt ] ( s1 ) at ( 0,0 ) ; ( s2 ) at ( 0,-2 ) ; ( b1 ) at ( 2,-1 ) @xmath114 ; ( b2 ) at ( 4.3,-1 ) ;    ( s1 ) edge node[midway , above ] ( b1 ) ( s2 ) edge node[midway , above ] ( b1 ) ( b1 ) edge node[midway , above ] ( b2 ) ;    ( pt1 ) at ( 1.6,-0.65 ) _ 1 _ ; ( pt2 ) at ( 1.56,-1.38 ) _ 2 _ ; ( pt3 ) at ( 2.5,-1.15 ) _ 3 _ ;    \\(x ) at ( 2,-1.8 ) @xmath159 ;    it has two incoming ports @xmath160 and one outgoing port @xmath100 .",
    "suppose there are two types of traffic flows going through this switch : skype calls and web surfing traffic .",
    "this switch should respect that the skype calls have higher priority , but at the same time not completely disallow the web surfing .",
    "suppose we want to give skype calls 80% of the bandwidth and to web surfing only 20% .",
    "this policy can be easily specified with    the following _ wnetkat _ expression , where @xmath25 is a packet - variable specifying the priority of the packet ( e.g. , skype has high priority @xmath161 and http low @xmath162 ) and @xmath159 are two switch - variables for counting the number of packets with the two priorities respectively .",
    "+    @xmath163    the second line deals with high priority packets : if the amount of the packets with this priority is less than @xmath107 , then it will be sent out through port @xmath100 .",
    "similar for the low priority packets .",
    "the last line resets @xmath159 to @xmath31 when both reach the upper limit , triggering a new round of counting .      while , using switch - variables ( e.g. , as counters ) , @xmath0 supports a basic form of prioritization , allowing to provide one flow with a larger share of the bandwidth than another , this solution is still naive .",
    "for example , when a skype packet arrives at switch @xmath114 and @xmath164 is already @xmath107 , then this packet will be dropped , which might lower the quality of the skype call . in a even worse situation , in the absence of web traffic packets , the switch will still wait and drop all the incoming skype packets . to overcome these problems and improved notion of quality - of - service ,",
    "we could introduce a notion of _ queue_. indeed , queues , e.g. , annotated with different round robin weights , are an essential component in any computer network today , and are also the predominant mechanism to implement service differentiation .",
    "however , while openflow actions can readily be used to _ enqueue _ a packet in a certain queue ,",
    "it is the responsibility of the management plane ( and not the sdn control plane ) to actually allocate these queues and scheduling policies .",
    "while we currently witness first attempts to combine control and management planes  @xcite , today , there does not exist any standard .",
    "nevertheless , we in the following start exploring how  @xmath0 could be extended with a notion of queues .",
    "concretely , we can extend  @xmath0 by a set of queues , henceforth denoted by  @xmath165 , which are used for buffering packets which currently can not be forwarded due to limited resources .",
    "we will assume that all queues are fifo with normal queue related functions , e.g. , enqueue ( @xmath166 ) , dequeue ( @xmath167 ) , head of queue ( @xmath168 ) , etc .    for specifying the queue operations ,",
    "we extend  @xmath0 to allow _ enqueue _ and _ dequeue _ , where  @xmath169 :    * * enqueue *  @xmath170 : put the current packet into the queue  @xmath171 .",
    "the packet remains in the queue until being processed by the switch .",
    "* * dequeue *  @xmath172 : dequeue the first packet from the queue  @xmath171 and delete it from the queue .",
    "the semantics are defined in table  [ sem-2 ] , for  @xmath169 .",
    "@xmath173    _ remarks : _ equations ( 5 ) and ( 6 ) deal with the queues at the switches , by taking care of the detailed queue processing .",
    "notice that each switch can only manage its own queues .",
    "@xmath62    consider the same switch in example [ exm - qos ] .",
    "= [ fill = white , draw , text = black ] = [ thick , decoration = markings , mark = at position 1 with , double distance=1.4pt , shorten > = 5.5pt , preaction = decorate , postaction = draw , line width=1.4pt , white , shorten > = 4.5pt ] = [ semithick , white , line width=1.4pt , shorten > = 4.5pt ] ( s1 ) at ( 0,0 ) ; ( s2 ) at ( 0,-2 ) ; ( b1 ) at ( 2,-1 ) @xmath114 ; ( b2 ) at ( 4.3,-1 ) ;    ( s1 ) edge node[midway , above ] ( b1 ) ( s2 ) edge node[midway , above ] ( b1 ) ( b1 ) edge node[midway , above ] ( b2 ) ;    ( pt1 ) at ( 1.6,-0.65 ) _ 1 _ ; ( pt2 ) at ( 1.56,-1.38 ) _ 2 _ ; ( pt3 ) at ( 2.5,-1.15 ) _ 3 _ ;    \\(y ) at ( 2,-0.3 ) @xmath174 ; ( x ) at ( 2,-1.8 ) @xmath159 ;    however , there are two queues at the switch for high priority packets ( e.g. , skype packets ) and low priority ( e.g. , http packets ) packets respectively .",
    "different from example [ exm - qos ] , when a packet arrives at the switch @xmath114 , it will be put into the right queue first .",
    "this can be specified using the following , where @xmath25 is the packet - variable representing the priority .",
    "@xmath175    moreover , the switch also makes sure that the high priority queue is processed 80% of the time and the low priority queue 20% of the time .",
    "the following expression shows the case of high priority packets .",
    "+    @xmath176    the second line specifies that when @xmath177 is less than @xmath107 , we take the first packet of the high priority queue and send it through port @xmath100 .",
    "this is similar to non - queue case .",
    "the third line specifies the situation when @xmath177 already reached its upper limit , meaning that the high priority packets already used up the bandwidth assigned for them .",
    "however , the low priority queue is empty , i.e. , there is no low priority packet that needs to use the link .",
    "therefore , in this case , the high priority packets can use the low priority packets share .",
    "the fourth line specifies the case that the high priority packets already used up their share and need to wait for the low packets to go first .",
    "the last line tests whether the counters both reach their upper limit and if yes , reset both of them .",
    "related to the quality - of - service discussion above is also the question of how to model entire flows competing for a _ set _ of shared resources ( e.g. , along paths ) .",
    "while so far , all our use cases have been described in terms of packet and switch variables only , these concepts are insufficient to model contention across multiple resources .    in principle , it is simple to extend  @xmath0 with a notion of global variables which allows to account for such more global aspects . in practice however , supporting global variables can be inefficient : such variables can not be maintained by the switch , but require interactions with the controller .",
    "the latter introduces network loads and latencies , which can be undesirable , especially in wide - area network where the controller can be located remotely .",
    "in this section we shed light on the fundamental decidability of weighted sdn programming languages like wnetkat .",
    "given today s trend toward more quantitative networking , we believe that this is an important yet hardly explored dimension . in particular , we will establish an equivalence between wnetkat and weighted automata .    in the following",
    ", we will restrict ourselves to settings where quantitative variables of the same type behave similarly in the entire network : for example , the cost variables ( e.g. , quantifying latencies ) in the network are always added up along a given path , while capacity variables require minimum operations along different paths .",
    "this is a reasonable for real - world networks .",
    "the definition of the weighted automata used here is slightly different from those usually studied , e.g. ,  @xcite .",
    "however , it is easy to see that they are equivalent .",
    "we first introduce some preliminaries .",
    "a _ semiring _ is a structure @xmath178 , where @xmath179 is a commutative monoid , @xmath180 is a monoid , multiplication distributes over addition @xmath181 , and @xmath182 for each @xmath183 . for example ,",
    "@xmath184 and @xmath185 are semirings , named the _",
    "tropical semiring_. @xmath186 is also a semiring .",
    "bimonoid _ is a structure @xmath178 , where @xmath179 and @xmath180 are monoids .",
    "@xmath28 is called a _ strong bimonoid _ if @xmath187 is commutative and @xmath188 for each @xmath183 .",
    "for example , @xmath189 is a ( strong ) bimonoid , named the _",
    "tropical bimonoid_.    now fix a semiring / bimonoid @xmath28 and an alphabet @xmath190 . a _ weighted finite automaton _ ( wfa ) over @xmath28 and @xmath190",
    "is a quadruple @xmath191 where @xmath192 is a finite set of states , @xmath6 is the starting state , @xmath193 is set of the final states , @xmath194 is the transition weight function and @xmath195 is the weight of entering the automaton . for @xmath196 ,",
    "we write @xmath197 .",
    "let @xmath198 be the set of complete non - quantitative tests and @xmath199 be the set of complete non - quantitative assignments .",
    "let @xmath47 be the set of complete quantitative tests and @xmath200 be the set of complete quantitative assignments .",
    "a weighted netkat automata is a finite state weighted automaton @xmath201 over a structure @xmath28 and alphabet @xmath190 .",
    "the inputs to the automaton are so called reduced strings introduced in @xcite , which belong to the set @xmath202 , i.e. , the strings belonging to @xmath203 are of the form : @xmath204 for some @xmath205 . intuitively , @xmath206 attempts to consume @xmath207 from the front of the input string and move to a new state with a weight and the new state has the residual input string @xmath208 .",
    "the following construction shows the equivalence between wnetkat and weighted automata .    * from wfa to wnetkat",
    "*    let @xmath209 be a weighted netkat automata over @xmath28 and @xmath190 .",
    "an accepting path in @xmath2 @xmath210 can be write as the following wnetkat expression :    @xmath211 , where + 1 .",
    "@xmath212 , @xmath213 and @xmath214 for @xmath215 ; + 2 .",
    "@xmath216 for @xmath217 .    * from wnetkat to wfa",
    "*    let @xmath218 be a weighted automata expression , then following @xcite , we can define a set of reduced strings @xmath219 which are semantically equivalent to @xmath218 .",
    "we define a weighted netkat automata @xmath201 over a structure @xmath28 and alphabet @xmath190 , where + @xmath220 and @xmath221 .",
    "+ @xmath222 is defined as : @xmath223 iff @xmath224 for short write @xmath225 . + @xmath226 + @xmath227 + @xmath228    we have the following theorem .",
    "\\(1 ) for every finite weighted wnetkat automaton @xmath2 , there exists a wnetkat expression @xmath218 such that the set of reduced strings accepted by @xmath2 is the set of reduced strings of @xmath218 .",
    "( 2 )  for every wnetkat expression @xmath218 , there is a weighted wnetkat automaton @xmath2 accepting the set of the reduced strings of @xmath218 .",
    "let us just give some examples :    1 .",
    "for the cost reachability use case , there exists a weighted wnetkat automaton over the tropical semiring @xmath229 that accepts the set of reduced strings of the wnetkat expression in section  [ sec : app - cost ] .",
    "2 .   for the capacitated reachability : ( i ) there exists a weighted wnetkat automaton over the semiring @xmath186 that accepts the set of the reduced strings of the wnetkat expression for the splitable case in section [ sec : app - cap ] . ( ii )",
    "there exists a weighted wnetkat automaton over the tropical bimonoid @xmath230 that accepts the set of the reduced strings of the wnetkat expression for the unsplitable case in section  [ sec : app - cap ] .    from this relationship",
    ", we have the following theorem about the ( un)decidability of wnetkat expression equivalence .",
    "deciding equivalence of two wnetkat expressions is equal to deciding the equivalence of the two corresponding weighted wnetkat automata .",
    "for all the semiring and bimonoid we encountered in this paper , the wfa equivalence is undecidable . therefore , the equivalence is also undeciable .",
    "this negative result highlights the inherent challenges involved in complex network languages which are powerful enough to deal with weighted aspects .",
    "however , we also observe that in many practical scenarios , the above undecidability result is too general and does not apply .",
    "for example , most of the use cases presented in in section [ sec : applications ] can actually be reduced to test _ emptiness _ : we often want to test whether a given wnetkat expression @xmath218 equals @xmath31 , i.e. , whether the corresponding weighted netkat automaton is empty .",
    "indeed , there seems to exist an intriguing relationship between emptiness and reachability .",
    "deciding whether a wnetkat expression is equal to @xmath31 is equal to deciding the emptiness of the corresponding weighted automaton .",
    "interestingly , as shown in  @xcite , the emptiness problem is decidable for several semirings / bimonoids , e.g. , the tropical semiring and the tropical bimonoid used in this paper .",
    "this leads to the decidability of the wnetkat equivalence over these structures .",
    "another interesting domain with many decidability results are unambiguous regular grammars and unambiguous finite automata  @xcite .",
    "accordingly , in our future work , we aim to extend these concepts to the weighted world and explore the unambiguous subsets of wnetkat which might enable decidability for equivalence .",
    "we conclude with some remarks on compilation and compatibility to openflow . in general , openflow today does not accommodate _ stateful _ packet operations , and thus , per - connection or per - packet logic require involvement of the controller .",
    "moreover , openflow switches do not per se support arithmetic computations , such as addition of packet field values .    however , we currently witness a strong trend toward computationally more advanced and stateful packet - processing functionality . for example , the advent of programming protocol - independent packet processors like p4  @xcite , programming platform - independent stateful openflow applications inside the switch like openstate  @xcite , but also systems like snap  @xcite , pof  @xcite , or domino  @xcite introduce features which render these platforms potentially interesting compilation targets for @xmath0 . to give another example",
    ", open vswitch allows running on - hypervisor `` local controllers '' in addition to a remote , primary controller , to introduce a more stateful packet processing .",
    "nevertheless , we observe that several features of _ today s _ openflow versions can be exploited for the compilation of @xmath0 expressions .",
    "for example , in order to implement arithmetic operations ( see e.g. , equations ( 3 ) and ( 4 ) ) , we can simply use lookup tables realized as openflow rules , see the technique in  @xcite .",
    "thus , cost reachability queries can be compiled to flow tables similarly as in netkat .",
    "interestingly , however , also a simple form of switch state can readily be implemented in openflow today .",
    "indeed , openflow switches provide stateful features such as group tables , packet counters , bandwidth meters , etc .",
    "for example , a simple yet inefficient solution to compile @xmath0 switch variables is to use either the meta - rule approach taken by schiff et al .",
    "@xcite ( introducing additional flow rules ) , or to leverage round robin groups  @xcite . finally , we note that while openflow actions can be used to forward packets to specific queues , the scheduling regime for the queues is defined via the management plane  @xcite .",
    "in our future research , we aim to chart a more comprehensive landscape of the decidability and decision complexity of  @xmath0 . in the longer term",
    ", we also aim to extend  @xmath0 to support probabilistic aspects of networking .",
    "we would like to thank alexandra silva , nate foster , and dexter kozen for many inputs and discussions on wnetkat .",
    "n.  foster , r.  harrison , m.  j. freedman , c.  monsanto , j.  rexford , a.  story , and d.  walker .",
    "frenetic : a network programming language . in _ proc .",
    "16th acm sigplan international conference on functional programming ( icfp ) _ , pages 279291 , 2011 .",
    "d.  kirsten .",
    "the support of a recognizable series over a zero - sum free , commutative semiring is recognizable . in _ developments in language theory , 13th international conference , dlt 2009 , stuttgart , germany , june 30 - july 3 , 2009 .",
    "proceedings _ , pages 326333 , 2009 .",
    "r.  e. stearns and h.  b. hunt . on the equivalence and containment problems for unambiguous regular expressions , grammars , and automata . in _ proc .",
    "22nd annual symposium on foundations of computer science ( sfcs ) _ , 1981 ."
  ],
  "abstract_text": [
    "<S> programmability and verifiability lie at the heart of the software - defined networking paradigm . while openflow and its match - action concept provide primitive operations to manipulate hardware configurations , over the last years , several more expressive network programming languages have been developed . </S>",
    "<S> this paper presents  @xmath0 , the first network programming language accounting for the fact that networks are inherently weighted , and communications subject to capacity constraints ( e.g. , in terms of bandwidth ) and costs ( e.g. , latency or monetary costs ) . </S>",
    "<S> @xmath0 is based on a syntactic and semantic extension of the netkat algebra . </S>",
    "<S> we demonstrate several relevant applications for  @xmath0 , including cost- and capacity - aware reachability , as well as quality - of - service and fairness aspects . </S>",
    "<S> these applications do not only apply to classic , splittable and unsplittable  @xmath1-flows , but also generalize to more complex network functions and service chains . </S>",
    "<S> for example , @xmath0 allows to model flows which need to traverse certain waypoint functions , which may change the traffic rate . </S>",
    "<S> this paper also shows the relation between the equivalence problem of wnetkat and the equivalence problem of the weighted finite automata , which implies undecidability of the former . </S>",
    "<S> however , this paper also succeeds to prove the decidability of another useful problem , which is sufficient in many practical scnearios : whether an expression equals to 0 . </S>",
    "<S> moreover , we initiate the discussion of decidable subsets of the whole language . </S>"
  ]
}