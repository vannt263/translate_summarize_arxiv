{
  "article_text": [
    "in the last years , radio frequency identification ( rfid ) systems have received much attention both in academia and in many industries , for applications of monitoring and tracking .",
    "rfid systems offer a promisingly affordable , cheap and flexible solution for object identification .",
    "for instance , fast and reliable reading of labels ( tags ) attached to different objects stowed in warehouses can greatly speed up operations such as localization and retrieval . among the countless applications",
    ", we can cite public transportation and ticketing , access control , production control , animal identification , inventory control , electronic payments , speed - up the checkout in shops , location monitoring in real - time of all tagged objects within the supply chain , secure operations in dangerous environments , localization of objects ( like cars in parking lots , or books in libraries ) , and of people .",
    "rfid systems consist of networked electromagnetic readers and tags , where the readers try to identify the tags attached to objects .",
    "the reader is an entity with great computation power and memory , while tags have ( very ) limited computation resources .",
    "tags have a unique i d and transmit their own i d to the reader for being identified .",
    "the reader must be able to identify tags as quickly as possible by wireless communications .",
    "rfid tags can be _ active _ or _ passive _ , according to their technology @xcite .",
    "active tags are continually powered by internal batteries , while passive tags have no internal power and reflect energy from the reader for communication .",
    "consequently , active tags can be read from a greater distance than passive tags . moreover , active tags have more functions than passive tags , e.g. data storage and sensor capabilities .",
    "tags have to be very simple in order to be as cheap as possible .",
    "the lifetime of active tags is over when the battery is exhausted .",
    "it is non economical to replace or recharge an active tag battery , because of large number of small and cheap nodes . for these reasons ,",
    "active tags are not practical for use with disposable consumer products , for instance .",
    "passive tags instead rely only on rf energy induced by the electromagnetic waves emitted by the reader . in a typical communication sequence ,",
    "the reader emits a continuous radio frequency wave .",
    "when a tag enters in the rf field of the reader , it receives energy from the field .",
    "continuous advancements in protocols and circuits design , make the reliability and the reading range of passive tags rfid systems continuously improving . besides , their cost continues to decrease , leading to an increase of their applications . to meet",
    "cost , size and lifetime requirements , passive tags seem to be the best solution for rfid systems , and we focus on them in this paper .    the limited available bandwidth forces all tags to share a common broadcast wireless channel .",
    "this can lead to the collision problem in signal transmission of the readers or the tags , which hardly leads to fast identification . as a result , either the reader may not recognize all objects , or a tag identification process may suffer from long delay . therefore ,",
    "anti - collision protocols which enable the fast and correct identification regardless of the occurrence of collisions are required .",
    "collisions are divided into reader collisions @xcite and tag collisions .",
    "reader collision problems arise when multiple readers are simultaneously used @xcite .",
    "the other collision problem ( approached in this paper ) is the tag collision one , that occurs when several tags try to answer to a reader query at the same time .",
    "the reader queries the tags for their i d through the rf communication channel , by broadcasting a request message to tags . upon receiving this message , all tags",
    "send an answer back to the reader .",
    "if only one tag answers , the reader identifies the tag .",
    "if more than one tag answer , their messages will collide on the rf communication channel , and the reader can not identify these tags .",
    "this is a special case of the multiple - access communication problem .",
    "however , rfid applications introduce a more challenging aspect to the problem . since the low functional power and energy constraints in each tag , it is unreasonable to assume that tags can communicate with each other directly , and that they can notice their neighboring tags or detect collisions .",
    "tags anti - collision protocols are required for identification in rfid systems .",
    "a natural question is : what is the best communication protocol so that the tags can be read as fast and reliable as possible ?",
    "this is known as anti - collision problem .",
    "the issue becomes more challenging on considering that the tags must be simple , cheap and small enough .",
    "there are two families of protocols for approaching the tag collision problem : a family of _ probabilistic _ protocols , and a family of _ deterministic _ ones .",
    "we will survey both families in section  [ section : relatedwork ] . in this paper",
    ", we propose a new anti - collision protocol which , assuming a particular rfid system simple technology , achieves an optimal performance outperforming all existing protocols .    the paper is organized as follows . in section  [ section :",
    "relatedwork ] , we survey the known suitable protocols for our problem . in section  [ section :",
    "theprotocol ] , we describe our approach , by highlighting the assumptions we made , and the achieved performance , in terms of number of reader queries . in section  [ section :",
    "correctness ] , we assess the protocol performance . conclusions ( section  [ section : conclusions ] ) terminate the paper .",
    "the proposed protocols for tag collision resolution in rfid systems are either probabilistic or deterministic .",
    "the first ones are _ aloha - based _ protocols @xcite , the last ones are _ tree - based _",
    "protocols @xcite .",
    "there are also hybrid approaches , where randomization is applied in tree schemes @xcite .",
    "aloha - based protocols , such as aloha , slotted aloha , framed slotted aloha , and dynamic framed slotted aloha , reduce the probability of the occurrence of tag collisions since tags try to answer at distinct times .    in framed slotted aloha ,",
    "a frame is a time interval between requests of a reader and consists of a number of slots .",
    "each tag transmits its serial number to the reader in a randomly selected slot of a frame , and the reader identifies tags when a time slot is used by one tag only .",
    "read cycles are repeated for unrecognized ( namely , whose transmission results in a collision ) tags , until all tags have been identified .",
    "so , in the last read cycle there must be no collision .",
    "the basic framed slotted aloha anti - collision protocol @xcite uses a fixed frame size and does not change the size during the process of tag identification .",
    "the dynamic framed slotted aloha @xcite protocol changes the frame size dynamically .",
    "the constraint of this protocol is that the frame size can not be increased indefinitely as the number of tags increases , but it has an upper bound .",
    "this implies a very high number of collisions when the number of tags exceeds the maximum admitted frame size .",
    "the enhanced dynamic framed slotted aloha ( edfsa ) protocol , analyzed in @xcite , overcomes such problem by dividing the unread tags into a number of groups and interrogating each group of them respectively .",
    "the system efficiency of edfsa protocol is improved by the variant enhanced dynamic framed slotted aloha protocol @xcite where a dynamic group dividing approach is adopted .",
    "the frame size affects the performance of aloha based algorithms .",
    "a small frame size results in many collisions , and so increases the required total number of slots when the number of tags is high .",
    "in contrast , a large frame size may result in more idle time slots , when the number of tags is small .",
    "different methods estimating the number of unread tags , permit to the reader of choosing an optimal frame size for the next read cycle , are presented in @xcite .    in @xcite ,",
    "the tree slotted aloha ( tsa ) protocol is proposed .",
    "it aims to reduce tag transmission collisions by querying only those tags colliding in the same slot of a previous frame of transmissions . at the end of each frame , for each slot in which a collision occurred , the reader starts a new small frame , reserved to those tags which collided in the same time slot . in this way , a transmission frame can be viewed as a node in a tree , where the root is the initial frame ; leaves represent frames where no collision occurred .",
    "aloha - based protocols can not perfectly prevent collisions .",
    "in addition , they have the serious problem that a tag may not be identified for an unlimited time ( the so called _ tag starvation problem _ ) .",
    "tree - based tag anti - collision protocols can have a longer identification delay than slotted aloha based ones , but they are able to avoid the tag starvation . among tree - based protocols ,",
    "there are binary search protocols @xcite and query tree protocols @xcite .    in query tree protocol ( qt )",
    ", the reader sends a prefix , and all tags having the i d matching the prefix , answer . if there is a collision , the reader queries for a one bit longer prefix , until no collision occurs .",
    "once a tag is identified , the reader starts a new round of queries with another prefix . in @xcite ,",
    "many improvements of qt protocol have been presented , for increasing its performance . among them , the best performing one is called query tree improved @xcite .",
    "this protocol avoids the queries that certainly will produce collisions .",
    "since tags do not need additional memory except the i d , query tree protocols have the advantage to be _ memoryless _ , and for this they require low functional and less expensive tags .",
    "however , since they use prefixes , their performance is sensitive to the distribution of tag ids which a reader have to identify .    in @xcite ,",
    "a prefix - randomized query tree protocol is proposed , where tags randomly choose the prefixes rather than using their id - based ones .",
    "the identification time of this protocol is improved with respect to qt protocol because it is no longer affected by the length and distribution of tag ids as in qt protocol .    in binary search protocols , @xcite , the reader performs identification by recursively splitting the set of answering tags .",
    "each tag has a counter initially set to zero . only tags with counter set to zero answer the reader s queries .",
    "after each tag transmission , the reader notifies the outcome of the query : collision , identification , or no - answer .",
    "when tag collision occurs , each tag with counter set to zero , adds a random binary number to its counter .",
    "the other tags increase by one their counters .",
    "in such a way , the set of answering tags is randomly split into two subsets . after a no - collision transmission",
    ", all tags decrease their counters by one .    in @xcite , the bi - slotted query tree algorithm , and bi - slotted collision tracking tree algorithm",
    "are proposed .",
    "they reduce the prefix overhead for fast tag identification .",
    "myung et al .",
    "@xcite proposed two adaptive tag anti - collision protocols : the adaptive query splitting protocol which is an improvement of the query tree protocol , and the adaptive binary splitting protocol which is based on the binary tree protocol . for reducing collisions ,",
    "the proposed protocols use information obtained from the last process of tag identification , assuming that in most object tracking and monitoring applications the set of rfid tags encountered in successive reading from a reader does not change substantially and information from a reading process can be used for the next one .",
    "an improvement of adaptive binary splitting protocol is proposed in @xcite .",
    "performance for tags collision problem , is usually computed as the ratio between the number of tags to be identified , and the number of queries ( or time slots , in case of slotted aloha based protocols ) performed in the whole identification process .",
    "this metric is referred as _",
    "system efficiency _ @xcite .",
    "all the protocols proposed so far exhibit an average performance ( both in terms of messages and in terms of transmitted bits , two metrics strictly related to system efficiency ) well below 50% .",
    "actually , the best performing protocols , namely qt and tsa , perform around 40% of system capacity on average , in their best performing versions @xcite .",
    "such results are reported in the above papers , where the protocols have been proposed , and were substantially confirmed in a paper @xcite describing an extensive simulation experiment set up for assessing the average performance of several tag identification protocols .    in this paper we propose an optimum tag identification protocol that outperforms , at the best of our knowledge , all existing protocols .",
    "we assume a particular simple rfid system technology that we describe in section [ subsection : system ] , and we show in section  [ section : correctness ] that by using this rfid system technology , our protocol achieves a system efficiency of 100% , and so perfectly solves the problem .",
    "in this section , we first state the assumptions made on the transmission techniques used by the target rfid systems .",
    "then , we give a detailed description of our protocol .      in this paper",
    ", we assume that signals transmitted by multiple entities sum up at the receiver , with no loss of information .",
    "besides , we assume ( as usual in this setting ) that the signal corresponding to a bit equal to 0 is the complement of that corresponding to a bit equal to 1 ( this is what happens , for instance , when a manchester bit coding is used )",
    ". we shall call such signals `` -1 '' and `` + 1 '' , respectively . for instance , if we have four tags with ids 011010 , 010101 , 110001 , 011111 , the simoultaneous transmission of their i d will be received by the reader as `` -2 4 0 0 0 2 '' . from the collided tags answers , a reader can detect the exact number of transmitting tags , provided that all such tags have transmitted the same bit ( say `` 1 '' ) in the same position ( say , the second one ) . in this case",
    ", the maximum ( in absolute value ) of the received signals is equal to the number of transmitting tags . in the above example",
    ", all four tags transmit a `` + 1 '' in second position .",
    "however , this is not always the case : consider for example the above tags , with the first one having a `` 0 '' in second position , instead of a `` 1 '' .",
    "then , the signals received by the reader would be `` -2 2 0 0 0 2 '' .",
    "this sort of `` capture effect '' prevents from exactly knowing the number of answering tags .",
    "as we shall see , this is not a problem since our protocol works in splitting the tags in two subsets , with possibly one subset containing only one tag ( thus identifying it ) .",
    "the important thing is that , when there are multiple answering tags , the received signal is not formed by `` + 1 '' and `` -1 '' only .",
    "this happens only when the number of `` 0 '' bits and that of `` 1 '' bits differ by exactly one . in this case",
    ", we have a `` false positive '' , namely we identify one tag that is not present in our set , whose i d is given by the sum of the ids of the colliding tags .",
    "for example , if ids `` 0 1 1 0 0 1 '' , `` 0 0 1 0 1 0 '' , `` 1 0 0 1 0 0 '' are transmitted simultaneously , the reader will receive `` 0 0 1 0 0 0 '' which does not correspond to any i d of tags in its range .",
    "notice that tag ids are 48 , 96 , ... ,",
    "bits long , and so the probability of this `` false positive '' is extremely low .",
    "anyway , the above problem can be overcome by adding a one bit prefix to each i d , so forcing each tag to transmit a `` + 1 '' ( for instance ) before their i d .",
    "the cost of this is obviously negligible , given the above reported i d s lengths .      given the above assumptions , it is possible to build a protocol which always achieves a 100% performance .",
    "the protocol , called @xmath0 , works as follows .",
    "initially , the reader asks all tags to transmit their own complete i d . from the answer , which is the sum of all ids , the reader starts to divide the set of tags in a recursive way until all tags are identified .",
    "the partioning is done in the following manner : the reader chooses the first bit position , say @xmath1 , for which the answer presents the maximum absolute value , say @xmath2 .",
    "two cases can occur :    @xmath3 : : :    @xmath4 in this case , a tag i d is recognized ; @xmath5 : : :    @xmath4 in this case , the reader searches the first position ,    say @xmath6 , where a value , say @xmath7 , equal to    the largest absolute value smaller than @xmath2 is present in    the previous answer .",
    "then , it issues a new query by asking all tags    having  1 \" in position @xmath6 , with the same sign of    @xmath7 .",
    "then , the reader repeats the above procedure with    the outcome of the last query .",
    "when a tag i d is recognized , the reader obtains another tag i d or the sum of more than one tag i d , by subtracting the recognized i d from the previous answer , so without issuing any query . by recursively applying the previous procedure , the reader always splits the responding tags into two groups : one having  + 1 \" in a given position , the other having  -1 \" in the same position .",
    "since any two tag ids differ in at least one bit position , the protocol converges to a complete identification of all tags .    in table",
    "[ tab : pseudocode ] , we sketch the behavior of protocol @xmath0 . when the reader issues a query , it transmits a _ mask _ of bits of the same length of tag ids ( @xmath8 in the pseudocode ) , initially empty ( empty value is coded with `` 0 '' ) .",
    "tags have their ids stored with `` -1 '' instead of `` 0 '' , and in table  [ tab : pseudocode ] such an i d is referred as @xmath9 .    in figure",
    "[ figure : example ] , we show the execution of @xmath0 protocol on a set of seven tags .",
    "the queries issued by the reader are represented with bold arrows between father nodes and left son nodes .",
    "arrows between father nodes and right son nodes , instead , represent ids sums obtained by difference between the previous and the actual answers . as evident from the figure ,",
    "the execution of @xmath0 protocol is equivalent to a depth first search ( dfs ) on the tree , where the leaves represent the ids of the tags to be identified .",
    "notice that tag hardware is very simple : tags have only to listen the reader queries and answer if the received mask matches with their own i d .",
    "so tags are memoryless .",
    "a = aaa = aa = aa = aa a +    _ /*initialization*/ _     + 1 .",
    "@xmath10 @xmath11=0 $ ] ; +    _ /*ask all tags for transmitting their id*/ _     + 2 .",
    "broadcast(@xmath12 ) ; +    _ /*put the sum of i d signals in an array called @xmath13*/ _     + 3 .",
    "@xmath14 getids ( ) ; +    _ /*analyse the result*/ _     + 4 .",
    "+   +   + @xmath15 : +    _ /*find the maximum absolute value present in @xmath13 and put it in @xmath2 * / _     + 1 .",
    "@xmath16 max absolute value in @xmath13 ; +    _ /*if",
    "@xmath2 equals 1 , a tag is identified*/ _     + 2 .",
    "( @xmath3 ) * then * + 3 .",
    "tag with i d equal to @xmath13 is identified ; + 4 . return ; +    _ /*if",
    "@xmath5 then the reader needs more queries*/ _     + 5 .",
    "( @xmath5 ) * then * +    _ /*find the second maximum absolute value in @xmath13 and put it in @xmath7*/ _     + 6 .",
    "@xmath17 second max absolute value in @xmath13 ; + 7 .",
    "@xmath18 bit position corresponding to @xmath7 ; +    _ /*@xmath19 gets @xmath20 with the same sign of @xmath21$]*/ _     + 8 . ( @xmath21\\geq 0 $ ] ) * then * @xmath22 `` + 1 '' ; + 9 .",
    "@xmath22 `` -1 '' ; +    _ /*set the bit mask before broadcasting it*/ _     + 10 .",
    "@xmath23=s2 $ ] ; +    _ /*issue the query*/ _",
    "broadcast(@xmath12 ) ; +    _ /*put the sum of i d signals in an array called @xmath24*/ _     + 12 .",
    "@xmath25 getids ( ) ; +    _ /*analyse the result*/ _     + 13 .",
    "@xmath26 ; +    _ /*set the mask for being used in the right subtree*/ _     + 14 .",
    "@xmath23=-s2 $ ] ; +    _ /*analyse the sum of ids obtained by difference*/ _     + 15 .",
    "+    _ /*reset the mask*/ _     + 16 .",
    "@xmath23=0 $ ] ; +   + * tag procedure : * + 1.(true ) + 2 .",
    "wait for reader transmission ; + 3 .",
    "( @xmath9 matches @xmath12 ) * then * transmit @xmath9 ; +",
    "in this section , we formally show that the above protocol always achieves 100% performance , provided that the transmission assumptions are met .",
    "[ lemmauno ] the execution of protocol @xmath0 for identifying @xmath28 tags can be represented by a full binary tree with @xmath29 nodes .",
    "a full binary tree is a tree in which every node has zero or two sons @xcite .",
    "@xmath0 works by dividing the tags set into two subsets : each subset is represented by a node in the full binary tree .",
    "when a set is partitioned by querying the tags having a given value (  + 1 \" or  -1 \" ) in a given bit position , the resulting two subsets are the sons of the node associated to the previous set . the subset related to the left son",
    "is obtained by query , while the other set ( the right son ) is obtained by difference between the previous answer ( father ) and the current answer ( left son ) .",
    "then , all the queries done by the reader are associated with all the edges between father and left son , in addition to the first query , whose answer is associated with the root of the full binary tree .",
    "a node associated with a subset with cardinality equal to one , is a leaf and it represents an identified tag .",
    "so , the number of leaves of the tree is @xmath28 ( the number of tags ) .",
    "it is well known that any full binary tree with @xmath28 leaves has @xmath29 nodes @xcite .",
    "given the above lemma , we are able to state the following theorem .",
    "protocol @xmath0 achieves always a 100% performance .",
    "due to leamma  [ lemmauno ] , every execution of @xmath0 for identifying @xmath28 tags , is equivalent to a full binary tree with @xmath29 nodes .",
    "queries are as many as the links between fathers and left sons of the associated full binary tree , plus one for the root .",
    "so , if the associated full binary tree has @xmath29 nodes , it has @xmath30 left sons . adding the root , we obtain that the number of queries is equal to @xmath28 .    on the other hand , a full binary tree with @xmath29 nodes ,",
    "has @xmath28 leaves @xcite .",
    "since leaves represent subsets with cardinality equal to one , they represent the tags participating to the identification process .",
    "so , the number of queries is equal to the number of tags .",
    "this means that @xmath0 always achieves the 100% performance .",
    "in this paper , we investigated the tags collision problem in rfid systems .",
    "we presented a novel protocol , and showed that its performance is 100% , provided that some assumptions on i d transmissions and receptions are met .",
    "the protocol outperforms the currently known protocols for the same problem . as the most important open problem",
    ", we cite the performance evaluation of our protocol when the assumptions made do not hold .",
    "m. nanjundaiah and v. chaudhary , improvement to the anticollision protocol specification for 900mhz class 0 radio frequency identification tag . in _ proc . of the 19@xmath31 int .",
    "conf . on advanced information networking and applications , aina05 _ , 2005 , pp .",
    "616620 .",
    "m.  a. bonuccelli , f.  lonetti , and f.  martelli .",
    "tree slotted aloha : a new protocol for tag identification in rfid networks . in _ proc .",
    "of ieee int .",
    "symposium on a world of wireless , mobile and multimedia networks _ , pp . 603608 , jun . 2006 .        c.  law , k.  lee , and k .- y .",
    "siu , efficient memoryless protocol for tag identification ( extended abstract ) . in _ proc .",
    "workshop on discrete algorithms and methods for mobile computing and communications ( dialm 00 ) _ ,",
    "new york , usa , 2000 , pp .",
    "7584 .",
    "a. micic , a. nayac , d. simplot - ryl and i. stojmenovic , a hybrid randomized protocol for rfid tag identification . in _",
    "1st ieee int .",
    "workshop on next generation wireless networks ( wongen 05)_. dec .",
    "2005 .",
    "j. myung , w. lee , j. srivastava and t.k .",
    "shih , tag - splitting : adaptive collision arbitration protocols for rfid tag identification . in _",
    "ieee trans . on parallel and",
    "distributed systems _ , vol . 18 ( 6 ) , pp .",
    "763 - 775 , jun . 2007 .",
    "q. peng , m. zhang and w. wu , variant enhanced dynamic frame slotted aloha algorithm for fast object identification in rfid system . in _ proc . of ieee int .",
    "workshop on anti - counterfeiting , security , identification _ , pp .",
    "88 - 91 , apr . 2007 .",
    "chen , s .-",
    "horng and p. fan , an enhanced anti - collision algorithm in rfid based on counter and stack . in _ proc . of the second int",
    ". conf . on systems and networks communications",
    "21 , aug . 2007 .",
    "j. park , m.y .",
    "chung and t.j .",
    "lee , identification of rfid tags in framed - slotted aloha with robust estimation and binary selection . in _ ieee communications letters _ ,",
    "11 ( 5 ) , pp .",
    "452454 , may 2007 ."
  ],
  "abstract_text": [
    "<S> radio frequency identification ( rfid ) systems are becoming more and more popular in the field of ubiquitous computing , in particular for objects identification . </S>",
    "<S> an rfid system is composed by one or more readers and a number of tags . </S>",
    "<S> one of the main issues in an rfid network is the fast and reliable identification of all tags in the reader range . </S>",
    "<S> the reader issues some queries , and tags properly answer . </S>",
    "<S> then , the reader must identify the tags from such answers . </S>",
    "<S> this is crucial for most applications . </S>",
    "<S> since the transmission medium is shared , the typical problem to be faced is a mac - like one , i.e. to avoid or limit the number of tags transmission collisions . </S>",
    "<S> we propose a protocol which , under some assumptions about transmission techniques , always achieves a 100% perfomance . </S>",
    "<S> it is based on a proper recursive splitting of the concurrent tags sets , until all tags have been identified . </S>",
    "<S> the other approaches present in literature have performances of about 42% in the average at most . </S>",
    "<S> the counterpart is a more sophisticated hardware to be deployed in the manufacture of low cost tags . </S>"
  ]
}