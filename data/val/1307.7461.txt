{
  "article_text": [
    "successful deployment of robotic assistants in our society requires these systems to deal with high complexity and wide variability of their surroundings to perform typical everyday tasks robustly and without sacrificing safety .",
    "consequently , there exists a pressing need to furnish these robotic systems not only with discrete high - level reasoning ( e.g. , task planning , diagnostic reasoning ) and continuous low - level reasoning ( e.g. , trajectory planning , deadline and stability enforcement ) capabilities , but also their tight integration resulting in hybrid planning .    motivated by the importance of hybrid planning , recently there have been some studies on integrating discrete task planning and continuous motion planning .",
    "these studies can be grouped into two , where integration is done at the search level or at the representation level .",
    "for instance , @xcite take advantage of a forward - search task planner to incrementally build a task plan , while checking its kinematic / geometric feasibility at each step by a motion planner ; all these approaches use different methods to utilize the information from the task - level to guide and narrow the search in the configuration space . by this way",
    ", the task planner helps focus the search process during motion planning .",
    "each one of these approaches presents a specialized combination of task and motion planning at the search level , and does not consider a general interface between task and motion planning .    on the other hand , @xcite integrate task and motion planning by considering a general interface between them , using `` external predicates / functions '' , which are predicates / functions that are computed by an external mechanism , e.g. , by a c++ program .",
    "the idea is to use external predicates / functions in the representation of actions , e.g. , for checking the feasibility of a primitive action by a motion planner .",
    "so , instead of guiding the task planner at the _ search level _ by manipulating its search algorithm directly , the motion planner guides the task planner at the _ representation level _ by means of external predicates / functions .",
    "@xcite apply this approach in the action description language @xmath0 @xcite using the causal reasoner  @xcite ; @xcite applies it in answer set programming ( asp )  @xcite using the asp solver  @xcite ; @xcite extends the planning domain description language pddl @xcite to support external predicates / functions ( called semantic attachments ) and modifies the planner ff @xcite accordingly .",
    "in these approaches , integration of task and motion planning is achieved at various levels .",
    "for instance , @xcite do not delegate all sorts of feasibility checks to external predicates as in @xcite , but implements only some of the feasibility checks ( e.g. , checking collisions of robots with each other and with other objects , but not collisions of objects with each other ) as external predicates and use these external predicates in action descriptions to guide task planning . for a tighter integration ,",
    "feasibility of task plans is checked by a dynamic simulator ; in case of infeasible plans , the planning problem is modified with respect to the causes of infeasibilities , and the task planner is asked to find another plan .    in this paper ,",
    "our goal is to better understand how much of integration between high - level reasoning and continuous low - level reasoning is useful , and for what sort of robotic applications .",
    "for that , we consider integration at the representation level , since this approach allows a modular integration via an interface , external predicates / functions , which provides some flexibility of embedding continuous low - level reasoning into high - level reasoning at various levels .",
    "such a flexible framework allowing a modular integration is important for a systematic analysis of levels of integration .",
    "we identify four distinct strategies to integrate a set of continuous feasibility checks into high - level reasoning , grouped into two : _ directly integrating _ low - level checks into high - level reasoning while a feasible plan is being generated , and generating candidate plans and then _ post - checking _ the feasibility of these candidate solutions with respect to the low - level checks . for direct integration we investigate two methods of integration : ( i ) low - level checks are done for all possible cases in advance and then this information is used during plan generation , ( ii ) low - level checks are done when they are needed during the search for a plan . for post - checking",
    "we look at two methods of integration : ( iii ) all plans are computed and then infeasible ones are filtered , ( iv ) by means of replanning , after finding a plan , low - level checks identify whether it is infeasible or not ; if it is infeasible , a new plan is computed considering the results of previous low - level checks .",
    "we consider these four methods of integration , as well as some of their combinations ; for instance , some geometric reasoning can be integrated within search as needed , whereas some temporal reasoning is utilized only after a plan is computed in a replanning loop . considering each method and",
    "some of their combinations provide us different levels of integration .",
    "to investigate the usefulness of these levels of integration at representation level , we consider 1 ) the expressive formalism of hex  programs for describing actions and the efficient hexsolver  to compute plans , and 2 ) the expressive formalism of asp programs for describing actions and the efficient asp solver to compute plans . unlike the formalisms and solvers used in other approaches  @xcite , that study integration at representation level , hex  @xcite and  @xcite allow external predicates / functions to take relations ( e.g. , a fluent describing locations of all objects ) as input without having to explicitly enumerate the objects in the domain .",
    "other formalisms and solvers allow external predicates / functions to take a limited number of objects and/or object variables as input only , and thus they do not allow embedding all continuous feasibility checks in the action descriptions . in that sense , the use of hexprograms with , along with the asp programs with enriches the extent of our experiments .",
    "we perform experiments on planning problems in a robotic manipulation domain ( like in  @xcite ) and in a legged locomotion domain ( like in  @xcite ) .",
    "robotic manipulation domain involves 3d collision checks and inverse kinematics , whereas legged locomotion involves stability and reachability checks .",
    "we analyze the usefulness of levels of integration in these domains , both from the point of view of computational efficiency ( in time and space ) and from the point of view of plan quality relative to its feasibility .",
    "assume that we have a task planning problem instance @xmath1 ( consisting of an initial state @xmath2 , goal conditions , and action descriptions ) in a robotics domain , represented in some logic - based formalism .",
    "a history of a plan @xmath3 from the given initial state @xmath2 to a goal state @xmath4 computed for @xmath1 consists of a sequence of transitions between states : @xmath5 . a _",
    "low - level continuous reasoning module _ gets as input , a part of a plan history computed for @xmath1 and returns whether this part of the plan history is feasible or not with respect to some geometric , dynamic or temporal reasoning .",
    "for example , if the position of a robot at step @xmath6 is represented as @xmath7 and the robot s action of moving to another location @xmath8 at step @xmath6 is represented as @xmath9 , then a motion planner could be used to verify feasibility of the movement @xmath10 @xmath11 . if duration of this action is represented as well , e.g. , as @xmath12 , then the low - level module can find an estimate of the duration of this movement relative to the trajectory computed by a motion planner , and it can determine the feasibility of the movement @xmath13 by comparing this estimate with @xmath14 .",
    "let @xmath15 denote a low - level reasoning module that can be used for the feasibility checks of plans for a planning problem instance @xmath1 .",
    "we consider four different methods of utilizing @xmath15 for computing feasible plans for @xmath1 , grouped into two : _ directly integrating _",
    "reasoning @xmath15 into @xmath1 , and _ post - checking _",
    "candidate solutions of @xmath1 using @xmath15 .    for",
    "_ directly integrating _ low - level reasoning into plan generation , we propose the following two levels of integration :    * * pre *  _ precomputation _ we perform all possible feasibility checks of @xmath15 that can be required by @xmath1 , in advance . for each failed check , we identify actions that cause the failure , and then add a constraint to the action descriptions in @xmath1 ensuring that these actions do not occur in a plan computed for @xmath1 .",
    "we then try to find a plan for the augmented planning problem instance @xmath16 .",
    "clearly , every plan obtained with this method satisfies all low - level checks . * * int *  _ interleaved computation _ we do not precompute but we interleave low - level checks with high - level reasoning in the search of a plan : for each action considered during the search , the necessary low - level checks are immediately performed to find out whether including this action will lead to an infeasible plan .",
    "an action is included in the plan only if it is feasible .",
    "the results of feasibility checks of actions can be stored not to consider infeasible actions repeatedly in the search of a plan .",
    "plans generated by interleaved computation satisfy all low - level checks .",
    "let us denote by @xmath17 and @xmath18 the low - level checks directly integrated into plan generation , with respect to preand int , respectively .",
    "alternatively , we can integrate low - level checks @xmath15 with @xmath1 , by means of _ post - checking _",
    "candidate solutions of @xmath1 relative to @xmath15 .",
    "we propose the following two methods to perform post - checks on solution candidates :    * * filt *  _ filtering _ : we generate all plan candidates for @xmath1 . for each low - level check in @xmath15",
    ", we check feasibility of each plan candidate and discard all infeasible candidates . * * repl *  _ replanning _ : we generate a plan candidate for @xmath1 . for each low - level check in @xmath15 , we check feasibility of the plan candidate . whenever a low - level check fails , we identify the actions that cause the failure , and then add a constraint to @xmath1 ensuring that these actions do not occur in a plan computed for @xmath1 .",
    "we generate a plan candidate for the updated planning problem instance @xmath19 and do the feasibility checks .",
    "we continue with generation of plan candidates and low - level checks until we find a feasible plan , or find out that such a feasible plan does not exist .",
    "let us denote by @xmath20 the low - level checks done after plan generation , with respect to filtor repl .    figure  [ fig : flows ] shows the hybrid planning framework we use in this paper to compare different levels of integration , and combinations thereof , on robotics planning scenarios . in particular , fig .",
    "[ fig : flows ] depicts computational components : precomputation extends the problem instance @xmath1 using a low - level reasoning module @xmath17 , planning integrates a low - level reasoning module @xmath18 into its search for a plan candidate for the problem instance @xmath16 generated by precomputation .",
    "postcheck uses a low - level module @xmath20 to verify solution candidates ( using filtor repl ) and to potentially add constraints @xmath19 to the input of planning .    in our systematic analysis of levels of integration",
    ", we do consider this hybrid framework by disabling some of its components .",
    "for instance , to analyze the usefulness of pre , we disable the other integrations ( i.e. , @xmath21 ) ; to analyze the usefulness of a combination of preand filt , we disable other integrations ( i.e. , @xmath22 ) .",
    "we investigate the usefulness of levels of integration as described above , considering two orthogonal properties : solution quality and planning efficiency .",
    "we quantify these properties as follows .",
    "( pre ) precomputation ; ( hex )    [ cols=\"^ \" , ]     ; ( post ) postcheck ; ; ; ;    ( pre.south )  node[left ] @xmath23 ( hex.north ) ; ( hex.south ) ",
    "node[left ] candidate solution ( post.north ) ; ( post.south ) ",
    "node[left , near end ] feasible solution ( @xmath24 ) ;    ( @xmath25 ) -| ( pre.north ) ; at ( @xmath26 ) @xmath1 ;    ( @xmath27 )  + + ( 0,-1em )  + +",
    "( 6em,0 )  + + ( 0,8.7em )  + + ( -6em,0 )  ( @xmath28 ) ; at ( @xmath29 ) @xmath19 constraints ; at ( @xmath30 )  ;    * solution quality . *     if some low - level module @xmath15 is not integrated into the planning process , some plan candidates will be infeasible due to failed low - level checks of @xmath15 .",
    "we quantify solution quality by measuring the number of feasible and infeasible plan candidates generated by the search for a plan .",
    "this way we obtain a measure that shows how _ relevant _ a given low - level check is for plan feasibility . note that with the filtapproach an infeasible plan candidate simply causes a new plan to be generated , while with replan infeasible plan candidate causes computation of additional constraints , and a restart of the plan search .",
    "tightly connected to the number of feasible and infeasible solution candidates is the number of low - level checks that is performed until finding the first feasible plan , and until finding all feasible plans .",
    "* planning efficiency . *     we quantify planning efficiency by measuring the time required to obtain the first feasible plan , and the time to enumerate all feasible plans .",
    "( note that this includes proving that no further plan exists . )",
    "independent from the number of low - level checks , the duration of these external computations can dominate the overall planning cost , or it can be negligible .",
    "therefore we measure not only the number of computations of low - level modules but also the time spent in these computations .",
    "for our empirical evaluation we use the robotic manipulation and the legged locomotion domains . both require hybrid planning .",
    "we next give an overview of the domains , their characteristics , and scenarios we used .",
    "* robotic manipulation . *     we consider a cooperative robotic manipulation problem , as in  @xcite , where two robots arrange elongated objects in a space that contains obstacles .",
    "the manipulated objects can only be carried cooperatively by both robots , objects must not collide with each other or the environment , similarly robots must not collide with each other .",
    "a large part of collision checks between objects can already be realized in the high - level representation , however certain checks require usage of geometric models .",
    "collision - freeness between robots for particular collaborative actions can only be determined using low - level geometric reasoning and is not represented in the world model .",
    "therefore we use two low - level reasoning components to check collision - freeness : the @xmath31module checks collisions between the robotic arms , and @xmath32checks collisions between an object and its environment .",
    "we experiment with 10 instances ( over a @xmath33 grid ) that require plans of upto 20 ( average 9.2 ) steps , and involving up to 58 ( average 25.1 ) actions .",
    "* legged locomotion .",
    "*     in the legged locomotion domain , a robot with high degrees of freedom must find a plan for placing its legs and moving its center of mass ( cm ) in order to move from one location to another one .",
    "for the purpose of studying integration of geometric reasoning with high - level task planning , we created a planning formulation for a four - legged robot that moves on a @xmath34 grid .",
    "some grid locations are occupied and must not be used by the robot .",
    "starting from a given initial configuration , the robot must reach a specified goal location where all legs are in contact with the ground",
    ".    as legged robots have high degrees of freedom , legged locomotion planning deals with planning in a high - dimensional space .",
    "we use a planning problem that is of similar complexity as has been investigated in climbing  @xcite and walking  @xcite robots .",
    "we also require a feasibility check of leg placement actions .",
    "we allow concurrent actions , i.e. , moving the center of mass while detaching a leg from the ground , if this does not cause the robot to lose its balance .",
    "we use a low - level reasoning component that determines whether the robot is in a balanced stable equilibrium ( @xmath35 ) , given its leg positions and the position of its cm .",
    "we realize this check by computing the support polygon of legs that are currently connected to the ground , and by checking if cm is within that polygon . for these checks we use the boost::geometry library to compute a convex hull of all leg positions , and then check whether cm is located within that convex hull .",
    "a second low - level module determines if leg positions are realistic wrt .",
    "the position of cm , i.e. , if every leg can reach the position where it is supposed to touch to the ground .",
    "this check ( @xmath36 ) is realized as a distance computation between coordinates of legs and cm .",
    "the domains we experiment with exhibit various differences in their characteristics , and such a variety allows us to get practically more relevant results .",
    "the most important differences between these two domains are as follows .",
    "* complexity of low - level reasoning . *",
    "in legged locomotion we use a c++ geometric library to perform basic geometric operations which are sufficient for computing check results .    in robotic manipulation ,",
    "object collision checking @xmath32operates on 3d models of objects and environments , and @xmath31additionally requires inverse kinematics to determine the joint configuration of each robot reaching a certain point before performing collision checks between arms .",
    "hence , in legged locomotion , each low - level check requires less time and memory than in robotic manipulation .    * information relevant for low - level reasoning . *     in legged locomotion",
    ", we consider problem instances over a @xmath37 grid .",
    "@xmath36is a check over two coordinates , therefore there are @xmath38 possible @xmath36checks .",
    "the balance check @xmath35is a totally different situation : we have an input of four leg coordinates and one cm coordinate , therefore , there are @xmath39 possible @xmath35checks .",
    "such a large number of checks makes precomputation infeasible .    in robotic manipulation ,",
    "both low - level checks are over coordinate pairs on a @xmath33 grid ; therefore , there are @xmath40 low - level checks .    based on the number of low - level checks , precomputation for",
    "legged locomotion seems feasible for only one of the two low - level modules ( @xmath36 ) , while for robotic manipulation we can apply precomputation for both low - level computations .",
    "indeed , precomputation for legged locomotion can be done in less than 1 second , and for robotic manipulation in 238 seconds .",
    "we applied different integration methods to 20 legged locomotion and 10 robotic manipulation instances of varying size and difficulty .",
    "tables  [ tbleff ] and  [ tblqual ] present results for    * * first * : obtaining the first feasible plan , and for * * all * : obtaining all ( maximum 10000 ) feasible plans .    in our experiments",
    ", we use a timeout of 2 hours ( 7200 seconds ) after which we stop computation and take measurements until that moment .",
    "we also limit the number of enumerated plans to 10000 plans .",
    "the measurements for enumerating up to 10000 plans reveal information about solution quality and provides a more complete picture of the behavior of each method : one method might find a feasible solutions very fast by chance , whereas finding many or all solutions fast by chance is unlikely .    * time measurements . *",
    "table  [ tbleff ] shows measurements about planning efficiency and time spent in low - level reasoning .",
    "firstly , it is clear that preand int the direct integration methods  outperform filtand repl the post - checking methods : for robotic manipulation , only preand intare able to enumerate all solutions within the given time limit ; for legged locomotion , only intand the pre / intcombination enumerates all solutions .    comparing the times required by preand int , we see that preis more efficient for robotic manipulation ( 888 sec vs 1007 sec on average ) , which is mainly due to efficient precomputation ( see below ) .",
    "even though preperforms better than int , it spends more time in low - level reasoning , hence high - level reasoning is faster there ; we can explain this by a more constrained search space ( low - level check results constraint the search ) .",
    "after preand int , the next best choice is repl : it finds solutions to 8 out of 10 instances in robotic manipulation , and it finds solutions to all instances for legged locomotion , whereas filthas the same number of timeouts in the manipulation domain and 5 timeouts for legged locomotion .",
    "in addition to that , we can see that replspends little time in low - level checks compared to other approaches .",
    "this is because replperforms many restarts of the high - level planner which causes it to spend a disproportionate amount of time in high - level planning .",
    "nevertheless , replshows its robustness by finding solutions to all but 2 instances .    finally , filtfails to find solutions for 7 instances in total which clearly makes it the worst - performing method .",
    "the time results for robotic manipulation suggest that filtmay be a bit faster than repl ; this may be an effect of some easy instances in that domain where replanning spends more time by reinitialization , than filtspends by iterating over many similar infeasible solutions .",
    "therefore , even in that domain , we would not suggest to use filt , as it might  by chance , as low - level reasoning can not give feedback to high - level reasoning  fail to find a feasible solution for a long time .",
    "* effort of low - level reasoning . *     in robotic manipulation , while attempting to enumerate all solutions , filtperforms only 724 low - level checks compared to 29282 checks of pre . similarly , in legged locomotion , filtperforms 35888 checks and fails to enumerate all solutions for 8 of 20 instances , while intenumerates all solutions while performing more ( 171109 ) low - level checks .",
    "note that these numbers ( the last column of table  [ tbleff ] ) indicate _ distinct _ low - level reasoning tasks as we cache low - level check results .",
    "these numbers show that filtencounters a small fraction of the low - level checks that are needed to verify all solutions in int .",
    "caching in fact allows filtto verify much more actions than int(numbers not shown ) , however the number of _ distinct _ checks ( numbers shown ) is higher in int .",
    "we conclude that inttraverses the solution space much more efficiently .",
    "in legged locomotion , low - level checks depend on a large part of the candidate plan , so caching is not as effective as in robotic manipulation .",
    "this , together with the fact that in filtthe high - level is not guided by low - level checks , causes the filtapproach to spend more time in low - level reasoning than other approaches .",
    "note that , to obtain a reasonable comparison between preand the other approaches , we include times and counts of precomputed low - level checks in table  [ tbleff ] ( which explains the large values for low - level computations in these rows ) .    * solution quality . *     methods preand intdo",
    "not generate infeasible solution candidates , as they use all low - level checks already in search .",
    "if we compare the number of infeasible solution candidates of filtand replin robotic manipulation , we observe that filtgenerates mainly infeasible solution candidates compared to the number of feasible solutions ( 11787 vs 622 ) while replcreates only 38 infeasible candidates while enumerating 621 feasible plans .",
    "in legged locomotion , the results for filtare similar , however replperforms a bit worse than in robotic manipulation with 250 infeasible candidates compared to 68 feasible solutions . a possible reason for this difference could be the same reason why preis not feasible in that domain : there is a large amount of possible inputs to @xmath35compared to the other low - level checks we used . due to the large input space ,",
    "each failed @xmath35check constrains the search space only by a small amount , so replproduces more infeasible solutions than in robotic manipulation .",
    "* memory usage . *     we measured peak memory usage over the whole runtime of each instance .",
    "interleaved computation with the solver ( columns with int ) requires an average of around 2000 mb , the maximum stays below 4000 mb . for non - interleaved computations , and were connected with low - level checks using scripts .",
    "these approaches require around 400 mb of memory with a maximum below 1000 mb .",
    "* combination of prewith other methods . *",
    "as shown in the legged locomotion experiments , precan be combined with other approaches . in our experiments",
    "we observe that adding preincreases efficiency .    however , preadds a fixed cost to solving because it precomputes many points . depending on efficiency of low - level computations ,",
    "even if there are few possible input combinations to low - level checks precomputation might be infeasible .",
    "dedicated precomputation methods can be more efficient than just checking for each possible input combination , e.g. , by saving on motion planner initialization . in our experiments we created such dedicated precomputation methods : for robotic manipulation dedicated precomputation takes 238 seconds in total , calling individual checks requires 1361 seconds in total . without dedicated efficient precomputation , preperforms worse than int .",
    "our experiments suggest the following conclusions . if robust and highly complex reasoning is required , and if this reasoning is done frequently ( so that performance gains will become relevant ) then using full interleaved reasoning ( int ) is the only good option . inthas the best performance with respect to run times , and it can enumerate most solutions compared to other approaches .",
    "the reason is that intuses only those low - level checks which are necessary ( they are computed on demand ) and therefore does not overload the solver with redundant information ( as predoes ) .",
    "furthermore , intconsiders failed checks in the search process and thereby never picks an action where it is known that the action will violate a low - level check .",
    "this is similar as in the replapproach , but much more efficient as the integration is much tighter compared to repl .",
    "however , the performance of intcomes at a price :    it requires more memory , and    it requires a solver that allows for interacting with the search process in a tight way , usually through an api that has to be used in a sophisticated way to be efficient .",
    "if reasoning operates on a manageable amount of inputs , such that precomputation is a feasible option , then preis a good choice . in our robotic manipulation experiments , preoutperforms all other methods , which is partially due to our using a dedicated efficient precomputation tool .",
    "in legged locomotion , combining prewith other methods also increased efficiency .",
    "the filtapproach performs the worst , because nothing guides the search into the direction of a feasible solution ; filtis not robust and enumerates many infeasible solutions .    if both preand intare not possible then replshould be used",
    "; this approach does not have the same performance as intand pre , however it is a very robust approach as it is guided by its wrong choices  we can think of the constraints that are added for failed low - level checks as the approach ` learning from its mistakes ' .",
    "the benchmark results for legged locomotion clearly show the robustness of replcompared to filt : the former finds solutions for all problems , the latter only for 15 out of 20 instances .    a possible improvement to replcould be to let it enumerate a certain amount of solutions to gather more constraints , then add all these constraints and restart the search .",
    "this is a hybrid approach between filtand repl . selecting the right moment to abort enumeration and restart",
    "the solver is crucial to the performance of such a hybrid approach , and we consider this a worthwhile subject for future investigations .",
    "this work is partially supported by tubitak grant 111e116 .",
    "peter schller is supported by tubitak 2216 research fellowship .",
    "gravot , f. , cambon , s. , alami , r. : planner that deals with intricate symbolic and geometric problems . in : robotics research",
    "the eleventh international symposium .",
    "volume  15 of springer tracts in advanced robotics .",
    "springer ( 2005 ) 100110    hauser , k. , latombe , j.c .",
    ": integrating task and prm motion planning : dealing with many infeasible motion planning queries . in : workshop on bridging the gap between task and motion planning at icaps .",
    "( 2009 )                erdem , e. , haspalamutgil , k. , palaz , c. , patoglu , v. , uras , t. : combining high - level causal reasoning with low - level geometric reasoning and motion planning for robotic manipulation . in : international conference on robotics and automation .",
    "( 2011 ) 45754581                        bretl , t. , lall , s. , latombe , j.c . , rock , s.m . : multi - step motion planning for free - climbing robots . in : algorithmic foundations of robotics vi .",
    "volume  17 of springer tracts in advanced robotics . , springer ( 2005 ) 5974    bretl , t. , rock , s.m . ,",
    "latombe , j.c .",
    ", kennedy , b. , aghazarian , h. : free - climbing with a multi - use robot . in jr .",
    ", m.h.a . ,",
    "khatib , o. , eds . : iser .",
    "volume  21 of springer tracts in advanced robotics . , springer ( 2004 ) 449458"
  ],
  "abstract_text": [
    "<S> we provide a systematic analysis of levels of integration between discrete high - level reasoning and continuous low - level reasoning to address hybrid planning problems in robotics . </S>",
    "<S> we identify four distinct strategies for such an integration : ( i ) low - level checks are done for all possible cases in advance and then this information is used during plan generation , ( ii ) low - level checks are done exactly when they are needed during the search for a plan , ( iii ) first all plans are computed and then infeasible ones are filtered , and ( iv ) by means of replanning , after finding a plan , low - level checks identify whether it is infeasible or not ; if it is infeasible , a new plan is computed considering the results of previous low - level checks . </S>",
    "<S> we perform experiments on hybrid planning problems in robotic manipulation and legged locomotion domains considering these four methods of integration , as well as some of their combinations . </S>",
    "<S> we analyze the usefulness of levels of integration in these domains , both from the point of view of computational efficiency ( in time and space ) and from the point of view of plan quality relative to its feasibility . </S>",
    "<S> we discuss advantages and disadvantages of each strategy in the light of experimental results and provide some guidelines on choosing proper strategies for a given domain .    </S>",
    "<S> [ firstpage ]    task planning , geometric reasoning , answer set programming . </S>"
  ]
}