{
  "article_text": [
    "there is a close historical connection between the investigation of permutation classes closed under pattern containment , and the study of what sequences can be generated ( or sorted ) using a particular data structure ( see for example @xcite , @xcite , @xcite , @xcite ) .",
    "indeed it could be argued that the parents of the study of these permutation classes are the erds - szekeres theorem and knuth s result that the permutations sortable with a single stack are precisely those which do not contain 231 as a pattern .",
    "one of the purposes of a data structure is to accept input data , store it in some form , and then release it in response to certain requests . in most structures these functions",
    "may be interleaved with one another .",
    "if we observe only the order that data is input to a data structure , and then the order in which it is released , the operation of the data structure will simply be perceived as generating a permutation of the data .",
    "so it is natural to associate with a data structure the collection of such permutations which it can realize .",
    "furthermore , most natural data structures have a hereditary property .",
    "that is , if they can achieve a certain permutation of a large collection of data , then they can achieve the restriction of that permutation to any subset of the data .",
    "subject to this property , the permutations associated to a data structure will be a class of permutations closed under pattern containment .",
    "the investigation of classes connected to data structures in this way is greatly facilitated by keeping this connection in mind .",
    "generally speaking , thinking about how the data are assigned to storage , manipulated within storage , and released from storage , will allow a clearer understanding of the corresponding class of permutations . in this paper",
    ", we carry out this program with respect to a new data structure , the _ forkstack _ , a stack in which it is possible to add or remove multiple data items with a single operation .",
    "the stack is an ubiquitous data structure , used in many algorithms , typically where last in , first out , behaviour is required or desirable .",
    "in some contexts however , the standard stack structure with its limited push and pop operations can seem overly restrictive .",
    "consider , for example , the situation where there are two stacks , each containing a sorted sequence of data values with smallest elements on top .",
    "it is desired that these sequences be merged into a single sorted sequence .",
    "if this merge is to take place into a new array , or into a queue , then the traditional stack is perfectly suited for the task .",
    "however , for reasons of parsimony or elegance , one might wish to accomplish this merge in place . in a standard stack",
    ", this is difficult .",
    "however , if we could pop ( and push ) sequences of elements from the top of each stack , then it becomes simplicity itself .",
    "one simply pops from the stack with smaller head the maximal sequence which ends with an element smaller than the head of the other stack , and pushes this sequence onto the other stack .",
    "this process is repeated until one of the stacks is empty .",
    "note that if the stacks are implemented as linked lists , then this entire process is simply a matter of repeated pointer assignments .",
    "also , by keeping track of the location of the original larger head the whole process can be accomplished by a single pass through the stacks .",
    "since the operations of a forkstack are more flexible than those of an ordinary stack it will be prudent to provide an algorithm for carrying out the process of sorting an input permutation , as well as an abstract characterisation of obstructions to sortability .",
    "we will also , in some cases , be able to explicitly determine algebraic relations satisfied by the generating functions that enumerate the number of sortable sequences of each length using push and pop operations which are bounded in size .",
    "we will describe a method which , in principle , allows all such enumeration problems to be resolved .    the name , _ forkstack _ , that we have given this data structure is derived from the following analogy which we find sufficiently powerful that it forms the foundations of our understanding of the structure .",
    "begin with a stack of boxes , called the input , labelled 1 through @xmath0 in some order .",
    "a powerful forklift can remove any segment of boxes from the top of the stack , and move it to the top of another stack , the working stack . from there",
    "another forklift can move the boxes to a final output stack .",
    "physical limitations prevent boxes being moved from the working stack to the input , or from the output to the working stack .",
    "the desired outcome is that the output should be ordered with box number 1 on top , then 2 , then 3 , ",
    ", with box @xmath0 at the bottom .",
    "an example of a sorting procedure in progress is shown in figure [ fork ] . in this analogy",
    ", the working stack corresponds to our forkstack data structure , and the operations performed on it by the truck to its operations .",
    "the process of sorting @xmath1 is documented below .",
    "note that , at the stage shown in figure [ fork ] it is essential that 41 be moved as a pair  moving either 4 alone , or the triple 415 would result ( eventually ) in 1 lying on top of 4 or 5 in the working stack , and thereby prevent sorting .",
    "@xmath2 some permutations , such as 35142 can not be sorted . here",
    ", we may move 3 to the working stack , and then 5 to the output , but now whether we move 1 alone , 14 , or 142 , we wind up with 1 lying on top of 3 or 4 in the working stack , and can not complete the sorting procedure .",
    "we will see below that if we can avoid creating this type of obstruction in the working stack , then sorting is possible .",
    "in the subsequent sections we will tend to continue to use the terminology of the introduction speaking of the input stack , forklifts , etc . however , it will be convenient to introduce a certain amount of basic notation in order to facilitate discussion .",
    "as we will always take the initial input to be a permutation of 1 through @xmath0 for some @xmath0 , the contents of each stack at any time can and will be represented by sequences of natural numbers ( not containing repetitions ) .",
    "our ultimate objective is always to reach a state where the contents of the output stack are the permutation @xmath3 and we will refer to this outcome as success .    in the basic situation where both forklifts are of unlimited capacity , we use @xmath4 to denote the collection of all permutations for which success is possible .",
    "if the input to working stack forklift is limited to moving @xmath5 boxes in a single move , and the working to output one to moving @xmath6 , then we denote the corresponding class @xmath7 . here",
    "@xmath5 and @xmath6 are either natural numbers , or @xmath8 .    given a permutation @xmath9 as input , a sequence of operations is _ allowed _ , if it does not result in an output state which provides clear evidence that sorting is not being carried out .",
    "that is , a sequence of operations is allowed if at the end of the sequence the output stack contains some tail of @xmath10 .    in discussing the algorithms for sorting it will be helpful to pretend that it is possible to move boxes directly from the input stack to the output stack  and",
    "such an operation , as well as the more normal type of output is called _ direct output_.",
    "so a direct output move consists either of output from the working stack , or moving a part of the input stack to the working stack ( in a single lift ) , and then moving exactly that set of boxes to the output stack , again in a single lift .",
    "when we consider enumeration results for forkstacks , it will often be convenient to think in terms of which permutations of an original input of @xmath11 can be produced , rather than which sequences can be sorted . in that case it will be convenient to be speak of _ operation sequences_. in the operation of a forkstack we use @xmath12 $ ] to denote the operation of pushing @xmath13 elements onto the stack , and @xmath14 $ ] to denote the operation of popping @xmath15 elements from it . if a parameter @xmath13 or @xmath15 is omitted , it is taken to equal 1 .",
    "how should a fork stack actually carry out its task of sorting a permutation when this is possible ?",
    "it turns out that there is a straightforward algorithm to accomplish this operation . broadly speaking",
    ", we may use a simple modification of a greedy algorithm :    * perform any output as soon as possible , * otherwise move the maximum decreasing sequence from the head of the input onto the working stack .    in order to justify this claim ( with some technical changes to the second option ) we require a slightly more abstract characterisation of unsortability .    for positive integers @xmath16 and @xmath17 ,",
    "@xmath18 means @xmath19 . in a series of fork stack moves ,",
    "we say that the _ dreaded 13 _ occurs if at some point the working stack contains adjacent elements @xmath20 with @xmath18 .",
    "[ dread13 ] a permutation @xmath9 is unsortable if and only if every allowable sequence of fork stack operations that empties the input produces , at some point , the dreaded 13 .",
    "suppose that we can not avoid producing a @xmath21 .",
    "then we can not sort @xmath9 for there is no way to insert the missing elements into the gap between the elements @xmath18 witnessing the @xmath21 . on the other hand",
    ", if there is some allowable sequence of operations that empties the input stack and avoids producing a 13 , then on completing them , the contents of the working stack will be a _ decreasing sequence , except possibly for some blocks of consecutive increasing elements_. such a stack is easily moved to the output in its sorted order .",
    "we refer to a sequence of the type emphasised above , as a _ near - decreasing _ sequence .",
    "suppose that no immediate output is possible and consider the maximal near - decreasing sequence , @xmath22 , at the top of the input stack .",
    "if the symbols occurring in @xmath22 do not form an interval , then any move other than taking the whole sequence @xmath22 and transferring it to the top of the working stack will , immediately or eventually , cause the dreaded 13 .",
    "it will cause an immediate 13 if we move more symbols than occur in @xmath22 , for the transition between the final element of @xmath22 and the next element of the input is an increase of more than 1 .",
    "if , on the other hand , we break @xmath22 at some intermediate point or points , then eventually either the same 13 as above will be formed , or some symbol of @xmath22 from below a gap in its values will be placed directly on top of some symbol from above that gap , thus creating a 13 . if the symbols occurring in @xmath22 do form a consecutive interval , then , as above , they must still all be moved to the working stack before any element of the remainder of the sequence is .",
    "however , we can arrange to place them on the working stack in order , with largest deepest .",
    "this is preferable to any other arrangement on the working stack , for it makes the top element of the working stack as small as possible , minimising the possibility of later creating a dreaded 13 .",
    "doing direct output as soon as it becomes available can never interfere with sorting . for",
    "if we have a successful sequence of sorting moves which we modify by doing some direct output earlier , we can simply continue to carry out the successful sequence , ignoring any effect on symbols which have already been moved to output  and we will still succeed .",
    "so we may assume that any sorting algorithm does in fact perform direct output whenever it can .",
    "then the observations of the preceding paragraph imply that when direct output is not available , the maximal near - decreasing sequence at the top of the input stack must be moved .",
    "if this sequence contains gaps , there is no choice in how to move it , and we have argued that if it does not , then moving it so that it forms an increasing sequence on the working stack is at least as effective as any other choice .",
    "this establishes that algorithm [ forksort ] will correctly sort any input stack , if it is sortable at all .",
    "perform as many direct output moves as possible .",
    "failure .",
    "how does algorithm [ forksort ] need to be modified in the case where either or both of the forklifts moving from input to working stack , or from working stack to output , are of limited power ?",
    "the first issue is how to modify proposition [ dread13 ] .",
    "the 13 configuration is bad regardless of the power of our forklifts , but if our output lift is limited to moving @xmath6 boxes we must add the condition that the working stack should not contain an increasing sequence of length longer than @xmath6 . now modifying",
    "the algorithm is straightforward . in the case where the maximal near - decreasing sequence contains gaps",
    "it must be moved as a block to avoid 13 s .",
    "so , if this block is larger than the capacity of our working forklift , we fail . in the non - gap case , we would normally attempt to make the sequence increasing .",
    "of course this would be foolish if it overwhelmed the capacity of our output lift ( and it could be impossible depending on the capacity of our input lift ) .",
    "the only other choice that does not create a 13 is to make it decreasing , so this should be attempted if the first choice is unavailable .",
    "failure may later occur because we create a block that is too long to move in the working stack , or a 13 there , but if not , then the algorithm will succeed .",
    "we now begin our combinatorial investigation of the collections of permutations sortable by various types of forklifts .",
    "the problem which we address in this section is how to identify the sortable or unsortable permutations without reference to algorithm [ forksort ] . in the following section we will consider the problem of enumerating these classes . for identification purposes we concentrate on producing a list of minimal unsortable permutations .    given permutations @xmath23 and @xmath9 , we say that @xmath23 is _ involved in _",
    "@xmath9 , and write @xmath24 if some subsequence of @xmath9 , of the same length as @xmath23 , consists of elements whose relative order agrees with those of the corresponding elements of @xmath23",
    ". a collection of permutations closed downwards under @xmath25 is called a _ closed class_.    it is easy to see that each of the collections @xmath7 of sortable permutations for a particular combination of forklifts is a closed class .",
    "this is because we may sort any subsequence of a sortable sequence by simply ignoring any moves that do not affect members of the subsequence .",
    "this policy can not increase the load on a forklift in any single move , so it still sorts the remaining elements .",
    "it follows , that if we take @xmath26 to be the set of @xmath25-minimal unsortable permutations then : @xmath27 in particular , @xmath26 can be thought of as a description of @xmath7 and we shall refer to it as the _ basis _ of @xmath7 .",
    "for example , the case @xmath28 corresponds to sorting with a single stack , and it is established in @xcite that @xmath29 this differs superficially from the cited result , owing to our convention the output should be produced with largest deepest , so it should be the _",
    "largest _ input item which is popped first .    for any @xmath30",
    "the set @xmath26 is finite .    as in the case of the sorting algorithm",
    ", we will first consider the case @xmath31 , and then modify the result to allow for the possibility of one or both forklifts being of limited power .    in order to show that @xmath32 is finite",
    ", it is sufficient to establish that any unsortable permutation @xmath9 has an unsortable subsequence @xmath23 whose length is less than some fixed upper bound . for in that case , the length of each element of @xmath33 is less than that upper bound , and of course there are only finitely many such permutations .",
    "so , let an unsortable permutation @xmath9 be given .",
    "as @xmath9 is unsortable , algorithm [ forksort ] fails to sort it , and so according to proposition [ dread13 ] , it must at some point produce a 13 in the working stack .",
    "we consider the state of the system when the first move from input to storage which would create a 13 is about to be made .",
    "the basic idea is that all of the elements which contribute to the failure of the algorithm at this point have a reason for being in the position that they are in .",
    "the collection of these elements , together with the ones which give them their reasons form the obstruction , @xmath23 , to sortability whose size is bounded .",
    "we warn the reader that the actual execution of this idea is of very limited interest , and if she is convinced of its basic soundness it would probably be better to skip it .",
    "let the block from the input stack whose movement creates the first 13 be @xmath34 with top element @xmath17 , the contents of the working stack just prior to this move be @xmath35 with top element @xmath5 , the remaining contents of the input stack be @xmath36 with top element @xmath37 , and the contents of the output stack be @xmath38 with top element @xmath39 ( if any ) . the 13 which the move creates is some pair @xmath40 where @xmath41 is the bottom element of @xmath34 .    as the algorithm specified making a block move from input , no direct output can have been possible . in particular ,",
    "since @xmath5 could not be output directly , the largest remaining element @xmath42 smaller than @xmath39 must be different from @xmath5 ( if @xmath39 does not exist , this element is simply the largest element overall ) .",
    "this element must be in @xmath36 , since were it in @xmath35 then we would either have a 13 already , contrary to hypothesis , or would be able to output the block including it and @xmath5 , while were it in @xmath34 , direct output from @xmath34 would be possible . note that an indirect consequence of this part of the argument is that @xmath36 is non - empty .",
    "since the block @xmath34 was broken off the input between @xmath41 and @xmath37 , there must be an element @xmath43 with @xmath44 .",
    "this element might belong to @xmath34 , @xmath36 , or @xmath35 .",
    "since the stack is non - empty , the preceding move onto the stack moved a block whose top was @xmath5 ( or a block whose top was subsequently output after some direct output from the input stack  but such elements are irrelevant ) .",
    "there are two possible ways in which this block can have been broken off the input .",
    "either it ended just above the top of block @xmath34 , or it ended just above some element which has subsequently been output .",
    "in the first case , @xmath5 lies above some element @xmath45 ( which was part of its block ) , so that for some element @xmath46 we have @xmath47 . the element @xmath46 might be in @xmath35 , @xmath34 , or @xmath36 . in the second case , @xmath5 lay above the element @xmath39 in the original input .",
    "finally , it might be necessary to ensure that the block @xmath34 is not a block of consecutive elements ( so that it is moved with @xmath41 at the bottom , when rearrangement would avoid the 13 ) .",
    "this would be witnessed by the existence of an element @xmath48 with @xmath49 and @xmath48 in @xmath35 or @xmath36 .",
    "now consider an attempt to sort the subpermutation of the original permutation whose elements are : @xmath50 the elements @xmath51 ( and in some cases , indirectly the other elements ) ensure that the @xmath40 pair will be produced in the working stack , and thus prevent sorting from taking place .",
    "next consider the class @xmath52 for some @xmath53 . as",
    "the operation of the input forklift is unrestricted , the only new obstructions which might arise would occur when we had in the stack a sequence of @xmath54 or more elements which were forced to be in increasing order ( read top to bottom ) , since these would have to be moved as a block but could nt be because of the output restriction . as we are considering only new obstructions , we may take the @xmath54 largest of those elements to form a consecutive block @xmath16 through @xmath55 . in the unlimited successful sorting of this sequence",
    "they are placed on the stack in increasing order , the stack must contain only smaller elements when they are added .",
    "no direct output affecting @xmath55 can occur while they are being added , so there must be a larger element lying below them all in the input . if no direct output is to take place while they are being added , then it is only necessary that they not be in an order which would allow them to be placed on the stack in decreasing order  that is , in any decreasing sequence of increasing blocks except @xmath56 in the former case , no interposing direct output can interfere with placing them in the stack in decreasing order , so they are not forced to be in increasing order on the stack , unless there is some subsequent @xmath57 which must be placed in the stack before they are removed .",
    "if so , this will also lengthen the block to be removed by 1 element , and so we can shorten the block by one element . in the latter case , this caveat also applies , but also any interposing element which is to be output directly , would force the block into ascending order .",
    "so the elements @xmath16 through @xmath55 , the element @xmath17 , or an interposing element , if required , and a larger element preventing direct output , are sufficient to ensure that @xmath16 through @xmath55 must be put on the stack in increasing order , and therefore provide any potential new obstructions to sortability .",
    "for example , one such new obstruction in the case @xmath58 is : @xmath59    by running the sorting algorithm backwards we see that in general : @xmath60 as the basis of the collection of inverses of elements of a class is simply the collection of inverses of its basis , we can conclude that the classes @xmath61 are also finitely based for any @xmath5 .",
    "but then the arguments of the preceding paragraph apply also to the class @xmath7 , and so all these classes are finitely based .    using the proof of the result above makes the computation of the sets @xmath26 relatively straightforward .",
    "the set @xmath32 consists of the permutation @xmath62 , together with 45 permutations of length six , and 6 of length seven .",
    "the sets @xmath63 are of particular interest in connection with the next section and they are : @xmath64",
    "in the case where @xmath66 , that is , the push operation onto the stack is restricted to moving a single element , there are no possible choices in the sorting procedure",
    ". pops from the storage stack must be made whenever they are available , and pushes made otherwise .",
    "this makes the enumeration of these classes relatively straightforward , at least compared to the classes where more general pushes are available , which we defer to the next section .",
    "the basic plan is to search for structural requirements on sortable permutations which are sufficient to develop algebraic relationships that the generating function for the class must satisfy .",
    "we will find the ordinary generating function of each class in this collection .",
    "as in the case of finding bases for the class , it turns out that the simplest instance to handle is the case @xmath67 , and the remaining instances can be derived from it by restriction in a fairly obvious way . the generating function for this class will be denoted @xmath68 , and we use @xmath41 as the variable symbol .",
    "suppose then that we have some permutation @xmath69 .",
    "choose @xmath70 to be the maximum integer such that the elements 1 through @xmath70 occur in @xmath9 in decreasing order ( thus , if 2 follows 1 , @xmath71 ) .",
    "so @xmath72 for some sequences @xmath73 through @xmath74 , where @xmath75 does not occur in @xmath74 .",
    "consider now the sorting procedure .",
    "the elements of @xmath74 are processed , and then we come to @xmath70 .",
    "now by the choice of @xmath70 , @xmath75 has not yet been processed , so we may not output @xmath70 ( except in the trivial case where all the @xmath76 are empty ) .",
    "so @xmath70 must be moved to the working stack .",
    "however , if it is non - empty at this time , that move would create a 13 .",
    "so the working stack must be empty , and @xmath74 must have been a sortable permutation of a final subinterval of the values occurring in @xmath9 .",
    "now proceed to the stage where @xmath77 is about to be moved . again",
    ", either @xmath75 has turned up by now , and the working stack is empty , or it contains only the value @xmath70 . in either case",
    "@xmath78 is a sortable permutation of a final subinterval of the remaining values .",
    "this argument persists inductively .",
    "so in the end we see that @xmath75 occurs in the first non - empty @xmath79 , and that the general requirements for sortability are that @xmath76 be sortable for each @xmath37 , and that each @xmath76 be supported by an interval , with @xmath80 .    in other words , having determined @xmath70 , we are free only to decide the sizes of the individual @xmath76 , and then their structure within the class , but having chosen their sizes , the elements that they contain are fixed .",
    "to carry out the enumeration , we distinguish two cases according to whether or not @xmath73 is empty . if it is , then @xmath81 where @xmath82 is an arbitrary sortable permutation .",
    "permutations of this type are enumerated by @xmath83 . if @xmath73 is not empty , then the generating function for the collection of permutations @xmath9 of this type ( with @xmath70 fixed ) is @xmath84 we can sum this over the possible values of @xmath70 , and include the trivial case of an empty permutation to obtain the equation : @xmath85 or , after summing the geometric series : @xmath86 we can then solve the resulting quadratic to get : @xmath87 the sequence that this generating function defines : @xmath88 is number a033321 in @xcite , and the references provided for it there connect it with other interesting enumeration problems .    the only change that needs to be made to find the generating function @xmath89 for @xmath65 is to change the upper limit of summation in the relationship above from @xmath8 to @xmath6 , since the maximum increasing sequence that we can deal with on the working stack is of length @xmath6 .",
    "of course @xmath90 is the generating function for the catalan numbers . in general , however , this gives an algebraic equation satisfied by @xmath89 with coefficients that are polynomials in @xmath41 .",
    "the form of this equation is slightly simpler for the related function @xmath91 namely @xmath92 which can be simplified still further through multiplication by @xmath93 yielding @xmath94    this allows efficient exact enumeration of these classes using standard generating function techniques .",
    "it also allows asymptotic expansions of the form : @xmath95 to be computed to any desired degree of accuracy using the methods developed in @xcite .",
    "the behaviour of the radius of convergence @xmath96 ( whose reciprocal gives the exponential part of the growth rate for the coefficients @xmath97 ) , as @xmath6 increases from @xmath98 to @xmath8 is particularly interesting .",
    "it begins at @xmath99 , since @xmath100 gives us the catalan numbers and then decreases to @xmath101 at @xmath67 .",
    "however , the rate of convergence to @xmath101 is geometric , with the difference decreasing by roughly a factor of 3 at each step .",
    "the first six values are : @xmath102 we can justify these results formally by noting that the radius of convergence in each case is the smallest positive root of the discriminant of the polynomial which @xmath103 satisfies ( this follows easily from results in @xcite ) . finding this root is simplified by considering the second form of the equation for @xmath103 , namely ( after change of name for convenience ) : @xmath104 we seek a minimum positive value @xmath105 of @xmath41 for which the resulting polynomial in @xmath16 has a double root . in order for this to be true , that root will also be a root of the derivative with respect to @xmath16 of this equation , that is of @xmath106 eliminating @xmath41 between these two equations gives : @xmath107 this equation has a root near @xmath108 which corresponds to the smallest root @xmath41 that we seek . if we write that root in the form @xmath109 , then the final three terms will be of order @xmath110 , while the value of the first expression will be of order @xmath111 .",
    "in other words , the value of @xmath112 decreases geometrically to @xmath113 as @xmath114 . then substituting this value of @xmath16 and solving for @xmath41 shows that the difference @xmath115 is also geometrically decreasing .",
    "in carrying out the enumeration of @xmath65 we concentrated on the structure of the sortable permutations .",
    "one reason for doing this was that , even in this simple context , the series of operations required to sort a permutation is not uniquely defined . for example",
    "@xmath117 can be sorted either by a sequence of alternating pops and pushes , or by two single pushes , followed by a pop of the whole storage stack . when both @xmath5 and @xmath6 are larger than 1 , this ambiguity in the operation sequence is compounded in a very complex fashion , and as we shall see ,",
    "makes it difficult to carry out explicit enumeration .",
    "in fact , the only class of this sort for which we will provide an explicit enumeration result is when @xmath118 .    in this section",
    "we will consider instead of the class of sortable permutations , the class of permutations which we can generate , i.e. produce by some sequence of operations from initial sorted input . as",
    "this class consists simply of the inverses of the sortable permutations , there is no essential difference involved in considering it instead .",
    "we shall be concentrating on operation sequences , and the relationship , @xmath119 , of equivalence between them defined as producing the same output from initially sorted input .",
    "the goal of the argument then is to produce a representative for each equivalence class of operation sequences .",
    "we will show that it is possible to define a deterministic push - down automaton that recognizes precisely one operation sequence from each equivalence class .    since , in particular , the language accepted by such an automaton is an unambiguous context free language",
    ", the results of section 2 in @xcite imply that the multivariate generating function for a representative class of operation sequences satisfies an algebraic equation . by replacing the ( variables corresponding to ) a push of @xmath37 items by @xmath120 , and any pop operations by @xmath98 , each term which represents a permutation of length @xmath0",
    "is replaced by @xmath121 and so we obtain the generating function for permutations which we can generate .",
    "thus we may conclude that the generating functions for these classes of permutations are algebraic .",
    "* first , we introduce a simple form of reduction for operation sequences , which allows us to consider only operation sequences which are in reduced form . *",
    "second we argue that if two reduced operation sequences represent the same permutation , then they must have the same `` profile '' ( as defined below ) . *",
    "finally we argue that even when two reduced operations sequences have the same profile , they can only represent the same permutation in certain special circumstances , circumstances so restrictive that , when the operation sizes are bounded we can find a suitable automaton .      in the operation of a forkstack",
    "let @xmath123 $ ] denote the operation of pushing @xmath16 elements onto the stack , and @xmath124 $ ] the operation of popping @xmath17 elements from it .",
    "if the parameter @xmath16 or @xmath17 is omitted , it is taken to equal 1 .",
    "a well formed operation sequence is then a word in the symbols @xmath123 $ ] and @xmath124 $ ] with @xmath16 and @xmath17 running over the positive integers , which has the property that for any initial segment , the sum of the push sizes is at least as great as the sum of the pop sizes , and over the whole sequence those sums are equal .",
    "the size of an operation sequence is the sum of all its push ( or pop ) sizes , that is , it is the size of the input sequence which it rearranges .",
    "two operation sequences are equivalent if they have the same size , @xmath0 , and produce the same permutation when acting on input @xmath125 .",
    "we associate with each operation sequence a series of vertices in the upper quadrant of the plane .",
    "if the sequence is @xmath126 then the associated vertices are @xmath127 through @xmath128 , where @xmath129 and for @xmath130 : @xmath131 $ , } \\\\ v_{i-1 } + ( a_i , -a_i ) &   \\mbox{if $ \\alpha_i = \\tau[a_i]$. } \\end{array } \\right.\\ ] ] we also associate with this sequence the path formed by the union of the closed line segments @xmath132 $ ] for @xmath133 .",
    "this path , which we call the _ profile _ of the operation sequence , is of course a dyck path and , in the restricted case where only single pops and pushes occur , the fact that distinct paths represent inequivalent operation sequences is one of the methods for connecting stack - sortable permutations to the catalan sequence .",
    "much of the difficulty in dealing with more general operation sequences arises because the relation of equivalence is not directly connected either to paths , or to their vertices . in figure [ lattpath ]",
    "we illustrate a lattice path for producing the sequence @xmath134 .",
    "notice that because the output occurs onto a stack , the first element popped from the working stack actually becomes the last element of the output permutation .",
    "suppose that within an operation sequence we have a consecutive pair of elements @xmath123 \\tau[b]$ ] with either @xmath135 , or @xmath136 .",
    "if @xmath137 we may replace this pair by the sequence @xmath138 $ ] , and thus produce an equivalent sequence .",
    "if @xmath139 we may replace it with with @xmath140 \\sigma^a \\tau^a$ ] . by performing a sequence of such reductions we can produce an equivalent operation sequences in which the only peaks in the profile are represented as pairs @xmath141 .",
    "at that point , no further transformations of this type are available . we will call an operation sequence with this property , _",
    "reduced_. we have seen that every operation sequence is equivalent to at least one reduced one ( `` at least '' is necessary here since for example @xmath142 \\tau[3]$ ] is equivalent to both of @xmath143 \\sigma \\tau \\tau[2]$ ] and @xmath144 ) .",
    "consider the form of a permutation produced through the operation of a forkstack according to a reduced operation sequence , @xmath145 at each peak , a sequence of pushes , culminating in the push of a single item , is followed by a sequence of pops , beginning with the pop of a single item .",
    "of course this item , call it @xmath146 , was the same as the one pushed by the final push  we say that @xmath146 is produced by this particular @xmath141 pair .",
    "as all the elements larger than @xmath146 are still in the input at the time that it is popped we see that , in the final permutation @xmath9 produced by the sequence , @xmath146 will be larger than all the elements that follow it .",
    "such an element will be called a local maximum of @xmath9 read right to left .",
    "all other pops which directly follow this particular peak ( i.e. which take place before any more pushes ) will produce elements in @xmath9 which were already in the stack before @xmath146 was added , that is , elements smaller than @xmath146 .",
    "this argument establishes :    let @xmath22 be a reduced operation sequence which produces a permutation @xmath9 .",
    "the elements of @xmath9 which are produced by the @xmath141 pairs forming the peaks of the profile of @xmath22 are the local maxima of @xmath9 read right to left .",
    "suppose that @xmath22 , as above , is a reduced sequence producing the permutation @xmath9 . by the preceding lemma , we can identify the elements of @xmath9 which arise from peaks in @xmath22 .",
    "any two peaks are separated in the profile by a descent followed by a rise .",
    "the total length of the descent is the number of elements popped between the peaks , and so is equal to the size of the gap between the two corresponding elements of @xmath9 .",
    "the size of the rise is equal to the difference in the values of the local maxima .",
    "as these quantities depend only on @xmath9 and not on @xmath22 , the profile of @xmath22 is determined by @xmath9 .",
    "next we will show that some of the segments making up the profile of a reduced sequence @xmath22 must also occur in any reduced sequence @xmath147 equivalent to @xmath22 .",
    "unimaginatively , we refer to these as _ fixed operations_. in order to characterise the fixed operations we need to introduce the notion of _ corresponding operations _ within an operation sequence .",
    "these are most easily understood in terms of the forkstack operation .",
    "namely , we define the _ support _ of each push operation to be the set of elements that it places on the stack ( which is , of course , an interval ) , and of each pop operation to be the set of elements which it removes from the stack ( not necessarily an interval ) . a push and a pop operation form a corresponding pair if their supports have non - empty intersection .",
    "graphically , a push and a pop operation form a corresponding pair if there is a horizontal line segment joining some interior point of the segment of the profile corresponding to each of the operations which intersects the profile only at its endpoints ( a connected piece of a contour line at a non - integer height ) .",
    "let @xmath22 be an operation sequence , and @xmath148 an element of @xmath22 representing a push that satisfies the conditions of the proposition .",
    "certainly the size , @xmath16 , of @xmath148 is at least two .",
    "suppose that @xmath148 pushes elements @xmath149 through @xmath150 onto the stack .",
    "up to and including the first pop , @xmath151 , corresponding to @xmath148 , the output will consist of some elements smaller than @xmath149 ( output before the push @xmath148 was made ) , a non - empty interval @xmath152 $ ] , and an interval @xmath153 $ ] , for some @xmath154 ( @xmath70 will be the length of the overlap between the segment of the profile associated with @xmath151 , and that associated with @xmath148 )",
    ". among the subset of these elements which are larger than @xmath41 , the first element output ( corresponding to a peak ) will be larger than @xmath150 .",
    "suppose that @xmath41 had not been output before the push @xmath148 was made . then before @xmath150 or @xmath41 are output , some other element @xmath155 representing any one of the peaks separating the pops corresponding to @xmath148 will be output .",
    "so , from the permutation alone we can determine that @xmath149 was added to the stack above both @xmath41 and @xmath150 ( but not @xmath156 ) .",
    "that is , the push of the interval @xmath157 $ ] is fixed , as claimed .    on the other hand ,",
    "if @xmath41 had already been output when the push @xmath148 was made , then it is separated from @xmath149 in the output by an element larger than @xmath150 , and using the remainder of the argument in the previous paragraph we can again deduce that @xmath149 was added to the stack above both @xmath41 and @xmath150 ( but not @xmath156 ) , and hence that the push @xmath148 is fixed .",
    "let @xmath148 be such a push , and @xmath151 such a pop .",
    "first consider the case where @xmath151 pops only elements which were pushed by @xmath148 .",
    "then @xmath151 partitions the support of @xmath148 into three pieces , an initial segment @xmath36 , a segment @xmath158 which is the support of @xmath151 , and a remainder @xmath159 . in the output stack ,",
    "all the elements of @xmath36 are lower than all the elements of @xmath158 which are in turn lower than all the elements of @xmath159 . since @xmath36 , @xmath158 , and @xmath159 occurred in that order in the input stack ( as @xmath148 was fixed ) , all of the elements in @xmath36 had to be popped before any elements of @xmath158 , and all of them before any elements of @xmath159 .",
    "furthermore the elements of @xmath158 must have been popped as a block since they occur in order in the output stack .",
    "that is , @xmath151 is fixed .",
    "essentially the same argument applies when the segment representing @xmath151 extends above , below , or both above and below , the ends of the segment representing @xmath148 .",
    "consider , for the sake of illustration , the first of these possibilities .",
    "then @xmath151 pops from storage a block consisting of elements pushed by operations later than @xmath148 , and then a non - empty initial segment @xmath36 of the block pushed by @xmath148 . if the initial part of this segment were broken up in any way ( or extended further ) then elements of the output which should be above @xmath36 would be below it , or vice versa . if the end of @xmath151 were pushed downwards , then elements not in @xmath36 would finish below it in output , again an inconsistency with the output permutation .",
    "a _ rise - fall _ subsequence of an operation sequence is a minimal pair of subwords , the first of which consists entirely of pushes , and the second entirely of the corresponding pops , both of the same size .",
    "two operation sequences are _ rise - fall _ related , if one is obtained from the other by replacing one rise - fall subsequence with another ( in the corresponding part of the operation sequence ) without changing the output permutation .    for example , in the operation sequence : @xmath160^a \\sigma[2 ]",
    "\\sigma[1]^b \\tau[1]^b \\tau[1 ] \\sigma[1]^c \\tau[1]^c \\tau[1 ] \\tau[2]^a \\tau[1]^a\\ ] ] there are three rise - fall subsequences , @xmath16 , @xmath17 , and @xmath161 ( the latter two in some sense trivial ) as marked by the superscripts .",
    "write this sequence as @xmath142 \\beta \\tau[2 ] \\tau[1]$ ] .",
    "it is rise - fall related to both of : @xmath162 \\sigma [ 2 ] \\ : \\beta \\ : \\tau [ 1 ] \\tau [ 2 ] \\quad \\mbox{and , } \\\\",
    "\\sigma[2 ] \\sigma[1 ]   \\ : \\beta \\ : \\tau[3 ] , \\end{array}\\ ] ] because @xmath160 \\tau[2 ] \\tau[1 ] { \\sim}\\sigma[1 ] \\sigma[2 ] \\tau[1 ] \\tau[2 ] { \\sim}\\sigma[2 ] \\sigma[1 ] \\tau[3].\\ ] ]      almost by definition , the only changes that can be made to a reduced operation sequence in order to form another such sequence modify unfixed pushes or pops . in a reduced operation sequence @xmath22 , consider any maximal subword @xmath163 of unfixed pushes . if the last pop corresponding to @xmath164 ended strictly below @xmath164 it would either correspond also to a fixed operation , @xmath165 , or in the event that @xmath165 were a pop , its corresponding operations would not form a subword of @xmath22 .",
    "so , it would be fixed , and hence so would @xmath164 be .",
    "thus the last pop @xmath166 , corresponding to @xmath164 ends at the level where @xmath164 begins .",
    "similarly , the first pop , @xmath167 , corresponding to @xmath168 begins where @xmath168 ends .",
    "either the subword from @xmath167 through @xmath166 consists of exactly the pops corresponding to elements @xmath164 through @xmath168 , or there are some interposed valleys and peaks . in the latter case , by the same argument as above , the bottoms of these valleys must occur at junction points between the elements @xmath164 through @xmath168 , and these junction points are determined by the positions of the various elements pushed by @xmath164 through @xmath168 relative to the local maxima of the output permutation read right to left . in other words , @xmath169 breaks apart into a sequence of the rise parts of rise - fall subsequences .",
    "the elements on which these rises operate are determined by the profile , and so the only scope for modification in producing an equivalent sequence is in changing some or all of these rise - fall subsequences through rise - fall equivalences .",
    "these changes operate independently of one another , and so we simply obtain the transitive closure of rise - fall relatedness .    it remains to characterize rise - fall relatedness , that is to determine which sequences of the form : @xmath170 \\sigma[a_2 ] \\cdots \\sigma[a_k ] \\tau[b_l ] \\tau[b_{l-1 } ] \\cdots \\tau[b_1]\\ ] ] represent the same permutations .",
    "let @xmath174 , and let : @xmath175 in order to analyse which other sequences this might be rise - fall related to we return to the analogy of reordering a stack of boxes using two forklifts . when considering rise - fall sequences the operations consist of a series of moves from the input stack to a storage stack , followed by another series of moves from the storage stack to the final output .",
    "so we represent the original input sequence @xmath176 as a column of numbers , with @xmath98 at the top . we _",
    "mark _ this column ( between elements ) on the left hand side after the first @xmath177 elements for each @xmath178 , and on the right hand side after the first @xmath179 elements for each @xmath180 .",
    "if we think of the markings as slips of paper , say red paper for the left marks , and blue ones for the right marks , then they can be used to instruct the forklift operators how to carry out the rise - fall sequence .",
    "the pushes are done by breaking the input stack at each red slip .",
    "then the pops are carried out by breaking the storage stack at the blue slips .",
    "the minimality criterion is precisely that there is no pair of boxes having both a red and a blue slip between them .",
    "obviously the blocks of the input between the marks are left intact , but some rearrangement of those blocks is carried out . if we could argue that the blocks originally consecutive in order were not consecutive and in the same order in the output , and that we could determine the markings from the rearrangements of the blocks alone , then it would follow that two distinct sequences represent different permutations .",
    "of course we can not prove this , for we have already seen that equivalence is a non - trivial relation on rise - fall sequences .",
    "however , we shall show that all such sequences which belong to non - singleton equivalence classes belong to two well - defined types : @xmath181 , and @xmath182 or @xmath183 .    to do this ,",
    "replace each block by a single element .",
    "there are now @xmath184 elements , @xmath185 markings on the left , and @xmath186 on the right .",
    "we represent the marks as a sequence of @xmath187 s and @xmath188 s , representing the side on which each mark occurs , reading from the top of the input stack downwards .",
    "we will argue that , provided @xmath189 and there are marks on both sides prior to the last one , then we can determine _ from the output permutation alone _ the type ( @xmath187 or @xmath188 ) of the final mark , and the permutation which arises from deleting it and the last element .",
    "suppose first that the final mark is on the right .",
    "the last push move will then be some sequence from @xmath190 through @xmath0 .",
    "this will be followed by singleton pops , leaving the tail of the output permutation as @xmath191 . assuming that this suffices to identify the position of the final mark",
    ", we can also identify the form of the permutation obtained by deleting @xmath0 and the final mark .",
    "it is obtained by deleting @xmath192 from the output permutation and changing @xmath0 to @xmath192 .",
    "note also in this case that @xmath0 never immediately follows @xmath192 in the output .",
    "now suppose that the final mark were on the left .",
    "this time , the top of the storage stack , after all the pushes have been made , begins with @xmath0 followed either by a descending sequence beginning with @xmath192 ( corresponding to other single pushes ) , or by a block from @xmath190 through @xmath192 for some @xmath190 . in the first case ,",
    "the entire descending block plus one more element is removed by the first pop , leaving an output tail of the form @xmath193 where @xmath194 . here",
    "note that the tail definitely differs from the right - marked case . in the other situation",
    "we begin with a doubleton pop leaving a tail of @xmath195 , again different from the right - marked case . in either case simply deleting @xmath0 from the final permutation leaves the permutation that results from deleting it from the input also .",
    "so , these cases can be identified from the form of the output permutation .",
    "if @xmath189 and all the marks save the last are on the same side , then we can tell if the final mark is on the opposite side and also which side the original marks were on . for note",
    "that the permutation marked by @xmath196 is @xmath197 , that marked by @xmath198 is @xmath199 . if the final mark on the same side , then it is still not possible to determine the marking as both @xmath200 and @xmath201 produce @xmath202 .",
    "we see that our goal of identifying the final mark , and the permutation arising when the final element is deleted is achievable if @xmath189 and if marks occur on both sides . the only ambiguities that might seem to arise in the entire mark sequence then are either in the first two positions , or in a block of left marks at the top which might be changed to right marks .",
    "however , it is easily checked that the latter case results in a different output permutation provided that there are marks on both sides in the whole permutation .",
    "furthermore , the only case where the output permutation contains consecutive elements @xmath37 and @xmath203 in that order occurs when @xmath204 , where we can produce @xmath205 through a @xmath206 marking , and @xmath207 through a @xmath208 one . adding an additional mark on either side in either case breaks the consecutive pair , and we have seen above , that no later consecutive pairs can be formed .    what ambiguity does that leave us at the original level of elements rather than blocks ?",
    "if no pair of blocks which were originally consecutive in the input are consecutive in that order in the output sequence then they are uniquely identified .",
    "so , if there are at least three marks and they occur on both sides , then the final permutation determines the marking ( that is , the operation sequence ) completely .",
    "if the blocks are descending , then all the marks go on one side , but we are free to choose which , and this gives two operation sequences producing a single permutation .",
    "these two sequences are represented in general by : @xmath209 \\sigma[c_2 ] \\cdots \\sigma[c_k ] \\tau[m ] \\quad \\mbox{and } \\quad \\sigma[m ] \\tau[c_1 ] \\tau[c_2 ] \\cdots \\tau[c_k]\\ ] ] for any sequence @xmath210 of sum @xmath211 . in subsequent arguments",
    "we will always assume that the first of these sequences is chosen as the representative of its equivalence class , in situations where both are available ( either one might overwhelm the capacity of one of our forklifts ) .",
    "this assumption is purely a matter of convenience .",
    "if there are only two marks , one on either side , then fixing one , we are free to move the other arbitrarily ( or to remove it if we wish ) . that gives for each pair @xmath212 with @xmath213 , a family of @xmath211 equivalent operation sequences all producing the permutation @xmath214 these sequences are : @xmath215 \\sigma[m-1 ] \\tau[j-1 ]",
    "\\tau[m - j+1 ] \\\\",
    "\\sigma[2 ] \\sigma[m-2 ] \\tau[j-2 ] \\tau[m - j+2 ] \\\\ \\vdots \\\\ \\sigma[j ] \\sigma[m - j ] \\tau[m ] \\\\",
    "\\sigma[j+1 ] \\sigma[m - j-1 ] \\tau[m-1 ] \\tau[1 ] \\\\ \\sigma[j+2 ] \\sigma[m - j-2 ] \\tau[m-2 ] \\tau[2 ] \\\\ \\vdots \\\\",
    "\\sigma[m ] \\tau[j ] \\tau[m - j ] .",
    "\\end{array}\\ ] ] finally , there is the case where there are no marks , arising from an original pair @xmath216 \\tau[m]$ ] .",
    "this of course represents the identity permutation , but that permutation can also be constructed in many other ways by allowing left and right marks , all at the same levels .",
    "we will always assume that the chosen representative for this equivalence class is @xmath217 .",
    "in the case where there are no limits on the sizes of the push and pop operations , each other non - trivial equivalence class of rise - fall sequences contains exactly one element which involves a series of pushes followed by a single pop .",
    "we intend to show that it is possible to construct a deterministic push down automata which recognizes only fully reduced sequences , and exactly one such from each equivalence class of operation sequences when the size of a push is bounded by @xmath5 and that of a pop by @xmath6 . once again , the construction will be more transparent if we first ignore the restriction on the sizes ( though of course this requires us to allow infinitely many states ) , and then to show that introducing those restrictions trims the automaton down to a manageable , that is finite , size .    [ dpda ]",
    "let @xmath218 be given .",
    "there exists a deterministic push down automata whose accepted language consists only of fully reduced operation sequences for the bounded forkstack where pushes up to size @xmath5 and pops up to size @xmath6 are allowed , and which contains exactly one such sequence from each equivalence class .",
    "we begin by constructing a rudimentary automaton to recognize any reduced operation sequence without bounds on the sizes of push or pop operations .",
    "this automaton simply has a stack holding two types of symbols , which we will call red plates and white plates , together with a register which records whether the preceding operation was a push or a pop . in the initial state",
    "the stack is empty .",
    "each push operation @xmath219 $ ] , beginning from a state where the top plate is red ( or the empty stack ) , simply puts @xmath220 white plates , and one red plate onto the stack , and records the last operation as a push .",
    "a pop operation @xmath14 $ ] basically pops the top @xmath15 elements from the stack .",
    "however , it can fail in two ways : if the stack contains fewer than @xmath15 plates making the pop impossible , and also if the preceding operation was a push , and @xmath221 or @xmath183 and after the pop the top plate of the stack is not red .",
    "the accepting states are any state with an empty stack .",
    "it is clear that this automaton recognizes precisely the reduced operation sequences .    in order to recognize only a single element from each equivalence class",
    "we augment the automaton with green and amber plates , a dictionary , and a notepad .",
    "the dictionary contains a chosen representative of each equivalence class of rise - fall sequences .",
    "metaphorically , the purpose of the notepad is to allow us to keep a record when we are making pops which might possibly be part of a rise - fall sequence .",
    "if we discover this to be false , we stop making notes , and return to a blank page . if we determine that such a sequence has in fact occurred , we check it against the dictionary to see whether it is the chosen representative of its particular equivalence class .",
    "the purpose of the new coloured plates are to provide markers where rise - fall sequences are broken up by intervening operations .",
    "when a push operation follows a pop , before adding plates to the stack the top plate is replaced with a green plate if it was white , and an amber one if it was red .",
    "green plates definitely break up any potential rise - fall sequences and so will cause recording on the notepad to cease .",
    "amber plates behave as green plates if they occur internally within a potential rise - fall sequence , but as red ones if they form either end of such a sequence .    formally then",
    ", we begin recording on the notepad each time that a pop sequence begins with a red or amber plate on top of the stack . if at any point during a recording sequence we pop a green or amber plate , we discard the current contents of the notepad , and do not begin recording again until we reach a state where the top of the stack is red or amber . on the notepad",
    "we record the size of the pop made , and the size(s ) of the pushes that it matches .",
    "if , after making the pop , the top of the stack is again red or amber , we check to see whether we have matched exactly one push ( in which case we fail if the pop we just made was of more than one element ) , two pushes @xmath16 and @xmath17 or some sequence of @xmath222 pushes . if there were two pushes we determine whether @xmath223 \\sigma[b ] \\tau[a+b]\\ ] ] is the chosen representative of that equivalence class .",
    "if so , we discard the notes , and begin a fresh set . if not , we fail .",
    "if we matched at least three pushes , then we simply continue with a fresh set of notes .",
    "if , on the other hand , after the pop the top is white we check to see whether we have already consumed at least two pushes .",
    "if so , we discard the notes and wait until the next time the top of the stack is red or amber before beginning to record again . if not , but the next element is a push , we again discard the notes . if the next element is a pop , we do it , and then check whether the two pops we have made have consumed exactly one or two pushes .",
    "if so , we check this sequence against the dictionary to see whether it is the chosen representative , and continue if it is , discarding these notes as usual , failing otherwise . if our two pops have not yet used up a single push , we continue with pops ( discarding notes if there are any intervening pushes as usual ) until we have either overrun , or precisely matched a single push . in the latter case",
    "we fail , since our chosen representative of that type consisted of a series of pushes followed by a single pop .",
    "having made all these modifications it is now clear that our machine recognizes exactly the reduced sequences all of whose rise - fall subsequences are the chosen representatives of their equivalence classes , and only these .",
    "now consider the case where the size of a push is limited to @xmath5 and that of a pop to @xmath6 .",
    "a minor modification is required in the situation where a series of pops matches a single push . in the limited power situation",
    "we now fail only if each of the pops could have been handled as a push and the whole sequence of elements could have been handled with a single pop .",
    "otherwise , we discard notes and continue fresh .",
    "the only situation in which we need to record sequences of more than four moves on the notepad is when a series of pops are being matched to a single push .",
    "this can lead to failure only if the total size of the pops is at most @xmath6 ( the pop limit ) and so the length of such a sequence is certainly bounded by @xmath54 ( we need to record the push as well ) . in any case , the notepad , and hence the automaton , has only finitely many states . of course the alphabet is finite as well , consisting of @xmath5 symbols for pushes , and @xmath6 for pops .",
    "the resulting automaton still recognizes precisely a single representative of each equivalence class of fully reduced operation sequences in the reduced machine , exactly as we required .    for any natural numbers @xmath5 and @xmath6 , the class of permutations which can be generated by a forkstack whose pushes",
    "are limited to size at most @xmath5 , and whose pops are limited to size at most @xmath6 has an algebraic generating function . by reversal , this is also true of the class of permutations sortable by such a machine .    for the case",
    "where @xmath118 we have carried out the construction of the deterministic push down automaton , analysed the resulting unambiguous context free grammar , and applied the methods of @xcite in order to determine the generating function @xmath224 of this class .",
    "the algebraic equation that @xmath224 satisfies is : @xmath225 the radius of convergence of @xmath224 is the least positive root of : @xmath226 and has value approximately @xmath227 .",
    "note that this is already smaller than the radius of convergence in the case @xmath66 , @xmath228 which was @xmath229 .",
    "this corresponds to a larger exponential rate of growth in the class size . in other words , it is better to have two forklifts each of which can move two boxes , than one which can move only one , regardless of how powerful the other one is !    in fact , we can extend theorem [ dpda ] to the case where one or the other ( but not both ) of @xmath5 or @xmath6 is infinite .",
    "consider the latter case .",
    "we do nt have a problem with our notepad since we never need to worry about pops of size larger than @xmath5 , or sequences of more than @xmath5 pops belonging to an equivalent pair .",
    "we do have a problem with the alphabet as we seem to need an infinite number of pop symbols .",
    "however , we deal with this by introducing a new symbol @xmath230 , whose operational interpretation is as a single pop of the stack , but which we require to occur in blocks of length at least @xmath231 ( a condition which is easy to enforce while retaining finitely many states ) .",
    "when @xmath230-pops are occurring , no recording takes place because these can never be part of a rise - fall sequence .",
    "so , that leaves only :            n.  chomsky and m.  p.  schtzenberger : the algebraic theory of context - free languages , in : _ computer programming and formal systems _ ed .",
    "p. braffort , d. hirschberg , north holland , amsterdam , 1963 , 118 - 161 ."
  ],
  "abstract_text": [
    "<S> a fork stack is a generalised stack which allows pushes and pops of several items at a time . </S>",
    "<S> we consider the problem of determining which input streams can be sorted using a single forkstack , or dually , which permutations of a fixed input stream can be produced using a single forkstack . </S>",
    "<S> an algorithm is given to solve the sorting problem and the minimal unsortable sequences are found . </S>",
    "<S> the results are extended to fork stacks where there are bounds on how many items can be pushed and popped at one time . in this context </S>",
    "<S> we also establish how to enumerate the collection of sortable sequences . </S>"
  ]
}