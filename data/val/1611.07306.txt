{
  "article_text": [
    "the cocoa project dates back to 1987 under the lead of l.  robbiano : the aim was to create a software laboratory for studying commutative algebra and especially grbner bases , and which is welcoming even to mathematicians who are wary of new - fangled computers ,    since then the realm of applicability of grbner baseshas continually expanded , so the researchers interested in using them now come from a broad palette of subject areas ranging from the theoretical to quite practical topics .",
    "so there are still the `` pure '' mathematicians as at the outset , but now also `` programming '' mathematicians , and statisticians , computer scientists , and so on .",
    "a factor crucial in making grbner basesrelevant to practical problems is the interim progress in computer hardware and software techniques .    since its beginning",
    "the cocoaproject has evolved and has been rewritten , and now comes in the form of a very flexible software combination cocoa-5/cocoalib , while maintaining its tradition of being _ user - friendly _ so it offers grbner basesfor all levels of interest and programming ability : _ a grbner basisfor everyone_. this means that the `` cocoaexperience '' covers a wide range : from the basic , quick call in the interactive system cocoa-5  @xcite , to the problem - specific optimized implementations , to the computer  computer communication with the open source c++ software library , cocoalib  @xcite , or with the prototype openmath - based server .",
    "the importance that grbner baseshave acquired derives from the fact they enable or facilitate so many other computational mathematical results .",
    "a natural consequence is that a grbner basisis almost never the final answer that is sought , but just a stepping stone on the way to the goal .",
    "it is very rare that anyone really wants to have a grbner basis , let alone actually look at one    usually they are frighteningly large beasts !      cocoa-4 was widely appreciated for its ease of use , and the naturalness of its interactive language .",
    "however , it did have limitations , and several `` grey areas '' .",
    "we designed the new cocoa-5 language to strike a balance between backward - compatibility ( hoping not to alienate existing cocoa-4 users ) and greater expressibility with a richer and more solid mathematical basis ( eliminating those `` grey areas '' ) .",
    "so , what s not new ? superficially the new cocoa-5 language / system closely resembles cocoa-4 because we kept it largely backward compatible ; at the same time it improves the naturalness and ease of use of the old system .",
    "we are very aware that a number of cocoa users are mathematicians with only limited programming experience , for whom learning cocoa was a `` big investment '' , and who are reluctant to make another big investment    that is why we wanted to make the passage to cocoa-5as painless as possible .",
    "so , if almost nothing has changed , what s new ?",
    "the clearly defined semantics of the cocoa-5new language make it both more robust and more flexible ; it provides greater expressibility and a more solid mathematical basis .",
    "in particular , it offers full flexibility for the field of coefficients : _",
    "e.g. _  fraction fields and algebraic extensions , and even heuristically guaranteed floating point arithmetics with rational reconstruction ( see section  [ sec : twinfloats ] ) .",
    "however , under the surface , the change is radical since its mathematical core , cocoalib , has been rewritten from scratch , to be faster , cleaner and more powerful than the old system , and also to be used as a c++ library .",
    "the glib answer is : _ as little as possible ! _",
    "a more honest answer is that that is our aim , but there is more work still to do . in any case , using cocoa-5will not magically make you into a c++ programmer , so some differences will necessarily remain .",
    "cocoa-5is an interactive , interpreted environment which makes it far better suited to `` rapid prototyping '' than the rigid , statically typed regime of c++ .",
    "to keep it simple to learn , cocoa-5has only a few data types : for instance , a power - product in cocoa-5 is represented as a monic polynomial with a single term , _",
    "i.e. _  a ring element ( of a polynomial ring ) ; in contrast , in cocoalibthere is a dedicated class , ` ppmonoidelem ` , which directly represents each power - product , and allows efficient operations on the values ( _ e.g. _  without the overhead of the superfluous coefficients ) .",
    "cocoalib  @xcite contains ( practically ) all the mathematical knowledge and ability while cocoa-5offers convenient access to cocoalib s capabilities .",
    "programming with cocoalibtends to be more onerous than with cocoa-5largely because of c++ s demanding , rigid rules ; the reward is typically faster computation ( sometimes much faster ) .",
    "also , of course , those who want to use cocoalib s abilities in their own c++ program have to use cocoalib , see section  [ sec : cocoalib ] .",
    "this is why everything which can be computed with cocoa-5 should be just as readily computable with cocoalib .",
    "some cocoa-5functions are still implemented in cocoa-5 packages ; but they are being steadily translated into c++ .",
    "( we do nt say which ones , because the list is constantly shrinking )",
    "the simplest context for grbner bases is for ideals in @xmath0 $ ] or @xmath1 $ ] with  @xmath2 a prime . these are also the easiest cases to give to cocoa .    an essential ingredient in the definition of a grbner basisis the term - ordering : a total ordering on the power - products which respects multiplication , and where 1 is the smallest power - product . in cocoathe term - ordering",
    "is specified at the same time as the polynomial ring ; all grbner basesof ideals in that polynomial ring will automatically be computed with respect to that ordering    unless otherwise specified , the ordering is `` degree reverse lexicographic '' , which is known to be the `` best general choice '' .",
    "cocoahas a fully general ( matrix - based ) implementation of term - orderings , with efficient handling of some common special cases .",
    "here is an example of computing a grbner basisin cocoa :    .... /**/",
    "use qq[x , y , z ] ; /**/ i : = ideal(x^3 + x*y^2 -2*z , x^2*y^3 -y*z^2 ) ; /**/",
    "gbasis(i ) ; [ x^3 + x*y^2 -2*z , x^2*y^3 -y*z^2 , x*y^5 -2*y^3*z + x*y*z^2 , .... ] ....    as mentioned above , the default ordering is ` stddegrevlex ` , which _ generally _ gives the best performance and smallest answer .",
    "however , other gradings and orderings may be useful for studying specific problems : for instance , an important family are the _ elimination orderings _ which are used implicitly in section  [ sec : elim ] .",
    "another well - known ordering is `",
    "lex ` , which gives a grbner basiswith a particular _ shape _ useful for solving polynomial systems ( see , for example , the kreuzer  robbiano book  @xcite , sec.3.7 ) .",
    "their practical usefulness is limited by the fact that ` lex ` bases tend to be particularly big and ugly , and are frequently rather costly to compute .    in cocoathe term - ordering",
    "is an intrinsic property of a polynomial ring : this means that @xmath0 $ ] with ` lex ` is viewed as a different ring from @xmath0 $ ] with ` stddegrevlex ` .",
    "here is an example of computing a ` lex ` grbner basis ; note how the term - ordering is specified at the start along with the polynomial ring .    .... /**/",
    "use qq[x , y , z ] , lex ; //",
    "specify ordering together with ring /**/",
    "i : = ideal(x^3 + 3 , y - x^2 , z - x - y ) ; /**/ reducedgbasis(i ) ;    // basis is wrt .",
    "lex ordering [ z^3 + 9*z -6 ,   y -(1/4)*z^2 -(3/4)*z -3/2 ,   x + ( 1/4)*z^2 -(1/4)*z + 3/2 ] ....    in the last example above we used the command ` reducedgbasis ` which computes a reduced grbner basiswhich is a `` cleaned up '' grbner basis with only non - redundant , monic , fully reduced elements    it is unique ( up to the order of the elements ) .",
    "the easy examples above show the definition of a polynomial rings with rational coefficients , but the choice in cocoais quite wide .",
    "for example @xmath3 where @xmath2 may also be quite large , or algebraic extensions , of fraction fields .    ....",
    "/**/ use zz/(100000000000000000000000000319)[x ] ; /**/",
    "reducedgbasis(ideal(3*x-1 ) ) ; [ x -33333333333333333333333333440 ]    /**/ use r : : = qq[i ] ; /**/",
    "qqi : = r / ideal(i^2 + 1 ) ; /**/ use qqi[x ,",
    "y , z ] ; /**/ i : = ideal(i*x^3 -z , x^2*y^3 -i*y*z^2 ) ; /**/",
    "reducedgbasis(i ) ; [ x^3 + ( i)*z , y^3*z + x*y*z^2 , x^2*y^3 + ( -i)*y*z^2 ]    /**/ use r : : = qq[sqrt2 , sqrt3 ] ; /**/ k : = r / ideal(sqrt2 ^ 2 -2 , sqrt3 ^ 2 -3 ) ; /**/",
    "use k[x , y , z ] ; /**/ i : = ideal(sqrt3*x^2 -y , x*y -sqrt2*z ) ; /**/",
    "reducedgbasis(i ) ; [ y^2 + ( -sqrt2*sqrt3)*x*z , x*y + ( -sqrt2)*z , x^2 + ( ( -1/3)*sqrt3)*y ]    /**/ use qqab : : = qq[a , b ] ; /**/",
    "k : = newfractionfield(qqab ) ; /**/",
    "use k[x , y , z ] ; /**/",
    "i : = ideal(x^3 -a*z , x^2*y^3 -b*y*z^2 ) ; /**/ reducedgbasis(i ) ; /**/ [ x^3 -a*z , y^3*z + ( -b / a)*x*y*z^2 , x^2*y^3 -b*y*z^2 ] ....",
    "please note in this last example @xmath4 is actually the field @xmath5 with no specialization of @xmath6 .",
    "so the grbner basisrepresents the _ generic _ case , meaning that an algebraic expression in @xmath7 which is not identically zero is considered to be non - zero .",
    "the problem of considering all possible specializations of the parameters is known as _ comprehensive grbner basis _ , and is not ( yet ) implemented in cocoa .",
    "another family of computationally interesting rings in cocoais given by ` newringtwinfloat(bitprec ) ` .",
    "it will be presented in detail in sections  [ sec : gin ] and [ sec : twinfloats ] .",
    "there is a notion of _ universal grbner basis _ which is a grbner basisfor every term - ordering .",
    "the cocoafunction will compute one such basis ; this function is based on the computation of the grbner fan ( a richer structure , see below ) which gives all possible reduced grbner bases : we can take the union of all of them to produce the universal basis .",
    "the following example shows that the maximal minors of a @xmath8 matrix of indeterminates form a universal grbner basisof the ideal they generate :    .... /**/ use r : : = qq[a , b , c , d , e , f , g , h , i , j , k , l ] ; /**/ i : = ideal(minors(mat([[a , b , c , d],[e , f , g , h],[i , j , k , l]]),3 ) ) ; /**/",
    "indent(universalgbasis(i ) ) ; [    d*g*j -c*h*j -d*f*k + b*h*k + c*f*l -b*g*l ,    d*g*i -c*h*i -d*e*k + a*h*k + c*e*l -a*g*l ,    d*f*i -b*h*i -d*e*j + a*h*j + b*e*l -a*f*l ,    c*f*i -b*g*i -c*e*j + a*g*j + b*e*k -a*f*k ] /**/",
    "eqset(-1*gens(i ) , reducedgbasis(i ) ) ; true ....    the * grbner fan * of an ideal was defined by mora and robbiano in 1988 ( @xcite ) : it is a ( finite ) fan of polyhedral cones indexing the reduced grbner basesof the ideal .",
    "this has been implemented by jensen in his software _ gfan _",
    "( @xcite ) which he has recently linked into cocoa ; we note that cocoa s fully general approach to representing term - orderings was essential in making this integration possible .",
    "the grbner fan is useful because many well - known theoretical applications of grbner basesrely on the existence of a grbner basisof an ideal with prescribed properties , such as having a certain cardinality , or comprising polynomials of a specified degree , or all squarefree .",
    "for example , if an ideal  @xmath9 $ ] has a grbner basisfor _ some _ term - ordering comprising just quadrics , then the algebra @xmath10/i$ ] is koszul .",
    "the function ` groebnerfanideals(i ) ` returns all reduced grbner basesof the ideal  @xmath11 as a list of ideals : we chose to encode each basis in an ideal because in cocoa an ideal  @xmath11 stores internally various pieces of information , including the term - ordering and the grbner basis , so putting the result in an ideal instead of a simple list of polynomials is more efficient for any subsequent operations .",
    "the following ideal , example 3.9 from sturmfels s book @xcite , has 360 distinct reduced grbner bases :    .... /**/ use r : : = qq[a , b , c ] ; /**/ i : = ideal(a^5+b^3+c^2 - 1 , a^2+b^2+c-1 , a^6+b^5+c^3 - 1 ) ; /**/",
    "l : = groebnerfanideals(i ) ; /**/",
    "len(l ) ; 360 ....    storing all the possible different ( reduced ) grbner basesis practicable only for a small example ; larger ideals may have thousands or even millions of different grbner bases .",
    "typically we are interested only in those bases satisfying a certain property .",
    "so in cocoathere is the function ` callongroebnerfanideals ` which calls a given function on each grbner basissuccessively without having to store them all in a big list ( if the computer s memory can handle it ! ) . using this cocoafunction",
    "needs a little technical ability , but might make the difference between getting an answer or not because the computer s memory filled up :    .... define gboflen3(i )   if len(gbasis(i))=3 then     println ; println ordmat(ringof(i ) ) ;     println gbasis(i ) ;   endif ; enddefine ;    /**/ use r : : = qq[a , b , c ] ; /**/",
    "i : = ideal(a^5+b^3+c^2 - 1 , b^2+a^2+c-1 , c^3+a^6+b^5 - 1 ) ; /**/",
    "callongroebnerfanideals(i , gboflen3 ) ; matrix(zz ,   [ [ 3 , 7 , 7 ] ,    [ 3 , 6 , 8 ] ,    [ 0 , 0 , -1 ] ] ) [ b^2+c+a^2 - 1 ,   a^5+c^2-b*c - a^2*b+b-1 ,   c^3+b*c^2 + 2*a^2*b*c+a^4*b - a*c^2+a*b*c+a^3*b-2*b*c-2*a^2*b - a*b+b+a-1 ] matrix(zz ,   [ [ 6 , 7 , 14 ] ,    [ 6 , 5 , 15 ] ,    [ 0 , 0 , -1 ] ] ) [ c+b^2+a^2 - 1 ,   -b^6 - 3*a^2*b^4 - 3*a^4*b^2+b^5 + 3*b^4 + 6*a^2*b^2 + 3*a^4 - 3*b^2 - 3*a^2 ,   a^5+b^4 + 2*a^2*b^2+a^4+b^3 - 2*b^2 - 2*a^2 ] ....    here we see explicitly that cocoarepresents some term - orderings via matrices of integers .",
    "see section  [ sec : elim ] for an example of how to ask cocoato compute a grbner basiswith a term - ordering given by a matrix .",
    "let @xmath12 $ ] be a polynomial ring over a field @xmath4 , and let @xmath13 be a term - ordering on the power - products in @xmath14 .",
    "if  @xmath11 is an ideal in @xmath14 then we define its * leading term ideal * with respect to @xmath13 , written @xmath15 , to be the ideal generated by the leading power - products of all non - zero polynomials in  @xmath11 ; some authors use the name `` initial ideal '' for this notion . a generating set for @xmath15",
    "may easily be obtained : we compute a reduced @xmath13-grbner basisfor  @xmath11 then collect the @xmath13 leading terms of the elements of the basis .",
    "remarkably @xmath15 captures some interesting `` combinatorial '' information about the original polynomial ideal @xmath11 : for instance , its hilbert series    so calling ` hilbertseries(r / i ) ` contains a `` hidden '' call to ` gbasis(i ) ` .",
    "a more sophisticated tool in commutative algebra is the * generic inital ideal * of a polynomial ideal  @xmath11 .",
    "this is useful because it encodes more geometrical properties of  @xmath11 into a monomial ideal .",
    "it is defined by taking a generic change of coordinates @xmath16 ( _ i.e. _  @xmath17 in @xmath18 $ ] ) then @xmath19 . and here we have to admit that the acronym _ gin _ sounds nicer than @xmath20 !",
    "the definition of _ gin _ suggests an obvious algorithm for computing it ( see section  [ sec : morecoefficients ] for an example with _",
    "coefficients ) .",
    "however , it quickly becomes apparent that the coefficients in @xmath21 become unwieldy except for the very simplest cases ; so the obvious approach is utterly hopeless .",
    "instead we can pick an explicit , random change of coordinates @xmath22 , and then compute @xmath23 ; the coordinate changes for which @xmath24 form a zariski - open set .",
    "this approach can be used when  @xmath4 is infinite ; if the random change of coordinates is chosen from a large set then @xmath23 will indeed be @xmath25 with high probability .",
    "this is what cocoadoes .",
    "while choosing random changes of coordinates with large coefficients increases the probability of getting the correct result , it also tends to produce large coefficients in the transformed polynomials . in this example",
    "the original polynomials have very small coefficients , but there is a coefficient with almost 50 digits in the tranformed polynomials :    .... /**/ use p : : = qq[x , y , z ] ; /**/",
    "i : = ideal(y^20 -x^5*z^6 ,   x^2*z^3 -y*z^2 ) ; /**/",
    "l : = [ sum ( [ random(-1000,1000)*indet(p , j ) | j in 1 .. 3 ] )                                                     | i in 1 .. 3 ] ; /**/",
    "l ; [ 941*x -70*y -981*z , 974*x + 342*y -789*z , 398*x + 112*y -942*z ] /**/",
    "g : = polyalgebrahom(p , p , l ) ; /**/",
    "gi : = ideal(apply(g , gens(i ) ) ) ;   gi ; ideal(101148714265738572816020149152880657871065317376*x^20 + ... ,         ....... ) ....    with coefficients like that , computing the grbner basisof the transformed ideal over the rationals would be quite expensive ! thus , when choosing random coefficients , one needs to strike a balance between a wide range , so the transformation is `` generic enough '' , but not too wide , to limit coefficient growth during the computation .",
    "the implementation for computing @xmath26 in cocoauses a special approximate floating - point representation for rational coefficients , namely _ twin - floats _ ( see section  [ sec : twinfloats ] ) .",
    "the grbner basisof the twin - float transformed ideal will only have approximate twin - float coefficients , but this does not matter because we need only the leading power - products of the polynomials in the basis .",
    "twin - float numbers have fixed - precision ( so do not grow in size the way rational numbers do ) , and employ heuristics to guarantee the correctness of results .",
    "this allows the implementation to make random coefficient choices from a wide range ( in fact , integers between @xmath27 and @xmath28 ) without paying the price for calculating with transformed polynomials having complicated rational coefficients .",
    "if the chosen precision for the twin - floats is too low , this will be signalled ; and the computation can be restarted choosing a higher precision .",
    "cocoa s function ` gin ` does this all automatically . moreover , it tries a second random change of coordinates , just to make sure it gets the same leading term ideal .",
    "the internal workings can be seen via printed messages when using the option ` verbose ` .    .... /**/",
    "gin(i , \" verbose \" ) ; [    15915*x ,    872152*x -383743*y ,    412211*x -406393*y -383480*z ] -- trying with floatprecision 64 [    -925894*x ,    327379*x -729412*y ,    -945709*x + 550455*y + 499099*z ] -- trying with floatprecision 64 ideal(x^5 , x^4*y^16 , x^3*y^18 , x^2*y^20 , x*y^22 , y^24 ) ....",
    "elimination is a central topic in computational commutative algebra ( see for example the text book by kreuzer and robbiano  @xcite , sec .  3.4 ) and its applications are countless .",
    "elimination means    blue :    given an ideal @xmath29 $ ] , find a set of generators of the ideal @xmath30 $ ] where the indeterminates @xmath31 have been `` eliminated '' .",
    "given its usefulness , elimination is an operation offered in almost all computer algebra systems .",
    "we can be sure that all such elimination functions internally compute a grbner basiswith respect to an * elimination ordering * for the subset of indeterminates to be eliminated : with such an ordering the subset of polynomials in the grbner basiswhose leading terms are not divisible by any of the @xmath32 are exactly the generators we seek for the ideal @xmath33 $ ] . in the example below we see the process we described and compare it with the actual output of cocoa s own function ` elim ` .",
    "note that in both cases the generators are not minimal , but they are indeed a grbner basisof the elimination ideal ( wrt .  to the restriction of the elimination term - ordering used ) .    .... /**/",
    "m : = elimmat(4 , [ 1 ] ) ;   m ; matrix(zz ,   [ [ 1 , 0 , 0 , 0 ] ,    [ 1 , 1 , 1 , 1 ] ,    [ 0 , 0 , 0 , -1 ] ,    [ 0 , 0 , -1 , 0 ] ] ) /**/",
    "p : = newpolyring(qq , \" t , x , y , z \" , m , 0 ) ; // 0-grading /**/",
    "use p ; /**/",
    "i : = ideal(x - t , y - t^2 , z - t^3 ) ; /**/",
    "gbasis(i ) ; [ -t + x , -x^2 + y , -x*y + z , y^2 -x*z ] /**/ elim([t ] , i ) ; ideal(-x^2 + y , -x*y + z , y^2 -x*z ) /**/",
    "minsubsetofgens(ideal(-x^2 + y , -x*y + z , y^2 -x*z ) ) ; [ -x^2 + y , -x*y + z ] ....    the simple example above indeed shows a particular application of ` elim ` , the * presentation of an algebra * @xmath34\\simeq k[x_1 , ... , x_n]/i$ ] .",
    "more precisely , let @xmath35 be elements in @xmath36 $ ] , where @xmath37 is another set of indeterminates ( viewed as parameters ) and consider the @xmath4-algebra homomorphism @xmath38 \\longrightarrow k(t_1 , \\dots , t_s )   \\text { given by }   x_i \\mapsto f_i \\hbox{\\rm \\quad   for\\ }   i=1 , \\dots , n\\ ] ] its kernel is a prime ideal , and the general problem of * implicitization * is to find a set of generators for this ideal .",
    "the grbner basiselimination technique consists of defining the ideal @xmath39 in the ring @xmath40 $ ] and _ eliminating _ all the parameters @xmath41 , as we saw in the example .",
    "unfortunately this extraordinarily elegant tool often turns out to be quite inefficent , resulting in long and costly computations . knowing how to exploit special properties of a given class of examples",
    "might make a huge difference .",
    "if the algebra we want to present is generated by power - products then the elimination can be computed by the cocoafunction ; toric ideals are prime and generated by binomials .",
    "again we consider @xmath42 $ ] , and also @xmath43 $ ] :    .... /**/",
    "use qq[x , y , z ] ; /**/ toric(rowmat([1,2,3 ] ) ) ; // just the list of exponents ideal(-x^2 + y , x^3 -z )    /**/",
    "use qq[x , y , z ] ; /**/ toric(rowmat([3,4,5 ] ) ) ; ideal(-y^2 + x*z , x^3 -y*z , -x^2*y + z^2 ) ....    with a very slightly more challenging example we can clearly measure the advantage in using the specialized function over the general function :    .... /**/ use r : : = zz/(2)[x[1 .. 6 ] , s , t , u , v ] ; /**/",
    "l : = [ s*u^20 , s*u^30 , s*t^20*v , t*v^20 , s*t*u*v , s*t^2*u ] ; /**/",
    "expl : = [ [ 1 ,   1 ,   1 ,   0 , 1 , 1 ] ,                [ 0 ,   0 , 20 ,   1 , 1 , 2 ] ,                [ 20 , 30 ,   0 ,   0 , 1 , 1 ] ,                [ 0 ,   0 ,   1 , 20 , 1 , 0 ] ] ;    /**/",
    "i : = ideal([x[i ] - l[i ] | i in 1 .. 6 ] ) ; /**/ t0 : = cputime ( ) ; ie : = elim([s , t , u , v ] , i ) ; timefrom(t0 ) ; 9.274 /**/ t0 : = cputime ( ) ; it : = toric(expl ) ; timefrom(t0 ) ; 0.032 ....    the cocoafunction employs a non - deterministic algorithm : so the actual set of ideal generators produced might vary .    for further details on the algorithms implemented in cocoasee bigatti , la  scala , robbiano @xcite .",
    "the article describes three different algorithms ; the default one in cocoais eati ( _ elimination algorithm for toric ideals _ ) .    for more details on the specific function type ` ?",
    "toric ` into cocoa(or read the pdf manual , or the html manual in the web - site ) .      as mentioned",
    "earlier elimination provides a general solution to the implicitization problem , but this solution is more elegant than practical .",
    "we can do rather better in the special case of implicitization of a hypersurface .",
    "one immediate feature is that the result is really just a single polynomial since the eliminated ideal must be principal .",
    "it is well - known that buchberger s algorithm usually works better with homogeneous ideals ( though there are sporadic exceptions ) . yet the very construction of the eliminating ideal @xmath44 looks intrinsically non - homogeneous . but with a little well - guided effort we can transform the problem into the calculation of a grbner basisof a homogeneous ideal .    if the @xmath45 are all polynomials then we take a new indeterminate ( say  @xmath22 ) and use it to homogenize each @xmath45 to produce @xmath46 .",
    "now we do have a homogeneous ideal @xmath47 provided we give weights to the @xmath48 indeterminates by setting @xmath49 for each  @xmath50 .",
    "since we are in the special case of a hypersurface , it can be shown that the ( non - zero ) polynomial of lowest degree in @xmath51 is unique up to scalar multiples ; its dehomogenization is then the polynomial we seek !",
    "we get two advantages from the homogeneous ideal @xmath51 : we gain efficiency by using buchberger s algorithm degree - by - degree , and we can stop as soon as the first basis polynomial is found    most probably there will still be many pairs to process .",
    "see abbott , bigatti , robbiano  @xcite for all details and proofs , and also how to `` correctly homogenize '' parametrizations by rational functions .",
    ".... /**/ use p : : = qq[s , t , x , y , z ] ; /**/",
    "elim([s , t ] ,   ideal(x - s^2 , y - s*t , z - t^2 ) ) ; ideal(y^2 -x*z )    /**/ use r : : = qq[s , t ] ; /**/",
    "p : : = qq[x , y , z ] ; /**/",
    "implicithypersurface(p , [ s^2 , s*t , t^2 ] , \" elimth \" ) ; ideal(y^2 -x*z ) ....    in the same paper we describe another algorithm which uses a completely different technique , a variant of the buchberger - mller algorithm ( see section  [ sec : bm ] ) , based on linear algebra .",
    "it is well - suited to low degree hypersurfaces .    .... /**/",
    "implicithypersurface(p , [ s^2 , s*t , t^2 ] , \" direct \" ) ; ideal(y^2 -x*z ) ....    both algorithms , in the case of rational coefficients , use modular methods computing the result for some primes , combining them using chinese remaindering , and reconstructing the rational coefficients of  @xmath16 using the fault - tolerant rational reconstruction described in section  [ sec : faulttolerant ] .",
    "let @xmath52 be a non - empty , finite set of points in @xmath53 , then the set of all polynomials in @xmath54 $ ] which vanish at all points in  @xmath52 is an ideal , @xmath55 .",
    "one reason this ideal is interesting is because captures the `` ambiguity '' present in a polynomial function which has been interpolated from its values at the points of @xmath52 .",
    "how best to compute a set of generators for @xmath55 , or a grbner basis , knowing the points  @xmath52 ?    if @xmath52 contains a single point @xmath56 then we can write down immediately a grbner basis , namely @xmath57 $ ] . if @xmath52 contains several points we could just intersect the ideals for each single point , and these intersections may be determined via grbner basiscomputations ; while fully effective and mathematically elegant this approach is computationally disappointing .",
    "a more efficient method is the buchberger - mller algorithm  @xcite .",
    "somewhat astonishingly this uses just simple linear algebra to determine the grbner basis .",
    "the original algorithm was closely analysed in  @xcite , then later generalized to zero - dimensional schemes  @xcite , where it turned out that it also incorporates the well - known fglm algorithm for `` changing term - ordering '' of a grbner basis .",
    "the bm algorithm is also amenable to a modular approach , a technique for achieving particularly efficient computation with rational numbers .",
    "the cocoaimplementation uses this approach .    .... /**/",
    "p : : = qq[x , y ] ; /**/ points : = mat([[10 , 0 ] , [ -10 , 0 ] , [ 0 , 10 ] , [ 0 ,",
    "-10 ] ,                       [ 7 , 7 ] , [ -7 , -7 ] , [ 7 , -7 ] , [ -7 , 7 ] ] ) ; /**/",
    "indent(idealofpoints(p , points ) ) ; ideal (    x^2*y + ( 49/51)*y^3 + ( -4900/51)*y ,    x^3 + ( 51/49)*x*y^2 -100*x ,    y^4 + ( -2499/2)*x^2 + ( -2699/2)*y^2 + 124950 ,    x*y^3 -49*x*y   ) ....    the simple use of linear algebra in the bm algorithm makes it a good candidate for identifying `` almost - vanishing '' polynomials for sets of _ approximate _ points : for instance , the points in the example above `` almost lie on '' a circle of radius @xmath58 centred on the origin . the notion of grbner basisdoes",
    "not generalize well to an `` approximate context '' because the algebraic structure of a grbner basisis determined by zariski - closed conditions ( _ i.e. _  the structure is valid when certain polynomials vanish ) ; instead the notion of a _ border basis _ is better suited since its structure is valid dependent on a zariski - open condition ( _ i.e. _  provided a certain polynomial _ does not _ vanish ) .",
    "so long as the approximate points are not too few nor too imprecise the bm algorithm can compute at least a partial border basis , and this should identify any `` approximate polynomial conditions '' which the points the almost satisfy ( see abbott , fassino , torrente @xcite ) .",
    "we can ask cocoato allow a certain approximation on the coordinates of the points :    .... /**/ epsilon : = colmat([0.1 , 0.1 ] ) ; //",
    "coord approximation 0.1 /**/",
    "av : = tmpnbm(p , points , epsilon).almostvanishing ; indent(av ) ; [    x^2 + ( 4999/5001)*y^2 -165000/1667 , // almost a circle    x*y^3 -49*x*y ,    y^5 -149*y^3 + 4900*y ]    /**/ epsilon : = colmat([0.01 , 0.01 ] ) ; //",
    "coord approximation 0.01 /**/",
    "av : = tmpnbm(p , points , epsilon).almostvanishing ; /**/",
    "indent(av ) ;   //   with this epsilon , not near a conic [    x^2*y + ( 49/51)*y^3 + ( -4900/51)*y ,    x^3 + ( 51/49)*x*y^2 -100*x ,    y^4 + ( -2499/2)*x^2 + ( -2699/2)*y^2 + 124950 ,    x*y^3 -49*x*y ] ....",
    "it is well known that computations with coefficients in @xmath59 can often be very costly in terms of both time and space . for grbner",
    "basesover @xmath59 we are free to multiply the polynomials by any non - zero rational ; so we can clear denominators and remove integer content .",
    "this does yield some benefit , but is not wholly satisfactory .",
    "sometimes the grbner basishas complicated coefficients ( _ i.e. _  we mean _ big numerators and denominators _ ) , but more often the coefficients in the answer are reasonably sized , while the computation to obtain them involved far more complicated coefficients : this problem is known _ intermediate coefficient swell_.    the phenomenon of coefficient swell is endemic in computer algebra , and many techniques have been investigated to tackle this problem .",
    "we illustrate what cocoaoffers .",
    "cocoaoffers floating - point arithmetic with a heuristic guarantee of correctness : the aim is to combine the speed of floating - point computation with the reliability of exact rational arithmetic    for a fuller description see the article  @xcite .",
    "normally a twin - float computation will produce either a good approximation to the correct result or an indication of failure ; strictly , there is a very small chance of getting a wrong result , but this never happens in practice .    to perform a computation with twin - floats",
    "the user must first specify the required precision ; cocoawill then check heuristically that the result of every computation has at least that precision .",
    "if the check fails then cocoasignals an `` insufficient precision '' error ; the user may then restart the computation specifying a higher precision . although twin - float values are , by definition , approximate , all input values are assumed to be exact ( so they can be converted to a twin - float of any precision ) .",
    "it is also possible to reconvert a twin - float value to an exact rational number .",
    "like all other twin - float operations , this conversion may fail ( because of `` insufficient precision '' ) .",
    "printing out a twin - float automatically checks if the value can be converted to a rational as rationals are easier to read and comprehend .    .... /**/",
    "rr16 : = newringtwinfloat(16 ) ; /**/ use rr16_x : : = rr16[x , y , z ] ; /**/",
    "f : = 12345678*x+1/456789 ; /**/",
    "f ;           // both coeffs are printed as rationals 12345678*x + 1/456789 /**/",
    "f * 10 ^ 3 ;    //",
    "first coeff is printed in \" floating - point \" 0.12345678 * 10 ^ 11*x + 1000/456789 /**/",
    "f * 10 ^ 5 ;    // both coeffs are printed in \" floating - point \" 0.12345678 * 10 ^ 13*x + 0.2189194573 ....    twin - floats include a ( heuristically guaranteed ) test for zero ; this means it is possible to compute grbner baseswith twin - float coefficients .",
    "one reason for wanting to do this is that often the grbner basisover the rationals involves `` complicated fractions '' ( _ i.e. _  whose numerator and denominator have many digits ) , and arithmetic with such complicated values can quickly become very costly .",
    "in contrast , with twin - floats the arithmetic has fixed cost ( dependent on the precision chosen , of course ) .",
    "these characteristics are exploited in cocoafor the computation of @xmath26 described in section  [ sec : gin ] .",
    "a widely used technique for avoiding intermediate coefficient swell is to perform the computation modulo one or more prime numbers , and then lift / reconstruct the final result over @xmath59 .",
    "we call this the * modular approach*. there are two general classes of method : * hensel lifting * and * chinese remaindering * , the first is not universally applicable but does work well for polynomial gcd and factorization , while the second is widely applicable and works well in most other contexts .",
    "the modular approach has been successfully used in numerous contexts , here are a few examples : polynomial factorization  @xcite , determinant of integer matrices  @xcite , ideals of points ( see section  [ sec : bm ] ) , and implicitization ( see section  [ sec : implicit ] ) .    in any specific application",
    "there are two important aspects which must be addressed before a modular approach can be adopted , and there is no universal technique for addressing these issues .    *",
    "knowing how many different primes to consider to guarantee the result ( _ i.e. _  find a realistic bound for the size of coefficients in the answer ) ; * handling _ bad primes _ : namely those whose related computation follows a different route , yielding an answer with the wrong `` shape '' ( _ i.e. _  which is not simply the modular reduction of the correct non - modular result ) .    in the context of grbner baseswe",
    "do not have good , general solutions to either of these issues .",
    "one of the first successes in applying modular techniques to grbner basiscomputation appeared in  @xcite . finding good ways to employ a modular approach for grbner basesis still an active area .",
    "cocoadoes not currently use a modular approach for general grbner basiscomputations .",
    "a vital complement to the modular computation is the reconstruction of the final , rational answer from the modular images .",
    "cocoaoffers functions for combining to two residue - modulus pairs into a single `` combined '' residue - modulus pair ( _ i.e. _  using the chinese remainder theorem ) .",
    "it also offers functions for determining a `` simple '' rational number coresponding to a residue - modulus pair ; this is called * rational reconstruction*. correct reconstruction can still be achieved even in the presence of a few `` faulty residues '' ( see  @xcite ) ; this fault - tolerance was exploited in the functions for hypersurface implicitization ( see section  [ sec : implicit ] ) .",
    "here we see how two modular images can be combined in cocoa(using in this case ) , and then the correct rational result is reconstructed from the combined residue - modulus pair .    .... /**/",
    "p1 : : = zz/(12347)[x ] ; /**/",
    "p2 : : = zz/(23459)[x ] ; /**/",
    "f1 : = readexpr(p1 , \" x/1234 - 1/5 \" ) ;   f1 ;   // in p1 -5293*x -4939 /**/",
    "f2 : = readexpr(p2 , \" x/1234 - 1/5 \" ) ;   f2 ;   // in p2 -1806*x -4692    /**/ use p   : : = qq[x ] ; /**/",
    "combined:=crtpoly(-5293*x-4939 , 12347 ,   -1806*x-4692 , 23459 ) ; /**/ combined ;   // in p record[modulus : = 289648273 , residue : = 79571122*x + 115859309 ] /**/",
    "ratreconstructpoly(combined.residue , combined.modulus ) ; ( 1/1234)*x -1/5 ....    this reconstruction is exploited in cocoafor the computation of the implicitization of hypersurfaces described in section  [ sec : implicit ] .",
    "as mentioned in section  [ sec : cocoalib - vs - cocoa5 ] , our aim is to make computation using cocoalib as easy as using cocoa-5 . to illustrate this , here",
    "is the first example from section  [ sec : gbwithease ] but in c++ :    .... ring p = newpolyring(ringqq ( ) , symbols(\"x , y , z \" ) ) ; ideal i = ideal(readexpr(p , \" x^3 + x*y^2 - 2*z \" ) ,                  readexpr(p , \" x^2*y^3 -y*z^2 \" )   ) ; cout < < gbasis(i ) ; ....    in comparison to cocoa-5 , this c++ code is more cumbersome and involved , though we maintain that it is still reasonably comprehensible ( once you know that ` cout < < ` is the c++ command for printing ) .",
    "we have designed cocoa-5and cocoalibtogether with the aim of making it easy to develop a prototype implementation in cocoa-5 , and then convert the code into c++ .",
    "to facilitate this conversion we have , whenever possible , used the same function names in both cocoa-5and cocoalib , and we have preferred traditional `` functional '' syntax in cocoalib over object oriented `` method dispatch '' syntax ( _ e.g. _  ` gbasis(i ) ` rather than  ` i.gbasis ( ) ` ) .",
    "this means that most of the cocoa-5examples given here require only minor changes to become equivalent c++ code for use with cocoalib .    naturally , a grbner basisis rare computed in isolation ; it is usually just one step in a higher - level computation .",
    "we have designed cocoalibto be easy to use , _ e.g. _  for preparing the generators of the ideals whose grbner basesare to be computed , and also for further processing with the grbner basesafter they have been computed . to maintain the `` friendly '' tradition of cocoasoftware ,",
    "our design of cocoalibfollows these aims :    * designed to be * easy and natural to use * * execution speed is * good * * well - documented , including * many example programs * * * free and open source * c++ code ( gpl3 licence ) * source code is * clean and portable * ( currently c++03 ) * design respects the underlying * mathematical * structures + ( inheritance , no templates ) * * robust * ( motto : `` no nasty surprises '' ) , exception - safe , thread - safe",
    "the cocoasoftware aims to make it easy for everyone to use grbner bases , whether directly or indirectly through some other function .",
    "the cocoa-5system is designed to be welcoming to those with little computer programming experience , while the cocoaliblibrary aims to make it easy for experienced programmers to use grbner basesin their own programs .",
    "b. buchberger , h.m .",
    "mller , _ the construction of multivariate polynomials with preassigned zeros _ , proceedings of the european computer algebra conference ( eurocam 82 ) , * 144 * , lecture notes in comp.sci . , ( 1982 ) , pp . 2431 ."
  ],
  "abstract_text": [
    "<S> we present a survey on the developments on grbner basesshowing explicit examples in cocoa .    </S>",
    "<S> the cocoa project dates back to 1987 : its aim was to create a `` mathematician''-friendly laboratory for studying commutative algebra , most especially grbner bases . since then , always maintaining this `` friendly '' tradition , it has evolved and has been completely rewritten .    </S>",
    "<S> cocoaoffers grbner bases for all levels of interest : from the basic quick call in the interactive system cocoa-5  @xcite , to problem - specific optimized implementations , to the computer  computer communication with the open source c++ software library , cocoalib  @xcite , or the prototype openmath - based server .    </S>",
    "<S> the openness and clean design of cocoalib and cocoa-5 are intended to offer different levels of usage , and to encourage external contributions . </S>"
  ]
}