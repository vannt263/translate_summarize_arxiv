{
  "article_text": [
    "secure distributed protocols have been an important and fruitful area of research for modern cryptography . in this",
    "setting , there is a group of participants who wish to perform some joint task , despite the fact that some of the participants in the protocol may cheat in order to obtain additional information or corrupt the outcome .",
    "we investigate a quantum version of an extensively studied classical problem , _ secure multi - party computation _ ( or _ secure function evaluation _ ) , first introduced by @xcite . a multi - party quantum computing ( mpqc ) protocol allows @xmath1 participants @xmath3 to compute an @xmath1-input quantum circuit in such a way that each party @xmath4 is responsible for providing one of the input states .",
    "the output of the circuit is broken into @xmath1 components @xmath5 , and @xmath4 receives the output @xmath6 .",
    "note that the inputs to this protocol are arbitrary quantum states  the player providing an input need only have it in his possession ; he does not need to know a classical description of it .",
    "moreover , unlike in the classical case , we can not assume without loss of generality that the result of the computation will be broadcast .",
    "instead , each player in the protocol receives some part of the output .",
    "informally , we require two security conditions : + _ - soundness and completeness : _ no coalition of @xmath7 or fewer cheaters should be able to affect the outcome of the protocol beyond their ability to choose their inputs .",
    "+ _ - privacy : _ no coalition of @xmath7 or fewer cheaters should learn anything beyond what they can deduce from their initial knowledge of their input and from their part of the output .",
    "* verifiable quantum secret sharing*.   in order to construct mpqc  protocols , we consider a subtask which we call _ verifiable quantum secret sharing_. in classical cryptography , a verifiable secret sharing scheme @xcite is a two phase protocol with one player designated as the `` dealer '' .",
    "after the first phase ( _ commitment _ ) , the dealer shares a secret amongst the players . in the second phase ( _ recovery _ ) , the players reconstruct the value publicly .",
    "the natural quantum version of this allows a dealer to share a state @xmath8 ( possibly unknown to him but nonetheless in his possession ) .",
    "because quantum information can not be cloned , we can not require that the state be reconstructed publicly ; instead , the recovery phase also has a designated player , the reconstructor @xmath9 .",
    "we require that , despite any malicious actions by @xmath10 players : + _ - soundness : _ as long as @xmath9 is honest and the dealer passes the commitment phase successfully , then there is a unique quantum state which can be recovered by @xmath9 .",
    "+ _ - completeness : _",
    "when @xmath11 is honest , then he always passes the commitment phase .",
    "moreover , when @xmath9 is also honest , then the value recovered by @xmath9 is exactly @xmath11 s input @xmath8 .",
    "+ _ - privacy : _ when @xmath11 is honest , no other player learns info about @xmath11 s input until the recovery step .",
    "note that for quantum data , the privacy condition is redundant : any information obtained about the shared state would imply some disturbance of that state , contradicting the completeness requirement . *",
    "contributions*.   we give a protocol for verifiable quantum secret sharing that tolerates any number @xmath12 of cheaters .",
    "we show that this is optimal , by proving that vqss  is impossible when @xmath13 . based on techniques from fault - tolerant quantum computing",
    ", we use our vqss  protocol to construct a multi - party quantum computation protocol tolerating any @xmath14 cheaters .",
    "( mpqc is similar to standard fault - tolerance but with a different error model , see previous work ) .",
    "our protocols run in time polynomial in both @xmath1 , the number of players , and @xmath15 , the security parameter .",
    "the error of the protocols is exponentially small in @xmath15 .    beyond these specific results ,",
    "there are a number of conceptual contributions of this paper to the theory of quantum cryptographic protocols .",
    "we provide a simple , general framework for defining and proving the security of distributed quantum protocols in terms of equivalence to an ideal protocol involving a third party .",
    "this follows the definitions for classical multi - party protocols .",
    "the analysis of our protocols leads us to consider various notions of local `` neighborhoods '' of quantum states , and more generally of quantum codes .",
    "we discuss three notions of a neighborhood .",
    "the notion most often used for the analysis of quantum error correction and fault - tolerance is insufficient for our needs , but we show that a very natural generalization ( specific to so - called `` css '' codes ) is adequate for our purposes . along the way , we provide modified versions of the classical sharing protocols of @xcite .",
    "the new property our protocols have is that dealers do not need to remember the randomness they use when constructing shares to distribute to other players .",
    "this allows them to replace a random choice of coins with the _ superposition _ over all such choices .",
    "* classical mpc*.   multi - party computing was introduced by goldreich , micali and wigderson @xcite , who showed that _ under computational assumptions _ , secure multi - party evaluation of any function was possible tolerating any minority of cheating players , i.e. if and only if @xmath16 .",
    "if one assumes pairwise secure channels but no computational assumptions , then one can compute any function securely if and only if @xmath17 @xcite .",
    "if one further assumes the availability of a secure broadcast channel , then one can in fact tolerate @xmath18 , and no more ( @xcite ) .",
    "all of these protocols rely on verifiable secret sharing as a basic tool .",
    "our solution draws most heavily on the techniques of chaum , crpeau and damgrd @xcite .    beyond these basic protocols ,",
    "much work has focused on finding proper definitions of security , e.g. @xcite .",
    "we adopt a simple definition based on the initial definitions of canetti .     * quantum secret sharing*.   relatively little work exists on multi - party cryptographic protocols with quantum data .",
    "secret sharing with a quantum secret was first studied by cleve et al .",
    "@xcite , who showed an equivalence with quantum error - correcting codes ( qecc ) .",
    "their scheme is the basis of our protocols .",
    "chau @xcite deals with classical computations , but also mentions the problem of verifiable quantum secret sharing as an open question .     * fault - tolerant quantum computing*.   the goal of ftqc  is to tolerate _ non - malicious _ faults occurring within a single computer .",
    "one assumes that at every stage in the computation , every qubit in the circuit has some known probability @xmath19 of suffering a random error , i.e. of becoming completely scrambled .",
    "moreover , errors are assumed to occur _ independently _ of each other and of the data in the computation .",
    "one can view multi - party computation as fault - tolerant computing with a different error model , one that is suited to distributed computing .",
    "the mpqc  model is weaker in some respects since we assume that errors will always occur in the same , limited number of positions , i.e. errors will only occur in the systems of the @xmath7 corrupted players .",
    "in other respects , the error model of mpqc  is stronger : in our setting errors may be _ maliciously _ coordinated . in particular , they will not be independently placed , and they may in fact depend on the data of the computation  the adversaries will use any partial information known about the other players data , as well as information about their own data , to attempt to corrupt the computation . for example , several ftqc  algorithms rely on the fact that at certain points in the computation , at most one error is likely to occur .",
    "such algorithms will fail when errors are placed adversarially .",
    "techniques from ftqc  are nonetheless useful for multi - party computing .",
    "we will draw most heavily on techniques due to aharonov and ben - or @xcite .      in this paper",
    ", we use a simple simulation - based framework for proving the security of quantum protocols , similar to early classical definitions .",
    "we specify a task by giving a protocol for implementing it in an ideal model where players have access to a trusted third party @xmath20 .",
    "we prove a given protocol secure by showing a simulator which translates any attack in the real - world protocol into an ( almost ) equally successful attack in the ideal model .",
    "we assume that every pair of participants is connected by perfect ( i.e. authenticated , unjammable , secret ) quantum and classical channels , and that there is a classical authenticated broadcast channel to which all players have access . because we will always consider settings where @xmath21 , we can also assume that players can perform _ classical _ multi - party computations securely @xcite in our setting . ] .",
    "the adversary is an arbitrary quantum algorithm ( or family of circuits ) @xmath22 ( not necessarily polynomial time ) , and so the security of our protocols does not rely on computational assumptions .",
    "the real and ideal models , as well as the notion of security , are specified more carefully in @xcite . in this paper",
    ", we use the following informal specifications of the ideal protocols .",
    "the real protocols are secure if they succeed in simulating the ideal ones .",
    "* multi - party quantum computation*.   [ sec : mpc - def ] all players hand their inputs to the @xmath20 , who runs the desired circuit and hands back the outputs . note that the only kind of cheating which is possible is that cheaters may choose their own input .",
    "in particular , cheaters can not force the protocol to abort .",
    "* verifiable quantum secret sharing*.   [ sec : vqss - def ] in the sharing phase , the dealer gives his secret system to the trusted party . in the reconstruction phase",
    ", the @xmath20 sends the secret system to the reconstructor @xmath9 .",
    "the only catch is that in the ideal model , honest players should not learn the identity of @xmath9 until after the first phase has finished ( otherwise , @xmath11 could simply send the secret state to @xmath9 in the first phase without violating the definition ) .",
    "we present the notation necessary for reading the protocols and proofs in this paper . for a more detailed explanation of the relevant background ,",
    "see @xcite or a textbook such as @xcite .",
    "we will work with @xmath19-dimensional quantum systems , for some prime @xmath23 .",
    "such a system is called a qupit , and the `` computational '' basis states are labelled by elements in @xmath24 .",
    "we will also be working in the fourier basis , which is given by the unitary transformation @xmath25 .",
    "a basis for the operators on a qupit is given by the @xmath26 pauli operators @xmath27 , where @xmath28 , @xmath29 , and @xmath30 .",
    "tensor products of these operators yield the pauli basis for the set of operators on a register of qupits .",
    "the weight of a tensor product operator is the number of components in which it is not the identity @xmath31 .     *",
    "quantum codes*.   the error - correcting codes used in this paper are quantum css codes .",
    "these are defined via two classical linear codes @xmath32 such that @xmath33 .",
    "if we denote @xmath34 for a classical code @xmath35 , then we can write the css code as @xmath36 .",
    "thus , @xmath37 is the set of states of @xmath1 qubits which yield a codeword of @xmath38 when measured in the computational basis and a codeword of @xmath35 when measured in the fourier basis .",
    "specifically , we will use quantum reed - solomon codes from @xcite .",
    "we specify a quantum rs code by a single parameter @xmath39 .",
    "the classical reed - solomon code @xmath40 is the set of all vectors @xmath41 , where @xmath42 is any univariate polynomial of degree at most @xmath43 .",
    "the related code @xmath44 is the subset of @xmath45 corresponding to polynomials which interpolate to 0 at the point 0 .",
    "that is : @xmath46 : \\",
    "\\deg(q ) \\leq \\delta\\ } $ ] and @xmath47 .",
    "the code @xmath40 has minimum distance @xmath48 , and an efficient error correction procedure .",
    "let @xmath49 .",
    "there are constants @xmath50 such that the dual of the code @xmath45 is just the code @xmath51 , rescaled by @xmath52 in the @xmath53 coordinate ; similarly , the dual of @xmath54 is a rescaled version of @xmath55 .",
    "denote these duals by @xmath56 , respectively .",
    "the quantum code @xmath57 for parameter @xmath43 is the css  code obtained from codes @xmath58 and @xmath59 .",
    "it encodes a single qupit , and has minimum distance @xmath60 ( thus , it corrects @xmath61 errors ) .",
    "moreover , errors can be corrected efficiently , given the syndrome of a corrupted codeword , i.e. the @xmath38 syndrome measured in the computational basis and the @xmath35 syndrome measured in the fourier basis .",
    "* transversal operations*.   a nice result from fault - tolerant computing @xcite is that one can in fact perform many operations on data encoded by a quantum rs code using only local operations and classical information transmitted between the components .",
    "consider the following gates :    [ gate : x ] shift : @xmath62 ,    sum : @xmath63 ,    scalar multiplication : @xmath64 , @xmath65 ,    [ gate : z ] phase shift : @xmath66 ,    fourier transform : @xmath67 ,    toffoli ( multiplication ) : @xmath68 .",
    "these gates are universal  @xcite , in the sense that a sequence of these gates can approximate any unitary operation with arbitrary accuracy . beyond these , in order to simulate arbitrary quantum circuits one should also be able to introduce qupits in some known state ( say @xmath69 ) , as well as to discard qupits . for any csscode",
    ", the gates [ gate : x ] through [ gate : z ] from the set above can be implemented _ transversally _ , that is using only local operations which affect the same component of two codewords .",
    "measurement and the remaining two operations can be performed almost transversally .     * measurement*.   for a quantum rs code , measuring each component of the encoding of @xmath70 yields a vector @xmath71 where @xmath72 .",
    "this operation is not quite transversal since after the qupit - wise measurement , the classical information must be gathered together in order to extract the measurement result .",
    "nonetheless , it can tolerate arbitrary corrupton of @xmath73 of the positions in the codeword if classical error correction is first applied to the vector of measurement results .",
    "* fourier and toffoli gates*.   for css  codes , applying the fourier transform transversally maps data encoded with the codes @xmath74 to the fourier transform of that data , encoded with the dual code @xmath75 defined via the codes @xmath76 . for quantum rs codes",
    ", rescaling each component of the dual code of @xmath57 produces the code @xmath77 .",
    "this allows one to perform the map @xmath78 , where @xmath79 is the encoding map for a code @xmath37 .    when @xmath80 , we have @xmath81 , so the fourier transform is in fact transversal , but the toffoli gate is difficult to perform .    when @xmath82 , neither the fourier transform nor the toffoli gate is transversal , but they can both be reduced to _ degree reduction _ via transversal operations  @xcite .",
    "degree reduction maps an arbitrary state @xmath83 encoded using @xmath84 to @xmath83 encoded with @xmath85 .",
    "the circuit we use for degree reduction is due to gottesman and bennett @xcite .",
    "we start with one block encoded using @xmath77 ( system @xmath86 ) , and an ancilla block in the state @xmath87 ( system @xmath88 ) .",
    "perform a sum gate from @xmath88 to @xmath86 ( this can be done transversally by a property of the codes @xmath89 ) .",
    "measure @xmath86 in the computational basis , obtaining @xmath90 , and apply @xmath91 to @xmath88 .",
    "the system @xmath88 now contains the data , encoded using @xmath89 .",
    "this entire procedure can be performed transversally except for the measurement step . however , as noted above , measurement requires only classical communication between the components .",
    "one of the ideas behind classical multi - party computing protocols is to ensure that data is encoded in a state that remains `` close '' to a codeword , differing only on those positions held by cheaters ( call that set @xmath92 ) . for classical codes , `` close '' means that the real word @xmath93 should differ from a codeword only on @xmath92 , so that any errors introduced by cheaters are correctable . for a code @xmath35 ,",
    "let the @xmath92-neighborhood @xmath94 be the set of vectors differing from a codeword of @xmath35 by positions in @xmath92 , i.e. , @xmath95 equivalently , one can define @xmath94 as the set of words obtained by distributing a ( correct ) codeword to all players , and then having all players send their shares to some ( honest ) reconstructor @xmath9 .    for quantum codes , there is more than one natural definition of the neighborhood corresponding to a set @xmath92 of positions .",
    "let @xmath96 be partitioned according to two sets @xmath97 .",
    "we say a mixed state @xmath98 is `` in '' @xmath37 if all states in the mixture lie in @xmath37 , i.e. @xmath99 where @xmath100 is the projector onto @xmath37 .",
    "we consider three definitions of a `` @xmath92-neighborhood '' of a css  code @xmath37 .",
    "let @xmath8 be an arbitrary state of the coding space .",
    "[ nbhd1 ] @xmath8 differs from a state in @xmath37 only by some quantum superoperator @xmath101 acting only on @xmath92 : + @xmath102 .",
    "[ nbhd2 ] @xmath8 can not be distinguished from a state in @xmath37 by looking only at positions in @xmath103 .",
    "+ @xmath104 .",
    "[ nbhd3 ] specifically for css  codes , one can require that the state @xmath8 pass checks on @xmath103 in both bases , i.e. that measuring either the @xmath105 syndrome in the computational basis , or the @xmath94 syndrome in the fourier basis , yields 0 .",
    "the set of states which pass this test is : @xmath106    in general , these notions form a strict hierarchy : + @xmath107 .",
    "only notion ( [ nbhd3 ] ) is always a subspace ( see @xcite for details ) .    in the analysis of quantum error correction and fault - tolerance schemes , it is sufficient to consider notion ( [ nbhd1 ] ) , for two reasons .",
    "on one hand , one starts from a correctly encoded state . on the other hand ,",
    "the errors introduced by the environment will be independent of the encoded data ( and in fact they must be for error correction to be possible at all in that context ) .    in our setting , however , we can not make such assumptions .",
    "the cheaters might possess states which are entangled with the data in the computation , and so the errors they introduce will not be independent of that data . instead , we show that our verifiable sharing protocol guarantees a condition similar to notion ( [ nbhd3 ] ) ( see lemma  [ lem : l2-sound ] ) . in order to provide some intuition for the proofs of section  [ sec:2ls ] , we characterize notion ( 3 ) below .     * well - definedness of decoding for @xmath108*.   the set @xmath108 is a subspace , since it is defined in terms of measurement outcomes .",
    "more particularly , it is spanned by the states of @xmath109 :    [ lem : charact ] if @xmath8 is in @xmath110 , then we can write @xmath111 , where @xmath112 , the @xmath113 are pauli operators on @xmath92 and @xmath114 .    to check if @xmath8 is in @xmath108 , we measure the @xmath105 syndrome in the computational basis and the @xmath94 syndrome in the fourier basis . however , the distribution on this outcome measurement will not change if we first measure the @xmath38 and @xmath35 syndromes , i.e. if we first make a measurement which projects @xmath8 into one of the subspaces @xmath115 ( i.e. @xmath8 maps to @xmath116 with probability @xmath117 , where @xmath118 is the projector for the space @xmath119 ) .",
    "the new state @xmath98 lies completely in one of the spaces @xmath115 .",
    "however , @xmath115 is either contained in @xmath108 ( if there is an operator equivalent to @xmath113 which acts only on @xmath92 ) or _ orthogonal _ to @xmath108 ( if no such operator exists ) .",
    "thus @xmath120 for all @xmath113 which act on more than @xmath92 .",
    "hence @xmath8 is a mixture of states @xmath121 each of which is a linear combination of elements of the spaces @xmath122 , where @xmath113 acts only on @xmath92 .",
    "this has a useful corollary , namely that decoding is well - defined for states in @xmath108 .",
    "formally , there are two natural `` reconstruction operators '' for extracting the secret out of a state which has been shared among several players .",
    "suppose that @xmath37 has distance @xmath123 and @xmath124 .",
    "first , @xmath125 is the decoding operator for the error - correcting code @xmath126 , which would be applied by an honest player holding all of the shares . for any operator @xmath113 of weight less than @xmath7 and for any state @xmath127 in @xmath126 ,",
    "we have @xmath128 ( i.e. the error is not only corrected but also identified ) .",
    "it will then discard the system containing the syndrome information @xmath129 .",
    "second , @xmath130 is the `` ideal recovery operator '' , defined by identifying the set @xmath92 of cheaters and applying the simple interpolation circuit to any set of @xmath131 good players positions ( this corresponds to erasure recovery ) .",
    "[ prop : l1-well - defined ] for any state @xmath8 in @xmath132 , the state @xmath133 is well - defined and is equal to @xmath134 .",
    "our protocols guarantee conditions similar to @xmath132 , and well - definedness is essential for proving simulatability .",
    "consider a particular basis state @xmath135 .",
    "the decoding operator @xmath136 will produce the state @xmath137 , since errors of weight at most @xmath7 can be identified uniquely .",
    "the ideal operator @xmath130 will extract the encoded state @xmath138 . without loss of generality ,",
    "the ideal recovery operator will replace @xmath138 with @xmath69 , the final output @xmath139 .",
    "in both cases , the output can be written as @xmath138 tensored with some ancilla whose state depends only on the syndrome @xmath140 ( and which identifies @xmath140 uniquely ) .",
    "once that state is traced out , the outputs of both operators will be identical . another way to see",
    "this is that the ideal operator can simulate the real operator : one can go from the output of the ideal operator to that of the real operator by applying a transformation which only affects the ancilla . for a state @xmath8 expressed as in lemma  [ lem : charact ] , the final outcome will be @xmath141 .",
    "in this section we define a two - tiered protocol for vqss . it is based on the vqss  protocols of @xcite as well as on the literature on quantum fault - tolerance and error correction , most notably on @xcite .",
    "detailed proofs for the claims of this section are in @xcite .",
    "however , some intuition is given by the proofs of section  [ sec : nbhds ] .",
    "in the vss  protocol of @xcite , the dealer @xmath11 takes his secret , splits it into @xmath1 shares and gives the @xmath53 component to player @xmath142 .",
    "player @xmath142 then shares this secret by splitting it into @xmath1 shares and giving the @xmath143 share to player @xmath140 .",
    "thus , there are @xmath144 total shares , which can be thought of as the leaves of a tree with depth 2 and fan - out @xmath1 : each leaf is a share ; the @xmath53 branch corresponds to the shares created by player @xmath142 , and the root corresponds to the initial shares created by the dealer .",
    "player @xmath140 holds the @xmath143 leaf in each branch of this tree .",
    "we will run a cut - and - choose protocol in order to guarantee some kind of consistency of the distributed shares .    during the protocol we accumulate @xmath145 sets of apparent cheaters : one set @xmath92 for the dealer ( this corresponds to a set of branches emanating from the root ) , and one set @xmath146 for each player @xmath142 ( this corresponds to a subset of the leaves in branch @xmath142 ) .",
    "these sets all have size at most @xmath7 .",
    "at the end of the protocol , we want to guarantee certain invariants .",
    "say @xmath38 has minimum distance @xmath147 , and each codeword corresponds to a single value @xmath148 .",
    "[ def : tgood ] we say a tree of @xmath144 field elements is @xmath149 with respect to the code @xmath38 and the sets @xmath150 if :    for each @xmath151 ( i.e. , corresponding to an honest player ) , we have @xmath152 , i.e. all apparent cheaters are real cheaters .    for each branch",
    "@xmath153 , the shares held by the honest players _ not in _",
    "@xmath146 should all be consistent with some codeword in @xmath38 , i.e. the vector of all shares should be in @xmath154 , where @xmath155 is the set of cheating players .",
    ": because there are at most @xmath7 players in @xmath146 and at most @xmath7 cheaters , there are at least @xmath156 honest players remaining , and so the polynomial above is uniquely defined .",
    "this guarantees that for each branch @xmath153 , there is a unique value @xmath157 which is obtained by interpolating the shares of the honest players not in @xmath146 .    for @xmath158 ,",
    "the values @xmath159 defined by the previous property are all consistent with a codeword of @xmath38 ( i.e. the vector @xmath160 is in @xmath105 ) .",
    "we will abbreviate this as @xmath161 , when the sets @xmath92 , @xmath162,@xmath163,@xmath164 are clear from the context .",
    "the vqss protocol is described in protocols [ prot : vqss ] and [ prot : qr ] .",
    "intuitively , it guarantees that a tree of quantum shares would yield a @xmath149 tree of classical values if measured in either the computational basis or the fourier basis .",
    "we use the codes @xmath165 and @xmath166 , with @xmath167 , although there is in fact no need to do this : the protocol will work for any css  code with distance at least @xmath168 , so long as the codes @xmath74 are efficiently decodable .",
    "the protocol can be tweaked for efficiency .",
    "the final protocol takes three rounds .",
    "each player sends and receives @xmath169 qubits , and the broadcast channel is used @xmath170 times overall , where @xmath171 is the soundness error of the protocol ( this requires setting @xmath172 ) .",
    "why is this a secure vqss  protocol ?",
    "we want to show that the protocol is equivalent to the `` ideal model '' , where at sharing time the dealer sends his secret system @xmath173 to a trusted outside party , and at reveal time the trusted party sends @xmath173 to the designated receiver . to do that , we will use two main technical claims .",
    "* soundness*.   [ sec : l2-sound ] we must show that at the end of the protocol , if the dealer passes all tests then there is an well - defined `` shared state '' which will be recovered by the dealer .",
    "to do so , we guarantee a property similar to @xmath174 ( notion ( [ nbhd3 ] ) of section  [ sec : nbhds ] ) .    [",
    "lem : l2-sound ] the system has high fidelity to the following statement : `` either the dealer is caught ( i.e. @xmath175 ) or measuring all shares in the computational ( resp .",
    "fourier ) basis would yield a @xmath149 tree with respect to the code @xmath38 ( resp .",
    "@xmath35 ) . ''",
    "proof of this is via a `` quantum - to - classical '' reduction , similar to that of @xcite .",
    "first , checks in the computational and fourier bases do nt interfere with each other , since they commute for css codes .",
    "second , in a given basis , we can assume w.l.o.g . that all ancillae are first measured in that basis , reducing to a classical analysis similar to @xcite .     *",
    "ideal reconstruction*.   in order to prove soundness carefully , we define an _ ideal interpolation _ circuit @xmath130 for @xmath149 trees : pick the first @xmath131 honest players not in @xmath92 , say @xmath176 . for each @xmath177 , pick @xmath131 honest players not in @xmath178 and apply the normal interpolation circuit ( i.e. erasure - recovery circuit ) for the code to their shares to get some qupit @xmath179 . applying the interpolation circuit again , we extract some system @xmath173 which we take to be the output of the ideal interpolation",
    "real _ recovery operator @xmath136 is given by protocol  [ prot : qr ] .",
    "the following lemma then applies , following essentially from proposition  [ prop : l1-well - defined ] .",
    "[ lem : l2-well - defined ] given a tree of qupits which is @xmath149 in both bases , the outputs of @xmath130 and @xmath180 are the same .",
    "in particular , this means that no changes made by cheaters to their shares can affect the outcome of @xmath180 .",
    "lemmas [ lem : l2-sound ] and [ lem : l2-well - defined ] show that there is essentially a unique state which will be recovered in the reconstruction phase when the receiver @xmath9 is honest .",
    "* completeness*.   [ sec : l2-complete ] as discussed earlier , the protocol is considered complete if when the dealer is honest , the state that is recovered by an honest reconstructor is exactly the dealer s input state .",
    "the key property is that _ when the dealer @xmath11 is honest , the effect of the verification phase on the shares which never pass through cheaters hands is the identity . _",
    "consider the case where the dealer s input is a pure state @xmath83 .",
    "on one hand , we can see by inspection that an honest dealer will always pass the protocol .",
    "moreover , since the shares that only go through honest players hands remain unchanged , it must be that if some state is reconstructed , then that state is @xmath83 , since the ideal reconstruction operator uses only those shares .",
    "finally , we know that since the dealer passed the protocol the overall tree must be @xmath149 in both bases , and so some value will be reconstructed .",
    "thus , on input @xmath83 , an honest reconstructor will reconstruct @xmath83 .",
    "we have proved :    [ purestate ] if @xmath11 and @xmath9 are honest , and the dealer s input is a pure state @xmath83 , then @xmath9 will reconstruct a state @xmath8 with fidelity @xmath181 to the state @xmath83 .",
    "not surprisingly , this lemma also guarantees the privacy of the dealer s input . by a strong form of the no cloning theorem",
    ", any information the cheaters could obtain would cause some disturbance , at least for a subset of the inputs .",
    "thus , the protocol is in fact also private .",
    "* simulatability*.   the claims above show that the protocol satisfies an intuitive notion of security . in this section",
    "we sketch a proof that the protocol satisfies a more formal notion of security : it is equivalent to a simple ideal model protocol .",
    "the equivalence is _ statistical _ , that is the outputs of the real and ideal protocols may not be identical but will have very high fidelity to one another .",
    "[ thm : vqss ] protocols [ prot : vqss ] and [ prot : qr ] are a statistically secure vqss  scheme .    the ideal protocol is sketched in section  [ sec : def ] . to show equivalence , we will give a transformation that takes an adversary @xmath182 for our protocol and turns it into an adversary @xmath183 for the ideal protocol . to give the transformation",
    ", we exhibit a simulator @xmath184 which acts as an intermediary between @xmath182 and the ideal protocol , making @xmath182 believe that it is experiencing the real protocol .",
    "the idea is that the simulator will simulate the regular vqss   protocol either on input provided by a cheating dealer or on bogus data @xmath69 , and then extract and/or change the shared state as needed .",
    "we give a sketch of the simulation procedure in algorithm  [ alg : vqss - sim ] .",
    "why does this simulation work ?    when @xmath11 is cheating :",
    "when @xmath9 is cheating , the simulation is trivially faithful , since there is _ no difference _ between the simulation and the real protocol : @xmath184 runs the normal sharing protocol , then runs the interpolation circuit , sending the result to @xmath20 . in the reconstruction phase , @xmath184 gets the same state back from @xmath20 , and runs the interpolation circuit in reverse .",
    "thus , the two executions of the interpolation circuit cancel out .    when @xmath9 is honest , the faithfulness of the simulation comes from lemma  [ lem : l2-well - defined ]",
    ": in the real protocol , @xmath9 outputs the result of the regular decoding operator . in the simulation",
    ", @xmath9 gets the output of the ideal interpolation .",
    "since the shared state has high fidelity to a @xmath149 tree ( by lemma  [ lem : l2-sound ] ) , the outputs will be essentially identical in both settings ( i.e. they will have high fidelity ) .    when @xmath11 is honest :    when @xmath9 is also honest , the faithfulness of the simulation follows from the completeness and privacy properties of the real protocol .",
    "privacy implies that the adversary @xmath182 can not tell that it is actually participating in a sharing of @xmath69 rather than the dealer s state , and completeness means that @xmath9 in the real protocol gets a state with high fidelity to that received by @xmath9 in the ideal protocol .    when @xmath9 is a cheater , @xmath184 does not get @xmath173 from @xmath20 until the reconstruction phase",
    "then he applies the ideal interpolation circuit to extract the @xmath69 state used during the verification phase , swaps @xmath173 with @xmath69 , then runs the ideal interpolation circuit backwards .",
    "since the ideal interpolation circuit only acts on shares of the honest players , @xmath184 is capable of performing these operations without tipping off @xmath182 to the fact that it is in a simulation . by the completeness property of the real protocol and the no - cloning theorem ,",
    "the residual state left over after the ideal interpolation circuit ( i.e. , the state of the cheaters ) has almost no correlation to the data shared using the circuit , so swapping in @xmath173 and running the circuit backwards gives us a state with high fidelity to the state that would have resulted from sharing @xmath173 directly with the same @xmath182 .",
    "thus , the simulation is faithful in this case as well .",
    "we have essentially proved theorem  [ thm : vqss ] .",
    "two - level sharings produced by the same dealer ( using the protocol above ) have some additional properties , which will be useful for multi - party computation .",
    "first of all , notice that there is no problem in tracking the sets @xmath150 incrementally across various invocations of the protocol for the same dealer , and so we assume below that these sets are the same for different sharings from the same dealer",
    ".    some operations can be applied transversally to valid sharings . applying the linear operation",
    "@xmath185 ( denoted @xmath186 ) to all shares of two sharings effectively applies @xmath186 to the shared states .",
    "similarly , applying the fourier rotation transversally changes the sharing to the dual code and applies a logical fourier rotation . finally , measuring all shares of a valid sharing in the computational basis and applying classical decoding yields the same result as measuring the shared state .",
    "thus , players can measure without exchanging quantum information .",
    "[ rem : share0 ] the dealer can additionally use the protocol to prove to all players that the system he is sharing is exactly the state @xmath69 : the ancillas he uses in this case will all be sharings of @xmath69 ( instead of @xmath187 ) .",
    "the verification step is the same as before , except now players verify that the reconstructed codeword at the top level interpolates to 0 .",
    "similarly , the dealer can prove that he is sharing a state @xmath188 .",
    "this will be useful for sharing ancillas in the mpqc  protocol .",
    "[ lem : no4 ] no 4-player vqss  scheme tolerates one cheater .",
    "suppose such a scheme exists .",
    "consider a run of the protocol in which all players behave perfectly honestly until the end of the sharing phase , at which point one ( unknown ) player introduces an arbitrary error .",
    "however , an honest `` receiver '' ruth , given access to the state of all players , must still be able to recover the shared state .",
    "thus , the joint state of all players constitutes a four - component qecc correcting one error . however , no such code exists , not even a mixed - state one , by the quantum singleton bound  @xcite .",
    "the optimality of our vqss  scheme is an immediate corollary , since any protocol tolerating @xmath189 cheaters could be used to construct a four - person protocol tolerating one cheater by having each participant simulate @xmath189 players in the original protocol :    no vqss  scheme for @xmath1 players exists which tolerates all coalitions of @xmath190 cheaters .    note",
    "that we have only proved the impossibility of _ perfect _ vqss  protocols .",
    "however , the quantum singleton bound still holds when exact equality is replaced by approximate correctness , and so in fact even statistical vqss  schemes are impossible when @xmath13 .",
    "in this section we show how to use the vqss  protocol of the previous section to construct a multi - party quantum computing scheme . first , we give a modified vqss  protocol . at the end of the protocol ,",
    "all players hold a single qupit . with high fidelity , either the dealer will be caught cheating or the shares of all honest players will be consistent in both the computational and fourier bases , i.e. there is no set @xmath92 of `` apparent cheaters '' .",
    "we then apply fault - tolerant techniques to achieve secure distributed computation",
    ".      we will now restrict attention to protocols tolerating @xmath14 cheaters , instead of @xmath12 cheaters as before .",
    "thus , we take @xmath191 for simplicity , and as before we set @xmath192 ( thus @xmath193 )",
    ". we will work with the css  code @xmath37 given by @xmath58 and @xmath59 .",
    "recall that this is the css  code for which there exist nearly - transversal fault - tolerant procedures ( section  [ sec : prelim ] ) .",
    "our goal is to share a state so that at the end all shares of honest players lie in @xmath194 .",
    "the new scheme is given in protocol  [ prot : l3-vqss ] .",
    "the idea is that the previous vqss  scheme allows distributed computation of linear gates and fourier transforms on states shared by the same dealer .",
    "it also allows verifying that a given shared state is either @xmath69 or @xmath195 . the players will use this to perform a distributed computation of the encoding gate for the code @xmath196",
    "thus , the dealer will share the secret system @xmath173 , as well as @xmath43 states @xmath187 and @xmath197 states @xmath69 .",
    "players then apply the ( linear ) encoding gate , and each player gets sent all shares of his component of the output . as before , the main lemmas are soundness and completeness of the protocol :    at the end of the sharing phase , the system has high fidelity to `` either the dealer is caught or the players shares @xmath198 lie in @xmath199 '' .",
    "when @xmath11 is honest , on pure state input @xmath83 , the shared state will have high fidelity to @xmath200 ( i.e. will differ from @xmath201 only on the cheaters shares ) .",
    "note the dealer can also prove that he has shared a @xmath69 state ( by showing that his input is @xmath69 ) .",
    "given the protocol of the previous section , and known fault - tolerant techniques , there is a natural protocol for secure multi - party computation of a circuit : have all players distribute their inputs via the top - level sharing ( protocol  [ prot : l3-vqss ] ) ; apply the gates of @xmath202 one - by - one , using the ( essentially ) transversal implementation of the gates described in section  [ sec : prelim ] ; then have all players send their share of each output to the appropriate receiver .",
    "see protocol  [ prot : mpqc ] .",
    "the only sticking point in the analysis is that the fault - tolerant procedures require some interaction when measuring a shared state .",
    "all players measure their share and broadcast the result , applying classical decoding to the resulting word .",
    "if the errors occurring in the measured ancilla were somehow correlated or entangled with errors in the real data , one could imagine that measuring and broadcasting them might introduce further entanglement .",
    "however , this will not be a problem : on one hand , any errors will occur only in the cheaters shares , and so provide nothing beyond what the cheaters could learn themselves ; on the other hand , the honest players will discard all the information from the broadcast except the decoded measurement result ( each honest player performs the decoding locally based on the broadcast values , so all honest players obtain the same result ) .",
    "again , the cheaters can do this themselves .",
    "suppose that all inputs and ancillas are shared at the beginning via states in @xmath174 .",
    "then the result of applying the protocol for a given circuit @xmath202 , and then sending all states to an honest decoder @xmath9 is the same as sending all states to @xmath9 and having @xmath9 apply @xmath202 to the reconstructed states .",
    "[ thm : mpqc - secure ] for any circuit @xmath202 , protocol  [ prot : mpqc ] is a statistically secure implementation of multi - party quantum computation as long as @xmath14 .",
    "the proof of this is by simulation , as before .",
    "the key observation is that when the simulator @xmath184 is controlling the honest players , the adversary can not tell the difference between the regular protocol and the following ideal - model simulation :    @xmath184 runs the input phase as in the protocol , using @xmath69 as the inputs for honest players . in this phase ,",
    "if any dealer is caught cheating , @xmath184 sends `` i am cheating '' to the @xmath20 on behalf of that player .",
    "@xmath184 `` swaps '' the cheaters inputs with bogus data @xmath69 , and sends the data to the @xmath20 .",
    "that is , he applies the interpolation circuit to honest players shares to get the various input systems @xmath203 ( for @xmath204 ) , and then runs the interpolation circuit backwards , with the state @xmath69 replacing the original data .",
    "@xmath184 now runs the computation protocol with the adversary on the bogus data .",
    "( because no information is revealed on the data , the adversary can not tell this from the real protocol . )",
    "@xmath184 receives the true computation results destined to cheating players from @xmath20 .",
    "@xmath184 `` swaps '' these back into the appropriate sharings , and sends all shares of the @xmath53 wire to player @xmath142 ( again , he does this only for @xmath204 ) .",
    "the proof that this simulation succeeds follows from the security of the top - level sharing protocol and the previous discussion on fault - tolerant procedures .",
    "given our results , the most obvious open question is if mpqc   is possible when @xmath205 .",
    "another natural direction of research is to find a vqss  protocol with zero error .",
    "for example , the techniques of @xcite for the classical case do not seem to apply to the quantum setting .",
    "finally , one can ask what tasks are achievable when we allow cheating players to force the abortion of the protocol ( usually called an `` optimistic protocol '' ) .",
    "thanks to richard cleve for helpful discussions .",
    "thanks madhu sudan for patience , support and advice .",
    "b.  chor , s.  goldwasser , s.  micali , and b.  awerbuch .",
    "verifiable secret sharing and achieving simultaneity in the presence of faults ( extended abstract ) . in _ proc . of 26th",
    "focs _ , pages 383395 , portland , oregon , 2123 oct .",
    "ieee .",
    "r.  cramer , i.  damgrd , s.  dziembowski , m.  hirt , and t.  rabin .",
    "efficient multiparty computations with dishonest minority . in j.",
    "stern , editor , _ proc . of eurocrypt  99",
    "_ , volume 1592 of _",
    "iacr , springer - verlag , 1999 .",
    "o.  goldreich , s.  micali , and a.  wigderson . how to play any mental game or a completeness theorem for protocols with honest majority . in _ proc .",
    "of 19th stoc _",
    ", pages 218229 , new york city , 2527 may 1987",
    ".    s.  goldwasser and l.  a. levin .",
    "fair computation of general functions in presence of immoral majority . in a.",
    "j. menezes and s.  a. vanstone , editors , _ proc . of crypto",
    "90 _ , volume 537 of _ lncs _ , pages 7793 .",
    "iacr , springer - verlag , 1991 ."
  ],
  "abstract_text": [
    "<S> _ secure multi - party computing _ , also called _ secure function evaluation _ , has been extensively studied in classical cryptography . </S>",
    "<S> we consider the extension of this task to computation with quantum inputs and circuits . </S>",
    "<S> our protocols are information - theoretically secure , i.e. no assumptions are made on the computational power of the adversary . for the weaker task of _ verifiable quantum secret sharing _ , we give a protocol which tolerates any @xmath0 cheating parties ( out of @xmath1 ) . </S>",
    "<S> this is shown to be optimal . </S>",
    "<S> we use this new tool to show how to perform any multi - party quantum computation as long as the number of dishonest players is less than @xmath2 .    </S>",
    "<S> [ this version appears with the permission of the acm . </S>",
    "<S> only minor typographical changes have been made from the version which appeared in the proceedings of _ stoc 2002_. ] </S>"
  ]
}