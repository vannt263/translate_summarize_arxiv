{
  "article_text": [
    "given a search problem we may want to find out whether one solution for a particular instance is `` close '' to another solution of that instance in order to get more insight into the solution space of the problem . studying the solution space from this perspective could , for instance , be potentially interesting for improving the performance of corresponding heuristics  @xcite .",
    "searching the solution space by making small `` feasible '' moves also turned out to be useful when analyzing randomized algorithms for sampling and counting @xmath0-colorings of a graph or when analyzing cases of glauber dynamics in statistical physics ( see section  5 of the survey of van den heuvel  @xcite ) .",
    "we also note that solution spaces in practical problems , such as stacking problems arising in storage planning  @xcite , have been explored in a similar matter .    in most general terms",
    ", the above situation can be modeled with solution graphs .",
    "we formalize this as follows : a _ solution graph concept _ @xmath6 is obtained by defining a set of _ instances _ , _ solutions _ for these instances , and a ( symmetric ) _ adjacency relation _ between pairs of solutions . for every instance @xmath3 of the problem , this gives a _ solution graph _ @xmath7 , also called a _ reconfiguration graph _",
    ", which has as node set all solutions of @xmath3 , with edges as defined by the given adjacency relation .",
    "( if @xmath3 has no solutions then @xmath7 is the empty graph . )",
    "the adjacency relation usually represents a smallest possible change ( or _ reconfiguration move _ ) between two solutions of the same instance . for example , the well - known _",
    "@xmath0-color graph concept _ @xmath8 , related to the @xmath0-colorability search problem , is defined as follows : instances are graphs @xmath3 , and solutions are ( proper ) @xmath0-colorings of @xmath3 .",
    "two colorings are adjacent if and only if they differ in exactly one vertex .",
    "note however that in general there may be more than one natural way to define the adjacency relation .",
    "solution graphs and their properties have been studied very intensively over the last couple of years for a variety of search problems , which include amongst others the following problems : @xmath0-coloring  @xcite , satisfiability  @xcite , independent set  @xcite , shortest path  @xcite , list coloring  @xcite , list edge coloring  @xcite , @xmath9-labeling  @xcite , @xmath10-coloring  @xcite and subset sum  @xcite ; see also the aforementioned survey  @xcite . the study of such solution graphs is commonly called _ reconfiguration_.    * reconfiguration problems . * both algorithmic and combinatorial questions have been considered in the fast - growing area of reconfiguration . for instance , what is the diameter of @xmath7 ( in terms of the size of the instance @xmath3 ) or if @xmath7 is not connected , what is the diameter of its ( connected ) components ?",
    "in particular , is the diameter always polynomially bounded or not ? this led to the introduction of the @xmath6-connectivity problem , which is that of deciding whether the solution graph @xmath7 of a given instance  @xmath3 is connected .",
    "refining this problem leads to the following problem :    @xmath6-reachability + _ instance : _ an instance @xmath3 with two solutions @xmath1 and @xmath2 .",
    "+ _ question : _ is there a path from @xmath1 to @xmath2 in @xmath7 ?    the @xmath6-reachability problem is a central problem in the area of reconfiguration , which has received much attention in the literature .",
    "the problem is sometimes called the _ @xmath1-@xmath2-path _",
    "problem for @xmath6  @xcite , whereas the specific case of @xmath8-reachability is also known as the @xmath0-color path problem  @xcite . if @xmath6 is a solution graph concept based on a specific well - known search problem , we may also name this problem accordingly , e.g.  a shortest - path - reachability problem is based on the shortest path problem ( although this leaves the adjacency relation unspecified ) .",
    "it must be noted that @xmath6-reachability is pspace - complete for most of the aforementioned solution graph concepts even for special graph classes  @xcite .",
    "for instance , @xmath8-reachability is pspace - complete even if @xmath4 and instances are restricted to planar bipartite graphs  @xcite .",
    "this explains that efficient algorithms are only known for very restricted classes of instances .",
    "hence , there is still a need for developing general algorithmic techniques for solving these problems in practice , and for sharpening the boundary between tractable and computationally hard instance classes .",
    "our paper can be seen as the next step in these directions .    * method .",
    "* one important algorithmic technique is _ dynamic programming ( dp)_. in the area of reconfiguration , there are only relatively few successful examples of nontrivial dp algorithms ( such as  @xcite ) . in this paper , we focus on a dp technique based on the concept of _ contracted solution graphs_. this method was first used by bonsma  @xcite to obtain an efficient algorithm for a shortest - path - reachability problem restricted to planar graphs .",
    "recently , hatanaka , ito and zhou  @xcite used this technique for proving that list - coloring - reachability is polynomial - time solvable for caterpillars .",
    "( in both papers , contracted solution graphs are called _",
    "encodings_. ) in our paper we will :    1 .   generalize the ideas of  @xcite to a unified dynamic programming method , 2 .",
    "introduce this method in a broader setting , 3 .",
    "provide useful notation , terminology and basic lemmas , and 4 .",
    "illustrate the method by giving a new application .    in section  [ s - method ] we give a detailed description of the general method of contracted solution graphs . informally speaking , in dynamic programming one",
    "first computes the required information for parts of the instance , and combines / propagates this to compute the same information for ever larger parts of the instance , until the desired information is known for the entire instance . in our case",
    ", the instance  @xmath3 can be any relational structure on a ground set , such as ( directed ) graphs , hypergraphs , satisfiability formulas , or constraint satisfaction problems in general ( see e.g.  @xcite ) .",
    "the order in which the information can be computed or in which parts should be considered is given by a _ decomposition _ of @xmath3 .",
    "the elements of the ground set that are in a processed part @xmath10 and that have incidences with the unexplored part are called _",
    "terminals_. the key idea behind the method is that reconfiguration moves in the processed part @xmath10 that do not involve terminals are often irrelevant .",
    "the information that is relevant is captured by the notion of a _",
    "terminal projection_. these projections assign labels to solutions , yielding so - called _ label components _ , which are maximally connected subgraphs of @xmath11 induced by sets of solutions that all have the same label .",
    "a contracted solution graph is obtained from @xmath11 by contracting the label components into single vertices ( see section  [ s - method ] for further details ) .",
    "we stress that the general method can readily be applied to _ any kind of relational structure _ , but in our example we focus on graphs , just as  @xcite and  @xcite .",
    "* relation to other results . * in  @xcite dynamic programming was done over a _ path decomposition _ of the given caterpillar . in  @xcite ,",
    "a layer - based decomposition of the graph was used ( for every @xmath12 , the subgraph @xmath13 consisted of all vertices at distance at most @xmath14 of the given shortest path starting from a vertex @xmath15 ) , which can also be viewed as a path decomposition . here",
    "we focus on the more general _ tree decompositions _ instead . for our application ,",
    "we give _ full _ dynamic programming rules for the @xmath8-reachability problem .",
    "in particular we introduce a join rule and we allow bags of size larger than  2 .",
    "our rules can be used directly for list - coloring - reachability as well and thus generalize the rules of  @xcite .",
    "many well - studied @xmath6-reachability problems ( including @xmath8-reachability for an appropriate constant @xmath0 ) are in fact pspace - complete already for graphs of bounded bandwidth  @xcite , and therefore also for graphs of bounded treewidth .",
    "recently , the pspace - completeness results from  @xcite were strengthened to hold even for planar graphs of bounded bandwidth and low maximum degree  @xcite .",
    "hence we can not hope to obtain polynomial time algorithms for graphs of treewidth @xmath16 , for every constant @xmath16 , and certainly not fixed parameter tractable ( fpt ) algorithms parameterized by @xmath16 , although such results are common when working with decision problems that are only np - complete instead of pspace - complete ( see  @xcite for more background on parameterized complexity ) .",
    "one way to cope with this problem is to restrict the problem even further . for instance",
    ", in a number of recent papers  @xcite the _ length - bounded _ version of the @xmath6-reachability problem was studied , that is the problem of finding a path of length at most  @xmath17 in the solution graph between two given solutions , in particular with an aim to determine fixed - parameter tractability ( observe that the length of a path between two solutions is a natural parameter ) .",
    "for instance , although @xmath8-reachability is pspace - complete for @xmath18 , the length - bounded version is fpt when parameterized by the length @xmath17  @xcite ( in addition , it is polynomial - time solvable for @xmath19  @xcite ) . in this restricted context",
    ", other dynamic programming algorithms over tree decompositions for reconfiguration problems are known : in  @xcite fpt algorithms are given for various length - bounded reachability problems , parameterized by both the treewidth and the length bound @xmath17 . in  @xcite ,",
    "fpt algorithms are given for the reachability versions of different token reconfiguration problems for graphs of bounded degeneracy ( and thus for bounded treewidth ) , when parameterized by the number of tokens .",
    "since we wish to solve @xmath6-reachability problems in general , we choose a different approach , and present a generally applicable method . however , because of the aforementioned pspace - completeness , we can obviously not guarantee that it terminates in polynomial time for all instances .",
    "nevertheless , one can identify restricted instance classes for which it does yield polynomial time algorithms , as illustrated by our new application and the two other examples  @xcite . moreover , our initial computational studies indicate that this method , with a few additions , performs well in practice for various instances of reconfiguration problems , for which the theoretical complexity status is not yet resolved .",
    "this will be reported in a subsequent paper , for which the current paper provides  the  basis .    *",
    "our application . * in section  [ sec : dp ] we illustrate the method by giving dynamic programming rules for the @xmath8-reachability problem , which describe how to compute new ( larger ) contracted solution graphs from smaller ones . recall that similar dynamic programming rules can be given for other reconfiguration problems , as done already in  @xcite .",
    "the given rules can be used when a tree decomposition of the graph is given .",
    "we emphasize that the rules solve the @xmath8-reachability problem correctly for _ every _ graph @xmath3 ( see e.g.  @xcite for information on finding tree decompositions ) .",
    "nevertheless , the algorithm is only _ efficient _ when the contracted solution graphs stay small enough ( that is , polynomially bounded ) . as indicated by the pspace - hardness of the problem ,",
    "this is not always the case .    in section  [ sec : badexamples ] ,",
    "we illustrate the dp rules and show that the size of the contracted solution graphs can grow exponentially , even for 2-connected 4-colorable unit interval graphs .    in section  [ sec : chordalgraphs ]",
    "we use our method to show that , for all @xmath20 , @xmath8-reachability can be solved in polynomial time for @xmath5-connected chordal graphs . as",
    "unit interval graphs are chordal , the result from the previous section implies that we need to exploit the structure of chordal graphs further in order to prove this .",
    "this is not surprising : although @xmath21-reachability can be solved in polynomial time for all graphs  @xcite , @xmath8-reachability is pspace - complete even for bipartite graphs , and if @xmath22 for planar graphs , and if @xmath4 for planar bipartite graphs  @xcite .",
    "in particular we need to prove a new bound on the size of any nice tree decomposition of a graph .",
    "we show that this bound is asymptotically tight even for chordal graphs .    as the proof for the pspace - completeness result for bipartite graphs from  @xcite",
    "can be easily modified to hold for @xmath5-connected bipartite graphs , our result for @xmath5-connected chordal graphs can not be extended to @xmath5-connected perfect graphs . on the positive side ,",
    "@xmath8-connectivity is polynomial - time solvable on chordal graphs .",
    "this is due to a more general result of bonamy et al .",
    "@xcite , which implies that for a chordal graph @xmath3 , @xmath23 is connected if and only if @xmath3 has no clique on more than @xmath24 vertices .",
    "hence , our result can be seen as an extension of this result if in addition @xmath5-connectivity is imposed .",
    "our result on @xmath8-reachability on @xmath5-connected chordal graphs is also the first time that dynamic programming over tree decompositions is used to solve the general version of a pspace - complete reachability problem in polynomial time for a graph class strictly broader than trees . in section  [ s - discussion ]",
    "we discuss possible directions for future work .",
    "we consider finite undirected graphs that have no multi - edges and no loops .",
    "below we define some basic terminology .",
    "in particular we give some coloring terminology , as we need such terminology throughout the paper .",
    "we refer to the textbook of diestel  @xcite for any undefined terms .    for a connected graph @xmath3 , a _",
    "vertex cut _ is a set @xmath25 such that @xmath26 is disconnected .",
    "vertices that are in different components of @xmath26 are said to be _ separated _ by @xmath27 . for @xmath28 , a ( connected ) graph",
    "@xmath3 is _ @xmath0-connected _ if @xmath29 and every vertex cut @xmath27 has @xmath30 .",
    "the _ contraction _ of an edge @xmath31 of a graph @xmath3 replaces @xmath32 and @xmath33 by a new vertex made adjacent to precisely those vertices that were adjacent to @xmath32 or @xmath33 in @xmath3 .",
    "note that this operation does not create any multi - edges or loops .",
    "let @xmath3 be a graph .",
    "a _ @xmath0-color assignment _ of @xmath3 is a function @xmath34 . for @xmath35 , @xmath36",
    "is called the _ color _ of @xmath33 .",
    "it is a _ @xmath0-coloring _ if @xmath37 for every edge @xmath38 .",
    "a _ coloring _ of @xmath3 is a @xmath0-coloring for some value of @xmath0 . if @xmath1 and @xmath2 are colorings of @xmath3 and a subgraph @xmath10 of @xmath3 , respectively , such that @xmath39 ( that is , @xmath1 and @xmath2 coincide on @xmath40 ) then @xmath1 and @xmath2 are said to be _",
    "compatible_. for an integer @xmath0 , the _",
    "@xmath0-color graph @xmath23 _ has as nodes all ( proper ) @xmath0-colorings of @xmath3 , such that two colorings are adjacent if and only if they differ on one vertex .",
    "a _ walk _ from @xmath32 to @xmath33 in @xmath3 is a sequence of vertices @xmath41 with @xmath42 , @xmath43 , such that for all @xmath44 , @xmath45 .",
    "a _ pseudowalk _ from @xmath32 to @xmath33 is a sequence of vertices @xmath41 with @xmath42 , @xmath43 , such that for all @xmath44 , either @xmath46 , or @xmath45 .",
    "a _ recoloring sequence _ from a @xmath0-coloring @xmath1 of @xmath3 to a @xmath0-coloring @xmath2 of @xmath3 is a pseudowalk from @xmath1 to @xmath2 in @xmath23 .",
    "a _ labeled graph _ is a pair @xmath47 where @xmath48 is a graph and @xmath49 is a vertex labeling ( which may assign the same label to different vertices ) .",
    "a _ label preserving isomorphism _ between two labeled graphs @xmath50 and @xmath51 is an isomorphism @xmath52 , such that @xmath53 for all @xmath54 .",
    "we consider two labeled graphs @xmath50 and @xmath51 to be the same if there exists a label preserving isomorphism between them .",
    "in this section we define the concept of _ contracted solution graphs _ ( csgs ) for reconfiguration problems in general .",
    "consider a solution graph concept @xmath6 , which for every instance @xmath3 of @xmath6 defines a solution graph that is denoted by @xmath7 .",
    "terminal projection _ for @xmath6 is a function  @xmath55 that assigns a _ label _ to each tuple @xmath56 consisting of an instance @xmath3 of @xmath6 , a set @xmath57 of _ terminals _ for @xmath3 and a solution @xmath58 for @xmath3 .",
    "we remark that @xmath3 and @xmath57 can be anything , but in our example and in previous examples in the literature  @xcite @xmath3 is always a graph , and @xmath57 is a subset of its vertices .",
    "we also note that a terminal projection @xmath55 can be seen as a node labeling for the solution graph @xmath7 .",
    "so , for every instance @xmath3 of @xmath6 , every choice of terminals @xmath57 may give a different label function for the solution graph @xmath7 . when @xmath3 and @xmath57 are clear from the context , we may write @xmath59 to denote the label of a node @xmath58 of @xmath7 .    _ example .",
    "_ consider the @xmath0-color graph concept @xmath8 .",
    "let @xmath3 be a graph .",
    "we can define a terminal projection @xmath55 as follows .",
    "let @xmath57 be a subset of @xmath60 .",
    "the nodes of @xmath23 are @xmath0-colorings and we give each node as label its restriction to @xmath57 , that is , for every @xmath0-coloring @xmath58 of @xmath3 , we set @xmath61 .",
    "note that @xmath62 is a @xmath0-coloring of @xmath63 $ ] .",
    "let @xmath55 be a terminal projection for a solution graph concept @xmath6 .",
    "for an instance  @xmath3 of @xmath6 and a terminal set  @xmath57 , a _ label component _ @xmath64 of @xmath7 is a maximal set of nodes @xmath58 that all have the same label @xmath59 and that induce a connected subgraph of @xmath7 .",
    "it is easy to see that every solution  @xmath58 of  @xmath3 is part of exactly one label component , or in other words : the label components partition the node set of @xmath7 .",
    "the _ contracted solution graph ( csg ) _",
    "@xmath65 is a labeled graph that has a node set that corresponds bijectively to the set of label components of  @xmath3 . for a node @xmath66 of @xmath65 ,",
    "we denote by @xmath67 the corresponding label component . two distinct nodes @xmath68 and @xmath69 of @xmath65 are adjacent if and only if there exist solutions @xmath70 and @xmath71 such that @xmath72 and @xmath73 are adjacent in @xmath7 .",
    "we define a label function @xmath74 for nodes of @xmath65 to denote the corresponding label in @xmath7 . more precisely : for a node @xmath66 of @xmath65 , the label @xmath75 is chosen such that @xmath76 for all @xmath77 .",
    "note that the contracted solution graph  @xmath65 can also be obtained from @xmath7 by contracting all label components into single nodes and choosing node labels appropriately , which explains their name .",
    "_ example .",
    "_ in figure  [ fig : cutvertcsg](c ) , one component of @xmath78 is shown for the ( 4-colorable ) graph @xmath3 from figure  [ fig : cutvertcsg](a ) .",
    "this is the component that contains all colorings of  @xmath3 whose vertices @xmath79 are colored with colors @xmath80 , respectively ( note that it is not possible to recolor any of these four vertices if one may recolor only one vertex at a time ) . so in figure  [ fig : cutvertcsg](c ) the colors of the vertices @xmath79 are omitted in the node labels , which only indicate the colors of @xmath81 , in this order . for terminal set @xmath82 , this component contains three label components ( of equal size ) , and contracting them yields the csg @xmath83 shown in figure  [ fig : cutvertcsg](d ) . for @xmath84 , there are seven label components , and the corresponding csg @xmath85 is shown in figure  [ fig : cutvertcsg](e ) .",
    "note that @xmath85 contains different nodes with the same label .",
    "we stress that the csg @xmath65 is a labeled graph that includes the label function @xmath74 defined above . however , to keep its size reasonable , the csg itself does not include the solution sets @xmath67 for each node that were used to define it . for proving the correctness of dynamic programming rules for csgs ,",
    "the following alternative characterization of csgs is useful .",
    "this gives an alternative characterization of the label components ; note that the sets @xmath67 correspond exactly to the label components .",
    "[ lem : characterizationcsgs ] consider an instance @xmath3 of a solution graph concept @xmath6 , terminal set  @xmath57 and terminal projection @xmath55 .",
    "let @xmath86 be a labeled graph .",
    "then @xmath87 if and only if one can define nonempty sets of solutions @xmath67 for each node @xmath88 such that the following properties hold :    a.   [ pr : partition ] @xmath89 is a partition of the nodes of @xmath7 ( the solutions of @xmath3 ) . b.   [ pr : correctlabels ] for every @xmath88 and every solution @xmath77 : @xmath90 . c.   [ pr : propercoloring ] for every edge @xmath91 : @xmath92 .",
    "d.   [ pr : connectedsets ] for every @xmath88 : @xmath67 induces a connected subgraph of @xmath7 .",
    "e.   [ pr : adjacency ] for every pair of distinct nodes @xmath93 : @xmath91 if and only if there exist solutions @xmath94 and @xmath95 such that @xmath1 and @xmath2 are adjacent in @xmath7 .",
    "@xmath96 : we choose the sets @xmath67 to be the label components , as chosen in the above definition of @xmath65 .",
    "then the properties  ( [ pr : partition ] ) , ( [ pr : correctlabels ] ) , ( [ pr : connectedsets ] ) and  ( [ pr : adjacency ] ) follow immediately from the definitions . for property  ( [ pr : propercoloring ] )",
    ", we use that label components are _ maximal _ connected node sets with the same label , together with properties  ( [ pr : correctlabels ] ) and  ( [ pr : adjacency ] ) .",
    "@xmath97 : let @xmath86 be a labeled graph for which solution sets @xmath67 can be defined such that the five properties hold . consider a node @xmath88 .",
    "properties  ( [ pr : connectedsets ] ) and  ( [ pr : correctlabels ] ) show that all solutions in @xmath67 are part of the same label component ; denote this label component by @xmath64 .",
    "note that for all @xmath94 , @xmath98 due to property  ( [ pr : correctlabels ] ) .    in order to show that in fact @xmath99 , let @xmath100 be adjacent to some solution in @xmath67 .",
    "we must show that @xmath101 . by property  ( [ pr : partition ] ) , @xmath58 belongs to a set  @xmath102 for some @xmath103 . by property  ( [ pr : adjacency ] ) , we obtain @xmath104 .",
    "then , by property  ( [ pr : propercoloring ] ) , we find that @xmath105 .",
    "hence @xmath106 due to property  ( [ pr : correctlabels ] ) .    because @xmath67 induces a label component for every @xmath66",
    ", there exists a bijection @xmath107 between the nodes of @xmath10 and the label components of @xmath7 ( this is a bijection because of property  ( [ pr : partition ] ) ) .",
    "this yields a bijection @xmath108 between the nodes of @xmath10 and the nodes of @xmath65 , which is label preserving by property  ( [ pr : correctlabels ] ) and an isomorphism by property  ( [ pr : adjacency ] ) and the definition of @xmath65 .",
    "hence @xmath109 to denote that there is a label preserving isomorphism between the two .",
    "more formally , @xmath65 can be seen as a class of labeled graphs that are equivalent under labeled isomorphisms . ] .",
    "a mapping @xmath27 that assigns solution sets ( or label components ) @xmath67 to each node  @xmath66 of @xmath65 that satisfies the properties given in lemma  [ lem : characterizationcsgs ] is called a _ certificate _ for @xmath65 .",
    "given such a certificate @xmath27 and a solution @xmath58 for @xmath3 , we define the _",
    "@xmath58-node _ of @xmath65 with respect to @xmath27 to be the node @xmath66 with @xmath77 .",
    "for readability , we will not always explicitly mention this certificate when talking about @xmath58-nodes in @xmath65 ( except in proposition  [ propo : one ] below ) , but the reader should keep the following convention in mind : when @xmath58-nodes are identified in @xmath65 for multiple solutions @xmath58 , _ these are all chosen with respect to the same certificate_.    _ example . _ in figures  [ fig : cutvertcsg](c)(f ) , the @xmath1-node for the coloring @xmath1 shown in figure  [ fig : cutvertcsg](b ) is marked .",
    "in particular consider @xmath85 in figure  [ fig : cutvertcsg](e ) .",
    "since the certificate for @xmath85 is not actually indicated in the figure , the other leaf with label  2 can also be chosen as the @xmath1-node ( considering the nontrivial label - preserving automorphisms of the graph ) .",
    "similarly , if we choose a coloring @xmath2 that coincides with @xmath1 except on nodes @xmath110 and @xmath111 , where we choose @xmath112 and @xmath113 , then the same two leaves ( the ones with label 2 ) of @xmath85 can be chosen as the @xmath2-node .",
    "nevertheless , if both an @xmath1-node and @xmath2-node are marked , then this will only be correct according to the above convention when they are distinct ! and @xmath2 , and correctly mark an @xmath1-node @xmath66 with respect to a one certificate @xmath114 , and a @xmath2-node @xmath115 with respect to another certificate @xmath116 , such that @xmath1 and @xmath2 are in different components of @xmath7 , but @xmath66 and @xmath115 are in the same component of @xmath65 .",
    "this is clearly not desirable ; see proposition  [ propo : one ] .",
    "]    the main purpose of the definitions in this section is the following key observation .",
    "[ propo : one ] let @xmath3 , with terminal set @xmath57 , be an instance of a solution graph concept @xmath6 .",
    "let @xmath65 be the contracted solution graph for some terminal projection  @xmath55 .",
    "let @xmath1 and @xmath2 be two solutions and let @xmath66 and @xmath115 be the @xmath1-node resp .",
    "@xmath2-node with respect to some certificate @xmath27 .",
    "then there is a path from @xmath1 to @xmath2 in @xmath7 if and only if there is a path from @xmath66 to @xmath115 in @xmath65 .",
    "first suppose that there exists a path @xmath117 from @xmath1 to @xmath2 in @xmath7 .",
    "replace every solution  @xmath118 in this sequence by the node @xmath33 of @xmath65 with @xmath119 . by definition ,",
    "the resulting node sequence starts in @xmath66 , and terminates in @xmath115 . by lemma  [ lem : characterizationcsgs]([pr : adjacency ] ) ,",
    "consecutive nodes in this sequence are the same or adjacent , so this sequence is a pseudowalk from @xmath66 to @xmath115 .",
    "this immediately yields a path from @xmath66 to  @xmath115 .    for the other direction , consider a path @xmath41 from @xmath66 to @xmath115 in @xmath65 . for every node @xmath120 , @xmath121 induces a connected subgraph of @xmath7 ( lemma  [ lem : characterizationcsgs]([pr : connectedsets ] ) ) . for any two consecutive nodes @xmath120 and @xmath122 ,",
    "there exist solutions @xmath123 and @xmath124 that are adjacent in @xmath7 ( lemma  [ lem : characterizationcsgs]([pr : adjacency ] ) ) .",
    "clearly , @xmath125 and @xmath126 . combining these facts yields a path from @xmath1 to @xmath2 in @xmath7 .",
    "proposition  [ propo : one ] implies that for a solution graph concept @xmath6 and _ any _ terminal projection @xmath55 and terminal set @xmath57 , we can decide the @xmath6-connectivity problem if we know @xmath65 ( the answer is yes if and only if @xmath65 is connected ) and the @xmath6-reachability problem if we know @xmath65 and the @xmath1-node and the @xmath2-node ( the answer is yes if and only if these two nodes are in the same component ) .",
    "however , in order to obtain an _ efficient _ algorithm using this strategy , we need to choose the terminal projection @xmath55 smartly : we need to throw away enough irrelevant information to ensure that @xmath65 will be significantly smaller than @xmath7 , yet we need to maintain enough information to ensure that @xmath65 can be computed efficiently , without first constructing @xmath7 . our strategy for doing this is to use dynamic programming to compute @xmath127 for ever larger subgraphs @xmath10 of @xmath3 , while ensuring that all of the s stay small throughout the process .",
    "the remainder of this paper shows a successful example of this strategy .",
    "the following terminology is based on widely used techniques for dynamic programming over tree decompositions ; see section  [ ssec : nicetds ] and  @xcite for background information .",
    "a _ terminal graph @xmath128 _ is a graph @xmath3 together with a vertex set @xmath129 , whose vertices are called the _",
    "terminals_. if @xmath130 , then @xmath128 is called a _",
    "leaf_. if @xmath131 , then we say that the new terminal graph @xmath132 is obtained from @xmath128 by _ forgetting @xmath33 _ ( or _ using a forget operation _ ) .",
    "if @xmath133 , @xmath131 and @xmath134 then we say that @xmath128 can be obtained from @xmath135 by _ introducing @xmath33 _ ( or _ using an introduce operation _ ) .",
    "note that for a terminal graph @xmath136 with @xmath137 , different graphs can be obtained from @xmath136 by introducing a vertex @xmath33 , whereas forgetting a terminal always yields a unique result .",
    "moreover , the condition that each neighbor of the new vertex  @xmath33 must be in  @xmath57 is necessary , as we will see at several places in our proofs .",
    "we say that @xmath128 is the _ join of @xmath138 and @xmath139 _ ( or _ can be constructed using a join operation _ ) if    * @xmath140 and @xmath141 are induced subgraphs of @xmath3 , * @xmath142 and @xmath143 , * @xmath144 and @xmath145 , and * for every @xmath38 , it holds that @xmath146 or @xmath147 .",
    "we will now focus on csgs for the @xmath0-color graph concept @xmath8 , using the terminal projection @xmath148 .",
    "we will show how to compute the  @xmath149 when @xmath128 is obtained using a forget , introduce or join operation from a ( pair of ) graph(s ) for which we know the ( s ) .",
    "we recall that a variant of these s have been considered before by hatanaka , ito and zhou  @xcite , namely for the case that @xmath150 in the context of list colorings of caterpillars .",
    "similar dynamic programming rules were given in  @xcite : for the case that @xmath150 , they presented a combined introduce and forget rule , and a restricted type of join rule .",
    "we start by stating a trivial rule for computing @xmath149 for leaves , which follows from the facts that @xmath23 has @xmath0-colorings of  @xmath3 as nodes and that the label @xmath151 of a node  @xmath66 in @xmath149 is a @xmath0-coloring of @xmath63 $ ] .",
    "[ propo : recolleaf ] let @xmath128 be a terminal graph with @xmath130 .",
    "then @xmath149 is isomorphic to @xmath23 and its label function @xmath17 is the isomorphism from @xmath149 to @xmath23 .",
    "moreover , for every @xmath0-coloring @xmath58 of @xmath3 , the @xmath58-node of @xmath149 is the node @xmath33 with @xmath152 .    here is the rule for the forget operation .",
    "this rule is illustrated in figure  [ fig : unitintcsg ] .",
    "[ lem : recolforget ] let @xmath128 be a terminal graph . for every @xmath131 , it holds that @xmath153 can be computed from @xmath154 as follows :    * for every node @xmath66 in @xmath155 with @xmath156 , let @xmath157 .",
    "* iteratively contract every edge between two nodes @xmath66 and @xmath115 with @xmath158 and assign label @xmath159 to the resulting node @xmath160 .",
    "moreover , for any coloring @xmath58 of @xmath3 , the @xmath58-node of @xmath161 is the node that results from contracting the set of nodes that includes the @xmath58-node of @xmath149 .",
    "let @xmath27 denote the certificate for @xmath162 , so for every node @xmath66 of @xmath155 , @xmath67 denotes the set of @xmath0-colorings of @xmath3 ( or _ solutions _ ) , such that these sets satisfy the properties stated in lemma  [ lem : characterizationcsgs ] .",
    "in addition , for every coloring @xmath58 for which a @xmath58-node @xmath66 has been marked in @xmath155 , we may assume that @xmath77 .",
    "we will prove the statement using lemma  [ lem : characterizationcsgs ] again , by giving a certificate @xmath163 for @xmath164 , and proving that the five properties hold for these .",
    "the graph @xmath165 is obtained by iteratively contracting edges of @xmath155 , so every node @xmath115 of @xmath165 corresponds to a connected set of nodes of @xmath155 , which we will denote by @xmath166 .",
    "so @xmath167 is a partition of @xmath168 . for every node @xmath169",
    ", we define @xmath170 .    for every @xmath0-coloring @xmath58 of @xmath3 such that the @xmath58-node @xmath171 is marked , we define the @xmath58-node of @xmath165 to be the node  @xmath115 with @xmath172 .",
    "clearly , @xmath173 then holds , so this is correct .",
    "it now remains to verify that the solution sets @xmath174 satisfy the five properties stated in lemma  [ lem : characterizationcsgs ] .",
    "a.   @xmath175 is a partition of the nodes of @xmath23 ( lemma  [ lem : characterizationcsgs]([pr : partition ] ) ) , and @xmath167 is a partition of @xmath168 , so @xmath176 is again a partition of the nodes @xmath23",
    ". b.   consider a node @xmath169 , with label @xmath177 , which is a @xmath0-coloring of @xmath178 $ ] .",
    "every node @xmath172 has a label @xmath151 with @xmath179 , and for every @xmath77 , it holds that @xmath180 ( lemma  [ lem : characterizationcsgs]([pr : correctlabels ] ) ) , and thus @xmath181 .",
    "therefore , for every @xmath173 , it holds that @xmath181 . c.   consider two adjacent nodes @xmath66 and @xmath115 in @xmath165 .",
    "this implies that there exists an edge @xmath182 between the node sets @xmath183 and @xmath166 of @xmath155 . by definition ,",
    "all nodes @xmath184 have @xmath185 , and all nodes @xmath186 have @xmath187 .",
    "so if @xmath158 , then the edge @xmath182 should also have been contracted when constructing @xmath165 , a contradiction .",
    "hence @xmath188 .",
    "d.   consider a node @xmath66 of @xmath165 .",
    "the node set @xmath183 is connected , so for any two nodes @xmath189 , the subgraph of @xmath155 induced by @xmath183 contains a path from @xmath115 to @xmath66 .",
    "edges @xmath182 of this path correspond to solution sets @xmath190 and @xmath191 that contain adjacent solutions ( lemma  [ lem : characterizationcsgs]([pr : adjacency ] ) ) .",
    "in addition , all such solution sets  @xmath190 are connected in @xmath23 ( lemma  [ lem : characterizationcsgs]([pr : connectedsets ] ) ) . combining these facts",
    "shows that the new solution sets @xmath174 are again connected in @xmath23 .",
    "e.   let @xmath160 and @xmath192 be two nodes of @xmath165 . by construction ,",
    "@xmath160 and @xmath192 are adjacent if and only if there exist nodes @xmath193 and @xmath194 that are adjacent in @xmath155 .",
    "two such nodes @xmath66 and @xmath195 are adjacent in @xmath155 if and only if there exist solutions @xmath94 and @xmath196 that are adjacent in @xmath23 ( lemma  [ lem : characterizationcsgs]([pr : adjacency ] ) ) . using the definition of @xmath197 and @xmath198 ,",
    "we conclude that @xmath160 and @xmath192 are adjacent if and only if there exist solutions @xmath199 and @xmath200 that are adjacent in @xmath23 .",
    "we now give the rule for the introduce operation .",
    "this rule is illustrated in figure  [ fig : unitintcsg ] as well .",
    "[ lem : recolintroduce ] let @xmath128 be a terminal graph obtained from a terminal graph @xmath201 by introducing @xmath33 .",
    "then @xmath202 can be computed as follows from @xmath203 :    * for every node @xmath66 of @xmath155 with label @xmath151 , and every color @xmath204 : if the ( unique ) function @xmath205 with @xmath206 and @xmath207 is a coloring of @xmath63 $ ] then introduce a node @xmath208 with label @xmath209 . * for every pair of distinct nodes @xmath208 and @xmath210 : add an edge between them if and only if ( 1 ) @xmath211 or ( 2 ) @xmath212 is an edge in @xmath155 and @xmath213 .    moreover , for every @xmath0-coloring @xmath58 of @xmath3 , if @xmath66 is the @xmath214-node in @xmath155 and @xmath215 , then @xmath208 is the @xmath58-node of @xmath165 .",
    "let @xmath27 be a certificate for @xmath162 , so for every node @xmath66 of @xmath155 , let @xmath67 denote the set of @xmath0-colorings of @xmath216 ( or solutions ) , such that these sets satisfy the properties stated in lemma  [ lem : characterizationcsgs ] .",
    "in addition , for every coloring @xmath58 for which a @xmath58-node @xmath66 has been marked in @xmath155 , we may assume that @xmath77 .",
    "now we construct a certificate @xmath163 for @xmath164 . for every node @xmath208 of @xmath165 ( that corresponds to a node  @xmath66 of @xmath155 , and to assigning a color @xmath217 to the new vertex @xmath33 ) , we define @xmath218 to be the set of @xmath0-colorings @xmath1 of @xmath3 with @xmath219 and @xmath220 . for every @xmath0-coloring  @xmath58 of @xmath3 and node @xmath208 of @xmath165",
    ", we define @xmath208 to be the @xmath58-node of @xmath165 if and only if @xmath215 and @xmath66 is the @xmath214-node of @xmath155 .",
    "clearly , this guarantees @xmath221 for the chosen @xmath58-node @xmath208 . to prove the statement , it only remains to show that the new solution sets @xmath218 satisfy the five properties stated in lemma  [ lem : characterizationcsgs ] .",
    "a.   first , we observe that for every node @xmath208 of @xmath165 , @xmath218 is a nonempty set of @xmath0-colorings of @xmath3 , because @xmath67 is nonempty ( lemma  [ lem : characterizationcsgs ] ) , and by choice of @xmath217 , every coloring  @xmath94 can be extended to a @xmath0-coloring of @xmath3 by setting @xmath219 ( this uses the fact that @xmath134 ) .",
    "so to prove that the new solution sets form a partition of the nodes of @xmath23 , it only remains to show that every @xmath0-coloring  @xmath1 of @xmath3 is included in @xmath218 for exactly one new node @xmath208 .",
    "for every such @xmath1 , there exists a unique node @xmath66 of @xmath155 such that @xmath222 ( lemma  [ lem : characterizationcsgs]([pr : partition ] ) ) .",
    "since @xmath1 is a coloring of @xmath3 , @xmath223 is a coloring of @xmath63 $ ] , so we have created one node @xmath208 with @xmath224 .",
    "this is the unique node of @xmath165 with @xmath225 .",
    "b.   consider a node @xmath208 of @xmath165 , with label @xmath209 .",
    "for every @xmath225 , it holds that @xmath219 and @xmath206 .",
    "furthermore , @xmath226 ( lemma  [ lem : characterizationcsgs]([pr : correctlabels ] ) ) .",
    "this shows that the label @xmath227 is chosen correctly .",
    "c.   consider two adjacent nodes @xmath208 and @xmath210 of @xmath165 . if @xmath211 then @xmath228 , so @xmath188",
    "otherwise , @xmath66 and @xmath115 are adjacent nodes in @xmath155 , so @xmath92 ( lemma  [ lem : characterizationcsgs]([pr : propercoloring ] ) ) .",
    "the labels @xmath151 and @xmath229 are the restrictions of @xmath227 and @xmath230 to @xmath231 , so also in this case we conclude that @xmath188 .",
    "d.   consider a node @xmath208 of @xmath165 , and two @xmath0-colorings @xmath1 and @xmath2 in @xmath218 .",
    "there is a path @xmath232 from @xmath233 to @xmath234 in the subgraph of @xmath235 induced by @xmath67 ( lemma  [ lem : characterizationcsgs]([pr : connectedsets ] ) ) .",
    "all colorings @xmath58 in @xmath232 have an _ extension _",
    "@xmath236 with @xmath237 and @xmath238 .",
    "so replacing all colorings in @xmath232 by their extension this way yields a path from @xmath1 to @xmath2 in the subgraph of @xmath23 induced by @xmath218 .",
    "therefore , @xmath218 is again connected .",
    "e.   consider two distinct nodes @xmath208 and @xmath210 in @xmath165 , and their corresponding sets of solutions @xmath218 and @xmath239 .",
    "observe that these contain solutions that are adjacent in @xmath23 if and only if at least one of the following is true : ( 1 ) @xmath213 ( and thus @xmath240 ) and @xmath67 and @xmath102 contain solutions that are adjacent in @xmath235 , or ( 2 ) @xmath228 and @xmath241 .",
    "the first case holds if and only if @xmath213 and the nodes @xmath66 and @xmath115 are adjacent in @xmath155 ( lemma  [ lem : characterizationcsgs]([pr : adjacency ] ) ) . in the second case",
    ", @xmath241 holds if and only if @xmath242 , and thus @xmath211 ( lemma  [ lem : characterizationcsgs]([pr : partition ] ) ) .",
    "this shows that we have added the edges correctly .",
    "we finish this section by giving the rule for the join operation .",
    "this rule is illustrated in figure  [ fig : bigstar ] .",
    "[ lem : recoljoin ] let @xmath128 be a terminal graph that is the join of terminal graphs @xmath138 and @xmath139 .",
    "let @xmath243 and @xmath244 .",
    "then @xmath245 can be computed as follows :    * for every pair of nodes @xmath246 and @xmath247 : if @xmath248 then introduce a node @xmath249 with @xmath250 .",
    "* for two distinct nodes @xmath249 and @xmath251 , add an edge between them if and only if @xmath252 is an edge in @xmath253 and @xmath254 is an edge in @xmath255 .    moreover , for every @xmath0-coloring @xmath58 of @xmath3 , if @xmath66 is the @xmath256-node in @xmath253 and @xmath115 is the @xmath257-node in @xmath255 , then @xmath249 is the @xmath58-node in @xmath165 .",
    "denote @xmath258 and @xmath259 . for nodes @xmath66 of @xmath253 ,",
    "let @xmath260 denote the set of @xmath0-colorings of @xmath140 such that these sets satisfy the properties stated in lemma  [ lem : characterizationcsgs ] .",
    "similarly , we define the sets @xmath261 for nodes @xmath66 of @xmath255 .",
    "in addition , we assume again that these sets coincide with the choices of @xmath262-nodes and @xmath263-nodes .",
    "we define a certificate @xmath27 for @xmath264 as follows .",
    "for every node @xmath249 of @xmath165 , we define the set @xmath265 to consist of all @xmath0-color assignments @xmath1 of @xmath3 such that @xmath266 and @xmath267 . for any @xmath0-coloring @xmath58 of @xmath3 and node @xmath249 of @xmath165",
    ", we choose @xmath249 to be the @xmath58-node of @xmath165 if and only if @xmath66 is the @xmath262-node of @xmath253 and @xmath115 is the @xmath263-node of @xmath255 .",
    "this obviously guarantees that @xmath268 for the chosen @xmath58-node @xmath249 . to prove the statement",
    ", it only remains to show that the new solution sets @xmath265 satisfy the five properties stated in lemma  [ lem : characterizationcsgs ] .",
    "a.   first , we show that for every node @xmath249 of @xmath165 , @xmath265 is a nonempty set of @xmath0-colorings of @xmath3 .",
    "the set @xmath260 contains at least one coloring @xmath269 of @xmath140 , and @xmath270 contains at least one coloring @xmath271 of @xmath141 ( lemma  [ lem : characterizationcsgs]([pr : partition ] ) ) .",
    "both of these colorings yield the coloring @xmath272 when restricted to @xmath57 ( lemma  [ lem : characterizationcsgs]([pr : correctlabels ] ) ) , so they can be combined into a @xmath0-color assignment @xmath1 for @xmath3 . since all edges of @xmath3 are part of @xmath140 or @xmath141 ( by definition of the join operation ) , the resulting @xmath1 is a @xmath0-coloring of @xmath3 .",
    "+ to prove that the sets @xmath265 partition the @xmath0-colorings of @xmath3 , it now suffices to show that every @xmath0-coloring @xmath1 of @xmath3 is included in exactly one set @xmath265 .",
    "consider @xmath273 for @xmath274 .",
    "then @xmath275 for exactly one node @xmath66 of @xmath253 , and @xmath276 for exactly one node @xmath115 of @xmath255 ( lemma  [ lem : characterizationcsgs]([pr : partition ] ) ) .",
    "these nodes have @xmath277 and @xmath278 ( lemma  [ lem : characterizationcsgs]([pr : correctlabels ] ) ) , so we have created exactly one node @xmath249 with @xmath279 .",
    "b.   consider a node @xmath249 of @xmath165 , and a solution @xmath279 .",
    "let @xmath280 .",
    "then @xmath281 ( lemma  [ lem : characterizationcsgs]([pr : correctlabels ] ) ) .",
    "c.   consider adjacent nodes @xmath249 and @xmath251 of @xmath165 .",
    "then by definition , @xmath66 and @xmath195 are adjacent in @xmath253 , so @xmath282 ( lemma  [ lem : characterizationcsgs]([pr : propercoloring ] ) ) , and thus @xmath283 .",
    "d.   consider a node @xmath249 of @xmath165 .",
    "we prove that @xmath265 is a connected set in @xmath23 .",
    "consider any two colorings @xmath284 .",
    "define @xmath273 and @xmath285 for @xmath274 .",
    "then for @xmath274 , there exists a path @xmath286 ( or _ recoloring sequence _ ) from @xmath287 to @xmath288 , in the subgraph of @xmath289 induced by @xmath260 resp .",
    "@xmath270 ( lemma  [ lem : characterizationcsgs]([pr : connectedsets ] ) ) .",
    "all colorings @xmath58 in both paths satisfy @xmath290 ( lemma  [ lem : characterizationcsgs]([pr : correctlabels ] ) ) .",
    "therefore , we can construct a recoloring sequence from @xmath1 to @xmath2 that contains only colorings in @xmath265 by first recoloring vertices of @xmath291 as prescribed by the recoloring sequence @xmath292 ( which yields a coloring  @xmath293 of @xmath3 with @xmath294 and @xmath295 ) , and subsequently recoloring vertices of @xmath296 as prescribed by the recoloring sequence @xmath297 ( which yields the coloring  @xmath2 ) .",
    "this can be done because @xmath298 and neither @xmath292 nor @xmath297 recolors a vertex of @xmath57 .",
    "all of the color assignments in the resulting sequence are part of @xmath265 by definition ( and they are in fact colorings , as argued above in  ( [ pr : partition ] ) ) .",
    "e.   consider two distinct nodes @xmath249 and @xmath251 in @xmath165 .",
    "we prove that they are adjacent if and only if there exist solutions @xmath279 and @xmath299 that are adjacent in @xmath23 .",
    "+ suppose @xmath249 and @xmath251 are adjacent . by definition",
    ", this means that @xmath66 and @xmath195 are adjacent ( and thus distinct ) nodes of @xmath253 , and @xmath115 and @xmath300 are adjacent nodes of @xmath255 .",
    "so we can choose solutions @xmath301 and @xmath302 that are adjacent in @xmath303 , and solutions @xmath304 and @xmath305 that are adjacent in @xmath306 ( lemma  [ lem : characterizationcsgs]([pr : adjacency ] ) ) .",
    "since @xmath307 ( lemma  [ lem : characterizationcsgs]([pr : propercoloring ] ) ) , and @xmath308 and @xmath309 ( lemma  [ lem : characterizationcsgs]([pr : correctlabels ] ) ) , the colorings @xmath310 and @xmath311 differ on @xmath57 , and therefore , since they are adjacent , only on @xmath57 ( so their restrictions to @xmath291 are the same ) .",
    "similarly , the colorings @xmath312 and @xmath313 differ only on @xmath57 . by definition of @xmath249 , @xmath248 , so we can choose a @xmath0-coloring @xmath1 of @xmath3 with @xmath314 and @xmath315 .",
    "similarly , we can choose a @xmath0-coloring @xmath2 of @xmath3 with @xmath316 and @xmath317 . as argued above ,",
    "the colorings @xmath1 and @xmath2 differ only on one vertex in @xmath57 , so they are adjacent in @xmath23 . by their construction , @xmath279 and @xmath318 , so this proves the first direction .",
    "+ for the converse , suppose that there exist adjacent colorings @xmath279 and @xmath318 .",
    "let @xmath319 and @xmath320 for @xmath274 .",
    "let @xmath16 be the ( unique ) vertex of @xmath3 with @xmath321 .",
    "if @xmath322 then , by using similar arguments as in the previous paragraph , one can verify that @xmath66 and @xmath195 are adjacent nodes in @xmath253 and @xmath115 and @xmath300 are adjacent nodes in @xmath255 , and therefore @xmath249 and @xmath251 are adjacent in @xmath165 .",
    "we conclude the proof by showing that @xmath322 always holds .",
    "suppose for contradiction that @xmath323 ; without loss of generality assume that @xmath324 .",
    ". therefore @xmath326 , and thus @xmath327 ( lemma  [ lem : characterizationcsgs]([pr : partition ] ) ) .",
    "it follows that @xmath328 .",
    "in addition , since @xmath249 and @xmath251 are distinct nodes and @xmath327 , it follows that @xmath329 . but @xmath301 and @xmath330 are adjacent , so @xmath331 ( lemma  [ lem : characterizationcsgs]([pr : adjacency ] ) ) .",
    "this is a contradiction ( as @xmath332 must hold due to lemma  [ lem : characterizationcsgs]([pr : propercoloring ] ) ) .",
    "_ remark 1 . _",
    "the dp rules in this section can be generalized further to capture the rules of  @xcite for the _ list coloring _",
    "generalization @xmath333 of @xmath8 . in this generalization ,",
    "an instance @xmath334 consists of a graph @xmath3 together with color lists @xmath335 for each @xmath35 .",
    "solutions are now list colorings , which are colorings @xmath1 of @xmath3 such that @xmath336 for each @xmath35 .",
    "adjacency is defined as before .",
    "so the _ list coloring solution graph _",
    "@xmath337 is an induced subgraph of @xmath23 .",
    "hence , it is straightforward to generalize our dp rules to @xmath333 , namely by simply omitting all nodes that correspond to invalid vertex colors .",
    "in this section , we further illustrate the dynamic programming rules given in section  [ sec : dp ] , and show that components of @xmath338 can grow exponentially , even if @xmath3 is a chordal graph and @xmath4 .    when considering 4-colorable chordal graphs that may have cut vertices , it is easy to obtain csgs that have exponentially large components : take @xmath55 copies of the graph shown in figure  [ fig : cutvertcsg](a ) , and identify the @xmath339-vertices of all of these graphs",
    ". call the resulting graph @xmath340 .",
    "the graph @xmath341 is shown in figure  [ fig : bigstar](a ) .",
    "[ propo : ex1 ] for every integer @xmath342 , @xmath343 has a component with @xmath344 nodes .    by induction over @xmath55",
    "we prove the following : @xmath343 has a component that is a star ( a @xmath345 graph ) in which the central node has label 1 ( to be precise , this means that the label is a coloring that assigns color 1 to vertex @xmath339 ) , and which has @xmath346 leaves with label @xmath347 , for @xmath348 . the case @xmath349 can easily be verified ; see also figure  [ fig : cutvertcsg ] .",
    "for the induction step , apply lemma  [ lem : recoljoin ] to the star components of @xmath350 and @xmath351 given by the induction hypothesis : for @xmath348 , the @xmath352 nodes with label  @xmath347 of the former graph are combined with two nodes with label  @xmath347 of the latter graph , giving @xmath346 new nodes with label  @xmath347 . all of these are adjacent only to the unique new node with label 1 .    with a little more effort",
    ", we can also construct csgs with exponentially large components when restricting to @xmath5-connected @xmath0-colorable chordal graphs , or even 2-connected 4-colorable unit interval graphs , as follows . for @xmath353 , let the graph @xmath354 have vertex set @xmath355 , and edge set @xmath356 .",
    "a graph isomorphic to @xmath357 is shown in figure  [ fig : unitintcsg ] .",
    "note that each @xmath354 is unit interval .",
    "for our proof we need the following simple observation ( which has been used in various earlier papers on recoloring , such as  @xcite ) .",
    "[ propo : degeneracy ] let @xmath1 and @xmath2 be two @xmath0-colorings of a graph @xmath48 , and let @xmath33 be a vertex of degree at most @xmath358 .",
    "then @xmath23 contains a path from @xmath1 to @xmath2 if and only if @xmath235 contains a path from @xmath359 to @xmath360 .",
    "below we state our claim more precisely and give a proof of it as well .",
    "[ propo : ex2 ] for @xmath361 with @xmath362 , the csg @xmath363 has @xmath364 components on at least @xmath365 nodes .    for every set @xmath366",
    ", we construct a coloring @xmath367 of @xmath354 as follows . for all @xmath368 :    * @xmath369 if @xmath370 , and @xmath371 if @xmath372 .",
    "* @xmath373 if @xmath370 , and @xmath374 if @xmath372 .",
    "* @xmath375 . * @xmath376 .",
    "observe that for every @xmath27 , @xmath367 is a 4-coloring of @xmath354 .",
    "there are @xmath365 possible choices of @xmath27 , and therefore @xmath365 such colorings @xmath367 .",
    "an induction proof based on proposition  [ propo : degeneracy ] shows that for every @xmath377 and @xmath378 , @xmath78 contains a path from @xmath379 to @xmath380 : informally , vertex @xmath381 has degree @xmath382 and is therefore irrelevant for the reachability question . after deleting @xmath381 ,",
    "@xmath383 has degree 2 , and may be deleted next .",
    "continuing this procedure ends with two colorings of the complete graph on vertices @xmath384 , which coincide ( for every @xmath27 , @xmath367 assigns the colors @xmath385 to the vertices @xmath386 , respectively ) .",
    "it follows that all of the colorings @xmath367 we constructed are part of the same component of @xmath387 . finally , we observe that every coloring @xmath367 forms a one - node label component in @xmath363 . indeed ,",
    "the only vertex that can be recolored in any @xmath367 is the vertex @xmath381 ; all other vertices have three distinctly - colored neighbors .",
    "summarizing , @xmath363 contains a component that contains at least @xmath365 nodes that are labeled with a coloring that assigns colors 1 and 2 to vertices @xmath383 and @xmath381 , respectively .    for every 4-coloring of @xmath388 $ ]",
    ", the csg contains a component isomorphic to the component considered above , so there are @xmath364 components of this type .",
    "the last csg shown in figure  [ fig : unitintcsg ] contains two nodes with label @xmath389 ; these correspond to the colorings @xmath390 and @xmath391 constructed in the above proof .",
    "the csg shows that any recoloring sequence between these two colorings needs to recolor the vertices @xmath392 and @xmath393 at least two resp .",
    "three times .",
    "we remark that the proofs of propositions  [ propo : ex1 ] and  [ propo : ex2 ] illustrate different proof techniques for csgs : one uses the dynamic programming rules , and the other argues about label components of the solution graph directly .",
    "both examples show that we may need some additional technique in order to efficiently solve the @xmath8-reachability problem for some graph class .",
    "we will illustrate such an additional technique in the next section , where we reconsider the class of @xmath5-connected chordal graphs .",
    "in this section we show that s can be used to efficiently decide the @xmath8-reachability problem for @xmath5-connected chordal graphs .",
    "a graph is _ chordal _ if it contains no induced cycle of length greater than  3 .",
    "chordal graphs form a well - studied and important graph class ; see e.g.  @xcite for more information . to prove the result , we use the fact that for a chordal graph @xmath3 and any clique  @xmath57 of @xmath3 , the terminal graph @xmath128 can recursively be constructed from simple cliques using a polynomial number of clique - based introduce , forget and join operations .",
    "this is made precise in section  [ ssec : nicetds ] , by defining chordal nice tree decompositions after first proving a general bound valid for arbitrary nice tree decompositions in section  [ ssec : nice1 ] .",
    "we remark that the results in these two sections can alternatively be obtained using known results on tree decompositions ; see e.g.  ( * ? ? ? *",
    "sec.12.3 ) for a well - known characterization of chordal graphs in terms of tree decompositions and for further background on tree decompositions . see  @xcite for information on turning tree decompositions into dp - friendly _ nice tree decompositions _ and corresponding bounds .",
    "one can verify that ` chordal tree decompositions ' can be maintained this way , and adapt bounds accordingly .",
    "see  @xcite for an introduction to dp over tree decompositions . for readability , and since we do need to prove the aforementioned new size bound , we give a self - contained presentation .",
    "nice tree decompositions describe how a terminal graph @xmath128 can be obtained from trivial graphs using forget , introduce and join operations .",
    "nice tree decomposition _ of a terminal graph @xmath128 ( where @xmath3 is an arbitrary graph , not necessarily chordal , and @xmath57 may not be a clique ) is a tuple @xmath394 , where @xmath395 is a tree with root @xmath396 and @xmath397 is an assignment of _ bags _",
    "@xmath398 for each @xmath399 that can be defined recursively as follows :    * if @xmath130 , then the tree @xmath395 consists of one ( root ) node @xmath396 with bag @xmath400 .",
    "* if @xmath401 and @xmath402 is a nice tree decomposition of @xmath403 , then a nice tree decomposition for @xmath128 can be obtained by adding a new root @xmath396 with @xmath400 , and adding the edge @xmath404 .",
    "* if @xmath128 can be obtained from @xmath135 using an introduce operation and @xmath402 is a nice tree decomposition of @xmath135 , then a nice tree decomposition for @xmath128 can be obtained by adding a new root @xmath396 with @xmath400 , and adding the edge @xmath404 . *",
    "if @xmath128 can be obtained from @xmath138 and @xmath139 using a join operation , and @xmath405 and @xmath406 are nice tree decompositions of @xmath138 and @xmath139 , then a nice tree decomposition for @xmath128 can be obtained by adding a new root @xmath396 with @xmath400 and adding edges @xmath407 and @xmath408 .",
    "we call a node @xmath399 a _ leaf _ , _ forget node _ ,",
    "_ introduce node _ or _",
    "join node _ if @xmath32 is added as the root in case ( 1 ) , ( 2 ) , ( 3 ) or ( 4 ) , respectively .",
    "the _ width _ of @xmath394 is @xmath409 .",
    "[ lem : sizenicetreedecomp ] let @xmath394 be a nice tree decomposition of @xmath128 of width at most @xmath410 , and let @xmath411",
    ". then @xmath412 .",
    "let @xmath413 .",
    "we use induction over @xmath414 to prove that @xmath415 then , since this value is at most @xmath416 , the lemma statement follows .",
    "let @xmath417 .",
    "then the root @xmath396 of @xmath395 is a leaf ( so @xmath130 and @xmath418 ) .",
    "hence , we have that @xmath419 let @xmath420 .",
    "then the root  @xmath396 is either a forget , introduce or join node .",
    "we consider each of these cases below .",
    "+ if @xmath396 is a forget node then by induction , after adding the new root to the tree , the number of nodes is at most : @xmath421 if @xmath396 is an introduce node then by induction , after adding the new root to the tree , the number of nodes is at most : @xmath422 @xmath423 finally , suppose that @xmath396 is a join node and that @xmath128 is obtained by joining together graphs on @xmath424 and @xmath425 nodes . from the definition of the join operation",
    "it follows that both of these values are strictly larger than @xmath426 , so we may write @xmath427 and @xmath428 . then by induction , after adding the new root , the number of nodes is at most : @xmath429 @xmath430 for the last step , we used that @xmath431 .    in section  [ ssec : nicetds ]",
    "we show that our bound is asymptotically tight .",
    "a nice tree decomposition @xmath394 of @xmath128 is _ chordal _ if for every node @xmath399 , @xmath432 is a clique of @xmath3 .",
    "note that , if @xmath394 is a chordal nice tree decomposition of a @xmath0-colorable graph @xmath3 , then the width of @xmath394 is at most @xmath24 .",
    "hence , lemma  [ lem : sizenicetreedecomp ] shows that any chordal nice tree decomposition has at most @xmath433 nodes .    in order to show how to find a chordal nice tree decomposition in polynomial time we need the following lemma , which tells us how to select the proper type of root node when constructing such a tree decomposition . here , a terminal graph @xmath434 is called _ smaller _ than another terminal graph @xmath435 if @xmath436 .    [ lem : chordalnicetreedecomp ] let @xmath128 be a terminal graph where @xmath48 is a chordal graph , and @xmath57 is a clique with @xmath437 .",
    "if @xmath438 is disconnected , then @xmath128 can be obtained from a pair of smaller chordal terminal graphs @xmath138 and @xmath139 using a join operation .",
    "otherwise , @xmath128 can be obtained from a smaller chordal terminal graph @xmath136 using either a forget or introduce operation , where @xmath439 is again a clique .",
    "for every such @xmath128 , the relevant operation and subgraph(s ) can be found in polynomial time .",
    "if @xmath438 is disconnected , then let @xmath64 be the vertex set of a component of @xmath438 , and consider the two graphs @xmath440 $ ] and @xmath441 $ ] .",
    "then @xmath128 is the join of @xmath138 and @xmath139 with @xmath442 and @xmath443 .",
    "next assume @xmath438 is connected .",
    "if @xmath57 contains a vertex @xmath33 that has no neighbors in @xmath438 , then @xmath128 can be obtained from @xmath135 using an introduce operation , and @xmath444 .",
    "finally , assume that @xmath438 is connected and every vertex in @xmath57 is adjacent to at least one vertex in @xmath438 .",
    "then we prove that there exists a vertex @xmath445 that is adjacent to every vertex in @xmath57 .",
    "let @xmath445 be a vertex with a maximum number of neighbors in @xmath57 .",
    "suppose for a contradiction that at least one vertex in @xmath57 is not adjacent to @xmath32 .",
    "then we can choose a _ shortest _ path @xmath232 in @xmath438 from @xmath32 to a vertex @xmath33 with @xmath446 .",
    "( such a @xmath33 and @xmath232 exist because every vertex in @xmath57 has a neighbor outside of @xmath57 and @xmath438 is connected . )",
    "let @xmath16 be the _",
    "last _ vertex on @xmath232 ( when going from @xmath32 to @xmath33 ) with @xmath447 . since @xmath32 satisfies this condition ( because it has a maximum number of neighbors in @xmath57 ) , such a vertex @xmath16 exists .",
    "now we have chosen distinct vertices @xmath16 and @xmath33 such that there exists a path @xmath448 between them ( namely the sub path of @xmath232 from @xmath16 to @xmath33 ) with the following property : for all internal vertices @xmath66 of @xmath448 , @xmath449 holds .",
    "choose @xmath450 and @xmath451 ( by the choice of @xmath33 and @xmath16 , such vertices exist ) . now combining the path @xmath448 from @xmath16 to @xmath33 with the edges @xmath452 , @xmath453 and @xmath454 yields an induced cycle in @xmath3 of length at least  4 , contradicting that @xmath3 is chordal .",
    "we conclude that there exists a vertex @xmath445 with @xmath455 .",
    "so @xmath128 can be obtained from @xmath456 by a forget operation , such that @xmath457 is a clique in @xmath3 , and @xmath458 .",
    "the above case study can easily be translated to a polynomial time algorithm for finding the graph operation that applies .",
    "we are now ready to state the following result .",
    "[ corol : chordalnicetreedecomp ]",
    "let @xmath3 be a chordal @xmath0-colorable graph on @xmath459 vertices , and let @xmath57 be a clique of @xmath3 .",
    "in polynomial time , we can find a chordal nice tree decomposition of @xmath128 on at most @xmath433 nodes .",
    "lemma  [ lem : chordalnicetreedecomp ] shows how we can choose the proper type of root node .",
    "we can build the chordal nice tree decomposition by adding this node to the tree decomposition(s ) of ( a ) smaller graph(s ) .",
    "the entire chordal nice tree decomposition is constructed by continuing this process recursively .",
    "lemma  [ lem : sizenicetreedecomp ] shows that the resulting chordal nice tree decomposition has at most @xmath416 nodes , where @xmath460 is the maximum bag size .",
    "since every bag is a clique of @xmath3 and the graph is @xmath0-colorable , we have @xmath461 , so there are at most @xmath433 nodes . since we have a polynomial number of nodes , and for every node we spend polynomial time ( lemma  [ lem : chordalnicetreedecomp ] ) , the entire process terminates in polynomial time .",
    "we note that the precise complexity bound in corollary  [ corol : chordalnicetreedecomp ] depends on implementation details , which are beyond the scope of this paper .",
    "note that the bound from lemma  [ lem : sizenicetreedecomp ] holds for _ any _ nice tree decomposition .",
    "this is in contrast to the ( stronger ) bound given in  @xcite , which states that for any @xmath3 , a nice tree decomposition of @xmath3 of minimum width on at most @xmath462 nodes can be constructed ( for an appropriate choice of the terminal set @xmath57 ) .",
    "however , we now show that there are @xmath0-colorable chordal graphs @xmath3 for which any _ chordal _ nice tree decomposition has at least @xmath463 nodes .",
    "this explains why we can not use the bound from  @xcite , and shows that the bound in lemma  [ lem : sizenicetreedecomp ] is asymptotically sharp .",
    "[ p - tight ] there are @xmath0-colorable chordal graphs @xmath3 for which any chordal nice tree decomposition has at least @xmath463 nodes .    for any @xmath464 , consider the graph @xmath3 on @xmath465 vertices with @xmath466 , such that for all @xmath14 : @xmath467 , and for all @xmath14 and @xmath347 with @xmath468 : @xmath469 and @xmath470 .",
    "these are all the edges . by using lemma  [ lem :",
    "chordalnicetreedecomp ] it is readily verified that for every clique @xmath129 , every chordal nice tree decomposition of @xmath128 has @xmath471 nodes .",
    "we end with a proposition that we will apply to @xmath5-connected @xmath0-colorable chordal graphs in our induction proofs .",
    "[ propo : connectedness ] let @xmath3 be a @xmath17-connected chordal graph , and let @xmath57 be a clique of @xmath3 with @xmath133 . if @xmath128 can be obtained from @xmath135 using an introduce operation , then @xmath472 and @xmath216 is @xmath17-connected .",
    "if @xmath128 can be obtained from @xmath138 and @xmath139 using a join operation , then @xmath473 and both @xmath140 and @xmath141 are @xmath17-connected .",
    "if @xmath128 is obtained from @xmath135 using an introduce operation , then @xmath474 by definition . since @xmath133",
    ", it follows that @xmath231 is a vertex cut of @xmath3 that separates @xmath33 from at least one other vertex , so @xmath475 .",
    "in addition , since @xmath57 is a clique of @xmath3 , every vertex cut of @xmath216 is also a vertex cut of @xmath3 , and therefore @xmath216 is again @xmath17-connected .",
    "if @xmath128 is obtained from @xmath138 and @xmath139 using a join operation , then @xmath57 is a vertex cut of @xmath3 that separates @xmath476 from @xmath477 , so @xmath473 .",
    "in addition , since @xmath57 is a clique of @xmath3 , every vertex cut of @xmath478 is a vertex cut of @xmath3 ( for @xmath274 ) , and therefore @xmath140 and @xmath141 are again @xmath17-connected .",
    "using an inductive proof based on lemma  [ lem : chordalnicetreedecomp ] , we will now characterize the shape of csgs for @xmath5-connected @xmath0-colorable chordal graphs .",
    "this requires the following two definitions . for integers",
    "@xmath479 with @xmath480 , a labeled graph @xmath86 is an _ @xmath481-color - complete graph _ if there exists a set @xmath57 with @xmath482 such that :    * for all vertices @xmath483 , @xmath484 is a @xmath0-coloring of a complete graph on vertex set @xmath57 , * every such @xmath0-coloring of @xmath57 appears at exactly one vertex of @xmath10 , and * two vertices of @xmath10 are adjacent if and only if their labels differ on exactly one element of @xmath57 .    from this definition",
    "it follows that for every pair of integers @xmath485 and @xmath0 , there is a unique @xmath481-color complete graph , up to the choice of @xmath57 .",
    "an @xmath481-color - complete graph has @xmath486 vertices ( this is the number of ways to @xmath0-color a complete graph on @xmath485 vertices ) , and every vertex has degree @xmath487 . in particular ,",
    "if @xmath488 then the graph consists of @xmath489 isolated vertices ( which is a forest ) . a labeled graph @xmath86",
    "is said to satisfy the _ injective neighborhood property ( inp ) _ if for every vertex @xmath490 and every pair of distinct neighbors @xmath491 , it holds that @xmath492 .",
    "note that @xmath481-color - complete graphs trivially satisfy the .",
    "we will now show that for the graphs we consider , the following invariant is maintained by introduce , forget and join operations : the csg is an @xmath481-color complete graph , or a forest that satisfies the inp .",
    "note that a @xmath493-color complete graph is trivially a forest that satisfies the inp .",
    "we start with the trivial observation that this invariant initially holds .",
    "[ propo : invariantleaf ] let @xmath48 be a complete graph on @xmath485 vertices , with @xmath494 . then @xmath495 is an @xmath481-color complete graph .",
    "we now prove that a _ forget _",
    "operation maintains the invariant ( below , we argue that all the relevant cases are covered by the next lemma ) .",
    "recall that a label @xmath496 of a node @xmath32 of @xmath149 is a coloring of @xmath63 $ ] , so by @xmath497 we denote the color that @xmath498 receives in this coloring .",
    "[ lem : invariantforget ] let @xmath3 be a @xmath0-colorable chordal graph and let @xmath57 be a clique of @xmath3 with @xmath499 , and @xmath131 . if @xmath149 is a @xmath500-color complete graph , then @xmath161 is a @xmath501-color complete graph .",
    "if @xmath149 is a forest that satisfies the inp , then @xmath161 is a forest that satisfies the inp .",
    "let @xmath502 and @xmath503 .",
    "we will use that @xmath504 can be constructed from @xmath86 as shown in lemma  [ lem : recolforget ] .    first consider the case that @xmath86 is a @xmath500-color - complete graph .",
    "then for every coloring @xmath1 of @xmath178 $ ] , the nodes @xmath505 induce a nonempty complete subgraph of @xmath10 .",
    "when constructing @xmath504 from @xmath86 , this subgraph will be contracted into one node , so for every such coloring @xmath1 , @xmath506 contains exactly one node with label @xmath1 .",
    "consider two colorings @xmath269 and @xmath271 of @xmath178 $ ] that differ on only one vertex @xmath507 .",
    "we can extend both to a coloring of @xmath63 $ ] by choosing a color for @xmath33 that occurs in neither @xmath269 nor @xmath271 ( since @xmath508 ) , which yields colorings of @xmath63 $ ] that are adjacent in @xmath10 ( since @xmath86 is @xmath500-color complete ) and that are compatible with @xmath269 resp .",
    "it follows that the nodes of @xmath506 with labels @xmath269 and @xmath271 are adjacent ( lemma  [ lem : recolforget ] ) .",
    "we conclude that @xmath504 is a @xmath501-color - complete graph .",
    "next , consider the case that @xmath86 is a forest that satisfies the inp .",
    "then @xmath506 is clearly a forest again , since it can be obtained by contracting @xmath10 ( lemma  [ lem : recolforget ] ) .",
    "if @xmath10 contains no edges , then @xmath506 contains no edges , and trivially satisfies the inp again .",
    "so it only remains to consider the case that @xmath10 contains at least one edge , and therefore @xmath509 .",
    "the last part of the proof is illustrated in figure  [ fig : invariantforget ] .",
    "for every node @xmath510 , denote by @xmath511 the set of nodes of @xmath10 that are contracted to obtain @xmath512 , when constructing @xmath504 from @xmath86 as shown in lemma  [ lem : recolforget ] ( so all nodes in @xmath511 are labeled with a @xmath63$]-coloring that is compatible with the @xmath178$]-coloring @xmath513 ) .",
    "for every @xmath0-coloring @xmath1 of @xmath178 $ ] , there are at most two compatible colorings of @xmath63 $ ] , since @xmath508 .",
    "so since @xmath10 satisfies the inp , the subgraph of @xmath10 induced by the nodes that have an @xmath1-compatible label has maximum degree at most  1 , and thus maximum component size at most  2 .",
    "it follows that for every @xmath510 , @xmath514 .",
    "we now prove that @xmath504 satisfies the inp again .",
    "suppose to the contrary that @xmath506 contains a node @xmath512 with @xmath515 , that has two neighbor nodes @xmath516 and @xmath217 with @xmath517 .",
    "let @xmath507 be the vertex on which @xmath1 and @xmath2 differ .",
    "so there are nodes @xmath518 and @xmath519 that are adjacent in @xmath10 , and nodes @xmath520 and @xmath521 that are adjacent in @xmath10 ( lemma  [ lem : recolforget ] ) . because the adjacent colorings @xmath229 and @xmath522 differ on vertex @xmath16 , they differ on no other vertex .",
    "the same holds for @xmath523 and @xmath524 .",
    "because @xmath10 satisfies the inp , it follows that @xmath525 , so @xmath526 , and thus @xmath527 .",
    "we conclude that @xmath528 is a path in @xmath10 such that @xmath529 , @xmath530 , and @xmath531 .",
    "recall that labels of adjacent nodes in @xmath10 differ on exactly one vertex .",
    "the colorings @xmath229 , @xmath522 , @xmath524 and @xmath523 all use @xmath509 different colors out of a total of @xmath0 colors . combining these facts",
    "shows that @xmath532 .",
    "but since @xmath229 and @xmath523 are both compatible with @xmath2 , @xmath533 .",
    "this contradicts that @xmath523 is a ( proper ) coloring of @xmath63 $ ] .",
    "we conclude that @xmath504 satisfies the inp again .",
    "next , we show that the introduce operation maintains the invariant .",
    "[ lem : invariantintroduce ] let @xmath48 be a @xmath5-connected @xmath0-colorable chordal graph and let @xmath57 be a clique of @xmath3 , with @xmath437 , such that @xmath128 can be obtained from @xmath534 using an introduce operation . if @xmath535 is a @xmath501-color complete graph , then @xmath149 is a @xmath500-color complete graph .",
    "if @xmath536 or @xmath535 is a forest that satisfies the inp , then @xmath149 is a forest that satisfies the inp .",
    "let @xmath537 and @xmath538 .",
    "we will use that @xmath504 can be constructed from @xmath86 as shown in lemma  [ lem : recolintroduce ] . by proposition  [ propo : connectedness ] ,",
    "if @xmath536 , then obviously @xmath506 is a set of isolated vertices , which proves the statement .",
    "so we may now assume that @xmath509 .",
    "first consider the case that @xmath86 is a @xmath501-color - complete graph .",
    "for every @xmath0-coloring @xmath1 of @xmath63 $ ] , there exists exactly one node in @xmath10 that has a label @xmath2 that is compatible with @xmath1 .",
    "so @xmath506 contains exactly one node with label @xmath1 .",
    "consider two colorings @xmath269 and @xmath271 of @xmath63 $ ] that differ on exactly one vertex .",
    "if this vertex is @xmath33 , then the nodes of @xmath506 with labels @xmath269 and @xmath271 are adjacent ( lemma  [ lem : recolintroduce ] ) .",
    "otherwise , let @xmath540 for @xmath274 .",
    "the nodes with labels @xmath541 and @xmath542 are adjacent in @xmath10 since it is a color - complete graph . therefore , the nodes of @xmath506 with labels @xmath269 and @xmath271 are also adjacent in this case ( lemma  [ lem : recolintroduce ] ) .",
    "we conclude that @xmath504 is a @xmath500-color complete graph .    next , consider the case that @xmath86 is a forest that satisfies the inp . from lemma  [ lem : recolintroduce ]",
    "it follows easily that @xmath504 satisfies the inp again .",
    "we now prove that @xmath506 is again a forest .",
    "since @xmath508 , every node @xmath66 of @xmath10 has as label @xmath151 a @xmath5-coloring of the complete graph @xmath178 $ ] .",
    "so there are exactly two nodes in @xmath506 that correspond to @xmath66 , which are adjacent ( lemma  [ lem : recolintroduce ] ) .",
    "we will now show that for any edge @xmath104 , the following holds : if @xmath68 and @xmath69 are the vertices of @xmath506 that correspond to @xmath66 , and @xmath543 and @xmath544 are the vertices of @xmath506 that correspond to @xmath115 , then there is at most one edge in @xmath506 with one end in @xmath545 and one end in @xmath546 .",
    "observe that this property , combined with the fact that @xmath10 contains no cycles , shows that @xmath506 again contains no cycles .",
    "assume without loss of generality that that @xmath68 and @xmath543 are adjacent in @xmath506 .",
    "let @xmath322 be the unique vertex with @xmath547 .",
    "observe that the colorings @xmath548 and @xmath549 differ only on @xmath33 , and that the same holds for the colorings @xmath550 and @xmath551 .",
    "since all colorings in @xmath552 use @xmath24 colors out of @xmath0 total colors , it follows that @xmath553 , and @xmath554 . because all of these labels are ( proper )",
    "colorings , we conclude that @xmath549 differs from the colorings @xmath550 and @xmath551 on both @xmath33 and @xmath16 , and @xmath551 differs from the colorings @xmath548 and @xmath549 on both @xmath33 and @xmath16 .",
    "therefore , @xmath555 is indeed the only edge between these two vertex groups .",
    "it follows that @xmath506 contains no cycles and is again a forest .",
    "finally , we show that the join operation maintains the invariant .",
    "[ lem : invariantjoin ] let @xmath48 be a @xmath0-colorable chordal graph and let @xmath57 be a clique of @xmath3 , such that @xmath128 can be obtained from @xmath138 and @xmath139 using a join operation . if one of @xmath556 or @xmath557 is an @xmath481-color complete graph , then @xmath149 equals the other graph .",
    "if both @xmath556 and @xmath557 are forests satisfying the inp , then @xmath149 is a forest satisfying the inp .",
    "let @xmath558 , @xmath559 , and @xmath502 .",
    "we use that @xmath86 can be constructed from @xmath560 and @xmath561 as shown in lemma  [ lem : recoljoin ] .",
    "first suppose that @xmath560 is a color - complete graph .",
    "then lemma  [ lem : recoljoin ] shows that every node of @xmath562 is combined with exactly one node of @xmath563 ( there is exactly one node with the same label ) , so the nodes of @xmath10 correspond bijectively to nodes of @xmath562 .",
    "furthermore , any edge of @xmath562 is maintained , since @xmath563 has edges between every pair of nodes labeled by colorings that differ on exactly one vertex .",
    "so @xmath86 equals @xmath561 .",
    "if @xmath561 is a color - complete graph , the proof is analog .",
    "so it only remains to prove the statement in the case that both @xmath560 and @xmath561 are forests that satisfy the inp . from lemma  [ lem : recoljoin ]",
    "it is easily seen that the inp is preserved in that case .",
    "we now argue that the resulting graph @xmath10 is again a forest .",
    "suppose to the contrary that @xmath10 contains a cycle @xmath564 with @xmath565 and @xmath566 ( we represent nodes of @xmath10 by tuples @xmath249 where @xmath567 and @xmath568 , as shown in lemma  [ lem : recoljoin ] ) .",
    "then @xmath569 is a closed walk in @xmath563 , and @xmath570 is a closed walk in @xmath562 , of length @xmath571 . since @xmath562 is a forest , there is an index @xmath14 such that @xmath572 .",
    "it follows that @xmath573 . but @xmath574 and @xmath575 are both neighbors of @xmath576 , so since @xmath563 satisfies the inp , @xmath577 .",
    "we conclude that the vertices @xmath578 and @xmath579 in @xmath10 are the same , contradicting that @xmath64 is a cycle .",
    "so @xmath10 is again a forest that satisfies the inp .",
    "combining the above lemmas yields :    [ thm : invariant ] let @xmath571 .",
    "let @xmath48 be a @xmath5-connected @xmath0-colorable chordal graph , and let @xmath129 be a clique of @xmath3 with @xmath580 .",
    "then @xmath149 is an @xmath481-color - complete graph , or it is a forest that satisfies the injective neighborhood property .",
    "we prove the statement by induction over @xmath581 .",
    "if @xmath130 , then @xmath149 is isomorphic to @xmath23 , with trivial label function ( proposition  [ propo : recolleaf ] ) , so this is an @xmath481-color - complete graph ( since @xmath57 is a clique ) .",
    "now assume that @xmath133 .    if @xmath128 can be obtained from a graph @xmath403 using a forget operation , where @xmath582 is a clique of @xmath3 , then by induction , @xmath583 is either an @xmath584-color - complete graph or a forest that satisfies the inp . because @xmath582 is",
    "a clique on @xmath585 vertices and @xmath3 is @xmath0-colorable , @xmath586 . if @xmath587 then @xmath583 is a set of isolated nodes",
    "this shows that lemma  [ lem : invariantforget ] covers all cases , and thus @xmath149 satisfies the desired property again .",
    "if @xmath128 can be obtained from a graph @xmath534 using an introduce operation then proposition  [ propo : connectedness ] shows that @xmath216 is again @xmath5-connected , and obviously it is again chordal , so we may use induction to conclude that @xmath535 is either an @xmath584-color - complete graph or a forest that satisfies the inp .",
    "proposition  [ propo : connectedness ] also shows that @xmath539 .",
    "this shows that lemma  [ lem : invariantintroduce ] covers all cases , and thus @xmath149 satisfies the desired property again .    in the remaining case ,",
    "lemma  [ lem : chordalnicetreedecomp ] shows that @xmath128 is the join of two ( smaller ) graphs @xmath138 and @xmath139 , which are again @xmath5-connected ( proposition  [ propo : connectedness ] ) , and chordal since they are induced subgraphs of @xmath3 , so we can use the induction hypothesis",
    ". then lemma  [ lem : invariantjoin ] can be applied , to show that @xmath149 satisfies the desired property again .    _",
    "_ the examples in figure  [ fig : cutvertcsg ] show that if we relax the connectivity requirement to @xmath588-connectedness , the property in theorem  [ thm : invariant ] does not necessarily hold anymore : the examples in figure  [ fig : cutvertcsg](c ) and  ( d ) are not forests , and the example in figure  [ fig : cutvertcsg](e ) does not satisfy the inp .",
    "hence , we can not generalize our polynomial - time result on @xmath589-reachability to @xmath588-connected chordal graphs in a straightforward way .    the characterization of @xmath149 in theorem  [ thm : invariant ] does not yet guarantee that simply keeping track of the ( relevant component of the )   yields a polynomial time algorithm , as shown by the second example in section  [ sec : badexamples ] . however",
    ", we will now show that it suffices to only keep track of the following essential information , which remains polynomially bounded .",
    "let @xmath48 be a graph with @xmath590 , and let @xmath1 and @xmath2 be @xmath0-colorings of a supergraph of @xmath3 .",
    "( @xmath3 should be viewed as a subgraph that occurs during the dynamic programming , while @xmath1 and @xmath2 are the colorings of the full graph . )",
    "let @xmath591 and @xmath592 . if @xmath149 is a forest with the @xmath593-node @xmath66 and @xmath594-node @xmath115 in the same component , then we define the _",
    "@xmath1-@xmath2-path _ to be the unique path in @xmath149 with end vertices @xmath66 and @xmath115 ( together with its vertex labels ) .",
    "given the two colorings @xmath1 and @xmath2 , the _ essential information _ for @xmath149 consists of the following :    * whether the @xmath593 and @xmath594 nodes appear in the same component , * whether @xmath149 is a forest , and * in case the answers to both questions are yes : the @xmath1-@xmath2-path in @xmath149 ( including vertex labels ) .",
    "we also need to prove a polynomial upper bound on the length of the @xmath1-@xmath2-path .",
    "this is nontrivial , since the introduce operation may increase the length by a factor  2 .",
    "however , we will show that this only happens when earlier , a forget operation has decreased the length by a similar amount . to formalize this",
    ", we use the following alternative length measure for paths in csgs for recoloring .    for a subgraph @xmath10 of @xmath3 and @xmath35",
    ", we denote the neighbors of @xmath33 in  @xmath10 by @xmath595 .",
    "let @xmath86 be a labeled graph , where every node label @xmath484 is a @xmath0-coloring of a complete graph on vertex set @xmath57 .",
    "the set of colors _ used by _ a node @xmath483 is defined as @xmath596 . if @xmath232 is a subgraph in @xmath10 and @xmath597 , then the _ node weight _ for @xmath33 is defined as @xmath598 .",
    "so this is the total number of colors that are used in the labels ( colorings ) for neighbors of @xmath66 in @xmath232 , that are not used by the label for @xmath66 itself .",
    "we define the _ weight of a subgraph @xmath232 of @xmath10 _ to be @xmath599 . for example , consider the last csg shown in figure  [ fig : unitintcsg ] : the vertex with label @xmath600 has weight  1 in the path with node labels @xmath601 , but weight  2 in the the path with node labels @xmath602 .",
    "this weight depends on whether the corresponding path in the previous csg ( before forgetting @xmath111 ) contained the ( blue ) edge between nodes @xmath603 and @xmath604 .",
    "the main idea is that for a path @xmath232 , @xmath605 bounds the length of @xmath232 , which follows from the next simple observation .",
    "[ propo : weightbounds ] let @xmath86 be a labeled graph , where every node label @xmath484 is a @xmath0-coloring of a complete graph on a vertex set @xmath57 , such that adjacent nodes do not have the same label .",
    "then for any subgraph @xmath232 of @xmath10 and any vertex @xmath597 : @xmath606 if @xmath33 is not an isolated vertex in @xmath232 , and @xmath607 otherwise .",
    "we observe that , as soon as the @xmath593 and @xmath594 nodes are separated in some csg that occurs during the dynamic programming , we may terminate and return no .",
    "[ propo : stopwhenno ] let @xmath608 be a subgraph of @xmath48 , and let @xmath1 and @xmath2 be two @xmath0-colorings of @xmath3 .",
    "let @xmath609 and @xmath610 .",
    "for any @xmath611 and @xmath590 : if the @xmath593 and @xmath594 nodes of @xmath612 are separated , then the @xmath1 and @xmath2 nodes of @xmath149 are separated .",
    "suppose that the @xmath1 and @xmath2 nodes of @xmath149 are not separated . then by proposition  [ propo : one ]",
    ", there exists a recoloring sequence @xmath613 from @xmath1 to @xmath2 . then restricting all of these colorings to @xmath614 yields a recoloring sequence @xmath615 from @xmath593 to @xmath594 for @xmath616 .",
    "so using proposition  [ propo : one ] again , the @xmath593 and @xmath594 nodes in @xmath617 are not separated .",
    "note that in the next lemmas , ` polynomial time ' means polynomial in the entire input size , which includes the essential information ( in particular , the path length ) .",
    "[ lem : pathforget ] let @xmath3 be a @xmath5-connected @xmath0-colorable chordal graph and let @xmath57 be a clique of @xmath3 with @xmath499 , and @xmath131 .",
    "if we know the essential information for @xmath149 , then in polynomial time we can compute the essential information for @xmath161 . if @xmath149 has a unique @xmath1-@xmath2-path @xmath232",
    ", then @xmath161 has a unique @xmath1-@xmath2-path @xmath448 , and @xmath618 .",
    "theorem  [ thm : invariant ] shows that @xmath149 is a forest that satisfies the inp or an @xmath481-color complete graph .",
    "lemma  [ lem : invariantforget ] then shows that @xmath161 is a forest iff @xmath149 is a forest .",
    "proposition  [ propo : stopwhenno ] shows that if @xmath149 has no @xmath1-@xmath2-path , then @xmath161 has no @xmath1-@xmath2-path .",
    "if @xmath149 is a forest with a unique @xmath1-@xmath2-path @xmath232 , then lemma  [ lem : recolforget ] shows that we can find an @xmath1-@xmath2-path @xmath448 in @xmath161 by starting with @xmath232 , adjusting the labels , and possibly contracting some edges .",
    "this yields the unique @xmath1-@xmath2-path in the forest @xmath161 .",
    "we go more into detail on the construction of @xmath448 from @xmath232 , to prove that @xmath618 .",
    "if @xmath536 then @xmath149 consists of only isolated nodes , and thus @xmath149 ( which is a contraction of the former graph ) as well , so the statement is trivial .",
    "so now assume that @xmath509 . by proposition  [ propo : weightbounds ] , every node in @xmath232 has weight  1 , and nodes in @xmath448 have weight at most  2 .",
    "so to prove that @xmath618 , it suffices to show that every node of @xmath448 with weight  2 results from contracting an edge of @xmath232 ( that is , contracting two nodes of weight  1 ) .",
    "denote by @xmath17 the node labels in @xmath161 ( which are @xmath5-colorings of @xmath178 $ ] ) .",
    "consider a node @xmath619 with weight  2 , so it has two neighbors @xmath620 .",
    "let @xmath621 , and @xmath622 .",
    "since @xmath623 , it holds that @xmath624 , so @xmath625 .",
    "so it is not possible to extend @xmath151 , @xmath229 and @xmath523 to @xmath0-colorings of @xmath63 $ ] by assigning the same color to @xmath33 , and therefore the node @xmath115 resulted from contracting two nodes of @xmath232 .",
    "[ lem : pathintroduce ] let @xmath48 be a @xmath5-connected @xmath0-colorable chordal graph and let @xmath57 be a clique of @xmath3 , with @xmath437 , such that @xmath128 can be obtained from @xmath135 using an introduce operation .",
    "let @xmath1 and @xmath2 be two @xmath0-colorings of a supergraph of @xmath3 .",
    "if we know the essential information for @xmath535 , then in polynomial time we can compute the essential information for @xmath149 . if @xmath149 has a unique @xmath1-@xmath2-path @xmath448 , then @xmath626 if @xmath535 has a unique @xmath1-@xmath2-path @xmath232 , and @xmath627 otherwise .",
    "let @xmath628 and @xmath629 , such that @xmath504 is obtained from @xmath86 as shown in lemma  [ lem : recolintroduce ] .",
    "let @xmath630 and @xmath631 .",
    "theorem  [ thm : invariant ] shows that @xmath86 is either an @xmath481-color - complete graph ( for @xmath632 ) , or a forest that satisfies the inp .",
    "( here , @xmath5-connectedness follows from proposition  [ propo : connectedness ] . )    if @xmath536 then @xmath506 is a forest consisting of isolated nodes .",
    "so its @xmath593 and @xmath594 nodes are in the same component if and only if they are the same .",
    "this holds if and only if @xmath633 , and either @xmath86 is a @xmath500-color - complete graph or a forest with an @xmath1-@xmath2-path of length zero .",
    "clearly the @xmath1-@xmath2-path in @xmath506 has length zero in this case , and the label of its node is @xmath634 .",
    "this shows how we can deduce the essential information if @xmath536 , so we may now now assume that @xmath509 ( proposition  [ propo : connectedness ] )",
    ". then lemma  [ lem : invariantintroduce ] shows that @xmath506 is a forest if and only if @xmath10 is a forest .",
    "proposition  [ propo : stopwhenno ] shows that if @xmath506 has no @xmath1-@xmath2-path , then @xmath10 has no @xmath1-@xmath2-path .",
    "now assume that @xmath10 has a unique @xmath1-@xmath2-path @xmath232 .",
    "we will now apply lemma  [ lem : recolintroduce ] to the nodes of @xmath232 to construct a ( labeled ) @xmath1-@xmath2-path @xmath448 , which is a ( labeled ) subgraph of @xmath504 , and thus the unique @xmath1-@xmath2-path in @xmath504 , and show that @xmath626 .",
    "( as an illustration of this proof , consider for instance how in figure  [ fig : unitintcsg ] , the path @xmath448 with @xmath635 between node labels @xmath636 and @xmath637 in the csg with @xmath638 is deduced from the path @xmath232 with @xmath639 between node labels @xmath640 and @xmath641 in the previous csg . )    since @xmath508 , lemma  [ lem : recolintroduce ] shows that every node @xmath642 yields two adjacent nodes of @xmath506 , which we will denote as @xmath68 and @xmath69 , such that the labels @xmath548 and @xmath549 ( @xmath643-colorings of @xmath63 $ ] ) assign the two colors @xmath512 and @xmath516 that are not used by @xmath151 to vertex @xmath33 . for any two adjacent nodes @xmath66 and @xmath115 in @xmath232 , @xmath151 and @xmath229 differ on exactly one vertex of @xmath231 , and both are @xmath5-colorings , so there is at least one color @xmath217 that is used neither by @xmath151 nor by @xmath229 .",
    "so we can choose indices @xmath644 such that @xmath645 and @xmath646 , and therefore @xmath647 and @xmath648 are adjacent in @xmath506 ( lemma  [ lem : recolintroduce ] ) .",
    "these two observations show that if we take the two nodes @xmath68 and @xmath69 for every @xmath642 , then all of these nodes together induce a connected subgraph of @xmath506 ( a caterpillar with a perfect matching in fact ) that contains the @xmath593-node and the @xmath594-node of @xmath506 . within this subgraph",
    "we can easily find the new @xmath1-@xmath2-path @xmath448 .",
    "every node of the new path @xmath448 has weight  1 ( proposition  [ propo : weightbounds ] )",
    ". the total weight of @xmath232 may increase by  2 if both end nodes of @xmath232 are replaced by a pair of nodes this way .",
    "nevertheless , we will now show that that the weight can not increase by more than  2 , by showing that internal nodes @xmath115 of @xmath232 are only replaced by a pair of nodes @xmath543 and @xmath544 in @xmath448 if @xmath649 .    consider a node @xmath650 with neighbors @xmath66 and @xmath160 on @xmath232 ,",
    "such that without loss of generality the path @xmath448 contains the new nodes @xmath651 , in this order . let @xmath652 be the unique vertex that the colorings @xmath548 and @xmath550 differ on , and let @xmath507 be the unique vertex that the colorings @xmath551 and @xmath653 differ on .",
    "since all of the colorings @xmath654 use @xmath24 colors out of a total of @xmath0 colors , we conclude that @xmath655 , and similarly , @xmath656 .",
    "it follows that the colorings @xmath657 and @xmath658 together still use all @xmath0 colors , and therefore @xmath649 .",
    "we conclude that internal nodes of @xmath232 can not contribute a weight increase , so @xmath626 .",
    "[ lem : pathjoin ] let @xmath48 be a @xmath5-connected @xmath0-colorable chordal graph and let @xmath57 be a clique of @xmath3 , such that @xmath128 can be obtained from @xmath138 and @xmath139 using a join operation .",
    "if we know the essential information for both @xmath659 and @xmath660 , then in polynomial time we can compute the essential information for @xmath661 . if @xmath149 is a forest with a unique @xmath1-@xmath2-path @xmath232 , then for at least one choice of @xmath662",
    ", @xmath663 is a forest with a unique @xmath1-@xmath2-path @xmath664 , and @xmath665 .",
    "let @xmath154 , @xmath666 and @xmath667 be labeled graphs such that @xmath86 is obtained from @xmath560 and @xmath561 as shown in lemma  [ lem : recoljoin ] . by theorem  [ thm : invariant ] , for @xmath662 , @xmath668 is either a @xmath669-color complete graph or a forest that satisfies the inp .",
    "( proposition  [ propo : connectedness ] shows that the graphs are again @xmath5-connected . )    by lemma  [ lem : invariantjoin ] , @xmath10 is a forest ( that satisfies the inp ) if and only if at least one of @xmath563 and @xmath562 is a forest . by proposition  [ propo : stopwhenno ] , if there is no @xmath1-@xmath2-path in one of @xmath563 and @xmath562 , then there is no @xmath1-@xmath2-path in @xmath10 .",
    "so now assume that both @xmath563 and @xmath562 contain an @xmath1-@xmath2-path ( though possibly not unique ) .",
    "if one of these , say @xmath13 , is a forest with a unique @xmath1-@xmath2-path @xmath664 , but the other is a color - complete graph , then the unique @xmath1-@xmath2-path @xmath232 of @xmath10 is the same as @xmath664 ( lemma  [ lem : invariantjoin ] ) , and thus @xmath665 .    it only remains to consider the case that both @xmath563 and @xmath562 are forests and contain a unique @xmath1-@xmath2-path ; call these @xmath670 and @xmath671 respectively .",
    "if @xmath670 equals @xmath671 , then @xmath10 also has an @xmath1-@xmath2-path that equals these paths ( lemma  [ lem : recoljoin ] ) , which is therefore the unique @xmath1-@xmath2-path @xmath232 in @xmath10 , with @xmath672 .",
    "we conclude the proof by showing the other direction .",
    "( this is similar to the last part of the proof of lemma  [ lem : invariantjoin ] . )",
    "suppose @xmath10 has an @xmath1-@xmath2-path @xmath673 .",
    "every node @xmath120 of @xmath10 corresponds to a pair @xmath674 and @xmath675 of nodes in @xmath563 resp .",
    "@xmath562 , with @xmath676 , and @xmath677 and @xmath678 are @xmath1-@xmath2-walks in @xmath563 resp .  @xmath562 ( lemma  [ lem : recoljoin ] ) .",
    "if one of these , say @xmath670 , is not a path , then since @xmath563 is a forest , there exists an index @xmath14 such that @xmath679 .",
    "so @xmath680 .",
    "but since @xmath232 is a path , @xmath681 and @xmath122 are distinct neighbors of @xmath120 , so this contradicts the inp .",
    "we conclude that both @xmath670 and @xmath671 are paths , so @xmath670 , @xmath671 and @xmath232 are all equal , so @xmath672 .",
    "this concludes the proof , which shows that we can decide in polynomial time whether @xmath10 is a forest with an @xmath1-@xmath2-path , and compute it in that case .",
    "combining the above statements yields the main result of this section :    [ thm : main ] let @xmath3 be a @xmath0-colorable @xmath5-connected chordal graph , and let @xmath1 and @xmath2 be two @xmath0-colorings of @xmath3 . then in polynomial time",
    ", we can decide whether @xmath23 contains an @xmath1-@xmath2 path .",
    "corollary  [ corol : chordalnicetreedecomp ] shows that for every chordal @xmath0-colorable graph @xmath3 on @xmath459 vertices , we can find in polynomial time a chordal nice tree decomposition on at most @xmath433 nodes .",
    "so every node of this tree decomposition corresponds to a @xmath5-connected chordal subgraph @xmath10 of @xmath3 with terminal set @xmath57 , such that either @xmath10 is a clique with @xmath682 ( leaf nodes ) , or @xmath683 can be obtained from the graph(s ) corresponding to its child node(s ) using a forget , introduce or join operation .",
    "( the fact that all of these graphs are @xmath5-connected follows inductively using proposition  [ propo : connectedness ] , and that they are chordal follows since they are induced subgraphs . ) for every one of those terminal subgraphs , we compute the essential information , bottom up ( proposition  [ propo : invariantleaf ] , lemmas  [ lem : pathforget ] , [ lem : pathintroduce ] and [ lem : pathjoin ] ) . the computation terminates , answering no , as soon as one subgraph @xmath683 is encountered such that @xmath1 and @xmath2 are separated in @xmath684 , which is correct by proposition  [ propo : stopwhenno ] .",
    "( we remark that this can occur when @xmath683 is obtained by a join operation , or by an introduce operation when @xmath536 . ) otherwise , the computation terminates for the root node of the tree decomposition , which corresponds to the entire graph @xmath3 itself , with some terminal set @xmath57 , with the conclusion that either @xmath149 is a color - complete graph , or that it is a forest that contains an @xmath1-@xmath2-path . in either case , the answer to the problem is yes ( proposition  [ propo : one ] ) .",
    "now we consider the complexity .",
    "we find the chordal nice tree decomposition in polynomial time , and it has at most @xmath433 nodes ( corollary  [ corol : chordalnicetreedecomp ] ) . computing",
    "the essential information for all nodes can be done in polynomial time , although the input size here includes the @xmath1-@xmath2-path .",
    "nevertheless , every operation increases the weight of the path by at most  2 ( lemmas  [ lem : pathforget ] , [ lem : pathintroduce ] and [ lem : pathjoin ] ) , and in every case the weight of the path is an upper bound for its length ( proposition  [ propo : weightbounds ] ) , so the maximum path length that can occur during the algorithm is at most @xmath685 .",
    "together this shows that the whole procedure terminates in polynomial time .",
    "we stress that @xmath481-color complete graphs , which have @xmath486 nodes , are not computed explicitly in our algorithm .",
    "so indeed , in order to obtain a polynomial time algorithm , we do not need to assume that @xmath0 is a constant .",
    "an obvious question is whether our polynomial - time algorithm can be extended to all chordal graphs , or whether @xmath8-reachability is pspace - hard for chordal graphs . since the @xmath21-reachability problem is polynomial - time solvable for general graphs  @xcite , the first open case is to determine the complexity of @xmath686-reachability for chordal graphs ( with at least one cut vertex ) .",
    "we refer to remark  2 for a brief discussion on why our current proof technique does not work for this case .",
    "we also note that the complexity of @xmath686-reachability is open for proper interval graphs .",
    "initial experimental results for proper interval graphs seem to suggest that even solving the latter problem is not straightforward .",
    "even though the dp method has now been used to obtain polynomial time algorithms for several reconfiguration problems , we remark that the true strength of the method is not always revealed when using the viewpoint of worst - case algorithm analysis . for instance , when considering randomly generated @xmath0-colorable chordal or interval graphs , we observed that the method performs well on most instances , despite the fact that specialized examples can be constructed that exhibit exponential growth .",
    "as we noticed when considering other reconfiguration problems , this behavior seems to occur in general .",
    "because of this ,",
    "we will write a subsequent paper which will include computational studies , where we apply extensions of this method to various other reconfiguration problems such as well - studied variants of independent set reconfiguration problems ( see e.g.  @xcite ) .      the method of using csgs is unsuited for the aforementioned length - bounded reachability problems ( see e.g.  @xcite ) , but one can easily apply it to solve the @xmath6-connectivity problem .",
    "hence , we believe that determining the complexity of @xmath6-connectivity for well - studied solution graph concepts @xmath6 via the use of csgs is an interesting question . in this context",
    "we recall that the @xmath8-connectivity problem is trivial for chordal graphs  @xcite ( see section  [ sec : intro ] ) .",
    "nevertheless , studying the complexity of the following related problem seems interesting . call two @xmath0-colorings @xmath1 and @xmath2 of a graph @xmath3 _ compatible _ if they coincide on all @xmath0-cliques of @xmath3 . given a chordal graph @xmath3 and @xmath0-coloring @xmath1 ,",
    "is the subgraph of @xmath23 induced by all @xmath0-colorings that are compatible with @xmath1 connected ?",
    "finally we discuss the list coloring generalization @xmath333 of @xmath8 . in remark  1 , we explained how to generalize the dp rules presented in section  [ sec : dp ] to @xmath333 ( namely , by simply omitting all nodes that correspond to invalid vertex colors ) .",
    "in this way , we showed that the dp rules presented in  @xcite can be generalized .",
    "however , it is not obvious whether the results from section  [ sec : chordalgraphs ] also generalize to list colorings . in this context",
    ", the following question by hatanaka ( asked at core 2015 ) is interesting : is there a polynomial time algorithm for @xmath333-reachability restricted to trees ?",
    "note that @xmath687-reachability is trivial for trees , because @xmath23 is connected for every tree  @xmath3 and every integer @xmath20 ( see  @xcite ; this also follows easily from proposition  [ propo : degeneracy ] ) .",
    "m. bonamy , m. johnson , i.m .",
    "lignos , v. patel and d. paulusma , reconfiguration graphs for vertex colourings of chordal and chordal bipartite graphs , journal of combinatorial optimization 27 ( 2014 ) 132143 ."
  ],
  "abstract_text": [
    "<S> we introduce in a general setting a dynamic programming method for solving reconfiguration problems . </S>",
    "<S> our method is based on _ contracted solution graphs _ , which are obtained from solution graphs by performing an appropriate series of edge contractions that decrease the graph size without losing any critical information needed to solve the reconfiguration problem under consideration . </S>",
    "<S> our general framework captures the approach behind known reconfiguration results of bonsma ( 2012 ) and hatanaka , ito and zhou ( 2014 ) . as a third example , we apply the method to the following problem : given two @xmath0-colorings @xmath1 and @xmath2 of a graph  @xmath3 , can @xmath1 be modified into @xmath2 by recoloring one vertex of @xmath3 at a time , while maintaining a @xmath0-coloring throughout ? this problem is known to be pspace - hard even for bipartite planar graphs and @xmath4 . by applying our method in combination with a thorough exploitation of the graph structure </S>",
    "<S> we obtain a polynomial time algorithm for @xmath5-connected chordal graphs . </S>"
  ]
}