{
  "article_text": [
    "-5 mm    the mathematics of cryptography is driven by real world applications .",
    "the original and most basic application is the wish to communicate privately in the presence of an eavesdropper who is listening in . with the rise of computers as means of communication , abundant other application arise , ranging from verifying authenticity of data and access priveleges to enabling complex financial transactions over the internet involving several parties each with its own confidential information .    as a rule , in theoretical fields inspired by applications",
    ", there is always a subtle ( and sometimes not so subtle ) tension between those who do `` theory '' and those who `` practice '' . at times , the practitioner shruggs of the search for a provably good method , saying that in practice his method works and will perform much better when put to the test than anything for which a theorem could be proved .",
    "the theory of cryptography is unusual in this respect . without theorems that provably guarantee the security of a system ,",
    "it is in a sense worthless , as there is no observable outcome of using a security system other than the guarantee that no one will be able to crack it .    in computational complexity",
    "based cryptography one takes feasible ( or easy ) to mean those computations that terminate in polynomial time and infeasible ( or hard ) those computations that do not .",
    "achieving many tasks of cryptography relies on a gap between feasible algorithms used by the legitimate user versus the infeasibility faced by the adversary . on close examination",
    "then , it becomes apparent that a necessary condition for many modern cryptographic goals is that @xmath0 , although it is not known to be a sufficient condition .",
    "a ( likely ) stronger necessary condition which is also sufficient for many tasks is the existence of _ one - way functions _ : those functions which are easy to compute but hard to invert with non - negligible probability of success taken over a polynomial time samplable distribution of inputs .    in 1976 when diffie and hellman came out with their paper `` new direction in cryptography ''",
    "@xcite announcing that we are `` on the brink of a revolution in cryptoghraphy '' hopes were high that the resolution of the celebrate @xmath1 vs. @xmath2 problem was close at hand and with it techniques to lower bound the number of steps required to break cryptosystems .",
    "that did not turn out to be the case . as of today , no non - linear lower bounds are known for any @xmath2 complete problem .",
    "namely , if an np complete problem can be solved in polynomial time and thus be in p , then all problems in np are in p. ] .    instead",
    ", we follow a 2-step program when faced with a cryptographic task which can not be proved unconditionally ( 1 ) find the minimal assumptions necessary and sufficient for the task at hand .",
    "( 2 ) design a cryptographic system for the task and prove its security if and only if the minimal assumptions hold .",
    "proofs of security then are realy proofs of secure design .",
    "they take a form of a constructive reduction . for example",
    ", the existence of a one - way function has been shown a sufficient and necessary condition for `` secure '' digital signatures to exist@xcite . to prove this statement one must show how to convert any `` break '' of the digital signature scheme into an efficient algorithm to invert the underlying one - way function .",
    "defining formally `` secure '' and `` break '' is an essential preliminary step in accomplishing this program .",
    "these type of constructive reductions are a double edged sword .",
    "say that system has been proved secure if and only if integer factorization is not in polynomial time . then , either the system is breakable and then the reduction proof immediately yields a polynomial time integer factorization algorithm which will please the mathematicians to no end , or there exists no polynomial time integer factorization algorithms and we have found a superb cryptosystem with guaranteed security which will please the computer users to no end .    curiously",
    ", whereas early hopes of complexity theory producing lower bounds have not materialized , cryptographic research has yielded many dividends to complexity theory .",
    "new research themes and paradigms , as well as techniques originating in cryptography , have made their way to the main stream of complexity theory .",
    "well known techniques include random self - reducibility , hardness amplification , low degree polynomial representations of boolean functions , and proofs by hybrid and simulation arguments .",
    "well known examples of research themes include : interactive and probabilisticly checkable proofs and their application to show inapproximability of np - hard algorithmic problems , the study of average versus worst case hardness of functions , and trading off hardness of computation for randomness to be used for derandomizing probabilistic complexity classes .",
    "these examples seem , on a superficial level , quite different from each other .",
    "there are similarities however , in addition to the fact that they are investigated by a common community of researchers , who use a common collection of techniques . in all of the above ,",
    "an `` observer '' is always present , success and failure are defined `` relative to the observer '' , and if the observer can not `` distinguish '' between two probabilistic events , they are treated as identical .",
    "this is best illustrated by examples .",
    "( 1 ) a probabilistically checkable proofs is defined to achieve soundness if the process of checking it errs with exponentially small probability ( which is indistinguishable from zero ) .",
    "( 2 ) a function is considered hard to compute if all observers fail to compute it with non negligible probability taken over a efficiently samplable input distribution .",
    "it is not considered `` hard '' enough if it is only hard to compute with respect to some worst case input never to be encountered by the observer .",
    "( 3 ) a source outputting bits according to some distribution is defined as pseudorandom if no observer can distinguish it from a truly random source ( informally viewed as an on going process of flipping a fair coin ) .",
    "-5 mm    computational infeasibility , which by algorithmic standards is the enemy of progress , is actually the cryptographer s best friend .",
    "when a computationally difficult problem comes along with some additional properties to be elaborated on in this article , it allows us to design methods which while achieving their intended functionality are `` infeasible '' to break .",
    "luckily , such computationally intensive problems are abundant in mathematics .",
    "famous examples include _ integer factorization , finding short vectors in an integer lattice , and elliptic curve logarithm problem_. viewed this way , cryptography is an external customer of number theory , algebra , and geometry .",
    "however , the complexity theory view point has not left these fields untouched , and often shed new light on old problems .",
    "in particular , the history of cryptography and complexity theory is intertwined with the development of algorithmic number theory .",
    "this is most evident in the invention of faster tests for integer primality testing and integer factorization @xcite whose quality is attested by complexity analysis rather than the earlier benchmarking of their performance . a beautiful account on the symbiotic relationship between number theory and complexity theory is given by adleman @xcite who prefaces his article by saying that `` though algorithmic number theory is one of man s oldest intellectual pursuit , its current vitality is unrivaled in history .",
    "this is due in part to the injection of new ideas from computational complexity . ''",
    "-5 mm    in a companion paper to his famous paper on information theory , shannon @xcite introduced a rigorous theory of perfect secrecy based on information theory .",
    "the theory addresses adversary algorithms which have unlimited computational resources .",
    "thus , all definitions of security , which we will refer to henceforth as _ information theoretic security _ , and proofs of possibility and impossibility are with respect to such adversary .",
    "shannon proves that `` perfectly secure encryption '' can only exist if the size of secret information that legitimate parties exchange between them in person prior to remote transmission , is as large as the total entropy of secret messages they exchange remotely .",
    "maurer @xcite generalized these bounds to two - way communications .",
    "this limits the practice of encryption based on information theory a great deal .",
    "even worse , the modern cryptographic tasks of public - key encryption , digital signatures , pseudo random number generation , and most two party protocols can be proved down right impossible information theoretically . to achieve those",
    ", we turn to adversaries who are limited computationally and aim at computational security with the cost of making computational assumptions or assumptions about the physical world .",
    "having said that , some cryptographic tasks can achieve full information theoretic security .",
    "a stellar example is of multi party computation .",
    "efficient and information theoretic secure multi - party protocols are possible unconditionally tolerating less than half faults , if there are perfect private channels between each pair of honest users @xcite .",
    "zero - knowledge proofs _ are another example @xcite .",
    "perfect private channels between pairs of honest users can be implemented in several settings : ( 1 ) the _ noisy channel _ setting @xcite ( which is a generalization of the _ wire tal channel _",
    "@xcite ) where the communication between users in the protocol as well as what the adversary taps is subject to noise ) . ( 2 ) a setting where the adversary s memory ( i.e. ability to store data ) is limited @xcite . ( 3 ) the _ quantum channels _ setting where by quantum mechanics , it is impossible for the adversary to obtain full information on messages exchanged between honest users . introducing new and reasonable such settings which enable information theoretic security is an important activity .",
    "moreover , often paradigms and construction introduced within the computational security framework can be and have been lifted out to achieve information theoretic security .",
    "the development of randomness extractors from pseudo random number generators can be done in this fashion @xcite .",
    "we note that whereas the computational complexity notions of secrecy , knowledge , and pseudo - randomness are different than their information theoretic analogues , techniques of error recovery developed in information theory are extremely useful .",
    "examples include the haddamard error correcting codes which is used to exhibit hard core predicates in one - way functions @xcite , and various polynomial based error correcting codes which enable high fault tolerance in multi - party computation @xcite .    to sum up , the theory of cryptography has in the last 30 years turned into a rich field with its own rules , structure , and mathematical beauty which has helped to shape complexity theory . in the talk , i will attempt to lead you through a short summary of what i believe to have been a fascinating journey of modern cryptography .",
    "i apologize in advance for describing my own journey , at the expense of other points of view .",
    "i attach a list of references including several survey articles that contain full details and proofs @xcite .    in the rest of the article",
    ", i will briefly reflect on a few points which will make my lecture easier to follow .",
    "-5 mm    we say that an algorithm is _ polynomial time _ if for all inputs @xmath3 , the algorithm runs in time bounded by some polynomial in @xmath4 where the latter denotes the length of @xmath3 when represented as a binary string .",
    "probabilistic algorithm _ is one that can make random choices , where without loss of generality each choice is among two and is taken with probability 1/2 .",
    "we view these choices as the algorithm _",
    "coin tosses_. a probabilistic algorithm @xmath5 on input @xmath3 may have more than one possible output depending on the outcome of its coin tosses , and we will let @xmath6 denote the probability distribution over all possible outputs .",
    "we say that a probabilistic algorithm is _",
    "probabilistic polynomial time _",
    "( ppt ) if for any input @xmath3 , the expectation of the running time taken over the all possible coin tosses is bounded by some polynomial in @xmath4 , regardless of the outcome of the coin tosses .    in complexity theory",
    ", we often speak of language classes .",
    "a language is a subset of all binary strings .",
    "the class p is the set of languages such that there exists a polynomial time algorithm , which on every input @xmath3 can decide if @xmath3 is in the language or not . the class @xmath7 are those languages whose membership can be decided by a probabilistic polynomial time algorithm which for every input , is incorrect with at most negligible probability taken over the coin tosses of the algorithm",
    ". the class np is the class of languages accepted by polynomial time non - deterministic algorithm which may make non - deterministic choices at every point of computation .",
    "another characterization of np is as the class of languages that have short proofs of memberships .",
    "formally , @xmath8 there exists polynomial time computable function @xmath9 and @xmath10 0 , such that @xmath11 iff there exists @xmath12 such that @xmath13 and @xmath14 .    in this article",
    ", we consider an ` easy ' computation to be one which is carried out by a ppt algorithm .",
    "a function @xmath15 is negligible if it vanishes faster than the inverse of any polynomial .",
    "all probabilities are defined with respect to finite probability spaces .",
    "-5 mm    indistinguishability of probability distributions is a central concept in modern cryptography .",
    "it was first introduced in the context of defining security of encryption systems by goldwasser and micali @xcite .",
    "subsequently , it turned out to play a fundamental role in defining pseudo - randomness by yao @xcite , and zero - knowledge proofs by goldwasser , micali , and rackoff @xcite .",
    "let @xmath16 , @xmath17 be two ensembles of probability distributions on @xmath18 .",
    "we say that @xmath19 is * computationally indistinguishable * from @xmath20 if @xmath21 probabilistic polynomial time algorithms @xmath5 , @xmath21 @xmath22 , @xmath23 , s.t @xmath24 , @xmath25 the algorithm @xmath5 used in the above definition is called a polynomial time _ statistical test_.    namely , for sufficiently long strings , no probabilistic polynomial time algorithms can tell whether the string was sampled according to @xmath19 or according to @xmath20 .",
    "note that such a definition can not make sense for a single string , as it can be drawn from either distribution . although we chose to focus on polynomial time indistinguishability",
    ", one could instead talk of distribution which are indistinguishable with respect to any other computational resource , in which case all the algorithms @xmath5 in the definition should be bounded by the relevant computational resource .",
    "this , has been quite useful when applied to space bounded computations @xcite .    of particular interest",
    "are those probability distributions which are indistinguishable from the uniform distribution , focused on in @xcite , and are called _",
    "pseudorandom distributions_.    let @xmath26 denote the uniform probability distribution on @xmath27 .",
    "that is , for every @xmath28 , @xmath29 = \\frac{1}{2^k}$ ] .",
    "we say that @xmath30 is * pseudo random * if it is computationally indistinguishable from @xmath31 .",
    "that is , @xmath21 probabilistic polynomial time algorithms @xmath5 , @xmath21 @xmath22 @xmath23 , such that @xmath24 , @xmath32 - \\pr_{t \\in u_k}[a(t ) = 1]| < \\frac{1}{k^c}.\\ ] ] if @xmath33 and @xmath34 such that the condition in definition @xmath35 is violated , we say that @xmath36 fails the statistical test @xmath5 .",
    "a simple but not very interesting example of two probability distributions which are computationally indistinguishable are two distributions which are statistically very close .",
    "for example , @xmath37 defined exactly as the uniform distribution over @xmath27 with two exceptions , @xmath38 appears with probability @xmath39 and @xmath40 appears with probability @xmath41 .",
    "then the uniform distribution and @xmath19 can not be distinguished by any algorithm ( even one with no computational restrictions ) as long as it is only given a polynomial size sample from one of the two distributions .",
    "it is fair to ask as this point whether computationally indistinguishability is anything more than statistical closeness where the latter is formally defined as follows .",
    "two probability distributions @xmath42 are statistically close if @xmath43 , @xmath44 such that @xmath45 , @xmath46 @xmath19 and @xmath20 are _ far _ if they are not close .",
    "do there exist distributions which are statistically far apart and yet are computationally indistinguishable ?",
    "goldreich and krawczyk @xcite who pose the question note this to be the case by a counting argument .",
    "however their argument is non constructive .",
    "the works on secure encryption and pseudo random number generators @xcite imply the existence of _ efficiently constructible _ pairs of distributions that are computationally indistinguishable but statistically far , under the existence of one - way functions .",
    "the use of assumptions is no accident .",
    "@xcite the existence of one - way functions is equivalent to the existence of pairs of polynomial - time constructible distributions which are computationally indistinguishable and statistically far .",
    "-5 mm    a central building block required for many tasks in cryptography is the existence of a one - way function .",
    "let us discuss this basic primitive as well as a few others in some detail .",
    "-5 mm    informally , a one - way function is a function which is `` easy '' to compute but `` hard '' to invert . any probabilistic polynomial time ( ppt )",
    "algorithm attempting to invert the function on an element in its range , should succeed with no more than `` negligible '' probability , where the probability is taken over the elements in the domain of the function and the coin tosses of the ppt attempting the inversion .",
    "we often refer to an algorithm attempting to invert the function as an adversary algorithm .",
    "a function @xmath47 is _ one - way _ if :    1 .",
    "easy to evaluate : there exists a ppt algorithm that on input @xmath3 output @xmath48 ; 2 .   hard to invert : for all ppt algorithm @xmath5 , for all @xmath22 , there exists @xmath49 such that for all @xmath50 , + + where the probability is taken over @xmath51 and the coin tosses of @xmath5 .    * note * unless otherwise mentioned , the probabilities during this section are calculated uniformly over all coin tosses made by the algorithm in question .",
    "a few remarks are in order .",
    "( 1)the guarantee is probabilistic .",
    "the adversary has low probability of inverting the function where the probability distribution is taken over the inputs of length @xmath52 to the one - way function and the possible coin tosses of the adversary .",
    "\\(2 ) the adversary is not asked to find @xmath3 ; that would be pretty near impossible .",
    "it is asked to find some inverse of @xmath48 . naturally , if the function is 1 - 1 then the only inverse is @xmath3 .",
    "we note that it is much easier to find candidate one - way functions without imposing further restrictions on its structure , but being 1 - 1 or at least _",
    "regular _ ( that is , the number of preimage of any image is about of the range ) , it results in easier and more efficient cryptographic constructions .",
    "\\(3 ) one may consider a non - uniform version of the `` hard to invert '' requirement , requiring the function to be hard to invert by all non - uniform polynomial size family of algorithms , rather than by all probabilistic polynomial time algorithms .",
    "the former extends probabilistic polynomial time algorithms to allow for each different input size , a different polynomial size algorithm .",
    "\\(4 ) the definition is typical to definitions from computational complexity theory , which work with asymptotic complexity  what happens as the size of the problem becomes large .",
    "one - wayness is only asked to hold for large enough input lengths , as @xmath52 goes to infinity . per this definition",
    ", it may be entirely feasible to invert @xmath9 on , say , 512 bit inputs .",
    "thus such definitions are useful for studying things on a basic level , but need to be adapted to be directly relevant to practice .",
    "\\(5 ) the above definition can be considerably weakened by replacing the second requirement of the function to require it to be hard to invert on * some * non - negligible fraction of its inputs ( rather than all but non - negligible fraction of its inputs ) .",
    "this relaxation to a _",
    "weak one - way function _ is motivated by the following example .",
    "consider the function @xmath53 where @xmath54 .",
    "this function can be easily inverted on at least half of its outputs ( namely , on the even integers ) and thus is not a one - way function as defined above .",
    "still , @xmath9 resists all efficient algorithms when @xmath3 and @xmath12 are primes of roughly the same length which is the case for a non - negligible fraction ( @xmath55 ) of the @xmath52-bit composite integers . thus according to our current state of knowledge of integer factorization",
    ", @xmath9 does satisfy the weaker requirement .",
    "convertion between any weak one - way function to a one - way function have been shown using `` hardness amplification '' techniques which expand the size of the input by a polynomial factor @xcite .",
    "using expanders , constant factor expansions ( of the input size ) construction of a one - way function from a weak one - way function is possible @xcite .",
    "\\(6 ) to apply this definition to practice we must typically envisage not a single one - way function but a family of them , parameterized by a _ security parameter _",
    "that is , for each value of the security parameter @xmath52 , there is a family of functions , each defined over some finite domain and finite ranges .",
    "the existence of a single one - way function is equivalent to the existence of a collection of one - way functions .",
    "[ oneway ] a collection of one - way functions is a set @xmath56 where @xmath57 is an index set , and @xmath58 ( @xmath59 ) are finite domain(range ) for @xmath60 , satisfying the following conditions .    1 .   selection in collection : @xmath61 ppt algorithm @xmath62 that on input @xmath40 outputs an @xmath63 where @xmath64 .",
    "2 .   selection in domain : @xmath61 ppt algorithm @xmath65 that on input @xmath66 outputs @xmath67 3 .",
    "easy to evaluate : @xmath61 ppt algorithm @xmath68 such that for @xmath69 and @xmath67 , @xmath70 .",
    "4 .   hardness to invert : @xmath21 ppt adversary algorithm @xmath5 , @xmath22 , @xmath61 @xmath49 such that @xmath21 @xmath50 , @xmath71 } } } \\leqq { 1\\over{k^c}}\\ ] ] ( the probability is taken over @xmath72 and the coin tosses of @xmath5 ) .",
    "the hardness to invert condition can be made weaker by requiring only that @xmath73 , such that @xmath21 ppt algorithm @xmath5 , @xmath61 @xmath49 such that @xmath21 @xmath50 .",
    "@xmath74 , @xmath75 > { 1\\over{k^c}}$ ] ( the probability taken over @xmath72 and the coin tosses of @xmath5 ) .",
    "we call collections which satisfy such weaker conditions , collection of weak one - way functions .",
    "transformations exist via sampling algorithms between both types of collections .",
    "another useful and equivalent notion is of a _ one - way predicate _",
    ", first introduced in @xcite .",
    "this is a boolean function of great use in encryption and protocol design .",
    "a one - way predicate is equivalent to the existence of 0/1 problems , for which it is possible to uniformly select an instance for which the answer is 0 ( or respectively 1 ) , and yet for a ( pre - selected ) instance it is hard to compute with success probability greater than @xmath76 whether the answer is 0 or 1 .    a _ one - way predicate _ is a boolean function @xmath77 for which    1 .",
    "_ sampling is possible _ : @xmath61 ppt algorithm @xmath78 that on input @xmath79 and @xmath40 , outputs a random @xmath3 such that @xmath80 and @xmath81 .",
    "guessing is hard _ : @xmath43 , @xmath21 ppt algorithms @xmath5 , @xmath82 sufficiently large , @xmath83 @xmath84 \\leqq { { 1\\over 2 } + { 1\\over{k^c}}}$ ] ( probability is taken over @xmath85 , and the coin tosses of @xmath5 ) .",
    "proving the equivalence between one - way predicates and one - way functions is easy in the forward direction , by viewing the sampling algorithm @xmath78 as a function over its coin tosses . to prove the reverse implication is quite involved . toward this goal ,",
    "the notion of a hard core predicate of a one - way function was introduced in @xcite . jumping ahead ,",
    "hard core predicate of one - way functions yield immediately one - way predicates .",
    "-5 mm    the fact that @xmath9 is a one - way function obviously does not necessarily imply that @xmath48 hides everything about @xmath3 .",
    "it is easy to come up with constructions of universal one - way functions in which one of the bits of @xmath3 _ leaks _ from @xmath48 .",
    "even if each bit of @xmath3 is well hidden by @xmath48 then some function of all of the bits of @xmath3 can be easy to compute .",
    "for example , the least significant bit of @xmath3 is easy to compute from @xmath86 where @xmath87 is a prime and @xmath88 a generator for the cyclic group @xmath89 , even though we know of no polynomial time algorithms to compute @xmath3 from @xmath90 .",
    "similarily , it is easy of compute the jacobi symbol of @xmath3 mod @xmath91 from the rsa function @xmath92 where @xmath93 , even though the fastest algorithm to invert @xmath94 needs to factor integer @xmath91 first , which is not known to be a polynomial time computation .    yet",
    ", clearly there are some bits of information about @xmath3 which can not be computed from @xmath48 , given that @xmath3 in its entirety is hard to compute . the question is , which bits of @xmath3 are hard to compute , and how hard to compute are they .",
    "the answer is encouraging .",
    "for several functions @xmath9 for which no polynomial time inverting algorithm is known , we can identify particular bits of the pre - image of @xmath9 which can be proven ( via a polynomial time reduction ) to be as hard as to compute with probability significantly better than @xmath76 , as it is to invert @xmath9 itself in polynomial time .",
    "examples of these can be found in @xcite .",
    "more generally , a _",
    "hard - core predicate _ for @xmath9 , is a boolean predicate about @xmath3 which is efficiently computable given @xmath3 , but is hard to compute from @xmath48 with probability significantly better than @xmath76 .",
    "a hard - core predicate of a function @xmath95 is a boolean predicate @xmath96 , such that    1 .",
    "@xmath97 algorithm @xmath98 such that @xmath99 2 .",
    "< \\frac{1}{2}+\\frac{1}{k^c}.$ ] the probability is taken over the random coin tosses of a , and random choices of @xmath3 of length @xmath52 .",
    "yao proposed a construction of a hard - core predicate for any one - way function @xcite .",
    "a considerably simpler construction and proof general result is due to goldreich and levin @xcite .",
    "[ th - gl ] @xcite",
    "let @xmath9 be a length preserving one - way function .",
    "define @xmath102 , where @xmath103 , and @xmath104 is the concatenation function .",
    "then @xmath105 is a hard - core predicate for @xmath106 ( notice that if @xmath9 is one - way then so is @xmath106 ) .",
    "interestingly , the proof of the theorem can be regarded as the first example of a polynomial time list decoding @xcite algorithm .",
    "essentially @xmath107 may be viewed as the @xmath108th bit of a haddamrd encoding of @xmath3 .",
    "the proof of the theorem yields a polynomial time error decoding algorithm which returns a polynomial size list of candidates for @xmath3 , as long as the encoding is subject to an error rate of less than @xmath109 where @xmath110 for some constant @xmath22 , @xmath111 .",
    "the length of the list is @xmath112 .",
    "-5 mm    a _ trapdoor function _",
    "@xmath9 is a one - way function with an extra property .",
    "there also exists a secret inverse function ( the _ trapdoor _ ) that allows its possessor to efficiently invert @xmath9 at any point in the domain of his choosing",
    ". it should be easy to compute @xmath9 on any point , but infeasible to invert @xmath9 with high probability without knowledge of the inverse function .",
    "moreover , it should be easy to generate matched pairs of @xmath9 s and corresponding trapdoor .    a _ trapdoor _ function is a one - way function @xmath113 such that there exists a polynomial @xmath87 and a probabilistic polynomial time algorithm @xmath57 such that for every @xmath52 there exists a @xmath114 such that @xmath115 and for all @xmath51 , @xmath116 such that @xmath117 .",
    "trapdoor functions are much harder to locate than one - way function , as they seem to require much more hidden structure .",
    "an important problem is to establish whether one implies the other .",
    "recent results of @xcite indicate this may not the case .",
    "a _ trapdoor predicate _ is a one - way predicate with an extra trapdoor property : for every @xmath52 , there must exist trapdoor information @xmath118 whose size is bounded by a polynomial in @xmath52 and whose knowledge enables the polynomial - time computation of @xmath119 , for all @xmath81 . restating as a collection of trapdoor predicates we get .",
    "let @xmath57 be an index set and for @xmath66 , @xmath58 a finite domain .",
    "a collection of trapdoor is a set @xmath120 such that :    1 .",
    "@xmath61 ppt algorithm @xmath62 which on input @xmath40 outputs @xmath121 where @xmath122 , and @xmath123 ( @xmath124 is the trapdoor ) .",
    "2 .   @xmath61 ppt algorithm @xmath65 which on input @xmath125 outputs @xmath67 such that @xmath126 .",
    "@xmath61 ppt algorithm @xmath127 which on input @xmath128 outputs @xmath129 .",
    "@xmath21 ppt adversary algorithms @xmath5 , @xmath22 , @xmath130 , @xmath131 \\leq { { 1\\over2 } + { 1\\over{k^c}}}$ ] ( the probability taken over @xmath132 , and the coins of a ) .",
    "[ one - way - predicates ]    the existence of a trapdoor predicate is equivalent to the existence of secure public - key encryption as we shall see in the next section .",
    "trapdoor functions imply trapdoor predicates , but it is an open problem to show that they are equivalent",
    ".    if trapdoor functions exist then collection of trapdoor predicates exist .",
    "-5 mm    it has been shown by a fairly straightforward diagonalization argument @xcite how to construct a _ universal _",
    "one - way function ( i.e. a function which is one - way if any one - way function exists ) .",
    "still this is very inefficient , and concrete proposals for one - way function are needed for any practical usage of cryptographic constructions which utilized one - way functions .",
    "moreover , looking into the algebraic , combinatorial , and geometric structure of concrete proposals has lead to many insights about what could be true about general one - way functions .",
    "the revelation process seems almost always to start from proving properties about concrete examples to generalizing to proving properties on general one - way functions .",
    "interesting proposals for one - way functions , trapdoor functions , and trapdoor predicates have been based on hard computational problems from number theory , coding theory , algebraic geometry , and geometry of numbers .",
    "what makes a computational problem a `` suitable '' candidate ?",
    "first , it should be put under extensive scrutiny by the relevant mathematical community .",
    "second , the problem should be hard on the _ average _ and not only in the _ worst _ case .",
    "a big project in cryptography is the construction of cryptographic functions which are provably hard to break _ on the average _ under some _ worst - case _ computational complexity assumption .",
    "a central technique is to show that a problem is as hard for an _ average _ instance as it is for a _ worst case _ instance by _ random self reducibility _ @xcite .",
    "a problem @xmath1 is random self reducible if there exists a probabilistic polynomial time algorithm that maps any instance @xmath57 of @xmath1 to a collection of random instances of @xmath1 such that given solutions to the random instances , one can efficiently obtain a solution to the original instance .",
    "variations would allow mapping any instance of @xmath1 to random instances of @xmath133 .",
    "perhaps the most interesting problem in cryptography today is to show ( or rule out ) that the existence of a one - way function is equivalent to the @xmath134 .    for lack of space ,",
    "we discuss in brief a few proposals .",
    "-5 mm    let @xmath87 be a prime integer and @xmath88 a generator for the multiplicative cyclic group @xmath135 .",
    "the _ discrete log problem _ ( dlp ) is given @xmath87,@xmath88 , and @xmath136 , compute the unique @xmath3 such that @xmath137 and @xmath138 .",
    "the discrete log problem has been first suggested to be useful for key exchange over the public channel by diffie and hellman @xcite .",
    "the function @xmath139 , and the corresponding collection of functions @xmath140 where @xmath141 have served as proposals for a one - way function and a collection of one - way functions ( respectively ) . on one hand , there exist efficient algorithms to select pairs of @xmath142 of a given length with uniform probability @xcite , and to perform modulo exponentiation . on the other hand , the fastest algorithms to solve",
    "the discrete log problem is the generalized number field sieve version of the index - calculus method which runs in expected time @xmath143 ( see survey @xcite ) .",
    "moreover , for a fixed prime @xmath87 , @xmath144 can be shown as hard to invert on the average over the @xmath145 and @xmath88 generators , as it is for every @xmath88 and @xmath3 .",
    "an important open problem is to prove that , _ without fixing first the prime @xmath87 _ , solving the discrete log problem for an average instance @xmath146 is hard on the average as in the worst case .    in the mid - eighties an extension of the discrete logarithm problem over prime integers , to _ computing discrete logarithms over elliptic curves",
    "_ was suggested by koblitz and v. miller ( see survey @xcite ) .",
    "the attraction is that the fastest algorithms known for computing logarithms over elliptic curves are of complexity @xmath147 for finite field @xmath148 .",
    "the main concern is that they have not been around long enough to go under extensive scrutiny , and that the intersection between the mathematical community who can offer such scrutiny and the cryptographic community is not large .",
    "-5 mm    in a celebrated paper @xcite ajtai described a problem that is hard _ on the average _ if some well - known integer lattice problems are _ hard to approximate in the worst case _ , and demonstrated how this problem can be used to construct one - way functions .",
    "previous worst case to average case reductions were applied to two parameter problems and the reduction was shown upon fixing one parameter ( e.g. in the discrete logarithm problem random self reducibility was shown fixing the prime parameter ) , whereas the @xcite reduction is the first which averages over all parameters .",
    "let @xmath149 be a set of @xmath91 linearly independent vectors @xmath150 .",
    "the integer lattice spanned by @xmath149 is the set of all possible linear combinations of the @xmath151 s with integer coefficients , namely @xmath152 .",
    "we call @xmath149 the basis of the lattice @xmath153 .",
    "we say that a set of vectors @xmath154 is a lattice if there is a basis @xmath149 such that @xmath155 .",
    "finding `` short vectors '' ( i.e. , vectors with small euclidean norm ) in lattices is a hard computational problem .",
    "there are no known efficient algorithms to find or even approximate - given an arbitrary basis of a lattice - either the shortest non - zero vector in the lattice , or another basis for the same lattice whose longest vector is as short as possible .",
    "given an arbitrary basis @xmath156 of a lattice @xmath157 in @xmath158 , the best algorithm to approximate ( up to a polynomial factor in @xmath91 ) the length of the shortest vector in @xmath157 is the @xmath159 algorithm @xcite which approximates these problems to within a ratio of @xmath160 in the worst case , and its improvement @xcite to ratio @xmath161 for any fixed @xmath162 .",
    "ajtai reduced the worst - case complexity of problem ( w ) which is closely related the length of the shortest vector and basis in a lattice , to the average - case complexity of problem ( a ) ( version presented here is due to goldreich , goldwasser , and halevi @xcite ) .    * : given an arbitrary basis @xmath156 of a lattice @xmath157 , find a set of @xmath91 linearly independent lattice vectors , whose length is at most polynomially ( in @xmath91 ) larger than the length of the smallest set of @xmath91 linearly independent lattice vectors .",
    "( the length of a set of vectors is the length of its longest vector . ) * : let parameters @xmath163 be such that @xmath164 and @xmath165 for some constant @xmath166 . given a matrix @xmath167 ,",
    "find a vector @xmath168 so that @xmath169 .",
    "@xcite suppose that it is possible to solve a uniformly selected instance of problem  ( a ) in expected @xmath170-time , where the expectation is taken over the choice of the instance as well as the coin - tosses of the solving algorithm .",
    "then it is possible to solve problem  ( w ) in expected @xmath171 time _ on every _",
    "@xmath91-dimensional instance @xmath57 , where the expectation is taken over the coin - tosses of the solving algorithm .",
    "the construction of a candidate one - way function follows in a straight forward fashion .",
    "let @xmath172 be a random @xmath173 matrix @xmath172 with entries from @xmath174 , where @xmath175 and @xmath176 are chosen so that @xmath177 and @xmath178 for some constant @xmath166 ( @xmath52 here is the security parameter ) .",
    "the one - way function candidate is then @xmath179 where @xmath180 and @xmath181 is the @xmath182th column of @xmath172 .",
    "we note that this function is regular .",
    "-5 mm    consider the function @xmath183 where @xmath184 for @xmath185 prime numbers and @xmath186 , and the corresponding collection of functions @xmath187 .",
    "this function is easy to compute without knowing the factorization of @xmath91 , and is easy to invert given the factorization of @xmath91 ( the trapdoor ) using fast square root extraction algorithms modulo prime moduli @xcite and the chinese remainder theorem .",
    "moreover , as the primes are abundant by the prime number theorem ( @xmath188 for @xmath52-bit primes ) and there exist probabilistic expected polynomial time algorithms for primality testing @xcite , it is easy to uniformly select @xmath189 of the right form .    in terms of hardness to invert , rabin @xcite has shown it as hard to invert as it is to factor @xmath91 as follows .",
    "suppose there exists a factoring algorithm @xmath5 .",
    "choose @xmath190 at random .",
    "let @xmath191 .",
    "if @xmath192 or @xmath193 , then let @xmath194 , else choose another @xmath108 and repeat . within expected 2 trials you should obtain @xmath87 .",
    "the asymptotically proven fastest integer factorization algorithm to date is the number field sieve which runs in expected time @xmath195 @xcite .",
    "the hardest input to any factoring algorithms are integers @xmath184 which are product of two primes of similar length .",
    "finally , for a fixed @xmath91 , @xmath196 can be shown as hard to invert on the average over @xmath186 as it is for any @xmath3 .",
    "we remark , that integer factorization has been first proposed as a basis for a trapdoor function in the celebrated work of rivest , shamir and adelman @xcite .    by choosing @xmath87 and @xmath176 to be both congruent to @xmath197 and restricting the domain of @xmath198 to the quadratic residues",
    "mod @xmath91 , this collection of functions becomes a collection of permutations proposed by williams @xcite , which are especially easy to work with in many cryptographic applications .",
    "an open problem is to prove that the difficulty of factoring integers is as hard on the average as in the worst case . in our terminology",
    "an affirmative answer would mean that @xmath199 is as hard to invert on the _ average _ over @xmath91 and @xmath3 , as it is for _ any _ @xmath91 and @xmath3 .",
    "-5 mm    let @xmath200 .",
    "then we call @xmath201 is a _ quadratic residue mod _ @xmath91 iff @xmath202 such that @xmath203 .",
    "let us restrict our attention to @xmath184 where @xmath204 .",
    "selecting a random quadratic residue mod @xmath91 is easy by choosing @xmath205 and computing @xmath206 .",
    "similarily , for such @xmath91 , selecting a random quadratic non - residue is easy by choosing @xmath205 and computing @xmath207 ( this is a quadratic non - residue by the property of the @xmath91 s chosen ) .    on the other hand , deciding whether @xmath3 is a quadratic residue modulo @xmath91 for @xmath91 composite ( which is the case if and only if it is a quadratic residue modulo each of its prime factors ) , seems a hard computational problem .",
    "no algorithm is known other than first factoring @xmath91 and then deciding whether @xmath3 is a quadratic residue modulo all its prime factors .",
    "this is easy for a prime modulos by computing the legendre symbol @xmath208 ( @xmath209 iff @xmath3 is a quadratic residue mod @xmath87 ) .",
    "the legendre symbol is generalizable to the jacobi symbol for composite moduli @xmath210 where @xmath211 .",
    "the jacobi symbol only provides partial answer to whether @xmath212 is a quadratic residue or not . for @xmath213",
    ", it gives no information .    a proposal by goldwasser and micali @xcite for a collection of trapdoor predicates follows .",
    "@xmath214 where @xmath215 , @xmath216    it can be proved that for every @xmath91 distinguishing between random quadratic residues and random quadratic non residues with jacobi symbol + 1 , is as hard as solving the problem entirely in the worst case .",
    "@xcite let @xmath217 .",
    "if there exists a ppt algorithm which for every @xmath218 , can distinguish between quadratic residues and quadratic non - residues with non - negligible probability over @xmath76 ( probability taken over the @xmath186 and the coin tosses of the distinguishing algorithm ) , then there exist a ppt algorithm which for every @xmath219 and every @xmath186 decides whether @xmath3 is a quadratic residue mod @xmath91 with probability close to 1 .",
    "-5 mm    as discussed in the introduction we would like to propose cryptographic schemes for which we can prove theorems guaranteeing the security of our proposals .",
    "this task includes a definition phase , construction phase and a reduction proof which is best illustrated with an example .",
    "we choose the example of encryption .",
    "we will address here the simplest setting of a passive adversary who can tap the public communication channels between communicating parties .",
    "we will measure the running time of the encryption , decryption , and adversary algorithms as a function of a _ security parameter _",
    "@xmath52 which is a parameter fixed at the time the cryptosystem is setup .",
    "we model the adversary as any probabilistic algorithm which runs in time bounded by some polynomial in @xmath52 .",
    "similarily , the encryption and decryption algorithms designed are probabilistic and run in polynomial time in @xmath52 .",
    "-5 mm    [ encrypt-public.def ] a _ public - key encryption scheme _ is a triple , @xmath220 , of probabilistic polynomial - time algorithms satisfying the following conditions    1 .",
    "key generation algorithm : on input @xmath40 ( the security parameter ) algorithm @xmath221 , produces a pair @xmath222 where @xmath223 is called the public key , and @xmath224 the corresponding private key .",
    "( notation : @xmath225 . )",
    "we will also refer to the pair @xmath222 a pair of _",
    "encryption_/_decryption _ keys . 2 .",
    "an encryption algorithm : algorithm @xmath226 takes as inputs encryption key @xmath223 from the range of @xmath227 and string @xmath228 called the _ message _ , and produces as output string @xmath229 called the _ ciphertext_. ( we use the notation @xmath230 or the shorthand @xmath231 . ) note that as @xmath226 is probabilistic , it may produce many ciphertexts per message .",
    "3 .   a decryption algorithm : algorithm @xmath232 takes as input decryption key @xmath224 from the range of @xmath233 , and a ciphertext @xmath34 from the range of @xmath234 , and produces as output a string @xmath235 , such that for every pair @xmath222 in the range of @xmath233 , for every @xmath175 , for every @xmath230 , the @xmath236 is negligible .",
    "4 .   furthermore ,",
    "this system is `` secure '' ( see discussion below ) .",
    "a _ private - key encryption scheme _ is identically defined except that @xmath237 .",
    "the security definition for private - key encryption and public - key encryption are different in one aspect only , in the latter @xmath223 is a public input available to the whereas in the former @xmath223 is a secret not available to the adversary .",
    "-5 mm    brain storming about what it means to be secure brings immediately to mind several desirable properties .",
    "let us start with the the minimal requirement and build up .",
    "first and foremost the private key should not be recoverable from seeing the public key .",
    "secondly , with high probability for any message space , messages should not be entirely recovered from seeing their encrypted form and the public file .",
    "thirdly , we may want that in fact no useful information can be computed about messages from their encrypted form .",
    "fourthly , we do not want the adversary to be able to compute any useful facts about traffic of messages , such as recognize that two messages of identical content were sent , nor would we want her probability of successfully deciphering a message to increase if the time of delivery or relationship to previous encrypted messages were made known to her .    in short",
    ", it would be desirable for the encryption scheme to be the mathematical analogy of opaque envelopes containing a piece of paper on which the message is written .",
    "the envelopes should be such that all legal senders can fill it , but only the legal recipient can open it .",
    "two definitions of security attempting to capture the `` opaque envelope '' analogy have been proposed in the work of @xcite and are in use today : computational indistinguishability and semantic security .",
    "the first definition is easy to work with whereas the second seems to be the natural extension of shannon s perfect secrecy definition to the computational world .",
    "they are equivalent to each other as shown by @xcite .",
    "the first definition essentially requires that the the adversary can not find a pair of messages @xmath238 for which the probability distributions over the corresponding ciphertexts is computationally distinguishable .",
    "we say that a _ public key cryptosystem @xmath220 is computationally indistinguishable _ if @xmath21 ppt algorithms @xmath239 , and for @xmath21 constant @xmath22 , @xmath44 , @xmath21 @xmath50 , @xmath240 , @xmath241 , @xmath242 \\\\    & & - \\pr[a(e , c ) = 1   ( e , d)\\in g(1^k);\\ , c\\in e(e , m_1)]| <    \\frac{1}{k^c}.\\end{aligned}\\ ] ]    * remarks about the definition *    1 .   in the case of private - key cryptosystem , the definition changes slightly .",
    "the encryption key @xmath223 is not given to algorithm @xmath5 .",
    "2 .   note that even if the adversary know that the messages being encrypted is one of two , he still can not tell the distributions of ciphertext of one message apart from the other .",
    "any cryptosystem in which the encryption algorithm @xmath226 is deterministic immediately fails to pass this security requirement .",
    "( e.g given @xmath243 and @xmath34 it would be trivial to decide whether @xmath244 or @xmath245 as for each message the ciphertext is unique . )    the next definition is called _",
    "semantic security_. it may be viewed as a computational version of shannon s perfect secrecy definition .",
    "it requires that the adversary should not gain any computational advantage or partial information from having seen the ciphertext .",
    "we say that an _ public key",
    "cryptosystem @xmath220 is semantically secure _ if @xmath21 ppt algorithm @xmath5 @xmath61 ppt algorithm @xmath156 , s.t .",
    "@xmath21 ppt algorithm @xmath172 , @xmath21 function @xmath246 , @xmath43 , @xmath247 , @xmath45 , @xmath248 \\leq \\pr[b(e,|m|)=h(m ) \\mid m\\in m(1^k ) ] + { 1\\over{k^c}}.$ ]    the algorithm @xmath172 corresponds to the message space from which messages are drawn , and the function @xmath249 corresponds to information about message @xmath175 ( for example , @xmath250 if @xmath175 has the letter ` e ' in it ) .",
    "@xcite a public key cryptosystem is computationally indistinguishable if and only if it is semantically secure .      -5 mm    we turn now to showing how to actually build a public key encryption scheme which is polynomial time indistinguishable .",
    "the construction shown here is by goldwasser and micali @xcite .",
    "the key to the construction is to answer a simpler problem : how to securely encrypt single bits .",
    "encrypting general messages would follow by viewing each message as a string of bits each encrypted independently .",
    "given a collection of trapdoor predicates b , we define a public key cryptosystem @xmath251 as follows :    [ encrypt.def ] a probabilistic encryption @xmath252 based on trapdoor predicates @xmath156 is defined as :    1 .",
    "key generation algorithm g : on input @xmath40 , g outputs @xmath121 where @xmath253 , @xmath254 and @xmath124 is the trapdoor information .",
    "the public encryption key is @xmath182 and the private decryption key is @xmath124 .",
    "( this is achieved by running the sampling algorithm @xmath62 from the def of b. ) 2 .",
    "let @xmath255 where @xmath256 be the message .",
    "+ @xmath257 encrypts @xmath175 as follows : + = choose @xmath258 such that @xmath259 for @xmath260 .",
    "+ output @xmath261 .",
    "+ + -5 mm 3 .",
    "let @xmath262 where @xmath263 be the cyph ertext .",
    "+ @xmath264 decrypts @xmath34 as follows : + = compute @xmath265 for @xmath260 .",
    "+ output @xmath255 .",
    "+    it is clear that all of the above operations can be done in expected polynomial time from the definition of trapdoor predicates and that messages can indeed be sent this way .",
    "let us ignore for a minute the apparent inefficiency of this proposal in bandwidth expansion and computation ( which has been addressed by blum and goldwasser in @xcite ) and talk about security .",
    "it follows essentially verbatim from the definition of trapdoor predicates that this system is polynomially time indistinguishable in the case the message is a single bit ( i.e. @xmath266 ) .",
    "even though every bit individually is secure , it is possible in principle that some predicate computed on all the bits ( e.g. their parity ) is easily computable .",
    "luckily , it is not the case .",
    "we prove polynomial time indistinguishability using the _ hybrid argument_. this method is a key proof technique in the theory of pseudo randomness and secure protocol design , in enabling to show how to convert a slight `` edge '' in solving a problem into a complete surrender of the problem .    as this is one of the most straight forward simplest examples of this technique we shall give it in full .",
    "@xcite probabilistic encryption @xmath267 is semantically secure if and only if @xmath156 is a collection of trapdoor predicates .",
    "suppose that @xmath220 is not indistinguishably secure ( i.e. not semantically secure ) .",
    "then there is a @xmath22 , a ppt @xmath5 and @xmath172 such that for infinitely many @xmath52 , @xmath268 with @xmath269 , @xmath270\\\\    & & -\\pr[a(i , c ) = 1   ( i , t_i)\\in g(1^k ) ; \\ , c\\in e(i , m_1 ) ] \\geq    \\frac{1}{k^c},\\end{aligned}\\ ] ] where the probability is taken the choice of @xmath121 , the coin tosses of @xmath5 and @xmath226 .    consider @xmath52 where ( * ) holds .",
    "wlog , assume that @xmath271 and that @xmath5 says @xmath272 more often when @xmath34 is an encryption of @xmath273 and @xmath274 more often when @xmath34 is an encryption of @xmath275 .    define distributions @xmath276 for @xmath277 where @xmath278 and @xmath279 differs from @xmath280 in precisely @xmath274 bit .",
    "let @xmath281 $ ] .",
    "then @xmath282 and since @xmath283 , @xmath284 such that @xmath285 .",
    "assume that @xmath279 and @xmath280 differ in the @xmath286 bit ; that is , @xmath287 or , equivalently , @xmath288 where @xmath289 is the @xmath290-th bit of @xmath279 .",
    "now , consider the following algorithm @xmath156 which takes input @xmath291 and outputs @xmath272 or @xmath274 as its guess to the value of the hard core predicate @xmath292 .",
    "@xmath156 on input @xmath291 :    1 .",
    "choose @xmath293 such that @xmath294 for @xmath295 using @xmath62 from the definition of @xmath156 .",
    "2 .   let @xmath296 where @xmath12 has replaced @xmath297 in the @xmath298 block .",
    "3 .   if @xmath299 then output @xmath300 .",
    "+ if @xmath299 then output @xmath301 .",
    "note that @xmath302 if @xmath303 and @xmath304 if @xmath305 .",
    "thus , in step @xmath306 of algorithm @xmath156 , outputting @xmath300 corresponds to @xmath5 predicting that @xmath34 is an encryption of @xmath279 .",
    "* claim *  @xmath307 > \\frac{1}{2 } + \\frac{1}{k^{c+1}}$ ] .",
    "@xmath308 & = & \\pr[a(i , c ) = 0 | c \\in e(i , s_j)]\\pr[c \\in e(i , s_j ) ] \\\\    & & + \\pr[a(i , c ) = 1 | c \\in e(i , s_{j+1 } ) ] \\pr[c \\in",
    "e(i , s_{j+1 } ) ] \\\\    & \\geq & ( 1-p_j)(\\frac{1}{2 } ) + ( p_{j+1})(\\frac{1}{2 } ) \\\\    & = & \\frac{1}{2 } + \\frac{1}{2}(p_{j+1 } - p_j ) \\\\",
    "& > & \\frac{1}{2 } + \\frac{1}{k^{c+1}}.\\end{aligned}\\ ] ]    thus , @xmath156 will predict @xmath292 given @xmath182 , @xmath12 with probability better than @xmath309 .",
    "this contradicts the assumption that @xmath310 is a trapdoor predicate .",
    "hence , the probabilistic encryption @xmath311 is indistinguishably secure .",
    "-5 mm    the entire discussion so far has assumed that the adversary can listen to the cipher texts being exchanged over the insecure channel , read the public - file ( in the case of public - key cryptography ) , generate encryptions of any message on his own ( for the case of public - key encryption ) , and perform probabilistic polynomial time computation .",
    "one may imagine a more powerful adversary who can intercept messages being transmitted from sender to receiver and either stop their delivery all together or alter them in some way .",
    "even worse , suppose the adversary can after seeing a ciphertext , request a polynomial number of related ciphertexts to be decrypted for him .",
    "for definitions and constructions of encryption schemes secure against such adverdary see @xcite .",
    "-5 mm    a theory of randomness based on computability theory was developed by kolmogorov , solomonov and chaitin @xcite .",
    "this theory applies to individual strings and defines the complexity of strings as the shortest program ( running on a universal machine ) that generates that string .",
    "a perfectly random string is the extreme case for which no shorter program than the length of the string itself can generate it .",
    "inherintly , it is impossible to generate perfect random strings from shorter ones .",
    "one of the surprising contributions of cryptographically motivated research in the early eighties , has been a theory of randomness computational complexity theory pioneered by shamir @xcite blum and micali @xcite , which makes it possible in principle to deterministically generate random strings from shorter ones .",
    "not to mix notions , we will henceforth refer to this latter development as a theory of pseudo randomness , and the strings generated as pseudo random .",
    "in contrast , when we speak of choosing a truly random string of a fixed length over some alphabet , we refer to selecting it with uniform probability over all strings of the same length . in this section",
    "we shall only speak of binary alphabet .",
    "the notation @xmath312 will thus be taken to mean that for every @xmath313 , the probability of @xmath314 is @xmath315 .",
    "defining pseudo - random distributions is a special case of the definition of computational indistinguishability , which we encountered earlier in the context of secure encryption .",
    "a distribution over binary strings is called _ pseudo - random _ if it is computationally indistinguishable from the uniform distribution over all binary strings of the same length .",
    "the idea is that as long as we can not tell apart samples from the uniform distribution from samples of a distribution @xmath19 in polynomial time , there is no difference between using either distributions that can be observed in polynomial time .",
    "in particular , any probabilistic algorithm , in which the internal coin flips of the algorithm are replaced by strings sampled from @xmath19 , must not behave any different than it would using truly random coin flips .",
    "a counter example will yield a statistical test to distinguish between @xmath19 and the uniform distribution .    a deterministic polynomial time program which stretchs a short input string selected with uniform distribution ( henceforth called the ` seed ' ) , to a polynomial long output string",
    "is called a pseudo random sequence generator .",
    "when such a construction is accompanied with a proof that the output string distribution is pseudo random we call the generator a strong pseudo random sequence generator ( sprsg ) .",
    "where @xmath91 is the seed length and is computationally indistinguishable with respect to algorithms which run in time @xmath316 for time functions @xmath317 . ]    in a culmination of a sequence of results by @xcite , hastand , impagliazzo , levin and luby showed that a necessary and sufficient condition for the existence of strong pseudo random sequence generators is the existence of one - way functions .",
    "the link between one - way functions and pseudo randomness starts from the following observation .",
    "first , rephrase the fact that inverting one - way functions is difficult , by saying that the inverse of a one - way function is unpredictable .",
    "in particular , the hard - core of a one - way function is impossible to predict with any non - negligible probability greater than @xmath76 .",
    "second , show that impossibility to predict is the ultimate test for pseudo randomness .",
    "namely , if a pseudo - random sequence generator has the property that it is difficult to predict the next bit from previous ones with probability significantly better than @xmath318 in time polynomial in the size of the seed , then it is impossible to distinguish in polynomial time between strings produced by the pseudo random sequence generators and truly random strings .",
    "this is proved by turning any statistical test that distinguishes in polynomial time pseudo random strings from random strings into polynomial time next bit predictor .",
    "this link is not conditional on the existence of one - way functions .",
    "in fact , in work by nisan and wigderson @xcite they removed the requirement that the pseudo random sequence generator has to work in time which is as fast as the algorithm trying to distinguish the output sequences from truly random .",
    "generators of this type are generally useless for cryptographic applications ( as they can not be generated in feasible time ) but are very useful for proving complexity theoretic results .",
    "strong pseudo random generators are useful for understanding the relation between deterministic algorithms and probablistic algorithms .",
    "the idea which was put forth by yao @xcite was to replace a single execution of a probablistic polynomial time algorithm @xmath5 with the majority output of all the executions of the same algorithm , where each execution uses instead of random coins the output of a strong pseudo random number generator on a different input seed .",
    "the cost of the latter deterministic procedure will be a factor of @xmath319 longer where @xmath320 is the seed length used to generate the pseudo random sequences necessary .",
    "the algorithm @xmath5 must behave `` the same '' when it uses truly random coins as when it uses coins which are pseudo - random , as otherwise it becomes a distinguisher between the uniform and pseudo - random distributions , an impossible task for a probabilistic polynomial time algorithm . putting this together ,",
    "we get : if one - way functions exist , then @xmath321 .",
    "this tradeoff between the _ hardness _ of inverting the one - way function , and _ randomness _ replacement , has been followed up with many papers in complexity theory each either relaxing the hardness assumption or tightening the relation between deterministic and probabilistic complexity classes .",
    "strong pseudo random generators are particularly useful for cryptography .",
    "suppose you need a large supply of random strings for your cryptographic applications ( e.g. the choice of secret keys , internal coin tosses of an encryption algorithm , etc . ) .",
    "if you use instead of truly random bits , pseudo random sequence generators which are weak ( e.g. predictable ) , it may completely destroy the underlying cryptographic applications @xcite .",
    "in contrast , we can replace any use of truly random coins with strong pseudo random ones ( assuming we have access to truly random coins for the seeds  which is an interesting discussion all by itself ) , without fear of compromising the security of the underlying application .",
    "indeed , if as a result of such replacement the cryptographic application becomes insecure , then a way is found to distinguish outputs of sprg from the uniform distribution .",
    "many classical pseudo random number generators which are quite useful and effective for monte carlo simulations , have been shown not only weak but predictable in a strong sense which makes them typically unsuitable for cryptographic applications .",
    "for example , _ linear _ feedback shift registers @xcite are well - known to be cryptographically insecure ; one can solve for the feedback pattern given a small number of output bits , and similarily outputs of linear congruential generators @xcite . in @xcite kannan , lenstra , and lovasz",
    "use the @xmath159 algorithm to show that the binary expansion of any algebraic number @xmath12 ( such as @xmath322 ) is insecure , since an adversary can identify @xmath12 exactly from a sufficient number of bits , and then extrapolate @xmath12 s expansion .",
    "-5 mm    similarily to defining pseudo random sequences one may ask what other random objects can be replaced with pseudo - random counter parts .",
    "goldreich , goldwasser and micali @xcite considered in this light random functions , which from a gold mind for applications .",
    "pseudo random functions are defined to be for every size @xmath52 a subset of all functions from ( and to ) the binary strings of length @xmath52 , which are polynomial time indistinguishable from truly random functions by any algorithm whose only access to the function is to query it on inputs of its choice . however",
    ", in contrast with a truly random function , a pseudo random function has a short description which if known enables efficient evaluation .",
    "let @xmath323 then @xmath324 . let @xmath325 .",
    "a _ polynomial time statistical test for functions _ is a polynomial time algorithm @xmath326 with access to a black box @xmath9 from which @xmath327 can request values of @xmath48 for x of @xmath327 s choice . a collection of functions @xmath328 where @xmath329 _ passes the statistical test @xmath327 _",
    "if @xmath330 , \\exists k_0 , \\forall k > k_{0 } \\ : |t(f_k ) - t(h_k)| < \\frac{1}{q(k)}$ ] where @xmath331 $ ] and @xmath332 $ ] .",
    "a collection of functions @xmath328 is a _ pseudo - random collection of functions _ if    1 .",
    "( indexing ) for each k , there is a unique index @xmath333 associated with each @xmath334 .",
    "the function @xmath334 associated with index @xmath182 will be written @xmath335 .",
    "efficiency ) there is a polynomial time function @xmath5 so that @xmath336 .",
    "( pseudo - randomness ) @xmath337 passes all polynomial time statistical tests for functions .",
    "@xcite if there exist one - way functions , then there exist pseudo - random collections of functions .",
    "an immediate application of pseudo random functions is the construction of semantically secure private key cryptosystem as follows .",
    "let @xmath338 an index of a pseudo random function @xmath339 be the joint secret key of the sender alice and the receiver bob .",
    "then to encrypt message @xmath175 , alice selects at random @xmath340 , and sets the cipher text @xmath341 where @xmath342 is the bit - wise exclusive - or of two strings .",
    "to decrypt @xmath343 , bob computes @xmath344 .",
    "pseudo random functions have been used to derive negative results in computational learning theory by valiant and kearns @xcite .",
    "they show that any concept class ( i.e. a set of boolean functions ) which contains a family of pseudo random functions can not be efficiently learnable under the uniform distribution and with the help of membership queries .",
    "a learning algorithm is given oracle access to any function in the class and is required to output a description of a function which is close to the target function ( being queried ) .",
    "the work on _ natural proofs _ originated by rudich and razborov @xcite use pseudo random functions to derive negative results on the possibility of proving good complexity lower bounds using a restricted class of circuit lower bound proofs referred to as _",
    "natural_. it is proved that natural ( lower bound ) proofs can not be established for complexity classes containing a family of pseudo random functions .",
    "an interesting question is to characterize which classes of random objects can be replaced by pseudo random objects .",
    "luby and rackoff @xcite treated the case of pseudo random permutations and naor and reingold the case of permutations with cyclic structure @xcite .",
    "as any object can be abstracted as a restricted class of functions , the real question is what form of access to the function does the statistical test have . in the standard definition , the statistical test for functions can query the functions at values of its choice",
    ". this may not be necessarily the natural choice in every case .",
    "for example , if the function corresponds to the description of a random graph ( e.g. @xmath345 if and only if an edge is present between vertices @xmath290 and @xmath346 ) .    define the `` ultimate '' extension of a statistical test for functions on @xmath52 bit strings , to be given access to the _ entire truth table _ of the function ( i.e. an exponential size input ) .",
    "the following observation is then straightforward .",
    "let @xmath113 be polynomial time computable function , for which the fastest inverting algorithm runs in time @xmath347 for some @xmath348 .",
    "then , there exist collections of pseudo random functions which pass all ultimate statistical tests for functions .",
    "-5 mm    secure one - way communication is a special case of general interactive protocols .",
    "the most exciting developments in cryptography beyond public - key cryptography has been the development of interactive protocols , interactive proofs , and zero knowledge interactive proofs @xcite .",
    "unfortunately , we have no space to cover these developments in this article .",
    "these topics have been surveyed extensively , and the interested reader may turn to @xcite .    a few final words .",
    "generally speaking , an _ interactive protocol _ consists of two or more parties who cooperate and coordinate without a trusted `` third '' party to accomplish a common goal , referred to as the _ functionality _ of the protocol , while maintaining the _ secrecy _ of their private data .",
    "a functionality may be computing a simple deterministic function such as majority of the inputs of the communicating parties , or a more complicated probabilistic computation such as playing a non - cooperative game without a trusted referee .    in the case of more than two parties ,",
    "the case of adversarial coalitions of participants who attempt to damage the functionality and break secrecy has been considered .",
    "very powerful and surprising theorems about the ability of playing non - cooperative games without a trusted `` third party '' have been shown .",
    "a sample theorem of benor , goldwasser , and wigderson shows that in the presence of an adversarial coalition containing less than a third of the parties , any probabilistic computation can be performed maintaining functionality and perfect information theoretic secrecy of the inputs , as long as each pair of parties can communicate in perfect secrecy @xcite .",
    "these results make extensive use of error correcting codes based on polynomials .",
    "the connection between these theorems and research in game theory and threory of auctions is well worth examining .",
    "christian cachin and ueli maurer unconditional security against memory - bounded adversaries advances in cryptology  crypto 97 , lecture notes in computer science , springer - verlag , vol .",
    "1294 , 292306 , 1997 .",
    "o.  goldreich , s.  micali , and a.  wigderson .",
    "proofs that yield nothing but their validity and a methodology of cryptographic protocol design . in _ proc .",
    "@xmath353th ieee symp .  on foundations of comp .",
    "science _ , 174187 , toronto , 1986 .",
    "ieee .",
    "r.  kannan , a.  lenstra , and l.  lovsz .",
    "polynomial factorization and non - randomness of bits of algebraic and some transcendental numbers . in _ proc .",
    "@xmath354th acm symp .  on theory of computing _ ,",
    "191200 , washington , d.c . , 1984 .",
    "acm .",
    "a.  k. lenstra and h.  w. lenstra , jr .",
    "algorithms in number theory . in jan van leeuwen , editor , _ handbook of theoretical computer science ( volume a : algorithms and complexity )",
    "_ , chapter  12 , 673715 .",
    "elsevier and mit press , 1990 .",
    "john rompel .",
    "one - way functions are necessary and sufficient for secure signatures .",
    "proceedings of the twenty second annual acm symposium on theory of computing , 387394 , baltimore , maryland , 1416 may 1990 ."
  ],
  "abstract_text": [
    "<S> theoretical computer science has found fertile ground in many areas of mathematics . </S>",
    "<S> the approach has been to consider classical problems through the prism of computational complexity , where the number of basic computational steps taken to solve a problem is the crucial qualitative parameter . </S>",
    "<S> this new approach has led to a sequence of advances , in setting and solving new mathematical challenges as well as in harnessing discrete mathematics to the task of solving real - world problems .    in this talk </S>",
    "<S> , i will survey the development of modern cryptography  the mathematics behind secret communications and protocols  in this light . </S>",
    "<S> i will describe the complexity theoretic foundations underlying the cryptographic tasks of encryption , pseudo - randomness number generators and functions , zero knowledge interactive proofs , and multi - party secure protocols . </S>",
    "<S> i will attempt to highlight the paradigms and proof techniques which unify these foundations , and which have made their way into the mainstream of complexity theory .    </S>",
    "<S> 4.5 mm    * 2000 mathematics subject classification : * 68qxx , 11xx .    * keywords and phrases : * crytography , complexity theory , one - way functions , pseudo randomness , computational indistinguishability , zero knowledge interactive proofs . </S>"
  ]
}