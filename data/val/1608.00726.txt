{
  "article_text": [
    "in a peer - to - peer overlay network , each member maintains the identifiers of its overlay neighbors in its memory while leaving message routing to the underlay .",
    "a peer - to - peer overlay network is inherently decentralized and scales up easily .",
    "peer - to - peer overlays are well suited for distributed content storage and delivery",
    ". recent applications of such overlays to internet telephony  @xcite and digital cryptocurrencies  @xcite further enhance interest in scientific studies of the principles of peer - to - peer overlay networks .    due to the lack of central authority and the volunteer nature of overlay network participation , _",
    "churn _ , or joining and leaving of peers , is a particularly vexing problem affecting peer - to - peer overlay networks .",
    "churn may be cooperative , if departing processes execute a prescribed departure algorithm ; or adversarial , if they just exit",
    ".     + * infinite and unlimited churn . *",
    "every peer - to - peer overlay network has to handle churn .",
    "usually , while the topological changes in the overlay required by the churn requests occur , the primary services of the overlay ( _ e.g. _ content retrieval ) are either considered suspended or they are disregarded altogether . in other words ,",
    "the churn is considered finite , and the overlay network users just wait until join / leave requests stop coming , then the overlay network recovers and restores services . if churn happens again , the service suspension repeats .",
    "this may be tolerable if churn is infrequent since the overlay network is available most of the time .",
    "however , at the scales that peer - to - peer overlay networks achieve , peers nearly always wish to join or leave the overlay network . in this case",
    ", the service degradation caused by intermittent suspensions may become unacceptable .",
    "that is , it is necessary to consider _ infinite churn _ under which the overlay network has maintain services while handling it .    one way to handle churn",
    "is to engineer sufficient redundancy in the overlay network topology , so that if the peers leave , there are enough alternative paths to enable service operation . in this approach ,",
    "the amount of redundancy necessarily places a limit on the number of processes that churn concurrently : the churning processes must not sever all redundant paths . however , under heavy churn load and large scale , a peer - to - peer overlay network may breach this limit and collapse ( that is , partition itself ) .",
    "also , the necessity to add redundancy leads to wasted resources .",
    "hence , there is an interest in studying the possibility of _ unlimited churn _ , where this is no bound on the number of concurrently joining or leaving processes .",
    "this paper is an attempt to define and study infinite unlimited churn in peer - to - peer overlay networks .",
    "+ * unfair and local churn . * a request to join and , in cooperative churn , leave the overlay network is submitted to the overlay by the churning process .",
    "a churn handling algorithm is _ fair _ if it eventually satisfies every request .",
    "by contrast , a churn algorithm that allows the possibility , under infinite churn , to bypass indefinitely some requests ( still guaranteeing progress , that is , satisfying some churn requests indefinitely ) , is _",
    "unfair_. unfair algorithms are possibly more efficient .",
    "potentially , a churn handling solution may be straightforward and _ global _ : have some distinguished process manage all churn requests and process them .",
    "however , such a centralized global solution is not practical for large scale overlay networks as it creates a performance bottleneck and a single point of failure .",
    "in contrast , in a _",
    "solution , only processes in the immediate vicinity of the churning process are involved in processing the request .    in this paper , we study fairness and locality of churn solutions .     + * our contribution .",
    "* specifically , we consider churn in the asynchronous message passing system model .",
    "we prove that there does not exist an algorithm that can handle unlimited adversarial churn .",
    "we then focus on cooperative unlimited churn .",
    "we define the infinite unlimited churn problem by specifying the properties of a churn handing algorithm . we distinguish fair and unfair types of the problem .",
    "we prove that there is no local solution to the fair infinite unlimited churn problem .",
    "we then present an algorithm that solves the unfair version of the problem while maintaining a linear topology , i.e. topological sort .",
    "we extend our algorithm to handle skip lists and skip graphs . to the best of our knowledge",
    ", this paper is the first systematic study of unlimited infinite churn .",
    "+ * related work . * independently of peer - to - peer overlay networks , several papers  @xcite address determination of the rate of churn , which is a difficult task itself .",
    "fundamental problems in distributed computing , such as agreement , were also studied in the context of churn  @xcite , however their inherently global setting makes them unsuitable for building peer - to - peer overlays .    usually , peer - to - peer overlay networks are designed to have redundant links so that they can withstand limited peer departure ( that is , limited adversarial churn in our terminology )  @xcite .",
    "many papers address repairing the topology after determining a process unexpectedly left the overlay network  @xcite .",
    "limited churn also enables the possibility to maintain overlay services while adjusting  @xcite .",
    "another approach deals with self - stabilizing peer - to - peer overlay maintenance algorithms  @xcite that enable the peer - to - peer overlay network to recover from an arbitrary topology disruption , once it stops .",
    "that is , self - stabilizing algorithms may handle unlimited but finite adversarial churn . in these algorithms , churn is handled implicitly : topology changes are assumed to eventually stop , after this the system is designed to recover . to handle the possibility of initial incorrect state",
    ", the use of oracles ( that is , abstract entities that provide information about the overlay network ) may be necessary  @xcite .",
    "the recent trend is to provide a general framework that can be instantiated for various overlay networks  @xcite .",
    "overall , previous studies in the context of peer - to - peer overlay networks consider _ limited _ and/or _ finite _ churn , while this paper focuses on unlimited and infinite churn .",
    "* peer - to - peer overlay networks , topology . *",
    "a peer - to - peer overlay network consists of a set of processes with unique identifiers .",
    "we refer to processes and their identifiers interchangeably .",
    "processes communicate by message passing .",
    "a process stores identifiers of other processes in its memory .",
    "process @xmath0 is a _ neighbor _ of process @xmath1 if @xmath1 stores the identifier of @xmath0 .",
    "note that @xmath1 is not necessarily a neighbor of @xmath0 .",
    "a process may send a message to any of its neighbors .",
    "message routing from the sender to the receiver is carried out by the underlying network .",
    "a process may send a message only to the receiver with a specific i d , i.e. we do not consider broadcasts or multicasts .",
    "communication channels are fifo with unlimited message capacity .",
    "a _ structured _ peer - to - peer overlay network maintains a particular topology .",
    "one of the basic topologies is _ linear _ , or a topological sort , where each process @xmath1 has two neighbors @xmath2 and @xmath3 such that @xmath0 is the highest i d in the overlay network that less than @xmath1 and @xmath4 is the lowest i d greater than @xmath1 . consider a particular topology .",
    "cut - set _ is a ( proper ) subset of processes of the network such that the removal of these processes and their incident edges disconnects the network .",
    "it is known that if a network topology is not a complete graph , it has a cut - set . since",
    "a peer - to - peer overlay network maintains its connectivity by storing identifiers in the memory of other processes , once disconnected it may not re - connect .",
    "hence , a peer - to - peer overlay network must not become disconnected either through the actions of the algorithm or through churn actions .",
    "+ * searching , joining and leaving the overlay network . *",
    "the primary use of a peer - to - peer overlay network is to determine whether a certain identifier is present in the overlay network .",
    "a search request message bearing an identifier , may appear in the incoming channel of any process that has already joined the overlay network .",
    "the request is routed until either the identifier is found or its absence is determined .",
    "a process may request to join the overlay network .",
    "we abstract bootstrapping by assuming that a join request , bearing the joining process identifier , appears in an incoming channel of any process that has already joined the overlay network .",
    "a process that joined the overlay network may leave it in two ways . in _",
    "adversarial churn _ a leaving process just exits the overlay network without participating in further algorithm actions . in _",
    "cooperative churn _ a leaving process sends a request to leave the overlay network .",
    "the leaving process exits only after it is allowed to do so by the algorithm .",
    "a process may join the overlay network and then leave .",
    "however , a process that left the overlay network may not join it again with the same identifier . a join or leave request is a _ churn request _ and the corresponding join or leave message is a _ churn message_. when a leaving process exits the overlay network , the messages in its incoming channels are lost .",
    "however , the messages sent from this process before exiting remain in the incoming channel of the receiving process .     + * infinite and unlimited churn definitions .",
    "* churn is _ infinite _ if the number of churn requests in a computation may not be bounded by a constant either known or unknown to the algorithm .",
    "churn is _ unlimited _ if the number of concurrent churn requests in the overlay network is not bounded by a constant either known or unknown to the algorithm .",
    "note that unlimited churn means that potentially all processes that are presently in the overlay network may request to leave .",
    "note also that the two properties are orthogonal .",
    "for example , churn may be finite but unlimited : all processes may request to leave but no more join or leave requests are forthcoming .",
    "alternatively , in infinite limited churn , there may be a infinite total number of join or leave requests but only , for example , five of them in any given state .    in this paper",
    "we only consider infinite unlimited churn .",
    "+ * churn algorithm . *",
    "a churn algorithm handles churn requests . for each process",
    ", an algorithm specifies a set of variables and actions . an _",
    "action _ is of the form @xmath5 where _ label _ differentiates actions , _ guard _ is a predicate over local variables , and _ command _ is a sequence of statements that are executed _ atomically_. the execution of an action transitions the overlay network from one state to another .",
    "an algorithm _ computation _ is an infinite fair sequence of such states .",
    "we assume two kinds of fairness of computation : weak fairness of action execution and fair message receipt .",
    "_ weak fairness _ of action execution means that if an action is enabled in all but finitely many states of the computation then this action is executed infinitely often . _",
    "fair message receipt _ means that if the computation contains a state where there is a message in a channel , this computation also contains a later state where this message is not present in the channel , i.e. the message is received .",
    "we place no bounds on message propagation delay or relative process execution speeds , i.e. we consider fully asynchronous computations .",
    "+ * algorithm locality .",
    "* a churn request may potentially be far , i.e. a large number of hops , from the place where the topology maintenance operation needs to occur .",
    "_ place of join _ for a join request of process @xmath6 , is the pair of processes @xmath7 and @xmath8 that already joined the overlay network , such that @xmath7 has the greatest identifier less than @xmath6 and @xmath8 has the smallest identifier greater than @xmath6 . in every particular state of the overlay network , for any join request , there is a unique place of join .",
    "note that as the algorithm progresses and other processes join or leave the overlay network , the place of join may change .",
    "_ place of leave _ for a leave request of process @xmath6 is defined similarly .",
    "_ place of churn _ is a place of join or leave .",
    "a network topology is _ expansive _ if there exists a constant @xmath9 independent of the network size such that for every pair of processes @xmath6 and @xmath7 where the distance between @xmath6 and @xmath7 is greater than @xmath9 , a finite number of processes may be added @xmath9 hops away from @xmath6 to increase the distance between @xmath6 and @xmath7 by at least one .",
    "this constant @xmath9 is the _ expansion vicinity _ of the topology . in other words , in an expansive topology , every pair of processes far enough away may be further separated by adding more processes to the network without modifying the expansion vicinity of one member of the pair .",
    "note that a completely connected topology is not expansive since the distance between any pair of processes is always one .",
    "however , a lot of practical peer - to - peer overlay network topologies are expansive .",
    "for example , a linear topology is expansive with expansion vicinity of @xmath10 since the distance between any pair of processes at least two hops away may be increased by one if a process is added outside the neighborhood of one member of the pair .",
    "a churn algorithm is _ local _ if there exists a constant @xmath11 independent of the overlay network size , such that only processes within @xmath11 hops from the place of churn need to take steps to satisfy this churn request .",
    "the minimum such constant @xmath11 is the _ locality _ of the algorithm .",
    "note that a local algorithm may maintain only an expansive topology , and that the expansive vicinity of this topology must be greater than the locality of the algorithm .     + * the infinite churn problem .",
    "* a _ link _ is the state of channels between a pair of neighbor processes . as a churn algorithm services requests",
    ", it may temporarily violate the overlay network topology that is being maintained .",
    "a _ transitional link _ violates the overlay network topology while a _ stable link _ conforms to it .",
    "an algorithm that solves the infinite churn problem conforms to a combination of the following properties :    if there is a churn request in the overlay network , some churn request is eventually satisfied ;    if there is a churn request in the overlay network , this churn request is eventually satisfied ;    every transitional link eventually becomes stable ;    a message in a stable link is either delivered or forwarded closer to the destination ;    a message in a transitional link is not lost .",
    "note that the fair request property implies the request progress property .",
    "the converse is not necessarily true .",
    "[ defunfair ] _ the unfair infinite unlimited churn problem _ is the combination of request progress , terminating transition , message progress and message safety properties .",
    "[ deffair ] _ the fair infinite unlimited churn problem _ is the combination of fair request , terminating transition , message progress and message safety properties .    in other words ,",
    "fair infinite unlimited churn guarantees that every churn request is eventually satisfied while unfair infinite unlimited churn does not .",
    "* adversarial churn .",
    "*    [ trmnoadversarial ] there does not exist a solution for unlimited adversarial churn if the maintained topology is not fully connected .",
    "assume there is an algorithm that maintains a topology that is not fully connected such that is resilient against unlimited adversarial churn .",
    "let @xmath12 be the number of processes in the overlay network in some global state .",
    "if the topology is not fully connected , there exists a cut - set @xmath13 of processes whose cardinality is less than @xmath12 .",
    "since handles unlimited churn , it should handle the departure of every process in @xmath13 .",
    "however , since @xmath13 is a cut - set , its departure disconnects the overlay network , which is not possible to handle .",
    "hence , is not able to handle unlimited adversarial churn .    since adversarial unlimited churn can not be handled , in the rest of the paper we are considering cooperative ( unlimited ) churn .     +",
    "* fair local churn . *",
    "intuitively , the proof of the below theorem describes the continuous servicing of join requests before a distant churn request can reach its place of churn .",
    "this join chain keeps building in front of the distant churn request , precluding it from ever reaching the appropriate place .",
    "[ impossible ] there does not exist a local solution to the fair infinite unlimited churn problem for an expansive overlay network topology .",
    "assume there exists a local algorithm with locality @xmath11 that satisfies the fair infinite unlimited churn problem while maintaining an expansive topology with expansion vicinity of @xmath14 .",
    "let us add a churn request with i d @xmath6 to the incoming channel of another process @xmath7 whose distance @xmath15 to the place of churn for @xmath6 is greater than @xmath9 and , therefore , @xmath11 .",
    "since the topology is expansive , there is a set of processes @xmath16 that are not part of the overlay network such that every process in this set can be added @xmath9 hops away from @xmath7 such that the distance @xmath15 between @xmath7 and the place of churn for @xmath6 increases by at least one .",
    "observe that is assumed local with locality @xmath11 that is less than expansion vicinity @xmath9 .",
    "this means that every process in @xmath16 may be added to the overlay network without @xmath7 having to take a step .",
    "let us add the processes of @xmath16 to the overlay network .",
    "let us then have @xmath7 receive the churn request for @xmath6 . since is a solution to the fair infinite unlimited churn problem , @xmath7 must forward this request closer to its place of churn .",
    "suppose @xmath7 forwards this request to some process @xmath17 .",
    "however , since the distance from @xmath7 to @xmath6 s place of churn is at least @xmath18 , the distance from @xmath17 to this place of churn is at least @xmath15 .",
    "we continue this procedure ad infinitum .",
    "the resultant sequence is a computation of algorithm . yet",
    ", there is a churn request of process @xmath6 that is never satisfied .",
    "this means that violates the fair request property of the fair infinite unlimited churn problem , which contradicts our initial assumption .    since fair local ( infinite unlimited ) churn is impossible , in the next section we address unfair local ( infinite unlimited ) churn",
    "* linear topology under churn . * in a linear topology , each process @xmath19 maintains two identifiers : _ left _ , where it stores the largest identifier greater than @xmath19 and _ right _ , where it stores the smallest identifier less than @xmath19 .",
    "processes are thus joined in a chain .",
    "for ease of exposition , we consider the chain laid out horizontally with higher - id processes to the right and lower - id processes to the left .",
    "the largest process stores positive infinity in its _ right _",
    "variable ; the smallest process stores negative infinity in _",
    "left_. a _ left end _ of a link is the smaller - id neighbor process .",
    "right end _ is the greater - id process .",
    "as a process joins or leaves the overlay network it may change the values of its own or its neighbors variables thus transitioning the link from one state to another . in a linear topology , a link is _ transitional _ if its left end is not a neighbor of its right end or vice versa .",
    "the link is _ stable _ otherwise . the largest and smallest processes may not leave .",
    "the links to the right of the largest process and to the left of the smallest processes are always stable .",
    "a process may leave the overlay network only after it has joined .",
    "we assume that in the initial state of the overlay network , all links are stable .",
    "+ * algorithm description .",
    "* we present a local algorithm _ unfair infinite unlimited churn _",
    "( ) that satisfies the four properties of the unfair infinite unlimited churn problem while maintaining a linear topology .",
    "the basic idea of the algorithm is to have the _ handler _ process with the smaller identifier coordinate churn requests to its immediate right .",
    "this handler considers one such request at a time .",
    "this serializes request processing and guarantees the accepted request s eventual completion .",
    "the algorithm is shown in figure  [ figalgo ] . to maintain the topology ,",
    "each process @xmath19 has two variables : _ left _ and _ right _ with respective domains less than @xmath19 and greater than @xmath19 . read - only variable _ leaving _ is set to * true * by the environment once the joined process wishes to leave the overlay network .",
    "variable _ busy _",
    "is used by the handler process to indicate whether it currently coordinates a churn request , or is initialized to * true * for a joining process .",
    "the incoming channel for process @xmath19 is variable @xmath20 .",
    "the request is sent in the form of a single _ join _ or _ leave _ message .",
    "we assume that a _ join _ and , for symmetry , a _ leave _ message is inserted into an incoming channel of an arbitrary joined process in the overlay network .",
    "message _ join _ carries the identifier of the process wishing to join the overlay network .",
    "leave _ carries the i d of the leaving process as well as the i d of the process immediately to its right . actions _",
    "joinrequest _ and _ leaverequest _ describe the processing of the two types of requests .",
    "if the receiver realizes that it is to the immediate right of the place of join or leave , and the receiver is not currently handling another request , i.e. @xmath21 , and it does not want to leave , it starts handling the arrived request .",
    "otherwise , the recipient process forwards the request to its left or right .",
    "request handling is illustrated in figure  [ figjoinleave ] .",
    "it is similar for join and leave and is divided into five stages .",
    "the first two stages are _ setup _ stages : they set up the channels for the links of the the joining process or for the processes that are the neighbors of the leaving process .",
    "the third and forth stages are _ teardown stages _ : they remove the channels of the links being replaced .",
    "the last stage informs either the leaving process that it may exit , or the joining process that it may start coordinating its own churn requests . in the case of join ,",
    "two links need to be set up , hence the setup stages are divided into two substages 1.1 , 1.2 , 2.1 and 2.2 .",
    "similarly , in the case of leave , the teardown stages are divided into substages because two links need to be torn down .",
    "the messages transmitted during corresponding stages are 1 . set up a * sua * , 2 . set up b * sub * , 3 .",
    "tear down a * tda * , 4 .",
    "tear down b * tdb * and 5 . finish teardown * ftd*.     + * correctness proof .",
    "* we denote message * tda * or * tdb * as * td**. similarly , * su * * is * sua * or * sub*. lemmas  [ lemmessages ] and  [ lemstages ] follow immediately from the operation of the algorithm .",
    "[ lemmessages ] message * td * * is the last message in the channel in every teardown stage .",
    "message * su * * is the first message in a channel in every set up stage .",
    "[ lemstages ] the two links of a churning process transition through stages 1 through 5 .",
    "no link participates in concurrent transitions .",
    "the below corollary follows from lemma  [ lemstages ] .",
    "[ lemterminatingtransition ] every transitional link is eventually stable .",
    "note that after the link is stable , it may transition again .",
    "[ lemmessagesafety ] no message in a transitional link is lost .",
    "observe that according to lemma  [ lemmessages ] , in a teardown stage , the last message in the channel is a * td**. by lemma  [ lemstages ] , each stage , including the teardown stages , eventually completes . by the design of the algorithm , a teardown stage completes when",
    "a * td * * message is received .",
    "since each channel is fifo , this teardown message is received only after all other messages in the channel are received .",
    "that is , after the teardown stage completes , there are no messages in the channel that is torn down .",
    "according to lemma  [ lemstages ] , every channel in a transitional link is eventually torn down .",
    "hence the lemma",
    ".    [ lemmessageprogress ] unless the link starts transitioning , a message in a stable link is either eventually delivered or forwarded to a process closer to destination .",
    "consider a message in a channel of a stable link .",
    "we assume fair channel message receipt .",
    "this means , unless the channel is altered due to transitioning , the message is eventually processed by the recipient process .",
    "if this process is the destination , the message is delivered ; if not , the recipient forwards it closer to the destination .",
    "[ lemrequestprogress ] if there is a churn request in the overlay network , some churn request is eventually satisfied .    consider state @xmath22 of the computation where there is a churn request message @xmath9 in a channel of the overlay network . in this state",
    ", some other churn request processing may be under way . according to lemma  [ lemterminatingtransition ] , the processing of all these requests eventually ends .",
    "let @xmath23 be the state of the computation where all requests under way in @xmath22 are done .",
    "if a new request processing has started in @xmath23 , then by applying lemma  [ lemterminatingtransition ] to it , we obtain the claim of this lemma .",
    "let us consider the case where no request processing has occurred between @xmath22 and @xmath23 .",
    "according to lemma  [ lemmessagesafety ] , message @xmath9 is sill in some channel of @xmath23 .",
    "since no requests are processed in @xmath23 , there are no transitional links . that is",
    ", @xmath9 is in a stable link . according to lemma  [ lemmessageprogress ] ,",
    "@xmath9 is forwarded towards its destination . continuing this way",
    ", we observe that either @xmath9 encounters a transitional link or arrives at a process @xmath19 that handles this request .",
    "if @xmath9 encounters a transitional link , this transition started after @xmath22 and the claim of the lemma follows .",
    "if @xmath9 arrives at @xmath19 , @xmath19 may either be busy or not . if @xmath19 is busy ,",
    "it is handling a request that started after @xmath23 .",
    "if @xmath19 is not busy , it starts processing @xmath9 .",
    "hence the lemma .    only processes to the immediate right and left of the churning process are involved in the processing of the churn request .",
    "hence the following lemma .",
    "[ lemlocality ] the locality of is 1 .",
    "the following theorem follows from corollary  [ lemterminatingtransition ] and lemmas  [ lemterminatingtransition],[lemmessagesafety],[lemmessageprogress],[lemrequestprogress ] and  [ lemlocality ] .",
    "[ theoremuiuc ] algorithm is local and it solves the unfair infinite unlimited churn problem .",
    "churn algorithm extends to more complicated topologies such as skip lists  @xcite and skip graphs  @xcite . in these topologies ,",
    "the processes have links on multiple levels .",
    "the processes are linearized in the lowest level . in the higher levels ,",
    "the processes have links to progressively more distant peers .",
    "these higher level links accelerate overlay network searches and other operations .",
    "see figure  [ figskiplist ] for an example skip list .",
    "to extend to such a structure a separate version of should be run at each level .",
    "the churn request should bear the level number to differentiate which level they belong to .",
    "the churning process should proceed up and down the levels as follows .",
    "a joining process first joins the first , linear , level , then the next and so on until it joins all the levels appropriate to the particular structure .",
    "the leaving process should proceed in reverse : the leaving process requests to leave the levels in decreasing order .",
    "for example , in figure  [ figskiplist ] , a process @xmath7 needs to first leave from level @xmath24 , then @xmath25 and so on .",
    "while a joining process @xmath6 needs to first join the overlay network at linearized level @xmath26 , then proceed to join level @xmath10 and so on until it reaches the level appropriate for the particular structure .    as further research",
    "it is interesting to consider extensions of to ring structures such as chord  @xcite or hyperring  @xcite .",
    "another important area of inquiry is addition of limited adversarial churn .",
    "this problem is difficult to address in the asynchronous message passing model where the exited process may not be differentiated from a slow one .",
    "oracles determining a process exit  @xcite may have to be used .",
    "james aspnes , jonathan kirsch , and arvind krishnamurthy .",
    "load balancing and locality in range - queriable data structures . in _ proceedings of the twenty - third annual acm symposium on principles of distributed computing _ , pages 115124 .",
    "acm , 2004 .",
    "john augustine , anisur  rahaman molla , ehab morsy , gopal pandurangan , peter robinson , and eli upfal .",
    "storage and search in dynamic peer - to - peer networks . in _ proceedings of the twenty - fifth annual acm symposium on parallelism in algorithms and architectures _ , pages 5362 .",
    "acm , 2013 .",
    "john augustine , gopal pandurangan , and peter robinson .",
    "fast byzantine agreement in dynamic networks . in _ proceedings of the 2013 acm symposium on principles of distributed computing _ , pages 7483 .",
    "acm , 2013 .",
    "john augustine , gopal pandurangan , peter robinson , scott roche , and eli upfal . enabling robust and efficient distributed computation in dynamic peer - to - peer networks . in _",
    "foundations of computer science ( focs ) , 2015 ieee 56th annual symposium on _ , pages 350369 .",
    "ieee , 2015 .",
    "baruch awerbuch and christian scheideler .",
    "the hyperring : a low - congestion deterministic data structure for distributed environments . in _ soda _ , pages 318327 , philadelphia , pa , usa , 2004 . society for industrial and applied mathematics .",
    "andrew berns , sukumar ghosh , and sriram  v pemmaraju .",
    "building self - stabilizing overlay networks with the transitive closure framework . in _",
    "symposium on self - stabilizing systems _ , pages 6276 .",
    "springer , 2011 .",
    "maximilian drees , robert gmyr , and christian scheideler .",
    "churn - and dos - resistant overlay networks based on network reconfiguration . in _ proceedings of the 28th acm symposium on parallelism in algorithms and architectures , spaa 2016 , california usa , july 11 - 13 , 2016",
    ". proceedings _ , pages 417427 .",
    "acm , 2016 .",
    "dianne foreback , andreas koutsopoulos , mikhail nesterenko , christian scheideler , and thim strothmann . on stabilizing departures in overlay networks .",
    "symposium on self - stabilizing systems _ , pages 4862 .",
    "springer , 2014 .",
    "dominik gall , riko jacob , andra  w. richa , christian scheideler , stefan schmid , and hanjo tubig .",
    "time complexity of distributed topological self - stabilization : the case of graph linearization . in",
    "_ latin _ , pages 294305 , 2010 .",
    "sbastien gambs , rachid guerraoui , hamza harkous , florian huc , and anne - marie kermarrec .",
    "scalable and secure polling in dynamic distributed networks . in",
    "_ reliable distributed systems ( srds ) , 2012 ieee 31st symposium on _ , pages 181190 .",
    "ieee , 2012 .",
    "michael  t goodrich , michael  j nelson , and jonathan  z sun . the rainbow skip graph : a fault - tolerant constant - degree distributed data structure . in",
    "_ proceedings of the seventeenth annual acm - siam symposium on discrete algorithm _ ,",
    "pages 384393 . society for industrial and applied mathematics , 2006 .",
    "rachid guerraoui , florian huc , and anne - marie kermarrec .",
    "highly dynamic distributed computing with byzantine failures . in _ proceedings of the 2013 acm symposium on principles of distributed computing _ , pages 176183 .",
    "acm , 2013 .",
    "steven  y ko , imranul hoque , and indranil gupta . using tractable and realistic churn models to analyze quiescence behavior of distributed protocols . in _ reliable distributed systems , 2008 .",
    "ieee symposium on _ , pages 259268 , 2008 .",
    "andreas koutsopoulos , christian scheideler , and thim strothmann . towards a universal approach for the finite departure problem in overlay networks . in andrzej pelc and alexander  a. schwarzmann , editors , _ stabilization , safety , and security of distributed systems - 17th international symposium , sss 2015 , edmonton , ab , canada , august 18 - 21 , 2015 , proceedings _",
    ", volume 9212 of _ lecture notes in computer science _ , pages 201216 .",
    "springer , 2015 .",
    "giuliano mega , alberto montresor , and gian  pietro picco . on churn and communication delays in social overlays .",
    "in _ peer - to - peer computing ( p2p ) , 2012 ieee 12th international conference on _ , pages 214224 .",
    "ieee , 2012 .",
    "rizal  mohd nor , mikhail nesterenko , and christian scheideler .",
    "corona : a stabilizing deterministic message - passing skip list . in _",
    "13th international symposium on stabilization , safety , and security of distributed systems ( sss ) _ , pages 356370 , grenoble , france , october 2011 .",
    "rizal  mohd nor , mikhail nesterenko , and sbastien tixeuil .",
    "linearizing peer - to - peer systems with oracles . in _ stabilization , safety , and security of",
    "distributed systems - 15th international symposium , sss 2013 , osaka , japan , november 13 - 16 , 2013",
    ". proceedings _ , pages 221236 , 2013 .",
    "antony i.  t. rowstron and peter druschel .",
    "pastry : scalable , decentralized object location , and routing for large - scale peer - to - peer systems . in _",
    "middleware _ , pages 329350 , london , uk , 2001 .",
    "springer - verlag .",
    "jared saia and amitabh trehan .",
    "picking up the pieces : self - healing in reconfigurable networks . in _",
    "parallel and distributed processing , 2008 .",
    "ipdps 2008 .",
    "ieee international symposium on _ , pages 112 .",
    "ieee , 2008 .",
    "ion stoica , robert morris , david liben - nowell , david  r. karger , m.  frans kaashoek , frank dabek , and hari balakrishnan . : a scalable peer - to - peer lookup protocol for internet applications .",
    ", 11(1):1732 , 2003 ."
  ],
  "abstract_text": [
    "<S> we study unlimited infinite churn in peer - to - peer overlay networks . under this </S>",
    "<S> churn , arbitrary many peers may concurrently request to join or leave the overlay network ; moreover these requests may never stop coming . </S>",
    "<S> we prove that unlimited adversarial churn , where processes may just exit the overlay network , is unsolvable . </S>",
    "<S> we focus on cooperative churn where exiting processes participate in the churn handling algorithm . </S>",
    "<S> we define the problem of unlimited infinite churn in this setting . </S>",
    "<S> we distinguish the fair version of the problem , where each request is eventually satisfied , from the unfair version that just guarantees progress . </S>",
    "<S> we focus on local solutions to the problem , and prove that a local solution to the fair infinite unlimited churn is impossible . </S>",
    "<S> we then present and prove correct an algorithm that solves the unfair infinite unlimited churn problem for a linearized peer - to - peer overlay network . </S>",
    "<S> we extend this solution to skip lists and skip graphs . </S>"
  ]
}