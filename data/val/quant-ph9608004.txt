{
  "article_text": [
    "_ title of program _ : quantum trajectory class library    _ program obtainable from _ : http://galisteo.ma.rhbnc.ac.uk/applied/qsd.html and the authors .    _ licensing provisions _ :",
    "none    _ operating systems under which the program has been tested _ : unix ( gnu g++ ) , dos ( turbo c++ ) , vms ( dec c++ )    _ programming language used _ : c++    _ memory required to execute with typical data _ : 1mbyte    _ has the code been vectorized ?",
    "_ : no    _ no .",
    "of lines in distributed program , including test data , etc .",
    "_ : 8000    _ keywords _ : open quantum system , master equation , hilbert space , quantum trajectories , unraveling , stochastic simulation , quantum computation , quantum optics , quantum state diffusion , quantum jumps , monte carlo wavefunction    _ nature of physical problem _ :",
    "+ open quantum systems , i.e. , systems whose interaction with the environment can not be neglected , occur in a variety of contexts .",
    "examples are quantum optics , atomic and molecular physics , and quantum computers .",
    "if the time evolution of the system is approximately markovian , it can be described by a master equation of lindblad form [ 1 ] , a first order differential equation for the density operator .",
    "solving the master equation is the principal purpose of the program .",
    "since the state and operator classes are very general , they can be used in any physical problem involving hilbert spaces with several degrees of freedom .",
    "_ method of solution _ : + by analogy with the solution of a fokker - planck equation by numerical simulation of the corresponding stochastic differential equation , a master equation can be solved by simulating the stochastic evolution of a vector in hilbert space . the correspondence between master equation and stochastic equation is not unique : there are many ways to _ unravel _ the master equation into stochastic quantum trajectories . the program implements three such unravelings , known as the `` quantum state diffusion method ( qsd ) '' [ 2 ] , the `` quantum jump method '' [ 35 ] , and the `` orthogonal jump method''[6 ] .",
    "the phenomenon of phase - space localization [ 7,8 ] is exploited numerically by representing quantum states in a local moving basis obtained by applying the coherent - state displacement operator to the usual harmonic - oscillator basis , often leading to dramatic savings of computing resources .",
    "_ unusual features of the program _ : + it is worth emphasizing the effortless way in which operators and states in product hilbert spaces are represented .",
    "primary operators implemented in the form of simple routines acting on single degrees of freedom can be used to build up arbitrarily complex operators in product hilbert spaces with arbitrary numbers of components .",
    "building operators , performing arithmetic operations on operators and states , and applying operators to states is done using standard algebraic notation .",
    "this program structure has been made possible by systematically implementing object - oriented programming concepts such as inheritance , concepts which are not ( yet ) widely used in computational physics .",
    "encapsulation of program modules makes it easy to add new basic operators , alternative unravelings of the master equation , or different integration algorithms .    _",
    "typical running time _ : + the running time depends on the complexity of the problem , the integration time , and the number of trajectories required . a typical running time for",
    "a simple problem is a few minutes .",
    "there is no upper limit .",
    "_ references _ :    [ 1 ] g. lindblad , commun .",
    "* 48 * , 119 ( 1976 ) .    [ 2 ] n. gisin and i.  c. percival , j. phys .",
    "a * 25 * , 5677 ( 1992 ) .    [ 3 ] h.  j. carmichael , _ an open systems approach to quantum optics _",
    "( springer , berlin , 1993 ) .    [ 4 ]",
    "j. dalibard , y. castin , and k. mlmer , phys .",
    ", 580 ( 1992 ) .",
    "[ 5 ] c.  w. gardiner , a.  s. parkins , and p. zoller , phys .",
    "a * 46 * , 4363 ( 1992 ) .    [ 6 ] l. disi , phys .",
    "a * 114 * , 451 ( 1986 ) .    [ 7 ]",
    "t. steimle , g. alber , and i.  c. percival , j. phys .",
    "a * 28 * , l491 ( 1995 ) .",
    "[ 8 ] r. schack , t. a. brun , and i. c. percival , j. phys .",
    "a * 28 * , 5401 ( 1995 ) .",
    "for many quantum systems of current interest it is no longer possible to neglect the interactions with the environment .",
    "those so - called _ open quantum systems _ occur in a variety of contexts including quantum optics , atomic and molecular physics , and quantum computers .",
    "open quantum systems can often be described by a master equation @xcite , a first - order differential equation for the density operator , in which the internal dynamics of the system is represented by the system hamiltonian @xmath0 , which is a hermitian hilbert - space operator , and the interaction with the environment is represented by one or more lindblad operators @xmath1 which are not necessarily hermitian .    by analogy with the solution of a fokker - planck equation by numerical simulation of the corresponding stochastic differential equation ( or langevin equation ) , a master equation can be solved by simulating the stochastic evolution of a vector in hilbert space . the correspondence between master equation and stochastic equation is not unique ; there are many ways to _ unravel _ the master equation into stochastic quantum trajectories .",
    "the main challenge of this software project was to develop a general program flexible enough to accommodate different integration algorithms and unravelings of the master equation , as well as the vast range of possible physical systems .",
    "in particular , we wanted to make it easy to add new algorithms and unravelings , and we wanted a program capable of dealing with arbitrary hamiltonian and lindblad operators in hilbert spaces with an arbitrary number of degrees of freedom .",
    "this task turned out to be ideal for the application of object - oriented programming .",
    "we chose the c++ language both because of its wide availability and because it allowed us to use standard mathematical notation for hilbert - space operations by overloading algebraic operators like ` + ' and ` @xmath2 ' .",
    "the core of the program are the c++ classes state and operator , which represent state vectors and operators in hilbert space . because of the object - oriented features of c++ , it is possible to hide the implementation details of these classes completely from the classes dealing with the simulation of quantum trajectories .",
    "these implementation details need not to be known either by a user of the program who wants to choose the quantum operators defining the physical problem of interest or by a programmer who wants to add a new unraveling of the master equation to the software .",
    "a welcome side effect of this encapsulation is that the state and operator classes can be used independently of the rest of the code .",
    "they should prove useful in many numerical schemes involving hilbert spaces for systems with several degrees of freedom .",
    "many hamiltonian and lindblad operators can be written as sums of products of simple operators acting on a single degree of freedom .",
    "here is an example of a hamiltonian operator coupling a two - level atom ( with raising and lowering operators @xmath3 and @xmath4 ) to an electromagnetic field mode ( with annihilation and creation operators @xmath5 and @xmath6 ) : @xmath7 where the parameter @xmath8 is the coupling strength . in the following code segment ,",
    "the atomic and field degrees of freedom are labeled 0 and 1 , respectively .",
    "the hamiltonian is defined in terms of the predefined _ primary operators _ sigmaplus and annihilationoperator using standard algebraic notation .",
    "the class adaptivestep is a _ stepper _ routine advancing the quantum trajectory by a single time step .    ....",
    "double g = 0.5 ; sigmaplus sp(0 ) ;              // operates on the 1st degree of freedom annihilationoperator a(1 ) ;    // operates on the 2nd degree of freedom operator sm = sp.hc ( ) ;        //",
    "hermitian conjugate operator ac = a.hc ( ) ; operator h = g * ( sp*a + sm*ac ) ;     //",
    "hamiltonian   ... adaptivestep thestepper ( ... , h , ... ) ;   // ... denotes further arguments ....",
    "the important feature illustrated by this example is that the stepper routine is passed an object of type operator without any reference to details like the number of degrees of freedom .",
    "all the stepper needs to know is that operators can be added , multiplied , etc . , and that they can be applied to state vectors .",
    "internally , the primary operators sigmaplus and annihilationoperator are represented as simple loops acting on a single - degree - of - freedom state vector .",
    "an instance of the more general operator class is represented by a stack that indicates which primary operators are used and the operations by which they are combined . for example , the sequence of steps executed by the program when the operator @xmath0 defined above is applied to a state @xmath9 is summarized in the expression @xmath10 in which the elementary steps are applying a primary operator to a state , adding two states , and multiplying a state by a scalar .",
    "it is clear from this example that a different grouping of the terms in the expression for @xmath0 could lead to inefficient code .",
    "this will be discussed in sec .",
    "[ secop ] .",
    "an open quantum system can not be described by a hilbert - space vector @xmath11 evolving according to the schrdinger equation ; instead , the state must be described by a density operator @xmath12 whose time evolution generally does not follow any simple law .",
    "fortunately it turns out that for a large class of systems the time evolution of the density operator @xmath12 is _ markovian _ to an excellent approximation , i.e. , the rate of change of @xmath12 at time @xmath13 , @xmath14 , depends only on @xmath15 , not on the value of @xmath12 at any earlier time .",
    "it has been shown that under the markov approximation the density operator of any open quantum system obeys a _",
    "master equation _ of lindblad form @xcite @xmath16 +   \\sum_j\\left(\\hat l_j\\hat\\rho \\hat l_j^\\dagger   - { 1\\over2 } \\hat l_j^\\dagger\\hat l_j\\hat\\rho    - { 1\\over2}\\hat\\rho   \\hat l_j^\\dagger\\hat l_j\\right ) \\ ; , \\label{eqmaster}\\ ] ] where @xmath0 is the system hamiltonian and the @xmath1 are the lindblad operators representing the interaction with the environment .    in many cases ,",
    "no analytical methods for the solution of the master equation are known ; one has to use numerical methods .",
    "but even a numerical solution of the master equation can be very hard .",
    "if a state requires @xmath17 basis vectors in hilbert space to represent it , the corresponding density operator will require @xmath18 real numbers ; this can often be too large for even the most powerful machines to handle , particularly if the system involves more than one degree of freedom .",
    "this problem can be overcome by unraveling the density operator evolution into _ quantum trajectories _ .",
    "since quantum trajectories represent the system as a state vector rather than a density operator , they often have a numerical advantage over solving the master equation directly , even though one has to average over many quantum trajectories to recover the solution of the master equation .",
    "a single quantum trajectory can give an excellent , albeit qualitative , picture of a single experimental run .",
    "the three unravelings of the master equation currently implemented are given by the following three nonlinear stochastic differential equation for a normalized state vector @xmath19 :    \\(i ) the quantum state diffusion ( qsd ) equation @xcite @xmath20 ( ii ) the quantum jump equation @xcite @xmath21 and ( iii ) the orthogonal jump equation @xcite @xmath22 the first sum in each of these equations represents the deterministic drift of the state vector due to the environment , and the second sum the random fluctuations .",
    "angular brackets denote the quantum expectation @xmath23 of the operator @xmath24 in the state @xmath19 .",
    "the @xmath25 are independent complex differential gaussian random variables satisfying the conditions @xmath26 where m denotes the ensemble mean .",
    "the @xmath27 are independent real discrete poissonian random variables satisfying the conditions @xmath28 where the `` conditional mean '' @xmath29 is defined as the mean over all trajectories for which @xmath30 , and where @xmath31 for the quantum jump equation  ( [ eqqj ] ) and @xmath32 for the orthogonal jump equation  ( [ eqortho ] ) .",
    "the density operator is given by the mean over the projectors onto the quantum states of the ensemble : @xmath33 if the pure states of the ensemble satisfy one of the quantum trajectory equations ( [ eqqsd ] ) , ( [ eqqj ] ) , or ( [ eqortho ] ) , then the density operator satisfies the master equation ( [ eqmaster ] ) : @xmath34 where we have assumed that initially the system is in a pure state @xmath35 at time @xmath36 . from this",
    "it is clear that the expectation value of an operator @xmath37 is given by @xmath38",
    "our c++ library can be divided roughly into three large parts :    \\1 .",
    "the state class and its associated friend functions .",
    "a state includes as member data the number of degrees of freedom it represents , how many basis vectors are allocated for each degree of freedom , the physical type of each degree of freedom , and ( of course ) the complex amplitudes of each basis vector in the total hilbert space .",
    "the member functions include constructors for a number of common state types ; arithmetic functions enabling states to be added , subtracted , multiplied by scalars , and normalized ; functions relating to the efficient use of memory , so that a state can be dynamically resized ; and functions controlling the action of operators on the state .",
    "there are also member data and functions relating to the moving basis algorithm , described below",
    ". states ( and operators ) can be used like ordinary variables . in particular ,",
    "when a locally defined state ( or operator ) goes out of scope , all memory used by it is properly returned to the system ; the user of the program need not worry about memory allocation and deallocation as this is done automatically .",
    "\\2 . the operator class .",
    "operators are defined in terms of their actions on states .",
    "there is a small class of primaryoperators , whose actions on a single degree of freedom are given by pre - defined functions .",
    "more complex operators are defined in terms of these primaryoperators ; they can be added , multiplied , multiplied by scalars or time - dependent functions , conjugated , or raised to powers .",
    "an operator s member data includes a number of dynamically allocated stacks which indicate which primaryoperators are used , and the operations by which they are combined .",
    "arithmetic operations on operators are then defined by operations on these stacks .",
    "\\3 . the trajectory class and associated classes .",
    "these encode the numerical algorithms for solving the quantum trajectory equations and generating output , with associated integration routines , random number generators , and other utilities .",
    "several different integration algorithms are currently included , including second- and fourth - order runge - kutta and cash - karp runge - kutta with adaptive time steps @xcite .",
    "these algorithms are used to solve the deterministic part of the quantum trajectory equations ( [ eqqsd ] ) , ( [ eqqj ] ) , and ( [ eqortho ] ) .",
    "the stochastic terms are solved using first - order euler integration .",
    "the implementation of more sophisticated stochastic integration methods ( see , e.g. , @xcite ) is straightforward . note that it is only in this part of the program that there is any reference at all to the details of quantum unravelings .",
    "the operator and state classes are very general .",
    "these three parts are roughly equal in size , but quite different in internal structure .",
    "the state class is a single monolithic c++ class with associated functions ; the operator class is a parent class with numerous descendent classes representing the different primaryoperators .",
    "the numerical integration classes are independent of the details of state and operator , and of each other . because of the object - oriented nature of c++ , these three groups need know very little about each other s internal workings .",
    "the following more detailed discussion is not exhaustive ; a complete description of the code can be found in the extensively commented # include files , particularly in state.h , operator.h , and traject.h .",
    "we represent a state @xmath9 with a single degree of freedom by an array of @xmath39 complex amplitudes @xmath40 in a given basis @xmath41 : @xmath42 the choice of basis vectors depends on the physical type of the system . for field modes ,",
    "we use fock states @xmath43 ; for spins ( @xmath44 ) , we use @xmath45 eigenstates @xmath46 and @xmath47 ; for @xmath39-level atoms , we use energy levels @xmath48 . other types , e.g. , molecules or higher spins , can be added easily .",
    "of course , a true field mode has an infinite - dimensional hilbert space .",
    "the state class represents fields by a finite number of basis states , which should be taken as a truncation of the true infinite expansion .    to represent a state then requires the physical type ( currently field , spin or atom ) , the number of basis vectors @xmath39 , and an array of @xmath39 complex amplitudes .",
    "the state class contains constructors for many typical situations .",
    "for instance , the expression    .... state psi(2,spin ) ; ....    defines psi to be the @xmath46 state of a spin ( @xmath49 ) , and    .... complex alpha(0.2,0.3 ) ; state psi(100,alpha , field ) ; ....    defines a coherent state @xmath50 with @xmath51 truncated to @xmath52 basis states .",
    "arithmetic operations for states are defined internally as operations on the complex amplitudes . in the following code examples ,",
    "the state @xmath53 is formed from the fock states @xmath54 and @xmath55 , added to @xmath56 , and then renormalized ; finally , the inner product @xmath57 is evaluated . here",
    "@xmath58 basis states are more than sufficient to represent all states without any truncation .    .... state psi1(10,0,field ) ; state psi2(10,3,field ) ; state psi3 = 0.5*psi1 - psi2 ; psi1 + = psi3 ; psi3.normalize ( ) ; complex z = psi2*psi3 ; ....    the expression psi1+=psi3 is superior to the alternative psi1=psi1+psi3 because it avoids the creation of temporary state objects , which is an important consideration in high - dimensional hilbert spaces .      a general way of representing operators is as @xmath59 complex matrices acting on vectors in @xmath39-dimensional hilbert space . for large @xmath39 , however , this can be very inefficient , as these matrices become very large , and applying them to states requires @xmath60 operations .",
    "fortunately , most of the operators of interest in quantum systems are _ sparse _ , consisting of sums and products of a few primary operators . for fields ,",
    "such primary operators are annihilation and creation operators @xmath5 and @xmath61 and position and momentum operators @xmath62 and @xmath63 ; for spins , the primary operators are the pauli matrices @xmath64 ; for atoms , we have the transition operators @xmath65 .    in the program , these primary operators are implemented as simple classes , as illustrated for the spin operator @xmath3 in the following code section .",
    ".... class sigmaplus : public primaryoperator { public :    sigmaplus ( ) : primaryoperator(0,spin ) { } ;    sigmaplus(int freedom ) : primaryoperator(freedom , spin ) { } ;    virtual void applyto(state&,int , double ) ; } ; void sigmaplus::applyto(state & v , int hc , double ) {    switch ( hc ) {    case no_hc :      v[1 ] = v[0 ] ; v[0 ] = 0 ; break ;    case hc :      v[0 ] = v[1 ] ; v[1 ] = 0 ; break ;     } } ....    the sigmaplus class is derived from the abstract class primaryoperator which serves as an interface to the different special classes like sigmaplus . apart from the two constructors , the class contains only the method applyto .",
    "the three arguments of applyto are a single - degree of freedom state , an integer switch determining whether to apply @xmath3 or its hermitian conjugate , and a double argument specifying the time for time - dependent operators , which is not used here .",
    "the program represents _ composite operators _ , i.e. , sums and products of primary operators , by stacks containing pointers to primary operators as illustrated in fig .",
    "[ figstack ] .",
    "those stacks are the principal member data of the operator class , which is the parent class of primaryoperator and therefore of all special classes derived from primaryoperator . for a primary operator like sigmaplus ,",
    "the stack consists just of the pointer to this , which points to the primary operator itself .",
    "figure  [ figinherit ] shows the hierarchy of operator classes .    the example stack in box 3 in fig .",
    "[ figstack ] is generated by the code segment    .... operator o1 = a + b ; operator o2 = ( 3 * c ) * d ; operator o3 = 01 - 02 ; ....    where a , b , c , d are assumed to be primary operators defined earlier in the program .",
    "the example illustrates how addition , subtraction , and multiplication of operators is implemented in terms of operations on the stack .",
    "further operations defined for operators include hermitian conjugation and raising to an integer power .",
    "the c++ inheritance mechanism ensures that all these operations are also defined for the derived primary - operator classes like sigmaplus .    to apply an operator to a state",
    ", the ` ' operator can be used as in the following example , where psi is a state and o3 is defined above :    .... state psi1 = o3 * psi ; ....    internally , this is implemented as a recursive evaluation of the stack . the order in which the primary operators are applied in the example",
    "can be inferred from the parentheses in @xmath66 the program keeps the number of operations and the number of temporary states it creates to a minimum .",
    "some care has to be exercised , however , to avoid an inefficient evaluation order .",
    "e.g. , in the code segment    .... double x=1.5 ; sigmaplus sp ; state psi1 = 2.0*x*sp*psi ; ....    the state sp*psi is first multiplied by 1.5 , then by 2.0 , whereas in    ....",
    "double x=1.5 ; sigmaplus sp ; state psi1 = ( 2.0*x)*sp*psi ; ....    there is only one multiplication by 3.0 .",
    "the creation of unnecessary temporary states can be avoided by applying operators to states using the ` = ' operator as in    .... sigmaplus sp ; state psi(2,spin ) ; psi * = sp ; ....    when this code segment is executed , no temporary states are created , in contrast to the otherwise equivalent code segment    .... sigmaplus sp ;    state psi(2,spin ) ; psi = sp*psi ; ....    a detailed explanation of the stack and the recursive evaluation procedure can be found in the extensively commented file operator.cc .",
    "a quantum system with @xmath67 degrees of freedom can be represented in a product hilbert space @xmath68 .",
    "we assume that there is a finite , perhaps truncated , product basis @xmath69 .",
    "any state @xmath70 can then be written in the form @xmath71 requiring a total of @xmath72 basis vectors .",
    "to represent a state with multiple degrees of freedom , the state class contains as member data the number of freedoms @xmath67 , an array of @xmath67 physical types , an array of @xmath67 subspace dimensions @xmath73 , and an array of @xmath74 amplitudes @xmath75 .",
    "product states can be initialized by passing a list of single - degree - of - freedom states to the appropriate state constructor .",
    "this is illustrated in the following example , where the state @xmath76 is assigned to psiini :    .... state phi1(50,field ) ; state phi2(50,field ) ; state phi3(2,spin ) ; state statelist[3 ] = { phi1 , phi2 , phi3 } ; state psiini(3,statelist ) ; ....    entangled states can be constructed by adding several product states or by explicitly initializing the array of amplitudes @xmath75 .",
    "operators acting on multiple degrees of freedom are represented as sums and products of primary operators each acting on a single degree of freedom .",
    "take the example of a primary operator @xmath77 acting on the first degree of freedom .",
    "it can be rewritten as the operator @xmath78 on the product hilbert space , where @xmath79 is the identity operator acting on all the other degrees of freedom .",
    "we can write any state @xmath9 as @xmath80 the action of @xmath78 on @xmath9 is therefore given by the action of @xmath77 on the first degree of freedom inside a hierarchy of loops over all the other degrees of freedom : @xmath81 in the program , the loops are unfolded into one big loop if the primary operator acts on the first or last degree of freedom ; otherwise the loops are unfolded into two loops , an `` inner '' and an `` outer '' loop .    to define , e.g. , a primary sigmaplus operator acting on the @xmath82rd degree of freedom , the constructor has to be called with the argument @xmath83 :    .... sigmaplus sp(2 ) ; ....    the operator class is virtually unaffected by the complications arising from multiple degrees of freedom ( see fig .",
    "[ figmultiple ] ) . whenever an operator is applied to a state psi",
    ", the recursive evaluation of the operator stack will eventually come across a pointer to some primary operator b acting on a particular freedom . at that stage",
    ", the pointer to b will be passed to the method psi.apply ( ) of the state class , which controls the loops over all the other degrees of freedom .",
    "each time the loop is executed , the state class passes a single - degree - of - freedom state to the method b.applyto ( ) of the primary operator b. the complex amplitudes of this single - freedom state are typically stored at widely spaced locations in the array of complex amplitudes @xmath75 , but this fact is completely hidden from the primary operator b.    this way of organizing the program has great advantages .",
    "most importantly , all the implementation details of multiple - freedom states are hidden from the operator class .",
    "apart from leading to a transparent program , this makes adding new primary operators very easy , as was seen in sec .",
    "[ secop ] .",
    "the definition of the primary - operator class sigmaplus given there is used without modification in the multiple - freedom case .",
    "our class library realizes its full potential when all operators are sums and products of a few simple primary operators .",
    "although this situation is extremely common in many fields , there are important exceptions like the coulomb potential . while the program could be adapted to implement such a case , some of its unique features would be lost in the process .    for efficiency",
    ", the state class distinguishes internally between single - freedom and multiple - freedom states ; many actions are more efficient for a single degree of freedom .",
    "this distinction , however , is completely transparent .",
    "the user need distinguish between the two only when constructing the initial state .",
    "in quantum - trajectory simulations , one often encounters field states that are well _ localized _ in phase space . in cases with strong localization , it is often possible to reduce drastically the number @xmath39 of basis states needed by continually changing the basis .",
    "if a state is localized about a point @xmath84 in phase space far from the origin , it requires many number states @xmath43 to represent it .",
    "but relatively few displaced number states ( or _ excited coherent states _ ) @xmath85 , are needed , with corresponding savings in computer storage space and computation time .",
    "the operator @xmath86 is the usual coherent state displacement operator @xcite , @xmath87 where @xmath62 and @xmath63 are the position and momentum operators .",
    "the separation of the representation into a classical part @xmath84 and a quantum part @xmath88 is called the _ moving basis _",
    "@xcite or , as in @xcite , the _",
    "mixed _ representation .",
    "to represent a state of type field in the moving basis requires to store the complex center of coordinates @xmath89 in addition to the complex amplitudes .",
    "a multiple - freedom state in the moving basis with several freedoms of type field requires an array of centers of coordinates .    implementing",
    "the moving basis algorithm is straightforward .",
    "suppose that at time @xmath90 the state @xmath91 is represented in the basis @xmath92 , centered at @xmath93 then after one discrete time step , the expectations in this basis shift to @xmath94 the computational advantage of a small number of basis states is then retained by changing the representation to the shifted basis @xmath95 centered at @xmath96 and @xmath97 .",
    "this shift in the origin of the basis represents the elementary single step of the moving basis .",
    "the components of @xmath98 can be computed using the expressions given above .",
    "the computing time needed for the basis shift is of the same order of magnitude as for computing a single discrete time step of one of the quantum trajectory equations . shifting the basis once every discrete time step could therefore double the computing time , depending on the complexity of the hamiltonian and the number of degrees of freedom . on the other hand",
    ", the reduced number of basis vectors needed to represent states in the moving basis can lead to savings far bigger than a factor of 2 .    in the example of second harmonic generation discussed in @xcite , two modes of the electromagnetic field interact . using the moving basis",
    "reduces the number of basis vectors needed by a factor of 100 in each mode .",
    "the total number of basis vectors needed is thus reduced by a factor of 10000 , leading to reduction in computing time by a factor of roughly @xmath99 .",
    "furthermore , the fixed basis would exceed the memory capacity of most computers .",
    "the state class includes a variety of basis - changing methods .",
    "the most important is the method    .... void movecoords ( const complex & displacement , int thefreedom ,                   double shiftaccuracy ) ; ....    which performs a relative shift of the center of coordinates @xmath89 by an amount given by the complex argument displacement .",
    "the integer argument thefreedom specifies which degree of freedom is to be shifted  this degree of freedom must be of type field .",
    "the double argument shiftaccuracy gives the numerical accuracy with which to make the shift .",
    "the physical state is unchanged by applying movecoords ( ) , but it is represented in a new basis .",
    "the method movecoords ( ) is used in the stochastic integration algorithms of the trajectory class described in sec .",
    "[ sectraj ] .",
    "the primary operators of type field defined in the files fieldop.h and fieldop.cc are implemented in such a way that they can handle moving - basis states as well as ordinary states .",
    "the quantum trajectory equations can contain both localizing and delocalizing terms . .",
    "nonlinear terms in the hamiltonian tend to spread the wave function in phase space , whereas the lindblad terms often cause it to localize .",
    "accordingly , the width of the wave packets varies along a typical trajectory .",
    "we use this to reduce the computing time even further by dynamically adjusting the number of basis vectors .",
    "our criterion for this adjustment depends on parameters @xmath100 , the _ cutoff probability _ , and @xmath101 , the _ pad size _ , which represents the number of boundary basis states that are checked for significant probability .",
    "we require the total probability of the top @xmath101 states to be no greater than @xmath102 , increasing or decreasing the number of states actually used accordingly , as the integration proceeds along the quantum trajectory .",
    "the method of the state class used to adjust the basis size is    .... void adjustcutoff(int thefreedom , double epsilon , int padsize ) ; ....    where the arguments specify the degree of freedom to be adjusted , the cutoff probability @xmath102 , and the pad size @xmath101 , respectively .    like the basis - changing methods discussed above , the method adjustcutoff ( ) is typically only used inside integration routines of the trajectory class .",
    "those methods will not normally be called from a top - level program , so the user need not be concerned by them .",
    "the trajectory class and its associated classes , defined in the files traject.h and",
    "traject.cc , implement the integration of the quantum trajectory equations  ( [ eqqsd ] ) , ( [ eqqj ] ) , and ( [ eqortho ] ) . at the heart of this part of the code",
    "is the abstract class integrationstep which serves as an interface for the specific stepper classes implementing single integration steps of lenght @xmath103 .",
    "the stepper classes derived from the class integrationstep include the class order4step for a single 4-th order runge - kutta step of the qsd equation  ( [ eqqsd ] ) as well as a group of classes using adaptive cash - karp runge - kutta time steps : the class adaptivestep for a time step of total length @xmath103 of the qsd equation  ( [ eqqsd ] ) , the class adaptivejump for a time step of total length @xmath103 of the quantum jump equation  ( [ eqqj ] ) , and the class adaptiveorthojump for a time step of total length @xmath103 of the orthogonal jump equation  ( [ eqortho ] ) .",
    "all those classes use a single first order euler integration step of length @xmath103 for the stochastic part .",
    "due to the modular structure of the class library , it is straightforward to add more sophisticated stochastic integration methods ( see , e.g. , @xcite ) .    to initialize a stepper , including",
    "all temporary memory needed for the integration algorithm , all one has to do is call the appropriate constructor as in the code segment    .... state psiini(2,spin ) ; sigmaplus sp ; operator h = sp + sp.hc ( ) ; int nl = 1 ; operator l[nl ] = { 0.1*sp.hc ( ) } adaptivestep stepper(psiini , h , nl , l ) ; ....    a less trivial example can be found in the sample program in sec .",
    "[ secsample ] .",
    "entire quantum trajectories are computed by repeatedly calling a stepper from within the trajectory class .",
    "a trajectory is initialized as in the following example which is taken from the sample program below :    .... double dt=0.01 ;     //",
    "basic time step passed to the stepper acg gen(38388389 ) ; //",
    "random number generator defined in acg.h complexnormal rndm(&gen ) ;                      //",
    "gaussian random numbers defined in cmplxran.h trajectory traj(psiini , dt , stepper , & rndm ) ; ....    the trajectory class comprises two methods to launch the simulation , compute expectation values of operators of interest , and produce output .",
    "the use of the method plotexp ( ) , designed to simulate a single trajectory , is explained in sec .",
    "[ secsample ] .",
    "the method sumexp ( ) , which is very similar to plotexp ( ) , can be used to compute the mean expectation values of operators averaged over many trajectories .",
    "in this section , we illustrate the main features of the class library in a complete example program which can be used as a template .",
    "the example program computes expectation values for a single trajectory of the quantum state diffusion equation ( [ eqqsd ] ) ; to compute means over many trajectories , one simply replaces the call to traj.plotexp ( ) in the template by a call to traj.sumexp ( ) . the system has three degrees of freedom : two nonlinearly coupled field modes described by annihilation operators @xmath104 and @xmath105 , and a spin described by raising and lowering operators @xmath3 and @xmath4 .",
    "the hamiltonian in the interaction picture is @xcite @xmath106 where @xmath107 is the strength of an external pump field , @xmath108 is the strength of the nonlinear interaction , @xmath109 is the detuning between the frequency of the field mode @xmath105 and the spin transition frequency , and @xmath110 is the strength of the coupling of the spin to the field mode @xmath105 .",
    "the lindblad operators @xmath111 describe dissipation of the field modes and the spin with coefficients @xmath112 , @xmath113 , and @xmath114 , respectively .",
    "the trajectory s initial state is the product state @xmath115 .",
    "the integration step - size is dt=0.01 and the total integration time is 500*dt = 5 .",
    "the integration stepper adaptivestep implements a single time step of length dt of the qsd equation  ( [ eqqsd ] ) using the cash - karp runge - kutta algorithm with adaptive time steps @xcite for the deterministic part and first - order euler integration for the stochastic part .    at times that are integer multiples of 50*dt = 0.5 ,",
    "the expectation values of the operators specified in the array outlist are computed and written to the files specified in the array flist .",
    "e.g. , the first element of outlist is the operator @xmath116 . at times",
    "@xmath117 , the method plotexp computes the expectation values @xmath118 and @xmath119 and writes @xmath13 , @xmath120 , @xmath121 , @xmath122 , and @xmath123 to the file x1.out .",
    "in addition , each time a set of expectation values is computed , the program writes 7 numbers to standard output ( see the sample output below ) : the time @xmath13 , 4 expectation values determined by the integer array pipe , the number of basis states used , and the number of adaptive steps taken .",
    "the integers in the array pipe correspond to the columns in the output files containing expectation values ( i.e. , columns 2 through 5 of each output file ) . in the present example , expectation values are computed for the 5 operators @xmath124 , @xmath125 , @xmath105 , @xmath126 , and @xmath127 , which are written to 5 output files with numbered columns 1 through 20 . according to the expression int pipe[]=\\{1,5,13,17 } ,",
    "the expectation values written to standard output are @xmath128 , @xmath129 , @xmath130 , and @xmath131 .",
    "the moving basis is used for both field degrees of freedom .",
    "the basis size is dynamically adjusted with a cutoff probability @xmath132 and a pad size @xmath133 .",
    "the sample output below shows how the basis size changes with time .",
    "initially , @xmath134 states are allocated , but at time @xmath135 , only 18 states are needed .",
    "subsequently , the basis size fluctuates around a typical size of 70 states .",
    "here is the complete program :    .... # include \" complex.h \" # include \" acg.h \" # include \" cmplxran.h \" # include \" state.h \" # include \" operator.h \" # include \" fieldop.h \" # include \" spinop.h \" # include \" traject.h \"    int main ( )   { //",
    "primary operators    annihilationoperator a1(0 ) ;   //",
    "1st freedom    numberoperator n1(0 ) ;    annihilationoperator a2(1 ) ;   //",
    "2nd freedom    numberoperator n2(1 ) ;    sigmaplus sp(2 ) ;              //",
    "3rd freedom    operator sm = sp.hc ( ) ;        //",
    "hermitian conjugate    operator ac1 = a1.hc ( ) ;    operator ac2 = a2.hc ( ) ; // hamiltonian    double e = 20.0 ;               double chi = 0.4 ;          double omega = -0.7 ;           double eta = 0.001 ;    complex i(0.0,1.0 ) ;    operator h = ( e*i)*(ac1-a1 )               + ( 0.5*chi*i)*(ac1*ac1*a2 - a1*a1*ac2 )               + omega*sp*sm + ( eta*i)*(a2*sp - ac2*sm ) ; // lindblad operators    double gamma1 = 1.0 ;           double gamma2 = 1.0 ;           double kappa = 0.1 ;            const int nl = 3 ;    operator l[nl]={sqrt(2*gamma1)*a1,sqrt(2*gamma2)*a2,sqrt(2*kappa)*sm } ; // initial state    state phi1(50,field ) ;        // see section 4.2    state phi2(50,field ) ;",
    "state phi3(2,spin ) ;    state statelist[3 ] = { phi1,phi2,phi3 } ;    state psiini(3,statelist ) ; // trajectory    double dt = 0.01 ;     // basic time step                                int numdts = 50 ;      //",
    "time interval between outputs = numdts*dt      int numsteps = 10 ;    // total integration time = numsteps*numdts*dt    int nofmovingfreedoms",
    "= 2 ;    double epsilon = 0.01 ;      // cutoff probability    int npad = 2 ;               // pad size    acg gen(38388389 ) ;          // random number generator with seed    complexnormal rndm(&gen ) ;   //",
    "complex gaussian random numbers    adaptivestep stepper(psiini , h , nl , l ) ;        // see section 5    trajectory traj(psiini , dt , stepper , & rndm ) ;   // see section 5 // output    const int nofout = 5 ;    operator outlist[nofout]= { sp*a2*sm*sp , sm*sp*a2*sm , a2 , n1 , n2 } ;    char * flist[nofout]={\"x1.out\",\"x2.out\",\"a2.out\",\"n1.out\",\"n2.out \" } ;    int pipe [ ] = { 1 , 5 , 13 , 17 } ;     //",
    "controls standard output //",
    "simulate one trajectory    traj.plotexp ( nofout , outlist , flist , pipe , numdts , numsteps ,                  nofmovingfreedoms , epsilon , npad ) ; } ....    in addition to the output files x1.out , x2.out , a2.out , n1.out , and n2.out , the program writes the following lines to standard output :    .... 0     0             0             0         0       5000     0 0.5   0.000505736   0.000504849 52.3875    3.5807    18    75 1     0.0131402     0.0131173    51.8747   35.1089    60    50 1.5   0.0329714     0.0320222    32.8707   44.3184   108    50 2     0.0425276     0.0455457    32.1562   41.7798    70    56 2.5   0.0284912     0.0564117    34.85     37.8809    80   117 3     0.0260639     0.0626976    33.9828   39.3437    80   143 3.5   0.0544306     0.0439029    51.0632   37.6462    70    99 4     0.0796275    -0.0209383    41.9614   38.0884    70   167 4.5   0.0834672    -0.0543796    33.1194   36.1007    70   195 5    -0.00616844    0.0110794    76.6321   29.4303    50   119 ....",
    "we would like to thank i. c. percival for initiating the project , for pushing us in the right direction , and for invaluable discussions .",
    "we would also like to thank m. rigo for several improvements of the code , and most notably for implementing the quantum jump and orthgonal jump classes .",
    "financial support was provided by the uk epsrc ."
  ],
  "abstract_text": [
    "<S> quantum trajectory methods can be used for a wide range of open quantum systems to solve the master equation by unraveling the density operator evolution into individual stochastic trajectories in hilbert space . </S>",
    "<S> this c++ class library offers a choice of integration algorithms for three important unravelings of the master equation . </S>",
    "<S> different physical systems are modeled by different hamiltonians and environment operators . </S>",
    "<S> the program achieves flexibility and user friendliness , without sacrificing execution speed , through the way it represents operators and states in hilbert space . </S>",
    "<S> primary operators , implemented in the form of simple routines acting on single degrees of freedom , can be used to build up arbitrarily complex operators in product hilbert spaces with arbitrary numbers of components . </S>",
    "<S> standard algebraic notation is used to build operators and to perform arithmetic operations on operators and states . </S>",
    "<S> states can be represented in a local moving basis , often leading to dramatic savings of computing resources . </S>",
    "<S> the state and operator classes are very general and can be used independently of the quantum trajectory algorithms </S>",
    "<S> . only a rudimentary knowledge of c++ is required to use this package .    </S>",
    "<S> # 1#1 | # 1| # 1 # 1#1 </S>"
  ]
}