{
  "article_text": [
    "efforts on developing implementations of nonmonotonic reasoning systems have intensified during the last years and , in particular , implementation techniques for declarative semantics of logic programs ( e.g. , stable model and well - founded semantics ) have considerably advanced . with an increasing number of systems the question of suitable test suites arises .",
    "typical benchmarks used for testing and comparing such systems include problems from graph theory , planning , and constraint satisfaction  @xcite . however , it is still difficult to find benchmark suites of wide industrial relevance .    in this paper",
    "we advocate that _ logical cryptanalysis _ is a good benchmark for nonmonotonic reasoning systems .",
    "logical cryptanalysis has been introduced by massacci and marraro   as a framework for reasoning about cryptographic algorithms .",
    "they pointed out that encoding cryptographic problems as sat problems might be beneficial for the automated reasoning community as it provides a set of problems of industrial relevance which optimally shares features of randomly generated problems and real - world problems .",
    "indeed , the encoding of the us data encryption standard ( des ) into sat proposed in @xcite has a number of useful features :    * it allows to generate random instances of similar structure in practically inexhaustible number ; * it provides solved instances ( for which one solution is known beforehand ) which are very hard , for which we can change the value of the solution , and such that we can generate as many different ( hard ) instances as we want with the same solution ; * it has a lot of structure , and the structure is very common to many similar problems in hardware verification , planning and constraint programming ( all - diff constraints , defined variables , layered definitions etc . ) .",
    "these considerations apply to the encoding of cryptographic problems for nonmonotonic reasoning systems with some further advantages :    * the representation of cryptographic algorithms using normal logic programs with the stable model semantics is extremely simple and easy to understand ; * normal logic programs with the stable model semantics can be seen as an interesting special case for many other more general formalizations of nonmonotonic reasoning .    indeed",
    ", we can provide a natural encoding of des out of the standard specifications  @xcite as a logic program .",
    "massacci and marraro  @xcite have developed a sat - encoding of des where substantial amount of preprocessing and optimizations are employed . as an alternative encoding of des using logic programs",
    "we have upgraded massacci and marraro s optimized sat - encoder to deal directly with logic programs . using these encodings one can perform most of the reasoning tasks suggested in  @xcite .",
    "we examine the efficiency of the encodings by using an implementation of the stable model semantics , the  system  @xcite , for des key search and by comparing the performance to that of sat - solvers which use the optimized encoding of des into sat developed massacci and marraro .",
    "the rest of the paper is organized as follows .",
    "we start by briefly introducing the stable model semantics and by discussing how to encode boolean expressions as logic programs .",
    "we first describe the direct encoding of des to logic programs and then the optimized encoding .",
    "we finish with some experimental results .",
    "the stable model semantics  @xcite generalizes the minimal model semantics of definite programs to normal logic program rules @xmath0 where negative body literals ( @xmath1 ) are allowed . for a ground ( variable - free )",
    "program @xmath2 , the stable models are defined as follows .",
    "the _ reduct _ @xmath3 of a program @xmath2 with respect to a set of atoms @xmath4 is the program obtained from @xmath2 by deleting    1 .",
    "each rule that has a negative literal @xmath5 in its body with @xmath6 and 2 .",
    "all negative literals in the remaining rules .",
    "the reduct @xmath3 can be seen as the set of potentially applicable rules given the stable model @xmath4 , i.e. , as the rules where the negative body literals are satisfied by the model .",
    "note that in the reduct the negative body literals of the potentially applicable rules are removed and , hence , the rules are definite .",
    "the idea is that a stable model should be grounded ( or justified ) in the sense that every atom in the model is a consequence of the potentially applicable rules and every consequence of the potentially applicable rules is included in the model .",
    "the atomic consequences of a set of definite rules can be captured by the unique minimal model , the _ least model _ , of the set seen as definite clauses .",
    "hence , a set of atoms is a stable model of a program if it coincides with the least model of the reduct .",
    "let @xmath2 be a ground program .",
    "then a set of ground atoms @xmath4 is a _ stable model _ of @xmath2 iff @xmath4 is the least model of @xmath3 .",
    "[ ex : smodel : intro ] program @xmath2 @xmath7{l } p \\leftarrow { \\mathrm{not}\\;}q , r\\\\ q \\leftarrow { \\mathrm{not}\\;}p \\\\ r \\leftarrow { \\mathrm{not}\\;}s \\\\ s \\leftarrow { \\mathrm{not}\\;}p \\end{array}\\ ] ] has a stable model @xmath8 because @xmath4 is the least model of @xmath3 .",
    "@xmath9{l } p \\leftarrow r \\\\",
    "r \\leftarrow \\end{array}\\ ] ] in addition to this model , @xmath2 has another stable model @xmath10 which can be verified similarly by constructing the reduct and its least model .",
    "the stable model semantics for programs with variables is obtained from the semantics of ground programs by employing the notion of _ herbrand models_. the stable models of a program with variables are the stable models of the ground instantiation of the program where variables are substituted by terms from the herbrand universe of the program ( the ground terms built from constants and functions in the program ) .    _ integrity constraints _ , i.e. , rules of the form @xmath11 are often useful for saying that a stable model containing @xmath12 but none of @xmath13 is not acceptable . these rules can be encoded using ordinary rules and @xmath14 and a new rule @xmath15 and finally replacing every rule of the form ( [ eq : icrule ] ) with one having @xmath16 as its head . ] .",
    "consider program @xmath2 in example  [ ex : smodel : intro ] extended by two integrity constraints @xmath17 this program has only one stable model @xmath18 as the other stable model of @xmath2 , @xmath10 , does not satisfy the first integrity constraint above .",
    "integrity constraints are a powerful and simple technique for pruning unwanted stable models as they can not introduce new stable models but only can eliminate them .",
    "this means that for a program @xmath2 and a set of integrity constraints @xmath19 , if @xmath4 is a stable model of @xmath20 , then @xmath4 is a stable model of @xmath2 .",
    "des can be seen as a boolean function which takes as input a vector of bits consisting of the plaintext and key and outputting a vector of bits ( the ciphertext ) .",
    "des is specified using standard boolean operators ( negation , disjunction , conjunction , xor ) as well as boolean functions given as truth tables .    in this section",
    "we discuss how to encode such boolean expressions using logic programs . here",
    "the goal is to achieve a compact and potentially computationally efficient coding .",
    "we aim to exploit the special property of the stable model semantics that everything is false unless otherwise stated .",
    "this means that it is enough to consider only the conditions under which an expression is true and let the default negation to handle the other case when the expression is false .",
    "given a boolean expression @xmath21 we provide a logic program @xmath22 such that satisfying truth assignments of @xmath21 and stable models of @xmath22 coincide .",
    "this can be done by introducing a new atom @xmath23 for each subexpression @xmath24 of @xmath21 and , according the intuition mentioned above , by only giving rules stating all conditions on its subexpressions under which @xmath24 is true .",
    "@xmath25{l } p { \\leftarrow}{p_{l_1}},\\ldots,{p_{l_n } }   \\end{array } \\\\",
    "\\hline l_1 \\lor \\cdots\\lor l_n & \\begin{array}[t]{l } p { \\leftarrow}{p_{l_1 } } \\\\ \\vdots   \\\\ p { \\leftarrow}{p_{l_n } }   \\end{array } \\\\",
    "\\hline \\neg l & \\begin{array}[t]{l } p { \\leftarrow}{\\mathrm{not}\\;}{p_{l } } \\\\",
    "\\end{array } \\\\",
    "\\hline l_1 { \\oplus}l_2 & \\begin{array}[t]{l } p { \\leftarrow}{p_{l_1}},{\\mathrm{not}\\;}{p_{l_2 } } \\\\ p { \\leftarrow}{\\mathrm{not}\\;}{p_{l_1 } } , { p_{l_2 } } \\\\ \\end{array } \\\\ \\hline \\end{array } $ ]    in table  [ table : btorules ] we give the corresponding rules for different kinds of subexpressions .",
    "we use the convention that we denote by @xmath26 the corresponding new atom of the subexpression in question and by @xmath27 the new atom introduced for any further subexpression @xmath28 .    as a further optimization ,",
    "note that it is not necessary to introduce a new atom in the program for negated subexpressions @xmath29 as they can be represented as @xmath30 in the program , a positive literal can be represented as such , and an expression @xmath31 as @xmath32.    for the rest of the original propositional atoms , which are not introduced as abbreviations in the original boolean expression , the assumption about the default negation is false because they can have any of the two truth values .",
    "therefore we encode this by introducing a new atom @xmath33 for each atomic subexpression @xmath32 and including two rules @xmath34 stating that either @xmath32 is in the stable model or @xmath33 is in the model ( when @xmath32 is not there ) .    now the satisfying truth assignments of @xmath21 and the stable models @xmath22 correspond in the following sense :    1 .",
    "each stable model @xmath4 of @xmath22 induces a truth assignment @xmath35 where an atom @xmath32 is true in @xmath35 iff @xmath36 and for each subexpression @xmath24 of @xmath21 , @xmath24 is true in @xmath35 iff the corresponding new atom @xmath23 is in @xmath4 .",
    "2 .   each truth assignment @xmath35 induces a stable model @xmath4 of @xmath22 such that for each subexpression @xmath24 of @xmath21 , @xmath24 is true in @xmath35 iff the corresponding new atom @xmath23 is in @xmath4 .    in order to consider stable models corresponding to assignments where @xmath21 is true , one adds to @xmath22 a rule @xmath37    further constraints on boolean ( sub)expressions can be encoded similarly . in order to ensure that a given ( sub)expression @xmath24 is true ( respectively false ) , it is enough to include to @xmath22 the rules @xmath38 where @xmath23 is the new atom corresponding to @xmath24 .",
    "notice that our translation can be seen as first breaking the boolean expression to a set of equivalences where new atoms are defined for each expression and then mapping these equivalence to rules .",
    "[ ex : equivalence ] consider an expression @xmath21 @xmath39 it can be seen as a set of equivalences @xmath40 now the program @xmath22 is @xmath41{l }   p_1 { \\leftarrow}p_2 , p_3 \\\\   p_2 { \\leftarrow}a \\\\   p_2 { \\leftarrow}{\\mathrm{not}\\;}b \\\\   p_3 { \\leftarrow}{\\mathrm{not}\\;}a,{\\mathrm{not}\\;}b \\\\   p_3 { \\leftarrow}a , b",
    "\\\\ \\end{array } \\hspace{4em } \\begin{array}[t]{l } a { \\leftarrow}{\\mathrm{not}\\;}\\hat{a } \\\\",
    "\\hat{a } { \\leftarrow}{\\mathrm{not}\\;}a   \\\\ b { \\leftarrow}{\\mathrm{not}\\;}\\hat{b } \\\\",
    "\\hat{b } { \\leftarrow}{\\mathrm{not}\\;}b    \\end{array}\\ ] ] for instance , the stable model @xmath42 of @xmath22 corresponds to the truth assignment where the atom @xmath32 is true but @xmath43 is false . if we want to have only models where @xmath21 true , it is enough to add to @xmath22 the rule @xmath44 when this is done , the resulting program has two stable models : @xmath45 and @xmath46 .    a boolean function given as a truth table",
    "can be represented using rules by considering a disjunctive normal form representation of the function .",
    "this means that we give the conditions under which the function obtains the value true and provide for each such case a corresponding rule .",
    "[ ex : table ] the function @xmath16 given by the table on the left hand side can be encoded by the rules on its right .",
    "@xmath47{|lll|l| } \\hline x_1 & x_2 & x_3 & f \\\\",
    "\\hline 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 1 \\\\ 0 & 1 & 1 & 0 \\\\ 1 & 0 & 0 & 0 \\\\ 1 & 0 & 1 & 0 \\\\ 1 & 1 & 0 & 1 \\\\ 1 & 1 & 1 & 0 \\\\ \\hline \\end{array } \\hspace{3em } \\begin{array}[c]{l }   f { \\leftarrow}{\\mathrm{not}\\;}x_1 , { \\mathrm{not}\\;}x_2 , { \\mathrm{not}\\;}x_3 \\\\   f { \\leftarrow}{\\mathrm{not}\\;}x_1 ,   x_2 , { \\mathrm{not}\\;}x_3 \\\\   f { \\leftarrow}x_1 ,   x_2 , { \\mathrm{not}\\;}x_3 \\\\ \\end{array}\\ ] ]",
    "for a complete description of des see  @xcite , ( * ? ? ?",
    "* chap.12 ) , or @xcite .",
    "des is a block - cipher and its input is a 64 bit block of _ plaintext _ and a 64 bit _ key _ , where every eighth bit is a parity check bit that is stripped off before the encryption .",
    "so , the actual key - size of des is 56 bits .",
    "this key is used for generating the _ round - keys _ , 48 bit permuted subkeys of the key .",
    "the output is a 64 bit block of _",
    "ciphertext_.        the high level structure of des is presented in figure  [ des : structure](a ) . following figure  [ des : structure](a ) top - down we see that des starts with an initial permutation ip of the 64 bit block of plaintext followed by a structure that is called a _ feistel cipher _ @xcite .    the basic component of a feistel cipher is called a _ round _ and is constituted by the following operations :    1 .",
    "the input of 64 bits is divided into left and right parts ; 2 .",
    "the right half ( 32 bits ) , together with a round - key , is taken as input of a function @xmath16 ( the round function ) , which is described below ; 3 .",
    "the output of @xmath16 is xored with the left half and the result is a new right half ; 4 .",
    "the unaltered old right half becomes the new left half .",
    "these rounds can now be chained together and the complete des contains 16 rounds ( figure  [ des : structure](a ) illustrates three rounds ) .",
    "the strength of des depends on the number of rounds : after 8 rounds a change in an input bit affects all output bits . in the end of des ,",
    "the switching of left and right sides is omitted and the bits are again permuted using the inversion of the initial permutation .    [ [ des - function - f . ] ] des function @xmath16 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    inside the function @xmath16 ( see figure [ des : structure](b ) ) the 32 input bits are first expanded to 48 bits by duplicating some of them .",
    "the expanded bit string is xored with the round - key given by the keyschedule described below .",
    "the resulting bits are input to 8 s - boxes , 6 bits for each box .",
    "the s - boxes are functions of six ( binary ) variables . the output of every s - box consists of 4 bits .",
    "the resulting 32 bits are finally permuted according to permutation p. the content of the boxes was decided at the time des was developed and they are the only non - linear part of des , hence the security of des relies on them .",
    "[ [ keyschedule . ] ] keyschedule .",
    "+ + + + + + + + + + + +    the keyschedule function takes as input the key and provides as out a 48 bit round - key for each round of the feistel cipher .",
    "the des key is a vector of 64 bits , where every 8th bit is a parity bit .",
    "first the parity bits are stripped off , then the keybits are permuted according to the permutation pc-1 .",
    "the result is divided into two parts that are shifted to the left one or two positions recursively , see figure  [ des : structure](c ) .",
    "after each shift the bit string is again permuted ( pc-2 ) in order to produce the round - key .",
    "we develop first a direct encoding of des as a logic program . it does not contain any optimization and the idea is to keep the code simple and readable .",
    "the code can be used for encryption or key search with several plaintext - ciphertext pairs ( the known plaintext attack ) .",
    "the encoding is given as rules with variables .",
    "however , each variable has a domain predicate in the body of the rule so that a set of ground instances with exactly the same stable models is straightforward to determine .",
    "the predicates contain variables @xmath2 indicating a plaintext - ciphertext pair and @xmath48 for round .",
    "the corresponding domain predicates are @xmath49 and @xmath50 which specify the relevant rounds and pairs , respectively . the total number of rounds is denoted by a constant @xmath51 . for instance",
    ", if we are considering a three round version of des with two plaintext - ciphertext pairs , these domain predicates would be defined using the facts : @xmath41{l } round(0 ) \\\\",
    "round(1 ) \\\\ \\end{array } \\;\\;\\;\\ ; \\begin{array}[t]{l } round(2 ) \\\\",
    "round(3 )   \\end{array } \\;\\;\\;\\ ; \\begin{array}[t]{l } pair(1 ) \\\\",
    "pair(2 )   \\end{array}\\ ] ]    we describe first des as used for encryption and then indicate changes needed to be done , e.g. , for key search .",
    "the plaintext is given as facts @xmath52 , where @xmath53 $ ] gives the number of the bit and @xmath2 indicates the pair in question .",
    "note that only facts for true plaintext bits need to be written .",
    "for instance , a set of facts @xmath54 specifies that in the first plaintext - ciphertext pair , the plaintext bits @xmath55 are true and all other false .      the rules which encode the round operations , i.e. , the rules that join the previous round to the next , are summarized in figure  [ fig : round ] .",
    "they work as follows .",
    "@xmath56    for the first round , the 64-bit block of plaintext is first permuted according to the initial - permutation ip which is given as a set of facts @xmath57 using these facts the rule for @xmath58 is easy to express .    for each pair @xmath2 ,",
    "the bits are divided in two 32 bit parts and renumbered .",
    "the renumbering is used only to make the description of the function @xmath16 easier to write and understand and it is done by dividing both halves ( 32 bits ) into 8 groups with each 4 bits .",
    "the bits are numbered so that the first digit represents the group and the second digit represents the bit . for example , bit 32 , is the second bit in the third group .",
    "this renumbering is given as facts : @xmath59 these facts are used in the rules and specifying the right and left parts where the predicate @xmath60 is defined using a set of facts giving the possible renumbered bits @xmath61 .    for each round @xmath62 and each plaintext - ciphertext",
    "pair @xmath2 , the left and right parts @xmath63 and @xmath64 can be defined in terms of the previous parts and the result of the function @xmath16 as follows .",
    "the right side is swapped to the left ( ) and the left side is xored with the output of @xmath16 to form the right side for the next round (  ) .    in the final round the switching of left and right halves",
    "is omitted (  ) but the renumbering is undone and the final permutation (  ) is applied .      for each round @xmath48 and for each pair @xmath2 ,",
    "the function @xmath16 takes as input the 32 bits of the right part of the previous round @xmath65 and a 48 bit round - key @xmath66 and works as follows .",
    "first every group of the right part is expanded from 4 to 6 bits .",
    "for example , the rule @xmath67{ll } e(p,65,n ) { \\leftarrow}&r(p,64,n-1 ) , round(n ) , \\\\ & round(n-1 ) , pair(p ) \\end{array } \\label{eq : expansion}\\ ] ] means that the 4th bit in the 6th group becomes the 5th bit in the 6th group .",
    "the expanded bit string is xored with the key bits : @xmath68 where the predicate @xmath69 is defined using a set of facts giving the possible extended renumbered bits @xmath70 .",
    "the resulting groups of 6 bits are the input of their respective s - boxes . the output of every s - box consists of 4 bits .",
    "if we consider the output one bit at the time , the s - boxes can be seen as truth tables .",
    "for example , if the input to the second s - box is 010101 , it s output is 0001 .",
    "we can encode this behavior with the following rule : @xmath71 once again , with the stable models semantics only rules that imply true output bits are needed ( see , example  [ ex : table ] ) . in this case , the output bits 1 - 3 are zeros , therefore no rules are needed for them . in the end of the des function , the vector of bits is permuted according to the permutation p. the rules for permutation are similar to the ones in expansion .    for each round @xmath48 , the keyschedule is given as a set of rules using the key bit facts @xmath72 .",
    "for example , the rule @xmath73 specifies that in the first round the ( renumbered ) bit 11 of the round - key is determined by the key bit 10 .",
    "the stages presented in figure [ des : structure](c ) and the renumbering is calculated beforehand in order to avoid some modulo arithmetic .",
    "this can be done because the keyschedule is independent of the plaintext to be used .",
    "the encoding can be easily modified to solve many kinds of computational problems related to des by changing the way the plaintext , ciphertext and the key are encoded .",
    "encryption : : :    it is sufficient to give the true bits @xmath74 of the    plaintext as facts @xmath52 for each pair @xmath2    and the true bits of the key as facts @xmath72 . now for    each pair @xmath2 , the true bits of the encrypted ciphertext    can be recovered as ground facts @xmath75 in the    unique stable model of the encoding with the plaintext and key facts .",
    "decryption : : :    the true bits of the key are specified as facts @xmath72 ,    the ciphertext is given in the form @xmath76 and the plaintext by the rules of the form    ( [ eq : choice ] ) saying that one can choose the truth values of the    ground atoms @xmath52 .",
    "then the decrypted plaintext is    given by the stable model of the encoding : for each true bit of the    plaintext a ground fact @xmath52 is in the model .",
    "+    actually , des is symmetric .",
    "this means that decryption is usually done    the same way as encryption , using the key schedule in reverse order    and the ciphertext in place of the plaintext .",
    "known plaintext attack : : :    for this attack we assume that a certain number of pairs of plaintexts    and the corresponding ciphertexts are available and that we want to    recover the key . for each pair",
    "@xmath2 , the true bits    @xmath74 of the plaintext are given as facts    @xmath52 , the ciphertext is given in the form    @xmath76 and the key is given by rules of the form ( [ eq : choice ] )    @xmath77    specifying that the truth values of the ground atoms    @xmath78 corresponding to the key bits can be chosen . then    the stable models of the resulting encoding correspond to the possible    keys yielding the ciphertext from the plaintext for each pair    @xmath2 .",
    "a key is given as ground facts @xmath72    in the corresponding stable model for all true key bits .",
    "massacci and marraro  @xcite have devised an optimized encoding of des to sat which is particularly effective when the plaintext and the ciphertext are used in a known plaintext attack .",
    "we show how to modify this to work with logic programs .",
    "we sketch here just the main ideas to make the paper self - contained and refer to @xcite for further details on the encoding .    the basic idea of the direct encoding is to represent each step of des as a logic program , the more straightforward , the better . for the optimized encoding",
    "we start from a different direction and represent des as a logical circuit in which each operation is represented as a boolean formula .",
    "then , for the operations that are repeated at each round ( such as the round function @xmath16 ) we apply off - line some advanced cad minimization techniques to squeeze their size as much as possible . in particular in @xcite the cad program espresso",
    "@xcite has been used for minimizing the representation of s - boxes as programmable logic arrays ( plas ) .",
    "the pla representation is just a representation of boolean functions with disjunctions of conjunctions .",
    "this yields a notable squeeze in the size of the boolean formulae representing the corresponding operations of the s - boxes but is not enough .",
    "the second important twist is that whenever possible , the program `` executes '' directly the des operations on the propositional variables representing the input bits .",
    "for instance , a permutation is not encoded into a boolean formula , rather the program executes the permutation of the input bits and provides as output the permuted propositional variables .",
    "the simplifying effect of this operation can be also explained as a form of partial evaluation in the direct encoding of des .",
    "consider , for instance , the logic program rule ( [ eq : expansion ] ) .",
    "the net effect of the `` execution '' step is that @xmath79 is replaced everywhere by @xmath80 .    at the end of this process the encoder program def2fml used in @xcite",
    "could output a minimized logic program corresponding to des w.r.t .",
    "the direct encoding that we have described in the previous section using the rules we have given in the section on coding boolean formulae .",
    "we can do more when the plaintext and the ciphertext are known , i.e.  when we want to perform a known plaintext attack .",
    "in particular , with a boolean representation we can perform a notable amount of linear reasoning ( reasoning using formulae with exclusive or ) . in @xcite",
    "it is noted that the presence of exclusive or is what makes the problem hard for state - of - the - art sat checkers and therefore its minimization is essential .",
    "so , for the encoding we acquire the boolean values corresponding to plaintext and ciphertext and preprocess the formula by applying exhaustively a set of simplification rules aimed at eliminating redundancies :    1 .",
    "variables defined by atomic equivalences where @xmath81 is a variable and @xmath82 is either another variable or a truth value . ]",
    "are replaced by the corresponding values to reduce the number of variables in other formulae , and to introduce the truth values .",
    "2 .   the propositional simplification rules listed in figure  [ fig : valprop ] are applied .",
    "the second step ( propositional simplification ) may introduce additional atomic equivalences and therefore the overall simplification phase is repeated until saturation is reached .",
    "l    [ cols=\"<,<\",options=\"header \" , ]     notice that such preprocessing , and in particular the operations involving exclusive or , can not be performed with a logic program representation ( at least with current technology ) .",
    "the resulting formula is then translated into a logic program using a further optimized translation w.r.t .",
    "that presented in the section on boolean encoding .",
    "we can exploit the knowledge that the final formula we got has the form shown in figure  [ fig : encod : preprocess ] ( adapted from @xcite ) and translate it as shown in figure  [ fig : encod : translate ] .",
    "the variables @xmath2 and @xmath48 stand for the number of pair and rounds , according the format of the direct encoding .",
    "the letter @xmath43 corresponds to a suitable ground value of the bit number represented by the variable @xmath74 used in the direct encoding .",
    "notice that the final output is a ground logic program so that @xmath48 and @xmath2 are appropriately instantiated by the optimizing encoder .",
    "@xmath83    @xmath84{@{}l@ { } } r(p , b,3 )   { \\leftarrow}\\pm s(p , b',1 ) , { \\mathrm{not}\\;}s(p , b'',3 )   \\\\",
    "r(p , b,3 )   { \\leftarrow}{\\mathrm{not}\\;}\\pm s(p , b',1 ) , s(p , b'',3 )   \\\\",
    "r(p , b,4 )   { \\leftarrow}\\pm s(p , b',2 ) , { \\mathrm{not}\\;}s(p , b'',4 )   \\\\",
    "r(p , b,4 )   { \\leftarrow}\\pm { \\mathrm{not}\\;}s(p , b',2 ) , s(p , b'',4 )   \\\\",
    "r(p , b , n )   { \\leftarrow}r(p , b',n-2 ) , { \\mathrm{not}\\;}s(p , b'',n ) , 5\\leq n\\leq r-4   \\\\",
    "r(p , b , n )   { \\leftarrow}{\\mathrm{not}\\;}r(p , b',n-2 ) , s(p , b'',n ) , 5\\leq n \\leq r-4   \\\\",
    "s(p , b , n ) { \\leftarrow}m(p , b',n ) , 1\\leq n\\leq r \\mbox { and } 1\\leq b'\\leq n_n    \\\\",
    "s(p , b , r-1 ) { \\leftarrow}\\pm r(p , b',r-5 ) , { \\mathrm{not}\\;}s(p , b'',r-3 ) \\\\",
    "s(p , b , r-1 ) { \\leftarrow}{\\mathrm{not}\\;}\\pm r(p , b',r-5 ) , s(p , b'',r-3 )   \\\\",
    "s(p , b , r ) { \\leftarrow}\\pm r(p , b',r-4 ) , { \\mathrm{not}\\;}s(p , b'',r-2 )   \\\\",
    "s(p , b , r ) { \\leftarrow}{\\mathrm{not}\\;}\\pm r(p , b'',r-4 ) , s(p , b'',r-2 )   \\\\",
    "m(p , b,1 ) { \\leftarrow}\\pm k(b',1 ) , \\ldots \\pm k(b'',1 )   \\\\",
    "m(p , b , n ) { \\leftarrow}x(p , b',n)_1 , \\ldots , x(p , b'',n)_{n_n } , 2\\leq n \\leq r-1   \\\\ m(p , b , r ) { \\leftarrow}\\pm k(b',r ) , \\ldots \\pm k(b'',r )   \\\\ \\end{array } \\begin{array}[t]{@{}l@ { } } x(p , b,2 )   { \\leftarrow}\\pm s(p , b',1 ) , { \\mathrm{not}\\;}k(b'',2 ) \\\\",
    "x(p , b,2 )   { \\leftarrow}\\pm { \\mathrm{not}\\;}s(p , b',1 ) , k(b'',2 ) \\\\ x(p , b,3 )   { \\leftarrow}\\pm s(p , b',2 ) , { \\mathrm{not}\\;}k(b'',3 ) \\\\",
    "x(p , b,3 )   { \\leftarrow}\\pm { \\mathrm{not}\\;}s(p , b',2 ) , k(b'',3 ) \\\\",
    "x(p , b , n )   { \\leftarrow}r(p , b',n-1 ) , { \\mathrm{not}\\;}k(b'',n ) , 4\\leq n\\leq r-3   \\\\",
    "x(p , b , n )   { \\leftarrow}{\\mathrm{not}\\;}r(p , b',n-1 ) , k(b'',n ) , 4\\leq n \\leq r-3   \\\\",
    "x(p , b , r-2 )   { \\leftarrow}\\pm s(p , b',r-1 ) , { \\mathrm{not}\\;}k(b'',r-1 )   \\\\",
    "x(p , b , r-2 )   { \\leftarrow}\\pm { \\mathrm{not}\\;}s(p , b',r-1 ) , k(b'',r-1 )   \\\\",
    "x(p , b , r-1 )   { \\leftarrow}\\pm s(p , b',r ) , { \\mathrm{not}\\;}k(b'',r ) \\\\",
    "x(p , b , r-1 )   { \\leftarrow}\\pm { \\mathrm{not}\\;}s(p , b',r ) , k(b'',r ) \\end{array } $ ]    notice that the translation of the formula is done piecewise : each equivalence is translated in a suitable number of rules : we use one rule for conjunctions , two rules for xors , and many rules of disjunctions ( as many as there are disjuncts ) .",
    "the trick is that we only encode one direction of the the equivalence exploiting the property of logic programs that `` everything is false by default '' . in this way we have only to specify when a boolean formula may be true .",
    "however , this is still not sufficient because the translation as sketched is not faithful : we might have more than one `` definition '' of the same atom , i.e. one or more formulae of the form @xmath85 for the same atom @xmath86 .",
    "if we left it that way , there would not be a one - one correspondence between stable models and propositional truth assignments .",
    "we would have more models than due .",
    "so we need a further twist to cope with atoms that are defined ( are on the left of the equivalence sign in figure  [ fig : encod : preprocess ] ) two or more times .",
    "suppose that we have a set of formulae of the form : @xmath87 and that denotes the fragment of the logic program translating the boolean formula @xmath88 according the rules we have used in table  [ table : btorules ] and figure  [ fig : encod : translate ] .",
    "we translate this set of formulae as follows : @xmath41{l@{\\hspace{4ex}}l } \\mbox{boolean formula } & \\mbox{logic program } \\\\[1ex ] a { \\leftrightarrow}\\varphi_1 &   \\translate{a { \\leftrightarrow}\\varphi_1 } \\\\[1ex ] a { \\leftrightarrow}\\varphi_2 & a { \\leftarrow}a_2 \\\\                 & { \\leftarrow}a,{\\mathrm{not}\\;}a_2\\\\                 & \\translate{a_2 { \\leftrightarrow}\\varphi_2 } \\\\ \\vdots          & \\vdots \\\\ a { \\leftrightarrow}\\varphi_n & a { \\leftarrow}a_n \\\\                 & { \\leftarrow}a,{\\mathrm{not}\\;}a_n\\\\                 & \\translate{a_n { \\leftrightarrow}\\varphi_n } \\end{array}\\ ] ] one may check that this is a faithful translation of the corresponding boolean formulae .",
    "the intuitive explanation is simply that the boolean set of formulae , read conjunctively , just says that all @xmath89 must have the same value and this value must also be assigned to @xmath32 .",
    "the first rule chooses a value , say @xmath90 and assign it to @xmath32 as in the standard encoding .",
    "the rest of the construction assigns the value of @xmath89 to a new atom @xmath91 and then specifies that @xmath32 is true when @xmath91 is true and that @xmath91 can not be false when @xmath32 is true",
    ".    then we add the rules ( [ eq : choice ] ) saying that one can choose the truth values of the atoms corresponding to key bits , as we do for the direct encoding , and we are done .",
    "we study the computational properties of the two logic program encodings of des by using them for key search in a known plaintext attack for a limited form of des running a given number of rounds .",
    "for each number of rounds and pairs of plaintext - ciphertext blocks we perform 50 key searches using different randomly generated plaintexts and report the mean of the running time and of the size of the search tree .",
    "the tests were run under linux 2.2.12 on 450 mhz pentium iii computers .",
    "the encodings and test cases are available at ` http://www.tcs.hut.fi/software/smodels/tests/des.html ` .",
    "table  [ table : smodels ] reports the data on s performance .",
    "the running times do not include preprocessing .",
    "for the direct encoding ( dir . )  preprocessing consists of parsing and grounding of the rules which is done by the standard  parser ` lparse ` .",
    "this takes only few seconds even for the largest examples . for the optimized encoding ( opt . )",
    "preprocessing is more involved as explained in the previous section .",
    "it includes off - line minimization of boolean functions used in des , partial evaluating the des description , simplifying it using the known plaintexts - ciphertext pairs , transforming the resulting boolean formula to a set of ground logic program rules as well as parsing the rules into the internal format of ` smodels ` .",
    "hence , in both cases preprocessing produces a ground program parsed into the internal format of ` smodels ` .",
    "table  [ table : smodels ] gives the average running time and search space size for ` smodels `  ( version 2.25 with ` -backjump ` option ) to find a stable model ( a key ) for such a ground program .",
    "entries marked with  are cases where the set of 50 key searches could not be completed because the running time for each key search extended several cpu hours .",
    "both encodings have a reasonable performance ( although it should be noted that special purpose methods and hardware are able to perform known plaintext attacks successfully even to the full des ) .",
    "the direct encoding does not seem to be able to propagate the information from the known plaintext - ciphertext pairs as efficiently as the preprocessing techniques in the optimized encoding .",
    "the search heuristics of ` smodels `  yields a rather stable performance on these des examples except for the optimized encoding with three rounds and two blocks where there are three orders of magnitude differences in the minimal and maximal observed running times and search space sizes .",
    "we compare the performance of  to that of a sat - checker which has been customized and tuned for the optimized sat - encoding of des described in @xcite .",
    "this sat - checker , based on  by bayardo and schrag , clearly outperforms state - of - the - art sat - checkers on des encodings  @xcite .",
    "table  [ table : relsat ] reports the data on",
    ". the data does not include preprocessing which in this case is similar to that of the optimized logic program encoding with the addition that it includes also the transformation of the optimized des description ( a boolean formula ) to a compact conjunctive normal form ( cnf ) representation .",
    "table  [ table : relsat ] presents the average running time and search space size for  to find a propositional model ( a key ) for this cnf formula .    from this preliminary analysis",
    "one can say that the usage of stable models as computational paradigm to be used in practice does not score at all badly for such an industrial application .",
    "rounds & blocks & & + & & ( dir . ) & ( opt . ) & ( dir . ) & ( opt . )",
    "+ 1 & 1 & 0.3 & 0.07 & 155 & 28 + 1 & 2 & 1.6 & 0.06 & 372 & 18 + 1 & 4 & 2.2 & 0.1 & 179 & 16 + 1 & 8 & 5.8 & 0.2 & 200 & 16 + 2 & 1 & 1.2 & 0.1 & 151 & 9 + 2 & 2 & 1.7 & 0.1 & 98 & 8 + 2 & 4 & 2.0 & 0.2 & 51 & 8 + 2 & 8 & 3.6 & 0.4 & 39 & 8 + 3 & 1 &  & 230 &  & 699 + 3 & 2 & 640 & 8900 & 20672 & 6000 + 3 & 4 & 1400 & 190 & 14709 & 29 + 3 & 8 & 3500 & 48 & 18612 & 8 +     rounds & blocks & time ( s ) & branches + 1 & 1 & 0.02 & 32 + 1 & 2 & 0.1 & 100 + 1 & 4 & 0.2 & 107 + 1 & 8 & 0.4 & 87 + 2 & 1 & 0.2 & 283 + 2 & 2 & 0.2 & 106 + 2 & 4 & 0.3 & 70 + 2 & 8 & 0.7 & 56 + 3 & 1 &  &  + 3 & 2 & 920 & 141291 + 3 & 4 & 110 & 14419 + 3 & 8 & 100 & 5483 +",
    "we believe that des provides an interesting benchmark problem for nonmonotonic reasoning systems because ( i )  it supplies practically inexhaustible number of industrial relevant test cases , ( ii )  the encoding of des using normal logic programs with the stable model semantics is easy to understand , and ( iii )  test cases are obtained for many nonmonotonic formalisms which contain this subclass of logic programs as a special case .",
    "we have developed a direct encoding and an optimized one extending the work of massacci and marraro .",
    "we have also tested the computational performance of the encodings using the  system .",
    "as des is basically a boolean function , its encoding does not require any particular nonmonotonic constructs .",
    "in our encoding we have used default negation in a straightforward way ( everything is false unless otherwise stated ) , to obtain a much leaner encoding than those obtained by encoding des as a sat formula ( where both ways of the equivalence are needed ) .",
    "the resulting encodings are acyclic sets of rules which are compact but fairly simple to write and understand .",
    "it seems that they are more easier to understand than corresponding encodings of des using cnf clauses which is the typical input format for current state - of - the - art sat - checkers .",
    "given that des key search is a natural boolean satisfiability problem , it is somewhat surprising that our encodings are competitive when compared to state - of - the - art sat - checkers and even to a tuned and customized sat - checker working on an optimized sat - encoding of des . we think that the success can be accounted for by the compactness of the logic program encoding and the search methods and pruning techniques employed in the  system .    in order to obtain a deeper understanding of the relative strengths of sat - checkers and stable model implementations",
    ", an interesting comparison would be to map the stable model finding problem of des key search directly to a satisfiability problem and use a state - of - the - art sat - checker to solve the resulting problem .",
    "as our encodings are acyclic programs , the reduction could be done using , e.g. , a completion approach  @xcite .",
    "massacci , f. 1999 . using walk - sat and look - back csp for cryptographic key search . in _ proc .   of the 16th international joint conference on artificial intelligence _ , 290295 .",
    "morgan kaufmann publishers .",
    "niemel , i. , and simons , p. 1997 .",
    "smodels  an implementation of the stable model and well - founded semantics for normal logic programs . in _ proc .   of the 4th international conference on logic programming and non - monotonic reasoning _ , 420429 .",
    "dagstuhl , germany : springer - verlag ."
  ],
  "abstract_text": [
    "<S> the us data encryption standard , des for short , is put forward as an interesting benchmark problem for nonmonotonic reasoning systems because ( i ) it provides a set of test cases of industrial relevance which shares features of randomly generated problems and real - world problems , ( ii ) the representation of des using normal logic programs with the stable model semantics is simple and easy to understand , and ( iii ) this subclass of logic programs can be seen as an interesting special case for many other formalizations of nonmonotonic reasoning . in this paper </S>",
    "<S> we present two encodings of des as logic programs : a direct one out of the standard specifications and an optimized one extending the work of massacci and marraro . </S>",
    "<S> the computational properties of the encodings are studied by using them for des key search with the  system as the implementation of the stable model semantics . </S>",
    "<S> results indicate that the encodings and  are quite competitive : they outperform state - of - the - art sat - checkers working with an optimized encoding of des into sat and are comparable with a sat - checker that is customized and tuned for the optimized sat encoding . </S>"
  ]
}