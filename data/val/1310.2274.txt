{
  "article_text": [
    "reinsurance companies who insure primary insurance companies against losses caused by catastrophes , such as earthquakes , hurricanes and floods , must quantify the risk related to large portfolios of risk transfer treaties .",
    "in reinsurance a portfolio represents complex insurance contracts covering properties against losses due catastrophes , and contracts include per - occurrence excess of loss ( xl ) , catastrophe xl and aggregate xl treaties .",
    "aggregate risk analysis is performed on portfolios to compute risk measures including probable maximum loss ( pml ) @xcite and the tail value - at - risk ( tvar ) @xcite . such an analysis is central to treaty pricing and portfolio / solvency applications .",
    "the analysis may involve simulations of over one million trials in which each trial consists of one thousand catastrophic events each of which may impact tens of thousands to millions of individual properties , for example buildings .",
    "not only is the analysis computationally intensive but also data intensive , and therefore the application of high performance computing ( hpc ) techniques is desirable .",
    "the analysis can be run weekly , monthly or quarterly on production systems based on the requirement for updating the portfolio .",
    "for example , based on the fluctuation of currency rates an entire portfolio a weekly update can be performed which requires more than twenty four hours .",
    "often times it is not sufficient to run routine analysis but requires ad hoc analysis .",
    "for example , consider a real - time pricing scenario in which an underwriter can evaluate different contractual terms and pricing while discussing with a client over a telephone .",
    "this can not be accommodated on production system that is committed to routine analysis and the response required for real - time can not be achieved on these systems .",
    "hence , achieving significant speed up using high - performance computing techniques in risk analysis is desirable .    in our previous work @xcite",
    ", we explored the design and implementation of a parallel aggregate risk analysis algorithm which was significantly faster than previous sequential solutions .",
    "however , it was limited for its use in portfolio wide risk analysis scenarios since the algorithm could only account for _ primary uncertainty _ - the uncertainty whether a catastrophic event occurs or not in a simulated year .",
    "it was not able to account for _ secondary uncertainty _ , the uncertainty in the amount of loss incurred when the event occurs . in this",
    "paper , secondary uncertainty is taken into account whereby loss distributions flow through the simulation rather than mean loss values due to an event .    in practice",
    "there are many sources of secondary uncertainty in catastrophic risk modelling .",
    "for example , the exposure data which describes the buildings , their locations , and construction types may be incomplete , lacking sufficient detail , or may just be inaccurate .",
    "also physical modelling of hazard , for example an earthquake , may naturally generate a distribution of hazard intensity values due to uncertainty in energy attenuation functions used or in driving data such as soil type .",
    "lastly , building vulnerability functions are simplifications of complex physical phenomenon and are therefore much better at producing loss distributions than accurate point estimates .",
    "an aggregate risk analysis algorithm that accounts only for primary uncertainty uses only mean loss values and fails to account for what is known about the loss distribution .",
    "therefore , aggregate analysis needs to take both primary and secondary uncertainty into account by considering event loss distributions represented by the event occurrence probability , mean loss , and independent and correlated standard deviations .",
    "this captures a wide range of possible outcomes .",
    "the research reported in this paper proposes an aggregate risk analysis algorithm capable of capturing both primary and secondary uncertainty .",
    "the algorithm is designed to run efficiently on both multi - core cpus and many - core gpus .",
    "a distribution of losses is used in the simulation rather than just mean loss values and efficient statistical operations , such as cumulative distribution functions and quantiles of the normal and beta distributions need to be performed . a significant challenge to not only balance the workload across threads performing fixed time operations ( for example , addition operation ) , but also to balance the workload when individual numerical operations require variable time ( for example , computations in iterative methods ) for achieving effective parallelism is addressed .",
    "the implementation and optimization of the algorithm for multi and many core architectures is presented along with experimental evaluation .",
    "since performance of the algorithm is dependent on the underlying statistical operations , four different statistical libraries were explored for use on the gpu and an additional three statistical libraries for use on the cpu .",
    "a parallel simulation of 800,000 trials with 1,000 catastrophic events per trial on an exposure set and on a contract structure taking secondary uncertainty exhibits a speedup of 24x over the sequential implementation on the cpu .",
    "the remainder of this paper is organized as follows .",
    "section [ finegrainanalytics ] proposes an algorithmic framework for performing aggregate risk analysis with primary and secondary uncertainty .",
    "section [ secondaryuncertainty ] presents how secondary uncertainty is applied within the inner loop of the risk analysis algorithm .",
    "section [ implementation ] describes the implementation of the proposed algorithm on the gpu platform .",
    "section [ results ] highlights the results obtained from experimental evaluation .",
    "section [ conclusion ] concludes the paper by considering future work .",
    "stochastic monte carlo simulations are required for portfolio risk management and contract pricing .",
    "such a simulation in which each trial of the simulation represents a distinct view of which catastrophic events occur and in what order they occur in a contractual year is referred to as aggregate risk analysis @xcite .",
    "one merit of performing such an analysis is that millions of alternative views of a single contractual year can be obtained .",
    "this section considers the inputs required for performing aggregate risk analysis , proposes an algorithm for aggregate risk analysis , considers the financial terms employed in the algorithms , and presents the output of the analysis .",
    "three data tables are input to aggregate risk analysis .",
    "the first table is the year event table ( yet ) , denoted as @xmath0 , which is a database of pre - simulated occurrences of catastrophic events from a catalogue of stochastic events .",
    "each record in a yet called a `` trial '' , denoted as @xmath1 , represents a possible sequence of event occurrences for any given year .",
    "the sequence of events is defined by an ordered set of tuples containing the i d of an event and the time - stamp of its occurrence in that trial @xmath2    the set is ordered by ascending time - stamp values .",
    "program - and - event - occurrence - specific random number , @xmath3 is considered in section [ secondaryuncertainty ] .",
    "a typical yet may comprise thousands to a million trials , and each trial may have approximately between 800 to 1500 ` event time - stamp ' pairs , based on a global event catalogue covering multiple perils .",
    "the yet can be represented as @xmath4    where @xmath5 and @xmath6 .",
    "the second table is the extended event loss tables , denoted as @xmath7 , which represents a collection of specific events and their corresponding losses with respect to an exposure set . in addition , a few parameters , namely the event - occurrence - specific random number ( @xmath8 ) , the independent standard deviation of loss ( @xmath9 ) , the correlated standard deviation of loss ( @xmath10 ) , and the maximum expected loss ( @xmath11 ) are represented within the @xmath7 .",
    "the loss associated with an event @xmath12 is represented as @xmath13 is required for the analysis with secondary uncertainty . applying secondary uncertainty using the xelt",
    "is presented in section [ secondaryuncertainty ] .",
    "each record in an xelt is denoted as ` extended ' event loss @xmath14 and the financial terms associated with the xelt are represented as a tuple @xmath15    a typical aggregate analysis may comprise 10,000 xelts , each containing 10,000 - 30,000 extended event losses with exceptions even up to 2,000,000 extended event losses .",
    "the xelts can be represented as @xmath16    with @xmath17 .",
    "the third table is the portfolio , denoted as @xmath18 , which contains a group of programs , denoted as @xmath19 and represented as @xmath20    with @xmath21 .",
    "each program in turn covers a set of layers , denoted as @xmath22 , which covers a collection of xelts under a set of layer terms . a single layer @xmath23 is composed of two attributes .",
    "firstly , the set of xelts @xmath24 and secondly , the layer terms , denoted as @xmath25    a typical layer covers approximately 3 to 30 individual xelts .",
    "the layer can be represented as @xmath26    with @xmath27 .",
    "the basic algorithm ( line no . 1 - 17 shown in algorithm [ algorithm1 ] ) for aggregate analysis has two stages . in the first stage ,",
    "data is loaded into local memory what is referred to as the preprocessing stage in this paper . in this stage @xmath0 , @xmath7 and @xmath18 , are loaded into memory .",
    "populate @xmath28 using @xmath29    in the second stage , the four step simulation executed for each layer and for each trial in the yet is performed as shown below and the resulting year loss table ( @xmath28 ) is produced .",
    "in the first step shown in line no . 6 in which each event of a trial and its corresponding event loss in the set of xelts associated with the layer are determined . in the second step shown in line nos . 7 - 9 ,",
    "secondary uncertainty is applied to each loss value of the event - loss pair extracted from an xelt .",
    "a set of contractual financial terms are then applied to the benefit of the layer . for this the losses for a specific event s net of financial terms @xmath30 are accumulated across all xelts into a single event loss shown in line no .",
    "9 . in the third step in line",
    "11 the event loss for each event occurrence in the trial , combined across all xelts associated with the layer , is subject to occurrence terms . in the fourth step in line no .",
    "12 aggregate terms are applied .",
    "the next sub - section will consider how the financial terms are applied .",
    "the financial terms applied on the loss values combined across all xelts associated with the layer are occurrence and aggregate terms .",
    "two occurrence terms , namely ( i ) occurrence retention , denoted as @xmath31 , which is the retention or deductible of the insured for an individual occurrence loss , and ( ii ) occurrence limit , denoted as @xmath32 , which is the limit or coverage the insurer will pay for occurrence losses in excess of the retention are applied .",
    "occurrence terms are applicable to individual event occurrences independent of any other occurrences in the trial .",
    "the occurrence terms capture specific contractual properties of excess of loss treaties as they apply to individual event occurrences only . the event losses net of occurrence terms",
    "are then accumulated into a single aggregate loss for the given trial .",
    "the occurrence terms are applied as @xmath33 .",
    "two aggregate terms , namely ( i ) aggregate retention , denoted as @xmath34 , which is the retention or deductible of the insured for an annual cumulative loss , and ( ii ) aggregate limit , denoted as @xmath35 , which is the limit or coverage the insurer will pay for annual cumulative losses in excess of the aggregate retention are applied .",
    "aggregate terms are applied to the trial s aggregate loss for a layer .",
    "unlike occurrence terms , aggregate terms are applied to the cumulative sum of occurrence losses within a trial and thus the result depends on the sequence of prior events in the trial .",
    "this behaviour captures contractual properties as they apply to multiple event occurrences .",
    "the aggregate loss net of the aggregate terms is referred to as the trial loss or the year loss .",
    "the aggregate terms are applied as @xmath36 .",
    "the output of the algorithm for performing aggregate risk analysis with primary and secondary uncertainty is a loss value associated with each trial of the yet .",
    "a reinsurer can derive important portfolio risk metrics such as the probable maximum loss ( pml ) and the tail value - at - risk ( tvar ) which are used for both internal risk management and reporting to regulators and rating agencies .",
    "furthermore , these metrics flow into a final stage of the risk analytics pipeline , namely enterprise risk management , where liability , asset , and other forms of risks are combined and correlated to generate an enterprise wide view of risk .",
    "additional functions can be used to generate reports that will aid actuaries and decision makers .",
    "for example , reports presenting return period losses ( rpl ) by line of business ( lob ) , class of business ( cob ) or type of participation ( top ) .",
    "further , the output of the analysis can be used for estimating region / peril losses and for performing multi - marginal analysis and stochastic exceedance probability ( step ) analysis .",
    "the methodology to compute secondary uncertainty heavily draws on industry - wide practices .",
    "the inputs required for the secondary uncertainty method and the sequence of steps for applying uncertainty to estimate a loss are considered in this section .",
    "six inputs are required for computing secondary uncertainty which are obtained from the year event table ( yet ) and the ` extended elt ' ( xelt ) .",
    "the first input is @xmath37 referred to as the program - and - event - occurrence - specific random number .",
    "each event occurrence across different programs have different random numbers .",
    "the second input is @xmath38 referred to as the event - occurrence - specific random number .",
    "each event occurrence across different programs have the same random number .",
    "the third input is @xmath13 referred to as the mean loss .",
    "the fourth input is @xmath9 referred to as the independent standard deviation of loss and represents the variance within the event - loss distribution .",
    "the fifth input is @xmath10 referred to as the correlated standard deviation of loss and represents the error of the event - occurrence dependencies .",
    "the sixth input is @xmath11 referred to as the maximum expected loss .      given the above inputs , the independent and correlated standard deviations need to be combined to reduce the error in estimating the loss value associated with an event .",
    "this is done in a sequence of five steps . in the first step , the raw standard deviation",
    "is produced as @xmath39 .    in the second step ,",
    "the probabilities of occurrences , @xmath40 and @xmath8 are transformed from uniform distribution to normal distribution using @xmath41 this is applied to the probabilities of event occurrences as @xmath42    in the third step , the linear combination of the transformed probabilities of event occurrences and the standard deviations is computed as @xmath43    in the fourth step , the normal random variable is computed as @xmath44    in the fifth step , the normal random variable is transformed from normal distribution to uniform distribution as @xmath45    the model used above for combining the independent and correlated standard deviations represents two extreme cases . the first case in which @xmath46 and the second case in which @xmath47 .",
    "the model also ensures that the final random number , @xmath48 , is based on both the independent and correlated standard deviations .",
    "the loss is estimated using the beta distribution since fitting such a distribution allows the representation of risks quite accurately .",
    "the beta distribution is a two parameter distribution , with an upper bound for the standard deviation .",
    "the standard deviation , mean , alpha and beta are defined as @xmath49    an upper bound is set to limit the standard deviation using @xmath50 , if @xmath51 , then @xmath52 . in the algorithm reported in this paper , for numerical purpose a value very close to @xmath53",
    "is chosen .    to obtain the loss after applying secondary uncertainty beta distribution functions",
    "are used as follows @xmath54",
    "in this section , the hardware platforms used for the experimental studies are firstly considered , followed by the implementation of the data structures required for aggregate risk analysis with uncertainty and the implementation of the methods for computing secondary uncertainty .",
    "optimizations incorporated in the implementations are further considered .",
    "two hardware platforms are used for implementing a sequential and parallel aggregate risk analysis algorithm .",
    "firstly , a multi - core cpu is employed whose specifications are a 3.40 ghz quad - core intel(r ) core ( tm ) i7 - 2600 processor with 16.0 gb of ram .",
    "the processor has 256 kb l2 cache per core , 8 mb l3 cache and maximum memory bandwidth of 21 gb / sec . the processor supports hyperthreading on the physical cores making eight virtual cores available .",
    "the experiments consider virtual cores as hyperthreading is beneficial for data intensive applications .",
    "both sequential and parallel versions of the aggregate risk analysis algorithm were implemented on this platform .",
    "the sequential version was implemented in c++ , while the parallel version was implemented in c++ and openmp .",
    "both versions were compiled using the gnu compiler collection g++ 4.7 using `` -o3 ` ' and `` -fopenmp ` ' when openmp is used .",
    "secondly , an nvidia tesla c2075 gpu , consisting of 448 processor cores ( organized as 14 streaming multi - processors each with 32 symmetric multi - processors ) , each with a frequency of 1.15 ghz , a global memory of 5.375 gb and a memory bandwidth of 144 gb / sec was employed in the gpu implementations of the aggregate risk analysis algorithm .",
    "the peak double precision floating point performance is 515 gflops whereas the peak single precision floating point performance is 1.03 tflops .",
    "the implementation of the algorithm is compiled using the nvidia cuda compiler ( nvcc ) , version 5.0 .",
    "the following implementations for aggregate risk analysis with uncertainty are considered in this paper : ( i ) a sequential implementation on the cpu , ( ii ) a parallel implementation on the multi - cores of the cpu , and ( iii ) a parallel implementation on the many - cores of the gpu .",
    "four libraries are used for applying secondary uncertainty on the many - core gpu and four additional libraries on the multi - core cpu .      in aggregate risk analysis ,",
    "the losses of events in a trial need to be determined by looking up losses in the xelt .",
    "the key design question is whether the data structure containing the event - loss pairs of all trials need to be a sparse matrix in the form of a direct access table or a compact representation .",
    "while fast lookups can be obtained in the sparse matrix representation , this performance is achieved at the cost of high memory usage .",
    "consider a yet with 1,000,000 events and one layer with 16 xelts , and each xelt consisting of 20,000 events with non - zero losses .",
    "the representation using a direct access table would require memory to hold @xmath55 event - loss pairs ( without considering the data required for secondary uncertainty calculations ) .",
    "while such a large data structure is held in memory , 15,700,000 events represent zero loss value .",
    "though the sparse representation requires large amount of memory it is chosen over any compact representation for the following reason .",
    "a search operation is required to find an event - loss pair even in a compact representation .",
    "if sequential search is adopted , then @xmath56 memory accesses are required to find an event - loss pair .",
    "if sorting is performed in a pre - processing phase to facilitate a binary search , then @xmath57 memory accesses are required to find an event - loss pair .",
    "if a constant - time space - efficient hashing scheme , such as cuckoo hashing @xcite is adopted then an event - loss pair can be accessed with a constant number of memory accesses . however , this can be only be achieved at the expense of a complex implementation and overheads depreciating run - time performance .",
    "further , such an implementation on the gpu with a complex memory hierarchy is cumbersome .",
    "although large memory space is required for a direct access table , looking up event - loss pairs can be achieved with fewer memory accesses compared to the memory accesses in a compact representation .",
    "two data structure implementations of 16 xelts were considered . in the first implementation , each xelt is considered as an independent table ; therefore , in a read cycle , each thread independently looks up its events from the xelts .",
    "all threads within a block access the same xelt . in the second implementation ,",
    "all the 16 xelts are combined into a single table .",
    "consequently , the threads then use the shared memory to load entire rows of the combined xelts at a time .",
    "the second implementation performs poorly compared to the first implementation .",
    "this is because of the memory overheads for the threads to collectively load rows from the combined xelt .    in the implementation on the multi - core cpu platform the entire data required for the algorithm",
    "is processed in memory .",
    "the gpu implementation of the algorithm uses the gpu s global memory to store all data structures . the parallel implementation on the gpu requires high memory transactions",
    "this is surmounted by utilising shared memory over global memory .",
    "three statistical functions are required in the method for applying secondary uncertainty .",
    "they are ( i ) the cumulative distribution function ( cdf ) of normal distribution , ( ii ) the quantile of the normal distribution , and ( iii ) the quantile of the beta distribution .",
    "the quantile of the beta distribution is a numerically intensive function since it is an iterative method which converges to the solution within a certain error .",
    "seven different libraries are used for implementing the secondary uncertainty methodology on the multi - core cpu .",
    "the first is the boost statistical library offered by the boost c++ libraries .",
    "the statistical functions are available inside the namespace ` boost::math ` . in order to use the distributions",
    "the header `` needs to be included .",
    "for example , ` boost::math::normal_distribution < > normdist ( 0.0l , 1.0l ) ` will create a standard normal distribution with mean equal to 0 and standard deviation equal to 1 .",
    "the quantile function of the normal distribution can be obtained by as ` quantile(normdist , double value ) ` .",
    "the cdf of the normal distribution is obtained by ` cdf ( normdist , double value ) ` .",
    "similarly , an assymetrical beta distribution with alpha and beta values can be created using ` boost::math::beta_distribution < > betadist ( double alpha , double beta ) ` and the quantile can be obtained from ` quantile(betadist , double cdf ) ` .    the second is the imsl c / c++ numerical libraries offered by rogue wave software .",
    "the mathematical functions are obtained from the ` imsl.h ` header file and the statistical functions are obtained from the ` imsls.h ` header file @xcite .",
    "the cdf for the normal distribution with mean equal to 0 and standard deviation equal to 1 is obtained from ` imsl_f_normal_cdf ( double value ) ` and the quantile is obtained from ` imsl_f_normal_inverse_cdf ( double cdf ) ` .",
    "the quantile for the beta distribution with alpha and beta values are obtained as ` imsl_f_beta_inverse_cdf ( double cdf , double alpha , double beta ) ` .",
    "the third is prob which is a c++ library that handles the probability density functions for various discrete and continuous distributions . in order to use the distributions the header ` prob.hpp > ` needs to be included .",
    "the cdf for the normal distribution with mean equal to 0 and standard deviation equal to 1 is obtained from ` normal_01_cdf ( double value ) ` or ` normal_cdf ( double x , double a , double b ) ` ( where @xmath58 and @xmath59 ) and the quantile from ` normal_01_cdf_inv ( double cdf ) ` or ` normal_cdf_inv ( double cdf , double a , double b ) ` ( where @xmath58 and @xmath59 ) .",
    "the quantile for the beta distribution with alpha and beta values are obtained as ` beta_cdf_inv ( double cdf , double alpha , double beta ) ` @xcite .",
    "the fourth is dcdflib which is a c library adapted from fortran for evaluating cdf and inverse cdf of discrete and continuous probability distributions . in order to use the distributions the header ` dcdflib.c ` needs to be included .",
    "the cdf and the quantile for the normal distribution with mean stored in ` mean ` and standard deviation stored in ` sd ` can be obtained from ` cdfnor ( int * which , double * p , double * q , double * value , double * mean , double * sd , int * status , double * bound ) ` @xcite . `` which ` ' is set to 1 to obtain the cdf value ` p ` and ` q = 1.0 - p ` .",
    "`` which ` ' is set to 2 to obtain the quantile in ` value ` .",
    "` status ` and ` bound ` are variables to report the status of the computation .",
    "the quantile of the beta distribution ` x ` and ` y = 1.0 - x ` for ` alpha ` and ` beta ` can be obtained from ` cdfbet ( int * which , double * p , double * q , double * x , double * y , double * alpha , double * beta , int * status , double * bound ) ` when ` which ` is set to 2 , ` p ` is the cdf and ` q = 1.0 - p ` @xcite .",
    "the fifth library is asa310 or the applied statistics algorithm 310 which is a c++ library for evaluating the cdf of the noncentral beta distribution @xcite .",
    "the include file is ` asa310.hpp ` .",
    "the iterative algorithm for achieving convergence of the solution to compute the quantile calls the function for computing the tail of the noncentral beta distribution ` betanc ( float value , float alpha , float beta , float lambda , int * ifault ) ` , where ` lambda ` , the noncentrality parameter is set to 0 for the standard beta distribution and ` ifault ` is an error flag .",
    "the sixth library is asa226 or the applied statistics algorithm 226 ^ 7^ which is a c++ library similar to asa310 @xcite .",
    "the include file is ` asa226.hpp ` .",
    "the iterative algorithm for achieving convergence of the solution to compute the quantile is used to call the function for computing the tail of the noncentral beta distribution .",
    "the seventh library is beta_nc another c++ library that can evaluate the cdf of the noncentral beta distribution @xcite .",
    "the include file is ` beta_nc.cpp ` .",
    "the iterative algorithm that achieves convergence of the solution to compute the quantile calls the ` beta_noncentral_cdf ( double alpha , double beta , double lambda , double value , double error_max ) ` , where ` lambda ` , the noncentrality parameter is set to 0 for the standard beta distribution and ` error_max ` is is the error control in the computation .    for implementing the secondary uncertainty methodology on the gpu statistical functions provided by the cuda math api",
    "are employed by including the ` math.h ` header file .",
    "the cdf of the normal distribution ` normcdf ` and the quantile of the normal distribution ` normcdfinv ` are fast methods and included in the implementation .",
    "the cuda math api currently does not support beta distribution functions .",
    "therefore , four libraries , namely the prob , asa310 , asa226 and beta_nc are incorporated in the implementation for the many - core gpu .",
    "these libraries are ported for the gpu platform and all the functions in the libraries are implemented as ` _ _ device _ _ ` functions for the gpu .",
    "the implementations were optimised for better performance in three ways .",
    "firstly , by incorporating loop unrolling , which refers to the compiler replicating of blocks of code within ` for loops ' to reduce the number of iterations performed by for loops .",
    "the ` for ` loops are unrolled using the ` pragma ` directive ; the ` for ` loops in line nos",
    ". 1 - 5 of algorithm [ algorithm1 ] can be unrolled as each iteration is a mutually independent iteration .    secondly , in the case of the gpu by migrating data from both shared and global memory to the kernel registry .",
    "the kernel registry has the lowest latency compared to all other memory .",
    "thirdly , by reducing the precision of variables used in the algorithm , whereby the double variables are changed to float variables . in the case of the gpu ,",
    "read operations are faster using float variables as they are only half the size of a double variable .",
    "furthermore , the performance of single precision operations tend to be approximately twice as fast as double precision operations .",
    "the cuda math api supports functions for floating point operations and the full acceleration of cuda math api can be achieved by using the compiler flag ` -use_fast_math ` .",
    "in this section , the results obtained from the sequential implementation on the cpu , the parallel implementation on the multi - core cpu and the many - core gpu , and the summary of the experimental results are presented .",
    "figure [ figure1 ] shows the graph plotted for the time taken for sequentially performing aggregate risk analysis using trials varying from 200,000 to 800,000 with each trial comprising 1,000 events on the cpu when secondary uncertainty is applied using the boost , imsl , prob , dcdflib , beta_nc , asa310 and asa226 libraries .",
    "the experiments are performed for one layer and 16 xelts .",
    "the boost library provides the fastest functions for secondary uncertainty followed by the beta_nc , dcdflib , asa310 and asa226 libraries .",
    "the prob library is approximately 2 times slower and the imsl numerical library is approximately 5 times slower than the boost library .",
    "figure [ figure2 ] shows the graph plotted for the time taken for applying secondary uncertainty for trials varying from 200,000 to 800,000 with each trial comprising 1,000 events on the cpu when boost library is used .",
    "the results from the boost library are chosen since it provides the fastest functions for applying secondary uncertainty .",
    "the experiments are performed for one layer and 16 xelts . in each case of trials shown in the graph",
    "the time for applying secondary uncertainty is nearly 2.5 times the time taken for aggregate risk analysis .",
    "the mathematical functions employed for applying secondary uncertainty are fast methods with the exception of the inverse cumulative distribution function of the beta distribution which takes majority of the time .",
    "the time taken both for performing aggregate risk analysis with only primary uncertainty and for applying secondary uncertainty with increasing number of trials should scale linearly and this is observed both in figure [ figure1 ] and figure [ figure2 ] .",
    "figure [ figure3 ] and figure [ figure4 ] show the graphs plotted for the time taken for performing parallel aggregate risk analysis and applying secondary uncertainty for 800,000 trials on the multi - core cpu using the boost , imsl , prob , dcdflib , beta_nc , asa310 and asa226 libraries .    in figure [ figure3 ] ,",
    "a single thread is run on each virtual core of the cpu and the number of cores are varied from 1 to 8 ( i.e. , up to two threads on each of the four physical cores ) .",
    "each threads performs the aggregate risk analysis for a single trial and applies secondary uncertainty .",
    "multiple threads are used by employing openmp directive ` # pragma omp parallel ` in the c++ source . with respect to the overall time",
    "the asa310 library performs the best requiring 232 seconds for the analysis . for the imsl library ,",
    "a speedup of nearly 1.9x is achieved for two cores , a speedup of nearly 3.6x is obtained for four cores and a speedup of 6.9x is obtained for 8 cores . while the performance keeps diminishing for the imsl library , the efficiency of all the other libraries used in secondary uncertainty is significantly low .",
    "no more than 4x speedup is achieved on eight cores in the best case .",
    "the limiting factor is that the bandwidth to memory is not increased as the number of cores increase .",
    "the majority of the time taken in aggregate risk analysis is for performing random access reads into the data structure representing the xelt .",
    "the majority of the time in applying secondary uncertainty is consumed in the inverse cumulative distribution function of the beta distribution .",
    "the boost library outperforms all the other libraries with respect to the overall time .",
    "the dcdflib library did not scale on multiple threads as the files are written as blocks of program with unconditional jumps using the ` goto ` statement .    in figure [ figure4 ] , the performance on all eight virtual cores of the cpu is illustrated ; multiple threads are run on each virtual core of the cpu .",
    "for example , when 16 threads are employed two threads run on each virtual core and when 2048 threads are employed 256 threads run on each virtual core of the cpu . a small drop",
    "is observed in the absolute time when many threads are executed on each core .",
    "when 256 threads run on a core , the overall runtime drops from 701 seconds ( using two threads per core ) to 620 seconds for the imsl library and the runtime drops from 269 seconds ( using two threads per core ) to 252 seconds for the boost library .",
    "when 2048 threads are employed , the asa310 library performs better than the boost library by 25 seconds .",
    "figure [ figure5 ] shows the graph plotted for the time taken for applying secondary uncertainty using 2048 threads for trials varying from 200,000 to 800,000 on the eight virtual cores of the cpu when the boost library is used . in each case of trials shown in the graph",
    "the time taken for applying secondary uncertainty increases with the number of trials .",
    "the time taken for applying secondary uncertainty on the multi - core is only @xmath60 the time taken in the sequential implementation .",
    "figure [ figure6 ] shows the graph plotted for the time taken for aggregate risk analysis and for applying secondary uncertainty using the boost library for 800,000 trials when the number of threads are varied from 1 to 2048 on the multi - core cpu .",
    "the lowest overall time is 252 seconds when 256 threads are employed per core of the cpu ; 161 seconds are required for the aggregate risk analysis and 91 seconds for applying secondary uncertainty .",
    "however , the lowest time taken for applying secondary uncertainty is 75 seconds which is achieved when one thread is used per core ( 8 threads on the cpu ) . while there is a decrease in the overall time taken as the number of threads increase ,",
    "there is a gradual increase in the time taken for applying secondary uncertainty when more than 8 threads are employed on the cpu ; 75 seconds when 8 threads are used , where as 91 seconds required when 2048 threads are used .",
    "this is due to the increasing overhead in swapping constants in and out of memory as the number of threads increase . the performance of boost surpasses that of asa only when one and two threads are used . beyond two threads asa310 has lower overall time .",
    "figure [ figure7 ] shows the graph plotted for the optimal ( best time ) time taken for applying secondary analysis in aggregate risk analysis for 800,000 trials using different libraries .",
    "optimality for overall time is achieved when 2048 threads are employed ; in this graph the optimality for applying secondary uncertainty is considered .",
    "for the asa310 library , the best time for applying secondary uncertainty is 66 seconds which is only @xmath61 the time taken in the sequential implementation .",
    "figure [ figure9 ] and figure [ figure10 ] show the graphs plotted for the time taken for performing parallel aggregate risk analysis and applying secondary uncertainty for 800,000 trials on the many - core gpu using the prob , asa310 , beta_nc and asa226 libraries .",
    "imsl and boost libraries are not available for gpus .",
    "the dcdflib library was ported for the gpu but did not execute on the hardware .",
    "cuda provides abstraction over the streaming multi - processors of the gpu , which is often referred to as a cuda block .",
    "the number of threads executed per cuda block can be varied in aggregate risk analysis .",
    "for example , consider the execution of 800,000 trials using 800,000 threads . if 256 threads are executed on one streaming multi - processor ( smp ) , then 3125 cuda blocks need to be executed on the 14 smps .",
    "each smp will have to execute 223 cuda blocks .",
    "all threads executing on one smp have a fixed size of shared and constant memory .",
    "fewer the threads employed , then each thread will have a large size of shared and constant memory .",
    "but there is a trade - off when fewer threads are used since the latency for accessing the global memory of the gpu increases .    in figure [ figure9 ]",
    "the analysis is performed for 800,000 trials on the gpu by varying the number of threads per block from 16 to 512 threads .",
    "an improvement in the performance is seen as the number of threads increase from 16 to 128 since the latency for accessing the global memory drops . beyond 128 threads the performance starts to drop as the shared and constant memory available to each thread decreases .",
    "asa226 library performs the best since the function used in computing secondary uncertainty has an optimal balance between the number of constants and the amount of computation required .",
    "this is vital when there is a trade - off between the size of shared and constant memory and latency in accessing global memory .",
    "the lowest time taken is 51 seconds when 128 threads per block are used .",
    "figure [ figure10 ] shows the time taken to perform aggregate risk analysis for applying primary uncertainty and for applying secondary uncertainty using the asa226 library on the gpu for 800,000 trials . the time taken for performing aggregate risk analysis is nearly a constant .",
    "the time taken for applying secondary uncertainty first decreases from 16 to 128 threads per block and then increase beyond 128 threads per block .",
    "this is due to the trade - off between the size of the shared and constant memory and latency in accessing global memory . in the best case",
    "when 128 threads per block are employed the time taken for applying secondary uncertainty is nearly twice the time taken for performing aggregate risk analysis .",
    "the best time for applying secondary uncertainty using asa226 on the gpu is only half the best time taken by asa310 for applying secondary uncertainty using multiple threads on the cpu .",
    "figure [ figure8 ] illustrates the performance of the asa226 , beta_nc , asa310 and prob libraries on the gpu for different trials varying from 200,000 to 800,000 . in each case of trials",
    "the time taken for applying secondary uncertainty increases with the number of trials .",
    "the asa226 outperforms the beta_nc , asa310 and prob libraries .",
    "figure [ figure11 ] shows the time taken to perform aggregate risk analysis for applying primary uncertainty and for applying secondary uncertainty using the asa226 library on the gpu for trials varying from 200,000 to 800,000 .",
    "both times scale linearly .",
    "figure [ figure12 ] is a graph that summarises the key results from the experimental study .",
    "the set of three bars represents the time taken for ( i ) fetching events from memory and for look up of loss sets in memory , ( ii ) applying financial terms and performing other computations in aggregate risk analysis , and ( iii ) applying secondary uncertainty on the sequential implementation on the cpu and the parallel implementations on both the multi - core cpu and many - core gpu when 800,00 trials , with each trial consisting 1,000 events , and 16 xelts are employed . in each case , parameters specific to the implementation , such as the number of threads , were set to the best value identified during experimentation .    in the parallel implementations for the basic aggregate analysis , a speedup of 2.3x",
    "is achieved on the cpu and a speedup of 20x is achieved on the gpu when compared against the sequential implementation . a speedup of 24x",
    "is achieved in the overall time for the implementation on the gpu in contrast to the sequential implementation on the cpu . for applying secondary uncertainty , multiple threading on the eight virtual cores of the cpu",
    "is nearly five times faster than the sequential implementation and three times slower than the gpu . for the numeric computations on the gpu an accelaration of",
    "approximately 26x is achieved over the sequential implementation .",
    "limited memory bandwidth is a bottleneck in the cpu resulting in approximately 27% and 53% of the time being spent for fetching events and for look up of loss sets in memory for the sequential and parallel implementation on the cpu respectively .",
    "while the time for fetching events and for look up of loss sets in memory have been significantly lowered on the gpu 39% of the total time is still used to this end .    in the sequential implementation on the cpu , in the parallel implementation on the multi - core cpu and in the parallel implementation on the many - core gpu approximately 62% , 38% and 56% ,",
    "respectively , of the total time for aggregate risk analysis is required for applying secondary uncertainty .",
    "the majority of this time is required by the computations of the inverse beta cumulative distribution .",
    "this calls for not only the development of fast methods to apply secondary uncertainty in risk analytics , but also the development of fast methods for the underlying statistical functions .",
    "fast methods have been implemented for computing the inverse cdf of the symmetrical beta distribution @xcite which considers one shape parameter , but there are minimal implementations of fast assymetrical beta distribution that takes two shape parameters .",
    "the research reported in this paper was motivated towards experimentally verifying whether gpus can accelerate aggregate risk analysis with both primary and secondary uncertainty . to this end",
    "an algorithm for the analysis of portfolios of risk and a methodology for applying secondary uncertainty was proposed and implemented . a sequential and a parallel implementation on the cpu and a parallel implementation on the gpu",
    "were presented .",
    "seven statistical libraries , namely boost , imsl , dcdflib , prob , asa310 , asa226 and beta_nc were investigated for implementing the computations of secondary uncertainty .",
    "numerous challenges in handling large data in limited memory of the gpu were surmounted ; the resultant was a speedup of 24x which was achieved for the parallel analysis on the gpu over its sequential counterpart on the cpu .    in this research ,",
    "the gpu performed well for the numerical computations of secondary uncertainty ; the gpu was five times faster than the multiple threaded analysis on the multi - core cpu for applying secondary uncertainty .",
    "the cpu could have performed well had it not been for its limited memory bandwidth and the gpu could have performed better had it not been for its limited memory availability .",
    "a. k. bahl , o. baltzer , a. rau - chaplin , and b. varghese , `` parallel simulations for analysing portfolios of catastrophic event risk , '' in workshop proceedings of the international conference of high performance computing , networking , storage and analysis ( sc12 ) , 2012 .",
    "g. w. cran , k. j. martin and g. e. thomas , `` remark as r19 and algorithm as 109 : a remark on algorithms as 63 : the incomplete beta integral and as 64 : inverse of the incomplete beta integeral , '' applied statistics , vol .",
    "26 , no . 1 , 1977 , pp .",
    "111 - 114 ."
  ],
  "abstract_text": [
    "<S> aggregate risk analysis is a computationally intensive and a data intensive problem , thereby making the application of high - performance computing techniques interesting . in this paper , </S>",
    "<S> the design and implementation of a parallel aggregate risk analysis algorithm on multi - core cpu and many - core gpu platforms are explored . </S>",
    "<S> the efficient computation of key risk measures , including probable maximum loss ( pml ) and the tail value - at - risk ( tvar ) in the presence of both primary and secondary uncertainty for a portfolio of property catastrophe insurance treaties is considered . _ primary uncertainty _ is the the uncertainty associated with whether a catastrophe event occurs or not in a simulated year , while _ secondary uncertainty _ is the uncertainty in the amount of loss when the event occurs .    </S>",
    "<S> a number of statistical algorithms are investigated for computing secondary uncertainty . </S>",
    "<S> numerous challenges such as loading large data onto hardware with limited memory and organising it are addressed . </S>",
    "<S> the results obtained from experimental studies are encouraging . </S>",
    "<S> consider for example , an aggregate risk analysis involving 800,000 trials , with 1,000 catastrophic events per trial , a million locations , and a complex contract structure taking into account secondary uncertainty . </S>",
    "<S> the analysis can be performed in just 41 seconds on a gpu , that is 24x faster than the sequential counterpart on a fast multi - core cpu . </S>",
    "<S> the results indicate that gpus can be used to efficiently accelerate aggregate risk analysis even in the presence of secondary uncertainty . </S>"
  ]
}