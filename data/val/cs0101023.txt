{
  "article_text": [
    "most of the recent logic programming languages provide the possibility of employing _ dynamic scheduling _ , i.e. , a runtime mechanism determining which atoms in a query are _ selectable _ and which ones are not .",
    "in fact , dynamic scheduling has proven to be useful in a number of applications ; among other things , it allows one to model coroutining , as shown in @xcite , and parallel executions , as shown in @xcite .",
    "let us use the following simple examples to show how dynamic scheduling can be enforced by using _ delay declarations _ and how it can prevent nontermination and unnecessary computations . consider the program ` append `    app ( [ ] , ys , ys ) . + app([h|xs],ys,[h|zs ] ) @xmath0app(xs , ys , zs ) .",
    "together with the query    @xmath1 app(xs,[5,6],ys ) , app([1,2],[3,4],xs ) .    in this query ,",
    "if we select and resolve the leftmost atom , we could easily have to face one of the following two problems .",
    "first , the possibility of nontermination : this is the case if we repeatedly resolve the leftmost atom against the second clause .",
    "the second problem is that of inefficiency . if , for instance , in @xmath2 we resolve the leftmost atom against the first clause , we obtain the query ` app([1,2],[3,4 ] , [  ] ) ` .",
    "this will eventually fail , yielding to ( unnecessary ) backtracking .",
    "notice that if one employs the rightmost selection rule , @xmath2 would terminate with success and without backtracking .",
    "basically , the problem when selecting ` app(xs,[5,6],ys ) ` , is that we do not know which clause we should use for resolving it , and the only practical way for getting to know this is by waiting until the outermost functor of ` xs ` is known : if it is the empty list ` [ ] ` we know that we should use the first clause , if it is the list - constructor symbol we know that we should use the second clause , if it is something else again , we know then that the query _ fails_. notice that the same problems arise for the query    @xmath3 app([1,2],[3,4],xs ) , app(xs,[5,6],ys ) .    if the rightmost selection rule is considered .",
    "this shows the usefulness of a mechanism for preventing the selection of those atoms which are not sufficiently instantiated .",
    "such a mechanism is in fact offered by most modern languages : in ghc @xcite programs are augmented with _",
    "guards _ in order to control the selection of atoms dynamically .",
    "moded flat ghc @xcite uses an extra condition on the input positions , which is extremely similar to the concept of input - consuming derivation step we refer to the sequel : the resolution of an atom with a definition must not instantiate the input arguments of the resolved atom . on the other hand , gdel @xcite and eclipse @xcite use _ delay declarations _ , and sicstus prolog @xcite employs block declarations ( which are a special kind of delay declarations ) .",
    "both _ delay _ and",
    "block declarations check the partial instantiation of some arguments of calls .",
    "for instance , the standard delay declaration for ` append ` is    @xmath4 delay app(ls , _ , _ ) until nonvar(ls ) .",
    "this declaration forbids the selection of an atom of the form @xmath5 unless @xmath6 is a non - variable term , which is precisely what we need in order to run the queries @xmath2 or @xmath7 efficiently .",
    "+ the adoption of dynamic scheduling has the disadvantage that various program properties that have been proven for logic and pure prolog programs do not apply any longer .",
    "the goal of our research is the study of termination properties .",
    "this is motivated by the fact that most of the literature on termination of logic programs ( see de schreye and decorte @xcite for a survey on this subject ) assumes the standard prolog selection rule , i.e. , the leftmost one .",
    "notable exceptions are bezem @xcite and cavedon @xcite who provide results for all selection rules .",
    "there are only few authors who tackled the specific problem of verifying the termination of logic programs with dynamic scheduling .",
    "namely , apt and luitjes @xcite , marchiori and teusink @xcite and smaus @xcite .",
    "we compare our results with the ones in @xcite in the concluding section .",
    "another feature of logic programs which does not hold in presence of dynamic scheduling is the well - known _ switching lemma _ , which is , for instance , at the base of the result on the independence of the selection rule . in this paper",
    "we show that  under certain conditions  a weak form of the well - known switching lemma holds .",
    "+ in order to recuperate at least part of the declarative reading of logic programming , we follow here the same approach to dynamic scheduling as @xcite and we substitute the use of delay declarations by the restriction to _ input - consuming _ derivations .",
    "the definition of input - consuming derivation is done in two phases .",
    "first we give the program a _ mode _",
    ", that is , we partition the positions of each atom into _ input _ and _ output _ positions .",
    "then , in presence of modes , _ input - consuming _ derivation steps are precisely those in which the input arguments of the selected atom will not be instantiated by the unification with the clause s head .",
    "if in a query no atom is resolvable via an input - consuming derivation step and a failure does not arise then we have a _",
    "situation , this notion of deadlock differs , in some way , from the usual one , which is given in the case of programs employing delay declarations . ] .    for example , the standard mode for the program ` append ` reported above , when used for concatenating two lists , is ` app(in , in , out ) ` .",
    "notice that in this case the delay declaration @xmath8 serves precisely the purpose of guaranteeing that if an atom of the form @xmath9 ( with @xmath10 being a variable ) is selectable and unifiable with a clause head , then the resulting derivation step is input - consuming .",
    "it is also worth remarking that , as a large body of literature shows , the vast majority of `` usual '' programs are actually moded and are , in a well - defined sense consistent wrt .  to their modes ( e.g. , well - moded , nicely - moded , simply - moded , etc .",
    ") ; see for example @xcite , or more simply , the tables of programs we report in section  [ sec : applicability ] , or consider for instance the logic programming language mercury @xcite , which requires that its programs are moded ( and well - moded ) .",
    "in this paper we study some properties of input - consuming derivations .    in the first place",
    "we show that , if we restrict ourselves to programs and queries which are nicely - moded , then a weak form of the well - known switching lemma holds .    furthermore , we study the termination properties of input - consuming derivations . for this",
    "we define the class of _ input terminating _ programs which characterizes programs whose input - consuming derivations starting in a nicely - moded query are finite . in order to prove that a program is input terminating , we use the concept of _ quasi recurrent _ program ( similar to , but noticeably less restrictive than the concept of semi - recurrent program introduced in @xcite ) .",
    "we show that if @xmath11 is nicely - moded and quasi recurrent then all its input - consuming derivations starting from a nicely - moded query terminate .",
    "furthermore , we demonstrate that under mild additional constraints ( namely , simply - modedness and input - recurrency ) the above condition is both sufficient and _ necessary _ for ensuring that all input - consuming derivations starting from a nicely - moded query terminate .",
    "this approach generalizes the method described in @xcite in two ways : first because we also provide conditions which are both necessary and sufficient , and secondly because we do not require programs and queries to be well - moded ; we only assume that they are nicely - moded .",
    "this is actually crucial : when programs and queries are well - moded , derivations can not _",
    "deadlock_. thus , as opposed to @xcite , our results capture also termination by deadlock . for instance , we can easily prove that the query @xmath12 terminates .",
    "a more detailed comparison is presented in the concluding section .",
    "we also show that the results presented in this paper can be extended to programs and queries which are _ permutation _ nicely- or simply - moded , @xcite .    to evaluate the practicality of the results we present , we consider the programs from various well - known collections , and we check whether they satisfy the conditions of our main theorem .",
    "the paper is organized as follows .",
    "section [ prel ] contains some preliminary notations and definitions . in section",
    "[ sec : input ] input - consuming derivations are introduced and some properties of them are proven . in section [ sec : switching ]",
    "we prove that , for nicely - moded input - consuming programs , a left switching lemma holds . in section [ input - ter ] a method for proving input termination of programs is presented , first in a non - modular way , then for modular programs . in section [ sec : necessity ]",
    "we show that this method is necessary for the class of simply - moded and input - recursive programs .",
    "section [ sec : applicability ] discusses the applicability of our results through simple examples of programs and reports the results obtained by applying our method to various benchmarks .",
    "finally , section  [ sec : conclusion ] concludes the paper .",
    "the reader is assumed to be familiar with the terminology and the basic results of logic programs @xcite .",
    "let @xmath13 be the set of terms built on a finite set of _ data constructors _ @xmath14 and a denumerable set of _ variable symbols _ @xmath15 .",
    "a _ substitution _",
    "@xmath16 is a mapping from @xmath15 to @xmath17 such that @xmath18 is finite . for any syntactic object @xmath19 ,",
    "we denote by @xmath20 the set of variables occurring in @xmath19 .",
    "a syntactic object is linear if every variable occurs in it at most once .",
    "we denote by @xmath21 the empty substitution . the _ composition _ @xmath22 of the substitutions @xmath16 and @xmath23 is defined as the functional composition , i.e. , @xmath24 .",
    "we consider the pre - ordering @xmath25 ( more general than ) on substitutions such that @xmath26 iff there exists @xmath27 such that @xmath28 .",
    "the result of the application of a substitution @xmath16 to a term @xmath29 is said an _ instance _ of @xmath29 and it is denoted by @xmath30 .",
    "we also consider the pre - ordering @xmath25 ( more general than ) on terms such that @xmath31 iff there exists @xmath16 such that @xmath32 .",
    "we denote by @xmath33 the associated equivalence relation ( _ variance _ ) .",
    "a substitution @xmath16 is a _ unifier _ of terms @xmath29 and @xmath34 iff @xmath35 .",
    "we denote by @xmath36 any _ most general unifier _ ( _ mgu _ , in short ) of @xmath29 and @xmath34 .",
    "an mgu @xmath16 of terms @xmath29 and @xmath34 is called relevant iff @xmath37 .",
    "let @xmath38 be a finite set of _ predicate symbols_. an _ atom _ is an object of the form @xmath39 where @xmath40 is an @xmath41-ary predicate symbol and @xmath42 .",
    "given an atom @xmath43 , we denote by @xmath44 the predicate symbol of @xmath43 .",
    "a _ query _ is a finite , possibly empty , sequence of atoms @xmath45 .",
    "the empty query is denoted by @xmath46 . following the convention adopted in @xcite",
    ", we use bold characters to denote queries .",
    "a _ clause _ is a formula @xmath47 where @xmath48 is an atom ( the _ head _ ) and @xmath49 is a query ( the _ body _ ) .",
    "when @xmath49 is empty , @xmath47 is written @xmath50 and is called a _ unit clause_. a _ program _ is a finite set of clauses .",
    "we denote atoms by @xmath51 queries by @xmath52 clauses by @xmath53 and programs by  @xmath11 .",
    "computations are constructed as sequences of `` basic '' steps .",
    "consider a non - empty query @xmath54 and a clause @xmath55 .",
    "let @xmath47 be a variant of @xmath55 variable disjoint from @xmath54 .",
    "let @xmath56 and @xmath48 unify with mgu @xmath16 .",
    "the query @xmath57 is called a _",
    "resolvent of _",
    "@xmath54 _ and _ @xmath55 _ with selected atom _ @xmath56 _ and mgu _ @xmath16 .",
    "a _ derivation step _ is denoted by @xmath58 the clause @xmath47 is called its _",
    "input clause_. the atom @xmath56 is called the _ selected atom _ of @xmath59 .    if @xmath11 is clear from the context or @xmath55 is irrelevant then we drop the reference to them .",
    "a derivation is obtained by iterating derivation steps .",
    "a maximal sequence @xmath60 is called a _ derivation of @xmath61 _ provided that for every step the standardization apart condition holds , i.e. , the input clause employed is variable disjoint from the initial query @xmath62 and from the substitutions and the input clauses used at earlier steps .",
    "derivations can be finite or infinite",
    ". if @xmath63 is a finite prefix of a derivation , also denoted @xmath64 with @xmath65 , we say that @xmath66 is a _ partial derivation _ and @xmath16 is a _ partial computed answer substitution _ of @xmath61 .",
    "if @xmath66 is maximal and ends with the empty query then @xmath16 is called _ computed answer substitution _",
    "( _ c.a.s .",
    "_ , for short ) .",
    "the length of a ( partial ) derivation @xmath66 , denoted by @xmath67 , is the number of derivation steps in @xmath66 .",
    "the following definition of @xmath68-step is due to smaus @xcite .",
    "let @xmath69 be a derivation step .",
    "we say that each atom in @xmath70 is a _ direct descendant of b _ , and for each atom @xmath71 in @xmath72 , @xmath73 is a _ direct descendant of e_. we say that @xmath71 is a descendant of @xmath74 if the pair @xmath75 is in the reflexive , transitive closure of the relation _ is a direct descendant of_. consider a derivation @xmath76 .",
    "we say that @xmath77 is a @xmath68-step if @xmath68 is a subquery of @xmath78 and the selected atom in @xmath79 is a descendant of an atom in @xmath68 .",
    "in this section we introduce the concept of input - consuming derivation which is strictly related to the notion of mode ; we discuss the relations between input - consuming derivations and programs using delay declarations ; we recall the notion of nicely - moded program and state some properties .",
    "let us first recall the notion of mode .",
    "a _ mode _ is a function that labels as _ input _ or _ output _ the positions of each predicate in order to indicate how the arguments of a predicate should be  used .",
    "consider an @xmath41-ary predicate symbol @xmath80 .",
    "a _ mode _ for @xmath80 is a function @xmath81 from @xmath82 to @xmath83 .    if @xmath84 ( resp .",
    "_ out _ ) , we say that @xmath85 is an @xmath86 ( resp .",
    "_ output _ ) _ position of _ @xmath80 ( wrt .",
    "@xmath81 ) .",
    "we assume that each predicate symbol has a unique mode associated to it ; multiple modes may be obtained by simply renaming the predicates .    if @xmath87 is a query , we denote by @xmath88 ( resp .",
    "@xmath89 ) the sequence of terms filling in the input ( resp .",
    "output ) positions of predicates in @xmath87 . moreover , when writing an atom as @xmath90 , we are indicating with @xmath91 the sequence of terms filling in the input positions of @xmath80 and with @xmath92 the sequence of terms filling in the output positions of @xmath80 .    the notion of input - consuming derivation was introduced in @xcite and is defined as follows .",
    "* an atom @xmath93 is called _ input - consuming resolvable wrt .",
    "a clause @xmath94 and a substitution @xmath16 _",
    "iff @xmath95 and @xmath96 . * a derivation step @xmath97 is called _ input - consuming _ iff the selected atom @xmath56 is input - consuming resolvable wrt .",
    "the input clause @xmath55 and the substitution @xmath16 . * a derivation is called _ input - consuming _",
    "iff all its derivation steps are input - consuming .    the following lemma states that we are allowed to restrict our attention to input - consuming derivations with relevant mgu s .",
    "[ relevance ] let @xmath93 and @xmath98 be two atoms . if there exists an mgu @xmath16 of @xmath90 and @xmath98 such that @xmath99 , then there exists a _ relevant",
    "_ mgu @xmath100 of @xmath93 and @xmath101 such that @xmath102 .",
    "since @xmath93 and @xmath98 are unifiable , there exists a relevant mgu @xmath103 of them ( cfr .",
    "@xcite , theorem 2.16 ) .",
    "now , @xmath103 is a renaming of @xmath16 .",
    "thus @xmath104 is a variant of @xmath91 .",
    "then there exists a renaming @xmath105 such that @xmath106 and @xmath107 .",
    "now , take @xmath108 .    from now on , we assume that all mgu s used in the input - consuming derivation steps are relevant .",
    "[ i - c ] consider the program reverse with accumulator in the modes defined below .",
    "mode reverse(in , out ) .",
    "+ mode reverse_acc(in , out , in ) + reverse(xs , ys ) @xmath0reverse_acc(xs , ys , [ ] ) .",
    "+ reverse_acc ( [ ] , ys , ys ) . + reverse_acc([x|xs],ys , zs ) @xmath0reverse_acc(xs , ys,[x|zs ] ) .",
    "the derivation @xmath66 of @xmath109,zs)}\\}$ ] depicted below is input - consuming .",
    "@xmath110 @xmath111,zs)}\\rightarrow    \\mathtt { reverse\\_acc([x1,x2],zs,[\\;])}\\rightarrow$ ] + @xmath112,zs,[x1])}\\rightarrow \\mathtt {      reverse\\_acc([\\;],zs,[x2,x1])}\\rightarrow \\square$ ] .",
    "delay declarations are by far the most popular mechanism for implementing dynamic scheduling . however , being a non - logical mechanism , they are difficult to model and there are few proposals concerning their semantics @xcite and @xcite .",
    "an alternative approach to dynamic scheduling , which is much more declarative in nature , has been proposed by smaus @xcite .",
    "it consists in the use of input - consuming derivations .",
    "there is a main difference between the concept of delay declaration and the one of input - consuming derivation : while in the first case only the atom selectability is controlled , in the second one both the atom and the clause selectability are affected .",
    "in fact , in presence of delay declarations , if an atom is selectable then it can be resolved with respect to any program clause ( provided it unifies with its head ) ; on the contrary , in an input - consuming derivation , if an atom is selectable then it is input - consuming resolvable wrt .",
    "some , but not necessarily all , program clauses , i.e , only a restricted class of clauses can be used for resolution .",
    "also the concept of _ deadlock _ has to be understood in two different ways . for programs using delay declarations",
    "a deadlock situation occurs when no atom in a query satisfies the delay declarations ( i.e. , no atom is selectable ) , while for input - consuming derivations a deadlock occurs when no atom in a query is resolvable via an input - consuming derivation step and the derivation does not fail , i.e. , there is some atom in the query which unifies with a clause head but the unification is not input - consuming .    in spite of these differences , in many situations",
    "there is a strict relation between programs using delay declarations and input - consuming derivations .",
    "this relation is studied by smaus in his phd thesis @xcite .",
    "more precisely , smaus proves a result that relates ` block ` declarations and input - consuming derivations .",
    "a ` block ` declaration is a special case of delay declaration and it is used to declare that certain arguments of an atom must be _ non - variable _ when the atom is selected for resolution . in chapter 7 of @xcite , smaus shows that ` block ` declarations can be used to ensure that derivations are input - consuming . in force of this result and of practical experience",
    ", we might claim that in most `` usual '' moded programs using them , delay declarations are employed precisely for ensuring the input - consumedness of the derivations .",
    "in fact , delay declarations are generally employed to guarantee that the interpreter will not use an `` inappropriate '' clause for resolving an atom ( the other , perhaps less prominent , use of delay declarations is to ensure absence of runtime errors , but we do not address this issue in this paper ) .",
    "this is achieved by preventing the selection of an atom until a certain degree of instantiation is reached .",
    "this degree of instantiation ensures then that the atom is unifiable only with the heads of the `` appropriate '' clauses . in presence of modes",
    ", we can reasonably assume that this degree of instantiation is the one of the _ input _ positions , which are the ones carrying the information .",
    "now , it is easy to see that a derivation step involving a clause @xmath55 is input - consuming iff no further instantiation of the input positions of the resolved atom could prevent it from being resolvable with @xmath55 .",
    "therefore @xmath55 must belong to the set of `` appropriate '' clauses for resolving it .",
    "thus , the concepts of input - consuming derivation and of delay declarations are often employed for ensuring the same properties .      in the sequel of the paper",
    "we will restrict ourselves to programs and queries which are nicely - moded . in this section",
    "we report the definition of this concept together with some basic important properties of nicely - moded programs .",
    "* a query @xmath113 is _ nicely - moded _ if @xmath114 is a linear sequence of terms and for all @xmath115 @xmath116 * a clause @xmath117 is _ nicely - moded _",
    "if @xmath87 is nicely - moded and @xmath118 in particular , every unit clause is nicely - moded . *",
    "a program @xmath11 is nicely - moded if all of its clauses are nicely - moded .",
    "note that a one - atom query @xmath93 is nicely - moded if and only if @xmath92 is linear and @xmath119 .",
    "[ programs ]    * the program append in the modes ` app(in , in , out ) ` is nicely - moded .",
    "* the program reverse with accumulator in the modes depicted in example  [ i - c ] is nicely - moded .",
    "* the following program merge is nicely - moded .",
    "+ mode merge(in , in , out ) .",
    "+ merge(xs , [ ] , xs ) .",
    "+ merge ( [ ] , xs , xs ) .",
    "+ merge([x|xs],[y|ys],[y|zs ] ) @xmath0y < x , merge([x|xs],ys , zs ) .",
    "+ merge([x|xs],[y|ys],[x|zs ] ) @xmath0y > x , merge(xs,[y|ys],zs ) .",
    "+ merge([x|xs],[x|ys],[x|zs ] ) @xmath0merge(xs,[x|ys],zs ) .",
    "the following result is due to smaus @xcite , and states that the class of programs and queries we are considering is persistent under resolution .",
    "[ smaus1 ] every resolvent of a nicely - moded query @xmath87 and a nicely - moded clause @xmath55 , where the derivation step is input - consuming and @xmath120 , is nicely - moded .",
    "the following remark , also in @xcite , is an immediate consequence of the definition of input - consuming derivation step and the fact that the mgu s we consider are relevant .",
    "[ smaus2 ] let the program @xmath11 and the query @xmath121 be nicely - moded .",
    "+ if @xmath122 is an input - consuming derivation step with selected atom @xmath90 , then @xmath123 .",
    "the _ switching lemma _ ( see for instance @xcite , lemma 3.32 ) is a well - known result which allows one to prove the independence of the computed answer substitutions from the selection rule .    in the case of logic programs using dynamic scheduling",
    ", the switching lemma does not hold any longer .",
    "for example , in program ` append ` reported in the introduction ( together with the delay declaration @xmath8 ) we have that the rightmost atom of @xmath7 is selectable only after the leftmost one has been resolved ; i.e. , the switching lemma can not be applied .",
    "nevertheless we can show that , for input - consuming derivations of nicely - moded programs , a weak version of the switching lemma still holds .",
    "intuitively , we show that we can switch the selection of two atoms whenever this results in a left to right selection . for this reason",
    ", we call it",
    "_ left switching lemma_.    first , we need one technical result , stating that the only variables of a query that can be `` affected '' in an input - consuming derivation process are those occurring in some output positions .",
    "intuitively , this means that if the input arguments of a call are not `` sufficiently instantiated '' then it is delayed until it allows for an input - consuming derivation step ( if it is not the case then a deadlock situation will arise ) .",
    "[ sandro1 ] let the program @xmath11 and the query @xmath87 be nicely - moded .",
    "let @xmath124 be a partial input - consuming derivation of @xmath125 .",
    "then , for all @xmath126 and @xmath127 , @xmath128 .",
    "let us first establish the following claim .",
    "[ lin ] let @xmath129 and @xmath130 be two variable disjoint sequences of terms such that @xmath130 is linear and @xmath131 .",
    "if @xmath132 and @xmath133 are two variable disjoint terms occurring in @xmath129 then @xmath134 and @xmath135 are variable disjoint terms .",
    "the result follows from lemmata 11.4 and 11.5 in @xcite .",
    "we proceed with the proof of the lemma by induction on @xmath136 .",
    "_ base case_. let @xmath137 . in this case @xmath138 and the result follows trivially .    _",
    "induction step_. let @xmath139 .",
    "suppose that @xmath140 and @xmath141 where @xmath93 is the selected atom of @xmath87 , @xmath142 is the input clause used in the first derivation step , @xmath143 is a relevant mgu of @xmath93 and @xmath98 and @xmath144 .",
    "let @xmath145 and @xmath146 .",
    "we first  show  that @xmath147 we distinguish two cases .",
    "@xmath148 @xmath149 . in this case",
    ", property @xmath150 follows from the hypothesis that @xmath66 is input - consuming .",
    "@xmath151 @xmath152 .",
    "since @xmath145 , by standardization apart , we have that @xmath153 .",
    "moreover , since @xmath146 , it also holds that @xmath154 .",
    "then , property @xmath150 follows from relevance of @xmath143 .",
    "+ now we show that @xmath155 again , we distinguish two cases :    @xmath156 @xmath157 . in this case , because of the standardization apart condition , @xmath158 will never occur in @xmath159 .",
    "hence , @xmath160 and @xmath161 .",
    "@xmath162 @xmath163 . in this case",
    ", in order to prove @xmath164 we show that @xmath165 .",
    "the result then follows by the inductive hypothesis .    from the standardization apart , relevance of @xmath143 and",
    "the fact that the first derivation step is input - consuming , it follows that @xmath166 .    from the hypothesis that @xmath87 is nicely - moded , @xmath167 . hence , @xmath168 .",
    "since @xmath169 , this proves that @xmath170 .",
    "it remains to be proven that @xmath171 .",
    "we distinguish two cases .",
    "@xmath172 @xmath152 .",
    "since @xmath173 , the fact that @xmath174 follows immediately by standardization apart condition and relevance of @xmath143 .    @xmath175 @xmath176 .",
    "by known results ( see @xcite , corollary 2.25 ) , there exists two relevant mgu @xmath177 and @xmath178 such that    * @xmath179 , * @xmath180 , * @xmath181 .    from relevance of @xmath177 and the fact that , by nicely - modedness of @xmath87 , @xmath182 , we have that @xmath183 , and by the standardization apart condition @xmath184 .",
    "now by nicely - modedness of @xmath55 , @xmath185 . since @xmath177 is relevant and by the standardization apart condition it follows that @xmath186 the proof proceeds now by contradiction . suppose that @xmath187 .",
    "since by hypothesis @xmath149 , and @xmath188 , we have that @xmath189 . by @xmath190 ,",
    "this means that there exist two distinct variables @xmath191 and @xmath192 in @xmath193 such that @xmath194 , @xmath195 and @xmath196 since , by the standardization apart condition and relevance of the mgu s , @xmath197 @xmath198 and @xmath199 , we have that @xmath191 and @xmath192 are two disjoint subterms of @xmath200 .",
    "since @xmath201 , @xmath92 is linear and disjoint from @xmath200 , ( [ eq : varz1sigmaz2 ] ) contradicts claim [ lin ] .",
    "the following corollary is an immediate consequence of the above lemma and the definition of nicely - moded program .",
    "[ corollary ] let the program @xmath11 and the one - atom query @xmath43 be nicely - moded .",
    "let @xmath202 be a partial input - consuming derivation of @xmath203 .",
    "then , for all @xmath204 , @xmath128 .",
    "next is the main result of this section , showing that for input - consuming nicely - moded programs one half of the well - known switching lemma holds .    [ switching ]",
    "let the program @xmath11 and the query @xmath62 be nicely - moded .",
    "let @xmath66 be a partial input - consuming derivation of @xmath61 of the form @xmath205 where    * @xmath206 is a query of the form @xmath207 , * @xmath208 is a resolvent of @xmath206 and @xmath209 wrt .",
    "@xmath210 , * @xmath211 is a resolvent of @xmath208 and @xmath212 wrt .",
    "@xmath213 .    then , there exist @xmath214 , @xmath215 , @xmath216 and a derivation @xmath217 such that @xmath218 and @xmath219 where @xmath217 is input - consuming and    * @xmath66 and @xmath217 coincide up to the resolvent @xmath206 , * @xmath214 is a resolvent of @xmath206 and @xmath212 wrt .",
    "@xmath56 , * @xmath211 is a resolvent of @xmath214 and @xmath209 wrt .",
    "@xmath220 , * @xmath66 and @xmath217 coincide after the resolvent @xmath211 .",
    "let @xmath221 , @xmath222 , @xmath223 and @xmath224 .",
    "hence , @xmath225 and @xmath226 by @xmath227 and the fact that @xmath206 is nicely - moded and @xmath228 is relevant , we have that @xmath229 .",
    "then , @xmath230 and @xmath231 moreover , to denote the mgu of a set of equations @xmath71 , see @xcite . ] @xmath232 where @xmath233 we construct the derivation @xmath217 as follows .",
    "@xmath219 where @xmath234 by @xmath235 , @xmath236 is an input - consuming derivation step .",
    "observe now that @xmath237 this proves that @xmath238 is an input - consuming derivation step .",
    "this result shows that it is always possible to proceed left - to - right to resolve the selected atoms . notice that this is different than saying that the leftmost atom of a query is always resolvable",
    ": it can very well be the case that the leftmost atom is suspended and the one next to it is resolvable .",
    "however , if the leftmost atom of a query is not resolvable then we can state that the derivation will not succeed , i.e. , either it ends by deadlock , or by failure or it is infinite .",
    "it is important to notice that if we drop the nicely - modedness condition the above lemma would not hold any longer .",
    "for instance , it does not apply to the query @xmath2 of the introduction which is not nicely - moded .",
    "in fact , the leftmost atom of @xmath2 is resolvable only after the rightmost one has been resolved at least once .",
    "the following immediate corollary will be used in the sequel .",
    "[ cor - sw ] let the program @xmath11 and the query @xmath239 be nicely - moded .",
    "suppose that @xmath240 that is a partial input - consuming derivation of @xmath125 where @xmath241 and @xmath242 are obtained by partially resolving @xmath243 and @xmath49 , respectively .",
    "then there exists a partial input - consuming derivation @xmath244 where all the @xmath243-steps are performed in the prefix @xmath245 and @xmath144 .",
    "in this section we study the termination of input - consuming derivations . to this end",
    "we refine the ideas of bezem @xcite and cavedon @xcite who studied the termination of logic programs in a very strong sense , namely with respect to all selection rules , and of smaus @xcite who characterized terminating input - consuming derivations of programs which are both well and nicely - moded .",
    "we first introduce the key notion of this section .",
    "a program is called _ input terminating _",
    "iff all its input - consuming derivations started in a nicely - moded query are finite .",
    "the method we use in order to prove that a program is input terminating is based on the following concept of moded level mapping due to etalle _",
    "_ @xcite .",
    "let @xmath11 be a program and @xmath246 be the extended herbrand base is the set of equivalence classes of all ( possibly non - ground ) atoms , modulo renaming , whose predicate symbol appears in @xmath11 . as usual ,",
    "an atom is identified with its equivalence class . ] for the language associated with @xmath11 .",
    "a function @xmath247 is a _ moded level mapping for @xmath11 _ iff :    * it is a function @xmath248 from atoms to natural numbers ; * for any @xmath92 and @xmath249 , @xmath250 .    for @xmath251",
    ", @xmath252 is the _ level _ of @xmath43 .",
    "the condition @xmath253 states that the level of an atom is independent from the terms in its output positions .",
    "there is actually a small yet important difference between this definition and the one in @xcite : in @xcite the level mapping is defined on ground atoms only .",
    "indeed , in @xcite only well - moded atoms are considered , i.e. , atoms with ground terms in the input positions . here , instead",
    ", we are considering nicely - moded atoms whose input positions can be filled in by ( possibly ) non - ground terms .",
    "[ exa : modedlevelmapping ] let us denote by @xmath254 the term size of a term @xmath29 , that is the number of function and constant symbols that occur in @xmath29 .",
    "* a moded level mapping for the program append reported in the introduction is as follows : +    * a moded level mapping for the program reverse with accumulator of example [ i - c ] is the following : +    ( @xmath255 ) +      in order to give a sufficient condition for termination , we are going to employ a generalization of the concept of _ recurrent _ and of _ semi - recurrent _ program . the first notion ( which in the case of normal programs , i.e. , programs with negation , coincides with the one of _ acyclic program _ ) was introduced in @xcite and independently in @xcite in order to prove universal termination for all selection rules together with other properties of logic programs .",
    "later , apt and pedreschi @xcite provided the new definition of semi - recurrent program , which is equivalent to the one of recurrent program , but it is easier to verify in an automatic fashion . in order to proceed ,",
    "we need a preliminary definition .",
    "let @xmath11 be a program , @xmath80 and @xmath256 be relations .",
    "we say that _",
    "@xmath80 refers to @xmath256 _ in @xmath11 iff there is a clause in @xmath11 with @xmath80 in the head and @xmath256 in the body .",
    "we say that _",
    "@xmath80 depends on @xmath256 _ and write @xmath257 in @xmath11 iff @xmath258 is in the reflexive and transitive closure of the relation _ refers to_.    according to the above definition , @xmath259 means that @xmath80 and @xmath256 are mutually recursive , and @xmath260 means that @xmath80 calls @xmath256 as a subprogram .",
    "notice that @xmath261 is a well - founded ordering .",
    "finally , we can provide the key concept we are going to use in order to prove input termination .",
    "let @xmath11 be a program and @xmath262 be a moded level mapping .    * a clause of @xmath11",
    "is called _ quasi recurrent with respect to @xmath247 _ if for every instance of it , @xmath263 latexmath:[\\[\\label{eq : qr } \\mbox{if } \\mathit{rel}(h)\\simeq \\mathit { rel}(b ) \\mbox { then }    * a program @xmath11 is called _ quasi recurrent with respect to @xmath247 _ if all its clauses are .",
    "@xmath11 is called _ quasi recurrent _ if it is quasi recurrent wrt .   some moded level mapping @xmath265 .",
    "the notion of quasi recurrent program differs from the concepts of recurrent and of semi - recurrent program in two ways .",
    "first , we require that @xmath266 only for those body atoms which mutually depend on @xmath267 ; in contrast , both the concept of recurrent and of semi - recurrent program require that @xmath266 ( @xmath268 in the case of semi - recurrency ) also for the atoms for which @xmath269 . secondly , every instance of a program clause is considered , not only ground instances as in the case of ( semi-)recurrent programs .",
    "this allows us to treat directly any nicely - moded query without introducing the concept of _ boundedness _ @xcite or _ cover _ as in @xcite .",
    "it is worthwhile noticing that this concept almost coincides with the one of _ icd - acceptable _ program introduced and used in @xcite .",
    "we decided to use a different name because we believe that referring to the word acceptable might lead to confusion : the concept of acceptable program was introduced by apt and pedreschi @xcite in order to prove termination of logic programs using the left - to - right selection rule .",
    "the crucial difference between recurrency and acceptability lies in the fact that the latter relies on a model @xmath270 ; this allows condition ( [ eq : qr ] ) to be checked only for those body atoms which are in a way `` reachable '' wrt .",
    "hence , every recurrent program is acceptable but not vice - versa . as an aside , marchiori and teusink @xcite",
    "introduce the notion of _ delay recurrent _ program although their concept is based on the presence of a model @xmath270 .",
    "our definition does not rely on a model , and so it is much more related to the notion of recurrent than the one of acceptable program .",
    "we can now state our first basic result on termination , in the case of non - modular programs .",
    "[ thm : sufficiency ]",
    "let @xmath11 be a nicely - moded program .",
    "if @xmath11 is quasi recurrent then @xmath11 is input terminating .",
    "it will be obtained from the proof of theorem [ ter - modular ] by setting @xmath271 .",
    "consider the program @xmath272 defined in example [ programs ] .",
    "let @xmath247 be the moded level mapping for @xmath273 defined by     = ( @xmath255 ) + ( @xmath274 ) .",
    "it is easy to prove that merge is quasi recurrent wrt .",
    "the moded level mapping above . by theorem [ thm :",
    "sufficiency ] , all input - consuming derivations of merge started with a query @xmath275 , where @xmath276 is linear and variable disjoint from @xmath277 and @xmath29 , are terminating .",
    "this section contains a generalization of theorem [ thm : sufficiency ] to the modular case , as well as the complete proofs for it .",
    "the following lemma is a crucial one .",
    "[ inf ] let the program @xmath11 and the query @xmath278 be nicely - moded .",
    "suppose that there exists an infinite input - consuming derivation @xmath66 of @xmath125 . then , there exist an index @xmath115 and substitution @xmath16 such that    1",
    ".   there exists an input - consuming derivation @xmath217 of @xmath125 of the form @xmath279 2 .",
    "there exists an infinite input - consuming derivation of @xmath280 .",
    "let @xmath281 be an infinite input - consuming derivation of @xmath125 .",
    "then @xmath66 contains an infinite number of @xmath282-steps for some @xmath283 .",
    "let @xmath85 be the minimum of such @xmath284 .",
    "hence @xmath66 contains a finite number of @xmath285-steps for @xmath286 and there exists @xmath287 and @xmath288 such that @xmath289 where @xmath290 is a finite prefix of @xmath66 which comprises all the @xmath285-steps of @xmath66 for @xmath286 and @xmath291 is the subquery of @xmath292 consisting of the atoms resulting from some @xmath285-step ( @xmath286 ) . by corollary  [ cor - sw ]",
    ", there exists an infinite input - consuming derivation @xmath217 such that @xmath293 where @xmath294 .",
    "this proves ( i ) .",
    "now , let @xmath295 .",
    "note that in @xmath296 the atoms of @xmath287 will never be selected and , by remark [ smaus2 ] , will never be instantiated .",
    "let @xmath297 be obtained from @xmath296 by omitting the prefix @xmath287 in each query .",
    "hence @xmath297 is an infinite input - consuming derivation of @xmath298 where an infinite number of @xmath299-steps are performed .",
    "again , by remark [ smaus2 ] , for every finite prefix of @xmath297 of the form @xmath300 where @xmath301 and @xmath302 are obtained by partially resolving @xmath303 and @xmath304 , respectively , and @xmath305 is an @xmath285-step for some @xmath306 , we have that @xmath307 .",
    "hence , from the hypothesis that there is an infinite number of @xmath299-steps in @xmath296 , it follows that there exists an infinite input - consuming derivation of @xmath280 .",
    "this proves ( ii ) .",
    "the importance of the above lemma is shown by the following corollary of it , which will allow us to concentrate on queries containing only one atom .",
    "[ cor : inf - one - atom ] let @xmath11 be a nicely - moded program .",
    "@xmath11 is input terminating iff for each nicely - moded one - atom query @xmath43 all input - consuming derivations of @xmath203 are finite .    we can now state the main result of this section . here and in what follows",
    "we say that a relation @xmath80 is _ defined in _",
    "the program @xmath11 if @xmath80 occurs in a head of a clause of @xmath11 , and that @xmath11 _ extends _ the program @xmath308 if no relation defined in @xmath11 occurs in @xmath308 .",
    "[ ter - modular ] let @xmath11 and @xmath308 be two programs such that @xmath11 extends @xmath308 .",
    "suppose that    * @xmath308 is input terminating , * @xmath11 is nicely - moded and quasi recurrent wrt .   a moded level mapping @xmath309 .",
    "then @xmath310 is input terminating .",
    "first , for each predicate symbol @xmath80 , we define @xmath311 to be the number of predicate symbols it depends on .",
    "more formally , @xmath311 is defined as the cardinality of the set @xmath312 .",
    "clearly , @xmath311 is always finite .",
    "further , it is immediate to see that if @xmath313 then @xmath314 and that if @xmath315 then @xmath316",
    ".    we can now prove our theorem . by corollary [ cor : inf - one - atom ] ,",
    "it is sufficient to prove that for any nicely - moded one - atom query @xmath43 , all input - consuming derivations of @xmath203 are finite .    first notice that if @xmath43 is defined in @xmath308 then the result follows immediately from the hypothesis that @xmath308 is input terminating and that @xmath11 is an extension of @xmath308 .",
    "so we can assume that @xmath43 is defined in @xmath11 .",
    "for the purpose of deriving a contradiction , assume that @xmath66 is an infinite input - consuming derivation of @xmath317 such that @xmath43 is defined in @xmath11 .",
    "then @xmath318 where @xmath319 is the input clause used in the first derivation step and @xmath320 .",
    "clearly , @xmath321 has an infinite input - consuming derivation in @xmath310 . by lemma [ inf ] , for some @xmath115 and for some substitution @xmath322 ,    1 .",
    "there exists an infinite input - consuming derivation of @xmath323 of the form @xmath324 2 .",
    "there exists an infinite input - consuming derivation of @xmath325    notice also that @xmath326 is nicely - moded .",
    "let now @xmath144 . note that @xmath327 is an instance of a clause of  @xmath11 .",
    "we show that ( 2 ) can not hold .",
    "this is done by induction on @xmath328 wrt .",
    "the ordering @xmath329 defined by : @xmath330 iff either @xmath331 or @xmath332 and @xmath333 .    _",
    "base_. let @xmath334 ( @xmath252 is arbitrary ) . in this case",
    ", @xmath43 does not depend on any predicate symbol of @xmath11 , thus all the @xmath335 as well as all the atoms occurring in its descendents in any input - consuming derivation are defined in @xmath308 . the hypothesis that @xmath308 is input terminating contradicts @xmath336 above .    _",
    "induction step_. we distinguish two cases :    1 .",
    "@xmath337 , 2 .",
    "@xmath338 .    in case",
    "@xmath148 we have that @xmath339 .",
    "so , @xmath340 .",
    "in case  @xmath151 , from the hypothesis that @xmath11 is quasi recurrent wrt .",
    "@xmath247 , it follows that @xmath341 .",
    "consider now the partial input - consuming derivation @xmath342 . by corollary  [ corollary ] and",
    "the fact that @xmath247 is a moded level mapping , it follows that @xmath343 .",
    "therefore , @xmath344 . in both cases , the contradiction follows by the inductive hypothesis .",
    "[ exa : flatten ] the program flatten using difference - lists is nicely - moded with respect to the modes described below , provided that one replaces `` @xmath345 '' by `` , '' , as we have done here .",
    "mode flatten(in , out ) .",
    "+ mode flatten_dl(in , out , in ) .",
    "+ mode constant(in ) .",
    "+ mode @xmath346(in , in ) .",
    "+ flatten(xs , ys ) @xmath0flatten_dl(xs , ys , [ ] ) .",
    "+ flatten_dl ( [ ] , ys , ys ) . + flatten_dl(x,[x|xs],xs ) @xmath0constant(x ) , x @xmath346 [ ] .",
    "+ flatten_dl([x|xs],ys , zs ) @xmath0= flatten_dl(xs , y1s , zs ) , + flatten_dl(x , ys , y1s ) .",
    "consider the moded level mapping for @xmath347 defined by     ( @xmath255 ) +    = ( @xmath255 ) .",
    "it is easy to see that the program flatten is quasi recurrent wrt .",
    "the moded level mapping above .",
    "hence , all input - consuming derivations of program flatten started with a query ` flatten(s , t ) ` , where @xmath29 is linear and variable disjoint from @xmath6 , are terminating .",
    "theorem [ thm : sufficiency ] provides a sufficient condition for termination .",
    "the condition is not necessary , as demonstrated by the following simple example .",
    "mode p(in , out ) .",
    "+ p(x , a ) @xmath0p(x , b ) .",
    "+ p(x , b ) .",
    "this program is clearly input terminating , however it is not quasi recurrent .",
    "if it was , we would have that @xmath348 , for some moded level mapping @xmath247 ( otherwise the first clause would not be quasi recurrent ) . on the other hand , since @xmath349 and @xmath350 differ only for the terms filling in their output positions , by definition of moded level mapping , @xmath351 . hence , we have a contradiction .    nevertheless , as shown by other works , e.g. , @xcite , it is important to be able to give a characterization of termination , i.e. , a condition which is _ necessary _ and sufficient to ensure termination . to this purpose",
    "is dedicated this section .      as demonstrated by the example above , in order to provide a necessary condition for termination we need to further restrict the class of programs we consider .",
    "the first problem is that we should rule out those situations in which termination is guaranteed by the instantiation of the output positions of some selected atom , as it happens in the above example . for this",
    "we restrict to _ simply - moded _ programs which are nicely - moded programs with the additional condition that the output arguments of clause bodies are variables .    *",
    "a query @xmath87 ( resp . , a clause @xmath352 ) is _ simply - moded _ if it is nicely - moded and @xmath353 is a linear sequence of variables . *",
    "a program @xmath11 is simply - moded iff all of its clauses are simply - moded .",
    "it is important to notice that most programs are simply - moded ( see the mini - survey at the end of @xcite ) and that often non simply - moded programs can naturally be transformed into simply - moded ones .",
    "[ programs - sm ]    * the programs reverse of example [ i - c ] , merge of example [ programs ] and flatten of example [ exa : flatten ] are all simply - moded . *",
    "consider the program last which extends reverse : + mode last(in , out ) .",
    "+ last(ls , e)@xmath0reverse(ls,[e| _ ] ) .",
    "+ this program is not simply - moded since the argument filling in the output position in the body of the first clause is not a variable .",
    "however , it can be transformed into a simply - moded one as follows : + mode last(in , out ) .",
    "+ mode selectfirst(in , out ) .",
    "+ last(ls , e)@xmath0reverse(ls , rs ) , selectfirst(rs , e ) .",
    "+ selectfirst([e|_],e ) .",
    "the following lemma , which is an immediate consequence of lemma 30 in @xcite , shows the persistence of the notion of simply - modedness .",
    "[ lemma : s - persistence ] every resolvent of a simply - moded query @xmath87 and a simply - moded clause @xmath55 , where the derivation step is input - consuming and @xmath354 , is simply - moded .",
    "unfortunately , the restriction to simply - moded programs alone is not sufficient to extend theorem [ thm : sufficiency ] by a necessary condition .",
    "consider for instance the following program ` quicksort ` :    mode qs(in , out ) .",
    "+ mode part(in , in , out , out ) . + mode app(in , in , out ) . + qs ( [ ] , [ ] ) . + @xmath355 qs([x|xs],ys ) @xmath0part(x , xs , littles , bigs ) , + qs(littles , ls ) , + qs(bigs , bs ) , + app(ls,[x|bs],ys )",
    ". + part(x , [ ] , [ ] , [ ] ) .",
    "+ part(x,[y|xs],[y|ls],bs ) @xmath0x > y , part(x , xs , ls , bs ) .",
    "+ part(x,[y|xs],ls,[y|bs ] ) @xmath0x<=y , part(x , xs , ls ,",
    "this program is simply - moded and input terminating .",
    "however it is not quasi recurrent . indeed",
    ", there exist no moded level mapping @xmath247 such that , for every variable - instance , @xmath356,ys)}| > |\\mathtt{qs(littles , ls)}|$ ] and @xmath356,ys)}| > |\\mathtt{qs(bigs , bs)}|$ ] .",
    "this is due to the fact that , in clause @xmath357 there is no direct link between the input arguments of the recursive calls and those of the clause head .",
    "this motivates the following definition of _ input - recursive _ programs .",
    "let @xmath11 be a program .",
    "* a clause @xmath263 of @xmath11 is called _ input - recursive _ if @xmath358 * a program @xmath11 is called _ input - recursive _ if all its clauses are .",
    "thus , we say that a clause is input - recursive if the set of variables occurring in the arguments filling in the input positions of each recursive call in the clause body is a subset of the set of variables occurring in the arguments filling in the input positions of the clause head .",
    "input - recursive programs have strong similarities with primitive recursive functions .",
    "[ programs - ir ]    * the programs append of the introduction , reverse of example [ i - c ] and merge of example [ programs ] are all input - recursive .",
    "* the program flatten of example [ exa : flatten ] is not input - recursive .",
    "this is due to the presence of the fresh variable ` y1s ` in a body atom of the last clause . * ` quicksort ` , is not input - recursive .",
    "in particular , clause @xmath357 is not input - recursive .",
    "we can now prove that by restricting ourselves to input - recursive and simply - moded programs , the condition of theorem [ thm : sufficiency ] is also a necessary one .    to prove this , we follow the approach of apt and pedreschi when characterizing terminating programs @xcite .",
    "first we introduce the notion of _ ic - tree _ that corresponds to the notion of _ s - tree _ in @xcite and provides us with a representation for all input - consuming derivations of a program @xmath11 with a query @xmath87 , then we define a level mapping which associates to every atom @xmath43 the number of nodes of a given ic - tree and finally we prove that @xmath11 is quasi recurrent wrt .   such a level mapping .",
    "[ def : i - tree ] an _ ic - tree _ for @xmath359 is a tree whose nodes are labelled with queries such that    * its branches are input - consuming derivations of @xmath359 , * every node @xmath87 has exactly one descendant for every atom @xmath43 of @xmath87 and every clause @xmath55 from @xmath11 such that @xmath43 is input - consuming resolvable wrt .",
    "this descendant is a resolvent of @xmath87 and @xmath55 wrt .",
    "@xmath43 .    in this tree ,",
    "a node s children consist of all its resolvents , `` modulo renaming '' , via an input - consuming derivation step wrt .",
    "all the possible choices of a program clause and a selected atom .",
    "[ lemma : i - tree1 ] an ic - tree for @xmath359 is finite iff all input - consuming derivations of @xmath359 are finite .    by definition , the ic - trees are finitely branching .",
    "the claim now follows by knig s lemma .",
    "notice that if an ic - tree for @xmath359 is finite then all the ic - trees for @xmath359 are finite .    for a program @xmath11 and a query @xmath87 ,",
    "we denote by @xmath360 the number of nodes in an ic - tree for @xmath359 .",
    "the following properties of ic - trees will be needed .",
    "[ lemma : i - tree2 ] let @xmath11 be a program , @xmath87 be a query and @xmath361 be a finite ic - tree for @xmath359 .",
    "then    * for all non - root nodes @xmath362 in @xmath361 , @xmath363 , * for all atoms @xmath43 of @xmath87 , @xmath364 .",
    "immediate by definition [ def : i - tree ] of ic - tree .",
    "we can now prove the desired result .",
    "[ thm : necessity ] let @xmath11 be a simply - moded and input - recursive program .",
    "if @xmath11 is input terminating then @xmath11 is quasi recurrent .",
    "we show that there exists a moded level mapping @xmath247 for @xmath11 such that @xmath11 is quasi recurrent wrt .",
    "@xmath247 .    given an atom @xmath43",
    ", we denote with @xmath365 an atom obtained from @xmath43 by replacing the terms filling in its output positions with fresh distinct variables .",
    "clearly , we have that @xmath365 is simply - moded .",
    "then we define the following moded level mapping for @xmath11 : @xmath366 notice that , the level @xmath252 of an atom @xmath43 is independent from the terms filling in its output positions , i.e. , @xmath247 is a moded level mapping . moreover , since @xmath11 is input terminating and @xmath365 is simply - moded ( in particular , it is nicely - moded ) , all the input - consuming derivations of @xmath367 are finite .",
    "therefore , by lemma  [ lemma : i - tree1 ] , @xmath368 is defined ( and finite ) , and thus @xmath252 is defined ( and finite ) for every atom @xmath43 .",
    "we now prove that @xmath11 is quasi recurrent wrt .",
    "@xmath247 .",
    "let @xmath369 be a clause of @xmath11 and @xmath370 be an instance of @xmath55 ( for some substitution @xmath16 ) .",
    "we show that @xmath371 .",
    "hence , @xmath372 where @xmath373 is a sequence of fresh distinct variables .",
    "consider a variant @xmath374 of @xmath55 variable disjoint from @xmath375 .",
    "let @xmath105 be a renaming such that @xmath376 .",
    "clearly , @xmath375 and @xmath377 unify .",
    "let @xmath378 . by properties of substitutions ( see @xcite ) ,",
    "since @xmath373 consists of fresh variables , there exists two relevant mgu @xmath177 and @xmath178 such that    * @xmath379 , * @xmath380 .    since @xmath381",
    ", we can assume that @xmath382 . because of standardization apart , since @xmath373 consists of fresh variables , @xmath383 and thus @xmath384 . since @xmath373 is a sequence of variables",
    ", we can also assume that @xmath385 .",
    "therefore @xmath386 .",
    "moreover , since @xmath387 , we have that @xmath388 is an input - consuming derivation step , i.e. , @xmath389 is a descendant of @xmath375 in an ic - tree for @xmath390 .    by definition of @xmath391 , @xmath392 ;",
    "hence @xmath393    let now @xmath394 . by ( [ eq : stheta ] ) and the hypothesis that @xmath55 is input - recursive , that is @xmath395",
    ", it follows that @xmath396 moreover , since @xmath397 is simply - moded , @xmath398 .",
    "hence , by definition of @xmath391 and standardization apart , @xmath399 , i.e. , @xmath400 therefore , by ( [ eq : utheta ] ) and ( [ eq : vrhomu ] ) , @xmath401 , i.e. , @xmath402 hence , +   + @xmath403 +",
    "this section is intended to show through some examples the applicability of our results .",
    "then , programs from various well - known collections are analyzed .",
    "it is worth noticing that , since the definition of input - consuming derivation is independent from the textual order of the atoms in the clause bodies , the results we have provided ( theorems [ thm : sufficiency ] , [ ter - modular ] and [ thm : necessity ] ) hold also in the case that programs and queries are _ permutation",
    "_ nicely- ( or simply- ) moded @xcite , that is programs and queries which would be nicely- ( or simply- ) moded after a permutation of the atoms in the bodies .",
    "therefore , for instance , we can apply theorems [ thm : sufficiency ] and [ ter - modular ] to the program @xmath347 as it is presented in @xcite ( except for the replacement of `` @xmath345 '' with `` , '' ) , i.e. ,    flatten(xs , ys ) @xmath0flatten_dl(xs , ys , [ ] ) .",
    "+ flatten_dl ( [ ] , ys , ys ) . + flatten_dl(x,[x|xs],xs ) @xmath0constant(x ) , x @xmath346 [ ] .",
    "+ flatten_dl([x|xs],ys , zs ) @xmath0= flatten_dl(x , ys , y1s ) , + flatten_dl(xs , y1s , zs ) .    where the atoms in the body of the last clause are permuted with respect to the version of example [ exa : flatten ] .",
    "+ let us consider again the program ` append ` of the introduction with its natural delay declaration :    mode app(in , in , out ) + app ( [ ] , ys , ys ) . + app([h|xs],ys,[h|zs ] ) @xmath0app(xs , ys , zs ) .",
    "delay app(xs , _ , _ ) until nonvar(xs ) .",
    "let @xmath404 be the set of one - atom queries of the form ` app(s , t , z ) ` where @xmath6 and @xmath29 are any terms and @xmath405 is a variable disjoint from @xmath6 and @xmath29 .",
    "observe that @xmath404 is closed under resolution : each resolvent in a derivation starting in a query from @xmath404 is still a query from @xmath404 .",
    "moreover , because of the presence of the delay declaration , only atoms whose first argument is a non - variable term are allowed to be selected .",
    "thus , selectable atoms have the form ` app(s , t , z ) ` where    * @xmath6 is a non - variable term , * @xmath29 is any term and @xmath405 is a variable disjoint from @xmath6 and @xmath29 .    any derivation of ` append ` starting in a query of @xmath404 is similar to an input - consuming one .",
    "this follows from the fact that for any selectable atom @xmath43 and clause s head @xmath48 , there exists a mgu @xmath16 which does not affect the input arguments of @xmath43 .",
    "in fact , let @xmath43 be a selectable atom of @xmath404 .",
    "if @xmath43 unifies with the head of the first clause then , by @xmath406 , @xmath6 is the empty list ` [ ] ` and @xmath407 . otherwise , if @xmath43 unifies with the head of the second clause then , by @xmath406 , @xmath6 is a term of the form ` [ s_1|s_2 ] ` and @xmath408\\}$ ] .",
    "by @xmath336 it follows that , in both cases , @xmath409 and @xmath410 , i.e. , @xmath16 does not affect the input arguments of @xmath43 .    moreover , it is easy to check that append is quasi recurrent wrt .",
    "the moded level mapping depicted in example [ exa : modedlevelmapping ] .",
    "since it is nicely - moded , by applying theorem [ thm : sufficiency ] it follows that it is input terminating . by the arguments above",
    ", we can conclude that all the derivations of @xmath411 in presence of the delay declaration @xmath8 and starting in a ( permutation ) nicely - moded query are finite .",
    "hence , in particular , we can state that all the derivations of ` append ` starting in the query @xmath2 of the introduction , which is not nicely - moded but it is permutation nicely - moded , are finite .",
    "in order to assess the applicability of our results , we have looked into four collections of logic programs , and we have checked those programs against the three classes of programs : ( permutation ) nicely - moded , input terminating and quasi recurrent programs .",
    "the results are reported in tables 1 to 4 .",
    "these tables clearly show that our results apply to the large majority of the programs considered .    in table 1",
    "the programs from apt s collection are considered , see @xcite .",
    "the programs from the dppd s collection , maintained by leuschel and available at the url : http://dsse.ecs.soton.ac.uk/@xmath412mal/systems/dppd.html , are referred to in table 2 .",
    "table 3 considers various programs from lindenstrauss s collection ( see the url : http://www.cs.huji.ac.il/@xmath412naomil ) .",
    "finally , in table 4 one finds the ( almost complete ) list of programs by f. bueno , m. garcia de la banda and m. hermenegildo that can be found at the url : http://www.clip.dia.fi.upm.es .    for each program",
    "we specify the name and the modes of the main procedure",
    ". then we report whether or not the program is ( permutation ) nicely - moded ( * nm * ) , input terminating ( * it * ) , and quasi recurrent ( * qr * ) .",
    "notice that for programs which are not input terminating , because of theorem [ thm : sufficiency ] , it does not make sense to check whether or not they are quasi recurrent . for this reason , we leave blank the cells in the column * qr * corresponding to non - input terminating programs .    finally , table 5 reports the list of programs from previous tables which have been found to be input terminating but not quasi recurrent . for these programs ,",
    "the notion of quasi recurrency does not provide an exact characterization of input termination .",
    "in particular , theorem [ thm : necessity ] does not apply . in order to understand which of the hypothesis of the theorem does not hold",
    ", we report in table 5 whether or not these programs are simply - moded ( * sm * ) and input - recursive ( * ir * ) .",
    "in this paper we studied the properties of input - consuming derivations of nicely - moded programs .",
    "this study is motivated by the widespread use of programs using dynamic scheduling controlled by delay declarations .",
    "in fact , as we have motivated in section [ sec : ic - dd ] , we believe that in most practical programs employing delay declarations these constructs are used for guaranteeing that the derivation steps are input - consuming .    in the first place",
    ", we showed that for nicely - moded programs a weak version of the well - known switching lemma holds : if , given a query @xmath413 , @xmath210 is selected before @xmath56 in an input - consuming derivation , then the two resolution steps can be interchanged while maintaining that the derivation is input - consuming .      in the literature ,",
    "the paper most related to the present one is certainly @xcite .",
    "our results strictly generalize those in @xcite in the fact that we drop the condition that programs and queries have to be well - moded .",
    "this is particularly important in the formulation of the queries .",
    "for instance , in the program ` flatten ` of example [ exa : flatten ] , our results show that every input - consuming derivation starting in a query of the form @xmath414 terminates provided that @xmath29 is linear and disjoint from @xmath6 , while the results of @xcite apply only if @xmath29 is a ground term .",
    "note that well - moded queries ( in well - moded programs ) never terminate by deadlock , since the leftmost atom of each resolvent is ground in its input positions and hence selectable .",
    "this does not hold for nicely - moded queries which might deadlock .",
    "our method allows us thus to cope also with this more difficult situation : for instance we can prove that all derivations of ` append ` starting in @xmath415 are terminating . in practice the result of @xcite identify a class of programs and queries which is both terminating and _",
    "deadlock free_. while deadlock is clearly an undesirable situation , there are various reasons why one might want to prove termination independently from the absence of deadlock : in the first place , one might want to prove absence of deadlock using a different tool than by employing well - moded programs .",
    "secondly , in some situations absence of deadlock might be difficult or impossible to prove , like in a modular context in which the code of some module is not known , hence not analyzable : consider for instance the query ` generator_1(x1s ) , generator_2(x2s ) , append(x1s , x2s , zs ) . ` , where the generators are defined in different modules ; our results allow us to demonstrate that if the ` generator`s terminate , then the above query terminates . on the other hand , one can not determine whether it is deadlock free unless one has a more precise specification of the generators .",
    "thirdly , it is well - known that one of the goals of dynamic scheduling is precisely enforcing termination ; in this respect a deadlock can be regarded as the situation in which `` all else failed '' .",
    "our system allows us to check how effective dynamic scheduling is in enforcing termination .    concluding our comparison with @xcite , for the class of ( permutation )",
    "simply - moded and input - recursive programs , we provide an exact characterization of input termination .",
    "a similar result is not present in @xcite .",
    "apt and luitjes @xcite have also tackled the problem of the termination of programs in presence of dynamic scheduling .",
    "the techniques employed in it are based on determinacy checks and the presence of successful derivations , thus are completely different from ours .",
    "it is nevertheless worth mentioning that @xcite reports a special ad - hoc theorem , in order to prove that , if @xmath416 is linear and disjoint from @xmath6 then the query @xmath417 terminates .",
    "this is reported in order to show the difficulties one encounters in proving termination in presence of dynamic scheduling .",
    "now , under the further ( mild ) additional condition that @xmath416 be disjoint from @xmath29 , the termination of @xmath417 is a direct consequence of our main result .",
    "another related paper is the one by marchiori and teusink @xcite .",
    "however , marchiori and teusink make a strong restriction on the selection rule , which has to be _ local _ ; this restriction actually forbids any form of coroutining .",
    "moreover , @xcite allows only _ safe _ delay declarations ; we do not report here the definition of _ safe _ delay declaration , we just say that it is rather restrictive : for instance , the delay declaration we have used for ` append ` is not safe ( a safe one would be ` delay app(x , _ , _ ) until list(x ) ` ) .",
    "actually , their requirements go beyond ensuring that derivations are input - consuming .",
    "applicability and effectiveness of our results have been demonstrated by matching our main definitions against the programs of four public program lists .",
    "these benchmarks showed that most of the considered programs are nicely - moded ( for a suitable mode ) and quasi recurrent ( wrt .",
    "a suitable level mapping ) .",
    "k.  r. apt and i.  luitjes .",
    "verification of logic programs with delay declarations . in a.",
    "borzyszkowski and s.  sokolowski , editors , _ proceedings of the fourth international conference on algebraic methodology and software technology , ( amast95 ) _ , lecture notes in computer science , berlin , 1995 .",
    "springer - verlag .",
    "k.  r. apt .",
    "introduction to logic programming . in j.",
    "van leeuwen , editor , _ handbook of theoretical computer science _",
    ", volume b : formal models and semantics , pages 495574 .",
    "elsevier , amsterdam and the mit press , cambridge , 1990 .",
    "l.  cavedon .",
    "continuity , consistency and completeness properties for logic programs . in g.",
    "levi and m.  martelli , editors , _ 6 international conference on logic programming _ , pages 571584 .",
    "mit press , 1989 .",
    "l.  naish . parallelizing nu - prolog . in kenneth",
    "a. bowen and robert  a. kowalski , editors , _ proceedings of the fifth international conference / symposium on logic programming _ ,",
    "pages 15461564 , seattle , washington , august 1988 .",
    "smaus , p.  m. hill , and a.  m. king .",
    "termination of logic programs with block declarations running in several modes .",
    "in c.  palamidessi , editor , _ proceedings of the 10th symposium on programming language implementations and logic programming _ , lncs .",
    "springer - verlag , 1998 .          k.  ueda .",
    "uarded horn clauses , a parallel logic programming language with the concept of a guard . in m.",
    "nivat and k.  fuchi , editors , _ programming of future generation computers _ , pages 441456",
    ". north holland , amsterdam , 1988 ."
  ],
  "abstract_text": [
    "<S> we study the properties of input - consuming derivations of moded logic programs . </S>",
    "<S> input - consuming derivations can be used to model the behavior of logic programs using dynamic scheduling and employing constructs such as _ delay declarations_.    we consider the class of _ nicely - moded _ programs and queries . </S>",
    "<S> we show that for these programs a weak version of the well - known _ switching lemma _ holds also for input - consuming derivations . </S>",
    "<S> furthermore , we show that , under suitable conditions , there exists an algebraic characterization of termination of input - consuming derivations . </S>"
  ]
}