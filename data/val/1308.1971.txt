{
  "article_text": [
    "peer - to - peer communication , when applied to streaming , is attractive because it enables the total bandwidth for service to scale with demand @xcite .",
    "scheduling algorithms need to be designed so that upload capacity provided by nodes can be utilized efficiently to serve the demand , and each node can download streams , providing playback continuity with small delay .",
    "the system needs to be robust enough to tolerate peer churn , link failures , and congestion .",
    "many designs have been proposed for p2p streaming .",
    "unstructured topologies with nodes constantly sampling new targets for new pieces are considered in @xcite .",
    "data dissemination algorithms based on mesh topologies are given in @xcite .",
    "in @xcite , random hamiltonian cycles are constructed and tangled and pieces are broadcasted around the union of the cycles .",
    "fixed underlying topologies are considered in @xcite and flows are scheduled between neighbors .",
    "algorithms to manage multiple distribution trees to disseminate different substreams of a video or audio are discussed in @xcite , but those papers do not concentrate on distributed algorithms .",
    "unstructured streaming systems are simple to manage and scale well , but playback continuity is sacrificed because constantly building and removing links requires prohibitive overhead .",
    "tree structures can provide good playback continuity with small startup delay , but can be difficult to manage , especially in a distributed way . in this paper",
    "we study how to manage trees for p2p streaming as in @xcite , but with a focus on distributed algorithms .",
    "consider a complete underlying network for control information , so arbitrary node to node contact is allowed . to model the bandwidth constraint for control information",
    ", we only allow each node to randomly contact a target from other nodes periodically at a certain constant rate .",
    "this setting , which is more suitable for p2p systems , is different from settings in @xcite , which discuss how to build multicast trees satisfying certain metrics under a fixed underlying topology .",
    "most problems formulated in @xcite are shown to be np hard and approximation algorithms are designed . in this paper",
    "we avoid np completeness with a homogeneous and complete underlying topology .",
    "the streaming network is built on top of the underlying network , through the cooperation of nodes . besides the bandwidth constraint on exchanging control information ,",
    "nodes have heterogeneous upload capacity so each of them has a maximum fan - out degree for streaming .",
    "nodes have a small buffer to store information about their parents and children in the streaming network .",
    "they can exchange messages with their parents and children , at the same time they can also exchange messages with their sampled targets at the sampling times . as in @xcite , we assume the video is cut into substreams , source coding like multiple description coding ( mdc @xcite ) is applied to provide redundancy in data . multiple diverse distribution trees , which constitute the streaming network , are constructed and managed , each for one substream .",
    "in @xcite it is mentioned that a good tree management algorithm should maintain 1 ) short trees , i.e. , trees have small depths so as to minimize the probability of disruption due to peer transience or congestion ; 2 ) tree diversity , i.e. , the set of ancestors of a node in each tree are as disjoint as possible so as to increase the effectiveness of the mdc - based distribution scheme ; 3 ) quick processing of node joins and leaves , and ; 4 ) scalability .",
    "centralized solutions in @xcite are proposed to achieve those goals . in this paper , an asynchronous distributed algorithm",
    "is designed to manage multiple trees , with the following properties :    1 .",
    "each node can receive enough substreams .",
    "depths of trees are logarithmic in the number of peers .",
    "3 .   trees are diverse and balanced .",
    "cycles are eliminated efficiently in a distributed way .",
    "convergence is fast , providing robustness to peer transience .",
    "6 .   nodes with higher upload capacity tend to be closer to the roots of the trees .",
    "heterogeneous upload capacity is supported , even in the case a few nodes with large degree act as servers and other nodes act as clients .",
    "convergence is insured even when the ratio of total demand to total upload capacity , @xmath0 , is one , and it converges more quickly as @xmath0 decreases from one .",
    "analyzing the complexity for message exchange for the algorithm is quite challenging .",
    "we show that the convergence time is stochastically tightly bounded by @xmath1 where @xmath2 is the number of nodes , both by theoretical analysis in the case of a single tree and by simulation . during a sampling interval @xmath3 messages",
    "are exchanged .",
    "so we conjecture that with high probability , only @xmath4 messages need to be exchanged before the algorithm converges",
    ".    other related work for p2p message transmission includes @xcite , which focus on modeling the performance of file sharing networks .",
    "the paper is organized as follows .",
    "the model is introduced in . the main algorithm and the proof of convergence",
    "are provided in .",
    "bounds on the convergence time are covered in .",
    "simulations are provided in which show that the algorithm works well even when most assumptions imposed in for theoretical tractability do not hold .",
    "consider a network containing one server and @xmath2 users ( nodes ) , labeled as @xmath5 .",
    "one video to be broadcast from the server to all nodes is cut into @xmath6 substreams .",
    "each substream is transmitted through a directed broadcast tree .",
    "we consider the problem of how to build broadcast trees , so as to avoid interference , achieve coverage and reduce delay .",
    "depth , @xmath7.,title=\"fig:\",width=245 ]    in this paper we consider a flow level model .",
    "let @xmath8 denote the set of @xmath2 nodes .",
    "as illustrated in , assume there are @xmath6 root nodes ( or roots , @xmath9 ) in @xmath8 , each of which always has an incoming link from the server , and always receives a distinct substream via such link .",
    "each root works as an `` agent '' of the server to further distribute its received substream .",
    "let @xmath10 denote the set of roots",
    ". for convenience , assume the root nodes are nodes 1 through @xmath6 , and label each substream by the label of the root receiving the stream from the server .",
    "assume nodes in @xmath8 can randomly contact each other and build directed links among themselves .",
    "let @xmath11 denote the set of all such links . through each link one and only one substream can be transmitted from the tail to the head of the link .",
    "assume that at the time a link is built , the substream to be transmitted on it is also determined .",
    "assume each link is colored by the label of the substream transmitted on it .",
    "let @xmath12 denote the set of all links with color @xmath13 for @xmath14 .",
    "the set of all @xmath12 s is a partition of @xmath11 .",
    "_ a node @xmath15 can receive substream @xmath13 if and only if in graph @xmath16 there is a directed path from root @xmath13 to @xmath15 ; and the delay of receiving substream @xmath13 is modeled by the number of hops of the shortest path from @xmath13 to @xmath15_. let @xmath17 denote the set of nodes to which there exists a path from root @xmath13 in @xmath16 .",
    "that is , @xmath17 is the set of nodes which can receive substream @xmath13 .",
    "assume that to recover the video , a node @xmath15 must receive at least @xmath18 substreams : @xmath19 .",
    "it is possible that @xmath20 , corresponding to the use of source coding .",
    "assume each node has a constraint on upload capacity ( outdegree ) : node @xmath15 can build at most @xmath21 outgoing links , whatever their colors are",
    ". contains examples of @xmath22 for @xmath23 and @xmath7 , where roots have outdegree one and other nodes have outdegree two . in , for each root @xmath13 , @xmath16 is a spanning tree with the minimum depth under out degree constraint , with the tree depth defined as the maximum number of hops over all root - leaf paths .",
    "five types of link updates are considered in this paper , as shown in .",
    "each link update can be executed locally because at most four nodes are involved .",
    "notice that link updates in are just combinations of building a link and removing a link .",
    "any node on the left side of a link update in can initiate that update , by exchanging messages with other nodes involved .",
    "assume each node maintains a poisson clock which ticks at rate @xmath24 , independently of poisson clocks of other nodes .",
    "whenever the clock of a node ticks , the node samples a target from other nodes uniformly at random , and decides whether to execute link updates in or not .",
    "_ in this paper , we assume link updates happen instantaneously , but at most one update can be executed at each sampling . _",
    "it makes the problem tractable and is also a reasonable relaxation because one link update consists of building at most two links and removing at most two links . in this paper",
    "we normalize the time so @xmath24 .",
    "in , the spanning tree for each substream has @xmath25 depth . in the next section",
    ", we show our algorithm , under which @xmath11 is repeatedly updated until no more updates are possible , insures that all substreams can be broadcasted through distinct trees with @xmath25 depth and each node can receive enough substreams for the video . for convenience ,",
    "notations are listed :    * @xmath26 the _ depth to @xmath13 of @xmath15 , defined as the minimum number of hops from root @xmath14 to @xmath15 in @xmath16 .",
    "define @xmath27 if no path exists from @xmath13 to @xmath15 in @xmath16 .",
    "_ * @xmath28 the depth to @xmath13 buffered by @xmath15 , which keeps updating . *",
    "@xmath29 for each @xmath30 .",
    "* @xmath13-link : an @xmath13-link refers to a link colored @xmath13 . *",
    "@xmath13-parent : @xmath15 is an @xmath13-parent of @xmath31 if @xmath32 . * @xmath13-child : @xmath31 is an @xmath13-child of @xmath15 if @xmath33 .",
    "* @xmath13-leaf : node @xmath15 is an @xmath13-leaf if @xmath34 .",
    "* @xmath13-internal : node @xmath15 is an @xmath13-internal node if @xmath35 . * @xmath36 the number of outgoing @xmath13-links of node @xmath15 .",
    "let @xmath37 be the total number of outgoing links of @xmath15 .",
    "* available : node @xmath15 is _",
    "available if @xmath15 has an incoming link and @xmath38 .",
    "_ * mixed node : a node is mixed if it has outgoing links with at least two colors .",
    "* mixed-@xmath13-@xmath39-node : node @xmath15 is a mixed-@xmath13-@xmath39-node if @xmath40 . * write @xmath41 for two sequences to mean @xmath42 .",
    "our main algorithm is summarized in as , which is a topology update procedure ran after nodes randomly contact each other . in the following we introduce by parts .",
    "notice that by assumption in running of is instantaneous .",
    "assume each node knows its parents , children , and colors of its incoming and outgoing links .",
    "each node buffers its depths to all roots . to begin",
    ", we assume at time @xmath43 @xmath22 satisfies .",
    "[ a.init ]     at time @xmath43 , @xmath22 satisfies the following :    1 .",
    "each node @xmath15 has at most @xmath44 incoming links , has at most one incoming @xmath13-link for each @xmath14 , and at most @xmath21 outgoing links , which implies that , 2 .",
    "@xmath45 is a directed tree rooted at @xmath13 for each @xmath14 .",
    "notice that 1 ) implies 2 ) in . and notice that cycles may appear in @xmath46 even if @xmath45 is a tree , as shown in .",
    "can be easily satisfied by requiring all nodes to remove extra incoming or outgoing links at time @xmath43 .",
    "we will show that the properties in are preserved by the update procedures we shall define . in the following the procedure for depth update is discussed first .",
    "each node buffers its depths to each root @xmath14 .",
    "notice @xmath47 denotes the depth to @xmath13 buffered by node @xmath15 .",
    "if node @xmath15 is root @xmath13 , @xmath15 sets @xmath47 to @xmath43 ; otherwise ,    * if @xmath15 has no incoming @xmath13-links , @xmath15 sets @xmath47 to @xmath48 ; * if @xmath15 has incoming @xmath13-links , let @xmath49 be the minimum depth to @xmath13 buffered by all @xmath13-parents of @xmath15 , @xmath15 sets @xmath47 to @xmath50 .",
    "we think @xmath51 in .",
    "root @xmath13 sets its depth to @xmath13 as @xmath43 , and any other node updates its depth to @xmath13 as @xmath50 if it finds that the minimum depth to @xmath13 buffered by its @xmath13-parents is @xmath49 .",
    "each node @xmath15 periodically runs so as to insure its buffered depths are close approximations to the real depths @xmath52 we will show that each node maintains just one incoming @xmath13-link over all time , so a node needs to contact just one @xmath13-parent when is running .",
    "we do not require nodes update depths much more frequenctly than they sample targets .",
    "assume node @xmath15 updates depths for three types of events :    * after @xmath15 builds a new incoming @xmath13-link , immediately @xmath15 runs ( @xmath15,@xmath13 ) .",
    "* after @xmath15 samples a target , @xmath15 runs ( @xmath15,@xmath39 ) for all @xmath53 immediately .",
    "* after @xmath15 is sampled as a target , @xmath15 runs ( @xmath15,@xmath39 ) for all @xmath53 immediately .",
    "thus , nodes update depths about twice as fast as their poisson clocks tick .      in this section a greedy procedure is proposed to insure that each node has at least @xmath44 incoming links with distinct colors .",
    "notice that nodes are randomly sampling others .",
    "assume a node @xmath15 runs after it samples node @xmath54 as a target :    * output : * return true if @xmath22 changes , return false otherwise .",
    "* tie broken : * arbitrarily    if @xmath15 has less than @xmath44 incoming links and there exists @xmath13 such that @xmath15 has no incoming @xmath13-link but @xmath54 has an incoming @xmath13-link ,    * * add : * if @xmath55 , build @xmath56 in @xmath12 , and return true ; * * insert : * if @xmath54 has an @xmath13-child , say @xmath57 , remove @xmath58 , build @xmath59 in @xmath12 , and return true .",
    "return false .",
    "( see )        does not use depth information .",
    "it has several properties : if is valid , as nodes sample targets and run ,    1 .",
    "statements in remain valid ; 2 .   for each @xmath14 , @xmath60 is nondecreasing , but the depth of tree @xmath45 is also nondecreasing .",
    "3 .   for each @xmath14 and each node @xmath15 ,",
    "both @xmath61 and the number of incoming @xmath13-links of @xmath15 are nondecreasing .    in the following we state",
    "several additional assumptions under which running after nodes sample targets can lead all nodes to be covered by @xmath44 trees .",
    "first , nodes have to provide enough fan - out degrees to meet the demands of incoming links , so is assumed .",
    "[ a.link ] @xmath62 .",
    "second , notice that for @xmath14 , if at time @xmath43 root @xmath13 is not available and root @xmath13 does not have outgoing @xmath13-links , it is not possible for any node to ever build incoming @xmath13-links from @xmath13 .",
    "that is , @xmath63 over all time . to avoid that , we assume root @xmath13 has at least one @xmath13-child at time @xmath43 :    [ a.root ] for each @xmath14 , @xmath64 and at time @xmath43 root @xmath13 has at least one @xmath13-child .",
    ".,title=\"fig:\",width=113 ]    third , does not generate new cycles , but it can not eliminate original cycles . as shown in , @xmath46 may contain cycles at time @xmath43 , which can not be eliminated by . in this section",
    "we pause discussions on cycles by assuming is valid , in the next section we will show how cycles are eliminated .",
    "[ a.nocycle ] at time @xmath43 in @xmath22 , for any @xmath14 , any node @xmath15 with @xmath65 does not have incoming @xmath13-links",
    ".    implies that no cycle exists in @xmath66 for each @xmath14 at time @xmath43 . by running no @xmath13-links",
    "will be built beween nodes in @xmath67 and so no cycle ever appears .",
    "the following two indicate the convergence of running .",
    "[ lem.static ] if are valid , then at time @xmath43 , ( @xmath15,@xmath31 ) returns false for all @xmath68 if and only if @xmath69 for each node @xmath15 , that is , if and only if each node is covered by @xmath44 trees .",
    "if a node has @xmath44 incoming links with distinct labels , returns false whichever target the node samples .",
    "so the if part follows .",
    "suppose there exists @xmath70 .",
    "we prove the only if part by showing that returns true when two specific nodes meet .",
    "node @xmath15 has fewer than @xmath44 incoming links .",
    "implies that each node has at most @xmath44 incoming links .",
    "so @xmath71 by .",
    "thus there exists node , say @xmath31 , with @xmath72 .",
    "a ) if @xmath31 has @xmath44 incoming links , ( @xmath15,@xmath31 ) returns true because `` add '' can happen ; b ) if @xmath31 has fewer than @xmath44 incoming links , ( @xmath31,@xmath13 ) returns true if @xmath73 because `` insert '' can happen .",
    "[ lem.cover ] under , if ( @xmath15,@xmath31 ) runs whenever @xmath15 samples @xmath31 for any @xmath68 , then @xmath74 for all @xmath75 in finite time .    are valid over all time .",
    "whenever returns true , @xmath76 increases by one . but @xmath77 .",
    "follows from .",
    "can achieve coverage , but it has two main drawbacks : first , the depth of the tree @xmath45 for @xmath78 can be large ; second , it can not detect and eliminate cycles .",
    "in the next section we show how to solve these two problems by adding balance algorithms as complements .",
    "one way of decreasing the tree depth is to balance the tree .",
    "here we provide a procedure under which trees can achieve balance and cycles can be eliminated .",
    "suppose ( @xmath15,@xmath31 ) runs whenever node @xmath15 samples node @xmath31 as a target .",
    "* output : * return true if @xmath22 changes , return false otherwise .    * tie broken : * arbitrarily    if there exists @xmath13 such that @xmath79 both have incoming @xmath13-links ,    * * jump * : if @xmath72 and @xmath80 , remove @xmath81 , build @xmath82 in @xmath12 , and return true ; * * leafswap * : if @xmath31 is an @xmath13-leaf but @xmath15 is not , and @xmath83 , remove @xmath84 , build @xmath85 in @xmath12 , and return true .",
    "return false .",
    "( see )        applies the information of buffered depths , which is updated periodically but may have estimation errors . analyzing under depth updating is quite challenging . _ to focus on properties of , let us temporarily assume holds .",
    "discussion under the case wihout will be covered by simulation in .",
    "_    [ a.freeerror ] @xmath86 , assume @xmath87 over all time .    for any nodes",
    "@xmath68 , after ( @xmath15,@xmath31 ) runs :    1 .",
    "statements in remain valid if they are valid before running",
    ". 2 .   for any node , its number of incoming @xmath13-links and number of outgoing @xmath13-links both remain unchanged .",
    "3 .   under , for any node @xmath88 with @xmath89 , @xmath90 is nonincreasing .",
    "4 .   under",
    ", no new cycles will be generated , and cycles in @xmath91 can be eliminated as shown in , because @xmath92 for all @xmath93 .",
    "the following lemma shows that can return true unless all trees achieve balance .",
    "[ lem.singlebalance ] under , at time @xmath43 , if ( @xmath15,@xmath31 ) returns false for all pairs of nodes @xmath79 , for each @xmath14 ,    1 .",
    "if holds , also holds , 2 .   for any two @xmath13-leaves @xmath79 , @xmath94 , and 3 .",
    "each @xmath13-internal node @xmath15 is unavailable and @xmath95 .",
    "\\1 ) tells that for each @xmath13 there is at least one @xmath13-leaf .",
    "thus is valid , otherwise ( @xmath15,@xmath31 ) returns true if @xmath96 has incoming @xmath13-links and @xmath31 is an @xmath13-leaf .",
    "\\2 ) assume node @xmath15 and @xmath97 are both @xmath13-leaves and @xmath98 .",
    "assume @xmath31 is the @xmath13-parent of @xmath97 , then @xmath99 .",
    "( @xmath15,@xmath31 ) returns true .",
    "thus , depths of any two @xmath13-leaves differ by at most one .",
    "\\3 ) if @xmath15 is an @xmath13-internal node , it can not be an @xmath13-leaf because of 2 ) , and it can not be available otherwise ( @xmath31,@xmath15 ) returns true where @xmath31 is the @xmath13-leaf with the largest depth to @xmath13 .        intuitively running and together can achieve both coverage and balance , as well as eliminate cycles .",
    "however , balance in a tree does not garantee the tree has small depth . as shown in , if there are many nodes with a single outgoing @xmath13-link , chains may appear and thereby the depth of tree @xmath45 can be large .",
    "fortunately , there exists ways to eliminate conditions like that , as shown in the following .",
    "nodes with a single child play an important role in increasing the depth of a tree .",
    "an unavailable node @xmath15 with a single @xmath13-child for certain @xmath14 either have @xmath100 or is a mixed node .",
    "the case that @xmath100 is less interesting because most nodes can be required to provide at least two outdegrees , especially when the streaming rate of a substream is small comparing to the upload capacity .",
    "suppose holds for simplicity .",
    "[ a.2 ] @xmath101 for all @xmath102 .",
    "notice that in existence of nodes with outdegree zero is allowed .",
    "gets rid of the case that many nodes have outdegree one .",
    "reducing the number of mixed nodes can lower the tree depths . in this section",
    "we provide under which the number of mixed nodes can be greatly reduced . for any pair of nodes",
    "@xmath103 , suppose ( @xmath57,@xmath31 ) runs when @xmath57 samples @xmath31 as a target .",
    "* output : * return true if @xmath22 changes , return false otherwise .",
    "* tie broken : * arbitrarily .",
    "if there exist @xmath104 such that @xmath31 has an @xmath39-child say @xmath97 , @xmath57 has an @xmath13-parent say @xmath15 , and     * mixswap * : if @xmath105 and either of the two is true :    * @xmath106 or @xmath107 , * @xmath108 , @xmath109 , @xmath110 , ( note @xmath111 are ids in \\{1, ... n}. )    then remove @xmath112 , build @xmath113 in @xmath114 , build @xmath115 in @xmath12 , and return true .",
    "otherwise return false .",
    "( see )      and @xmath97 switch their parents if one can decrease its depth while the other one s depth does not increase , or depths are unchanged but lower - id parents can get lower - color links.,title=\"fig:\",width=207 ]    ( @xmath57,@xmath31 ) returns true if after `` mixswap '' , between @xmath57 and one child of @xmath31 , one can decrease its depth while the other one s depth does not increase , or depths are unchanged but parents with lower ids can get outgoing links with lower colors .",
    "we break the tie by assuming parents with lower ids have a preference on links with lower colors , so as to eliminate the case that there are many mixed nodes with exactly the same depths in multiple trees .    under , for any pair of nodes @xmath79 , after ( @xmath15,@xmath31 )",
    "runs ,    1 .",
    "statements in remain valid if they are valid before running",
    "@xmath90 is nonincreasing for any node @xmath88 , 3 .",
    "no new cycle is generated .",
    "moreover , the following lemma indicates that can return true unless depth vectors of mixed nodes form a strict chain :    [ lem.mix ] under , if ( @xmath116,@xmath117 ) returns false for all pairs of nodes @xmath118 , for any @xmath119 and any two mixed-@xmath13-@xmath39-nodes @xmath79 , either @xmath120 or @xmath121 .",
    "the lemma follows by noticing that if @xmath79 are both mixed-@xmath13-@xmath39-nodes , `` mixswap '' can happen when either a child of @xmath15 contacts @xmath31 or a child of @xmath31 contacts @xmath15 , unless @xmath122 and @xmath123 are in a strict order .",
    "still does not guarantee that the number of mixed nodes is small . as shown in",
    ", mixed nodes can form a long chain where the conclusion in still holds .",
    "however , the appearances of the structure in are quite rare because random sampling is assumed . and intuitively it becomes rarer as @xmath2 increases . in practice we may safely ignore it , but here for completeness of analysis , we eliminate the possibility of a long chain as in by assuming holds",
    ". we will show later by simulation that ignoring does not harm performance .",
    "[ a.hat ] at time @xmath43 , there exists @xmath124 such that for each @xmath125 , there are at least @xmath6 @xmath13-leaves in @xmath126 , where @xmath127 .",
    "says that initially in any tree the subtree of nodes with depth bounded by @xmath128 has at least @xmath6 leaves",
    ". intuitively suggests there is something analogous to a shower head , which provides enough branches near the top of each tree @xmath45 .",
    "the value @xmath128 in can be as small as @xmath129 , or even @xmath130 if the root or its children have large outdegrees .",
    "we have under .    [ lem.balance ] under ,",
    "if ( @xmath15,@xmath31 ) and ( @xmath15,@xmath31 ) both return false for all @xmath68 , then for each @xmath14 the depth of each tree @xmath45 is less than or equal to @xmath131 , where @xmath128 is defined in .",
    "suppose the depth of tree @xmath45 is @xmath132 .",
    "tells that for each @xmath133 and for each @xmath134 , there are at most one mixed-@xmath13-@xmath39-nodes whose depth to @xmath13 is @xmath135 .",
    "so there are at most @xmath136 mixed nodes which have @xmath13-child and whose depth to @xmath13 is @xmath135 .",
    "tells that all @xmath13-internal nodes must have at least @xmath137 children because they are unavailable and because holds .",
    "thus , for each @xmath138 , in the set of nodes whose depth to @xmath13 is @xmath135 , at most @xmath136 of them can have a single @xmath13-child , while each of the other nodes has at least @xmath137 @xmath13-children because they are unavailable non - mixed @xmath13-internal nodes .",
    "notice that there are at least @xmath6 nodes whose depth to @xmath13 is @xmath128 .",
    "thus , the number of nodes whose depth to @xmath13 is in @xmath139 $ ] is at least @xmath140 , so @xmath141 .",
    "here we combine all parts above together . for each pair of nodes @xmath79 ,",
    "run ( @xmath15,@xmath31 ) when @xmath15 samples @xmath31 .",
    "* output : * return true if @xmath22 changes , return false otherwise .    * tie broken : * arbitrarily    nodes @xmath79 update their buffered depth by running for each @xmath14 respectively ( @xmath15 , @xmath31 ) +   ( @xmath15 , @xmath31 ) ( @xmath15 , @xmath31 )    just like that in c or c++ , in , if operation `` a '' returns true , operation `` a or b '' immediately returns and operation `` b '' does not run .",
    "notice that buffered depths are also updated whenever new links are built , as assumed in . and notice that under , for any pair of nodes @xmath79 , after ( @xmath15,@xmath31 ) runs , statements in remain valid if they hold before running , respectively",
    ".    shows that by running certain metric changes monotonely .",
    "some additional definitions are necessary before defining the metric .",
    "define @xmath142 , i.e. , @xmath143 is the same as @xmath144 except that @xmath145 instead of @xmath48 if there is no path from @xmath13 to @xmath15 .",
    "let @xmath146 so @xmath147 is the sum of all modified depths of all nodes .",
    "let @xmath148 be the sum of the colors of all outgoing links of @xmath15 , and let @xmath149 .",
    "[ lem.balanceconv ] under , for any pair of nodes @xmath79 , after ( @xmath15,@xmath31 ) runs , if it returns true , @xmath150 decrease lexicographically by at least one , otherwise @xmath150 does not change .    under , if returns true , @xmath76 increases by one ; if returns true , or returns true because of condition ( a ) , @xmath147 decreases by at least one but @xmath76 remains unchanged ; if returns true because of condition ( b ) , @xmath151 increases by at least one while @xmath152 remain unchanged .    helps to show convergence of the algorithm .",
    "[ lem.conv ] under , suppose ( @xmath15,@xmath31 ) runs whenever @xmath15 samples @xmath31 for any @xmath68 .",
    "then in finite time ( @xmath15,@xmath31 ) returns false for all @xmath79 , and at that time ,    1 .",
    "@xmath153 , 2 .",
    "@xmath154 the depth of the tree @xmath45 is bounded by @xmath131 , where @xmath128 is the value in .",
    "notice that statements in are valid over all time .",
    "and the boundness of @xmath155 and @xmath151 tell that in finite time will return false whenever any two nodes meet .",
    "tells that ( a ) is valid while tells that ( b ) is valid .      under",
    ", no new cycles can appear by running , which is not the case when depths are updated distributedly .",
    "here we argue that cycles are rare and can be eliminated quickly even if does not hold .",
    "first , a new cycle appears only if a node builds an incoming link from one of its descendants , which happens only if the descendant has a smaller buffered depth .",
    "that condition is rare because 1 ) most nodes just have several descendants ; 2 ) if @xmath15 is a descendant of @xmath31 and if the depth of @xmath15 is larger than the depth of @xmath31 , by running and the depth of @xmath15 can remain larger than that of @xmath31 .",
    "usually a node has smaller depth than its ancestors only when many nodes suddenly become ancestors of the node in a short time , which is also a rare event .",
    "second , even if a new cycle appears , it will disappear in a short time . by , depths of nodes in a cycle keep updating and can count to a large value , just like the `` counting to infinity '' problem in network routing .",
    "whenever a node with a large depth meets a leaf node , changes as shown in can happen and thereby the cycle disappears .",
    "at least half of the nodes in a tree are leaves , so by random sampling , cycles are eliminated quickly .    in summary , we argue that distributed depth update does not harm performance much compared to that under , which is supported by simulations in .",
    "analyzing the convergence time of running is highly challenging .",
    "this section provides a stochastic bound for the convergence time under the case of a single tree , i.e , @xmath156 .",
    "we further assume that each node has outdegree at least @xmath137 , i.e. , @xmath157 for all @xmath158 . and suppose holds so that each node knows its depth to the root . for theoretical tractability , instead of running ,",
    "we simply the algorithm by assuming that only `` add '' in and `` jump '' in run when two nodes meet .",
    "the simplified model is summarized as follows : each node knows its depth to the root ; whenever a node s poisson clock ticks , the node samples a target uniformly at random , if the target is available and the depth of the target is less than the depth of the node by at least two , the node removes its current incoming link if there is and builds a new incoming link from the target ; otherwise nothing happens .",
    "assume initially each node has at most one incoming link , then convergence time is upper bounded :    [ p.rate ] let @xmath159 be the first time for the maximum depth of all nodes to be bounded up by @xmath160 , then @xmath161 < 3e^{-\\epsilon}.\\ ] ]    notice that the maximum depth is @xmath48 if there is a node to which no path exists from the root .",
    "so bounds the time for the tree to cover all nodes and achieve balance .",
    "it implies that the model converges in @xmath1 time .",
    "we argue that for the case of multiple trees similar bounds as in can be generated , and by running the network can converge in @xmath1 time . because when targets are unavailable , `` leafswap '' substitutes `` jump '' efficiently since half nodes are leaves , and `` insert '' substitutes `` add '' as well .",
    "the proof of is provided below .",
    "we assume nodes sample targets randomly at times of poisson processes with rate @xmath162 .",
    "equivalently , we can assume that each @xmath163 pair maintains a poisson clock which ticks at rate @xmath164 .",
    "the following definitions are applied for the proof .",
    "define @xmath165 and @xmath166 .",
    "define @xmath167 .",
    "define @xmath168 to be the number of nodes with depths @xmath169 .",
    "note that @xmath170 is a discrete counting process .",
    "define @xmath171 .",
    "the model describes a markov process with state being @xmath172",
    ". we apply @xmath172 to denote the process as well as the graph .",
    "it is not difficult to see that graph @xmath172 can converge to a balanced tree covering all nodes in finite time , because 1 ) the depth of each node is nonincreasing , i.e. , @xmath173 for each @xmath13 is nondecreasing , and 2 ) there exist nodes which can decrease their depths if @xmath22 is not balanced or @xmath22 does not cover all nodes .    the process is separeted into two phases , illustrated by , respectively .",
    "the time for the first phase is described below .",
    "[ lem.t0 ] for any @xmath174 , let @xmath175 be the first time that @xmath176 , @xmath177 \\leq 2^{l_\\alpha+1 } p[poi(\\alpha t/2)\\leq l_{\\alpha}-1].\\ ] ]    define an alternative process @xmath178 such that it is identical to the original process @xmath179 when @xmath180 ; when @xmath181 , whenever a node with depth @xmath182 changes its depth , a new node with fan - out degree @xmath137 whose depth is @xmath183 arrives to @xmath184 .",
    "after @xmath175 , @xmath185 may increase but we assume the poisson clock of each @xmath186 pair still ticks at rate @xmath187 .",
    "on @xmath184 , the number of nodes with depths @xmath182 does not change after @xmath175 , and always @xmath188 .",
    "the probability @xmath189 $ ] is identical for processes @xmath179 or @xmath184 .",
    "_ in the following , our discussion are on process @xmath184 . for simplicity",
    ", we apply the same notations for @xmath184 as for @xmath179_. let @xmath190 .",
    "notice that the number of available nodes with depths @xmath169 is larger or equal to @xmath191 : consider each node labels its outgoing degrees and marks the first two degrees red .",
    "each node has at least @xmath137 red degrees but there are only @xmath192 nodes to serve .",
    "so there are at most @xmath193 nodes whose red degrees are both taken .",
    "the number of nodes with depths @xmath182 is larger or equal to @xmath194 .",
    "thus , if @xmath195 , the transition rate for @xmath173 to jump is lower bounded by @xmath196    there exists a process @xmath197 in @xmath198 on an extended probability space such that each coordinate of @xmath199 has jumps of size one and jump rate for @xmath200 is @xmath201 . notice that simultaneous jumps of different coordinates of @xmath199 are allowed .",
    "let @xmath202 .",
    "initially we have @xmath203 .",
    "process @xmath204 and @xmath199 can be coupled so that @xmath205 with probability one for all @xmath206 .",
    "that is because if @xmath207 then jump rate of @xmath173 is larger or equal to jump rate of @xmath200 for all @xmath13 such that @xmath208 .",
    "so the jumps of @xmath199 can be obtained by generally thinning the jumps of @xmath204 , and adding more jumps to @xmath200 s with @xmath209 .    by induction",
    "it is easy to show that @xmath210 with probability one for all @xmath206 , because jump rate of @xmath200 is zero if @xmath211 .",
    "moreover , @xmath212 $ ] , @xmath213\\over dt } & = & e\\left[{\\alpha \\over 2 } \\left(1 + 2{\\tilde{z}}_{i-1}(t)-{\\tilde{z}}_{i}(t)\\right)^{+}\\right]\\\\ & \\geq & { \\alpha\\over 2}\\left(1 + 2e[{\\tilde{z}}_{i-1}(t ) ]   - e[{\\tilde{z}}_i(t)]\\right)^{+}.\\end{aligned}\\ ] ]    let @xmath214 to be a motion trajectory defined by the following linear differential equation : @xmath215 by induction it is easy to prove that , @xmath216 \\geq y_i(t)$ ] .",
    "define @xmath217 .",
    "notice that @xmath218 , apply markov s inequality and , @xmath219 = p[z_{l_\\alpha}(t ) \\leq ( 1-\\alpha)n-1 ] \\\\ & \\leq & p[{\\tilde{z}}_{l_\\alpha}(t ) \\leq 2^{l_\\alpha+1}-2 ] = p[\\delta(t ) \\geq 1 ] \\\\ & \\leq & e[\\delta(t ) ] \\leq 2^{l_\\alpha+1}-1 - y_{l_\\alpha}(t)\\\\ & \\leq & 2^{l_\\alpha+1 } p[pois(\\alpha t/2)\\leq l_{\\alpha}-1].\\end{aligned}\\ ] ] the lemma follows .",
    "[ lem.diff ] let @xmath220 to be a motion trajectory defined by the following : @xmath221 where @xmath222 is a constant , then @xmath223\\right\\ } -1.\\ ] ]    let @xmath224 / 2^{i+1}$ ] , we can simplify the equation of @xmath225 as @xmath226 notice that by induction we can show that @xmath227 , where @xmath228 solving the differential equation about @xmath229 gives that @xmath230 @xmath231 thus @xmath232 , \\ ] ] and so the lemma follows .",
    "the time of the second phase is described below .",
    "[ lem.t1 ] for any @xmath233 , given @xmath234 , let @xmath235 be the first time that @xmath236 , then @xmath237 \\geq \\left[1 - e^{-(1 - 2\\alpha)t/2}\\right ] ^{\\alpha n}.\\ ] ]    let @xmath238 be the number of nodes with depths @xmath239 , and let @xmath240 be the number of available nodes with depths @xmath169 .",
    "consider the jumping rate of @xmath241 .",
    "notice that @xmath242 , and @xmath243}\\left\\{1+z_{i}-x_{i+1}\\right\\}\\\\ & \\geq & \\max _",
    "{ i\\in [ l_\\alpha , l_c]}\\left\\ {   ( 1-\\alpha)n + \\sum_{k = l_\\alpha+1}^i x_k - x_{i+1 } \\right\\}\\geq ( 1 - 2\\alpha ) n.\\end{aligned}\\ ] ]    the last inequalities above is due to the fact that @xmath244 .",
    "the rate for any node with depth @xmath245 to jump to join @xmath246 is at least @xmath247 .",
    "so the lemma follows .",
    "now are combined to prove .",
    "consider , apply the chernoff bound for poisson variable : @xmath248 \\leq { e^{-\\lambda}(\\lambda e)^x\\over x^x}$ ] if @xmath249 , and @xmath250 , we have @xmath251\\leq 2\\exp\\left\\ { r(1+ln 2 - { t\\over r } + ln{t\\over r } ) \\right\\},\\ ] ] where @xmath252 .",
    "notice that @xmath253 , so @xmath254\\leq 2e^ { -\\epsilon } .\\ ] ] consider : @xmath237 \\geq 1 - \\alpha n e^{-(1 - 2\\alpha)t/2 } \\geq 1 -   ( n+1 ) e^{-(1 - 2\\alpha)t/2}.\\ ] ] and so @xmath255 \\leq e^{-\\epsilon}.\\ ] ] choose @xmath256 , which minimizes @xmath257 , we get @xmath258\\leq 3e^{-\\epsilon}.\\ ] ]",
    "we show that works pretty well under , without .",
    "let each node sample targets randomly with rate @xmath24 and run",
    ". is not invoked so depths update distributedly .",
    "notice that runs instantaneously in simulations . in each experiment",
    "below , we set @xmath259 fixed ; at time @xmath43 , we first set @xmath11 to be empty , then let each root @xmath13 build an @xmath13-child which is randomly selected from @xmath260 .",
    "so at time @xmath43 @xmath11 contains @xmath261 links and both hold .",
    "we let hold too .    because holds , during each simulation below @xmath45 for each @xmath13 is always a tree .",
    "tree @xmath13 is given by @xmath45 .",
    "say that a node is _ covered by tree @xmath13 _ if @xmath262 , and say that a node is _ fully covered _ if it is covered by at least @xmath44 trees .    in experiments below",
    ", the parameters chosen include @xmath263 and the degree vector @xmath264 . for each selection of parameters @xmath265",
    ", we repeat running the experiment @xmath266 times , with each experiment running for @xmath267 time units and with system states recorded in the same time units .",
    "metrics considered include the fraction of nodes fully covered and the maximum tree depth .      in this series of experiments , we let each root have degree @xmath268 : @xmath269 , and let each non - root node have degree @xmath44 : @xmath270 , @xmath271 .",
    "the capacity is tight because the equality in is achieved : @xmath272 .",
    "keep @xmath273 so holds . after repeating an experiment for @xmath266 times , for @xmath274 ,",
    "we record metrics of the @xmath275 worst experiment at each time @xmath206 . notice that each line with legend `` worst case '' correponds to the case @xmath276 , which means that there is no experiment performing worse than the line at any time .",
    "( @xmath277 ) .",
    "point @xmath278 on a line legended @xmath275 means only in @xmath275 of @xmath266 experiments",
    "the corresponding metric at time @xmath206 is worse than @xmath225.,title=\"fig:\",width=162 ]    0.22 .",
    "point @xmath278 on a line legended @xmath275 means only in @xmath275 of @xmath266 experiments",
    "the corresponding metric at time @xmath206 is worse than @xmath225.,title=\"fig:\",width=162 ]    for example , in we set @xmath23 .",
    "a point @xmath278 in on the line with legend `` @xmath279 '' means that in @xmath279 of @xmath266 repeated experiments , the fraction of nodes fully covered at time @xmath206 is no larger than @xmath225 ; a point @xmath278 in on the line with legend `` @xmath280 '' means that in @xmath280 of @xmath266 repeated experiments , the max tree depth at time @xmath206 is no less than @xmath225",
    ".    shows what a specific sample path looks like under . in",
    ", we can see that the fraction of nodes fully covered increases almost exponentially from @xmath43 to @xmath162 , over @xmath281 nodes are fully covered by time @xmath282 under @xmath283 experiments .",
    "that is because nodes can gradually increase the number of trees covering them until they get fully covered , as they meet other fully covered nodes .",
    "_ it appears that the fraction of nodes is almost nondecreasing over all time , which validates that cycles generated are rare and are quickly eliminated .",
    "_ as indicated in , the maximum tree depth increases linearly in the beginning , then decreases almost exponentially , and finally converges to below @xmath284 . at time @xmath282 , in @xmath283 repeated experiments max tree depths are below @xmath285 .",
    "the rate of convergence follows , though is for the case of one tree .",
    "notice that not only in , but also in all our simulations below , the `` worst case '' lines are quite close to the `` 1% '' lines , but the latters are much more smooth than the former . _ in the following , we apply `` 1% '' lines instead of `` worst case '' lines to describe performance . _    0.22   cumulative lines when @xmath286 varies .",
    ", title=\"fig:\",width=162 ]    0.22   cumulative lines when @xmath286 varies .",
    ", title=\"fig:\",width=162 ]    in we test different @xmath44 s so as to make sure convergence follows in other cases .",
    "notice that typically in practice @xmath44 is below @xmath287 .",
    "set @xmath286 with @xmath44 varying in @xmath288 .",
    "we expect to observe similar images as in , with longer convergence time as @xmath44 increases because each node has to get covered by more trees . for each @xmath44",
    ", we draw the @xmath280 worst case line in . as expected , for each @xmath44 both the fraction of nodes fully covered and",
    "the max tree depth converge , as in . in , lines shift right almost linearly with a slow rate as @xmath44 increases . with @xmath289 , over @xmath281 nodes are fully covered by time @xmath290 . in",
    ", lines shift both downwards and right , and converge to lower values as @xmath44 increases .",
    "because balanced trees have smaller depth if nodes have larger degree : with @xmath289 , the line converges to @xmath291 in .",
    "whatever @xmath44 is , the max tree depth is below @xmath285 by time @xmath282 .",
    "0.22   cumulative lines when @xmath6 varies and @xmath292.,title=\"fig:\",width=162 ]    0.22   cumulative lines when @xmath6 varies and @xmath292.,title=\"fig:\",width=162 ]    in , we test the case under source coding by drawing the @xmath280 worst case lines when @xmath292 and @xmath6 be in @xmath293 , that is , there are more trees than nodes need .",
    "notice that the capacity is still tight . in , lines shift left as @xmath6 increases , showing that source coding tends to decrease the convergence time for coverage . in",
    ", limits slightly increase as @xmath6 increases . because when @xmath6 is larger there are more types of mixed nodes , which may have single children in a tree and thereby increase the depth .",
    "that condition is also implied by , where the value @xmath128 is considered to be of @xmath129 .",
    "thus , source coding creates a tradeoff between the tree depth limit and the convergence time of coverage . intuitively and as shown in , the increasing of depth limit is of @xmath129 which is small , so it is worth trying source coding to get a faster convergence .    for all simulations above",
    ", we test cases where the capacity is tight , which illustrates and supports that convergence is exponential . one common feature of curves in is that long tails exist .",
    "for example , in , it takes quite long for curves to arrive at @xmath162 . that is because near the end of the process only a few nodes are available and a few others are not fully covered , and it takes long for these nodes to meet each other by random sampling .",
    "long tails can be eliminated by broadcasting or adding more capacity .",
    "broadcasting is not discussed in this paper , in the following we show experiments where extra capacity exists .      0.22   cumulative , @xmath23 and @xmath294 varies.,title=\"fig:\",width=162 ]    0.22   cumulative , @xmath23 and @xmath294 varies.,title=\"fig:\",width=162 ]    we set the total number of degrees @xmath295 , with a new parameter @xmath294 . to achieve that",
    ", we first let each node have degree @xmath44 , then add @xmath296 degrees , one by one , to nodes selected uniformly at random . in",
    ", we set @xmath23 , and let @xmath294 increase . in , we can see that adding just @xmath297 extra capacity can greatly shorten the tail : all nodes are fully covered by time @xmath282 as shown by the line @xmath298 .",
    "the larger @xmath294 is , the shorter the tail is . when @xmath299 , all nodes get fully covered by time @xmath300 .",
    "in , as @xmath294 increases , curves converge faster and limits also decrease .      0.22   cumulative .",
    "@xmath23 , @xmath301 server nodes with degree @xmath302 , @xmath296 degrees added to server nodes randomly.,title=\"fig:\",width=162 ]    0.22   cumulative .",
    "@xmath23 , @xmath301 server nodes with degree @xmath302 , @xmath296 degrees added to server nodes randomly.,title=\"fig:\",width=162 ]     +    0.22   cumulative .",
    "@xmath23 , @xmath301 server nodes with degree @xmath302 , @xmath296 degrees added to server nodes randomly.,title=\"fig:\",width=162 ]    0.22   cumulative .",
    "@xmath23 , @xmath301 server nodes with degree @xmath302 , @xmath296 degrees added to server nodes randomly.,title=\"fig:\",width=162 ]    0.22   cumulative .",
    "@xmath23 , @xmath303 server nodes with degree @xmath302.,title=\"fig:\",width=162 ]    0.22   cumulative .",
    "@xmath23 , @xmath303 server nodes with degree @xmath302.,title=\"fig:\",width=162 ]    in this section , we show that works well under the server - client case , where a portion of nodes are server nodes with high degrees and other nodes are client nodes with zero degrees .",
    "the algorithm favors nodes with higher degree ; they tend to get smaller depths than nodes with lower degrees .",
    "we expect to observe similar images as in .",
    "notice that the convergence times will increase because it takes more time for nodes to meet server nodes under uniform random sampling .",
    "that problem can be solved by adding mechanisms to help nodes find server nodes . in this paper , we stay focused on the uniform sampling assumption despite the small increase in convergence time .    in , we let @xmath304 server nodes ( include roots ) have degree @xmath302 and all other nodes have degree @xmath43 , then add @xmath305 degrees one by one to server nodes randomly .",
    "as expected , in , lines shift right as @xmath306 increase because there are less server nodes , but still increases exponentially from @xmath43 to @xmath162 .",
    "in , max tree depth decreases greatly as @xmath306 increase from @xmath162 to @xmath137 , and further decreases as @xmath306 increase . in",
    ", @xmath306 is fixed at @xmath137 with @xmath294 increases , which shows long tails get eliminated like that in .    in",
    ", we let @xmath303 server nodes ( include roots ) have degree @xmath302 and all other nodes have degree @xmath43 .",
    "we set @xmath307 , let @xmath294 increase , and draw the line at @xmath308 for comparison .",
    "notice that lines at @xmath309 in are exactly the same . as @xmath294 increases ,",
    "there are more server nodes so lines shift left quickly in , and max tree depth decreases quickly in . when @xmath310 , lines in are close to lines in . as @xmath294 increases , in lines shift left but in they do not .",
    "that suggests that performance is sensitive to the number of server nodes instead of the degree distribution among server nodes .",
    "above all , our simulations validate by showing that fraction of nodes fully covered increases from @xmath43 to @xmath162 , and the maximum tree depth decreases to its limit , almost exponentially , under tight or un - tight capacity constraint , homogeneous or heterogeneous capacity distribution , when hold .",
    "the simulations suggest that cycles are eliminated quickly because the fraction of nodes covered is almost increasing over all time ; long tails can be eliminated by adding @xmath297 extra capacity ; and the algorithm favors nodes with higher degree so it works well under the server - client case too .",
    "convergence times increase with either increasing @xmath44 or decreasing the chance for nodes to meet server nodes .",
    "when parameters change , curves shift with shapes staying similar , revealing robustness of the algorithm .",
    "in this paper a distributed algorithm to manage multiple trees for streaming is proposed .",
    "the algorithm can achieve coverage , balance , and small delay in a short time .",
    "the algorithm works on a complete underlying graph assuming random sampling among peers is enabled .",
    "future work may include extending the algorithm for given incomplete underlying topologies .",
    "this work was supported by the national science foundation under grant nsf ccf 10 - 16959 .",
    "w.  zhang , q.  zheng , h.  li , and f.  tian , `` an overlay multicast protocol for live streaming and delay - guaranteed interactive media , '' _ journal of network and computer applications _ , vol .",
    "35 , no .  1 ,",
    "pp . 2028 , 2012 ."
  ],
  "abstract_text": [
    "<S> this paper presents an asynchronous distributed algorithm to manage multiple trees for peer - to - peer streaming in a flow level model . </S>",
    "<S> it is assumed that videos are cut into substreams , with or without source coding , to be distributed to all nodes . </S>",
    "<S> the algorithm guarantees that each node receives sufficiently many substreams within delay logarithmic in the number of peers . </S>",
    "<S> the algorithm works by constantly updating the topology so that each substream is distributed through trees to as many nodes as possible without interference . </S>",
    "<S> competition among trees for limited upload capacity is managed so that both coverage and balance are achieved . </S>",
    "<S> the algorithm is robust in that it efficiently eliminates cycles and maintains tree structures in a distributed way . </S>",
    "<S> the algorithm favors nodes with higher degree , so it not only works for live streaming and video on demand , but also in the case a few nodes with large degree act as servers and other nodes act as clients .    a proof of convergence of the algorithm is given assuming instantaneous update of depth information , and for the case of a single tree it is shown that the convergence time is stochastically tightly bounded by a small constant times the log of the number of nodes . </S>",
    "<S> these theoretical results are complemented by simulations showing that the algorithm works well even when most assumptions for the theoretical tractability do not hold . </S>"
  ]
}