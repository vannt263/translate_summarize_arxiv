{
  "article_text": [
    "rendezvous and treasure hunt are two basic tasks performed by mobile agents in networks . in rendezvous , two agents , initially located at distinct nodes of the network , traverse network edges in synchronous rounds and have to meet at some node . in treasure hunt , a single agent has to find a stationary target ( called treasure ) situated at an unknown node of the network .",
    "the network might model a labyrinth or a system of corridors in a cave , in which case the agents might be mobile robots .",
    "the meeting of such robots might be motivated by the need to exchange previously collected samples , or to agree how to share a future cleaning or decontamination task .",
    "treasure hunt might mean searching a cave for a resource or for a missing person after an accident .",
    "in other applications we can consider a computer network , in which the mobile entities are software agents .",
    "the meeting of such agents might be necessary to exchange data or share a future task of checking the functionality of network components .",
    "treasure hunt in this case might mean looking for valuable data residing at some node of the network , or for a virus implanted at some site .",
    "the network is modeled as a simple undirected connected graph whose nodes have distinct identities .",
    "ports at a node of degree @xmath8 are numbered @xmath9 .",
    "the agents are anonymous , i.e. , do not have identifiers .",
    "agents execute a deterministic algorithm , such that , at each step , they choose a port at the current node .",
    "when an agent enters a node , it learns the entry port number , the label of the node and its degree .",
    "the cost of a rendezvous algorithm is the total worst - case number of edge traversals performed by both agents until meeting .",
    "the cost of a treasure hunt algorithm is the worst - case number of edge traversals performed by the agent until the treasure is found .",
    "if the agents have no information about the network , the cost of both rendezvous and treasure hunt can be as large as @xmath10 for networks with @xmath1 edges .",
    "this is clear for treasure hunt , as all edges ( except one ) need to be traversed by the agent to find the treasure in the worst case .",
    "the same lower bound for rendezvous follows from proposition [ eq ] in the present paper . on the other hand ,",
    "if @xmath2 is the distance between the initial positions of the agents , or from the initial position of the agent to the treasure , a lower bound on the cost of rendezvous and of treasure hunt is @xmath2 .    in this paper , we study tradeoffs between the amount of information available _ a priori _ to the agents and the cost of rendezvous and treasure hunt . following the paradigm of algorithms with advice @xcite , this information is provided to the agents at the start of their navigation by an oracle that knows the network , the starting positions of the agents and , in the case of treasure hunt , the node where the treasure is hidden .",
    "the oracle assists the agents by providing them with a binary string called _ advice _ , which can be used by the agent during the algorithm execution . in the case of rendezvous",
    ", the advice given to each agent can be different .",
    "the length of the string given to the agent in treasure hunt and the sum of the lengths of strings given to both agents in rendezvous is called the _ size of advice_.      using the framework of advice permits us to quantify the amount of information needed for an efficient solution of a given network problem ( in our case , rendezvous and treasure hunt ) regardless of the type of information that is provided .",
    "our goal is to find the smallest size of advice which enables the agents to solve rendezvous and treasure hunt at a given cost @xmath0 in a network with @xmath1 edges .",
    "this size turns out to depend on the initial distance @xmath2 ( between the agents in rendezvous , and between the agent and the treasure in treasure hunt ) and on the ratio @xmath3 , which is the _ relative cost gain _ due to advice . for arbitrary graphs , we give upper and lower bounds of @xmath4 and @xmath5 , respectively , on the optimal size of advice .",
    "hence our bounds leave only a logarithmic gap in the general case . for the class of trees ,",
    "we give nearly tight upper and lower bounds of @xmath6 and @xmath7 , respectively .",
    "our upper bounds are obtained by constructing an algorithm for all graphs ( respectively , for all trees ) that works at the given cost and with advice of the given size , while the lower bounds are proved by exhibiting networks for which it is impossible to achieve the given cost with smaller advice .",
    "treasure hunt , network exploration and rendezvous in networks are interrelated problems that have received much attention in recent literature .",
    "treasure hunt has been investigated in the line @xcite , in the plane @xcite and in other terrains @xcite .",
    "treasure hunt in anonymous networks ( without any information about the network ) has been studied in @xcite with the goal of minimizing cost .",
    "the related problem of graph exploration by mobile agents ( often called robots ) has been intensely studied as well .",
    "the goal of this task is to visit all of the nodes and/or traverse all of the edges of a graph .",
    "a lot of research considered the case of a single agent exploring a labeled graph . in @xcite",
    "the agent explores strongly - connected directed graphs . in a directed graph , an agent can move only in the direction from tail to head of an edge , not vice - versa .",
    "in particular , @xcite investigated the minimum time of exploration of directed graphs , and @xcite gave improved algorithms for this problem in terms of the deficiency of the graph ( i.e. , the minimum number of edges that must be added to make the graph eulerian ) .",
    "many papers , e.g. , @xcite studied the scenario where the graph to be explored is labeled and undirected , and the agent can traverse edges in both directions . in @xcite , it was shown that a graph with @xmath11 nodes and @xmath1 edges can be explored in time @xmath12 . in some papers , additional restrictions on the moves of the agent were imposed , e.g. , it was assumed that the agent is tethered , i.e. , attached to the base by a rope or cable of restricted length @xcite . in @xcite , a log - space construction of a deterministic exploration for all graphs with a given bound on size was shown .",
    "the problem of rendezvous has been studied both under randomized and deterministic scenarios . in the framework of networks",
    ", it is usually assumed that the nodes do not have distinct identities .",
    "an extensive survey of randomized rendezvous in various models can be found in @xcite , cf .",
    "also @xcite . deterministic rendezvous in networks has been surveyed in @xcite .",
    "several authors considered geometric scenarios ( rendezvous in an interval of the real line , e.g. , @xcite , or in the plane , e.g. , @xcite ) .",
    "gathering more than two agents was studied , e.g. , in @xcite .",
    "for the deterministic setting , many authors studied the feasibility and time complexity of rendezvous of synchronous agents , i.e. , agents that move in rounds . in @xcite",
    "the authors studied tradeoffs between the time of rendezvous and the number of edge traversals by both agents . in @xcite",
    ", the authors presented a rendezvous algorithm whose running time is polynomial in the size of the graph , the length of the shorter label and the delay between the starting times of the agents . in @xcite ,",
    "rendezvous time is polynomial in the first two of these parameters and independent of the delay .",
    "the amount of memory required by the agents to achieve deterministic rendezvous was studied in @xcite for general graphs .",
    "the amount of memory needed for randomized rendezvous in the ring was discussed , e.g. , in  @xcite .",
    "several authors investigated asynchronous rendezvous in the plane @xcite and in network environments @xcite .",
    "providing nodes or agents with information of arbitrary type that can be used to perform network tasks more efficiently has been proposed in @xcite .",
    "this approach was referred to as algorithms with _",
    "advice_. the advice is given either to nodes of the network or to mobile agents performing some network task .",
    "several of the authors cited above studied the minimum size of advice required to solve the respective network problem in an efficient way .    in @xcite , given a distributed representation of a solution for a problem , the authors investigated the number of bits of communication needed to verify the legality of the represented solution . in @xcite , the authors compared the minimum size of advice required to solve two information dissemination problems using a linear number of messages . in @xcite",
    ", it was shown that a constant amount of advice enables the nodes to carry out the distributed construction of a minimum spanning tree in logarithmic time . in @xcite ,",
    "the advice paradigm was used for online problems . in @xcite ,",
    "the authors established lower bounds on the size of advice needed to beat time @xmath13 for 3-coloring a cycle and to achieve time @xmath13 for 3-coloring unoriented trees . in the case of @xcite ,",
    "the issue was not efficiency but feasibility : it was shown that @xmath14 is the minimum size of advice required to perform monotone connected graph clearing . in @xcite ,",
    "the authors studied radio networks for which it is possible to perform centralized broadcasting with advice in constant time .",
    "they proved that @xmath15 bits of advice allow to obtain constant time in such networks , while @xmath16 bits are not enough . in @xcite",
    ", the authors studied the problem of topology recognition with advice given to nodes . in @xcite",
    ", the authors considered the task of drawing an isomorphic map by an agent in a graph , and their goal was to determine the minimum amount of advice that has to be given to the agent for the task to be feasible .    among the papers using the paradigm of advice ,",
    "@xcite are closest to the present work .",
    "both @xcite concerned the task of graph exploration by an agent . in @xcite ,",
    "the authors investigated the minimum size of advice that has to be given to unlabeled nodes ( and not to the agent ) to permit graph exploration by an agent modeled as a @xmath17-state automaton . in @xcite , the authors established the size of advice that has to be given to an agent completing exploration of trees , in order to break competitive ratio 2 . in @xcite , the authors studied the minimum size of advice that must be provided to labeled agents , in order to achieve rendezvous at minimum possible cost , i.e. , at cost @xmath18 , where @xmath2 is the initial distance between the agents .",
    "they showed that this optimal size of advice for rendezvous in @xmath11-node networks is @xmath19 , where the labels of agents are drawn from the set @xmath20 .",
    "this paper differs from the present one in two important aspects .",
    "first , as opposed to the present paper , in @xcite , agents get identical advice , and nodes of the network are unlabeled .",
    "second , instead of looking at tradeoffs between cost and the size of advice , as we do in the present paper , the focus of @xcite was on the size of advice sufficient to achieve the lowest possible cost .",
    "in this section we show that , in the context of advice , treasure hunt and rendezvous are essentially equivalent .",
    "more precisely , the following proposition shows that the minimum advice sufficient to solve both problems at a given cost in the class of graphs with @xmath10 edges and with the initial distance @xmath18 is the same , up to constant factors . throughout the paper",
    "a _ graph _ means a simple connected undirected graph .",
    "the number of nodes in the graph is denoted by @xmath11 , and the number of edges is denoted by @xmath1 .",
    "all logarithms are to base 2 .    [ eq ]",
    "let @xmath21 be positive integers .    1 .",
    "if there exists an algorithm th that solves treasure hunt at cost @xmath0 with advice of size @xmath22 in all graphs with @xmath1 edges and with initial distance @xmath2 between the agent and the treasure , then there exists an algorithm rv that solves rendezvous at cost @xmath0 with advice of size @xmath23 in all graphs with @xmath1 edges and with initial distance @xmath2 between the agents .",
    "if there exists an algorithm rv solving rendezvous at cost @xmath0 with advice of size less than @xmath22 in all graphs with @xmath24 edges and with initial distance @xmath25 between the agents , then there exists an algorithm th that solves treasure hunt at cost at most @xmath0 with advice of size at most @xmath22 in all graphs with @xmath1 edges and with initial distance @xmath2 between the agent and the treasure .    _",
    "_ consider a graph @xmath26 with @xmath1 edges , and two agents , @xmath27 and @xmath28 , that have to meet .",
    "suppose that @xmath27 and @xmath28 start at nodes @xmath29 and @xmath30 in graph @xmath26 , and that @xmath2 is the distance between @xmath29 and @xmath30 .",
    "let @xmath31 be the advice string of size @xmath22 that enables an agent starting at @xmath29 to find the treasure located at @xmath30 at cost @xmath0 using algorithm @xmath32 .",
    "give advice string @xmath33 to agent @xmath28 and advice string @xmath34 to agent @xmath27 .",
    "the sum of the lengths of these strings is @xmath23 .",
    "the rendezvous algorithm rv is the following . with advice string @xmath33",
    "stay inert ; with advice string @xmath34 execute algorithm @xmath32 using advice @xmath31 . by the correctness of th ,",
    "this rendezvous algorithm is correct and its cost is @xmath0 .    _",
    "consider a graph @xmath26 with @xmath1 edges and with initial distance @xmath2 between the agent ( initially located at @xmath29 ) and the treasure ( initially located at @xmath30 ) .",
    "we construct the following graph @xmath35 .",
    "it consists of two disjoint copies @xmath36 of @xmath26 with the respective nodes @xmath30 in each copy joined by an additional edge @xmath37 .",
    "the graph @xmath35 has @xmath24 edges .",
    "label nodes of the graph @xmath35 as follows .",
    "if some node of @xmath26 has label @xmath38 , then the corresponding node in @xmath39 has label @xmath40 and the corresponding node in @xmath41 has label @xmath42 .",
    "place two agents in @xmath35 , each at the node @xmath29 of a different copy of graph @xmath26 .",
    "hence , the initial positions of the agents are at distance @xmath25 in @xmath35 .",
    "let @xmath43 and @xmath44 be the advice strings ( whose lengths sum to less than @xmath22 ) that are provided to the agents starting in @xmath39 and @xmath41 , respectively , in the execution of rv in @xmath35 . in this execution ,",
    "at least one of the agents has to traverse edge @xmath37 , and , hence , it has to reach the node @xmath30 in its copy @xmath45 of @xmath26 .",
    "therefore it travels from @xmath29 to @xmath30 in @xmath45 with an advice string @xmath46 of size less than @xmath22 , at cost at most @xmath0 .",
    "algorithm th for treasure hunt in @xmath26 is given the advice string @xmath46 with the single bit @xmath47 appended .",
    "the algorithm consists of the solo execution of rv where the agent transforms the label @xmath38 of each visited node to @xmath48 .    in view of proposition [ eq ] ,",
    "in the rest of the paper we can restrict attention to the problem of treasure hunt .",
    "all of our results , both the upper and the lower bounds , also apply to the rendezvous problem ( with the provision that , if treasure hunt can be solved at cost @xmath0 with no advice , then rendezvous can be solved at cost @xmath0 with constant advice ) .",
    "notice that the equivalence of rendezvous and treasure hunt depends on the fact that , in rendezvous , the oracle can give different pieces of advice to the two agents .",
    "if the oracle was forced to give the same advice to both agents , then symmetry could not be broken in all cases since agents are anonymous , and rendezvous would be impossible in some networks .",
    "in this section , we proceed to prove upper and lower bounds on the advice needed to solve treasure hunt in arbitrary graphs .",
    "these bounds are expressed in terms of @xmath2 , which is the distance between the treasure and the initial position of the agent , and in terms of the ratio @xmath3 , where @xmath1 is the number of edges in the graph and @xmath0 is an upper bound on the cost of the algorithm .",
    "this ratio is the relative cost gain due to advice .",
    "we first provide an algorithm that solves treasure hunt using @xmath49 bits of advice , and then prove that any deterministic algorithm for this task uses at least @xmath5 bits of advice .",
    "consider an @xmath11-node graph @xmath26 and a node @xmath50 of @xmath26 , which is the initial position of the agent .",
    "let @xmath51 be a shortest path from @xmath50 to the treasure , where @xmath52 is the node at distance @xmath47 from @xmath50 along path @xmath53 .",
    "let @xmath54 .",
    "intuitively , @xmath55 is an upper bound on the total number of bits needed to fully describe the sequence of ports leading from @xmath50 to the treasure . for any fixed integer @xmath56",
    ", we describe a binary advice string of length @xmath57 and an algorithm that uses this advice when searching for the treasure .",
    "we do not consider values of @xmath38 greater than @xmath55 since we will show that , when @xmath58 , our algorithm has optimal cost @xmath2 .    to construct the advice ,",
    "the idea is to use @xmath38 bits to produce @xmath2 advice substrings to guide the agent along path @xmath53 . in particular , the first @xmath38 bits of advice consist of @xmath2 binary substrings @xmath59 . for each @xmath60 , the substring @xmath61 is created by considering the node @xmath52 on path @xmath53 that is at distance @xmath47 from @xmath50 in @xmath26 .",
    "the length of @xmath61 is dictated by the ratio of the number of bits needed to describe the degree of @xmath52 to the total number of bits needed to describe the degrees of all nodes on path @xmath53 .",
    "the set of ports at @xmath52 is partitioned into numbered _ sectors _ ( i.e. , subintervals ) of size at most @xmath62 .",
    "in fact , at most one of the sectors can have size smaller than this value .",
    "the substring @xmath61 is taken to be the binary representation of the number of the sector containing the port that leads to the next node @xmath63 on path @xmath53 towards the treasure .",
    "below , we provide pseudocode that describes how the advice is created .",
    "first , algorithm [ createadvice ] finds a shortest path @xmath53 from @xmath50 to the treasure .",
    "the path consists of node / port pairs @xmath64 for each @xmath60 , where @xmath65 and , for each @xmath60 , port @xmath66 leads from node @xmath52 to node @xmath63 .",
    "the sum @xmath67 is calculated and stored in @xmath55 .",
    "for ease of notation , we define @xmath68 .",
    "each pair @xmath64 is passed to the subroutine described in algorithm [ encodesector ] , along with @xmath69 .",
    "this subroutine uses @xmath69 and the degree of @xmath52 to determine the appropriate number @xmath70 of advice bits via the formula @xmath71 , then divides the set of ports at @xmath52 into numbered sectors , determines to which sector port @xmath66 belongs , and outputs the binary representation of this sector number as a @xmath70-bit string @xmath61 .",
    "the resulting sequence of substrings @xmath72 , along with the binary string @xmath73 representing the value of @xmath55 , is encoded into a single advice string to pass to the algorithm .",
    "more specifically , these strings are encoded by doubling each digit in each substring and putting 01 between substrings .",
    "this permits the agent to unambiguously decode the original sequence , to calculate the value of @xmath2 by looking at the number of separators 01 , and to calculate the value of @xmath38 by looking at the lengths of the first @xmath2 advice substrings .",
    "denote by @xmath74 this encoding and let @xmath75 be the inverse ( decoding ) function , i.e. @xmath76 . as an example , @xmath77 .",
    "note that the encoding increases the total number of advice bits by a constant factor .",
    "the advice string , calculated by algorithm [ createadvice ] using the strings @xmath61 supplied by algorithm [ encodesector ] , is @xmath78 .",
    "the advice string @xmath79 is given to the agent .    find a shortest path @xmath80 in @xmath26 from node @xmath50 to the node containing the treasure .",
    "@xmath81 @xmath82 @xmath83 port number leading from @xmath52 to node on path @xmath53 at distance @xmath84 from @xmath50 @xmath85 ` encodesectornumber`@xmath86 @xmath87 binary representation of @xmath55 output @xmath74    [ createadvice ]    @xmath88 @xmath89 @xmath90 //",
    "_ port _ is contained in the range @xmath91 return the @xmath92-bit binary representation of @xmath93    [ encodesector ]    [ advicesize ] the advice string @xmath78 has size @xmath57 .",
    "each of the strings @xmath61 has length @xmath94 , and the sum of these lengths is at most @xmath38 .",
    "the string @xmath73 is the binary encoding of the sum @xmath67 .",
    "this sum is maximized when all @xmath52 have the same degree , hence it is @xmath95 .",
    "it follows that the length of @xmath73 is @xmath96 .",
    "therefore , the length of @xmath97 is in @xmath57 .",
    "next , we describe the algorithm findtreasure , which is the agent s algorithm given an advice string @xmath98 . for the purpose of description only , we define the _ trail _ of the agent , which is a stack of edges that it has previously traversed .",
    "the stack gets popped when the agent backtracks .",
    "the agent performs a walk in @xmath26 starting at node @xmath50 . in each step of the algorithm",
    ", the agent chooses an edge to add to the trail , or it backtracks along the trail edge that it added most recently .",
    "the number of edges in the agent s trail will be used to measure the agent s progress . in particular , when the agent is located at a node @xmath29 and there are @xmath47 edges in the agent s trail , we will say that the agent is at _ progress level _ @xmath47 .",
    "the agent keeps track of its current progress level by maintaining a counter that is incremented when it adds a trail edge and decremented when it backtracks .",
    "the agent maintains a table containing the labels of the nodes that it has visited , and , for each node label , the smallest progress level at which the agent visited the node so far .",
    "when the agent arrives at a node @xmath29 from a lower progress level and does not find the treasure , it checks if its current progress level @xmath47 is lower than the progress level stored in the table for node @xmath29 . if this is not the case , or if @xmath99 , then the agent backtracks by going back along the edge it just arrived on",
    "also , the agent backtracks immediately if it sees that the degree of @xmath29 does not `` match '' the size of @xmath61 in the following sense : using @xmath38 , the value of @xmath55 that is encoded in @xmath73 , and the degree of @xmath29 , the agent checks if @xmath100 is equal to the number of bits that the oracle would have provided if @xmath29 was indeed on the path from @xmath50 to the treasure , i.e. , if @xmath101 .",
    "otherwise , if the agent has determined that it should not backtrack immediately , then it uses the advice substring @xmath61 in the following way : it divides the set of port numbers at @xmath29 into sectors ( i.e. , intervals of port numbers ) of size @xmath102 , gives numbers to the sectors , and then interprets @xmath61 as the binary representation of an integer that specifies one of these sectors . for each port number in the specified sector ,",
    "the agent takes the port and arrives at some neighbour @xmath30 of @xmath29 .",
    "the agent terminates if it finds the treasure at node @xmath30 , or , otherwise , repeats the above at node @xmath30 .",
    "if , after trying all ports at node @xmath29 in the specified sector , the treasure has not been found , the agent backtracks .",
    "note that the advice was created with the goal of ` steering ' the agent in the right direction , i.e. , along path @xmath53 , but we can only guarantee that this will happen when the agent is located at nodes on path @xmath53 . in fact , an even stronger condition must hold : for any node @xmath29 on path @xmath53 at distance @xmath47 from @xmath50 , we can only guarantee that the advice will be helpful if the agent is located at node @xmath29 at progress level @xmath47 , since this is when the agent reads the advice substring @xmath61 .",
    "in other words , it is possible that the agent visits a node @xmath29 on @xmath53 at the ` wrong ' progress level , in the sense that it wo nt use the advice that was created specifically for @xmath29 .",
    "this is why it is not sufficient to simply have the agent backtrack whenever it arrives at a previously - visited node , since during its previous visit , it may have used the wrong advice .",
    "moreover , we must ensure that the algorithm gracefully deals with the situation where the agent is at a node @xmath30 at progress level @xmath103 , but the advice substring @xmath104 specifies ports that do not exist at @xmath30 . in our algorithm , the agent ignores any port numbers that are greater than or equal to the current node s degree .",
    "to summarize , in our algorithm , the agent searches for the treasure in a depth - first manner , but it can not perform dfs ( even only to distance @xmath2 ) because the cost would be too large . instead , the agent takes only a fraction of ports at each node , but may possibly have to pay for it by traversing the same edge several times ( while in dfs every edge is traversed at most twice ) . as our analysis will show , this gives an overall decrease of the total cost , especially when the advice is large .",
    "the pseudocode of the search conducted by algorithm findtreasure is described by algorithm [ takestep ] .",
    "it shows how the agent takes a step in the graph , i.e. , for each @xmath60 , how it uses @xmath61 to move from a node at progress level @xmath47 to a node at progress level @xmath84 . in order to initiate the search ,",
    "this algorithm is called at node @xmath50 with progress level 0 ( and @xmath105 ) .",
    "algorithm [ decodesector ] , used as a subroutine in algorithm [ takestep ] , shows how the agent decodes substring @xmath61 to obtain a range of port numbers .",
    "we assume that we have two functions related to the agent - maintained table of visited nodes : ` updatetable`@xmath106 that writes @xmath47 into the entry for node @xmath29 as the smallest progress level at which the agent has ever visited node @xmath29 , and ` currentmin`@xmath107 that reads the entry of the table for node @xmath29 .",
    "each table entry is initialized to @xmath108 .",
    "stop    [ line : ifline ]    ` updatetable`@xmath106 [ line : updatetable ]    @xmath109 @xmath110 @xmath111 integer value encoded in binary string @xmath73 @xmath82 [ line : sizematch ] @xmath112 [ line : forloop ] take port @xmath113 [ line : takeport ] @xmath114 the node reached after taking port @xmath113 call @xmath115    return to node @xmath116 [ line : backtrack ]    [ takestep ]    @xmath117 number of bits in _ sectornumberencoding _",
    "@xmath119 integer value of _ sectornumberencoding _ return @xmath91    [ decodesector ]      in what follows , let @xmath53 be the path from @xmath50 to the treasure that is used to create the advice string @xmath120 .",
    "suppose that @xmath53 consists of the nodes @xmath121 , where , for each @xmath122 , @xmath52 is at distance @xmath47 from @xmath50 , and the treasure is located at node @xmath123 .",
    "also , for each @xmath60 , let @xmath66 be the port at node @xmath52 that leads to node @xmath63 .    to prove the correctness of the algorithm",
    ", we first consider an arbitrary node @xmath52 on path @xmath53 and suppose that the agent is at progress level @xmath47 .",
    "clearly , this occurs at least once during the execution of ` findtreasure ` since the agent is initially located at @xmath124 at progress level 0 .",
    "one of the ports at @xmath52 that are specified by the advice substring @xmath61 leads to node @xmath63 , but the agent may try some other of these ports first .",
    "we show that either the agent finds the treasure by recursively calling ` takestep ` after taking one of these other ports , or , the agent eventually takes the port that leads to node  @xmath63 .",
    "[ makesprogress ] for any @xmath60 , consider the first time that the agent is located at node @xmath52 at progress level @xmath47 . during the execution of ` takestep`@xmath125 , for some node @xmath30 , either :    1 .   the agent moves to node @xmath63 at progress level @xmath84 , or , 2 .",
    "there is a node @xmath126 such that the agent moves to node @xmath29 at progress level @xmath84 , calls ` takestep`@xmath127 , and , during its execution , the treasure is found by the agent .",
    "since we are considering the agent s first visit to node @xmath52 at progress level @xmath47 , and it is not possible for the agent to visit @xmath52 at a progress level less than @xmath47 , it follows that @xmath128 .",
    "so , the * if * condition on line [ line : ifline ] evaluates to true .",
    "further , since node @xmath52 was used in the creation of the advice substring @xmath61 , it follows that @xmath129 , so the * if * condition on line [ line : sizematch ] evaluates to true .",
    "suppose that the treasure is not found during any execution of ` takestep`@xmath127 with @xmath126 . by the choice of @xmath61 , port @xmath66",
    "is located in the range of port numbers returned by ` getsector ` . since taking port @xmath66 at node",
    "@xmath52 leads to node @xmath63 , there exists an iteration of the loop in ` takestep ` such that the agent moves to node @xmath63 and increments its progress level to @xmath84 .",
    "using induction , we extend lemma [ makesprogress ] to show that the agent eventually reaches node @xmath123 .",
    "[ eventuallyfinds ] for any @xmath60 , consider the first time that the agent is located at node @xmath52 at progress level @xmath47 . during the execution of ` takestep`@xmath125 , for some node @xmath30 , the agent finds the treasure .",
    "the proof proceeds by induction on @xmath130 . in the base case , @xmath131 , and",
    "the agent finds the treasure when it is first located at node @xmath123 at progress level @xmath2 since the treasure is located at @xmath123 . as induction hypothesis ,",
    "assume that , for some @xmath132 , when the agent is first located at node @xmath52 at progress level @xmath47 , the agent finds the treasure during the execution of ` takestep ` .",
    "now , consider the first time that the agent is located at node @xmath133 at progress level @xmath134 .",
    "note that , by the induction hypothesis , the agent was not previously located at node @xmath52 at progress level @xmath47 , since otherwise , during the execution of ` takestep ` at the first such visit , the agent would have found the treasure and terminated .    by lemma [ makesprogress ] , when the agent is first located at node @xmath133 at progress level @xmath134 , either :    1 .",
    "the agent moves to node @xmath52 at progress level @xmath47 , or , 2 .",
    "there is a node @xmath135 such that the agent moves to node @xmath29 at progress level @xmath47 , calls ` takestep`@xmath136 , and , during its execution , the treasure is found by the agent .    in the first case",
    ", the induction hypothesis implies that the agent finds the treasure . in the second case",
    ", the treasure is found by the agent , so we are done .    by lemma [ eventuallyfinds ] with @xmath137 ,",
    "the agent finds the treasure during the first execution of takestep , hence @xmath138 is correct .",
    "next , we consider the cost of algorithm ` findtreasure ` .",
    "our analysis considers the cases @xmath58 and @xmath139 separately . we proceed to find upper bounds on the cost of algorithm ` findtreasure ` in terms of a fixed upper bound on the amount of advice provided . to prove the upper bounds , we first give upper bounds on the size of the sector returned by ` getsector ` .",
    "in the first case , we show that when @xmath58 ( i.e. @xmath140 ) the cost of algorithm ` findtreasure ` is optimal .",
    "[ sectorupperone ] suppose that @xmath141 .",
    "for all @xmath60 , if the agent is located at node @xmath52 at progress level @xmath47 , then the size of the sector returned by @xmath142 is exactly 1 .    by the advice construction , @xmath143 .",
    "since @xmath141 , it follows that @xmath144 .",
    "hence , in the execution of @xmath142 , the value of @xmath145 is a positive integer @xmath146 , as required .",
    "[ findtreasurecostone ] suppose that @xmath141 . when provided with advice @xmath74 , the algorithm @xmath138 has cost @xmath2 .    by lemma [ sectorupperone ] , for each @xmath60 , when the agent is located at node @xmath52 at progress level @xmath47 , the execution of @xmath142 returns exactly 1 port number @xmath113 leading to node @xmath63 .",
    "since the agent starts at node @xmath124 at progress level 0 , it follows that the agent takes exactly @xmath2 steps to find the treasure .",
    "therefore , when @xmath141 , algorithm @xmath138 has cost exactly @xmath2 .",
    "in the second case , we assume that @xmath139 ( i.e. @xmath147 ) .",
    "[ sectorupper ] suppose that @xmath147 . for all @xmath60 ,",
    "the size of the sector returned by @xmath148 is at most @xmath149 .",
    "note that , when @xmath148 is executed , it must be the case that line [ line : sizematch ] evaluated to true , i.e. , that @xmath150 . in the execution of @xmath148 ,",
    "the variable @xmath145 is assigned the value @xmath151 .",
    "note that @xmath152 since @xmath147 , it follows that @xmath153 and @xmath154 , so @xmath155 .",
    "therefore , we have shown that @xmath156 , which implies that @xmath157 , as required .",
    "we are now ready to calculate an upper bound on the cost of algorithm ` findtreasure ` .",
    "we denote by @xmath158 an index such that @xmath159 .",
    "[ findtreasurecost ] suppose that @xmath147 . when provided with advice @xmath74 , the algorithm @xmath138 has cost at most @xmath160 .",
    "it suffices to count the total number of times that line [ line : takeport ] of ` takestep ` is called and multiply this value by 2 .",
    "this is because the cost incurred by backtracking ( i.e. , line [ line : backtrack ] of ` takestep ` ) is at most 1 for each execution of ` takestep ` , which amounts to an overall multiplicative factor of at most 2 .",
    "so , we consider the number of times that line [ line : takeport ] of ` takestep ` is called at an arbitrary node @xmath29 . the number of times that the * for * loop at line [ line : forloop ] is iterated is at most @xmath161 when @xmath29 is visited at progress level @xmath47 , since , by lemma [ sectorupper ] , this is an upper bound on the size of the range returned by ` getsector ` .",
    "since line [ line : updatetable ] ensures that the condition on line [ line : ifline ] is true at most once at each progress level @xmath60 , it follows that the total number of times that line [ line : takeport ] is executed is bounded above by @xmath162 . taking the sum over all nodes ,",
    "the total number of calls to ` takestep ` is bounded above by @xmath163 next , since @xmath164 , it follows that @xmath165    since @xmath147 , it follows that @xmath166    finally , we fix an upper bound @xmath0 on the cost of ` findtreasure ` and re - state lemmas [ findtreasurecostone ] and [ findtreasurecost ] to obtain an upper bound on the amount of advice needed to solve treasure hunt at cost @xmath0 .",
    "[ ub ] let @xmath26 be any graph with @xmath1 edges , and let @xmath167 be the distance from the initial position of the agent to the treasure .",
    "let @xmath0 be any integer such that @xmath168 .",
    "the amount of advice needed to solve treasure hunt at cost at most @xmath0 is at most @xmath169 bits .",
    "first , consider the case where @xmath141 . in this case , @xmath170 ( by lemma [ findtreasurecostone ] ) and @xmath171 .",
    "next , consider the case where @xmath147 . by lemma [ findtreasurecost ] ,",
    "algorithm ` findtreasure ` solves treasure hunt with cost @xmath172 .",
    "it follows that @xmath173 , so @xmath174 .",
    "since @xmath175 for each @xmath60 , it follows that @xmath176 .",
    "therefore , regardless of the value of @xmath69 , we have shown that @xmath177 . by lemma [ advicesize ] ,",
    "the size of advice is @xmath178 .",
    "the following lower bound follows immediately from theorem [ tree - lb ] , which is proven by constructing a tree for which treasure hunt requires @xmath5 bits of advice .",
    "this theorem will be proven in section 4 .",
    "[ lb ] let @xmath168 .",
    "there exists a graph @xmath26 with @xmath10 edges , and a position of the treasure at distance @xmath2 from the initial position of the agent , such that treasure hunt at cost @xmath0 requires @xmath5 bits of advice .",
    "the gap between the upper bound given by theorem [ ub ] and the lower bound given by theorem [ lb ] is at most a factor logarithmic in @xmath2 .",
    "moreover , it should be noted that our bounds differ only by an additive term @xmath179 whenever @xmath2 is polynomial in the gain @xmath3 .",
    "we now proceed to prove upper and lower bounds on the advice needed to solve treasure hunt in trees . unlike in the case of arbitrary graphs , where our upper and lower bounds may differ by a logarithmic factor , for trees our bounds differ only by an additive term @xmath179 . again , our bounds will be expressed in terms of @xmath2 , which is the distance between the treasure and the initial position of the agent , and in terms of the ratio @xmath180 , where @xmath1 is the number of edges in the tree , @xmath11 is the number of nodes , and @xmath0 is an upper bound on the cost of the algorithm .",
    "also , for any two nodes @xmath181 , we will denote by @xmath182 the distance between @xmath27 and @xmath28 in the tree , i.e. , the number of edges in the simple path between them .      to obtain our upper bound , we will use algorithm ` findtreasure ` that was defined and proven correct in section [ findtreasure ] for arbitrary graphs . in this section ,",
    "we provide an analysis of the algorithm specifically for the case of trees , which gives a strictly better upper bound .",
    "we start with the following technical lemma , which shows that , if we take the agent s initial position as the root of the tree , the agent s progress level and the agent s current depth in the tree ( i.e. , its current distance from the root ) do not differ . essentially , this is because there is only one simple path from the agent s initial position to each node , and the algorithm ensures that the agent s trail does not contain the same edge multiple times .",
    "[ progresslevel ] consider algorithm findtreasure executed in any tree .",
    "suppose that , for some neighbouring nodes @xmath29 and @xmath116 , @xmath183 is executed at node @xmath29 .",
    "if line [ line : ifline ] evaluates to true , then progress level @xmath184 .",
    "we proceed by induction on the agent s progress level . in the base case , consider progress level @xmath137 . since the first call to ` takestep ` has @xmath137 , and every subsequent call increments the current progress level , the agent must be located at node @xmath50 .",
    "next , assume that , for some progress level @xmath60 and any neighbouring nodes @xmath29 and @xmath116 , in the execution of ` takestep`@xmath185 , if line [ line : ifline ] evaluates to true , then @xmath184 .",
    "now , for some neighbouring nodes @xmath186 and @xmath187 , consider the execution of ` takestep`@xmath188 .",
    "` takestep ` was executed at node @xmath187 at progress level @xmath47 and line [ line : ifline ] of this execution evaluated to true . by the induction hypothesis , it follows that @xmath189 .",
    "next , consider the value of @xmath190 . in a tree",
    ", there is only one simple path from @xmath50 to @xmath186 and one simple path from @xmath50 to @xmath187 . since @xmath186 and @xmath187 are neighbours , either @xmath186 is on the path from @xmath50 to @xmath187 ( in which case @xmath191 ) or @xmath187 is on the path from @xmath50 to @xmath186 ( in which case @xmath192 ) .",
    "if line [ line : ifline ] of the execution of ` takestep`@xmath188 evaluates to true , then @xmath193 , i.e. , @xmath186 was not previously visited at a progress level less than @xmath194 .",
    "it follows that @xmath186 is not located on the path from @xmath50 to @xmath187 .",
    "therefore , it must be the case that @xmath192 , so @xmath195 .",
    "next , we proceed to find an upper bound on the cost of algorithm ` findtreasure ` in trees in terms of a fixed upper bound on the amount of advice provided .",
    "the proof is analogous to the proof of lemma [ findtreasurecost ] , the main difference being that we do not need to multiply by a factor of @xmath2 in order to account for the different paths that the agent could use to reach a given node .",
    "as before , we denote by @xmath158 an index such that @xmath159 .",
    "[ findtreasurecostintrees ] suppose that @xmath147 .",
    "when provided with advice @xmath74 , the algorithm @xmath138 has cost at most @xmath196 .    as in lemma",
    "[ findtreasurecost ] , it suffices to count the total number of times that line [ line : takeport ] of ` takestep ` is called and multiply this value by 2 .",
    "so , we consider the number of times that line [ line : takeport ] of ` takestep ` is called at an arbitrary node @xmath29 . since line [ line : takeport ] is only executed if line [ line : ifline ] evaluates to true , then , by lemma [ progresslevel ] , it follows that @xmath184 at line [ line : takeport ] . by lemma [ sectorupper ] ,",
    "the * for * loop at line [ line : forloop ] is iterated at most @xmath197 times . taking the sum over all nodes ,",
    "the total number of calls to ` takestep ` is bounded above by @xmath198    next , since @xmath164 , it follows that @xmath199 since @xmath200 and @xmath147 , it follows that @xmath201    finally , we fix an upper bound @xmath0 on the cost of ` findtreasure ` and re - state lemmas [ findtreasurecostone ] and [ findtreasurecostintrees ] as an upper bound on the amount of advice needed to solve treasure hunt in trees at cost @xmath0 .",
    "[ tree - ub ] let @xmath202 .",
    "the amount of advice needed to solve treasure hunt on trees of size @xmath11 with cost at most @xmath0 is at most @xmath203 bits .",
    "first , consider the case where @xmath141 .",
    "in this case , @xmath170 ( by lemma [ findtreasurecostone ] ) and @xmath204 .",
    "next , consider the case where @xmath147 . by lemma [ findtreasurecostintrees ] ,",
    "algorithm ` findtreasure ` solves treasure hunt with cost @xmath205 .",
    "it follows that @xmath206 , so @xmath207 . since @xmath175 for each @xmath60",
    ", it follows that @xmath208 .",
    "therefore , regardless of the value of @xmath69 , we have shown that @xmath209 . by lemma [ advicesize ] ,",
    "the size of advice is @xmath210 .",
    "we now set out to prove a lower bound on the amount of advice needed to solve treasure hunt at cost at most @xmath0 .",
    "we consider a collection @xmath211 of _ caterpillar trees _",
    ", each constructed as follows .",
    "take a path graph @xmath53 consisting of @xmath212 nodes @xmath121 , where @xmath52 and @xmath63 are adjacent , for every @xmath213 .",
    "place the treasure at node @xmath123 . for each @xmath60",
    ", add @xmath214 nodes to the graph such that each of them has degree 1 and is adjacent only to node @xmath52 .",
    "the resulting graph is a tree on @xmath215 nodes . for each node @xmath29 in this tree",
    ", the ports at @xmath29 are labeled with the integers @xmath216 so that , for each @xmath217 , the port numbers at both ends of the edge @xmath218 are equal .",
    "finally we fix node labels as follows . for each @xmath60 ,",
    "node @xmath52 has label @xmath219 , and each leaf adjacent to @xmath52 has label @xmath220 , where the port number at @xmath52 leading to it is @xmath103 .",
    "notice that all labels are distinct .    for each @xmath60 ,",
    "let @xmath66 be the port number at @xmath52 corresponding to the edge @xmath218 .",
    "the trees in @xmath211 are in one - to - one correspondence with the sequences @xmath221 because the label of each leaf is determined by the port number ( at the adjacent node @xmath52 ) leading to it .",
    "it follows that the number of distinct caterpillar trees in @xmath211 ( taking into consideration the placement of the treasure ) is @xmath222 .",
    "figure [ caterpillardiagram ] gives a diagram of a caterpillar tree in @xmath211 and shows how nodes are labeled .     with ports on path",
    "@xmath53 labeled .",
    "( b ) the labels of the @xmath214 added leaves adjacent to @xmath52 are shown .",
    "node @xmath52 is labeled @xmath219 . ]",
    "consider any fixed caterpillar tree @xmath223 .",
    "we set the starting node of the agent to be @xmath124 . to find the treasure",
    ", the agent must traverse the @xmath2 edges of path @xmath53 .",
    "suppose that , for some @xmath60 , the agent is located at node @xmath52 .",
    "if the agent takes port @xmath66 , it will arrive at node @xmath63 , and we say that this edge traversal is _",
    "successful_. we may assume that the agent does not return to node @xmath52 , i.e. , away from the treasure , because such a move would only increase the cost of the algorithm .",
    "further , the agent can detect when it has found the treasure and terminate immediately .",
    "when an agent s step is not successful ( that is , when located at node @xmath52 , it chooses a port other than @xmath66 ) it arrives at a leaf adjacent to @xmath52 . in this case , we say that the agent _ misses_. after a miss , the agent s next step is to return to node @xmath52 .",
    "let @xmath224 be the number of times that the agent takes a port other than @xmath66 when located at node @xmath52 in @xmath26 .",
    "the _ cost at node @xmath52 _ , denoted by @xmath225 , is @xmath226 , since there are two edge traversals for each miss and one successful edge traversal .",
    "this implies the following fact .",
    "[ cost ] for any @xmath223 , the total cost of any treasure hunt algorithm in @xmath26 is @xmath227 .",
    "we now prove a lower bound on the size of advice needed to solve treasure hunt for the class of caterpillar trees .",
    "[ tree - lb ]",
    "let @xmath228 .",
    "there exists a tree of size @xmath229 , and a position of the treasure at distance @xmath2 from the initial position of the agent , such that treasure hunt at cost @xmath0 requires @xmath5 bits of advice .",
    "consider any algorithm @xmath22 that solves treasure hunt at cost at most @xmath0 using @xmath28 bits of advice .",
    "let @xmath230 .",
    "let @xmath231 be a set of maximum size consisting of trees from @xmath211 such that , for all trees in @xmath231 , the agent is given the same advice string . by the pigeonhole principle , it follows that @xmath232 .",
    "we proceed to find an upper bound on the size of such a set @xmath231 .",
    "consider any two different trees @xmath233 such that the agent is given the same advice string for both of them .",
    "let @xmath47 be the smallest index such that the port at @xmath52 leading to @xmath63 is different in @xmath26 and @xmath35 .",
    "then the behaviour of the agent prior to visiting @xmath52 for the first time is the same in @xmath26 and in @xmath35 .",
    "hence , @xmath234 . by fact",
    "[ cost ] , we know that @xmath235 , so @xmath236 . therefore , the number of trees in @xmath231 is bounded above by the number of distinct integer - valued @xmath2-tuples of non - negative terms whose sum is at most @xmath237 .",
    "( these tuples correspond to sequences @xmath238 ) . )    if @xmath239 , then there is only one such @xmath2-tuple , i.e. , the tuple with all entries equal to 0 .",
    "it follows that @xmath240 .",
    "recall that @xmath231 was chosen as a set of maximum size such that , for all trees in @xmath231 , the same advice is given to the agent .",
    "it follows that , for each tree in @xmath211 , the agent is given a different advice string .",
    "therefore , the number of different advice strings is @xmath222 , so the size of advice is at least @xmath241 .",
    "since @xmath242 , and @xmath239 implies that @xmath243 , it follows that @xmath244 , as required .",
    "so , we proceed with the assumption that @xmath245 .",
    "the following claim will be used to obtain an upper bound on the number of distinct integer - valued @xmath2-tuples of non - negative terms whose sum is at most @xmath237 . in the sequel , @xmath2-tuples with integer coordinates will be called _ integer points_.",
    "[ tuples ] fix any @xmath246 .",
    "let @xmath53 be the set of integer - valued @xmath2-tuples of non - negative terms whose sum is at most @xmath247 .",
    "then , @xmath248 .    to prove the claim",
    ", we note that @xmath249 is the number of integer points in the simplex @xmath250 .",
    "let @xmath251 denote the simplex @xmath252 .",
    "since @xmath251 is a translation of the points in @xmath253 by @xmath247 in every coordinate , it follows that @xmath249 is also the number of integer points in the simplex @xmath251 . for each integer point",
    "@xmath113 in @xmath251 , we construct a small @xmath2-dimensional _ box _ centered at @xmath113 .",
    "more specifically , for each @xmath254 such that @xmath255 , we construct @xmath256 . note that , for any two distinct integer points @xmath257 , the boxes @xmath258 and @xmath259 are disjoint .",
    "further , the volume of each such @xmath258 is @xmath260 .",
    "finally , we wish to find an upper bound on the volume of the union of all boxes @xmath258 where @xmath113 is an integer point in @xmath251 . to this end , we define a simplex @xmath261 ( a scaled version of @xmath253 ) such that , for each integer point @xmath262 , the box @xmath258 is completely contained in @xmath261 . in particular , we define @xmath263 .",
    "it follows that @xmath264 is bounded above by the volume of @xmath261 . from @xcite ,",
    "the volume of @xmath261 is equal to @xmath265 , which implies that @xmath248 .",
    "this completes the proof of the claim .    by claim [ tuples ] with @xmath266",
    ", the number of trees in @xmath231 is bounded above by @xmath267 .",
    "combined with our earlier lower bound on the number of trees in @xmath231 , we have @xmath268 , which implies that    @xmath269{d!}}{3(c - d ) } \\geq \\frac{k \\cdot \\sqrt[d]{d!}}{3c}.\\ ] ] so , @xmath270{d!}}{3c } \\right).\\ ] ]    by stirling s formula we have @xmath271 , for sufficiently large @xmath2 . hence @xmath272{d ! } \\geq",
    "d^{1/(2d ) } \\cdot ( d / e)$ ] , where @xmath1 is the euler s constant .",
    "since the first factor converges to 1 as @xmath2 grows , we have @xmath272{d ! }",
    "\\in \\omega(d)$ ] .",
    "hence , the above bound on @xmath28 implies @xmath273 . since @xmath230",
    ", it follows that @xmath274 , so the size of advice is in @xmath275 , as required .",
    "we established upper and lower bounds on the minimum size of advice sufficient to solve the problems of rendezvous and of treasure hunt at a given cost . for the class of trees our bounds are almost tight , up to constant factors and a summand of @xmath276 . for the class of arbitrary graphs , our bounds leave a gap of a logarithmic factor . closing these gaps",
    "is a natural open problem .",
    "it should be noted , however , that , even for arbitrary graphs , our bounds are asymptotically tight whenever @xmath277 is @xmath278 and @xmath2 is polynomial in the gain @xmath3 .",
    "this is the case , for example , when we want to accomplish treasure hunt or rendezvous at cost @xmath279 in an @xmath11-node graph .",
    "there are only two special situations when our gap for arbitrary graphs remains non - constant .",
    "one of them is if @xmath2 is very large with respect to the gain @xmath3 , e.g. , for an @xmath11-node graph with @xmath280 edges in which the treasure is located at distance @xmath279 at cost @xmath281 ; our ( multiplicative ) gap is @xmath282 in this case .",
    "the other situation is when both @xmath2 and @xmath3 are very small with respect to @xmath1 , e.g. , when the treasure in an @xmath11-node graph is located at distance @xmath283 and we want to do treasure hunt at cost @xmath284 . in this case we have an additive gap of @xmath285 .",
    "it should also be noted that , in the context of advice , treasure hunt is not only equivalent to rendezvous of two agents , as shown in proposition [ eq ] , but also to rendezvous of many agents , which is often called _ gathering_. this task consists in gathering several agents at the same node in the same round . in this case , the cost should be defined as the maximum number of edge traversals per agent , and the advice size as the maximum number of bits per agent .",
    "the reduction given by the first part of proposition [ eq ] should be modified as follows .",
    "one of the agents , starting at some node @xmath30 , is given advice string @xmath33 indicating that it should be inert .",
    "each other agent @xmath103 is given the advice string @xmath286 , where @xmath287 is the advice enabling agent @xmath103 to find a treasure located at @xmath30 .",
    "this work was partially supported by nserc discovery grant 8136  2013 and by the research chair in distributed computing at the universit du qubec en outaouais .",
    "e. bampas , j. czyzowicz , l. gasieniec , d. ilcinkas , a. labourel , almost optimal asynchronous rendezvous in infinite multidimensional grids , proc .",
    "24th international symposium on distributed computing ( disc 2010 ) , 297 - 311 .",
    "p. fraigniaud , d. ilcinkas , a. pelc , communication algorithms with advice , journal of computer and system sciences 76 ( 2010 ) , 222232 .",
    "p. fraigniaud , d. ilcinkas , a. pelc , tree exploration with advice , information and computation 206 ( 2008 ) , 12761287 .",
    "p. fraigniaud , a. korman , e. lebhar , local mst computation with short advice , theory of computing systems 47 ( 2010 ) , 920933 .        c.  gavoille , d.  peleg , s.  prennes , r.  raz .",
    "distance labeling in graphs , journal of algorithms 53 ( 2004 ) , 85 - 112 .",
    "hipke , c. icking , r. klein , e. langetepe , how to nd a point on a line within a xed distance . disc .",
    "93 ( 1999 ) , 6773 .",
    "a. miller , a. pelc , fast rendezvous with advice , proc .",
    "10th int . symp . on algorithms and experiments for sensor systems , wireless networks and distributed robotics ( algosensors 2014 ) .",
    "full version at arxiv:1407.1428v1 [ cs.ds ]"
  ],
  "abstract_text": [
    "<S> in rendezvous , two agents traverse network edges in synchronous rounds and have to meet at some node . in treasure hunt </S>",
    "<S> , a single agent has to find a stationary target situated at an unknown node of the network . </S>",
    "<S> we study tradeoffs between the amount of information ( _ advice _ ) available _ a priori _ to the agents and the cost ( number of edge traversals ) of rendezvous and treasure hunt . </S>",
    "<S> our goal is to find the smallest size of advice which enables the agents to solve these tasks at some cost @xmath0 in a network with @xmath1 edges . </S>",
    "<S> this size turns out to depend on the initial distance @xmath2 and on the ratio @xmath3 , which is the _ relative cost gain _ due to advice . for arbitrary graphs , </S>",
    "<S> we give upper and lower bounds of @xmath4 and @xmath5 , respectively , on the optimal size of advice . </S>",
    "<S> for the class of trees , we give nearly tight upper and lower bounds of @xmath6 and @xmath7 , respectively .    </S>",
    "<S> * keywords : * rendezvous , treasure hunt , advice , deterministic algorithm , mobile agent , cost .    0.2 in 0.1 in 0.0 in </S>"
  ]
}