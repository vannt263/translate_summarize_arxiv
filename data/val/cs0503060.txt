{
  "article_text": [
    "one - way hash chains are an important cryptographic primitive and have been used as a building block of a variety of cryptographic applications such as access control , one - time signature , electronic payment , on - line auction , etc .",
    "in particular , there are many micropayment schemes based on one - way hash chains , including payword @xcite , netcard @xcite , micro - ikp @xcite and others .    by definition ,",
    "micropayments are electronic payments of low value .",
    "other schemes designed for payments of high value normally use a digital signature to authenticate every payment made .",
    "such an approach is not suitable for micropayments because of high computational cost and bank processing cost in comparison with the value of payment .",
    "the use of hash chains in micropayment schemes allows minimizing the use of digital signature , whose computation is far slower than the computation of a hash function ( according to @xcite , hash functions are about 100 times faster than rsa signature verification , and about 10,000 times faster than rsa signature generation ) .",
    "moreover , because a whole hash chain is authenticated by a single digital signature on the root of chain , successive micropayments can be aggregated into a single larger payment , thus reducing bank processing cost .",
    "there are a variety of improvements to hash chains .",
    "for example , in the paytree payment scheme @xcite , jutla and yung generalized the hash chain to a hash tree .",
    "this construction allows the customer to use parts of a tree to pay different vendors .",
    "recently , researchers have proposed a number of improved hash chains , which are more efficient in terms of computational overhead and storage requirement @xcite .",
    "this paper is organized as follows . in section [ mdhc ]",
    "we introduce the notion of multi - dimensional hash chains ( mdhc for short ) .",
    "we also analyze efficiency of this construction and show that rsa modular exponentiations could be used as one - way hash functions of a mdhc .",
    "section [ cashlikeschemes ] describes two cash - like micropayment schemes based on mdhc , which have a number of advantages in terms of efficiency and security . in section [ improvepayword ]",
    "we also examine some possible improvements to payword and similar schemes . finally , section [ conclusion ] concludes the paper .",
    "the notion of mdhc originates from one - way hash chains and one - way accumulators @xcite .",
    "here we briefly describe these two constructions .",
    "a hash chain is generated by applying a hash function multiple times .",
    "suppose that we have a one - way hash function @xmath1 and some starting value @xmath2 .",
    "a hash chain consists of values @xmath3 where @xmath4 for @xmath5 .",
    "the value @xmath6 is called the root of hash chain .",
    "the figure below depicts a hash chain of size @xmath7 :    in contrast , a one - way accumulator is the output of multiple hash functions , each of them applied only once : @xmath8    in order to ensure that the output is uniquely determined regardless of the application order , functions @xmath9 must be in pairs commutative , i.e. @xmath10 for any @xmath11 .    combining the two constructions described above , we define a multi - dimensional hash chain as the result of multiple applications of different commutative hash functions , so the root of an @xmath12-dimensional hash chain is : @xmath13    it is necessary to note that mdhc differs from other generalizations of normal hash chain such as hash tree , which is used in paytree scheme . in particular such trees",
    "are generated from multiple leaf nodes , while a mdhc is generated from a single starting value ( i.e. the value @xmath14 above ) .",
    "we begin with necessary definitions .    *",
    "_ definition 1 .",
    "_ * two functions @xmath15 are called commutative if @xmath16 for any @xmath17 .",
    "* _ definition 2 .",
    "_ * a one - way function @xmath18 is called one - way independent of one - way functions @xmath19 of the same domain if for any @xmath20 , computing @xmath21 is intractable even if values @xmath22 are known .",
    "and now we define mdhc as follows .    * _ definition 3 . _ * let @xmath19 be @xmath12 one - way hash functions that are in pairs commutative and every of them is one - way independent from all others .",
    "an @xmath12-dimensional hash chain of size @xmath23 consists of values @xmath24 where : @xmath25    the value @xmath26 is called the starting node , and the value @xmath27 is called the root of the mdhc , which is uniquely determined from @xmath14 due to commutativity of hash functions : @xmath28    as an illustration , the figure below depicts a two - dimensional hash chain of size ( 3,2 ) :      in recent literature , there are a number of improvements to one - way hash chains that aim to be more efficient in terms of computational overhead and storage requirement .",
    "a widely used metric for one - way hash chain efficiency is the storage - computational complexity , which is the product of the traversal overhead and the storage required to compute consecutive nodes of the hash chain .",
    "it is easy to see that a linear hash chain size of @xmath7 has storage - computational complexity of @xmath29 .",
    "in fact , if we precompute and store all nodes ( storage of @xmath30 , then no computation is needed when a node is requested ( traversal of @xmath31 .",
    "alternatively , we can store only the starting value , and compute every node from the beginning each time it is requested .",
    "this approach requires storage of @xmath32 and @xmath29 computations .",
    "also , if we store each of @xmath33 nodes , then storage of @xmath34 and @xmath35 computations are required .",
    "so , in any case , the storage - computational complexity of the linear hash chain is @xmath29 .",
    "in @xcite the authors have proposed new techniques that make traversal and storage more efficient , which require @xmath36 computations and @xmath36 storage , resulting in storage - computational complexity of @xmath37 .",
    "recently , hu et al .",
    "@xcite have presented a new hierarchical construction for one - way hash chains that requires @xmath36 storage and only @xmath32 traversal overhead .    in our case of @xmath12-dimensional hash chain of size @xmath7 ( for simplicity we assume all dimensions have the same size @xmath38 ,",
    "the number of nodes is @xmath39 .",
    "if we store only the starting node of the chain ( storage of @xmath31 then maximal number of calculations required to compute any node is @xmath40 , or @xmath41 if we select @xmath42 . in that case",
    "the storage - computational complexity of mdhc is @xmath0 , which is equivalent to the results in @xcite .",
    "the advantage of mdhc is its simple implementation that does not rely on the so - called pebbling technique , which is used in the constructions mentioned above .",
    "however , the main limitation of this construction is the fact that hash functions have to meet the conditions described in the definition of mdhc .",
    "the rsa modular exponentiation is known to meet these conditions , but it is not as fast as the traditional hash functions , e.g. md5 or sha .",
    "let consider the function of rsa modular exponentiation : @xmath43 where @xmath44 is some constant value and @xmath45 is an rsa modulus , which is a product of two large primes of equal bit length @xmath46 and @xmath47 .    according to @xcite",
    ", the rsa modular exponentiation functions with appropriately selected exponents could meet mdhc requirements .",
    "first , obviously these functions are in pairs commutative : @xmath48    second , one - wayness of these functions is derived from the rsa assumption @xcite , which states that the problem of finding the modular root @xmath49 is intractable .    finally , regarding one - way independence of functions , shamir @xcite showed that if @xmath44 is not a divisor of the product @xmath50 then the modular roots @xmath51 are insufficient to compute the value of @xmath52 .",
    "therefore we can use the functions of rsa modular exponentiation as one - way hash functions to construct multi - dimensional hash chains .    in that case",
    "we have following recursive expression : @xmath53 where @xmath54 are exponents of rsa functions @xmath19 respectively .",
    "note that if one knows the factorization of @xmath45 ( i.e. knows @xmath46 and @xmath55 , then one can compute @xmath56 quickly by using following expression : @xmath57 where @xmath58 , and @xmath59 denotes the euler s totient function .",
    "the expression above consists of only one modular exponentiation with modulus @xmath45 and @xmath41 modular multiplications with modulus @xmath60 .",
    "since a multiplication is far faster than an exponentiation , this expression allows us to compute @xmath56 from @xmath14 in a very effective manner .",
    "cash - like payment schemes use the notion of electronic coin , which is an authenticated ( by the bank ) bit string that is easy to verify , but hard to forge .",
    "examples of such coin are hash collisions ( as in micromint @xcite ) , or digital signatures ( as in ecash @xcite ) .",
    "let s recall the definition of mdhc .",
    "if we select the size of the hash chain with @xmath42 then all nodes @xmath61 ( with all @xmath62 , except @xmath63 have the same hash value : @xmath64 .",
    "so we can use a pair @xmath65 as an electronic coin since :    * it is easy to verify by just one hashing . *",
    "it is hard to forge because hash functions @xmath66 are one - way , and their one - way independence assures that coin forgery is impossible even if one knows other coins with the same root @xmath56 .",
    "as a proof of that concept , we suggest two micropayment schemes based on mdhc with the rsa modular exponentiation . we refer to these as s1 and s2 schemes .",
    "we assume that there are three parties involved in a micropayment scheme , namely a bank ( b ) , a customer ( c ) and a vendor ( v ) .",
    "b is trusted by both c and v.    setup :    * b selects an rsa modulus @xmath67 where @xmath46 and @xmath47 are large _ safe _ primes of equal bit length .",
    "a prime p is called safe if @xmath68 where @xmath69 is also an odd prime . *",
    "b chooses @xmath12 constant values @xmath54 that satisfy the condition of one - way independence , i.e. each @xmath70 is not a factor of @xmath71 .",
    "these values together with modulus @xmath45 are public parameters and can be used for multiple coin generations . * to generate @xmath12 coins",
    ", b picks a random value @xmath14 and computes : @xmath72 @xmath73 @xmath74 + now b has @xmath12 coins @xmath75 . *",
    "b keeps @xmath56 in a public list of coin roots .",
    "* for prevention of double - spending b keeps another list of all unspent coins .",
    "in addition , b can also generate vendor - specific as well as customer - specific coins by using some bit portions of constants @xmath70 to form vendor i d and customer i d , similar to the technique used in micromint scheme . * c buys a sufficiently large number of coins from b before making purchases .    payment :    * c pays a coin @xmath75 to vendor v. * v verifies the coin by computing @xmath76 , and checks if @xmath56 is in the list of coin roots . note that this list is relative small and does not change",
    "frequently so c could keep it locally . * to assure that a coin was not double - spent , v either checks the list of unspent coins on - line with b , or checks ( off - line ) the list of coins he already received if the coin is vendor - specific .",
    "redemption :    * v deposits the coins he got from customers to b and receives an amount corresponding to number of coins .    at the end of the coin validity period ,",
    "c can sell unused coins back to b or exchange them for new coins .",
    "the proposed above scheme has several advantages :    * coins are hard to forge under the rsa assumption .",
    "* payment can be made off - line by using vendor - specific coins . *",
    "if customer - specific coins are not used , the scheme is anonymous and untraceable because coins contain no customer information and there are no links between coins .",
    "however , the disadvantages of this scheme are :    * generation and verification of coins is not very efficient .",
    "each coin requires one modular exponentiation to generate or verify it , which is much slower than normal hash calculation .",
    "* the list of unspent coins can be very big , though this is a common problem of most coin - based schemes .    to overcome these disadvantages , we propose a modified scheme with larger size hash chains ( i.e. with @xmath77 .",
    "in this scheme , b generates @xmath12 chains of coins at once , rather than @xmath12 single coins .",
    "each coin chain is similar to the hash chain used in the payword scheme .",
    "setup :    * b selects public parameters @xmath45 and @xmath54 in the same way as in the s1 scheme .",
    "let @xmath7 be the size of the hash chains ( for simplicity we assume all dimensions have the same size i.e. @xmath78 .",
    "* b picks a random value @xmath14 and computes : @xmath79 @xmath80 @xmath81 + now b has @xmath12 coin chains @xmath75 .",
    "each of those chains contains exactly @xmath7 coins @xmath82 for @xmath83 where : + @xmath84 @xmath85 + the coins from one coin chain must be paid to the same vendor . * for double - spending prevention , now there is no need to keep track of all unspent coins .",
    "instead , b keeps the list of first coins of all unused chains . * as in the s1 scheme , coin chains can be vendor - specific as well as customer - specific .",
    "* c buys coin chains from b before making purchases .",
    "payment :    * c pays a vendor v the coins from a coin chain . the first coin of the chain @xmath86 is verified by computing @xmath87 and lookup of @xmath56 in the list of chain roots .",
    "it is also checked for double - spending by lookup in the list of unused chains .",
    "any subsequent coin is verified by checking that it hashes to the previous coin in the chain , as in the payword scheme : @xmath88    redemption :    * v deposits the last coin ( i.e. the coin with highest index @xmath89 of each coin chain he got from customers to b and receives an amount corresponding to number of coins .    comparing with the s1 scheme ,",
    "this modified scheme retains all advantages of s1 , but storage requirement is reduced by factor of @xmath7 .",
    "in fact , b keeps track of only the first coins of @xmath7-coin chains .",
    "another advantage of this scheme is more efficient coin generation .",
    "because b knows the factorization of m , he can compute the starting node of a coin chain by just one modular exponentiation .",
    "thus the cost of this computational expensive operation is shared over all coins of the chain .",
    "similarly , b can also verify coin chains that he got from vendors by computing one modular exponentiation per chain .",
    "generally speaking , the s2 scheme combines the advantages of two approaches .",
    "a first approach uses unrelated coins that are convenient for payments to multiple vendors .",
    "another approach uses chains of coins that are easy to generate and verify . in our scheme different coin chains",
    "are unrelated , while coins within a chain are generated and verified only by repeated hashing .",
    "the payword scheme has been proposed in @xcite .",
    "it is based on one - way hash chains described in the section [ mdhc ] . in this scheme , before making purchases a customer c generates a hash chain @xmath90 ( that is a chain of paywords ) and sends his signature of the root @xmath91 to the vendor v. the customer then makes a payment to v by revealing the next payword , which can be verified by checking that it hashes to the previous payword .",
    "the payword scheme allows a vendor to aggregate successive payments from a customer by sending only last payword he got from the customer to the bank for redemption .",
    "however , a vendor can not aggregate payments of different customers , nor can a customer use the same chain of paywords to make payments to different vendors , because there is no way to merge different hash chains .    by using mdhc , we can improve payword scheme in a number of ways .",
    "below we briefly describe two of such possible improvements .",
    "note that some irrelevant details in these descriptions are omitted for convenience .",
    "in the original payword scheme the size of the hash chain must be large enough .",
    "for example , if each micropayment is worth 1 cent and total payment is up to $ 100 , then a chain with size of 10,000 must be generated , which requires 10,000 hash calculations .",
    "we can reduce the number of hash calculations by using mdhc instead of linear hash chain .",
    "the idea is that every dimension of mdhc will be associated with different weight ( or denomination ) according to some number system ( e.g. decimal or binary ) .",
    "suppose we have an @xmath12-dimensional hash chain with size of @xmath7 .",
    "if one step in the ( @xmath92 + 1)@xmath93 dimension is equivalent to @xmath94 steps in @xmath95 dimension , then a node @xmath96 corresponds to the value : @xmath97    the maximal value that could be represented by this hash chain is @xmath98 and the number of hash calculations required to generate the hash chain is @xmath99 . in the case of a binary number system ( i.e. @xmath100 it is @xmath101 .    returning to the example above , the hash chain now requires just 14 calculations to generate .    similarly ,",
    "verification of the payword also requires significantly less calculations than in the case of the original payword scheme .      in the payword scheme",
    "a hash chain can be used for payments to only one vendor .",
    "a customer must generate different hash chains for payment to different vendors .",
    "we can overcome this drawback by using mdhc as well .",
    "let every vendor @xmath102 in the payment system is assigned a different hash function @xmath66 ( i.e. a public parameter @xmath70 in the case of rsa modular exponentiation ) .",
    "now , in order to make payment to @xmath12 different vendors , a customer generates an @xmath12-dimensional hash chain with their public parameters @xmath70 and signs its root .",
    "the customer then makes a payment to @xmath102 by revealing the next payword in the @xmath95 dimension , starting from the root of hash chain .",
    "in particular , if the current payword is @xmath103 , the next payword in @xmath95 dimension will be @xmath104 .    at the end of the day",
    ", vendors deposit the last paywords they got to the bank for redemption .",
    "the bank picks the last payword ( which is the one with highest indices ) among paywords with certain root ( which all come from one customer ) .",
    "finally , the bank credits vendors @xmath102 by the amount equivalent to @xmath105 , and debits the customer s account accordingly .    there could be other possible improvements to the payword scheme by using mdhc .",
    "for example we can aggregate payments of different customers into a single mdhc that is generated by the bank , or we can construct a payment scheme with multiple currencies , etc .",
    "the proposed multi - dimensional hash chain is a simple and efficient construction for one - way hash chains .",
    "whereas a traditional one - way hash chain has a storage - computational complexity of @xmath29 , our construction achieves a complexity of @xmath36 , which is comparable with the best result among other recently proposed constructions .",
    "we show that multi - dimensional hash chains can be very useful in micropayment schemes .",
    "in particular , we suggest two cash - like micropayment schemes based on mdhc with rsa modular exponentiation as one - way hash function .",
    "the first scheme utilizes coins that are hard to forge under the rsa assumption",
    ". this scheme could be also off - line and untraceable .",
    "the second scheme has additional advantages including very efficient coin generation / verification and much less storage requirements .",
    "we also point out some possible improvements to payword and similar schemes by using mdhc , including payword chains with multiple denominations , and a scheme that allows payment to multiple vendors using the same payword chain .",
    "r. anderson , h. manifavas , and c. sutherland .",
    "netcard - a practical electronic cash system . _ proceedings of the 4th security protocols international workshop ( security protocols ) _ , pp.4957 , lecture notes in computer science vol .",
    "springer - verlag , berlin , 1996 .",
    "r. rivest and a. shamir .",
    "payword and micromint : two simple micropayment schemes . _",
    "proceedings of the 4th security protocols international workshop ( security protocols ) _ , pp.6987 , lecture notes in computer science vol . 1189 .",
    "springer - verlag , berlin , 1996 .",
    "b. schoenmakers .",
    "security aspects of the ecash payment system . _ state of the art in applied cryptography : course on computer security and industrial cryptography - revised lectures _ , pp.33852 , lecture notes in computer science vol .",
    "springer - verlag , berlin , 1998 ."
  ],
  "abstract_text": [
    "<S> one - way hash chains have been used in many micropayment schemes due to their simplicity and efficiency . in this paper </S>",
    "<S> we introduce the notion of multi - dimensional hash chains , which is a new generalization of traditional one - way hash chains . </S>",
    "<S> we show that this construction has storage - computational complexity of @xmath0 per chain element , which is comparable with the best result reported in recent literature . based on multi - dimensional hash chains , </S>",
    "<S> we then propose two cash - like micropayment schemes , which have a number of advantages in terms of efficiency and security . </S>",
    "<S> we also point out some possible improvements to payword and similar schemes by using multi - dimensional hash chains . </S>"
  ]
}