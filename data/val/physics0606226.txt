{
  "article_text": [
    "molecular dynamics simulations are a powerful tool for determining the behavior of multiparticle systems and are used in a wide range of applications @xcite .",
    "there are two basic approaches to these simulations :    \\(i ) time driven simulations @xcite in which equations of motion of all particles are solved for a series of small time slices .",
    "the positions and velocities of the particles are determined at the end of each time slice and used as input to the calculation for the next time slice .",
    "\\(ii ) event driven simulations @xcite which are applicable to systems of hard spheres or more generally to systems with interparticle potentials which are piecewise constant .",
    "the approach with event driven simulations is to determine when the next collision between two particles occurs , determine the positions and velocities of these particles after the collision and then repeat this process .",
    "a collision is defined as the event in which the hard spheres collide or more generally when two particles reach a discontinuity in their interparticle potential .",
    "we focus here on event driven simulations which , where applicable , provide exact results and typically run faster than time driven simulations .",
    "determination of the next event is usually composed of two steps @xcite :    \\(i ) determination of the collision event with the shortest time for each particle . by dividing the system into cells and/or maintaining lists of particles within a certain distance of a given particle ( neighbor lists ) , the time taken for calculation of the first collision event for a given particle can be made independent of n , the total number of particles in the system @xcite .",
    "\\(ii ) determination of the collision event with the shortest time among all the particles , given the events with the shortest time for each particle obtained in ( i ) .",
    "approaches have been proposed and implemented which allow this determination in o(@xmath1 ) time .",
    "the subject of this paper is an approach to determining the next collision event among all particles .",
    "this has been a heavily researched subject @xcite .",
    "the requirements for a queue to allow this determination is as follows .",
    "the queue must support :    \\(i ) addition of an event to the queue ;    \\(ii ) identification and deletion from the queue of the event with the shortest collision time ;    \\(iii ) deletion of a given event from the queue ( e.g. when a collision ( p , q ) occurs we may want to remove the event ( q , p ) from the queue . )",
    "these requirements define abstractly the concept of a _ priority queue_.    implementations of priority queues for molecular dynamics simulations have for the most part been based on various types of binary trees .",
    "they all share the property that determining the event in the queue with the smallest value requires o(@xmath1 ) time @xcite .",
    "the early work on priority queues is reviewed in ref .",
    "the earliest implementations of priority queues used linked lists which results in @xmath2 performance .",
    "implementations with @xmath3 performance were introduced and analyzed in refs .",
    "the oldest priority queue implementations with @xmath4 performance used _ implicit heaps _ binary trees in which each item always has a priority higher than its children and the tree is embedded in an array @xcite .",
    "other @xmath4 implementations include _ leftist trees _",
    "@xcite , _ binomial queues _",
    "@xcite , _ pagodas _",
    "@xcite , _ skew heaps _",
    "@xcite , _ splay trees _ @xcite and _ pairing heaps _ @xcite .",
    "marin et al .",
    "@xcite introduced a version of the _ complete binary tree _ which also has @xmath4 performance and compared it to earlier priority queue implementations explicitly in the context of molecular dynamics simulations . they find that over a wide range of densities their complete binary tree variant has the best performance in terms of the coefficient of the @xmath1 term and large @xmath0 behavior .    in this work",
    ", we propose a priority queue for use in event driven molecular dynamics simulations for which all operations require o(1 ) time .",
    "the approach is inspired by the concept of a _ bounded priority queue _ which is typically implemented as an array of linear lists and which is applicable to problems in which the values associated with queue items are integers and are bounded ( i.e. the values @xmath5 associated with events obey @xmath6 where @xmath7 and @xmath8 are constants ) . bounded priority queues are not directly applicable to the molecular dynamics queueing problem because neither of these requirements are met .",
    "we show , however , that with a hybrid approach that employs both a normal priority queue and a bounded priority queue we can ensure all operations on the queue take o(1 ) time .",
    "we make use of the facts that for molecular dynamics simulations :    \\(i ) the time associated with an event to be added to the queue is always later than the time associated with the last event removed from the top of the queue .",
    "that is , @xmath9 where @xmath5 is the time associated with the event to be added to the queue and @xmath10 is the last event removed from the top of the queue .",
    "\\(ii ) there exists a constant , @xmath11 such that @xmath12 we call a priority queue which supports such events a bipq ( bounded increasing priority queue ) .",
    "the basic idea is to :    \\(i ) perform a gross sort of the events using an array of linear lists and    \\(ii ) to use a binary tree to perform a fine sort of only those events which are currently candidates for the event with the shortest time .",
    "more specifically , our priority queue is composed of the following components :    \\1 .",
    "an array , @xmath13 , of @xmath14 linear lists @xmath15 , @xmath16 .",
    "( section [ choose ] below discusses how to determine the the size @xmath14 of the array . )",
    "the array is treated in a circular manner .",
    "that is , the last linear list in the array is followed logically by the first linear list .",
    "we implement each linear list as a doubly linked list .",
    "\\2 . a binary tree which is used to implement a conventional priority queue .",
    "we also maintain two additional quantities : the _ current index _",
    ", @xmath17 , and @xmath18 a _ base index _ associated with the queue .",
    "initially , all linear lists and the binary tree are empty and @xmath17 and @xmath18 are @xmath19 .",
    "here we describe how operations on the queue are implemented using the data structures described above .",
    "\\(i ) addition .",
    "events are added to either one of the linear lists or to the binary tree as follows : an index @xmath20 for the event to be added is determined by @xmath21 where : @xmath5 is the time associated with the event ; @xmath18 is the base index ; and @xmath22 is a _ scale factor _ the value of which is such the binary tree never contains more than a relatively small number of events ( @xmath23 ) .",
    "if @xmath20 is equal to the _ current index _ , @xmath17 , the event is added to the binary tree , otherwise it is added to linear list @xmath15 .",
    "\\(ii ) identification of the event with shortest time .",
    "the event with the shortest time is simply the root of the binary tree , as is the case with a normal priority queue implemented using a binary tree .",
    "if a request is made for the event with the smallest time and the binary tree is empty , the current index is incremented by one ( wrapping around to @xmath24 if we reach the end of the array ) and all events in the linear list @xmath25are inserted in the binary tree .",
    "if there are none , we continue to increment @xmath17 until a non - empty linear list is found .",
    "if we wrap around to the beginning of the list , @xmath18 is incremented by @xmath14 .",
    "we find that in practice , when the binary tree becomes empty the next linear list is always non - empty ( see section [ choose ] in which we show the distribution of event times ) .",
    "\\(iii ) deletion of an event .",
    "we simply delete the event from the array of linear lists or from the binary tree depending on the structure in which it is located .",
    "the fact that the time associated with an event to be added to the queue is always greater than or equal to the time associated with the last event removed allows us to use the array of linear lists in a circular fashion .",
    "the requirement that there exists a constant , @xmath26 such that @xmath27 allows us to use a finite number of linear lists .",
    "the number of linear lists required is proportional to @xmath11 . in practice",
    "we find that we can always find a reasonable value of @xmath11 such that eq .",
    "( [ tmax ] )   holds . if a rare event occurs which violates this constraint or we want to use less memory for linear lists causing the constraint to be violated , the event is handled on an exception basis as implemented in the _ processoverflowlist _ function in code contained in the appendix",
    "alternatively , the application which calls the priority queue code can guarantee that such an event never occurs by creating an earlier fictitious collision with a time which does not violate the constraint .    thus all of the events , except for those deleted before they are placed in the binary tree , will eventually be added to the binary tree , but at any given time the tree , instead of containing o(@xmath0 ) entries , will contain only a relatively small number of entries .",
    "the number of events maintained in the binary tree is only a fraction of the total number of particles @xmath0 in the system and can be made independent of @xmath0 .",
    "our priority queue is similar to a _",
    "calendar queue _",
    "@xcite ; however , the calender queue does not employ a binary tree ",
    "events are sorted in each of the linear lists .",
    "two parameters , @xmath14 the number of linear lists and @xmath22 the scale factor , must be chosen to specify the implementation of the queue .",
    "operationally , they can be chosen as follows :    \\(i ) first , by instrumenting the queue to count the number of events in the binary tree , determine a value of @xmath22 such that the number of events in the binary tree is relatively small ( @xmath23 ) .",
    "table i. and fig .",
    "[ mem](a ) summarize the values of @xmath22 we have used for our simulations .",
    "the figure is consistent with a scale factor linear in @xmath0 with a different coefficient of linearity dependent on density . because we use a binary tree to store events with the soonest times , the performance of the algorithm is somewhat insensitive to the choice of @xmath22 .",
    "for example , a choice of @xmath22 which results in a doubling of the number of events in the binary tree results in only one additional level in the tree .",
    "\\(ii ) instrument the queue to find @xmath11 , the maximum difference between the time associated with an event to be added and the time associated with the last event removed and set @xmath28 to ensure that ( eq .  [ tmax ] ) is met .",
    "table i. and fig .",
    "[ mem](b ) summarize the number of linear lists @xmath14 we have used for our simulations . as with @xmath22 , @xmath14 is linear in @xmath0 with a different coefficient of linearity dependent on density .",
    "we note that while memory requirements are @xmath2 as in the conventional implementation of priority queues , the hybrid implementation does require significantly more memory than the conventional implementation due to the memory required for the linear lists .",
    "tradefoffs can be made of cpu time for memory by increasing the scale factor and/or reducing the number of linear lists ( resulting in more exception conditions ) .",
    "figure    [ pdist](a ) plots @xmath29 the average number of events with index @xmath30 versus @xmath30 for various @xmath0 . here",
    "@xmath31 that is , @xmath30 is the distance of @xmath20 from the current index taking into account the circular nature of the array of linear lists .",
    "the data was obtained by sampling the queue many times at regular intervals . with the choice of scale factors shown in table i",
    "we achieve our goal of having @xmath23 events with index @xmath32 and thus in the binary tree .",
    "note that to achieve this , the scale factor increases with increasing @xmath0 resulting in the cutoff of the distributions also increasing with increasing @xmath0 .",
    "( in fact , if the @xmath33-axis is transformed by @xmath34 , the plots collapse as shown in fig .",
    "[ pdist](b ) reflecting the fact that the probability distribution of collision times is independent of @xmath0 . )",
    "thus , the number of linear lists required to ensure that eq .",
    "( [ tmax ] ) holds also increases with @xmath0 . in fig .",
    "[ pbucket0 ] , we plot the distribution @xmath35 the probability that the number of events with the current index , @xmath17 is @xmath36 versus @xmath36 .",
    "the distributions are strongly peaked indicating that the number of events in the binary tree do not vary much from the average .",
    "the basic operations involved in the queue are :    \\(i ) insertion into and deletion from the linear lists .",
    "use of doubly linked lists allows these operations to be implemented to take o(1 ) time .",
    "\\(ii ) binary tree operations .",
    "we use the code of ref .",
    "@xcite to implement the binary tree operations .",
    "when a leaf representing an item in the priority queue is added to or deleted from the tree , the tree must be traversed from the affected leaf possibly all the way to the root node and adjustments made to reflect the presence or absence of the affected leaf .",
    "thus a bound on the number of levels which must be traversed is @xmath37 where @xmath38 is the number of items in the priority queue . in sec .",
    "[ choose ] we show that by choosing the scale factor @xmath22 appropriately , @xmath38 can be made to be independent of @xmath0 ( and have a relatively small value , @xmath23 ) .",
    "thus binary tree operations will be o(1 ) .",
    "\\(iii ) identification of the next non - empty linear list , after the current linear list is exhausted . as explained in item ( ii ) of sec .",
    "[ queueoperation ] , when the binary tree is empty , we search forward through the array of linear lists until a non - empty list is found . if the number of lists we must search through increases with @xmath0 , this process will not be o(1 ) .",
    "we show below that with the proper choice of @xmath22 , the number of lists we must search does not grow with @xmath0 and in fact show that the next linear list after the current one almost always is non - empty .",
    "thus the complexity of identification of the next non - empty list will be o(1 ) .",
    "thus the overall time taken by queue operations per collision is o(1 ) .",
    "we run simulations using both a conventional priority queue and our new hybrid approach . for simplicity",
    "the simulation was of identical size hard spheres of radius one and unit mass .",
    "the sizes @xmath39 of the cubic systems are set to maintain equal densities .",
    "the parameters of the simulation are as shown in table i.    to demonstrate the performance of our approach , we run simulations for cubic systems at four volume densities @xmath40 and @xmath41 . the first density represents a rarefied gas and the last density represents a jammed system .",
    "the jamming density for hard sphere systems is @xmath42 @xcite .",
    "for both the conventional priority queue and the hybrid queue we used the binary tree code from ref .",
    "@xcite .",
    "figure [ pcbt ] shows the time taken for @xmath43 collisions for queue operations with both a conventional priority queue and the hybrid queue .",
    "as expected , the time for the conventional priority queue increases as @xmath1 while the time for the hybrid queue is essentially constant",
    ".    there is , however , a slight upward trend in the hybrid queue results . to determine if this trend is a feature of the algorithm or of the the benchmark environment , we proceed as follows .",
    "we first study the only two places in the hybrid code where looping is involved :    \\(i ) in the _ updatecbt _ function of ref .",
    "@xcite we loop as we traverse the binary tree .",
    "if we traverse more levels as the n grows , the algorithm will not be o(1 ) . to explore this possibility , we instrument the function to count the number of number of levels we traverse in the tree . the results are shown in fig .",
    "the number of loop iterations is essentially constant , independent of @xmath0 .",
    "\\(ii ) in the _ deletefirstfromeventq _ function , after the priority queue for the current linear list is exhausted , we loop until we find a non - empty list .",
    "if the number of lists we must examine before we find the first non - empty list grows with the system size , the algorithm will not be o(1 ) .",
    "we examine this possibility by counting the number of times we encounter an empty list and find that on average the probability of encountering an empty list does not grow with @xmath0 and that the probability of encountering an empty list is very small : we encounter an empty list only @xmath44 of the times after exhausting the priority queue .",
    "having ruled out dependence of the number of loop iterations on @xmath0 as the source of the upward trend in the execution times , we now consider whether the larger memory needed as @xmath0 increases is the cause of the trend .",
    "all modern computer processors employ high speed cpu cache memory to reduce the average time to access memory @xcite .",
    "in fact , the processor we use in our simulations , the amd opteron , employs a two - level memory cache ( 64 kb level 1 cache , 1 mb level 2 cache ) @xcite .",
    "a similar cache structure is used in the intel xeon processor @xcite . because memory caches are finite size , if the memory access is random the larger the memory used by a program , the lower the probability that data will be found in the cache resulting in slower instruction execution .",
    "the effect of cache in benchmark runtimes has been studied in ref .",
    "we study the effect of the finite size of the cache in our system as follows : instead of running the molecular dynamics simulations , we run a small test program which randomly accesses the data structures used by the molecular dynamics simulations . for each value of @xmath0",
    ", the test program executes exactly the same number of instructions but uses data structures of the size used by the molecular dynamics simulations for that value of @xmath0 . the results are shown in fig .",
    "[ pcbt ] and show an upward trend similar to that of the simulation results for all of the densities studied .",
    "the above results thus suggest that the complexity of the hybrid algorithm is , in fact , o(1 ) and that the upward trend in the results is due to the finite size of the high speed memory cache .",
    "we have defined a new abstract data type , the bounded increasing priority queue ( bipq ) having the same operations as a conventional priority queue but which takes advantage of the fact that the value associated with an item to be added to the queue has the properties that : ( i ) the value is greater than or equal to the value associated with the last item removed from the top of the queue and ( ii ) the value minus the value of the last item removed from the top of the queue is bounded .",
    "these properties are obeyed for events in event driven molecular dynamic simulations .",
    "we implement a bipq using a hybrid approach incorporating a conventional priority queue ( implemented with a binary tree ) and a bounded priority queue .",
    "all operations on the bipq take an average o(1 ) time per collision .",
    "this type of queue should provide performance speedups for molecular dynamics simulations in which the event queue is the bottleneck .",
    "we thank sergey buldyrev , pradeep kumar , sameet sreenivasan , and brigita urbanc for helpful discussions .",
    "we onr , nsf and nih for support .",
    "the following code implements the hybrid queue proposed here .",
    "the calls to insert and delete are to the functions contained in ref .",
    "@xcite , which update np and the complete binary tree , cbt .",
    "any code providing the same functions could be substituted for insert and delete .",
    "i=(int)(scale*pt->t - baseindex ) ;    if(i>(nlists-1 ) )      / * account for wrap * /               {      i-=nlists ;      if(i>=currentindex-1 )      {              i = nlists ; / * store in overflow list * /      }    }    pt->qindex = i ;            processoverflowlist ( ) {    int i , e , enext ;    i = nlists ;   / * overflow list * /    e = linearlists[i ] ;    linearlists[i]=-1 ;   / * mark empty ; we will       treat all entries and may re - add some * /    while(e!=-1 )    {      enext = eventqentries[e].next ; / * save next",
    "* /      insertineventq(e ) ;   / * try add to regular list now * /      e = enext ;    } }                                                      j. j. erpenbeck and w. w. wood , in statistical mechanics b : modern theoretical chemistry , b.j.berne ( ed . ) , molecular dynamics techniques for hard core systems , vol.6 , institute of physics publishing , london , ( 1977 ) 1 - 40 .",
    "j. francon , g. viennot , and j. vuillemin , description and analysis of an efficient priority queue representation . in proceeding of the 19th annual symposium on foundations of computer science .",
    "ieee ( 1978 ) 1 - 7 ."
  ],
  "abstract_text": [
    "<S> we propose and implement a priority queue suitable for use in event driven molecular dynamics simulations . </S>",
    "<S> all operations on the queue take on average o(1 ) time per collision . in comparison , </S>",
    "<S> previously studied queues for event driven molecular dynamics simulations require o(log @xmath0 ) time per collision for systems of @xmath0 particles . </S>"
  ]
}