{
  "article_text": [
    "in the last decades computer science has undergone a spectacular development that has left its marks on most aspects of our everyday life while truly revolutionizing a number of domain specific human activities .",
    "however , brute computing force growing at exponential rate was not the answer to the problem of complexity as signaled already in the late sixties when the term  software crisis \" got coined @xcite .",
    "thanks to a dynamic it market marked by fierce competition , software development has been constantly maturing ever since .",
    "unfortunately , computational science remained immune to all those environmental factors that drive the development of the software industry . even though it has always made much better use of the improving hardware capabilities by squeezing every last drop of performance out of the available computing resources , in terms of efficiency and software quality it has fallen much behind modern trends .",
    "recently , almost forty years later , scientists realized too the obstacles standing in the way of large scale scientific software projects @xcite .",
    "the two papers send a clear message to the computational science community : _ a change of paradigm is necessary ! _ in @xcite and @xcite this message is reinforced in the context of small and medium size projects that make up the bulk of the activity in the community .",
    "it is pointed out that there is an acute need for shifting towards a reuse oriented paradigm which would improve dramatically the efficiency and quality of computational research .",
    "component software @xcite is a relatively recent buzzword in the software industry many viewing it as the holy grail of software reuse .",
    "these ideas found a fertile soil in computational science thanks to grid computing that enjoys high priority on the research agenda of most developed regions such as eu , north - america and japan .",
    "grid computing , even though still very much in its infancy , has been preparing the path for component software for some years .",
    "driven by the challenges of grid computing the fundamental ideas from component software have quickly been taken up by a few groups and a recommendation for a common component architecture ( cca ) emerged @xcite@xcite .",
    "the dominance of this approach is secured by the common component architecture forum , an organization backed by several us based universities @xcite . at the core of cca stands a language interoperability tool , called babel , and the scientific interface definition language ( sidl)@xcite . starting from a manually written sidl file babel can generate stub and skeleton source code for a number of programming languages commonly used in scientific computing .",
    "the programmer can include the implementation part and after compilation the functions can seamlessly communicate across the boundaries of programming languages .",
    "several toy and production frameworks have been developed based on babel @xcite@xcite@xcite .",
    "they provide a visual programming environment for assembling components into computational projects .",
    "there is no doubt that this approach can be viable on the long run yet presently it is not much more than an intellectual experiment as the amount of training for a developer trying to produce a cca compliant component represents a threshold that are too high for most to consider the solution . the developer is required to learn sidl and the constituting object - oriented programming concepts .",
    "existing numeric libraries can not be turned into a component without carrying out changes in the function signatures . beside the involved extra work ,",
    "another reason why many would not take this step is because , as long as cca is not an established standard ,  spoiling \" the code s compliance with previous prescriptions would not pay off . especially not for a natural scientists or engineers who want the  most bang for the buck \" in their own research and do not share the excitement of computer scientists over using a well designed but fresh standard that apparently makes life only more difficult for quite a few years to come .",
    "no wonder that the associated public component repository , alexandria , is still empty several years after project launch .",
    "another notable solution is the iris explorer of the numerical algorithms group ( nag)@xcite .",
    "apart from the wide - spread flow - based visual programming environment on the user side , on the component development side the author is assisted by a module builder application that , after collecting sufficient information on the input and output ports via self - explanatory gui forms , it wraps and builds the code into an iris module . however , documenting the code in terms of its interface is completely manual and avoiding mismatches between the source and its description is the responsibility of the author . using custom datatypes constitutes another challenge for the developer .",
    "the two main reasons , though , why the nag solution fails to have the impact we envision for the future computational framework is that , on the one hand it is limited to mathematical problems and data visualization , on the other it is a commercial product . as a result , in spite of the iris explorer centre of excellence initiative @xcite",
    "the public repository has not received new modules since 2002 .",
    "nevertheless , since the nag solution is endowed with a multitude of deasirable features , we consider that its user base should have an important word to say in conceiving the new high impact solution .",
    "determined to avoid the aforementioned pitfalls the comodi initiative is meant to be a pragmatic approach with well - defined objectives formulated in view of the ultimate goal of moving computational science out of its nadir and giving it a hand in starting on the road towards modern programming practices while harvesting along the way all the efficiency and quality benefits of a new reuse oriented paradigm .",
    "comodi emerges from a set of premises that are not exclusively its own .",
    "even though not always explicitly formulated by the authors of other solutions yet stand at the basis of these approaches . the following premises are the distilled conclusions of a preliminary survey made with a mixed group of computational scientists on the occasions of conferences , workshops and via an online form on the comodi website @xcite :    1 .   computational science is not computer science : the roots of computational science are in natural sciences and engineering not in computer science ; 2 .",
    "computational science demands a new paradigm . the efficiency and quality of the scientific software development process and the reproducibility of virtual computer ",
    "experiments \" need major improvements .",
    "3 .   computational science will not take up any new technologies in the short run unless simpler than those that are in use today ; 4 .",
    "the community itself should decide on the new paradigm .",
    "a restricted group of promoters can only set the process off and catalyze it ; 5 .",
    "a few , relatively homogeneous groups make up the bulk of the community .",
    "the new solution should target these groups instead of trying to be fully comprehensive .",
    "out of the above five points the last three are comodi specific but the extra emphasis on point 3 is the one that makes comodi essentially different from the rest .",
    "this latter postulate translates into a fundamental requirement that we can term as _  zero effort threshold\"_. we can make it more specific by formulating a series of commandments that will guide the design process . a clear distinction needs to be made between what comodi means to end - users on the one hand , and to component developers or authors on the other .",
    "the former group is primarily involved in assembling components into projects and executing them while component authors design and implement new components .",
    "since the two activities require different skills and work methods the requirements set for the employed tools in each case also differ . for user satisfaction",
    "the solution has to be endowed with the following features :    * user friendly graphical interface ; * intuitive representation of data and processes such that the elements of low - level programming , c and fortran programmers are accustomed to , can be clearly identified ; * high - level flow - based visual programming environment ; * possibility for low - level control ; * platform independence of the framework and of the components ; * comprehensive component repository ; * free !    in order to fully support developers it is imperative that no compliance criteria are set for the computational code neither in terms of structure nor used data types .",
    "in other words , any valid code written in the supported programming languages should automatically be ready for comodi .",
    "therefore the following restrictions apply to adapting regular code to comodi :    * no change in the source code .",
    "neither in the interface nor in the implementation ; * no extra coding . connectivity is achieved by supplementing author provided source - code with automatically generated glue - code ; * no need for the author to know other languages / standards then the ones used for implementing the code ; * no platform dependence .",
    "the capabilities of the system the development is carried out on is extended by on - line servers providing compilation as web service ; * no language dependence .",
    "c / c++ , fortran , java , python and other present and future languages should be able to communicate seamlessly ; * low performance overhead ; * support for both open source and commercial components .    for closely matching the low - level approach of computational scientist s to programming , components need to be the lowest possible granularity units of code , namely functions and procedures . in @xcite and",
    "@xcite they are also referred to as _ logical components _ so that they could be clearly distinguished from higher granularity _ physical components _ or _ packages _ that are units of deployment .",
    "a physical component can contain a large number of logical components that are packed together and then uploaded as one file into the repository .",
    "clearly , the above commandments are easier to state than to comply with .",
    "communicating data across , language and platform boundaries represents a serious technical challenge .",
    "the tip of the iceberg includes the following issues :    * language dependence : e.g. pascal uses the call stack differently ; * architecture dependence : file systems , little endian vs big endian ; * compiler dependence : the same data type may be represented differently .",
    "e.g. 16 bits vs 32 bits ; * exporting type definitions .    for bridging over languages",
    "there are several solutions at hand such as translating all types of source code into a single language , e.g. c , or compile them to an intermediate language similar to java bytecodes or the microsoft il for .net .",
    "alternatively , following the design of iris explorer one can provide an api for the different languages or create stub and skeleton code based on some interface description as done with babel for the common component architecture ( cca ) .",
    "however , none of the above can fully live up to the expectations formulated in the commandments from the previous section as they either require extra care from the developer or interfere with his / her source code or induce a significant performance overhead .",
    "we suggest that the responsibility of all wiring related issues should be assumed by generated glue - code .",
    "similarly to iris and unlike babel , interface glue - code is generated after the implementation which apparently is not a healthy programming practice as this would prescribe defining all interfaces first and then stuffing the implementation into the code .",
    "however , babel glue - code is generated from an sidl file written manually by the developer .",
    "this means a new language to be mastered which would make comodi much less appealing . besides , the target segment of comodi are scientists that already have programmed for a few years and ready to try comodi in view of the zero effort threshold .",
    "these either already have their implementation ready or will develop it using their own familiar programming environment .",
    "iris does a better job in this respect but falls short of effectively minimizing the effort of the developer and when it comes to user defined datatypes the developer bumpes into apis and an involved type definition procedure .",
    "thus , the problem of interoperability in itself is not impossible to circumvent .",
    "the question remains though  at what cost ? by ",
    "cost \" we mean the compromises that need to be made when there are no available alternatives for simultaneously respecting all of the above formulated general requirements to their full extent .",
    "our small prototypes arm us with confidence but complete certainty is conditioned by a solution that has been tested against a wide range of different computational tasks .",
    "merging the reuse oriented paradigm with that of distributed computing represents a double effort threshold for the community , on the user and developer side alike .",
    "both areas are in an experimental stage .",
    "therefore we recommend that comodi should focus on providing a viable solution for the problems it is targeting , namely efficiency and quality of scientific software development , without getting involved in the problem of efficient computing and storage resource sharing .",
    "nevertheless , all design decisions should be taken in view of the requirements for adapting the framework to the grid in the near future .",
    "the complete solution is made up of the following major elements :    * high - level visual programming environment for computational projects ; * standardized scientific component descriptor language ( cdl ) ; * component developer tools for adapting regular code to the framework ; * distributed component repository ; * compilation web service .    as it has already been suggested in the previous section , depending on the programming activities the above software elements support they can be divided into two fundamental groups : the _ user side _ and the _ developer side_. on figure [ f : architecture ] we can see the sketch of the comodi architecture .",
    "the responsibilities of each part are summarized in table [ t : roles ] .",
    ".responsibilities of the two major parts of comodi [ cols=\"<,<\",options=\"header \" , ]     the developer layer contains a user friendly _ graphical user interface _ ( gui ) , a _ component developer tool _ ( cdt ) with a _",
    "parser_. the cdt , after semi - automatically collecting information pertaining to the content , behavior , and representation of the component , generates a _ component descriptor file _",
    "( cdf ) in the xml based _ component desciptor language _ ( cdl ) and the source of the _ glue - code _ that will intermediate the communication of the component within the comodi framework . at this stage",
    "the cdf will contain all communication related information such as exported functions and data types .",
    "it describes both syntactically and semantically the component , supports the programming style of computational scientists as far as data structures , and it is extensible .",
    "its complexity is expected to grow together with the user community and the number of application areas . by semi - automatical",
    "we mean that the _ parser _ , which stands at the basis of the tool , inspects the source file and generates a primary cdf .",
    "using the gui , the developer only has to confirm the exported ports , provide human readable documentation for the component , set default values and add representation related information .",
    "the cdt then contacts on - line _ compilation servers _ and returns ready - made binaries for the platforms of the developer s choice .",
    "the compiled library together with the descriptor file is uploaded by the developer to a place where it can be accessed publicly while the cdt registers the component in the _ component repository_.        the deployed component is a package containing the component s source code - if the developer chooses to make the source open - the component descriptor file , the binaries for both the computational- and the generated glue - code , and further resources .",
    "components are packed into standard zip or tar.gz format and registered in the _ remote component repository_. upon use within the comodi framework , the component is downloaded and stored in the _ local component repository_.    the sources provided by the component developer suffer no changes whatsoever during the component creation process .",
    "all glue - code comes as additional functions in a separate file .",
    "not touching the source of the developer has the benefit of the compiled component being usable both within and outside the comodi framework making comodi components fully compatible with traditional programming environments .    in order to make comodi itself easily extensible it has to be component - based .",
    "this requires the separation of the framework into a _ kernel layer _ and several other modules built on the top of it .",
    "it is possible to enforce a very general view on this component architecture and deal uniformly with computational components and components that are intimately related to the framework itself . in this approach ,",
    "anything apart from the kernel is a component , be it a simple numerical component or a heavyweight gui .",
    "however , this uniformity , while simplifying the integration of components vital to the proper functioning of comodi , will come dear as it compromises the postulated simplicity of wiring computational components by users .",
    "therefore it is sensible not to sacrifice the support of user and component developer activities in favor of those related to the development of comodi @xcite .",
    "in the previous section we pointed out that `` clever '' glue - code is the key to following the comodi commandments .",
    "it can come in two flavors depending on whether it mediates an incoming function call through a provides port or an outgoing call via a uses port .",
    "we shall prepend the term glue - code with the words `` uses '' or `` provides '' whenever this aspect will be of relevance .",
    "connectors represent a similar concept intimately related to component software .",
    "there is no fundamental difference between connectors and glue - code .",
    "both are meant to bridge over incompatibilities that are not essential from the point of view of the composed client - server system .",
    "as such they can be handled automatically or semi - automatically .",
    "the most important difference between the two consists in the fact that glue - code is generated while connectors , as components in general , are hand - made .",
    "glue - code is tightly associated with a component within the boundaries of the same physical component ( deployed unit ) .",
    "glue - code is a kind of integrated connector that can communicate with anybody at one end but it only connects to a well - defined component located in the same physical component .",
    "glue - code is included into the component instead being part of the framework for a number of reasons :    * there are functionalities that can only be set statically , depending on the content of the source code ; * it can be better optimized for performance : in order to satisfy the requirement of low overhead it is necessary that the framework does not intermediate the communication between components .",
    "instead , it will wire up the connections by setting direct component - to - component references @xcite ; * freedom of the component author to further optimize it ; * keeps the framework platform independent ; * in view of the approaching era of grid computing the autonomy of components should be increased .",
    "the obvious disadvantage of this solution is the components increased size .",
    "however , this increase is not expected to be a relevant problem .",
    "since glue - code takes over all the burden of making regular code connectible it has several responsibilities :    * _ call stack management : _ bridge the difference in handling the call stack in various languages * _ parameter passing management : _ when the two involved languages ca nt automatically do it by themselves . for example , when calling fortran from c , parameters can only be passed by reference . * _ linking : _ by linking we mean the process of setting all call references between components .",
    "these references are set according to parameter strings extracted from an xml encoded file containing the description of the assembled computational application .",
    "they are stored in static variables of glue - code segments and are passed to the computational code during runtime ( see figure [ f : linking ] ) .",
    "the runtime entry point is called once also during link - time and the children references are requested from the glue - code function in charge with wiring . as a result , the wiring function can be completely avoided during runtime .",
    "the actual computational code , referred to as  business logic \" in figure [ f : linking ] , will be in the body of a function that receives all necessary information , including the child references , as parameters .",
    "this has the additional benefit of self - containment .",
    "the function is also fully functional outside the context of the framework without confusing extra arguments .",
    "a more detailed discussion on the wiring mechanism can be found in @xcite .",
    "+    * _ handling data and code aggregates : _ translates between data structures of different granularity .",
    "for example , structures records and objects can be decomposed into a set of variables and vice versa .",
    "this is especially important when binding c++ code to c. * _ managing default values and references : _ the author of a component is encouraged to provide default values for the parameters of both uses and provide ports .",
    "there are at least two benefits to this feature .",
    "for once , users can gradually explore the capabilities of a component by using a reduced set of parameters at each port .",
    "secondly , default parameters endow a given port with the flexibility of connecting to ports that require a different number of parameters . * _ managing global naming conventions : _ since the components are autonomous , authors must respect only the rules of the programming language in which the component is developed .",
    "problems may arise with the identifiers ( names of functions , procedures , types , variables , constants , parameters )  if two or more authors give the same name to two or more entities .",
    "the glue - code generator translates the identifiers between local and global naming conventions . * _ managing remote calls : _ it realizes a _ stub - skeleton _ architecture for local and remote component calls .",
    "the details implementing connectors in comodi is a topic on its own right and it is beyond the scope of this paper",
    ". the reader can refer to chapter 10 . in @xcite and @xcite .",
    "one of the particularities of the comodi solution is that the process of converting the source code into a component is automated to the maximum possible extent .",
    "therefore the component developer tool must `` gain insight '' into the the source code with the help of the parser .",
    "the aim of the _ parser _ is to extract the necessary information from the programs source code in order to elaborate a full documentation of the component .",
    "the output of the parser is an xml document that is piped into the glue code generator and also serves as raw material for the content of the component descriptor file .",
    "the parser analyzes lexically and syntactically the source of the developers computational code .",
    "the semantic analysis is outside the scope of the parser .",
    "the used information is :    * identifiers * types * variables * constants * functions * procedures * parameters * comments for the documentation * special directives    the architecture of the comodi parser consists of two blocks : _ the programming language description and recognition part _ ( ebnf parser ) and _ the program recognition part _ , which carries out the lexical and the syntactical analysis based on a self - constructive automata - system ( fig .",
    "[ f : parser ] ) .",
    "the description of the programming languages is given in ebnf format ( standard : iso / iec 14977 ) .",
    "the _ ebnf parser _ reads the ebnf description of the programming language ( fortran , c , c++ , pascal , java , etc . ) , and builds an automata - system , responsible for the lexical and the syntactical analysis of the source code .",
    "the automata - system contains a set of modified push - down automata , interconnected into a network , each automaton each possessing an inner stack .",
    "this system is equivalent to a single non - deterministic push - down automaton , capable of recognizing context - free languages .",
    "the lexical elements and the syntax of the majority of the used imperative programming languages , and also their recognition rules , can be defined with context - free grammars .",
    "so , our automata - system can recognize the majority of imperative programming language , once their ebnf definitions are available .",
    "the automata - system receives as input the program source code ",
    "each token is an element of the alphabet",
    " starts from an initial state , and after reading the symbol next in the line , it changes the inner - state according to the transitional function . during this transition",
    "it modifies the stack . after reading all the input symbols ,",
    "if the automata - system is in one of the final states , and the stack is empty , the automata - system recognizes the input source code and builds correctly the tables . in all other cases it fails .",
    "our prototype show that the above algorithm seems to work well for languages such as c or fortran .",
    "we have presented the general requirements and a few design guidelines for a complete reuse oriented solution for computational scientists .",
    "the lack of impact of present solutions is blamed on the involved high effort threshold , in many cases made worse by a closed source and restrictive copyrights .",
    "therefore , the corner stone of comodi is the zero effort threshold requirement for component developers .",
    "we argue that the community needs a solution that allows a smooth , effortless transition to the new paradigm . once there",
    ", high - tech solutions will automatically be accepted by the community .",
    "we also claim that a change of paradigm requires a solution that is widely used and supported , situation that is only conceivable within an opensource project .",
    "comodi should be a joint effort of computer scientists assuring the quality of the code and computational scientists collectively and actively contributing to refining the requirements .",
    "if the contribution of either of the two sides gets out of balance comodi ends up as just another interesting case study in computer science or , conversely , becomes an unreliable pile of code impossible to maintain .",
    "our prototypes indicate that the suggested architecture is feasible .",
    "thus , the main challenge is not of technical nature but rather consists in sparking the interest of the community in developing and using comodi .",
    "this work is supported by the national university research council of romania with grant no .",
    ".    11 _ comodi homepage , _",
    "p. naur and b. randell , _ software engineering : report on 1968 nato conference , _ nato , 1969 d. post , _ the coming crisis in computational science _ , proceedings of the ieee international conference on high performance computer architecture : workshop on productivity and performance in high - end computing , madrid , spain , february 14",
    ", 2004 d.e . post and l.g .",
    "votta , _ computational science demands a new paradigm , _ phys . today , january 2005 , p.35    zs.i .",
    "lzr , b. prv , j.r .",
    "heringa , s.w .",
    "de leeuw , _ comodi : guidelines for a component based framework for scientific computing , _ studia babe - bolyai , series informatica , vol .",
    "xlix , no . 2 ( 2004 ) 91 zs.i .",
    "lzr , j.r .",
    "heringa , b. prv , and s.w .",
    "de leeuw , _ comodi : component based programming in scientific computing : a practical approach , _ submitted to computers in science & engineering c. szyperski , d. gruntz and s. murer , _ component software ; beyond object oriented programming _ , 2nd edition , addison - wesley ( 2002 ) r. armstrong , dennis gannon , a. geist , k. keahey , s. kohn , l. mcinnes , s. parker and , b. smolinski , _ toward a common component architecture for high - performance scientific computing _ , proceedings of the 8th ieee international symposium on high - performance scientific distributed computing , august ( 1999 ) r. bramley , k. chiu , s. diwan and d. gannon , _ a component based services architecture for building distributed applications _ , ninth ieee international symposium on high performance distributed computing , august 01 - 04 , 2000 ( http://www.extreme.indiana.edu/ccat/papers/hpdc2000.pdf ) _ common component architecture ( cca ) forum homepage , _ http://www.cca-forum.org _ babel homepage , _ http://www.llnl.gov/casc/components/babel.html _ ccafe homepage , _ http://www.cca-forum.org/",
    "baallan / ccafe _ xcat homepage , _ http://www.extreme.indiana.edu/xcat _",
    "scirun homepage , _ http://www.sci.utah.edu _ numerical algorithms group homepage _ , http://www.nag.co.uk/ _ iris explorer centre of excellence homepage , _",
    "_ open data explorer homepage , _",
    "lzr , b. prv , _ comodi : component wiring in a framework for scientific computing _ , studia babe - bolyai , series informatica , vol .",
    "xlix , no . 2 ( 2004 ) 103 a. mayer , s. mcgough , m. gulamali , l. young , j. stanton , s. newhouse , j. darlington , _ meaning and behaviour in grid oriented components _ , proceedings of the third international workshop on grid computing , springer - verlag ( 2002 ) ( www.lesc.ic.ac.uk/iceni/pdf/grid2002.pdf )"
  ],
  "abstract_text": [
    "<S> the computational module integrator ( comodi ) @xcite is an initiative aiming at a component based framework , component developer tool and component repository for scientific computing . </S>",
    "<S> we identify the main ingredients to a solution that would be sufficiently appealing to scientists and engineers to consider alternatives to their deeply rooted programming traditions . </S>",
    "<S> the overall structure of the complete solution is sketched with special emphasis on the component developer tool standing at the basis of comodi . </S>"
  ]
}