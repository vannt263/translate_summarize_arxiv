{
  "article_text": [
    "molecular dynamics ( md ) simulation is one of the most important numerical methods in computational physics , chemistry , biology and materials science @xcite . it is a very versatile method that allows particle based simulations of a wide variety of systems provided that a suitable model for the interactions between the particles exists .",
    "advances of computer technology have dramatically increased the number of particles that can be handled by md simulations . when used in conjunction with a short - range interaction model , i.e.  a model where particle interactions become zero",
    "if the distance between the particles exceeds a cutoff distance @xmath0 , simulations containing tens or hundreds of millions of particles can be performed without too many difficulties .    in recent years",
    ", a strong increase of computational power has been achieved through the introduction of multicore processors that integrate multiple cpu cores on a single chip .",
    "currently the trend goes from multi - core to many - core systems which integrate hundreds or thousands of processors .",
    "an early example of this technology is the intel xeon phi coprocessor @xcite .",
    "such massively parallel systems both enable and require new approaches to the development of parallel programs .    in this article a task - based approach to the parallelization of md simulations",
    "is described .",
    "the _ cell task _ algorithm overcomes some limitations of previous approaches and gives excellent parallel performance in simulations of large - scale systems . in its current form the algorithm is designed for single node systems with approximately uniform memory access times .",
    "applicable systems range from dual and quad core desktop computers over typical hpc nodes or server systems ( 8 - 48 cores ) to the intel xeon phi ( 60 cores , 4 hardware threads per core ) .",
    "an extension of the algorithm into a hybrid scheme that uses message passing between nodes is straightforward .",
    "the algorithm is not designed for shared memory systems with strongly non - uniform memory access times ( so - called virtual shared memory machines ) or gpu computing .",
    "the implementation of md simulations on gpus has recently been discussed in ref .",
    "@xcite .",
    "the motivation for the development of a new md algorithm is twofold . on the one hand ,",
    "the cell task method is an attempt to explore new ways to adapt to the changes in computing technology and to get the most out of modern hardware . on the other hand ,",
    "the applications of the md method have changed over time .",
    "it is now possible to simulate complete nanodevices or nanostructured materials that combine different materials on length scales of several nanometers .",
    "as discussed below , the inhomogeneity of such systems reduces the efficiency of previous methods .",
    "the proposed algorithm has been designed specifically to provide an efficient parallelization for such systems .",
    "a necessary ingredient for large - scale md simulations is parallel computing .",
    "three principal strategies for the parallelization of md simulations are space ( or domain ) decomposition , particle decomposition , and force decomposition @xcite . on shared memory architectures",
    "one can also employ thread - based approaches using , for example , openmp @xcite .",
    "the particle decomposition method and the force decomposition method are both based on a static decomposition of the system s force matrix .",
    "particle decomposition assigns complete rows of the force matrix to a processor while force decomposition uses a block decomposition of this matrix .",
    "as discussed by plimpton  @xcite , both methods are not ideal for simulations of large systems with short - range forces due to communication overhead .",
    "in addition to this , the force decomposition method is subject to load balancing issues if the force matrix is not uniformly sparse .    in the spatial decomposition approach ( see , e.g. , ref .",
    "@xcite ) , the simulation cell is divided into as many domains as there are processors .",
    "each processor is then responsible for the calculations of forces on particles in one domain .",
    "when a particle crosses the border between two domains , it is reassigned to the processor of the new domain .",
    "spatial decomposition achieves very good parallel speedups under two conditions : the domains must be large enough so that most of the interactions happen between particles on the same processor , and the particle density system must be sufficiently homogeneous in order to achieve comparable computational loads on the processors .",
    "strongly inhomogeneous systems do not satisfy the latter condition , and the efficiency of spatial decomposition for these systems is therefore reduced by load imbalances .",
    "recently , a number of variations of the spatial decomposition approach have been developed @xcite .",
    "these neutral territory methods have the potential to outperform traditional spatial decomposition for high levels of parallelism .",
    "these methods are , however , not well suited to handle strongly inhomogeneous systems .",
    "while it is fairly straightforward to parallelize md programs using openmp , this approach rarely leads to satisfactory speedups .",
    "the reason for this are uncoordinated accesses to the particle data by the threads . in order to avoid race conditions particle updates",
    "must be protected by synchronization constructs or newton s third law can not be exploited .",
    "the performance is further degraded since accesses to the same particle by different threads may result in frequent transfers of cache lines between the cpu s .",
    "task - based programming is a modern approach to parallel computing .",
    "this technique uses high - level abstractions to subdivide the problem into small work units ( tasks ) without regard for details of the task execution on the hardware .",
    "these techniques are generally most efficient if the number of tasks that can be executed concurrently is much larger than the number of available processors .",
    "task - based programming and examples of task - based programming models are discussed in refs .",
    "@xcite .",
    "the cell task method described in this article uses a task - based programming model .",
    "the method subdivides the calculation of the forces in a large number of small tasks .",
    "these tasks are then executed according to a dependent task schedule that avoids access conflicts between the threads .",
    "for sufficiently large systems this leads to excellent parallel speedups that are largely independent of the degree of homogeneity of the simulated system .",
    "in addition to this , the algorithm relieves the user from technical considerations like the best subdivision of the system for a given number of processors .",
    "the primary objective of this work was the design of an efficient parallel md algorithm that achieves high parallel speedups for large and strongly inhomogeneous systems .",
    "secondary goals were consistent speedups for all numbers of processors and to make the method robust against external perturbations that might temporarily delay computations on individual processors .    the problems of spatial decomposition and simple thread - based approaches can both be traced to the kind of geometric information used by the methods . spatial decomposition fails to achieve a good load balance if the size of the processor domains exceeds the characteristic length scale of inhomogeneities in the system . in the simple thread - based approach on the other hand",
    "the efficiency is reduced by the need for synchronization which is ultimately due to the fact that no geometric information is used at all .",
    "these observations lead to the idea to use geometric information on a small length scale for the parallelization .    in order to avoid synchronization constructs during the calculation of forces on the particles",
    ", one must ensure that two threads will never update the same particle at the same time .",
    "this means that threads must keep a distance of @xmath1 between the particles on which they work .",
    "fortunately , the necessary information to ensure this condition is readily available in many cases or it can be obtained easily .",
    "most general purpose md codes use the so - called linked - cell technique @xcite to facilitate the construction of neighbor lists . in the linked - cell method , the simulation box is subdivided into a grid of small cells whose width is larger than @xmath0 and for each cell a linked list of the particles in the cell is constructed .",
    "a particle can then interact only with particles in the same cell or one of its neighbors .",
    "symbols in the respective grid cells.,width=272 ]    the proposed parallelization method reuses the data structures from the linked cell technique to partition the problem of the force calculation into tasks . a task in this method consists of the calculation of the forces on all particles in one grid cell . since particles in one cell",
    "do only interact with particles in neighboring cells , two tasks can be executed concurrently if there are at least two grid cells between them in all directions .",
    "tasks that fulfill this condition are called _ non - overlapping _ otherwise they are said to be _",
    "overlapping_. figure  [ figwave ] shows a two - dimensional example of a cell grid and a set of tasks that can be executed in parallel since they are non - overlapping .",
    "the essence of the proposed algorithm is the following :    1 .",
    "the particles are binned into grid cells ( as part of the linked cell technique ) .",
    "the force calculation is broken into cell tasks .",
    "a cell tasks consists of the calculation of forces on all particles in one grid cell .",
    "the tasks are executed in parallel by a thread pool according to a dependent schedule that ensures that only non - overlapping tasks are executed simultaneously .",
    "the algorithm does not assume that the execution of the tasks requires similar amounts of computing time .",
    "even in a homogeneous system this might not be the case and in inhomogeneous systems a substantial amount of grid cells might in fact be empty .",
    "notwithstanding , a good load balance is achieved if the tasks are dynamically scheduled rather then statically .",
    "dynamic scheduling assigns the tasks to the threads as these finish previous tasks .",
    "this keeps all threads busy and averages the imbalances .",
    "in addition to this , dynamic scheduling limits the impact of external disturbances such as unrelated processes running on one of the cores or differences in memory access times .",
    "if a processor is slowed down by external factors , other processors will take on a larger number of tasks , thereby minimizing the delay .",
    "with static scheduling a delay of one processor leaves the rest of the system idling .",
    "another positive side effect of the cell task algorithm is an improved memory access pattern .",
    "particles in the same grid cell have similar sets of neighbors .",
    "the calculation of the forces on particles in the same cell within the same task therefore leads to high cache reuse without a special ordering of the particles .",
    "after the force calculation , the second most time - consuming part of an md simulation is usually the generation of the neighbor lists . in a program that uses the linked cell method",
    "the neighbor lists are naturally generated for all particles in a grid cell at once .",
    "for this reason it is straightforward to apply the cell task method to the generation of the neighbor lists .",
    "the only difference to the force calculation is the kind of work performed by a cell task . during the neighbor list construction",
    "a cell task constructs the neighbor lists of all particles in the task s cell .",
    "an important difference between the force calculation and the generation of neighbor lists is the fact that the neighbor list generation never performs simultaneous particle updates .",
    "for this reason , the tasks generating the neighbor lists could all be scheduled simultaneously . on the other hand ,",
    "the overhead of the dependent schedule is very low as long as the system is large enough to keep all processors busy .",
    "this is since most of the overhead is incurred during the construction of the schedule , which is done only when the cell grid changes .",
    "while there are no simultaneous particle updates , simultaneous updates of the neighbor list data structure can be a problem .",
    "one way to solve this is that each task maintains a separate data structure for the neighbor lists of its particles .",
    "other typical parts of md simulations like the integration of the equation of motion are usually implemented with simple loops over the particles that access only one particle at a time .",
    "these loops can be parallelized using simple threading techniques since there are no synchronization concerns .",
    "a central problem of the proposed algorithm is the generation and execution of a dependent task schedule that guarantees that only non - overlapping tasks run concurrently .",
    "this section presents two algorithms for this problem named the _ forward _ and the _ backward wave method_.    the wave methods group the cell tasks into an ordered set of so - called _",
    "waves_. a wave is a set of non - overlapping tasks that can be scheduled independently .",
    "there are many ways to generate a set of waves that will cover all cells . in order to keep the method efficient",
    ", each wave should include as many cells as possible , and the number of dependencies between tasks should be low . the algorithm used in this work",
    "is described in the appendix .",
    "the grouping of the tasks into waves establishes a partial ordering of the tasks .",
    "a simple scheduling method is to allow tasks in the same wave to run concurrently but to require that a wave must be completely finished before the next wave can start .",
    "the problem of this algorithm is that it imposes a barrier after each wave which reduces its efficiency .",
    "note , however , that this scheme can easily be implemented in an environment that does not allow for dependent task scheduling .",
    "the wave methods use the ordering imposed by the waves to order the access to the grid cells by the tasks .",
    "each grid cell is accessed by at most 27 tasks ( less for cells at the simulation box boundary ) .",
    "the wave methods allow a task @xmath2 to execute as soon as all tasks from previous waves that access one of @xmath2 s cells are completed .",
    "a further simplification is possible since the preceding tasks depend on each other . for each of its cells",
    "@xmath2 only has to wait for the last task that accesses this cell before @xmath2 ( since the last task has already waited for all previous tasks accessing this cell ) .",
    "the set of last tasks accessing any of @xmath2 s grid cells are called the direct predecessors of @xmath2 .",
    "similarly the direct successors of @xmath2 are those tasks which have @xmath2 as a direct predecessor .",
    "the scheduling algorithm of both wave methods uses an acyclic graph algorithm similar to the one described in the documentation of intel s threading building blocks library @xcite .",
    "each task has a data structure that stores its grid cell , the number of its direct predecessors , a list of its direct successors and a reference counter .",
    "the reference counter is initially set to the number of direct predecessors and all tasks that have no direct predecessors are added to the thread pools list of tasks that are ready for execution .",
    "the execution of a a task involves the following steps :    1 .",
    "the work associated with the task is carried out ( force calculation , neighbor list generation , etc . )",
    "the reference counter of all direct successors is decremented atomically .",
    "3 .   successor tasks whose reference counter becomes zero are added to the ready list .",
    "the purpose of the wave algorithms is to generate for each task its number of direct predecessors and the list of its successors .",
    "the forward wave method maintains a three - dimensional array @xmath3[ny][nz]$ ] that stores for each grid cell the index of the last task that has accessed the cell .",
    "initially this array is initialized with a special marker ( -1 ) that indicates that the cell has not been accessed .",
    "the algorithm loops over the waves in ascending order starting with the first wave . for each task in a wave",
    "the following steps are performed :    1 .",
    "for all cells accessed by the task , copy the corresponding element of @xmath4 into a list .",
    "2 .   eliminate duplicates and the special marker from the list .",
    "the result is the task s set of direct predecessors .",
    "3 .   store the number of predecessors in the task structure .",
    "4 .   for each direct predecessor , add the task to its successor list .",
    "initialize an empty successor list 6 .",
    "overwrite elements of @xmath4 used in step 1 with the task s index .",
    "a drawback of the forward wave algorithm is the fact that when a task is created by the algorithm , only the predecessors are known . since the tasks needs to store its list of successors rather than its predecessors it would simplify the task generation if the list of successors were known at the time when a task is created",
    "this is achieved by the backward wave method .",
    "the backward method works like the forward method , but it replaces the array @xmath4 with an array @xmath5[ny][nz]$ ] which stores for each grid cell the index of the next task that accesses the cell . the array is again initialized with the special marker , which now means that no further task accesses the cell .",
    "the backward algorithm then creates the waves in reverse order from the last wave to the first . for each task in a wave the method performs the following steps :    1 .",
    "for all cells accessed by the task , copy the corresponding element of @xmath6 into a list .",
    "2 .   eliminate duplicates and the special marker from the list .",
    "store the result as the task s direct successor list .",
    "3 .   for all direct successors : increment the number of direct predecessors by one .",
    "4 .   initialize the task s number of direct predecessors to zero 5 .",
    "overwrite elements of s used in step 1 with the task s index .      in order to be able to test the cell task algorithm in practice",
    ", the method has been implemented in a general purpose parallel md code named @xcite .",
    "this code has been developed for large - scale simulations using many - body potentials of the embedded - atom method type @xcite or the similar finnis - sinclair  @xcite and tight - binding second - moment potentials  @xcite .",
    "the code already supported parallelization through spatial decomposition so that parallel speedups can be compared .",
    "the implementation of the cell task method requires a software environment supporting task - based programming .",
    "the current implementation of the cell task method makes use of intel s threading building blocks library ( tbb ) for the management of the thread pool and the tasks .",
    "tbb is a c++ library that is available under an open - source license for many platforms  @xcite .",
    "it should be noted however that other task - based programming systems , for example those described in refs .",
    "@xcite or openmp , could probably be used as well to implement the cell task method .",
    "since uses the linked - cell technique for the generation of the neighbor lists , the implementation of the wave method required relatively little changes to the code since most data structures were already in place and ready to use . the majority of the code that had to be developed concerns the task scheduling .",
    "this code is concentrated in one c++ class named scheduler that provides member functions for the creation of the dependent task schedule and for the execution of the schedule .",
    "the creation of the task schedule is performed during the creation of the neighbor lists when the particles have been binned into the cell grid .",
    "the scheduler then checks if the cell grid has changed and runs the backward wave algorithm if necessary .",
    "since the schedule depends only on the cell grid , there is no need to recreate it after every execution .    in order to execute the task schedule",
    ", a functor object is passed to the scheduler .",
    "the scheduler then uses the execution algorithm described in sec .",
    "[ secwave ] to submit tasks to the tbb for execution .",
    "whenever the tbb starts a task , the functor object is invoked to perform the actual work of the task .",
    "the functor thus acts as a delegate and makes it possible to perform different operations like force calculation or neighbor list generation with the same schedule .",
    "in contrast to a simple function pointer , the functor can pass additional information to the task .",
    "for example , in a replica style simulation where multiple copies of the system are simulated simultaneously the functor might carry the information on which system copy the task should operate .",
    "if the program is run with a single thread , a special version of the scheduler is created .",
    "this serial scheduler skips the generation of the task schedule and does not use the tbb .",
    "other changes concern mainly the force - calculation and neighbor - list generation . in the force calculation",
    "the loops over all particles had to be changed so that they run only over the particles in one grid cell .",
    "in addition to this the original c code was moved to a c++ class so that the scheduler could invoke it .",
    "some care was required to create thread local storage for accumulated quantities like the potential energy .",
    "finally , the code for the integration of the equations of motion was modified to use a thread - based parallelization .    as mentioned in sec .",
    "[ sectask ] , a problem created by the parallel generation of the neighbor lists is the simultaneous update of the lists by multiple tasks . in order to avoid such conflicts , the current implementation stores the neighbor lists of each task separately . to this end",
    ", the data structure of each task contains a c++ template std::vector@xmath7 .",
    "the usage of automatic memory management might incur some overhead in terms of both memory and speed .",
    "the experience with the code so far indicates , however , that the impact is small .        for large systems with a substantial amount of empty volumes",
    "a large number of grid cells may be empty . instead of scheduling a task for these cells",
    ", it makes sense to check for empty tasks during the generation of the task schedule and skip empty cells altogether .",
    "this may lead to a substantial reduction of the data structures and the scheduling overhead .",
    "the drawback of this optimization is that the task schedule must be regenerated every time that the linked - cell algorithm has run since particles might have moved into a previously empty cell . without empty - task skipping , the task schedule needs only to be regenerated if the number of grid cells changes . for systems that have a low number of empty cells",
    "it is therefore more efficient not to skip the empty cells and to save the overhead of the repeated schedule generation instead .      another way to reduce the number of empty tasks and the number of tasks to be scheduled is to group a small block of @xmath8 grid cells into a single cell task .",
    "this corresponds to an enlargement of the grid cells by an integer factor for the purpose of task scheduling ( the grid cells are still generated in the usual way so that the generation of neighbor lists is unaffected by this optimization ) .",
    "cell task blocking is a double edged sword . on the one hand",
    ", the reduction of the number of tasks through the blocking can reduce the scheduling overhead .",
    "in addition to this cache performance improves as long as all particles affected by a task fit into the cache memory .    on the other hand ,",
    "both advantages turn into disadvantages for larger cell blocks .",
    "the thread scheduler requires a large number of short tasks in order to obtain a good load balance , and the cache performance will decrease if the amount of memory used by the blocked task exceeds the size of the cache . for these reasons",
    "task blocking should be used with care .",
    "benchmark tests are recommended in order to find the optimal block size for a system .      in many cases , the definition of overlapping tasks given in sec .",
    "[ sectask ] is actually unnecessarily restrictive .",
    "if newton s third law is exploited by a simulation program , neighbor lists are usually constructed in such a way that pairs of particles are accounted for only once . if particles @xmath9 and @xmath10 are within the cutoff radius , @xmath9 will appear in the neighbor list of @xmath10 or @xmath10 will be in the neighbor list of @xmath9 but not both .",
    "this is typically achieved by limiting the search for neighbors of a particle to 14 out of the 27 surrounding cells .",
    "if the construction of neighbor lists excludes some of the surrounding cells , these cells can also be excluded from the definition of overlapping tasks as there is no risk of simultaneous particle updates in these cells .",
    "a reduction of the overlap area of the tasks could be exploited to place more tasks in a wave , which increases the number of tasks that can run simultaneously .",
    "while it is difficult to exploit the exact arrangements of the 14 cells used for the neighbor lists , it is easily possible to reduce the size of the overlap area from 27 to @xmath11 cells .",
    "this would increase the number of tasks in a wave by up to 50% .",
    "the current implementation of the cell task method does not employ a stricter definition of the task overlap - area for two reasons : first , there are actually potentials that access all 27 cells that surround an atom even if newton s third law is applied .",
    "an example for this are the forces generated by the screening factor in the modified embedded - atom method @xcite .",
    "second , this optimizations requires a tighter coupling between the neighbor list generation and the wave algorithm .",
    "the optimization will , however , most likely be included in a future version of the code .",
    "in order to test the efficiency of the proposed algorithm a series of benchmark tests involving four different configurations were carried out .",
    "the configurations are a cubic block of fcc bulk copper ( 1,000,188 atoms ) , a spherical copper nanoparticle with a diameter of 30 nm ( 1,177,151 atoms ) , a porous system of partially sintered copper nanoparticles ( 1,992,220 atoms ) and two sintered copper nanoparticles ( 57,482 atoms ) .",
    "these configurations are very different in terms of there homogeneity and the challenge they pose for the spatial decomposition method .",
    "all simulations used the tight - binding second - moment potential for copper by cleri and rosato @xcite .",
    "the structure of this potential is very similar to other many - body potentials of the embedded - atom method @xcite or finnis - sinclair @xcite type .",
    "compared to other potentials the cleri and rosato potentials use rather simple functions , and the calculation of the forces with these potentials is therefore very fast . due to the low computational complexity , memory access speed can become a limiting factor in simulations with these potentials .",
    "simulations of the three larger systems ( the small system ) were run over a period of 100 ( 2500 ) simulation steps .",
    "all simulations regenerated the neighbor lists at every 10th step .",
    "execution times were calculated as the average run time of five independent simulations excluding the time for initialization of the simulation and the loading or saving of the configuration .",
    "the benchmark simulations were run on two different computers .",
    "the first was a typical dual hex - core server with intel xeon x5650 processors and 16 gb ddr3 - 1333 ram . on this multi - core machine the original serial version of , the mpi based spatial decomposition version using 2 to 12 mpi ranks and",
    "the new task - based version using 1 to 12 threads were tested .",
    "the second test system was a xeon phi coprocessor 5110p @xcite .",
    "only the task - based version of the program was employed on this machine , running the code in native mode with 1 to 240 threads .    the simulations with the task - based method used task blocking with a block size of @xmath12 for the three large systems and a block size of @xmath13 for the small system .",
    "empty task skipping was used except for the simulations of bulk copper .",
    "simulations with the mpi version employed @xmath14 and @xmath15 decompositions where possible in order to obtain the most compact subvolumes . for the compact bulk system",
    "the impact of the details of the decomposition is very small . for the inhomogeneous systems the execution times certainly depend on the decomposition .",
    "the general picture , however , can be expected to remain the same .",
    "no attempt was therefore made to optimize the decomposition of these systems .",
    "no direct comparison of the execution times of the program versions is attempted in the following .",
    "the execution times @xmath16 of the task - based version running with @xmath17 threads are without exception lower than the corresponding times @xmath18 of the mpi version running with @xmath17 ranks or the execution time @xmath19 of the original serial program .",
    "however the performance gains of the cell task versions are partly due to code changes when the force calculation was moved into a c++ class .",
    "comparisons of the execution times or calculation of the speedup with respect to the fastest serial time [ which is @xmath20 would therefore make little sense .    in order to compare the cell task algorithm with spatial decomposition , the speedup of these algorithms with respect to the serial version that uses the same force calculation is used .",
    "the speedups of the mpi and cell task version are thus calculated as @xmath21 and @xmath22 , respectively .",
    "this definition eliminates the differences of the force calculation from the results and allows a fair comparison of the merits of both parallelization methods .",
    "the crystalline bulk copper configuration is an example for a perfectly homogeneous system for which the spatial decomposition method works well .",
    "figure  [ figbulk ] shows the parallel speedups obtained by the cell task method and spatial decomposition for this system on the multi - core machine .",
    "as expected , spatial decomposition yields excellent parallel efficiencies ( speedup per processor or thread ) above 80% for almost all numbers of processors .",
    "there are , however , dips in the curve at 5 , 10 , and 11 processors .",
    "the reason for this is that for these numbers the regular crystal lattice of the system can not be divided evenly among the processors .",
    "this emphasizes another disadvantage of spatial decomposition : the efficiency of the method depends on details of the system , and not all numbers of processors work equally well .",
    "the cell task method , on the other hand , delivers much more consistent speedup factors that increase monotonously with the number of threads . with the exception of the cases of 5 , 10 , and 11 processors which have already been discussed , both methods obtain similar speedups .",
    "according to the figure the cell task method might have a slight advantage , but this should not be overemphasized as this might be a result of the differences in the force calculation code .",
    "for the bulk system , the cell task method obtains a parallel efficiency of 83.6% when using 12 threads .",
    "one might ask whether for a system with more than one million atoms this value should not be higher since for a system of this size the fraction of time spent in serial code can be expected to be negligible . while some overhead is certainly caused by the dynamic scheduling of the tasks",
    "the principal factor limiting parallel efficiency is memory access speed .",
    "a short test on a system with a lower clock frequency but faster memory resulted in a higher parallel efficiency of 90.2% for 12 threads .",
    "in addition to this , the fact that the spatial decomposition program achieves similar speedups indicates that the parallel efficiency is limited by hardware constraints rather than the algorithms .",
    "the spherical nanoparticle system is inhomogeneous in the sense that the particle fills only a part of the volume of the simulation box leaving the rest empty . for the spatial decomposition method this configuration is challenging since there is no simple way to divide the simulation box into an arbitrary number of domains with equal shapes so that each domain contains a similar number of particles .",
    "exceptions are the cases of two , four and eight processors where equal partitions can be obtained by cutting the sphere repeatedly into halves .",
    "this is confirmed by the speedup factors obtained on the multi - core machine for this system ( see fig .",
    "[ figsphere ] ) . spatial decomposition in this system",
    "is efficient only for two , four and eight processors . in all other cases",
    "the parallel efficiency is significantly lower in the range of 50% - 60% .",
    "in contrast to this , the cell task method yields efficiencies above 80% for all numbers of threads .",
    "the parallel efficiency of the cell task method for this system is 82.8% when using 12 threads , very similar to the value obtained for the bulk system .",
    "the partially sintered nanocrystalline copper system is the most complex and inhomogenous of the three benchmark systems ( see fig .  [ figcubocfg ] ) .",
    "the configuration is an intermediate result from a simulation of the coalescence of an ensemble of copper nanoparticles . as can be seen from fig .",
    "[ figcubocfg ] the system is very inhomogeneous with an irregular distribution of the atoms and a large amount of empty space .",
    "the work presented in this article was motivated by systems like this .",
    "figure  [ figcubo ] shows the speedup factors obtained for the nanocrystalline configuration on the multi - core machine .",
    "it is clear from this figure that spatial decomposition is not very effective for this kind of system .",
    "while the speedup factors increase more or less monotonously , they are far below the ideal value of one per processor .",
    "the reason for this is clear from fig .",
    "[ figcubocfg ] . only by great chance",
    "could a regular subdivision of the system into domains result in a balanced workload .",
    "the cell task method , on the other hand , has no particular problems with the porous nature of this system .",
    "the speedups shown in fig .",
    "[ figcubo ] for the cell task method are very similar to those obtained for the two previous benchmark systems . with 80.9%",
    "the parallel efficiency of the cell task method for this system when using 12 threads is slightly lower than for the previous two systems .",
    "this can probably be explained by the large surface of the configuration which reduces the average number of neighbors per particle significantly . the lower number of neighbors in turn affects the memory access pattern and might reduce cache efficiency .          in order to test the efficiency of the cell task method for smaller configurations , a system consisting of two sintered copper nanoparticles with only 57,482 atoms",
    "was used . fig .",
    "[ figsys08cfg ] shows the dumbbell - like shape of the system , which constitutes a similar challenge to spatial decomposition as the spherical nanoparticle .        on the multi - core machine ,",
    "the behavior of the speedup factor in this benchmark is similar to the nanoparticle system ( see fig .",
    "[ figsys08 ] ) .",
    "the speedup of the cell task method increases continuously with the number of threads .",
    "the speedups for the spatial decomposition method are generally inferior to those obtained by the cell task method except for @xmath23 2 , 4 and 8 where the symmetry of the configuration allows an efficient decomposition .    the main difference between the speedups of the cell task method shown in fig .",
    "[ figsys08 ] and the other benchmark systems is a slight overall reduction of the cell task method s parallel efficiency . when using 12 threads , the efficiency obtained for this system is only 77.3% .",
    "the reason for this reduction is most likely the growing impact of serial code .",
    "the benchmark results presented in the preceding sections demonstrate the efficiency of the cell task method on typical multi - core machines . in this section the efficiency of the method on a many - core system",
    "is studied .",
    "the intel xeon phi coprocessors 5110p integrates 60 compute cores on a single chip and provides a large memory bandwidth .",
    "each core supports four hardware threads and has 512-bit vector registers that allow the simultaneous execution of eight double - precision floating - point operations . under normal conditions ,",
    "optimal performance can be achieved only if at least two threads are running on each core .",
    "for a detailed discussion of these devices the reader is referred to ref .",
    "@xcite .",
    "figure  [ figmic ] shows the parallel speedups obtained with the four benchmark systems used in this work on the xeon phi coprocessor using up to 240 threads .",
    "interestingly , the behavior of all four systems is different .    until @xmath24 threads ,",
    "the speedups for the three large systems stay close to the line of ideal speedup . at @xmath24 ,",
    "the speedup of the three systems range from @xmath25 ( cf .",
    "table  [ tabmic ] ) , corresponding to parallel efficiencies between 83.4% and 90.8% . at this point ,",
    "the three curves exhibit a sharp bend but the speedup continues to rise at a lower rate until @xmath26 .",
    "this is due to the fact that now more than one thread is running per core .",
    "although the xeon phi microarchitecture requires more than one thread per core for optimal performance , it is not guaranteed that the performance will be doubled by a second thread .",
    "the threads share after all some of the physical units of the core like level 1 and 2 caches .",
    "a likely reason for the slower increase of the speedup for @xmath17 in the range from 60 to 120 is an increased amount of cache misses .",
    "beyond @xmath26 the speedup curves of the three large benchmark systems show a more or less pronounced dip ( hardly noticeable for the porous nanocrystalline system and most visible in case of the nanoparticle ) after which the speedup continues to rise .",
    "the reason for this dip is not yet understood .",
    "the bulk system and the porous nanocrystalline system reach their maximum speedup at @xmath27 after which the speedup decreases for both systems .",
    "in contrast to this , the nanoparticle simulation increases its speedup until @xmath28 .    compared to the larger benchmark systems , simulations of the sintered nanoparticles achieve significantly lower speedups on the xeon phi .",
    "the speedup curve for this system deviates early on from the ideal behavior and it reaches a plateau around @xmath29 . for larger values of @xmath17",
    "the curve decreases with clear steps at @xmath26 and @xmath27",
    ". the lower performance of the xeon phi in this benchmark can be explained by the system size .",
    "the small volume of the configuration does not allow for more than about 100 tasks to be run simultaneously .",
    "adding more threads can therefore not accelerate the computations .",
    "the decrease of the efficiency for larger values of @xmath17 is probably caused by increased management overhead when the internal task queues run empty .",
    "a similar effect might be the reason for the efficiency decrease in case of the bulk system beyond @xmath27 .    .",
    "speedup of benchmarks systems on the xeon phi coprocessor : number of threads @xmath30 for which the maximum speedup was obtained together with the corresponding speedup @xmath31 , and the speedup for 60 threads @xmath32 and maximum speedup @xmath33 with respect to the 12-core test machine . [ cols=\"<,^,^,^,^\",options=\"header \" , ]     table  [ tabmic ] summarizes the maximum speedups obtained for the four benchmark systems on the xeon phi coprocessor .",
    "the best speedups above 90 are achieved by the bulk system and the nanoparticle .",
    "the porous nanocrystalline system reaches a maximum speedup of 75 , whereas the small system of two sintered nanoparticles is limited to @xmath34 .",
    "the table also gives the speedup of the systems on the coprocessor with respect to single thread execution on the 12 core machine .",
    "these values are not overly impressive .",
    "one has to keep in mind , however , that the individual cores of the coprocessor are considerably less powerful than a modern general purpose cpu . as pointed out in ref .",
    "@xcite , the key to a strong performance of the xeon phi coprocessor is a highly parallel algorithm combined with vectorization . in this work only the first part has been addressed .",
    "this article describes the design of a parallel algorithm for md simulations with short - ranged forces on single node multi- and many - core systems .",
    "the aim of the cell task algorithm is to provide an efficient parallelization method for systems where spatial decomposition is not effective .",
    "examples for such problematic cases are large inhomogeneous systems like nanostructured materials or nanodevices .",
    "the cell task method makes use of the linked - cell technique to subdivide the force calculation into small tasks .",
    "the tasks are then executed by a team of threads according to a dependent task schedule .",
    "this schedule is an important part of the algorithm .",
    "it avoids the situation that a particle is accessed by two threads simultaneously .",
    "this effectively eliminates the need for synchronization constructs in the force calculation , which makes the algorithm very efficient .",
    "benchmark simulations on a 12-core system show clearly that for inhomogeneous configurations like nanoparticles or porous systems the cell task method performs significantly better than spatial decomposition . for a homogeneous crystalline bulk system",
    "both methods achieve comparable speedups .",
    "an added advantage of the cell task method is its consistent performance .",
    "the speedup factor of this method increases continuously with the number of threads in a very similar manner for all types of systems .",
    "it relieves the user from technical considerations like which spatial decomposition strategy works best for a given system .",
    "the benchmarks on the multi - core system reveal two factors that limit the parallel efficiency of the cell task method : memory access speed and small system size .",
    "neither of these factors is specific to the cell task method .",
    "no parallelization strategy will work if the memory system can not deliver the data fast enough , and every md program contains inevitably some serial code that limits the parallel efficiency .",
    "note , however , that in the current implementation of the cell task method the construction of the task schedule increases the fraction of time spent in serial code slightly as the wave algorithm has not been parallelized yet .",
    "execution of the benchmark simulations on a 60 core intel xeon phi coprocessor shows that the cell task method scales to large numbers of threads . for large configurations the speedup increases linearly and close to the ideal line until @xmath24 . beyond 60 threads , the speedups increase at a lower rate since",
    "the number of threads per core is now greater than one .",
    "running more than one thread per core is almost always beneficial on the xeon phi since it hides latencies of the microarchitecture  @xcite .",
    "table  [ tabmic ] shows that the three larger benchmark systems reach their maximum speedups on the xeon phi at three or four threads per core .",
    "these maximum speedups @xmath31 range from 75 to 93 and they are 44% to 86% higher than the speedups @xmath32 obtained at one thread per core",
    ".    the smallest benchmark system does not perform optimally on the xeon phi coprocessor .",
    "the reason for this is that the configuration is not large enough to keep two or more threads per core busy .",
    "the dependent task schedule limits the number of tasks that can run simultaneously to at most 1/27 of the total number of tasks . in order to keep all threads running , the number of tasks must therefore be at least 27 times the number of threads . in practice optimal performance",
    "might require an even substantially larger number of tasks per thread .",
    "more work will be necessary to study the performance limits of the algorithm for smaller systems .",
    "all benchmarks shown in this work used the copper potential by cleri and rosato  @xcite .",
    "this choice might have limited the parallel efficiency due to the low computational complexity of the potential which emphasizes memory access issues .",
    "it would be interesting to see the performance of the cell task algorithm with a computationally more demanding potential like , for example , one of the eam potentials in ref .",
    "with such a potential higher parallel efficiencies closer to the ideal limit can be expected since the influence of memory access speed and serial code execution would be diminished .",
    "work is currently in progress to let the program take advantage of the vector capabilities of the xeon phi architecture .",
    "in addition to this it is planned to extend the method into a hybrid scheme for distributed systems that combines the cell task algorithm for the parallelization on the compute nodes with spatial decomposition to share the work between multiple nodes .",
    "this work has been supported financially by laurentian university and the natural sciences and engineering research council of canada ( nserc ) .",
    "generous allocation of computer time on the facilities of the shared hierarchical academic research network ( sharcnet )  @xcite and compute / calcul canada is gratefully acknowledged .",
    "the wave algorithm generates the dependent task schedule for the cell task method from a series of sets of non - overlapping tasks ( _ waves _ ) .",
    "this appendix gives details about the construction of the waves .",
    "the indices of the cells belonging to one wave are generated from the cartesian product of three sets of integers ( one for each dimension ) . to give a two - dimensional example , the wave shown in fig .",
    "[ figwave ] could be constructed from the product @xmath35 [ we assume here and in the following that the cell in the lower left corner has the indices ( 1,1 ) ] .",
    "the product @xmath36 would generate a similar wave with the tasks shifted one cell to the right .",
    "note that not all index sets can be used to generate a wave . in order to obtain non - overlapping task",
    ", the differences between all indices in a set must be at least three ( subject to the boundary condition of that dimension ; for a dimension with @xmath37 cells and periodic boundary conditions , the difference between index 1 and @xmath37 is 1 ) .",
    "the product @xmath38 , for example , does not give a valid wave .",
    "the number of index sets necessary to cover all cells in one dimension depends on two factors .",
    "if the number of cells @xmath37 in that dimension is a multiple of three or if periodic boundary conditions do not apply in that direction , three index sets are enough .",
    "these three sets start with the numbers 1 , 2 , and 3 , respectively , and advance in steps of three to the end of the system .",
    "for example , all cells of a non - periodic system with @xmath39 are covered by the following three sets : @xmath40 , @xmath41 , and @xmath42 .",
    "this coverage of the cells in one dimension is shown by the following figure where the numbers indicate to which wave the cell belongs .",
    "@xmath43 it is easy to see that the cells belonging to the same wave are separated by at least two cells not belonging to that wave .",
    "things are more complicated for directions where periodic boundary conditions apply and where @xmath37 is not a multiple of three . in this case",
    "a fourth index set is required .",
    "the index sets for such a case can be obtained by advancing continuously in steps of three , wrapping around at the boundary @xmath37 . for a periodic system with @xmath39 ,",
    "the first set is then @xmath44 . unlike the non - periodic case , @xmath45",
    "can not be included in this set as that cell overlaps with the first . by advancing in steps of three",
    "we obtain the second set @xmath46 .",
    "advancing further in steps of three we obtain for the third and fourth sets @xmath47 and @xmath48 .",
    "the coverage of the cells in this case is thus @xmath49    a complete set of waves in more than one dimension can be generated by nested loops where each loop generates the index sets for one dimension . in order to keep the number of dependencies between tasks low ,",
    "it is best if from one wave to the next , the task pattern is shifted only in one direction .",
    "this is achieved if the inner loops are not reset when one of the outer loops advances . instead",
    ", the inner loops repeat their last pattern , possibly filling it to the maximum number of cells .",
    "this is explained by the next figure , which shows the first six waves in a periodic system with @xmath50 cells : @xmath51    the first four waves use the same index set @xmath52 for the @xmath53 direction and thus essentially repeat the one - dimensional example given above . when going from the fourth to the fifth wave , the index set for the @xmath54 direction does not return to the set of the first wave .",
    "instead the set reuses the indices from the fourth wave @xmath55 and completes the set by advancing in steps of three which leads to leads to the set @xmath56 .",
    "the sixth set is then generated by further advances in steps of three as described above .    since each dimension",
    "is covered by three or four sets of indices , the total number of waves for a system with @xmath57 dimensions is given by a product of @xmath57 factors where each factor is 3 or 4 depending on the dimensions of the cell grid and the boundary conditions . in three dimensions",
    "the total number of waves is thus 27 , 36 , 48 , or 64 .",
    "27ifxundefined [ 1 ] ifx#1 ifnum [ 1 ] # 1firstoftwo secondoftwo ifx [ 1 ] # 1firstoftwo secondoftwo `` `` # 1''''@noop [ 0]secondoftwosanitize@url [ 0 ]",
    " + 12$12  & 12#1212_12%12@startlink[1]@endlink[0]@bib@innerbibempty @noop _",
    "( ,  ,  ) @noop _ _  ( ,  ,  ) @noop _ _ ,  ed .",
    "( ,  , ) @noop _ _ ,  ed .",
    "( ,  ) @noop",
    "* * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop @noop _ _  ( ,  ,  ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) in  https://www.usenix.org/legacy/events/hotpar11/tech/final_files/vandierendonck.pdf[__ ]  ( ,  ,  ) @noop * * ,   ( ) @noop * * ,   ( ) @noop @noop ph.d . thesis ,  , ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop _ _ ,  ed .",
    "( , ,  ) @noop * * ,   ( ) @noop * * ,   ( ) @noop"
  ],
  "abstract_text": [
    "<S> this article introduces a highly parallel algorithm for molecular dynamics simulations with short - range forces on single node multi- and many - core systems . </S>",
    "<S> the algorithm is designed to achieve high parallel speedups for strongly inhomogeneous systems like nanodevices or nanostructured materials . in the proposed scheme the calculation of the forces and the generation of neighbor lists </S>",
    "<S> are divided into small tasks . </S>",
    "<S> the tasks are then executed by a thread pool according to a dependent task schedule . </S>",
    "<S> this schedule is constructed in such a way that a particle is never accessed by two threads at the same time . </S>",
    "<S> benchmark simulations on a typical 12 core machine show that the described algorithm achieves excellent parallel efficiencies above 80% for different kinds of systems and all numbers of cores . for inhomogeneous systems the speedups are strongly superior to those obtained with spatial decomposition . </S>",
    "<S> further benchmarks were performed on an intel xeon phi coprocessor . </S>",
    "<S> these simulations demonstrate that the algorithm scales well to large numbers of cores . </S>"
  ]
}