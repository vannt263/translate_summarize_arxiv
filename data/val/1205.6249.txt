{
  "article_text": [
    "leader election is one of the fundamental problems in distributed computing , first stated in @xcite .",
    "each entity in some set has a boolean variable initialized to 0 and , after the election , exactly one of these entities , called the _ leader _ , should change this value to 1 .",
    "all other entities should know which one becomes the leader .",
    "in this paper we consider the problem of leader election among mobile agents that operate in a network .",
    "we assume that neither nodes of the network nor agents have labels that can be used for leader election .",
    "this assumption is motivated by scenarios where nodes and/or agents may refrain from revealing their identities , e.g. , for security or privacy reasons .",
    "hence it is desirable to have leader election algorithms that do not rely on identities but exploit asymmetries in the initial configuration of agents due to its topology and to port labelings . with unlabeled nodes and agents ,",
    "leader election is impossible for symmetric initial configurations , e.g. , in a ring in which ports at each node are 0,1 , in the clockwise direction and agents are initially situated at every node .",
    "our goal is to answer the following question :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ for which initial configurations of agents is leader election possible and how to do it when it is possible ? _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    a network is modeled as an undirected connected graph with unlabeled nodes .",
    "it is important to note that the agents have to be able to _ locally _ distinguish ports at a node : otherwise , the adversary could prevent an agent from choosing a particular edge , thus making navigation in the network impossible even in the simple case of trees .",
    "this justifies a common assumption made in the literature : ports at a node of degree @xmath0 have arbitrary fixed labelings @xmath1 @xmath2 . throughout the paper",
    ", we will use the term `` graph '' to mean a graph with the above properties .",
    "we do not assume any coherence between port labelings at various nodes .",
    "agents can read the port numbers when entering and leaving nodes .    at the beginning ,",
    "identical agents are situated in some nodes of the graph , at most one agent at each node .",
    "the graph with bicolored nodes ( black if the node is occupied , white if it is not ) is called an initial configuration .",
    "agents do not have labels and have unlimited memory : they are modeled as identical turing machines .",
    "they execute the same deterministic algorithm .",
    "agents navigate in the graph in an asynchronous way which is formalized by an adversarial model used in @xcite and described below .",
    "two important notions used to specify movements of agents are the _ route _ of the agent and its _",
    "walk_. intuitively , the agent chooses the route _ where _ it moves and the adversary describes the walk on this route , deciding _ how _ the agent moves .",
    "more precisely , these notions are defined as follows .",
    "the adversary initially places an agent at some node of the graph .",
    "the route is chosen by the agent and is defined as follows .",
    "the agent chooses one of the available ports at the current node .",
    "after getting to the other end of the corresponding edge , the agent learns the port number by which it enters and the degree of the entered node .",
    "then it chooses one of the available ports at this node or decides to stay at this node .",
    "the resulting route of the agent is the corresponding sequence of edges @xmath3 , which is a ( not necessarily simple ) path in the graph .",
    "we now describe the walk @xmath4 of an agent on its route .",
    "let @xmath5 be the route of an agent .",
    "let @xmath6 .",
    "let @xmath7 , where @xmath8 , be an increasing sequence of reals , chosen by the adversary , that represent points in time .",
    "let @xmath9\\rightarrow [ v_i , v_{i+1}]$ ] be any continuous function , chosen by the adversary , such that @xmath10 and @xmath11 .",
    "for any @xmath12 $ ] , we define @xmath13 .",
    "the interpretation of the walk @xmath4 is as follows : at time @xmath14 the agent is at the point @xmath15 of its route .",
    "this general definition of the walk and the fact that ( as opposed to the route ) it is designed by the adversary , are a way to formalize the asynchronous characteristics of the process .",
    "the movement of the agent can be at arbitrary speed , the adversary may sometimes stop the agent or move it back and forth , as long as the walk in each edge of the route is continuous and covers all of it .",
    "this definition makes the adversary very powerful , and consequently agents have little control on how they move .",
    "this , for example , makes meetings between agents hard to achieve .",
    "note that agents can meet either at nodes or inside edges of the graph .",
    "agents with routes @xmath16 and @xmath17 and with walks @xmath18 and @xmath19 meet at time @xmath14 , if points @xmath20 and @xmath21 are identical .",
    "a meeting is guaranteed for routes @xmath16 and @xmath17 , if the agents using these routes meet at some time @xmath14 , regardless of the walks chosen by the adversary .",
    "when agents meet , they notice this fact and can exchange all previously acquired information . however , if the meeting is inside an edge , they continue the walk prescribed by the adversary until reaching the other end of the current edge . new knowledge acquired at the meeting",
    "can then influence the choice of the subsequent part of the routes constructed by each of the agents .",
    "since agents do not know a priori the topology of the graph and have identical memories at the beginning , the only way to elect a leader among agents is by learning the asymmetries in their initial positions in the graph . hence agents must gain this knowledge by navigating in the network and share it with other agents to accomplish leader election . sharing the knowledge can be done only as a result of meetings of agents , which is difficult because of the asynchronous way in which they move .",
    "it is not hard to see ( cf . proposition [ no - bound ] ) that in the absence of a known upper bound on the size of the graph , leader election is impossible even for asymmetric configurations .",
    "hence we assume that all agents know a priori a common upper bound @xmath22 on the size of the graph .",
    "this is the only information about the environment available to the agents when they start the task of leader election .",
    "having described our model , we can now make the initial problem more precise .",
    "call an initial configuration _ eligible _ if , starting from this configuration , leader election can be accomplished regardless of the actions of the adversary . thus in order that a configuration be eligible , it is enough to have some leader election algorithm starting from it , even one dedicated to this specific configuration .",
    "now our problem can be reformulated as follows .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ which initial configurations are eligible ? find a universal leader election algorithm that elects a leader regardless of the actions of the adversary , for all eligible configurations in graphs of size at most @xmath22 , where @xmath22 is known to the agents .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _      assuming an upper bound @xmath22 on the size of the graph , known a priori to all agents , we characterize all eligible initial configurations and construct an algorithm that accomplishes leader election for all of them .",
    "more precisely , we formulate a combinatorial condition on the initial configuration , which has the following properties . on the one hand , if this condition does not hold , then the adversary can prevent leader election starting from the given initial configuration . on the other hand",
    ", we construct an algorithm that elects a leader , regardless of the adversary , for all initial configurations satisfying the condition , in graphs of size at most equal to the given bound @xmath22 .",
    "intuitively , leader election is possible when the initial configuration is asymmetric and when agents can learn this , regardless of the actions of the adversary .",
    "both these requirements are contained in the necessary and sufficient condition on eligibility , which we formulate in section  [ sec : feasibility ] .",
    "in fact , the process of learning the asymmetries by the agents is the main conceptual and technical challenge in the design and analysis of our algorithm .",
    "agents acquire and share this knowledge as a result of meetings .",
    "the difficulty is to design the algorithm in such a way that all asymmetries be finally learned by all agents and that all agents be aware of this fact and thus capable to correctly elect the leader .",
    "leader election in networks was mostly studied assuming that all nodes have distinct labels and election has to be performed among nodes .",
    "this task was first studied for rings . a synchronous algorithm , based on comparisons of labels , and using @xmath23 messages was given in @xcite .",
    "it was proved in @xcite that this complexity is optimal for comparison - based algorithms .",
    "on the other hand , the authors showed an algorithm using a linear number of messages but requiring very large running time .",
    "an asynchronous algorithm using @xmath23 messages was given , e.g. , in @xcite and the optimality of this message complexity was shown in @xcite .",
    "deterministic leader election in radio networks has been studied , e.g. , in @xcite and randomized leader election , e.g. , in @xcite . in @xcite",
    "the leader election problem is approached in a model based on mobile agents for networks with labeled nodes .",
    "many authors @xcite studied various computing problems in anonymous networks .",
    "in particular , @xcite characterize message passing networks in which leader election can be achieved when nodes are anonymous . in @xcite",
    "the authors study the problem of leader election in general networks , under the assumption that labels are not unique .",
    "they characterize networks in which this can be done and give an algorithm which performs election when it is feasible .",
    "they assume that the number of nodes of the network is known to all nodes .",
    "in @xcite the authors study feasibility and message complexity of sorting and leader election in rings with nonunique labels , while in @xcite the authors provide algorithms for the generalized leader election problem in rings with arbitrary labels , unknown ( and arbitrary ) size of the ring and for both synchronous and asynchronous communication .",
    "characterizations of feasible instances for leader election and naming problems have been provided in  @xcite .",
    "memory needed for leader election in unlabeled networks has been studied in @xcite .",
    "the asynchronous model for mobile agents navigation in unlabeled networks has been previously used in @xcite in the context of rendezvous between two agents . in @xcite agents",
    "had different labels and in @xcite agents were anonymous , as in our present scenario .",
    "the synchronous model , in which agents traverse edges in lock - step , has been used , e.g. , in @xcite , also in the context of rendezvous .      in section  [ sec : memory_states ] we formalize the description of how agents decide .",
    "this concerns both navigation decisions ( on what basis the agents construct their routes ) and the final decision who is the leader .",
    "we define memory states of the agents that are the basis of all these decisions . in section  [ sec : feasibility ] we formulate the combinatorial condition ec concerning initial configurations that is then proved to be equivalent to eligibility , and we formulate our main result . in section  [ sec : negative ] we prove two negative results concerning leader election : one saying that condition ec is necessary for eligibility and the other saying that the assumption concerning knowledge of the upper bound can not be removed . in section",
    "[ sec : algorithm ] we give our main contribution : we construct a universal algorithm electing a leader for all configurations satisfying condition ec , if agents know an upper bound on the size of the graph .",
    "section  [ sec : conclusions ] contains conclusions .",
    "in this section we describe formally on what basis the agents make decisions concerning navigation in the graph ( i.e. , how they construct their routes ) and on what basis they make the decision concerning leader election .",
    "all these decisions depend on the _ memory states _ of the agents . at every time @xmath14",
    "the memory state of an agent is a finite sequence of symbols defined as follows . before an agent is woken up by the adversary , its memory state is blank : it is the empty sequence .",
    "when an agent is woken up , it perceives the degree @xmath0 of its initial position , i.e. , its memory state becomes the sequence @xmath24 .",
    "further on , the memory state of an agent changes when it visits a node .",
    "it is caused by the following three types of events : entering a node by the agent , meeting other agents , and leaving a node by the agent .",
    "a change of a memory state of an agent is done by appending to its current memory state a sequence of symbols defined as follows .",
    "the change due to entering a node of degree @xmath0 by port number @xmath25 , consists of appending the sequence @xmath26 to the current memory state of the agent .",
    "the change due to leaving a node by port @xmath27 consists of appending @xmath27 to the current memory state of the agent .",
    "the change due to meeting other agents is defined as follows . when entering a node @xmath28 the agent considers all meetings with other agents that occurred since leaving the previous node .",
    "suppose that the current memory states of the agents met in this time interval by agent @xmath29 were @xmath30 , in lexicographic order , regardless of the order of meetings in this time interval and disregarding repeated meetings corresponding to the same memory state ( and thus to the same agent ) .",
    "agent @xmath29 appends the sequence of symbols @xmath31 ... [\\sigma_k])$ ] to its current memory state . when two or more of these events occur simultaneously , for example an agent meets another agent when it enters a node , or an agent meets simultaneously several agents , then the appropriate sequences are appended to its current memory one after another , in lexicographic order .",
    "when in the previous memory state the agent made a decision to stay idle at the current node , then its memory state can change only if and when some other agent enters this node .",
    "this completes the description of how the memory states of agents evolve .",
    "notice that after traversing an edge the action of agent @xmath29 consisting of appending a sequence of symbols @xmath32 $ ] due to a meeting with an agent with current memory state @xmath33 since leaving the previous node , is performed by @xmath29 at most once .",
    "since the number of agents is finite , this implies that , by any given moment in time , the memory state of an agent has changed only a finite number of times , and each time a finite sequence of symbols has been appended .",
    "hence memory states are indeed finite sequences of symbols .",
    "the decisions of agents are made always when an agent is at a node and they are of three possible types : an agent can decide to stay idle , it can decide to exit the current node by some port , or it can elect a leader and stop forever .",
    "all these decisions are based on the memory state of the agent after entering the current node and are prescribed by the algorithm .",
    "( recall that agents execute the same deterministic algorithm . )",
    "if an agent decides to stay at a given node , then it remains idle at it until another agent enters this node . at this time the memory state of the idle agent changes , and in the new memory state the agent makes a new decision .",
    "if an agent decides to leave the current node by a given port , it walks in the edge in the way prescribed by the adversary and makes a new decision after arriving at the other end of the edge .",
    "finally , if an agent decides to elect a leader , it either elects itself , or it decides that it is not a leader , in which case it has to give a sequence of port numbers leading from its own initial position to the initial position of the leader : this is the meaning of the requirement that every non - leader has to know which agent is the leader .",
    "in this section we express the necessary and sufficient condition on eligibility of an initial configuration and we formulate the main result of this paper .",
    "we first introduce some basic terminology .",
    "we will use the following notion from @xcite .",
    "let @xmath34 be a graph and @xmath28 a node of @xmath34 .",
    "we first define , for any @xmath35 , the _ truncated view _",
    "@xmath36 at depth @xmath37 , by induction on @xmath37 .",
    "@xmath38 is a tree consisting of a single node @xmath39 . if @xmath40 is defined for any node @xmath41 in the graph , then @xmath42 is the port - labeled tree rooted at @xmath39 and defined as follows . for every node @xmath43 , @xmath44 , adjacent to @xmath28 ,",
    "there is a child @xmath45 of @xmath39 in @xmath42 such that the port number at @xmath28 corresponding to edge @xmath46 is the same as the port number at @xmath39 corresponding to edge @xmath47 , and the port number at @xmath43 corresponding to edge @xmath46 is the same as the port number at @xmath45 corresponding to edge @xmath47 .",
    "now node @xmath45 , for @xmath44 becomes the root of the truncated view @xmath48 .",
    "the _ view _ from @xmath28 is the infinite rooted tree @xmath49 with labeled ports , such that @xmath36 is its truncation to level @xmath37 , for each @xmath50 . for an initial configuration",
    "in which node @xmath28 is the initial position of an agent , the view @xmath49 is called the view of this agent .    we will also use a notion similar to that of the view but reflecting the positions of agents in an initial configuration . consider a graph @xmath34 and an initial configuration of agents in this graph .",
    "let @xmath28 be a node occupied by an agent .",
    "a function @xmath4 that assigns either @xmath51 or @xmath52 to each node of @xmath49 is called a _ binary mapping _ for @xmath49 .",
    "a pair @xmath53 , where @xmath4 is a binary mapping for @xmath49 , such that @xmath54 if and only if @xmath55 corresponds to an initial position of an agent , is called the _ enhanced view _ from @xmath28 .",
    "thus , the enhanced view of an agent additionally marks in its view the nodes corresponding to initial positions of other agents in the initial configuration .    for any route @xmath56 such that @xmath6 ,",
    "we denote @xmath57 and @xmath58 , and we say that @xmath59 _ leads _ from @xmath60 to @xmath61 in @xmath34 . since nodes of @xmath34 are unlabeled , agents traveling on a route are aware only of the port numbers of the edges they traverse .",
    "hence , it will be usually more convenient to refer to these sequences of port numbers rather than to the edges of the route .",
    "any finite sequence of non - negative integers will be called a _",
    "trail_.    we define an operator @xmath62 , that provides the trail corresponding to a given route .",
    "more formally , if @xmath63 is a route in @xmath34 , then define @xmath64 to be the trail such that @xmath65 and @xmath66 are the port numbers of @xmath67 at @xmath43 and @xmath68 , respectively , for @xmath69 .",
    "we say that a trail @xmath70 is _ feasible from _ @xmath28 in @xmath34 , if there exists a route @xmath59 in @xmath34 such that @xmath71 and @xmath72 , and in such a case the route @xmath59 is denoted by @xmath73 .    for a sequence @xmath74",
    "we denote by @xmath75 the sequence @xmath76 . for two sequences @xmath74 and @xmath77 we write @xmath78 to refer to the sequence @xmath79 .    for any agent @xmath80 ,",
    "let @xmath81 denote its initial position .",
    "consider two agents @xmath80 and @xmath82 .",
    "consider any route @xmath59 leading from @xmath81 to @xmath83 and let @xmath84 .",
    "if @xmath85 , then we say that the route @xmath59 is a palindrome . for a given initial configuration ,",
    "a palindrome @xmath59 is called _ uniform _ , if for any route @xmath86 such that @xmath87 , whenever @xmath88 is occupied by an agent , then @xmath89 is also occupied by an agent .",
    "we are now ready to formulate our condition on an initial configuration , that will be called ec ( for eligibility condition ) in the sequel :    enhanced views of all agents are different _ and _ + ( there exist agents with different views _ or _ there exists a non - uniform palindrome )    we now formulate our main result whose proof is the objective of the rest of the paper .",
    "[ main ] assume that all agents are provided with an upper bound @xmath22 on the size of the graph .",
    "then an initial configuration is eligible if and only if condition _ ce _ holds for this configuration .",
    "moreover , there exists an algorithm electing a leader for all eligible configurations , regardless of the actions of the adversary .",
    "in this section we prove two negative results concerning the feasibility of leader election .",
    "the first result shows that condition ce is necessary to carry out leader election , even if the graph ( and hence its size ) is known to the agents .",
    "[ pro : negative1 ] suppose that the condition _ ce _ does not hold for the initial configuration .",
    "then there exists an adversary , such that leader election can not be accomplished for this configuration , even if the graph is known to the agents .",
    "fix an initial configuration . condition ce can be abbreviated as @xmath90 , where @xmath91 is `` enhanced views of all agents are different '' , @xmath92 is `` there exist agents with different views '' , and @xmath93 is `` there exists a non - uniform palindrome '' .",
    "suppose that ec does not hold .",
    "first consider the case when @xmath91 is false .",
    "this means that there exist agents @xmath29 and @xmath94 with the same enhanced view .",
    "this in turn implies that for every agent @xmath95 there exists an agent @xmath96 that has the same enhanced view as @xmath95 .",
    "indeed , if @xmath70 is the trail corresponding to a route that leads from @xmath97 to @xmath98 , agent @xmath96 is the agent whose initial position is at the end of the route corresponding to @xmath70 and starting at @xmath99 . for every agent",
    "@xmath95 we will call the agent @xmath96 its twin . consider a hypothetical leader election algorithm and the `` perfectly synchronous '' adversary that starts the execution of the algorithm simultaneously for all agents and moves all of them with the same constant speed",
    ". such an adversary induces rounds which are units of time in which all agents traverse an edge .",
    "the beginning of a round coincides with the end of the previous round .",
    "hence at the beginning and at the end of each round every agent is at a node .",
    "if agents meet inside an edge , they must meet exactly in the middle of a round in which they traverse an edge in opposite directions .",
    "we will show that the memory state of twins is identical at the end of each round .",
    "this implies that leader election is impossible , as an agent elects a leader when it is at a node , and consequently if some agent elects itself as a leader , its twin would elect itself as well , violating the uniqueness of the leader .",
    "the invariant that the memory state of twins is identical at the end of each round is proved by induction on the round number .",
    "it holds at the beginning , due to the same degree of initial positions of twins .",
    "suppose that after some round @xmath100 the memory states of twins are identical .",
    "consider twins @xmath95 and @xmath96 . in round",
    "@xmath101 they exit by the same port number and enter the next node by the same port number . if in round @xmath101 they do nt meet any agent in the middle of the edge , at the end of the round @xmath95 must meet agents with the same memory states as those met by @xmath96 ( if any ) , and hence memory states of @xmath95 and @xmath96 at the end of round @xmath101 are identical .",
    "if in round @xmath101 agent @xmath95 meets some agents in the middle of the edge , then agent @xmath96 must meet exactly the twins of these agents in the middle of the edge . by the inductive hypothesis",
    ", these twins have the same memory states as agents met by @xmath95 and hence again , at the end of the round the memory states of @xmath95 and @xmath96 are identical .",
    "this concludes the proof if @xmath91 is false .",
    "next consider the case when @xmath102 is false .",
    "this means that views of all agents are identical and every palindrome for the initial configuration ( if any ) is uniform . for any trail @xmath103 that yields a uniform palindrome , this gives a partition of all agents into pairs @xmath104 of agents at the ends of routes that correspond to this trail .",
    "again we consider the `` perfectly synchronous '' adversary described above .",
    "there are two subcases .",
    "if there is no palindrome in the initial configuration , then we prove the following invariant , holding at the beginning of each round , by induction on the round number : the memory state of all agents is the same and there is no palindrome between agents .",
    "the invariant holds at the beginning by assumption .",
    "suppose it holds after round @xmath100 . in round @xmath101",
    "all agents choose the same port number and enter the next node by the same port number .",
    "there are no meetings in round @xmath101 .",
    "indeed , the only meeting could be in the middle of an edge but this would mean that agents were joined by a one - edge palindrome at the beginning of round @xmath101 . if a pair of agents were joined by a palindrome after round @xmath101 , they would have to be joined by a palindrome longer or shorter by two edges at the beginning of the round , contradicting the inductive assumption .",
    "hence the invariant holds by induction .",
    "the second subcase is when there is a palindrome in the initial configuration ( and hence all such palindromes are uniform ) .",
    "now we prove the following invariant holding in the beginning of each round : the memory state of all agents is the same and every agent is at the end of a palindrome corresponding to the same trail .",
    "the invariant holds at the beginning by the assumption .",
    "suppose the invariant holds after round @xmath100 . in round @xmath101",
    "all agents choose the same port number and enter the next node by the same port number .",
    "if after round @xmath100 no pair of agents were at the ends of an edge with both ports equal , or they were but agents did not choose this port in round @xmath101 , then no meeting occurred and the invariant carries on after round @xmath101 .",
    "if after round @xmath100 every pair of agents were at the ends of an edge with both ports @xmath25 and the agents chose this port in round @xmath101 , then meetings of agents with identical memory states occurred in pairs in the middle of each joining edge . since meeting agents had identical memory state during the meeting , this holds also after round @xmath101 and agents are again in pairs at the ends of edges with both ports @xmath25",
    "thus the invariant holds at the end of round @xmath101 .",
    "hence at the beginning of each round the memory state of all agents is the same , both when @xmath91 and when @xmath102 is violated .",
    "this implies that with the `` perfectly synchronous '' adversary leader election is impossible whenever condition ec is violated for the initial configuration .",
    "notice that the argument holds even when agents know the graph in which they operate .",
    "our second negative result shows that the assumption about the knowledge of an upper bound on the size of the graph can not be removed from theorem [ main ] .",
    "[ no - bound ] there is no algorithm that accomplishes leader election regardless of the adversary for all initial configurations satisfying condition _",
    "ce_.    suppose for a contradiction that such a universal algorithm @xmath105 exists .",
    "consider an `` almost ''",
    "oriented ring of size @xmath106 : ports 0,1 are in the clockwise direction at each node except one , where they are counterclockwise .",
    "this node is called _",
    "special_. the initial configuration on this ring consists of two agents : one at the special node , and one at the neighbor clockwise from it .",
    "call this configuration @xmath107 ( cf . fig .",
    "[ fig : negative ] ( a ) ) .",
    "this configuration satisfies condition ce : agents have different views .",
    "hence algorithm @xmath105 must elect a leader for this configuration , regardless of the adversary .",
    "consider a `` perfectly synchronous '' adversary that starts the execution of the algorithm simultaneously for all agents and moves all of them with the same constant speed .",
    "it induces rounds corresponding to edge traversals by all agents .",
    "suppose that a leader is elected for this adversary after @xmath14 rounds .",
    "now consider a ring of size @xmath108 in which there are @xmath109 special nodes at distances @xmath106 : at these nodes ports 0,1 are in the counterclockwise direction , and in all other nodes they are in the clockwise direction .",
    "the initial configuration consists of @xmath110 agents .",
    "there is an agent at every special node and at every clockwise neighbor of a special node .",
    "additionally there is an agent at the counterclockwise neighbor of one special node . call this configuration @xmath111 ( cf .",
    "[ fig : negative ] ( b ) ) .",
    "this configuration satisfies condition ce .",
    "indeed , due to the single group of three consecutive agents , all agents have distinct enhanced views .",
    "on the other hand , agents at special nodes have a different view from agents at clockwise neighbors of special nodes .",
    "hence algorithm @xmath105 must elect a leader for this configuration as well , regardless of the adversary .",
    "consider the same `` perfectly synchronous '' adversary as before .",
    "consider the agent @xmath29 in the configuration @xmath111 that is initially situated at the special node @xmath28 antipodal to the special node with both neighbors hosting agents .",
    "consider the agent @xmath94 initially situated at the special node @xmath112 that is clockwise from @xmath28 and closest to @xmath28 . in the first @xmath14 rounds of the execution of @xmath105 starting from configuration @xmath111 , memory states of agents @xmath29 and @xmath94 are identical to memory states of the agent @xmath95 initially situated at the special node of configuration @xmath107 .",
    "this is due to the large size of the ring in configuration @xmath111 .",
    "hence if in configuration @xmath107 agent @xmath95 elects itself , then in configuration @xmath111 agents @xmath29 and @xmath94 elect each of them itself as the leader after @xmath14 rounds .",
    "if in configuration @xmath107 agent @xmath95 elects its neighbor , then in configuration @xmath111 agents @xmath29 and @xmath94 elect each of them their neighbor as the leader after @xmath14 rounds . in both cases two different agents are elected , which is a contradiction .",
    "in this section we present an algorithm that elects a leader for all initial configurations satisfying condition ec , assuming that an upper bound on the size of the graph is known to all agents . in view of proposition",
    "[ no - bound ] , this assumption can not be removed .",
    "this upper bound , denoted by @xmath22 , is an input of our algorithm .",
    "the section is divided into three subsections . in the first subsection we provide additional terminology and notation , as well as some auxiliary results used in the algorithm and in its analysis . in the second subsection",
    "we give the intuitive overview of the algorithm and its formal description , and we provide some illustrative examples of its functioning .",
    "finally , the third subsection is devoted to the proof that the algorithm is correct .",
    "let @xmath34 be a graph and let @xmath28 be any node of @xmath34 . for any integer @xmath113 , we define the _ code _ of @xmath114 as the sequence @xmath115 of integers obtained as follows .",
    "perform the complete depth first search traversal of @xmath114 , starting at its root , in such a way that at each node an edge with a smaller port number is selected prior to an edge with a larger port number . then , if @xmath116 is the @xmath100-th traversed edge , when going from @xmath55 to @xmath117 during the traversal of @xmath116 , then the @xmath118-th and @xmath119-th elements of @xmath115 are the port numbers of @xmath116 at @xmath55 and @xmath117 , respectively .",
    "the following is a direct consequence of this definition .",
    "[ prop : codes_distinguish ] let @xmath41 and @xmath28 be any nodes of @xmath34 and let @xmath113 be an integer .",
    "@xmath120 if and only if @xmath121 .",
    "@xmath122    let @xmath113 be an integer .",
    "we extend the notion of binary mappings to the truncated views .",
    "we say that @xmath4 is a _ binary mapping _ for @xmath114 , if @xmath4 assigns either @xmath51 or @xmath52 to each node of @xmath114 .",
    "if @xmath4 is a binary mapping for @xmath123 ( or for @xmath124 for some @xmath125 ) , then @xmath126 ( where @xmath127 , respectively ) refers to @xmath4 restricted to the nodes of @xmath114 .",
    "given two binary mappings @xmath128 for @xmath114 , we write @xmath129 if @xmath130 for each node @xmath55 of @xmath114 . if @xmath131 is the enhanced view from @xmath28 and @xmath132 is a binary mapping for @xmath114 such that @xmath133 , then the pair @xmath134 is called a _ partially enhanced view _ from @xmath28 . intuitively , in a partially enhanced view only some nodes corresponding to initial positions of agents are marked .",
    "let @xmath131 be the enhanced view from @xmath28 , where @xmath28 is selected so that there exists an agent @xmath80 with @xmath135 .",
    "then , @xmath136 is called the _",
    "complete identifier _ of @xmath80 .",
    "the significance of the notion of a complete identifier is the following .",
    "an agent can never get the entire view or the entire enhanced view , as these are infinite objects . however ,",
    "the following propositions from @xcite show that to differentiate two views or two enhanced views , it is enough to consider their truncations to depth @xmath137",
    ". thus , as stated in corollary  @xmath138 , complete identifiers identify agents with different enhanced views .",
    "[ prop : no ] for a @xmath22-node graph @xmath34 and for all nodes @xmath41 and @xmath28 of @xmath34 ,",
    "@xmath139 if and only if @xmath140 . @xmath122    [ prop : no2 ] for a @xmath22-node graph @xmath34 , for all nodes @xmath41 and @xmath28 of @xmath34 , if @xmath141 and @xmath142 are the enhanced views from @xmath41 and @xmath28 , respectively , then @xmath143 if and only if @xmath144 .",
    "@xmath122    [ cor : no2 ] for a @xmath22-node graph @xmath34 and for any agents @xmath80 and @xmath82 , the enhanced views from @xmath81 and @xmath83 are equal if and only if the complete identifiers of @xmath80 and @xmath82 are equal .",
    "@xmath122    a sequence of the form @xmath145 is called a _ label _ , if the following conditions hold :    1 .",
    "@xmath28 is a node of @xmath34 , and @xmath113 and @xmath146 are integers , 2 .",
    "@xmath147 is a binary mapping for @xmath114 for each @xmath148 .",
    "@xmath18 is the binary mapping for @xmath114 that assigns @xmath52 only to the root , and @xmath149 for every index @xmath150 .",
    "moreover , we say that @xmath151 is the _ length _ of the label @xmath152 , denoted by @xmath153 .",
    "let @xmath154 be the set of all labels of length at most @xmath151 .",
    "in this section we give a high - level description of the algorithm and its pseudo - code formulation .",
    "an important ingredient of the algorithm are meetings between agents during which information is exchanged .",
    "the method that guarantees that some meetings between pairs of agents will occur uses the idea of tunnels introduced in @xcite .",
    "the routes @xmath155 and @xmath86 form a _ tunnel _ if @xmath156 for some @xmath157 and for some @xmath158 .",
    "moreover , we say that the route @xmath159 is the _ tunnel core with respect to _ @xmath59 .",
    "note that if @xmath160 is the tunnel core with respect to @xmath59 , then @xmath161 is the tunnel core with respect to @xmath86 .",
    "[ prop : tunnel ] let @xmath162 be an agent with route @xmath163 , @xmath164 . if @xmath16 and @xmath17 form a tunnel with the tunnel core @xmath165 , then @xmath166 and @xmath167 are guaranteed to have a meeting such that @xmath168 and @xmath169 are the routes of the agents traversed till the meeting , where @xmath170 .",
    "@xmath122    informally speaking , if the routes of two agents form a tunnel , then they are guaranteed to have a meeting with the property that the routes traversed to date by the agents give ( by taking one of the routes and the reversal of the other ) the tunnel core .",
    "let @xmath171 be the set of all integer sequences with terms in @xmath172 , whose length is even and equals at most @xmath173 .",
    "then , we define @xmath174 and let @xmath175 be the @xmath100-th triple in @xmath176 , @xmath177",
    ".    in our leader election algorithm we will proceed in phases , and in each phase the label of each agent is fixed .",
    "( due to the fact that the model is asynchronous , the adversary may force the agents to be in different phases in a particular point of time . )",
    "the total number of phases for each agent is @xmath178 .",
    "after the first phase each agent computes its label used in phase @xmath179 .",
    "these labels are defined in such a way that there exist two agents @xmath80 and @xmath82 with different labels .",
    "the aim of phase @xmath179 is that agents @xmath80 and @xmath82 correctly identify each other s initial positions in their respective views . after phase @xmath178",
    "every agent can identify the initial positions of all agents in its view and hence is able to perform leader election .",
    "the label of an agent @xmath80 used in phase @xmath25 is denoted by @xmath180 , @xmath181 .",
    "label @xmath182 is computed before the start of phase @xmath52 , and @xmath183 is computed at the end of phase @xmath25 , for @xmath181 .",
    "label @xmath184 is used to elect the leader at the end of the algorithm .",
    "each phase is divided into @xmath185 stages . by @xmath186",
    "we denote the route traversed by agent @xmath80 till the end of stage @xmath187 in phase @xmath25 , @xmath181 , @xmath188 .",
    "as we prove later , each agent @xmath80 starts and ends each stage at its initial position @xmath81 .",
    "let @xmath189 be the route of an agent @xmath80 traversed till the beginning of phase @xmath25 , and hence till the end of phase @xmath190 , whenever @xmath191 .",
    "hence , @xmath192 is the route traversed by @xmath80 prior to the beginning of the first phase .",
    "now we give an informal description of algorithm @xmath193 .",
    "this algorithm is executed by each agent , and @xmath80 in the pseudo - code is used to refer to the executing agent .",
    "note that the upper bound @xmath22 on the number of nodes of @xmath34 is given as an input .",
    "the pseudo - code of the algorithm and pseudo - codes of its subroutines are in frames . in the informal description",
    "we refer to lines of these pseudo - codes .",
    "first , we discuss procedure  @xmath194 that is called at the beginning of algorithm @xmath193 .",
    "the agent starts by computing @xmath176 .",
    "this can be done knowing @xmath22 , without any exploration of the graph .",
    "then , the agent computes @xmath195 by performing a dfs traversal of @xmath34 to the depth @xmath196 ( line  @xmath197 ) .",
    "the function @xmath198 is set ( line  @xmath199 ) to be the binary mapping for @xmath195 that assigns @xmath51 to all nodes of @xmath195 except for the root .",
    "hence , @xmath200 is a partially enhanced view from @xmath81 .",
    "the value of @xmath182 , that will be the label of @xmath80 in the first phase , is set to @xmath201 ( line  @xmath202 ) .",
    "now we informally describe the main part of algorithm @xmath193 , refering to the lines of the pseudo - code given below .",
    "the @xmath25-th iteration of the main ` for ' loop in lines @xmath197-@xmath203 is responsible for the traversal performed by the agent in phase @xmath25 , @xmath204 .",
    "an internal ` for ' loop in lines @xmath199-@xmath205 is executed and its @xmath187-th iteration determines the behavior of @xmath80 in stage @xmath187 .",
    "the stage @xmath187 of each phase ` processes ' the @xmath187-th element @xmath206 of @xmath176 .",
    "if @xmath207 , then the agent @xmath80 does not move in this stage and proceeds to the next one .",
    "otherwise let @xmath208 ( we describe only this case as the other one is symmetric ) . the agent checks in line",
    "@xmath209 whether a certain trail @xmath210 is feasible from @xmath81 , and if it is not , then the stage ends .",
    "as we prove later , the verification of the feasibility of @xmath210 can be done by inspecting @xmath195 .",
    "if @xmath210 is feasible from @xmath81 , then @xmath80 follows the route @xmath211 ( line  @xmath212 ) , which guarantees that :    * if the agent @xmath80 is located at @xmath81 at the beginning of stage @xmath187 , then @xmath80 is located at @xmath81 at the end of stage @xmath187 ( see lemma  [ lem : closed ] ) , and * if the route @xmath213 leads from @xmath81 to the initial position of another agent @xmath82 and @xmath214 , then the routes @xmath186 and @xmath215 form a tunnel .",
    "the agent ends phase @xmath25 by updating its label .",
    "this is done by calling function @xmath216 in line  @xmath217 , which produces a binary mapping @xmath198 that is used to update the label in line  @xmath218 . after completing the tree phases ( for @xmath181 ) the agent calls procedure @xmath219 which completes the task of leader election .",
    "in order to formally describe the trail @xmath220 mentioned above we need the following notation .",
    "let @xmath221 be a label of length @xmath222 , let @xmath223 and let @xmath28 be a node of @xmath34 .",
    "we define @xmath224 to be the trail that corresponds to the route performed till the end of stage @xmath187 of phase @xmath25 by an agent @xmath82 whose label equals @xmath225 in phase @xmath25 , @xmath226 , and whose initial position corresponds to the root of the truncated view @xmath227 in @xmath225 .",
    "we prove ( see lemma  [ lem : history_simulation ] ) that , for any @xmath91 and @xmath187 the trail @xmath228 can be computed on the basis of @xmath152 and @xmath187 .",
    "the trail @xmath220 mentioned above is @xmath229 .",
    "figure  [ fig : tunnel ] illustrates the routes of a pair of agents @xmath80 and @xmath82 that execute one iteration of the internal ` for ' loop in lines @xmath199-@xmath205 of @xmath193 , for the same values of @xmath25 and @xmath187 , such that @xmath230 .",
    "we assume in this example that @xmath213 leads from @xmath81 to @xmath83 in @xmath34 .",
    "figure  [ fig : tunnel ] gives the prefixes of two routes @xmath186 and @xmath215 traversed by the two agents .",
    "the fact that the routes form a tunnel ( as shown in figure  [ fig : tunnel ] ) follows from lemma  [ lem : guaranteed_t_confirmation ] proven later .    the routes in figure  [ fig : tunnel ] are extended to @xmath186 and @xmath215 once @xmath80 goes from @xmath83 to its initial position @xmath81 by following the route @xmath231 in @xmath34 , and @xmath82 follows @xmath213 in order to return to @xmath83 , respectively .",
    "note that the routes @xmath232 , @xmath233 and @xmath213 are not edge disjoint .",
    "although we use tunnels , we use them differently from @xcite .",
    "first , we are able to construct much simpler routes that form tunnels .",
    "this is due to the fact that @xcite deals with the rendez - vous problem in finite graphs of unknown size and in infinite graphs .",
    "as argued before , for leader election we have to assume that an upper bound @xmath22 on the size of the graph is known , and we take advantage of knowing @xmath22 to construct ` shorter ' tunnels which simplifies our analysis .",
    "second and more importantly , it is not sufficient for our purposes to just generate a meeting for a particular pair of agents  the meetings are generated to perform the exchange of information .",
    "in particular , as a result of a meeting that occurs in a tunnel an agent should be able to determine the node ( in its own view ) corresponding to the initial position of the other agent .",
    "this leads us to the following concept of meetings with ` confirmation ' of a trail .",
    "[ def : confirms ] let @xmath234 .",
    "suppose that agents @xmath80 and @xmath82 meet .",
    "we say that @xmath80 _ confirms _ @xmath70 as a result of this meeting if    1 .",
    "[ it : confirms : stage ] @xmath80 is in stage @xmath187 of phase @xmath25 and @xmath82 is in stage @xmath235 of phase @xmath236 , where @xmath237 , or @xmath238 and @xmath239 , 2 .",
    "[ it : confirms : label ] @xmath240 , where @xmath241 , 3 .",
    "[ it : confirms : trail ] if @xmath242 and @xmath243 are the trails traversed by @xmath80 and @xmath82 , respectively , till the meeting , then @xmath244 where @xmath245 and @xmath246 when @xmath208 , and @xmath247 and @xmath248 otherwise .",
    "as we prove in section  [ subsec : alg : analysis ] , if an agent @xmath80 confirms @xmath70 as a result of a meeting with @xmath82 , then @xmath249 .",
    "figure  [ fig : verification ] depicts the equation in part [ it : confirms : trail ] of definition  [ def : confirms ] .",
    "figure  [ fig : verification](a ) presents the trail @xmath250 that is a perfix of the trail corresponding to the route @xmath186 followed by the agent @xmath80 till the end of stage @xmath187 of phase @xmath25 .",
    "figure  [ fig : verification](b ) presents the trails @xmath242 ( dashed line ) and @xmath243 ( dotted line ) .",
    "it remains to describe function @xmath216 and procedure @xmath219 that are called in the algorithm @xmath193 .",
    "we start by giving intuition of the first of them .",
    "this procedure is crucial for the entire algorithm , as it takes advantage of memory state exchanges between agents that meet and permits every agent to insert initial positions of all agents in its view .",
    "this in turn allows the agents to learn asymmetries in the initial configuration and thus correctly perform leader election .",
    "function @xmath216 takes as an input the current memory state of an agent @xmath80 and returns a binary mapping @xmath198 for its view @xmath195 , such that @xmath200 is a partially enhanced view for agent @xmath80 .",
    "agent @xmath80 considers memory states @xmath251 of all previously met agents at the times of the meetings .",
    "the memory state @xmath252 , @xmath157 , of an agent @xmath82 and the memory state of @xmath80 at the time of their meeting permit the agent @xmath80 to verify whether @xmath80 or @xmath82 confirmed @xmath70 as a result of their meeting .",
    "if one of the agents confirms @xmath70 , then @xmath80 takes the advantage of this fact to determine the nodes of its view corresponding to initial positions of agents . in particular",
    ", @xmath80 is able to locate a node in its own view that corresponds to the initial position of @xmath82 , because there exists a route corresponding to @xmath70 and connecting the initial positions of the two agents . afterwards",
    ", if this route is of length at most @xmath137 , then @xmath80 recursively calls function @xmath216 for the memory state @xmath252 ( which is shorter than the current memory state of @xmath80 and thus recursion is correct ) .",
    "hence , @xmath80 can compute the binary mappings corresponding to memory states of all previously met agents at the times of the meetings . using trails between initial positions of these agents and @xmath81 , as well as the obtained binary mappings , agent @xmath80",
    "can correctly position all partially enhanced views of these agents in its own view .",
    "a call to function @xmath216 at the end of phase @xmath25 executed by agent @xmath80 permits to compute @xmath183 .    in the formulation of function",
    "@xmath216 we use the following notions .",
    "let @xmath41 and @xmath28 be two nodes of @xmath34 .",
    "we say that a function @xmath253 assigning to each node of @xmath254 a node of @xmath255 is a _ transition _ from @xmath254 to @xmath255 , if @xmath256 and @xmath55 correspond to the same node of @xmath34 for each node @xmath55 of @xmath254 . for any trail @xmath70 and any node @xmath28",
    ", we say that a node @xmath55 at depth @xmath100 in @xmath49 is at the end of @xmath70 from the root , if the length of @xmath70 is @xmath257 and the sequence of ports corresponding to the simple path from the root of @xmath49 to @xmath55 is  @xmath70 .",
    "in the following example we illustrate one iteration of the ` for ' loop in lines  @xmath199-@xmath258 of function  @xmath216 . the graph @xmath34 is given in figure  [ fig : meeting](a ) , and let @xmath259 be an upper bound that was initially provided to each agent .    ;",
    "( b ) @xmath260 ; a subtree of @xmath261    the black nodes of @xmath34 are the initial positions of some agents .",
    "denote by @xmath262 and @xmath263 the agents whose initial positions are @xmath264 and @xmath265 , respectively .",
    "note that the views from any two nodes of @xmath34 are identical in this case .",
    "however , the enhanced view from each node of @xmath34 is unique .",
    "we focus on the instance of function  @xmath216 executed by @xmath263 during its meeting with @xmath266 . for simplicity , we show only some subtrees of @xmath267 and @xmath268 in figures  [ fig : meeting](b ) and  [ fig : meeting](c ) , respectively .",
    "note that the nodes of @xmath34 , and therefore the nodes of any view , are unlabeled and we provide the labels only for the illustrative purpose . in this example",
    "the trail @xmath269 , computed in line  @xmath202 of function @xmath216 equals @xmath270 , which determines the node of the truncated view @xmath267 that corresponds to the root of @xmath268 . the black nodes of both views correspond to the initial positions of agents that @xmath263 and @xmath266 determined prior to this meeting .",
    "the dotted arrows give the part of the transition @xmath253 that maps the nodes of @xmath271 to the black nodes of @xmath268 .",
    "it follows from the definition of the view that , in general , more than one node of @xmath272 can be mapped by @xmath253 to a node of @xmath273 .",
    "we finally present procedure @xmath219 that is called by algorithm @xmath193 after the third phase .",
    "the leader is selected by an agent @xmath80 on the basis of the label @xmath274 .",
    "let @xmath55 be a node at depth at most @xmath137 in @xmath195 and satisfying @xmath275 .",
    "let @xmath276 be a subtree of depth @xmath137 of @xmath195 rooted at @xmath55 .",
    "we prove later that the pair @xmath277 is the complete identifier of some agent .",
    "since the initial positions of all agents have been detected till the end of phase @xmath178 , the agent can determine all complete identifiers and hence elect the leader .",
    "this section is devoted to the proof that algorithm @xmath193 correctly elects a leader whenever an initial configuration satisfies condition @xmath278 , regardless of the actions of the adversary .",
    "the proof is split into a series of lemmas .",
    "the role of the first lemma is to show that knowing @xmath279 is enough to check if a trail of any length is feasible from @xmath28 .",
    "[ lem : view_extension ] let @xmath28 be any node of @xmath34 . using @xmath279 ,",
    "the truncated view @xmath114 can be computed for any positive integer @xmath37 .",
    "if @xmath280 , then @xmath114 is a subtree of @xmath279 , so we may assume that @xmath281 .",
    "we extend the view @xmath282 to @xmath283 for each @xmath284 . to this end",
    "we perform the following computation for each node @xmath55 at depth @xmath285 of @xmath286 .",
    "let @xmath41 be the node of @xmath34 that corresponds to @xmath55 .",
    "note that the subtree of @xmath286 rooted at @xmath55 and containing all descendants of @xmath55 in @xmath286 is equal to @xmath287 .",
    "hence , there exists a node @xmath288 in @xmath289 such that @xmath288 corresponds to @xmath41 , in view of the connectedness of @xmath34 .",
    "this implies that there exists a node @xmath117 in @xmath289 such that the subtree of @xmath279 consisting of @xmath117 and all its descendants to depth @xmath137 from @xmath117 is equal to @xmath287 .",
    "hence , one can find any such node @xmath117 of @xmath289 .",
    "let @xmath290 be the node of @xmath34 that corresponds to @xmath117 . due to proposition  [ prop : no ] , @xmath291 is equal to @xmath292 .",
    "since @xmath117 belongs to @xmath289 we obtain that @xmath291 is a subtree of @xmath286 rooted at @xmath117 , and therefore we can extend the subtree @xmath287 by replacing in @xmath286 the subtree rooted at @xmath55 with @xmath291 .",
    "[ cor : other_views_computable ] let @xmath28 be any node of @xmath34 and let @xmath55 be any node of @xmath279 . then , the subtree of @xmath123 to depth @xmath37 and rooted at @xmath55 can be computed for any @xmath113 , using @xmath279 .",
    "@xmath122    [ cor : trail_verification ] let @xmath70 be any trail and let @xmath28 be any node of @xmath34 . using @xmath279",
    "it can be verified if @xmath70 is feasible from @xmath28 in @xmath34 .",
    "@xmath122    the next lemma shows that given any label @xmath152 of the agent and the stage number @xmath187 , it is possible to compute the trail @xmath228 which , informally speaking , is the history of the moves of the agent with label @xmath152 till this stage .",
    "[ lem : history_simulation ] using a label @xmath293 and an integer @xmath223 , the trail @xmath228 can be computed .",
    "suppose that @xmath152 is of length @xmath25 , @xmath204",
    ". by definition , @xmath294 , where @xmath147 is a binary mapping for @xmath273 and @xmath28 is a node of @xmath34 .",
    "first note that @xmath273 can be reconstructed from its code .",
    "suppose that @xmath80 is an agent whose initial position is @xmath28 and whose label in phase @xmath25 is @xmath152 , @xmath295 .",
    "the trail @xmath228 can be computed by simulating the execution of algorithm @xmath193 for the agent @xmath80 . by its formulation ,",
    "the agent @xmath80 executed procedure @xmath194 , @xmath190 iterations of the main ` for ' loop in lines @xmath197-@xmath203 of algorithm @xmath193 , and exactly @xmath187 iterations of the nested ` for ' loop in lines @xmath199-@xmath205 of algorithm @xmath193 in the @xmath25-th iteration of the main ` for ' loop .",
    "thus results in traversing the route @xmath296 .",
    "note that @xmath34 is unknown to @xmath80 , but we will reconstruct the route by simulating edge traversals in @xmath123 .",
    "( while @xmath123 is infinite , it can be reconstructed from @xmath273 to any finite depth , using corollary [ cor : trail_verification ] . )",
    "we prove the lemma by induction on the total number of stages ` processed ' by an agent .",
    "note that if @xmath297 and @xmath298 , then the trail @xmath228 corresponds to the route that is the dfs traversal of @xmath34 to depth @xmath299 and starting at @xmath28 .",
    "this trail can be obtained by performing the dfs traversal of @xmath273 that starts and ends at the root .",
    "now assume that @xmath300 . in order to simulate the behavior of @xmath80 in any stage @xmath151 , @xmath301 , of phase @xmath100 , @xmath302 , one needs to know @xmath303 . by construction , @xmath304 .",
    "the induction hypothesis and corollary  [ cor : trail_verification ] imply that the second part of the condition in line  @xmath209 of algorithm @xmath193 can be checked . if @xmath305 , where @xmath306 , then @xmath80 does not move in stage @xmath151 of phase @xmath100 .",
    "hence , assume without loss of generality that @xmath307 .",
    "this implies that @xmath80 executes the instruction in line  @xmath212 of algorithm @xmath193 . by the induction hypothesis ,",
    "the trail @xmath308 in lines @xmath209 and @xmath212 can be computed on the basis of @xmath309 and @xmath151 .",
    "we say that a route @xmath59 is _ closed _ if @xmath310 .",
    "the following lemma implies that at the end of each stage each agent comes back to its initial position .",
    "[ lem : closed ] let @xmath80 be any agent . for every @xmath204 and for every @xmath311 the route @xmath186 is closed .",
    "denote by @xmath312 the route that the agent @xmath80 follows in stage @xmath187 , @xmath223 , of phase @xmath25 , @xmath204 .",
    "we prove the lemma by induction on the total number of stages processed in all phases by an agent .",
    "first note that @xmath192 , i.e. , the route of @xmath80 performed as a result of the execution of line  @xmath197 of procedure @xmath194 is closed .",
    "hence , it remains to prove that if @xmath215 is closed for each agent @xmath82 , for some @xmath204 and for some @xmath313 , then @xmath314 is closed as well .",
    "note that @xmath315 .",
    "hence , @xmath316 and therefore it is enough to argue that @xmath317 is closed .",
    "let @xmath318 .",
    "if @xmath207 , then according to lines  @xmath209 and  @xmath319 of algorithm @xmath193 , @xmath320 is empty , i.e. @xmath80 does not move in stage @xmath321 of phase @xmath25 . in this case",
    "the proof is completed .",
    "otherwise , we obtain that @xmath322 where @xmath323 and @xmath324 ( see lines  @xmath212 and  @xmath325 of algorithm @xmath193 ) .",
    "let @xmath326 .",
    "hence , @xmath317 is closed if and only if @xmath327 is closed . however , by definition , the latter route equals @xmath215 for an agent @xmath82 such that its initial position is @xmath41 and @xmath328 ( if such an agent exists ) .",
    "it follows from the induction hypothesis that @xmath215 is closed , which completes the proof of the lemma .",
    "the next lemma shows the importance of confirmation of a trail .",
    "it implies that if an agent @xmath80 confirms @xmath70 as a result of a meeting with @xmath82 , then it can correctly situate the initial position of @xmath82 in its view .",
    "[ lem : tconfirmation ] let @xmath204 , let @xmath223 and let @xmath240 .",
    "let @xmath80 be an agent such that @xmath241 .",
    "suppose that the agent @xmath80 meets an agent @xmath82 , when @xmath80 is in stage @xmath187 of phase @xmath25 .",
    "if @xmath80 confirms @xmath70 as a result of this meeting , then @xmath329 , where @xmath245 if @xmath208 and @xmath247 if @xmath330 .",
    "suppose without loss of generality that @xmath331 .",
    "condition [ it : confirms : trail ] in definition  [ def : confirms ] implies that the route @xmath332 leads from @xmath81 to @xmath83 in @xmath34 .",
    "let @xmath326 .",
    "by lemma  [ lem : closed ] , both @xmath232 and @xmath333 are closed .",
    "this implies that @xmath334 as required .",
    "the following lemma shows that processing an appropriate triple @xmath335 by two agents guarantees their meeting confirming @xmath70 .",
    "[ lem : guaranteed_t_confirmation ] let @xmath204 .",
    "let @xmath80 and @xmath82 be two agents such that @xmath336 for some @xmath234 and @xmath223 . if @xmath337 , then prior to the first moment when one of the agents completes phase @xmath25 , the agents @xmath80 and @xmath82 have a meeting as a result of which either @xmath80 or @xmath82 confirms @xmath70 .",
    "suppose without loss of generality that @xmath80 ends the traversal of @xmath232 at the same time or earlier than @xmath82 ends the traversal of @xmath233 .",
    "let @xmath312 be the route traversed by @xmath80 in stage @xmath187 of phase @xmath25 .",
    "by lemma  [ lem : closed ] , @xmath338 .",
    "the route @xmath312 is constructed as a result of the execution of lines @xmath209-@xmath212 of algorithm @xmath193 by @xmath80 . since @xmath339 in line @xmath212 of algorithm @xmath193",
    ", we obtain that @xmath312 and @xmath215 form a tunnel with the tunnel core @xmath340 . by proposition  [ prop :",
    "tunnel ] , @xmath80 and @xmath82 will have a meeting while @xmath80 is in stage @xmath187 of phase @xmath25 and before @xmath82 ends the traversal of @xmath215 .",
    "this implies that [ it : confirms : stage ] of definition  [ def : confirms ] holds .",
    "moreover , [ it : confirms : label ] of definition  [ def : confirms ] is satisfied by assumption .",
    "let @xmath242 and @xmath243 be the trails traversed by @xmath80 and @xmath82 , respectively , till the meeting . by proposition  [ prop :",
    "tunnel ] , @xmath341 , where @xmath160 is the tunnel core .",
    "this proves that [ it : confirms : trail ] of definition  [ def : confirms ] holds .",
    "hence , the agent @xmath80 confirms @xmath70 as a result of the meeting .",
    "the role of the next lemma is to show that an agent never marks falsely an initial position of another agent in its view .",
    "[ lem : no_false_noting ] let @xmath342 be the label of any agent @xmath80 in phase @xmath204 . if @xmath55 is any node of @xmath195 corresponding to a node of @xmath34 that is not an initial position of an agent , then @xmath343 .",
    "suppose for a contradiction that an agent @xmath80 sets @xmath344 to be @xmath52 , and @xmath55 corresponds to a node of @xmath34 that is not an initial position of an agent .",
    "suppose that the input memory state @xmath345 of the agent @xmath80 is the shortest that satisfies this property .",
    "this assumption implies that if @xmath132 is computed by agent @xmath80 in line  @xmath325 of function @xmath216 for any memory state @xmath252 , @xmath148 , then @xmath346 is a partially enhanced view from @xmath28 , where @xmath28 corresponds to the node @xmath55 at the end of @xmath269 from the root in @xmath195 .",
    "hence , if @xmath28 is an initial position of an agent , then , due to the definition of transition , each node @xmath117 from line  @xmath217 of function @xmath216 corresponds to an initial position of an agent .",
    "the latter implies that the assignment of @xmath52 to @xmath344 occurs in line  @xmath212 of @xmath216 , as a consequence of a meeting with some agent @xmath82 whose memory state was @xmath252 at the time of the meeting .",
    "hence , @xmath55 is at the end of @xmath269 from the root in @xmath195 . due to line @xmath209 of @xmath216",
    ", either @xmath80 or @xmath82 confirms @xmath70 as a result of their meeting . by lemma  [ lem : tconfirmation ] , @xmath347 , where @xmath323 is determined in line  @xmath202 of @xmath216 .",
    "thus , @xmath83 corresponds to the node at the end of @xmath269 from the root in @xmath195 .",
    "the latter implies that @xmath83 corresponds to @xmath55 , contradicting our assumption .",
    "the next lemma is a companion result to lemma  [ lem : no_false_noting ] .",
    "it says that if an agent confirms a trail @xmath70 as a result of a meeting with @xmath82 , then both of them correctly mark their respective initial positions in their views .",
    "[ lem : updatef ] let @xmath204 .",
    "let @xmath80 and @xmath82 be two agents with labels @xmath348 and @xmath349 . if agent @xmath80 confirms @xmath70 as a result of a meeting with agent @xmath82 in phase @xmath236 , @xmath350 , then    1 .",
    "@xmath351 , where @xmath55 is at the end of @xmath269 from the root in @xmath195 , such that @xmath323 and @xmath249 .",
    "@xmath352 , where @xmath288 is at the end of @xmath353 from the root in @xmath227 , and @xmath354 .",
    "suppose that @xmath80 is in some stage of phase @xmath236 , @xmath350 , when a meeting with @xmath82 occurs as a result of which @xmath80 confirms @xmath70 .",
    "hence , one of the memory states in line  @xmath197 of function @xmath216 called at the end of phase @xmath25 is the memory state @xmath252 , @xmath157 , of @xmath82 at the time of the meeting .",
    "we consider the @xmath100-th iteration of the ` for ' loop in lines @xmath199-@xmath258 of function @xmath216 , i.e. , informally speaking , the iteration in which @xmath80 ` analyzes ' the meeting with @xmath82 .",
    "the agent @xmath80 determines in line  @xmath209 of function @xmath216 the fact that either @xmath80 or @xmath82 confirms @xmath70 as a result of the meeting .",
    "then , in line  @xmath212 of function @xmath216 , @xmath344 is set to @xmath52 , where @xmath55 is at the end of @xmath269 from the root of @xmath195 . by lemma  [ lem : tconfirmation ] and by the choice of @xmath269 in line  @xmath202 of function @xmath216",
    ", @xmath55 corresponds to @xmath83 .",
    "function @xmath216 returns @xmath198 .",
    "due to line  @xmath218 of algorithm @xmath193 , @xmath351 .    in order to prove the second part of the lemma notice that agent @xmath82 has also access to the memory states of @xmath80 and @xmath82 at the time of the meeting .",
    "hence , upon completing phase @xmath25 it performs analogous computations as @xmath80 during its execution of function @xmath216 at the end of phase @xmath25 and sets @xmath352 .",
    "let @xmath80 be an agent and let @xmath55 be a node of the truncated view @xmath195 at the end of a trail @xmath70 from the root of @xmath195 .",
    "if the agent @xmath80 sets @xmath355 during the execution of function @xmath216 and @xmath55 corresponds to the initial position of some agent @xmath82 , then we say that @xmath80 _ noted @xmath82 on @xmath70_.    a label @xmath356 , where @xmath204 , of an agent @xmath80 is _ complete with respect to _",
    "@xmath82 if @xmath357 for each node @xmath55 of @xmath195 that corresponds to an initial position of @xmath82 .",
    "we say that @xmath152 is _ semi - complete with respect to _",
    "@xmath82 if @xmath357 for each node @xmath55 that corresponds to an initial position of @xmath82 and belongs to a level @xmath358 of @xmath359",
    ".    the next lemma explains how agents confirm trails as a result of their meetings .",
    "agents with different labels can confirm any trail in @xmath171 between their initial positions , while agents with equal labels are able to confirm only ` palindromes ' .",
    "[ lem : label_complete ] let @xmath204 and let @xmath80 and @xmath82 be any two agents .    1 .",
    "[ it : different_labels ] if @xmath360 , then @xmath183 is complete with respect to @xmath82 .",
    "[ it : identical_labels ] if @xmath361 , then prior to the end of its phase @xmath25 the agent @xmath80 has noted @xmath82 on each trail @xmath70 such that @xmath234,@xmath85 and @xmath362 .    to prove [ it : different_labels ] let @xmath234 be any trail such that @xmath213 leads from @xmath81 to @xmath83 in @xmath34 .",
    "by construction of @xmath176 , @xmath363 for some index @xmath364 , because @xmath360 . by lemma  [ lem : guaranteed_t_confirmation ] ,",
    "one of the agents @xmath80 or @xmath82 confirms @xmath70 as a result of a meeting that occurs when it is in phase @xmath25 .",
    "this is done by checking the conditions [ it : confirms : stage ] , [ it : confirms : label ] and [ it : confirms : trail ] in definition  [ def : confirms ] , which can be accomplished by analyzing the memory states of @xmath80 and @xmath82 at the time of the meeting . by lemma  [ lem : updatef ] , @xmath355 , where @xmath55 is at the end of @xmath70 in @xmath195 ,",
    "regardless of which agent confirmed @xmath70 as a result of the meeting .",
    "the proof of [ it : identical_labels ] is analogous .    [",
    "lem : phase1 ] there exist two agents @xmath80 and @xmath82 such that @xmath365 .    if there exist two agents @xmath80 and @xmath82 with different views , @xmath366 , then by proposition  [ prop : no ] , @xmath367 .",
    "proposition  [ prop : codes_distinguish ] implies @xmath368 , and consequently @xmath365 .",
    "thus , assume in the following that the views from the initial positions of all agents are equal . in view of condition @xmath278 there exists a non - uniform palindrome .",
    "hence , there exist two agents @xmath369 and a trail @xmath70 , such that @xmath85 , @xmath213 leads from @xmath81 to a node @xmath41 that is an initial position of an agent @xmath370 , and @xmath371 leads from @xmath83 to a node @xmath290 that is not an initial position of any agent .",
    "let @xmath55 and @xmath288 be the nodes of @xmath195 and @xmath227 , respectively , at the end of @xmath70 from the roots .",
    "note that @xmath55 corresponds to @xmath41 and @xmath288 corresponds to @xmath290 . by lemma  [ lem : label_complete][it : identical_labels ] , @xmath80 noted @xmath370 on @xmath70 in phase @xmath52 and , by lemma  [ lem : no_false_noting ] , @xmath82 does not note any agent on @xmath70 during the entire execution of its algorithm .",
    "hence , @xmath355 and @xmath372 after the execution of procedure @xmath216 at the end of phase @xmath52 .",
    "since the views @xmath195 and @xmath227 are equal , we have @xmath373 and @xmath374 , where @xmath375 .",
    "hence , @xmath365 .",
    "the role of the next lemma is to explain indirect learning of initial positions of other agents .",
    "if two agents @xmath80 and @xmath82 have equal labels , then they mutually situate their initial positions using a third agent @xmath370 with a different label as an intermediary .",
    "such an agent exists by lemma  [ lem : phase1 ] .",
    "agents @xmath80 and @xmath82 can correctly fill their initial positions to depth @xmath376 in their views due to the fact that the intermediary @xmath370 has their initial positions to depth @xmath196 .    [",
    "lem : completetosemicomplete ] let @xmath80 and @xmath82 be two agents such that @xmath180 is complete with respect to @xmath82 , @xmath204 . if @xmath370 is any agent such that @xmath377 , then @xmath378 is semi - complete with respect to @xmath82 .    since @xmath377 we obtain , by the definition of @xmath176 , that @xmath379 for some @xmath364 , where @xmath70 is such a trail that the route @xmath380 contains at most @xmath137 edges and @xmath381 .",
    "we analyze the execution of function @xmath216 by @xmath370 at the end of phase @xmath25 . by lemma  [ lem : guaranteed_t_confirmation ] ,",
    "@xmath80 or @xmath370 confirms @xmath70 as a result of their meeting prior to the completion of phase @xmath25 by @xmath370 , i.e. , prior to the execution of function @xmath216 we consider .",
    "the agent @xmath370 learns this fact in line  @xmath209 of function @xmath216 .",
    "then , the condition in line  @xmath319 of function @xmath216 is satisfied by assumption , and @xmath370 verifies this condition by checking whether the length of @xmath70 does not exceed @xmath376 .",
    "consequently , @xmath370 finds in line  @xmath382 of function @xmath216 a transition @xmath253 that maps the node at the end of @xmath70 in @xmath383 to the root of @xmath195 , because @xmath381 . since @xmath384 is of length at most @xmath137 , @xmath370 sets @xmath385 ( in the ` for ' loop in lines @xmath205-@xmath217 of function @xmath216 ) for each node @xmath117 at depth at most @xmath376 in @xmath383 corresponding to @xmath83 .",
    "the latter is due to the fact that @xmath180 is complete with respect to @xmath82 .",
    "this proves that @xmath378 is semi - complete with respect to @xmath82 .",
    "see figure  [ fig : complete ] , where the root and some nodes that correspond to the initial position of @xmath82 have been marked on @xmath386 , and we show a transition that allows to determine all nodes in the view of @xmath370 to the depth @xmath376 corresponding to @xmath83 .    in view of the next lemma , upon completion of phase @xmath178 an agent",
    "has correctly situated all nodes corresponding to initial positions of all agents to depth @xmath376 in its view .",
    "[ lem : phase3 ] let @xmath80 be any agent . then",
    ", @xmath184 is semi - complete with respect to each agent @xmath82 .    if",
    "@xmath387 , then by lemma  [ lem : label_complete][it : different_labels ] , @xmath184 is complete with respect to @xmath82 , and therefore it is semi - complete with respect to @xmath82 .",
    "hence , suppose that @xmath388 , which implies @xmath389 .",
    "hence , lemma  [ lem : phase1 ] implies that there exists an agent @xmath370 such that @xmath390 . due to lemma",
    "[ lem : label_complete][it : different_labels ] , @xmath391 is complete with respect to @xmath82 . note that @xmath392 implies @xmath393 .",
    "lemma  [ lem : completetosemicomplete ] completes the proof .",
    "our final lemma says that any agent can correctly reconstruct complete identifiers of all other agents .",
    "this is due to the fact that every agent has filled initial positions of all agents to depth @xmath376 in its view .",
    "[ lem : complete_identifiers ] let @xmath394 be the set computed in procedure @xmath219 executed by an @xmath80 .",
    "then , for every agent @xmath82 , there exists an index @xmath395 such that @xmath396 is the complete identifier of @xmath82 and @xmath397 leads from @xmath81 to @xmath83 in @xmath34 .",
    "let @xmath274 be the label of @xmath80 obtained at the end of phase @xmath178 .",
    "initially @xmath398 is set to be empty in line  @xmath399 of procedure @xmath219 .",
    "consider the nodes @xmath28 and @xmath55 and the function @xmath132 from line  @xmath199 of procedure @xmath219 . by lemma  [ lem : no_false_noting ]",
    ", @xmath28 is an initial position of an agent @xmath370 , because @xmath400 .",
    "thus , in view of lemma  [ lem : phase3 ] , @xmath401 is the complete identifier of @xmath370 . due to lines @xmath202-@xmath212 of procedure @xmath219 , @xmath402 for some trail @xmath70 such that @xmath403 . by lemma  [ lem : phase3 ] , for any agent @xmath82",
    ", there is a node in @xmath272 corresponding to @xmath83 .",
    "this implies that , for any agent @xmath82 , the set @xmath398 contains ( at the end of the ` for ' loop in lines @xmath197-@xmath319 of procedure @xmath219 ) a pair @xmath404 , @xmath395 , such that @xmath396 is the complete identifier of @xmath82 and @xmath397 leads from @xmath81 to @xmath83 in @xmath34 .",
    "[ thm : le_part2 ] if the condition @xmath278 is satisfied for an initial configuration , then algorithm @xmath193 correctly elects a leader regardless of the actions of the adversary .",
    "let @xmath405 be the agent whose complete identifier @xmath406 is lexicographically smallest among the complete identifiers of all agents . by condition @xmath278 ( more precisely by its part saying that all enhanced views are different ) and by corollary  [ cor : no2 ] , agent @xmath405 is unique .    each agent",
    "@xmath80 computes @xmath184 as a result of the execution of algorithm @xmath193 . by lemma  [ lem : complete_identifiers ] , @xmath80 computes ( in lines @xmath399-@xmath319 of procedure @xmath219 ) , for each agent @xmath82 , the complete identifier of @xmath82 and a trail @xmath70 such that the route @xmath213 of length at most @xmath137 leads from @xmath81 to @xmath83 in @xmath34 . by corollary  [ cor : no2 ]",
    ", the complete identifiers uniquely distinguish the agents . using the lexicographic order @xmath407 on the set of all complete identifiers",
    ", the agent @xmath80 finds in line @xmath325 of procedure @xmath219 the complete identifier @xmath408 such that @xmath409 and @xmath410 for each @xmath411 such that @xmath412 for some trail @xmath269 . by definition ,",
    "then , @xmath80 decides in line  @xmath382 of procedure @xmath219 that the agent with the initial position @xmath414 is the leader .",
    "this is agent @xmath405 .",
    "theorem  [ thm : le_part2 ] , together with proposition  [ pro : negative1 ] implies our main result which is theorem  [ main ] from section  [ sec : feasibility ] .",
    "we characterized all initial configurations of agents for which leader election is possible and we constructed a universal algorithm electing a leader for all such configurations , assuming that agents know an upper bound on the size of the graph .",
    "we observed that the latter assumption can not be removed . in this paper we focused on the feasibility of leader election under a very harsh scenario in which the adversary controls the speed and the way in which agents move along their chosen routes .",
    "this adversarial scenario captures the totally asynchronous nature of mobile agents .",
    "while we gave a complete solution to the problem of feasibility of leader election , we did not try to optimize the efficiency of the algorithm , e.g. , in terms of its cost , i.e. , of the total or of the maximum number of edge traversals performed by the mobile agents .",
    "in fact , any kind of such optimization appears to be quite challenging .",
    "it is clear that in order to elect a leader agents have to meet .",
    "already the much simpler problem of optimizing the cost of meeting of two agents in our asynchronous model is open , both when agents have different labels @xcite and when they are anonymous , as in our present scenario @xcite . in particular , in the latter paper the authors asked if rendezvous of two agents can be accomplished ( whenever it is feasible ) at a cost polynomial in the size of the graph .",
    "e. bampas , j. czyzowicz , l. gasieniec , d. ilcinkas , a. labourel , almost optimal asynchronous rendezvous in infinite multidimensional grids , _ proc .",
    "24th international symposium on distributed computing ( disc 2010 ) _ , _ lncs _ 6343 , 297 - 311    p. boldi , s. shammah , s. vigna , b. codenotti , p. gemmell , and j. simon , symmetry breaking in anonymous networks : characterizations .",
    "4th israel symposium on theory of computing and systems , ( istcs 1996 _ ) , 16 - 26        j. chalopin , local computations on closed unlabelled edges : the election problem and the naming problem _ proc .",
    "31st conference on current trends in theory and practice of computer science ( sofsem 2005 ) _ , 82 - 91                              m.a .",
    "haddar , a.h .",
    "kacem , y. mtivier , m. mosbah , and m. jmaiel , electing a leader in the local computation model using mobile agents .",
    "6th acs / ieee international conference on computer systems and applications ( aiccsa 2008 _ ) , 473 - 480"
  ],
  "abstract_text": [
    "<S> we study the problem of leader election among mobile agents operating in an arbitrary network modeled as an undirected graph . </S>",
    "<S> nodes of the network are unlabeled and all agents are identical . hence the only way to elect a leader among agents is by exploiting asymmetries in their initial positions in the graph . </S>",
    "<S> agents do not know the graph or their positions in it , hence they must gain this knowledge by navigating in the graph and share it with other agents to accomplish leader election . </S>",
    "<S> this can be done using meetings of agents , which is difficult because of their asynchronous nature : an adversary has total control over the speed of agents . when can a leader be elected in this adversarial scenario and how to do it ? we give a complete answer to this question by characterizing all initial configurations for which leader election is possible and by constructing an algorithm that accomplishes leader election for all configurations for which this can be done .    * keywords : * leader election , anonymous network , asynchronous mobile agents    [ section ] [ section ] [ section ] [ section ] [ section ] [ section ] [ section ] [ section ]    [ 1][proof ]    * # 1 : * </S>"
  ]
}