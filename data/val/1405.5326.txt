{
  "article_text": [
    "today , political and commercial entities are increasingly engaging in sophisticated cyber - warfare to damage , disrupt , or censor information content  @xcite . in designing anonymous communication services ,",
    "there is a need to ensure reliability even against very powerful types of adversaries .",
    "such adversaries can monitor large portions of networks and control a certain fraction of the parties to run sophisticated _ active _ attacks such as jamming , corruption , and forging , as well as simple _ passive _ attacks such as eavesdropping and non - participation .    in this paper , we focus on the problem of secure anonymous broadcast , where a set of @xmath2 parties want to anonymously send their messages to all parties .",
    "anonymous broadcast is an important tool for achieving privacy in several distributed applications such as anonymous communication  @xcite , private information retrieval  @xcite , secure auctions  @xcite , and multi - party computation ( mpc ) .",
    "our goal is to design a decentralized anonymous broadcast protocol that scales well with the number of parties and is robust against an active adversary .",
    "one motivating application for this protocol is a decentralized version of twitter that enables provably - anonymous broadcast of messages .",
    "one challenging problem with most anonymity - based systems is resistance against _ traffic - analysis_. a global adversary can monitor traffic exchanged between parties to link messages to the their corresponding senders .",
    "such a powerful adversary was assumed to be unrealistic in the past but it is believed to be realistic today especially if the service provider is controlled or compromised by a state - level surveillance authority  @xcite .",
    "unfortunately , well - known anonymous services such as crowds  @xcite and tor  @xcite are not secure against traffic analysis attacks .",
    "two widely - accepted architectures for providing general anonymity against an active adversary are _ mix networks ( mix - nets ) _ and _ dining cryptographers networks ( dc - nets ) _ , both of which were originally proposed by chaum  @xcite .",
    "mix - nets require semi - trusted infrastructure nodes and are known to be vulnerable to traffic analysis and active attacks  @xcite .",
    "dc - nets  @xcite , on the other hand , provide anonymous broadcast protocols among a group of parties without requiring trusted parties .",
    "the core idea of dc - nets is that a protocol for multi - party computation can be used to perform sender and receiver anonymous broadcast .",
    "for example , if party @xmath3 wants to broadcast a message @xmath4 anonymously , then all other parties participate in a multi - party sum with input zero , while party @xmath3 participates with input @xmath4 .",
    "all parties learn the sum , which is @xmath4 while all inputs remain private .",
    "this ensures that no party can trace the output message @xmath4 to its input , keeping @xmath3 anonymous .",
    "although dc - nets are provably - secure against traffic analysis , they face several challenges .",
    "first , a reservation mechanism is required to schedule which party is broadcasting without compromising the anonymity of the sender .",
    "second , dc - nets are susceptible to collisions , which degrade throughput",
    ". a jamming adversary may even use collisions to render the channel useless by continuously transmitting in every round .",
    "third , typical dc - nets are not scalable given that the bit complexity required to anonymously broadcast a single bit among @xmath2 parties is @xmath5 .",
    "state - of - the - art approaches that address some of these challenges include  @xcite .",
    "the majority of these methods scale poorly with network size , rendering them impractical for large networks .",
    "recently , zamani et al .",
    "@xcite proposed the first anonymous broadcast protocol where each party sends @xmath6 bits to broadcast a bit among @xmath2 parties .",
    "their protocol uses multi - party computation to achieve full anonymity and logarithmic - size groups of parties to achieve @xmath7 communication and computation costs .",
    "unfortunately , their protocol has polylogarithmic rounds of communication and is not practical due to large logarithmic factors hidden in the complexity notation .    to the best of our knowledge ,",
    "every sender and receiver anonymous broadcast protocol that does not rely on a trusted party consists of at least three steps .    1 .",
    "* input : * initially , each party holds a message .",
    "the party distributes its message or a representation of it among all or a subset of parties .",
    "this step requires sending @xmath8 messages .",
    "* multi - party shuffling : * all or a subset of parties participate in a multi - party protocol to obliviously generate a random permutation of the sequence of message they hold .",
    "output : * all or a subset of parties holding a sequence of messages broadcast them to all parties .",
    "this step requires sending @xmath5 messages for delivering @xmath2 shuffled messages .",
    "since much can not be done to improve the cost of the output phase , we will mainly focus on the multi - party shuffling step in this paper .",
    "multi - party shuffling can be used as a black - box in multi - party computation problems .",
    "boyle  et  al .",
    "@xcite use oblivious shuffling to randomly choose inputs for a sublinear function evaluation , where a function is evaluated over @xmath6 inputs chosen uniformly at random in the presence of an active adversary .",
    "laur  et  al .",
    "@xcite and goodrich  et  al .",
    "@xcite describe how multi - party shuffling can be used for implementing oblivious database operations and oblivious storage .    our  model .",
    ": :    in this paper , we consider a network of @xmath2 parties whose    identities are common knowledge .",
    "we assume there is a private and    authenticated communication channel between every pair of parties and    the communication is _",
    "synchronous_. our protocol does not require the    presence of any trusted third party , and we do not assume the    existence of a reliable broadcast channel .",
    "we assume    @xmath9 of the parties are controlled by an    _ active _ adversary , for some positive constant @xmath10 .",
    "we assume our adversary is _ computationally unbounded _ and is actively    trying to prevent the protocol from succeeding by attacking the    privacy of the parties , and the integrity of communications , by    attempting to corrupt , forge , or drop messages .",
    "we say that the    parties controlled by the adversary are _ dishonest _ and that the    remaining parties are _ honest _ meaning that they strictly follow our    protocol .",
    "we finally assume that the adversary is _ static _ meaning    that it must select the set of dishonest parties at the start of the    protocol .      in this paper",
    ", we design a decentralized protocol for anonymous communication that is secure against an active adversary . our protocol is efficient and scales well with the number of parties .",
    "moreover , our protocol is load - balanced meaning that each party handles a roughly equal amount of communication and computation .",
    "we use techniques from multi - party computation , where a set of @xmath2 parties , each having a secret value , compute a known function over their inputs , without revealing the inputs to any party .    recently , boyleet  al .",
    "@xcite and dani  et  al .",
    "@xcite proposed scalable solutions to general mpc .",
    "unfortunately , both of these protocols are not practical due to large logarithmic and constant factors in their communication / computation costs . moreover , the protocol of boyle  et al .",
    "is not load - balanced making it hard to be used in settings like mobile networks where the parties have limited resources . despite their inefficiency , we are inspired by @xcite and @xcite to achieve scalability by performing local communications and computations in logarithmic - size groups of parties called _ _",
    "quorum__s , where the number of dishonest parties in each quorum is guaranteed not to exceed a certain fraction .",
    "using quorums and by simplifying much of their work , we develop an efficient multi - party shuffling protocol for anonymizing user inputs .",
    "our protocol is provably - secure as it is based on a formal security framework , which follows from the security of mpc .",
    "we show that the anonymity achieved by this method is , in particular , resistant to traffic analysis",
    ". we also provide provable anonymity against _ a priori _ knowledge that an adversary might have regarding the potential communicating parties .",
    "moreover , unlike the majority of previous work which rely on centralized trusted servers , our protocol is fully - decentralized and does not require any trusted party .",
    "our protocol has polylogarithmic communication and computation costs with respect to the number of parties .",
    "we prove the following main theorem in section  [ sec : security - proofs ] .",
    "[ thm : main ] consider @xmath2 parties in a fully connected network with private channels where each party has a message to send to all parties .",
    "there exists an unconditionally - secure @xmath2-party protocol such that if all honest parties follow the protocol , then with high probability , for @xmath11 and sufficiently large @xmath2 . ]",
    ":    each honest party sends its message to all parties anonymously .",
    "the protocol tolerates up to @xmath9 malicious parties , for some positive constant @xmath10 .",
    "each party sends @xmath7 bits and computes @xmath7 operations for shuffling @xmath2 messages notation is used as a variant of the big - o notation that ignores logarithmic factors .",
    "thus , @xmath12 means @xmath13 for some @xmath14 . ] .",
    "0.69999999999999996    each party sends @xmath7 bits and computes @xmath7 operations for delivering one anonymous bit .",
    "the protocol has @xmath0 rounds of communication .",
    "protocol  overview .",
    ": :    in our protocol , @xmath2 parties participate in a mpc to    jointly compute a shuffling function that randomly permutes their    messages .",
    "then , the results are broadcast to all participating    parties .",
    "more specifically , our protocol builds a set of quorums in a    one - time setup phase and then , uses the quorums in the online phase    for shuffling input messages .",
    "we represent the desired shuffling    function by an arithmetic circuit , where the computation of each gate    is assigned to a quorum .",
    "then , we evaluate the circuit level - by - level ,    passing the outputs of one level as the inputs to the next level .",
    "once    the local computation is finished in each quorum , the result is    forwarded to the next quorum via one - to - one communication with parties    of the next quorum . finally , at the highest level , the shuffled    messages are computed and sent to all parties .",
    "one technique for randomly shuffling a set of messages in a multi - party setting is to assign to each message a uniform random value and then , obliviously sort the messages according to the random values .",
    "one issue with this technique is that if the randoms are not distinct ( i.e. , there is a _ collision _ ) , then the resulting distribution deviates from the uniform distribution . unfortunately , this gives the adversary some advantage to map the inputs to outputs and thus , break the anonymity .",
    "more formally , let @xmath2 be the number of messages and @xmath15 $ ] be the range of random values we choose for each message . with @xmath2 such random values , we can generate @xmath16 possible states while there are @xmath17 possible permutations of the messages .",
    "since @xmath18 , it is easy to see that some permutations are more likely to be generated than others . on the other hand , we will show that by choosing a sufficiently large @xmath19 , we can prevent collisions with high probability . using the chernoff bound",
    ", we will prove that choosing @xmath20 guarantees a uniform random shuffle with probability @xmath21 , for any constant @xmath22 .",
    "some protocols are built upon a relaxed notion of anonymity called _ @xmath14-anonymity _",
    "@xcite , where the adversary is assumed to be unable to identify the actual sender / receiver of a message from a set of @xmath14 parties ( called _ anonymity set _ ) . even though _",
    "@xmath14-anonymity _ often increases efficiency significantly , choosing small @xmath14 s can result in severe privacy problems .",
    "for example , attackers often have background knowledge and it is shown that small anonymity sets are likely to leak privacy when attackers have such knowledge  @xcite .",
    "for example , a person located in new mexico is more likely to search for a restaurant serving chili stew than a person in vermont .",
    "von ahn et al .  @xcite develop a cryptographic broadcast protocol based on dc - nets that is resistant to a static active adversary .",
    "a set of @xmath2 parties with private inputs compute and share the sum of their inputs without revealing any parties input .",
    "the authors introduce @xmath14-anonymity , which means no polynomial - time adversary may distinguish the sender / receiver of a message from among @xmath14 honest senders / receivers .",
    "to achieve @xmath14-anonymity , they partition the set of parties into groups of size @xmath23 and execute a multi - party sum protocol inside each group .",
    "the jamming detection mechanism is weak against an adversary who may waste valuable resources by adaptively filling up to @xmath19 channels . in the case where @xmath2-anonymity is desired",
    ", the protocol requires @xmath24 messages to be sent per anonymous message and the total bit complexity is @xmath25 .",
    "the protocol has latency that is @xmath26 on average when the number of broadcasts is large , but which can be @xmath27 in worst case for a single broadcast .",
    "golle and juels  @xcite employ cryptographic proofs of correctness to solve the jamming problem in dc - nets assuming a static byzantine adversary .",
    "the protocol detects jamming with high probability in @xmath26 rounds , requiring a total communication and computation complexity of @xmath28 bits .",
    "their protocol assumes the existence of a reliable broadcast and a centralized trusted authority for key management distribution .",
    "the xor - trees approach of  @xcite extends dc - nets to achieve @xmath27 amortized bit complexity , which is optimal . in this protocol",
    ", only a single user is allowed to send at any one time in a xor - tree .",
    "hence , the protocol is subject to performance degradation due to collisions as the number of users increases .",
    "the protocol assumes the existence of a public - key infrastructure and a non - byzantine polynomial - time adversary .",
    "the total bit complexity of the protocol is @xmath29 bits in worst case , where @xmath30 is the number of dishonest parties .",
    "the latency of the protocol is @xmath27 in worst case .",
    "however , a sender may broadcast large payloads to amortize the costs .",
    "the amortized latency of the protocol is @xmath26 .",
    "the verdict protocol of  @xcite ( which is based on dissent  @xcite ) has a client - server architecture and uses verifiable dc - nets , where participants use public - key cryptography to construct ciphertext , and knowledge proofs to detect and exclude jamming parties before disruption .",
    "the protocol assumes the existence of a few highly - available servers , where at least one server is honest .",
    "all servers must be alive , however , for the protocol to work .",
    "an interesting aspect of verdict is that it is robust to a large fraction of byzantine parties ( up to @xmath31 ) .",
    "the paper demonstrates empirically that the system scales well with the number of parties , when the number of servers is fixed .",
    "the tarzan protocol of freedman and morris  @xcite provides resistance against traffic analysis , but only against a passive adversary .    the aqua protocol of le blond  et  al .",
    "@xcite provides @xmath14-anonymity with traffic - analysis resistance against passive global attacks and active local attacks .",
    "the protocol achieves anonymity in a way similar to tor ( onion routing ) and achieves unobservability through traffic obfuscating , which is to add artificial delay or artificial traffic ( called chaff ) to the connection .    in the last three decades ,",
    "a large body of work has been devoted to designing mpc protocols  @xcite .",
    "unfortunately , most of these protocols are inefficient and scale poorly with the number of parties .",
    "several mpc sorting and shuffling protocols have been proposed in the literature  @xcite .",
    "laur  et  al .",
    "@xcite describe a multi - party shuffling protocol that can be used for anonymizing a set of inputs .",
    "although the communication and round complexity of their protocol scales well with the number of inputs , they scale exponentially with the number of parties and hence , the method can not be used in our model , where @xmath2 is relatively large .",
    "goodrich  @xcite proposes an efficient data - oblivious randomized shellsort algorithm .",
    "unfortunately , when implemented in a multi - party setting , this protocol requires @xmath32 rounds of communication to sort @xmath33 values and has communication complexity @xmath34 , where @xmath35 is the message size .",
    "zhang  @xcite and hamada  et  al .  @xcite develop constant - round mpc sorting protocols that scale well with the number of inputs but scale poorly with the number of parties .",
    "in this section , we define standard terms , notation , and results used throughout the paper .",
    "an event occurs _ with high probability _ , if it occurs with probability at least @xmath36 , for any @xmath11 and all sufficiently large @xmath2 .",
    "we denote the set of integers @xmath37 by @xmath38 $ ] .",
    "also , let @xmath39 denote the additive group of integers modulo a prime @xmath40 .",
    "in this section , we review the definitions of standard basic tools used throughout the paper .",
    "verifiable  secret  sharing . : :    an _ @xmath41-secret sharing _",
    "scheme , is a protocol in which    a dealer who holds a secret value shares the secret among    @xmath2 parties such that any set of @xmath30 parties    can not gain any information about the secret , but any set of at least    @xmath42 parties can reconstructs it .",
    "an    _ @xmath41-verifiable secret sharing ( vss ) _ scheme is an    _ @xmath41_-secret sharing scheme with the additional    property that after the sharing phase , a dishonest dealer is either    disqualified or the honest parties can reconstruct the secret , even if    shares sent by dishonest parties are spurious . in our protocol , we use    the constant - round vss protocol of katz  et  al .  @xcite that is based    on shamir s secret sharing scheme  @xcite .",
    "this result is described in    theorem  [ thm : katz - vss ] .",
    "[ thm : katz - vss]_@xcite _ there exists a synchronous linear _",
    "@xmath41_-vss scheme for @xmath43 that is perfectly - secure against a static active adversary .",
    "the protocol requires one broadcast and three rounds of communication .    for practical purposes",
    ", one can use the cryptographic vss scheme of kate  et al .",
    "@xcite called _ evss _ ( stands for efficient vss ) , which is based on shamir s scheme and the hardness of the discrete logarithm ( dl ) problem . since evss generates commitments over elliptic curve groups , it requires smaller message sizes than other dl - based vss scheme such as  @xcite .",
    "[ thm : evss]_@xcite _ there exists a synchronous linear _",
    "@xmath41_-vss scheme for @xmath44 that is secure against a computationally - bounded static adversary .",
    "in worst case , the protocol requires two broadcasts and four rounds of communication .",
    "quorum  building .",
    ": :    a _ good quorum _ is a set of @xmath45 parties that    contains a majority of honest parties .",
    "king et al .",
    "@xcite showed that    a _ byzantine agreement ( ba ) _ protocol can be used to bring all parties    to agreement on a collection of @xmath2 good quorums .",
    "+    in this paper , we use the fast ba protocol of    braud - santoni  et  al .",
    "@xcite to build @xmath2 good quorums .",
    "+    [ thm : quorum - building]_@xcite _ there exists a constant - round    unconditionally - secure protocol that brings all good parties to    agreement on @xmath2 good quorums with high probability . the    protocol has @xmath46 amortized communication and    computation complexity ,    and it can tolerate up to @xmath47 malicious    parties .",
    "secure  broadcast .",
    ": :    in the malicious setting , when parties have only access to secure    pairwise channels , a protocol is required to ensure secure ( reliable )    broadcast .",
    "such    a broadcast protocol guarantees all parties receive the same message    even if the broadcaster ( dealer ) is dishonest and sends different    messages to different parties .",
    "it is known that a ba protocol can be    used to perform secure broadcasts .",
    "+    in our protocol , we use the ba algorithm of braud - santoni  et    al .",
    "@xcite to perform secure broadcasts .    +    _ [ thm : broadcast]@xcite _ there exists a constant - round    unconditionally - secure protocol for performing secure broadcasts among    @xmath2 parties .",
    "the protocol has @xmath46    amortized communication and computation complexity , and it can    tolerate up to @xmath47 malicious parties . sorting  networks .",
    ": :    a _ sorting network _ is a network of _",
    "each comparator is    a gate with two input wires and two output wires .",
    "when two values    enter a comparator , it outputs the lower value on the top output wire ,    and the higher value on the bottom output wire .",
    "ajtai  et al .",
    "@xcite    describe an asymptotically - optimal @xmath0 depth    sorting network . however , this network is not practical due to large    constants hidden in the depth complexity .",
    "leighton and plaxton  @xcite    propose a practical _",
    "probabilistic sorting circuit _ that sorts with    very high probability meaning that it sorts all but    @xmath48 of the @xmath17 possible input    permutations , where @xmath49 ,    for any constant @xmath22 .",
    "for example , for @xmath50    and @xmath51 , we get @xmath52 . while    this circuit is sufficient for us to prove our main results    ( theorem  [ thm : main ] ) , one can instead use the    @xmath53-depth sorting network of batcher  @xcite    for sorting all @xmath17 permutations at the expense of    @xmath53 protocol latency .",
    "secure  comparison .",
    ": :    given two linearly secret - shared values @xmath54",
    ",    nishide and ohta  @xcite propose an efficient protocol for computing a    sharing of @xmath55 such that    @xmath56 .",
    "their protocol has @xmath26    rounds and requires @xmath57 invocations of a secure    multiplication protocol , where @xmath35 is the bit - length of    elements to be compared .",
    "we refer to this protocol by .",
    "we also    describe a fast multiplication protocol to be used along with the    comparison protocol of @xcite for implementing fast comparator gates .",
    "share  renewal .",
    ": :    in our protocol , a shuffling circuit is securely evaluated .",
    "each gate    of the circuit is assigned a quorum @xmath58 and the parties in    @xmath58 are responsible for comparison of secret - shared    inputs .",
    "then , they send the secret - shared result to any quorums    associated with gates that need this result as input .",
    "let    @xmath59 be one such quorum . in order to secret - share    the result to @xmath59 without revealing any    information to any individual party ( or to any coalition of dishonest    parties ) , a fresh sharing of the result must be distributed in    @xmath59 . to this end",
    ", we use the share renewal    protocol of herzberg  et al .",
    "@xcite . to update a shared value    @xmath60 defined over a degree @xmath61 polynomial    @xmath62 ,",
    "the protocol generates a degree @xmath61    random polynomial @xmath63 such that    @xmath64 .",
    "the new polynomial    @xmath65 is then computed from    @xmath66 . since    @xmath67",
    ", the new polynomial    @xmath65 defines a fresh sharing of @xmath60 .",
    "combined with the vss scheme of theorem  [ thm : katz - vss ] ( or    theorem  [ thm : evss ] ) , this protocol is secure against an active    adversary ( with @xmath43 ) , takes constant number of rounds ,    and requires each party to send @xmath28 field elements .",
    "we refer to this protocol by throughout this paper .",
    "in this section , we describe our protocol for anonymous broadcast .",
    "consider @xmath2 parties @xmath68 each having a message @xmath69 , for a prime @xmath40 and all @xmath70$]___. _ _ _ the parties want to anonymously send the messages to each other and receive the results back .",
    "we first describe an ideal functionality of our protocol where a hypothetical trusted party @xmath71 computes the desired protocol outcome by communicating with all parties . in every run of the protocol",
    ", @xmath71 executes a shuffling protocol over the messages and sends the shuffled sequence of messages to all parties .",
    "the shuffling protocol first chooses a uniform random number @xmath72 to form an input pair @xmath73 for each party @xmath74 and for all @xmath70 $ ] .",
    "the protocol then uses a shuffling circuit that is based on the sorting network of leighton and plaxton  @xcite to sort the set of pairs @xmath75 according to their first elements .",
    "we later show that this functionality randomly permutes the set of inputs @xmath76 .    in our protocol , we denote the shuffling circuit by @xmath77 , which has @xmath33 gates .",
    "each gate is essentially a comparator gate and is denoted by @xmath78 , for @xmath79.$ ] our protocol first creates @xmath2 quorums and then assigns each gate of @xmath77 to a quorum . for @xmath2 parties ,",
    "the circuit has @xmath80 input gates as each comparator gate has two inputs .",
    "we label the quorums assigned to the input gates by @xmath81 and call them _",
    "input quorums_. @xmath77 also has @xmath80 output gates , which correspond to _ output quorums",
    "_ labeled by @xmath82 .",
    "we now implement the real functionality of our protocol based on the ideal functionality described above .",
    "protocol  [ pro : main ] defines our main algorithm . throughout the protocol",
    ", we represent each _ _ shared value @xmath83 by @xmath84 meaning that each party @xmath74 holds a share @xmath85 generated by the vss scheme during its sharing phase . using the natural component - wise addition of representations ,",
    "we define @xmath86 . for multiplication",
    ", we define @xmath87 , where @xmath88 is a protocol defined in this section .    for the reader s convenience , we now list all subprotocols that we use in our protocol .",
    "these subprotocols are also defined in this section , section  [ sec : preliminaries ] , and section  [ sec : remaining - algorithms ] .    * a well - known technique ( due to @xcite ) that generates uniform random secrets by adding shared values chosen uniformly at random by each party . defined as protocol  [ pro : genrand ] in section  [ sec : remaining - algorithms ] . *",
    "the protocol of nishide and ohta  @xcite for securely comparing two secret - shared values .",
    "* multiplies two secret - shared values .",
    "defined as protocol  [ pro : multiply ] in this section .",
    "* the share renewal protocol of herzberg  et al .",
    "@xcite for re - randomizing shares of a secret - shared value .",
    "this makes past knowledge of the adversary obsolete after re - sharing the secret . *",
    "given a shared secret @xmath60 , reconstructs @xmath60 via polynomial interpolation and error correction .",
    "defined as protocol  [ pro : reconst ] in section  [ sec : remaining - algorithms ] .    1 .   *",
    "* 2 .    3 .",
    "* * * * over @xmath89 , @xmath90 , @xmath91 , and @xmath92 5 .",
    "* *    we prove the correctness and secrecy of protocol  [ pro : main](and theorem  [ thm : main ] ) in section  [ sub : security - of - main ] . in lemma",
    "[ lem : collision ] , we show that for sufficiently large @xmath22 and @xmath93 , this protocolcomputes a random permutation of the input messages with high probability .",
    "we also prove the following lemmas in section  [ sec : proof - of - costs ] .    _",
    "[ lem : protocol - costs]using the perfectly - secure vss of theorem  [ thm : katz - vss ] , protocol  [ pro : main ]",
    "_ sends @xmath46 bits , computes @xmath46 operations , and takes @xmath0 rounds of communication for shuffling @xmath2 messages .    _",
    "[ lem : protocol - costs - evss]using the cryptographic vss of theorem  [ thm : evss ] , protocol  [ pro : main ]",
    "_ sends @xmath94 messages of size @xmath95 and computes @xmath96 operations for shuffling @xmath2 messages , where @xmath97 is the security parameter .",
    "the protocol has @xmath0 rounds of communication .",
    "we now describe the subprotocol @xmath88 that is based on a well - known technique proposed by beaver  @xcite .",
    "the technique generates a shared multiplication triple @xmath98 such that @xmath99 .",
    "the triple is then used to convert multiplications over shared values into additions .",
    "since the triple generation step is independent of the inputs , it can be done in a preprocessing phase . moreover , since each triple acts like a one - time pad , a fresh triple must be used for each multiplication .    _ _    1 .    2 .    3 .",
    "clearly , @xmath100 and @xmath101 can be safely revealed to all parties so that each party can compute @xmath102 locally . the correctness and the secrecy of the algorithmare proved by beaver  @xcite .",
    "the only difference between beaver s original method and our protocol is as follows .",
    "following @xcite , he proposes to generate shared random elements @xmath103 and @xmath104 on a polynomial of degree @xmath105 and multiply them to get a polynomial of degree @xmath106 for @xmath107 .",
    "then , a degree reduction algorithm is run to reduce the degree from @xmath106 to @xmath105 . instead of this",
    ", we choose polynomials of degree @xmath108 for @xmath103 and @xmath104 to get a polynomial of degree @xmath105 for @xmath107 . in our protocol , since up to @xmath108 of parties are dishonest is each quorum , we can do this without revealing any information to the adversary .",
    "we prove this formally in lemma [ lem : evssprops ] and lemma [ lem : multiply - secrecy ] .",
    "one issue with multiplying shares , as noticed by ben - or  et  al .",
    "@xcite , is that the resulting polynomial is not completely random because , for example , the product of two polynomials can not be irreducible . to solve this",
    ", we simply re - randomize the shares via .",
    "moreover , since @xmath109 and @xmath110 are on degree @xmath108 polynomials and uses them to mask - and - reveal the inputs ( that are on degree @xmath105 polynomials ) in the last step , it is necessary to randomize @xmath109 and @xmath110 via before masking .",
    "this puts the shared values @xmath109 and @xmath110 on new random polynomials with degree @xmath105 .    *",
    "[ perfect random permutation ] * consider a set of @xmath111 elements @xmath112 .",
    "a perfect random permutation of @xmath113 is a permutation chosen uniformly at random from the set of all possible @xmath17 permutations of @xmath113 .",
    "[ lem : permutation ] consider a sequence of input pairs @xmath114 , and a sorting protocol @xmath115that sorts the pairs according to their first elements .",
    "@xmath115 computes a perfect random permutation of the pairs if their first elements are chosen uniformly at random and are distinct .",
    "let @xmath116 be the input sequence and @xmath117 be the output sequence of @xmath115 .",
    "note @xmath118is the sorted sequence of @xmath119 .",
    "an arbitrary output sequence of pairs @xmath120 is said to be equal to @xmath121 if @xmath122 , for all @xmath70 $ ] .",
    "we want to prove that the probability of @xmath123 being equal to @xmath121 is @xmath124 .",
    "in general , for any @xmath70 $ ] , @xmath122 if and only if @xmath125 is the @xmath126-th smallest element in @xmath119 conditioned on knowing the @xmath127 smallest elements , which happens with probability @xmath128 .",
    "thus , the probability that @xmath129 is @xmath130    in the random generation step of protocol  [ pro : main ] , it is possible that two or more input quorums choose the same random elements from @xmath131 . in this situation",
    ", we say a _ collision _ happens .",
    "collisions reduce the level of anonymity our protocol guarantees because the higher the probability of collisions , the higher the chance the adversary is given in guessing the correct sequence of inputs .",
    "on the other hand , we observe that if the field size ( i.e. , @xmath40 ) is sufficiently large , then the probability of collisions becomes overwhelmingly small .",
    "lemma  [ lem : collision ] gives a lower bound on @xmath40 such that collisions are guaranteed to happen with negligible probability .",
    "[ lem : collision ] let @xmath131 be the field of random elements generated in the random generation step of protocol  [ pro : main ] .",
    "the probability there is a collision between any two parties is negligible if @xmath93 , for some @xmath22 .",
    "based on theorem  [ thm : quorum - building ] , all input quorums are good . based on the correctness of , all elements generated by the input quorums in the random generation step of protocol  [ pro : main]are chosen uniformly at random and independent of all other random elements generated throughout the protocol .",
    "let @xmath74 and @xmath132 be two parties and @xmath133 and @xmath134 be the random values assigned to them respectively by their corresponding input quorums .",
    "the probability that @xmath135 is @xmath136 .",
    "let @xmath137 be the following indicator random variable and @xmath121 be a random variable giving the number of collisions between any two parties , using the linearity of expectations , we want to find an upper bound on the probability of collisions using the chernoff bound defined byto ensure that no collision happens with high probability , we need to have @xmath138 while @xmath139 , for any @xmath22 .",
    "choosing @xmath140 and solving the inequalities for @xmath141 we get    @xmath142    @xmath143    since @xmath144 , solving this for @xmath40 gives the bound @xmath93 and @xmath145 .",
    "to study the feasibility of our scheme and compare it to previous work , we implemented an experimental simulation of our protocol and three other protocols which can be used for shuffling @xmath2 inputs randomly ( with traffic - analysis resistance ) in the same setting .",
    "these protocols are due to dani  et  al .",
    "@xcite , boyle  et  al .",
    "@xcite , and zamani  et  al .",
    "@xcite . to the best of our knowledge ,",
    "these protocols have the best scalability with respect to the network size among other works described in the literature for the same setting .",
    "since the protocols of @xcite and @xcite are general mpc algorithms , we use them for running our shuffling technique described in section  [ sec : protocol ] .",
    "the protocol of @xcite is a jamming - resistant version of dc - nets that scales better than other dc - net protocols  @xcite .",
    "we stress that we are interested in evaluating our protocols for large network sizes and hence , our choice of protocols for this section is based on their scalability for large @xmath2 s .",
    "one may find other protocols in the literature that perform better than the protocols of our choice for small @xmath2 s .",
    "we run our protocol for inputs chosen from @xmath39 with a 160-bit prime @xmath40 for getting about 80 bits of security .",
    "we set the parameters of our protocol in such a way that we ensure the probability of error for the quorum building algorithm of @xcite is smaller than @xmath146 . for the sorting circuit , we set @xmath50 to get @xmath147 for all values of @xmath2 in the experiment .",
    "clearly , for larger values of @xmath2 , the error becomes superpolynomially smaller , e.g. , for @xmath148 , we get @xmath149 . for all protocols evaluated in this section ,",
    "we assume cheating ( by malicious parties ) happens in every round of the protocols .",
    "this is essential for evaluating various strategies used by these protocols for tolerating active attacks .",
    "figure  [ fig : plots ] illustrates the simulation results obtained for various network sizes between @xmath150 and @xmath151 ( i.e. , between 32 and about 1 billion ) . to better compare the protocols , the vertical and horizontal axis of the plot",
    "are scaled logarithmically .",
    "the @xmath152-axis presents the number of parties and the @xmath153-axis presents the number of kilobytes sent by each party for delivering one anonymous bit . in this figure , we report results from three different versions of our protocols .",
    "the first plot ( marked with circles ) belongs to our unconditionally - secure protocol that uses the perfectly - secure vss scheme of katz  et  al .",
    "the second plot ( marked with stars ) represents our computationally - secure protocol which uses the cryptographic vss of kate  et  al .",
    "the last plot ( marked with diamonds ) shows the cost of the cryptographic protocol with amortized ( averaged ) setup cost . to obtain the amortized plot",
    ", we run the setup phase of protocol  [ pro : main ] once and then used the setup data to run our online protocol 100 times .",
    "the total number of bits sent was then divided by 100 to get the average communication cost . to achieve better results",
    ", we also generated a sufficient number of random triples in the setup phase .",
    "then , the triples were used by our multiplication subprotocol in the online phase to multiply secret - shared values efficiently .",
    "we observe that our protocols ( even the unconditional version ) perform significantly better than the other protocols .",
    "for example , for @xmath154 ( about 1 million parties ) , the amortized protocol requires each party to send about 64 kb of data per anonymous bit delivered ( about 8 mb for our crypto version and about 64 mb for our unconditional version ) while the protocols of @xcite , @xcite , and @xcite each send more than one terabytes of data per party and per anonymous bit delivered .",
    "we described an anonymous broadcast protocol that is fully decentralized and tolerates up to @xmath1 active faults .",
    "moreover , our protocol is load - balanced and can tolerate traffic - analysis attacks .",
    "the amount of information sent and the amount of computations performed by each party scales polylogarithmically with the number of parties .",
    "the scalability is achieved by performing local communications and computations in groups of logarithmic size and by relaxing the latency requirements .",
    "several open problems remain .",
    "first , can we decrease the number of rounds of our protocol using a smaller - depth sorting circuit ?",
    "for example , since our protocol sorts uniform random numbers , it seems possible to use a smaller depth non - comparison - based sorting circuit like bucket sort .",
    "second , can we improve performance even further by detecting and blacklisting parties that exhibit adversarial behavior ?",
    "finally , can we adopt our results to the asynchronous model of communication ?",
    "we believe that this is possible for a suitably chosen upper bound on the fraction of faulty parties .",
    "in this section , we prove the correctness and secrecy of our protocols .      we have already showed the correctness of the and now prove the secrecy of the algorithm .",
    "we first define @xmath30-secrecy , a property required for the proof of secrecy .",
    "* [ @xmath30-secrecy ] * a secret - shared value defined over a polynomial @xmath155 is said to have _",
    "@xmath30-secrecy _ if and only if    1 .",
    "@xmath30-private _ meaning that no set of at most @xmath30 parties can compute @xmath156 , and 2 .",
    "@xmath30-resilient _ meaning that no set of @xmath30 or less parties can prevent the other @xmath157 remaining parties from correctly reconstructing @xmath156 .    [ lem : evssprops ] the shamir s secret sharing scheme has the following properties .    1",
    ".   a sharing defined over a polynomial of degree @xmath61 has @xmath61-secrecy if the adversary has less than @xmath61 of the shares .",
    "2 .   let @xmath158 and @xmath159 be independent random polynomials of degree @xmath160 and @xmath161 that correspond to sharings with @xmath160-secrecy and @xmath161-secrecy respectively .",
    "@xmath162 is a polynomial of degree @xmath163 that corresponds to a sharing with @xmath164-secrecy .",
    "3 .   let @xmath158 and @xmath159 be polynomials of degree @xmath61 that correspond to two sharings both with @xmath61-secrecy .",
    "@xmath165 is a polynomial of degree @xmath166 that corresponds to a sharing with @xmath61-secrecy .",
    "the first property follows from the definition .",
    "the second property is correct due to the linearity shamir s scheme . without loss of generality ,",
    "let @xmath167 . intuitively ,",
    "if we assume that the sharing defined by @xmath168 does not have @xmath161-secrecy . then , parties compute @xmath169 .",
    "thus , they can find @xmath170 ( or similarly prevent others from learning @xmath170 ) .",
    "this contradicts with the fact that @xmath159 corresponds to a sharing with @xmath161-secrecy . for a complete proof ,",
    "we refer the reader to claim 3.4 of @xcite .",
    "the third property is correct because considering an arbitrary @xmath74 holding two shares @xmath171 and @xmath172 on polynomials @xmath158 and @xmath159 respectively , @xmath74 learns nothing from @xmath173 other than what is revealed from @xmath171 and @xmath172 since @xmath74 computes it locally .",
    "so , the resulting shared value also has @xmath61-secrecy .",
    "[ lem : multiply - secrecy ] let @xmath174 and @xmath175 be two secret - shared values both with @xmath105-secrecy and .",
    "the sharing @xmath176 has @xmath105-secrecy .    in the first step of , algorithm creates two shared values @xmath177 and @xmath178 that correspond to degree @xmath108 polynomials .",
    "lemma  [ lem : evssprops ] proves that @xmath109 and @xmath110 both have @xmath108-secrecy . for each party @xmath179 based on lemma  [ lem : evssprops ]",
    ", @xmath180 defines a new sharing that is on a polynomial of degree @xmath105 and has @xmath108-secrecy .",
    "moreover , @xmath181 and @xmath182 both are on polynomials of degree @xmath105 and have @xmath105-secrecy .",
    "thus , based on lemma  [ lem : evssprops ] , @xmath183 defines a new sharing @xmath176 that is on a polynomial of degree @xmath105 and has @xmath105-secrecy .",
    "[ lem : multiply ] given two secret - shared values @xmath174 and @xmath175 , the protocol _ correctly returns a shared value @xmath176 such that @xmath184 .",
    "_    follows from the proof of @xcite .      in this section",
    ", we prove our main theorem ( theorem  [ thm : main ] ) .",
    "we prove in the real / ideal world model as described by canetti  @xcite .",
    "first , we consider the protocol in an ideal model . in this model ,",
    "all parties send their input to a trusted party who computes the shuffling circuit .",
    "then , it sends the result to all parties .",
    "let @xmath113 be the sequence of inputs and @xmath185 be the sequence of sorted inputs according to the random numbers associated with them . recall that we have at least @xmath157 honest parties .",
    "based on lemma  [ lem : permutation ] and conditioned on the event that no collision happens with high probability ( lemma  [ lem : collision ] ) , the elements of @xmath185 that correspond to honest parties can be any permutation of the elements of honest parties in @xmath113 .",
    "in other words , the probability that the adversary can successfully map @xmath185 to @xmath113 is less than @xmath186 which guarantees @xmath187-anonymity ( i.e. , full anonymity ) .",
    "protocol  [ pro : main ] is the realization of the above ideal model .",
    "the real model computes the circuit in a multi - party setting .",
    "we prove this realization is correct and secure .",
    ": :    the correctness and secrecy follows from the proof of    theorem  [ thm : quorum - building ] .",
    "input  sharing .",
    ": :    the correctness and secrecy follows from the proof of the vss scheme    used ( @xcite ) . after this step",
    ", each input quorum    @xmath188 has a correct sharing of @xmath74 s    input .",
    "this is the base case for our proof of circuit computation    step**. * * random  generation .",
    ": :    the correctness and secrecy follows from the proof of the algorithm . circuit  computation . : :    _ correctness . _",
    "we prove by induction in the real / ideal model .",
    "the    invariant is that if the input shares are correct , then the output of    each gate is equal to the output when the gate is computed by a    trusted party in the ideal model , and the result is shared between    parties of the quorum correctly . for the base case ,",
    "note that the    invariant is true for input gates .",
    "induction step is based on the    universal composability of and @xmath88 .",
    "moreover , based on the correctness of , the output resharing step    generates new shares without changing the output .",
    "+    _ secrecy .",
    "_ we prove by induction .",
    "the adversary can not obtain any    information about the inputs and outputs during the computation of    each gate of the circuit .",
    "let @xmath58 , and    @xmath59 be two quorums involved in the computation of    a gate , where @xmath58 provides an input to the gate , and    @xmath59 computes the gate .",
    "consider a party    @xmath71 .",
    "let @xmath189 be the set of all shares    @xmath71 receives during the protocol .",
    "we consider two cases .",
    "first , if @xmath190 , then elements of    @xmath189 are independent of the shares @xmath58 sends to    @xmath59 .",
    "moreover , elements of @xmath189 are    independent of the output of @xmath59 since    @xmath59 also re - shares its output(s ) .",
    "hence ,    @xmath189 reveals nothing about the inputs and outputs of the    gate .",
    "+    second , if @xmath191 , then the inductive    invariant is that the collection of all shares held by dishonest    parties in @xmath58 and @xmath59 does not give    the adversary any information about the inputs and the outputs . as the    base case , it is clear that the invariant is valid for input gates .",
    "the induction step is as follows .",
    "the adversary can obtain at most    @xmath192 shares of any shared value during the    computation step ; @xmath108 from dishonest parties in    @xmath58 and @xmath108 from dishonest parties in    @xmath59 . by the secrecy of the vss scheme , at least    @xmath193 shares are required for reconstructing the secret .    by the secrecy of @xmath194 and    @xmath88 ,",
    "when at most @xmath105 of the    shares are revealed , the secrecy of the computation step is proved    using universal computability of multi - party protocols .",
    "+    the gate computation step of protocol  [ pro : main ] obliviously swaps the    pairs @xmath195 and @xmath196    according to their first , i.e. , if @xmath197 ,    then this step outputs    @xmath198 and    @xmath199",
    ".    otherwise , it outputs    @xmath200    and    @xmath201 .    in both cases ,",
    "the adversary remains oblivious of which output is    mapped to the first ( second ) input pair .",
    "+    let @xmath202 . based    on the correctness and security of ( see @xcite ) ,",
    "@xmath203    if and only if @xmath197 and    @xmath204 , otherwise .",
    "also , the adversary does not learn    anything about @xmath205 and @xmath206 .",
    "if    @xmath203 , then based on equation  [ eq : switching ] , the    linearity of the vss scheme , and the correctness and secrecy of    ( lemmata  [ lem : multiply - secrecy ] and [ lem : multiply ] ) ,    @xmath207 , @xmath208 ,    @xmath209 , and    @xmath210 . otherwise ,    @xmath211 , @xmath212 ,    @xmath213 , and @xmath214 .",
    "output  propagation .",
    ": :    the correctness and secrecy follows from the proof of the subprotocol    .",
    "we first compute the cost of each step of the protocol separately and then compute the total cost .",
    "let @xmath215 and @xmath216 be the communication and computation complexity of the vss subprotocol respectively when it is invoked among @xmath2 parties . as stated in theorem  [ thm : katz - vss ] and theorem  [ thm : evss ] both vss protocols used in this paper take constant rounds of communication .",
    "* _ setup .",
    "_ the communication and computation costs are equal to those costs of the quorum building algorithm of theorem  [ thm : quorum - building ] , which is @xmath7 for each party .",
    "this protocol takes constant rounds of communication . *",
    "_ input  broadcast .",
    "_ the input broadcast step invokes the vss protocol @xmath2 times among @xmath45 parties .",
    "so , this step sends @xmath217 bits and performs @xmath218 operations .",
    "since the vss scheme is constant - round , this step also takes constant rounds .",
    "* _ random  generation .",
    "_ it is easy to see that the subprotocol sends @xmath219 messages , performs @xmath220 , and has constant rounds .",
    "* _ circuit  computation .",
    "_ the sorting network of leighton and plaxton  @xcite has gates .",
    "so , the communication cost of this step is equal to the communication and computation cost of running instantiations of and . requires @xmath221 invocation of which sends @xmath219 messages and computes @xmath220 operations .",
    "also sends @xmath219 messages and computes @xmath220 operations .",
    "hence , the circuit computation phase sends @xmath222 messages computes @xmath223 . since the sorting network has depth @xmath0 , and takes constant rounds , this steps takes @xmath0 rounds of communication . *",
    "_ output  propagation .",
    "_ the costs are equal to the communication and computation costs of running@xmath2 invocations of which costs @xmath224 , plus sending the outputs to all parties , which costs @xmath225 .",
    "thus , this step costs @xmath225 .",
    "since is a constant - round protocol , this step takes constant rounds . *",
    "_ total . _ since @xmath226 , for a constant @xmath14 , @xmath227 and @xmath228 ) .",
    "using evss , we get @xmath229 .",
    "thus , protocol  [ pro : main ] sends @xmath94 messages of size @xmath95 , computes @xmath96 operations for shuffling @xmath2 messages ( excluding the output step ) .",
    "this proves lemma  [ lem : protocol - costs - evss ] . for lemma  [ lem : protocol - costs ] , since @xmath230 , protocol  [ pro : main ] sends @xmath46 bits and computes @xmath46 operations for shuffling @xmath2 messages .",
    "this proves lemma  [ lem : protocol - costs ] . in both cases ,",
    "the output propagation step costs @xmath231 field elements .",
    "finally , in both cases , the protocol requires @xmath0 rounds of communication .",
    "this finishes the proof of theorem  [ thm : main ] .",
    "beaver  @xcite describes a simple technique for generating uniform random secrets by adding shared values chosen uniformly at random by each party .",
    "such a random shared value is used in several parts of our protocol .",
    "the following subprotocol implements this technique .      in the malicious setting ,",
    "it is possible that dishonest parties send spurious shares during secret reconstruction phase . in evss",
    "@xcite ( used in the cryptographic version of our protocol ) , this is solved by asking all parties to broadcast a proof ( called _ witness _ ) during reconstruction to verify broadcast shares . in our protocol",
    ", reconstruction is postponed to after circuit computation .",
    "since the witnesses are generated in the sharing phase at the beginning of the computation , and the witnesses do not have necessary homomorphic properties , we can not use them in our reconstruction phase . instead",
    ", we correct corruptions using a bch decoding algorithm ( e.g. , the algorithm of berlekamp and welch  @xcite ) as in normal secret reconstruction  @xcite .",
    "this technique is also used in the vss of katz  et  al .",
    "@xcite and is implemented in the following subprotocol ."
  ],
  "abstract_text": [
    "<S> in anonymous broadcast , one or more parties want to anonymously send messages to all parties . </S>",
    "<S> this problem is increasingly important as a black - box in many privacy - preserving applications such as anonymous communication , distributed auctions , and multi - party computation . in this paper , we design decentralized protocols for anonymous broadcast that require each party to send ( and compute ) a polylogarithmic number of bits ( and operations ) per anonymous bit delivered with @xmath0 rounds of communication . our protocol is provably secure against traffic analysis , does not require any trusted party , and is completely load - balanced . </S>",
    "<S> the protocol tolerates up to @xmath1 statically - scheduled byzantine parties that are controlled by a computationally unbounded adversary . </S>",
    "<S> our main strategy for achieving scalability is to perform local communications ( and computations ) among a logarithmic number of parties . </S>",
    "<S> we provide simulation results to show that our protocol improves significantly over previous work . </S>",
    "<S> we finally show that using a common cryptographic tool in our protocol one can achieve practical results for anonymous broadcast . </S>"
  ]
}