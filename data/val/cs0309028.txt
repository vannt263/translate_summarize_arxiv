{
  "article_text": [
    "termination is a crucial aspect of program verification .",
    "it is of particular importance for logic programs @xcite , since there are no _ a priori _ syntactic restrictions to queries and , as a matter of fact , most predicates programmers tend to write do not terminate for their most general queries . in the last fifteen years , termination has been the subject of several research works in the field of logic programming ( see , for instance , @xcite ) . in contrast to what happens for other programming paradigms , there are two notions of termination for logic programs @xcite : _ existential _ and _ universal _ termination . to illustrate them , assume we are using a standard prolog engine .",
    "existential termination of a query means that either the computation finitely fails or it produces _ one _ solution in finite time .",
    "this does not exclude the possibility that the engine , when asked for further solutions , will loop . on the other hand",
    ", universal termination means that the computation yields all solutions and eventually fails in finite time ( if we repeatedly ask for further solutions ) .",
    "although the concept of existential termination plays an important role in connection with _",
    "normal _ logic programs , it has severe drawbacks that make it not appropriate in other contexts : existential termination is not _",
    "instantiation - closed _",
    "( i.e. , a goal may existentially terminate , yet some of its instances may not terminate ) , hence it is not _ and - compositional _",
    "( i.e. , two goals may existentially terminate while their conjunction does not ) ; finally , existential termination depends on the textual order of clauses in the program .",
    "universal termination is a stronger and much more robust concept : it implies existential termination and it is both and - compositional and instantiation - closed .",
    "existential termination has been the subject of only a few works @xcite whereas most research focused on universal termination .",
    "there are two main directions ( see @xcite for a survey ) : characterizing termination @xcite and finding weaker but decidable sufficient conditions that lead to actual algorithms , e.g. , @xcite . even though our research belongs to both streams , in this paper we focus on an intuitive presentation of the implementation of our approach .",
    "a companion paper presents a complete formalization of our work in the theoretical setting of acceptability for constraint logic programs @xcite , where we refine a necessary and sufficient condition for termination to the sufficient condition implemented in cti .",
    "our main contribution compared to other automated termination analyzers @xcite is that our tool _ infers _ sufficient universal termination conditions from the text of any prolog program , adopting a bottom - up approach to termination .",
    "an important feature of this approach first presented in @xcite is that there is no need to define in advance a class of queries of interest .",
    "( if required , these classes can be provided after the analysis has finished in order to specialize the obtained results . ) our system , called _ cti _ from _ onstraint - based ermination nference _ , is written in sicstus prolog . a preliminary account of the work described in this paper appeared in @xcite , where we showed that numeric computations took most of the execution times .",
    "now cti relies on the specialized parma polyhedra library @xcite , a modern c library for the manipulation of convex polyhedra that significantly speeds up the analysis .",
    "moreover , cti has been extended so that it can analyze any iso - prolog program @xcite .",
    "the only correctness requirement we currently impose on programs is that they must not create infinite rational terms .",
    "hence we assume execution with occurs - check or , equivalently , nsto programs ( i.e. , programs that are _ not subject to occur - check _ @xcite and thus are safely executed with any standard conforming system ) .",
    "we point out that simple , sufficient syntactic methods for ensuring occurs - check freedom are presented in @xcite while @xcite describe abstract - interpretation based solutions .",
    "recently , _ finite - tree analysis _",
    "@xcite has been proposed to confine infinite rational terms in programs that are not occurs - check free .",
    "both the approach described in @xcite and the cti system can be extended , with the help of finite - tree analysis , to deal also with such programs .    throughout the paper",
    "we assume a basic knowledge of logic programming ( see , e.g. , @xcite ) , constraint logic programming ( see , e.g. ,",
    "@xcite ) , abstract interpretation ( see , e.g. , @xcite ) , and propositional @xmath0-calculus ( see , e.g. , @xcite ) . in section  [ sec",
    ": cti - overview ] we present cti informally with an example analysis . how to use cti",
    "is described in section  [ sec : using - cti ] .",
    "an experimental evaluation of the system is the subject of section  [ sec : experimental - evaluation ] .",
    "related work is discussed in section  [ sec : related - work ] while section  [ sec : conclusion ] concludes .",
    "our aim is to compute classes of queries for which universal left termination is guaranteed .",
    "we call such classes _ termination conditions_. more precisely , let @xmath1 be a prolog program and @xmath2 a predicate symbol of @xmath1 .",
    "a termination condition for @xmath2 is a set @xmath3 of goals of the form @xmath4 where @xmath5 is a clp(@xmath6 ) constraint such that , for any goal @xmath7 , each derivation of @xmath1 and @xmath8 using the left - to - right selection rule is finite .",
    "our analyzer uses three main constraint structures : herbrand terms for the initial program @xmath1 ( seen as a clp(@xmath6 ) program ) , non - negative integers , and booleans ( @xmath1 is abstracted into both a clp(@xmath9 ) and a clp(@xmath10 ) program ) .",
    "we illustrate our method to infer termination conditions by means of an example .",
    "the method consists of six distinct steps , which will be illustrated on the following definition for the predicates ` app/3 ` , ` nrev/2 ` and ` app3/4 ` .",
    "l|l|l    ` app ( [ ] , x , x ) . `",
    "+ ` app([e|x ] , y , [ e|z ] ) : - ` + ` app(x , y , z ) . `    &    ` nrev ( [ ] , [ ] ) . `",
    "+ ` nrev([e|x ] , y ) : - ` + ` nrev(x , z ) , ` + ` app(z , [ e ] , y ) . `    &    ` app3(x , y , z , u ) : - ` + ` app(x , y , v ) , ` + ` app(v , z , u ) . `    [ [ step1-from - prolog - to - clpmathcaln . ] ] step  1 : from prolog to clp(@xmath9 ) .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    from the prolog program @xmath1 , a clp(@xmath9 ) program @xmath11 is obtained by applying a symbolic norm . in our example",
    ", we use the _ term - size _ norm , which is the one cti applies by default .",
    "all iso - predefined predicates have been manually pre - analyzed for this norm .",
    "notice that , as explained in @xcite , termination inference for pure prolog programs can be based on any linear norm .",
    "the symbolic term - size norm is inductively defined as follows : @xmath12 for example , @xmath13 .",
    "all non - monotonic elements of the program are approximated by monotone constructs .",
    "for instance , prolog s unsound negation ` \\+ g ` is approximated by ` ( ( g , false ) ; true ) ` .",
    "more generally , extra - logical predicates are mapped to their first - order counterparts so that the termination property is preserved . for our running example",
    ", we obtain the following clp(@xmath9 ) clauses :    l|l|l    @xmath14 + @xmath15 + @xmath16    &    @xmath17 + @xmath18 + @xmath19 + @xmath20    &    @xmath21 + @xmath22 + @xmath23    [ [ step2-computing - a - numeric - model . ] ] step  2 : computing a numeric model .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a model of the clp(@xmath9 ) program is now computed . for each predicate @xmath24",
    ", the model describes , with a finite conjunction of linear equalities and inequalities denoted by @xmath25 , the linear inter - argument relations that hold for every solution of @xmath24 . in our example we obtain the following model : @xmath26 the actual computation is performed on the set of nonnegative , infinite precision rational numbers , using a fixpoint calculator based on ppl , the parma polyhedra library @xcite , and the standard widening @xcite . in our example",
    "the least model is found . in general , however , only a less precise model can be determined .    [ [ step3-computing - a - numeric - level - mapping . ] ] step  3 : computing a numeric level mapping .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the information provided by the numerical model is crucial to compute a _",
    "level mapping _",
    "let @xmath24 be an @xmath28-ary predicate symbol in the clp(@xmath9 ) program .",
    "the level mapping associates to @xmath24 a function @xmath29 that is guaranteed to decrease when going from the head of the clause to each recursive call(s ) , if any , for each clause defining @xmath24 . for example , a level mapping @xmath27 such that @xmath30 intuitively means : for each ground instance of each recursive clause defining @xmath31 , the first argument decreases when going from the head of the clause to the recursive call ( since @xmath32 for each @xmath33 ) . since no clause defining @xmath34 is recursive , the level mapping can be defined so that @xmath35 .",
    "the level mapping computed for our example is defined by : @xmath36 this is obtained by means of an improvement of the technique by k.  sohn and a.  van  gelder for the automatic generation of linear level mappings .",
    "their algorithm , which is based on linear programming , is complete in the sense that it will always provide a linear level mapping if one exists @xcite . our extension , which is described in @xcite ,",
    "consists in first computing a constraint over the coefficients of a generic linear level mapping ( step  3a ) .",
    "then we generate a concrete level mapping ( step  3b ) .",
    "notice that for a multi - directional predicate ( such as ` app/3 ` ) we may get multiple linear level mappings .",
    "these are combined , with the @xmath37 operator , into one non - linear level mapping .",
    "in contrast with the well - known standard framework of acceptability , the decrease of the level mapping has to be shown only for predicates belonging to the same strongly connected component ( scc ) of the call graph . step  5 below will ensure that the other calls to predicates from lower scc s do left terminate .",
    "the advantage of this approach is twofold : first , the computation of a level mapping , being scc - based , is modular .",
    "secondly , the expressive power of _ linear _ level mappings with respect to termination is much higher than in the acceptability case .",
    "[ [ step4-from - clpmathcaln - to - clpmathcalb . ] ] step  4 : from clp(@xmath9 ) to clp(@xmath10 ) .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    from the clp(@xmath9 ) program @xmath11 a clp(@xmath10 ) program , @xmath38 , is obtained by mapping each natural number to @xmath39 ( true ) , each variable symbol to itself , and addition to logical conjunction .",
    "l|l|l    @xmath40 + @xmath41 + @xmath42    &    @xmath43 + @xmath44 + @xmath45 + @xmath46    &    @xmath47 + @xmath48 + @xmath49    the purpose of @xmath38 is the one of capturing boundedness dependencies within @xmath11 or , equivalently , rigidity dependencies within the original program .",
    "is _ rigid _ with respect to a symbolic norm @xmath50 if and only if its measure is invariant by instantiation , i.e. , @xmath51 for any substitution @xmath52 . ] a model for @xmath38 is then computed and a boolean level mapping @xmath53 is obtained from the numerical level mapping computed in step  3 . in order to do that , the translation scheme outlined above is augmented with the association of the logical disjunction @xmath54 to @xmath55 : this means that @xmath55 is a bounded quantity if @xmath56 or @xmath57 or both are bounded . here",
    "is what we obtain for the example program : @xmath58 for instance , as we use the term - size norm , this model tells us that for any computed answer @xmath52 to a call @xmath59 , @xmath60 is ground if and only if @xmath61 is ground .    [ [ step5-computing - boolean - termination - conditions . ] ] step  5 : computing boolean termination conditions .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the information obtained from @xmath38 for each program point is combined with the level mapping by means of the following boolean @xmath0-calculus formul , whose solution gives the desired boolean termination conditions .",
    "@xmath62    here is the intuition behind such boolean @xmath0-calculus formul . consider the ` nrev/2 ` predicate .",
    "its unit clause is taken into account in the computation of the numeric and the boolean model .",
    "for computing the boolean termination condition @xmath63 , we consider the clause @xmath64 ,        \\mathrm{nrev}_{\\ensuremath{\\mathcal{b}}}(x ' , z ) ,        \\mathrm{app}_{\\ensuremath{\\mathcal{b}}}(z , 1\\land e , y).\\ ] ] we are looking for a boolean relation @xmath65 satisfying the following conditions :    * for each @xmath66 in @xmath67 , the level mapping has to be bounded , which leads to condition ( 1 ) above ; * the recursive call to ` nrev/2 ` has to terminate , hence condition ( 2 ) ; * for any state resulting from the evaluation of the first call , the subsequent call to ` app/3 ` has to terminate , giving condition ( 3 ) ; * finally , we are interested in the weakest solution for @xmath67 , hence the boolean termination condition is defined as a greatest fixpoint : @xmath68    solving the equations for our example gives : @xmath69    the greatest fixpoint is evaluated with the boolean @xmath0-solver described in @xcite , which computes on the domain @xmath70 of positive boolean formul  @xcite and is based on the boolean solver of sicstus prolog .",
    "[ [ step-6-back - to - prolog . ] ] step 6 : back to prolog .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    in the final step of the analysis , the boolean termination conditions are lifted to termination conditions with the following interpretation , where the @xmath5 s are clp(@xmath6 ) constraints :    * each goal `` ? - `  @xmath5 ,  ` app(x , y , z ) . ` ' left - terminates if ` x ` or ` z ` are ground in @xmath5 ; * each goal `` ? - `  @xmath5 ,  ` nrev(x , y ) . ` ' left - terminates if ` x ` is ground in @xmath5 ; * each goal `` ? - `  @xmath5 ,  ` app3(x , y , z , u ) . ` ' left - terminates if ` x ` and ` y ` are ground in @xmath5 or ` x ` and ` u ` are ground in @xmath5 .",
    "once compiled and installed , cti is invoked with the command `` cti source ` ' , where the program in `` source ` ' is assumed to be an iso - prolog program .",
    "the user may then control the behavior of cti with some options .",
    "we describe the main ones .    `` -p file ` ' : :    by default , undefined predicates are assumed to fail .",
    "the user may    enrich or redefine the set of built - ins recognized by the system , by    specifying `` -p file ` ' on the command line .",
    "this has the effect of    importing the predicates whose numerical model , boolean model , and    termination condition are given in `` file ` ' . as predicates imported    that way can not be redefined in the analyzed program , this scheme    provides a way to overcome potential weaknesses of the analysis .",
    "`` -t timeout_in_ms ` ' : :    the analysis steps  2 ,  3a ,  3b ,  4 ,  and  5 described in    section  [ sec : cti - overview ] all include potentially expensive    computations . because of this , for each such step , the computation    concerning each scc is subject to a timeout ,",
    "whose default value is 2    seconds .",
    "the `` -t ` ' option allows the user to modify this value .",
    "`` -n n ` ' : :    for the computation of the numeric model ( step  2 ) , a widening is used    after @xmath28 iterations of the approximate fixpoint    iteration .",
    "the default value for @xmath28 is 1 .",
    "the user may also modify a program to give specific information for selected program points .",
    "we illustrate this facility by means of examples ; the precise syntax is given in the cti s documentation .",
    "one may specify that particular program variables will only be bound to non - negative integers and that the analyzer should take into account some constraints involving them .",
    "for instance , cti does not detect that the following program terminates :    .... p1(n ) : - n > 0 , m is n-1 , p1(m ) .",
    "p1(n ) : - n >",
    "1 , a is n>>1 , z is n - a , p1(a ) , p1(z ) . ....    where the predefined arithmetic functor `` >",
    "> /2 ` ' is the bitwise arithmetic right shift . on the other hand ,",
    "cti is able to show that ` p2(n ) ` terminates :    .... p2(n ) : - cti:{n > 0 , m = n-1 } , p2(m ) .",
    "p2(n ) : - cti:{n > 1 , 2*a = <",
    "n , n = < 2*a+1 , z = n - a } , p2(a ) , p2(z ) . ....",
    "finally , at any program point , the user can add linear inter - argument relations or groundness relations that the analyzer will take for granted .",
    "the system can thus prove the termination of the goal `` ? - top . ` ' where the predicate ` top/0 ` is defined by the program given in section  [ sec : cti - overview ] augmented with the following clause , where the term - size of ` l1 ` is declared to be less than 10 and ` l2 ` is declared to be ground :    .... top : - cti:{n(l1 ) < 10},app(l1,zs , l2),cti:{b(l2)},app(xs , ys , l2 ) . ....    while such programs are no longer iso - prolog programs , the annotations can be automatically removed so as to obtain the original programs back .",
    "the assertion language currently used in cti is only experimental , and future versions of the system may be based on the language defined in @xcite .",
    "unless otherwise specified , the experiments we present here were all conducted with the option ( see section [ sec : using - cti ] ) ` -p predef_for_compatibility.pl ` , which ensures that non - iso built - ins used in the benchmarks ( several of which are written in a non - iso dialect of prolog ) are predefined .",
    "this experimental evaluation was done on a gnu / linux system with an intel i686 cpu clocked at 2.4 ghz , 512 mb of ram , running the linux kernel version 2.4 , sicstus prolog 3.10.0 ( 28.3 mlips ) , ppl version 0.5 , and cti version 1.0 .",
    "[ [ standard - programs - from - the - termination - literature . ] ] standard programs from the termination literature .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    table  [ table_results_dds ] presents timings and results of cti on some standard lp termination benchmarks .",
    "the columns are labeled as follows :    program : : :    the name of the analyzed program ( the asterisk near a name means that    we had to use one of the options that allow to tune the behavior of    cti ) ; top - level predicate : : :    the predicate of interest ; checked : : :    the class of queries _ checked _ by the analyzers of ( * ? ? ?",
    "* ; * ? ? ?",
    "* ;    * ? ? ?",
    "* ) ; result : : :    the best result among those reported in @xcite ( where ,    of course , ` _ _ yes , the program terminates _ _ ' is better than ` _ _ no ,    do nt know _ _ ' ) ; inferred : : :    the termination condition _ inferred _ by cti ( 1 means that any call to    the predicate terminates , 0 means that cti could not find a    terminating mode for that predicate ) ; time : : :    the running time , in seconds , for cti to infer the termination    conditions .",
    "for all the examples presented in table  [ table_results_dds ] , our analyzer is able to infer a class of terminating queries at least as large than the one checked by the analyzers of @xcite ( although we manually tuned cti three times ) .",
    "we point out that termilog @xcite and terminweb @xcite are sometimes able to prove termination whereas cti is not and _",
    "vice versa_.     program & top - level predicate & checked & result & inferred & + permute & @xmath71 & @xmath56 & yes&@xmath56 & 0.03 + duplicate & @xmath72 & @xmath56 & yes&@xmath73 & 0.02 + sum & @xmath74 & @xmath75&yes&@xmath76 & 0.03 + merge & @xmath77 & @xmath75&yes&@xmath78&0.03 + dis - con & @xmath79 & @xmath56 & yes&@xmath56 & 0.03 + reverse & @xmath80 & @xmath81&yes&@xmath56 & 0.02 + append & @xmath82 & @xmath75&yes&@xmath83 & 0.02 + list & @xmath84 & @xmath56 & yes&@xmath56 & 0.01 + fold & @xmath85 & @xmath75&yes&@xmath57 & 0.02 + lte & @xmath86 & @xmath39 & yes&@xmath39 & 0.02 + map & @xmath87 & @xmath56 & yes&@xmath54 & 0.02 + member & @xmath88 & @xmath57 & yes&@xmath57 & 0.01 + mergesort & @xmath89 & @xmath56 & no & @xmath90 & 0.06 + mergesort^*^ & @xmath89 & @xmath56 & no & @xmath56 & 0.07 + mergesort_ap & @xmath91 & @xmath56 & yes&@xmath92 & 0.11 + mergesort_ap^*^ & @xmath91 & @xmath56 & yes&@xmath83 & 0.11 + naive_rev & @xmath93 & @xmath56 & yes&@xmath56 & 0.03 + ordered & @xmath94 & @xmath56 & yes&@xmath56 & 0.01 + overlap & @xmath95 & @xmath75&yes&@xmath96 & 0.01 + permutation & @xmath97 & @xmath56 & yes&@xmath56 & 0.03 + quicksort & @xmath98 & @xmath56 & yes&@xmath56 & 0.06 + select & @xmath99 & @xmath57 & yes&@xmath100 & 0.01 + subset & @xmath101 & @xmath75&yes&@xmath96 & 0.02 + sum & @xmath74 & @xmath92 & yes&@xmath102 & 0.02 + pl2.3.1 & @xmath103 & @xmath56 & no & @xmath90 & 0.01 + pl3.5.6 & @xmath104 & @xmath39 & no & @xmath56 & 0.01 + pl3.5.6a & @xmath104 & @xmath39 & yes&@xmath56 & 0.01 + pl4.0.1 & append3(x , y , z , v)&@xmath105 & yes&@xmath106 & 0.02 + pl4.5.2 & @xmath107 & @xmath56 & no & @xmath90 & 0.03 + pl4.5.3a & @xmath104 & @xmath56 & no & @xmath90 & 0.01 + pl5.2.2 & @xmath108 & @xmath109 & no & @xmath90 & 0.11 + pl7.2.9 & @xmath110 & @xmath75 & yes&@xmath75 & 0.02 + pl7.6.2a & @xmath111 & @xmath109 & no & @xmath90 & 0.02 + pl7.6.2b & @xmath112 & @xmath113&no & @xmath90 & 0.03 + pl7.6.2c & @xmath112 & @xmath113&yes&@xmath114 & 0.04 + pl8.3.1 & @xmath115 & @xmath56 & no & @xmath75 & 0.04 + pl8.3.1a & @xmath115 & @xmath56 & yes&@xmath56 & 0.04 + pl8.4.1 & @xmath116 & @xmath56 & yes&@xmath56 & 0.02 + pl8.4.2 & @xmath117 & @xmath56 & yes&@xmath56 & 0.07 +    [ [ standard - programs - from - the - abstract - interpretation - literature . ] ] standard programs from the abstract interpretation literature .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    table  [ table_results_middle ] presents timings of cti using some standard benchmarks from the lp program analysis community .",
    "we have chosen eleven middle - sized , well - known logic programs .",
    "all the programs are taken from @xcite except credit and plan .",
    "the first column of table  [ table_results_middle ] gives the name of the analyzed program and the second one gives the number of its clauses ( before any program transformation takes place ) .",
    "the following six columns indicate the running times ( minimum execution times over ten runs ) , in seconds , for computing :    @xmath118 : : :    a numeric model ( step  2 ) ; @xmath119 : : :    the constraint over the coefficients of a generic linear level mapping    ( step  3a ) ; @xmath0 : : :    the concrete level mapping ( step  3b ) ; @xmath120 : : :    a boolean model ( step  4 ) ; @xmath121 : : :    the boolean termination conditions ( step  5 ) .",
    "the next column reports the total runtime in seconds while the last column , labeled ` q% ' , expresses the quality of the analysis , computed as the ratio of the number of user - defined predicates that have a non - empty termination condition over the total number of user - defined predicates ( the result of an analysis presents all the user - defined predicates together with their corresponding termination conditions ) .",
    "we note that cti can prove that bid , credit , and plan are _ left - terminating _ : every ground atom left - terminates . for any such program @xmath1",
    ", @xmath122 has only one fixpoint ( * ? ? ?",
    "* theorem  8.13 ) , which may help proving its partial correctness .",
    "moreover , as the ground semantics of such a program is decidable , prolog is its own decision procedure , which does help testing and validating the program .    on the other hand ,",
    "when the quality of the analysis is less than 100% , it means that there exists at least one scc where the inferred termination condition is 0 .",
    "let us call such scc s _ failed sccs_. they are clearly identified , which may help the programmer . here",
    "are some reasons why cti may fail : potential non - termination , poor numeric model , non - existence of a linear level mapping for a predicate with respect to the model , inadequate norm .",
    "also , the analysis of the scc s which depend on a failed scc is likely to fail , but this does not prevent cti from analyzing other parts of the call graph .",
    "program & clauses & & & & & & & q% + ann & 177 & 0.17 & 0.48 & 0.08 & 0.17 & 0.06 & 1.00 & 49% + bid & 50 & 0.03 & 0.04 & 0.02 & 0.02 & 0.02 & 0.14 & 100% + boyer & 136 & 0.07 & 0.06 & 0.02 & 0.08 & 0.02 & 0.30 & 85% + browse & 30 & 0.05 & 0.12 & 0.03 & 0.04 & 0.01 & 0.26 & 60% + credit & 57 & 0.02 & 0.03 & 0.02 & 0.02 & 0.01 & 0.11 & 100% + peephole & 134 & 0.18 & 0.56 & 0.03 & 0.20 & 0.06 & 1.08 & 94% + plan & 29 & 0.02 & 0.03 & 0.01 & 0.02 & 0.02 & 0.11 & 100% + qplan & 148 & 0.20 & 0.52 & 0.12 & 0.18 & 0.07 & 1.13 & 68% + rdtok & 55 & 0.13 & 0.39 & 0.03 & 0.07 & 0.02 & 0.65 & 44% + read & 88 & 0.26 & 1.00 & 0.04 & 0.31 & 0.08 & 1.72 & 52% + warplan & 101 & 0.10 & 0.25 & 0.01 & 0.08 & 0.02 & 0.49 & 33% + & & & & & & + & +    [ [ some - larger - programs . ] ] some larger programs .",
    "+ + + + + + + + + + + + + + + + + + + + +    finally , we have tested cti on the following programs :    * chat is a parser written by f.c.n .  pereira and d.h.d .",
    "warren ; * lptp is an interactive theorem prover for prolog written by r.  strk @xcite ; * pl2wam is the compiler from prolog to wam of gnu - prolog 1.1.2 developed by d.  diaz @xcite ; * slice is a multi - language interpreter developed by r.  bagnara and a.  riaudo ; * symbolic1 seems to be a simulator for a prolog machine .",
    "we do not know the origin of this file .",
    "the results of the analysis are given in table [ reslarger ] .",
    "as explained in the previous section , we set up a timeout of 2 seconds per scc for computing a clp(@xmath9 ) model , the constraints defining level mappings , a clp(@xmath10 ) model , and the termination condition .",
    "so we have a limit of 10 seconds of cpu time per scc .",
    "the last but one column in table  [ reslarger ] summarizes the number of timeouts for steps 2/3a/3b/4/5 , respectively .     program & clauses & & & & & & & timeouts & q% + chat & 515 & 3.89 & 2.78 & 2.84 & 2.85 & 0.35 & 12.80 & 1/1/1/0/0 & 71% + lptp & 1298 & 3.99 & 14.10 & 1.84 & 2.88 & 1.65 & 25.10 & 0/1/0/0/0 & 67% + pl2wam & 1190 & 2.12 & 2.37 & 0.99 & 2.00 & 1.29 & 9.22 & 0/0/0/0/0 & 64% + slice & 952 & 2.20 & 10.46 & 0.13 & 2.08 & 0.93 & 16.20 & 0/3/0/0/0 & 55% + symbolic1 & 923 & 1.49 & 0.67 & 0.04 & 0.61 & 0.29 & 3.47 & 0/0/0/0/0 & 58% +",
    "the compiler of the mercury programming language @xcite includes a termination checker , described in @xcite .",
    "the speed of the analyzer is quite impressive .",
    "we see two reasons for this .",
    "first , the termination checker is written in mercury itself .",
    "second , and most importantly , the analyzer takes high profit of the mode informations that are part of the text of the program being checked . on the other hand , while the running times of cti are bigger , termination inference is a more general problem than termination checking : in the worst case , an exponential number of termination checks are needed to simulate termination inference .",
    "talp @xcite is an automatic tool that transforms a well - moded logic program ( see , e.g. , @xcite ) into a term rewriting system such that termination of the latter implies termination of the former .",
    "the generated term rewriting system is then proved terminating by the cime tool ( http://cime.lri.fr/ ) .",
    "the system seems quite powerful for this class of logic programs .",
    "@xcite made recently a link between backward analysis @xcite and termination analysis , which leads to termination inference .",
    "although they used a completely different scheme for computing level mappings , the results of the analysis on the programs described in tables  [ table_results_dds ] and [ table_results_middle ] were rather similar , both in time and quality , to previous versions of cti that rely on the rational linear solver of sicstus prolog .",
    "thanks to the ppl , cti is now significantly faster ( speed - ups from a factor of two to more than an order of magnitude have been observed ) .",
    "the latest version of terminweb emphasizes termination analysis of typed logic programs .",
    "termination of logic programming where numerical computations are taken into account are studied in @xcite .",
    "the authors present some advanced techniques for explicitly dealing with integers and floating point numbers computations .",
    "the _ size - change termination principle _ has been proposed in @xcite for deciding termination of first - order functional programs .",
    "the resulting analysis is close to the termilog approach @xcite and the authors establish its intrinsic complexity .",
    "finally , we point out that the system ciao - prolog @xcite adopts another approach for termination , based on complexity analysis @xcite .",
    "we have presented cti , the first bottom - up left - termination inference tool for iso - prolog , and its experimental evaluation over standard termination benchmarks as well as middle - sized and larger logic programs . running cti on large programs",
    "shows that the approach scales up satisfactorily .",
    "we believe that , thanks to the parma polyhedra library , cti is today the fastest and most robust termination inference tool for logic programs .",
    "when a scc is too large , computations relying on projection may become too expensive .",
    "so we have added for each computation which may be too costly a timeout and if necessary we are able to return a value which does not destroy the correctness of the analysis , although the quality of the inference is obviously weaker .",
    "it allows cti to keep on analyzing the program . as a side effect ,",
    "the running time of cti is _ linear _ with respect to the number of scc s in the call graph .",
    "finally , one can observe that the termination conditions computed in section [ sec : cti - overview ] are actually _ optimal _ with respect to the language used for describing classes of queries .",
    "can one prove such properties automatically ?",
    "@xcite presents a first step in this direction .",
    "* acknowledgments .",
    "* we would like to thank ulrich neumerkel for numerous discussions we had on termination inference and for the help he provided while debugging cti .",
    "thanks also to the readers of a previous version of this paper for their comments .    *",
    "* cti is distributed under the gnu general public license .",
    "the analyzer , together with the programs analyzed for benchmarking , are available from cti s web site : http://www.cs.unipr.it/cti .",
    "termination of logic programs using semantic unification . in _",
    "logic program synthesis and transformation : proceedings of the 5th international workshop _",
    ", m.  proietti , ed .",
    "lecture notes in computer science , vol .",
    "springer - verlag , berlin , utrecht , the netherlands , 219233 .      , ricci , e. , zaffanella , e. , and hill , p.  m. 2002 .",
    "possibly not closed convex polyhedra and the parma polyhedra library . in _",
    "static analysis : proceedings of the 9th international symposium _ ,",
    "m.  v. hermenegildo and g.  puebla , eds .",
    "lecture notes in computer science , vol . 2477 .",
    "springer - verlag , berlin , madrid , spain , 213229 .      ,",
    "cabeza , d. , carro , m. , hermenegildo , m. , lpez - garca , p. , and puebla , g. 1997 .",
    "the ciao prolog system .",
    "reference manual .",
    "clip3/97.1 , school of computer science , technical university of madrid ( upm ) .",
    "available from http://www.clip.dia.fi.upm.es/.    , de  la banda , m.  g. , and hermenegildo , m.  v. 1994 .",
    "effectiveness of global analysis in strict independence - based automatic program parallelization . in _ logic programming : proceedings of the 1994 international symposium _",
    ", m.  bruynooghe , ed .",
    "mit press series in logic programming .",
    "the mit press , ithaca , ny , usa , 253268 .              \\1978 . automatic discovery of linear restraints among variables of a program . in _",
    "conference record of the fifth annual acm symposium on principles of programming languages_. acm press , tucson , arizona , 8496 .    , kelly , a.  d. , and sndergaard , h. 1996 .",
    "a comparison of three occur - check analysers . in _",
    "static analysis : proceedings of the 3rd international symposium _",
    ", r.  cousot and d.  a. schmidt , eds .",
    "lecture notes in computer science , vol .",
    "springer - verlag , berlin , aachen , germany , 159173 .",
    ", lpez - garca , p. , hermenegildo , m.  v. , and lin , n .- w .",
    "1994 . estimating the computational cost of logic programs . in _ static analysis : proceedings of the 1st international symposium _ , b.  le charlier , ed .",
    "lecture notes in computer science , vol .",
    "springer - verlag , berlin , namur , belgium , 255265 .          ,",
    "ferrand , g. , and tguia : , m. 1991 .",
    "programs ( not subject to occur - check ) . in _ logic programming : proceedings of the 1991 international symposium _ , v.  a. saraswat and k.  ueda , eds .",
    "mit press series in logic programming . the mit press , san diego , usa , 533547 .      ,",
    "grumberg , o. , katz , s. , and pnueli , a. 1985 .",
    "proving termination of prolog programs . in",
    "_ proceedings of third workshop on logics of programs _ , r.  parikh , ed .",
    "lecture notes in computer science , vol .",
    "springer - verlag , berlin , brooklyn , new york , 89105 .          ,",
    "puebla , g. , and bueno , f. 2000 .",
    "an assertion language for constraint logic programs . in _ analysis and visualization tools for constraint programming _ , p.  deransart , m.  v. hermenegildo , and j.  mauszyski , eds .",
    "lecture notes in computer science , vol .",
    "springer - verlag , berlin , 2361 .",
    ", jones , n.  d. , and ben - amram , a.  m. 2001 .",
    "the size - change principle for program termination . in _ proceedings of the 28th acm sigplan - sigact symposium on principles of programming languages ( popl-01 ) _ , c.  norris and j.  j.  b. fenwick , eds .",
    "acm sigplan notices , vol .",
    "association for computing machinery , london , uk , 8192 .",
    "contributions to a theory of txistential termination for definite logic programs . in _ proceedings of the `` 1995 joint conference on declarative programming ( gulp - prode95 ) ''",
    "_ , m.  alpuente and m.  i. sessa , eds .",
    "marina di vietri , italy , 631642 .",
    "automatic termination analysis of logic programs . in _ logic programming : proceedings of the fourteenth international conference on logic programming _ ,",
    "l.  naish , ed .",
    "mit press series in logic programming .",
    "the mit press , leuven , belgium , 6377 .      \\1996 .",
    "proving existential termination of normal logic programs . in _ proceedings of the fifth international conference on algebraic methodology and software technology ( amast96 )",
    "_ , m.  wirsing and m.  nivat , eds .",
    "lecture notes in computer science , vol . 1101 .",
    "springer - verlag , berlin , munich , germany , 375390 .",
    "\\1996 . inferring left - terminating classes of queries for constraint logic programs by means of approximations . in _ logic programming : proceedings of the joint international conference and symposium on logic programming _ , m.  j. maher , ed .",
    "mit press series in logic programming . the mit press , bonn , germany , 721 .",
    "termination detection in logic programs using argument sizes . in _ proceedings of the tenth acm sigact - sigmod - sigart symposium on principles of database systems_. association for computing machinery , denver , colorado , 216226 . extended abstract .",
    "an application of abstract interpretation of logic programs : occur check reduction . in",
    "_ proceedings of the 1986 european symposium on programming _ , b.  robinet and r.  wilhelm , eds .",
    "lecture notes in computer science , vol .",
    "springer - verlag , berlin , saarbrcken , federal republic of germany , 327338 .    ,",
    "somogyi , z. , and sndergaard , h. 1997 .",
    "termination analysis for mercury . in _",
    "static analysis : proceedings of the 4th international symposium _ , p.  van hentenryck , ed .",
    "lecture notes in computer science , vol .",
    "springer - verlag , berlin , paris , france , 157171 ."
  ],
  "abstract_text": [
    "<S> we present cti , the first system for universal left - termination inference of logic programs . </S>",
    "<S> termination inference generalizes termination analysis and checking . </S>",
    "<S> traditionally , a termination analyzer tries to prove that a given class of queries terminates . </S>",
    "<S> this class must be provided to the system , for instance by means of user annotations . moreover </S>",
    "<S> , the analysis must be redone every time the class of queries of interest is updated . </S>",
    "<S> termination inference , in contrast , requires neither user annotations nor recomputation . in this approach , terminating classes for all predicates are inferred at once . </S>",
    "<S> we describe the architecture of cti and report an extensive experimental evaluation of the system covering many classical examples from the logic programming termination literature and several prolog programs of respectable size and complexity .    </S>",
    "<S> termination inference ; termination analysis ; logic programming ; abstract interpretation . </S>"
  ]
}