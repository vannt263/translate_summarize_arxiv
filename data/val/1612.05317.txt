{
  "article_text": [
    "in synchronous distributed models of computation , the number of rounds ( also called the round complexity ) is one of the most important complexity measures , especially when we want to design fast distributed algorithms . from a complexity - theoretic point of view",
    ", seeking low - round complexity leads to clarifying how much parallelism the problem inherently has .",
    "this would be reminiscent of the study of shallow circuit classes ( e.g. , @xmath6 ) , in which the depth of a circuit solving a problem corresponds to the inherent parallelism of the problem . in this paper , we study distributed algorithms with low - round complexity .",
    "the round complexity is closely related to the diameter of the underlying graph of a given network .",
    "this is because , when computing global properties of the network , it necessarily takes at least as many rounds for message exchanges as the value of the diameter for some party to get information from the farthest party .",
    "therefore , when every party s initial knowledge includes an upper bound @xmath7 on the diameter , the ultimate goal is to achieve a round complexity close to ( typically , linear in ) @xmath7 . in particular , we are interested in whether the round complexity @xmath8 ( resp . , @xmath0 ) can be achieved when every party s initial knowledge includes the number @xmath3 of parties ( resp .",
    ", an upper bound @xmath1 on @xmath3 ) .",
    "this can actually be achieved in a straightforward manner if there is a unique party ( called the leader ) distinguishable from the others or , almost equivalently , if every party has its own identity : the unique leader , which can be elected in @xmath9 rounds if every party has its own identity , can gather all the distributed inputs , solve the problem , and distribute the solution to every party in @xmath9 rounds . however , it is not a simple task to bound the achievable round complexity for networks where no party has its own identity ( namely , all parties with the same number of communication links are identical ) .",
    "such a network is called an _ anonymous network _ , which was first introduced by angluin  @xcite to examine how much each party in a network needs to know about its own identity and other parties ( e.g. , refs .",
    "@xcite ) , and thereby understand the fundamental properties of distributed computing .",
    "it has been revealed in the literature that anonymous networks make it highly non - trivial or even impossible to exactly solve many distributed problems , including the leader election one , that are easy to solve on non - anonymous networks ( i.e. , the networks in which every party has its own identity ) . here , by `` exactly solve '' ,",
    "we mean `` solve without error within a bounded time '' .",
    "the good news is that if the number @xmath3 of parties is provided to each party , all solvable problems can be solved exactly in @xmath8 rounds is given , all solvable problems can be solved in @xmath10 rounds  @xcite . ] for any unknown underlying graph by constructing tree - shaped data structures , called universal covers  @xcite or views  @xcite .",
    "obviously , however , this does not help us deal with the infinitely many instances of fundamental problems that are impossible to solve on anonymous networks .",
    "the best known among them is the leader election problem ( @xmath11 ) , the problem of electing a unique leader .",
    "there are infinitely many @xmath3 such that @xmath11 can not be solved exactly for anonymous networks with certain underlying graphs over @xmath3 nodes even if @xmath3 is provided to each party  @xcite .",
    "the above situation changes drastically if quantum computation and communication are allowed on anonymous networks ( called _ anonymous quantum networks _ ) : @xmath11 can be solved exactly for any unknown underlying graph , even when only an upper bound @xmath1 on @xmath3 is provided to every party  @xcite .",
    "this implies that , if a problem is solvable in non - anonymous networks , then it is also solvable in anonymous quantum networks . for the round complexity , however , the known quantum algorithms for electing a unique leader require super - linear rounds in @xmath1 ( or @xmath3 when @xmath3 is provided ) @xcite .",
    "motivated by this situation , we study the linear - round exact solvability of another fundamental problem , the solitude verification problem ( @xmath12 )  @xcite , in anonymous quantum networks .",
    "the goal of @xmath12 is to verify that there is a unique contender in a network with an unknown set of contenders ( which may be empty ) among the @xmath3 parties .",
    "although the final target is to clarify whether a unique leader can be _ elected _ in linear rounds or not , @xmath12 would be a natural choice as the first step .",
    "this is because @xmath12 is a subproblem of many common problems , including the leader election problem : a unique leader can be elected by repeating attrition and solitude verification as observed in ref .",
    "another reason is that @xmath12 is one of the simplest nontrivial problems concerned with the global properties of a given network , as pointed out in ref .",
    "indeed , @xmath12 is not always solvable in the classical case : one can easily show , by modifying the proof of theorem 4.5 in ref .",
    "@xcite , that it is impossible to exactly solve @xmath12 on any anonymous classical network whose underlying graph is not a tree if only an upper bound @xmath1 is provided to each party ( the problem can be solved exactly in @xmath8 rounds if @xmath3 is provided ) . in the quantum setting ,",
    "the only quantum algorithms for @xmath12 are the straightforward ones that first elect a unique leader ( with a super - linear round complexity ) , who then verifies that there is a unique contender .",
    "recently , kobayashi et al .",
    "@xcite proposed an @xmath0-round quantum algorithm when each communication link in the network is bidirectional , i.e. , the underlying graph is undirected .",
    "however , their algorithm _ can not _ work in the more general case where the underlying graph is directed .",
    "this is due to a technicality that is distinctive in quantum computing : their algorithm uses a standard quantum technique to erase `` garbage '' information generated in the course of computation .",
    "the technique inverts some operations that have been performed and thus involves sending back messages via bidirectional communication links in the distributed computing setting .",
    "let @xmath13 be the set of all strongly connected digraphs with @xmath3 nodes .",
    "our main result is an @xmath0-round quantum algorithm that exactly solves @xmath12 , where the input to each party is a binary value indicating whether the party is a contender or not ( see sec .  [",
    "sec : defofsvandle ] for a more formal definition ) .",
    "[ th : sv ] there exists a quantum algorithm that , if an upper bound @xmath1 on the number @xmath3 of parties is provided to each party , exactly solves @xmath14 in @xmath0 rounds with bit complexity @xmath15 on an anonymous network with any unknown underlying graph in @xmath13 .",
    "as described previously , we are most interested in whether @xmath11 can be solved exactly in @xmath0 rounds . for the present",
    ", we do not have an answer to this question .",
    "we can , however , obtain a partial answer as a corollary of theorem  [ th : sv ] : there exists an @xmath0-round _ zero - error _ quantum algorithm for @xmath11 . here",
    ", we say that a problem is solved with zero error if there exists an algorithm that outputs a correct answer with probability at least @xmath16 and gives up with probability at most @xmath17 , where @xmath17 is some non - negative constant less than @xmath18 .",
    "we can assume without loss of generality that @xmath17 is an arbitrarily small constant , since a constant number of repetitions reduce the `` give - up '' probability to an arbitrary small constant , which changes the complexity by at most a constant factor .",
    "[ cr : le ] there exists a zero - error quantum algorithm that , if an upper bound @xmath1 on the number @xmath3 of parties is provided to each party , solves @xmath19 in @xmath0 rounds with bit complexity @xmath20 on an anonymous network with any unknown underlying graph in @xmath13 .",
    "this implies that in the quantum setting , anonymous networks can be converted to the corresponding non - anonymous ones without error in @xmath0 rounds on average , since a unique leader can assign a unique number to each party in @xmath0 rounds ( in the worst case ) . in the special case of @xmath21 ,",
    "if a classical problem is solvable in a non - anonymous classical / quantum network in @xmath8 rounds with a polynomial bit complexity , then in the corresponding anonymous networks the problem is still solvable without error in @xmath8 rounds on average with a polynomial bit complexity whenever quantum computation and communication are allowed .",
    "we next consider a generalization of theorem  [ th : sv ] .",
    "note that we can think of @xmath12 as the problem of deciding whether the hamming weight ( i.e. , the sum ) of the @xmath3 input bits is exactly one or not , which is equivalent to computing the corresponding symmetric function . as generalizations of this function , let us consider a collection @xmath22 , for @xmath5 , of all symmetric boolean functions @xmath23 such that @xmath24 is constant over all @xmath25 with @xmath26 .",
    "note that @xmath27 for each @xmath28 $ ] , and @xmath22 for any @xmath29 represents the set of all symmetric functions over @xmath3 bits .",
    "in particular , the function corresponding to @xmath12 belongs to @xmath30 .",
    "we then have the following theorem .",
    "[ th : symmetric ] suppose that there are @xmath3 parties on an anonymous network with any unknown underlying graph in @xmath13 in which an upper bound @xmath1 on @xmath3 is provided to each party . for every @xmath31 with @xmath5 , there exists a quantum algorithm that exactly computes @xmath24 over distributed input @xmath32 on the network in @xmath2 rounds with a bit complexity bounded by some polynomial in @xmath1 .",
    "note that an @xmath0-round quantum algorithm for @xmath11 would imply that all solvable problems , including computing @xmath33 , can be solved in @xmath0 rounds ( since the leader can convert the anonymous network into the corresponding non - anonymous one ) .",
    "computing @xmath34 is thus something lying between @xmath12 and @xmath11 with respect to linear - round solvability .",
    "recall that the reason the @xmath0-round leader election algorithm in ref .",
    "@xcite does not work on directed graphs",
    "is that it sends back messages via bidirectional communication links to erase `` garbage '' information produced in the course of computation .",
    "this seems inevitable as it uses ( a version of ) the quantum amplitude amplification  @xcite ( or a special case of the general quantum amplitude amplification  @xcite ) .",
    "it is a critical issue , however , when the underlying graph is directed , since , although strong connectivity ensures at least one directed path on which the message could be sent back , parties can not identify the path in the anonymous network ( since the original sender of the message can not be identified ) . in the classical",
    "setting , such an issue can not arise since the message need not be sent back ( the sender has only to keep a copy of the message if it needs to ) .",
    "our idea for resolving this issue is to employ the symmetry - breaking procedure introduced in ( * ? ? ?",
    "* sec .  4 ) .",
    "the procedure was used to solve the leader election problem as follows : initially , all parties are candidates for the leader and they repeatedly perform a certain distributed procedure that reduces the set @xmath35 of the candidates by at least 1 . more concretely , the procedure partitions @xmath35 into at least two subsets if @xmath36 and removes one of them from @xmath35 .",
    "a simple but effective way of viewing this is that it not only reduces @xmath35 but decides whether @xmath37 is at least two or not , since it can partition @xmath35 only when there are at least two candidates .",
    "this observation would exactly solve @xmath12 by regarding @xmath35 as the set of contenders if the procedure outputs the correct answer with certainty .",
    "however , the procedure heavily depends on the following unknowns : the cardinality of @xmath35 and the number @xmath3 of parties . in ref .",
    "@xcite , a similar problem arises when deciding whether an @xmath3-bit string @xmath38 is of hamming weight at most @xmath18 , and it is resolved by running a base algorithm in parallel for all possible guesses at @xmath39 and making the decision based on the set of all outputs ( the `` base algorithm '' uses amplitude amplification and is totally different from the symmetry - breaking approach ) .",
    "together with a simple algorithm for testing whether @xmath38 is the all - zero string , the parallel execution of the base algorithm is used in the leader election algorithm  @xcite to verify that a random @xmath38 is of hamming weight exactly one .",
    "this verification framework actually works in our case , and it underlies the entire structure of our algorithm .",
    "namely , we replace the base algorithm in the framework with a subroutine constructed by carefully combining the symmetry - breaking procedure introduced in ref .",
    "@xcite with classical techniques related to the view  @xcite .",
    "this means that all parties collaborate to perform this subroutine in parallel for all possible pairs of guesses at @xmath40 .",
    "the round complexity is thus equal to the number of rounds required to perform the subroutine once , i.e. , @xmath0 rounds . to show the correctness , we prove that the set of the outputs over all possible pairs of the guesses yields the correct answer to any @xmath12 instance with certainty .",
    "this needs an in - depth and careful analysis of all operations of which our algorithm consists for every pair not necessarily equal to @xmath40 .    before the present work",
    ", it has seemed as if the symmetry - breaking approach introduced in refs .",
    "@xcite is entirely different from the amplitude amplification approach used in ref .",
    "our algorithm first demonstrates that these approaches are quite compatible , and , indeed , the technical core of refs .",
    "@xcite can effectively function in the algorithmic framework proposed in ref .",
    "this would contribute to a better understanding of distributed quantum computing and would be very helpful for future studies of quantum algorithms .",
    "our algorithm can be generalized to the case of computing a family @xmath34 of more general symmetric functions as follows : all parties collaborate to partition @xmath35 into subsets by recursively applying the procedure up to @xmath41 levels .",
    "if there is a singleton set among the subsets at a certain recursion level , then the algorithm stops and all parties elect the only member of the subset as a leader , who can compute @xmath37 and thus compute the value of the given function in @xmath42 . if no singleton set appears even after the@xmath41-th recursion level , there must be more than @xmath4 parties in @xmath35 , in which case any function in @xmath42 is constant by the definition .",
    "pal , singh , and kumar  @xcite and dhondt and panangaden  @xcite dealt with @xmath11 and the ghz - state sharing problem in a different setting , where pre - shared entanglement is assumed but only classical communication is allowed .",
    "the relation between several network models that differ in available quantum resources has been discussed by gavoille , kosowski , and markiewicz  @xcite .",
    "recently , elkin et al .",
    "@xcite proved that quantum communication can not substantially speed up algorithms for some fundamental problems , such as the minimum spanning tree , compared to the classical setting . for fault - tolerant distributed quantum computing ,",
    "the byzantine agreement problem and the consensus problem were studied by ben - or and hassidim  @xcite and chlebus , kowalski , and strojnowski  @xcite , respectively . in the cryptographic context where there are cheating parties , refs .",
    "@xcite devises quantum algorithms that elect a unique leader with a small bias .",
    "some quantum distributed protocols were experimentally demonstrated by gaertner et al .",
    "@xcite and okubo et al .",
    "@xcite .",
    "see the surveys  @xcite and the references therein for more work on distributed quantum computing .",
    "section 2 defines the network model and the problems considered in this paper .",
    "it then mentions several known facts employed in the subsequent sections .",
    "section 3 provides the structure of our algorithm and then proves theorem  [ th : sv ] assuming several properties of the key subroutine @xmath43 .",
    "section 4 describes @xmath43step by step and presents numerous claims and propositions to show how each step takes effect .",
    "section 5 proves all the claims and propositions appearing in section  4 and then completes the proof that @xmath43has the properties assumed in section  3 .",
    "section 6 proves corollary  [ cr : le ] , and then generalizes theorem  [ th : sv ] for proving theorem  [ th : symmetric ] .",
    "let @xmath44 be the set of all complex numbers , @xmath45 the set of all positive integers , and @xmath46 the set of all non - negative integers .",
    "for any @xmath47 with @xmath48 , @xmath49 $ ] denotes the set @xmath50 , and @xmath51 $ ] represents @xmath52 $ ] .",
    "we first define a classical model and then adapt it to the quantum model , where every party can perform quantum computation and communication .",
    "a classical _ distributed network _ consists of multiple parties and _ unidirectional _ communication links , each of which connects a pair of parties . by regarding the parties and links as nodes and edges , respectively , in a graph",
    ", the topology of the distributed network can be represented by a strongly connected digraph ( i.e. , directed graph ) , which may have multiple edges or self - loops .",
    "a natural assumption is that every party can distinguish one link from another among all communication links incident to the party ; namely , it can assign a unique label to every such link .",
    "we associate these labels with _",
    "communication ports_. since every party has _ incoming _ and _ outgoing _ communication links ( although a self - loop is a single communication link , it looks like a pair of incoming and outgoing links for the party ) , it has two kinds of _ communication ports _ accordingly : _ in - ports _ and _ out - ports_. for a more formal definition in graph theory terms , we modify the definition given in ref .",
    "@xcite , which assumes undirected graphs : the underlying digraph @xmath53 of the distributed network has a _ port - numbering _ , which is a set of paired functions @xmath54 such that for each node @xmath55 with in - degree @xmath56 and out - degree @xmath57 , the function @xmath58 ( resp . , @xmath59 ) is a bijective map from the set of incoming edges ( resp .",
    ", outgoing edges ) incident to @xmath55 to the set @xmath60 $ ] ( resp .",
    ", @xmath61 $ ] ) .",
    "it is stressed that each function pair @xmath62 is defined independently of any other pair @xmath63 with @xmath64 . for the sake of convenience , we assume that each edge @xmath65 is labeled with the pair of the associated out - port and in - port ( of the two different parties ) ; namely , @xmath66,\\sigma_v^{\\text{in}}[e])$ ] ( each party can know the labels of edges incident to it by only a one - round message exchange as described in example  [ example ] ) . in our model , each party knows the number of its in - ports and out - ports and can choose one of its in - ports or one of its out - ports in any way whenever it sends or receives a message .    in distributed computing ,",
    "what information each party initially possesses has a great impact on complexity .",
    "let @xmath67 be the information that only party @xmath68 initially knows , such as its local state and the number of its ports .",
    "let @xmath69 be the information initially shared by all parties .",
    "we may call @xmath67 and @xmath69 _ local _ and _ global _ information , respectively .    without loss of generality , we assume that every party @xmath68 runs the same algorithm with @xmath70 as its arguments ( or the input to the algorithm ) , in addition to the instance @xmath71 of a problem to solve",
    ". we will not explicitly write @xmath70 as input to algorithms when it is clear from the context .",
    "note that @xmath70 is not part of the problem instance but part of the model .",
    "also note that the algorithm may invoke subroutines with part of @xmath72 as _ input to the subroutine_. if all parties in a network have the same local information except for the number of their ports , the network is said to be _ anonymous _ , and the parties in the anonymous network are said to be anonymous . in this paper",
    ", we assume that for each party @xmath68 , @xmath67 consists of a common initial state , a common description of the same algorithm , and the numbers @xmath73 of in - ports and out - ports .",
    "an extreme case of networks is a regular graph , such as a directed ring , in which case each party is identical to any other party ; that is , effectively , every party has the same identifier . obviously , the difficulty of solving a problem depends on the underlying graph . moreover , it may also depend on port - numberings .",
    "this can be intuitively understood from example  [ example ] .",
    "when solving problems on distributed networks , we do not assume a particular port - numbering ; in other words , we say that a problem can be solved if there is an algorithm that solves the problem for _ any _ port - numbering .",
    "this paper deals with only anonymous networks but may refer to a party with its index ( e.g. , party @xmath74 ) only for the purpose of clear descriptions .",
    "our goal is to construct an algorithm that works for _ any _ port - numbering on _ any _ digraph in @xmath13 , where @xmath13 denotes the set of all @xmath3-node strongly connected digraphs , which may have multiple edges or self - loops , and is used through this paper .",
    "[ example ] _ fig . _",
    "@xmath75 shows two anonymous networks , @xmath76 and @xmath77 , on the same four - node regular graph with different port - numberings @xmath78 and @xmath79 , respectively , where @xmath80 each party has two in - ports and two out - ports , and @xmath81 each directed edge @xmath82 is labeled with @xmath83 and @xmath84 on networks @xmath76 and @xmath77 , respectively , where @xmath85 @xmath86resp .",
    ", @xmath87@xmath88 is put on the source side and @xmath89 @xmath86resp .",
    ", @xmath90@xmath88 is put on the destination side .",
    "observe that each party can know the label of each incoming edge incident to the party by exchanging a message@xmath91 each party sends a message ",
    "@xmath74 \" out via every out - port @xmath74 , and if another party receives this message via in - port @xmath92 , the receiver concludes that it has an incoming edge with label @xmath93 . to elect a unique leader on network @xmath76 in _ fig . _",
    "@xmath75 , consider the following game : @xmath80 if a party has an incoming edge with label @xmath93 , then it scores 1 point if @xmath94 @xmath86win@xmath88 , 0 points if @xmath95 @xmath86draw@xmath88 , -1 point if @xmath96 @xmath86lose@xmath88@xmath97 @xmath81 each party earns the the sum of points over all its incoming edge@xmath97 and @xmath98 a party wins the game if it earns the largest sum of points among all parties .",
    "it is easy to see that each party can compute the sum of points as we observed . in the case of @xmath76 ,",
    "the upper - left party is the unique winner : it earns 1 point in total , while the others earn @xmath99 or @xmath100 points .",
    "this fact can be used to elect a unique leader . in the case of @xmath77 , however , all parties earn @xmath99 points .",
    "hence , the above game can not elect a unique leader .",
    "actually , no deterministic algorithm can elect a unique leader in the case of @xmath77  _",
    "@xcite_.        a network is either _ synchronous _ or _",
    "asynchronous_. in the synchronous case , message passing is performed synchronously .",
    "the unit interval of synchronization is called a _ round _ ,",
    "which consists of the following sequential execution of the two ( probabilistic ) procedures that are defined in the algorithm invoked by each party  @xcite : one procedure changes the local state of the party depending on the current local state and the incoming messages , and then removes the messages from ports ; the other procedure then prepares new messages and decides the ports through which the messages should be sent , depending on the current local state , and finally the messages are sent out via the ports .",
    "we do not impose any limit on the number of bits in a message sent in each round .",
    "a network that is not synchronous is _ asynchronous_. in asynchronous networks , every party can send messages at any time and the time it takes for a message to go through a communication link is finite but not bounded .",
    "this paper deals with synchronous networks for simplicity , but our algorithms can be emulated in asynchronous networks without sacrificing the communication cost by just delaying the local operation that would be done in each round in the synchronous setting until a message arrives at every port .    the only difference between the quantum and classical models is that every party can perform quantum computation and communication in the former model [ for the basics of quantum computation and communication , we refer readers to standard textbooks ( e.g. , refs .",
    "@xcite ) ] .",
    "more concretely , the two procedures for producing messages and changing local states are replaced with physically realizable super - operators ( i.e. , a trace - preserving completely positive super - operator ) that act on the registers storing the local quantum state and quantum messages received to produce new quantum messages and a new local quantum state and to specify port numbers .",
    "accordingly , we assume that every communication link can transfer quantum messages . for sending quantum messages at the end of each round , each party sends out one of its quantum registers through the specified out - port .",
    "the party then receives quantum registers from its neighbors at the beginning of the next round and uses them for local quantum computation .",
    "this paper focuses on the required number of rounds as the primary complexity measure ( called _ round complexity _ ) .",
    "this is often used as an approximate value of time complexity , which includes the time taken by local operations as well as the time taken by message exchanges .",
    "although our primary goal is to construct algorithms with low round complexities , our algorithms all have bit complexities bounded by certain polynomials in the given upper bound on the number of parties ( _ or _ polynomial bit complexities for short ) , where the _ bit complexity _ of an algorithm is the number of bits or qubits communicated by the algorithm ( a.k.a .",
    ", communication complexity ) .",
    "finally , we assume that there are no faulty parties and no faulty communication links .",
    "let @xmath101 .",
    "for any bit string @xmath102 , let @xmath39 be the hamming weight of @xmath38 , i.e. , the number of @xmath18 s in @xmath38 .",
    "for any @xmath103 , without loss of generality , we assume that @xmath104 is identified with the set @xmath51 $ ] .    for any @xmath105 , let @xmath106 be the symmetric boolean function that is @xmath107 if and only if @xmath39 is equal to @xmath4 for input @xmath102 distributed over @xmath3 parties ( i.e. , each party is in possession of one of the @xmath3 bits ) .",
    "note that @xmath4 may be larger than @xmath3 , in which case @xmath108 is @xmath109 for all @xmath102 .",
    "the function @xmath110 is hence well - defined even if each party does not know the integer @xmath3 ( since the value of @xmath110 depends not on @xmath3 but on @xmath4 and @xmath39 ) .",
    "we also define @xmath111 as the symmetric boolean function such that @xmath112 is @xmath107 if and only if @xmath113 for @xmath102 ; namely , @xmath114 . note again that @xmath115 is well - defined even if @xmath3 is unknown .",
    "the _ solitude verification problem _ is equivalent to computing @xmath116 as can be seen from the following definition .",
    "suppose that there is a distributed network with any underlying graph @xmath117 , which is unknown to any party .",
    "suppose further that each party @xmath118 $ ] in the network is given as input a boolean value @xmath119 and a variable @xmath120 initialized to @xmath107 .",
    "the goal is to set @xmath121 for every @xmath118 $ ] , where @xmath122 .",
    "if every party has a unique identifier picked from , say , @xmath51 $ ] , this problem can easily be solved by simply gathering all @xmath123 s to the party numbered @xmath18 ( although the complexity may not be optimal ) . on anonymous networks , however , this simple idea can no longer work since the parties do not have a unique identifier .",
    "if the global information @xmath69 includes the _ exact _ number @xmath3 of parties , @xmath14 can be solved deterministically by a non - trivial algorithm , which runs in @xmath8 rounds with a polynomial bit complexity  @xcite . in a more general case , however , this is impossible .",
    "[ fact : sv ] there are infinitely many @xmath101 such that , if only an upper bound on the number @xmath3 of the parties is provided to each party as global information , @xmath14 can not be solved in the zero - error @xmath86i.e . , las vegas@xmath88 setting as well as in the exact setting on anonymous classical networks with a certain underlying graph @xmath117 .",
    "our main contribution is a quantum algorithm that exactly computes the function @xmath124 in rounds linear in @xmath1 even if only an upper bound @xmath1 on @xmath3 is provided .",
    "this implies that there exists a quantum algorithm that exactly computes @xmath125 ( and thus @xmath12 ) in rounds linear in @xmath1 , since there is a simple ( classical ) deterministic algorithm for computing @xmath126 ( i.e. , the negation of @xmath127 over all input bits ) .",
    "we next define the leader election problem , which is closely related to @xmath12 .",
    "suppose that there is a distributed network with any underlying graph @xmath117 , which is unknown to any party .",
    "suppose further that each party @xmath128 $ ] is given a variable @xmath129 initialized to @xmath18 .",
    "the goal is to set @xmath130 for arbitrary but unique @xmath131 $ ] and @xmath132 for every remaining @xmath118\\setminus \\{k\\}$ ] .",
    "@xmath11 is a fundamental problem with a long history of research starting from the dawn of distributed computing ; there are a lot of studies on efficient algorithms for solving it on non - anonymous networks . on anonymous networks , however , it is impossible to exactly solve @xmath11 .",
    "[ fact : le ] there are infinitely many @xmath101 such that , even if the number @xmath3 is provided to each party as global information , @xmath19 can not be solved exactly on anonymous classical networks with a certain underlying graph @xmath117 .",
    "moreover , if only an upper bound on @xmath3 is provided to each party , it is impossible to solve @xmath11 even with zero - error .    actually , the former part of this fact is a corollary of a more general theorem proved in ref .",
    "@xcite , which provides a necessary and sufficient condition on underlying graphs and port - numbering for exactly solving @xmath11 when every party knows the number @xmath3 as its global information .",
    "the latter part of fact  [ fact : le ] ( i.e. , the zero - error unsolvability of @xmath11 ) follows from fact  [ fact : sv ] and the fact is one : the leader first assigns a unique identifier to each party .",
    "it then gathers all @xmath123 together with the identifier of the owner of @xmath123 ( along a spanning tree after setting it up ) . ]",
    "that @xmath12 is reducible to @xmath11 .",
    "in contrast , it is _ possible _ to solve the problems on anonymous _ quantum _ networks .",
    "[ fact : stacs05 ] there exists a quantum algorithm that , for every @xmath101 with @xmath133 , if an upper bound @xmath1 on @xmath3 is provided to each party as global information , _ exactly _ solves @xmath19 in @xmath134 rounds with a polynomially bounded bit complexity @xmath135 on an anonymous network with any unknown underlying graph @xmath117 , where @xmath136 is the bit complexity of constructing the view  _ @xcite _ , a tree - like data - structure , of depth @xmath0 .",
    "the best known bound on @xmath136 is @xmath137  _",
    "@xcite_.    when an upper bound @xmath7 on the diameter of the graph is provided to each party , the round complexity becomes @xmath138 by using the recent result on the view in ref .  _",
    "@xcite_.    we next provide a powerful primitive in classical distributed computing : a linear - round algorithm that deterministically computes any symmetric function on anonymous networks .",
    "this algorithm is actually obtained from a more generic one that effectively uses the full - power of deterministic computation in the anonymous classical network : during the execution of the generic algorithm , every party constructs a tree - like data structure , called _ view _",
    "@xcite , which contains as much information as it can gather in the anonymous network . in terms of graph theory ,",
    "the view of depth @xmath4 is defined for each node @xmath55 , and it is a labeled tree rooted at @xmath55 that is obtained by sharing the maximal common suffix of every pair of @xmath4-length directed paths to the node @xmath55 .",
    "it is not difficult to see that the view of depth @xmath4 can be constructed by exchanging messages @xmath4 times  @xcite as follows : ( 1 ) every party creates a @xmath99-depth view , which is nothing but a single node , @xmath139 , labeled by the input to the party ; ( 2 ) for each @xmath140 in this order , each party sends its @xmath141-depth view to every neighbor , receives a @xmath141-depth view from every neighbor , and then makes a @xmath92-depth view by connecting the node @xmath139 with the roots of received views by edges labeled with port numbers . since it is proved in ref .",
    "@xcite that setting @xmath142 is necessary and sufficient to gather all the information in the network , @xmath143-depth views need to be constructed in general for solving problems . for @xmath142 , the above nave construction algorithm obviously has an exponential bit complexity in @xmath3 , but it is actually possible to compress each message so that the total bit complexity is polynomially bounded in @xmath3  @xcite . since the hamming weight @xmath39 of @xmath3 distributed input bits can be locally computed as a rational function of the number @xmath3 and the number of non - isomorphic subtrees of depth @xmath144 in the view  @xcite , every party can compute any symmetric function on @xmath38 from its view whenever @xmath3 is given .",
    "this algorithm is summarized as follows .",
    "[ th : view ] for any @xmath101 with @xmath133 , suppose an anonymous network with any unknown underlying graph @xmath117 , where the number @xmath3 of parties is given to each party as global information .",
    "then , there exists a deterministic algorithm that computes any symmetric function over @xmath3 distributed input bits in @xmath8 rounds with bit complexity @xmath145 , where @xmath146 is the function defined in fact  @xmath147 .    to exactly compute the symmetric function with this algorithm",
    ", every party needs to know the exact number @xmath3 of the parties . nevertheless , even when a wrong @xmath148 is provided instead of @xmath3 , the algorithm can still run through and output some value .",
    "namely , it constructs the view of depth @xmath149 for every party and outputs the value of the rational function over the number @xmath150 and the number of isomorphic subtrees in the view , as can be seen from the above sketch of the algorithm .",
    "this requires @xmath151 rounds and @xmath152 bits of communication .",
    "in fact , we will use this algorithm for a guess @xmath150 at @xmath3 ( this @xmath150 is not necessarily equal to @xmath3 ) .",
    "although the output may be wrong , the set of the outputs over all possible guesses @xmath150 s contains useful information as will be described in the following sections .    finally , we define some terms .",
    "suppose that each party @xmath68 has a @xmath153-bit string @xmath154 ( i.e. , the @xmath3 parties share a @xmath155-bit string @xmath156 ) .",
    "given a set @xmath157}$ ] , the string @xmath158 is said to be _ consistent _ over @xmath35 if @xmath159 has the same value for all @xmath68 in @xmath35 .",
    "otherwise , @xmath158 is said to be _ inconsistent _ over @xmath35 .",
    "in particular , if @xmath35 is the empty set , then any string @xmath158 is consistent over @xmath35 .",
    "we also say that a @xmath155-qubit pure state @xmath160 shared by the @xmath3 parties is _ consistent ( inconsistent ) _ over @xmath35 if @xmath161 only for @xmath158 s that are consistent ( inconsistent ) over @xmath35 .",
    "note that there are pure states that are neither consistent nor inconsistent over @xmath35 ( i.e. , superpositions of both consistent string(s ) and inconsistent string(s ) over @xmath35 ) .",
    "we may simply say `` consistent / inconsistent strings / states '' if the associated set @xmath35 is clear from the context .",
    "we say that a quantum state @xmath162 is an _",
    "@xmath150-partite ghz - state _ if @xmath162 is of the form @xmath163 for some natural number @xmath150 .",
    "when @xmath150 is clear from the context , we may simply call the state @xmath162 a _ ghz - state_.",
    "this section proves theorem  [ th : sv ] by showing a quantum algorithm that exactly computes @xmath164 on @xmath3 bits distributed over an anonymous quantum network with @xmath3 parties when an upper bound @xmath1 on @xmath3 is provided as global information .",
    "suppose that a bit @xmath123 is provided to each party @xmath118 $ ] as input .",
    "we say that any party @xmath74 with @xmath165 is _ active _ and any party @xmath92 with @xmath166 is _",
    "inactive_. let @xmath167 .",
    "the algorithm actually computes the functions @xmath168 and @xmath169 on input @xmath38 in parallel and then outputs @xmath170 .",
    "the function @xmath126 can be computed in any anonymous network by a simple and standard deterministic algorithm in @xmath0 rounds if any upper bound @xmath1 on @xmath3 is given , as stated in proposition  [ pr : t_0 ] ( the proof is provided in sec .  [ sec : proofs ] for completeness ) .",
    "[ pr : t_0 ] suppose that there are @xmath3 parties on an anonymous network with any underlying graph @xmath103 , in which an upper bound @xmath7 on @xmath3 is given as global information .",
    "then , there exists a deterministic algorithm that computes @xmath171}x_i$ ] on the network in @xmath9 rounds with bit complexity @xmath172 , where @xmath173 , if every party @xmath174 gives a bit @xmath175 as the input to the algorithm .",
    "the difficult part is computing @xmath124 .",
    "it runs another quantum algorithm @xmath43as a subroutine for all pairs of @xmath176\\times [ 2 .. n]$ ] .",
    "the integers @xmath177 and @xmath150 mean guesses at the number of active parties ( i.e. , @xmath39 ) and the number of parties ( i.e. , @xmath3 ) , respectively , which are unknown to any party .",
    "the following lemma states the properties of @xmath43 .",
    "[ lm : qh , m ] there exists a set of distributed quantum algorithms @xmath178\\times [ 2 .. n]\\}}$ ] such that , if every party @xmath74 @xmath179 performs the algorithm @xmath43with a bit @xmath119 and an upper bound @xmath1 on the number @xmath3 of parties , then @xmath43always reaches a halting state in @xmath0 rounds with @xmath180 qubits and @xmath137 classical bits of communication for every @xmath181 $ ] and every @xmath182 $ ] and satisfies the following properties@xmath91    1 .   for each @xmath183",
    ", @xmath43outputs `` @xmath107 '' or `` @xmath109 '' at each party , where these outputs agree over all parties@xmath97 2 .   for @xmath184 , @xmath43 computes @xmath185 with certainty for every @xmath38@xmath97 and 3 .   for every @xmath181 $ ] and every @xmath182 $ ] , @xmath43 outputs `` @xmath107 '' with certainty whenever @xmath186 ,    where @xmath167 .",
    "section  [ sec : keysub ] demonstrates how @xmath43works , and sec .",
    "[ sec : proofs ] proves that it works as stated in the lemma .",
    "after all parties collaborate to run @xmath43(in parallel ) for all pairs @xmath183 , every party obtains @xmath187 classical results : @xmath188\\times [ 2 .. n],q_{h , m}\\in { \\{{\\mathsf{true}},{\\mathsf{false}}\\ } } \\}},\\ ] ] where @xmath189 is the output of @xmath43for input @xmath38 .",
    "note that this set of results agree over all parties by property  1 in lemma  [ lm : qh , m ] . from properties 2 and 3",
    ", we can observe that there is at least one @xmath109 in @xmath190 if and only if @xmath185 is `` @xmath109 '' ( since @xmath189 is equal to @xmath185 whenever @xmath191 equals @xmath192 ) .",
    "thus , every party can locally compute @xmath185 , once it obtains all the classical results @xmath190 .",
    "therefore , together with the algorithm in proposition  [ pr : t_0 ] , @xmath170 can be computed exactly .",
    "moreover , proposition  [ pr : t_0 ] and lemma  [ lm : qh , m ] imply that the entire solitude verification algorithm runs in @xmath0 rounds and with @xmath193 qubits and @xmath15 classical bits of communication .",
    "the pseudo code , algorithm qsv , provided below summarizes the above operations .",
    "to demonstrate simply how @xmath43works , we mainly consider the case where @xmath183 equals @xmath192 ( and defer the analysis in the other cases until the following sections ) .",
    "in fact , @xmath43originates from the following simple idea .",
    "every active party flips a coin , broadcasts the outcome , and receives the outcomes of all parties .",
    "obviously , those outcomes can not include both heads and tails if there is at most _ one _ active party .",
    "otherwise , they include both with high probability .",
    "this implies that , with high probability , one can tell whether the number of active parties is at most one or not , based on whether the outcomes include both heads and tails .",
    "one can thus obtain the correct answer to @xmath12 with high probability , since one can easily check whether there exists at least one active party . however , this still yields the wrong answer with positive probability . since we want to solve the problem exactly , we need to suppress this error .",
    "for this purpose , we carefully combine several quantum tools with classical techniques based on the idea sketched in ( * ? ? ?",
    "* sec .  4 ) .",
    "suppose that every party @xmath74 has a two - qubit register @xmath195 .",
    "let @xmath196 be an orthonormal basis of @xmath197 ( `` @xmath198 '' represents the empty set ) . for notational simplicity , we also use @xmath199 to denote @xmath200 , respectively ( `` @xmath201 '' intuitively means _ inconsistency",
    "_ since we have both @xmath99 and @xmath18 in the corresponding set ) . without loss of generality",
    ", we identify @xmath202 with @xmath203 , respectively .",
    "we now start to describe @xmath43step by step and explain the effect of each step by showing claims and propositions .",
    "we defer their proofs to the next section .",
    "every active party @xmath74 prepares @xmath204 in register @xmath195 , while every inactive party @xmath92 prepares @xmath205 in @xmath206 .",
    "let @xmath207 be the set of @xmath195 over all @xmath208 , where @xmath35 is the set of active parties , and let @xmath209 be the set of @xmath195 over all @xmath118\\setminus s$ ] .",
    "we then denote by @xmath210 the pair @xmath211 .",
    "the quantum state @xmath212 over @xmath210 can be written as @xmath213 } {   { | \\emptyset \\rangle}^{\\otimes n-{\\vert { \\mathbf{x } } \\vert } }   }   _ { { \\mathsf{r}}_{\\overline{s } } } \\otimes   { { \\left [ } \\right ] } { { { \\left ( } \\right ) } {     \\frac{{| \\hat{0 } \\rangle}+{| \\hat{1 } \\rangle}}{\\sqrt{2 } }   } ^{\\otimes { \\vert { \\mathbf{x } } \\vert } }   }   _ { { \\mathsf{r}}_s}.\\ ] ]    all parties attempt to project @xmath212 onto the space spanned by @xmath214 or @xmath215 , where @xmath216 is the set of all strings @xmath158 in @xmath217 such that @xmath158 does not contain both @xmath218 and @xmath219 simultaneously , i.e. , @xmath220 , and @xmath221 is the complement of @xmath216 .    for step  2 , every party applies the operator @xmath222 with @xmath223 to @xmath212 , where @xmath222 is defined in the following claim .",
    "the resulting state @xmath224 is @xmath225 times    @xmath226    [ claim : step2 ] there exists a distributed quantum algorithm @xmath227 that , for given upper bound @xmath7 on the diameter of the underlying graph @xmath103 , implements the following operator as well as @xmath228@xmath91 @xmath229 where @xmath230 is an orthonormal basis of @xmath231 , @xmath232 denotes a set of ancillary single - qubit registers @xmath233 possessed by party @xmath74 for all @xmath118 $ ] , and @xmath234 denotes a set of all the other ancillary registers , the content @xmath235 of which is a bit string uniquely determined also depends on the underlying graph , but we assume without loss of generality that the graph is fixed . ] by @xmath7 and @xmath158 .",
    "moreover , @xmath227 runs in @xmath9 rounds and communicates @xmath236 qubits . in particular",
    ", any upper bound @xmath1 of @xmath3 can be used as @xmath7 .",
    "note that the operator @xmath237 has an effect similar to the measurement @xmath238 on @xmath212 , where @xmath239 and @xmath240 for the identity operator @xmath241 over the space @xmath242 .",
    "the difference is that @xmath237 leaves the garbage part @xmath243 , which is due to the `` distributed execution '' of the measurement .    every party @xmath74 measures the register @xmath233 of @xmath244 in the basis @xmath230 . if the outcome is `` @xmath245 '' , then @xmath43halts and returns `` @xmath109 '' .    to understand the consequence of each possible outcome , we first provide an easy proposition .",
    "[ claim : step3 - 1 ] @xmath246 is in the space spanned by @xmath214 if and only if @xmath247 .",
    "if the outcome is `` @xmath245 '' , there must exist @xmath248 such that @xmath249 has a non - zero amplitude in @xmath246 , implying that @xmath246 does _ not _ lie in the space spanned by @xmath214 and thus @xmath250 by claim  [ claim : step3 - 1 ] .",
    "therefore , every party can conclude that @xmath185 is `` @xmath109 '' without error if the outcome is `` @xmath245 '' .",
    "if the outcome is `` @xmath251 '' , we have the resulting state ( from eq .",
    "( [ eq : state1 ] ) ) : @xmath252 where @xmath253 is the normalizing factor . in this case",
    ", the parties can not determine the value of @xmath124 on @xmath38 since @xmath246 may or may not be in the space @xmath214 .",
    "hence , we need a few more steps .    for proceeding to the next step , the following observation is crucial , which is obtained from the definition of @xmath216 : in the state @xmath254 , the contents of the registers @xmath195 for all active parties @xmath74 ( i.e. , the values at the positions of all such @xmath74 in @xmath255 ) are identical ; namely , they are all `` @xmath218 '' or all `` @xmath219 ''",
    ". furthermore , we can prove the following claim :    [ claim : step3 - 2 ] the state @xmath254 is of the form @xmath256 for some @xmath257 with @xmath258 , where @xmath259 is a certain partition of the set of registers in @xmath234 .",
    "in particular , if there are no active parties , then @xmath260 is equal to @xmath99 and thus @xmath254 is a tensor product of @xmath205 .",
    "this follows from the fact that the operator @xmath237 consists of idempotent operations , copy operations via @xmath261 , and register exchanges .",
    "every party attempts to shrink the _ ghz_-state part of @xmath254 down to a @xmath39-partite _ ghz_-state over only the registers @xmath195 of active parties by performing a subroutine , called @xmath262 , the properties of which are described in claim  @xmath263 . if @xmath262 outputs `` @xmath107 '' , then @xmath43halts and returns `` @xmath107 '' .",
    "for realizing step  4 , if the state @xmath264 were over local registers , we could just apply the following standard technique : measure all registers except all @xmath195 of active parties in the hadamard basis @xmath265 , count the number of outcomes @xmath266 , and correct the phase by rotating the state by the angle 0 or @xmath267 , depending on ( the parity of ) the number . by the definition of anonymous networks , however , every ( active ) party has to use the _ same _ algorithm to collaboratively compute the parity of the number of @xmath266 and rotate the state if needed . for this purpose , the classical algorithm provided in fact  [ th :",
    "view ] seems suitable , since it computes any symmetric function in an _ anonymous _ network .",
    "what one should note here is that this classical algorithm outputs a correct answer _ if _ it is given the correct number @xmath3 of parties ( as @xmath150 ) .",
    "if @xmath150 is equal to @xmath3 , the algorithm outputs a correct answer . in general cases , however , the value of @xmath150 is merely a guess at @xmath3 and not necessarily equal to @xmath3 . to rotate the state by the angle @xmath267",
    ", every active party applies to its share of the registers the rotation operator for the angle @xmath268 , so that the sum of the angles over all active parties is @xmath267 .",
    "this works correctly _ if _ the number of active parties is given ( as @xmath177 ) . with the assumption that @xmath177 equals @xmath39 ,",
    "the state should be rotated by the correct angle @xmath267 . in general cases , however , the value of @xmath177 is not necessarily equal to @xmath39 .    in the case where @xmath39 equals @xmath99 ,",
    "no active parties exist and thus no operations are performed in this step .",
    "the following claim summarizes the effect of @xmath262 .",
    "[ claim : step4 ] there exists a distributed quantum algorithm @xmath262 such that , for given @xmath183 ,    * if @xmath39 equals zero , then for any @xmath183 it halts with the output `` @xmath107 '' at every party or applies the identity operator to @xmath254@xmath97 * else if @xmath183 equals @xmath192 , it transforms @xmath254 to @xmath269@xmath97 * else it halts with the output `` @xmath107 '' at every party or transforms @xmath254 to the state @xmath270 for some real @xmath271 .",
    "moreover , @xmath262 runs in @xmath151 rounds and communicates @xmath152 classical bits , where @xmath146 is the function defined in fact  @xmath147 .",
    "then , @xmath43proceeds to step  5 . by claim  [ claim : step4 ] ,",
    "step  5 is performed with @xmath272 only if both @xmath273 and @xmath274 hold . in this case , to meet item  3 in lemma  [ lm : qh , m ] , we only need to examine the output of q@xmath275 on @xmath38 with @xmath276 ( we defer until the next section easy proofs that item  1 holds and that q@xmath275 reaches a halting state for all @xmath38 ) . for @xmath38 with @xmath276 ,",
    "the behavior of q@xmath275 is almost the same as in the case of @xmath184 .",
    "thus , in the following part of this section , we assume that @xmath39 is equal to @xmath99 or step  5 starts with @xmath277 for simplicity ( the proof of lemma  [ lm : qh , m ] provided in the next section will rigorously analyze all cases ) .    every active party @xmath74 applies the local unitary operator @xmath278 to its register @xmath195 , where @xmath279 is defined as follows@xmath91 @xmath280 where @xmath281 and @xmath282 are defined in sec .",
    "@xmath283 of ref .  _",
    "@xmath284 acts on the first qubit , controlled by the second qubit , and @xmath285 is the identity over @xmath286 .    to see how the operator @xmath279 works , we provide the following claim .",
    "[ claim : step5 ] _ step  5 _ satisfies the following :    * if @xmath39 is zero , then _ step 5 _ is effectively skipped . *",
    "if @xmath39 is one , then @xmath287 for some @xmath288 .",
    "* if @xmath39 is at least two and @xmath177 equals @xmath39 , then it holds that @xmath289 where @xmath290 and @xmath291 .",
    "that is , if @xmath39 is zero , then the state over @xmath292 is a tensor product of @xmath205 by claims  [ claim : step3 - 2 ]  and  [ claim : step4 ] .",
    "if @xmath39 is exactly one , i.e. , @xmath293 for some @xmath294 , then , whatever unitary operator @xmath279 has acted on @xmath295 , the resulting state @xmath296 is a quantum state over the register @xmath295 .",
    "this state is obviously consistent over @xmath35 , since there is only one active party .",
    "if @xmath39 is at least two and @xmath177 equals @xmath39 , step 5 transforms the state @xmath297 into @xmath298 , which is an inconsistent state over @xmath35 .",
    "intuitively , the state @xmath298 is a superposition of only the basis states that correspond to the situations where at least two active parties have different contents chosen from @xmath299 in their @xmath195 .",
    "this fact exhibits a striking difference from the case of @xmath247 .",
    "we should emphasize that the amplitude @xmath300 vanishes for each @xmath301 _ only when _",
    "@xmath177 equals @xmath39 .",
    "in general , however , @xmath177 may not be equal to @xmath39 , in which case the amplitude @xmath300 is nonzero for some @xmath301 .",
    "every active party measures @xmath195 in the basis @xmath302 and obtains a two - bit classical outcome @xmath303 .",
    "suppose that @xmath39 is at least one and that the quantum state over @xmath207 just before step 6 is @xmath298 .",
    "if @xmath39 is at least two and @xmath177 equals @xmath39 , claim  [ claim : step5 ] implies that there are at least two distinct outcomes among those obtained by active parties .",
    "if @xmath39 equals one , then there is obviously a single outcome in the network .",
    "finally , suppose that @xmath39 is zero .",
    "since there are no active parties , there are no outcomes that would be obtained by the measurement .",
    "the number of distinct outcomes is hence different between these three cases .",
    "all parties collaborate to decide whether the number of distinct elements among the outcomes @xmath304 is at most one by running the distributed deterministic algorithm provided in proposition  [ pr : colorcounting ] .",
    "if the number is at most one , return @xmath107 ; otherwise , return @xmath109 .    to realize step  7",
    ", it suffices to decide whether the string @xmath305 is consistent over @xmath35 , where @xmath306 for @xmath307 is set at an appropriate value that is distinguishable from any possible outcome @xmath303 for @xmath208 ( technically , @xmath303 is a three - bit value ) . for this purpose , we use the distributed algorithm @xmath308 given in proposition  [ pr : colorcounting ] ( a special form of a more general statement  @xcite ) .",
    "the algorithm yields the correct output if an upper bound of the diameter of the underlying graph is known . in our setting , @xmath1 can be used to upper - bound the diameter .",
    "every party can therefore decide whether @xmath185 is @xmath107 or @xmath109 .",
    "[ pr : colorcounting ] let @xmath103 be the the underlying graph of an anonymous network with a diameter upper - bounded by @xmath7 . let @xmath309 $ ] be the set of active parties and let @xmath310 be the set of a constant number of colors .",
    "then , there is a deterministic algorithm @xmath311 that , if the upper bound @xmath7 , a color @xmath312 , and a bit @xmath313 indicating whether @xmath208 or not are given at each party @xmath118 $ ] , decides which is true among the following three cases and informs every party of the decision@xmath91    @xmath314 @xmath315 , @xmath316 @xmath317 , @xmath318 @xmath319 +    in @xmath9 rounds with @xmath236 classical bits of communication @xmath320the case @xmath321 occurs if and only if @xmath35 is the empty set@xmath322 $ ] . as a special case , the algorithm decides whether all active parties are assigned a certain single color @xmath320called the `` @xmath251 '' case , corresponding to @xmath321 or @xmath80@xmath322 $ ] or at least two colors @xmath320called the `` @xmath245 '' case , corresponding to @xmath81@xmath322 $ ] .",
    "when the algorithm is used for this purpose , it is denoted by @xmath308 .",
    "the operations performed by each party @xmath74 in executing @xmath43are described in algorithm @xmath43shown below .",
    "we should emphasize that these operations are independent of the index @xmath74 ( recall that this is the requirement of computing on anonymous networks ) . indeed , when executing @xmath43 , each party need not tell its own registers from the other parties ; it just needs to distinguish between its local registers and perform operators on them in a way independent of its index ( but dependent on input ) .",
    "thus , the subscript @xmath74 of each register / variable in algorithm  @xmath43can safely be dropped without introducing any ambiguity from the viewpoint of the party @xmath74 .",
    "this section first provides all the proofs of the propositions and claims in sec .",
    "[ sec : keysub ] ( except those appearing in previous works ) .",
    "then it proves lemma  [ lm : qh , m ] .",
    "all proofs except the one for claim  [ claim : step4 ] essentially follow from the ideas in refs .  @xcite . readers familiar with these references",
    "can safely skip the proofs .",
    "the proof for claim  [ claim : step4 ] is based on ref .",
    "@xcite for the special case , but it also discusses the other cases that the reference does not deal with .    proposition  [ pr : colorcounting ] is simply an adaptation of theorem  1 in ref .  @xcite . for completeness",
    ", we provide its proof .",
    "proposition  [ pr : colorcounting ] suppose that every party @xmath74 prepares a variable @xmath323 .",
    "each active party initializes @xmath323 to @xmath324 , while each inactive party initializes @xmath323 to `` @xmath198 '' , representing the empty set .",
    "every party then sends a copy of @xmath323 via every out - port while keeping a copy of @xmath323 and receives a message as a variable @xmath325 via every in - port @xmath4 .",
    "the party then updates @xmath323 by setting it at the union of @xmath323 and @xmath326 over all @xmath4 .",
    "every party repeats the above sending / receiving at most @xmath7 times .",
    "it is easy to see that every party s final @xmath323 is the set of all colors in active parties possession .",
    "since each message is of constant size , the bit complexity is @xmath236 .    as a corollary of proposition  [ pr : colorcounting ]",
    ", we obtain proposition  [ pr : t_0 ]",
    ".    proposition  [ pr : t_0 ] let @xmath327 and @xmath328 \\colon x_{i}=1\\}}$ ] .",
    "every party runs @xmath311 in proposition  [ pr : colorcounting ] and decides which of the two cases , ( 0 ) or ( 1 ) , holds ( event ( 2 ) never occurs since @xmath329 ) .",
    "we henceforth provide proofs of the claims in order .    claim  [ claim : step2 ] the claimed quantum algorithm essentially follows from  consistency@xmath330 \" on page  21 of ref .",
    "@xcite , where @xmath3 is replaced with @xmath331 and the binary operation `` @xmath332 '' is interpreted as the union operation over sets in our case .",
    "note that ",
    "consistency@xmath330 \" is a simple quantization of the classical algorithm in proposition  [ pr : colorcounting ] .",
    "the ancillary quantum registers left at _ each _ party after consistency@xmath330 runs in @xmath7 rounds are ( 1 ) the master copy @xmath333 whose copies have been sent out to neighbors in each round @xmath334 $ ] , ( 2 ) all registers @xmath335 received in each round @xmath334 $ ] , and ( 3 ) the final output register @xmath336 .",
    "let @xmath337 be the collection @xmath338 , where @xmath233 for @xmath118 $ ] denotes the register @xmath336 in the possession of party @xmath74 , and let @xmath234 be all the ancillary registers in the network except @xmath337 , namely , the collection of @xmath339 , @xmath340 over all parties @xmath74 .",
    "it is easy to see that the whole action of the quantum algorithm can be written as the operator @xmath237 in the claim .    for the complexity",
    ", @xmath341 requires @xmath9 rounds .",
    "in addition , @xmath341 communicates @xmath236 qubits , since a single register representing a subset of @xmath299 is sent through each communication link at each round .",
    "claim  [ claim : step3 - 1 ] the claim is very easy .",
    "we omit the proof .",
    "claim  [ claim : step3 - 2 ] since the state @xmath342 is a superposition of @xmath343 with @xmath255 , the contents of the registers @xmath195 of all active parties @xmath74 are identical by the definition of @xmath216 .",
    "more precisely , they are either all `` @xmath218 '' or all `` @xmath219 '' with probability @xmath344 .",
    "meanwhile , the contents of @xmath206 of all inactive parties @xmath92 are `` @xmath198 '' . the state @xmath342 is hence of the form @xmath345 this fact and items 1 to 3 of the following claim  [ cl : contentsofg ] imply @xmath346 where @xmath347 is the set of ( unentangled ) registers in @xmath234 whose contents are `` @xmath198 '' , and @xmath348 is the remaining registers in @xmath234 .",
    "it is obvious that @xmath349 .",
    "it also holds that @xmath350 , since the content of @xmath195 for @xmath208 is either `` @xmath218 '' and `` @xmath219 '' . in particular , when @xmath37 is @xmath99 , item 4 of claim  [ cl : contentsofg ] implies that @xmath260 equals 0 .",
    "this completes the proof of claim  [ claim : step3 - 2 ] .",
    "[ cl : contentsofg ] for a fixed set @xmath35 of active parties , suppose that the state of @xmath292 is @xmath351 .",
    "then the following hold .    1 .",
    "if the content of @xmath195 is `` @xmath218 '' for every @xmath208 , then the content of every register in @xmath234 is either `` @xmath218 '' or `` @xmath198 '' .",
    "if the content of @xmath195 is `` @xmath219 '' for every @xmath208 , then the content of every register in @xmath234 is either `` @xmath219 '' or `` @xmath198 '' .",
    "if a register in @xmath234 has the content `` @xmath198 '' , then the register is unentangled .",
    "if there are no active parties , then the content of every register in @xmath292 is `` @xmath198 '' .",
    "claim  [ cl : contentsofg ] essentially follows from the fact that the operator @xmath237 , i.e. , @xmath227 , consists of idempotent operations , copy operations via cnot , and register exchanges .",
    "we thus omit the proof .",
    "this claim is ( implictly ) observed in sec .  4 of ref .",
    "@xcite .",
    "claim  [ claim : step4 ] the algorithm @xmath262 is a modification of the algorithm sketched in sec .  4 of ref",
    ".  @xcite , which is obtained by combining standard quantum and classical techniques .",
    "that is , every party @xmath74 performs the following procedure on @xmath292 , which is supposed to be in the state @xmath254 .",
    "let @xmath352 and @xmath353 .    1 .",
    "measure every local register in @xmath234 in the basis @xmath354 .",
    "2 .   locally count the number @xmath355 of the measurement outcomes `` @xmath356 '' that party @xmath74 has obtained .",
    "3 .   attempt to compute the sum of @xmath357 @xmath358 over all parties by invoking the algorithm in fact  [ th : view ] with @xmath357 and @xmath150 .",
    "let @xmath359 be the output of the algorithm .",
    "4 .   decide with @xmath308 given in proposition  [ pr : colorcounting ] whether the string induced by @xmath359 s is consistent over all parties . if either the result is `` @xmath245 '' or @xmath359 is not a non - negative integer , then output `` @xmath107 '' and halt .",
    "if the party @xmath74 is active ( i.e. , @xmath208 ) , the output @xmath360 equals one , and @xmath177 is at least @xmath18 , then perform @xmath361 } {        \\begin{smallmatrix }          1 & 0\\\\          0 & { \\mathrm{e}}^{{\\mathbf{i}}\\frac{\\pi}{h } }        \\end{smallmatrix }       }     $ ] on the subspace spanned by @xmath362 on @xmath195 and output @xmath195 .",
    "the reason step ( iv ) is needed is as follows : for @xmath363 , the algorithm involved in step ( iii ) may not work correctly , and some party could output @xmath359 that is different from other parties @xmath359 and/or is even a non - integer value ( actually , the algorithm never outputs negative values , which follows from the details of the algorithm , which we do not touch on in this paper )",
    ". step ( iv ) is for the purpose of detecting that the guess at @xmath150 is wrong and precluding this wrong guess from leading to the wrong final decision when the number of active parties is at most one .",
    "first assume that @xmath183 equals @xmath192 and @xmath39 is at least one .",
    "in this case , steps ( i)-(v ) transform the state @xmath364 to @xmath365 by following sec .  4 in ref .",
    "@xcite .",
    "next suppose that @xmath39 is zero .",
    "for any pair @xmath183 , every party can still perform steps ( i ) and ( ii ) since these steps are independent of @xmath183 .",
    "every party then performs step  ( iii ) .",
    "note that this is possible even when @xmath150 is not equal to @xmath3 ( see the description just after fact  [ th : view ] ) .",
    "if @xmath150 is not equal to @xmath3 , however , the value @xmath359 obtained in step ( iii ) may be wrong or the string induced by @xmath359 s could be inconsistent over all parties . is zero , @xmath357 is zero for all @xmath74 .",
    "this actually implies that @xmath359 is zero for all parties regardless of @xmath150 , which follows from the details found in ref .",
    "however , we consider the possibility of halting at step ( iv ) to avoid getting into the details of the algorithm in fact  [ th : view ] . ] since @xmath308 can run and make a common decision for each party by setting @xmath7 at @xmath1 ( proposition  [ pr : colorcounting ] ) , either every party halts with output `` @xmath107 '' at step  ( iv ) or every party proceeds to step  ( v ) with a non - negative integer @xmath359 that agrees with any other party s @xmath359 . in the latter case ,",
    "no operations are performed in step  ( v ) since no active parties exist ( i.e. , @xmath366 ) .",
    "thus , the procedure effectively applies the identity operator to @xmath254 , i.e. , a tensor product of @xmath205 .",
    "finally , suppose that @xmath183 is not equal to @xmath192 and @xmath39 is at least one .",
    "for any pair @xmath183 , every party can still perform steps ( i ) , ( ii ) , and ( iii ) . as in the case of @xmath367 , either every party halts with output `` @xmath107 '' at step  ( iv ) or every party proceeds to step  ( v ) with a non - negative integer @xmath359 that agrees with any other party s @xmath359 .",
    "suppose that it proceeds to step  ( v ) .",
    "if @xmath177 is at least @xmath18 and the value @xmath360 happens to be one , then every active party applies @xmath368 .",
    "this effectively multiplies the state @xmath369 by a factor @xmath370 ; namely , it transforms @xmath371 to @xmath372 . if @xmath177 or @xmath360 equals zero , then step  ( iv ) performs no operations , and thus the entire procedure effectively transforms @xmath371 to @xmath373 .    for the communication cost ,",
    "observe that only steps ( iii ) and ( iv ) involve ( classical ) communication .",
    "step  ( iii ) just runs the algorithm provided in fact  [ th : view ] with @xmath150 instead of ( unknown ) @xmath3 . in this case",
    ", the algorithm runs in @xmath151 rounds and communicates @xmath152 classical bits , as described just after fact  [ th : view ] .",
    "the cost of step  ( iv ) is shown in proposition  [ pr : colorcounting ] and dominated by the cost of step  ( iii ) .",
    "claim  [ claim : step5 ] if @xmath39 is zero , there exist no active parties .",
    "step  5 is hence effectively skipped .",
    "if @xmath39 is one , the register @xmath207 consists of two qubits .",
    "since @xmath302 is an orthonormal basis of @xmath197 , the statement follows .",
    "now suppose that @xmath39 is at least two .",
    "in addition , assume that @xmath177 equals @xmath39 .",
    "recall that @xmath374 denotes @xmath375 .",
    "we thus have @xmath376 .",
    "every active party applies the unitary operator @xmath279 to its @xmath195 , where @xmath279 is either @xmath377 for even @xmath177 or @xmath378 for odd @xmath177 .",
    "lemmas 3.3 and 3.5 in ref .",
    "@xcite imply that @xmath379 is transformed into an inconsistent state over @xmath35 whenever @xmath380 : @xmath381 for certain amplitudes @xmath382 .",
    "we first show that , for any @xmath183 , steps  1 and 2 can run and yield @xmath383 . since step  1 is independent of @xmath183 , it always yields @xmath246 .",
    "step  2 runs the algorithm provided in claim  [ claim : step2 ] , which only requires an upper bound @xmath7 on the diameter of the underlying graph @xmath384 . by setting @xmath7 at @xmath1 ,",
    "claim  [ claim : step2 ] implies that step  2 always yields @xmath383 .    for step  3 and latter steps ,",
    "we consider three cases separately : ( a ) @xmath367 ; ( b ) @xmath385 and @xmath184 ; ( c ) @xmath385 and @xmath273 .",
    "suppose case ( a ) : @xmath367 .",
    "step  3 can be performed , since it consists of only a measurement that is independent of @xmath183 . moreover , every party can obtain the same outcome after step  3 , since @xmath383 is of the form shown in eq .",
    "( [ eq : state1 ] ) .",
    "the common outcome is `` @xmath251 '' with certainty by claim  [ claim : step3 - 1 ] .",
    "thus , the state resulting from the measurement is always @xmath254 , which is a tensor product of @xmath205 by claim  [ claim : step3 - 2 ] .",
    "step  4 consists of a distributed algorithm @xmath262 , which either returns `` @xmath107 '' or keeps the tensor product in @xmath292 , as asserted by claim  [ claim : step4 ] .",
    "steps  5 and 6 are effectively skipped , since there are no active parties .",
    "hence , there are no measurement outcomes in the network , which step  6 would yield if it were not skipped .",
    "this forces step  7 to determine by using proposition  [ pr : colorcounting ] that the number of distinct elements among the outcomes is zero with certainty , which leads to returning `` @xmath107 '' .",
    "note that step  7 consists of the distributed algorithm @xmath308 provided in proposition  [ pr : colorcounting ] , which makes the decision of `` @xmath107 '' at every party for any @xmath183 .",
    "therefore , items 1 through 3 in lemma  [ lm : qh , m ] hold when @xmath39 is zero",
    ".    next , suppose case ( b ) : @xmath385 and @xmath184 .",
    "claim  [ claim : step3 - 1 ] implies that , if @xmath39 is one , then each party obtains with certainty the outcome `` @xmath251 '' of the measurement made in step  3 .",
    "note that , with the same argument as in case ( a ) , the outcomes of all parties agree .",
    "step  3 can thus measure `` @xmath245 '' and output `` @xmath109 '' only if @xmath39 is at least two .",
    "hence , whenever step  3 outputs `` @xmath109 '' , this output agrees with @xmath185 .",
    "assume henceforth that the outcome is `` @xmath251 '' .",
    "the resulting state is then @xmath254 , which is of the form in eq .",
    "( [ eq : state2 ] ) in claim  [ claim : step3 - 2 ] .",
    "step  4 then transforms @xmath254 to @xmath297 with certainty as asserted by claim  [ claim : step4 ] .",
    "step  5 further transforms @xmath297 to @xmath298 as implied by claim  [ claim : step5 ] .",
    "if @xmath386 is one , then @xmath298 is exactly the state of @xmath195 of the only active party @xmath74 , and thus only a single outcome of the measurement is obtained in the whole network in step  6 . in this case ,",
    "step  7 returns `` @xmath107 '' , which matches @xmath185 .",
    "if @xmath39 is at least two , then the state @xmath298 is inconsistent over @xmath35 by claim  [ claim : step5 ] , so that the string induced by the measurement outcomes obtained in step  6 is also inconsistent over @xmath35 .",
    "thus , there are two or more distinct outcomes in the whole network , and step  7 returns `` @xmath109 '' , matching @xmath185 .",
    "therefore , items 1 through 3 in lemma  [ lm : qh , m ] hold if @xmath385 and @xmath184 .",
    "finally , suppose case ( c ) : @xmath385 and @xmath273 .",
    "it suffices to show that items 1 and 3 in lemma  [ lm : qh , m ] hold in this case ; namely , that steps  3 through 7 can be performed , @xmath43returns a common decision ( i.e. , @xmath107 or @xmath109 ) to every party for any @xmath183 , and @xmath43always returns `` @xmath107 '' if @xmath39 is one . as described in case ( a ) , every party obtains the same outcome of the measurement for any @xmath183 in step  3 . with the same argument used in case ( b ) ,",
    "if @xmath39 is one , then claim  [ claim : step3 - 1 ] implies that step  3 never returns `` @xmath109 '' and every party proceeds to step  4 with the state @xmath254 .",
    "claim  [ claim : step4 ] then implies that , for any @xmath385 and for any @xmath273 , step  4 either returns `` @xmath107 '' to every party or transforms @xmath254 to @xmath387 . assume the latter case . in step  5",
    ", every active party applies the local unitary operator @xmath279 to its share of @xmath387 .",
    "this is possible for any @xmath183 , since @xmath279 is defined for every possible @xmath177 .",
    "step  6 can obviously be performed , since it consists of a measurement that is independent of @xmath183 . for any @xmath183",
    ", step  7 makes a common decision at every party as stated in proposition  [ pr : colorcounting ] .",
    "if @xmath39 is one , the register @xmath207 is exactly @xmath195 of the only active party @xmath74 .",
    "therefore , whatever state in @xmath207 results from step  5 , step  6 yields only a single outcome in the whole network .",
    "step  7 thus returns `` @xmath107 '' .",
    "this shows that items 1 and 3 in lemma  [ lm : qh , m ] hold .    to bound the complexity ,",
    "observe that all the communication performed by @xmath43is devoted to steps  2 , 4 , and 7 .",
    "the complexities of these steps are shown in claims  [ claim : step2 ] and [ claim : step4 ] and proposition  [ pr : colorcounting ] with @xmath1 as @xmath7 .",
    "summing them up shows that @xmath43runs in @xmath0 rounds and communicates @xmath180 qubits and @xmath388 classical bits .",
    "this section provides some applications of the solitude verification algorithm .",
    "the algorithm in theorem  [ th : sv ] , called qsv , leads to a simple zero - error algorithm for the leader election problem ( a pseudo - code is given as algorithm  [ zqle ] ) .",
    "this application is somewhat standard , but we will sketch how it works for completeness .    for every @xmath389 $ ] , every party @xmath74 sets @xmath390 to a random bit , which is @xmath18 with probability @xmath391 or @xmath99 with probability @xmath392 .",
    "the party then performs qsv with @xmath393 and @xmath1 over all @xmath394 in parallel .",
    "let qsv@xmath395 $ ] be the ( common ) output of qsv that every party obtains , where @xmath396 .",
    "if there exists at least one @xmath394 such that qsv@xmath395 $ ] is `` @xmath107 '' , then every party @xmath74 outputs @xmath397 , where @xmath398 is the maximum of @xmath394 such that qsv@xmath395 $ ] is `` @xmath107 '' ; otherwise , it gives up .",
    "the party with @xmath399 is elected as a unique leader .",
    "note that this elects a unique leader without error whenever @xmath398 exists .",
    "the probability of successfully electing a unique leader is at least some constant , since for @xmath400 , the probability that there is exactly a single @xmath118 $ ] with @xmath401 is @xmath402 . by the standard argument",
    ", this probability can be amplified to a constant arbitrarily close to one by simply repeating qzle sufficiently many but constant times . since all communication in qzle",
    "is devoted to qsv , which runs for all @xmath389 $ ] in parallel , the overall round complexity is still @xmath0 and the overall bit complexity is @xmath403 .      the simple idea in the formal proof is likely to be hidden under complicated notations .",
    "we thus only sketch the proof and relegate its formal description to appendix  [ appdx : symmetric ] .    recall that if there are at least two active parties , then during the execution of algorithm  qsv ( on page  ) , algorithm @xmath43(on page ) for some @xmath183 outputs `` @xmath109 '' .",
    "let @xmath404 be the lexicographically smallest pair among the pairs @xmath183 for which @xmath43outputs `` @xmath109 '' on @xmath38 and @xmath1 .",
    "note that the decision `` @xmath109 '' must have been made at either step  3 or step  7 of @xmath405 . if step  3 outputs `` @xmath109 '' , we insert the new step where every party measures its @xmath195 . since the state over",
    "all @xmath195 s is an inconsistent state over the set @xmath35 of active parties in this case , the string induced by the set of all the measurement outcomes is inconsistent over @xmath35 .",
    "the string thus partitions the set of active parties into equivalence classes naturally defined by the outcomes .",
    "similarly , if step  7 outputs `` @xmath109 '' , then for the measurement outcomes @xmath406)$ ] defined in @xmath405 , the string @xmath407 is inconsistent over the set @xmath35 of active parties .",
    "the string thus partitions the set of active parties into equivalence classes naturally defined by @xmath303 s . by repeating this process recursively",
    ", the active parties will eventually be partitioned into equivalence classes @xmath408 such that at least one of them is a singleton .",
    "this can be verified as follows : for each equivalence class @xmath409 , run qsv with the members of @xmath409 as active parties .",
    "if two or more singleton classes are found , then all parties agree on one of the singleton classes in an arbitrary way .",
    "the parties then decide that the unique member of the class be a leader .",
    "it is not difficult to show that once a unique leader is elected , the leader can compute @xmath39 in @xmath0 rounds with a polynomially bounded bit complexity , which is more formally stated as claim  [ cl : eval|x| ] .",
    "[ cl : eval|x| ] suppose that there are @xmath3 parties on an anonymous ( classical ) network with any underlying graph @xmath410 in @xmath13 in which an upper bound @xmath1 on @xmath3 is given as global information .",
    "suppose further that each party @xmath74 in the network has a variable @xmath313 such that @xmath411``@xmath412 '' for a certain @xmath413 $ ] and @xmath414``@xmath415 '' for all @xmath118\\setminus{\\{l\\}}$ ] .",
    "if every party @xmath74 is given @xmath119 , then every party can compute @xmath39 in @xmath0 rounds with the bit complexity @xmath416 .",
    "the parties can thus tell the value of @xmath24 for any fixed @xmath417 .",
    "observe that such a singleton class appears within @xmath418 levels of recursion .",
    "then , it suffices for the following reason to continue the process up to @xmath419-th recursion level : if there are no singleton sets at @xmath419-th recursion , then @xmath39 must be larger than @xmath4 , and thus the parties can determine the value of @xmath24 ; otherwise , the parties can compute @xmath24 as we have already shown .",
    "the total number of rounds is thus @xmath420 .",
    "[ rm : alternative ] for readers familiar with algorithm ii in ref .  _",
    "@xcite _ ( which works even for any strongly connected directed graph ) , an alternative algorithm for computing @xmath421 can be considered as follows@xmath91 first start algorithm ii and stop after the first @xmath419 phases have finished .",
    "then , verify with _",
    "algorithm  qsv _ that a unique leader is elected .",
    "if this is the case , the leader can compute @xmath39 as in claim  [ cl : eval|x| ] .",
    "if it fails , then this implies that @xmath39 is more than @xmath422 and thus determines the value of @xmath24 . since each phase consists of @xmath0 rounds , the whole algorithm runs in @xmath420 rounds @xmath86with a polynomially bounded bit complexity@xmath88",
    "the author is grateful to anonymous referees for various helpful comments for improving the presentation and suggesting the alternative approach mentioned in remark  [ rm : alternative ] .",
    "the author is also grateful to the elc project ( grant - in - aid for scientific research on innovative areas no .",
    "24106009 of the mext in japan ) for encouraging the research presented in this paper .",
    "kkvdb94    karl  r. abrahamson , andrew adler , lisa higham , and david  g. kirkpatrick .",
    "probabilistic solitude verification on a ring . in _ proceedings of the fifth annual acm symposium on principles of distributed computing ( podc 86 ) _ , pages 161173 , 1986 .",
    "karl  r. abrahamson , andrew adler , lisa higham , and david  g. kirkpatrick .",
    "tight lower bounds for probabilistic solitude verification on anonymous rings . , 41(2):277310 , 1994 .",
    "yehuda afek and yossi matias .",
    "elections in anonymous networks . , 113(2):312330 , 1994 .",
    "dana angluin .",
    "local and global properties in networks of processors ( extended abstract ) . in _ proceedings of the 12th annual acm symposium on theory of computing _ , pages 8293 , 1980 .",
    "n.  aharon and j.  silman .",
    "quantum dice rolling : a multi - outcome generalization of quantum coin flipping . , 12(033027 ) , 2010 . also available in arxiv:0909.4186 .",
    "gilles brassard , peter hyer , michele mosca , and alain tapp . quantum amplitude amplification and estimation . in _ quantum computation and information _ , volume 305 of _ contemporary mathematics _ ,",
    "pages 5374 .",
    "american mathematical society , 2002 .",
    "michael ben - or and avinatan hassidim . fast quantum byzantine agreement . in _ proceedings of the 37th annual acm symposium on theory of computing _ , pages 481485 , 2005 .",
    "harry buhrman and hein rhrig .",
    "distributed quantum computing . in _ proceedings of the 28th international symposium",
    "mathematical foundations of computer science ( mfcs 2003 ) _ , volume 2747 of _ lecture notes in computer science _ , pages 120 .",
    "springer , 2003 .",
    "paolo boldi , shella shammah , sebastiano vigna , bruno codenotti , peter gemmell , and janos simon .",
    "symmetry breaking in anonymous networks : characterizations . in _ proceedings of the fourth israel symposium on theory of computing and systems _ , pages 1626 .",
    "ieee computer society , 1996 .",
    "anne broadbent and alain tapp .",
    "can quantum mechanics help distributed computing ? , 39(3):6776 , 2008 .",
    "paolo boldi and sebastiano vigna .",
    "fibrations of graphs . , 243(1 - 3):2166 , 2002 .",
    "dong  pyo chi and jinsoo kim .",
    "quantum database search by a single query . in _ proceedings of the first nasa international conference quantum computing and quantum communications _ ,",
    "volume 1509 of _ lecture notes in computer science _ , pages 148151 .",
    "springer , 1998 .",
    "bogdan  s. chlebus , dariusz  r. kowalski , and michal strojnowski .",
    "scalable quantum consensus for crash failures . in _ proceedings of the 24th international symposium distributed computing ( disc 2010 ) _ ,",
    "volume 6343 of _ lecture notes in computer science _ , pages 236250 .",
    "springer , 2010 .",
    "vasil  s. denchev and gopal pandurangan .",
    "distributed quantum computing : a new frontier in distributed systems or science fiction ?",
    ", 39(3):7795 , 2006 .",
    "ellie dhondt and prakash panangaden . the computational power of the w and ghz states .",
    ", 6(2):173183 , 2006 .",
    "michael elkin , hartmut klauck , danupon nanongkai , and gopal pandurangan . can quantum communication speed up distributed computation ? in _ proceedings of the 33rd acm sigact - sigops symposium on principles of distributed computing ( podc 14 ) _ , pages 166175 , 2014 .",
    "maor ganz .",
    "quantum leader election .",
    "arxiv:0910.4952 , 2009 .",
    "sascha gaertner , mohamed bourennane , christian kurtsiefer , adn cabello , and harald weinfurter .",
    "experimental demonstration of a quantum protocol for byzantine agreement and liar detection .",
    ", 100(070504 ) , 2008 .",
    "cyril gavoille , adrian kosowski , and marcin markiewicz .",
    "what can be observed locally ?",
    "in idit keidar , editor , _ proceedings of the 23rd international symposium on distributed computing ( disc 2009 ) _ , volume 5805 of _ lecture notes in computer science _ , pages 243257 .",
    "springer , 2009 .",
    "julien  m. hendrickx .",
    "views in a graph : to which depth must equality be checked ?",
    ", 25(7):19071912 , 2014 .",
    "lisa higham , david  g. kirkpatrick , karl  r. abrahamson , and andrew adler .",
    "optimal algorithms for probabilistic solitude detection on anonymous rings .",
    ", 23(2):291328 , 1997 .    alon itai and michael rodeh .",
    "symmetry breaking in distributive networks . in _ proceedings of the 22nd annual ieee symposium on foundations of computer science _ , pages 150158 , 1981 .",
    "alon itai and michael rodeh .",
    "symmetry breaking in distributed networks .",
    ", 88(1):6087 , 1990 .",
    "evangelos kranakis , danny krizanc , and jacob van  den berg .",
    "computing boolean functions on anonymous networks .",
    ", 114(2):214236 , 1994 .",
    "phillip kaye , raymond laflamme , and michele mosca . .",
    "oxford university press , 2007 .",
    "hirotada kobayashi , keiji matsumoto , and seiichiro tani .",
    "simpler exact leader election via quantum reduction .",
    ", 2014(10 ) , 2014 .",
    "alexei  yu . kitaev , alexander  h. shen , and mikhail  n. vyalyi . , volume  47 of _ graduate studies in mathematics_. ams , 2002 .",
    "nancy  a. lynch . .",
    "morgan kaufman publishers , 1996 .",
    "michael  a. nielsen and isaac  l. chuang . .",
    "cambridge university press , 2000 .",
    "n.  norris .",
    "universal covers of graphs : isomoriphism to depth @xmath144 implies isomoriphism to all depths . , 56(1):6174 , 1995 .",
    "yuta okubo , xiang - bin wang , yun - kun jiang , seiichiro tani , and akihisa tomita . experimental demonstration of quantum leader election in linear optics .",
    ", 77(032343 ) , 2008 .    sudebkumar",
    "prasant pal , sudhir  kumar singh , and somesh kumar . multi - partite quantum entanglement versus randomization : fair and unbiased leader election in networks .",
    "arxiv : quant - ph/0306195 , 2003 .",
    "seiichiro tani .",
    "compression of view on anonymous networks ",
    "folded view . , 23(2):255  262 , 2012 .",
    "seiichiro tani , hirotada kobayashi , and keiji matsumoto .",
    "exact quantum algorithms for the leader election problem . in _ proceedings of the 22nd symposium on theoretical aspects of computer science",
    "( stacs 05 ) _ , volume 3404 of _ lecture notes in computer science _ , pages 581592 .",
    "springer , 2005 .",
    "seiichiro tani , hirotada kobayashi , and keiji matsumoto .",
    "exact quantum algorithms for the leader election problem . , 4(1 ) , 2012 .",
    "masafumi yamashita and tsunehiko kameda .",
    "computing on anonymous networks : part i  characterizing the solvable cases .",
    ", 7(1):6989 , 1996 .",
    "masafumi yamashita and tsunehiko kameda .",
    "computing on anonymous networks : part ii  decision and memobership problems .",
    ", 7(1):9096 , 1996 .",
    "claim  [ cl : eval|x| ] to compute the value @xmath39 , the leader first assigns a unique indetifier @xmath423 to each party @xmath74 and then every party collects all pairs @xmath424 for @xmath118 $ ] by using proposition  [ pr : colorcounting ] , from which every party can compute the value @xmath39 locally .    to assign unique identifiers",
    ", the leader first sends a message `` @xmath92 '' of @xmath425 bits via every out - port @xmath92 .",
    "the leader ignores any message it has received .",
    "suppose then that a follower @xmath74 has received a message @xmath426 .",
    "if this message is the second one that the follower has received , it ignores the message ; otherwise , it sets @xmath427 and sends a message @xmath428 via every out - port @xmath92 , where ` @xmath332 ' means concatenation ( when the follower  @xmath74 receives multiple messages at once , the follower arbitrarily breaks the tie and chooses one of them as the first message ) . since each message is a sequence of out - port numbers , this chain of messages uniquely determines a directed path starting from the leader to each party that receives one of the messages without ignoring it .",
    "hence , @xmath423 is not equal to @xmath429 whenever @xmath430 .",
    "the message - passings stop in at most @xmath1 rounds , since the number of required rounds is equal to one plus the length of the longest path among those determined by the chains of messages , and any such path includes each party at most once .",
    "every party thus moves to the next procedure after @xmath1 rounds .",
    "the bit complexity is @xmath431 , since the size of each message is @xmath432 and each communication link is used for exactly one message .    to collect all pairs @xmath424 for @xmath118",
    "$ ] , all parties run ( a slight modification of ) @xmath311 in proposition  [ pr : colorcounting ] for @xmath433\\}}$ ] .",
    "each party then obtains @xmath310 in @xmath0 rounds .",
    "notice that , unlike the statement of proposition  [ pr : colorcounting ] , the size of @xmath310 is not constant in this case .",
    "hence , the bit complexity should be multiplied by at most the size of a message : @xmath434 ( since the set @xmath310 has @xmath435 pairs of @xmath432 bits ) .",
    "thus , the bit complexity is @xmath436 .",
    "theorem  [ th : symmetric ] for each recursion level @xmath437 $ ] , let @xmath438 be the collection of _ all possible _ equivalence classes of active parties such that each class @xmath439 in @xmath438 is the subset of active parties that have obtained the same sequence @xmath440 of outcomes in the first through @xmath441th levels of recursion [ recall that each outcome is obtained by measruing @xmath195 at ( modified ) step  3 or step  6 ] .",
    "note that some @xmath442 may be the empty set .",
    "define @xmath443 .",
    "since each outcome is a two - bit value , we have @xmath444 .",
    "more concretely , @xmath445 is the finer collection obtained by partitioning @xmath446 into four possible equivalence classes associated with four possible outcomes of @xmath447 : @xmath448 . for",
    "each @xmath437 $ ] , let @xmath449 be a bijection that maps each element in @xmath438 to the corresponding sequence of outcomes @xmath450 .",
    "we also define @xmath451 for the unique element @xmath452 in @xmath453 . for simplicity",
    ", we identify each element @xmath442 with @xmath454 .",
    "next , we make a slight modification to algorithm  qsv as follows ( let qsv@xmath455 be the modified version ) : if @xmath456 or @xmath367 , then qsv@xmath455 outputs @xmath303 at each party @xmath74 , where @xmath303 is the outcome of measurement on @xmath195 made at ( modified ) step  3 or step  6 in @xmath405 ; if @xmath276 , qsv@xmath455 outputs `` @xmath107 '' as the original qsv does .",
    "qsym consists of @xmath458 stages defined as follows : at stage  @xmath18 , every party @xmath74 performs qsv@xmath455 with input @xmath459 , where @xmath460 means the input bit @xmath123 .",
    "let @xmath461 be the output of qsv@xmath455 .",
    "if @xmath39 is one , then @xmath461 is `` @xmath107 '' by the definiton of qsv@xmath455 . in this case , only the party @xmath74 with @xmath462 sets @xmath463``@xmath412 '' , and then every party can compute @xmath39 by the algorithm in claim  [ cl : eval|x| ] , from which it can compute @xmath24 locally . if @xmath456 or @xmath367 , then qsv@xmath455 returns the measurement outcome @xmath461 to every party @xmath74 .",
    "every party @xmath74 then decides which class in @xmath445 it belongs to by using the value of @xmath461 .",
    "moreover , for each class @xmath464 , the party sets the input @xmath465 for the second stage to @xmath18 if it is a member of @xmath466 ( i.e. , @xmath467 ) , and to @xmath99 otherwise .",
    "the algorithm then proceeds to the second stage to further partition the equivalence classes ( actually , all parties can check whether @xmath39 is zero or not by computing @xmath126 at the beginning of qsym , but we design the algorithm as above just to simplify the descriptions ) .",
    "more generally , at each stage @xmath441 , every party @xmath74 performs qsv@xmath455 with @xmath468 for each @xmath469 .",
    "if qsv@xmath455 returns @xmath470 , then every party computes @xmath39 by claim  [ cl : eval|x| ] and outputs @xmath24 . otherwise , qsv@xmath455 returns @xmath471 . for each @xmath472 and each @xmath473 , a unique @xmath474 satisfies @xmath475 .",
    "every party @xmath74 then sets the input for stage @xmath476 as follows : @xmath477,\\ ] ] where @xmath478 $ ] is the predicate , which is 1 if and only if @xmath479 ; in other worlds , for each @xmath480 , @xmath481 is 1 if the party @xmath74 is a member of @xmath482 and @xmath99 otherwise .",
    "if the algorithm runs up to the @xmath458-th stage and does not output `` @xmath107 '' for any @xmath483 , then @xmath39 should be larger than @xmath4 .",
    "every party thus chooses an arbitrary @xmath484 with @xmath485 , and computes the value of @xmath486 on @xmath487 .    for each @xmath441 ,",
    "all the communication is devoted to running qsv@xmath455 and the algorithm in claim  [ cl : eval|x| ] , both of which require @xmath0 rounds and a polynomially bounded number of ( qu)bits for communication ."
  ],
  "abstract_text": [
    "<S> solitude verification is arguably one of the simplest fundamental problems in distributed computing , where the goal is to verify that there is a unique contender in a network . </S>",
    "<S> this paper devises a quantum algorithm that exactly solves the problem on an anonymous network , which is known as a network model with minimal assumptions [ angluin , stoc80 ] . </S>",
    "<S> the algorithm runs in @xmath0 rounds if every party initially has the common knowledge of an upper bound @xmath1 on the number of parties . </S>",
    "<S> this implies that all solvable problems can be solved in @xmath0 rounds on average without error ( i.e. , with zero - sided error ) on the network . as a generalization , a quantum algorithm that works in @xmath2 rounds </S>",
    "<S> is obtained for the problem of exactly computing any symmetric boolean function , over @xmath3 distributed input bits , which is constant over all the @xmath3 bits whose sum is larger than @xmath4 for @xmath5 . </S>",
    "<S> all these algorithms work with the bit complexities bounded by a polynomial in @xmath1 . </S>"
  ]
}