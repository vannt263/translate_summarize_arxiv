{
  "article_text": [
    "6.65pt plus 4pt minus 2pt    plus 1pt minus 2pt plus 0.5pt minus 0.5pt plus 1pt minus 0.5pt plus 1pt minus 0.5pt    -    listi listii - plus 1pt minus 0.5pt plus 0.5pt minus 0.5pt listiii - plus 0.5pt minus 0.5pt @ 0.5pt plus 0pt minus 0.5pt listiv - listv - listvi -    plus2pt minus5pt plus3pt plus3pt minus3pt normalsizesetsizexpt    = 5by 3    ifundefinedmathindent =    mkexlabel#1 itemlabel#1 ( ) tempa#1tempaempty ( # 1 ) tempa currentlabel#1 tempa    mksubexlabel#1 itemlabel#1 .",
    "tempa#1tempaempty # 1 .",
    "tempa currentlabel#1 tempa    mksubsubexlabel#1 itemlabel#1 .",
    "tempa#1tempaempty # 1 .",
    "tempa currentlabel#1 tempa    # 1    # 1    # 1@xmath0    [ theorem]lemma [ theorem]corollary [ theorem]definition [ theorem]proposition    = .5ex = .5ex    0.25 in 6.75 in -3.5ex -0.0 in -3.5ex 0.30ex    -0.5ex -0.2ex    * subject areas : * feature logic , constraint - based grammars , hpsg",
    "grammatical formalisms such as hpsg @xcite @xcite and lfg @xcite employ feature descriptions @xcite @xcite as the primary means for stating linguistic theories .",
    "however the descriptive machinery employed by these formalisms easily exceed the descriptive machinery available in feature logic @xcite .",
    "furthermore the descriptive machinery employed by both hpsg and lfg is difficult ( if not impossible ) to state in feature based formalisms such as ale  @xcite , tfs  @xcite and cuf  @xcite which augment feature logic with a type system .",
    "one such expressive device employed both within lfg  @xcite and hpsg but is unavailable in feature logic is that of set descriptions .",
    "although various researchers have studied set descriptions ( with different semantics ) @xcite @xcite two issues remain unaddressed .",
    "firstly there has not been any work on consistency checking techniques for feature terms augmented with set descriptions .",
    "secondly , for applications within grammatical theories such as the hpsg formalism , set descriptions alone are not enough since descriptions involving set union are also needed .",
    "thus to adequately address the knowledge representation needs of current linguistic theories one needs to provide set descriptions as well as mechanisms to manipulate these .    in the hpsg grammar formalism @xcite ,",
    "set descriptions are employed for the modelling of so called _ semantic indices _",
    "( @xcite _ pp .",
    "the attribute inds in the example in ( [ ex : semind ] ) is a multi - valued attribute whose value models a set consisting of ( at most ) 2 objects .",
    "however multi - valued attributes can not be described within feature logic @xcite @xcite .",
    "[ ex : semind ]   +    a further complication arises since to be able to deal with anaphoric dependencies we think that set memberships will be needed to resolve pronoun dependencies .",
    "equally , set unions may be called for to incrementally construct discourse referents .",
    "thus set - valued extension to feature logic is insufficient on its own .",
    "similarly , set valued subcategorisation frames ( see ( [ ex : bsubcat ] ) ) has been considered as a possibility within the hpsg formalism .",
    "[ ex : bsubcat ]   +    but once set valued subcategorisation frames are employed , a set valued analog of the hpsg subcategorisation principle too is needed . in section [ sec : setlogic ]",
    "we show that the set valued analog of the subcategorisation principle can be adequately described by employing a disjoint union operation over set descriptions as available within the logic described in this paper .",
    "in this section we provide the semantics of feature terms augmented with set descriptions and various constraints over set descriptions .",
    "we assume an alphabet consisting of @xmath1 the set of _ variables _ ; @xmath2 the set of _ relation symbols _ ; @xmath3 the set of _ constant symbols _ ; @xmath4 the set of primitive concept symbols and @xmath5 the set of _ atomic symbols_. furthermore , we require that @xmath6 .    the syntax of our term language defined by the following bnf definition :    1 .",
    "@xmath7 2 .",
    "@xmath8    where @xmath9 are terms ; @xmath10 is an _ atom _ ; @xmath11 is a _ constant _ ; @xmath12 is a _ primitive concept _ and @xmath13 is a _",
    "relation symbol_.    the interpretation of _ relation symbols _ and _ atoms _ is provided by an interpretation @xmath14 where @xmath15 is an arbitrary non - empty set and @xmath16 is an interpretation function that maps :    1 .",
    "every relation symbol @xmath17 to a binary relation @xmath18 2 .",
    "every atom @xmath19 to an element @xmath20    * notation : *    * let @xmath21 denote the set @xmath22 * let @xmath23 mean @xmath24    @xmath25 is required to satisfy the following properties :    1 .   if @xmath26 then @xmath27  ( _ distinctness _ ) 2 .   for any atom @xmath19 and for any relation @xmath17",
    "there exists no @xmath28 such that @xmath29  ( _ atomicity _ )    for a given interpretation @xmath25 an * @xmath25-assignment * @xmath30 is a function that maps :    1 .",
    "every variable @xmath31 to an element @xmath32 2 .   every constant @xmath33 to an element @xmath34 such that for distinct constants @xmath35 : @xmath36 3 .",
    "every primitive concept @xmath37 to a subset @xmath38 such that : * @xmath39 * @xmath40    the interpretation of terms is provided by a denotation function @xmath41 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha}$ ] that given an interpretation @xmath25 and an @xmath25-assignment @xmath30 maps terms to subsets of @xmath15 .",
    "the function @xmath41 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha}$ ] is defined as follows :    1 .",
    "@xmath42 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = \\ { \\alpha(x ) \\}$ ] 2 .",
    "@xmath43 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = \\ { a^{i } \\}$ ] 3 .",
    "@xmath44 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = \\ { \\alpha(c ) \\}$ ] 4 .",
    "@xmath45 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = \\alpha(c)$ ] 5 .",
    "@xmath46 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = $ ] + @xmath47 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } \\}$ ] 6 .",
    "@xmath48 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = $ ] + @xmath49 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } \\}$ ] 7 .",
    "@xmath50 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = $ ] + @xmath51 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } \\}$ ] 8 .",
    "@xmath52 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = $ ] + @xmath53 + @xmath54 + @xmath55 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha }                           \\wedge \\ldots \\wedge                          e_{n } \\in { { [ \\hspace{-.5 mm } [ } t_{n } { ] \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha}\\}$ ] 9 .",
    "@xmath56 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = $ ] + @xmath57 + @xmath58 + @xmath55 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha }                           \\wedge \\ldots \\wedge                          e_{n } \\in { { [ \\hspace{-.5 mm } [ } t_{n } { ] \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha}\\}$ ] 10 .",
    "@xmath59 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = $ ] + @xmath60 11 .",
    "@xmath61 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = $ ] + @xmath62 12 .",
    "@xmath63 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = $ ] + @xmath64 13 .",
    "@xmath65 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } = $ ] * @xmath66 if @xmath67 * @xmath15 if @xmath68 14 .",
    "@xmath69 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } =                     { { [ \\hspace{-.5 mm } [ } s { ] \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } \\cap                      { { [ \\hspace{-.5 mm } [ } t { ] \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha}$ ] 15 .",
    "@xmath70 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } =                         { \\mbox{${\\cal u}$}}^{i } - { { [ \\hspace{-.5 mm } [ } t { ] \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha}$ ]    the above definitions fix the syntax and semantics of every term .",
    "it follows from the above definitions that : + @xmath71    although _ disjoint union _ is not a primitive in the logic it can easily be defined by employing set disjointness and set union operations :    * @xmath72    thus disjoint set union is exactly like set union except that it additionally requires the sets denoted by @xmath73 and @xmath74 to be disjoint .",
    "the set - valued description of the subcategorisation principle can now be stated as given in example ( [ ex : setsubcat ] ) .",
    "[ ex : setsubcat ] + @xmath75 { \\hspace*{-1 mm }                          \\mbox{\\uppercase{syn{{\\mbox{$\\mid$}}}loc } }                          &                           y \\hspace*{-.25ex}\\\\ }          { \\hspace*{-1 mm }                          \\mbox{\\uppercase{dtrs } }                          &                           x \\sqcap\\             { \\mbox{\\tiny \\ (                               \\setlength{\\arraycolsep}{.4ex }                               \\renewcommand{\\arraystretch}{1.0 }                                \\hspace*{-1.4ex}\\left [                                \\begin{array}{ll }                                 \\\\[-1ex ] { \\hspace*{-1 mm }                          \\mbox{\\uppercase{h - dtr{{\\mbox{$\\mid$}}}syn{{\\mbox{$\\mid$}}}loc{{\\mbox{$\\mid$}}}subcat } }                          &                           \\mbox{c - dtrs}(x ) \\uplus \\mbox{subcat}(y ) \\hspace*{-.25ex}\\\\ }                  \\\\[-1.4ex ]                               \\end{array }                               \\right]\\hspace*{-2.3ex }                             \\ )                      } }                \\hspace*{-.25ex}\\\\ }              \\\\[-1.4ex ]                               \\end{array }                               \\right]\\hspace*{-2.3ex }                             \\ )                      } } $ ]    the description in ( [ ex : setsubcat ] ) simply states that the subcat value of the is the disjoint union of the subcat value of the mother and the values of .",
    "note that the disjoint union operation is the right operation to be specified to split the set into two disjoint subsets .",
    "employing just union operation would not work since it would permit repetition between members of the attribute and attribute .",
    "alternatively , we can assume that n is the only multi - valued relation symbol while both subcat and c - dtrs are single - valued and then employ the intuitively appealing subcategorisation principle given in ( [ ex : setsubcat2 ] ) .",
    "[ ex : setsubcat2 ] + @xmath75 { \\hspace*{-1 mm }                          \\mbox{\\uppercase{syn{{\\mbox{$\\mid$}}}loc{{\\mbox{$\\mid$}}}subcat } }                          &                           y \\hspace*{-.25ex}\\\\ }          { \\hspace*{-1 mm }                          \\mbox{\\uppercase{dtrs } }                          &                                      { \\mbox{\\tiny \\ (                               \\setlength{\\arraycolsep}{.4ex }                               \\renewcommand{\\arraystretch}{1.0 }                                \\hspace*{-1.4ex}\\left [                                \\begin{array}{ll }                                 \\\\[-1ex ] { \\hspace*{-1 mm }                          \\mbox{\\uppercase{h - dtr{{\\mbox{$\\mid$}}}syn{{\\mbox{$\\mid$}}}loc{{\\mbox{$\\mid$}}}subcat{{\\mbox{$\\mid$}}}n } }                          &                           \\mbox{n}(x ) \\uplus \\mbox{n}(y ) \\hspace*{-.25ex}\\\\ }                  { \\hspace*{-1 mm }                          \\mbox{\\uppercase{c - dtrs } }                          &                           x \\hspace*{-.25ex}\\\\ }                  \\\\[-1.4ex ]                               \\end{array }                               \\right]\\hspace*{-2.3ex }                             \\ )                      } }                \\hspace*{-.25ex}\\\\ }              \\\\[-1.4ex ]                               \\end{array }                               \\right]\\hspace*{-2.3ex }                             \\ )                      } } $ ]    with the availability of set operations , multi - valued structures can be incrementally built .",
    "for instance , by employing union operations , semantic indices can be incrementally constructed and by employing membership constraints on the set of semantic indices pronoun resolution may be carried out .",
    "the set difference operation @xmath76 is not available from the constructs described so far .",
    "however , assume that we are given the term @xmath77 and it is known that @xmath78 for every interpretation @xmath79 such that @xmath80 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha } \\neq \\emptyset$ ] .",
    "then the term @xmath77 ( assuming the obvious interpretation for the set difference operation ) is consistent iff the term @xmath81 is consistent .",
    "this is so since for sets g , f , h :  g - f = h @xmath82 f @xmath83 g _ iff _ g = f @xmath84 h. see figure [ fig : venn ] for verification .",
    "to employ a term language for knowledge representation tasks or in constraint programming languages the minimal operation that needs to be supported is that of consistency checking of terms .",
    "a term @xmath85 is * consistent * if there exists an interpretation @xmath25 and an @xmath25-assignment @xmath30 such that @xmath86 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha}\\neq\\emptyset$ ] .    in order to develop constraint solving algorithms for consistency testing of terms we follow the approaches in @xcite @xcite .",
    "a * containment constraint * is a constraint of the form @xmath87 where @xmath88 is a variable and @xmath85 is an term .",
    "in addition , for the purposes of consistency checking we need to introduce * disjunctive constraints * which are of the form .",
    "we say that an interpretation @xmath25 and an @xmath25-assignment @xmath30 satisfies a constraint @xmath89 written @xmath90 _ if _ :    * @xmath91 \\hspace{-.5 mm } ] } } ^{{{\\cal i}},\\alpha}$ ] * @xmath92 for some @xmath93 .    a * constraint system * @xmath94 is a _ conjunction _ of constraints .",
    "we say that an interpretation @xmath25 and an @xmath25-assignment @xmath30 * satisfy * a constraint system @xmath94 _ iff _ @xmath79 satisfies every constraint in @xmath94 .",
    "the following lemma demonstrates the usefulness of constraint systems for the purposes of consistency checking .",
    "an term @xmath85 is consistent iff there exists a variable @xmath88 , an interpretation @xmath25 and an @xmath25-assignment @xmath30 such that @xmath79 satisfies the constraint system @xmath87 .",
    "now we are ready to turn our attention to constraint solving rules that will allow us to determine the consistency of a given constraint system .",
    "we say that a constraint system @xmath94 is * basic * if _ none _ of the _ decomposition rules _",
    "( see figure [ fig : drules ] ) are applicable to @xmath94 .",
    "the purpose of the decomposition rules is to break down a complex constraint into possibly a number of simpler constraints upon which the constraint simplification rules ( see figures [ fig : srules1 ] , [ fig : srules2 ] and 5 ) can apply by possibly introducing new variables .    the first phase of consistency checking of a term @xmath85 consists of exhaustively applying the decomposition rules to an initial constraint of the form @xmath87 ( where @xmath88 does not occur in @xmath85 ) until no rules are applicable .",
    "this transforms any given constraint system into _",
    "basic form_.    the constraint simplification rules ( see figures [ fig : srules1 ] , [ fig : srules2 ] and 5 ) either eliminate variable equalities of the form @xmath95 or generate them from existing constraints .",
    "however , they do not introduce new variables .",
    "the constraint simplification rules given in figure [ fig : srules1 ] are the analog of the feature simplification rules provided in @xcite .",
    "the main difference being that our simplification rules have been modified to deal with relation symbols as opposed to just feature symbols .",
    "the constraint simplification rules given in figure [ fig : srules2 ] simplify constraints involving set descriptions when they interact with other constraints such as feature constraints - rule ( [ rule : ssetf ] ) , singleton sets - rule ( [ rule : sset ] ) , duplicate elements in a set - rule ( [ rule : sdup ] ) , universally quantified constraint - rule ( [ rule : sforall ] ) , another set description - rule ( [ rule : ssetset ] ) .",
    "rule ( [ rule : sdis ] ) on the other hand simplifies disjunctive constraints . amongst all the constraint simplification rules in figures [ fig : srules1 ] and [ fig : srules2 ] only rule ( [ rule : sdis ] ) is non - deterministic and creates a @xmath96-ary choice point",
    ".    rules ( [ rule : sset ] ) and ( [ rule : sdup ] ) are redundant as completeness ( see section below ) is not affected by these rules",
    ". however these rules result in a simpler normal form .",
    "the following syntactic notion of entailment is employed to render a slightly compact presentation of the constraint solving rules for dealing with set operations given in figure 5 .",
    "a constraint system @xmath94 _ syntactically entails _ the ( conjunction of ) constraint(s ) @xmath97 if @xmath98 is derivable from the following deduction rules :    1 .",
    "@xmath99 2 .",
    "@xmath100 3 .",
    "@xmath101 4 .",
    "@xmath102 5 .",
    "@xmath103 6 .",
    "@xmath104 7 .",
    "@xmath105 8 .",
    "@xmath106    note that the above definitions are an incomplete list of deduction rules .",
    "however @xmath98 implies @xmath107 where @xmath108 is the semantic entailment relation defined as for predicate logic .",
    "we write @xmath109 if it is not the case that @xmath110 .",
    "the constraint simplification rules given in figure 5 deal with constraints involving set operations . rule ( [ rule : subset ] ) propagates @xmath111-values of @xmath112 into @xmath13-values of @xmath88 in the presence of the constraint @xmath113 .",
    "rule ( [ rule : unionleft ] ) ( correspondingly rule ( [ rule : unionright ] ) ) adds the constraint @xmath113 ( correspondingly @xmath114 ) in the presence of the constraint @xmath115 .",
    "also in the presence of @xmath116 rule ( [ rule : uniondown ] ) non - deterministically propagates an @xmath13-value of @xmath88 to either an @xmath111-value of @xmath112 or an @xmath117-value of @xmath118 ( if neither already holds ) .",
    "the notation @xmath119 denotes a non - deterministic choice between @xmath120 and @xmath121 .",
    "rule ( [ rule : intersectiondown ] ) propagates an @xmath13-value of @xmath88 both as a @xmath111-value of @xmath112 and @xmath117-value of @xmath118 in the presence of the constraint @xmath122 .",
    "finally , rule ( [ rule : intersectionup ] ) propagates a common @xmath111-value of @xmath112 and @xmath117-value of @xmath118 as an @xmath13-value of @xmath88 in the presence of the constraint @xmath122 .",
    "in this section we establish the main results of this paper - namely that our consistency checking procedure for set descriptions and set operations is invariant , complete and terminating . in other words",
    ", we have a decision procedure for determining the consistency of terms in our extended feature logic .    for the purpose of showing _ invariance _ of our rules we distinguish between _ deterministic _ and _ non - deterministic _ rules .",
    "amongst all our rules only rule ( [ rule : sdis ] ) given in figure [ fig : srules2 ] and rule ( [ rule : uniondown ] ) are non - deterministic while all the other rules are deterministic .    1 .",
    "if a decomposition rule transforms @xmath94 to @xmath123 then @xmath94 is consistent iff @xmath123 is consistent .",
    "let @xmath79 be any interpretation , assignment pair and let @xmath94 be any constraint system .",
    "* if a deterministic simplification rule transforms @xmath94 to @xmath123 then : + @xmath124 iff @xmath125 * if a non - deterministic simplification rule applies to @xmath94 then there is at least one non - deterministic choice which transforms @xmath94 to @xmath123 such that : + @xmath124 iff @xmath125    a constraint system @xmath94 is in * normal form * if no rules are applicable to @xmath94 .",
    "let @xmath126 denote the set :    * @xmath127    a constraint system @xmath94 in normal form contains a * clash * if there exists a variable @xmath88 in @xmath94 such that _ any _ of the following conditions are satisfied :    1 .",
    "@xmath128 and @xmath129 such that @xmath26 2 .",
    "@xmath130 and @xmath131 such that @xmath132 3 .",
    "@xmath133 and @xmath134 + where @xmath135 ranges over @xmath136 .",
    "4 .   @xmath137 and @xmath138 5 .",
    "@xmath139 and @xmath140 6 .",
    "@xmath141 and @xmath142    if @xmath94 does not contain a clash then @xmath94 is called * clash - free*.    the constraint solving process can terminate as soon as a _ clash - free _ constraint system in normal form is found or alternatively all the choice points are exhausted .    the purpose of the _ clash _ definition is highlighted in the _ completeness _ theorem given below .    for a constraint system @xmath94 in normal form an _ equivalence relation _",
    "@xmath143 on variables occurring in @xmath94 is defined as follows :    * @xmath144 if @xmath145    for a variable @xmath88 we represent its equivalence class by @xmath146 $ ] .",
    "a constraint system @xmath94 in normal form is consistent iff @xmath94 is clash - free .",
    "_ proof sketch _ : for the first part , let @xmath94 be a constraint system containing a clash then it is clear from the definition of clash that there is no interpretation @xmath25 and @xmath25-assignment @xmath30 which satisfies @xmath94 .",
    "let @xmath94 be a clash - free constraint system in normal form .",
    "we shall construct an interpretation @xmath147 and a variable assignment @xmath30 such that @xmath148 .",
    "let @xmath149 .",
    "the assignment function @xmath30 is defined as follows :    1 .   for every variable @xmath88 in @xmath150 1 .   if @xmath138 then @xmath151 2 .   if the previous condition does not apply then @xmath152)$ ] where @xmath153)$ ] denotes a unique representative ( chosen arbitrarily ) from the equivalence class @xmath146 $ ] .",
    "2 .   for every constant @xmath11 in @xmath154 : 1 .   if @xmath155 then @xmath156 2 .   if @xmath11 is a constant such that the previous condition does not apply then @xmath157 3 .   for every primitive concept @xmath12 in @xmath158 : * @xmath159    the interpretation function @xmath160 is defined as follows :    * @xmath161 * @xmath162    it can be shown by a case by case analysis that for every constraint @xmath89 in @xmath94 : + @xmath163 .    hence we have the theorem .",
    "the  consistency checking procedure terminates in a finite number of steps .",
    "_ proof sketch _ : termination is obvious if we observe the following properties :    1 .   since decomposition rules breakdown terms into smaller ones these rules must terminate .",
    "none of the simplification rules introduce new variables and hence there is an upper bound on the number of variables .",
    "every simplification rule does either of the following : 1 .   reduces the ` effective ' number of variables . + a variable @xmath88 is considered to be _ ineffective _ if it occurs only once in @xmath94 within the constraint @xmath164 such that rule ( [ rule : sequals ] ) does not apply .",
    "a variable that is not _ ineffective _ is considered to be _",
    "effective_. 2 .   adds a constraint of the form @xmath165 where @xmath12 ranges over @xmath166 which means there is an upper bound on the number of constraints of the form @xmath167 that the simplification rules can add .",
    "this is so since the number of variables , atoms , constants and primitive concepts are bounded for every constraint system in basic form .",
    "3 .   increases the size of @xmath126 .",
    "but the size of @xmath126 is bounded by the number of variables in @xmath94 which remains constant during the application of the simplification rules .",
    "hence our constraint solving rules can not indefinitely increase the size of @xmath126 .",
    "in this section , we show that consistency checking of terms within the logic described in this paper is np - complete .",
    "this result holds even if the terms involving set operations are excluded .",
    "we prove this result by providing a polynomial time translation of the well - known np - complete problem of determining the satisfiability of propositional formulas @xcite .",
    "determining consistency of terms is np - complete .    _",
    "proof : _ let @xmath97 be any given propositional formula for which consistency is to be determined .",
    "we split our translation into two intuitive parts : _ truth assignment _ denoted by @xmath168 and _ evaluation _ denoted by @xmath169 .",
    "let @xmath170 be the set of propositional variables occurring in @xmath97 .",
    "we translate every propositional variable @xmath10 by a variable @xmath171 in our logic .",
    "let @xmath13 be some relation symbol .",
    "let @xmath172 be two atoms .",
    "furthermore , let @xmath173 be a finite set of variables distinct from the ones introduced above .",
    "we define the translation function @xmath168 by :    * @xmath174{llll }           \\delta(\\phi ) = & f : \\ { true , false \\ } \\sqcap \\\\                          & \\exists f : x_{a } \\sqcap \\exists f : x_{b }   \\sqcap                            \\ldots \\sqcap\\\\                          & \\exists f : x_{1 } \\sqcap \\exists f : x_{2 }   \\sqcap                 \\ldots          \\end{array}$ ]    the above description forces each of the variable @xmath175 and each of the variables @xmath173 to be either equivalent to _ true _ or _ false_.    we define the evaluation function @xmath169 by :    * @xmath176 * @xmath177 * @xmath178 + where @xmath179 is a new variable * @xmath180 + where @xmath179 is a new variable    intuitively speaking @xmath181 can be understood as follows .",
    "evaluation of a propositional variable is just its value ; evaluating a conjunction amounts to evaluating each of the conjuncts ; evaluating a disjunction amounts to evaluating either of the disjuncts and finally evaluating a negation involves choosing something other than the value of the term",
    ".    determining satisfiability of @xmath97 then amounts to determining the consistency of the following term :    * @xmath182    note that the term @xmath183 forces the value of @xmath169 to be @xmath184 .",
    "this translation demonstrates that determining consistency of terms is np - hard .    on the other hand ,",
    "every deterministic completion of our constraint solving rules terminate in polynomial time since they do not generate new variables and the number of new constraints are polynomially bounded .",
    "this means determining consistency of terms is np - easy .",
    "hence , we conclude that determining consistency of terms is np - complete .",
    "the schnfinkel - bernays class ( see @xcite ) consists of function - free first - order formulae which have the form :    * @xmath185    in this section we show that the attributive logic developed in this paper can be encoded within the schnfinkel - bernays subclass of first - order formulae by extending the approach developed in @xcite .",
    "however formulae such as @xmath186 which involve an embedded existential quantification can not be translated into the schnfinkel - bernays class .",
    "this means that an unrestricted variant of our logic which does not restrict the universal role quantification can not be expressed within the schnfinkel - bernays class .    in order to put things more concretely ,",
    "we provide a translation of every construct in our logic into the schnfinkel - bernays class .",
    "let @xmath85 be any extended feature term .",
    "let @xmath88 be a variable _ free _ in @xmath85 .",
    "then @xmath85 is consistent _ iff _ the formula @xmath187 is consistent where @xmath188 is a translation function from our extended feature logic into the schnfinkel - bernays class .",
    "here we provide only the essential definitions of @xmath188 :    * @xmath189 * @xmath190 * @xmath191 + @xmath192 + where @xmath112 is a new variable * @xmath193 + where @xmath112 is a new variable * @xmath194 * @xmath195 * @xmath196 + @xmath197 + where @xmath198 are new variables * @xmath199 + @xmath200 * @xmath201 + @xmath202 * @xmath203    these translation rules essentially mimic the decomposition rules given in figure [ fig : drules ] .",
    "furthermore for every atom @xmath10 and every feature @xmath13 in @xmath85 we need the following axiom :    * @xmath204    for every distinct atoms @xmath205 in @xmath85 we need the axiom :    * @xmath206    taking into account the np - completeness result established earlier this translation identifies a np - complete subclass of formulae within the schnfinkel - bernays class which is suited for nl applications .",
    "feature logics and concept languages such as kl - one are closely related family of languages @xcite .",
    "the principal difference being that feature logics interpret attributive labels as functional binary relations while concept languages interpret them as just binary relations .",
    "however the integration of concept languages with feature logics has been problematic due to the fact the while path equations do not lead to increased computational complexity in feature logic the addition of role - value - maps ( which are the relational analog of path equations ) in concept languages causes undecidability @xcite .",
    "this blocks a straightforward integration of a variable - free concept language such as alc @xcite with a variable - free feature logic @xcite .    in @xcite the addition of variables , feature symbols and set descriptions to alc",
    "is investigated providing an alternative method for integrating concept languages and feature logics .",
    "it is shown that set descriptions can be translated into the so called `` number restrictions '' available within concept languages such as back @xcite",
    ". however , the propositionally complete languages alv and als investigated in @xcite are pspace - hard languages which do not support set operations .",
    "the work described in this paper describes yet another unexplored dimension for concept languages - that of a restricted concept language with variables , feature symbols , set descriptions and set operations for which the consistency checking problem is within the complexity class np .",
    "in this paper we have provided an extended feature logic ( excluding disjunctions and negations ) with a range of constraints involving set descriptions .",
    "these constraints are set descriptions , fixed cardinality set descriptions , set - membership constraints , restricted universal role quantifications , set union , set intersection , subset and disjointness .",
    "we have given a model theoretic semantics to our extended logic which shows that a simple and elegant formalisation of set descriptions is possible if we add relational attributes to our logic as opposed to just functional attributes available in feature logic .",
    "for realistic implementation of the logic described in this paper , further investigation is needed to develop concrete algorithms that are reasonably efficient in the average case . the consistency checking procedure described in this paper abstracts away from algorithmic considerations and clearly modest improvements to the basic algorithm suggested in this paper",
    ". however , a report on such improvements is beyond the scope of this paper .    for applications within constraint based grammar formalisms such as hpsg , minimally a type system @xcite and/or a horn - like extension @xcite will be necessary .",
    "we believe that the logic described in this paper provides both a better picture of the formal aspects of current constraint based grammar formalisms which employ set descriptions and at the same time gives a basis for building knowledge representation tools in order to support grammar development within these formalisms .",
    "the work described here has been carried out as part of the ec - funded project lre-61 - 061 rgr ( reusability of grammatical resources ) .",
    "a longer version of the paper is available in @xcite .",
    "the work described is a further development of the author s phd thesis carried out at the department of artificial intelligence , university of edinburgh .",
    "i thank my supervisors chris mellish and alan smaill for their guidance .",
    "i have also benefited from comments by an anonymous reviewer and discussions with chris brew , bob carpenter , jochen drre and herbert ruessink .",
    "ronald  m. kaplan and joan bresnan . : a formal system for grammatical representation . in joan bresnan , editor , _ the mental representation of grammatical relations _ , pages 173  281 . mit press , cambridge ,",
    "massachussets , 1982 .",
    "robert kasper and william rounds . a logical semantics for feature structures . in _ 24th annual meeting of the association for computational linguistics , columbia university , new york _ , pages 257265 , 1986 .",
    "bernhard nebel and gert smolka .",
    "attributive description formalisms and the rest of the world .",
    "research report rr-91 - 15 , german research center for artificial intelligence ( dfki ) , saarbrcken , germany , may 1991 .",
    "carl  j. pollard and m.  drew moshier . unifying partial descriptions of sets . in philip",
    "p. hanson , editor , _ information , language and cognition_. university of british columbia press , vancouver , canada , 1990 .",
    "vancouver studies in cognitive science , no .  1 ."
  ],
  "abstract_text": [
    "<S> this paper provides a model theoretic semantics to feature terms augmented with set descriptions . </S>",
    "<S> we provide constraints to specify hpsg style set descriptions , fixed cardinality set descriptions , set - membership constraints , restricted universal role quantifications , set union , intersection , subset and disjointness . </S>",
    "<S> a sound , complete and terminating consistency checking procedure is provided to determine the consistency of any given term in the logic . </S>",
    "<S> it is shown that determining consistency of terms is a np - complete problem .    </S>",
    "<S> internalcite biblabel#1##1##2##1 , # # 2[#1 ]    # 1#2#3    maketitleto </S>"
  ]
}