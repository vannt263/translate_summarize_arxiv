{
  "article_text": [
    "linear temporal logic ( ltl ) has been proposed by pnueli  @xcite as a formalism to specify properties of parallel programs and concurrent systems , as well as to reason about their behaviour . since then",
    ", it has been widely used for these purposes .",
    "recent developments require reasoning tasks  such as deciding satisfiability , validity , or model checking  to be performed automatically . therefore , decidability and computational complexity of the corresponding decision problems are of great interest .",
    "the earliest and fundamental source of complexity results for the satisfiability problem ( sat ) and the model - checking problem ( mc ) of ltl is certainly sistla and clarke s paper @xcite .",
    "they have established -completeness of sat and mc for ltl with the temporal operators  ( eventually ) ,  ( invariantly ) ,  ( next - time ) ,  ( until ) , and   ( since ) .",
    "they have also shown that these problems are -complete for certain restrictions of the set of temporal operators .",
    "this work was continued by markey  @xcite .",
    "the results of sistla , clarke , and markey imply that sat and mc for ltl and a multitude of its fragments are intractable .",
    "in fact , they do not exhibit any tractable fragment .",
    "the fragments they consider are obtained by restricting the set of temporal operators and the use of negations .",
    "what they do not consider are arbitrary fragments of temporal _ and _ boolean operators . for propositional logic ,",
    "a complete analysis has been achieved by lewis @xcite .",
    "he divides all infinitely many sets of boolean operators into those with tractable ( polynomial - time solvable ) and intractable ( -complete ) sat problems .",
    "a similar systematic classification has been obtained by bauland et al .  in @xcite for ltl .",
    "they divide fragments of ltl  determined by arbitrary combinations of temporal and boolean operators  into those with polynomial - time solvable , -complete , and -complete sat problems .",
    "this paper continues the work on the mc problem for ltl .",
    "similarly as in @xcite , the considered fragments are arbitrary combinations of temporal and boolean operators",
    ". we will separate the mc problem for almost all ltl fragments into tractable ( , polynomial - time solvable ) and intractable ( , -hard ) cases .",
    "this extends the work of sistla and clarke , and markey @xcite , but in contrast to their results , we will exhibit many tractable fragments and exactly determine their computational complexity .",
    "surprisingly , we will see that tractable cases for model checking are even very easy  that is , -complete or even -solvable .",
    "there is only one set of boolean operators , consisting of the binary -operator , that we will have to leave open .",
    "this constellation has already proved difficult to handle in @xcite , the latter being a paper where sat for basic modal logics has been classified in a similar way .    while the borderline between tractable and intractable fragments in @xcite is quite easily recognisable ( sat for fragments containing the boolean function @xmath0 is intractable , almost all others are tractable ) , our results for mc will exhibit a rather diffuse borderline .",
    "this will become visible in the following overview and is addressed in the conclusion .",
    "our most surprising intractability result is the -hardness of the fragment that only allows the temporal operator  and no propositional operator at all .",
    "our most surprising tractability result is the -completeness of mc for the fragment that only allows the temporal operators , , and the binary -operator .",
    "taking into account that mc for the fragment with only  plus is already -hard ( which is a consequence from @xcite ) , we would have expected the same lower bound for the `` dual '' fragment with only  plus , but in fact we show that even the fragment with  and  and  is tractable . in the presence of the -operator ,",
    "the expected duality occurs : the fragment with ,  plus  and the one with ,  plus  are both -hard .",
    "table [ tab : overview ] gives an overview of our results .",
    "the top row refers to the sets of boolean operators given in definition  [ def : clones ] .",
    "these seven sets of boolean operators are all relevant cases , which is due to post s fundamental paper @xcite and lemma [ lemma : const ] .",
    "entries in bold - face type denote completeness for the given complexity class under logspace reductions .",
    "( all reductions in this paper are logspace reductions @xmath1 . )",
    "the entry  stands for logspace solvability .",
    "all other entries denote hardness results .",
    "superscripts refer to the source of the corresponding result as explained in the legend .",
    "this paper is organised as follows .",
    "section [ sec : prelims ] contains all necessary definitions and notation . in section [ sec : np ] , we show -hardness of all intractable cases , followed by section [ sec : nl ] with the -completeness of almost all remaining cases .",
    "we conclude in section [ sec : concl ] . due to the limitations of space ,",
    "we have left out a number of proofs .",
    "these can be found in the technical report @xcite .",
    "a _ boolean function _ is a function @xmath2",
    ". we can identify an @xmath3-ary propositional function symbol @xmath4 with the @xmath3-ary boolean function @xmath5 defined by : @xmath6 if and only if the formula @xmath7 becomes true when assigning @xmath8 to @xmath9 for all @xmath10 .",
    "an _ operator _ is either a function or a function symbol , which becomes clear from the context .",
    "additionally to propositional operators we use the unary temporal operators @xmath11 ( next - time ) , @xmath12 ( eventually ) , @xmath13 ( invariantly ) and the binary temporal operators @xmath14 ( until ) , and @xmath15 ( since ) .",
    "let @xmath16 be a finite set of boolean operators and @xmath17 be a set of temporal operators .",
    "temporal @xmath16-formula over @xmath17 _ is a formula @xmath18 that is built from variables , propositional operators from @xmath16 , and temporal operators from @xmath17 .",
    "more formally , a temporal @xmath16-formula over @xmath17 is either a propositional variable or of the form @xmath19 or @xmath20 , where @xmath21 are temporal @xmath16-formulae over @xmath17 , @xmath5 is an @xmath3-ary propositional operator from @xmath16 and @xmath22 is an @xmath23-ary temporal operator from @xmath17 . in @xcite , complexity results for formulae using the temporal operators , ,  ( unary ) , and ,   ( binary ) were presented .",
    "we extend these results to temporal @xmath16-formulae over subsets of those temporal operators .",
    "the set of variables appearing in @xmath18 is denoted by @xmath24 if @xmath25 we call @xmath18 a _",
    "temporal @xmath16-formula _ , and if @xmath26 we call @xmath18 a _ propositional @xmath16-formula _ or simply a _ @xmath16-formula_. the set of all temporal @xmath16-formulae over @xmath17 is denoted with @xmath27    a _ kripke structure _ is a triple @xmath28 , where @xmath29 is a finite set of states , @xmath30 is a total binary relation ( meaning that , for each @xmath31 , there is some @xmath32 such that @xmath33 ) , and @xmath34 for a set  of variables .",
    "a model in linear temporal logic is a linear structure of states , which intuitively can be seen as different points of time , with propositional assignments .",
    "formally , a _ path _",
    "@xmath35 in @xmath36 is an infinite sequence denoted as @xmath37 , where , for all @xmath38 , @xmath39 and @xmath40 .    for a temporal @xmath41-formula over @xmath42 with variables from , a kripke structure @xmath43 , and a path @xmath35 in @xmath36",
    ", we define what it means that _ @xmath44 satisfies @xmath18 in @xmath45 _ ( @xmath46 ) : let @xmath47 and @xmath48 be temporal @xmath41-formulae over @xmath42 and let @xmath49 be a variable .",
    "lll + @xmath50 &  iff  & @xmath51 + @xmath52 &  iff  & @xmath53 and @xmath54 + @xmath55 &  iff  &",
    "@xmath56 + @xmath57 &  iff  & there is a @xmath58 such that @xmath59 + @xmath60 &  iff  & for all @xmath58 , @xmath59 + @xmath61 &  iff  & @xmath62 + @xmath63 &  iff  & there is an @xmath64 such that @xmath65 , + & & and for every @xmath66 ,   @xmath59 + @xmath67 &  iff  & there is an @xmath68 such that @xmath65 , + & & and for every @xmath69 ,   @xmath59    since every boolean operator can be composed from @xmath70 and @xmath71 , the above definition generalises to temporal @xmath16-formulae for arbitrary sets @xmath16 of boolean operators .",
    "this paper examines the model - checking problems for finite sets @xmath16 of boolean functions and sets @xmath17 of temporal operators .",
    "sistla and clarke @xcite have established the computational complexity of the model - checking problem for temporal @xmath72-formulae over some sets of temporal operators .",
    "[ theorem : sicl85 ]     [ part : mc(f;andorneg ) np - c ] @xmath73 is -complete .",
    "[ part : mc(f , x|u|u , s , x;andorneg ) pspace - c ] @xmath74 , @xmath75 , and @xmath76 are -complete .",
    "since there are infinitely many finite sets of boolean functions , we introduce some algebraic tools to classify the complexity of the infinitely many arising satisfiability problems .",
    "we denote with the @xmath3-ary projection to the @xmath77-th variable , where @xmath78 , , @xmath79 , and with the @xmath3-ary constant function defined by @xmath80 . for @xmath81 and @xmath82",
    "we simply write 1 and 0 . a set @xmath83 of boolean functions",
    "is called a _ clone _ if it is closed under superposition , which means @xmath83 contains all projections and @xmath83 is closed under arbitrary composition @xcite . for a set @xmath16 of boolean functions",
    "we denote with @xmath84 the smallest clone containing @xmath16 and call @xmath16 a _ base _ for @xmath84 . in @xcite post",
    "classified the lattice of all clones and found a finite base for each clone .",
    "the definitions of all clones as well as the full inclusion graph can be found , for example , in  @xcite .",
    "the following lemma the following lemma , which we prove in @xcite , implies that only clones with both constants @xmath85 are relevant for the model - checking problem ; hence we will only define those clones .",
    "note , however , that our results will carry over to all clones .",
    "[ lemma : const ] let @xmath16 be a finite set of boolean functions and @xmath17 be a set of temporal operators",
    ". then @xmath86 .",
    "@xmath87 is trivial . for @xmath88 let @xmath89 be an instance of for a kripke structure @xmath43 and",
    "let @xmath90 and @xmath91 be two fresh variables .",
    "we define a new kripke structure @xmath92 where @xmath93 and we define @xmath94 to be a copy of @xmath18 where every appearance of 0 is replaced by @xmath90 and every appearance of 1 by @xmath91 .",
    "it holds that @xmath95 is an instance of and that @xmath96 if and only if @xmath97 .    because of lemma [ lemma : const ] it is sufficient to look only at the clones with constants , which are introduced in definition  [ def : clones ] .",
    "their bases and inclusion structure are given in figure  [ figure : clones with constants ] .",
    "[ def : clones ] let @xmath98 denote the binary exclusive or .",
    "let @xmath5 be an @xmath3-ary boolean function .",
    "@xmath99 is the set of all boolean functions .",
    "@xmath100 is the set of all monotone functions , that is , the set of all functions @xmath5 where @xmath101 , @xmath102 , @xmath103 implies @xmath104 .",
    "@xmath105 is the set of all linear functions , that is , the set of all functions @xmath5 that satisfy @xmath106 , for constants @xmath107 .",
    "@xmath108 is the set of all functions @xmath5 where @xmath109 , for constants @xmath107 .",
    "@xmath110 is the set of all functions @xmath5 where @xmath111 , for constants @xmath107 .",
    "@xmath112 is the set of all functions that depend on at most one variable .",
    "@xmath113 is the set of all projections and constants .",
    "there is a strong connection between propositional formulae and post s lattice .",
    "if we interpret propositional formulae as boolean functions , it is obvious that @xmath114 $ ] includes exactly those functions that can be represented by @xmath16-formulae .",
    "this connection has been used various times to classify the complexity of problems related to propositional formulae .",
    "for example , lewis presented a dichotomy for the satisfiability problem for propositional @xmath16-formulae : it is -complete if @xmath115 , and solvable in  otherwise @xcite .",
    "furthermore , post s lattice has been applied to the equivalence problem @xcite , to counting @xcite and finding minimal @xcite solutions , and to learnability @xcite for boolean formulae .",
    "the technique has been used in non - classical logic as well : bauland et al .",
    "achieved a trichotomy in the context of modal logic , which says that the satisfiability problem for modal formulae is , depending on the allowed propositional connectives , -complete , -complete , or solvable in  @xcite . for the inference problem for propositional circumscription ,",
    "nordh presented another trichotomy theorem @xcite .",
    "an important tool in restricting the length of the resulting formula in many of our reductions is the following lemma .",
    "following lemma , which we prove in @xcite .",
    "[ lemma : subred ] let @xmath116 , and let @xmath83 be a finite set of boolean functions such that @xmath117 $ ] .",
    "then @xmath118 for every set @xmath17 of temporal operators .",
    "let @xmath119 . from lemmas",
    "1.4.4 and 1.4.5 in  @xcite we directly conclude : let @xmath5 be one of the functions , , and  such that @xmath120 .",
    "let @xmath77 be the arity of @xmath5 .",
    "then there is a @xmath121-formula @xmath122 representing @xmath5 , such that every variable occurs only once in @xmath18 . hence @xmath123 . from lemma  [ lemma : const ]",
    "follows @xmath124 .",
    "it is essential for this lemma that @xmath116 . for , , @xmath125 ,",
    "it is open whether @xmath126 .",
    "this is a reason why we can not immediately transform upper bounds proven by sistla and clarke  @xcite  for example , @xmath127to upper bounds for all finite sets of boolean functions , it is open whether for all finite sets @xmath16 of boolean functions , @xmath128 .",
    "sistla and clarke @xcite and markey @xcite have considered the complexity of model - checking for temporal @xmath72-formulae restricted to atomic negation and propositional negation , respectively .",
    "we define a temporal @xmath16-formula with _",
    "propositional negation _ to be a temporal @xmath16-formula where additional negations are allowed , but only in such a way that no temporal operator appears in the scope of a negation sign . in the case",
    "that negation is an element of @xmath16 , a temporal @xmath16-formula with propositional negation is simply a temporal @xmath16-formula . in @xcite , _ atomic negation _ is considered , which restricts the use of negation even further ",
    "negation is only allowed directly for variables .",
    "we will now show that propositional negation does not make any difference for the complexity of the model checking problem .",
    "since this obviously implies that atomic negation inherits the same complexity behaviour , we will only speak about propositional negation in the following .",
    "the proof of the following lemma is similar to that of lemma  [ lemma : const ] .",
    "[ lemma : propositional negation ] let @xmath17 be a set of temporal operators , and @xmath16 a finite set of boolean functions .",
    "we use @xmath129 to denote the model - checking problem @xmath130 extended to @xmath16-formulae with propositional negation",
    ". then @xmath131 .",
    "the reduction @xmath132 is trivial . for @xmath133 ,",
    "assume that negation is not an element of @xmath16 , otherwise there is nothing to prove .",
    "let @xmath134 be an instance of , where @xmath43 .",
    "let @xmath135 be the variables that appear in @xmath18 , and for each formula of the kind @xmath136 appearing in @xmath137 let @xmath138 be a new variable .",
    "note that since only propositional negation is allowed in @xmath137 in these cases @xmath139 is purely propositional .",
    "we obtain @xmath92 from @xmath36 by extending @xmath140 to the variables @xmath138 in such a way that @xmath138 is _ true _ in a state if and only if @xmath141 is _",
    "false_. finally , to obtain @xmath94 from @xmath18 we replace every appearance of @xmath136 with @xmath142 now , @xmath94 is a temporal @xmath16-formula . by the construction it is straightforward to see that @xmath143 iff @xmath144 .",
    "propositional negation does not affect the complexity of the model checking problem .",
    "this can be proven similarly to lemma  [ lemma : const ] . using lemma  [ lemma : subred ] in addition , we can generalise the above mentioned hardness results from @xcite for temporal monotone formulae to obtain the following intractability results for model - checking .",
    "the proofs of all results in this section are given in @xcite .",
    "[ theorem : propositional negation ] let @xmath145 be a finite set of boolean functions such that @xmath146 . then    [ part : mc(f , g , x;m ) pspace - h ] is -hard .",
    "[ part : mc(f|g|x;m ) np - h ] @xmath147 , @xmath148 , and @xmath149 are -hard .",
    "[ part : mc(u|g , x;m ) pspace - h ] @xmath150 and @xmath151 are -hard .    [ part : mc(s , g|s , f;m ) pspace - h ] @xmath152 and @xmath153 are -hard .    in theorem 3.5 in @xcite it is shown that is -hard .",
    "in fact , sistla and clarke give a reduction from  to .",
    "the result for arbitrary bases @xmath16 generating a clone above @xmath110 follows from lemma  [ lemma : subred ] .",
    "[ cor : mc(f;e ) np - h ] let @xmath154 be a finite set of boolean functions such that @xmath155 . then is -hard .    in general , the model - checking problem for the temporal operators @xmath12 and @xmath11 is -complete due to @xcite .",
    "it is in  when we only allow propositional negation , again following @xcite .",
    "therefore , this problem is in @xmath156 for monotone formulae .",
    "combining this with the result that we are -complete above  even if we only have the temporal operator  ( corollary  [ corollary : mc(f;e ) np - c ] ) , immediately gives the following result .",
    "[ corollary : mc(x , f;e|m ) np - c ] let @xmath157 be a finite set of boolean functions such that @xmath158",
    ". then is -complete .",
    "the model - checking problem for temporal @xmath159-@xmath160-formulae is -complete ( theorem  [ theorem : propositional negation][part : mc(u|g , x;m ) pspace - h ] due to @xcite ) .",
    "the boolean operators @xmath160 are a basis of @xmath100 , the class of monotone boolean formulae .",
    "what happens for fragments of ? in theorem  [ theorem : mc(f , x;v ) mc(g , x;e ) nl - c ] we will show that is -complete , , the model - checking problem for temporal @xmath161-formulae over @xmath159 is very simple .",
    "we can prove that switching from @xmath70 to @xmath162 makes the problem intractable .",
    "as notation , we use @xmath163 to denote the literals obtained from variables that appear in @xmath18 .    [",
    "theorem : mc(g , x;v ) np - h ] let @xmath164 be a finite set of boolean functions such that @xmath165",
    ". then @xmath166 is -hard .",
    "it suffices to give a reduction from   to @xmath167 ( due to lemma  [ lemma : subred ] ) .",
    "a formula @xmath139 in 3cnf is mapped to an instance @xmath168 of as follows .",
    "let @xmath169 consist of @xmath23 clauses , and @xmath170 variables .",
    "the kripke structure @xmath171 has states @xmath172 containing one state for every clause , a sequence of states @xmath173 for every literal , and a final sink state @xmath174 .",
    "that is , the set of states is @xmath175 .",
    "the variables of @xmath171 are @xmath176 .",
    "variable @xmath177 is assigned _ true _ in a state @xmath178 iff literal @xmath179 is contained in clause @xmath180 . in all other states , every @xmath181 is _",
    "false_. variable @xmath4 is assigned _ true _ in all states in @xmath182 .",
    "the relation between the states is @xmath183 as follows .",
    "it starts with the path @xmath184 : @xmath185 .",
    "@xmath186 has an edge to @xmath187 and an edge to @xmath188 : @xmath189 .",
    "each @xmath178 is the starting point of a path @xmath190 : @xmath191 .",
    "each endpoint of these paths has both the literals with the next index resp .",
    "the final sink state as neighbours : @xmath192 .",
    "the final sink state @xmath174 has an edge to @xmath174 itself , @xmath193 .     for @xmath194 .",
    "]    figure  [ figure : structure for gxv ] shows an example for a formula @xmath195 and the kripke structure @xmath196 .",
    "notice that every path in such a kripke structure @xmath171 corresponds to an assignment to the variables in @xmath139 .",
    "a path corresponds to a satisfying assignment iff for every @xmath181 the path contains a state that @xmath181 is assigned to .",
    "we are now going to construct a formula @xmath197 to express this property .",
    "if we were allowed to use the @xmath70 in @xmath197 , this would be easy .",
    "but , the formula @xmath197 consists only of operators , , @xmath162 , and of variables @xmath176 . in order to define @xmath197 , we use formulae @xmath21 and @xmath198 defined as follows . for @xmath199",
    "define @xmath200 intuitively , @xmath21 says that @xmath181 is satisfied in a state in distance @xmath201 , where @xmath202 . the state @xmath203 is the only state in @xmath204 where @xmath205 can hold .",
    "every path @xmath35 in @xmath171 has the form @xmath206 .",
    "every state except for @xmath174 appears at most once in @xmath35 . for the sake of simplicity , we use the notation @xmath207 for @xmath208 ( for @xmath199 ) , and @xmath209 for @xmath210 .",
    "we use for a path @xmath211 in @xmath171 and @xmath212 the notation @xmath207 for @xmath208 .",
    "[ claim : np1 ] for every path @xmath35 in @xmath171 and @xmath213 holds : if @xmath214 , then @xmath215 .",
    "assume @xmath214 , where @xmath213 . by the definition of @xmath205",
    ", it follows that @xmath216 for some @xmath77 with @xmath78 .",
    "consider any path @xmath35 in @xmath171 .",
    "after the initial part @xmath217 of @xmath35 follows a sequence @xmath218 of @xmath219 states , where @xmath220 ( for @xmath221 ) . therefore , @xmath222 for some @xmath223 ( that does not matter here ) . but",
    "@xmath224 implies @xmath225 , by the definition of @xmath171 , and therefore @xmath226 . since @xmath213",
    ", it follows that @xmath227 .",
    "the formulae @xmath198 are defined inductively for @xmath228 as follows ( as before , we can use @xmath162 in our construction ) : @xmath229 finally , @xmath230 .",
    "it is clear that the reduction function @xmath231 can be computed in logarithmic space .",
    "it remains to prove the correctness of the reduction .",
    "using claim  [ claim : np1 ] , we make the following observation .    [",
    "claim : np2 ] for every path @xmath211 in @xmath171 and @xmath232 holds :      @xmath233   if and only if   for @xmath234 holds @xmath235 .",
    "the direction from right to left is straightforward . to prove the other direction , we use induction .",
    "as base case we consider @xmath236 .",
    "assume @xmath237 .",
    "by construction of @xmath171 holds @xmath238 , and therefore @xmath239 holds .",
    "for the inductive step , assume @xmath240 .",
    "claim  [ claim : np1 ] proves @xmath241 for @xmath242 , and with @xmath243 we obtain @xmath244 .",
    "this implies @xmath245 and @xmath246 . by the inductive hypothesis",
    ", the claim follows .    for a path @xmath35 in @xmath171 ,",
    "let @xmath247 be the corresponding assignment for @xmath139 .",
    "it is clear that @xmath248 if and only if @xmath247 satisfies clause @xmath249 of @xmath139 . using claim  [ claim : np2 ] , it follows that @xmath250 if and only if @xmath247 satisfies all clauses of @xmath139 , , @xmath247 satisfies @xmath139 . using the one - to - one correspondence between paths in @xmath171 and assignments to the variables of @xmath139 we get @xmath251 if and only if @xmath252 .    from @xcite",
    "it follows that @xmath253 is in .",
    "it remains open whether @xmath253 or @xmath254 have an upper bound below .    if we allow only one of the temporal operators @xmath13 and @xmath11 in monotone formulae , the complexity of model - checking drops to -complete .",
    "[ lemma : mc(g|x;m ) np ] and are in .",
    "-membership of is known from  @xcite .",
    "it remains to show that @xmath255 . given a formula @xmath256 , a kripke structure @xmath257 , and a state @xmath31 ,",
    "let @xmath23 denote the maximal nesting depth of -operators in @xmath18 .",
    "clearly @xmath258 .",
    "notice that for any @xmath77-ary boolean operator @xmath5 from @xmath99 , the formula @xmath259 is equivalent to @xmath260 .",
    "hence @xmath18 can be transformed in polynomial time into a formula @xmath261 , where the -operators occur in @xmath94 only in front of atomic propositions or constants ( possibly in sequences @xmath262 ) .",
    "the truth of @xmath94 at @xmath263 in @xmath36 can now be determined as follows : guess a path @xmath264 in @xmath36 starting at @xmath265 . for each subformula @xmath266 of @xmath94 ,",
    "@xmath267 , if @xmath268 , then mark @xmath269 with @xmath266 .",
    "finally , evaluate that boolean formula at @xmath269 which is obtained from @xmath94 if all subformulae @xmath266 are considered as atomic propositions .",
    "it is clear that all three steps can be performed in polynomial time .",
    "combining lemma  [ lemma : mc(g|x;m ) np ] and theorem  [ theorem : propositional negation][theorem : propositional negation : mc(f|g|x;m ) np - c ] we obtain the following result .",
    "[ theorem : mc(g|x;m ) np - c ] let @xmath16 be a finite set of boolean functions such that @xmath270 . then and are -complete .",
    "next , we consider formulae with the until - operator or the since - operator .",
    "we first show that using the until - operator makes model - checking intractable .",
    "[ theorem : mc(u;. ) np - h ] let @xmath16 be a finite set of boolean functions . then is -hard .",
    "we give a reduction from  to @xmath271 .",
    "this means , that we do not need any boolean operators in the temporal formula over @xmath272 to which a  instance is mapped .",
    "let @xmath273 be a 3cnf formula consisting of @xmath23 clauses and @xmath3 variables .",
    "the structure @xmath171 has states @xmath274 , with initial state @xmath275 .",
    "the assignment for state @xmath276 is @xmath277 ( for @xmath199 ) , and for state @xmath179 it is @xmath278 . in state @xmath279",
    ", no variable is assigned true .",
    "the relation between the states is as follows .",
    "each @xmath276 ( @xmath280 ) has an edge to @xmath281 , @xmath186 has edges to @xmath282 and to @xmath283 , each @xmath179 ( @xmath284 ) has edges to @xmath285 and to @xmath286 , and @xmath287 and @xmath288 have an edge to @xmath279 .",
    "@xmath279 has an edge to @xmath279 only .",
    "figure  [ figure : structure for until ] gives an example .     for @xmath289",
    "the following facts are easy to verify for any path @xmath35 in @xmath171 . for the sake of simplicity , we use for a path @xmath211 in @xmath171 and @xmath212 the notation @xmath207 for @xmath208 .",
    "fact 1 : :    for @xmath290 holds :    @xmath291 .",
    "fact 2 : :    for @xmath292 holds :    @xmath293 iff    @xmath294 .    the formulae @xmath295 are defined inductively as follows . @xmath296",
    "the reduction from @xmath297 to is the mapping @xmath298 , where @xmath139 is a 3cnf - formula with @xmath23 clauses .",
    "this reduction can evidently be performed in logarithmic space . to prove its correctness",
    ", we use the following claim .    [ claim : np3 ] let @xmath171 be constructed from a formula @xmath139 with @xmath23 clauses , and let @xmath35 be a path in @xmath171 . for @xmath299 , it holds that @xmath300",
    "@xmath301    we prove the claim by induction .",
    "the base case @xmath302 is straightforward : @xmath303 is equivalent to @xmath304 which by fact 2 is equivalent to @xmath305 .",
    "the inductive step is split into two cases .",
    "first , assume @xmath306 .",
    "since @xmath307 , it follows that @xmath308 .",
    "using fact 2 , we conclude @xmath309 .",
    "by fact 1 , @xmath310 . by the initial assumption",
    ", this leads to @xmath311 .",
    "second , assume @xmath311 and @xmath309 . using the induction hypothesis",
    ", we obtain @xmath312 for @xmath313 . by the construction of @xmath314",
    "we immediately get @xmath315 .",
    "we have a one - to - one correspondence between paths in @xmath171 and assignments to variables of @xmath139 . for a path @xmath35 we will denote the corresponding assignment by @xmath247 . using claim  [ claim : np3 ] , it is easy to see that the following properties are equivalent .    1 .",
    "@xmath247 is a satisfying assignment for @xmath139 .",
    "path @xmath35 in @xmath171 contains for every @xmath199 a state with assignment @xmath181 .",
    "3 .   @xmath316 for @xmath199 .",
    "4 .   @xmath317 .",
    "this concludes the proof that @xmath318 if and only if @xmath319 .",
    "although the until - operator and the since - operator appear to be similar , model - checking for formulae that use the since - operator as only operator is as simple as for formulae without temporal operators  see theorem  [ theorem : mc(s;bf ) in l ] .",
    "the reason is that the since - operator has no use at the beginning of a path of states , where no past exists .",
    "it needs other temporal operators that are able to enforce to visit a state on a path that has a past .",
    "[ theorem : mc(s , g;. ) np - h][theorem : mc(s , x;. ) np - h ] let @xmath16 be a finite set of boolean functions . then and are -hard .",
    "we give a reduction from  to that is similar to that in the proof of theorem  [ theorem : mc(u;. ) np - h ] for .",
    "let @xmath139 be an instance of , and let @xmath171 be the structure as in the proof of theorem  [ theorem : mc(u;. ) np - h ] . from @xmath320",
    "we obtain the structure @xmath321 as follows .",
    "first , we add a new state @xmath322 , , @xmath323 .",
    "second , replace @xmath324 by its inverse @xmath325 from which the loop at state @xmath279 is removed .",
    "the state @xmath279 has in - degree @xmath326 and will be seen as initial state of @xmath327 .",
    "the new state @xmath322 will be used as sink state .",
    "therefore , we add the arcs @xmath328 and @xmath329 .",
    "this results in @xmath330 . finally , we add a new variable @xmath331 that is _ true _ only in state @xmath322 , and a variable @xmath201 that is _ true _ in states @xmath332 . for all other variables , @xmath333 is the same as @xmath140",
    ".     for @xmath289    ( figure  [ figure : structure for since ] shows an example . )",
    "the formulae @xmath334 are defined inductively as follows .",
    "@xmath335 the reduction from @xmath297 to is the mapping @xmath336 , where @xmath139 is a 3cnf - formula with @xmath23 clauses .",
    "this reduction can evidently be performed in logarithmic space . to prove its correctness",
    ", we use the following claim .",
    "every path @xmath337 in @xmath338 that begins in state @xmath279 corresponds to an assignment @xmath339 to the variables in @xmath139 , that sets all literals to _ true _ that appear on @xmath35 . for the sake of simplicity",
    ", we use the notation @xmath340 for @xmath341 .",
    "[ claim : np4 ] let @xmath338 be constructed from a formula @xmath342 with @xmath23 clauses , and let @xmath337 be a path in @xmath338 .",
    "for @xmath299 it holds that    @xmath343   if and only if   the assignment @xmath344 satisfies clauses @xmath345 .",
    "notice that @xmath344 satisfies clause @xmath346 if and only if @xmath35 contains a state @xmath347 with @xmath348 .",
    "we prove the claim by induction .",
    "since the variable @xmath201 holds in all predecessors of @xmath186 in @xmath35 but not in @xmath186 , it follows that @xmath349 holds in @xmath186 iff @xmath350 holds in @xmath186 . since @xmath351",
    ", it follows that @xmath350 holds in @xmath186 iff @xmath352 holds in a predecessor of @xmath186 iff @xmath344 satisfies @xmath353 .",
    "this completes the base case .",
    "for the inductive step , notice that @xmath343 iff @xmath354 and @xmath355 . by the construction of @xmath338",
    "it follows that @xmath354 iff @xmath344 satisfies @xmath346 , and the rest follows from the induction hypothesis .",
    "finally , let @xmath139 be a 3cnf formula , and let @xmath337 be a path in @xmath338 .",
    "on the first @xmath356 states of @xmath35 , the variable @xmath201 holds . therefore , @xmath357 and henceforth @xmath358 is satisfied in all these states . on the @xmath23 following states @xmath359 , neither @xmath201 nor @xmath331 holds .",
    "notice that @xmath360 iff @xmath361 ( for @xmath362 ) . by claim  [ claim : np4 ] , @xmath357 and",
    "henceforth @xmath358 is satisfied in all these states iff @xmath344 satisfies @xmath139 . on the remaining states , only the variable @xmath331 holds .",
    "hence , @xmath358 is satisfied in all the latter states iff @xmath344 satisfies @xmath139 . concluding",
    ", it follows that @xmath363 iff @xmath344 satisfies @xmath139 . since for every assignment to @xmath139 the structure @xmath338 contains a corresponding path , the correctness of the reduction is proven .",
    "the future - operator @xmath12 alone is not powerful enough to make the since - operator @xmath15 -hard : we will show in theorem  [ theorem : mc(s , f;v ) nl - c ] that for @xmath364 is -complete .",
    "but with the help of @xmath71 or @xmath70 , the model - checking problem for @xmath12 and @xmath15 becomes intractable .",
    "[ theorem : mc(s , f;e|n ) np - h ] let @xmath365 be a finite set of boolean functions such that @xmath366 . then  is -hard .    by lemma  [ lemma : subred ] it suffices to give a reduction from   to @xmath367 .",
    "for a 3cnf formula @xmath139 , let @xmath368 be the instance of @xmath369 as described in the proof of theorem  [ theorem : mc(s , g;. ) np - h ] . using @xmath370",
    ", it follows that @xmath371 , where the latter is a @xmath112-formula over @xmath372 .",
    "the correctness of the reduction the same line as the proof of theorem  [ theorem : mc(s , g;. ) np - h ] .    [ theorem : mc(s , x;. ) np - c ] let @xmath16 be a finite set of boolean functions .",
    "then is -hard .",
    "to prove -hardness , we give a reduction from  to . for a 3cnf formula @xmath139 ,",
    "let @xmath338 be the structure as described in the proof of theorem  [ theorem : mc(s , g;. ) np - h ] .",
    "the reduction function maps @xmath139 to @xmath373 .",
    "the @xmath374 `` moves '' to state @xmath275 on any path in @xmath338 .",
    "the correctness proof follows the same line as the proof of theorem  [ theorem : mc(s , g;. ) np - h ] .",
    "an upper bound better than  for the intractable cases with the until - operator or the since - operator remains open .",
    "we will now show that one canonical way to prove an  upper bound fails , in showing that these problems do not have the `` short path property '' , which claims that a path in the structure that fulfills the formula has length polynomial in the length of the structure and the formula .",
    "hence , it will most likely be nontrivial to obtain a better upper bound",
    ".    we will now sketch such families of structures and formulae using an inductive definition .",
    "let @xmath375 be the family of graphs presented in figures  [ fig : exponential size graph 1 ] and [ fig : exponential size graph 2 ] .",
    "notice that @xmath376 is inserted into @xmath377 using the obvious lead - in and lead - out arrows .    ]    ]    the truth assignments for these graphs are as follows : @xmath378 now the formulae are defined as follows : @xmath379    the rough idea behind the construction is as follows : to satisfy the formula @xmath47 in @xmath380 the path has to repeat the circle once . in the inductive construction , this leads to an exponential number of repetitions .",
    "this subsection is concerned with fragments of ltl that have a tractable model - checking problem .",
    "we will provide a complete analysis for these fragments by proving that model checking for all of them is -complete or even solvable in logarithmic space .",
    "this exhibits a surprisingly large gap in complexity between easy and hard fragments .",
    "the following lemma establishes -hardness for all tractable fragments .",
    "it is proven in @xcite .",
    "[ lemma : mc(f|g|x;. ) nl - h ] let @xmath16 be a finite set of boolean functions . then , , and are -hard .",
    "first consider .",
    "we reduce the accessibility problem for digraphs , gap , to .",
    "the reduction is via the following logspace computable function .",
    "given an instance @xmath381 of gap , where @xmath382 is a digraph and @xmath383 , map it to the instance @xmath384 of with @xmath385 , where @xmath386 denotes the reflexive closure of @xmath157 , and @xmath140 is given by @xmath387 and @xmath388 , for all @xmath389 .",
    "it is immediately clear that there is a path from @xmath263 to @xmath390 in @xmath391 if and only if there is a path @xmath35 in @xmath392 starting from @xmath263 such that @xmath393 .    for",
    ", we use an analogous reduction from gap to .",
    "given an instance @xmath381 of , where @xmath394 , transform it into the instance @xmath395 of with the kripke structure @xmath392 from above .",
    "now it is clear that there is a path from @xmath263 to @xmath390 in @xmath391 if and only if there is a path of length @xmath396 from @xmath263 to @xmath390 in the reflexive structure @xmath392 , if and only if there is a path @xmath35 in @xmath392 starting from @xmath263 such that @xmath397 .",
    "now consider .",
    "we reduce the following problem to . given a directed graph @xmath382 and a vertex @xmath398 , is there an infinite path in @xmath391 starting at @xmath263 ?",
    "it is folklore that this is an -hard problem ( see lemma  [ lem : existence_of_infinite_path_is_nl - hard ] in the appendix ) .",
    "given an instance @xmath399 of this problem , transform it into the instance @xmath400 of , where @xmath401 .",
    "here @xmath402 , @xmath403 , @xmath404 for all @xmath405 , and @xmath406 , for all @xmath407 .",
    "it is immediately clear that there is an infinite path in @xmath391 starting at @xmath263 if and only if there is a path @xmath35 in @xmath408 starting from @xmath263 such that @xmath409 .",
    "it now remains to establish upper complexity bounds .",
    "let @xmath83 be one of the clones , , , and , and let @xmath16 be a finite set of boolean functions such that @xmath410 .",
    "whenever we want to establish -membership for some problem , it will suffice to assume that formulae are given over one of the bases @xmath411 , @xmath412 , @xmath413 , or @xmath414 , respectively .",
    "this follows since these clones only contain constants , projections , and multi - ary versions of , , , and @xmath98 , respectively .",
    "[ theorem : mc(f , g , x;n ) nl - c ] let @xmath415 be a finite set of boolean functions such that @xmath416 then is -complete .",
    "the lower bound follows from lemma  [ lemma : mc(f|g|x;. ) nl - h ] . for the upper bound , first note that for an ltl formula @xmath139 the following equivalences",
    "hold : @xmath417 , @xmath418 , @xmath419 , @xmath420 , @xmath421 , and @xmath422 . furthermore , it is possible to interchange @xmath11 and adjacent @xmath13- , @xmath12- , or @xmath71-operators without affecting satisfiability . under these considerations ,",
    "each formula @xmath423 can be transformed without changing satisfiability into a normal form @xmath424 , where @xmath425 is a prefix ranging over the values `` empty string '' , , , , and ; @xmath23 is the number of occurrences of  in @xmath18 ; @xmath426 is either the empty string or @xmath71 ; and @xmath427 is a variable or a constant .",
    "this normal form has two important properties .",
    "first , it can be represented in logarithmic space using two binary counters @xmath263 and @xmath390 .",
    "the counter @xmath263 stores @xmath23 , and @xmath390 takes on values @xmath428 to represent each possible combination of @xmath425 and @xmath426 . note that @xmath263 takes on values less than @xmath429 , and @xmath390 has a constant range .",
    "hence both counters require at most logarithmic space . it is not necessary to store any information about @xmath427 , because it can be taken from the representation of @xmath18 .",
    "second , @xmath94 can be _ computed _ from @xmath18 in logarithmic space .",
    "the value of @xmath263 is obtained by counting the occurrences of  in @xmath18 , and @xmath390 is obtained by linearly parsing @xmath18 with the automaton that is given in figure  [ fig : automaton_for_gfneg_prefix ] , and which ignores all occurrences of .    ]",
    "the state of this automaton at the end of the passage through @xmath18 determines the values of @xmath425 and @xmath426 in @xmath18 .",
    "now let @xmath18 be an \\{,,},n_--formula , @xmath43 a kripke structure and @xmath31 .",
    "if @xmath427 is constant , the problem is trivial , therefore it remains to consider the case where @xmath427 is a variable . according to the possible values of @xmath425 and @xmath426 in @xmath18 ,",
    "there are ten cases to consider .",
    "we only present the argumentation for those five in which @xmath426 is empty .",
    "( for the dual cases , kindly replace each occurrence of `` @xmath430 '' by `` @xmath431 '' . ) in the following list , we assume that @xmath432 . as per explanation below , this is not a significant restriction .",
    "@xmath425 is empty : :    then @xmath433 if    and only if there is a state @xmath390 in @xmath36    accessible from @xmath263 via @xmath324 such that    @xmath434 .",
    "@xmath435 : :    in this case we have to check whether there is a state    @xmath32 that can be reached from @xmath263 via    @xmath324 , and @xmath434 .",
    "@xmath436 : :    we define @xmath437 and    @xmath438 .",
    "it holds that    @xmath433 if and    only if there is some @xmath439 such that @xmath390    is accessible from @xmath263 via @xmath440 and    @xmath390 belongs to a cycle in @xmath440 .",
    "@xmath441 : :    we can reduce this case to the previous one :    @xmath433 if and    only if there is some @xmath439 that can be reached from    @xmath263 via @xmath324 , and    @xmath442 . @xmath443",
    ": :    we have to check whether there exists some @xmath32 that    can be reached from @xmath263 via @xmath324 such that    @xmath434 and @xmath390 belongs to a cycle .",
    "since the questions whether there is a path from any vertex to another and whether any vertex belongs to a cycle in a directed graph can be answered in , all previously given procedures are -algorithms .",
    "the restriction @xmath432 is removed by the observation that @xmath444 if and only if there exists some state @xmath390 in @xmath36 that is accessible from @xmath263 in @xmath23 @xmath324-steps such that @xmath445 .",
    "this reduces the case @xmath446 to @xmath432 .",
    "hence we have found an -algorithm deciding : given @xmath447 , compute @xmath94 , guess a state @xmath390 accessible from @xmath263 in @xmath23 @xmath324-steps , apply the procedure of one of the above five cases to @xmath448 , and accept if the last step was successful .",
    "we show in @xcite how to obtain an  algorithm using the normal form @xmath94 .",
    "[ theorem : mc(f , x;v ) mc(g , x;e ) nl - c ]    [ part : fxv ] let @xmath449 be a finite set of boolean functions such that @xmath450",
    ". then  is -complete .",
    "[ part : gxe ] let @xmath451 be a finite set of boolean functions such that @xmath452 .",
    "+ then  is -complete .",
    "the lower bounds follow from lemma  [ lemma : mc(f|g|x;. ) nl - h ] .",
    "first consider the case @xmath453 it holds that @xmath454 as well as @xmath455 and @xmath456 .",
    "therefore , every formula @xmath457 can be rewritten as @xmath458 where @xmath459 are variables or constants ( note that this representation of @xmath18 can be constructed in ) .",
    "now let @xmath447 be an instance of , where @xmath257 , and let @xmath18 be of the above form .",
    "thus , @xmath460",
    "if and only if for some @xmath461 , there is a state @xmath32 such that @xmath462 and @xmath390 is accessible from @xmath263 in exactly @xmath463 @xmath324-steps or if , for some @xmath464 , there is a state @xmath32 such that @xmath462 and @xmath390 is accessible from @xmath263 in at least @xmath463 @xmath324-steps . this can be tested in .    as for the case",
    "@xmath465 we take advantage of the duality of @xmath12 and @xmath13 , and @xmath70 and @xmath162 , respectively .",
    "analogous considerations as above lead to the logspace computable normal form @xmath466 let @xmath467 .",
    "for each @xmath468 , we define @xmath469 and @xmath470 .",
    "furthermore , let @xmath471 be the union of @xmath472 for @xmath473 ( ! ) , and let @xmath474 .",
    "now @xmath475 if and only if there is some state @xmath439 satisfying the following conditions .",
    "* there is an @xmath324-path @xmath35 of length at least @xmath476 from @xmath263 to @xmath390 , where the first @xmath477 states on @xmath35 are @xmath478 , @xmath479 , ",
    ", @xmath480 . *",
    "the state @xmath481 lies on a cycle in @xmath471 .",
    "* for each @xmath473 , each state of @xmath35 from @xmath482 to @xmath480 is from @xmath472 . * for each @xmath483 , the state @xmath482 is from @xmath472 .",
    "these conditions can be tested in  as follows .",
    "successively guess @xmath484 and verify their membership in the appropriate sets @xmath472 .",
    "then guess @xmath390 , verify whether @xmath439 , whether @xmath390 lies on some @xmath440-cycle , and whether there is an @xmath440-path from @xmath480 to @xmath390 .    in the proof of theorem  [",
    "theorem : mc(f , x;v ) mc(g , x;e ) nl - c ] , we have exploited the duality of  and , and @xmath162 and @xmath70 , respectively .",
    "furthermore , the proof relied on the fact that  and @xmath162 ( and  and @xmath70 ) are interchangeable .",
    "this is not the case for  and @xmath70 , or  and @xmath162 , respectively .",
    "hence it is not surprising that @xmath485 is -hard ( corollary  [ cor : mc(f;e ) np - h ] ) .",
    "however , the -membership of @xmath486 _ is _ surprising .",
    "before we formulate this result , we try to provide an intuition for the tractability of this problem .",
    "the main reason is that an inductive view on @xmath487-formulae allows us to subsequently guess parts of a satisfying path without keeping the previously guessed parts in memory .",
    "this is possible because each @xmath487-formula @xmath18 can be rewritten as @xmath488 where the @xmath489 are variables ( or constants ) , and each @xmath490 is an @xmath487-formula of the same form with a strictly smaller nesting depth of -operators .",
    "now , @xmath18 is _ true _ at the begin of some path @xmath35 iff one of its disjuncts is _ true _ there . in case none of the @xmath491 or @xmath492",
    "is _ true _ , we must guess one of the @xmath493 ( or @xmath494 ) and check whether @xmath490 ( or @xmath495 ) is _ true _ on the entire path @xmath35 ( or on @xmath35 minus some finite number of initial states ) .",
    "now @xmath490 is again of the above form .",
    "so we must either find an infinite path on which @xmath496 is _ true _ everywhere ( a cycle containing at least @xmath497 states satisfying some @xmath491 or @xmath498 suffices , where @xmath499 is the set of states of the kripke structure ) , or we must find a _",
    "path satisfying the same conditions and followed by an infinite path satisfying one of the @xmath493 ( or @xmath494 ) at its initial point .",
    "hence we can recursively solve a problem of the same kind with reduced problem size .",
    "note that it is neither necessary to explicitly compute the normal form for @xmath18 or one of the @xmath490 , nor need previously visited states be stored in memory .",
    "[ theorem : mc(f , g;v ) nl - c ] let @xmath449 be a finite set of boolean functions such that @xmath453 then and are -complete .",
    "the lower bound follows from lemma  [ lemma : mc(f|g|x;. ) nl - h ] .",
    "it remains to show -membership of .",
    "for this purpose , we devise the recursive algorithm  as given in table [ tab : alg_ltl - f , g , v - mc ] .",
    "note that we have deliberately left out constants .",
    "this is no restriction , since we have observed in lemma  [ lemma : const ] that each constant can be regarded as a variable that is set to _ true _ or _ false _ throughout the whole kripke structure .",
    "* algorithm *    .the algorithm [ cols= \" < , < \" , ]     ' '' ''    ' '' ''    ' '' ''    ' '' ''    ' '' ''    [ tab : alg_ltl - f , g , v - mc ]    the parameter _ mode _ indicates the current `` mode '' of the computation .",
    "the idea is as follows . in order to determine whether @xmath18 is satisfiable at the _ initial _ point of some structure starting at @xmath263 in @xmath36",
    ", the algorithm has to be in mode ` now ` .",
    "this , hence , is the default setting for the first call of .",
    "as soon as the algorithm chooses to process a -subformula @xmath500 of @xmath18 , it has to determine whether @xmath501 is satisfiable at _ every _ point in some structure starting at the currently visited state in @xmath36 .",
    "it therefore changes into ` always ` mode and calls itself recursively with the first parameter set to @xmath501 , see line 17 .",
    "hence , given an instance @xmath447 of the problem , we have to invoke @xmath502 in order to determine whether there is a satisfying path for @xmath18 in @xmath36 starting at @xmath263 .",
    "it is easy to see that this call always terminates : first , whenever the algorithm calls itself recursively , the first argument of the new call is a strict subformula of the original first argument .",
    "therefore there can be at most @xmath429 recursive calls .",
    "second , within each call , each passage through the _ while _ loop ( lines 232 ) either decreases @xmath139 or increases @xmath4 .",
    "hence , there can be at most @xmath503 passages through the _ while _ loop until the algorithm accepts or rejects .",
    "is an  algorithm : the values of all parameters and programme variables are either subformulae of the original formula @xmath18 , states of the given kripke structure @xmath36 , counters of range @xmath504 , or booleans .",
    "they can all be represented using @xmath505 , @xmath506 , or constantly many bits .",
    "furthermore , since the algorithm uses no _ return _",
    "command , the recursive calls may re - use the space provided for all parameters and programme variables , and no return addresses need be stored .",
    "it remains to show the correctness of , which we will do in two steps . in ` always ` mode , which will be shown by induction on the nesting depth of the -operator in @xmath18 .",
    "we denote this value by @xmath507 .",
    "claim  [ claim : fgv2 ] will then ensure the correct behaviour in ` now ` mode .",
    "both claims are proven in @xcite .",
    "[ claim : fgv1 ] for each @xmath508 , each @xmath257 , and each @xmath31 :    @xmath509   @xmath510   + @xmath511 .    _ for the base case of the induction , _",
    "let @xmath512 .",
    "because of the equivalences @xmath513 and @xmath514 , we may assume w.l.o.g .",
    "that any occurrence of the -operator is in front of some variable in @xmath18 .",
    "if we think of @xmath18 as a tree , this means that -operators can only occur in direct predecessors of leaves .",
    "note that the algorithm computes this normal form implicitly : whenever it guesses a path from the root ( @xmath18 ) to some leaf ( a variable ) in the tree and encounters an -operator in line 6 , the flag _ ffound _ is set . only after processing all @xmath162-operators on the remaining part of the path ,",
    "the -operator is processed in lines 1015 .",
    "now let @xmath515 be all variables that occur in the scope of an -operator in @xmath18 , and let @xmath516 be all other variables in @xmath18 .",
    "_ for the `` @xmath517 '' direction , _",
    "suppose @xmath509 .",
    "then there exists a path @xmath35 in @xmath36 such that @xmath518 , and for all @xmath38 , @xmath519 .",
    "this means that , for each @xmath520 , either there exists some @xmath521 such that @xmath522 , or there is some @xmath523 such that @xmath524 .",
    "now it can be seen that there is a non - rejecting sequence of runs through the _ while _ loop in lines 232 after which @xmath4 has value @xmath525 , which then leads to the _ accept _ in line 33 :    consider the begin of an arbitrary single run through the _ while _ loop in line 2 .",
    "let @xmath45 be the current value of @xmath390 .",
    "if @xmath521 , then the algorithm can `` guess its way through the tree of @xmath18 '' in lines 35 and finally reaches line 19 with @xmath526 .",
    "it does not reject in line 20 , increases @xmath4 in line 23 , guesses @xmath527 in line 24 , and resets _ ffound _ and @xmath139 appropriately in lines 25 , 26 .",
    "otherwise , if @xmath523 , then there is some @xmath528 such that @xmath529 satisfies @xmath9 .",
    "it is safe to assume that @xmath530 because otherwise the path from @xmath45 to @xmath529 would describe a cycle within @xmath36 which could be replaced by a shorter , more direct , path without affecting satisfiability of the relevant subformulae in the states @xmath531 .",
    "now the algorithm can proceed as in the previous case , but , in addition , it has to guess the correct value of @xmath3 and the sequence @xmath532 in lines 1015 .",
    "_ for the `` @xmath533 '' direction , _",
    "let there be an accepting run of @xmath511 . since the algorithm is in `",
    "always ` mode , and @xmath18 is -free , the acceptance can only take place in line 33 , without a recursive call in line 17 .",
    "hence the counter @xmath4 reaches value @xmath525 in the _ while _ loop in lines 232 .",
    "let @xmath534 be the sequence of states guessed in this run in lines 13 and 24 , where @xmath518 .",
    "furthermore , let @xmath535 be an index sequence that determines a subsequence of @xmath35 such that    * @xmath536,and * for each @xmath537 , @xmath538 is the value assigned to @xmath390 in line 24 after having set @xmath4 to value @xmath539 in line 23 .",
    "now it is clear that for all @xmath540 , there must be a variable @xmath541 such that @xmath542 . if @xmath543 , then @xmath544 , and each structure @xmath545 extending @xmath35 beyond @xmath546 satisfies @xmath541 ( and hence @xmath18 ) at @xmath538 .",
    "otherwise @xmath547 , and the accepting run of the algorithm has guessed the states @xmath548 in line 13 . in this case , each structure @xmath545 extending @xmath35 beyond @xmath546 satisfies @xmath549 ( and hence @xmath18 ) at @xmath548 .",
    "from these two cases , we conclude that each such @xmath545 satisfies @xmath18 in all states @xmath550 .",
    "we now restrict attention to the states @xmath551 . among these @xmath525 states ,",
    "some of the @xmath552 states of @xmath36 has to occur twice .",
    "assume @xmath553 and @xmath554 represent the same state from @xmath36 , where @xmath555 .",
    "then we can create an ( infinite ) structure @xmath556 from @xmath35 that consists of states @xmath557 , followed by an infinite repetition of the sequence @xmath558 .",
    "it is now obvious that @xmath556 satisfies @xmath18 in every state , hence @xmath559 , that is , @xmath509 .",
    "_ for the induction step , _",
    "let @xmath560 .",
    "for the same reasons as above , we can assume that any -operator only occurs in front of variables or in front of some -operator in @xmath18 .",
    "this `` normal form '' is taken care of by setting _ ffound _ to ` true ` when  is found ( line 7 ) and processing this occurrence of  only when a variable or some -operator is found ( lines 1015 ) .",
    "_ for the `` @xmath517 '' direction , _",
    "suppose @xmath509 .",
    "then there exists a path @xmath35 in @xmath36 such that @xmath518 , and for all @xmath38 , @xmath561 .",
    "we describe an accepting run of @xmath511 .",
    "consider a single passage through the _ while _ loop with the following configuration .",
    "the programme counter has value @xmath562 , @xmath4 has value at most @xmath552 , @xmath390 has value @xmath45 , and @xmath139 has value @xmath18 . since @xmath561 , there are four possible cases .",
    "the argumentation for the first two of them is the same as in the base case .",
    "blub    @xmath563 , for some @xmath564 .",
    "@xmath565 , for some @xmath566 .",
    "@xmath567 , for some maximal -subformula @xmath500 of @xmath18 that is _ not _ in the scope of some -operator .",
    "this means that @xmath501 is _ true _ everywhere on the path @xmath568 .",
    "hence , due to the induction hypothesis , @xmath569 has an accepting run . by appropriate guesses in line 4",
    ", the current call of the algorithm can reach that accepting recursive call in line 17 .",
    "@xmath567 , for some maximal -subformula @xmath500 of @xmath18 that _ is _ in the scope of some -operator .    by combining the arguments of cases 3 and 2",
    ", we can find an accepting run for this case .",
    "if only cases 1 or 2 occur more than @xmath552 times in a sequence , then @xmath4 will finally take on value @xmath525 , and this call will accept in line 31 .",
    "otherwise , whenever one of cases 3 and 4 occurs , than the acceptance of the new call  and hence of the current call  is due to the induction hypothesis .",
    "_ for the `` @xmath533 '' direction , _",
    "let there be an accepting run of @xmath511 .",
    "since the algorithm is in ` always ` mode , the acceptance can only take place in line 33 or in the recursive call in line 17 . if the run accepts in line 33 , the same arguments as in the base case apply . if the acceptance is via the recursive call , then let @xmath570 be the sequence of states guessed such that @xmath518 , and @xmath546 is the value of @xmath390 when the recursive call with @xmath500 takes place .",
    "due to the induction hypothesis , @xmath571 and , hence , there is an infinite structure @xmath545 extending @xmath35 beyond @xmath546 such that @xmath572 .",
    "furthermore , we can use the same argumentation as in the base case to show that , for each @xmath573 , @xmath574 .",
    "therefore , @xmath575 , which proves @xmath509 .",
    "[ claim : fgv2 ] for each @xmath576 , each @xmath257 , and each @xmath31 : @xmath577    _ for the `` @xmath517 '' direction , _",
    "suppose @xmath578 .",
    "then there exists a path @xmath35 in @xmath36 such that @xmath518 and @xmath579 .",
    "we describe an accepting run of @xmath502 .",
    "consider the first passage through the _ while _ loop with the following configuration .",
    "the programme counter has value @xmath562 , @xmath4 has value @xmath326 ( this value does not change in _ now _ mode ) , @xmath390 has value @xmath263 , and @xmath139 has value @xmath18 . since @xmath579 , there are four possible cases .",
    "the argumentation for them is very similar to that in the proof of claim [ claim : fgv1 ] .",
    "blub    @xmath580 , for some @xmath564 .    as in the proof of claim [ claim : fgv1 ]",
    ", the algorithm can guess the appropriate disjuncts in lines 35 , does not reject in line 20 and accepts ( it is in _ now _ mode ! ) in line 28 .",
    "@xmath581 , for some @xmath566 .    as in the proof of claim [ claim : fgv1 ]",
    ", there exists some @xmath3 with @xmath582 such that @xmath583 satisfies @xmath9 .",
    "the algorithm can proceed as in the previous case , but , in addition , it has to guess the correct value of @xmath3 and the sequence @xmath584 in lines 1015 .",
    "@xmath585 , for some maximal -subformula @xmath500 of @xmath18 that is _ not _ in the scope of some -operator .",
    "this means that @xmath501 is _ true _ everywhere on the path @xmath35 .",
    "hence , due to the induction hypothesis , @xmath586 has an accepting run . by appropriate guesses in line 4",
    ", the current call of the algorithm can reach that accepting recursive call in line 17 .",
    "@xmath585 , for some maximal -subformula @xmath500 of @xmath18 that _ is _ in the scope of some -operator .    by combining the arguments of cases 3 and 2",
    ", we can find an accepting run for this case .",
    "_ for the `` @xmath533 '' direction , _",
    "suppose there exists an accepting run of @xmath502 .",
    "since the algorithm is in ` now ` mode , the acceptance can only take place in line 28 or in the recursive call in line 17 . if the run accepts in line 28 , then there is some variable @xmath587 such that either @xmath564 and @xmath588 , or @xmath566 and the run guesses a path @xmath550 with @xmath518 and @xmath589 . in both cases ,",
    "each structure @xmath545 extending the sequence of states guessed so far , satisfies @xmath18 at @xmath263 .",
    "on the other hand , if the run accepts in the recursive call , we can argue as in the proof of claim [ claim : fgv1 ] .",
    "unfortunately , the above argumentation fails for because of the following considerations .",
    "the -algorithm in the previous proof relies on the fact that a satisfying path for @xmath590 , where @xmath139 is of the form , can be divided into a `` short '' initial part satisfying the disjunction of the atoms , and the remaining end path satisfying one of the @xmath493 at its initial state . when guessing the initial part , it suffices to separately guess each state and consult @xmath140 .",
    "if  were in our language , the disjuncts would be of the form @xmath591 and @xmath592 . not only would this make the guessing of the initial part more intricate .",
    "it would also require memory for processing each of the previously satisfied disjuncts @xmath591 .",
    "an adequate modification of  would require more than logarithmic space .",
    "we have shown -hardness for in theorem  [ theorem : mc(g , x;v ) np - h ] .",
    "[ theorem : mc(x;l ) nl - c ] let @xmath593 be a finite set of boolean functions such that @xmath594 then is -complete .",
    "* algorithm *    the lower bound follows from lemma  [ lemma : mc(f|g|x;. ) nl - h ] .    for the upper bound , let @xmath595 be a formula , @xmath257 a kripke structure , and @xmath31 a state .",
    "let @xmath23 denote the maximal nesting depth of -operators in @xmath18 .",
    "since for any @xmath77-ary boolean operator @xmath5 from @xmath593 , the formula @xmath259 is equivalent to @xmath260 , @xmath18 is equivalent to a formula @xmath596 of the form @xmath597 , where @xmath598 for each @xmath599 .",
    "it is not necessary to compute @xmath94 all at once , because it will be sufficient to calculate @xmath463 each time the variable @xmath600 is encountered in the algorithm  given in table  [ tab : xlalgo ] .",
    "it is easy to see that  returns @xmath601 if and only if @xmath18 is satisfiable . from the used variables ,",
    "it is clear that  runs in nondeterministic logarithmic space .     in the fragment with   as the only temporal operator ,   is without effect , since we can never leave the initial state .",
    "hence , any formula @xmath602 is satisfied at the initial state of any structure @xmath36 if and only if @xmath603 is .",
    "this leads to a straightforward logspace reduction from to : given a formula @xmath604 , successively replace every subformula @xmath602 by @xmath603 until all occurrences of ",
    "are eliminated .",
    "the resulting formula @xmath94 is initially satisfied in any structure @xmath36 iff @xmath18 is .",
    "now is the formula value problem , which has been shown to be solvable in logarithmic space in @xcite .",
    "thus we obtain the following result .    [",
    "theorem : mc(s;bf ) in l][theorem : mc(s;. ) in l ] let @xmath16 be a finite set of boolean functions",
    ". then @xmath605 .    in our classification of complexity , which is based on logspace reductions @xmath1 , a further analysis of ",
    "-fragments is not possible .",
    "however , a more detailed picture emerges if stricter reductions are considered , see ( * ? ? ?",
    "* chapter 2 ) .",
    "[ theorem : mc(s , f;v ) nl - c ] let @xmath449 be a finite set of boolean functions such that @xmath453 then is -complete .",
    "the lower bound follows from lemma  [ lemma : mc(f|g|x;. ) nl - h ] . for the upper bound",
    ", we will show that can be reduced to by disposing of the  -operator as follows .",
    "consider an arbitrary kripke structure @xmath36 and a path @xmath35 therein .",
    "then the following equivalences hold .",
    "statements and are standard properties and follow directly from the definition of satisfaction for  and @xmath162 .",
    "statement is simply due to the fact that there is no state in the past of @xmath606 . as for",
    ", we consider both directions separately .",
    "assume that @xmath607 .",
    "then there is some @xmath38 such that @xmath608 .",
    "this implies that there is some @xmath539 with @xmath609 and @xmath610 .",
    "hence , @xmath611 . for the other direction , let @xmath611 .",
    "then there is some @xmath38 such that @xmath612 .",
    "this implies @xmath608 .",
    "hence , @xmath607 .",
    "now consider an arbitrary formula @xmath613 .",
    "let @xmath94 be the formula obtained from @xmath18 by successively replacing the outermost ",
    "@xmath602 by @xmath603 until all occurrences of   are eliminated .",
    "this procedure can be performed in logarithmic space , and the result @xmath94 is in @xmath614 . due to ",
    ", for any path @xmath35 in any kripke structure @xmath36 , it holds that @xmath615 hence , the mapping @xmath616 is a logspace reduction from to .",
    "we have almost completely separated the model - checking problem for linear temporal logic with respect to arbitrary combinations of temporal and propositional operators into tractable and intractable cases .",
    "we have shown that all tractable mc problems are at most -complete or even easier to solve .",
    "this exhibits a surprisingly large gap in complexity between tractable and intractable cases .",
    "the only fragments that we have not been able to cover by our classification are those where only the binary -operator is allowed .",
    "however , it is not for the first time that this constellation has been difficult to handle , see @xcite . therefore , these fragments can justifiably be called ugly .",
    "the borderline between tractable and intractable fragments is somewhat diffuse among all sets of temporal operators without . on the one hand , this borderline is not determined by a single set of propositional operators ( which is the case for the satisfiability problem , see @xcite ) . on the other hand , the columns  and",
    "do not , as one might expect , behave dually .",
    "for instance , while is tractable , is not  although  and  are dual , and so are  and",
    ".    further work should find a way to handle the open  cases from this paper as well as from @xcite .",
    "in addition , the precise complexity of all hard fragments not in bold - face type in table [ tab : overview ] could be determined .",
    "furthermore , we find it a promising perspective to use our approach for obtaining a fine - grained analysis of the model - checking problem for more expressive logics , such as ctl , ctl * , and hybrid temporal logics .",
    "bcrv03    e.  bhler , n.  creignou , s.  reith , and h.  vollmer .",
    "playing with boolean blocks , part i : post s lattice with applications to complexity theory .",
    ", 34(4):3852 , 2003 .",
    "m.  bauland , e.  hemaspaandra , h.  schnoor , and i.  schnoor .",
    "generalized modal satisfiability . in b.",
    "durand and w.  thomas , editors , _ stacs _ , volume 3884 of _ lecture notes in computer science _ , pages 500511 .",
    "springer , 2006 .",
    "m.  bauland , t.  schneider , h.  schnoor , i.  schnoor , and h.  vollmer .",
    "the complexity of generalized satisfiability for linear temporal logic . in h.  seidl , editor , _ fossacs _ , volume 4423 of _ lecture notes in computer science _ ,",
    "pages 4862 .",
    "springer , 2007 .",
    "v.  dalmau . .",
    "phd thesis , department de llenguatges i sistemes informtica , universitat politcnica de catalunya , 2000 .",
    "h.  lewis .",
    "satisfiability problems for propositional calculi . , 13:4553 , 1979 .",
    "nancy  a. lynch .",
    "log space recognition and translation of parenthesis languages .",
    ", 24(4):583590 , 1977 .",
    "nicolas markey .",
    "past is for free : on the complexity of verifying linear temporal properties with past . , 40(6 - 7):431458 , 2004 .",
    "g.  nordh .",
    "a trichotomy in the complexity of propositional circumscription . in _ lpar _ ,",
    "volume 3452 of _ lecture notes in computer science _ , pages 257269 .",
    "springer verlag , 2005 .",
    "n.  pippenger . .",
    "cambridge university press , cambridge , 1997 .",
    "a.  pnueli .",
    "the temporal logic of programs . in _ focs _ , pages 4657 .",
    "ieee , 1977 .",
    "e.  post .",
    "the two - valued iterative systems of mathematical logic . , 5:1122 , 1941 .",
    "s.  reith . .",
    "phd thesis , fachbereich mathematik und informatik , universitt wrzburg , 2001 .",
    "s.  reith and h.  vollmer .",
    "optimal satisfiability for propositional calculi and constraint satisfaction problems . , 186(1):119 , 2003 .",
    "s.  reith and k.  w. wagner .",
    "the complexity of problems defined by boolean circuits . in _",
    "mfi 99_. world science publishing , 2005 .",
    "w.  j. savitch .",
    "maze recognizing automata and nondeterministic tape complexity .",
    ", 7:389403 , 1973 .",
    "a.  sistla and e.  clarke .",
    "the complexity of propositional linear temporal logics .",
    ", 32(3):733749 , 1985 .",
    "h.  schnoor . .",
    "phd thesis , university of hannover , 2007 .",
    "[ lem : existence_of_infinite_path_is_nl - hard ]      we reduce from the graph accessibility problem ( gap ) , which is defined as follows . given a directed graph @xmath394 and",
    "two nodes @xmath383 , is there a path in @xmath391 from @xmath263 to @xmath390 ?",
    "this problem is known to be -complete  @xcite .    for the reduction ,",
    "consider an arbitrary instance @xmath381 of gap , where @xmath394 and @xmath383 .",
    "let @xmath617 .",
    "we transform @xmath391 into a new graph @xmath618 that consists of @xmath3 `` layers '' each of which contains a copy of the nodes from @xmath619 .",
    "whenever there is an edge from node @xmath620 to node @xmath347 in @xmath391 , the new graph @xmath618 will have edges from each copy of @xmath620 to the copy of @xmath347 on the next layer .",
    "this destroys all cycles from @xmath391 .",
    "now we add an edge from each copy of @xmath390 to the first copy of @xmath263 .",
    "it is easy to see that this transformation is a logspace reduction .",
    "let the size of a graph be determined by the size of its adjacency matrix .",
    "hence @xmath391 has size @xmath624 , and @xmath618 is of size @xmath625 . apart from the representation of @xmath618 , the only space required by the described transformation",
    "is spent for four counters that take values between @xmath601 and @xmath3 . with their help , each bit of the new adjacency matrix is set according to the definition of @xmath626 , where only a look - up in the old adjacency matrix is required .",
    "[ claim : graph_problems ] for each directed graph @xmath394 and each pair of nodes @xmath383 , there exists a path in @xmath391 from @xmath263 to @xmath390 if and only if there exists an infinite path in @xmath618 starting at @xmath627 .",
    "`` @xmath517 '' .",
    "suppose there is a path in @xmath391 from @xmath263 to @xmath390 .",
    "we can assume that no node occurs more than once on this path , @xmath263 and @xmath390 included .",
    "hence there exist nodes @xmath628 with @xmath629 such that @xmath630 , @xmath631 , and for each @xmath632 , @xmath633 . due to its construction",
    ", @xmath618 has the cycle @xmath634 that contains @xmath627 .",
    "hence @xmath618 has an infinite path starting at @xmath627 .",
    "`` @xmath533 '' .",
    "suppose there is an infinite path @xmath35 in @xmath618 starting at @xmath627 .",
    "since @xmath618 is finite , some node must occur infinitely often on @xmath35 .",
    "this , together with the layer - wise construction of @xmath618 , implies that there are infinitely many nodes of layer 1 on @xmath35 . among layer-1 nodes",
    ", only @xmath627 has ingoing edges .",
    "hence @xmath627 must occur infinitely often on @xmath35 .",
    "now the path from some occurrence of @xmath627 to the next is a cycle , where the predecessor node of @xmath627 must be some @xmath635 .",
    "this implies that there is a path in @xmath618 from @xmath627 to @xmath635 . due to the construction of @xmath618 ,",
    "this corresponds to a path in @xmath391 from @xmath263 to @xmath390 ."
  ],
  "abstract_text": [
    "<S> in a seminal paper from 1985 , sistla and clarke showed that the model - checking problem for linear temporal logic ( ltl ) is either -complete or -complete , depending on the set of temporal operators used . </S>",
    "<S> if , in contrast , the set of propositional operators is restricted , the complexity may decrease . </S>",
    "<S> this paper systematically studies the model - checking problem for ltl formulae over restricted sets of propositional and temporal operators . for almost all combinations of temporal and propositional operators , we determine whether the model - checking problem is tractable ( in ) or intractable ( -hard ) . </S>",
    "<S> we then focus on the tractable cases , showing that they all are -complete or even logspace solvable . </S>",
    "<S> this leads to a surprising gap in complexity between tractable and intractable cases . </S>",
    "<S> it is worth noting that our analysis covers an infinite set of problems , since there are infinitely many sets of propositional operators . </S>"
  ]
}