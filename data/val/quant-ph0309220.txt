{
  "article_text": [
    "in the last two decades , polynomials of many varieties have been used quite successfully in complexity theory , both for upper and lower bounds .",
    "we study a variety here that is tailored to analyzing algorithms with _",
    "noisy input_.    [ [ robust - polynomials . ] ] robust polynomials .",
    "+ + + + + + + + + + + + + + + + + + +    a _ robust _ polynomial for a boolean function @xmath7 is a real multivariate polynomial @xmath8 such that for every @xmath9 and every @xmath10 if @xmath11 in both cases can be changed to any other positive constant less than 1/2 ) .",
    "the _ robust degree _ of @xmath1 is the smallest degree of a robust polynomial for @xmath1 ; note that we do not require robust polynomials to be multilinear .",
    "the motivation behind the definition of robust polynomials is twofold .",
    "first , it can be viewed as a strengthening ( restriction ) of the notion of approximating polynomials .",
    "an approximating polynomial for @xmath1 is a multivariate real polynomial @xmath12 that approximates @xmath1 within an additive term of @xmath13 for each boolean input .",
    "approximating polynomials for boolean functions are of interest in themselves and have been the object of study for quite a while .",
    "their minimal degree is tightly related to the decision tree complexity of @xmath1 .",
    "indeed , this `` polynomial method '' is one of the main tools for obtaining lower bounds on the number of queries in _ quantum _ algorithms .",
    "one difficulty , however , is that approximating polynomials do not directly compose : if @xmath14 is a boolean function with an approximating polynomial @xmath15 and @xmath16 is a boolean function with an approximating polynomial @xmath17 , then the polynomial on @xmath18 variables @xmath19 that is obtained by plugging in a copy of @xmath17 for each of the @xmath20 , is not necessarily an approximating polynomial for the composed function @xmath21 on @xmath18 variables .",
    "this difficulty is avoided with robust polynomials : if @xmath22 are robust for @xmath23 respectively , then their composition is a robust polynomial ( and thus also approximating ) for the composed function .",
    "a second motivation for robust polynomials is the study of quantum decision trees that can tolerate noise in their inputs .",
    "we show that a natural quantum analogue of classical fault - tolerant decision trees can be defined . as a result",
    ", it will follow that every such algorithm that uses @xmath24 queries to its input bits ( and hence every classical noisy decision tree algorithm as well ) implies the existence of a robust degree-@xmath25 polynomial for the function .",
    "this relates the robust degree to fault - tolerant quantum query algorithms in exactly the same way that approximating polynomials are related to bounded - error quantum query algorithms .",
    "surprisingly , our results imply robust quantum algorithms with a linear number of queries , as well as robust polynomials of linear degree , for _ any _ boolean function .",
    "this should be contrasted with the result of feige  et  al .  .",
    "they proved that for most boolean functions , an overhead factor of @xmath26 on the number of queries is needed in the noisy case compared to the non - noisy case . in particular , consider the parity function on @xmath0 variables .",
    "this function can be decided trivially by an @xmath0-query decision tree , and hence can be represented exactly by a real multilinear polynomial of degree @xmath0 ( which is just the single monomial containing all variables in the @xmath27 representation ) .",
    "feige  et  al .",
    "prove that in the noisy decision tree model any algorithm for parity needs @xmath28 queries .",
    "using standard amplification techniques , this yields an @xmath29-degree robust polynomial for parity .",
    "can one do better ?",
    "our results imply that there is a robust polynomial for parity of degree @xmath3 . however , we only have an indirect description of this polynomial by means of a quantum algorithm , and do not know of an explicit simple construction of such a polynomial .    [",
    "[ noisy - quantum - queries . ] ] noisy quantum queries .",
    "+ + + + + + + + + + + + + + + + + + + + + +    we now discuss in more detail the model of noisy decision trees in the quantum world .",
    "the notion of a `` noisy query '' in the quantum case is not as obvious and natural as in the classical case , because one application of a quantum query can address many different @xmath20 s in superposition .",
    "a first proposal would be that for each quantum query , each of the bits is flipped independently with probability @xmath30 .",
    "each such quantum query introduces a lot of randomness and the algorithm s state after the query is a mixed quantum state rather than a pure state .",
    "in fact , this model is a concrete ( and very destructive ) form of decoherence ; the effects of various forms of decoherence on oracle algorithms like grover s have been studied before , see e.g.,@xcite .",
    "a second model , which we will adopt here , is to assume that we have @xmath0 quantum procedures , @xmath31 , such that @xmath32 outputs @xmath20 with probability at least @xmath33 .",
    "such a _ coherent - noise model _ is not unreasonable .",
    "for instance , it could be the case that the input bits are actually computed for us by subroutines .",
    "such algorithms can always be made coherent by pushing measurements to the end , which means that we can apply and reverse them at will . to enable us to apply the @xmath32 s in superposition , we assume we have a black box that maps @xmath34 one application of this will count as one query .    a third model , which we will call the _ multiple - noisy - copies model _ , was studied by szegedy and chen  . here , instead of @xmath20 ,",
    "the algorithm can only query `` perturbed '' copies @xmath35 ,  , @xmath36 of @xmath20 .",
    "the @xmath37 are independent boolean random variables with @xmath38 \\ge 1 - \\epsilon$ ] for each @xmath39 and @xmath40 .",
    "in contrast to the first proposal , this model leaves the queries perfectly reversible , since the perturbed copies are fixed at the start of the algorithm and the same @xmath37 can be queried more than once .",
    "the assumption of this model is also stronger than the second model , since we can construct a 1-query @xmath32 that just outputs a superposition of all @xmath37 .",
    "if @xmath41 is sufficiently large , this @xmath32 will compute @xmath20 with high success probability , satisfying the assumption of the second model ( see section  [ subsec2models ] for details ) .",
    "[ [ robust - quantum - algorithms . ] ] robust quantum algorithms .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    assuming the second model of noisy queries and some fixed @xmath30 , we call a quantum algorithm _ robust _ if it computes @xmath1 on @xmath0 inputs with bounded error probability when the @xmath0 inputs are given by bounded - error algorithms @xmath31 , respectively .",
    "a first observation is that every @xmath24-query non - robust algorithm can be made robust at a multiplicative cost of @xmath42 . with @xmath43 queries , a majority gate , and an uncomputation step",
    ", we can construct a unitary @xmath44 that approximates an exact quantum query @xmath45 very well in the standard operator norm : @xmath46 . since errors add linearly in a quantum algorithm  , replacing @xmath47 by @xmath44 in a non - robust algorithm",
    "gives a robust algorithm with almost the same final state .",
    "in some cases better constructions are possible .",
    "for instance , a recent result by hyer  et  al .",
    "@xcite implies a quantum algorithm that robustly computes the @xmath0-bit or function with @xmath48 queries .",
    "this is only a constant factor worse than the noiseless case , which is grover s algorithm  @xcite .",
    "in fact , we do not know of any function where the robust quantum query complexity is more than a constant factor larger than the non - robust complexity .",
    "our main result about robust quantum algorithms ( made precise in theorem  [ thm : recoverinput ] ) is the following :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ there exists a quantum algorithm that outputs @xmath49 , with high probability , using @xmath3 invocations of the @xmath32 algorithms ( i.e.,queries ) . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    as already mentioned , this result implies that _ every _ @xmath0-bit function @xmath1 can be robustly quantum computed with @xmath3 queries .",
    "this contrasts with the classical @xmath50 lower bound for parity .",
    "it is quite interesting to note that quantum computers , which usually are more fragile than classical computers , are actually more robust in the case of computing parity in this model with noisy inputs .",
    "the result for parity can be extended to every symmetric function : for every such function , the optimal quantum algorithm can be made robust with only a constant factor overhead ( see section  [ subsecconsequences ] ) .",
    "our result has a direct bearing on the _ direct - sum problem _ , which is the question how the complexity of computing @xmath0 independent instances of a function scales with the complexity of one instance .",
    "one would expect that computing @xmath0 instances with bounded - error takes no more than @xmath0 times the complexity of one instance .",
    "however , since we want all @xmath0 instances to be computed correctly _ simultaneously _ with high probability , the only known general method in the classical world is to compute each instance with error probability reduced to @xmath51 .",
    "this costs another factor of @xmath52 .",
    "in fact , it follows from the @xmath50 bound for parity that this factor of @xmath53 is optimal if we can only run algorithms for individual instances in a black - box fashion .",
    "in contrast , our result implies that in the quantum world , the bounded - error complexity of @xmath0 instances is at most @xmath3 times the bounded - error complexity of one instance .",
    "this is a very general result .",
    "for example , it also applies to communication complexity  .",
    "if alice and bob have a bounded - error protocol for a distributed function @xmath1 , using @xmath54 bits ( or qubits ) of communication , then there is a bounded - error quantum protocol for @xmath0 instances of @xmath1 , using @xmath55 qubits of communication .",
    "the additive @xmath53 is because alice and bob need to communicate ( possibly in superposition ) the index of the instance that they are computing .",
    "in contrast , the best known general classical solution uses @xmath56 bits of communication .",
    "[ [ note - about - related - work . ] ] note about related work .",
    "+ + + + + + + + + + + + + + + + + + + + + + + +    in their manuscript  @xcite , iwama  et  al.study a similar but slightly weaker setting .",
    "there , the error probability for each input variable is _ exactly _ @xmath30 . if @xmath30 is known , then one can use a version of exact amplitude amplification to `` rotate off '' the error using @xmath57 queries and hence make the algorithm robust .",
    "if @xmath30 unknown , it can be estimated very well using quantum amplitude estimation , after which amplitude amplification can be used as if @xmath30 was known .",
    "iwama  et  al.derive from this that any quantum algorithm can be made robust ( in their model ) with only a constant factor overhead .",
    "their model has the disadvantage that it does not cover the subroutine - scenario , where each input bit @xmath20 is computed for us by an algorithm or subroutine @xmath32 whose error we can only upper bound .",
    "our model does not need the assumption that the error is the same for all input bits , and hence does not have this disadvantage .",
    "in this section we study robust polynomials of two different but essentially equivalent types .",
    "the first type arises from the multiple - noisy - copies model , the second type is what we discussed in the introduction .",
    "let @xmath58 .",
    "an _ @xmath59-perturbation _ of @xmath60 is a matrix @xmath61 of @xmath62 independent binary random variables @xmath37 such that @xmath63 \\ge 1 - \\epsilon$ ] for each @xmath64 .",
    "[ def : typeone ] a _",
    "type-1 @xmath59-robust polynomial _ for the boolean function @xmath65 is a real polynomial @xmath2 in @xmath66 variables @xmath37 ( with @xmath67 and @xmath64 ) so that for every @xmath68 and @xmath61 an @xmath69-perturbation of @xmath70 , we have @xmath71 <    1/3,\\ ] ] where the probability is taken over the distribution on the @xmath72 bits in @xmath61 .",
    "moreover , for every @xmath73 , we require @xmath74 .",
    "since @xmath75 for a bit @xmath37 , we can restrict attention to _ multilinear _ polynomials here .",
    "notice that the error parameter @xmath13 in our definition of type-1 polynomial is consistent with having _ expected _ error more than @xmath76 for some @xmath70 : it could be that @xmath77 with probability @xmath78 , and @xmath79 with probability @xmath13 , giving expected error @xmath78 .",
    "however , this is not a significant problem , as the next lemma shows that the error parameter @xmath13 can be reduced to any small @xmath80 at only a small multiplicative cost in the degree and the number of perturbations .",
    "it employs the following chernoff bound from  .",
    "let @xmath81 , @xmath82 , be mutually independent random variables with all @xmath83=0 $ ] and all @xmath84 .",
    "set @xmath85 .",
    "then @xmath86\\leq e^{-a^2/2k}$ ] .",
    "[ lem : typeoneboost ] consider any @xmath80 . if there is a _",
    "type-1 @xmath59-robust polynomial _",
    "@xmath2 for @xmath1 of degree @xmath87 , then there exists a type-1 @xmath88-robust polynomial @xmath12 for @xmath1 of degree @xmath89 and @xmath90 , such that for @xmath68 and @xmath61 an @xmath88-perturbation of @xmath70 , we have @xmath91 < \\delta.\\ ] ] moreover , for every @xmath92 we have @xmath93 $ ] .",
    "we first analyze the following single - variate `` amplification polynomial '' of degree @xmath94 : @xmath95 note that @xmath96 is exactly the probability that among @xmath94 coin flips with bias @xmath70 towards 1 , more than half come up 1 .",
    "since it s a probability , we have @xmath97 $ ] for all @xmath98 $ ] .",
    "moreover , applying the chernoff bound with @xmath81 being the outcome of the @xmath99th coin flip minus @xmath70 , and @xmath100 , we have @xmath101 $ ] for all @xmath102 $ ] . similarly @xmath103",
    "$ ] for @xmath104 $ ] . by `` stretching '' the domain a bit",
    ", we can turn this into a degree-@xmath94 polynomial @xmath105 such that @xmath101 $ ] for @xmath106 $ ] , @xmath97 $ ] for @xmath107 $ ] , and @xmath103 $ ] for @xmath108 $ ] .",
    "we use @xmath109 independent @xmath59-perturbations of @xmath70 , denoted @xmath110 , for some number @xmath109 to be determined later . for each perturbation",
    "@xmath111 it holds that @xmath112 < 1/3 $ ] . using the amplification polynomial @xmath105 with @xmath113 we can get the value of @xmath2 closer to @xmath1 : @xmath114 < 1/3 $ ] . note that the expected value of @xmath115 is now at most @xmath116 . now define an average polynomial @xmath117 .",
    "choosing @xmath118 , the chernoff bound ( with @xmath119 , and @xmath81 being the indicator random variable for the event that @xmath120 minus its expectation ) we have @xmath121 < \\delta.\\ ] ] finally we apply @xmath105 again , this time with degree @xmath122 , in order to get the value of @xmath123 @xmath124-close to the value @xmath5 : if we define @xmath125 then @xmath126 <",
    "\\delta.\\ ] ] the degree of @xmath12 is @xmath89 , and @xmath127 .",
    "the last property of the lemma is also easily seen .",
    "the second kind of robust polynomial is the following :    [ def : typetwo ] for a boolean function @xmath65 , we call @xmath12 a _ type-2 @xmath30-robust polynomial for @xmath1 _ if @xmath12 is a real polynomial in @xmath0 variables such that for every @xmath68 and every @xmath128^n$ ] we have @xmath129 if @xmath130 for all",
    "@xmath131 $ ] .",
    "if @xmath132 , then @xmath12 is called an _ approximating polynomial _ for @xmath1 .    note",
    "that we restrict the @xmath133 s to lie in the set @xmath134\\cup[1-\\epsilon,1]$ ] rather than the less restrictive @xmath135\\cup[1-\\epsilon,1+\\epsilon]$ ] .",
    "this facilitates later proofs , because it enables us to interpret the @xmath133 s as probabilities .",
    "however , with some extra work we could also use the less restrictive definition here . also note that a minimal - degree type-2 robust polynomial for @xmath1 need not be multilinear , in contrast to the type-1 variety .    for @xmath65 ,",
    "let @xmath136 denote the minimum degree of any type-1 @xmath137-robust polynomial for @xmath1 , let @xmath138 be the minimum degree of any type-2 @xmath13-robust polynomial for @xmath1 , and let @xmath139 be the minimum degree among all approximating polynomials for @xmath1",
    ".    strictly speaking , we should fix an explicit constant for the @xmath52 of the type-1 polynomial , but to simplify proofs we ll use the @xmath140 instead .",
    "we characterize the relation of type-1 and type-2 robust polynomials as follows :    [ thm : typeonetwoequiv ] for every type-2 @xmath30-robust polynomial of degree @xmath87 for @xmath1 there is a type-1 @xmath141(1/2-\\epsilon)^2))$]-robust polynomial of degree @xmath87 for @xmath1 .",
    "conversely , for every type-1 ( @xmath142-robust polynomial of degree @xmath87 for @xmath1 there is a type-2 @xmath30-robust polynomial of degree @xmath143 for @xmath1 .",
    "let @xmath2 be a type-2 @xmath30-robust polynomial of degree @xmath87 for @xmath1 .",
    "we choose @xmath144 .",
    "if each @xmath37 is wrong with probability @xmath145 , then the chernoff bound implies that the probability that the average @xmath146 is more than @xmath30 away from @xmath20 , is at most @xmath147 .",
    "then by the union bound , with probability at least @xmath78 we have @xmath148 for all @xmath149 $ ] simultaneously .",
    "hence the polynomial @xmath150 will be a type-1 @xmath151-robust polynomial of degree @xmath87 for @xmath1 .    for the other direction ,",
    "consider a type-1 @xmath152-robust polynomial of degree @xmath87 for @xmath1 .",
    "using lemma  [ lem : typeoneboost ] , we boost the approximation parameters to obtain a type-1 @xmath153-robust polynomial @xmath2 of degree @xmath143 , with @xmath154 , such that for any @xmath68 and @xmath88-perturbation @xmath61 of @xmath70 , @xmath155    < 1/9 $ ] . for @xmath156",
    "define the formal polynomial @xmath157 ( over the reals ) by replacing each appearance of @xmath37 in @xmath158 with @xmath133 . for @xmath159 with @xmath160 for all @xmath99 , let @xmath37 ( @xmath131 $ ] , @xmath161 $ ] ) be independent @xmath162 random variables , where @xmath163 =    z_i$ ] .",
    "then the polynomial @xmath157 that is defined above can be viewed as @xmath164 $ ] because @xmath165 = p ( { \\ensuremath{\\operatorname{e } } } [ y ] ) $ ] and @xmath163 = z_i$ ] .",
    "in particular , if for @xmath166 there exists @xmath68 with @xmath167 for all @xmath99 , then for any @xmath168 that is an @xmath59-perturbation of @xmath70 , we have @xmath164 $ ] ( here expectation is according to the distribution induced by @xmath61 ) .",
    "therefore @xmath169 has probability @xmath170 >",
    "8/9 $ ] and @xmath171 \\left ( f(x ) - p(v ) \\right )      \\right| + \\left| \\sum_{v \\notin v } \\pr[y = v ] \\left ( 1+\\frac19        \\right ) \\right|",
    "< \\frac13 \\enspace .\\ ] ] this means that @xmath157 is a type-2 @xmath30-robust polynomial for @xmath1 of degree @xmath172 .",
    "note , in all the above we have discussed total boolean functions .",
    "the definitions above make sense also for partial boolean functions ( or promise problems ) .",
    "the theorem as well as the next corollary are true also for such cases .",
    "[ cor : deg1deg2equiv ] @xmath173 for every boolean function @xmath65 .",
    "the well known `` polynomial method ''  @xcite allows us to make a connection between `` robust '' quantum algorithms and robust type-1 polynomials :    [ lem : functiontotype1poly ] let @xmath65 be a boolean function . let @xmath174 be a quantum algorithm that makes at most @xmath24 queries on inputs @xmath61 from @xmath175 , and let @xmath176 denote the binary random variable that is its output . if for every @xmath68 and @xmath61 an @xmath69-perturbation of @xmath70 , we have that @xmath177 \\ge 8/9 $ ] ( probability taken over the distribution on the @xmath72 bits in @xmath61 as well as over the algorithm ) , then there exists a degree-@xmath25 type-1 @xmath69-robust polynomial for @xmath1 .    by (",
    "* lemma  4.2 ) , @xmath174 induces a degree-@xmath25 multilinear polynomial @xmath2 on @xmath66 variables that gives the acceptance probability of @xmath174 on fixed input @xmath178 , i.e. , @xmath179 $ ] ( probability taken only over the algorithm ) . fix @xmath68 .",
    "suppose @xmath180 , then we want to show that @xmath181<1/3 $ ] . since @xmath182 \\ge 8/9 $ ]",
    ", we have @xmath183=\\pr_y[q(y)=1]\\leq 1/9 $ ] .",
    "hence markov s inequality implies @xmath181<1/3 $ ] and we are done .",
    "the case @xmath184 is similar .",
    "in this section we prove our main result , that we can recover an @xmath0-bit string @xmath70 using @xmath3 invocations of algorithms @xmath31 where @xmath32 computes @xmath20 with bounded error .",
    "let @xmath185 denote the hamming weight of a bit string @xmath70 .",
    "our main theorem says that with high probability we can find @xmath186 1-bits in the input @xmath70 ( if they are present ) using @xmath187 noisy queries .",
    "[ thm : recoverinput ] let @xmath58 .",
    "consider @xmath30-error algorithms @xmath188 , ",
    ", @xmath189 that compute the bits @xmath190 .",
    "for every @xmath186 , @xmath191 , there is a quantum algorithm that makes @xmath192 queries ( invocations of the @xmath32 ) and that outputs @xmath193 such that with probability at least 2/3    1 .   for all @xmath99 : @xmath194 2 .",
    "@xmath195 .",
    "in particular , with @xmath196 we obtain @xmath197 using @xmath3 queries .      for simplicity",
    "we assume that @xmath198 is fixed and that @xmath32 is a unitary transformation @xmath199 for some @xmath200 such that @xmath201 if @xmath202 and @xmath203 if @xmath204 ; @xmath205 and @xmath206 are arbitrary norm-1 quantum states .",
    "the _ output _ is the random variable obtained from measuring the first qubit .",
    "it equals @xmath20 with probability at least @xmath33 .",
    "it is standard that any quantum algorithm can be expressed in this form by postponing measurements ( i.e.,unitarily write the measurement in an auxiliary register without collapsing the state ) ; any classical randomized algorithm can be converted into this form by making it reversible and replacing random bits by states @xmath207 .",
    "we define the following notion of closeness :    for @xmath58 and algorithms @xmath208 , we say @xmath209 is _",
    "@xmath30-close _ to @xmath210 if @xmath211 \\ge 1-\\epsilon$ ] for all @xmath131 $ ]",
    ".    we sometimes modify our sequence of algorithms @xmath212 as follows . for an @xmath0-bit string @xmath213",
    ", we negate the answer of @xmath32 if @xmath214 , and denote the resulting sequence of @xmath0 algorithms by @xmath215 .",
    "note that @xmath215 is close to @xmath216 if and only if @xmath217 .",
    "in other words , by finding ones in @xmath215 , we find positions where @xmath213 differs from @xmath70 .",
    "in addition , for a set @xmath218 $ ] we use @xmath219 to denote the vector of algorithms @xmath220 , except that for all @xmath221 the @xmath99th algorithm always outputs 0 instead of running @xmath32 .",
    "also , for @xmath222 as above and @xmath223 we denote by @xmath224 the string that is identical to @xmath70 on indices in @xmath222 and is @xmath225 on indices in @xmath226 .",
    "our algorithm builds on a robust quantum search algorithm by hyer , mosca , and de  wolf  @xcite , which we call .",
    "this subroutine takes a vector @xmath227 of @xmath0 quantum algorithms and in the good case returns an index @xmath99 such that the `` high probability '' output of @xmath32 is @xmath228 .",
    "formally , the input / output relation of is stated in theorem [ thm : robustfind ] .",
    "[ thm : robustfind ] there is a procedure * robustfind(@xmath0 , @xmath209 , @xmath30 , @xmath229 , @xmath230 , @xmath124 ) * where @xmath231 , @xmath209 : @xmath0 quantum algorithms , @xmath232 + * output : * @xmath233 \\cup \\ { \\perp \\ } $ ] and with the following properties :    1 .",
    "if @xmath209 is @xmath30-close to @xmath68 and @xmath70 has hamming weight @xmath234 , then @xmath235 with probability @xmath236 2 .",
    "if @xmath209 is @xmath30-close to @xmath68 and if @xmath237 , then @xmath238 with probability @xmath239    * complexity : * @xmath240      before we formally prove theorem [ thm : recoverinput ] we explain the intuition and high level of our algorithm ( as defined by the pseudo code on page  ) and of the proof . clearly , for @xmath241 theorem [ thm : recoverinput ] is obvious as we can run @xmath186 times to recover @xmath186 indices @xmath99 such that @xmath238 with @xmath242 queries .",
    "therefore all considerations below will be for @xmath243 for some @xmath244 that is independent of @xmath0 and will be specified later .",
    "an important feature of the robust quantum search is that it can be used to verify a purported solution @xmath245 by running on @xmath246 to find differences with the real input @xmath70 .",
    "[ proc : allinputs ]    @xmath247 , @xmath209 : @xmath0 algorithms , @xmath248    @xmath249    @xmath250 $ ] _ that contains at least _ @xmath251 _ and at most _",
    "@xmath252 @xmath228 s _ of the input_. [ alg : begin : initialguess ] @xmath253 @xmath254 [ alg : end : initialguess ]    @xmath255 @xmath256 $ ]    * part 2 , aim : * _ correctly find all but @xmath257 @xmath228s_.    @xmath258 @xmath259 [ alg : begin : samplebad ] @xmath260 @xmath261 [ alg : bkl]@xmath262 @xmath254 [ alg : end : samplebad ]    [ alg : begin : findallbad ] @xmath263 @xmath254 [ alg : end : findallbad ] @xmath264    let @xmath70 be the unique assignment such that @xmath265 is @xmath30-close to @xmath70 . assume first that the hamming weight is @xmath266 . our idea is to apply repeatedly for about @xmath252 times ( with threshold , say , @xmath267 ) and error probability @xmath268 .",
    "we expect that for at least a @xmath269-fraction of the calls , will return an index @xmath99 such that @xmath202 , and expect at most a @xmath270-fraction of wrong indices .",
    "the first problem to note is that might return the same ( correct ) index over and over again .",
    "this is easily resolved as follows : we set @xmath271 to be @xmath272 for every index @xmath99 that we obtained from and @xmath225 everywhere else , and call with @xmath273 rather than with @xmath265 .",
    "this means that the @xmath228 s that are to be reported by are in @xmath274 which is supported on the erroneous indices of @xmath264 , namely , on those indices that are either @xmath228 in @xmath264 but are @xmath225 in @xmath70 ( false positive ) and those indices that are @xmath225 on @xmath264 while they are @xmath228 on @xmath70 ( false negative ) .    done this , we expect about @xmath275 errors of both kinds ( false positive and false negative ) in the @xmath252 calls to , which should result in @xmath264 being quite close to @xmath70 .",
    "we then call @xmath276 times hoping to correct some of the errors while not introducing too many new errors",
    ". this would be reasonable as we call in this second phase half the times we call it in the first phase .",
    "thus we expect to have half the number of new errors , while good chance of correcting many old errors ( as they are @xmath228 in @xmath274 and hence is expected to report a @xmath269-fraction of them ) .",
    "we keep doing this until the number of expected errors is smaller than @xmath277 . at this point",
    "we can afford to run for @xmath277 times , with error probability as low as @xmath278 .",
    "this finds all remaining errors with high probability .",
    "indeed this is the structure of part 2 and part 3 of our algorithm .",
    "however , the idea above fails to work when @xmath279 . to see",
    "the problem assume that @xmath280 while @xmath281 . then , after the first round above , @xmath264 will be supported on about @xmath282 indices , out of which about @xmath283 might be false positives",
    ". however , in every next call to , the procedure has about @xmath284 false negative indices to report back - those that are @xmath228 s in @xmath70 but still @xmath225 in @xmath264 .",
    "thus , even if all the next @xmath285 calls return a correct such index , we still might be left with the same @xmath283 false positive errors that are introduced in the first round .",
    "note that if @xmath286 , which is the case when the algorithm is applied to find all inputs , this last discussion is of no concern .",
    "however , for relatively small @xmath186 ( which will be needed for some applications , e.g. , theorem  [ thm : symmetric ] ) we need to introduce a first part to the algorithm .",
    "this part is only meant to find a subset @xmath287 $ ] such that @xmath288 .",
    "once this is done , we can use @xmath289 instead of @xmath70 in the description above , which will now work for every input .",
    "we now prove that the success probability of the algorithm is at least @xmath78 .",
    "[ [ success - probability . ] ] success probability .",
    "+ + + + + + + + + + + + + + + + + + + +    the algorithm is composed of three parts .",
    "we first prove that after part  1 , that is , prior to line  9 , we have @xmath290 with probability @xmath291 .    indeed ,",
    "assume first that just prior to the execution of line  7 we have @xmath292 .",
    "then the upper bound on @xmath293 is trivial . for the lower bound assume ( by way of contradiction ) that @xmath294 .",
    "then we can have @xmath292 only if at least @xmath295 wrong indices have been reported by .",
    "however , as we call with @xmath296 we expect at most @xmath275 errors . thus by the chernoff bound we have @xmath297 with probability @xmath291 .",
    "if , on the other hand , we reach line  7 with @xmath298 then @xmath222 is set to be @xmath299 $ ] , for which the lower bound on @xmath293 certainly holds . for the upper bound assume that @xmath300 .",
    "then to have @xmath298 at line  7 means that at least @xmath301 errors occurred in the @xmath252 calls for ( an error here is whenever returns either @xmath302 or a false negative index ; the @xmath303 term comes from the threshold @xmath304 ) .",
    "however , the error probability in this case is at most @xmath270 ( as we call with @xmath305 ) .",
    "thus we expect at most @xmath306 errors .",
    "again by chernoff we are done .",
    "accordingly , we may assume that with probability @xmath307 the @xmath222 we have at line  9 is such that @xmath290 .",
    "in part  2 of the algorithm we want to find _ correctly _ most of the @xmath228 s in @xmath289 .",
    "we maintain @xmath264 as our current estimate of @xmath289 .",
    "initially @xmath308 .",
    "denote by @xmath309 the event that @xmath310 at the end of the @xmath94th run of the loop in line  10 ; @xmath311 denotes the complementary event ( the negation of @xmath312 ) .",
    "we prove inductively that @xmath313   = e^{-\\omega(t_k)}$ ] .",
    "this together with an assertion that @xmath314   =   e^{-\\omega(t)}$ ] will imply that at the end of part  2 , @xmath315 with probability at least @xmath316 , assuming that @xmath186 is large enough ( such that @xmath317 ) .    indeed , let us examine the situation during the first round , namely for @xmath318 .",
    "we call in the first round for @xmath319 times with threshold @xmath320",
    ". thus , as long as @xmath321 happens , each call to gives an @xmath131 $ ] with probability at least @xmath322 .",
    "moreover , we expect at most a @xmath268 fraction of errors in the reported indices",
    ". assume first that at the beginning of the first round @xmath323 and let @xmath324 . then after the first @xmath325 calls to we expect at least @xmath269 fraction of correct indices .",
    "thus with probability @xmath326 we will get less than @xmath327 correct indices .",
    "however , if we do get at least @xmath328 correct indices after those @xmath325 calls we get an @xmath264 for which @xmath329 . now , assuming this happens , then @xmath330 can happen at the end of the first round only if during the rest of the @xmath331 remaining calls at least @xmath332 incorrect indices have been made . as the probability for an incorrect index",
    "is bounded by @xmath268 we expect only at most @xmath333 errors .",
    "thus , by chernoff @xmath332 errors will occur with probability @xmath326 .",
    "if , however , at the beginning of the first round @xmath334 then by a similar argument @xmath330 can happen at the end of the first round only if during the @xmath252 calls to at least @xmath335 incorrect indices have been made .",
    "again by chernoff this will happen with probability @xmath336 .",
    "this concludes the proof that @xmath337 = e^{-\\omega ( t)}$ ] .",
    "we now inductively prove that @xmath338 \\leq e^{-\\omega(t_k)}$ ] .",
    "indeed , assume that @xmath339 happens , namely that just prior to the beginning of the @xmath94th round we have @xmath340 .",
    "in round @xmath94 we call with threshold @xmath341 ; hence , as long as @xmath342 , we expect to return an index @xmath131\\cap s$ ] with probability at least @xmath322 .",
    "moreover , every time it returns a correct index ( which occurs with probability at least @xmath322 ) it is a @xmath228 in @xmath343 hence reduces the weight of symmetric difference ( the total number of errors ) by @xmath228 .",
    "suppose first that prior to round @xmath94 , @xmath344 .",
    "then , for @xmath311 to happen at the end of round @xmath94 , would need to return at least @xmath345 wrong indices , namely @xmath131 \\cap s$ ] such that @xmath346 ( returning a @xmath347 here does not count as a false index ) .",
    "however , as the probability of a wrong index is at most @xmath268 and is called @xmath348 times , then , by chernoff , the probability of @xmath311 is @xmath349 .",
    "assume now that @xmath350 at the beginning of round @xmath94 .",
    "recall also that by the assumption that @xmath339 occurs , we have @xmath351 at the beginning of the @xmath94th round .",
    "consider the first @xmath352 calls for . in each of those calls",
    "@xmath353 , hence with probability @xmath322 every such call returns an index @xmath131 \\cap s$ ] which is then a correct index with probability @xmath322 .",
    "thus we expect that at least @xmath354 correct indices will be returned in the first @xmath325 calls . by chernoff , the probability that the number of correctly returned indices in those @xmath325 calls is less than @xmath355 is @xmath349 ( as @xmath356 ) .",
    "but if the number of correctly returned indices is at least @xmath355 , then after the first @xmath325 calls of , @xmath357 .",
    "thus , at this point we are still left with @xmath358 calls to which will result in @xmath311 only if at least @xmath359 wrong indices will be returned .",
    "this again will happen with probability @xmath349 .",
    "we conclude that in all cases @xmath360 = e^{-\\omega(t_k)}$ ] .",
    "note that @xmath361 .",
    "thus if we choose @xmath362 such that for every @xmath94 the probability @xmath360 = e^{-\\omega(t_k ) } < 1/(10t)$ ] we get that @xmath363 < 1/10 $ ] for @xmath364 after the end of part  2 . hence , with probability at least @xmath365",
    ", we have @xmath366 bad indices at the end of the ` for ` loop in lines  [ alg : begin : samplebad][alg : end : samplebad ] .    finally , in part  3 we find ( with probability close to 1 ) all remaining wrong indices by making the individual error probability in so small that we can use the union bound",
    ": we determine each of the remaining bad indices with error probability @xmath367 .",
    "this implies an overall success probability of at least @xmath368 .",
    "[ [ complexity . ] ] complexity .",
    "+ + + + + + + + + + +    clearly the complexity is determined by parts  2 and  3 of the algorithm .",
    "we bound the number of queries to @xmath1 in lines  1117 as follows : @xmath369 the number of queries in lines  1821 is bounded by @xmath370 therefore , the total query complexity of is @xmath192 .",
    "here we state a few corollaries of theorem  [ thm : recoverinput ] . first ,",
    "once we have recovered the input @xmath70 we can compute any function of @xmath70 without further queries , hence    [ cor : quantumrobustatmostnqueries ] for every @xmath7 , there is a robust quantum algorithm that computes @xmath1 using @xmath3 queries .    in particular , parity can be robustly quantum computed with @xmath3 queries while it takes @xmath50 queries classically  .",
    "second , in the context of the direct - sum problem , the complexity of quantum computing a vector of instances of a function scales linearly with the complexity of one instance .",
    "if there exists a @xmath24-query bounded - error quantum algorithm for @xmath1 , then there is an @xmath371-query bounded - error quantum algorithm for @xmath0 independent instances of @xmath1 .",
    "as mentioned , the best classical upper bound has an additional factor of @xmath53 , and this is optimal in a classical black - box setting .",
    "thirdly , all _ symmetric _ functions can be computed robustly on a quantum computer with the same asymptotic complexity as non - robustly .",
    "a function is symmetric if its value only depends on the hamming weight of the input .",
    "let @xmath372 changes value if the hamming weight of the input changes from @xmath94 to @xmath373 .",
    "beals  et  al .",
    "* theorem  4.10 ) exhibited a bounded - error quantum algorithm for @xmath1 using @xmath374 quantum queries , which is optimal .",
    "we show that this upper bound remains valid also for _ robust _ algorithms .",
    "[ thm : symmetric ] for every symmetric function @xmath1 , there is a robust quantum algorithm that computes @xmath1 using @xmath374 quantum queries .",
    "note that @xmath1 is constant when the hamming weight of its input lies in the middle interval @xmath375 $ ] .",
    "using two applications of theorem  [ thm : recoverinput ] with sufficiently small error probability , we robustly search for @xmath376 ones and @xmath377 zeros in the input .",
    "if both of these searches succeeded ( i.e.,found the required zeros and ones ) , then we know that our input lies in the middle interval . if the search for zeros failed ( i.e.,ended with fewer zeros ) then we know _ all _ zeros and hence the whole input @xmath70 .",
    "similarly , if the search for ones failed then we know @xmath70 . either way , we can output @xmath5 .      as mentioned in the introduction",
    ", the assumption that we have a bounded - error algorithm @xmath32 for each of the input bits @xmath20 also covers the model of   where we have a sequence @xmath378 of noisy copies of @xmath20 . these we can query by means of a mapping @xmath379 here we spell out this connection in some more detail .",
    "first , by a chernoff bound , choosing @xmath380 implies that the average @xmath381 is close to @xmath20 with very high probability : @xmath382\\leq \\frac{1}{100n}.\\ ] ] by the union bound , with probability @xmath322 this closeness will hold for all @xmath149 $ ] simultaneously . assuming this is the case , we implement the following unitary mapping using one query : @xmath383 measuring the last qubit of the resulting state gives @xmath20 with probability at least @xmath384 .",
    "hence , we can run our algorithm from section  [ sec : recoverinput ] and recover @xmath70 using @xmath3 queries to the @xmath37 .",
    "similarly , all consequences mentioned in section  [ subsecconsequences ] hold for this multiple - noisy - copies model as well .",
    "the next theorem follows immediately from earlier results .",
    "@xmath385 for every @xmath7 .    by corollary  [ cor : quantumrobustatmostnqueries ] and the discussion in section  [ subsec2models ]",
    ", @xmath1 has an @xmath3-query robust quantum algorithm in the multiple - noisy - copies model that operates on @xmath52 copies . by lemma  [ lem : functiontotype1poly ]",
    "this induces a type-1 robust polynomial for @xmath1 of degree @xmath3 . and",
    "finally , by corollary  [ cor : deg1deg2equiv ] there also exists a degree-@xmath3 type-2 robust polynomial for @xmath1 .    in particular , this shows that for functions with approximate degree @xmath386 we can make the approximating polynomial robust at only constant factor overhead in the degree .",
    "this case includes explicit functions like parity and majority , but also random ( hence almost all ) functions .",
    "it is open whether approximating polynomials can _ always _ be made robust at only a constant overhead in the degree .",
    "the best we can do is show that a non - robust degree-@xmath87 approximating polynomial can be made robust at a cost of a factor @xmath387 .",
    "our proof makes use of the well known notion of _ certificate complexity_.    an assignment @xmath388 of values to some subset @xmath389 $ ] of the @xmath0 variables is _ consistent _ with @xmath390 if @xmath391 for all @xmath392 . for @xmath393 , a _",
    "@xmath394-certificate _ for @xmath1 is an assignment @xmath395 such that @xmath396 whenever @xmath70 is consistent with @xmath395 .",
    "the _ size _ of @xmath395 is @xmath397 , the cardinality of @xmath222 .",
    "the _ certificate complexity @xmath398 of @xmath1 on @xmath70 _ is the size of a smallest @xmath5-certificate that is consistent with @xmath70 .",
    "the _ certificate complexity _ of @xmath1 is @xmath399 .",
    "let @xmath2 be an @xmath30-approximating polynomial for @xmath7 , and @xmath400 be the certificate complexity of @xmath1 .",
    "if @xmath390 and @xmath401^n$ ] satisfy @xmath402 for all @xmath149 $ ] , then @xmath403 .",
    "consider a certificate @xmath395 for @xmath70 of size @xmath54 .",
    "we will use @xmath404 and @xmath405 to denote the parts of @xmath70 corresponding to @xmath395 and to its complement , respectively , and write @xmath406 . if @xmath407 is chosen according to the @xmath166-distribution ( @xmath408 with probability @xmath133 ) , then @xmath409=      \\sum_{y^c y^{\\overline c } } \\pr [ y^c ] \\pr [ y^{\\overline c } ]       p(y^cy^{\\overline{c } } )      =      \\sum_{y^{\\overline{c}}}\\pr[y^{\\overline{c}}]\\cdot      { \\ensuremath{\\operatorname{e}}}_{y^c}[p(y^cy^{\\overline{c}})].\\ ] ] now consider the expectation @xmath410 $ ] , where @xmath411 is fixed , while the @xmath412-bits are still chosen according to the @xmath166-distribution . consider the @xmath54-variate polynomial obtained from @xmath2 by fixing the bits in @xmath413 .",
    "since the `` error '' in the @xmath414-variables is at most @xmath415 , we have @xmath416\\geq ( 1 - 1/(10c))^c\\geq 9/10 $ ] . if @xmath417 , then the difference between @xmath418 and @xmath419 is at most @xmath420 , so @xmath421-p(x^cy^{\\overline{c}})|      \\leq ( 1 + 2\\epsilon)/10.\\ ] ] but @xmath422 , because the input @xmath423 is consistent with the same certificate as @xmath70 .",
    "hence @xmath424-f(x)| & \\leq & |{\\ensuremath{\\operatorname{e}}}_{y^c}[p(y^cy^{\\overline{c}})]-p(x^cy^{\\overline{c}})|+     |p(x^cy^{\\overline{c}})-f(x)|\\\\     & \\leq & ( 1 + 2\\epsilon)/10+\\epsilon=1/10 + 6\\epsilon/5 ,      \\end{aligned}\\ ] ] and also @xmath403 .",
    "this lemma implies that we can make a non - robust approximating polynomial robust at the cost of a factor of @xmath425 in the degree : replace each variable by an @xmath425-degree amplification polynomial as used in the proof of lemma  [ lem : typeoneboost ] . since it is known that @xmath426 and @xmath139 are polynomially related ( @xmath427 , see  ) , we obtain :    @xmath428 .",
    "we mention some open problems . first , in contrast to the classical case ( parity ) we do not know of any function where making a quantum algorithm robust costs more than a constant factor .",
    "such a constant overhead suffices in the case of symmetric functions and functions whose approximate degree is @xmath429 .",
    "it is conceivable that quantum algorithms ( and polynomials ) can _ always _ be made robust at a constant factor overhead . proving or disproving this would be very interesting .",
    "second , we are not aware of a direct `` closed form '' or other natural way to describe a robust degree-@xmath0 polynomial for the parity of @xmath0 bits , but can only infer its existence from the existence of a robust quantum algorithm . given the simplicity of the non - robust representing polynomial for parity",
    ", one would hope for a simple closed form for robust polynomials for parity as well .",
    "finally , we have chosen our model of a noisy query such that we can coherently make a query and reverse it .",
    "it is not clear to what extent non - robust quantum algorithms can be made resilient against decohering queries , since the usual transformations to achieve fault - tolerant quantum computation do not immediately apply to the query gate , which acts on a non - constant number of quantum bits simultaneously .",
    "we thank peter hyer for inspiring initial discussions that led to our main result , and michele mosca for sending us a version of @xcite .",
    "oded regev pointed out that when recovering all input bits , the quantum - search subroutine does not need to be robust . thanks to the anonymous tocs referees for many helpful comments .",
    "p.  hyer , m.  mosca , and r.  de wolf .",
    "quantum search on bounded - error inputs . in _ proceedings of 30th international colloquium on automata , languages and programming ( icalp03 ) _ , volume 2719 of _ lecture notes in computer science _ , pages 291299 .",
    "springer , 2003 .",
    "quant - ph/0304052 ."
  ],
  "abstract_text": [
    "<S> we define and study the complexity of _ robust _ polynomials for boolean functions and the related fault - tolerant quantum decision trees , where input bits are perturbed by noise . </S>",
    "<S> we compare several different possible definitions . </S>",
    "<S> our main results are    * for every @xmath0-bit boolean function @xmath1 there is an @xmath0-variate polynomial @xmath2 of degree @xmath3 that _ robustly _ approximates it , in the sense that @xmath4 remains close to @xmath5 if we slightly vary each of the @xmath0 inputs of the polynomial . </S>",
    "<S> * there is an @xmath3-query quantum algorithm that _ robustly _ recovers @xmath0 noisy input bits . </S>",
    "<S> hence every @xmath0-bit function can be quantum computed with @xmath3 queries in the presence of noise . </S>",
    "<S> this contrasts with the classical model of feige  et  al . , where functions such as parity need @xmath6 queries .    </S>",
    "<S> we give several extensions and applications of these results . </S>"
  ]
}