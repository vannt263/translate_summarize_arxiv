{
  "article_text": [
    "recent advances in health and life sciences have led to generation of a large amount of biomedical data , represented in various biomedical databases or ontologies .",
    "that these databases and ontologies are represented in different formats and constructed / maintained independently from each other at different locations , have brought about many challenges for answering complex biomedical queries that require integration of knowledge represented in these ontologies and databases .",
    "one of the challenges for the users is to be able to represent such a biomedical query in a natural language , and get its answers in an understandable form .",
    "another challenge is to extract relevant knowledge from different knowledge resources , and integrate them appropriately using also definitions , such as , chains of gene - gene interactions , cliques of genes based on gene - gene relations , or similarity / diversity of genes / drugs .",
    "furthermore , once an answer is found for a complex query , the experts may need further explanations about the answer .",
    "table  [ tab : queries ] displays a list of complex biomedical queries that are important from the point of view of drug discovery . in the queries , drug - drug interactions present negative interactions among drugs , and gene - gene interactions present both negative and positive interactions among genes .",
    "consider , for instance the query  q6 .",
    "new molecule synthesis by changing substitutes of parent compound may lead to different biochemical and physiological effects ; and each trial may lead to different indications .",
    "such studies are important for fast inventions of new molecules .",
    "for example , while developing the drug lovastatin ( a member of the drug class of hmg - coa reductase inhibitors , used for lowering cholesterol ) from _ aspergillus terreus _",
    "( a sort of fungus ) in 1979 , scientists at merck derived a new molecule named simvastatin that also belongs to the same drug category ( a hypolipidemic drug used to control elevated cholesterol ) targeting the same gene .",
    "therefore , identifying genes targeted by a group of drugs automatically by means of queries like q6 may be useful for experts .",
    "once an answer to a query is found , the experts may ask for an explanation to have a better understanding . for instance , an answer for the query  q3 in table  [ tab : queries ] is `` adrb1 '' .",
    "a shortest explanation for this answer is as follows :    * the drug epinephrine targets the gene adrb1 according to .",
    "+ the gene  dlg4 interacts with the gene adrb1 according to .",
    "an answer for the query  q8 is `` cask '' .",
    "a shortest explanation for this answer is as follows :    the distance of the gene cask from the start gene is 2 .",
    "the gene cask interacts with the gene dlg4 according to .",
    "the distance of the gene dlg4 from the start gene is 1 .",
    "the gene dlg4 interacts with the gene adrb1 according to .",
    "adrb1 is the start gene .",
    "( statements with more indentations provide explanations for statements with less indentations . )    to address the first two challenges described above ( i.e. , representing complex queries in natural language and finding answers to queries efficiently ) , novel methods and a software system , called  @xcite ( figure  [ fig : bqasp ] ) , have been developed using answer set programming ( asp )  @xcite :    * erdem and yeniterzi  @xcite developed a controlled natural language , , for expressing biomedical queries related to drug discovery .",
    "for instance , queries q1q10 in table  [ tab : queries ] are in this language .",
    "recently , this language has been extended ( called ) to cover queries q11q13",
    "some algorithms have been introduced to translate a given query in  ( resp . ) to a program in asp as well .",
    "* bodenreider et al .",
    "@xcite introduced methods to extract biomedical information from various knowledge resources and integrate them by a rule layer .",
    "this rule layer not only integrates those knowledge resources but also provides definitions of auxiliary concepts . *",
    "erdem et al .",
    "@xcite have introduced an algorithm for query answering by identifying the relevant parts of the rule layer and the knowledge resources with respect to a given query .",
    "the details of representing biomedical queries in natural language and answering them using asp are explained in a companion article .",
    "the focus of this article is the last challenge : generating explanations for biomedical queries .",
    "most of the existing biomedical querying systems ( e.g. , web services built over the available knowledge resources ) support keyword search but not complex queries like the queries in table  [ tab : queries ] .",
    "none of the existing systems can provide informative explanations about the answers , but point to related web pages of the knowledge resources available online .",
    "the contributions of this article can be summarized as follows .",
    "* we have formally defined `` explanations '' in asp , utilizing properties of programs and graphs .",
    "we have also defined variations of explanations , such as `` shortest explanations '' and `` @xmath0 different explanations '' .",
    "* we have introduced novel generic algorithms to generate explanations for biomedical queries .",
    "these algorithms can compute shortest or @xmath0 different explanations .",
    "we have analyzed the termination , soundness , and complexity of those algorithms .",
    "* we have developed a computational tool , called , that implements these explanation generation algorithms .",
    "* we have showed the applicability of our methods to generate explanations for answers of complex biomedical queries related to drug discovery .",
    "* we have embedded  into  so that the experts can obtain explanations regarding the answers of biomedical queries , in a natural language .",
    "the rest of the article is organized as follows . in section  [ sec : asp ] , we provide a summary of answer set programming .",
    "next , in section  [ sec : query ] , we give an overview of , in particular , the earlier work done on answering biomedical queries in asp . then ,",
    "in sections  [ sec : exp][sec : kdiff ] , we provide some definitions and algorithms related to generating shortest or @xmath0 different explanations for an answer , also in asp .",
    "next , section  [ sec : expex ] illustrates the usefulness of these algorithms on some complex queries over the biomedical knowledge resources  @xcite ,  @xcite ,  @xcite ,  @xcite ,  @xcite ,  @xcite and . in sections  [ sec : expnl ] and",
    "[ sec : expimp ] , we discuss how to present explanations to the user in a natural language , and embedding of these algorithms in . in section  [ sec : related ] , we provide a detailed analysis of the related work on `` justifications ''  @xcite in comparison to explanations ; and in section  [ sec : relatedwork ] , we briefly discuss other related work .",
    "we conclude in section  [ sec : conclusion ] by summarizing our contributions and pointing out some possible future work .",
    "proofs are provided in the online appendix of the paper .",
    "answer set programming ( asp )  @xcite is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge - intensive problems .",
    "the idea is to represent a problem as a `` program '' whose models ( called `` answer sets ''  @xcite ) correspond to the solutions .",
    "the answer sets for the given program can then be computed by special implemented systems called answer set solvers .",
    "asp has a high - level representation language that allows recursive definitions , aggregates , weight constraints , optimization statements , and default negation .",
    "asp also provides efficient solvers , such as  @xcite . due to the continuous improvement of the asp solvers and highly expressive representation language of asp which is supported by a strong theoretical background that results from a years of intensive research ,",
    "asp has been applied fruitfully to a wide range of areas . here",
    "are , for instance , three applications of asp used in industry :    * _ decision support systems _ : an asp - based system was developed to help flight controllers of space shuttle solve some planning and diagnostic tasks  @xcite ( used by united space alliance ) . * _ automated product configuration _ : a web - based commercial system uses an asp - based product configuration technology  @xcite ( used by variantum oy ) . * _ workforce management _ : an asp - based system is developed to build teams of employees to handle incoming ships by taking into account a variety of requirements , e.g. , skills , fairness , regulations  @xcite ( used by gioia tauro seaport ) .",
    "let us briefly explain the syntax and semantics of asp programs and describe how a computational problem can be solved in asp .",
    "[ [ syntax ] ] syntax + + + + + +    the input language of asp programs are composed of three sets namely _ constant symbols _ , _ predicate symbols _ , and _",
    "variable symbols _ where intersection of constant symbols and variable symbols is empty .",
    "the basic elements of the asp programs are _",
    "an atom @xmath1 is composed of a predicate symbol @xmath2 and _ terms _ @xmath3 where each @xmath4 ( @xmath5 ) is either a constant or a variable .",
    "literal _ is either an atom  @xmath1 or its negated form @xmath6 .",
    "an asp program is a finite set of _ rules _ of the form : @xmath7 where @xmath8 and each @xmath9 is an atom ; whereas , @xmath10 is an atom or @xmath11 .    for a rule @xmath12 of the form",
    "( [ eq_rule ] ) , @xmath10 is called the _",
    "head _ of the rule and denoted by @xmath13 .",
    "the conjunction of the literals @xmath14 is called the _ body _ of @xmath12 .",
    "the set @xmath15 of atoms ( called the positive part of the body ) is denoted by  @xmath16 , and the set @xmath17 of atoms ( called the negative part of the body ) is denoted by  @xmath18 , and all the atoms in the body are denoted by @xmath19 .",
    "we say that a rule @xmath12 is a _ fact _",
    "if @xmath20 , and we usually omit the @xmath21 sign . furthermore , we say that a rule @xmath12 is a _ constraint _ if the head of @xmath12 is @xmath11 , and we usually omit the @xmath11 sign .    [ [ semantics - answer - sets ] ] semantics ( answer sets ) + + + + + + + + + + + + + + + + + + + + + + +    answer sets of a program are defined over _",
    "ground programs_. we call an atom , rule , or program _ ground _ , if it does not contain any variables .",
    "given a program  @xmath22 , the set @xmath23 represents all the constants in @xmath22 , and the set @xmath24 represents all the ground atoms that can be constructed from atoms in @xmath22 with constants in @xmath25 .",
    "also , @xmath26 denotes the set of all the ground rules which are obtained by substituting all variables in rules with the set of all possible constants in @xmath25 .    a subset @xmath27 of @xmath28 is called an _ interpretation _ for @xmath22 .",
    "a ground atom @xmath2 is true with respect to an interpretation @xmath27 if @xmath29 ; otherwise , it is false .",
    "similarly , a set @xmath30 of atoms is true ( resp . , false ) with respect to @xmath27 if each atom @xmath31 is true ( resp . ,",
    "false ) with respect to  @xmath27 .",
    "an interpretation @xmath27 _ satisfies _ a ground rule @xmath12 , if @xmath13 is true with respect to @xmath27 whenever @xmath16 is true and @xmath18 is false with respect to @xmath27 .",
    "an interpretation @xmath27 is called a _ model _ of a program @xmath22 if it satisfies all the rules in @xmath22 .",
    "the _ reduct _ @xmath32 of a program @xmath22 with respect to an interpretation @xmath27 is defined as follows : @xmath33    an interpretation @xmath27 is an _ answer set _ for a program @xmath22 , if it is a subset - minimal model for  @xmath32 , and @xmath34 denotes the set of all the answer sets of a program @xmath22 .",
    "for example , consider the following program @xmath35 : @xmath36 and take an interpretation @xmath37 .",
    "the reduct @xmath38 is as follows : @xmath39 the interpretation  @xmath27 is a model of the reduct  ( [ eq : reduct ] ) .",
    "let us take a strict subset @xmath40 of @xmath27 which is @xmath41 .",
    "then , the reduct  @xmath42 is again equal to  ( [ eq : reduct ] ) ; however , @xmath40 does not satisfy  ( [ eq : reduct ] ) .",
    "therefore , @xmath37 is a subset - minimal model ; hence an answer set of  @xmath35 .",
    "note also that @xmath43 is the only answer set of  @xmath22 .",
    "the idea of asp  @xcite is to represent a computational problem as a program whose answer sets correspond to the solutions of the problem , and to find the answer sets for that program using an answer set solver .",
    "when we represent a problem in asp , two kinds of rules play an important role : those that `` generate '' many answer sets corresponding to `` possible solutions '' , and those that can be used to `` eliminate '' the answer sets that do not correspond to solutions .",
    "the rules @xmath44 are of the former kind : they generate the answer sets @xmath43 and  @xmath45 .",
    "constraints are of the latter kind . for instance , adding the constraint @xmath46 to program ( [ eq : pi2 ] ) eliminates the answer sets for the program that contain  @xmath2 .    in asp , we use special constructs of the form \\{a_1,  ,a_n}^c ( called _ choice expressions _ ) , and of the form l \\{a_1,  ,a_m } u ( called _ cardinality expressions _ ) where each @xmath9 is an atom and @xmath47 and @xmath48 are nonnegative integers denoting the `` lower bound '' and the `` upper bound ''  @xcite .",
    "programs using these constructs can be viewed as abbreviations for normal nested programs defined in  @xcite .",
    "expression  ( [ choice ] ) describes subsets of @xmath49 .",
    "such expressions can be used in heads of rules to generate many answer sets .",
    "for instance , the answer sets for the program \\{p , q , r}^c     are arbitrary subsets of  @xmath50",
    ". expression  ( [ cardinality ] ) describes the subsets of the set @xmath51 whose cardinalities are at least @xmath47 and at most  @xmath48 .",
    "such expressions can be used in constraints to eliminate some answer sets .",
    "for instance , adding the constraint    @xmath52 to program ( [ ex : p - q - r ] ) eliminates the answer sets for ( [ ex : p - q - r ] ) whose cardinalities are at least 2 .",
    "we abbreviate the rules @xmath53 by the rule @xmath54    in asp , there are also special constructs that are useful for optimization problems . for instance , to compute answer sets that contain the maximum number of elements from the set @xmath55 , we can use the following optimization statement .",
    "@xmath56      once we represent a computational problem as a program whose answer sets correspond to the solutions of the problem , we can use an answer set solver to compute the solutions of the problem . to present a program to an answer set solver , like",
    ", we need to make some syntactic modifications .",
    "recall that answer sets for a program are defined over ground programs .",
    "thus , the input of asp solvers should be ground instantiations of the programs . for that , programs go through a `` grounding '' phase in which variables in the program ( if exists ) are substituted by constants . for , we use the `` grounder ''  @xcite .",
    "although the syntax of the input language of  is somewhat more restricted than the class of programs defined above , it provides a number of useful special constructs . for instance , the head of a rule can be an expression of one of the forms @xmath57 but the superscript @xmath58 and the sign @xmath59 are dropped .",
    "the body can also contain cardinality expressions but the sign @xmath59 is dropped . in the input language of , : - stands for @xmath60 , and each rule is followed by a period . for facts @xmath60 is dropped .",
    "for instance , the rule @xmath61 can be presented to  as follow :    .... 1{p , q , r}1 . ....",
    "variables in a program are represented by strings whose initial letters are capitalized .",
    "the constants and predicate symbols , on the other hand , start with a lowercase letter .",
    "for instance , the program @xmath62 @xmath63 can be presented to  as follows :    .... index(1 .. n ) .",
    "p(i ) : - not p(i+1 ) , index(i ) . ....    here , the auxiliary predicate index is a `` domain predicate '' used to describe the ranges of variables .",
    "variables can be also used `` locally '' to describe the list of formulas .",
    "for instance , the rule @xmath64 can be expressed in  as follows    ....",
    "index(1 .. n ) .",
    "1{p(i ) : index(i)}1 . ....",
    "we have earlier developed the software system  @xcite ( see figure  [ fig : bqasp ] ) to answer complex queries that require appropriate integration of relevant knowledge from different knowledge resources and auxiliary definitions such as chains of drug - drug interactions , cliques of genes based on gene - gene relations , or similar / diverse genes .",
    "as depicted in figure  [ fig : bqasp ] ,  takes a query in a controlled natural language and transforms it into asp .",
    "meanwhile , it extracts knowledge from biomedical databases and ontologies , and integrates them in asp .",
    "afterwards , it computes an answer to the given query using an asp solver .",
    "let us give an example to illustrate these stages ; the details of representing biomedical queries in natural language and answering them using asp are explained in a companion article though .",
    "first of all , let us mention that knowledge related to drug discovery is extracted from the biomedical databases / ontologies and represented in asp . if the biomedical ontology is in rdf(s)/owl then we can extract such knowledge using the asp solver  @xcite by making use of external predicates . for instance ,",
    "consider as an external theory a drug ontology described in rdf .",
    "all triples from this theory can be exported using the external predicate & rdf :    .... triple_drug(x , y , z ) : - & rdf[\"uri for drug ontology\"](x , y , z ) . ....    then the names of drugs can be extracted by  using the rule :    .... drug_name(a ) : - triple_drug(_,\"drugproperties : name\",a ) .",
    "....    some knowledge resources are provided as relational databases , or more often as a set of triples ( probably extracted from ontologies in rdf ) . in such cases ,",
    "we use short scripts to transform the relations into asp .    to relate the knowledge extracted from the biomedical databases or ontologies and also provide auxiliary definitions , a rule layer is constructed in asp . for instance , drugs targeting genes are described by the relation drug_gene defined in the rule layer as follows :    .... drug_gene(d , g ) : - drug_gene_pharmgkb(d , g ) .",
    "drug_gene(d , g ) : - drug_gene_ctd(d , g ) . ....    where drug_gene_pharmgkb and drug_gene_ctd are relations for extracting knowledge from relevant knowledge resources .",
    "the auxiliary concept of reachability of a gene from another gene by means of a chain of gene - gene interactions is defined in the rule layer as well :    .... gene_reachable_from(x,1 ) : - gene_gene(x , y ) , start_gene(y ) .",
    "gene_reachable_from(x , n+1 ) : - gene_gene(x , z ) ,     gene_reachable_from(z , n ) , 0 < n , n < l ,     max_chain_length(l ) . ....    now , consider , for instance , the query  q11 from table  [ tab : queries ] .",
    "what are the drugs that treat the disease depression and that do not target the gene  acyp1 ?",
    "this type of queries might be important in terms of drug repurposing  @xcite which has achieved a number of successes in drug development , including the famous example of pfizer s viagra  @xcite .",
    "this query is then translated into the following program in the language of :    .... what_be_drugs(drg ) : -   cond1(drg ) , cond2(drg ) .",
    "cond1(drg ) : - drug_disease(drg,\"depression \" ) .",
    "cond2(drg ) : - drug_name(drg ) , not drug_gene(drg,\"acyp1 \" ) .",
    "answer_exists : - what_be_drugs(drg ) .",
    ": - not answer_exists . ....    where cond1 and cond2 are invented relations , drug_name , drug_disease and drug_gene are defined in the rule layer .",
    "once the query and the rule layer are in asp , the parts of the rule layer that are relevant to the given query are identified by an algorithm  @xcite .",
    "for some queries , the relevant part of the program is almost 100 times smaller than the whole program ( considering the number of ground rules ) .",
    "then , given the query as an asp program and the relevant knowledge as an asp program , we can find answers to the query by computing an answer set for the union of these two programs using .",
    "for the query above an answer computed in this way is `` fluoxetine '' .",
    "once an answer is found for a complex biomedical query , the experts may need informative explanations about the answer , as discussed in the introduction . with this motivation",
    ", we study generating explanations for complex biomedical queries .",
    "since the queries , knowledge extracted from databases and ontologies , and the rule layer are in asp , our studies focus on explanation generation within the context of asp .",
    "before we introduce our methods to generate explanations for a given query , let us introduce some definitions regarding explanations in asp .",
    "let @xmath22 be the relevant part of a ground asp program with respect to a given biomedical query @xmath65 ( also a ground asp program ) , that contains rules describing the knowledge extracted from biomedical ontologies and databases , the knowledge integrating them , and the background knowledge .",
    "rules in @xmath66 generally do not contain cardinality / choice expressions in the head ; therefore , we assume that in @xmath66 only bodies of rules contain cardinality expressions .",
    "let @xmath67 be an answer set for @xmath66 .",
    "let @xmath2 be an atom that characterizes an answer to the query @xmath65 .",
    "the goal is to find an `` explanation '' as to why @xmath2 is computed as an answer to the query @xmath65 , i.e. , why is @xmath2 in @xmath67 ? before we introduce a definition of an explanation , we need the following notations and definitions .",
    "we say that a set  @xmath67 of atoms _ satisfies _ a cardinality expression @xmath68 of the form @xmath69 if the cardinality of @xmath70 is within the lower bound @xmath47 and upper bound @xmath48 .",
    "also @xmath67 _ satisfies _ a set @xmath71 of cardinality expressions ( denoted by @xmath72 ) , if @xmath67 satisfies every element of @xmath71 .",
    "let @xmath22 be a ground asp program , @xmath12 be a rule in @xmath22 , @xmath2 be an atom in @xmath22 , and @xmath73 and @xmath74 be two sets of atoms .",
    "let @xmath75 denote the set of cardinality expressions that appear in the body of @xmath12 .",
    "we say that @xmath12 _ supports _ an atom @xmath2 using atoms in @xmath73 but not in @xmath74 ( or with respect to @xmath73 but @xmath74 ) , if the following hold : @xmath76 we denote the set of rules in @xmath22 that support @xmath2 with respect to @xmath73 but @xmath74 , by @xmath77 .",
    "we now introduce definitions about explanations in asp .",
    "we first define a generic tree whose vertices are labeled by either atoms or rules .    a _ vertex - labeled tree _",
    "@xmath78 for a program @xmath22 and a set @xmath67 of atoms is a tree @xmath79 whose vertices are labeled by a function @xmath47 that maps @xmath80 to @xmath81 . in this tree ,",
    "the vertices labeled by an atom ( resp . ,",
    "a rule ) are called _ atom vertices _ ( resp . , _ rule vertices _ ) .    for a vertex - labeled tree @xmath82 and a vertex @xmath83 in @xmath80",
    ", we introduce the following notations :    * @xmath84 denotes the set of atoms which are labels of ancestors of @xmath83 .",
    "* @xmath85 denotes the set of rule vertices which are descendants of @xmath83 . *",
    "@xmath86 denotes the set of children of @xmath83 . *",
    "@xmath87 denotes the set of siblings of @xmath83 .",
    "* @xmath88 denotes the set of out - going edges of @xmath83 .",
    "* @xmath89 denotes the degree of @xmath83 and equals to @xmath90 . * if @xmath91 , then @xmath83 is a _ leaf _ vertex .",
    "* @xmath92 denotes the set of leaves of @xmath93 . *",
    "the _ root _ of @xmath93 is the root of @xmath79 .",
    "* @xmath93 is _ empty _ if @xmath94 .",
    "we now define a specific class of vertex - labeled trees which contains all possible `` explanations '' for an atom .",
    "[ def : andor ] let @xmath22 be a ground asp program , @xmath67 be an answer set for @xmath22 , @xmath2 be an atom in @xmath67 .",
    "the _ and - or explanation tree _ for @xmath2 with respect to @xmath22 and @xmath67 is a vertex - labeled tree @xmath95 that satisfies the following :    * for the root @xmath96 of the tree , @xmath97 ; * for every atom vertex @xmath96 , @xmath98 * for every rule vertex @xmath96 , @xmath99 * each leaf vertex is a rule vertex .",
    "let us explain conditions @xmath100 in definition [ def : andor ] in detail .    1 .",
    "the root of the and - or explanation tree @xmath93 is labeled by the atom @xmath2 .",
    "intuitively , @xmath93 contains all possible explanations for @xmath2 .",
    "2 .   for every atom vertex @xmath96",
    ", there is an out - going edge @xmath101 to a rule vertex @xmath102 under the following conditions : the rule that labels @xmath103 supports the atom that labels @xmath83 , using atoms in @xmath67 but not any atom that labels an ancestor of @xmath103 .",
    "we want to exclude the atoms labeling ancestors of @xmath103 to ensure that the height of the and - or explanation tree is finite ( e.g. , otherwise , due to cyclic dependencies the tree may be infinite ) .",
    "3 .   for every rule vertex @xmath96",
    ", there is an out - going edge @xmath101 to an atom vertex if the atom that labels @xmath103 is in the positive body of the rule that labels @xmath83 . in this way",
    ", we make sure that every atom in the positive body of the rule that labels @xmath83 takes part in explaining the head of the rule that labels @xmath83 .",
    "4 .   together with conditions @xmath104 and @xmath105 above",
    ", this condition guarantees that the leaves of the and - or explanation tree are rule vertices that are labeled by facts in the reduct of the given asp program @xmath22 with respect to the given answer set @xmath67 .",
    "intuitively , this condition expresses that the leaves are self - explanatory .",
    "[ ex : andor ] let @xmath22 be the program @xmath106 and @xmath107 . the and - or explanation tree for @xmath108 with respect to @xmath22 and @xmath67 is shown in figure  [ fig : andor ] .",
    "intuitively , the and - or explanation tree includes all possible `` explanations '' for an atom .",
    "for instance , according to figure  [ fig : andor ] , the atom @xmath108 has two explanations :    * one explanation is characterized by the rules that label the vertices in the left subtree of the root : @xmath108 is in @xmath67 because the rule @xmath109 support @xmath108 .",
    "moreover , this rule can be `` applied to generate @xmath108 '' because @xmath110 and @xmath111 , the atoms in its positive body , are in @xmath67 .",
    "further , @xmath110 is in @xmath67 because the rule @xmath112 supports @xmath110 .",
    "further , @xmath111 is in @xmath67 because @xmath111 is supported by the rule @xmath113 which is self - explanatory . *",
    "the other explanation is characterized by the rules that label the vertices in the right subtree of the root : @xmath108 is in @xmath67 because the rule @xmath114 supports @xmath108 .",
    "further , this rule can be `` applied to generate @xmath108 '' because @xmath115 is in @xmath67 .",
    "in addition , @xmath115 is in @xmath67 because @xmath115 is supported by the rule @xmath116 which is self - explanatory .",
    "[ - > ] child node@xmath117 child node@xmath110 child node@xmath118 child node@xmath111 child node@xmath119 child node@xmath111 child node@xmath119 child node@xmath120 child node@xmath115 child node@xmath121 ;    [ prop : andornonempty ] let @xmath22 be a ground asp program and @xmath67 be an answer set for @xmath22 . for every @xmath2 in @xmath67 ,",
    "the and - or explanation tree for @xmath2 with respect to @xmath22 and @xmath67 is not empty .",
    "note that in the and - or explanation tree , atom vertices are the `` or '' vertices , and rule vertices are the `` and '' vertices .",
    "then , we can obtain a subtree of the and - or explanation tree that contains an explanation , by visiting only one child of every atom vertex and every child of every rule vertex , starting from the root of the and - or explanation tree .",
    "here is precise definition of such a subtree , called an explanation tree .",
    "[ def : exptree ] let @xmath22 be a ground asp program , @xmath67 be an answer set for @xmath22 , @xmath2 be an atom in @xmath67 , and @xmath122 be the and - or explanation tree for @xmath2 with respect to @xmath22 and @xmath67 . an _ explanation tree _ in @xmath93 is a vertex - labeled tree such that    * @xmath123 is a subtree of @xmath79 ; * the root of @xmath123 is the root of @xmath79 ; * for every atom vertex @xmath124 , @xmath125 ; * for every rule vertex @xmath124 , @xmath126 .",
    "[ ex : extree ] let @xmath93 be the and - or explanation tree in figure [ fig : andor ] . then , figure [ fig : exptree ] illustrates the explanation trees in @xmath93 .",
    "these explanation trees characterize the two explanations for @xmath108 explained in example  [ ex : andor ] .",
    "[ - > ] child node@xmath117 child node@xmath110 child node@xmath118 child node@xmath111 child node@xmath119 child node@xmath111 child node@xmath119 ;    [ - > ] child node@xmath120 child node@xmath115 child node@xmath121 ;    after having defined the and - or explanation tree and an explanation tree for an atom , let us now define an explanation for an atom .",
    "[ def : explanation ] let @xmath22 be a ground asp program , @xmath67 be an answer set for  @xmath22 , and @xmath2 be an atom in  @xmath67 .",
    "a vertex - labeled tree @xmath127 is an _ explanation _ for @xmath2 with respect to @xmath22 and @xmath67 if there exists an explanation tree @xmath78 in the and - or explanation tree for @xmath2 with respect to @xmath22 and @xmath67 such that    * @xmath128 ; * @xmath129 .",
    "intuitively , an explanation can be obtained from an explanation tree by `` ignoring '' its atom vertices .",
    "[ ex : ex ] let @xmath22 and @xmath67 be defined as in example [ ex : andor ] .",
    "then , figure [ fig : exp ] depicts two explanations for @xmath108 with respect to @xmath22 and @xmath67 , described in example  [ ex : andor ] .",
    "so far , we have considered only positive programs in the examples .",
    "our definitions can also be used in programs that contain negation and aggregates in the bodies of rules .",
    "[ ex : explanationnegaggr ] let @xmath22 be the program @xmath130 and @xmath107 . the and - or explanation tree for @xmath108 with respect to @xmath22 and @xmath67 is shown in figure  [ fig : explanationnegaggr](a ) . here",
    ", the rule @xmath131 is not included in the tree as @xmath110 is in @xmath67 , whereas the rule @xmath132 is in the tree as @xmath133 is not in @xmath67 and , @xmath110 and @xmath111 are in @xmath67 .",
    "also , the rule @xmath134 is in the tree as @xmath115 is in @xmath67 and the cardinality expression @xmath135 is satisfied by @xmath67 . an explanation for @xmath108 with respect to @xmath22 and @xmath67 is shown in figure  [ fig : explanationnegaggr](b ) .    note that our definition of an and - or explanation tree considers positive body parts of the rules only to provide explanations .",
    "therefore , explanation trees do not provide further explanations for negated literals ( e.g. , why an atom is not included in the answer set ) , or aggregates ( e.g. , why a cardinality constraint is satisfied ) as seen in the example above .",
    "as can be seen in figure  [ fig : exp ] , there might be more than one explanation for a given atom .",
    "hence , it is not surprising that one may prefer some explanations to others .",
    "consider biomedical queries about chains of gene - gene interactions like the query q8 in table  [ tab : queries ] .",
    "answers of such queries may contain chains of gene - gene interactions with different lengths .",
    "for instance , an answer for this query is `` cask '' .",
    "figure  [ fig : expq8 ] shows an explanation for this answer . here",
    ", `` cask '' is related to `` adrb1 '' via a gene - gene chain interaction of length @xmath136 ( the chain `` cask''``dlg4''``adrb1 '' ) .",
    "another explanation is partly shown in figure  [ fig : expq8_3 ] . now , `` cask '' is related to `` adrb1 '' via a gene - gene chain interaction of length @xmath137 ( the chain `` cask'' `` dlg1''``dlg4''``adrb1 '' ) . since gene - gene interactions are important for drug discovery , it may be more desirable for the experts to reason about chains with shortest lengths .    with this motivation , we consider generating shortest explanations . intuitively , an explanation  @xmath30 is shorter than another explanation  @xmath138 if the number of rule vertices involved in  @xmath30 is less than the number of rule vertices involved in  @xmath138 .",
    "then we can define shortest explanations as follows .",
    "[ - > ] child    node    [ cols= \" < \" , ]",
    "based on the algorithms introduced above , we have developed a computational tool called  @xcite , using the programming language c++ . given an asp program and",
    "its answer set ,  generates shortest explanations as well as @xmath0 different explanations .",
    "the input of  are    * an asp program @xmath22 , * an answer set @xmath67 for @xmath22 , * an atom @xmath2 in @xmath67 , * an option that is used to generate either a shortest explanation or @xmath0 different explanations , * a predicate look - up table ,    and the output are    * a shortest explanation for @xmath2 with respect to @xmath22 and @xmath67 in a natural language ( if shortest explanation option is chosen ) , * @xmath0 different explanations for @xmath2 with respect to @xmath22 and @xmath67 in a natural language ( if @xmath0 different explanations option is chosen ) .    for generating shortest explanations ( resp .",
    ", @xmath0 different explanations ) ,  utilizes algorithm  [ alg : shortexp ] ( resp .",
    ", algorithm  [ alg : kdiff ] ) .    to provide experts with further informative explanations about the answers of biomedical queries ,",
    "we have embedded  into  by utilizing table  [ tab : lookup ] as the predicate look - up table of the system .",
    "figure  [ fig : expgenasp ] shows a snapshot of the explanation generation mechanism of .",
    "the most similar work to ours is  @xcite that study the question `` why is an atom  @xmath2 in an answer set  @xmath67 for an asp program  @xmath22 '' . as an answer to this question",
    ", the authors of  @xcite finds a `` justification '' , which is a labeled graph that provides an explanation for the truth values of atoms with respect to an answer set .",
    "[ ex : pontelli ] let @xmath22 be the program presented in example  [ ex : andor ] : @xmath106 and @xmath107 .",
    "figure  [ fig : jstfpontelli ] is an offline justification of @xmath139 with respect to @xmath67 and @xmath41 .",
    "intuitively , @xmath108 is in @xmath67 since @xmath110 and @xmath111 are also in @xmath67 and there is a rule in @xmath22 that supports @xmath108 using the atoms @xmath110 and @xmath111 .",
    "furthermore , @xmath110 is in @xmath67 since @xmath111 is in @xmath67 and there is a rule in @xmath22 that supports @xmath110 using the atom @xmath111 . finally , @xmath111 is in @xmath67 as it is a fact in @xmath22 .",
    "[ - > ] child node ( b+ ) @xmath140 edge from parent node[pos=0.4,left ] @xmath141 child node ( c+ ) @xmath142 child node@xmath143 edge from parent node[left ] @xmath141 edge from parent node[pos=0.4,right ] @xmath141 ; ( b+ )  ( c+ )",
    "node[pos=.5 , above ] @xmath141 ;    to relate offline justifications and explanations , we need to introduce the following definitions and notations about justifications defined in  @xcite .",
    "first , let us introduce notations related to asp programs used in  @xcite .",
    "the class of asp programs studied is normal programs , i.e. , programs that consist of the rules of the form @xmath144 where @xmath8 and @xmath10 and each @xmath9 is an atom .",
    "therefore , the programs we consider are more general .",
    "let @xmath22 be a normal asp program .",
    "then , @xmath145 is the herbrand base of @xmath22 . an _ interpretation _",
    "@xmath27 for a program @xmath22 is defined as a pair @xmath146 , where @xmath147 and @xmath148 .",
    "intuitively , @xmath149 denotes the set of atoms that are true , while @xmath150 denotes the set of atoms that are false .",
    "@xmath27 is a _ complete interpretation _ if @xmath151 .",
    "the _ reduct _",
    "@xmath32 of @xmath22 with respect to @xmath27 is defined as @xmath152 a complete interpretation @xmath153 for a program @xmath22 is an answer set for @xmath22 if @xmath154 is an answer set for @xmath155 .",
    "literal _ is either an atom or a formula of the form @xmath156 where @xmath108 is an atom .",
    "the set of atoms which appear as negated literals in @xmath22 is denoted by @xmath157 . for an atom @xmath108",
    ", @xmath139 denotes that the atom @xmath108 is true and @xmath158 denotes that @xmath158 is false .",
    "then , @xmath139 and @xmath158 are called the _ annotated _ versions of @xmath108 .",
    "moreover , it is defined that @xmath159 and @xmath160 . for a set @xmath30 of atoms ,",
    "the following sets of annotated atoms are defined .    * @xmath161 * @xmath162    finally , the set @xmath163 is defined as @xmath164 .",
    "apart from the answer set semantics , there is another important semantics of logic programs , called the well - founded semantics  @xcite .",
    "since this semantics is important to build the notion of a justification , we now briefly describe the well - founded semantics .",
    "we consider the definition proposed in  @xcite , instead of the original definition proposed in  @xcite , as the authors of  @xcite considered .",
    "let @xmath22 be a normal asp program , and @xmath30 and @xmath80 be two sets of atoms from @xmath145 .",
    "then , the _ immediate consequence _ of @xmath30 with respect to @xmath22 and @xmath80 , denoted by @xmath165 is the set defined as follows : @xmath166    we denote by @xmath167 the least fixpoint of @xmath168 when @xmath80 is fixed .",
    "let @xmath22 be a normal asp program , @xmath169 .",
    "the sequence @xmath170 is defined as follows : @xmath171 let @xmath172 be the first index of the computation such that @xmath173 .",
    "then , _ the well - founded model _ of @xmath22 is @xmath174 where @xmath175 and @xmath176 .",
    "[ ex : wellfounded ] let @xmath22 be the program @xmath177 then , the well - founded model of @xmath22 is computed as follows : @xmath178 thus , @xmath179 .",
    "we now provide definitions regarding the notion of an offline justification .",
    "first , we introduce the basic building of an offline justification , a labeled graph called as e - graph .",
    "[ def : egraph ] let @xmath22 be a normal asp program . an _",
    "e - graph _ for @xmath22 is a labeled , directed graph @xmath180 , where @xmath181 and @xmath182 , which satisfies following properties :    * the only sinks ( i.e. , nodes without out - going edges ) in the graph are @xmath183 ; * for every @xmath184 , @xmath185 and @xmath186 ; * for every @xmath187 , @xmath188 and @xmath189 ; * for every @xmath190 , if for some @xmath191 and @xmath192 , @xmath193 , then @xmath194 is the only out - going edge originating from @xmath110 .    according to this definition ,",
    "an edge of an e - graph connects two annotated atoms or an annotated atom with one of the nodes in @xmath195 and is marked by a label from @xmath196 .",
    "an edge is called as _ positive _ ( resp . ,",
    "_ negative _ ) if it is labeled by @xmath141 ( resp . , @xmath197 ) .",
    "also , a path in an e - graph is called as _ positive _ if it has only positive edges , whereas it is called as _ negative _ if it has at least one negative edge .",
    "the existence of a positive path between two nodes @xmath198 and @xmath199 is denoted by @xmath200 . in the offline justification ,",
    "@xmath143 is used to explain facts , @xmath11 to explain atoms which do not have defining rules , and @xmath201 is for atoms for which explanations are not needed , i.e. , they are assumed to be true or false .",
    "[ ex : egraph ] let @xmath22 be the program presented in example  [ ex : andor ] , and @xmath107 . then , figure [ fig : egraph ] is an e - graph for @xmath22 . intuitively , the true state of @xmath108 depends on the true state of @xmath110 and the false state of @xmath111 , where @xmath110 is assumed to be true and @xmath111 is assumed to be false .",
    "[ - > ] child node@xmath140 child node@xmath201 edge from parent node[left ] @xmath141 edge from parent node[left ] @xmath141 child node@xmath202 child node@xmath201 edge from parent node[left ] @xmath197 edge from parent node[right ] @xmath197 ;    in an e - graph , a set of elements that directly contributes to the truth value of an atom can be obtained through the out - going edges of a corresponding node .",
    "this set is defined as follows .",
    "[ def : support ] let @xmath22 be a normal asp program , @xmath203 be an e - graph for @xmath22 and @xmath204 be a node in @xmath205 .",
    "then , _ @xmath206 _ is defined as follows .",
    "* @xmath207 , if for some @xmath191 and @xmath192 , @xmath194 is in @xmath208 ; * @xmath209 , otherwise .",
    "[ ex : support ] let @xmath205 be the e - graph in figure  [ fig : egraph ] . then , @xmath210 , @xmath211 and @xmath212",
    "to define the notion of a justification , an e - graph should be enriched with explanations of truth values of atoms that are derived from the rules of the program .",
    "for that , the concept of one step justification of a literal is defined as follows .",
    "[ def : lce ] let @xmath22 be a normal asp program , @xmath110 be an atom , @xmath213 be a possible interpretation for @xmath22 , @xmath214 be a set of atoms , and @xmath215 be a set of literals .",
    "we say that    * @xmath30 is an _ lce _ of @xmath140 with respect to @xmath216 , if @xmath217 and * * @xmath218 or * * @xmath219 , @xmath220 , and there is a rule @xmath221 such that @xmath222 and @xmath223 . in case , @xmath20 , @xmath30 is denoted by the set @xmath224 .",
    "* @xmath30 is an _ lce _ of @xmath225 with respect to @xmath216 , if @xmath226 and * * @xmath218 or * * @xmath227 , @xmath228 , and @xmath30 is a minimal set of literals such that for every rule @xmath229 if @xmath222 , then @xmath230 or @xmath231 . in case ,",
    "@xmath232 , @xmath30 is denoted by the set @xmath233 .",
    "the set of all the lces of @xmath140 with respect to @xmath216 is denoted by @xmath234 and the set of all the lces of @xmath225 with respect to @xmath216 is denoted by @xmath235 .    here , a possible interpretation @xmath213 denotes an answer set .",
    "the set @xmath236 consists of atoms that are assumed to be false ( which will be called as assumptions in the notion of justification later on ) .",
    "the need for @xmath236 comes from the fact that the truth value of some atoms is first guessed while computing answer sets .",
    "intuitively , if an atom @xmath108 is true , an lce consists of the body of a rule which is satisfied by @xmath213 and has @xmath108 in its head ; if @xmath108 is false , an lce consists of a set of literals that are false in @xmath213 and falsify all rules whose head are @xmath108 .",
    "[ ex : lce ] let @xmath22 and @xmath67 be defined as in example  [ ex : egraph ] .",
    "then , the lces of the atoms with respect to @xmath237 is as follows .",
    "@xmath238    accordingly , a class of e - graphs where edges represent lces of the corresponding nodes are defined as follows .",
    "[ def : ju ] let @xmath22 be a normal asp program , @xmath213 be a possible interpretation for @xmath22 , @xmath239 be a set of atoms and @xmath110 be an element in @xmath240 .",
    "@xmath216-based e - graph _",
    "@xmath241 of @xmath110 is an e - graph such that    * every node @xmath242 is reachable from @xmath110 , * for every @xmath243 , @xmath244 is an lce of @xmath111 with respect to @xmath216 ;    a @xmath216-based e - graph @xmath180 is _ safe _ if for all @xmath245 , i.e. , there is no positive cycle in the graph .",
    "we now introduce a special class of @xmath216-based e - graphs where only false elements can be assumed .",
    "[ def : offlinegraph ] let @xmath22 be a normal asp program , @xmath213 be a partial interpretation for @xmath22 , @xmath239 be a set of atoms and @xmath110 be an element in @xmath246 .",
    "offline e - graph _",
    "@xmath241 of @xmath110 with respect to @xmath213 and @xmath236 is a @xmath216-based e - graph of @xmath110 that satisfies following properties :    * there exists no @xmath247 such that @xmath248 ; * @xmath249 if and only if @xmath250 .",
    "@xmath251 is the set of all offline e - graphs of @xmath110 with respect to @xmath213 and @xmath236 .    here ,",
    "the roles of @xmath213 and @xmath236 are the same as their roles in definition  [ def : lce ] .",
    "observe that true atoms can not be assumed due to the first condition and only elements in the set @xmath236 are assumed due to the second condition .",
    "we said earlier that in a @xmath216-based e - graph @xmath213 represents an answer set and @xmath236 consists of atoms that are assumed to be false . here , @xmath236 is chosen based on some characteristics of @xmath213 . in particular",
    ", we want @xmath236 to be a set of atoms such that when its elements are assumed to be false , the truth value of other atoms in the program can be uniquely determined and leads to @xmath213 .",
    "we now introduce regarding definitions formally .",
    "[ def : tentative ] let @xmath22 be a normal asp program , @xmath153 be an answer set for @xmath22 and @xmath252 be the well - founded model of @xmath22 .",
    "the _ tentative assumptions _ @xmath253 of @xmath22 with respect to @xmath153 are defined as @xmath254    [ ex : tentative ] let @xmath22 be the program : @xmath255 then , @xmath256 is an answer set for @xmath22 and @xmath257 is the well - founded model of @xmath22 . given that , @xmath258 as @xmath259 , @xmath260 and @xmath261 .",
    "in fact , tentative assumptions is a set of atoms whose subsets might `` potentially '' form @xmath236 .",
    "we provide a definition that would allow one to obtain a program from a given program @xmath22 and a set @xmath80 of atoms by assuming all the atoms in @xmath80 as false .",
    "[ def : negreduct ]",
    "let @xmath22 be a normal asp program , @xmath153 be an answer set for @xmath22 , and @xmath262 be a set of tentative assumption atoms .",
    "the _ negative reduct _",
    "@xmath263 of @xmath22 with respect to @xmath236 is the set of rules defined as @xmath264    finally , the concept of assumptions can be introduced formally .",
    "[ def : assumption ] let @xmath22 be a normal asp program , @xmath153 be an answer set for @xmath22",
    "assumption _ of @xmath22 with respect to @xmath153 is a set @xmath236 of atoms that satisfies the following properties :    * @xmath262 ; * the well - founded model of @xmath263 is equal to @xmath153 .",
    "@xmath265 is the set of all assumptions of @xmath22 with respect to @xmath153 .",
    "let @xmath22 and @xmath67 be defined as in example  [ ex : tentative ] .",
    "let @xmath266 .",
    "then , @xmath263 is : @xmath267 and @xmath268 is the well - founded model of @xmath263 .",
    "thus , @xmath236 is an assumption of @xmath22 with respect to @xmath67 .",
    "note that assumptions are nothing but subsets of tentative assumptions that would allow to obtain the answer set @xmath213 .    at last , we are ready to define the notion of offline justification .",
    "[ def : justification ] let @xmath22 be a normal asp program , @xmath153 be an answer set for @xmath22 , @xmath236 be an assumption in @xmath265 and @xmath110 be an annotated atom in @xmath269 .",
    "an _ offline justification _ of @xmath110 with respect to @xmath153 and @xmath236 is an element @xmath180 of @xmath270 which is safe .    according to the definition ,",
    "a justification is a @xmath216-based e - graph where @xmath213 is an answer set and @xmath236 is an assumption .",
    "also , justifications do not allow the creation of positive cycles in the justification of true atoms .",
    "for instance , for @xmath22 and @xmath67 defined as in example  [ ex : andor ] , figure  [ fig : jstfpontelli ] illustrates an offline justification of @xmath139 with respect to @xmath67 and @xmath41 .    in  @xcite , the authors prove the following proposition which shows that for every atom in the program , there exists an offline justification .    [",
    "prop : pontelli ] let @xmath22 be a ground normal asp program , @xmath67 be an answer for @xmath22 .",
    "then , for each atom @xmath108 in @xmath22 , there is an offline justification of with respect to @xmath67 and @xmath271 which does not contain negative cycles .",
    "we relate a justification to an explanation .",
    "in particular , given an offline justification , we show that one can obtain an explanation tree whose atom vertices are formed by utilizing the `` annotated atoms '' of the justification and rule vertices are formed by utilizing the `` support '' of annotated atoms . to compute such explanation trees , we develop algorithm  [ alg : jstf2exp ] .    @xmath272 @xmath273 create a vertex @xmath83 s.t .",
    "@xmath97 @xmath274    let us now explain the algorithm in detail .",
    "algorithm  [ alg : jstf2exp ] takes as input a ground normal asp program @xmath22 , an answer set @xmath67 for @xmath22 , an atom @xmath2 in @xmath67 , and a justification @xmath275 of @xmath276 with respect to @xmath67 and some @xmath277 .",
    "our goal is to obtain an explanation tree in the and - or explanation tree for @xmath2 with respect to @xmath22 and @xmath67 from the justification @xmath275 .",
    "the algorithm starts by creating two sets @xmath278 and @xmath279 ( line  @xmath280 ) . here",
    ", @xmath278 and @xmath279 corresponds to the set of vertices and the set of edges of the explanation tree , respectively . by condition  @xmath104 in definition  [ def : exptree ] and condition  @xmath281 in definition  [ def : andor ] , we know that the label of the root of an explanation tree for @xmath2 with respect to @xmath22 and @xmath67 is @xmath2 .",
    "thus , a vertex @xmath83 with label @xmath2 is defined ( line  @xmath136 ) , and added into the queue  @xmath65 ( line  @xmath137 ) .",
    "then , the algorithm enters into a `` while '' loop which executes until @xmath65 becomes empty . at every iteration of the loop , an element @xmath83 from @xmath65",
    "is first extracted ( line  @xmath282 ) and added into @xmath278 ( line  @xmath283 ) .",
    "this implies that every element added into @xmath65 is also added into @xmath278 .",
    "for instance , the vertex defined at line  @xmath136 is the first vertex extracted from @xmath65 and also added into @xmath278 , which makes sense since we know that the root of an explanation tree is an atom vertex with label @xmath83 .",
    "then , according to the type of the extracted vertex , its out - going edges are defined .",
    "let @xmath284 be a vertex extracted from @xmath65 at line  @xmath282 in some iteration of the loop .",
    "consider the following two cases .    *",
    "assume that @xmath284 is an atom vertex .",
    "then , the algorithm directly goes to line  @xmath285 . by condition  @xmath281 in definition  [ def : exptree ] , we know that an explanation tree is a subtree of the and - or explanation tree .",
    "hence , we need to define out - going edges of @xmath284 by taking into account condition  @xmath104 in definition  [ def : andor ] , which implies that a child of @xmath284 must be a rule vertex @xmath286 such that the rule that labels @xmath286 `` supports '' the atom that labels @xmath284 .",
    "thus , a rule @xmath12 that supports the atom that labels @xmath284 is created ( line  @xmath285 ) .",
    "we ensure `` supportedness '' property by utilizing the annotated atoms in the given offline justification which supports the annotated version of the atom that labels @xmath284 .",
    "then , a vertex @xmath286 with label @xmath12 is created ( line  @xmath287 ) , and a corresponding child of @xmath284 is added into @xmath279 ( line  @xmath288 ) . by condition  @xmath105 in definition  [ def : exptree ] , we know that every atom vertex of an explanation tree has a single child .",
    "therefore , another child of @xmath284 is not created .",
    "then , before finishing the iteration of the loop , the child @xmath286 of @xmath284 is added into @xmath65 so that its children can be formed in the next iterations of the loop . *",
    "assume that @xmath284 is a rule vertex .",
    "then , the condition at line  @xmath289 is satisfied and the algorithm goes to line  @xmath290 . in this case",
    ", while forming the children of @xmath284 , we should consider condition  @xmath105 in definition  [ def : andor ] , which implies that a child @xmath286 of @xmath284 must be an atom vertex such that the atom that labels @xmath286 is in the positive body of the rule that labels @xmath284 .",
    "also , by condition @xmath291 in definition  [ def : exptree ] , we should ensure that for every atom @xmath108 in the positive body of the rule that labels @xmath284 , there exists a child @xmath292 of @xmath284 such that the atom that labels @xmath292 is equal to @xmath108 .",
    "thus , the loop between lines  @xmath290@xmath293 iterates for every atom @xmath108 in the positive body of the label of @xmath284 and a vertex @xmath286 with label @xmath108 is created ( line  @xmath294 ) .",
    "then , @xmath286 becomes a child of @xmath284 ( line  @xmath295 ) .",
    "to form the children of @xmath286 in the next iterations of the `` while '' loop , the child @xmath286 of @xmath284 is added into @xmath65 ( line  @xmath293 ) .",
    "when the algorithm finishes processing the elements of @xmath65 , i.e. , @xmath65 becomes empty , the `` while '' loop terminates .",
    "then , the algorithm returns a vertex - labeled tree ( line  @xmath296 ) .",
    "we now provide the proposition about the soundness of algorithm  [ alg : jstf2exp ] .",
    "[ prop : jstf2exp ] given a ground normal asp program @xmath22 , an answer set @xmath67 for @xmath22 , an atom @xmath2 in @xmath67 , an assumption @xmath236 in @xmath297 , and an offline justification @xmath298 of @xmath276 with respect to @xmath67 and @xmath236 , algorithm [ alg : jstf2exp ] returns an explanation tree @xmath299 in the and - or explanation tree for @xmath2 with respect to @xmath22 and @xmath67 .",
    "let @xmath22 and @xmath67 be defined as in example  [ ex : egraph ] .",
    "figure  [ fig : jstf2exp](a ) is an offline justification of @xmath139 with respect to @xmath67 and @xmath41 .",
    "figure  [ fig : jstf2exp](b ) shows a corresponding explanation tree in the and - or explanation tree for @xmath108 with respect to @xmath22 and @xmath67 that is obtained by using algorithm  [ alg : jstf2exp ] .",
    "we relate an explanation to a justification . in particular , given an explanation tree whose labels of vertices are unique",
    ", we show that one can obtain an offline justification by utilizing the labels of atom vertices of the explanation tree . for that , we design algorithm  [ alg : exp2jstf ] .",
    "@xmath300 @xmath301 root of @xmath302 @xmath303    let us now describe the algorithm in detail .",
    "algorithm  [ alg : exp2jstf ] takes as input a ground normal asp program @xmath22 , an answer set @xmath67 for @xmath22 , an atom @xmath2 in @xmath67 , and an explanation tree @xmath304 in the and - or explanation tree for @xmath2 with respect to @xmath22 and @xmath67 .",
    "our goal is to obtain an offline justification @xmath275 of @xmath276 in @xmath305 with respect to @xmath67 and  @xmath41 .",
    "the reason to obtain the offline justification in the reduct of @xmath22 with respect to @xmath67 is that our definition of explanation is not defined for the atoms that are not in the answer set .",
    "algorithm  [ alg : exp2jstf ] starts by creating two sets @xmath80 and @xmath208 which will correspond to the set of nodes and the set of edges of the offline justification , respectively ( line  @xmath280 ) .",
    "then , the root of @xmath302 is added into the queue @xmath65 ( line  @xmath136 ) and we enter into a `` while '' loop that iterates until @xmath65 becomes empty . at every iteration of the loop",
    ", first an element @xmath83 is extracted from @xmath65 ( line  @xmath306 ) and @xmath307 is added into @xmath80 ( line  @xmath282 ) .",
    "then , we form the out - going edges of @xmath307 . due to condition @xmath105 in definition  [ def : exptree ] , every atom vertex in an explanation tree has a single child , which is a rule vertex due to condition @xmath281 in definition  [ def : exptree ] and condition @xmath104 in definition  [ def : andor ] .",
    "then , we extract the child @xmath284 of @xmath83 at line  @xmath283 and consider two cases .",
    "note that @xmath284 is a rule vertex .",
    "* assume that @xmath308 is a fact in @xmath305 .",
    "then , @xmath308 satisfies the condition at line  @xmath289 and we add @xmath309 into @xmath208 at line  @xmath290 .",
    "the key insight behind that is as follows .",
    "due to condition @xmath104 in definition  [ def : ju ] , @xmath310 must be an lce of @xmath307 .",
    "due to condition @xmath281 in definition  [ def : exptree ] and condition @xmath104 in definition  [ def : andor ] , the head of @xmath308 is @xmath311 . as @xmath308 is a fact in @xmath305 , i.e.",
    ", its body is empty in @xmath305 , @xmath224 becomes an lce of @xmath307 with respect to @xmath237 , due to definition  [ def : lce ] .",
    "thus , by adding @xmath309 to @xmath208 , @xmath310 becomes @xmath224 . *",
    "assume that @xmath308 is not a fact in @xmath305 .",
    "then , for every child @xmath286 of @xmath284 , we add @xmath312 into @xmath208 at line  @xmath295 .",
    "the intuition behind this is to make sure that @xmath310 is an lce of @xmath307 . due to condition @xmath281 in definition  [ def : exptree ] ,",
    "an explanation tree is a subtree of the corresponding and - or explanation tree .",
    "then , due to condition @xmath104 in definition  [ def : andor ] , for every atom vertex @xmath83 in an explanation tree , the atoms in the positive body of the rule that labels the child @xmath284 of @xmath83 are in the given answer set  @xmath67 .",
    "thus , due to definition  [ def : lce ] , adding @xmath313 into @xmath208 for every child @xmath286 of @xmath284 ensures that @xmath310 is an lce of @xmath307 with respect to @xmath237 . also , we add @xmath286 into @xmath80 so that its children in @xmath80 are formed in the next iterations of the `` while '' loop .",
    "due to line  @xmath290 , there are incoming edges of @xmath143 .",
    "but , @xmath143 is not added into @xmath80 inside the `` while '' loop . thus , when the `` while '' loop terminates , before returning @xmath275 at line  @xmath285 , we add @xmath143 into @xmath80 .",
    "algorithm  [ alg : exp2jstf ] creates an offline justification of the given atom in the reduct of the given asp program with respect to the given answer set , provided that labels of the vertices of the given explanation tree are unique .",
    "[ prop : exp2jstf ] given a ground normal asp program @xmath22 , an answer set @xmath67 for @xmath22 , an atom @xmath2 in @xmath67 , and an explanation tree @xmath299 in the and - or explanation tree for  @xmath2 with respect to @xmath22 and @xmath67 such that for every @xmath314 , @xmath315 if and only if @xmath316 , algorithm  [ alg : exp2jstf ] returns an offline justification of @xmath276 in @xmath305 with respect to @xmath67 and @xmath41 .",
    "let @xmath22 be the program : @xmath317 and @xmath256 .",
    "figure  [ fig : exp2jstf](a ) is an explanation tree @xmath93 in the and - or explanation tree for @xmath108 with respect to @xmath22 and @xmath67 .",
    "then , given @xmath318 and @xmath93 , algorithm  [ alg : exp2jstf ] creates an offline justification of @xmath139 in @xmath305 with respect to @xmath22 and @xmath41 as in figure  [ fig : exp2jstf](b ) .",
    "the most recent work related to explanation generation in asp are  @xcite , in the context of debugging asp programs . among those ,",
    "@xcite studies why a program does not have an answer set , and @xcite studies why a set of atoms is not an answer set .",
    "as we study the problem of explaining the reasons why atoms are in the answer set , our work differs from those two work .    in  @xcite ,",
    "similar to our work , the question `` why is an atom  @xmath2 in an answer set  @xmath67 for an asp program  @xmath22 '' is studied . as an answer to this question",
    ", the authors of  @xcite provide the rule in @xmath22 that supports @xmath67 with respect to @xmath22 ; whereas we compute shortest or @xmath0 different explanations ( as a tree whose vertices are labeled by rules ) .",
    "pontelli et al .",
    "@xcite also introduce the notion of an online justification that aims to justify the truth values of atoms during the computation of an answer set . in  @xcite , a framework where the users can construct interpretations through an interactive stepping process is introduced . as a result , @xcite and @xcite can be used together to provide the users with justifications of the truth values of atoms during the construction of interpretations interactively through stepping .",
    "we have formally defined explanations in the context of asp .",
    "we have also introduced variations of explanations , such as `` shortest explanations '' and `` @xmath0 different explanations '' .",
    "we have proposed generic algorithms to generate explanations for biomedical queries . in particular , we have presented algorithms to compute shortest or @xmath0 different explanations .",
    "we have analyzed termination , soundness and complexity of these algorithms .",
    "in particular , the complexity of generating a shortest explanation for an answer ( in an answer set @xmath67 ) is @xmath319 where @xmath320 is the number of asp rules representing the query , the knowledge extracted from biomedical resources and the rule layer , and @xmath321 is the number of atoms in @xmath22 . the complexity of generating @xmath0 different explanations is @xmath322 acknowledgments ---------------    we would like to thank yelda erdem ( sanovel pharmaceutical inc . ) for her help in identifying biomedical queries relevant to drug discovery , and halit erdogan ( sabanci university ) for his help with an earlier version of  which he implemented as part of his ms thesis studies .",
    "we would like to thank hans tompits ( vienna university of technology ) for his useful comments about the work presented in the paper , and pointing out relevant references in the context of debugging asp programs .",
    "we also would like to thank anonymous reviewers for their useful comments and suggestions on an earlier draft .",
    "this work was partially supported by tubitak grant 108e229 .                ,",
    "king , b.  l. , mockus , s. , murphy , c.  g. , saraceni - richards , c. , rosenstein , m. , wiegers , t. , and mattingly , c.  j. 2011 .",
    "the comparative toxicogenomics database : update 2011 .",
    "_ 39 , _  database issue , d1067d1072 .                            ,",
    "law , v. , jewison , t. , liu , p. , ly , s. , frolkis , a. , pon , a. , banco , k. , mak , c. , neveu , v. , djoumbou , y. , eisner , r. , guo , a.  c. , and wishart , d.  s. 2010 . drugbank 3.0 : a comprehensive resource for ` omics ' research on drugs .",
    "_ 39 , _  database issue , d1035d1041 .            , whirl - carrillo , m. , garten , y. , altman , r.  b. , and klein , t.  e. 2011 . from pharmacogenomic knowledge acquisition to clinical applications : the pharmgkb as a clinical pharmacogenomic biomarker resource .",
    "_ 5 , _  6 , 795806 ."
  ],
  "abstract_text": [
    "<S> we introduce novel mathematical models and algorithms to generate ( shortest or @xmath0 different ) explanations for biomedical queries , using answer set programming . </S>",
    "<S> we implement these algorithms and integrate them in . </S>",
    "<S> we illustrate the usefulness of these methods with some complex biomedical queries related to drug discovery , over the biomedical knowledge resources , , , , ,  and .    </S>",
    "<S> [ firstpage ]    answer set programming , explanation generation , query answering , biomedical queries </S>"
  ]
}