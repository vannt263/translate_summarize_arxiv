{
  "article_text": [
    "in the paradigm of discrete - event systems ( des s ) , one can distinguish two fundamental types of control to satisfy given specifications .",
    "specifications prescribe constraints that assert some orderly flow of system activities based on system needs or limitations @xcite .",
    "one type is that of external supervisors controlling discrete - event processes or agents to satisfy given control constraints @xcite , while the other type is that of agents coordinating among themselves through their coordination modules ( cm s ) to satisfy given inter - agent constraints @xcite .",
    "the cm s are built - in strategies designed for the given constraints , and constitute an agent s local interface `` plugged '' onto the agent model via the synchronization operator , and through which every agent coordinates by interacting and communicating with other agents in the system .",
    "although the two types of control are mathematically related , they are clearly conceptually different @xcite .    in @xcite , we formulate and address the fundamental coordination problem of multiple agents coordinating to satisfy one common constraint . therein , by establishing the mathematical connection between the discrete - event coordination problem with the conceptually different discrete - event supervisory control problem @xcite , we successfully adapt concepts and techniques from supervisory control of des s @xcite for the development of a cm synthesis algorithm .    in this paper , we generalize the fundamental coordination problem @xcite to a networked coordination problem of multiple agents coordinating to satisfy multiple constraints distributed among them .",
    "the inter - agent constraints are distributed in such a way that each constraint is pre - specified for a subgroup of agents .",
    "these agent subgroups can be overlapping , meaning that an agent can be coordinating on different inter - agent constraints with different agents in the system , and hence conflict or blocking between their different coordinating actions may arise .",
    "in general , multiagent conflict can occur if some agent actions in a system state can permanently prevent some of the agents in the system from reaching their local design goals characterized by marked states under the discrete - event paradigm .",
    "this presents a challenging design problem of networked agent coordination which is commonly encountered in large scale distributed systems .    to address the networked coordination problem for large scale des s in a systematic fashion , we propose a novel compositional synthesis approach .",
    "this approach consists of two main steps . in the first step ,",
    "we construct for each agent a set of local cm s , one for each of the agent s relevant constraints , using the synthesis algorithm proposed in @xcite .",
    "the advantage of constructing local cm s is that we can avoid having to compute the product of all agent and constraint models , thereby mitigating the problem of state explosion . in the second step ,",
    "we generate a conflict resolution plan , and execute this plan to design additional deconflicting cm s for individual agents .",
    "a conflict resolution plan for a dcsn shows a sequential or partial order of applying deconflicting cm synthesis to successive pairs of potentially conflicting , constrained agent subgroups .",
    "deconflicting cm s are individual agent cm s to be interposed between every agent model and its local cm s , so that in coordinating among themselves , the agents can automatically resolve the conflicts that may otherwise occur due to the different inter - agent constraints on which each agent s local cm s are synthesized . composing the agent models and the local and deconflicting cm s",
    "can then be shown to constitute a correct solution to the networked coordination problem .",
    "our compositional synthesis approach for designing distributed coordinating agents is supported by two original ideas .",
    "the first is a new formalism called the distributed constraint specification network ( dcsn ) that can describe comprehensibly the networking constraint relationships among agents , on which the multiagent networked coordination problem is formulated and addressed ( sections [ sect - problemformulation ] and [ sect - subnetsynthesis ] ) .",
    "the second is multiagent conflict resolution planning that entails generating a compact and/or graph representation @xcite of conflict resolution plans and selecting some criterion - based optimal plan for a given dcsn ( section [ sect - conflictresolutionplanning ] ) . at the outset ,",
    "the background and preliminaries are presented ( section [ sect - pre ] ) .",
    "an example system introduced in section [ sect - problemformulation ] is used throughout the paper to illustrate the various aspects of the proposed approach .",
    "the proofs of all new results are presented in the appendix . a summary and a discussion of related work",
    "conclude the paper ( section [ sect - relatedwork - conclusion ] ) .",
    "in this paper , we will use small letters such as @xmath0 , @xmath1 , @xmath2 , @xmath3 to denote integers . for an integer @xmath4 ,",
    "the symbol @xmath5 denotes the index set @xmath6 .",
    "let @xmath7 be a finite alphabet of symbols representing individual events .",
    "a _ string _ is a finite sequence of events from @xmath7 .",
    "denote @xmath8 as the set of all strings from @xmath7 including the empty string @xmath9 .",
    "a string @xmath10 is a _ prefix _ of @xmath11 if @xmath12 @xmath13 .",
    "a _ language _ @xmath14 over @xmath7 is a subset of @xmath8 .",
    "say @xmath15 is a _ sublanguage _ of @xmath16 if @xmath17 .",
    "the _ prefix closure _ @xmath18 of a language @xmath14 is the language consisting of all prefixes of its strings .",
    "clearly @xmath19 .",
    "a language @xmath14 is _ prefixed - closed _ if @xmath20 .",
    "given @xmath21 , the natural projection @xmath22 , which erases from a string @xmath23 every event @xmath24 , is defined recursively as follows : @xmath25 , and @xmath26 , @xmath27 , if @xmath28 , and @xmath29 , otherwise .",
    "for @xmath30 , @xmath31 denotes the language @xmath32 .",
    "the inverse image of @xmath33 , denoted by @xmath34 , is a mapping from @xmath35 to @xmath36 , and defined as : for @xmath37 , @xmath38 . clearly , for @xmath39 , @xmath40 .",
    "if a language is _ regular _ @xcite , then it can be _ generated _ by an automaton .",
    "an _ automaton _",
    "@xmath41 is a 5-tuple @xmath42 , where @xmath43 is the finite set of states , @xmath44 is the finite set of events , @xmath45 is the ( partial ) transition function , @xmath46 is the _ initial state _ and @xmath47 is the subset of _ marker states_.    the definition of @xmath48 can be extended to @xmath49 as follows : @xmath50 , and @xmath51 .",
    "write @xmath52 to denote that @xmath53 is defined",
    ". the behaviors of automaton @xmath41 can then be described by the prefix - closed language @xmath54 and the marked language @xmath55 .",
    "formally , @xmath56 , and @xmath57 .",
    "let @xmath58 , @xmath59 , be two automata .",
    "then their _ synchronous product _ @xmath41 , denoted by @xmath60 , models a discrete - event system ( des ) of @xmath61 and @xmath62 operating concurrently by interleaving events generated by @xmath61 and @xmath62 , with synchronization on shared events @xmath63 .",
    "it has been shown that if @xmath64 then @xmath65 and @xmath66 @xcite . if @xmath67 , then @xmath68 and @xmath69 .",
    "the synchronous product of @xmath70 automata @xmath61 , @xmath62 , ... @xmath71 , denoted by @xmath72 , can be defined recursively using the associativity of @xmath73 @xcite .",
    "let @xmath74 be a set of @xmath70 nonblocking automata modeling @xmath0 discrete - event agents , with @xmath75 for @xmath76 .",
    "the event set @xmath77 ( of agent @xmath58 ) is partitioned into the controllable event set @xmath78 and the uncontrollable event set @xmath79 . interpreted from the agent viewpoint , an uncontrollable event is inherently autonomous and can be executed solely at the free will of the owner agent .",
    "let @xmath80 model a system of @xmath0 agents in @xmath81 freely interacting , with @xmath82 and @xmath83 .",
    "let @xmath84 .",
    "then , an inter - agent constraint for a group of agents @xmath85 can be prescribed by an automaton @xmath86 such that @xmath87 .",
    "the language @xmath88 is interpreted as the set of desirable event sequences that one wishes to impose on the group of agents @xmath89 . in other words , constraint @xmath86 specifies that the agents in @xmath89 must coordinate among themselves so that none of those event sequences in @xmath90 will ever be generated during their interaction , where @xmath91 .",
    "@xmath86 is then said to be a relevant constraint for agent group @xmath92 .",
    "_ @xcite : _ [ def - coordinationmodule ] a coordination module ( cm ) for an agent @xmath58 , @xmath93 , is an automaton @xmath94 with the following properties : ( i ) @xmath95 , and ( ii ) @xmath94 is @xmath96-enabling , namely , @xmath97 @xmath98 $ ] .    through their cm s ,",
    "the agents coordinate as follows . following the execution of a string @xmath99",
    ", @xmath58 updates the state of every cm @xmath94 to @xmath100 .",
    "@xmath58 then enables ( allows to execute ) only events @xmath101 that is defined at every current state of its cm s .",
    "the result is that the system behavior is restricted to a sublanguage of @xmath54 .",
    "that each cm @xmath94 is @xmath96-enabling guarantees that @xmath58 only disables its own controllable events . in other words , @xmath58 always enables ( and hence never prevents from execution ) its uncontrollable events and never interferes with the execution of events of the other agents .",
    "@xmath102 represents the set of events that @xmath58 needs to observe in order to correctly update the state of @xmath94 when interacting with the other agents .",
    "the event set @xmath103 , which can not be observed locally by @xmath58 , must be communicated to @xmath58 by other agents .",
    "let @xmath104 and @xmath105 . the system of @xmath0 agents in @xmath81 coordinating through their respective cm s can then be represented by @xmath106 .",
    "the cm s are then said to be nonblocking if every string generated during the agents interaction can be completed to a marked string , i.e. , @xmath107 .",
    "the fundamental problem of multiple agents coordinating to respect one constraint may now be stated as follows : given @xmath0 agents @xmath58 , @xmath108 , and an inter - agent constraint @xmath109 , construct a nonblocking cm set @xmath110 , where @xmath111 is for @xmath58 , such that @xmath112 is equal to the supremal controllable sublanguage @xcite of @xmath113 .",
    "theorem [ th - mc - pro-1 ] addresses the fundamental problem of multiple agents coordinating to respect one constraint .",
    "it is expressed in terms of the concepts of language controllability ( definition [ def - controllabellanguage ] ) and language observability ( definition [ def - observablelanguage ] ) .",
    "[ th - mc - pro-1 ] given @xmath70 agent automata @xmath58 , @xmath108 , with @xmath75 for @xmath76 .",
    "let @xmath114 , @xmath115 and @xmath116 .",
    "then , there exists a cm set @xmath117 , where @xmath111 is for @xmath58 , such that @xmath118 , @xmath119 and @xmath120 , if and only if @xmath121 is coordinable w.r.t @xmath41 and @xmath122 , namely , @xmath121 is controllable w.r.t @xmath41 and @xmath123 and @xmath121 is observable w.r.t @xmath41 and @xmath124 for all @xmath108 .",
    "theorem [ th - mc - pro-1 ] follows from the fact that supervision and multiagent coordination are mathematically equivalent , as established and discussed in @xcite .",
    "importantly , in theorem [ th - mc - pro-1 ] , @xmath122 constitutes the system communication set , which is a union of local event subsets to be communicated to each agent .",
    "as explained in @xcite , unlike supervisory control , the observable events for a receiving agent ( or events to be communicated to the agent when they occur ) are not pre - determined but computed with the aim of minimizing communication , and therefore can be different for a different inter - agent constraint .",
    "_ @xcite : _ [ def - controllabellanguage ] @xmath125 is said to be _ controllable _ with respect to ( w.r.t ) @xmath41 and @xmath126 ( or just controllable if @xmath126 is understood ) if @xmath127 @xmath128 $ ] .    in other words , @xmath121 is controllable provided no @xmath54-string which is already a prefix of some string in @xmath121 , that when followed by an uncontrollable event in @xmath129 , would exit from @xmath130 .",
    "it has been shown that the _ supremal controllable sublanguage _ @xcite of @xmath121 w.r.t @xmath41 and @xmath126 exists , and is equal to @xmath121 if it is controllable .",
    "for an automaton @xmath109 , the @xmath131 procedure @xcite , which computes a nonblocking automaton @xmath132 such that @xmath133 is the supremal controllable sublanguage of @xmath113 , can be implemented with polynomial time complexity @xcite .",
    "_ @xcite : _ [ def - observablelanguage ] @xmath134 is said to be _",
    "w.r.t @xmath41 and @xmath135 ( or just observable if @xmath135 is understood ) if @xmath136 for which @xmath137 , the following two conditions are satisfied : ( 1 ) @xmath138 $ ] , and ( 2 ) @xmath139 \\rightarrow s^\\prime \\in k$ ] .",
    "the above conditions ensure that @xmath140 provides a sufficient view for an observer to determine all necessary control and marking actions . taken together",
    ", that @xmath121 is coordinable w.r.t @xmath41 and @xmath122 means that ( i ) if each agent coordinates properly ( by appropriately enabling and disabling its own controllable events ) , then the coordinated system behavior will conform to @xmath121 , and ( ii ) @xmath58 has sufficient information for determining its coordinating actions ( that ensure the conformance of the coordinated system behavior to @xmath121 ) .",
    "in distributed multiagent systems , there are often multiple distributed inter - agent constraints , each restricting a group of interacting agents . to specify the relevance relationships of distributed constraints among these agents",
    ", we define a formalism called the distributed constraint specification network ( dcsn ) .",
    "the dcsn allows a human designer to organize and interconnect the agents and their distributed constraints in a networking structure that , in our opinion , comprehensibly shows who needs to coordinate with whom over what constraints  .",
    "[ ch - networkedparti - def - dcsn ] let @xmath70 , @xmath141 . a distributed constraint specification network ( dcsn )",
    "@xmath142 is a tuple @xmath143 , where @xmath144 is an agent set of size @xmath0 and @xmath145 is an inter - agent constraint set of size @xmath1 , such that @xmath146 .",
    "each @xmath147 in a dcsn @xmath142 , where @xmath2 is the constraint index , is said to be a relevant constraint for agents in the group @xmath148 . without loss of generality , assume henceforth that @xmath149 , i.e. , every agent in @xmath81 is in @xmath150 for some @xmath2 , and so every agent needs to coordinate .",
    "then a dcsn can be redefined as @xmath151 .",
    "[ ch - networkedparti - def - subnet ] an element @xmath152 of @xmath142 is called a basic subnet of @xmath142 ; and a non - empty @xmath153 consisting of @xmath154 basic subnets is called a @xmath3-constraint subnet of @xmath142 with constraint subset @xmath155 . where the constraint subset is arbitrary , a @xmath3-constraint subnet is simply denoted by @xmath156 .",
    "by definition [ ch - networkedparti - def - subnet ] , a subnet of a dcsn is also a dcsn . intuitively , a dcsn is a formalism that represents interconnections among agents and constraints , associating every agent with its relevant inter - agent constraints . under the interconnections ,",
    "an inter - agent constraint induces a group of agents that it is relevant for .",
    "it is then clear that the agents in the agent group need to coordinate to satisfy the constraint .",
    "a dcsn can be graphically represented by an undirected hyper - graph with agents represented by rectangular nodes , and each constraint relevant for an agent group by an oval hyper - edge with arcs connecting it to all the agents in the group . through its graphical representation which is intuitively clear and easy to understand , a dcsn is designer comprehensible for modeling the inter - agent constraint relationships among agents , as the following example will demonstrate .    throughout this paper",
    ", we shall use a simple manufacturing transfer line example [ fig .",
    "[ ch - networkedparti - fig - overall ] ] to illustrate our theoretical development .",
    "the system under study consists of three agents @xmath61 , @xmath62 and @xmath157 [ figs .",
    "[ ch - networkedparti - fig - a1][ch - networkedparti - fig - a3 ] ] , and four constraints @xmath158 , @xmath159 , @xmath160 and @xmath161 [ figs .",
    "[ ch - networkedparti - fig - e1][ch - networkedparti - fig - b2 ] ] , organized into a dcsn ( fig .",
    "[ ch - networkedparti - fig - nw ] ) .",
    "the system works as follows .",
    "@xmath61 and @xmath62 are producer agents that continually follow a production plan : acquire manufacturing equipment @xmath162 and @xmath163 in either order , produce a workpiece , return the equipment to their initial location , move to the buffers location , place the finished workpiece into the respective buffer , and finally return to the initial state for a new production cycle .",
    "@xmath157 is a delivery agent that continually takes a work piece from either buffer 1 or buffer 2 , processes , and delivers it to customers .",
    "we fix @xmath164 @xmath165 .",
    "the four constraints @xmath158 , @xmath159 , @xmath160 and @xmath161 are formulated to respectively ensure mutual exclusion of equipment use , and no overflow or underflow of buffers .",
    "the dcsn is composed of four basic subnets @xmath166 , @xmath167 , @xmath168 and @xmath169 . when depicted graphically , a nice feature of dcsn is that the constraint inter - connections between agents are explicitly shown for comprehensibility of design .",
    "for instance , in fig .",
    "[ ch - networkedparti - fig - nw ] , it is clear that @xmath61 would need to coordinate with @xmath62 for @xmath158 and @xmath159 , and with @xmath157 for @xmath160 .",
    "[ ch - networkedparti - prob - main ] given a dcsn @xmath170 of @xmath0 agents and @xmath1 inter - agent constraints , let @xmath171 and @xmath172 , where @xmath173 and @xmath147 .",
    "synthesize a set @xmath174 , where @xmath175 is a set of cm s for agent @xmath58 , such that @xmath176 , i.e. , the resulting coordinated system is nonblocking and satisfies every constraint in @xmath177 in a minimally restrictive manner .",
    "@xmath178 specifies the desired behavior , embodying all the event sequences that one wishes to impose on the system @xmath41 .",
    "a set @xmath179 of cm s is then said to satisfy ( every constraint in ) @xmath177 if @xmath180 .",
    "it can be easily shown that @xmath181 is controllable with respect to @xmath41 and @xmath129 .",
    "thus , for a set @xmath179 of cm s satisfying @xmath177 , @xmath182 . a cm set @xmath179 is then said to satisfy @xmath177 in a _ minimally interventive _",
    "manner if @xmath176 , implying that using such cm s , each agent @xmath58 would not unnecessarily disable its controllable events , unless not doing so could lead eventually to the violation of some inter - agent constraint in @xmath177 .      as discussed in the introduction , our compositional synthesis approach for a given dcsn can be described as follows .",
    "* - step 1 basic subnet synthesis : * synthesize for every agent a set of @xmath73-connected local cm s , one for each of the agent s relevant constraints .",
    "this step is performed by applying the algorithm developed in @xcite to every basic constraint subnet of the dcsn , i.e. , every subnet containing one inter - agent constraint .",
    "* - step 2 subnet composition *    * * step 2.1 conflict resolution plan generation : * generate a conflict resolution plan for the dcsn .",
    "this plan is a sequence of subnet composition operations .",
    "each operation entails designing deconflicting cm s for the agents of the subnets concerned , so as to ensure nonblockingness , and hence correctness , when the subnets are composed together .",
    "* * step 2.2 conflict resolution plan execution : * compose subnets with conflict resolution by following a precedence order of subnet composition operations in the plan generated in step 2.1 .",
    "this is to completely deconflict the local cm s synthesized in step 1 to ensure nonblockingness of the whole dcsn .    in the remaining of this paper ,",
    "we explain how these steps are formally carried out .",
    "this section fills in the cm synthesis details of our approach , presenting for step 1 , the local cm synthesis algorithm developed in @xcite , and for step 2.2 , how the cm solutions obtained of smaller subnets can be composed to obtain a nonblocking solution for the resultant bigger subnet .    note that , having pointed out in @xcite the mathematical relation between multiagent coordination and supervisory control , we are able to identify and utilize some mathematical results developed for supervisory control to support subnet composition synthesis , by carefully redefining these results in the notation of our des multiagent coordination framework . in the following ,",
    "the supporting results are proposition 1 , lemma 1 and lemma 2 , and in the spirit of scientific rigor , these are validated by proofs presented in @xcite under our framework notation . in the increasingly cross - disciplinary research environment , we find it necessary to adopt this approach , in order to develop a standalone treatment of our new distributed agent coordination theory that contributes conceptually clear des methods for multiagent coordination , without the distracting shadow of terminology from the mathematically related , but conceptually different field of supervisory control .      given a dcsn @xmath170 of @xmath0 agents and @xmath1 inter - agent constraints",
    ", we consider the problem of synthesizing cm s for some basic subnet @xmath152 of @xmath142 , @xmath183 . to fix notation , let @xmath184 and @xmath185 .",
    "we are interested in synthesizing , for each agent @xmath58 in the subnet , a cm @xmath186 such that @xmath187 .",
    "the pseudo - code of the synthesis algorithm @xcite based on theorem [ th - mc - pro-1 ] is notationally redefined as procedure @xmath188 for basic subnet synthesis .",
    "recall from @xcite that @xmath189 computes and returns a minimal cardinality communication event set that the agents @xmath58 s in the subnets must communicate among themselves , @xmath190 constructs for each agent @xmath58 , @xmath191 , a cm @xmath186 from @xmath192 and @xmath193 , and @xmath194 is a cm reduced procedure adapted from the supervisor reduction procedure @xcite , which can often return a greatly state - size reduced cm automaton for agent @xmath58 , achieving the same behavior of @xmath195 .",
    "[ ch - networkedparti - ex - basicnet ] to illustrate the use of procedure @xmath188 , we apply it to the manufacturing transfer line example and synthesize cm s for agents @xmath61 and @xmath62 to cooperatively satisfy @xmath158 . by step 1 of @xmath188 , we first compute @xmath196 , which has 40 states and 82 transitions . next , by step 2 , the minimal communication sets for @xmath61 and @xmath62 are computed : @xmath197 and @xmath198 . following step 3 ,",
    "cm s @xmath199 , @xmath200 , are computed by applying procedure @xmath190 on @xmath201 and @xmath202 .",
    "each of these cm s has 11 states and 19 transitions .",
    "finally , in step 4 , @xmath194 is applied to reduce the state size of @xmath203 and @xmath204 , arriving at the state - reduced cm s , each with 2 states and 11 transitions ( see fig .",
    "[ ch - networkedparti - fig - basicnetex1 ] ) .",
    "to elaborate , using these cm s means : @xmath61 must inform @xmath62 whenever it takes or returns the equipment @xmath162 , and @xmath62 reciprocates in turn .",
    "similarly , the cm s @xmath205 and @xmath206 synthesized using @xmath188 for agents @xmath61 and @xmath62 to cooperatively satisfy @xmath159 are given in fig .",
    "[ ch - networkedparti - fig - basicnetex2 ] .",
    "we now consider how the cm solutions of two basic subnets can be composed together to obtain a solution for the resultant two - constraint subnet .",
    "given @xmath207 , let @xmath208 .",
    "we are interested in synthesizing , for each agent @xmath58 , a set of cm s @xmath175 such that @xmath209 . without loss of generality ,",
    "we assume @xmath210 .",
    "otherwise , the two basic subnets contain no common agents and would only need to be synthesized individually .",
    "one simple approach is to reorganize @xmath211 into a new subnet consisting of one constraint @xmath212 for the agent group @xmath213 .",
    "the solution for this reorganized basic subnet can then be obtained by applying @xmath188 .",
    "this approach , however , has a major drawback : it suffers from exponential complexity of computing the product of all agents @xmath213 and constraints @xmath214 and @xmath215 . for a large number of agents ,",
    "this computation may become prohibitively expensive .",
    "our compositional approach entails designing deconflicting cm s for the agents concerned to resolve any conflict between @xmath216 and @xmath217 .",
    "the need for additional deconflicting cm s will be clear from the following example .",
    "[ ex - blocking ] for @xmath218 , we apply @xmath188 to compute cm s of agents @xmath61 and @xmath62 for @xmath219 and @xmath220 .",
    "the cm s @xmath203 and @xmath204 for @xmath221 , and @xmath205 and @xmath206 for @xmath222 , are shown in figs .",
    "[ ch - networkedparti - fig - basicnetex1 ] and [ ch - networkedparti - fig - basicnetex2 ] .",
    "however , using only these cm s does not guarantee that @xmath61 and @xmath62 will interact correctly for the subnet @xmath223 .",
    "in fact , the system of @xmath61 and @xmath62 interacting using these cm s contains blocking states .",
    "for instance , the event sequence @xmath224 , which is allowed to be executed by the cm s , leads to the blocking situation of each agent holding one equipment and waiting forever to acquire the equipment held by the other agent .",
    "thus , the local cm s individually constructed for @xmath216 and @xmath217 do not generally constitute a correct solution for @xmath211 .",
    "the reason is that , in general , @xmath225 ; and whenever this happens , the system of coordinating agents using only their cm s constructed for the individual basic subnets will contain blocking states .",
    "we say that @xmath216 and @xmath217 are nonconflicting if @xmath226 is nonblocking .",
    "otherwise , they are conflicting .",
    "being nonconflicting means no deconflicting cm s need to be additionally constructed .",
    "this motivates the development of a procedure of testing for the nonconflicting of @xmath216 and @xmath217 .",
    "the simplest way of doing so is to directly compute @xmath226 and check whether or not it is a nonblocking automaton .",
    "however , this approach is computationally inefficient since it can be shown to have the same complexity order as that of computing the product of all agents and constraints .",
    "lemma [ ch - networkedparti - lemma - nonconflicttest2 ] leads us to a more efficient approach to testing the nonconflict of @xmath216 and @xmath217 .",
    "this and the next lemmas are formulated in terms of the concepts of language observer and output control consistent ( occ ) projection @xcite .",
    "[ def - observerandocc ] _ observer and occ projection @xcite : _ given an automaton @xmath41 with @xmath227 , and @xmath228 .    1 .",
    "@xmath229 is said to be a @xmath55-observer if : @xmath230 , if @xmath231 is a prefix of @xmath232 then @xmath233 such that @xmath234 and @xmath235 .",
    "@xmath229 is said to be occ for @xmath54 if @xmath236 of the form @xmath237 , where @xmath10 is either @xmath9 or terminates with an event in @xmath7 , the following holds : @xmath238 and @xmath239 $ ] @xmath240 $ ] .    in words , definition",
    "[ def - observerandocc].1 asserts that whenever @xmath241 can be extended to a string in @xmath242 by catenating to it a string @xmath243 , the underlying string @xmath11 can also be extended to a string in @xmath55 by catenating to it a string @xmath244 with @xmath245 .",
    "thus , definition [ def - observerandocc].1 says that every string in the abstract model @xmath246 is realizable by the original model @xmath41 .    by definition [ def - observerandocc].2 , along every @xmath99 , in between every observable but uncontrollable event that exists and",
    "its nearest `` upstream '' observable event ( or otherwise the empty string prior to the `` starting '' event of the string ) is a string of uncontrollable and unobservable events .",
    "thus , if @xmath54 is interpreted as ( the behavior of ) an underlying system model and @xmath247 as ( the behavior of ) the abstracted system model , then , that @xmath229 is occ for @xmath54 characterizes the semantics that every uncontrollable event in the abstracted model can never be disabled and hence prevented from occurring by disabling controllable events in the underlying model .",
    "the abstracted model output @xmath247 is , in this sense , `` control consistent '' with the underlying model @xmath54 .",
    "[ ch - networkedparti - lemma - nonconflicttest2 ] let @xmath248 and define @xmath249 and @xmath250 as projections from @xmath251 and @xmath252 to @xmath253 , respectively . then",
    ", if @xmath249 is a @xmath254-observer and @xmath250 is a @xmath255-observer , two basic subnets @xmath216 and @xmath217 are nonconflicting if and only if @xmath256 is a nonblocking automaton .",
    "thus , under the stated sufficiency conditions in lemma [ ch - networkedparti - lemma - nonconflicttest2 ] , testing the nonconflict of@xmath216 and @xmath217 can be reduced to checking whether or not @xmath256 is nonblocking . this way",
    ", we only need to first compute @xmath256 instead of @xmath226 , which results in a computationally cheaper nonconflict test for two reasons .",
    "the first is that such automata @xmath257 and @xmath258 can be individually computed in polynomial time @xcite , and the second is that their state sizes are often smaller than those of @xmath259 and @xmath192 , respectively .    nevertheless , if @xmath216 and @xmath217 are conflicting ( due to blocking ) , we need to design additional deconflicting cm s for the agents concerned to resolve the conflicts between @xmath216 and @xmath217 .",
    "together with the local cm s synthesized for @xmath216 and @xmath217 , deconflicting cm s will constitute a correct solution for @xmath211 .",
    "essentially , deconflicting cm s remove blocking states from @xmath226 when used by the agents of subnet @xmath211 .    in designing deconflicting cm",
    "s for coordinating agents , our approach is to first synthesize an automaton as the basis for conflict resolution between two basic subnets , and then `` localize '' it to every agent as the agent s deconflicting cm if the agent shares some events with the conflict resolution ( automaton ) . formally , an automaton @xmath260 is said to be a conflict resolution for @xmath216 and @xmath217 if @xmath261 \\equiv sup^{\\{h , k\\}}$ ] .",
    "it can be shown that a conflict resolution for any two basic subnets always exists .",
    "indeed , @xmath260 can be simply computed as @xmath262 , where @xmath263 is a one - state automaton that generates and marks @xmath264 .",
    "however , similar to the problem of testing the nonconflict of two basic subnets discussed previously , computing @xmath260 as @xmath262 has the same order of complexity as that of @xmath265 , which is inefficient .    in what follows ,",
    "we present an efficient approach for computing a conflicting resolution ( automaton ) for two basic subnets ( lemma [ ch - networkedparti - thm - leifeng ] ) , and using which we propose a conflict resolution algorithm ( procedure @xmath266 ) .",
    "[ ch - networkedparti - thm - leifeng ] let @xmath248 and define @xmath249 and @xmath250 as projections from @xmath251 and @xmath252 to @xmath253 , respectively . then",
    ", if @xmath249 is a @xmath254-observer , @xmath250 is a @xmath255-observer , and @xmath267 , @xmath268 is occ for @xmath269 , then @xmath270 $ ] is a conflict resolution for @xmath216 and @xmath217 , where @xmath263 is a one - state automaton that generates @xmath271 as both the prefix - closed and marked languages .",
    "thus , @xmath260 can be computed as @xmath272 $ ] if all the conditions stated in lemma [ ch - networkedparti - thm - leifeng ] are satisfied .",
    "importantly , following this approach to compute a conflict resolution , instead of @xmath226 , we only need to compute the product @xmath256",
    ". since @xmath273 , @xmath274 , is a @xmath275-observer , the state size of @xmath276 is known to be often smaller than that of @xmath201 .    by lemma",
    "[ ch - networkedparti - thm - leifeng ] , a conflict resolution for @xmath216 and @xmath217 can be computed as follows : ( i ) initially , let @xmath277 ; ( ii ) next , enlarge @xmath278 to @xmath253 so that all the stated conditions in lemma [ ch - networkedparti - thm - leifeng ] are satisfied ; ( iii ) then , construct @xmath263 as a one - state automaton with its only state being both an initial state and a marker state , and with every event in @xmath279 self - looped at that state .",
    "thus , @xmath263 generates @xmath280 which is both its prefix - closed and marked languages ; ( iv ) finally , compute @xmath281 $ ] .",
    "note that the smaller the cardinality of the set @xmath253 returned by step ( ii ) is , the more economical the computation would be for step ( iv ) .",
    "the problem of finding a minimal cardinality event set @xmath253 satisfying every condition in lemma [ ch - networkedparti - thm - leifeng ] has proven to be np - hard @xcite . however , a polynomial time algorithm exists to synthesize such an event set @xmath253 of reasonably small size @xcite .    from the foregoing discussion ,",
    "procedure @xmath266 is developed to design deconflicting cm s for @xmath216 and @xmath217 .",
    "it first checks if @xmath216 and @xmath217 are nonconflicting by applying lemma [ ch - networkedparti - lemma - nonconflicttest2 ] ( step 1 ) .",
    "if they are , then no deconflicting cm is needed .",
    "otherwise , lemma [ ch - networkedparti - thm - leifeng ] is applied to compute a conflict resolution @xmath260 for the two subnets ( step 2 ) .",
    "next , in step 3 , the procedure determines whether or not an agent @xmath58 needs to take part in resolving the conflict between the subnets , i.e. , if @xmath282 .",
    "if so , it computes for @xmath58 a deconflicting cm @xmath283 .",
    "note that such a deconflicting cm could simply be taken as @xmath260 .",
    "however , to achieve economy of implementation , it uses @xmath194 to obtain a reduced cm @xmath284 . in the worst case , @xmath285 and @xmath266 has to compute the synchronous product of all agents and constraints in the two subnets .",
    "it therefore has exponential complexity .",
    "however , @xmath266 is often efficient in practice since @xmath253 is often a strict subset of @xmath286 .",
    "* output : * a deconflicting cm @xmath283 for agent @xmath58 to resolve the conflict between @xmath216 and @xmath217    [ ch - networkedparti - lemma - deconflictbasicsubnet ] for @xmath287 , let @xmath283 be the deconflicting cm computed for agent @xmath58 in step 3 of @xmath266 , or trivially a one - state automaton that generates and marks @xmath288 if no deconflicting cm is needed for @xmath58 , either because @xmath216 and @xmath217 are nonconflicting or because @xmath289 . then , @xmath290 .",
    "theorem [ ch - networkedparti - thm - subnet ] formally summarizes how we can compose ( the solution cm s of ) two basic subnets @xmath216 and @xmath217 to form ( a cm solution set for ) the two - constraint subnet @xmath211 .",
    "[ ch - networkedparti - thm - subnet ] for @xmath287 , let @xmath175 be the cm set for agent @xmath58 computed as follows : ( i ) @xmath175 includes every cm computed for @xmath58 when applying @xmath188 for @xmath216 and @xmath217 , and ( ii ) @xmath175 includes every deconflicting cm computed for @xmath58 when applying @xmath266 to resolve the conflict that exists between @xmath216 and @xmath217 .",
    "then @xmath209 , where @xmath291 is a synchronous product of all cm s in @xmath175 .      with slight modifications ,",
    "the theoretical results presented in the previous section can be generalized to composing two subnets @xmath292 and @xmath293 of sizes @xmath294 , to form a larger @xmath295-constraint subnet . in doing so , we follow the same composition logic , i.e. , we first synthesize the cm s for each individual subnet , and then design , if necessary , deconflicting cm s for the agents to resolve the conflict between the two subnets . a procedure called @xmath296 for @xmath292 and",
    "@xmath293 is developed .",
    "it is almost identical to but extends @xmath266 based on a straightforward generalization of lemma [ ch - networkedparti - thm - leifeng ] .",
    "this section fills in step 2.1 of our compositional synthesis approach , presenting the formalism and algorithms for the representation and generation conflict resolution plans .",
    "[ ch - networkedpartii - def - subnetdecomposition ] given a dcsn @xmath142 consisting of @xmath1 basic subnets @xmath221 , ... @xmath297 , a subnet - decomposition @xmath298 is a set of subnets of @xmath142 such that : 1 ) every element subnet of @xmath298 is constraint - connected , 2 ) every basic subnet of @xmath142 is contained in one of the elements of @xmath298 , and 3 ) there is no basic subnet of @xmath142 that is contained in two different elements of @xmath298 .",
    "it follows that a conflict resolution plan for @xmath142 is a sequence of transitions of subnet - decompositions , starting with @xmath299 and ending with @xmath300 .",
    "@xmath301 characterizes the situation in which all the basic subnets are `` disconnected '' from each other , and @xmath302 characterizes the situation where all the basic subnets are already deconflicted together to form the complete dcsn @xmath142 .",
    "each transition from one subnet - decomposition to another characterizes an operation of deconflicting ( the cm solutions of ) subnets to form ( a cm solution of ) a larger subnet .",
    "a conflict resolution plan should only include transitions that correspond to resolving conflicts of subnets that contain common agents , since subnets that contain no common agents are trivially nonconflicting . generating a conflict resolution plan for @xmath142 is then equivalent to searching for a path of subnet - decomposition transitions from @xmath301 to @xmath302 .",
    "observe that a conflict resolution planning sequence for a dcsn @xmath142 is a reversal of a successive decomposition , starting with @xmath142 , of constraint - connected component subnets until only basic subnets remain .",
    "this suggests that the forward search problem of generating conflict resolution plans for a dcsn @xmath142 can be addressed as a backward search problem of successively decomposing @xmath142 into pairs of constraint - connected component subnets until only basic subnets are left .",
    "the space of all possible conflict resolution plans for @xmath142 can therefore be generated by enumerating all possible ways of successively decomposing @xmath142 this way .    because there are many subnet - decompositions that can be made from the same dcsn , the branching factor from the initial state @xmath301 to the goal state @xmath302 is greater than that from @xmath302 to @xmath301 .",
    "a backward search is , therefore , often more efficient than a forward search for the conflict resolution planning problem .    and/or graphs @xcite are suitable in representing decomposable problems .",
    "by recognizing that conflict resolution plans for a dcsn can be generated by enumerating all possible ways of successively decomposing it , definition [ ch - networkedpartii - def - andorgraph ] proposes a representation using and/or graphs for the conflict resolution plans of a dcsn .",
    "[ ch - networkedpartii - def - andorgraph ] the and/or graph of conflict resolution plans for a dcsn @xmath142 is a hyper - graph @xmath303 , where    1 .",
    "@xmath304 is the set of nodes of @xmath305 and defined as @xmath306 .",
    "@xmath307 is the set of hyper - edges of @xmath305 and defined as @xmath308 .",
    "the nodes in the and/or graph @xmath305 represent constraint - connected subnets of @xmath142 , and each of the hyper - edges is a pair @xmath309 denoting the decomposition of subnet @xmath310 into two component subnets @xmath311 and @xmath312 , or equivalently , the composition of @xmath311 and @xmath312 into @xmath310 . a hyper - edge points from a node representing a subnet to two nodes representing the component subnets .",
    "the node that represents the complete dcsn @xmath142 is referred to as the root node and denoted by @xmath313 , and the nodes representing basic subnets of @xmath142 are referred to as the leaf nodes .",
    "the set of all leaf nodes of @xmath305 is @xmath314 , and is denoted by @xmath315 .    in what follows ,",
    "a conflict resolution plan for @xmath142 is represented by a tree in @xmath305 that starts at @xmath313 and terminates at @xmath315 .",
    "formally , a tree @xmath316 in the and/or graph @xmath303 , starting at a node @xmath317 and terminating at a set of nodes @xmath318 , can be described recursively as follows .    *",
    "if @xmath319 , @xmath316 contains only one node @xmath320 and no edge , and we write @xmath321 . *",
    "otherwise , @xmath316 contains the node @xmath320 , an edge @xmath322 , and the nodes and edges of two trees @xmath323 and @xmath324 .",
    "each tree @xmath325 , @xmath326 , starts from one of @xmath320 s two successors , @xmath327 , and terminates at some @xmath328 , where @xmath329 and @xmath330 are disjoint and @xmath331 . in this case",
    ", we write @xmath332 .",
    "the set of all trees starting from @xmath320 and terminating at @xmath333 is denoted by @xmath334 . if @xmath335 , @xmath320 is called the root node of @xmath316 and a node in @xmath333 called a terminal node of @xmath316 .",
    "whenever the set of terminal nodes is arbitrary , the set of trees starting from a node @xmath320 is simply denoted by @xmath336 , and the set of all trees of @xmath305 is denoted by @xmath337 .",
    "a tree in @xmath338 is said to be complete . formally then , a complete tree is a conflict resolution plan .",
    "any tree in @xmath305 whose root node is not @xmath313 or whose leaf nodes are not all in @xmath315 is called a non - complete tree .",
    "a non - complete tree is a subgraph of one or more complete trees .",
    "a non - complete tree whose root node is @xmath313 is called a partial tree . in what follows ,",
    "a tree in @xmath339 is a partial conflict resolution plan .",
    "we now present an algorithm for generating the and/or graph representation of conflict resolution plans .",
    "our algorithm takes as input a dcsn and generates as output the and/or graph representation of conflict resolution plans for the dcsn .",
    "the basic idea of our algorithm is to first enumerate all possible decompositions of a dcsn @xmath142 into two constraint - connected component subnets .",
    "each such decomposition corresponds to an edge of the and/or graph @xmath305 connecting the root node representing @xmath142 to two nodes , with each representing a component subnet .",
    "the same decomposition process is then repeated for each of the component subnets , which are component dcsn s , until only basic subnets are left .",
    "recursive decomposition lends itself to straightforward and/or graph construction of all conflict resolution plans .    to facilitate the systematic enumeration of all possible decompositions of a subnet in a dcsn , we first convert the dcsn to a constraint relational network ( crn ) .",
    "in essence , the crn of a dcsn , formally defined in definition [ ch - networkedproblemii - def - crn ] below , is a constraint relational model which explicitly relates every pair of inter - agent constraints whose induced agent groups overlap .",
    "[ ch - networkedproblemii - def - crn ] the constraint relational network ( crn ) @xmath340 of a @xmath3-constraint subnet @xmath341 is a tuple @xmath342 , where @xmath343 is the constraint set of size @xmath3 in @xmath156 and @xmath344 is a relation over @xmath345 , such that @xmath346 $ ] .    by definition",
    "[ ch - networkedproblemii - def - crn ] , two constraints @xmath215 and @xmath214 are related if their induced agent groups are overlapping , i.e. , @xmath347 , meaning that there is at least one agent @xmath58 , where @xmath348 , that belongs to both the basic subnets @xmath349 and @xmath350 .",
    "in other words , @xmath58 has to coordinate on @xmath215 with some agents , and on @xmath214 with some other agents . as already discussed in section [ sect - twobasicnets ] , conflicts between ( the agents in ) such a pair of subnets may arise , and hence",
    ", there is a need to check for and resolve any conflict when composing the subnets .",
    "graphically , a crn can be represented by an undirected graph with constraints represented by nodes , and the relation between two agent - related constraints @xmath215 and @xmath214 by an edge that connects the corresponding two nodes and is labeled with the agent group overlap between the subnets @xmath349 and @xmath350 .",
    "observe that enumerating all possible decompositions of a subnet @xmath156 into two constraint - connected subnets can be done by enumerating all possible cut - sets , a cut - set @xcite is a set of edges @xmath351 such that the removal of @xmath352 from @xmath263 disconnects @xmath263 and the removal of any strict subset of @xmath352 does not disconnect @xmath263 .",
    "since a cut - set @xmath352 always `` cuts '' @xmath263 into two parts , it may be conveniently represented as @xmath353 , where @xmath354 and @xmath355 are the sets of vertices belonging to these two parts .",
    "let @xmath356 be a spanning tree of @xmath263 .",
    "then a `` fundamental '' cut - set of @xmath263 is defined as a cut - set that contains exactly one branch of @xmath356 . defining the ring sum operation @xmath357 of two arbitrary sets @xmath41 and @xmath358 as @xmath359",
    ", it has been shown that any cut - set of @xmath263 has the form @xmath360 that is not a union of edge - disjoint cut - sets , where @xmath361 is arbitrary and @xmath362 are different fundamental cut - sets of @xmath263 .",
    "thus , a formal approach to generate all cut - sets of @xmath263 is to ( i ) construct a spanning tree , ( ii ) generate the set of fundamental cut - sets for the spanning tree , and then ( iii ) properly combine these fundamental cut - sets to get a new cut - set .",
    "] of its crn @xmath340 .",
    "specifically , consider a cut - set @xmath363 that decomposes @xmath340 into two parts , where @xmath364 and @xmath365 are the two disjoint sets of vertices of @xmath340 belonging to these two parts .",
    "write @xmath366 and @xmath367 to denote respectively that @xmath368 and @xmath369 are the component subnets induced by @xmath364 and @xmath365 , namely @xmath370 and @xmath371",
    ". then @xmath368 and @xmath369 are two constraint - connected component subnets decomposed from @xmath156 .",
    "conversely , any decomposition of @xmath156 into two constraint - connected component subnets @xmath368 and @xmath369 corresponds to a cut - set @xmath363 of @xmath340 , with @xmath366 and @xmath367 .    from the foregoing observation ,",
    "procedure @xmath372 details the steps to generate an and/or graph representation of conflict resolution plans for a given dcsn @xmath142 .",
    "if @xmath142 is a basic subnet , the procedure simply returns an empty and/or graph ( step 1 ) , otherwise it converts @xmath142 to the a crn @xmath373 , and computes @xmath374 as the set of all cut - sets of @xmath373 ( step 2 ) . in step 3",
    ", the procedure uses the cut - sets to recursively construct the and/or graph representation of conflict resolution plans .",
    "* output : * an and/or graph @xmath303 of conflict resolution plans for @xmath142 , initialized with @xmath375 and @xmath376    based on the foregoing discussion , @xmath372 is correct and complete in the sense that it correctly generates , for a dcsn @xmath142 , an and/or graph that completely encompasses all possible conflict resolution plans for @xmath142 .",
    "the amount of computation involved depends on the number of basic subnets of the input dcsn and its connectivity structure , which both affect the number of cut - sets of the crn of @xmath142 and that of the crn of each successively decomposed subnet .",
    "a complexity evaluation of the algorithm has been conducted , which shows that in general , the more basic subnets and the more `` connected '' they are in an input dcsn , the higher the amount of computation incurred .",
    "presented elsewhere @xcite , a complexity evaluation of the algorithm has been conducted , which shows that in general , the more basic subnets and the more `` connected '' they are in an input dcsn , the higher the amount of computation incurred .",
    "given a dcsn with @xmath1 basic subnets , the worst - case complexity of @xmath377 from @xmath378 to @xmath379 .    in practice ,",
    "based on some criterion , the cut - sets may be subjected to some acceptance tests in step 3a , and only accepted cut - sets are passed on to steps 3b and 3c .",
    "such tests can be developed to generate conflict resolution plans which must also satisfy some problem - dependent conditions .",
    "for example , a particular multiagent coordination system may contain some subnets which need to be able to run standalone from time to time .",
    "to support this standalone operation , we need to guarantee multiagent nonblocking reconfigurability for every standalone subnet ; in other words , at the outset , we need to guarantee that agents in a standalone subnet can always maintain nonblockingness of their subnet s coordination tasks during runtime , after a system network reconfiguration of simply unloading all other agent and cm models not relevant to the subnet .",
    "this has significant implications in generating and selecting conflict resolution plans .",
    "given a dcsn containing standalone subnets , not all of which are basic , we would need an and/or graph plan representation that must include only decompositions in which each of these subnets is wholly contained in a child node of the graph , whenever it is part of a bigger subnet in the parent node . executing such plans forward",
    "can then guarantee multiagent nonblocking reconfigurability .",
    "a simple cut - set acceptance test can be developed to generate such and/or graph plans .        to select an optimal conflict resolution plan for a given dcsn @xmath142 , in addition to the ability to traverse the space of all possible conflict resolution plans provided by @xmath305 ,",
    "there is a need for an optimization metric to access , or rank , the quality of individual plans .    since a conflict resolution plan is a tree in @xmath305 that starts from @xmath380 and terminates at @xmath381 , an optimization metric for plan selection is simply a real function @xmath382 , where @xmath383 is the set of real numbers .",
    "we assume a minimization problem , and interpret a better conflict resolution plan as a plan with lower @xmath384-value .",
    "thus if @xmath323 , @xmath385 with @xmath386 , then the conflict resolution plan @xmath323 is preferable to @xmath324 .    selecting an optimal plan can be made algorithmically using a heuristic defined on the set of partial trees @xmath338 in @xmath305 for a given optimization metric .",
    "[ ch - networkedpartii - def - heuristic ] a heuristic ( for an optimization metric @xmath382 ) is a real function @xmath387 such that @xmath388 .",
    "given a partial tree @xmath389 , the heuristic value @xmath390 shall be used in our algorithm as an estimation of the @xmath384-value of the best conflict resolution plan @xmath391 that encompasses the partial plan @xmath392 .",
    "heuristic @xmath393 is said to be admissible if the @xmath393-value of an arbitrary partial tree always underestimates the @xmath384-value of any complete tree encompassing it , as formalized in definition [ ch - networkedpartii - def - admissible ] .",
    "[ ch - networkedpartii - def - admissible ] a heuristic @xmath394 is said to be admissible ( for an optimization metric @xmath382 ) if , for an arbitrary partial @xmath395 and every complete tree @xmath391 for which @xmath392 is a subgraph of , @xmath396 .",
    "we can now formally present our plan selection algorithm .",
    "given an admissible heuristic @xmath393 for some optimization metric @xmath384 , procedure @xmath397 details the steps to select an optimal conflict resolution plan for a dcsn @xmath142 from the and/or graph @xmath305 .",
    "the procedure returns a complete tree of @xmath305 with the lowest @xmath384-value , and is thus an optimal conflict resolution plan for @xmath142 .    *",
    "input : * and/or graph of conflict resolution plans @xmath303 for dcsn @xmath142 and an admissible heuristic @xmath394    * output : * a tree in @xmath338 with the lowest @xmath384-value , which is an optimal conflict resolution plan for @xmath142    @xmath397 maintains a priority queue @xmath398 that contains partial trees of @xmath305 , ranked by their heuristic @xmath393-value . in steps 1 and 2 , a partial tree that contains only the root node @xmath313 is created and put into @xmath398 . each time through the while loop of step 3 , a tree with the lowest @xmath393-value is extracted from @xmath398 ( step 3a ) , and is returned as a solution if it is a complete tree ( step 3b ) , or otherwise expanded ( steps 3c and 3d ) .",
    "the expanded trees are then put into @xmath398 for further examination ( step 3d2 ) .",
    "[ ch - networkedpartii - prop - heuristic ] if @xmath393 is an admissible heuristic for @xmath384 , then @xmath397 returns a complete tree in @xmath338 with the lowest @xmath384-value .",
    "we now introduce a criterion to evaluate and select conflict resolution plans .",
    "the criterion is to maximize the simultaneous execution of operations for subnet composition .",
    "an optimization metric to rank the plans quantitatively based on this criterion is formulated , and an admissible heuristic of this metric is designed for @xmath397 .",
    "importantly , the selected plan provides the opportunity to maximize the parallel use of available computing resources in simultaneous subnet compositions , and can often be executed in minimal total execution time .    over a conflict resolution planning tree in the and/or graph @xmath305 , the measure of simultaneity of execution supported in the operations of subnet composition",
    "can be quantified by the depth of the tree , defined recursively as follows .",
    "@xmath399 if @xmath321 , and @xmath400 if @xmath332 .",
    "using this measure , the optimization metric is defined as : @xmath401 such that @xmath402 , where @xmath403 is the set of natural numbers .",
    "we now design an admissible heuristic @xmath404 for @xmath405 . recall that the set of nodes of @xmath305 is @xmath306 , namely , each node of @xmath305 represents a constraint - connected subnet of @xmath142 . for each @xmath406 , let @xmath407 denote the number of basic subnets in the constraint - connected subnet represented by node @xmath0 .",
    "let @xmath408 be a real function on @xmath337 , defined recursively as follows : @xmath409 if @xmath321 , and @xmath410 if @xmath332 .",
    "then an admissible heuristic @xmath404 for @xmath405 can be specified as @xmath411 such that @xmath412 .",
    "[ ch - networkedpartii - sect - lemmaadmissible ] @xmath404 is an admissible heuristic for @xmath405 .",
    "thus , by lemma [ ch - networkedpartii - sect - lemmaadmissible ] , heuristic @xmath404 can be incorporated into @xmath397 for the selection of a plan with the lowest @xmath405 value .",
    "we now provide a solution for the manufacturing example . following step 1 of our approach presented",
    ", we use @xmath188 to design three local cm s for each of the agents @xmath61 and @xmath62 , and two cm s for agent @xmath157 .",
    "each of these local cm s corresponds to a relevant constraint of the agents .    in step 2.1 , we need to generate a conflict resolution plan to completely and correctly composing together the subnets of the dcsn presented in fig .",
    "[ ch - networkedparti - fig - nw ] .",
    "the crn of this dcsn is shown in fig .",
    "[ ch - networkedpartii - fig - crn ] .",
    "we apply @xmath372 to decompose the crn and generate the and/or graph plan shown in fig .",
    "[ ch - networkedpartii - fig - generatedandorgraph ] .",
    "each node in that graph represents a subnet of the dcsn .",
    "the root node represents the dcsn @xmath142 .",
    "there are six hyper - edges leaving that node , each of those represents one way the dcsn can be decomposed and points to the two nodes representing the resulting subnets .",
    "similarly , the other nodes in the graph have a leaving hyper - edge for each possible way in which the subnets they represent can be decomposed .",
    "the and/or graph plans in fig .",
    "[ ch - networkedpartii - fig - partialandorgraph ] ] are partially formed after the initial recursion , where all cut - sets for the crn of dcsn @xmath142 are computed @xcite based on fundamental cut - sets derived from a spanning tree highlighted over the crn [ fig .",
    "[ ch - networkedpartii - fig - crn ] ] . in every recursion , each cut - set stored in @xmath374 is a decomposition of the given subnet into a pair of subnets .",
    "figs.[ch - networkedpartii - fig - tree1]-[ch - networkedpartii - fig - tree3 ] show three conflict resolution plan trees that are extracted from the and/or graph",
    ". one important feature of the and/or graph tree representation of conflict resolution plans is that it shows explicitly the possibility of executing deconflicting operations in parallel .",
    "for example , while there are three deconflicting operations required by the conflict resolution plan represented by the tree in fig .",
    "[ ch - networkedpartii - fig - tree1 ] , the first two operations , for resolving the conflicts between @xmath221 and @xmath222 , and @xmath413 and @xmath414 , can be performed simultaneously .",
    "therefore , if there are two computational resources that can operate in parallel , the resolution plan can be completed in two sequential steps , with the first step to simultaneously deconflict between @xmath221 and @xmath222 , and @xmath413 and @xmath414 , and the second step to deconflict between @xmath223 and @xmath415 .",
    "in contrast , each of the other two trees in figs .",
    "[ ch - networkedpartii - fig - tree2]-[ch - networkedpartii - fig - tree3 ] also has three operations .",
    "however , these operations have to be performed sequentially .",
    "thus , no matter how many computational resources we have , each of these plans requires three sequential steps to complete .    to select an optimal conflict resolution plan from the generated and/or graph",
    ", we apply @xmath397 using the heuristic @xmath404 , namely , one that allows maximal simultaneity in the execution of subnet composition operations .",
    "the selected conflict resolution plan is the one shown in fig .",
    "[ ch - networkedpartii - fig - tree1 ] . following this plan and using @xmath416 to compose subnets with conflict resolution ,",
    "the complete solution is found and shown in fig .",
    "[ ch - networkedparti - fig - completesolution ] .",
    "this paper has introduced and addressed a novel multiagent coordination problem in a discrete - event formal languages and finite automata framework .",
    "the presented work is built on the results of @xcite , generalizing the theory of multiagent coordination for a multi - constraint network of distributed agents .    among related",
    "work under the same discrete - event paradigm , we have earlier discussed the mathematical equivalence and conceptual difference between our work on discrete - event multiagent coordination and the well - established supervisory control of des s framework in our previous papers @xcite .",
    "elsewhere @xcite , we have also discussed our discrete - event multiagent coordination framework in relation to the distributed constraint satisfaction problem ( dcsp ) @xcite , multiagent planning @xcite and the partially observable markov decision process ( pomdp ) coordination framework @xcite .    in a recent independent and emerging work @xcite , a different problem called supervisor localization is presented . for a des @xmath41 consisting of @xmath70 interacting local components @xmath58 , @xmath417 , with pair - wise disjoint event sets , the localization problem focuses on decomposing ( or localizing ) a global supervisor @xmath132 of @xmath41 into a set of local supervisors @xmath418 , with @xmath111 controlling @xmath58 , while preserving the control behavior of @xmath132 over @xmath41 .",
    "although communication minimization is not explicitly considered in the supervisor localization solution , the problem can be shown to be equivalent to our multiagent coordination problem , i.e. , problem [ ch - networkedparti - prob - main ] . however , unlike the supervisor localization framework @xcite , our multiagent framework clearly distinguishes the related but different concepts of control and coordination by the cartesian and synchronous product operators @xcite , respectively . in distinguishing control and coordination ,",
    "the mathematical equivalence between coordination of localized supervisors and of agents is established and discussed in ( * ? ? ?",
    "* corollary 1 ) .",
    "more importantly , in our opinion , this conceptual difference brings into sharper focus the essence of our new coordination problem , namely , designing built - in cm s - not supervisors - for autonomous agents , and leads us to not prejudging that the only means of cm synthesis is by first constructing supervisors for a multiagent system .",
    "in addition , we note that the intent of our framework is to naturally model active agents coordinating through their cm s , whereas that of the framework @xcite is apparently to model passive agents being controlled by their interacting localized supervisors .",
    "finally , we note that the multiagent conflict resolution planning problem has not been addressed in the supervisor localization framework @xcite . in this paper , perhaps for the first time , we have proposed an efficient representation of conflict resolution plans for discrete - event agents using and/or graphs , and presented an algorithm to automatically generate an and/or graph representation of conflict resolution plans from a dcsn using cut - set theory @xcite .",
    "importantly , due to the mathematical equivalence between control and coordination , it is envisaged that our new results on multiagent conflict resolution planning can be adapted in the supervisor localization framework @xcite for systematic and efficient synthesis of localized supervisors .",
    "we have @xmath419 , @xmath185 and @xmath248 .",
    "suppose @xmath249 is a @xmath254-observer and @xmath250 is a @xmath255-observer . then abstracting a theoretical result proved in @xcite , it follows that @xmath226 is nonblocking if and only if @xmath256 is nonblocking . in other words",
    ", @xmath216 and @xmath217 are nonconflicting if and only if @xmath256 is a nonblocking automaton .",
    "since the event sets of the agents in @xmath420 are pair - wise disjoint , @xmath419 , @xmath185 and @xmath248 , it follows from a theoretical result proved in @xcite that if @xmath249 is a @xmath254-observer , @xmath250 is a @xmath255-observer and @xmath421 @xmath268 is occ for @xmath269 , then @xmath272 \\parallel sup^h \\parallel sup^k$ ] @xmath422 , namely , @xmath272 $ ] is a conflict resolution for @xmath216 and @xmath217 .",
    "if the two basic subnets @xmath216 and @xmath217 are nonconflicting , the lemma is trivially true . otherwise , by step 3 of @xmath266 , for every agent @xmath58 with @xmath282",
    ", we have @xmath423 . recall from @xcite that @xmath194 is a procedure that , given @xmath260 and @xmath58 , often returns a greatly state - size reduced cm automaton for agent @xmath58 achieving the same behavior of @xmath424 .",
    "it follows that @xmath425 for other agents that do no share events with @xmath260 , essentially no deconflicting cm is needed .",
    "therefore , @xmath426      if @xmath216 and @xmath217 are nonconflicting , the theorem is trivially true .",
    "otherwise , by lemma [ ch - networkedparti - lemma - deconflictbasicsubnet ] , we have @xmath427 where @xmath260 is a conflict resolution for @xmath216 and @xmath217 computed in step 2 of @xmath266 . since , @xmath428",
    ", it follows that @xmath429 hence the theorem .",
    "let the lowest @xmath384-value be @xmath430 . by contradiction ,",
    "assume that @xmath397 returns @xmath316 with @xmath431 .",
    "since @xmath391 , we also have @xmath432 .",
    "consider a partial tree @xmath392 that is a subgraph of an optimal plan @xmath433 with @xmath434 and that is contained in @xmath398 before @xmath316 is extracted from @xmath398 ( there must always be such trees since an optimal solution always exists ) .",
    "then , since @xmath393 is an admissible heuristic , we have @xmath435 .",
    "we now have @xmath436 . since in step 3a",
    ", @xmath397 always extracts from @xmath398 a tree with the lowest @xmath393-value , it follows that @xmath316 will not be extracted from @xmath398 before @xmath392 is . and",
    "when @xmath392 is extracted from @xmath398 , it will be expanded in steps 3c and 3d , and eventually becomes @xmath437 before @xmath316 can ever be extracted from @xmath398 .",
    "the reason is that @xmath438 and @xmath393 is an admissible heuristic , meaning that any subgraph of @xmath437 that is expanded from @xmath392 in steps 3c and 3d will have its @xmath393-value smaller than that of @xmath316 and therefore , extracted from @xmath398 before @xmath316 . finally ,",
    "if @xmath437 is ever be extracted from @xmath398 in step 3a , it will be returned as a solution by @xmath397 . in other words ,",
    "@xmath316 will never be returned by @xmath397 , contradicting our initial assumption .",
    "hence the theorem .            * _ base : _ first , since @xmath444 , any tree that contains only one node representing a basic subnet of @xmath142 has both its @xmath408-value and its depth equal to 0 .",
    "* _ inductive hypothesis : _ now , assume that any tree whose depth smaller than or equal to an integer @xmath445 and whose terminal nodes are all in @xmath315 has its depth equal to its @xmath408-value .",
    "we then show that any tree with depth @xmath446 and with all terminal nodes in @xmath315 will also have its depth equal to its @xmath408-value as follows .",
    "* * let @xmath332 be a tree with @xmath447 and with every terminal node in @xmath315 .",
    "since @xmath448 , @xmath449 .",
    "* * it follows that both the depths of @xmath323 and @xmath324 are equal to or smaller than @xmath450 .",
    "furthermore , every terminal node of @xmath323 and @xmath324 is in @xmath315 .",
    "therefore , by the inductive hypothesis , @xmath451 and @xmath452 . *",
    "* it then follows that @xmath453 , or @xmath454 . by the definition of @xmath408 , therefore , @xmath455 . *",
    "thus , by induction , if @xmath391 then @xmath456 . by the definitions of @xmath405 and @xmath404 , it then follows that if @xmath391 , @xmath439 .    to prove ( ii ) , consider a partial tree @xmath392 in @xmath305 that starts from @xmath313 and terminates at a set of nodes that are not necessarily leaf nodes . consider a terminal node @xmath457 of @xmath392 that is not a leaf node , which represents a constraint - connected subnet of @xmath142",
    "let @xmath458 be an arbitrary tree that starts at @xmath457 and terminates at a subset of leaf nodes .",
    "@xmath458 is then a sub - plan for @xmath142 , namely , a plan to synthesize the subnet represented by @xmath457 .",
    "the depth of @xmath458 must then be equal to or greater than @xmath459 , since to synthesize the subnet represented by @xmath457 , we need to successively compose two different subnets of it at a time .",
    "since the depth of a tree starting from an arbitrary terminal node @xmath457 of @xmath392 and terminating at @xmath315 is equal to or greater than @xmath459 , by the recursive definitions of @xmath408 , it follows that the depth of any tree in @xmath338 that encompasses @xmath392 as a subgraph is equal to or greater than @xmath460 .",
    "in other words , @xmath404 is an admissible heuristic for @xmath405 .",
    "k.  t. seow , m.  t. pham , c.  ma , and m.  yokoo , `` coordination planning : applying control synthesis methods for a class of distributed agents , '' _ ieee transactions on control systems technology _ , vol .",
    "17 , no .  2 , pp . 405415 , 2009 .",
    "w.  m. wonham , _ notes on control of discrete - event systems ece 1636f/1637s_.1em plus 0.5em minus 0.4emsystems control group , university of toronto , updated 1st july 2012 , http://www.control.toronto.edu/cgi-bin/dldes.cgi",
    ".    m.  t. pham and k.  t. seow , `` towards synthesizing optimal coordination modules for distributed agents , '' in _ proceedings of the 23th aaai conference on artificial intelligence _ , chicago , illinois , usa , july 2008 , pp .",
    "14791480 .",
    "k.  t. seow , c.  ma , and m.  yokoo , `` multiagent planning as control synthesis , '' in _ proceedings of the 3rd international joint conference on autonomous agents and multi - agent systems _ , columbia university , new york , july 2004 , pp .",
    "972979 .",
    "w.  m. wonham , _ control design software : tct_.1em plus 0.5em minus 0.4emdeveloped by systems control group , university of toronto , canada , updated 1st july 2008 , http://www.control.toronto.edu/cgi-bin/dlxptct.cgi .",
    "m.  yokoo , _ distributed constraint satisfaction : foundations of cooperation in multi - agent systems_.1em plus 0.5em minus 0.4em",
    "springer - verlag , heidelberg , germany , 2000 ,  springer series on agent technology .",
    "l.  hunsberger , `` algorithms for a temporal decoupling problem in multi - agent planning , '' in _ proceedings the 18th national conference on artificial intelligence _ , edmonton ,",
    "alberta , july - august 2002 , pp . 468475 .",
    "l.  planken , m.  de  weerdt , and c.  witteveen , `` optimal temporal decoupling in multiagent systems , '' in _ proceedings of the 9th international joint conference on autonomous agents and multi - agent systems _ , toronto , may 2010 , pp .",
    "789796 .",
    "j.  c.  b. jr . and",
    "e.  h. durfee , `` distributed algorithms for solving the multiagent temporal decoupling problem , '' in _ proceedings of the 10th international joint conference on autonomous agents and multi - agent systems _ ,",
    "taipei , may 2011 , pp .",
    "141148 .",
    "j.  shen and v.  r. lesser , `` communication management using abstraction in distributed bayesian networks , '' in _ proceedings of the fifth international joint conference on autonomous agents and multi - agent systems _ , future university - hakodate , hakodate , may 2006 , pp",
    ". 622629 .",
    "k.  cai and w.  m. wonham , `` supervisor localization : a top - down approach to distributed control of discrete - event systems , '' in _ second mediterranean conference on intelligent systems and automation ( cisa09 ) .",
    "aip conference proceedings _ , vol . 1107 , zarzis , march 2009 , pp .",
    "302308 .",
    " , `` supervisor localization of discrete - event systems based on state tree structures , '' in _ proceeding of the 51st ieee conference on decision and control _ , maui , hawaii , december 2012 , pp . 58225827 .",
    "p.  n. pena , j.  e.  r. cury , and s.  lafortune , `` testing modularity of local supervisors : an approach based on abstractions , '' in _ proceedings of the 8th international workshop on discrete event systems _ , ann arbor , michigan , july 2006 , pp ."
  ],
  "abstract_text": [
    "<S> this paper presents a novel compositional approach to distributed coordination module ( cm ) synthesis for multiple discrete - event agents in the formal languages and automata framework . </S>",
    "<S> the approach is supported by two original ideas . </S>",
    "<S> the first is a new formalism called the distributed constraint specification network ( dcsn ) that can comprehensibly describe the networking constraint relationships among distributed agents . </S>",
    "<S> the second is multiagent conflict resolution planning , which entails generating and using and/or graphs to compactly represent conflict resolution ( synthesis - process ) plans for a dcsn . together with the framework of local cm design developed in the authors earlier work , the systematic approach supports separately designing local and deconflicting cm s for individual agents in accordance to a selected conflict resolution plan . composing the agent models and </S>",
    "<S> the cm s designed furnishes an overall nonblocking coordination solution that meets the set of inter - agent constraints specified in a given dcsn . </S>"
  ]
}