{
  "article_text": [
    "modern sat - solvers are famously efficient for solving the decision problem of satisfiability of propositional formulas , and we may wonder whether the ideas used in sat - solvers could be generalized to the first - order case .",
    "this paper addresses this question from a purely proof - theoretical perspective .",
    "we briefly recall the first - order resolution calculus ( in section [ sec : resolution ] ) , which is the theoretical foundation for many current state - of - the - art first - order theorem provers ( e.g. @xcite ) , and the dpll and cdcl procedures used by sat - solvers ( in section [ sec : dpllcdcl ] ) .",
    "the main contribution of this paper ( presented in section [ sec : uprcl ] ) is the _ conflict resolution _",
    "* cr*. it extends the first - order resolution calculus with _ decision literals _ and a new inference rule for _ clause learning _ and restricts the resolution rule in order to force it to behave like _",
    "unit propagation_. as discussed in subsection [ sec : isomorphism ] , a certain subclass of * cr*derivations is isomorphic to the abstract data structure known as _ conflict graphs _ or _ implication graphs _ and widely used to describe the procedures of modern sat - solvers .",
    "furthermore , as shown in section [ sec : splitting ] , whereas the _ splitting _ technique used by modern first - order provers must either be handled at an extra - logical level or lead to an unacceptable increase in proof size if simulated in the resolution calculus , its simulation by * cr * s decisions and clause learning is lean and straightforward .",
    "therefore , the new * cr*calculus provides a more adequate proof - theoretical foundation for procedures currently implemented by sat - solvers and first - order provers .    in * cr * , it becomes evident that decision literals are analogous to assumptions in natural deduction , whereas clause learning resembles natural deduction s implication introduction rule .",
    "this fact is crucial for the proof of soundness of",
    "* cr*(shown in section [ sec : soundness ] ) and it illustrates an insightful novelty of the calculus : while the resolution inference proposed by robinson ( @xcite ) can be regarded as a first - order generalization of modus ponens ( a.k.a .",
    "natural deduction s implication _ elimination _ ) by taking unification into account , the clause learning rule proposed here ( and inspired by the propositional cdcl technique ) can be considered a first - order generalization of implication _ introduction _ , as it discharges decision literals in a way that allows for unification .",
    "any resolution refutation can be translated into a refutation in the proposed calculus .",
    "therefore , * cr * s refutational completeness follows easily from the refutational completeness of the resolution calculus ( as demonstrated in section [ sec : completeness ] ) .",
    "a main motivation for the development of the conflict resolution calculus was that it might eventually serve as a theoretical common ground for existing first - order provers that try to harness or mimic the power of sat - solvers ( cf .",
    "section [ sec : relatedwork ] ) ) or as a starting point for the development of new provers , in the same way that the pure resolution calculus provided the basic foundation for several generations of automated theorem provers in the last decades . to achieve this goal ,",
    "the calculus is presented in a general way , avoiding premature optimizations and refinements , so that future work may easily build on it and explore various proof search strategies and implementation techniques .",
    "_ clauses _ ( denoted @xmath0 , possibly subscripted ) are disjunctions of literals . a _",
    "literal _ is either an atom or a negated atom , and an _ atom _ is a @xmath1-ary predicate ( denoted @xmath2 or @xmath3 ) applied to @xmath1 terms .",
    "a _ term _ is either a constant ( denoted @xmath4 or @xmath5 ) , a variable ( denoted @xmath6 , @xmath7 , @xmath8 or @xmath9 ) or an @xmath1-ary function ( denoted @xmath10 or @xmath11 ) applied to @xmath1 terms . variables in a clause are assumed to be implicitly universally quantified .",
    "a clause having a single literal is called _",
    "unit_. if @xmath12 is a literal , @xmath13 denotes its dual ( i.e. @xmath14 and @xmath15 ) .",
    "the nullary atoms @xmath16 ( _ verum _ ) and @xmath17 ( _ falsum _ ) have special meanings characterized by the following equations : @xmath18 and @xmath19 .",
    "all inference rules operating on clauses are assumed to be modulo disjunction s associativity and commutativity , modulo negation s involutivity and modulo the equations for @xmath16 and @xmath17 .",
    "the empty clause is logically equivalent to the clause containing only @xmath17 .",
    "therefore , slightly abusing notation , it is denoted by @xmath17 .",
    "substitutions ( denoted by @xmath20 , possibly sub- and superscripted ) are assumed to implicitly avoid variable capture .",
    "the empty ( i.e. identity ) substitution is denoted @xmath21 .",
    "the inference rules of the resolution calculus are shown in fig .",
    "[ fig : resolution ] . a resolution _",
    "proof _ of a clause @xmath0 from a set of clauses @xmath22 is a directed acyclic graph ( dag ) where leaves ( i.e. input nodes ) are clauses from @xmath22 , internal nodes are obtained from their parents through application of the inference rules and the sink node is the clause @xmath0 .",
    "a resolution _ refutation _ of a set of clauses @xmath22 is a proof of the empty clause ( denoted @xmath17 ) from @xmath22 .",
    "it is assumed that distinct input clauses do not share variables .",
    "furthermore , the inference rules implicitly generate fresh symbols for variables , thereby maintaining the invariant that distinct clauses do not share variables .",
    "proof dags are sometimes displayed as a collection of trees according to the following convention : nodes used as premises more than once are given names ( e.g. @xmath23 , @xmath24 or @xmath25 ) when they are used for the first time , and the names are used to refer to the nodes whenever they are used again . by naming and referring , wide proof trees can also be broken down in smaller displayable parts .",
    "consider a proof with the following non - tree form :        it can be displayed as the single tree with names and references below , where the second ( rightmost ) occurrence of the name @xmath24 is to be understood as a reference to the node named @xmath24 by the first ( leftmost ) occurrence of @xmath24 :    or it can also be displayed as the following forest , where the two occurrences of the name @xmath24 in the lower tree are to be understood as references to the node named @xmath24 in the upper tree :    given a set of clauses , a resolution prover exhaustively applies the inference rules , generating more and more clauses .",
    "if the initial clause set is unsatisfiable and a fair clause / rule selection strategy is used , the empty clause is eventually derived , because resolution is refutationally complete @xcite . if the set is satisfiable , the prover will either never terminate or will terminate in a state where the set of initial and derived clauses is saturated with respect to redundancy criteria ( i.e. only redundant clauses would still be derivable ) ( cf . @xcite @xcite ) .",
    "one practical problem in this saturation approach is the vast number of clauses that are generated .",
    "this led to research on refinements of the resolution calculus , aiming at restricting the inference rules in order to generate fewer clauses , and on efficient ways to detect and delete redundant ( e.g. subsumed ) clauses .",
    "these efforts culminated in the _ _ superposition _ _ calculus @xcite , which extends the resolution calculus with a paramodulation rule @xcite for equality reasoning and refines it with ordering restrictions on terms and literals .    *",
    "resolution : * @xmath26{(\\gamma \\vee",
    "\\delta)~\\sigma}{\\gamma \\vee \\ell & \\dual{\\ell ' } \\vee \\delta}\\ ] ]    where @xmath20 is a unifier of @xmath12 and @xmath27 .    * factoring : * @xmath28{(\\ell \\vee \\ell'_1 \\vee \\ldots \\vee \\ell'_m)~\\sigma}{\\ell_1 \\vee \\ldots \\vee \\ell_n \\vee \\ell'_1 \\vee \\ldots \\vee \\ell'_m}\\ ] ]    where @xmath20 is a unifier of @xmath29 ,  @xmath30 and @xmath31 , for any @xmath32 .",
    "another practical problem is that the resolvent of a clause with @xmath1 literals and another clause with @xmath33 literals has @xmath34 literals .",
    "when iterated , this results in very long clauses and , consequently , a loss of efficiency .",
    "this practical problem has been solved with a technique known as _ splitting _ @xcite : if the current set of clauses is @xmath35 and the sets of variables @xmath36 of @xmath37 are mutually disjoint , then we can split the long clause @xmath38 into its variable - disjoint components and the clause set into the @xmath39 sets @xmath40 ( for @xmath41 ) .",
    "the disjointness of the sets of variables @xmath36 ensures that we can check the unsatisfiability of each resulting clause set independently : @xmath35 is unsatisfiable iff @xmath40 is unsatisfiable for every variable - disjoint component @xmath37 .    from a proof - theoretical perspective",
    ", splitting resembles the @xmath42-rule of free - variable tableaux @xcite .",
    "therefore , superposition provers that implement splitting @xcite can be seen as hybrids combining resolution / superposition and tableaux .",
    "up to now , however , there has been no single pure proof system capable of characterizing what is going on inside a modern state - of - the - art first - order theorem prover .",
    "this gap between theory and practice is something that can be remedied with the adoption of the * cr*calculus proposed here ( cf . section [ sec : splitting ] ) .",
    "in the propositional case , davis , logemann and loveland @xcite had already noticed that the propositional resolution rule @xcite `` can easily increase the number and the lengths of the clauses '' and proposed to replace it by a form of splitting , which is , however , different from the later notion of splitting described in section [ sec : resolution ] . instead of splitting a clause into variable - disjoint components , we select a propositional atom @xmath2 and split the problem in two subproblems : one where @xmath2 is assumed to be true and the other where it is assumed to be false . nowadays ,",
    "the so - called dpll procedure is presented slightly differently , but equivalently .",
    "we _ decide _ to assign the truth value ` true ` ( or ` false ` ) to an atom ; then , through _ unit propagation _ , other atoms will be assigned truth values as well . repeating this process of decisions and propagations , we will either reach an assignment that satisfies all clauses ( if the clause set is satisfiable ) or we will reach a _ conflict _ where we are to assign both ` true ` and ` false ` to an atom . in the latter case , we backtrack some of our decisions , and try different assignments .",
    "in contrast to saturation - based theorem proving , dpll - based sat - solving does not generate any clause at all .",
    "but this is , of course , dependent on the fact that in propositional logic it suffices to consider only two truth - value assignments for each atom . in a nave adaptation of this idea",
    "to first - order logic , on the other hand , we would need to consider truth - value assignments for each instance of an atom containing variables .",
    "we would need to generate possibly several instances .    in practice",
    ", it has been found that it is , nevertheless , beneficial to generate _ some _ clauses when backtracking from conflicts .",
    "for example , suppose that the backtracking dppl procedure decided to assign ` true ` to @xmath2 and @xmath3 , and this led to a conflict .",
    "it is then forced to backtrack these decisions and try other decisions . without clause learning",
    ", it could happen that , after assigning truth values to other atoms , it would again consider the possibility of assigning ` true ` to @xmath2 and @xmath3 , even though it is clear ( from the previous conflict ) that @xmath2 and @xmath3 can not be both ` true ` , independently of later assignments to other atoms . to prevent this from happening , we can generate and add the clause @xmath43 to the set of clauses . then",
    ", whenever the procedure retries assigning , for instance , ` true ` to @xmath2 it will immediately conclude ( by unit propagation ) that ` false ` should be assigned to @xmath3 .",
    "this idea is known as _ conflict - driven clause learning_.    the procedure up to a conflict can be understood as the construction of a directed graph .",
    "nodes are literals which have been assigned ` true ` . a _ decision literal _",
    "( i.e. a literal with truth value assigned by decision ) has no incoming edge .",
    "a _ propagated literal _",
    "( i.e. a literal with truth value assigned by unit propagation ) @xmath12 has incoming edges @xmath44 for @xmath45 iff the clause @xmath46 was the clause used by unit propagation to assign a truth value to @xmath12 .",
    "a conflict is indicated by the simultaneous presence of any literal and its dual in the graph .",
    "when a conflict is detected , the graph can be analyzed to determine clauses that should be learned .",
    "various conflict analysis algorithms exist @xcite .",
    "the conceptually simplest one recommends learning a clause that is a disjunction of the negations of the decision literals .",
    "more sophisticated algorithms @xcite are capable of learning stronger clauses .",
    "an important benefit of conflict - driven clause learning is that redundant ( i.e. subsumed ) clauses are never derived .",
    "the learned clause can be derived by a sequence of resolution steps using the clauses corresponding to the edges in the graph as premises .",
    "when this is done , a sat - solver is capable of outputting a propositional resolution refutation for an unsatisfiable clause set @xcite .",
    "however , most developers of sat - solvers consider the overhead ( in both proving time and memory consumption ) of doing so unacceptable , especially when advanced techniques for minimizing learned clauses are used . instead",
    ", they prefer to generate proof certificates in the drup or drat formats @xcite , which record clauses that have been learned , but do not inform which premises are needed to derive them .",
    "a consequence of this lack of information is that checking a drup / drat certificate or converting it to a resolution refutation ( using the drat - trim tool ) can take as long as solving the problem in the first place .",
    "[ example : conflictgraphs ] consider the clause set @xmath47 . deciding @xmath2 and propagating units results in the conflict graph at the left side below .",
    "we backtrack and learn the unit clause @xmath48 , whose propagation leads to the conflict graph in the right side below . since this last conflict does not depend on any decision literal , no backtracking is possible , and we may conclude that the clause set is unsatisfiable .",
    "the resolution proof extracted from the first conflict graph is :    the resolution proof extracted from the second conflict graph is :",
    "as we have seen in the previous two sections , both propositional and first - order automated deduction have progressed ( in different ways ) much beyond their historical common roots in resolution .",
    "techniques such as splitting , conflict graphs and conflict - driven clause learning are not so easily explained in terms of a pure resolution calculus .",
    "there is a growing gap between the current state - of - the - art in automated deduction and its original proof - theoretical foundation . in this section ,",
    "we propose the * cr*calculus , which modifies the first - order resolution calculus by incorporating ideas from sat - solving , in an attempt to reduce not only the gap between automated deduction and proof theory but also between the first - order and the propositional cases .    as in resolution ,",
    "a * cr*__derivation _ _ is a directed acyclic graph where nodes are clauses and internal nodes are obtained from their parents by one of the inference rules shown in fig .",
    "[ fig : uprcl ] .",
    "the _ conflict _ rule is just a restriction of the resolution rule .",
    "the _ _ unit - propagating resolution _ _ rule is essentially a sequence of applications of the resolution rule where the left premises must always be unit clauses ; the conclusion clause must be unit as well , and its literal is called a _ propagated literal_.    the main innovation lies in the _ conflict - driven clause learning _ rule .",
    "the literals within brackets are the _ decision literals _ that have been assumed .",
    "the superscript index @xmath49 indicates that this assumption is discharged by the @xmath50 inference with index @xmath49 .",
    "it is not required that a @xmath50 inference discharge all decision literals above it .",
    "some decision literals may be left undischarged , to be discharged by future @xmath50 inferences .",
    "the vertical dots denote any derivation of @xmath17 using the decision literals , input clauses and previously derived clauses .",
    "the conclusion clause of this rule is the _ learned clause_. in contrast to the propositional case",
    ", the learned clause must be a disjunction of negations of _ instances _ of the discharged decision literals , because variables occurring in the discharged decision literals may be instantiated by unifications performed during the proof .",
    "since the derivation of @xmath17 need not be tree - like , we may need to consider several instances of each decision literal .",
    "a * cr*derivation is a * cr*__proof _ _ iff all its decision literals have been discharged .",
    "a * cr*__refutation _ _ is a * cr*proof of @xmath17 .",
    "* unit - propagating resolution : * @xmath51{\\ell~\\sigma}{\\ell_1 & \\ldots & \\ell_n & \\dual{\\ell'_1 } \\vee \\ldots \\vee \\dual{\\ell'_n } \\vee \\ell}\\ ] ]    where @xmath20 is a unifier of @xmath52 and @xmath53 , for all @xmath32 .",
    "* conflict : * @xmath54{\\bot}{\\ell & \\dual{\\ell'}}\\ ] ]    where @xmath20 is a unifier of @xmath52 and @xmath53 , for all @xmath32 .",
    "* conflict - driven clause learning : * @xmath55 { ( \\dual{\\ell_1 } \\sigma^1_1 \\vee \\ldots \\vee \\dual{\\ell_1 } \\sigma^1_{m_1 } ) \\vee \\ldots \\vee ( \\dual{\\ell_n } \\sigma^n_1 \\vee \\ldots \\vee \\dual{\\ell_n } \\sigma^n_{m_n } ) } { \\infer*{\\bot}{\\infer*[(\\sigma_1 ^ 1,\\ldots,\\sigma_{m_1}^1)]{}{[\\ell_1]^{i_1 } } &   & \\infer*[(\\sigma_1^n,\\ldots,\\sigma_{m_n}^n)]{}{[\\ell_n]^{i_n } } } } \\ ] ]    where @xmath56 ( for @xmath57 and @xmath58 ) is the composition of all substitutions used on the @xmath59-th path from @xmath52 to @xmath17 .",
    "resolution s _ factoring _ rule can be simulated by a sequence of decisions , one unit - propagation , one conflict and one conflict - driven clause learning . in this way , we can prove the following lemma .",
    "resolution s factoring rule is admissible in * cr*.    let @xmath60 be a * cr*derivation of @xmath61 and consider constructing @xmath23 by applying the factoring inference to the conclusion of @xmath60 , as shown below : @xmath28{(\\ell \\vee \\ell'_1 \\vee \\ldots \\vee",
    "\\ell'_m)~\\sigma}{\\infer*[\\varphi']{\\ell_1 \\vee \\ldots \\vee \\ell_n \\vee \\ell'_1 \\vee \\ldots \\vee \\ell'_m } { } } \\ ] ] this is admissible because , instead of using the factoring inference , we could have used a sequence of * cr*inferences , as shown in fig .  [ fig : factoringadmissibility ] .",
    "@xmath62 { ( \\ell \\vee \\ell'_1 \\vee \\ldots",
    "\\vee \\ell'_m)~\\sigma } {      \\infer[{\\mathbf{c}(\\varepsilon)}]{\\bot }      {          \\infer[{\\mathbf{u}(\\sigma)}]{\\ell'_m~\\sigma }          {              \\psi : [ \\dual{\\ell}]^{1_1 }              &              \\overbrace{\\psi \\quad \\ldots \\quad \\psi}^{n-1 \\ \\mathrm{times } }              &               [ \\dual{\\ell'_1}]^{1_{n+1 } }              &              \\ldots              &              [ \\dual{\\ell'_{m-1 } } ] ^{1_{n+m-1 } }              &              \\infer*[\\varphi']{\\ell_1 \\vee \\ldots \\vee \\ell_n \\vee \\ell'_1 \\vee \\ldots \\vee \\ell'_m } { }          }          &          [ \\dual{\\ell'_m}~\\sigma ]      } } \\ ] ]    where @xmath20 is a unifier of @xmath29 ,  @xmath30 and @xmath31 , for any @xmath32 .",
    "the simulation of factoring depends on a sufficient degree of freedom in the choice of decision literals",
    ". we must be allowed ( as indeed we are in * cr * ) to assume a decision literal ( @xmath13 ) that is the dual of an instance of all @xmath63 ( for @xmath64 ) .",
    "[ example : uprcl ] consider the following clause set : @xmath65    it admits the * cr*refutation shown in fig .",
    "[ fig : uprclrefutation ] . a shorter refutation would be possible if we had taken , for instance , @xmath3 as a decision literal . but taking @xmath66 as a decision literal instead , as done in the refutation in fig .",
    "[ fig : uprclrefutation ] , we can see how conflict driven clause learning behaves in the first - order case , when decision literals can contain variables , that can be instantiated during the process of propagation .",
    "in one path from @xmath67 to @xmath17 just above the @xmath68 inference , the unification performed by the unit - propagating resolution inference instantiates @xmath6 with @xmath4 , whereas in the other path @xmath6 is instantiated with @xmath5 .",
    "therefore , the @xmath68 inference learns the clause @xmath69 , which is the disjunction of the negations of all the instances of the decision literal @xmath66 .",
    "this is in contrast with ( and a generalization of ) the propositional case , where instances did not need to be considered .    as in the propositional case",
    ", the decisions and unit propagations can be represented graphically :          by comparing the conflict graphs and * cr*derivations in example [ example : uprcl ] , it is noticeable that there is a straightforward isomorphism between conflict graphs and * cr*sub - derivations with a single conflict inference .",
    "every decision literal in a conflict graph appears as a decision literal in the corresponding * cr*derivation .",
    "every propagated literal in the conflict graph appears as a propagated literal derived by a unit - propagating resolution inference , and the clause associated to the incoming edges of the propagated literal is exactly the non - unit clause used as the rightmost premise of the unit - propagating inference .",
    "finally , the conflict in the conflict graph is a conflict inference in the corresponding * cr*derivation .",
    "in contrast , the correspondence between resolution derivations and conflict graphs is imperfect .",
    "as illustrated in example [ example : conflictgraphs ] , we have a map from conflict graphs to resolution derivations ; however , this map is not an isomorphism , simply because it is not even surjective .",
    "furthermore , there is a mismatch between the conflict graph operations ( i.e. decisions , propagations and conflict ) and the operations of the resolution calculus ( i.e. the resolution and factoring inference rules ) . in other words ,",
    "no map from conflict graphs to resolution derivations could be an isomorphism , because the algebraic structure can not be preserved . from this algebraic point of view",
    ", we may conjecture that the popular belief that ( propositional ) resolution is the underlying proof system of modern sat - solvers ( which actually implement the cdcl procedure based on conflict graphs ) is mistaken .",
    "we also speculate that the mismatch is the theoretical explanation for the overhead experienced in the transformation of conflict graphs to resolution derivations ( as discussed in the end of section [ sec : dpllcdcl ] ) .",
    "perhaps a calculus such as * cr * , that enjoys a better correspondence to conflict graphs , could enable proof production with less overhead .",
    "a proof system * p * is _ refutationally complete _ iff any unsatisfiable clause set has a refutation in * p*. instead of proving refutational completeness for * cr*directly , we will prove it indirectly , showing that * cr*can simulate another refutationally complete proof system . a proof system *",
    "p * simulates another proof system * q * iff there is a map transforming any * q*-derivation of @xmath0 from @xmath22 to * p*-derivation of @xmath0 from @xmath22 .    this indirect approach to proving completeness can be traced back at least to gentzen s work ( @xcite ) , who applied it to his natural deduction and sequent calculi . in our case , the target proof system for the simulation is resolution , and the key idea of the simulation is that every resolution step that is not a unit - propagating resolution inference can be simulated by several decisions , two unit - propagating resolution inferences , one conflict inference and one conflict - driven clause learning inference .    [",
    "theorem : simulationofresolution ] * cr*linearly simulates resolution .",
    "let @xmath24 be a resolution derivation of a clause @xmath0 from a set of clauses @xmath22 .",
    "we show that there is a * cr*derivation @xmath23 of @xmath0 from @xmath22 , proceeding by induction :    * _ base case : _",
    "@xmath24 is just a single node @xmath0 . in this case",
    ", @xmath23 is just the single node @xmath0 as well . *",
    "_ induction case 1 : _",
    "@xmath24 ends with a factoring inference @xmath70 . in this case , let @xmath71 be the subderivation whose conclusion @xmath72 is the premise of @xmath70 . by induction hypothesis , there is a * cr*derivation @xmath60 of @xmath72 from @xmath22 .",
    "and then @xmath23 can be constructed as the * cr*derivation of @xmath0 from @xmath22 obtained from @xmath60 by applying the admissible factoring inference rule to its conclusion in the same way as @xmath70 in @xmath24 or by simulating factoring as shown in fig .",
    "[ fig : factoringadmissibility ] . in any case , the conclusion of @xmath23 is @xmath0 , as desired . * _ induction case 2 : _",
    "@xmath24 ends with a resolution inference . in this case",
    ", @xmath24 is of the following form : @xmath26 { ( \\ell_1 \\vee \\ldots \\vee \\ell_n \\vee \\ell'_1 \\vee \\ldots \\vee \\ell'_m)~\\sigma } { \\infer*[\\psi_1]{\\ell_1 \\vee \\ldots \\vee \\ell_n \\vee",
    "\\ell \\qquad } { } &    \\infer*[\\psi_2]{\\qquad \\dual{\\ell ' } \\vee \\ell'_1 \\vee \\ldots \\vee \\ell'_m } { } } \\ ] ] by induction hypothesis , we have a * cr*derivation @xmath73 of @xmath74 from @xmath22 and a * cr*derivation @xmath75 of @xmath76 from @xmath22",
    ". then a * cr*derivation @xmath23 of @xmath77 can be constructed as shown in fig .",
    "[ fig : simulationofresolution ] .",
    "+ @xmath62{(\\ell_1 \\vee \\ldots \\vee \\ell_n \\vee \\ell'_1 \\vee \\ldots \\vee \\ell'_m)~\\sigma } {      \\infer[{\\mathbf{c}(\\sigma)}]{\\bot } {          \\infer[{\\mathbf{u}(\\varepsilon)}]{\\ell}{[\\dual{\\ell_1}]^1 & \\ldots & [ \\dual{\\ell_n}]^1 & \\infer*[\\varphi_1]{\\ell_1 \\vee \\ldots \\vee \\ell_n \\vee \\ell } { } }          &          \\infer[{\\mathbf{u}(\\varepsilon)}]{\\dual{\\ell ' } } { [ \\ell'_1]^1 & \\ldots & [ \\ell'_m]^1 & \\infer*[\\varphi_2]{\\dual{\\ell ' } \\vee \\ell'_1 \\vee \\ldots \\vee \\ell'_m } { } }      } } \\ ] ]    the simulation is linear both in length ( i.e. number of inferences ) and size ( i.e. number of literals ) . if @xmath24 has @xmath1 resolutions and @xmath33 factorings , then @xmath23 has @xmath1 clause learning inferences , @xmath1 conflicts , @xmath78 unit propagations and @xmath33 factorings .",
    "hence , @xmath79 . if @xmath24 has @xmath80 literals occurring in conclusions of resolution inferences and @xmath81 literals occurring in conclusions of factoring inferences , then @xmath23 has @xmath80 logical symbols occurring in conclusions of clause learning inferences , @xmath82 logical symbols occurring in premises of conflict inferences , @xmath80 literals occurring as decision literals for unit propagations and @xmath81 literals . hence , @xmath83 . since every resolution inference in @xmath24 has at least one literal in its conclusion , except for the last one deriving the empty clause , @xmath84 .",
    "therefore , @xmath85 and thus @xmath86 .",
    "* cr*is refutationally complete .",
    "let @xmath87 be an unsatisfiable clause set .",
    "as resolution is a refutationally complete calculus @xcite , there is a resolution refutation @xmath24 of @xmath87 . by theorem [ theorem : simulationofresolution ]",
    ", @xmath24 can be transformed to a * cr*refutation @xmath23 of @xmath87 .",
    "a mere restriction of resolution to unit - propagating resolution would result in a refutationally incomplete calculus .",
    "the unsatisfiable clause sets from examples [ example : conflictgraphs ] and [ example : uprcl ] , for instance , would not be refutable . by incorporating decision literals , as well as the conflict rule and the conflict - driven clause learning rule",
    ", we regain refutational completeness .    the fact that we need two unit - propagating resolution inferences , one conflict and one conflict - driven clause learning to simulate a single resolution inference ( as shown in fig .",
    "[ fig : simulationofresolution ] ) may lead us to think that * cr*is more bureaucratic and more inefficient than resolution .",
    "however , efficiency of proof search is not directly correlated with proof length .",
    "the efficiency of * cr*is a consequence of the fact that much fewer clauses are generated by unit - propagating resolution than by unrestricted resolution and the clause sizes are reduced through decisions and propagations .",
    "moreover , in any case , any resolution proof search , as well as any resolution proof , can be simulated in the * cr*calculus with only a ( small ) linear increase in length .",
    "to prove soundness , we exploit the key observation that decision literals resemble natural deduction s _ assumptions _ and conflict - driven clause learning resembles _ implication / negation introduction_. therefore , natural deduction is an excellent candidate for proving soundness indirectly , again by simulation .",
    "however , typical natural deduction rules operate on general formulas , which are not necessarily in clause form , and this makes a direct simulation technically difficult . in order to overcome this challenge",
    ", we define an intermediary _ clausal natural deduction calculus _",
    "( abbreviated as * cnd * ) with inference rules that operate on clauses , as shown in fig .",
    "[ fig : cnd ] .",
    "* implication elimination ( modus ponens ) : * @xmath88{\\gamma}{\\ell & \\dual{\\ell } \\vee \\gamma}\\ ] ]    * implication introduction : * @xmath89 { \\dual{\\ell } \\vee \\gamma } { \\infer*{\\gamma}{[\\ell]^i}}\\ ] ]    * universal quantification elimination : * @xmath90{\\gamma \\sigma } { \\gamma}\\ ] ]    * universal quantification introduction : * @xmath91 { \\gamma } { \\gamma \\ { { x_1 \\backslash \\alpha_1 } , \\ldots , { x_n \\backslash \\alpha_n}\\ } } \\ ] ]    @xmath92 must be a distinct _ eigen - variable _ : + it should occur neither in @xmath93 nor in any undischarged assumption .",
    "the clausal natural deduction calculus * cnd*can be simulated by any standard non - clausal natural deduction calculus extended with a classical rule for double negation elimination .",
    "the key idea is to use the well - known classical equivalence @xmath94 ( where @xmath95 is an abbreviation for @xmath96 ) , in order to transform the clauses in a @xmath97 proof into formulas containing only implication , which are therefore suitable for a minimal non - clausal natural deduction calculus .",
    "when transforming a * cnd*proof into a standard non - clausal natural deduction proof , sequences of implication introduction / elimination rules may have to be added to the natural deduction proof , in order to reorder literals ( because associativity and commutativity of disjunction is implicitly taken into account by * cnd * s inference rules , but must be handled explicitly in a standard natural deduction calculus ) .",
    "the classical rule of double negation elimination is needed in order to handle the involutivity of classical negation , which is implicit in * cnd*. a more detailed proof of this simulation is omitted because it would be tedious and space - consuming .",
    "soundness of * cnd*is a corollary of the simulation , since natural deduction is sound .",
    "remembering that all clausal rules are assumed to be modulo negation s involutivity and modulo the neutrality of @xmath17 w.r.t .",
    "disjunction , the rules for negation introduction and elimination shown in fig .",
    "[ fig : cndnegationrules ] are admissible in * cnd * , since they are just special cases of , respectively , implication introduction and elimination , when @xmath98 .",
    "we are now ready to prove the following theorem .",
    "* negation elimination : * @xmath99{\\bot}{\\ell & \\dual{\\ell } } \\ ] ]    * negation introduction : * @xmath100 { \\dual{\\ell } } { \\infer*{\\bot}{[\\ell]^i}}\\ ] ]    [ theorem : simulationbynd ] * cnd*simulates * cr*.    given a * cr*derivation @xmath24 of a clause @xmath0 from a set of clauses @xmath22 , we must construct a * cnd*derivation @xmath23 of @xmath0 from @xmath22 ( modulo variable renaming ) .",
    "we first expand @xmath24 into a tree - like proof @xmath71 : for each clause @xmath72 with several children @xmath101 ( where @xmath102 ) , we create @xmath1 copies @xmath103 of @xmath72 and use each @xmath104 ( for @xmath57 ) as a parent for @xmath105 .",
    "the variables in each copy are renamed to fresh variables and all substitutions in the proof are updated accordingly , in order to maintain the property that distinct clauses in @xmath71 do not share variables ( cf .",
    "section [ sec : resolution ] ) .",
    "now that @xmath71 is tree - like , we may compute its _ global substitution _",
    "@xmath106 ( i.e. the composition ( in topological order ) of all the substitutions used in the proof ) do not share variables and @xmath71 is tree - like , we do not need to worry about variable clashes in the composition of all substitutions .",
    "the topological order is needed because a variable @xmath6 introduced by a substitution @xmath107 may be in the domain of another substitution @xmath108 occurring below @xmath107 . in this case , the topologically ordered composition is @xmath109 ( i.e. apply first @xmath107 and then @xmath108 ) . ] .",
    "we now do a recursive top - down traversal of @xmath71 and for each subderivation @xmath110 deriving a clause @xmath72 from @xmath22 with decision literals @xmath111 , \\ldots , [ \\ell_n]$ ] , we construct a corresponding subderivation @xmath25 deriving @xmath112 from @xmath22 with assumptions @xmath113 , \\ldots , [ \\ell_n~\\sigma^*]$ ] :    * _ base case 1 : _",
    "@xmath110 has just a leaf node containing a decision literal @xmath114 $ ] . in this case",
    ", @xmath25 is the leaf node containing the assumption @xmath115 $ ] . * _ base case 2 : _",
    "@xmath110 has just a leaf node containing a clause @xmath93 . in this case , @xmath25 is : @xmath90{\\gamma~\\sigma^*}{\\gamma}\\ ] ] * _ induction case 1 : _",
    "@xmath110 ends with a unit - propagating resolution inference , as shown below : @xmath51 { \\ell~\\sigma } {    \\infer*[\\eta_1]{\\ell_1 } { }   & \\ldots &     \\infer*[\\eta_n]{\\ell_n } { }   &     \\infer*[\\eta']{\\dual{\\ell'_1 } \\vee \\ldots",
    "\\vee \\dual{\\ell'_n } \\vee \\ell } { }   } \\ ] ] by induction hypothesis , there are * cnd*derivations @xmath116 ,  , @xmath117 , @xmath118 of , respectively , @xmath119 ,  , @xmath120 , @xmath121 .",
    "we then construct @xmath25 by applying implication elimination @xmath1 times , as shown below : @xmath88 { \\ell~\\sigma } {      \\infer*[\\xi_n]{\\ell_n~\\sigma^ * } { }      &      \\infer[\\imp_e ]      { \\vdots }      {          \\infer*{\\qquad } { }      &          \\infer[\\imp_e ]          { ( \\dual{\\ell'_2 } \\vee \\ldots \\vee \\dual{\\ell'_n } \\vee \\ell)~\\sigma }          {            \\infer*[\\xi_1]{\\ell_1~\\sigma^ * } { }          &            \\infer*[\\xi']{(\\dual{\\ell'_1 } \\vee \\ldots",
    "\\vee \\dual{\\ell'_n } \\vee \\ell)~\\sigma^ * } { }          }      } } \\ ] ] * _ induction case 2 : _",
    "@xmath110 ends with a conflict inference .",
    "this case is analogous to the case above .",
    "but , instead of @xmath1 implication elimination inferences , a single negation elimination inference suffices . * _ induction case 3 : _",
    "@xmath110 ends with a conflict - driven clause learning inference . in this case",
    ", the corresponding subproof in @xmath24 used to have the following form : @xmath55 { ( \\dual{\\ell_1 } \\sigma^1_1 \\vee \\ldots \\vee \\dual{\\ell_1 } \\sigma^1_{m_1 } ) \\vee \\ldots \\vee ( \\dual{\\ell_n } \\sigma^n_1 \\vee \\ldots",
    "\\vee \\dual{\\ell_n } \\sigma^n_{m_n } ) } { \\infer*{\\bot}{\\infer*[(\\sigma_1 ^ 1,\\ldots,\\sigma_{m_1}^1)]{}{[\\ell_1]^{i_1 } } &   & \\infer*[(\\sigma_1^n,\\ldots,\\sigma_{m_n}^n)]{}{[\\ell_n]^{i_n } } } } \\ ] ] but due to the expansion to a tree , the subproof @xmath110 in @xmath71 has the form shown below , where there is a copy @xmath122 $ ] of a decision literal @xmath123 $ ] for every path @xmath59 that existed from @xmath123 $ ] to @xmath17 in @xmath24 .",
    "the copies have fresh variables , but are identical modulo variable renaming . for every @xmath39 and @xmath59 ,",
    "the substitution @xmath124 is essentially identical to @xmath125 , except for the fact that different variable names are used .",
    "@xmath55 { ( \\dual{\\ell_1 } \\sigma^{1'}_1 \\vee \\ldots",
    "\\vee \\dual{\\ell_1 } \\sigma^{1'}_{m_1 } ) \\vee \\ldots \\vee ( \\dual{\\ell_n } \\sigma^{n'}_1 \\vee \\ldots \\vee \\dual{\\ell_n } \\sigma^{'n}_{m_n } ) } { \\infer*{\\bot } { \\infer*[\\sigma_1^{1'}]{}{[\\ell_1 ^ 1]^{i_1 } }   & \\ldots & \\infer*[\\sigma_{m_1}^{1'}]{}{[\\ell_1^{m_1}]^{i_1 } }   & \\ldots   &   \\infer*[\\sigma_1^{n'}]{}{[\\ell_n^1]^{i_n } }   & \\ldots & \\infer*[\\sigma_{m_n}^{n'}]{}{[\\ell_n^{m_n}]^{i_n } }   } } \\ ] ] by induction hypothesis , there is a derivation @xmath118 with the form : @xmath126{}{[\\ell_1 ^ 1~\\sigma^ * ] }   & \\ldots & \\infer*[]{}{[\\ell_1^{m_1}~\\sigma^ * ] }   & \\ldots   &   \\infer*[]{}{[\\ell_n^1~\\sigma^ * ] }   & \\ldots & \\infer*[]{}{[\\ell_n^{m_n}~\\sigma^ * ] }   } \\ ] ] and then a derivation @xmath25 can be constructed by applying the implication introduction rule as many times @xmath39 as there are assumptions @xmath127 , \\ldots , [ \\ell_1^{m_1}~\\sigma^ * ] , \\ldots , \\ell_n^1~\\sigma^ * ] , \\ldots , [ \\ell_n^{m_n}~\\sigma^*]$ ] to be discharged , as depicted below : + @xmath128 { ( \\dual{\\ell_1 ^ 1 } \\sigma^ * \\vee \\ldots \\vee \\dual{\\ell_1^{m_1 } } \\sigma^ * ) \\vee \\ldots \\vee ( \\dual{\\ell_n^1 } \\sigma^ * \\vee \\ldots \\vee \\dual{\\ell_n^{m_n } } \\sigma^ * ) } {          \\infer*{\\qquad\\bot\\qquad }          {          \\infer*[]{}{[\\ell_1 ^ 1~\\sigma^*]^1 }                                                                           &          \\ldots          &          \\infer*[]{}{[\\ell_n^{m_n}~\\sigma^*]^k }           } } \\ ] ] + since @xmath106 is the composition of all substitutions in @xmath71 , including every @xmath124 , we have that @xmath129 .",
    "therefore , the conclusion of @xmath25 is identical to : @xmath130    at the end of the top - down traversal , we have a * cnd*proof @xmath23 of @xmath131 from @xmath22 .",
    "since @xmath106 is the global substitution of all substitutions used in @xmath71 and @xmath71 derives @xmath132 , we have that @xmath133 . therefore , @xmath23 is a * cnd*proof of @xmath0 from @xmath22 , as desired .    to illustrate the transformation of * cr*derivations into * cnd*derivations used in the proof of theorem [ theorem : simulationbynd ] , fig .",
    "[ fig : cndderivation ] shows the * cnd*derivation obtained by transforming the * cr*derivation shown in fig .",
    "[ fig : uprclrefutation ] .    where @xmath134 is a reference to a copy of @xmath75 .",
    "* cr*is sound .",
    "let @xmath23 be an arbitrary * cr*proof of @xmath0 from @xmath22 .",
    "then , by theorem [ theorem : simulationbynd ] , there is a * cnd*proof of @xmath0 from @xmath22 .",
    "since the natural deduction calculus * cnd*is sound , @xmath0 is entailed by @xmath22 .",
    "therefore , * cr*is sound .",
    "suppose that a prover refutes the set of clauses @xmath35 ( where the sets of variables @xmath36 of @xmath37 are mutually disjoint ) , by splitting it into the @xmath39 sets @xmath40 ( for @xmath41 ) and finding a resolution refutation @xmath135 for each set @xmath40 .",
    "one way to combine these proofs into a single resolution refutation of @xmath35 would be to use the following recursive method :    * _ for @xmath136 : _ construct @xmath137 by replacing every leaf occurrence of @xmath138 in @xmath139 by @xmath38 , propagating the added literals downwards and factoring the added literals when possible ; then @xmath137 is not a refutation , but a derivation of @xmath140 . * _ for @xmath49 from @xmath78 to @xmath39 : _ construct @xmath141 by replacing every leaf occurrence of @xmath142 in @xmath143 by the subproof @xmath144 deriving @xmath145 ; as before , propagate the added literals downwards and factor them when possible , so that @xmath141 is a proof of @xmath146 , if @xmath147 , or @xmath17 , otherwise .    however , this method is undesirable , because it requires a substantial modification of the component proofs @xmath135 .",
    "the modified subproofs are larger ( because of all the additional literals ) , and this may hinder readability of the proof by humans and reduce the efficiency of automatic proof checking .    a pragmatic approach is to disregard the attempt to output a single refutation for the original problem and simply output all the separate proofs for the split problems instead . keeping track of all splittings is important , particularly in the more general case where splitting is done recursively ( i.e. where each set @xmath40 can be split further ) .",
    "this seems to be the approach taken by most automated theorem provers .",
    "splittings performed during the proof search are recorded in the proof file in an extra - logical way , which may even violate informal semantic requirements of the tptp proof format rule or splitting .",
    "* cr * s conflict - driven clause learning is also affected by this limitation . ] .    in * cr * , splitting can be simulated in such a way that the refutations for the split sub - problems can be combined without the drawbacks that are incurred when this is done in resolution .",
    "suppose that @xmath148 are derivations of @xmath40 .",
    "then a refutation @xmath23 of @xmath35 can be constructed by combining all the @xmath148 ( for @xmath41 ) using the following recursive method :    * _ for @xmath136 : _ construct @xmath149 by replacing every leaf occurrence of @xmath138 in @xmath73 by the following subproof ( where @xmath150 are duals of the literals in @xmath37 ) : + @xmath151{\\gamma_1 } {      [ \\ell_2 ^ 1]^2      &      \\ldots      &      [ \\ell_2^{n_1}]^2      &      \\ldots      &      [ \\ell_k^1]^k      &      \\ldots      &      [ \\ell_k^{n_k}]^k      &      \\gamma_1 \\vee \\ldots \\vee \\gamma_k } \\ ] ] + then construct @xmath149 by adding a conflict - driven clause learning to the bottom of @xmath152 : * _ for @xmath49 from @xmath78 to @xmath39 : _ construct @xmath153 by replacing every leaf occurrence of @xmath37 in @xmath148 by the following subproof : @xmath154{\\gamma_i } {      \\infer*[\\varphi'_{i-1}]{\\bot } { } } \\ ] ]    the desired refutation @xmath23 of @xmath35 is taken to be @xmath155 .",
    "this method of simulating splitting in * cr*requires no internal modification of the proofs @xmath148 : the modified proofs @xmath153 ( @xmath156 ) are just @xmath148 with a few @xmath50 inferences on top .",
    "hence , there is no loss in readability , and the only overhead for automatic proof checking is caused by the extra need to check the additional @xmath50 inferences .",
    "if the leaf clause @xmath37 occurs only once does not need to be tree - like . ] , a single @xmath50 inference suffices , in fact .",
    "therefore , the increase in proof size and the overhead for proof checking are negligible .",
    "the simulation described here shows that splitting can be seen as a macro - rule that performs , for a variable - disjoint component @xmath37 , batch decisions assuming the duals of all literals not in @xmath37 .",
    "the first - order mechanism of decisions and conflict - drive clause learning provided by * cr*is , however , more general , because it allows splitting even when the components are not variable - disjoint .",
    "the proof of * cr * s soundness in section [ sec : soundness ] demonstrates that there is a lot in common between * cr*and natural deduction . in the same way that natural deduction can be presented with a sequent notation , in which assumptions are listed in the antecedent of the sequent ( i.e. at the left side of the turnstile symbol ) , *",
    "cr*can also be presented with a sequent notation , with decision literals kept at the antecedent .",
    "this is shown in fig .",
    "[ fig : uprclsequentnotation ] .    * decision : * @xmath157^i}{}\\ ] ]    * initial : * @xmath158    if @xmath0 is an input clause    * unit - propagating resolution : * @xmath51{\\delta_1~\\sigma , \\ldots , \\delta_n~\\sigma , \\delta~\\sigma \\vdash \\ell~\\sigma}{\\delta_1 \\vdash \\ell_1 & \\ldots & \\delta_1 \\vdash \\ell_n & \\delta \\vdash \\dual{\\ell'_1 } \\vee \\ldots \\vee \\dual{\\ell'_n } \\vee \\ell}\\ ] ]    where @xmath20 is a unifier of @xmath52 and @xmath53 , for all @xmath32 .",
    "* conflict : * @xmath54{\\delta_1~\\sigma , \\delta_2~\\sigma \\vdash \\bot}{\\delta_1 \\vdash \\ell & \\delta_2 \\vdash \\dual{\\ell'}}\\ ] ]    where @xmath20 is a unifier of @xmath52 and @xmath53 , for all @xmath32 .    * conflict - driven clause learning : * @xmath55 { \\delta \\vdash ( \\dual{\\ell_1 } \\sigma^1_1 \\vee \\ldots \\vee \\dual{\\ell_1 } \\sigma^1_{m_1 } ) \\vee \\ldots \\vee ( \\dual{\\ell_n } \\sigma^n_1 \\vee \\ldots",
    "\\vee \\dual{\\ell_n } \\sigma^n_{m_n } ) } { \\delta , \\ell_1^i \\sigma^1_1 , \\ldots , \\ell_1^i \\sigma^1_{m_1 } , \\ldots , \\ell_n^i \\sigma^n_1 , \\ldots , \\ell_n^i \\sigma^n_{m_n } \\vdash \\bot } \\ ] ]    where @xmath56 ( for @xmath57 and @xmath58 ) is the composition of all substitutions used on the @xmath59-th path from @xmath52 to @xmath17 .    with the sequent notation",
    ", it is easier to state the inference rule for conflict - driven clause learning .",
    "all the substitutions that should be applied to the literals whose duals will be part of the learned clause have already been applied to the literals in the antecedent .",
    "there is no need to look at the substitutions that have been used in the paths above . on the other hand ,",
    "the presentation with sequent notation is much more redundant and bureaucratic .",
    "whereas in the standard presentation , the use of decision literals is a powerful way to reduce the size of clauses ( as in the simulation of splitting ) , this beneficial effect is lost in the presentation with the sequent notation , because the decision literals are carried along in the antecedents .",
    "for example , if we have the clause @xmath159 , then assuming the duals of the first @xmath1 literals and resolving them with the clause through unit - propagation would result in the unit clause @xmath12 in the standard presentation .",
    "with sequent notation , on the other hand , we would obtain @xmath160 .",
    "while this may be conceptually convenient , because it reminds us explicitly that the unit clause @xmath12 holds only under the assumptions @xmath161 , we have no reduction in size if we also count the antecedent s size .",
    "in fact , because the proof may be a non - tree - like dag , and decision literals may be instantiated by different substitutions along different paths of the dag , several instances of the decision literal will accumulate in the antecedent .",
    "the number of instances may be in the worst case exponential in the height of the derivation .",
    "that is one reason why the standard presentation , where the dependence of @xmath12 on assumptions and the substitutions used to instantiate the decision literals remain implicit in the derivation , is preferable .",
    "this is particularly important during proof search , in which not all inferences are useful and we do not want to apply substitutions and accumulate copies of literals unnecessarily along the derivation .",
    "we should do that only when a conflict , warranting conflict - driven clause learning , is reached .",
    "the seminal work of baumgartner and tinelli ( @xcite ) defining the _ model evolution _ ( me ) procedure was probably the first lifting of dpll to the first - order case .",
    "it was later extended with a lemma learning rule @xcite , while retaining a traditional dpll flavor ( distinct from the _ conflict graph _",
    "approach ) . in model evolution",
    ", decision literals do not contain standard variables , but _ parameters _ , which are variables with special semantics and behavior in the case of backtracking and clause learning .",
    "* cr*may be considered simpler , because it does not introduce the notion of parameter ; however , in contrast to model evolution , for * cr*the problem of interpreting decision literals as a model has not been investigated yet .",
    "more recently , alagi and weidenbach ( @xcite ) proposed the _ non - redundant clause learning _ ( nrcl ) procedure generalizing cdcl to the bernays - schnfinkel fragment of first - order logic .",
    "they introduce the notion of _ blocked decisions and clauses _ , which restricts the decisions that can be made and thus allows them to prove that the learned clause is non - redundant ( whereas in * cr*they might not be ) .",
    "they also introduce the notion of _ constrained literals _ , which allow more compact representation of the model . in * cr * , such optimizations and restrictions are intentionally avoided , in favor of a simple calculus focused on the core aspects of generalizing decisions and conflict - driven clause learning to _ full _ first - order logic .",
    "bonacina , fuhrbach and sofronie - stokkermans ( @xcite ) give a preview of a yet unpublished first - order _ semantically - guided goal sensitive _ ( sggs ) procedure inspired by cdcl . as they observe",
    ", there is a symmetry between positive and negative literals in the propositional case ( i.e. in the sense that when a decision literal @xmath12 is false , @xmath13 is true ) which appears to be lost in the first - order case ( i.e. because when @xmath12 is false , we can not conclude that @xmath13 is true ; we can only conclude that @xmath162 is true for some @xmath20 ) .",
    "one of the main challenges in lifting conflict - driven clause learning to first - order lies precisely in computing and dealing with the substitution @xmath20 when a decision literal @xmath12 leads to a conflict and a clause containing @xmath162 must be learned . instead of addressing this challenge , they circumvent it by introducing the notion of _ uniform falsity _ , according to which @xmath13 must be true when @xmath12 is uniformly false . with this notion , clause learning is still essentially propositional and it is not triggered at every conflict ( in the standard non - uniform sense of conflict ) .",
    "for instance , a conflict between @xmath163 and @xmath164 does not lead to clause learning but must be repaired by revising @xmath163 to @xmath165 instead .",
    "the variety of approaches attempting to generalize cdcl to first - order logic shows that this is not a trivial task .",
    "the most pragmatically successful approaches so far have harnessed the power of sat - solvers in first - order ( or even higher - order ) logic not by generalizing their underlying procedures but simply by employing them as _ black - boxes _ inside a theorem prover @xcite .",
    "the development of the conflict resolution calculus * cr*was initially motivated by the recent success of cdcl and by the desire to generalize its main ideas to first - order logic .",
    "however , * cr*can also be seen as the convergence of two ideas that actually precede cdcl by several decades .",
    "the first one is the assumption mechanism introduced by gentzen ( @xcite ) in his natural deduction calculus .",
    "the second one is robinson s generalization of the resolution rule to first - order logic through unification ( @xcite ) . *",
    "cr*extends resolution as natural deduction extends hilbert - style proof systems : decision literals are essentially assumptions , and conflict driven clause learning corresponds to ( several applications of ) natural deduction s implication introduction rule . and whereas robinson used unification to generalize resolution , * cr*uses unification to generalize conflict - driven clause learning .    from a historical perspective",
    ", what we are seeing today is similar to what happened between 1960 and 1965 . in 1960 , @xcite defined the _ propositional _ resolution rule , which can be regarded as an efficient machine - oriented variant of modus ponens ( implication elimination ) .",
    "the first - order case was then handled by _",
    "grounding / instantiating _ the first - order problem and using the propositional resolution rule . in 1965 ,",
    "@xcite s direct generalization of the resolution rule to the first - order case enabled a breakthrough in first - order automated theorem proving .",
    "nowadays , we have a powerful _ propositional _ conflict driven clause learning rule , which can be regarded as an efficient machine - oriented variant of implication introduction .",
    "the first - order case is being handled by essentially grounding / instantiating the problem in various ways and using the propositional rule .",
    "if history repeats itself , we might see another breakthrough when clause learning is directly lifted to the first - order case through unification , as done in the * cr*calculus proposed here .",
    "a well - defined proof system is just a first step towards the development of a proof search procedure that could be implemented as an efficient theorem prover .",
    "there is much more to the efficiency of a modern sat - solver than just the ideas of decision literals , conflict - driven clause learning and unit - propagation . sat - solvers use restarts , strategies for selecting decision literals and data - structures that allow efficient unit - propagation , fast conflict graph analysis and fast backtracking . adapting these proof search strategies and implementation techniques to the conflict resolution calculus * cr*is beyond the scope of this paper , but is a crucial direction for future work .",
    "[ [ acknowledgements ] ] acknowledgements : + + + + + + + + + + + + + + + + +    bruno is grateful to pascal fontaine , who supervised him during his first post - doc , providing a great opportunity for him to learn some of the essential ideas behind current sat - solvers .",
    "bruno is thankful to peter baumgartner , who shared his experience in model evolution and other related methods , when they discussed the idea of * cr*in may 2015 .",
    "bruno would also like to thank hans de nivelle and jens otten for discussions during the vienna summer of logic about limitations of the tptp proof format that affect the representation of natural deduction and tableau proofs .",
    "gabor alagi and christoph weidenbach .",
    "`` non - redundant clause learning '' . in : _",
    "frocos _ ( 2015 ) , pp .",
    "evert w. beth .",
    "`` semantic entailment and formal derivability '' . in : _",
    "mededelingen van de koninklijke nederlandse akademie van wetenschappen , afdeling letterkunde _ 18.13 ( 1955 ) , pp .",
    "309342 .",
    "leo bachmair and harald ganzinger .",
    "`` completion of first - order clauses with equality by strict superposition ( extended abstract ) '' . in : _",
    "2nd international workshop conditional and typed rewriting systems _ , lncs 516 , springer ( 1990 ) , pp . 162180 .",
    "leo bachmair and harald ganzinger .",
    "`` rewrite - based equational theorem proving with selection and simplification '' . in : _ journal of logic and computation",
    "_ 4.3 ( 1994 ) , pp .",
    "217247 .",
    "peter baumgartner .",
    "`` model evolution based theorem proving '' . in : _ ieee inteligent systems _",
    "29(1 ) ( 2014 ) , pp . 410 .",
    "peter baumgartner and cesare tinelli .",
    "`` the model evolution calculus '' . in : _",
    "cade _ ( 2003 ) , pp .",
    "350364 .",
    "peter baumgartner , alexander fuchs and cesare tinelli .",
    "`` lemma learning in the model evolution calculus '' . in : _",
    "lpar _ ( 2006 ) , pp .",
    "572586 .",
    "armin biere .",
    "`` picosat essentials '' . in : _",
    "journal on satisfiability , boolean modelling and computation ( jsat ) _ ( 2008 ) .",
    "maria paola bonacina , ulrich fuhrbach and viorica sofronie - stokkermans .",
    "`` on first - order model - based reasoning '' . in : _ logic , rewriting and concurrency _ ( 2015 ) , pp .",
    "181204 .",
    "chad e. brown .",
    "`` satallax : an automatic higher - order prover '' . in : _",
    "ijcar _ ( 2012 ) , pp .",
    "111117 .",
    "chad e. brown .",
    "`` reducing higher - order theorem proving to a sequence of sat problems '' . in : _ journal of automated reasoning _ ( 2013 ) , pp .",
    "5777 .    martin davis and hilary putnam .",
    "`` a computing procedure for quantification theory '' . in : _",
    "journal of the acm _ 7 ( 1960 ) , pp .",
    "201215 .",
    "martin davis , george logemann and donald loveland .",
    "`` a machine program for theorem proving '' . in : _ communications of the acm _",
    "5(7 ) ( 1962 ) , pp . 394397 .",
    "gerhard gentzen .",
    "`` untersuchungen ber das logische schlieen i & ii '' . in : _ mathematische zeitschrift _ 39.1 ( 1935 ) , pp .",
    "176210 & 405431 .",
    "konstantin korovin .",
    "`` iprover - an instantiation - based theorem prover for first - order logic ( system description ) '' . in : _",
    "international joint conference on automated reasoning ( ijcar ) _",
    "( 2008 ) , pp .",
    "292298 .",
    "joao marques - silva and k.a .",
    "`` grasp : a new search algorithm for satisfiability '' . in : _",
    "international conference on computer - aided design _ ( 1996 ) , pp .",
    ".    joao marques - silva , ines lynce and sharad malik .",
    "`` conflict - driven clause learning sat solvers '' . in : _ handbook of satisfiability _ ( 2008 ) , pp .",
    "127  149 .",
    "j. mccharen , r. overbeek and l. wos .",
    "`` complexity and related enhancements for automated theorem - proving programs '' . in : _ computers and mathematics with applications _ 2 ( 1976 ) ,",
    "w. mccune .",
    "`` prover9manual '' ( 2006 ) .",
    "alexandre riazanov and andrei voronkov .",
    "`` the design and implementation of vampire '' . in : _",
    "ai communications _ 15(2 - 3)(2002 ) , pp .",
    "91110 .",
    "john alan robinson .",
    "`` a machine - oriented logic based on the resolution principle '' . in : _ journal of the acm _ 12.1 ( 1965 ) , pp .",
    "george robinson and larry wos .",
    "`` paramodulation and theorem - proving in first - order thories with equality '' . in : _",
    "machine intelligence _ 4 ( 1969 ) , pp . 135150 .",
    "stephan schultz .",
    "`` system description : e 1.8 '' . in : _",
    "lpar _ ( 2013 ) , pp .",
    "735743 .",
    "geoff sutcliffe .",
    "`` the tptp problem library and associated infrastructure : the fof and cnf parts , v3.5.0 '' . in : _ journal of automated reasoning _ 43.4 ( 2009 ) ,",
    "337362 .    andrei voronkov .",
    "`` avatar : the architecture for first - order theorem provers '' . in : _ cav _ ( 2014 ) ,",
    "696710 .",
    "uwe waldmann .",
    "`` superposition '' . in : _ encyclopedia of proof systems _",
    "( 2015 ) .",
    "uwe waldmann .",
    "`` saturation with redundancy '' . in : _",
    "encyclopedia of proof systems _ ( 2015 ) .",
    "christoph weidenbach .",
    "`` combining superposition , sorts and splitting '' . in : _ handbook of automated reasoning _ ( 2001 ) , pp .",
    "19652013 .",
    "christoph weidenbach .",
    "`` the theory of spass version 2.0 '' . in : _ spass 2.0 documentation_.    christoph weidenbach , dilyana dimova , arnaud fietzke , rohit kumar , martin suda , patrick wischnewski .",
    "`` spass version 3.5 '' . in : _ cade _ ( 2009 ) , pp .",
    "140145 .",
    "nathan wetzler , marijn heule and warren a. hunt jr .",
    "`` drat - trim : efficient checking and trimming using expressive clausal proofs '' .",
    "in : _ sat _ ( 2014 ) , pp .",
    "422429 .",
    "lintao zhang , conor f. madigan , matthew h. moskewicz , sharad malik . `` efficient conflict driven learning in a boolean satisfiability solver '' . in : _",
    "international conference on computer - aided design _ ( 2001 ) , pp .",
    "a standard natural deduction calculus for minimal quantified logic extended with a classical rule for double negation elimination is shown in fig .  [",
    "fig : nd ] ."
  ],
  "abstract_text": [
    "<S> this paper defines the ( first - order ) conflict resolution calculus : an extension of the resolution calculus inspired by techniques used in modern sat - solvers . </S>",
    "<S> the resolution inference is restricted to ( first - order ) unit - propagation and the calculus is extended with a mechanism for assuming _ decision literals _ and a new inference rule for _ clause learning _ , which is a first - order generalization of the propositional _ conflict - driven clause learning _ ( cdcl ) procedure . </S>",
    "<S> the calculus is sound ( because it can be simulated by natural deduction ) and refutationally complete ( because it can simulate resolution ) , and these facts are proven in detail here .    </S>",
    "<S> australian national university john.slaney@anu.edu.au bruno.wp@gmail.com    proof theory , resolution , natural deduction , sat , first - order logic , conflict - driven clause learning </S>"
  ]
}