{
  "article_text": [
    "the first quantum key distribution ( qkd ) protocols were proposed independently by bennett and brassard  @xcite in 1984  inspired by early work on quantum money by wiesner  @xcite  and by ekert  @xcite in 1991 .",
    "the original papers discussed security in the presence of an eavesdropper that could perform only limited operations on the quantum channel . the first security proofs that considered an unbounded adversary were given more than a decade later  @xcite .",
    "another decade after the first such proof , knig et al .",
    "@xcite showed that the security criterion used was insufficient : even though it guarantees that an eavesdropper can not guess the key , this only holds if the key is never used .",
    "if part of the key is revealed to the eavesdropper  for example , by using it to encrypt a message known to her  the rest becomes insecure .",
    "a new security criterion for qkd was introduced , along with a new proof of security for bb84  @xcite .",
    "it was argued that @xmath0 , the joint state of the final key ( @xmath1 ) and quantum information gathered by an eavesdropper ( @xmath2 ) , must be close to an ideal key , @xmath3 , that is perfectly uniform and independent from the adversary s information @xmath4 : @xmath5 where @xmath6 is the probability that the protocol aborts , , with @xmath7 , instead of explicitly writing the factor @xmath8 .",
    "the two formulations are however mathematically equivalent . ]",
    "@xmath9 is the trace distance and @xmath10 $ ] is a ( small ) real number .",
    ", has also been proposed in the literature .",
    "we discuss this alternative in . ]",
    "the type of security flaw suffered by the early qkd security criteria is well known in classical cryptography .",
    "it was addressed independently by pfitzmann and waidner  @xcite and canetti  @xcite , who introduced general frameworks to define cryptographic security , which they dubbed _ reactive simulatability _ and _ universal composability _ , respectively .",
    "these frameworks were adapted to quantum cryptography by ben - or and mayers  @xcite and unruh  @xcite , and the security of qkd was discussed within these frameworks by ben - or et al .",
    "@xcite and mller - quade and renner  @xcite .",
    "recently , maurer and renner  @xcite introduced a new cryptographic security framework , _ abstract cryptography _ (",
    "ac ) , which both simplifies and generalizes previous frameworks , and applies equally to the classical and quantum settings .",
    "the core idea of all these security frameworks is to prove that the functionality constructed by the real protocol is indistinguishable from the functionality of an ideal resource that fulfills in a perfect way whatever task is expected of the cryptographic protocol  in the case of qkd , this ideal resource provides the two players with a perfect key , unknown to the adversary .",
    "if this ideal system is indistinguishable from the real one , then one can be substituted for the other in any context . players who run a qkd protocol can thus treat the resulting key as if it were perfect , which trivially implies that it can be safely used and composed arbitrarily with other ( secure ) protocols .      since the security criterion of provides the aforementioned compositional guarantees , it is widely used in the qkd literature and generally introduced as the correct security definition ( see , e.g. , the qkd review paper @xcite ) .",
    "a more detailed explanation as to why this is the case is however usually omitted due to the highly involved security frameworks .",
    "even the technical works  @xcite that introduced and discuss do not provide a self contained justification of this security notion .",
    "the current paper aims to fill in this gap by revisiting the security of qkd using the ac framework .",
    "our goals are twofold .",
    "firstly , we provide an introduction to cryptographic security .",
    "we do not discuss the ac framework in detail , but explain the main ideas underlying cryptographic security and illustrate protocol composition with many examples .",
    "secondly , we use this framework to show how can be _",
    "we also provide in an extensive discussion of the interpretation and operational meaning of the trace distance used in .      the traditional approach to defining security  @xcite can be seen as bottom / up .",
    "one first defines ( at a low level ) a computational model ( e.g. , a turing machine ) .",
    "one then defines how the machines communicate ( e.g. , by writing to and reading from shared tapes ) and some form of scheduling .",
    "next , one can define notions of complexity and efficiency .",
    "finally , the security of a cryptosystem can be defined .",
    "abstract cryptography ( ac ) on the other hand uses a top / down approach . in",
    "order to state definitions and develop a theory , one starts from the other end , the highest possible level of abstraction  the composition of abstract systems  and proceeds downwards , introducing in each new lower level only the minimal necessary specializations .",
    "the ( in)distinguishability of the real and ideal systems is defined as a metric on abstract systems , which , at a lower level , can be chosen to capture the distinguishing power of a computationally bounded or unbounded environment .",
    "the abstract systems are instantiated with , e.g. , a synchronous or asynchronous network of ( abstract ) machines .",
    "these machines can be instantiated with either classical or quantum processes .",
    "one may give the analogous example of group theory , which is used to describe matrix multiplication .",
    "in the bottom / up approach , one would start explaining how matrices are multiplied , and then based on this find properties of the matrix multiplication .",
    "in contrast to this , the top / down approach would correspond to first defining the ( abstract ) multiplication group and prove theorems already on this level .",
    "the matrix multiplication would then be introduced as a special case of the multiplicative group .",
    "this simplifies greatly the framework by avoiding unnecessary specificities from lower levels , and does not hard code a computation or communication model ( e.g. , classical or quantum , synchronous or asynchronous ) in the security framework .      in",
    "we start by introducing a simplified version of the ac framework  @xcite , which is sufficient for the specific adversarial structure relevant to qkd , namely honest alice and bob , and dishonest eve . in",
    "we model the real and ideal systems of a generic qkd protocol , and plug it in the ac security framework , obtaining a security definition for qkd . in we",
    "then prove that this can be reduced to . in",
    "we illustrate the composition of protocols in ac with examples of qkd composed in various settings .",
    "we emphasize that this section does not prove that the qkd security criterion is composable  the proof of this follows from the generic proof that the ac framework is composable  @xcite  but illustrates how the security of composed protocols results from the security of individual protocols and the triangle inequality .",
    "further examples can be found in , where we model the security of authentication and compose it with qkd , resulting in a key expansion protocol .",
    "we also provide a substantial review of the trace distance and its operational interpretations in .",
    "in particular , we prove that it corresponds to the probability a distinguisher has of correctly guessing whether it is interacting with the real or ideal qkd system  the measure used in the ac framework  and discuss how to interpet this .",
    "an overview of the other appendices is given on .",
    "a central element in modeling security is that of _ resources _ ",
    "resources used in protocols and resources constructed by protocols . for example , a qkd protocol constructs a functionality which shares a secret key between two players .",
    "this functionality is a resource , which can be used by other protocols , e.g. , to encrypt a message . to construct this secret key resource ,",
    "a qkd protocol typically uses two other resources , an authentic classical channel and an insecure quantum channel .",
    "the authentic channel resource can in turn be constructed from an insecure channel resource and a password  @xcite . composing the authentication protocol with the qkd protocol results in a scheme which constructs a secret key from a password and insecure channels .",
    "part of the resulting secret key can be used in further rounds of authentication and qkd to produce even more secret key .",
    "this is illustrated in .",
    "( a1 ) at ( 0*,0 ) short password ; ( a3 ) at ( 2*,0 ) insecure classical channel ; ( b2 ) at ( 1*,3 ) authentic channel ; ( n2 ) at ( 1*,1.5 ) ; ( b4 ) at ( 3*,3 ) insecure quantum channel ; ( c3 ) at ( 2*,6 ) long secret key ; ( o3 ) at ( 2*,4.5 ) ; ( c1 ) at ( 0*,6 ) insecure classical channel ; ( c5 ) at ( 4*,6 ) insecure classical channel ; ( d2 ) at ( 1*,9 ) authentic channel ; ( d4 ) at ( 3*,9 ) authentic channel ; ( p2 ) at ( 1*,7.5 ) ; ( p4 ) at ( 3*,7.5 ) ; ( e25 ) at ( 1.5*,12 ) secure channel ; ( q3 ) at ( 2*,9 ) ; ( r25 ) at ( 1.5*,10.5 ) ; ( d6 ) at ( 5*,9 ) insecure quantum channel ; ( e5 ) at ( 4*,12 ) long secret key ; ( r5 ) at ( 4*,10.5 ) ;    ( a1 ) to ( n2.center ) ; ( a3 ) to ( n2.center ) ; ( n2.center ) to node[auto ] authentication ( b2 ) ; ( b2 ) to ( o3.center ) ; ( b4 ) to ( o3.center ) ; ( o3.center ) to node[auto ] qkd ( c3 ) ; ( c1 ) to ( p2.center ) ; ( c3 ) to ( p2.center ) ; ( p2.center ) to node[auto ] authentication ( d2 ) ; ( c3 ) to ( p4.center ) ; ( c5 ) to ( p4.center ) ; ( p4.center ) to node[auto , swap ] authentication ( d4 ) ; ( c3 ) to ( q3.center ) ; ( d2 ) to ( r25.center ) ; ( q3.center ) to ( r25.center ) ; ( r25.center ) to node[auto ] one - time pad ( e25 ) ; ( d4 ) to ( r5.center ) ; ( d6 ) to ( r5.center ) ; ( r5.center ) to node[auto , swap ] qkd ( e5 ) ;    for any cryptographic task one can define an ideal resource which fullfils this task in a perfect way .",
    "a protocol is then considered secure if the real resource actually constructed is indistinguishable from a system running the ideal resource .",
    "this notion of security based on distinguishing real and ideal systems is explained informally in .",
    "it is then illustrated with the one - time pad with a bit of a key @xmath11 , and transmits the resulting ciphertext @xmath12 to the receiver .",
    "the message , which can be decrypted by performing the reverse operation @xmath13 , is hidden from any player who intercepts the ciphertext @xmath14 but has no knowledge of the key @xmath11 . ] in . in",
    "we give a formal security definition in the abstract cryptography ( ac ) framework for the special case of three party protocols with honest alice and bob , and dishonest eve .",
    "finally , in we discuss how the metric used to quantify the ( in)distinguishability between the real and ideal settings should be interpreted .",
    "cryptography aims at providing security guarantees in the presence of an _ adversary_. and traditionally , security has been defined with respect to the information gathered by this adversary  but , as we shall see , this can be insufficient to achieve the desired security guarantees .",
    "a typical example of this is the security criterion used in early papers on qkd , e.g. , @xcite",
    ". let @xmath1 be the secret key produced by a run of a qkd protocol , and @xmath15 be a random variable obtained by an adversary attacking the scheme and measuring her quantum system @xmath2 .",
    "it can be argued that the key is unknown to the adversary if she gains only negligible information about it , i.e. , if for all attacks and measurements of the resulting quantum system , @xmath16 where @xmath17 is the mutual information between @xmath1 and @xmath15 .",
    "however , even if a key obtained from a protocol satisfying is used in a perfectly secure encryption scheme like the one - time pad , it can leak information about the message .",
    "knig et al .",
    "@xcite give such an example : they find a quantum state @xmath0 which satisfies , but which can not be used to encrypt a message partly known to an adversary .",
    "they show that if the key is split in two , @xmath18 , and the adversary delays measuring her system @xmath2 until the first part , @xmath19 , is revealed to her ",
    "e.g. , because a known message was encrypted by the one - time pad with @xmath19  she can obtain information about the rest of the key . more precisely , they prove that for this state @xmath20 , @xmath21 where @xmath22 is a random variable obtained by a measurement of the joint state @xmath23 consisting of the partial key @xmath19 and the quantum information @xmath2 gathered during the qkd protocol .",
    "even though the key obtained from the qkd protocol is approximately uniform and independent from the adversary s information @xmath15 , it is unusable in a cryptographic context , and another approach than the adversarial viewpoint is necessary for defining cryptographic security .",
    "this new approach was proposed independently by canetti  @xcite and pfitzmann and waidner  @xcite for classical cryptography .",
    "the gist of their global security paradigm lies in measuring how well some _ real _ protocol can be distinguished from some _ ideal _ system that fullfils the task in an ideal way , and is often referred to as the `` real / world ideal / world '' paradigm .    to do this",
    ", the notion of an adversary is dropped in favor of a _ distinguisher_. apart from having the capabilities of the adversary , this distinguisher also encompasses any protocol that is run before , after , and during the protocol being analyzed .",
    "the role of the distinguisher is to capture `` the rest of the world '' , everything that exists outside of the honest players and the resources they share .",
    "a distinguisher is defined as an entity that can choose the inputs of the honest players ( that might come from a previously run protocol ) , receives their outputs ( that could be used in a subsequent protocol ) , and simultaneously fullfils the role of the adversary , possibly eavesdropping on the communication channels and tampering with messages .",
    "this distinguisher is given a black box access to either the real or an ideal system , and must decide with which of the two it is interacting . a protocol",
    "is then considered secure if the real system constructed is indistinguishable from the ideal one .",
    "this is illustrated in .",
    ".6 2.27    ( r1 ) at ( 0 , ) ; ( r2 ) at ( 0,0 ) ; ( r3 ) at ( 0,- ) ; ( rr1 ) at ( -,0 ) ; ( rr2 ) at ( 0,0 ) ; ( rr3 ) at ( , 0 ) ; ( r ) at ( 0,0 ) real system ;    ( -1.618 - 1.15,1 )  + +",
    "( .75,0 )  + + ( 0,-2.4 )  + + ( 1.618 * 2+.8,0 )  + + ( 0,2.4 )  + + ( .75,0 )  + + ( 0,-3.4 )  + + ( -1.618 * 2 - 2.3,0 )  cycle ;    at ( 0 , ) distinguisher ; ( dd1 ) at ( - , ) ; ( dd2 ) at ( 0 , ) ; ( dd3 ) at ( , ) ; ( d1 ) at ( - , ) ; ( d2 ) at ( -,0 ) ; ( d3 ) at ( -,- ) ; ( d4 ) at ( , ) ; ( d5 ) at ( , 0 ) ; ( d6 ) at ( , - ) ; ( d0 ) at ( 0,-.5-.7 ) ;    ( rr1 ) to ( dd1 ) ; ( dd2 ) to ( rr2 ) ; ( rr3 ) to ( dd3 ) ; ( d1 ) to ( r1 ) ; ( r2 ) to ( d2 ) ; ( d3 ) to ( r3 ) ; ( r1 ) to ( d4 ) ; ( d5 ) to ( r2 ) ; ( r3 ) to ( d6 ) ; ( dd2 ) to node[auto , pos=.6 ] @xmath24 ( d0 ) ;    ( i1 ) at ( 0 , ) ; ( i2 ) at ( 0,0 ) ; ( i3 ) at ( 0,- ) ; ( ii1 ) at ( -,0 ) ; ( ii2 ) at ( 0,0 ) ; ( ii3 ) at ( , 0 ) ; ( i ) at ( 0,0 ) ideal system ;    ( -1.618 - 1.15,1 )  + +",
    "( .75,0 )  + + ( 0,-2.4 )  + + ( 1.618 * 2+.8,0 )  + + ( 0,2.4 )  + + ( .75,0 )  + + ( 0,-3.4 )  + + ( -1.618 * 2 - 2.3,0 )  cycle ;    at ( 0 , ) distinguisher ; ( ee1 ) at ( - , ) ; ( ee2 ) at ( 0 , ) ; ( ee3 ) at ( , ) ; ( e1 ) at ( - , ) ; ( e2 ) at ( -,0 ) ; ( e3 ) at ( -,- ) ; ( e4 ) at ( , ) ; ( e5 ) at ( , 0 ) ; ( e6 ) at ( , - ) ; ( e0 ) at ( 0,-.5-.7 ) ;    ( ii1 ) to ( ee1 ) ; ( ee2 ) to ( ii2 ) ; ( ii3 ) to ( ee3 ) ; ( e1 ) to ( i1 ) ; ( i2 ) to ( e2 ) ; ( e3 ) to ( i3 ) ; ( i1 ) to ( e4 ) ; ( e5 ) to ( i2 ) ; ( i3 ) to ( e6 ) ; ( ee2 ) to node[auto , pos=.6 ] @xmath24 ( e0 ) ;    in the case of qkd , this means that the distinguisher does not only obtain the system @xmath2 of the eavesdropper , but also receives the final key @xmath1 generated by alice and bob . in the real world , this key is potentially correlated to @xmath2 , and in an ideal system , @xmath1 is uniformly random and independent from @xmath2 .",
    "the distinguisher can then run the attack of knig et al .",
    "@xcite to distinguish between the real and ideal systems : if @xmath22 , the result of the measurement of @xmath19 and @xmath2 is correlated to @xmath25 , it knows that it was given the real system , otherwise it must have the ideal one .",
    "this specific attack is illustrated in more detail in .      in this section ,",
    "we illustrate with the one - time pad how security is defined in the real / world ideal / world paradigm .",
    "the one - time pad protocol uses a secret key @xmath11 to encrypt a message @xmath26 as @xmath27 .",
    "the ciphertext @xmath14 is then sent on an authentic channel to the receiver , who decrypts it , obtaining @xmath28 .",
    "@xmath14 is however also leaked to the adversary that is eavesdropping on the authentic channel . this is depicted in .",
    "2.89 .75    ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( a ) at ( -,0 ) @xmath29 + @xmath30 ; at ( a.north west ) @xmath31 ; ( alice ) at ( -,0 ) alice ;    ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ; ( b ) at ( , 0 ) @xmath32 + @xmath33 ; at ( b.north west ) @xmath34 ; ( bob ) at ( , 0 ) bob ;    ( keybox ) at ( 0 , ) ; ( key ) at ( 0 , ) key ; at ( keybox.north west ) secret key ; ( channel ) at ( 0,- ) ; at ( channel.north west ) authentic channel ; ( eve ) at ( 0,-1.95 ) eve ; ( junc ) at ( eve |- a3 ) ;    ( key ) to node[auto , swap , pos=.3 ] @xmath11 ( a1 ) ; ( key ) to node[auto , pos=.3 ] @xmath11 ( b1 ) ;    ( alice ) to node[auto , pos=.38 ] @xmath26 ( a2 ) ; ( b2 ) to node[auto , pos=.6 ] @xmath26 ( bob ) ;    ( a3 ) to node[pos=.11,auto ] @xmath14 node[pos=.89,auto ] @xmath14 ( b3 ) ; ( junc.center ) to node[pos=.75,auto ] @xmath14 ( eve ) ;    the one - time pad protocol thus uses two resources , a secret key and an authentic channel .",
    "the resource we wish to construct with this encryption scheme is a secure channel : a resource which transmits a message @xmath26 from the sender to the receiver , and leaks only information about the message size @xmath35 at the adversary s interface , but not the contents of the message .",
    "this is illustrated in .",
    "( keybox ) at ( 0,0 ) ; ( alice ) at ( -2.6,0 ) alice ; ( bob ) at ( 2.6,0 ) bob ; ( eve ) at ( 0,-1.7 ) eve ; ( ajunc ) at ( eve.north |- alice ) ;    ( alice ) to node[pos=.06,auto ] @xmath26 node[pos=.94,auto ] @xmath26 ( bob ) ; ( ajunc.center ) to node[pos=.85,auto , swap ] @xmath35 ( eve ) ;    since an ideal resource `` magically '' solves the cryptographic task considered , e.g. , by producing perfect secret keys or transmitting a message directly from alice to bob , the adversary s interface of the ideal resource is usually quite different from her interface of the real system , which gives her access to the resources used .",
    "for the one - time pad , the real system from outputs a string @xmath14 at eve s interface , but the ideal secure channel from outputs an integer , @xmath35 . to make the comparison between real and ideal systems possible , we define the ideal system to consist of the ideal resource as well as a _ simulator _ plugged into the adversary s interface of the ideal resource , that recreates the communication occurring in the real system . for the one - time pad , this simulator must generate a ciphertext @xmath14 given the message length @xmath35 .",
    "this is simply done by generating a random string of the appropriate length , as depicted in .",
    "note that putting such a simulator between the ideal resource and the adversary can only weaken her , since any operation performed by the simulator could equivalently be performed by an adversary connected directly to the interface of the ideal resource .",
    "-.75 .75 ( channel ) at ( 0 , ) ; at ( channel.north west ) secure channel ; ( alice ) at ( -2.6 , ) alice ; ( bob ) at ( 2.6 , ) bob ;    ( sim ) at ( 0 , ) ; at ( sim.north west ) @xmath36 ; ( rand ) at ( 0 , ) random string ;    ( alice ) to node[pos=.06,auto ] @xmath26 node[pos=.93,auto ] @xmath26 ( bob ) ; ( 0 , ) to node[pos=.6,auto ] @xmath35 ( rand ) ;    ( eve ) at ( 0,-.2 ) eve ; ( rand ) to node[pos=.65,auto ] @xmath14 ( eve ) ;    to prove that the one - time pad constructs a secure channel from an authentic channel and a secret key , we view the real and ideal one - time pad systems of and as black boxes , and need to show that no distinguisher can tell with which of the two it has been connected . for both black boxes ,",
    "if the distinguisher inputs @xmath26 at alice s interface , the same string @xmath26 is output at bob s interface and a uniformly random string of length @xmath35 is output at eve s interface .",
    "the two systems are thus completely indistinguishable  if the distinguisher were to take a guess , it would be right with probability exactly @xmath37  and we say that the one - time pad has perfect security .    if two systems are indistinguishable , they can be used interchangeably in any setting .",
    "for example , let some protocol @xmath38 be proven secure if alice and bob are connected by a secure channel .",
    "since the one - time pad constructs such a channel , it can be used in lieu of the secure channel , and composed with @xmath38 . or equivalently , the contrapositive : if composing the one - time pad and @xmath38 were to leak some vital information , which would not happen with a secure channel , a distinguisher that is either given the real or ideal system could run @xmath38 internally and check whether this leak occurs to know with which of the two it is interacting .",
    "the previous sections introduced the concepts of resources , protocols and simulator in an informal manner . in the ac framework",
    "these elements are defined in an abstract way .",
    "for example , a resource is an abstract system that is shared between all players and provides each one with an interface that allows in- and outputs .",
    "ac does not define the internal workings of a resource .",
    "it postulates axioms that these abstract systems must fulfill  e.g. there must exist a metric and a parallel composition operator on the space of resources  and is valid for any instantiation which respects these axioms . in the group theory analogy introduced in , these axioms correspond to the group axioms ( closure , associativity , identity and invertibility ) . any set and operation that respects these group axioms is an instantiation of a group , and any theorem proven for groups applies to this instantiation .",
    "thus , ac defines cryptographic security for abstract systems which fulfill certain basic properties . in the following",
    "we briefly sketch what these are .",
    "note that examples  such as the model of the one - time pad given in figures  [ fig : otp.real ] and [ fig : otp.ideal ]  necessarily assume some instantiation of the abstract systems .",
    "since we consider only simple examples in this work , we do not provide formal generic definitions of these lower levels , and refer to the discussions in @xcite on how this can be modeled .",
    "[ [ resource . ] ] resource .",
    "+ + + + + + + + +    an _",
    "@xmath39-resource _ is an ( abstract ) system with interfaces specified by a set @xmath39 ( e.g. , @xmath40 ) .",
    "each interface @xmath41 is accessible to a user @xmath42 and provides her or him with certain controls ( the possibility of reading outputs and providing inputs ) .",
    "resources are equipped with a parallel composition operator , @xmath43 , that maps two resources to another resource .",
    "[ [ converter . ] ] converter .",
    "+ + + + + + + + + +    to transform one resource into another , we use _",
    "these are ( abstract ) systems with two interfaces , an _ inside _ interface and an _ outside _ interface .",
    "the inside interface connects to an interface of a resource , and the outside interface becomes the new interface of the constructed resource .",
    "we write either @xmath44 or @xmath45 to denote the new resource with the converter @xmath46 connected at the interface @xmath42 of @xmath47 , and @xmath45 .",
    "it sometimes simplifies the notation to have the converters for some players written on the right of the resource and the ones for other players on the left , instead of all on the same side , hence the two notations . ] and @xmath48 or @xmath49 for a set of converters @xmath50 , for which it is clear to which interface they connect .",
    "a protocol is a set of converters ( one for every honest player ) and a simulator is also a converter .",
    "another type of converter that we need is a _ filter _ , which we often denote by @xmath51 or @xmath52 .",
    "when placed over a dishonest player s interface , a filter prevents access to the corresponding controls and emulates an honest behavior .",
    "serial and parallel composition of converters is defined as follows : @xmath53    [ [ filtered - resource . ] ] filtered resource .",
    "+ + + + + + + + + + + + + + + + + +    a pair of a resource @xmath47 and a filter @xmath51 together specify the ( reactive ) behavior of a system both when no adversary is present  with the filter plugged in the adversarial interface , @xmath54  and in the case of a cheating player that removes the filter and has full access to her interface of @xmath47 .",
    "we call such a pair @xmath55 a _ filtered resource _ , and usually denote it by @xmath56 .    [ [ metric . ] ] metric .",
    "+ + + + + + +    there must exist a pseudo / metric @xmath57 on the space of resources , i.e. , for any three resources @xmath58 , it satisfies the following conditions : , then @xmath59 is a metric . ]",
    "@xmath60 furthermore , this pseudo / metric must be non - increasing under composition with resources and converters : for any converter @xmath46 and resources @xmath58 , we require @xmath61    we are now ready to define the security of a cryptographic protocol .",
    "we do so in the three player setting , for honest alice and bob , and dishonest eve .",
    "thus , in the following , all resources have three interfaces , denoted @xmath62 , @xmath63 and @xmath2 , and we only consider honest behaviors ( given by a protocol @xmath64 ) at the @xmath62 and @xmath63/interfaces , but arbitrary behavior at the @xmath2/interface .",
    "we refer to @xcite for the general case , when arbitrary players can be dishonest .",
    "[ def : security ] let @xmath65 be a protocol and @xmath66 and @xmath67 denote two filtered resources .",
    "we say that _ @xmath68 constructs @xmath69 from @xmath56 within @xmath70 _ , which we write @xmath71 , if the two following conditions hold :    1 .",
    "[ eq : def.cor ] we have @xmath72 2 .   [ eq : def.sec ] there exists a converter @xmath73  which we call simulator  such that @xmath74    if it is clear from the context what filtered resources @xmath56 and @xmath75 are meant , we simply say that @xmath68 is @xmath70/secure .",
    "the first of these two conditions measures how close the constructed resource is to the ideal resource in the case where no malicious player is intervening , which we call _ availability_. the second condition captures _ security _ in the presence of an adversary .",
    "these two equations are illustrated in .",
    "2.9 .6    ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( a ) at ( -,0 ) ; at ( a.north west ) @xmath76 ; ( alice1 ) at ( - , ) ; ( alice2 ) at ( -,0 ) ; ( alice3 ) at ( -,- ) ;    ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ; ( b ) at ( , 0 ) ; at ( b.north west ) @xmath77 ; ( bob1 ) at ( , ) ; ( bob2 ) at ( , 0 ) ; ( bob3 ) at ( , - ) ;    ( r1 ) at ( 0 , ) ; ( r2 ) at ( 0,0 ) ; ( r3 ) at ( 0,- ) ; ( rr1 ) at ( -,0 ) ; ( rr2 ) at ( 0,0 ) ; ( rr3 ) at ( , 0 ) ; ( r ) at ( 0,0 ) ; at ( r.north west ) @xmath47 ;    ( eve1 ) at ( -,- ) ; ( eve2 ) at ( 0,- ) ; ( eve3 ) at ( , - ) ;    ( fi ) at ( 0,-1.9 ) ; at ( fi.north west ) @xmath78 ;    ( alice1 ) to ( a1 ) ; ( a2 ) to ( alice2 ) ; ( alice3 ) to ( a3 ) ;    ( a1 ) to ( r1 ) ; ( r2 ) to ( a2 ) ; ( a3 ) to ( r3 ) ;    ( r1 ) to ( b1 ) ; ( b2 ) to ( r2 ) ; ( r3 ) to ( b3 ) ;    ( b1 ) to ( bob1 ) ; ( bob2 ) to ( b2 ) ; ( b3 ) to ( bob3 ) ;    ( rr1 ) to ( eve1 ) ; ( eve2 ) to ( rr2 ) ; ( rr3 ) to ( eve3 ) ;    at ( , 0 ) @xmath79 ;    ( s1 ) at ( , + ) ; ( s2 ) at ( , ) ; ( s3 ) at ( , -+ ) ; ( ss1 ) at ( - , ) ; ( ss2 ) at ( , ) ; ( ss3 ) at ( + , ) ; ( s ) at ( , ) ; at ( s.north west ) @xmath80 ;    ( t1 ) at ( -,- ) ; ( t2 ) at ( , - ) ; ( t3 ) at ( + , - ) ; ( fil ) at ( , - ) ; at ( fil.north east ) @xmath81 ;    ( cate1 ) at ( -,+ ) ; ( cate2 ) at ( - , ) ; ( cate3 ) at ( -,-+ ) ;    ( dave1 ) at ( + , + ) ; ( dave2 ) at ( + , ) ; ( dave3 ) at ( + , -+ ) ;    ( cate1 ) to ( s1 ) ; ( s2 ) to ( cate2 ) ; ( cate3 ) to ( s3 ) ;    ( s1 ) to ( dave1 ) ; ( dave2 ) to ( s2 ) ; ( s3 ) to ( dave3 ) ;    ( ss1 ) to ( t1 ) ; ( t2 ) to ( ss2 ) ; ( ss3 ) to ( t3 ) ;    2.9 .6    ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( a ) at ( -,0 ) ; at ( a.north west ) @xmath76 ; ( alice1 ) at ( - , ) ; ( alice2 ) at ( -,0 ) ; ( alice3 ) at ( -,- ) ;    ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ; ( b ) at ( , 0 ) ; at ( b.north west ) @xmath77 ; ( bob1 ) at ( , ) ; ( bob2 ) at ( , 0 ) ; ( bob3 ) at ( , - ) ;    ( r1 ) at ( 0 , ) ; ( r2 ) at ( 0,0 ) ; ( r3 ) at ( 0,- ) ; ( rr1 ) at ( -,0 ) ; ( rr2 ) at ( 0,0 ) ; ( rr3 ) at ( , 0 ) ; ( r ) at ( 0,0 ) ; at ( r.north west ) @xmath47 ;    ( eve1 ) at ( -,- ) ; ( eve2 ) at ( 0,- ) ; ( eve3 ) at ( , - ) ;    ( alice1 ) to ( a1 ) ; ( a2 ) to ( alice2 ) ; ( alice3 ) to ( a3 ) ;    ( a1 ) to ( r1 ) ; ( r2 ) to ( a2 ) ; ( a3 ) to ( r3 ) ;    ( r1 ) to ( b1 ) ; ( b2 ) to ( r2 ) ; ( r3 ) to ( b3 ) ;    ( b1 ) to ( bob1 ) ; ( bob2 ) to ( b2 ) ; ( b3 ) to ( bob3 ) ;    ( rr1 ) to ( eve1 ) ; ( eve2 ) to ( rr2 ) ; ( rr3 ) to ( eve3 ) ;    at ( , 0 ) @xmath79 ;    ( s1 ) at ( , + ) ; ( s2 ) at ( , ) ; ( s3 ) at ( , -+ ) ; ( ss1 ) at ( - , ) ; ( ss2 ) at ( , ) ; ( ss3 ) at ( + , ) ; ( s ) at ( , ) ; at ( s.north west ) @xmath80 ;    ( t1 ) at ( -,- ) ; ( t2 ) at ( , - ) ; ( t3 ) at ( + , - ) ; ( sim ) at ( , - ) ; at ( sim.north east ) @xmath73 ;    ( cate1 ) at ( -,+ ) ; ( cate2 ) at ( - , ) ; ( cate3 ) at ( -,-+ ) ;    ( dave1 ) at ( + , + ) ; ( dave2 ) at ( + , ) ; ( dave3 ) at ( + , -+ ) ;    ( finn1 ) at ( -,- ) ; ( finn2 ) at ( , - ) ; ( finn3 ) at ( + , - ) ;    ( cate1 ) to ( s1 ) ; ( s2 ) to ( cate2 ) ; ( cate3 ) to ( s3 ) ;    ( s1 ) to ( dave1 ) ; ( dave2 ) to ( s2 ) ; ( s3 ) to ( dave3 ) ;    ( ss1 ) to ( t1 ) ; ( t2 ) to ( ss2 ) ; ( ss3 ) to ( t3 ) ;    ( t1 ) to ( finn1 ) ; ( finn2 ) to ( t2 ) ; ( t3 ) to ( finn3 ) ;    it follows from the ac framework  @xcite that if two protocols @xmath82 and @xmath38 are @xmath70- and @xmath83/secure , the composition of the two is @xmath84/secure .",
    "we illustrate this with several examples in and , and sketch a generic proof in .",
    "the usual pseudo / metric used to define security in the real / world ideal / world paradigm is the _ distinguishing advantage _ , defined as follows .",
    "if a distinguisher @xmath85 can guess correctly with probability @xmath86 with which of two systems @xmath47 and @xmath80 it is interacting , we define its advantage as @xmath87 changing the power of the distinguisher @xmath85 ( e.g. , computationally bounded or unbounded ) results in different metrics and different levels of security . in this work",
    "we are interested only in information / theoretic security , we therefore consider only a computationally unbounded distinguisher , and drop the superscript @xmath85 .",
    "we write @xmath88 if two systems @xmath47 and @xmath80 can be distinguished with advantage at most @xmath70 , and in the following , the distance between two resources always refers to the distinguishing advantage of an unbounded distinguisher .",
    "a more extensive discussion of distinguishers is given in .",
    "although any pseudo / metric which satisfies the basic axioms can be used in , the distinguishing advantage is of particular importance , because it has an operational definition  the advantage a distinguisher has in guessing whether it is interacting with the real or ideal system .",
    "if the distinguisher notices a difference between the two , then something in the real setting did not behave ideally .",
    "this can be loosely interpreted as a failure occurring .",
    "if the distinguisher can guess correctly with probability @xmath89 with which system it is interacting , a failure must occur systematically .",
    "if it can only guess correctly with probability @xmath37 , no failure occurs at all .",
    "if it can guess correctly with probability @xmath90 , this can be seen as a failure occurring with probability @xmath91 .",
    "the distinguishing advantage can thus be interpreted as the probability that a failure occurs in the real protocol . and",
    "in any practical implementation , the value @xmath70 can be chosen accordingly .",
    "a bound on the security of a protocol does however not tell us how `` bad '' this failure is .",
    "for example , a key distribution protocol which produces a perfectly uniform key , but with probability @xmath70 alice and bob end up with different keys , is @xmath70/secure .",
    "likewise , a protocol which gives @xmath89 bit of the key to eve with probability @xmath70 , but is perfect otherwise , and another protocol which gives the entire key to eve with probability @xmath70 , but is perfect otherwise , are both @xmath70/secure as well .",
    "one could argue that leaking the entire key is worse than leaking one bit , which is worse than not leaking anything but generating mismatching keys , and this should be reflected in the level of security of the protocol .",
    "however , leaking one bit can be as bad as leaking the entire key if only one bit of the message is vital , and this happens to be the bit obtained by eve .",
    "having mismatching keys and therefore misinterpreting a message could have more dire consequences than leaking the message to eve .",
    "how bad a failure is depends on the use of the protocol , and since the purpose of cryptographic security is to make a security statement that is valid for all contexts , bounding the probability that a failure occurs is the best it can do .",
    "since such a security bound gives no idea of the gravity of a failure  a faulty qkd protocol might not only leak the current key , but all future keys as well if the current key is used to authenticate messages in future rounds  the probability @xmath70 of a failure occurring must be chosen small enough that the accumulation of all possible failure probabilities over a lifetime is still small enough .",
    "for example , if an implementation of a qkd protocol produces a key at a rate of @xmath89 mbit / s with a failure per bit of @xmath92 , then this protocol can be run for the age of the universe and still have an accumulated failure strictly less than @xmath89 .",
    "in order to apply the general ac security definition to qkd , we need to specify the ideal key filtered resource , which we do in .",
    "likewise , we specify in the real qkd system consisting of the protocol , an authentic classical channel and an insecure quantum channel . plugging these systems in",
    ", we obtain in the security criteria for qkd .",
    "the goal of a key distribution protocol is to generate a secret key shared between two players .",
    "one can represent such a resource by a box , one end of which is in alice s lab , and another in bob s .",
    "it provides each of them with a secret key of a given length , but does not give eve any information about the key .",
    "this is illustrated in , and is the key resource we used in the one - time pad construction ( ) .",
    "[ .5][c ]    0 ( keybox ) at ( 0,0 ) ; ( alice ) at ( -2.5 , ) alice ; ( bob ) at ( 2.5 , ) bob ; ( eve ) at ( 0,-1.7 ) eve ; ( key ) at ( 0,0 ) key ;    ( key ) to node[pos=.55,auto , swap ] @xmath11 ( alice ) ; ( key ) to node[pos=.55,auto ] @xmath11 ( bob ) ;    [ .5][c ]    .236 ( keybox ) at ( 0,0 ) ; ( alice ) at ( -2.5 , ) alice ; ( bob ) at ( 2.5 , ) bob ; ( eve ) at ( 0,-1.7 ) eve ; ( key ) at ( .8,/2-.5 ) key ; ( junc ) at ( -.5,0 |- key.center ) ;    ( alice ) to node[pos=.2,auto ] @xmath93 node[pos=.8,auto ] @xmath93 ( bob ) ; ( junc.center |- 0 , ) to ( junc.center ) to node[pos=.666 ] ( handle ) + ( 160:-.8 ) ; ( .3,0 |- junc.center ) to ( key ) ; ( eve ) to node[pos=.2,auto ] @xmath24 ( handle.center ) ;    [ .5][c ]    -1.85 .118    ( keybox ) at ( 0,0 ) ; ( key ) at ( 0,/2-.25 ) key ; ( junc ) at ( -1.4,0 |- key.center ) ; at ( keybox.north west ) secret key @xmath94 ; ( alice ) at ( - , ) ; ( bob ) at ( , ) ;    ( alice.center ) to node[pos=.08,auto ] @xmath93 node[pos=.92,auto ] @xmath93 ( bob.center ) ; ( junc.center |- 0 , ) to ( junc.center ) to node[pos=.472 ] ( handle ) + ( 160:-.8 ) ; ( -.6,0 |- junc.center ) to ( key ) ;    ( sim ) at ( 0,+.35 ) ; at ( sim.north west ) @xmath81 ; ( a1 ) at ( handle |- 0,+.35 ) ;    ( a1 ) to node[pos=.55,auto , swap ] @xmath24 ( handle.center ) ;    [ .5][c ]    -1.85 .118    ( keybox ) at ( 0,0 ) ; ( key ) at ( 0,/2-.25 ) key ; ( junc ) at ( -1.4,0 |- key.center ) ; at ( keybox.north west ) secret key @xmath94 ; ( alice ) at ( - , ) ; ( bob ) at ( , ) ;    ( alice.center ) to node[pos=.08,auto ] @xmath93 node[pos=.92,auto ] @xmath93 ( bob.center ) ; ( junc.center |- 0 , ) to ( junc.center ) to node[pos=.472 ] ( handle ) +",
    "( 160:-.8 ) ; ( -.6,0 |- junc.center ) to ( key ) ;    ( sim ) at ( 0 , ) ; at ( sim.north west ) @xmath73 ; ( a1 ) at ( -,+.35 ) ; ( a2 ) at ( -,u-.35 ) ; ( b2 ) at ( , u-.35 ) ; ( c2 ) at ( 0,u-.35 ) ;    ( evel ) at ( - , ) ; ( evec ) at ( 0 , ) ; ( ever ) at ( , ) ;    ( a1 ) to node[pos=.55,auto , swap ] @xmath24 ( handle.center ) ; ( a2 ) to ( evel.center ) ; ( evec.center ) to ( c2 ) ; ( b2 ) to ( ever.center ) ;    however , if we wish to realize such a functionality with qkd , there is a caveat : an eavesdropper can always prevent any real qkd protocol from generating a key by cutting or jumbling the communication lines between alice and bob , and this must be reflected in the definition of the ideal resource .",
    "this box thus also has an interface accessible to eve , which provides her with a switch that , when pressed , prevents the box from generating this key .",
    "we depict this in .",
    "if modeled with the secret key resource of , the one - time pad is trivially secure conditioned on eve preventing a key from being distributed  in this case , alice and bob do not have a key and do not run the one - time pad .",
    "the security of the one - time pad is thus reduced to the case where a key is generated , which corresponds to and is the situation analyzed in .",
    "if no adversary is present , a filter covers eve s interface of the resource , making it inaccessible to the distinguisher .",
    "this filter emulates the honest behavior that one expects in the case of a non / malicious noisy channel . for a protocol and noisy channel that together produce a key with probability @xmath95",
    ", the filter should flip the switch on the @xmath2/interface of the ideal key with probability @xmath96 .",
    "this is illustrated in , and discussed in more detail in .",
    "[ rem : adaptive ] for a protocol to construct the shared secret key resource of , it must either abort or produce a key of a fixed length .",
    "a more practical protocol could adapt the secret key length to the noise level on the quantum channel .",
    "this provides the adversary with the functionality to control the key length ( not only whether it gets generated or not ) , and can be modeled by allowing the key length to be input at eve s interface of the ideal key resource .      to construct the secret key resource of",
    ", a qkd protocol uses some other resources : a two - way authentic classical channel and an insecure quantum channel .",
    "an authentic channel faithfully transmits messages between alice and bob , but provides eve with a copy as well .",
    "an insecure channel is completely under the control of eve , she can apply any operation allowed by physics to the message on the channel .",
    "if eve does not intervene , some noise might still be present on the channel , which is modeled by a filter that prevents eve from reading the message , but introduces honest noise instead . since an authentic channel can be constructed from an insecure channel and a short shared secret key , qkd",
    "is sometimes referred to as a _ key expansion _ protocol .",
    "a qkd protocol typically has three phases : quantum state distribution , error estimation and classical post / processing ( for a detailed review of qkd see @xcite ) . in the first",
    ", alice sends some quantum states on the insecure channel to bob , who measures them upon reception , obtaining a classical string . in the error estimation phase",
    ", they communicate on the ( two - way ) authentic classical channel to sample some bits at random positions in the string and estimate the noise on the quantum channel by comparing these values to what bob should have obtained . if the noise level is above a certain threshold , they abort the protocol and output an error message .",
    "if the noise is low enough , they move on to the third phase , and make use of the authentic channel to perform error correction and privacy amplification on their respective strings , resulting in keys @xmath97 and @xmath98 ( which , ideally , should be equal ) .",
    "we sketch this in .    3.7 .75    ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( a ) at ( -,0 ) ; at ( a.north west ) @xmath99 ; ( alice ) at ( -,0 ) ;    ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ; ( b ) at ( , 0 ) ; at ( b.north west ) @xmath100 ; ( bob ) at ( , 0 ) ;    ( cch ) at ( , ) ; at ( cch.north west ) authentic channel @xmath101 ; ( qch ) at ( -,- ) ; at ( qch.north west ) insecure channel @xmath102 ; ( eveq1 ) at ( --.4,-1.75 ) ; ( junc1 ) at ( eveq1 |- a3 ) ; ( eveq2 ) at ( -+.4,-1.75 ) ; ( junc2 ) at ( eveq2 |- a3 ) ; ( evec ) at ( + , -1.75 ) ; ( junc3 ) at ( evec |- b1 ) ;    ( a1 ) to node[auto , pos=.08 ] @xmath103 node[auto , pos=.92 ] @xmath103 ( b1 ) ; ( junc3.center ) to node[auto , pos=.9 ] @xmath103 ( evec.center ) ;    ( a2 ) to node[auto , pos=.75,swap ] @xmath104 ( alice.center ) ; ( b2 ) to node[auto , pos=.75 ] @xmath105 ( bob.center ) ;    ( a3 ) to ( junc1.center ) to node[pos=.8,auto , swap ] @xmath106 ( eveq1.center ) ; ( eveq2.center ) to node[pos=.264,auto , swap ] @xmath107 ( junc2.center ) to ( b3 ) ;    3.7 .75    ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( a ) at ( -,0 ) ; at ( a.north west ) @xmath99 ; ( alice ) at ( -,0 ) ;    ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ; ( b ) at ( , 0 ) ; at ( b.north west ) @xmath100 ; ( bob ) at ( , 0 ) ;    ( cch ) at ( , ) ; at ( cch.north west ) authentic channel @xmath101 ; ( qch ) at ( -,- ) ; at ( qch.north west ) insecure channel @xmath102 ;    ( qchf ) at ( -,-3 * ) ; at ( qchf.north west ) @xmath78 ; ( cchf ) at ( 2*,-3 * ) ; at ( cchf.east ) @xmath108 ;    ( qchfl ) at ( qchf.center ) ; ( qchfr ) at ( qchf.center ) ; ( qchl ) at ( qchfl    a3 ) ; ( junc2 ) at ( qchfr |- a3 ) ;    ( junc3 ) at ( cchf.center |- b1 ) ;    ( a1 ) to node[auto , pos=.08 ] @xmath103 node[auto , pos=.92 ] @xmath103 ( b1 ) ; ( junc3.center ) to node[auto , pos=.9 ] @xmath103 ( cchf ) ;    ( a2 ) to node[auto , pos=.75,swap ] @xmath104 ( alice.center ) ; ( b2 ) to node[auto , pos=.75 ] @xmath105 ( bob.center ) ;    ( a3 ) to ( junc1.center ) to node[pos=.8,auto , swap ] @xmath106 ( qchl.center ) ; ( qchr.center ) to node[pos=.264,auto , swap ] @xmath107 ( junc2.center ) to ( b3 ) ;    ( qchl.center ) to ( qchfl.center ) to ( qchfr.center ) to ( qchr.center ) ;    [ rem : entanglement ] in this work we use an insecure quantum channel from alice to bob to construct the shared secret key resource .",
    "an alternative resource that is frequently used in qkd instead of this insecure channel , is a source of entangled states under the control of eve .",
    "the source sends half of an entangled state to alice and another half to bob .",
    "it can be modeled similarly to the insecure channel depicted in , but with the first arrow reversed : the states are sent from eve to alice and from eve to bob .",
    "let @xmath109 be the qkd protocol .",
    "let @xmath102 and @xmath101 be the insecure quantum channel and authentic classical channel , respectively , with their filters @xmath78 and @xmath108 .",
    "let @xmath94 denote the secret key resource of and let @xmath81 be its filter .",
    "applying , we find that @xmath110 constructs @xmath111 from @xmath112 and @xmath113 within @xmath70 if @xmath114 the left- and right - hand sides of are illustrated in figures  [ fig : qkd.real.filter ] and [ fig : qkd.resource.filter ] , and the left- and right - hand sides of are illustrated in figures  [ fig : qkd.real.adv ] and [ fig : qkd.resource.sim ] .",
    "these two conditions are decomposed into simpler criteria in .",
    "by applying the general ac security definition to qkd , we obtained two criteria , and , capturing availability and security , respectively . in this section",
    "we derive , the trace distance criterion discussed in the introduction , from .",
    "we first show in that the distinguishing advantage used in the previous sections reduces to the trace distance between the quantum states gathered by the distinguisher interacting with the real and ideal systems .",
    "then in , we fix the simulator @xmath73 from the ideal system . in we decompose the resulting security criterion into a combination of _ secrecy _   and _ correctness _  the probability that alice s and bob s keys differ . in the last section , [ sec : security.rob ] ,",
    "we consider the security condition of , which captures whether , in the absence of a malicious adversary , the protocol behaves as specified by the ideal resource and corresponding filter .",
    "we show how this condition can be used to model the _ robustness _ of the protocol  the probability that the protocol aborts with non / malicious noise .      the security criteria given in and are defined in terms of the distinguishing advantage between resources . to simplify these equations , we rewrite them in terms of the trace distance , @xmath9 .",
    "a formal definition of this metric is given in , along with a discussion of how to interpret it in the rest of .",
    "we start with the simpler case of in the next paragraph , then deal with after that .",
    "the two resources on the left- and right - hand sides of simply output classical strings ( a key or error message ) at alice and bob s interfaces .",
    "let these pairs of strings be given by the joint probability distributions @xmath115 and @xmath116 .",
    "the distinguishing advantage between these systems is thus simply the distinguishing advantage between these probability distributions  a distinguisher",
    "is given a pair of strings sampled according to either @xmath115 or @xmath116 and has to guess from which distribution it was sampled ",
    "i.e. , @xmath117 the distinguishing advantage between two probability distributions is equal to their total variation distance , since the former is a special case of the latter . ]",
    " which we prove in in  i.e. , @xmath118 .",
    "putting the two together we get @xmath119 where @xmath115 and @xmath116 are the distributions of the strings output by the real and ideal systems , respectively .",
    "the resources on the left- and right - hand sides of are slightly more complex .",
    "they first output a state @xmath120 at the @xmath2/interface , namely the quantum states prepared by alice , which she sends on the insecure quantum channel . without loss of generality , the distinguisher now applies any map @xmath121 allowed by quantum physics to this state , obtaining @xmath122 and puts the @xmath123 register back on the insecure channel for bob , keeping the part in @xmath124 . finally , the systems output some keys ( or error messages ) at the @xmath62 and @xmath63/interfaces , and a transcript of the post / processing at the @xmath2/interface .",
    "let @xmath125 denote the tripartite state held by a distinguisher interacting with the real system , and let @xmath126 denote the state held after interacting with the ideal system , where the registers @xmath62 and @xmath63 contain the final keys or error messages , and the register @xmath2 holds both the state @xmath127 obtained from tampering with the quantum channel and the post - processing transcript . distinguishing between these two systems thus reduces to maximizing over the distinguisher strategies ( the choice of @xmath128 ) and distinguishing between the resulting states , @xmath125 and @xmath126 : @xmath129 the advantage a distinguisher has in guessing whether it holds the state @xmath125 or @xmath126 is given by the trace distance between these states , i.e. , @xmath130 this was first proven by helstrom  @xcite . for completeness",
    ", we provide a proof in , .",
    "the distinguishing advantage between the real and ideal systems of thus reduces to the trace distance between the quantum states gathered by the distinguisher . in the following , we usually omit @xmath131 where it is clear that we are maximizing over the distinguisher strategies , and simply express the security criterion as @xmath132 where @xmath133 and @xmath134 are the quantum states gathered by the distinguisher interacting with the real and ideal systems , respectively .      in the real setting ( ) , eve has full control over the quantum channel and obtains the entire classical transcript of the protocol .",
    "so for the real and ideal settings to be indistinguishable , a simulator @xmath135 must generate the same communication as in the real setting .",
    "this can be done by internally running alice s and bob s protocol @xmath136 , producing the same messages at eve s interface as the real system .",
    "however , instead of letting this ( simulated ) protocol decide the value of the key as in the real setting , the simulator only checks whether they actually produce a key or an error message , and presses the switch on the secret key resource accordingly .",
    "we illustrate this in .",
    "-1.85 .118    ( keybox ) at ( 0,0 ) ; ( key ) at ( 0,/2-.25 ) key ; ( junc ) at ( -1.4,0 |- key.center ) ; at ( keybox.north west ) secret key @xmath94 ; ( alice ) at ( - , ) ; ( bob ) at ( , ) ;    ( alice.center ) to node[pos=.08,auto ] @xmath93 node[pos=.92,auto ] @xmath93 ( bob.center ) ; ( junc.center |- 0 , ) to ( junc.center ) to node[pos=.472 ] ( handle ) +",
    "( 160:-.8 ) ; ( -.6,0 |- junc.center ) to ( key ) ;    ( sim ) at ( 0 , ) ; at ( sim.north west ) @xmath135 ; ( pleft ) at ( - , ) @xmath99 ; ( pright ) at ( , ) @xmath100 ; ( a1 ) at ( -,+.35 ) ; ( a2 ) at ( -,u-.35 ) ; ( b1 ) at ( , + .35 ) ; ( b2 ) at ( , u-.35 ) ;    ( evel ) at ( -.45 , ) ; ( juncl ) at ( evel |- a2 ) ; ( evec ) at ( -.2 , ) ; ( juncc ) at ( evec |- a2 ) ; ( ever ) at ( .45 , ) ; ( juncr ) at ( ever |- a1 ) ;    ( a1 ) to node[pos=.55,auto , swap ] @xmath24 ( handle.center ) ; ( a1 ) to ( b1 ) ; ( juncr.center ) to node[pos=.852,auto ] @xmath103 ( ever.center ) ; ( a2 ) to ( juncl.center ) to node[pos=.805,auto , swap ] @xmath106 ( evel.center ) ; ( evec.center ) to node[pos=.25,auto , swap ] @xmath107 ( juncc.center ) to ( b2 ) ;    the security criterion from can now be simplified by noting that with this simulator , the states of the ideal and real systems are identical when no key is produced .",
    "the outputs at alice s and bob s interfaces are classical , elements of the set @xmath137 , where @xmath138 symbolizes an error and @xmath139 is the set of possible keys .",
    "the states of the real and ideal systems can be written as @xmath140    plugging these in we get @xmath141 where @xmath142 is the renormalized state of the system conditioned on not aborting and @xmath143 is a perfectly uniform shared key .",
    "we now break down into two components , often referred to as _ correctness _ and _ secrecy _ , and recover the security definition for qkd introduced in @xcite .",
    "the correctness of a qkd protocol refers to the probability that alice and bob end up holding different keys .",
    "we say that a protocol is _ @xmath144/correct _ if for all adversarial strategies , @xmath145 \\leq \\eps_{{\\text{cor } } } \\ , \\ ] ] where @xmath146 and @xmath147 are random variables over the alphabet @xmath148 describing alice s and bob s outputs .",
    "\\leq \\eps_{{\\text{cor}}}$ ] , where @xmath149 is the probability of aborting and @xmath150 and @xmath151 are alice and bob s keys conditioned on not aborting . ] the secrecy of a qkd protocol measures how close the final key is to a distribution that is uniform and independent of the adversary s system . let @xmath149 be the probability that the protocol aborts , and @xmath152 be the resulting state of the @xmath153 subsystems conditioned on not aborting .",
    "a protocol is _ @xmath154/secret _ if for all adversarial strategies , @xmath155 where the distance @xmath9 is the trace distance and @xmath156 is the fully mixed state .",
    "[ thm : qkd ] if a qkd protocol is @xmath144/correct and @xmath154/secret , then is satisfied for @xmath157 .",
    "let us define @xmath158 to be a state obtained from @xmath159 ( ) by throwing away the @xmath63 system and replacing it with a copy of @xmath62 , i.e. , @xmath160 from the triangle inequality we get @xmath161    since in the states @xmath158 and @xmath162 the @xmath63 system is a copy of the @xmath62 system , it does not modify the distance .",
    "furthermore , @xmath163{\\gamma_{abe } } = \\trace[b]{\\rho^{\\top}_{abe}}$ ] .",
    "hence @xmath164    for the other term note that @xmath165 \\ .\\end{aligned}\\ ] ] putting the above together with , we get @xmath166 + ( 1-p^\\bot ) d(\\rho^\\top_{ae},\\tau_{a }    \\tensor \\rho^\\top_{e } ) \\ .",
    "\\qedhere \\end{aligned}\\ ] ]    in we prove a bound on the second security condition of for qkd in terms of the correctness and secrecy of the protocol .",
    "the converse can also be shown : if holds for some @xmath70 , then the corresponding qkd protocol is both @xmath70/correct and @xmath167/secret . is a result of the _ existence _ of the simulator @xmath73 in the security definition .",
    "we can not exclude that for some specific qkd protocol there exists a different simulator @xmath168  different from the one used in this proof  generating a state @xmath169 when interacting with the distinguisher , such that @xmath170 .",
    "however , by the triangle inequality we also have that for any @xmath169 , @xmath171 . hence the failure @xmath70 of the generic simulator used in",
    "this proof is at most twice larger than optimal . ]",
    "so far in this section we have discussed the security of a qkd protocol with respect to a malicious eve using the second condition from ( ) . a qkd protocol which always aborts without producing any key trivially satisfies with @xmath172 , but is not a useful protocol at all ! the real system must not only be indistinguishable from ideal when an adversary is present , but also when the adversarial interfaces are covered by filters emulating honest behavior .",
    "this is modeled by the first condition from , namely for qkd .",
    "if no adversary is tampering with the quantum channel  only natural non / malicious noise is present  we expect a secret key to be generated with high probability .",
    "this can be captured by designing the filter @xmath81 to allow a key to be produced with high probability : if the real system does not generate a key with the same probability , this immediately results in a gap noticeable by the distinguisher .",
    "the probability of a key being generated depends on the noise introduced by the filter @xmath78 covering the adversarial interface of the insecure quantum channel @xmath102 in the real system ( illustrated in ) .",
    "suppose that this noise is parametrized by a value @xmath173 , e.g. , a depolarizing channel with probability @xmath173 .",
    "for every @xmath173 , the protocol has a probability of aborting , @xmath96 , which is called the _",
    "robustness_. let @xmath174 denote a filter of the channel @xmath102 that models this noise , and let @xmath175 denote the filter of the ideal key resource @xmath94 , which flips the switch to prevent a key from being generated with corresponding probability @xmath96 .",
    "thus becomes @xmath176 where varying @xmath173 and @xmath96 results in a family of real and ideal systems .",
    "we now prove that in this case the failure @xmath70 from is bounded by @xmath177 .",
    "note that this statement is only useful if the probability of aborting , @xmath96 , is small for reasonable noise models @xmath173 .",
    "[ lem : robustness ] if the filters from are parametrized such that @xmath175 aborts with exactly the same probability as the protocol @xmath110 run on the noisy channel @xmath178 , then the availability of the protocol is bounded by the security , i.e. , @xmath179 where the simulator @xmath135 is the one used in the previous sections , introduced in , .",
    "since @xmath175 aborts with exactly the same probability as the real system and since @xmath135 simulates the real system , we can substitute @xmath180 for @xmath175 .",
    "the result then follows , because the converter @xmath181 on both the real and ideal systems can only decrease their distance ( ) .",
    "it is immediate from the ac framework  @xcite that the composition of two protocols satisfying is still secure . in this section",
    "we attempt to provide a better feeling for protocol composition by illustrating it with several examples .",
    "we compose qkd in series and in parallel , and show that  as a result of the triangle inequality and the security of the individual protocols  the corresponding composed real systems are indistinguishable from the composed ideal systems .    in",
    "we first look at a situation in which part of the key is known to the adversary . in",
    "we compose qkd with a one - time pad . and in we compose two runs of a qkd protocol in parallel .",
    "we provide a more extensive example of protocol composition in , where we model the security of authentication and compose it with qkd , resulting in a key expansion protocol .    to simplify the examples , we only consider security in the presence of an adversary and ignore the first condition from .",
    "for the same reason , when writing up the security condition with the trace distance , we hard - code the simulator used in in the security criterion .",
    "furthermore , as shown in , conditioned on aborting , the real and ideal systems of qkd are identical , so the security criterion can be reduced to the case in which the qkd protocol terminates with a shared key between alice and bob , which happens with probability @xmath182 . with these simplifications ,",
    "a qkd protocol is @xmath70/secure if @xmath183 where @xmath184 is a perfect shared key and @xmath133 and @xmath185 are the final states , conditioned on producing a key , that the distinguisher holds after interacting with the real and ideal systems , respectively .      the accessible information given in is shown to be insufficient to define security for a qkd protocol by considering a setting in which part of the key @xmath1 is available to eve  @xcite .",
    "this allows her to guess the remaining bits of the key , which would not have been possible had the key been distributed using an ideal resource .",
    "we analyze exactly this setting here , and argue that this does not affect the security of a qkd scheme that satisfies . to model this partial knowledge of the key ,",
    "let alice run a protocol @xmath186 that receives part of the secret key  generated either by a qkd protocol or by an ideal resource  and sends it on a channel to eve . plugging this in the real and ideal qkd systems from figures  [ fig : qkd.real.adv ] and [ fig : qkd.ideal ]",
    ", we get .    2.5 .75    ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( a ) at ( -,0 ) ; at ( a.north west ) @xmath99 ; ( alice ) at ( - , ) ;    ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ; ( b ) at ( , 0 ) ; at ( b.north west ) @xmath100 ; ( bob ) at ( , 0 ) ;    ( f1 ) at ( -,0 ) ; ( f3 ) at ( -,-2 * ) ; ( f ) at ( -,- ) ; at ( f.north west ) @xmath186 ;    ( eveq1 ) at ( - , ) ; ( junc1 ) at ( eveq1 |- a3 ) ; ( eveq2 ) at ( 0 , ) ; ( junc2 ) at ( eveq2 |- a3 ) ; ( evec ) at ( , ) ; ( junc3 ) at ( evec |- b1 ) ; ( evef ) at ( -2 * , ) ; ( junc0 ) at ( evef |- f3 ) ;    ( a1 ) to ( b1 ) ; ( junc3.center ) to node[auto , pos=.9,swap ] @xmath103 ( evec.center ) ;    ( a2 ) to node[auto , pos=.5,swap ] @xmath187 ( f1 ) ; ( b2 ) to node[auto , pos=.6 ] @xmath188 ( bob.center ) ;    ( a3 ) to ( junc1.center ) to node[pos=.85,auto , swap ] @xmath106 ( eveq1.center ) ; ( eveq2.center ) to node[pos=.19,auto ] @xmath107 ( junc2.center ) to ( b3 ) ;    ( a1 ) to node[auto , pos=.5,swap ] @xmath189 ( alice.center ) ; ( f3 ) to ( junc0.center ) to node[pos=.7,auto , swap ] @xmath190 ( evef.center ) ;    -1.85 .118    ( keybox ) at ( 0,0 ) ; ( key ) at ( 0,/2-.25 ) key ; ( junc ) at ( -1.4,0 |- key.center ) ; at ( keybox.north west ) secret key ; ( alice ) at ( - , ) ; ( bob ) at ( , ) ;    \\(f ) at ( , ) ; ( f1 ) at ( , -.75 ) ; ( f3 ) at ( , -2.95 ) ; at ( f.north west ) @xmath186 ;    ( alice.center ) to node[pos=.2,auto ] @xmath191 node[pos=.94,auto ] @xmath11 ( bob.center ) ; ( junc.center |- 0 , ) to ( junc.center ) to node[pos=.472 ] ( handle ) + ( 160:-.8 ) ; ( -.6,0 |- junc.center ) to ( key ) ;    ( sim ) at ( 0 , ) ; at ( sim.north east ) @xmath135 ; ( pleft ) at ( - , ) ; ( pcenter ) at ( 0 , ) ; ( pright ) at ( , ) ;    ( evell ) at ( -2 * , ) ; ( juncll ) at ( evell |- f3 ) ; ( evel ) at ( - , ) ; ( evec ) at ( 0 , ) ; ( ever ) at ( , ) ;    ( junctt ) at ( evell |- alice ) ; ( junct ) at ( evell |- f1 ) ;    ( pleft ) to node[pos=.55,auto , swap ] @xmath24 ( handle.center ) ; ( pright ) to node[pos=.8,auto ] @xmath103 ( ever.center ) ; ( pleft ) to node[pos=.805,auto ] @xmath106 ( evel.center ) ; ( evec.center ) to node[pos=.22,auto , swap ] @xmath107 ( pcenter ) ;    ( junctt.center ) to ( junct.center ) to node[pos=.4,auto , swap ] @xmath192 ( f1 ) ;    ( f3 ) to ( juncll.center ) to node[auto , pos=.7 ] @xmath192 ( evell.center ) ;    it is immediate from that @xmath186 can not increase the distance between the real and ideal systems and therefore can not compromise security : the systems in gray can be run internally by a distinguisher attempting to guess whether it is interacting with the real or ideal qkd system , so this case is already bounded by the security of qkd .",
    "this reasoning is summed up in the following equation , which can be directly derived from : @xmath193    the same can be obtained from the properties of the trace distance if we write out explicitly the states gathered by the distinguisher .",
    "if the qkd protocol is @xmath70/secure , we have from that @xmath194 where @xmath133 is the state gathered by a distinguisher interacting with the real qkd system ( ) and @xmath195 is the state gathered by interacting with the ideal system ( ) , conditioned on the protocol not aborting .",
    "a distinguisher interacting with either of the two systems from gets extra information at eve s interface , namely the first part of alice s key @xmath192 , and only the second part of that key @xmath191 at alice s interface .",
    "the complete states gathered by interacting with and are given by @xmath196 and @xmath197 , respectively , where the orignal system @xmath198 containing alice s key is split in two , @xmath199 and @xmath200 .",
    "these can be obtained from @xmath133 and @xmath185 by a unitary map which simply permutes the registers .",
    "thus , the trace distance does not increase .",
    "so we have @xmath201    if we analyze the same situation from the perspective of an adversary that can access only the @xmath2/interface , composing qkd with a protocol that reveals @xmath192 results in a net gain of information for this adversary .",
    "but as shown above , for a distinguisher that also receives the outputs of the honest players  the generated secret keys  there is no gain .",
    "if we compose a one - time pad ( depicted in ) and a qkd protocol ( depicted in ) , we obtain , where the secret key resource used by the one - time pad is replaced by the qkd protocol .",
    "we showed in that a one - time pad constructs a secure channel ( ) , which provides eve with only one functionality , learning the length of the message .",
    "however , this was if the one - time pad protocol had access to a secret key resource with a blank @xmath2/interface , as in .",
    "in reality , qkd constructs a resource that allows eve to prevent a key from being generated , as in .",
    "it can easily be shown that with access to this resource , a one - time pad constructs a secure channel with two controls at eve s interface : one for preventing any message from being sent and a second for learning the length of the message if she did not activate the first .",
    "this resource is illustrated in , along with the appropriate simulator for constructing this resource with a one - time pad and a qkd protocol : the combination of the two simulators used in the individual proofs of the one - time pad ( ) and qkd ( ) .    2.5 .75    ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( a ) at ( -,0 ) ; at ( a.north west ) @xmath99 ; ( alice ) at ( -,- ) ;    ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ; ( b ) at ( , 0 ) ; at ( b.north west ) @xmath100 ; ( bob ) at ( , - ) ;    ( f1 ) at ( -,0 ) ; ( f2 ) at ( -,- ) ; ( f3 ) at ( -,-2 * ) ; ( f ) at ( -,- ) @xmath29 + @xmath202 ; at ( f.north west ) @xmath31 ;    ( g1 ) at ( , 0 ) ; ( g2 ) at ( , - ) ; ( g3 ) at ( , -2 * ) ; ( g ) at ( , - ) @xmath203 + @xmath204 ; at ( g.north west ) @xmath34 ;    ( eveq1 ) at ( - , ) ; ( junc1 ) at ( eveq1 |- a3 ) ; ( eveq2 ) at ( 0 , ) ; ( junc2 ) at ( eveq2 |- a3 ) ; ( evec ) at ( , ) ; ( junc3 ) at ( evec |- b1 ) ; ( evef ) at ( 2 * , ) ; ( junc4 ) at ( evef |- f3 ) ;    ( a1 ) to ( b1 ) ; ( junc3.center ) to node[auto , pos=.9,swap ] @xmath103 ( evec.center ) ;    ( a2 ) to node[auto , pos=.5,swap ] @xmath205 ( f1 ) ; ( b2 ) to node[auto , pos=.5 ] @xmath188 ( g1 ) ;    ( a3 ) to ( junc1.center ) to node[pos=.85,auto , swap ] @xmath106 ( eveq1.center ) ; ( eveq2.center ) to node[pos=.19,auto ] @xmath107 ( junc2.center ) to ( b3 ) ;    ( alice.center ) to node[auto , pos=.4 ] @xmath206 ( f2 ) ; ( g2 ) to node[auto , pos=.6 ] @xmath207 ( bob.center ) ; ( f3 ) to node[pos=.07,auto , swap ] @xmath14 node[pos=.93,auto , swap ] @xmath14 ( g3 ) ; ( junc4.center ) to node[pos=.7,auto , swap ] @xmath14 ( evef.center ) ;    -1.85 .118    ( keybox ) at ( 0,0 ) ; ( key ) at ( 0,/2-.25 ) key ; ( junc ) at ( -1.4,0 |- key.center ) ; at ( keybox.north west ) secret key @xmath94 ; ( alice ) at ( - , ) ; ( bob ) at ( , ) ;    \\(f ) at ( - , ) @xmath208 + @xmath30 ; ( f1 ) at ( - , ) ; ( f2 ) at ( - , ) ; ( f3 ) at ( - , ) ; at ( f.north west ) @xmath31 ;    \\(g ) at ( , ) @xmath209 + @xmath33 ;    ( g1 ) at ( , ) ; ( g2 ) at ( , ) ; ( g3 ) at ( , ) ; at ( g.north west ) @xmath34 ;    ( f1 ) to node[pos=.15,auto ] @xmath11 node[pos=.85,auto ] @xmath11 ( g1 ) ; ( junc.center |- 0 , ) to ( junc.center ) to node[pos=.472 ] ( handle ) + ( 160:-.8 ) ; ( -.6,0 |- junc.center ) to ( key ) ;    ( sim ) at ( 0 , ) ; at ( sim.north east ) @xmath135 ; ( pleft ) at ( - , ) ; ( pcenter ) at ( 0 , ) ; ( pright ) at ( , ) ;    ( everr ) at ( 2 * , ) ; ( juncrr ) at ( everr |- f3 ) ; ( evel ) at ( - , ) ; ( evec ) at ( 0 , ) ; ( ever ) at ( , ) ;    ( pleft ) to node[pos=.55,auto , swap ] @xmath24 ( handle.center ) ; ( pright ) to node[pos=.8,auto , swap ] @xmath103 ( ever.center ) ; ( pleft ) to node[pos=.805,auto , swap ] @xmath106 ( evel.center ) ; ( evec.center ) to node[pos=.22,auto ] @xmath107 ( pcenter ) ;    ( f3 ) to node[auto , pos=.1,swap ] @xmath14 node[auto , pos=.9,swap ] @xmath14 ( g3 ) ; ( juncrr.center ) to node[auto , pos=.7,swap ] @xmath14 ( everr.center ) ; ( alice.center ) to node[auto , pos=.4 ] @xmath206 ( f2 ) ; ( g2 ) to node[auto , pos=.6 ] @xmath207 ( bob.center ) ;    -1.85    ( channel ) at ( 0,0 ) ; at ( channel.north west ) secure channel @xmath80 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ;    ( simqkd ) at ( -2 * , ) ; at ( simqkd.north west ) @xmath135 ; ( pleft ) at ( -3 * , ) ; ( pcenter ) at ( -2 * , ) ; ( pright ) at ( - , ) ;    ( simotp ) at ( 2 * , ) ; at ( simotp.north east ) @xmath36 ; ( qleft ) at ( , ) ; ( qcenter ) at ( 2 * , ) ; ( qright ) at ( 3 * , ) ;    ( ajunc ) at ( pcenter |- alice ) ; ( alice ) to node[pos=.2,auto ] @xmath26 ( ajunc.center ) to node[pos=.528 ] ( handle ) + ( 160:-.8 ) ; ( pcenter ) to node[pos=.35,auto , swap ] @xmath24 ( handle.center ) ; ( bjunc ) at ( pcenter |- bob ) ; ( bjunc.center ) to node[pos=.96,auto ] @xmath26 ( bob ) ; ( leak ) at ( qcenter |- bob ) ; ( leak.center ) to node[pos=.65,auto , swap ] @xmath35 ( qcenter ) ;    ( peve1 ) at ( -3 * , ) ; ( peve2 ) at ( -2 * , ) ; ( peve3 ) at ( - , ) ; ( qeve ) at ( 2 * , ) ;    ( pleft ) to node[pos=.6,auto ] @xmath106 ( peve1 ) ; ( peve2 ) to node[pos=.45,auto , swap ] @xmath107 ( pcenter ) ; ( pright ) to node[pos=.6,auto ] @xmath103 ( peve3 ) ; ( qcenter ) to node[pos=.6,auto ] @xmath14 ( qeve ) ;    we now wish to show that the combination of an @xmath70/secure qkd protocol and a ( perfect ) one - time pad results in a combined scheme that constructs within @xmath70 a secure channel from authentic classical channels , for each . ] and an insecure quantum channel . to do this , we look at an intermediary step consisting of the combination of an ideal secret key resource and a one - time pad , which we illustrate in . if we remove the gray parts from figures  [ fig : ex.otp.real ] and [ fig : ex.otp.hybrid ]",
    ", we recover the real and ideal systems of qkd .",
    "if the qkd protocol is @xmath70/secure , then the distinguishing advantage between these two figures can also be at most @xmath70 .",
    "likewise , if we remove the dashed parts from figures  [ fig : ex.otp.hybrid ] and [ fig : ex.otp.ideal ] we recover the real and ideal systems of the one - time pad .",
    "since the one - time pad is perfectly secure , the distinguishing advantage between these two figures must be @xmath210 .",
    "it follows from the triangle inequality that the composition of an @xmath70/secure qkd protocol and a one - time pad is @xmath70/secure .",
    "this reasoning is summed up in the following equation , which can be directly derived from , and the triangle inequality ( ): @xmath211    the same can be obtained from the properties of the trace distance if we write out explicitly the states gathered by the distinguisher . after a run of an @xmath70/secure qkd scheme , we know that @xmath212 the encryption and decryption operations of the one - time pad , @xmath213 , plugged into figures  [ fig : ex.otp.real ] and [ fig : ex.otp.hybrid ] , modify the states @xmath214 and @xmath184 .",
    "they correspond to a unitary map @xmath215 which takes the message @xmath206 and alice s and bob s keys @xmath97 , @xmath98 , and generates the ciphertext and bob s message while persevering alice s message , @xmath216 a unitary map does not change the trace distance , so for @xmath217 we have @xmath218 where @xmath219 and @xmath220 are",
    "the states held be a distinguisher interacting with figures  [ fig : ex.otp.real ] and [ fig : ex.otp.hybrid ] , respectively .",
    "we also know that the one - time pad perfectly constructs a secure channel from an authentic channel and a secret key , i.e. , if we remove the simulator @xmath135 from figures  [ fig : ex.otp.hybrid ] and [ fig : ex.otp.ideal ] , the corresponding systems are indistinguishable  a distinguisher interacting with them obtains two states @xmath221 and @xmath222 with @xmath223 .",
    "plugging the simulator @xmath135 in eve s interface simply results in the state @xmath4 being appended to @xmath224 and @xmath225 .",
    "the final state held by the distinguisher is thus @xmath226 and @xmath227 , respectively , with @xmath228 .    by the triangle inequality",
    ", the distance between figures  [ fig : ex.otp.real ] and [ fig : ex.otp.ideal ] is then @xmath229      if two qkd protocols are run in parallel , as illustrated in the adversary can entwine their respective messages as she pleases , e.g , parts of the state @xmath106 sent on the insecure channel by the first protocol can be input into the insecure channel of the second protocol . we wish to show that even in this case , the combined protocol is still @xmath167/secure  i.e. , indistinguishable from the parallel compositions of two ideal key resources and their individual simulators  if each qkd protocol is @xmath70/secure .",
    "this ideal case is depicted in .",
    "3.7 .75    ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( a ) at ( -,0 ) ; at ( a.north west ) @xmath99 ; ( alice ) at ( -,0 ) ;    ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ; ( b ) at ( , 0 ) ; at ( b.north west ) @xmath100 ; ( bob ) at ( , 0 ) ;    ( cch ) at ( , ) ; at ( cch.north west ) authentic channel @xmath101 ; ( qch ) at ( -,- ) ; at ( qch.north west ) insecure channel @xmath102 ; ( eveq1 ) at ( --.4,-1.75 ) ; ( junc1 ) at ( eveq1 |- a3 ) ; ( eveq2 ) at ( -+.4,-1.75 ) ; ( junc2 ) at ( eveq2 |- a3 ) ; ( evec ) at ( + , -1.75 ) ; ( junc3 ) at ( evec |- b1 ) ;    ( a1 ) to node[auto , pos=.08 ] @xmath103 node[auto , pos=.92 ] @xmath103 ( b1 ) ; ( junc3.center ) to node[auto , pos=.9 ] @xmath103 ( evec.center ) ;    ( a2 ) to node[auto , pos=.75,swap ] @xmath104 ( alice.center ) ; ( b2 ) to node[auto , pos=.75 ] @xmath105 ( bob.center ) ;    ( a3 ) to ( junc1.center ) to node[pos=.8,auto , swap ] @xmath106 ( eveq1.center ) ; ( eveq2.center ) to node[pos=.264,auto , swap ] @xmath107 ( junc2.center ) to ( b3 ) ;    ( a1a ) at ( -,- ) ; ( a2a ) at ( -,0 ) ; ( a3a ) at ( - , ) ; ( aa ) at ( -,0 ) ; at ( aa.north west ) @xmath230 ; ( alicea ) at ( -,0 ) ;    ( b1a ) at ( , - ) ; ( b2a ) at ( , 0 ) ; ( b3a ) at ( , ) ; ( ba ) at ( , 0 ) ; at ( ba.north west ) @xmath231 ; ( boba ) at ( , 0 ) ;    ( ccha ) at ( , - ) ; at ( ccha.south west ) authentic channel @xmath101 ; ( qcha ) at ( - , ) ; at ( qcha.south west ) insecure channel @xmath102 ; ( eveq1a ) at ( --.4,1.75 ) ; ( junc1a ) at ( eveq1a    ( eveca ) at ( + , 1.75 ) ; ( junc3a ) at ( eveca |- b1a ) ;    ( a1a ) to node[auto , pos=.08 ] @xmath232 node[auto , pos=.92 ] @xmath232 ( b1a ) ; ( junc3a.center ) to node[auto , pos=.9,swap ] @xmath232 ( eveca.center ) ;    ( a2a ) to node[auto , pos=.75,swap ] @xmath233 ( alicea.center ) ; ( b2a ) to node[auto , pos=.75 ] @xmath234 ( boba.center ) ;    ( a3a ) to ( junc1a.center ) to node[pos=.8,auto ] @xmath235 ( eveq1a.center ) ; ( eveq2a.center ) to node[pos=.19,auto ] @xmath236 ( junc2a.center ) to ( b3a ) ;    -1.85 .118 2.5 cm    ( keybox ) at ( 0,0 ) ; ( key ) at ( 0,/2-.25 ) key ; ( junc ) at ( -1.4,0 |- key.center ) ; at ( keybox.north west ) secret key @xmath94 ; ( alice ) at ( - , ) ; ( bob ) at ( , ) ;    ( alice.center ) to node[pos=.04,auto ] @xmath93 node[pos=.96,auto ] @xmath93 ( bob.center ) ; ( junc.center |- 0 , ) to ( junc.center ) to node[pos=.472 ] ( handle ) + ( 160:-.8 ) ; ( -.6,0 |- junc.center ) to ( key ) ;    ( sim ) at ( 0 , ) ; at ( sim.north west ) @xmath135 ; ( pleft ) at ( - , ) @xmath99 ; ( pright ) at ( , ) @xmath100 ; ( a1 ) at ( -,+.35 ) ; ( a2 ) at ( -,u-.35 ) ; ( b1 ) at ( , + .35 ) ; ( b2 ) at ( , u-.35 ) ;    ( evel ) at ( -.45 , ) ; ( juncl ) at ( evel |- a2 ) ; ( evec ) at ( -.2 , ) ; ( juncc ) at ( evec |- a2 ) ; ( ever ) at ( .45 , ) ; ( juncr ) at ( ever |- a1 ) ;    ( a1 ) to node[pos=.55,auto , swap ] @xmath24 ( handle.center ) ; ( a1 ) to ( b1 ) ; ( juncr.center ) to node[pos=.852,auto ] @xmath103 ( ever.center ) ; ( a2 ) to ( juncl.center ) to node[pos=.805,auto , swap ] @xmath106 ( evel.center ) ; ( evec.center ) to node[pos=.25,auto , swap ] @xmath107 ( juncc.center ) to ( b2 ) ;    ( keyboxa ) at ( 0,0 ) ; ( keya ) at ( 0,-/2+.25 ) key ; ( junca ) at ( -1.4,0 |- keya.center ) ; at ( keyboxa.south west ) secret key @xmath94 ; ( alicea ) at ( -,- ) ; ( boba ) at ( , - ) ;    ( alicea.center ) to node[pos=.04,auto , swap ] @xmath237 node[pos=.97,auto , swap ] @xmath237 ( boba.center ) ; ( junca.center |- 0,- ) to ( junca.center ) to node[pos=.472 ] ( handlea ) + ( 200:-.8 ) ; ( -.6,0 |- junca.center ) to ( keya ) ;    ( sima ) at ( 0,-1 * ) ; at ( sima.south east ) @xmath238 ; ( plefta ) at ( -,-1 * ) @xmath230 ; ( prighta ) at ( , -1 * ) @xmath231 ; ( a1a ) at ( -,-1*u-.35 ) ; ( a2a ) at ( -,-1*+.35 ) ; ( b1a ) at ( , -1*u-.35 ) ; ( b2a ) at ( , -1*+.35 ) ;    ( evela ) at ( -.45,-1 * ) ; ( juncla ) at ( evela |- a2a ) ; ( eveca ) at ( -.2,-1 * ) ; ( juncca ) at ( eveca |- a2a ) ; ( evera ) at ( .45,-1 * ) ; ( juncra ) at ( evera |- a1a ) ;    ( a1a ) to node[pos=.55,auto , swap ] @xmath24 ( handlea.center ) ; ( a1a ) to ( b1a ) ; ( juncra.center ) to node[pos=.852,auto , swap ] @xmath232 ( evera.center ) ; ( a2a ) to ( juncla.center ) to node[pos=.805,auto ] @xmath235 ( evela.center ) ; ( eveca.center ) to node[pos=.17,auto ] @xmath236 ( juncca.center ) to ( b2a ) ;    like for serial composition , this follows from the triangle inequality .",
    "if the real qkd system is @xmath70/close to the ideal qkd system , then two real qkd systems in parallel must be @xmath70/close to an ideal and real qkd system composed in parallel , since otherwise a distinguisher could run a real qkd system internally in parallel to the system it is testing .",
    "likewise , a real and ideal qkd system in parallel must be @xmath70/close to two ideal qkd systems in parallel . and",
    "hence two parallel runs of an @xmath70/secure qkd protocol is @xmath167/secure .",
    "the trace distance notation does not lend itself to writing up parallel composition of protocols .",
    "so instead of using this notation as in the previous examples , we write up the reasoning from the paragraph above in more detail using the resource / converter formalism . if the real and ideal system of a qkd protocol are @xmath70/close , then @xmath239 it follows immediately from this and that @xmath240 from the triangle equality ( ) we then have @xmath241 finally , using to rearrange this expression , we get @xmath242 i.e. , the parallel composition of two runs of a qkd protocol , @xmath243 , run with authentic classical and insecure quantum channel resources , @xmath244 , is @xmath167/close to the parallel composition of two ideal key resources , @xmath245 , and a simulator , @xmath246 .",
    "[ app ]    in we formally define the trace distance and show that it corresponds to the distinguishing advantage between two quantum states .",
    "we also prove several lemmas that help interpret its meaning and how to choose a value in a practical implementation . in",
    "we discuss an alternative to the secrecy criterion of , which has appeared in the literature . in",
    "we provide some details on technical aspects of the abstract cryptography framework . in",
    "we discuss how to define a distinguisher so that the resulting distinguishing advantage is non / increasing under compositions . in",
    "we sketch a proof that the security definition from is composable .",
    "a complete proof of this can be found in @xcite . and finally , in we model the security of authentication with universal hashing  @xcite , then use this as a subprotocol of qkd to authenticate the classical post / processing .",
    "since this type of authentication uses a short key ( and an insecure classical channel ) to construct an authentic channel and qkd uses an authentic channel ( and an insecure quantum channel ) to construct a long key , the composition of the two is a key expansion protocol , which constructs a long key from a short key ( and insecure channels ) .",
    "we have used several times in this work the well / known fact that the distinguishing advantage between two systems that output states @xmath106 and @xmath247 is equivalent to the trace distance between these states . in this appendix , we prove this fact , along with several other theorems that help interpret the meaning of the trace distance .    in",
    "we first define the trace distance  as well as its classical counterpart , the total variation distance and prove some basic lemmas that can also be found in textbooks such as @xcite . in we then show the connection between trace distance and distinguishing advantage , which was originally proven by helstrom  @xcite . in",
    "we prove that we can alternatively think of the trace distance between a real and ideal system as a bound on the probability that a failure occurs in the real system . finally , in we bound two typical information theory notions of secrecy  the conditional entropy of a key given the eavesdropper s information and her probability of correctly guessing the key  in terms of the trace distance .",
    "although such measures of information are generally ill - suited for defining cryptographic security , they can help interpret the notion of a key being @xmath70/close to uniform .      in the case of a classical system",
    ", statistical security is defined by the total variation ( or statistical ) distance between the probability distributions describing the real and ideal settings , which is defined as follows . for both the total variation and trace distance , since the former is a special case of the latter . ]",
    "[ def : vdist ] the total variation distance between two probability distributions @xmath248 and @xmath249 over an alphabet @xmath250 is defined as @xmath251    using the fact that @xmath252 , the total variation distance can also be written as @xmath253 \\ .\\ ] ]    in the case of quantum states instead of classical random variables , the total variation distance generalizes to the trace distance . more precisely , the trace distance between two density operators that are diagonal in the same orthonormal basis is equal to the total variation distance between the probability distributions defined by their respective eigenvalues .",
    "[ def : tdist ] the trace distance between two quantum states @xmath106 and @xmath247 is defined as @xmath254    we now introduce some technical lemmas involving the trace distance , which help us derive the theorems in the next sections . most of these proofs are taken from @xcite .    [",
    "lem : op.definitions.pos ] for any two states @xmath106 and @xmath247 and any operator @xmath255 , the two following inequalities hold : @xmath256 furthermore , each of these inequalities is tight for some values of @xmath257 .",
    "the trace distance can thus alternatively be written as @xmath258    we start with the proof of .",
    "let @xmath259 be the eigenvalues and vectors of @xmath260 , and define @xmath261 we have @xmath262 and @xmath263 .",
    "note that since @xmath264 , we have @xmath265 , hence @xmath266 if we set @xmath267 , the projector on @xmath268 , we get @xmath269 and for any operator @xmath270 , @xmath271    to prove that holds , note that for any operator @xmath270 , @xmath272 is tight for any operator @xmath257 which satisfies @xmath273 i.e. , any operator such that either @xmath274 or @xmath275 , where @xmath276 is defined as above and @xmath277 .",
    "let @xmath278 be a positive operator / valued measure ( povm )  a set of operators @xmath279 such that @xmath280  and let @xmath281 denote the outcome of measuring a quantum state @xmath106 with @xmath278 , i.e. , @xmath282 .",
    "our next lemma says that the trace distance between two states @xmath106 and @xmath247 is equal to the total variation between the outcomes  @xmath281 and @xmath283  of an optimal measurement on the two states .",
    "[ lem : op.definitions.opt ] for any two states @xmath106 and @xmath247 , @xmath284 where @xmath281 and @xmath283 are the probability distributions resulting from measuring @xmath106 and @xmath247 with a povm @xmath285 , respectively , and the maximization is over all povms .",
    "furthermore , if the two states @xmath286 and @xmath287 have a classical subsystem @xmath288 , then the measurement satisfying leaves the classical subsystem unchanged , i.e. , the maximum is reached for a povm with elements @xmath289 where @xmath290 is the classical orthonormal basis of @xmath288 .    using from we get @xmath291 the conditions for equality",
    "are given at the end of the proof of , e.g. , a measurement with @xmath292 , where @xmath293 are the eigenvectors of @xmath260 .",
    "if @xmath294 and @xmath295 , then @xmath296 and the eigenvectors of @xmath260 have the form @xmath297 , where @xmath298 is an eigenvector of @xmath299 .",
    "so the optimal measurement , @xmath300 , satisfies .",
    "helstrom  @xcite proved that the advantage a distinguisher has in guessing whether it was provided with one of two states , @xmath106 or @xmath247 , is given by the trace distance between the two , @xmath301 . and",
    "@xmath247 are picked with apriori probabilities @xmath90 and @xmath302 , respectively , instead of @xmath37 as in the definition of the distinguishing advantage .",
    "] we first sketch the classical case , then prove the quantum version .",
    "let a distinguisher be given a value sampled according to probability distributions @xmath248 or @xmath249 , where @xmath248 and @xmath249 are each chosen with probability @xmath37 .",
    "suppose the value received by the distinguisher is @xmath303 .",
    "if @xmath304 , its best guess is that the value was sampled according to @xmath248 .",
    "otherwise , it should guess that it was @xmath249 .",
    "let @xmath305 and @xmath306 .",
    "there are a total of @xmath307 possible events : the sample is chosen according to @xmath248 or @xmath249 and takes the value @xmath303 .",
    "these events have probabilities @xmath308 and @xmath309 . conditioned on @xmath248",
    "being chosen and @xmath310 being the sampled value , the distinguisher has probability @xmath89 of guessing correctly with the strategy outlined above if @xmath311 , and @xmath210 otherwise . likewise ,",
    "if @xmath249 was selected , it has probability @xmath89 of guessing correctly if @xmath312 and @xmath210 otherwise . the probability of correctly guessing whether it was given a value sampled according to @xmath248 or @xmath249 , which we denote @xmath313 , is obtained by summing over all possible events weighted by their probabilities .",
    "hence @xmath314 \\\\    & = \\frac{1}{2 } + \\frac{1}{2 } d(p_z , p_{\\tilde{z } } ) \\ , \\end{aligned}\\ ] ] where in the last equality we used the alternative formulation of the total variation distance from .",
    "we now generalize the argument above to quantum states .",
    "[ thm : op.distinguishing ] for any states @xmath106 and @xmath247 , we have @xmath315    if a distinguisher is given one of two states @xmath106 or @xmath247 , each with probability @xmath37 , its probability of guessing which one it holds is given by a maximization of all possible measurements it may do : it chooses some povm @xmath316 , where @xmath317 and @xmath318 are positive operators with @xmath319 , and measures the state it holds .",
    "if it gets the outcome @xmath210 , it guesses that it holds @xmath106 and if it gets the outcome @xmath89 , it guesses that it holds @xmath247 .",
    "the probability of guessing correctly is given by @xmath320 \\notag \\\\    & = \\frac{1}{2}\\max_{\\gamma_0 } \\left [ \\trace{\\gamma_0\\rho } +      \\trace{(i-\\gamma_0)\\sigma } \\right ] \\notag \\\\    & = \\frac{1}{2 } + \\frac{1}{2 } \\max_{\\gamma_0 }    \\trace{\\gamma_0(\\rho-\\sigma ) } \\ .",
    "\\label{eq : op.distinguishing.thm}\\end{aligned}\\ ] ] the proof concludes by plugging in .      the trace distance is used as the security definition of qkd , because the relevant measure for cryptographic security is the distinguishing advantage ( as discussed in ) , and as proven in , the distinguishing advantage between two quantum states corresponds to their trace distance .",
    "this operational interpretation of the trace distance involves two worlds , an ideal one and a real one , and the distance measure is the ( renormalized ) difference between the probabilities of the distinguisher correctly guessing to which world it is connected .    in this section",
    "we describe a different interpretation of the total variation and trace distances . instead of having two different worlds , we consider one world in which the outcomes of interacting with the real and ideal systems co - exist . and instead of these distance measures being a difference between probability distributions",
    ", they become the probability that any ( classical ) value occurring in one of the systems does not _ simultaneously _ occur in the other .",
    "we call such an event a _ failure _  since one system is ideal , if the other behaves differently , it must have failed  and the trace distance becomes the probability of a failure occurring",
    ".    given two random variables @xmath288 and @xmath321 with probability distributions @xmath248 and @xmath249 , any distribution @xmath322 with marginals given by @xmath248 and @xmath249 is called a coupling of @xmath248 and @xmath249 .",
    "the interpretation of the trace distance treated in this section uses one specific coupling , known as a _",
    "maximal coupling _ in probability theory  @xcite .",
    "[ thm : difference ] let @xmath248 and @xmath249 be two probability distributions over the same alphabet @xmath250 .",
    "then there exists a probability distribution @xmath323 on @xmath324 such that @xmath325 : = \\sum_{z } p_{z \\tilde{z}}(z , z ) \\geq 1-   d(p_z , p_{\\tilde{z}})\\ ] ] and such that @xmath248 and @xmath249 are the marginals of @xmath326 , i.e. , @xmath327    it turns out that the inequality in is tight , i.e. , one can also show that for any distribution @xmath322 , @xmath328 \\leq 1 - d(p_z , p_{\\tilde{z}})$ ] .",
    "we will however not use this fact here .",
    "consider now a real system that outputs values given by @xmath288 and an ideal system that outputs values according to @xmath321",
    ". tells us that there exists a coupling of these distributions such that the probability of the real system producing a different value from the ideal system is bounded by the total variation distance between @xmath248 and @xmath249 .",
    "thus , the real system behaves ideally except with probability @xmath329 .",
    "we first prove this theorem , then in here below we apply it to quantum systems .",
    "let @xmath330 be the real function on @xmath324 defined by @xmath331 & \\text{if $ z=\\tilde{z}$ } \\\\ 0 & \\text{otherwise}\\end{cases }     \\end{aligned}\\ ] ] ( for all @xmath332 ) .",
    "furthermore , let @xmath333 and @xmath334 be the real functions on @xmath250 defined by @xmath335 we then define @xmath323 by @xmath336    we now show that @xmath323 satisfies the conditions of the theorem .",
    "for this , we note that for any @xmath303 @xmath337 \\geq 0 \\      ,     \\end{aligned}\\ ] ] i.e. , @xmath333 , and , likewise , @xmath334 , are nonnegative .",
    "since @xmath330 is by definition also nonnegative , we have that @xmath323 is nonnegative , too . from or  , which we will prove below",
    ", it follows that @xmath323 is also normalized .",
    "hence , @xmath323 is a valid probability distribution .    to show we use again the non / negativity of @xmath338 and @xmath334 , which implies @xmath339 = 1- d(p_z , p_{\\tilde{z } } ) \\ ,    \\end{aligned}\\ ] ] where in the last equality we used the alternative formulation of the total variation distance from .",
    "to prove , we first note that @xmath340 = d(p_z ,   p_{\\tilde{z } } ) \\ .",
    "\\end{aligned}\\ ] ] using this we find that for any @xmath303 @xmath341 by symmetry , this also proves .    in the case of quantum states , can be used to couple the outcomes of any observable applied to the quantum systems .",
    "[ cor : difference ] for any states @xmath106 and @xmath247 with trace distance @xmath342 , and any measurement given by its povm operators @xmath343 with outcome probabilities @xmath344 and @xmath345 , there exists a coupling of @xmath346 and @xmath347 such that @xmath348 \\leq d(\\rho,\\sigma ) \\ .\\ ] ]    immediate by combining and .",
    "tells us that if two systems produce states @xmath106 and @xmath247 , then for any observations made on those systems there exists a coupling for which the values of each measurement will differ with probability at most @xmath301 .",
    "it is instructive to remember that this operational meaning is not essential to the security notion or part of the framework in any way .",
    "it is an intuitive way of understanding the trace distance , so as to better choose a suitable value .",
    "it allows this distance to be thought of as a maximum failure probability , and the value for @xmath70 to be chosen accordingly .",
    "non / composable security models often use measures of uncertainty to quantify how much information an adversary might have about a secret , e.g. , entropy as used by shannon to prove the security of the one - time pad  @xcite .",
    "these measures are often weaker than what one obtains using a global distinguisher , and in general do not provide good security definitions .",
    "they are however quite intuitive and in order to further illustrate the quantitative value of the distinguishing advantage , we derive bounds on two of these measures of uncertainty in terms of the trace distance , namely on the probability of guessing the secret key in and on the von neumann entropy of the secret key in .",
    "let @xmath349 be the joint state of a secret key in the @xmath1 subsystem and eve s information in the @xmath2 subsystem . to guess the value of the key",
    ", eve can pick a povm @xmath350 , measure her system , and output the result of the measurement .",
    "given that the key is @xmath11 , her probability of having guessed correctly is @xmath351 .",
    "the average probability of guessing correctly for this measurement is then given by the sum over all @xmath11 , weighted by their respective probabilities @xmath352 . and eve s probability of correctly guessing the key is defined by taking the maximum over all measurements , @xmath353{k|e } \\coloneqq    \\max_{\\{\\gamma_k\\ } } \\sum_{k \\in \\ck } p_k \\trace{\\gamma_k \\rho^k_e } \\    .\\ ] ]    [ lem : pguess ] for any bipartite state @xmath0 with classical @xmath1 , @xmath354{k|e } \\leq \\frac{1}{|\\ck| } + d\\left ( \\rho_{ke},\\tau_k \\tensor \\rho_e\\right ) \\ , \\ ] ] where @xmath3 is the fully mixed state .",
    "note that for @xmath355 , where @xmath356 maximizes , the guessing probability can equivalently be written @xmath354{k|e } =    \\trace{m \\rho_{ke } } \\ .\\ ] ] furthermore , @xmath357 in we proved that for any operator @xmath270 , @xmath358 setting @xmath359 and @xmath360 in the above inequality , we finish the proof : @xmath361{k|e } & \\leq \\frac{1}{|\\ck| } + d\\left ( \\rho_{ke},\\tau_k     \\tensor \\rho_e\\right ) \\ . \\qedhere\\end{aligned}\\ ] ]      let @xmath349 be the joint state of a secret key in the @xmath1 subsystem and eve s information in the @xmath2 subsystem .",
    "we wish to bound the von neumann entropy of @xmath1 given @xmath2 ",
    "@xmath362 , where @xmath363  in terms of the trace distance @xmath364 .",
    "we first derive a lower bound on the von neumann entropy , using the following theorem from alicki and fannes  @xcite .",
    "[ thm : af04 ] for any bipartite states @xmath214 and @xmath365 with trace distance @xmath366 and @xmath367 , we have @xmath368 where @xmath369 is the binary entropy .    [ cor : af04 ] for any state @xmath0 with @xmath370 , where @xmath3 is the fully mixed state , we have @xmath371    immediate by plugging @xmath0 and @xmath372 in",
    ".    given the von neumann entropy of @xmath1 conditioned on @xmath2 , @xmath373 , one can also upper bound the trace distance of @xmath0 from @xmath372 by relating @xmath373 to the relative entropy of @xmath0 to @xmath372  the relative entropy of @xmath106 to @xmath247 is defined as @xmath374 .",
    "[ lem : entropybound ] for any quantum state @xmath0 , @xmath375    from the definitions of the relative and von neumann entropies we have @xmath376 where @xmath377 is the identity matrix .",
    "we then use the following bound on the relative entropy ( * ? ? ?",
    "* theorem  1.15 ) to conclude the proof : @xmath378    and can be written together in one equation , upper and lower bounding the conditional von neumann entropy : @xmath379 .",
    "in we derived two conditions  secrecy and correctness  that together imply that a real qkd system is indistinguishable from the ideal one . an alternative definition for _",
    "@xmath70/secrecy _ was proposed in the literature  @xcite : @xmath380    this alternative notion is equivalent to the standard definition of secrecy ( ) up to a factor @xmath381 , as can be seen by the following calculation .",
    "let @xmath382 be the state for which the minimum in is achieved .",
    "then , @xmath383 we thus have @xmath384 this means that any qkd scheme proven secure with one definition is still secure according to the other , with a minor adjustment of the failure parameter @xmath70 .",
    "however , we do not know how to derive this alternative notion from a composable framework .",
    "in particular , it is not clear if the failure @xmath70 from is additive under parallel composition .",
    "for example , the concatenation of two keys that each , individually , satisfy , could possibly have distance from uniform greater than @xmath167 .",
    "for this reason , the arxiv version of @xcite was updated to use instead .",
    "a distinguisher has been introduced as a single entity that has to guess which of two systems it is holding .",
    "mathematically , it is more convenient to model a distinguisher as a set @xmath85 .",
    "each element @xmath385 is a system with @xmath386 interfaces .",
    "@xmath387 of them connect to the @xmath387 interfaces of a resource @xmath47 or @xmath80 and the last interface outputs a bit , as illustrated in on .",
    "thus , for any @xmath385 and any compatible system @xmath47 , @xmath388 is a binary random variable .",
    "the distinguishing advantage can be rewritten as @xmath389 - \\pr[d(\\as)=1 ] \\ .\\ ] ]    for a set @xmath85 to be a valid distinguisher , it has to be closed under composition with all resources and converters . for a converter @xmath46 and a resource @xmath390 , define @xmath391 a distinguisher @xmath85",
    "is closed under composition with a set of converters @xmath392 and a set of resources @xmath393 , and a set of resources @xmath393 to be valid , they also have to be closed under composition , i.e. , for all @xmath394 and all @xmath395 , @xmath396 ] if for all @xmath385 , all @xmath397 and all @xmath398 , @xmath399 for example , the set of all possible distinguishers is closed under composition with the sets of all possible converters and resources , and is used for information / theoretic security .",
    "the set of all efficient distinguishers is closed under composition with the sets of all efficient converters and resources , and is used for computational security . the fact that the distinguishing advantage is non / increasing under composition ( see on ) follows directly from the closure of the distinguisher , .      in this section",
    "we briefly sketch why the security criteria of guarantee that the composition of two secure protocols is also secure .",
    "we write up the argument in the case where an adversary is present ( from ) .",
    "the case with no adversary follows similarly with the simulator @xmath247 removed and a filter connected to eve s interface of every resource .",
    "proofs of this can be found in @xcite .",
    "let protocols @xmath82 and @xmath38 construct @xmath75 from @xmath56 and @xmath400 from @xmath75 within @xmath70 and @xmath83 , respectively , i.e. , @xmath401 it then follows from the triangle inequality of the distinguishing metric that @xmath402 constructs @xmath400 from @xmath56 within @xmath403 , @xmath404    to see why this holds when an adversary is present , note that since @xmath405 can not be distinguished from @xmath406 with advantage greater than @xmath70 , by a distinguisher running @xmath38 in particular can not distinguish them . hence @xmath407 likewise , a distinguisher running @xmath247 does not know if it is interacting with @xmath408 or @xmath409 , i.e. , @xmath410 combining the two equations above , we get @xmath411    so there exists a simulator , namely @xmath412 , such that the real and ideal systems can not be distinguished with advantage greater than @xmath403 .",
    "the argument for parallel composition is similar to that of sequential composition .",
    "let @xmath82 and @xmath38 construct @xmath75 and @xmath413 from @xmath56 and @xmath414 within @xmath70 and @xmath83 , respectively , i.e. , @xmath415 if these resources and protocols are composed in parallel , we find that @xmath416 constructs @xmath417 from @xmath418 within @xmath403 , @xmath419 where @xmath420 is the filtered resource consisting of the parallel composition of the resources and filters from @xmath56 and @xmath414 .    for the case",
    "where an adversary is present , this can be proven as follows . from the definition of parallel composition of converters in we",
    "have @xmath421 since for some @xmath247 , @xmath405 can not be distinguished from @xmath406 with advantage greater than @xmath70 , by running @xmath422 in parallel can not help the distinguisher , hence @xmath423 for the same reason we also have @xmath424 combining the equations above and one more use of , we obtain @xmath425    thus , there exists a simulator , namely @xmath426 , such that the real and ideal systems can not be distinguished with advantage greater than @xmath403 .",
    "in this section we model recursive composition of an authentication protocol and qkd . starting with a short ( uniform ) key",
    ", we construct an authentic channel , which is then used in a qkd protocol to obtain a long key . part of this new key is then consumed in another round of authentication , which is used by qkd , resulting in more shared secret key .",
    "this can be repeated indefinitely . from the composability of the security definitions we immediately have that the total failure is bounded by the sum of the individual failures of ( each run of ) each protocol .",
    "the goal of this section is to write this out explicitly : we show that @xmath427 where @xmath428 and @xmath429 are registers containing all shared , unused secret keys generated in @xmath387 rounds of authentication and qkd , @xmath2 contains the adversary s information , @xmath430 and @xmath431 are the states obtained by a distinguisher interacting with the real and ideal systems , by conditioning on obtaining a key and writing it as @xmath432 , because the @xmath387 repetitions of the protocol lead to @xmath386 events : it never aborted , aborted after one round , two rounds , etc . ] and @xmath433 and @xmath434 are the ( probabilities of ) failure of the authentication and qkd protocols in each round . is half of that in round @xmath435 , and the sum @xmath436 is bounded for all @xmath387 . ]    for this recursive construction it is not necessary to use the ( interactive ) authentication protocol of renner and wolf  @xcite which only requires a password .",
    "instead we use the simpler universal hashing of wegman and carter  @xcite , which appends a tag to the message that is sent , but requires an ( almost ) uniform key .",
    "a more detailed analysis of this authentication method , including key recycling and a proof that strong universal hashing meets the corresponding security definition can be found in @xcite .    in",
    "we sketch how to construct an authentic channel from a shared secret key and insecure channel resource , and provide a generic simulator . in we compose multiple authentication protocols in parallel so that we may have multiple use authentic channels in qkd . in",
    "we compose such a construction with qkd , obtaining a key expansion protocol . and",
    "finally in we iteratively compose a key expansion protocol with itself , resulting in a continuous stream of secret key bits .",
    "the qkd and one - time pad protocols discussed in this work make use of authentic channels as depicted in , which always deliver the correct message to the receiver .",
    "this is however impossible to construct from an insecure channel , since eve can always cut the communication between alice and bob , and prevent any message from being transmitted .",
    "what can be constructed , is a channel which guarantees that bob does not receive a corrupted message .",
    "he either receives the correct message sent by alice , or an error , which symbolizes an attempt by eve to change the message .",
    "this can be modeled by giving eve s idealized interface two controls : the first provides her with alice s message , the second allows her to input one bit that prevents alice s message from being delivered to bob and produces an error instead .",
    "we illustrate this in .",
    "[ .5][l ]    ( keybox ) at ( 0,0 ) ; ( alice ) at ( -2.6,0 ) alice ; ( bob ) at ( 2.6,0 ) bob ; ( eve ) at ( 0,-1.7 ) eve ; ( ajunc ) at ( eve.north |- alice ) ;    ( alice ) to node[pos=.06,auto ] @xmath26 node[pos=.94,auto ] @xmath26 ( bob ) ; ( ajunc.center ) to node[pos=.85,auto ] @xmath26 ( eve ) ;    [ .5][r ]    ( keybox ) at ( 0,0 ) ; ( alice ) at ( -2.6,0 ) alice ; ( bob ) at ( 2.6,0 ) bob ; ( eve ) at ( 0,-1.7 ) eve ; ( ajunc ) at ( eve.north west |- alice ) ;    ( alice ) to node[pos=.12,auto ] @xmath26 ( 0,0 ) to node[pos=.5 ] ( ejunc ) + ( 160:-.8 ) ; ( ajunc.center ) to node[pos=.85,auto , swap ] @xmath26 ( eve.north west ) ; ( .8,0 ) to node[pos=.9,auto ] @xmath437 ( bob ) ; ( ejunc.center |- eve.north ) to node[pos=.15,auto , swap ] @xmath24 ( ejunc.center ) ;    a construction of this authentic channel resource from an insecure channel and a shared secret key resource is typically accomplished by computing the hash @xmath438 of the message @xmath26 , and sending the string @xmath439 to bob , where @xmath11 is the shared secret key and @xmath440 a family of hash functions  @xcite .",
    "alice s part of the authentication protocol @xmath441 thus gets a key @xmath11 from an ideal key resource , a message @xmath26 from alice , and sends @xmath442 down the insecure channel .",
    "when bob receives a string @xmath443 , he needs to check whether @xmath444 .",
    "his part of the protocol gets a key @xmath11 from an ideal key resource , a message @xmath445 from the channel , and outputs @xmath446 if @xmath444 , otherwise an error @xmath138 .",
    "if the ideal key resource used by both players produces an error instead of a key , alice and bob abort , and the protocol is trivially secure .",
    "so for simplicity we omit this possibility in the following , and assume that they always get a shared secret key .",
    "this is depicted in .",
    "2.89 .75    ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( a ) at ( -,0 ) @xmath447 + @xmath448 ; at ( a.north west ) @xmath441 ; ( alice ) at ( -,0 ) ;    ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ; ( b ) at ( , 0 ) @xmath449 + @xmath450 ; at ( b.north west ) @xmath451 ; ( bob ) at ( , 0 ) ;    ( keybox ) at ( 0 , ) ; ( key ) at ( 0 , ) key ; at ( keybox.north west ) secret key @xmath94 ; ( channel ) at ( 0,- ) ; at ( channel.north west ) insecure channel @xmath452 ; ( eveleft ) at ( -.4,-1.75 ) ; ( everight ) at ( .4,-1.75 ) ; ( ajunc ) at ( eveleft |- a3 ) ; ( bjunc ) at ( everight |- b3 ) ;    ( key ) to node[auto , swap , pos=.3 ] @xmath11 ( a1 ) ; ( key ) to node[auto , pos=.3 ] @xmath11 ( b1 ) ;    ( alice.center ) to node[auto , pos=.4 ] @xmath26 ( a2 ) ; ( b2 ) to node[auto , pos=.75 ] @xmath453 ( bob.center ) ;    ( a3 ) to ( ajunc.center ) to node[pos=.8,auto , swap ] @xmath454 ( eveleft.center ) ; ( everight.center ) to node[pos=.2,auto , swap ] @xmath455 ( bjunc.center ) to ( b3 ) ;    in the case where no adversary is present and filters cover eve s interfaces of figures  [ fig : auth.resource.switch ] and [ fig : auth.real ] , the real and ideal systems are indistinguishable as they are both identity channels which faithfully transmit @xmath26 from alice to bob .",
    "so in the following we only consider the case where an adversary is present , condition   in .    in the ideal setting",
    ", the authentic channel ( ) has the same interface on alice s and bob s sides as the real setting ( ): alice can input a message , and bob receives either a message or an error .",
    "however , eve s interface looks quite different : in the real setting she can modify the transmission on the insecure channel , whereas in the ideal setting the adversarial interface provides only controls to read the message and interrupt the transmission . from",
    "we have that an authentication protocol constructs the authentic channel if there exists a simulator @xmath456 that can recreate the real interface while accessing just the idealized one . an obvious choice for the simulator is to first generate its own key @xmath11 and output @xmath439 .",
    "then upon receiving @xmath455 , it checks if @xmath457 and cuts the transmission on the authentic channel if this does not hold .",
    "we illustrate this in .",
    "-1.1 .75 ( channel ) at ( 0 , ) ; at ( channel.north west ) authentic channel @xmath101 ; ( alice ) at ( - , ) ; ( bob ) at ( , ) ;    ( sim ) at ( 0 , ) ; at ( sim.north west ) @xmath456 ; ( sleft ) at ( -.809 , ) ; ( sright ) at ( .809 , ) ; ( sim.north ) to ( sim.south ) ;    ( ajunc ) at ( sleft |- alice ) ; ( bjunc ) at ( sright |- bob ) ;    ( alice.center ) to node[pos=.15,auto ] @xmath26 ( .4 , ) to node[pos=.54 ] ( ejunc ) + ( 160:-.8 ) ; ( ajunc.center ) to node[pos=.63,auto , swap ] @xmath26 ( sleft ) ; ( 1.2 , ) to node[pos=.75,auto ] @xmath437 ( bob.center ) ; ( sright ) to node[pos=.4,auto , swap ] @xmath24 ( ejunc.center ) ;    ( sltext ) at ( -.809 , ) @xmath458 ; ( srtext ) at ( .809 , ) @xmath459 + @xmath460 ;    ( eveleft ) at ( sleft |- 0 , ) ; ( everight ) at ( sright |- 0 , ) ; ( sleft ) to node[pos=.75,auto , swap ] @xmath454 ( eveleft.center ) ; ( everight.center ) to node[pos=.25,auto , swap ] @xmath455 ( sright ) ;    ( key ) at ( .15,+.8 ) key ; ( key ) to ( sleft ) ;    an authentication protocol is then @xmath70/secure if figures  [ fig : auth.real ] and [ fig : auth.ideal ] are @xmath70/close , i.e. , @xmath461 portmann  @xcite showed that is satisfied if the hash functions used are @xmath70/almost strongly universal@xmath462 . if any two different messages are almost uniformly mapped to all pairs of tags . ]",
    "in we modeled one run of an authentication protocol , that constructs a one - time use authentic channel .",
    "in general , qkd protocols require multiple rounds of authenticated communication .",
    "this is achieved by running the same protocol in parallel multiple times with new keys .",
    "it is straightforward from , , and that @xmath463 parallel repetitions of the authentication protocol are @xmath464/close to @xmath463 ideal authentic channels and simulators in parallel , @xmath465    in the following , when we speak of the authentication used in qkd we always refer to parallel repetitions of the protocol that construct multiple use authenticated channels @xmath466 . for simplicity",
    ", we use the same notation for multiple authentic channels as we have for single channels  we denote the resulting multiple use authentic channel by @xmath101 , as well as @xmath452 for the multiple use insecure channel , @xmath94 for a key sufficiently long for authenticating every message and @xmath433 for the accumulated failure of all parallel repetitions in one round of qkd .",
    "let @xmath467 be an authentication protocol which constructs with failure @xmath433 a ( multiple use ) authentic channel @xmath101 from a short secret key of length @xmath463 , @xmath468 , and an insecure classical channel @xmath452 , @xmath469 let @xmath470 be a qkd protocol which constructs with failure @xmath434 a long secret key of length @xmath471 , @xmath472 , from an authentic channel @xmath101 and an insecure quantum channel @xmath102 , @xmath473 by sequentially composing the two protocols , we immediately have that @xmath474 constructs a long secret key @xmath472 from a short secret key @xmath468 and insecure channels @xmath452 and @xmath102 , with failure @xmath475 , @xmath476 the generic argument for sequential composition is given in . here",
    "we illustrate it in the special case of authentication and qkd , and draw it in .    2.25 .75    ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( a ) at ( -,0 ) ; at ( a.north west ) @xmath441 ; ( alice ) at ( -,- ) ;    ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ; ( b ) at ( , 0 ) ; at ( b.north west ) @xmath451 ; ( bob ) at ( , - ) ;    ( keybox ) at ( 0 , ) ; ( key ) at ( 0 , ) ; at ( keybox.north west ) secret key @xmath468 ;    ( f1 ) at ( -,0 ) ; ( f2 ) at ( -,- ) ; ( f3 ) at ( -,-2 * ) ; ( f ) at ( -,- ) ; at ( f.north west ) @xmath99 ;    ( g1 ) at ( , 0 ) ; ( g2 ) at ( , - ) ; ( g3 ) at ( , -2 * ) ; ( g ) at ( , - ) ; at ( g.north west ) @xmath100 ;    ( eveq1 ) at ( -2 * , ) ; ( juncq1 ) at ( eveq1 |- f3 ) ; ( eveq2 ) at ( - , ) ; ( juncq2 ) at ( eveq2 |- f3 ) ; ( evec1 ) at ( 0 , ) ; ( juncc1 ) at ( evec1 |- a3 ) ; ( evec2 ) at ( , ) ; ( juncc2 ) at ( evec2 |- a3 ) ;    ( key ) to ( a1 ) ; ( key ) to ( b1 ) ;    ( a2 ) to node[auto , pos=.5,swap ] @xmath477 ( f1 ) ; ( b2 ) to node[auto , pos=.5 ] @xmath478 ( g1 ) ;    ( a3 ) to ( juncc1.center ) to node[pos=.85,auto , swap ] @xmath310 ( evec1.center ) ; ( evec2.center ) to node[pos=.19,auto ] @xmath479 ( juncc2.center ) to ( b3 ) ;    ( f3 ) to ( juncq1.center ) to node[pos=.7,auto , swap ] @xmath106 ( eveq1.center ) ; ( eveq2.center ) to node[pos=.34,auto ] @xmath107 ( juncq2.center ) to ( g3 ) ;    ( f2 ) to node[auto , pos=.8,swap ] @xmath480 ( alice.center ) ; ( g2 ) to node[auto , pos=.8 ] @xmath481 ( bob.center ) ;    -1.85 0    ( channel ) at ( 0 , ) ; ( c0 ) at ( 0 , ) ; at ( channel.north west ) authentic channel @xmath101 ; ( alice ) at ( - , ) ; ( bob ) at ( , ) ;    \\(f ) at ( - , ) ; ( f1 ) at ( - , ) ; ( f2 ) at ( - , ) ; ( f3 ) at ( - , ) ; at ( f.north west ) @xmath99 ;    \\(g ) at ( , ) ; ( g1 ) at ( , ) ; ( g2 ) at ( , ) ; ( g3 ) at ( , ) ; at ( g.north west ) @xmath100 ;    ( sim ) at ( 0 , ) ; at ( sim.north east ) @xmath456 ; ( sleft ) at ( -.809 , ) ; ( sright ) at ( .809 , ) ; ( srright ) at ( , ) ; ( scenter ) at ( 0 , ) ; ( c1 ) at ( sleft |- f1 ) ; ( c2 ) at ( sright |- g1 ) ;    ( c0 ) to node[pos=.5,auto , swap ] @xmath477 ( f1 ) ; ( c0 ) to node[pos=.5,auto ] @xmath477 ( g1 ) ; ( c1 ) to node[pos=.5,auto , swap ] @xmath103 ( sleft ) ; ( sright ) to node[pos=.5,auto , swap ] @xmath24 ( c2 ) ;    ( eveq1 ) at ( -2 * , ) ; ( juncq1 ) at ( eveq1 |- f3 ) ; ( eveq2 ) at ( - , ) ; ( juncq2 ) at ( eveq2 |- f3 ) ; ( evec1 ) at ( 0 , ) ; ( evec2 ) at ( , ) ;    ( scenter ) to node[pos=.8,auto , swap ] @xmath310 ( evec1.center ) ; ( srright ) to node[pos=.78,auto , swap ] @xmath479 ( evec2.center ) ;    ( f2 ) to node[auto , pos=.8,swap ] @xmath480 ( alice.center ) ; ( g2 ) to node[auto , pos=.8 ] @xmath481 ( bob.center ) ; ( f3 ) to ( juncq1.center ) to node[pos=.7,auto , swap ] @xmath106 ( eveq1.center ) ; ( eveq2.center ) to node[pos=.34,auto ] @xmath107 ( juncq2.center ) to ( g3 ) ;    -1.3    ( channel ) at ( 0,0 ) ; ( c0 ) at ( 0,0 ) ; at ( channel.north west ) secret key @xmath472 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ;    ( simqkd ) at ( - , ) ; at ( simqkd.west ) @xmath135 ; ( pleft ) at ( -2 * , ) ; ( pcenter ) at ( - , ) ; ( pright ) at ( 0 , ) ;    ( simauth ) at ( , ) ; at ( simauth.east ) @xmath456 ; ( qleft ) at ( 0 , ) ; ( qcenter ) at ( , ) ; ( qright ) at ( 2 * , ) ;    ( ajunc ) at ( pcenter |- alice ) ; ( bjunc ) at ( qcenter |- bob ) ; ( c0 ) to node[pos=.8,auto , swap ] @xmath93 ( alice ) ; ( c0 ) to node[pos=.8,auto ] @xmath93 ( bob ) ; ( pcenter ) to node[pos=.45,auto , swap ] @xmath24 ( ajunc ) ; ( qcenter ) to node[pos=.48,auto , swap ] @xmath24 ( bjunc ) ;    ( peve1 ) at ( -2 * , ) ; ( peve2 ) at ( - , ) ; ( qeve1 ) at ( , ) ; ( qeve2 ) at ( 2 * , ) ;    ( pleft ) to node[pos=.84,auto , swap ] @xmath106 ( peve1 ) ; ( peve2 ) to node[pos=.18,auto ] @xmath107 ( pcenter ) ; ( pright ) to node[pos=.5,auto ] @xmath103 ( qleft ) ; ( qcenter ) to node[pos=.6,auto , swap ] @xmath310 ( qeve1 ) ; ( qright ) to node[pos=.55,auto , swap ] @xmath479 ( qeve2 ) ;    depicts the real world : the two protocols are composed in sequence and run using the short key and insecure channel resources . in",
    "we have a system consisting of the real qkd protocol and the ideal authentic channel and simulator .",
    "we know that the black parts of figures  [ fig : ex.auth.real ] and [ fig : ex.auth.hybrid ] are @xmath433/close , so adding the qkd protocol in gray can only reduce the distance .",
    "depicts the ideal secret key resource and simulators . by removing the dashed simulator @xmath456 from figures  [ fig : ex.auth.hybrid ] and [ fig : ex.auth.ideal ] , we recover the real and ideal qkd systems from figures  [ fig : qkd.real.adv ] and [ fig : qkd.ideal ]  with an extra switch on the authentic channel in the real system and on the secret key resource in the ideal system . since these are @xmath434/close , so are figures  [ fig : ex.auth.hybrid ] and [ fig : ex.auth.ideal ] . putting the two statements together with the triangle inequality",
    "finishes the argument .",
    "this reasoning is summed up in the following equation , which can be directly derived from , and : @xmath482    let @xmath133 be the state gathered by a distinguisher interacting with the real system from and @xmath134 be the state gathered by the distinguisher interacting with the ideal system from . by the argument above we have @xmath483      in we show that the composition of qkd and authentication  i.e. , key expansion  constructs a long key from a short key and insecure channels . to show that this can be done recursively , we need to argue that part of the long key",
    "can be kept for the next round of key expansion .",
    "so far the secret keys have been treated as blocks , entirely consumed by a protocol , which is not convenient for the analysis of a protocol that uses only part of a key .",
    "instead , we should think of these key resources ",
    "e.g. , @xmath468 and @xmath472 in figures  [ fig : ex.auth.real ] and [ fig : ex.auth.ideal ]  as a parallel composition of resources that produce a single bit of key , i.e. , @xmath484 , where @xmath485 is the @xmath486 instance of a resource @xmath487 that produces one bit of key ( or an error message ) at alice and bob s interfaces , and has a switch at eve s interface that decides if it produces the key or error .    then , a proof that @xmath488 is immediately also a proof that @xmath489 for any @xmath490 . iterating the protocol @xmath387 times",
    "we get @xmath491 where @xmath492 and @xmath493 are @xmath387 instances of the resources @xmath452 and @xmath102 in parallel , and @xmath494 is @xmath387 times the sequential composition of @xmath474",
    ". follows immediately from this .",
    "we are greatly indebted to the following people for having proofread an initial draft and provided us with invaluable feedback and comments : rotem arnon friedman , normand beaudry , vedran dunjko , felipe lacerda , charles ci wen lim , christoph pacher , joseph renes , marco tomamichel , and nino walenta .",
    "this work has been funded by the swiss national science foundation ( via grant no .",
    "200020 - 135048 and the national centre of competence in research ` quantum science and technology ' ) , the european research council ",
    "erc ( grant no .",
    "258932 )  and by the vienna science and technology fund ( wwtf ) through project ict10 - 067 ( hipanq ) .",
    "charles  h. bennett and gilles brassard .",
    "quantum cryptography : public key distribution and coin tossing . in _ proceedings of ieee international conference on computers , systems , and",
    "signal processing _ , pages 175179 , 1984 .",
    "eli biham , michel boyer , p.  oscar boykin , tal mor , and vwani roychowdhury .",
    "a proof of the security of quantum key distribution ( extended abstract ) . in _ proceedings of the 32nd symposium on theory of computing , stoc  00 _ , pages 715724 .",
    "acm , 2000 . .",
    "michael ben - or , michael horodecki , debbie leung , dominic mayers , and jonathan oppenheim . the universal composable security of quantum key distribution .",
    "in _ theory of cryptography , proceedings of tcc 2005 _ , volume 3378 of _ lecture notes in computer science _ , pages 386406 .",
    "springer , 2005 . .",
    "michael backes , birgit pfitzmann , and michael waidner . a general composition theorem for secure reactive systems . in _ theory of cryptography ,",
    "proceedings of tcc 2004 _ , volume 2951 of _ lecture notes in computer science _ , pages 336354 .",
    "springer , 2004 .",
    ".      ran canetti .",
    "universally composable security : a new paradigm for cryptographic protocols . in",
    "_ proceedings of the 42nd symposium on foundations of computer science , focs  01 _ , pages 136145 .",
    "ieee , 2001 .",
    ".      ran canetti , yevgeniy dodis , rafael pass , and shabsi walfish .",
    "universally composable security with global setup . in _ theory of cryptography , proceedings of tcc 2007",
    "_ , volume 4392 of _ lecture notes in computer science _ , pages 6185 .",
    "springer , 2007 . .",
    ". constructive cryptography  a new paradigm for security definitions and proofs . in _ proceedings of theory of security and applications , tosca 2011 _ , volume 6993 of _ lecture notes in computer science _ , pages 3356 .",
    "springer , 2012 . .",
    "dominic mayers .",
    "quantum key distribution and string oblivious transfer in noisy channels . in _ advances in cryptology ",
    "crypto  96 _ , volume 1109 of _ lecture notes in computer science _ , pages 343357 .",
    "springer , 1996 . .",
    "birgit pfitzmann and michael waidner .",
    "composition and integrity preservation of secure reactive systems . in _ proceedings of the 7th acm conference on computer and communications security , css  00",
    "_ , pages 245254 .",
    "acm , 2000 . .",
    "birgit pfitzmann and michael waidner . a model for asynchronous reactive systems and its application to secure message transmission .",
    "ieee symposium on security and privacy _ , pages 184200 .",
    "ieee , 2001 . .",
    "renato renner and robert knig .",
    "universally composable privacy amplification against quantum adversaries . in joe",
    "kilian , editor , _ theory of cryptography , proceedings of tcc 2005 _ , volume 3378 of _ lecture notes in computer science _ , pages 407425 .",
    "springer , 2005 . .",
    "renato renner and stefan wolf .",
    "unconditional authenticity and privacy from an arbitrarily weak secret . in",
    "_ advances in cryptology ",
    "crypto 2003 _ , volume 2729 of _ lecture notes in computer science _ , pages 7895 .",
    "springer , 2003 . .",
    "valerio scarani , helle bechmann - pasquinucci , nicolas  j. cerf , miloslav du  ek , norbert ltkenhaus , and momtchil peev .",
    "the security of practical quantum key distribution .",
    ", 81:13011350 , september 2009 . .",
    "marco tomamichel , christian schaffner , adam smith , and renato renner .",
    "leftover hashing against quantum side information . in",
    "_ proceedings of 2010 international symposium on information theory , isit _ , pages 27032707 .",
    "ieee , 2010 . .",
    "dominique unruh .",
    "universally composable quantum multi - party computation . in _ advances in cryptology ",
    "eurocrypt 2010 _ , volume 6110 of _ lecture notes in computer science _ , pages 486505 .",
    "springer , 2010 . ."
  ],
  "abstract_text": [
    "<S> this work is intended as an introduction to cryptographic security and a motivation for the widely used quantum key distribution ( qkd ) security definition . </S>",
    "<S> we review the notion of security necessary for a protocol to be usable in a larger cryptographic context , i.e. , for it to remain secure when composed with other secure protocols . </S>",
    "<S> we then derive the corresponding security criterion for qkd . </S>",
    "<S> we provide several examples of qkd composed in sequence and parallel with different cryptographic schemes to illustrate how the error of a composed protocol is the sum of the errors of the individual protocols . </S>",
    "<S> we also discuss the operational interpretations of the distance metric used to quantify these errors . </S>"
  ]
}