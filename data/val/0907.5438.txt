{
  "article_text": [
    "due to advances in technology , it is now possible to have low - cost , stand - alone sensor and actuator devices that can communicate through the wireless medium .",
    "such devices have applications in areas like epidemic detection , biological attack detection , intruder detection . in some applications ,",
    "these sensor nodes are deployed in hostile environments , and therefore security of communication becomes critical . to provide security , well - developed public key cryptographic methods",
    "have been considered , but these are compute - intensive and too demanding for resource - constrained devices @xcite .",
    "so , symmetric key based encryption is the only way for secure communication between nodes .",
    "however , to do that , two nodes should agree upon a common key first . for this",
    ", various key distribution schemes have been proposed in the literature .",
    "eschenauer and gligor @xcite proposed a random key predistribution scheme , referred to as the basic scheme or eg scheme .",
    "based on this scheme , various improvements have been proposed in the literature @xcite .    recently , there has been research on key distribution schemes which make use of predeployment knowledge of expected locations of the nodes , and these schemes are shown to perform better than the basic schemes .",
    "but in some cases predeployment knowledge is not available , so in @xcite liu et.al .",
    "proposed a scheme which uses group - based deployment model and showed that their scheme is better than the basic schemes .",
    "although in @xcite , anjum proposed a scheme which does not use predeployment knowledge of the nodes , and group - based deployment model , the scheme requires some nodes which can transmit at different power levels .",
    "our scheme also uses the same concept of groups as used by @xcite but we have dropped the assumptions of predeployment knowledge of expected locations of nodes and group - based deployment .",
    "moreover , our scheme does not require nodes which can transmit messages at different power levels .",
    "our contributions in this paper are as follows .    * we propose a scheme , in which nodes form groups _ after _",
    "deployment on the basis of their physical locations , and generate keys which depend on the group they are part of .",
    "each group is assigned a key pool and no two key pools have a common key .",
    "if a node is compromised , then it can affect communication in its group only ; so the proposed scheme is more resilient to node capture than the basic schemes .",
    "* we show using simulations that our scheme performs better than the basic scheme @xcite and the schemes which assume pre - deployment knowledge of node locations @xcite .",
    "our scheme assumes that there exists some constant time before which the adversary is unable to extract keys from the nodes , as assumed in @xcite .",
    "we show that this time can be considerably less for our scheme than that in @xcite , with certain tradeoff .",
    "* we also look at the problem of connectivity of the key graph formed when our scheme is followed .",
    "this problem is studied in the framework of the `` ab random geometric graph '' @xcite . using results in @xcite , the number of tagged nodes",
    "is calculated such that the whole key graph is connected with high probability .",
    "the rest of this paper is organized as follows . in section  [ s :",
    "related_work ] , we discuss related work .",
    "section  [ s : proposal ] describes our proposal .",
    "section  [ s : abrandom ] gives the expressions for the parameters ensuring connectivity of the key graph .",
    "section  [ s : sim_results ] gives the comparison with the scheme proposed by du.et.al @xcite .",
    "section  [ s : otherapp ] describes other applications where our scheme could be useful .",
    "section  [ s : conclusion ] concludes the paper .",
    "various key distribution schemes have been proposed in the literature for wireless sensor networks , keeping in view the resource - constrained devices used in these networks .",
    "eschenauer and gligor @xcite proposed a scheme in which for every node , keys are picked randomly ( with replacement ) from a key pool and assigned to it before deployment ; this scheme is known as the basic or eg scheme .",
    "after key discovery , two neighbor nodes that have a common key use that as the key for secure communication . based on this basic scheme",
    ", several schemes with enhanced security features have been suggested in @xcite .",
    "there is another class of schemes called `` threshold schemes . '' in these schemes , all nodes can communicate with one another , and no communication is compromised until some fixed number of nodes is compromised .",
    "blundo et.al.@xcite and blom @xcite proposed such threshold schemes .",
    "blundo s scheme uses symmetric bivariate polynomials to obtain pairwise keys , while blom s scheme also uses a similar idea , in which symmetric matrices are used instead of symmetric polynomials .",
    "@xcite improve upon blom s scheme by combining it with the random key distribution scheme .",
    "similarly , liu and ning @xcite improve upon blundo s @xcite scheme by combining it with random key distribution scheme .",
    "both these schemes perform better than the eg scheme @xcite in terms of connectivity and resilience against node capture .",
    "but threshold schemes do not scale with the number of nodes in the network . for a fixed resilience against node",
    "capture , if the number of nodes is increased , then they require large memory .    in any sensor network , generally nodes need to talk to their neighbor nodes only .",
    "so it is quite intuitive that nodes which are near should share the same key pool .",
    "this will lead to more efficient use of memory , and will give better connectivity and better resilience against node capture . because of this reason , various location - based key distribution schemes have been proposed .",
    "@xcite and liu and ning @xcite independently proposed schemes which assume predeployment knowledge of expected locations of the nodes .",
    "nodes are assumed to be deployed in groups ( group - based deployment model ) and nodes in the same group have the same expected location , so that after deployment , they lie close to one another . further in @xcite , nodes in the same group are allocated keys from the same key pool , while the groups which lie far from each other are allocated disjoint key pools . therefore , compromise of any node jeopardises transmissions of nearby nodes only .",
    "due to this reason , performance is better than that of the eg scheme .",
    "all the location - based schemes which depend on the knowledge of expected locations of nodes perform well , but they are all prone to estimation errors in the expected positions of the nodes . so other schemes which do not assume predeployment knowledge of the expected locations of the nodes have been proposed . in @xcite ,",
    "liu et.al . proposed a scheme which does not use expected locations of the nodes but still uses group - based deployment .",
    "this scheme proposes a framework , and any basic scheme like random key distribution or polynomial - based scheme can be used with this framework .",
    "the authors showed that basic schemes used with their proposed framework perform better than when used alone .",
    "further , anjum @xcite removed the assumption of group - based deployment model and also removed the assumption of knowledge of expected locations of nodes .",
    "he showed that the scheme performs better than the basic scheme ; but the scheme requires nodes which can transmit at different power levels . in this scheme",
    "there are some special nodes which generate different random numbers ( nonces ) and transmit them at different power levels .",
    "nodes receiving the same nonce can communicate , provided they are neighbors .",
    "our scheme is different from this scheme , since we do not require the presence of nodes which can transmit at different levels . instead of using different power levels ,",
    "our scheme uses ttl scoping . in ttl",
    "scoping , after the deployment phase , some nodes transmit a broadcast packet containing the ttl ( time to live ) field , similar to that of ip packets in data networks .    in addition , our scheme is also different in the way nodes choose their key rings . in @xcite , on receiving the nonce , nodes map it to some different value . in contrast , in our scheme , some nodes transmit their i d , and corresponding to every i d there is an associated key pool . nodes sample keys from the key pool corresponding to the received i d . the main advantage of doing this is the improved resilience against node capture . in  @xcite ,",
    "all nodes receiving the same nonce use the same key for secure communication ; so if any node is compromised , all the secure links formed by the nonce received by this node will be compromised . on the other hand , in our scheme , communication with other nodes",
    "is compromised _ with some probability only _ , because nodes receiving the same i d sample keys from the key pool instead of using the same key .",
    "in this paper , we consider static sensor networks .",
    "nodes are uniformly distributed across the deployment region .",
    "we use the following cryptographic primitives :    * pseudo random number generator ( prng )  this is a deterministic function , which takes an @xmath0 bit number as input and produces output of @xmath1 pseudorandom bits : @xmath2 * hash function  this is a deterministic function which takes an input of any length and returns a number of fixed bit - size . given the output of the hash function , one can not find the input and it is highly unlikely that for two different inputs , the output is same : @xmath3 where @xmath0 is variable , and @xmath4 is fixed .      in our scheme ,",
    "all nodes are divided into two sets : the `` tagged node '' set and the `` normal node '' set .",
    "tagged nodes are similar to normal nodes in terms of memory , storage , and transmission range .",
    "they are deployed in the same way as normal nodes .",
    "the difference is that tagged nodes are programmed to broadcast a packet after the deployment phase is over .",
    "subsequently , tagged nodes behave like normal nodes .",
    "once deployment is over , a tagged node broadcasts a packet with ttl value @xmath5 .",
    "nodes within distance @xmath6 from the tagged node receive this packet , and all these nodes associate themselves in one group .",
    "different groups are associated with _",
    "key pools , and nodes in a group `` sample '' keys from the same key pool .",
    "since we are using disjoint key pools , so compromise of any node results in compromise of communications in _ its _ group only ; in this way _ localization _ of the effects of node compromise is achieved .",
    "our scheme relies on the assumption that the adversary will not be able to extract keying material from a captured node before a small time interval has elapsed .",
    "this is a reasonable assumption because breaking into a node and extracting keying material will take some time .",
    "the same assumption has been made in @xcite and @xcite .",
    "our scheme consists of the following four phases :    * predeployment phase * broadcast phase * key generation phase * shared key discovery phase      in this phase , two keys are stored in the nodes .",
    "* global key ( @xmath7 ) : this is common to all the nodes and is used for authentication and encryption of packets during the broadcast phase . *",
    "root key ( @xmath8 ) : this key is a single key stored in all the nodes .",
    "it is used to derive the other keys during the key allocation phase ; this procedure is explained subsequently .",
    "after nodes are deployed , all tagged nodes broadcast a packet up to @xmath5 hops , containing two fields : tagged node i d field and hop count field .",
    "each node ( both normal and tagged node ) receiving this packet fetches the tagged node i d from the packet , and compares it with previously stored tag ids .",
    "if there is no match with any of the previously stored tag ids , then its value is stored . then",
    ", the hop count value is fetched from the packet and its value is decreased by @xmath9 . if , after decreasing , the value is @xmath10 , then the packet is discarded ; otherwise , the packet is broadcast again with the new value of the hop count .",
    "this broadcast packet is encrypted and authenticated using the global key ( @xmath7 ) .",
    "all nodes are able to decrypt and authenticate this packet since this key is stored in all the nodes . after the end of this phase , all nodes which are within distance @xmath6 from the tagged node receive the packet . in this way , all the nodes are divided into groups , on the basis of their physical locations .",
    "consider a tagged node @xmath11 .",
    "it will broadcast a packet with tagged node i d field set to @xmath11 .",
    "all nodes within the radius of @xmath6 of this tagged node will receive this packet and associate themselves with tagged node i d @xmath11 .",
    "all these nodes will consider themselves as a part of group @xmath12 .",
    "so there will be a group corresponding to each tagged node .",
    "we note that , since a node can receive broadcasts from more than one tagged node , a node can be part of multiple groups .",
    "there is a key pool corresponding to each group and each node samples @xmath13 keys from the key pool of each group to which it belongs . since a node can be part of multiple groups , so different nodes can choose different key ring sizes . to bound the number of keys chosen by any node",
    ", a limit is put on the number of key pools from which a node samples keys .",
    "let @xmath14 be the maximum number of groups to which a node can belong .",
    "we define two sets for any node @xmath15 , @xmath16 and @xmath17 .",
    "@xmath16 contains all the distinct tagged node ids received during the broadcast phase .",
    "@xmath17 is a subset of @xmath16 .",
    "a selects @xmath14 tag ids out of the received tag ids , and the set @xmath17 contains these selected values .    randomly selecting the tagged node ids from @xmath16",
    "is not the best thing to do .",
    "consider an example with @xmath18 .",
    "if two neighbor nodes receive broadcasts from the same @xmath19 nodes , then on randomly selecting the tag i d , the probability that both choose the same tagged node i d is @xmath20 .",
    "but if both the nodes plan to choose the least tag node i d , then with probability @xmath9 they will choose the same tag node i d . and",
    "intuitively one can say that two neighbor nodes are more likely to receive broadcasts from the same set of tagged nodes .",
    "so we set the selection criterion as : node @xmath15 selects the smallest @xmath14 tagged node ids from the set @xmath16 .      once the broadcast phase is over , nodes select @xmath14 smallest tag ids from the received tag ids . if we consider node @xmath15 , then it is a part of groups in the set @xmath21 .",
    "after the node has associated itself with the groups , it has to sample keys from the key pools corresponding to the selected groups .",
    "one way to do this is to store all the key pools in all the nodes before deployment , but this is not feasible because of memory constraints .",
    "so we propose a way in which nodes can _ compute _ the keys such that it is _ equivalent _ to first selecting the key pools and then sampling keys from them .",
    "let @xmath22 be the key pool associated with tag i d @xmath11 or group i d @xmath11 . the pool is generated by using [ eqn : key_pool ] .",
    "@xmath23    [ eqn : key_pool ]    here , @xmath24 represents the concatenation operator , @xmath25 is the key pool size per group , @xmath8 is the root key as defined earlier and @xmath26 represents @xmath11 hash operations on @xmath8 ; for example @xmath27 .",
    "however , instead of deriving the key pool and then sampling the keys , one can first select @xmath13 numbers uniformly distributed in the range from @xmath9 to @xmath25 , ( called key indices ) , and then applying the function @xmath28 to them .",
    "each key can be identified by the tuple ( group number , key index ) .",
    "keys are stored along with this tuple to identify them during the subsequent key discovery phase .    to understand the procedure followed by nodes to derive their key rings",
    ", we consider a node @xmath15 , and examine what it does .",
    "\\1 ) node @xmath15 generates the set @xmath29 , and arranges it in ascending order of its index values , @xmath30 , with @xmath31 .",
    "let us call these values `` group keys . ''",
    "if there are large number of tagged nodes then it will be expensive to compute the group key corresponding to tag nodes with large tag i d s .",
    "so to minimize the computation , some fraction of group keys , uniformly distributed across the full range , can be computed offline and stored in the node before deployment .",
    "for example , if the number of tagged node is @xmath32 , then @xmath33 group keys ( @xmath34 ) could be pre - stored , so that the average number of hash computations done by any node will be @xmath35 .",
    "\\2 ) in this step , node @xmath15 generates @xmath36 sets each containing @xmath13 values in the range of @xmath9 to @xmath25 .",
    "these sets are generated using the prng , with @xmath37 as the seed values .",
    "let us call the elements of these sets `` key indices . ''",
    "since a node can generate a maximum of @xmath14 sets , so it will use @xmath14 seed values in the range @xmath38 to @xmath39 .",
    "further , nodes @xmath15 and @xmath40 will use different seed values since node @xmath15 will use seed values in the range @xmath38 to @xmath39 , while node @xmath40 will use values in the range @xmath41 to @xmath42 . in this way ,",
    "all sets of key indices are generated independently , and hence the key rings are also generated independently .",
    "\\3 ) in this step , mapping of key indices to actual keys is done .",
    "node @xmath15 has @xmath36 group keys and same number of key index sets .",
    "node @xmath15 will pair each key index set with a single group key .",
    "pairs are formed by first arranging the group keys in ascending order of their indices , and the group key with the smallest index is paired up with the key index set generated using @xmath43 as the seed value . from each pair ,",
    "@xmath13 tuples are formed , where the first element of the tuple is the group key and the second element is the key index of the set .",
    "for example , suppose @xmath44 . if the key index set produced using @xmath43 is @xmath45 and that using @xmath46 is @xmath47 , then following set of tuples is produced : + @xmath48 = \\{@xmath49 , @xmath50 , @xmath51 , @xmath52 , @xmath53 , @xmath54 }    note that each tuple can be identified by ( group number(@xmath11 ) , key index ) .",
    "so even after the key @xmath55 is deleted from the memory of the node , tuples can be identified using the group number ; for the above example , tuples can be identified by @xmath56 @xmath57 .",
    "this is important because during the key discovery phase , node will send it s node i d ( @xmath15 ) and the set @xmath17 , and from this information , other nodes should be able to identify the common keys .",
    "final keys are obtained by concatenating the elements of the tuple and then hashing the resultant value .",
    "this procedure is also illustrated in fig .",
    "[ figure : keygen1 ] .",
    "our scheme requires nodes that are close to each other to be in the same group , nodes in the same group to sample keys from the same key pool and key pools selected by distinct groups to be disjoint .",
    "the procedure described above satisfies all our requirements .",
    "as soon as the key allocation phase is over , @xmath8 and the set @xmath58 should be deleted from memory , because given this information , an attacker may be able to generate all the keys in the network , and that will lead to compromise of all communication .      in this phase ,",
    "node @xmath15 broadcasts its node i d and the set @xmath17 .",
    "if node @xmath59 is a neighbor of node @xmath15 , then node @xmath59 will receive the broadcast by node @xmath15 .",
    "on receiving this broadcast packet , node @xmath59 will fetch the set @xmath17 and then compare its elements with @xmath60 .",
    "if there is no matching element between the two sets , then there is no common key .",
    "if there are common elements between the two sets , then call the set of matching elements as @xmath61 , @xmath62 .",
    "let us call an element of @xmath61 as @xmath63 .",
    "now node @xmath59 will find the index of the elements present in the set @xmath61 , in sets @xmath17 and @xmath60 .",
    "what is done with the index is explained using the example below .",
    "for example , let @xmath64 and @xmath65 , so the set @xmath66 , and the index of these elements in set @xmath17 is @xmath9 and @xmath19 , while in set @xmath60 it is @xmath9 and @xmath67 .",
    "now node @xmath59 will generate @xmath13 numbers for seed values @xmath43 ,",
    "@xmath68 and @xmath69 , @xmath70",
    "using the prng . then it will compare the values produced from seed values @xmath43 and @xmath69 , and also compare the values produced from the seed values @xmath68 and @xmath70 .",
    "if any value matches , then the node @xmath15 and @xmath59 share a common key , and as mentioned earlier , the key is identified by the tuple ( group number , key index ) .",
    "if multiple keys are found to be shared , then xor of all the keys will be used as the common key . on following a similar procedure ,",
    "node @xmath15 can also find common keys with node @xmath59 .",
    "after keys have been generated and discovered , the natural question which arises is : can any two nodes exchange information securely ?",
    "this question is addressed by considering the notion of the key graph and connectivity of the key graph .",
    "a node is represented by a vertex in the graph .",
    "there exists an edge between two vertices if the corresponding nodes share at least one common key , and lie in the coverage radius of each other . a graph formed in this way",
    "is called a `` key graph . ''",
    "there are two properties of connectivity : local connectivity and global connectivity .",
    "local connectivity of any node is the probability of sharing at least one key with the neighbor nodes , while global connectivity is the percentage of the nodes in the key graph that is reachable from any node .    in this section ,",
    "we are concerned with the problem of how to find the number of tagged and normal nodes such that the resulting key graph is connected .",
    "the problem of connectivity of the key graph can be broken down into followingthe three sub problems :    * inter group connectivity ( ieg )  since key pools are disjoint , so nodes belonging to two different groups will have zero probability of sharing a key .",
    "so , two groups can only be connected if there exist @xmath71 nodes ( @xmath72 ) , which belong to both the groups . as these common nodes sample keys from the key pools of both the groups , so these nodes are reachable from the nodes of both the groups ; thus , these nodes act as `` gateways . '' + now consider a graph in which a _ group _ is represented by a vertex , and there exists an edge between two vertices , if there exists at least one common node between two groups . in",
    "_ this _ graph , if all the vertices are reachable from any vertex , then the ieg property holds .",
    "we will use the results in @xcite on ab random geometric graphs to find the minimum number of groups or tagged nodes required such that all the groups are connected .",
    "+ in @xcite , two kinds of nodes are considered : a type and b type .",
    "two a type nodes can communicate via a b type node only .",
    "let the graph formed in this way _ among a type nodes _ , be denoted as @xmath73 , where @xmath0 is the number of a type nodes and @xmath74 is the number of b type nodes .",
    "we apply this framework by taking type a nodes as tagged nodes , and type b nodes as normal nodes .",
    "+ define @xmath75 as the largest nearest neighbor radius of the ab random geometric graph , i.e. , the radius below which there exists at least one node with degree equal to zero .",
    "then , @xcite shows that @xmath76 for transmission radius ( @xmath77 ) equal to @xmath78 .",
    "+ also , the thereshold transmission radius of the nodes for which the graph @xmath73 is connected with high probability as @xmath79 is given by eqn .",
    "[ eqn : iyer_radius ] : @xmath80 we will fix @xmath81 , which will translate to a target small probability of `` graph isolated '' groups . then , we find the value of number of tagged nodes ( @xmath0 ) required , for the given value of @xmath82 and total number of nodes to be deployed ( @xmath83 ) , by substituting @xmath84 and @xmath85 in eqn .",
    "[ eqn : iyer_radius ] .",
    "if @xmath86 is the solution obtained and if @xmath87 , then the number of tagged nodes greater than @xmath88 will satisfy ieg property . *",
    "tagged node - covered  nodes which do not receive broadcasts will not be part of any group ; so these nodes are isolated from rest of the network .",
    "the number of tagged nodes should be such that all the normal nodes are covered by broadcast from at least one tagged node .",
    "we will use the result from @xcite to calculate the expected number of normal nodes not covered by any broadcast .",
    "it is given by eqn .",
    "[ eqn : kcovered0 ] .",
    "@xmath89 = ( n - n ) e^{-\\frac{n}{a } \\pi ( hr)^2 } \\label{eqn : kcovered0}\\ ] ] where , @xmath90 is the deployment area . to satisfy this property , @xmath91 $ ]",
    "should be less than @xmath9 . if @xmath86 is the solution of the equation @xmath91 = 1 $ ] , and if @xmath92 , then the number of tagged nodes greater than @xmath93 will satisfy node - covered property .",
    "+ so , to satisfy both the node - covered property and and inter group connectivity , the number of tagged nodes is given by eqn .",
    "[ eqn : calct ] . @xmath94 * intra group connectivity ( iag )  all the nodes within a group should be reachable from any node in the key graph .",
    "we will ensure this by using expressions to calculate the keyring size in the eg scheme @xcite .",
    "since the number of nodes in a group has decreased , so less number of nodes will share the key pool .",
    "so , key pool size could be reduced , which , in turn , will reduce the requisite keyring size .    if all the above mentioned requirements",
    "are met , then our objective of connectivity of the key graph is achieved , because all the nodes are reachable within a group , all the groups are reachable from any group and all the nodes are part of at least one group .",
    "we compare our proposed scheme with the scheme  @xcite which makes the stronger assumption of availability of expected knowledge of positions of nodes , which our scheme does not .",
    "however our scheme makes another assumption : that there exists an interval ( vulnerable time ) , after the deployment , during which attacker should not be able to extract the keys .",
    "it may be noted that in our scheme , keys are generated by nodes _",
    "after _ they are deployed , while in @xcite , keys are loaded into nodes before deployment . moreover",
    ", our scheme also has the features of random key distribution .",
    "so it is appropriate to compare the connectivity and resilience of our scheme with that of schemes which use random key pre distribution ( rkd ) schemes ( for example , @xcite ) and a scheme like in @xcite , which uses rkd with the assumption of knowledge of expected locations of the nodes .",
    "we will also compare our scheme with leap@xmath95 in @xcite , which is also a post - deployment key generation scheme and considers the notion of vulnerable time .",
    "we will argue that our scheme leads to a smaller vulnerable time than that required by in leap@xmath95 , and discuss a related trade - off .    for the evaluation of our scheme , we use the following metrics",
    ".    * connectivity of the nodes in the key graph : local and global connectivity . * resilience against node capture  this is the ratio of the number of links compromised to the total number of links formed .",
    "links which are formed among the compromised nodes and the links which are between the compromised nodes and the noncompromised nodes are not taken into account while calculating the number of compromised links and the total links .",
    "* memory requirement  as the sensor nodes are resource - constrained , so there is always the requirement of attaining high connectivity using minimum memory . * vulnerable time  it is the time interval after the deployment during which attacker should not be able to extract key material from the nodes , and before which all nodes should delete the key material from their memory .",
    "it is desirable to keep it as less as possible .",
    "our simulations are done for the following values of parameters .",
    "the number of tagged nodes is calculated using the analysis in the previous section .",
    "* deployment region : @xmath96 * total number of nodes @xmath97 is taken as @xmath98 * transmission radius of the node is taken as @xmath99 * hop count ( @xmath5 ) is taken as @xmath9 * @xmath100 , keys per key pool @xmath101 * tagged nodes : @xmath102 , @xmath103    also , simulations for the scheme @xcite are done using the same set of values .",
    "figure  [ fig_all_1 ] shows the plot of probability of sharing at least one key between two neighbor nodes versus the key ring size of our scheme , scheme @xcite and eg scheme .",
    "we have simulated our scheme for @xmath104 . from the graph it is clear that our scheme performs better than or as well as the scheme @xcite . for lower values of key ring size ,",
    "@xmath105 should be chosen which gives better connectivity than that of the scheme @xcite , while for larger value of key ring sizes @xmath106 should be chosen , which gives same connectivity as that of the scheme @xcite .",
    "we have derived analytical expressions for the probability of sharing at least one key between two neighbor nodes , and the results match well with the simulated values as shown in fig .",
    "[ fig_sim_anal_h2 ] .",
    "the analytical expressions are not reported here due to lack of space .",
    "for @xmath104 , table  [ tab : locvsglob ] gives the comparison of local connectivity with global connectivity of the nodes . as we can see from the last row of the table",
    ", there are small percentages ( @xmath107 and @xmath108 ) of nodes which are isolated even at large value of key ring size .",
    "this is because they do not receive broadcasts from any of the tagged nodes , and hence remain isolated from the network .",
    "however , an algorithm could be developed to tackle this problem of a small number of nodes not receiving broadcast from any tagged node .",
    "the simplest algorithm is as follows : all nodes which do not receive a broadcast from any tagged node send a packet containing their node i d to the sink node , and broadcast it up to one hop . nodes which receive _ this _ broadcast packet fetch the node i d from the packet , and send a message to the sink node ( authenticated and encrypted with their own key ) containing the node i d they received from the broadcast packet and their group i d . the sink node samples keys from the group key pool of the neighbor nodes and communicates it to the uncovered node .",
    ".local vs global connectivity [ cols=\"^,^,^,^,^\",options=\"header \" , ]      the basic threat model that we have considered is as follows : if a node is captured , then all the keys contained in it are revealed to the adversary . to evaluate the resilience of our scheme",
    ", we consider that @xmath109 nodes are compromised and they are distributed uniformly across the deployment region .",
    "key ring size of any node is @xmath110 , where @xmath13 is the key ring size per group .",
    "total number of keys in the key pool is given by @xmath111 , where @xmath25 is key pool size per group , and @xmath112 is number of tagged nodes . if one node is captured , then the probability that a link between two non - captured nodes is compromised is at most @xmath113 .",
    "( this is a worst case value since links between non - captured nodes could be secured by multiple keys ) .",
    "@xmath113 . for @xmath114 compromised nodes , the probability that a link is not compromised is at least @xmath115 .",
    "then , the probability that a link is compromised is at most @xmath116 . while comparing this metric with other schemes , local connectivity ( @xmath117 ) needs to be kept the same .",
    "figure [ fig_security33 ] , [ fig_security50 ] show a comparison of the resilience metric of our scheme with that of other schemes , at local connectivity @xmath118 and @xmath119 .",
    "it shows that our scheme performs better than other schemes .",
    "we see that the fraction of links compromised due to node capture is very small compared to that in @xcite .",
    "this is attributed to the fact that our scheme has small group size , which is equal to the total number of nodes falling in the transmission radius of the node .",
    "so when a node is compromised , it affects communication links of the groups it is part of , and these are very small in size ; so the fraction of total links compromised is also very small . in @xcite ,",
    "the group size is bigger , so the number of affected nodes is larger , and so is the fraction of compromised links .",
    "however , it could be argued that in this scheme also the number of groups can be increased , simultaneously decreasing the number of nodes a group ; but this requires expected locations to be known with more precision , with a corresponding increase in the complexity of deployment .      since in our scheme keys",
    "are computed after the nodes are deployed , so it is important to consider another threat , which is the vulnerable time during which the compromise of a single node can lead to compromise of whole network .",
    "we will compare our scheme with leap@xmath95 , which also needs to address the issue of vulnerable time . since we have shown that our scheme for ( @xmath120 ) performs better than the schemes using deployment knowledge , so we will compare the vulnerable time for @xmath120 only .",
    "vulnerable time required by our scheme for ( @xmath120 ) is just the time taken by all the tagged nodes to broadcast up to one hop or time taken by all the nodes to hear broadcast from all the neighbor tagged nodes ; the latter constitute a fraction ( @xmath121 ) of the total number of nodes . in leap@xmath95",
    "@xcite , it is the time taken by all the nodes to hear broadcast from all the neighbor nodes . since the number retransmission attempts required by the node to transmit in any mac protocol depends on the number of active neighbor nodes , so our scheme , which requires that nodes should hear from only neighbor tagged nodes which are only the fraction of total number nodes , requires less time , than what leap+ does .",
    "however , there is a trade off between performance achieved and the requirement of the vulnerable time , since leap+ acheives perfect resilience and connectivity while our scheme does not . nevertheless , still our scheme is able to achieve better performance than the schemes which assumes predeployment knowledge of the nodes .      to add new nodes after the initial deployment , the base station or sink informs tagged nodes to broadcast their tag i d s for the new nodes .",
    "root key is stored in the new nodes before their deployment , using which they generate the keys .",
    "key generation and shared key discovery procedure is same as described earlier .",
    "after the generation of the key ring they delete the root key .",
    "apart from the main objective of key distribution , our scheme could be used for other applications as well .",
    "tagged nodes could be considered as the virtual base stations ( vbs ) distributed all across the deployment region , and other nodes around them associated with them .",
    "if the main base station wants to convey a broadcast message only to some nodes lying in a certain region , then this could be accomplished by a single unicast message to the tagged node ( assuming tagged nodes can identify their location ) lying near that region and then that tagged node can broadcast that message with a flag indicating a `` regional broadcast , '' so that receiving nodes check the hop count value before rebroadcasting the message .",
    "all the tagged nodes can maintain a group key which is known only to its group members ; this will help secure delivery of the message .",
    "this scheme can also be used for group key management . in a distributed environment where all nodes can not communicate directly with base station",
    ", tagged nodes can act as the virtual base stations .",
    "such a scheme involving decentralization is proposed in @xcite ; however , in this scheme , cluster heads ( tagged nodes ) have larger transmission range than the cluster members ( normal nodes ) , so that they can communicate directly with sink nodes , and are less energy - constrained than the normal nodes .",
    "another application could be the collection of data , where the nodes in the group sends their data to the vbs of their respective group , and then vbs creates a single packet and send it to bs .",
    "we have proposed a key distribution scheme , which does not assume node predeployment knowledge and also does not require nodes to be deployed in groups , still our scheme achieves better performance in terms of connectivity and security than the scheme  @xcite which take these assumptions . however our scheme assumes existence of vulnerable time , which is less than that of the leap+  @xcite , with tradeoff of connectivity and resilience .",
    "our future work is to propose a way to allocate polynomial based keys  @xcite , to make our scheme more robust against node capture attack .",
    "another future work is to evaluate and compare the performance of our scheme for non - uniform deployments .",
    "this work was supported by drdo under project 571 : a research and implementation project on sensor networks ."
  ],
  "abstract_text": [
    "<S> many basic key distribution schemes specifically tuned to wireless sensor networks have been proposed in the literature . </S>",
    "<S> recently , several researchers have proposed schemes in which they have used group - based deployment models and assumed predeployment knowledge of the expected locations of nodes . </S>",
    "<S> they have shown that these schemes achieve better performance than the basic schemes , in terms of connectivity , resilience against node capture and storage requirements . </S>",
    "<S> but in many situations expected locations of nodes are not available . in this paper </S>",
    "<S> we propose a solution which uses the basic scheme , but does _ not _ use group - based deployment model and predeployment knowledge of the locations of nodes , and yet performs better than schemes which make the aforementioned assumptions .    in our scheme , </S>",
    "<S> groups are formed _ </S>",
    "<S> after _ deployment of sensor nodes , on the basis of their physical locations , and the nodes sample keys from disjoint key pools . </S>",
    "<S> compromise of a node affects secure links with other nodes that are part of its group only . because of this reason , our scheme performs better than the basic schemes and the schemes using predeployment knowledge , in terms of connectivity , storage requirement , and security . </S>",
    "<S> moreover , the post - deployment key generation process completes sooner than in schemes like leap+  @xcite .    </S>",
    "<S> security ; key distribution ; sensor networks </S>"
  ]
}