{
  "article_text": [
    "arithmetic branching programs ( abps ) are a well studied model of computation in algebraic complexity : they were already used by valiant in the @xmath3-completeness proof of the permanent @xcite and have since then contributed to the understanding of arithmetic circuit complexity ( see e.g. @xcite ) . the computational power of abps is well understood : they are equivalent to both skew and weakly skew arithmetic circuits and thus capture the determinant , matrix power and other natural problems from linear algebra  @xcite .",
    "the complexity of bounded width abps is also well understood : in a parallel to barrington s theorem @xcite , ben - or and cleve @xcite proved that polynomial size abps of bounded width are equivalent to arithmetic formulas .",
    "we modify abps by giving them memory during their computations and ask how this changes their computational power .",
    "there are several different motivations for doing this : we define branching programs with stacks , that are an adaption of the nondeterministic auxiliary pushdown automaton ( nauxpda ) model to the arithmetic circuit model .",
    "the nauxpda - characterization of @xmath4has been very successful in the study of this class and has contributed a lot to its understanding .",
    "we give a characterization of @xmath5 a class that is well known for its apparent lack of natural characterizations . in the boolean",
    "setting graph connectivity problems on edge - labeled graphs that are similar to our abps with stacks have been shown to be complete for @xmath6 @xcite .",
    "one motivation for adapting these results to the arithmetic circuit setting is the hope that one can apply techniques from the nauxpda setting to arithmetic circuits .",
    "we show that this is indeed applicable by presenting an adaption of a proof of niedermeier and rossmanith @xcite to give a straightforward proof of the classical parallelization theorem for @xmath5first proved by valiant et al .",
    "@xcite .",
    "another motivation is that our modified branching programs in different settings give various very similar characterizations of different arithmetic circuit classes .",
    "this allows us to give a new perspective on problems like @xmath5vs .",
    "@xmath7 , @xmath5vs .",
    "@xmath3 that are classical question from arithmetic circuit complexity .",
    "this is similar to the motivation that kintali  @xcite has for studying similar graph connectivity problems in the boolean setting .",
    "finally , all modifications we make to abps are straightforward and natural .",
    "the basic question is the following : abps are in a certain sense a memoryless model of computation . at each point of time during the computation we do not have any information about the history of the computation sofar apart from the state we are in .",
    "so what happens if we allow memory during the computation ?",
    "intuitively , the computational power should increase , and we will see that it indeed does ( under standard complexity assumptions of course ) . how do different types of memory compare ? what is the role of the width of the branching programs if we allow memory ? in the remainder we will answer several of these questions .    the structure of the paper is a follows : after some preliminaries we start off with abps that may use a stack during their computation .",
    "we show that they characterize  @xmath5 , consider several restrictions and give a proof of the parallelization theorem for  @xmath5 .",
    "next we consider abps with random access memory , show that they characterize  @xmath3and consider some restrictions of them , too .",
    "we briefly recall the relevant definitions from arithmetic circuit complexity .",
    "a more thorough introduction into arithmetic circuit classes can be found in the book by brgisser  @xcite .",
    "newer insights into the nature of  @xmath5and especially  @xmath7are presented in the excellent paper of malod and portier  @xcite .",
    "an _ arithmetic circuit _ over a field @xmath8 is a labeled directed acyclic graph ( dag ) consisting of vertices or gates with indegree or fanin @xmath9 or @xmath10 . the gates with fanin @xmath9 are called input gates and are labeled with constants from @xmath8 or variables @xmath11 . the gates with fanin @xmath10",
    "are called computation gates and are labeled with @xmath12 or @xmath13 .    the polynomial computed by an arithmetic circuit is defined in the obvious way : an input gates computes the value of its label , a computation gate computes the product or the sum of its childrens values , respectively .",
    "we assume that a circuit has only one sink which we call the output gate .",
    "we say that the polynomial computed by the circuit is the polynomial computed by the output gate .",
    "the _ size _ of an arithmetic circuit is the number of gates .",
    "the _ depth _ of a circuit is the length of the longest path from an input gate to the output gate in the circuit .",
    "we also consider circuits in which the @xmath13-gates may have unbounded fanin .",
    "we call these circuits _ semi - unbounded circuits_. observe that in semi - unbounded circuits @xmath12-gates still have fanin @xmath10 .",
    "a circuit is called _ multiplicatively disjoint _ if for each @xmath12-gate @xmath14 the subcircuits that have the children of @xmath14 as output - gates are disjoint .",
    "a circuit is called _ skew _ , if for all of its @xmath12-gates one of the children is an input gate .",
    "we call a sequence @xmath15 of multivariate polynomials a family of polynomials or _ polynomial family_. we say that a polynomial family is of polynomial degree , if there is a univariate polynomial @xmath16 such that @xmath17 for each @xmath18",
    ". @xmath5is the class of polynomial families of polynomial degree computed by families of polynomial size arithmetic circuits .",
    "we will use the following well known characterizations of  @xmath5 :    ( @xcite)[thm : vpknown ] let @xmath15 be a family of polynomials .",
    "the following statements are equivalent :    1 .",
    "@xmath19 2 .",
    "@xmath15 is computed by a family of multiplicatively disjoint polynomial size circuits . 3 .",
    "@xmath15 is computed by a family of semi - unbounded circuits of logarithmic depth and polynomial size .",
    "@xmath20is defined analogously to @xmath5with the circuits restricted to trees . by a classical result of brent @xcite , @xmath20equals the class of polynomial families computed by arithmetic circuits of depth @xmath21 .",
    "@xmath7  is the class of families of polynomials computed by families of skew circuits of polynomial size . finally , a family @xmath15 of polynomials is in @xmath3 , if there is a family @xmath22 and a polynomial @xmath16 such that @xmath23 for all @xmath18 where @xmath24 denotes the vector @xmath25 for some polynomial  @xmath26 .",
    "a polynomial @xmath27 is called a _ projection _ of @xmath28 ( symbol : @xmath29 ) , if there are values @xmath30 such that @xmath31 .",
    "a family @xmath15 of polynomials is a @xmath16-projection of @xmath32 ( symbol : @xmath33 ) , if there is a polynomial @xmath34 such that @xmath35 for all @xmath18 . as usual",
    "we say that @xmath32 is hard for an arithmetic circuit class @xmath36 if for every @xmath37 we have @xmath33 .",
    "if further @xmath38 we say that @xmath32 is @xmath36-complete .",
    "the following criterion by valiant @xcite for containment in @xmath2 is often helpful :    [ lem : criterion ] let @xmath39 be a function in @xmath40 , then the family @xmath15 of polynomials defined by @xmath41 is in @xmath2",
    ".      the second common model of computation in arithmetic circuit complexity are arithmetic branching programs .",
    "an _ arithmetic branching program _ ( abp ) @xmath42 is a dag with two vertices @xmath43 and @xmath44 and an edge labeling @xmath45 .",
    "a path @xmath46 in @xmath42 has the _ weight _ @xmath47 .",
    "let @xmath14 and @xmath48 be two vertices in @xmath42 , then we define @xmath49 where the sum is over all @xmath14-@xmath48-paths @xmath50 .",
    "the abp @xmath42 computes the polynomial @xmath51 .",
    "the _ size _ of @xmath42 is the number of vertices of @xmath42 .",
    "malod and portier proved the following theorem :    ( @xcite ) @xmath52 , iff @xmath15 is computed by a family of polynomial size  abps .",
    "an abp of width @xmath53 is an abp in which all vertices are organized into layers @xmath54 , there are only edges from layer @xmath55 to @xmath56 and the number of vertices in each layer @xmath55 is at most @xmath53 .",
    "the computational power of abps of constant width was settled by ben - or and  cleve :    ( @xcite ) @xmath57 , iff @xmath15 is computed by a family of polynomial size abps of constant width .",
    "let @xmath58 be a set called _ symbol set_. for a symbol @xmath59 we define two _ stack operations _ : @xmath60 and @xmath61 .",
    "additionally we define the stack operation @xmath62 without any arguments .",
    "a _ sequence of stack operations _ on @xmath58 is a sequence @xmath63 , where either @xmath64 for @xmath65 and @xmath66 or @xmath67 . _",
    "realizable sequences _ of stack operations are defined inductively :    * the empty sequence is realizable . *",
    "if @xmath50 is a realizable sequence of stack operations , then @xmath68 is realizable for all @xmath59 .",
    "also @xmath69 and @xmath70 are realizable sequences . * if @xmath50 and @xmath71 are realizable sequences of stack operations , then @xmath72 is a realizable sequence .    a _ stack branching program _ ( sbp )",
    "@xmath42 is an abp with an additional edge labeling @xmath73 .",
    "a path @xmath74 in @xmath42 has the sequence of stack operations @xmath75 .",
    "if @xmath76 is realizable we call @xmath50 a _ stack - realizable path_. the sbp @xmath42 computes the polynomial @xmath77 where the sum is over all stack - realizable @xmath43-@xmath44-paths @xmath50 .",
    "it is helpful to interpret the stack operations as operations on a real stack that happen along a path through @xmath42 . on an edge @xmath78 with the stack operation @xmath79 we simply push @xmath43 onto the stack . if @xmath78 has the stack operation @xmath80 we pop the top symbol of the stack . if it is @xmath43 we continue the path , but if it is different from @xmath43 the path is not stack realizable and we abort it .",
    "@xmath62 stands for `` no operation '' and thus as this name suggests the stack is not changed on edges labelled with @xmath81 .",
    "realizable paths are exactly the paths on which we can go from @xmath43 to @xmath44 in this way without aborting while starting and ending with an empty stack .    to ease notation we sometimes call edges @xmath82 with @xmath83 for an @xmath59 simply @xmath84-edges .",
    "@xmath85-edges and @xmath62-edges are defined in the obvious analogous way .",
    "it will sometimes be convenient to consider only sbps that have no @xmath62-edges .",
    "the following easy proposition shows that this is not a restriction .",
    "[ prop : nonopsbp ] let @xmath42 be an sbp of size @xmath43 .",
    "there is an sbp @xmath86 of size @xmath87 such that @xmath88 and @xmath86 does not contain any @xmath62-edges . if @xmath42 is layered with width @xmath53 , then @xmath86 is layered , too , and has width at most @xmath89 .",
    "the idea of the construction is to subdivide every edge of @xmath42 .",
    "so let @xmath42 be an sbp with vertex set @xmath90 and edge set @xmath91 .",
    "let @xmath92 and @xmath93 be the stack symbol labeling and the weight function , respectively .",
    "@xmath86 will have the vertex set @xmath94 , stack symbol labeling @xmath95 and weight function @xmath96 .",
    "the construction goes as follows : for each edge @xmath97 the sbp @xmath86 has the edges @xmath98 .",
    "we set @xmath99 and @xmath100 . if @xmath82 is a @xmath62-edge we set @xmath101 and @xmath102 for an arbitrary stack symbol @xmath43 . otherwise , both @xmath103 and @xmath104 get the stack operation @xmath105 .",
    "it is easy to verify that @xmath86 has all desired properties .      in this section",
    "we show that stack branching programs of polynomial size characterize  @xmath5 .",
    "[ thm : charvp ] @xmath106 , iff @xmath15 is computed by a family of polynomial size  sbps .    we the two direction of theorem [ thm : charvp ] independently .    if @xmath15 is computed by a family of polynomial size sbps , then @xmath19 .",
    "let @xmath107 be a family of sbps computing @xmath108 , of size at most @xmath109 for a polynomial  @xmath16 .",
    "observe that @xmath110 , so we only have to show that we can compute the @xmath111 by polynomial size circuits @xmath112 .",
    "let @xmath113 be an sbp with @xmath114 vertices , source @xmath43 and sink @xmath44 .",
    "the construction of @xmath115 uses the following basic observation : every stack - realizable path @xmath50 of length @xmath116 between two vertices @xmath14 and @xmath48 can be uniquely decomposed in the following way .",
    "there are vertices @xmath117 and a symbol @xmath59 such that there are edges @xmath118 and @xmath119 with @xmath120 and @xmath121 .",
    "furthermore there are stack - realizable paths @xmath122 from @xmath123 to @xmath124 and @xmath125 from @xmath126 to @xmath48 such that @xmath127 and @xmath128 .",
    "the paths @xmath122 and @xmath125 may be empty .",
    "we define @xmath129 where the sum is over all stack - realizable @xmath43-@xmath44-paths of length @xmath116 .",
    "the values @xmath130 can be computed efficiently with a straightforward dynamic programming approach .",
    "first observe that @xmath131 for odd @xmath116 .",
    "for @xmath132 we set @xmath133 for @xmath134 and @xmath135 .",
    "for even @xmath136 we get @xmath137 where the sum is over all @xmath59 , all @xmath138 and all @xmath139 such that @xmath120 and @xmath121 . with this recursion formula",
    "we can compute alnote that kintali proved a similar result for the turing machine setting .",
    "l @xmath140 with a polynomial number of arithmetic operations .",
    "having computed all @xmath140 we get @xmath141 } w(s , t , i)$ ] .",
    "the more involved direction of the proof of theorem [ thm : charvp ] will be the second direction . to prove it it will be convenient to slightly relax our model of computation .",
    "a _ relaxed sbp _",
    "@xmath42 is an sbp where the underlying directed graph is not necessarily acyclic . to make use of cyclicity we do not consider paths in a relaxed sbp @xmath42 but _ walks _ , i.e.  vertices and edges of @xmath42 may be visited several times .",
    "_ realizable walks _ are defined completely analogously to realizable paths .",
    "also the weight @xmath142 of a walk is defined in the obvious way .",
    "clearly , we can not define the polynomial computed by a relaxed abp by summing over the weight of all realizable walks , because there may be infinitely many of them and they may be arbitrarily long .",
    "hence , we define for each pair @xmath143 of vertices and for each integer @xmath114 the polynomial @xmath144 where the sum is over all stack - realizable @xmath48-@xmath14-walks @xmath50 in @xmath42 that have length @xmath114 .",
    "furthermore , we say that for each @xmath114 the relaxed sbp @xmath42 computes the polynomial @xmath145 .",
    "the connection to sbps is given by the following straight - forward lemma .",
    "[ lem : relaxed ] let @xmath42 be a relaxed sbp and @xmath146 . then for each @xmath114 there is an sbp @xmath147 of size @xmath148 that computes @xmath149 .",
    "the idea is to unwind the computation of the relaxed sbp into @xmath114 layers .",
    "let @xmath150 , then for each @xmath151 the sbp @xmath86 has @xmath114 copies @xmath152 . for each @xmath153",
    "the sbp @xmath86 had the edges @xmath154 for @xmath155 $ ] with weight @xmath156 and stack operation @xmath157 .",
    "this completes the construction of @xmath86 .",
    "clearly , @xmath86 indeed computes @xmath149 and has size @xmath148 .    to prove the characterization of @xmath1 we show the following rather technical proposition :    [ prop : technical ]",
    "let @xmath158 be a multiplicatively disjoint arithmetic circuit .",
    "for each @xmath151 we denote by @xmath159 the subcircuit of @xmath158 with output @xmath14 and we denote by @xmath160 the polynomial computed by @xmath159 . then there is a relaxed sbp @xmath161 of size at most @xmath162 such that for each @xmath151 there is a pair @xmath163 and an integer @xmath164 with    * @xmath165 , and * there is no stack - realizable walk from @xmath166 to @xmath167 in @xmath42 that is shorter than @xmath168 .",
    "we construct @xmath42 iteratively along a topological order of @xmath158 by adding new vertices and edges , starting from the empty relaxed sbp .",
    "let first @xmath14 be an input of @xmath158 with label @xmath24 .",
    "we add two new vertices @xmath169 to @xmath42 and the edge @xmath170 with weigth @xmath171 and stack - operation @xmath172 .",
    "furthermore , @xmath173 . clearly , none of the polynomials computed before change and the size of the relaxed sbp grows only by @xmath10 .",
    "thus all statements of the proposition of fulfilled .",
    "let now @xmath14 be an addition gate with children @xmath143 .",
    "by induction @xmath42 contains vertices @xmath174 and there are @xmath175 such that @xmath176 and @xmath177 .",
    "assume w.l.o.g .",
    "we add two new vertices @xmath169 to @xmath42 .",
    "furthermore , we add a directed path of length @xmath179 with start vertex @xmath180 and end vertex @xmath181 to @xmath42 . we add the edges @xmath182 , @xmath183 , @xmath184 , @xmath185 and @xmath186 .",
    "all edges we add get weight @xmath187 . furthermore , we set @xmath188 , @xmath189 , @xmath190 and @xmath191 for new stack symbols @xmath192 and @xmath193 .",
    "all other edges we added are @xmath62-edges .",
    "finally , set @xmath194 .",
    "let us first check that @xmath42 computes the correct polynomials .",
    "first observe that the edges we added do not allow any new walks between old vertices , so we still compute all old polynomials by induction .",
    "thus we only have to consider the realizable @xmath166-@xmath167-walks of length  @xmath168 .",
    "each of these either starts with the edge @xmath182 or the edge @xmath183 . in the first case , because of the stack symbols the walk must end with the edge @xmath185 .",
    "thus the realizable @xmath170-walks of length @xmath168 that start with @xmath182 contribute exactly the same weight as the realizable @xmath195-@xmath196-walks of length @xmath197 which is exactly @xmath198 by induction",
    ". moreover , every @xmath170-walks of length @xmath168 that start with @xmath183 first makes @xmath179 unweighted steps to @xmath199 and ends with the edge @xmath186 .",
    "thus , these walks contribute exactly the same as the stackrealizable @xmath199-@xmath200 walks of length @xmath201 , so they contribute @xmath202 . combining all walks we get @xmath203 as desired .",
    "we have @xmath204 where the first inequality is by induction and the second inequality follows from the fact that @xmath14 is not contained in @xmath205 and thus @xmath206 . to see the bound on @xmath207 let @xmath43 be the size of @xmath42 before adding the new edges and vertices . by induction @xmath208 .",
    "we have added @xmath209 vertices and thus @xmath42 has now size @xmath210 .",
    "but we have @xmath211 and thus the number of vertices in @xmath42 is at most @xmath212 .",
    "this completes the case that @xmath14 is an addition gate .",
    "let now @xmath14 be a multiplication gate with children @xmath143 .",
    "as before , @xmath42 already contains @xmath174 and there are @xmath175 with the desired properties .",
    "we add three vertices @xmath166 , @xmath167 and @xmath213 and the edges @xmath182 , @xmath214 , @xmath215 and @xmath186 all with weight  @xmath187 .",
    "the new edges have the stack symbols @xmath188 , @xmath216 , @xmath217 and @xmath191 for new stack symbols @xmath192 and @xmath193 . finally , set @xmath218 .",
    "clearly , no stack - realizable walk between any pair of old vertices can traverse @xmath166 , @xmath167 or @xmath213 and thus these walks still compute the same polynomials as before .",
    "thus we only have to analyse the @xmath166-@xmath167-walks of length @xmath168 in @xmath42 .",
    "let @xmath50 be such a walk .",
    "because of the stack symbols @xmath192 and @xmath193 the walk @xmath50 must have the structure @xmath219 where @xmath220 and @xmath221 are a stack - realizable @xmath195-@xmath196-walk and a stack - realizable @xmath199-@xmath200-walk , respectively .",
    "the walk @xmath50 is of length @xmath168 and thus @xmath220 and @xmath221 must have the combined length @xmath222 .",
    "but by induction @xmath220 must at least have length @xmath197 and @xmath221 must have at least length @xmath223 , so it follows that @xmath220 has length exactly @xmath197 and @xmath221 has length exactly @xmath223 .",
    "the walks @xmath220 and @xmath221 are independent and thus we have @xmath224 as desired .",
    "the circuit @xmath158 is multiplicatively disjoint and thus we have @xmath225 .",
    "it follows that @xmath226 where we get the inequality by induction .",
    "the relaxed sbp grows only by @xmath227 vertices which gives the bound on the size of @xmath42 .",
    "this completes the proof for the case that @xmath14 is an addition gate and hence the proof of the lemma .",
    "now the second direction of theorem [ thm : charvp ] is straight - forward .",
    "[ lem : charvpseconddirection ] every family @xmath19 can be computed by a family of sbps of polynomial size .    given a family @xmath228 of multiplicatively disjoint arithmetic circuits of polynomial size , first turn them into relaxed sbps of polynomial size and polynomial @xmath114 with proposition [ prop : technical ] and then turn those relaxed sbps into sbps with lemma [ lem : relaxed ] .",
    "it is easy to check that the resulting sbps have polynomial size .",
    "it is easy to see , that the number of symbols used in sbps can be lowered to @xmath10 without loss of computational power and with only logarithmic overhead in the size ( see also section [ sct : widthreductionsbp ] .",
    "therefore the only meaningful restriction of the size of the symbol set is the restriction to a set only consisting of one single symbol .",
    "the following fairly straightforward lemma shows that doing so indeed decreases the computational power .",
    "note that kintali proved a similar result for the turing machine setting .",
    "@xmath52 if and only if it can be computed by polynomial size sbps with one stack symbol .",
    "the direction from left to right is easy : simply interpret each edge @xmath82 of an abp @xmath42 as a @xmath62-edge .",
    "for the other direction the key insight is that if one has only one stack symbol one only has to keep track of the size of the stack at any point in the path .",
    "but this height can be encoded by vertices of an abp .",
    "so let @xmath42 be a sbp of size @xmath114 .",
    "it is clear that the stack can not be higher than @xmath114 on any path through @xmath42 .",
    "we construct an abp @xmath86 that has for every vertex @xmath14 in @xmath42 the @xmath229 vertices @xmath230 .",
    "if @xmath192 is a @xmath84-edge in @xmath42 , we connect @xmath213 to @xmath231 for @xmath232 in @xmath86 .",
    "if @xmath192 is a @xmath85-edge in @xmath42 , we add @xmath233 for @xmath234 to @xmath86 .",
    "all these edges get the same weight as @xmath192 in the @xmath42 .",
    "it is easy to see that every stack - realizable path @xmath50 in the sbp @xmath42 corresponds directly to a path @xmath235 in the abp @xmath86 and @xmath50 and @xmath235 have the same weight .",
    "thus @xmath42 and @xmath86 compute the same polynomial .",
    "moreover , @xmath236 which completes the proof .      in this section we show that unlike for ordinary abps bounding the width of sbps does not decrease the computational power : polynomial size sbps with at least 2 stack symbols and width @xmath10 can still compute every family in  @xmath5 .",
    "every family @xmath19 can be computed by a sbp of width @xmath10 with the stack symbol set @xmath237 .",
    "the idea of the proof is to start from the characterization of @xmath1 by sbps from theorem [ thm : charvp ] .",
    "we use the stack to remember which edge will be used next on a realizable path through the branching program .",
    "we will show how this can be done with width @xmath10 sbps with a bigger stack symbol size . in a second step",
    "we will seee how to reduce the stack symbol set to @xmath237 .",
    "so let @xmath107 be a family of sbps .",
    "fix @xmath18 and let @xmath238 with vertex set @xmath90 and edge set @xmath91 .",
    "furthermore , let @xmath93 be the weight function , @xmath92 the stack operation labeling and @xmath58 the stack symbol of @xmath42 .",
    "let @xmath43 and @xmath44 be the source and the sink of the sbp @xmath42 .",
    "we assume without loss of generality that @xmath43 has one single outgoing edge @xmath239 .",
    "furthermore @xmath44 is only entered by one @xmath62-edge @xmath240 with weight @xmath187 .",
    "we will construct a new sbp @xmath86 with weight function @xmath96 and stack operation labeling @xmath95 .",
    "@xmath86 will have stack symbol set @xmath241 .",
    "for each edge @xmath82 with a successor edge @xmath242 the sbp@xmath86 contains a gadget @xmath243 .",
    "the vertex set of @xmath243 is @xmath244 .",
    "these vertices are connected to a dag by the edges @xmath245 .",
    "all these edges have weight  @xmath187 except for @xmath246 for which we set @xmath247 .",
    "we call @xmath246 the _ weighted edge _ of @xmath243",
    ". furthermore we set @xmath248 , @xmath249 , @xmath250 .",
    "all other edges are @xmath62-edges .",
    "the construction of @xmath243 is illustrated in figure [ fig : gadget ] .",
    "@of#1#2 @anchorcenter @do@auto@anchor= @addtransform @extract@node@dist@node@distance and@stop @node@at @extract@node@dist#1and#2@stop @extracted@node@distance#1    \\(a ) @xmath251 ; ( d ) [ right of = a ] @xmath252 ; ( b ) [ above of = d ] @xmath253 ; ( c ) [ right of = b ] @xmath254 ; ( e ) [ right of = d ] @xmath255 ; ( f ) [ right of = e ] @xmath256 ;    \\(a ) edge node @xmath257 ( b ) edge node ( d ) ( b ) edge node @xmath258 ( c ) ( c ) edge node @xmath259 ( f ) ( d ) edge node ( e ) ( e ) edge node ( f ) ;    now choose an order @xmath260 of @xmath91 such that for each pair @xmath261 , the edge @xmath78 comes before @xmath193 .",
    "this order can be iteratively constructed from a topological order  @xmath262 of  @xmath90 : for each vertex @xmath14 along @xmath262 iteratively add the edges entering @xmath14 to @xmath260 as the new maximum . from @xmath260",
    "we construct an order @xmath263 of the gadgets @xmath243 by defining @xmath264    we now connect the gadgets along the order @xmath263 in the following way : let @xmath265 and @xmath266 be two successors in @xmath263 .",
    "we connect @xmath267 to @xmath268 by a @xmath62-edge of weight  @xmath187 .",
    "let @xmath243 be the minimum of @xmath263 .",
    "we add a new vertex @xmath43 and the edge @xmath269 with weigth @xmath187 and stack opeation @xmath270 where @xmath239 is the single outgoing edge of @xmath43 in @xmath42 .",
    "let now @xmath243 be the maximum gadget in @xmath263 .",
    "we add a new vertex @xmath44 and the edge @xmath271 with weight @xmath187 and stack operation @xmath272 .",
    "this concludes the construction of @xmath86 .",
    "it is easy to see that @xmath86 has indeed width @xmath10 .",
    "thus we only need to show that @xmath42 and @xmath86 compute the same polynomial .",
    "this will follow directly from the following claim :    there is a bijection @xmath273 between the stack - realizable paths in @xmath42 and @xmath86 .",
    "furthermore @xmath274 for each stack - realizable path in @xmath42 .",
    "clearly every @xmath43-@xmath44-path must traverse all gadgets in @xmath86 .",
    "furthermore , whenever a gadget is entered , the stack contains only one symbol from @xmath91 which lies at the top of the stack . through each gadget",
    "@xmath243 there are exactly the two paths @xmath275 and @xmath276 .",
    "we call the former the _ weighted path _ through @xmath243 . for a stack - realizable @xmath43-@xmath44-path @xmath277 through @xmath42",
    "we define @xmath278 to be the unique path through @xmath86 that takes the weighted path through exactly the gadgets @xmath279 for @xmath280 .",
    "we have @xmath274 with this definition , because only the weighted edges in the gadgets have a weight different from @xmath187 in @xmath86 .",
    "so it suffices to show that @xmath273 is indeed a bijection .",
    "we first show that @xmath273 maps stack - realizable paths in @xmath42 to stack - realizable paths in @xmath86 .",
    "so let  @xmath50 be as before .",
    "observe that  @xmath278 traverses the gadgets @xmath279 in the same order as  @xmath50 traverses the edges  @xmath281 .",
    "furthermore , whenever @xmath278 enters a gadget @xmath279 the top stack symbol is @xmath281 and the rest of the stack content is exactly that on  @xmath50 before traversing  @xmath281 . when leaving @xmath279 the stack content is that after traversing  @xmath281 on  @xmath50 with an additional symbol  @xmath282 on the top .",
    "thus all stack operations along  @xmath278 must be legal and the stack is empty after traversing the last edge towards  @xmath44 .",
    "thus  @xmath278 is indeed stack - realizable .",
    "clearly , @xmath273 is injective , so to complete the proof of the claim we only need to show that it is surjective .",
    "so let @xmath235 be a stack - realizable @xmath43-@xmath44-path in @xmath86 .",
    "let @xmath283 be the gadgets in which @xmath235 takes the weighted path in the order in which they are visited .",
    "we claim that @xmath284 is a stack - realizable @xmath43-@xmath44-path . clearly , @xmath43 is the first vertex of @xmath50 .",
    "also in @xmath235 the symbol @xmath240 is popped in the last step by construction of @xmath86 , so the last gadget in which @xmath235 took a weighted path must be one of the form @xmath285 , because otherwise @xmath240 can not be the top symbol on the stack before the last step . thus @xmath44 is the last vertex of @xmath50 .    to see that @xmath50 is a path , observe that we have @xmath286 .",
    "otherwise @xmath50 can not have the right top symbol when taking the weighted path in @xmath287 .",
    "thus @xmath282 must be a successor of @xmath281 in @xmath42 and @xmath50 is an @xmath43-@xmath44-path .    to see that @xmath50 is stack - realizable observe that when @xmath235 traverses the weighted edge of a gadget @xmath288 it has the same stack content as when @xmath50 traverses @xmath281 in @xmath42 .",
    "so @xmath50 is obviously stack - realizable because @xmath235 is .",
    "observing that obviously @xmath289 by construction completes the proof .    in a final step",
    "we now reduce the stack symbol size to @xmath237 in a straightforward way .",
    "let @xmath290 , then each stack symbol @xmath43 can be encoded into a @xmath237-string @xmath291 of length  @xmath292 .",
    "now we substitute each edge @xmath82 of @xmath86 by a path @xmath293 of length  @xmath292 . if @xmath294 we the edges along @xmath293 are @xmath84-edges , too , that push @xmath295 onto the stack . if @xmath296 we pop @xmath291 in reverse order along @xmath293 .",
    "if @xmath82 is a @xmath62-edge , all edges of @xmath293 are @xmath62-edges , too .",
    "finally , we give one of the edges in @xmath293 the weight @xmath297 , while all other edges get weight @xmath187 . doing this for all edges ,",
    "it is easy to see that the resulting sbp computes the same polynomial as @xmath86 .",
    "furthermore , its width is @xmath10 .      in this section",
    "we show that the characerization of @xmath5by sbps allows us to directly use results from counting complexity that rely on nauxpdas .",
    "we demonstrate this by adapting a proof by niedermeier and rossmanith @xcite to reprove the classical parallelization theorem for @xmath5originally proved by valiant et al . @xcite .",
    "while neither the result nor the proof technique is new in itself , we argue that the use of applying the techniques using sbps results in a proof that is arguably more transparent than any other proof of this classical theorem that we know .",
    "this raises our hopes that the sbp characterization of @xmath5 may be helpful in the future .",
    "we now start presenting the ideas of niedermeier and rossmanith in detail .",
    "the basic idea is the following : the realizable paths are recursively cut into subpaths and the polynomials are then computed by combining the polynomials of the subpaths . in order to reach logarithmic depth we have to make sure that the paths are cut in paths of approximately equal length to result in a balanced computation .",
    "this is complicated by that fact that the paths have to be realizable , so we have to account for the content of the stack during the computation .",
    "we now give the details of the construction .",
    "let @xmath42 be an sbp and let @xmath50 be a realizable path in @xmath42 from @xmath123 to @xmath124 .",
    "let @xmath126 be a vertex on @xmath50 , then the stack height of @xmath50 in @xmath126 is the number of @xmath84-edges minus the number of @xmath85-edges on @xmath50 from @xmath123 up to @xmath126 .",
    "similarly to niedermeier and rossmanith we give to a path @xmath50 a description @xmath298 , where @xmath123 is the start vertex , @xmath124 the end vertex and @xmath116 the length of @xmath50 .",
    "we define a relation @xmath299 on paths in order to decompose them .",
    "let @xmath50 be a path with realizable subpaths @xmath220 and @xmath221 and let these three paths have the descriptions @xmath298 , @xmath300 and @xmath301 .",
    "then we write @xmath302 iff    * the stack height of @xmath50 on @xmath82 is @xmath9 * there is an @xmath59 such that @xmath303 and @xmath304 and * @xmath305 .",
    "we state a lemma by niedermeier and rossmanith :    [ lem : dec1 ] let @xmath50 be a path with description @xmath298 and @xmath306 . then there",
    "exist uniquely described subpaths @xmath220 , @xmath221 and @xmath307 with descriptions @xmath308 , @xmath309 and @xmath310 with @xmath311 such that @xmath312 .",
    "lemma [ lem : dec1 ] allows us to cut a path @xmath50 into three parts @xmath221 , @xmath307 and @xmath313 .",
    "none of these parts is too big , but we can not iterate this procedure , because unfortunately @xmath313 is not a path because it has a `` gap '' from @xmath126 to @xmath314 . to remedy the situation niedermeier and rossmanith",
    "formalize this notion of a path with gap in the following way : a _ path with gap _ with description @xmath315 consists of two paths , one from @xmath123 to @xmath126 and one from @xmath314 to @xmath124 , where @xmath116 and @xmath316 with @xmath317 are even natural numbers .",
    "@xmath50 is realizable , if identifying @xmath126 and @xmath314 results in a realizable path of length @xmath318 .",
    "observe that @xmath50 with description @xmath319 is realizable if and only if @xmath320 and @xmath321 , i.e. the path consists only of a gap .",
    "we now extend the relation @xmath299 to paths with gaps .",
    "this is complicated a little by the fact that the gap can lie in either of the two subpaths that we want to split a path with gap into .",
    "so let @xmath50 be a path with gap and description @xmath322 .",
    "for the first case let @xmath220 be a subpath with gap and description @xmath323 and @xmath221 be a subpath with description @xmath324 . for the second case let @xmath220 be a subpath with description @xmath325 and",
    "@xmath221 a subpath with gap and description @xmath326",
    ". then we write @xmath302 if and only if the stack height @xmath28 is @xmath9 , there is an @xmath59 such that @xmath303 and @xmath304 and @xmath327 .",
    "observe that if @xmath328 and @xmath329 this definition coincides with the definition on paths without gap .",
    "niedermeier and rossmanith give a version of lemma [ lem : dec1 ] for paths with gap .",
    "[ lem : dec2 ] let @xmath322 with @xmath330 be a realizable path with gap . then there exist uniquely determined paths @xmath220 , @xmath221 and @xmath307 such that @xmath220 has the description @xmath331 , @xmath312 and either    1 .",
    "@xmath221 has the description @xmath332 and @xmath307 has the description @xmath333 such that @xmath334 or 2 .",
    "@xmath221 has the description @xmath335 and @xmath307 has the description @xmath336 such that @xmath337 .",
    "let @xmath50 be a realizable path with gap with description @xmath338 .",
    "then we define its weight @xmath339 where @xmath235 is the realizable path we get from @xmath50 when we identify @xmath126 and @xmath314 .",
    "let @xmath340 where the sum is over all realizable paths with description @xmath298 .",
    "furthermore , @xmath341 where the sum is over all realizable paths with gap with description @xmath342 . with these definitions and the lemmas [ lem : dec1 ] and [ lem : dec2 ] we get the following lemma :    [ lem : parallel ]    1 .",
    "@xmath343 where the sum is over all @xmath344 such that there is an @xmath43 with @xmath345 and @xmath346 and all even numbers @xmath347 with @xmath348 and @xmath349 .",
    "2 .   @xmath350 + where both sums are over all @xmath351 such that there is an @xmath43 with @xmath352 and @xmath346 .",
    "the first sum is also over all even numbers @xmath353 with @xmath354 and @xmath355 , while the second sum is over all even numbers @xmath353 with @xmath356 and @xmath355 .",
    "( sketch ) for a ) oberve that the decomposition of lemma [ lem : dec1 ] is unique .",
    "so we sum the weight of every path from @xmath123 to @xmath124 of length @xmath116 exactly once . for b ) use lemma [ lem : dec2 ] for the same argument .",
    "the following lemma is now easy to see :    let @xmath42 be an sbp .",
    "then @xmath357 can be computed by a semi - unbounded circuit of depth @xmath358 and size @xmath359 .",
    "combined with theorem [ thm : charvp ] we get the parallelization lemma by valiant et al . @xcite .",
    "let @xmath19 .",
    "then @xmath15 can be computed by a family of semi - unbounded circuits of polynomial size and logarithmic depth in @xmath18 .",
    "we change the model of computation by allowing random access memory instead of a stack .",
    "we still work over a symbol set @xmath58 like for sbps but we introduce three _ random access memory operations _ : the operation @xmath360 and @xmath361 take an argument @xmath59 while the operation @xmath62 again takes no argument .",
    "let @xmath362 be a random access memory operation with @xmath363 and @xmath364 a sequence of memory operations .",
    "with @xmath365 we denote the number of occurences of @xmath362 in @xmath50 .",
    "we call a sequence @xmath50 realizable if for all symbols @xmath59 we have that @xmath366 and for all prefixes @xmath235 of @xmath50 we have @xmath367 for all @xmath59 .",
    "intuitively the random access memory operations do the following : @xmath368 writes the symbol @xmath43 into the random access memory . if @xmath43 is already there it adds it another time . @xmath369 deletes one occurence of the symbol @xmath43 from the memory if there is one .",
    "otherwise an error occurs .",
    "@xmath62 is the `` no operation '' operation again like for sbps .",
    "a sequence of operations is realizable if no error occurs during the deletions and starting from empty memory the memory is empty again after the sequence of operations .    a _ random access branching program _ ( rabp )",
    "@xmath42 is an abp with an additional edge labeling @xmath370 .",
    "a path @xmath74 in @xmath42 has the sequence of random access memory operations @xmath75 .",
    "if @xmath76 is realizable we call @xmath50 a _ random - access - realizable path_. the rabp @xmath42 computes the polynomial @xmath77 where the sum is over all random - access - realizable @xmath43-@xmath44-paths @xmath50 .    in a completely analogous way to proposition [ prop : nonopsbp ] we can proof that disallowing @xmath62-edges does not change the computational power of rabps .",
    "let @xmath42 be an rabp of size @xmath43 .",
    "there is an sbp @xmath86 of size @xmath87 such that @xmath88 and @xmath86 does not contain any @xmath62-edges . if @xmath42 is layered with width @xmath53 , then @xmath86 is layered , too , and has width at most @xmath89 .",
    "intuitively random access on the memory allows us more fine - grained control over the paths in the branching program that contribute to the computation . while in sbps",
    "nearly all of the memory content is hidden , in rabps we have access to the complete memory at all times .",
    "this makes rabps more expressive than sbps which is formalized in the following theorem .",
    "[ thm : rabp ] @xmath371 if and only if there is a family of polynomial size rabps computing @xmath15 .",
    "again we prove the theorem in two independent lemmas , starting with the upper bound which is very easy .",
    "[ lem : containvnp ] if @xmath15 is computed by a family of polynomial size rabps , then @xmath371 .",
    "this is easy to see with valiant s criterion ( lemma [ lem : criterion ] ) and the fact that checking if a path through a rabp is realizable is certainly in @xmath372 .",
    "we will now show the lower bound of theorem [ thm : rabp ] .",
    "we will prove it directly for bounded width rabps .",
    "to do so we consider the following dominating - set polynomial for a graph @xmath373 :    @xmath374 where the sum is over all dominating sets @xmath375 in @xmath42 .    in appendix",
    "[ app : dshard ] we show that the is a family @xmath107 of graphs such that the resulting family @xmath376 of polynomials is @xmath2-complete .    for each family @xmath377",
    "there is a family of width @xmath10 rabps of polynomial size computing @xmath15 .",
    "we will show that for a graph @xmath378 with @xmath18 vertices there is a rabp of size @xmath379 and width @xmath10 that computes @xmath380 .",
    "the rabp works in two stages .",
    "the symbol set of the rabp will be @xmath90 . in a first stage it iteratively selects vertices @xmath14 and writes @xmath14 and all of its neightbors into the memory . in a second stage",
    "it checks that each vertex @xmath14 was written at least once into the memory , i.e. , either @xmath14 or one of its neighbors was chosen in the first phase .",
    "thus the set of chosen vertices must have been a dominating set .",
    "so fix a graph @xmath42 . for each vertex @xmath14 with neighbors",
    "@xmath381 we construct a gadget @xmath382 as shown in figure [ fig : chooseds ] .",
    "we call the path through @xmath382 with the edges that have memory operations the _ choosing path_. now for each vertex @xmath14 we construct a second gadget @xmath383 that is shown in figure [ fig : checkds ]",
    ". choose an order on the vertices .",
    "for each non - maximal vertex @xmath14 in the order with successor @xmath48 , we connect the sink of @xmath382 to the source of @xmath384 and the sink of @xmath385 to the source of @xmath386 with a @xmath62-edge of weight @xmath187 .",
    "finally , let @xmath387 be the maximal vertex in the order and @xmath388 the minimal vertex .",
    "connect the sink of @xmath389 to the source of @xmath390 again by a @xmath62-edge of weight @xmath187 .",
    "= [ minimum size=13 mm ]    \\(a ) @xmath391 ; ( d ) [ right of = a ] @xmath392 ; ( b ) [ above of = d ] @xmath393 ; ( c ) [ right of = b ] @xmath394 ; ( e ) [ right of = d ] @xmath395 ; ( h ) [ right of = c ] @xmath396 ; ( j ) [ right of = e ] @xmath397 ; ( f ) [ right of = h ] @xmath398 ;    \\(a ) edge node @xmath399 ( b ) edge node ( d ) ( b ) edge node @xmath400 ( c ) ( d ) edge node ( e ) ( h ) edge node @xmath401 ( f ) ( j ) edge node ( f ) ;    \\(e ) edge node ( j ) ( c ) edge node ( h ) ;    = [ minimum size=13 mm ]    \\(x ) @xmath402 ; ( a ) [ right of = x ] @xmath403 ; ( d ) [ right of = a ] @xmath395 ; ( b ) [ above of = d ] @xmath394 ; ( c ) [ right of = b ] @xmath404 ; ( e ) [ right of = d ] @xmath405 ; ( h ) [ right of = c ] @xmath406 ; ( j ) [ right of = e ] @xmath407 ; ( f ) [ right of = h ] @xmath408 ;    \\(x ) edge node @xmath409 ( a ) ( a ) edge node ( b ) edge node @xmath409 ( d ) ( b ) edge node ( c ) ( d ) edge node @xmath409 ( e ) edge node ( c ) ( h ) edge node ( f ) ( j ) edge node ( f ) ;    \\(e ) edge node ( j ) ( c ) edge node ( h ) ( e ) edge node ( h ) ;    we claim that @xmath86 computes @xmath410 . to see this ,",
    "define the weight of a vertex set @xmath375 in @xmath42 to be @xmath411 .",
    "the following claim completes the proof .",
    "there is a bijection @xmath273 between dominating sets in @xmath42 and ra - realizing paths in @xmath86 such that for each dominating set @xmath375 in @xmath42 we have @xmath412 .",
    "observe that for ra - realizing paths through @xmath86 once the path through the gadgets @xmath382 is chosen , then rest of the path is fixed .",
    "so each ra - realizing path @xmath50 can be described completely by the @xmath14 for which the choosing paths through @xmath382 is taken .",
    "let @xmath375 be a dominating set .",
    "let @xmath413 be the set of @xmath43-@xmath44-paths in @xmath86 that for each @xmath414 take the choosing path through @xmath382 and for each @xmath86 take the other path .",
    "because @xmath375 is dominating , after a path @xmath415 has passed through the gadgets @xmath382 , it contains each symbol @xmath151 at least once .",
    "thus there is a unique path in @xmath413 that is ra - realizing .",
    "call this path @xmath416 .    obviously , @xmath273 is injective . to show that it is surjective , too , consider an ra - realizable path @xmath50 in @xmath86 .",
    "let @xmath375 be the set of @xmath417 for which @xmath50 takes the choosing path .",
    "the path @xmath50 passes every gadget @xmath385 , so each element @xmath151 gets deleted from the memory at least once .",
    "it follows that each @xmath151 must have been written to memory at least once before .",
    "so for @xmath151 the path @xmath50 must go through @xmath382 or through @xmath384 for a neighbor @xmath48 of @xmath14 .",
    "it follows that @xmath375 is a dominating set .",
    "furthermore , @xmath418 , so @xmath273 is surjective .",
    "finally , @xmath412 is true , because the only weighted edges in @xmath86 are in the gadgets @xmath382 and for each @xmath14 the weighted edge in @xmath382 has the weight @xmath419 .    observing that @xmath86 has width @xmath10 , completes the proof .",
    "[ [ acknowledgements ] ] acknowledgements : + + + + + + + + + + + + + + + + +    the author would like to thank sbastien tavenas for pointing out an error in an earlier proof of lemma [ lem : charvpseconddirection ] .",
    "the corrected proof presented in this paper is the result of discussions with him and pascal koiran .",
    "the author is very thankful for this contribution .",
    "furthermore , the author is grateful to guillaume malod who gave very helpful feedback on a draft of this paper .",
    "finally , the author would like to thank peter brgisser and meena mahajan for encouraging him to write up these results as a paper .",
    "10    d.a .",
    "barrington . .",
    ", 38(1):150164 , 1989 .",
    "michael ben - or and richard cleve .",
    "computing algebraic formulas using a constant number of registers .",
    ", 21(1):5458 , 1992 .",
    "in r  p  brent r  s  andersson , editor , _ the complexity of computational problem solving _ , pages 126165 . univ .",
    "of queensland press , 1976 .",
    "i.  briquel and p.  koiran . a dichotomy theorem for polynomial evaluation . ,",
    "pages 187198 , 2009 .",
    "peter brgisser . .",
    "springer verlag , 2000 .",
    "shiva kintali .",
    "realizable paths and the nl vs l problem .",
    ", 17:158 , 2010 .",
    "pascal koiran .",
    "arithmetic circuits : the chasm at depth four gets wider .",
    ", 448:5665 , 2012 .    guillaume malod and natacha portier .",
    "characterizing valiant s algebraic complexity classes .",
    ", 24(1):1638 , 2008 .",
    "r.  niedermeier and p.  rossmanith . .",
    ", 118(2):227245 , 1995 .",
    "n.  nisan . .",
    "in _ proceedings of the twenty - third annual acm symposium on theory of computing _",
    ", page 418 .",
    "acm , 1991 .",
    "sven skyum and leslie  g. valiant . a complexity theory based on boolean algebra .",
    ", 32(2):484502 , 1985 .",
    "leslie  g. valiant , sven skyum , s.  berkowitz , and charles rackoff .",
    "fast parallel computation of polynomials using few processors .",
    ", 12(4):641644 , 1983 .",
    "completeness classes in algebra . in",
    "_ proceedings of the eleventh annual acm symposium on theory of computing _ , pages 249261 .",
    "acm , 1979 .",
    "volker weber and thomas schwentick .",
    "dynamic complexity theory revisited . , 40(4):355377 , 2007 .",
    "in this appendix we show that there is a family of graphs such that the the polynomial family @xmath420 is @xmath2-complete . with valiant s criterion ( lemma [ lem : criterion ] ) containment in @xmath2",
    "is clear .    for hardness we will reduce from the polynomial @xmath421 where the sum is over all vertex covers @xmath58 of @xmath42 .",
    "this polynomial was introduced by briquel and koiran @xcite who showed the following hardness result :      with lemma [ lem : vchard ] it suffices to show that for every graph @xmath42 there is a graph @xmath86 of size polynomial in the size of @xmath42 such that @xmath423 so let @xmath378 be a graph .",
    "we construct @xmath86 by adding for each @xmath424 a vertex @xmath425 and the edges @xmath103 and @xmath426 .",
    "every dominating set @xmath375 of @xmath86 must contain @xmath425 or one of @xmath427 .",
    "thus @xmath375 is either a vertex cover of @xmath42 or it contains a vertex @xmath425 for an @xmath428 . setting @xmath429 one",
    "gets @xmath430 as the projection of @xmath431 .",
    "this finishes the proof ."
  ],
  "abstract_text": [
    "<S> we extend the well known characterization of @xmath0 as the class of polynomials computed by polynomial size arithmetic branching programs to other complexity classes . in order to do </S>",
    "<S> so we add additional memory to the computation of branching programs to make them more expressive . </S>",
    "<S> we show that allowing different types of memory in branching programs increases the computational power even for constant width programs . </S>",
    "<S> in particular , this leads to very natural and robust characterizations of @xmath1 and @xmath2 by branching programs with memory . </S>"
  ]
}