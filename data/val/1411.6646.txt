{
  "article_text": [
    "the study of automata over data words , i.e. , words over an infinite alphabet , has its origins in the seminal work by kaminski and francez @xcite .",
    "their finite - memory automata ( more commonly called _",
    "register automata _ ) equip finite - state machines with registers in which data values ( from the infinite alphabet ) can be stored and be reused later .",
    "register automata preserve some of the good properties of finite automata : they have a decidable emptiness problem and are closed under union and intersection . on the other hand , register automata are neither determinizable nor closed under complementation , and they have an undecidable equivalence / inclusion problem .",
    "there are actually several variants of register automata , which all have the same expressive power but differ in the complexity of decision problems @xcite . in the sequel ,",
    "many more automata models have been introduced ( not necessarily with registers ) , aiming at a good balance between expressivity , decidability , and closure properties @xcite .",
    "some of those models extend register automata , inheriting their drawbacks such as undecidability of the equivalence problem .",
    "we will follow the work on register automata and study a model that supports the notion of _ freshness_. when reading a data value , it may enforce that the data value is _ fresh _ ,",
    "i.e. , it has not occurred in the whole history of the run .",
    "this feature has been proposed in @xcite to model computation with names in the context of programming - language semantics . actually , fresh names are needed to model object creation in object - oriented languages , and they are important ingredients in modeling security protocols which often make use of so - called fresh nonces to achieve their security assertions @xcite .",
    "fresh names are also crucial in the field of network protocols , and they are one of the key features of the @xmath0-calculus @xcite . like ordinary register automata , fresh - register automata preserve some of the good properties of finite automata .",
    "however , they are not closed under complement and also come with an undecidable equivalence problem .    in this paper",
    ", we propose _ session automata _ , a robust automata model over data words .",
    "like register automata , session automata are a syntactical restriction of fresh - register automata , but in an orthogonal way .",
    "register automata drop the feature of checking _ global freshness _ ( referring to the whole history ) while keeping a local variant ( referring to the registers ) .",
    "session automata , on the other hand , discard local freshness , while keeping the global one .",
    "session automata are well - suited whenever fresh values are important for a finite period , for which they will be stored in one of the registers .",
    "they correspond to the model from @xcite without stacks .",
    "not surprisingly , we will show that session automata and register automata describe incomparable classes of languages of data words , whereas both are strictly weaker than fresh - register automata .",
    "contrary to finite - state unification based automata introduced in  @xcite , session automata ( like fresh - register automata ) do not have the capability to reset the content of a register .",
    "however , they can test global freshness which the model of @xcite can not .",
    "the _ variable automata _ from @xcite do not employ registers , but rather use bound and free variables .",
    "however , variable automata are close to our model : they use a finite set of bound variables to track the occurrences of some data values , and a single free variable for all other data values ( that must be different from data values tracked by bound variables ) .",
    "contrary to our model , variable automata can not test for global freshness , but we are not able to recognize the language of all data words , contrary to them .    in this paper , we show that session automata ( i ) are closed under intersection , union , and resource - sensitive complementation , ( ii ) have a unique canonical form ( analogous to minimal deterministic finite automata ) , ( iii ) have a decidable equivalence / inclusion problem , and ( iv ) enjoy logical characterizations .",
    "altogether , this provides a versatile framework for languages over infinite alphabets .    in a second part of the paper , we present an application of our automata model in the area of learning , where decidability of the equivalence problem is crucial .",
    "learning automata deals with the inference of automata based on some partial information , for example samples , which are words that either belong to the accepted language or not .",
    "a popular framework is that of active learning defined by angluin @xcite in which a learner may consult a teacher for so - called membership and equivalence queries to eventually infer the automaton in question .",
    "learning automata has many applications in computer science .",
    "notable examples are the use in model checking @xcite and testing @xcite .",
    "see @xcite for an overview .",
    "while active learning of regular languages is meanwhile well understood and is supported by freely available libraries such as learnlib @xcite and libalf @xcite , extensions beyond plain regular languages are still an area of active research .",
    "recently , automata dealing with potentially infinite data as basis objects have been studied .",
    "seminal works in this area are that of @xcite and @xcite . while the first two use abstraction and refinement techniques to cope with infinite data , the second approach learns a sub - class of register automata .",
    "note that session automata are incomparable with the model from @xcite .",
    "thanks to their closure and decidability properties , a conservative extension of angluin s classical algorithm will do for their automatic inference .",
    "the paper is structured as follows . in section  [ sec : data ] we introduce session automata . section  [ sec : snf - can ] presents the main tool allowing us to establish the results of this paper , namely the use of data words in symbolic normal form and the construction of a canonical session automaton .",
    "the section also presents some closure properties of session automata and the decidability of the equivalence problem .",
    "section  [ sec : logic ] gives logical characterizations of our model . in section  [ sec : learning ] , we present an active learning algorithm for session automata .",
    "this paper is an extended version of @xcite .",
    "we let @xmath1 be the set of natural numbers and @xmath2 be the set of non - zero natural numbers . in the following , we fix a non - empty finite alphabet @xmath3 of _ labels _ and an infinite set @xmath4 of _ data values_. in examples , we usually use @xmath5 .",
    "a _ data word _ over @xmath3 and @xmath6 is a sequence @xmath7 of pairs @xmath8 . in other words",
    ", @xmath9 is an element from @xmath10 . for @xmath11 , we let @xmath12 denote the position @xmath13 where @xmath14 occurs for the first time , i.e. , such that @xmath15 and there is no @xmath16 such that @xmath17 . accordingly , we define @xmath18 to be the last position where @xmath14 occurs .    an example data word over @xmath19 and @xmath5 is given by @xmath20 @xmath21 .",
    "we have @xmath22 and @xmath23 .",
    "this section recalls two existing automata models over data words  namely register automata , previously introduced in @xcite , and fresh - register automata , introduced in @xcite as a generalization of register automata .",
    "moreover , we introduce the new model of session automata , our main object of interest .    register automata ( initially called finite - memory automata ) equip finite - state machines with registers in which data values can be stored and be read out later .",
    "fresh - register automata additionally come with an oracle that can determine if a data value is _ fresh _ ,",
    "i.e. , has not occurred in the history of a run . both register and fresh - register automata are closed under union and intersection , and they have a decidable emptiness problem .",
    "however , they are not closed under complementation , and their equivalence problem is undecidable , which limits their application in areas such as model checking and automata learning .",
    "session automata , on the other hand , are closed under ( resource - sensitive ) complementation , and they have a decidable inclusion / equivalence problem .    given a set @xmath24 , we let @xmath25 , @xmath26 , and @xmath27 . in the automata models that we are going to introduce , @xmath24 will be the set of registers .",
    "transitions will be labeled with an element from @xmath28 , which determines a register and the operation that is performed on it .",
    "more precisely , @xmath29 writes a globally fresh value into @xmath30 , @xmath31 writes a locally fresh value into @xmath30 , and @xmath32 uses the value that is currently stored in @xmath30 . for @xmath33 ,",
    "we let @xmath34 if @xmath35 .",
    "similarly , @xmath36    a _ fresh - register automaton _ ( over @xmath3 and @xmath6 ) is a tuple @xmath37 where    * @xmath38 is the non - empty finite set of _ states _ , * @xmath24 is the non - empty finite set of _ registers _ , * @xmath39 is the _ initial state _ , * @xmath40 is the set of _ final states _ , and * @xmath41 is a finite set of _ transitions _ : each transition is a tuple of the form @xmath42 where @xmath43 are the source and target state , respectively , @xmath44 , and @xmath33 .",
    "we call @xmath45 the _ transition label_.    for a transition @xmath46 , we also write @xmath47 . when taking this transition , the automaton moves from state @xmath48 to state @xmath49 and reads a symbol @xmath50 .",
    "if @xmath51 , then @xmath14 is the data value that is currently stored in register @xmath30 .",
    "if @xmath52 , then @xmath14 is some _ globally fresh _ data value , which has not been read in the _ whole _ history of the run ; @xmath14 is then written into register @xmath30 . finally ,",
    "if @xmath53 , then @xmath14 is some _ locally fresh _ data value , which is _ currently _ not stored in the registers ; it will henceforth be stored in register @xmath30 .",
    "let us formally define the semantics of @xmath54 .",
    "configuration _ is a triple @xmath55 where @xmath56 is the current state , @xmath57 is a partial mapping encoding the current register assignment , and @xmath58 is the set of data values that have been used so far . by @xmath59 ,",
    "we denote the set of registers @xmath30 such that @xmath60 is defined .",
    "moreover , @xmath61 .",
    "we say that @xmath62 is _ final _ if @xmath63 . as usual , we define a transition relation over configurations and let @xmath64 , where @xmath65 , if there is a transition @xmath66 such that the following conditions hold :    1 .",
    "@xmath67 2 .",
    "@xmath68 and @xmath69 , 3 .",
    "@xmath70 and @xmath71 for all @xmath72 .",
    "a run of @xmath54 on a data word @xmath73 is a sequence @xmath74 for suitable configurations @xmath75 with @xmath76 ( here the partial mapping  @xmath77 represents the mapping with empty domain ) .",
    "the run is _ accepting _ if @xmath78 is a final configuration .",
    "the _ language _ @xmath79 of @xmath54 is then defined as the set of data words for which there is an accepting run .",
    "note that fresh - register automata can not distinguish between data words that are equivalent up to permutation of data values .",
    "more precisely , given @xmath80 , we write @xmath81 if @xmath82 and @xmath83 such that , for all @xmath84 , we have @xmath85 iff  @xmath86 . for instance , @xmath87 . in the following , the equivalence class of a data word @xmath9 wrt .",
    "@xmath88 is written @xmath89_{\\approx}$ ] .",
    "we call @xmath90 a _ data language _ if , for all @xmath80 such that @xmath81 , we have @xmath91 if , and only if , @xmath92 . in particular , @xmath93 is a data language for every fresh - register automaton @xmath54 .",
    "we obtain natural subclasses of fresh - register automata when we restrict the transition labels @xmath94 in the transitions .    a _ register automaton _ is a fresh - register automaton where every transition label is from @xmath95 .    like",
    "register automata , session automata are a syntactical restriction of fresh - register automata , but in an orthogonal way . instead of local freshness",
    ", they include the feature of global freshness .",
    "a _ session automaton _ is a fresh - register automaton where every transition label is from @xmath96 .",
    "we first compare the three models of automata introduced above in terms of expressive power .",
    "[ ex : req - ack ] consider the set of labels @xmath97 and the set of data values @xmath98 , representing an infinite supply of process identifiers ( pids ) .",
    "we model a simple ( sequential ) system where processes can approach a server and make a request , indicated by @xmath99 , and where the server can acknowledge these requests , indicated by @xmath100 .",
    "more precisely , @xmath101 means that the process with pid @xmath102 performs a request , which is acknowledged when the system executes @xmath103 .",
    "[ fig : multiples3](a ) depicts a register automaton that recognizes the language @xmath104 of data words verifying the following conditions :    * there are at most two open requests at a time ; * a process waits for an acknowledgment before making another request ; * every acknowledgment is preceded by a request ; * requests are acknowledged in the order they are received .    in the figure ,",
    "an edge label of the form @xmath105 shall denote that there are two transitions , one labeled with @xmath106 , and one labeled with @xmath107 . whereas a transition labeled with @xmath106 is taken when the current data value does not appear currently in the registers ( but could have appeared before in the data word ) and store it in @xmath108",
    ", transition labeled with @xmath107 simply checks that the current data is stored in register @xmath108 .",
    "the automaton models a server that can store two requests at a time and will acknowledge them in the order they are received . for example , it accepts @xmath109 .    when we want to guarantee that , in addition , every process makes at most one request , we need the global freshness operator .  [",
    "fig : multiples3](b ) hence depicts a session automaton recognizing the language @xmath110 of all the data words of @xmath104 in which every process makes at most one request .",
    "notice that the transition from @xmath111 to @xmath112 is now labeled with @xmath113 , so that this transition can only be taken in case the current data value has never been seen before .",
    "we obtain @xmath114 from @xmath115 by replacing every occurrence of @xmath116 with @xmath117 . while @xmath109 is no longer contained in @xmath110 , @xmath118 @xmath119",
    "is still accepted .    as a last example , consider the language @xmath120 of data words in which every process makes at most one request ( without any other condition ) . a fresh - register automaton recognizing it is given in  [ fig : fra ] .",
    "= 4 ( 0)(0,0)@xmath111 ( 1)(-20,0)@xmath112 ( 2)(20,0)@xmath121 ( 12)(0,13)@xmath122 ( 21)(0,-13)@xmath123 ( 0,1)@xmath124 ( 1,0)@xmath125 ( 1,12)@xmath126 ( 2,21)@xmath124 ( 21,1)@xmath127 ( 12,2)@xmath125 ( 0,2)@xmath126 ( 2,0)@xmath127    = 4 ( 0)(0,0)@xmath111 ( 1)(-20,0)@xmath112 ( 2)(20,0)@xmath121 ( 12)(0,13)@xmath122 ( 21)(0,-13)@xmath123 ( 0,1)@xmath113 ( 1,0)@xmath125 ( 1,12)@xmath128 ( 2,21)@xmath113 ( 21,1)@xmath127 ( 12,2)@xmath125 ( 0,2)@xmath128 ( 2,0)@xmath127    [ cols=\"^,^ \" , ]      + @xmath129 :    we apply our learning algorithm on the data language given by the automaton @xmath54 of  [ fig : examplecanonical](a ) . in  [ fig : learning ] the successive observation tables constructed by the algorithm are given .",
    "to save space some letters whose rows contain only @xmath130 s are omitted . in  [ fig : hypos ] the successive automata constructed from the closed observation tables are given .",
    "for sake of clarity we omit the sink states .",
    "we start with the alphabet @xmath131 .",
    "we omit letters @xmath132 and @xmath133 .",
    "table @xmath134 is obtained after initialization and closing by adding @xmath135 to the top .",
    "we use @xmath136 to indicate that all letters will lead to the same row . from @xmath134",
    "the first hypothesis automaton @xmath115 is constructed .",
    "we suppose that the equivalence query gives back as counterexample the data word @xmath137 whose normal form is @xmath138 . here",
    "the break - point yields the distinguishing word @xmath135 .",
    "we add it to @xmath139 .",
    "the obtained table is not closed anymore .",
    "we close it by adding @xmath140 to the top and get table @xmath141 yielding hypothesis automaton @xmath114 . notice that @xmath142 .",
    "this means that the equivalence query must give back a data word whose normal form is using at least @xmath143 registers ( here @xmath144 with normal form @xmath145 ) .",
    "as the word uses @xmath143 registers , we extend the alphabet to @xmath146 and obtain table @xmath147 .",
    "we close the table and get @xmath148 .",
    "from there we obtain the hypothesis automaton @xmath149 . after the equivalence query we get @xmath150 as normal form of the data word counterexample @xmath151 . after adding @xmath152 to @xmath139 and closing the table by moving @xmath145 to the top we get finally the table @xmath153 from which the canonical automaton @xmath129 is obtained and the equivalence query succeeds .",
    "in this paper , we developed a theory of session automata , which form a robust class of data languages .",
    "in particular , they are closed under union , intersection , and resource - sensitive complementation .",
    "moreover , they enjoy logical characterizations in terms of ( a fragment of ) mso logic with a predicate to compare data values for equality . finally , unlike most other automata models for data words , session automata have a decidable inclusion problem .",
    "this makes them attractive for verification and learning .",
    "in fact , we provided a complete framework for algorithmic learning of session automata , making use of their canonical normal form . an interesting direction to follow",
    "would be to try to apply those methods to other models of automata dealing with data values like data automata @xcite or variable automata @xcite . as a next step ,",
    "we plan to employ our setting for various verification tasks .",
    "in particular , the next step is to implement our framework , using possibly other learning algorithms than the one of rivest and shapire that we presented in this article , for instance using the learnlib platform @xcite or libalf @xcite .",
    "f.  aarts , f.  heidarian , h.  kuppens , p.  olsen , and f.  w. vaandrager .",
    "automata learning through counterexample guided abstraction refinement . in _ fm _ ,",
    "volume 7436 of _ lecture notes in computer science _ , pages 1027 .",
    "springer , 2012 .",
    "t.  berg , o.  grinchtein , b.  jonsson , m.  leucker , h.  raffelt , and b.  steffen . on the correspondence between conformance testing and regular inference . in _",
    "fase _ , volume 3442 of _ lecture notes in computer science _ , pages 175189 .",
    "springer , 2005 .",
    "b.  bollig , a.  cyriac , p.  gastin , and k.  narayan  kumar .",
    "model checking languages of data words . in l.",
    "birkedal , editor , _ proceedings of fossacs12 _ , volume 7213 of _ lecture notes in computer science _",
    ", pages 391405 .",
    "springer , 2012 .",
    "b.  bollig , p.  habermehl , m.  leucker , and b.  monmege . a  fresh approach to learning register automata . in _ proceedings of the 17th international conference on developments in language theory ( dlt13 ) _ , volume 7907 of _ lecture notes in computer science _ , pages 118130 .",
    "springer , 2013 .",
    "j.  m. cobleigh , d.  giannakopoulou , and c.  s. pasareanu .",
    "learning assumptions for compositional verification . in _ tacas _ , volume 2619 of _ lecture notes in computer science _ ,",
    "pages 331346 .",
    "springer , 2003 .",
    "t.  colcombet , c.  ley , and g.  puppis . on the use of guards for logics with data . in",
    "_ proceedings of mfcs11 _ , volume 6907 of _ lecture notes in computer science _ , pages 243255 .",
    "springer berlin / heidelberg , 2011 .",
    "o.  grumberg , o.  kupferman , and s.  sheinvald .",
    "an automata - theoretic approach to reasoning about parameterized systems and specifications . in _",
    "volume 8172 of _ lecture notes in computer science _ , pages 397411 .",
    "springer , 2013 .",
    "a.  kurz , t.  suzuki , and e.  tuosto . on nominal regular languages with binders . in l.",
    "birkedal , editor , _ proceedings of fossacs12 _ , volume 7213 of _ lecture notes in computer science _ , pages 255269 .",
    "springer , 2012 ."
  ],
  "abstract_text": [
    "<S> we introduce _ session automata _ , an automata model to process data words , i.e. , words over an infinite alphabet . session automata support the notion of _ fresh _ data values , which are well suited for modeling protocols in which sessions using fresh values are of major interest , like in security protocols or ad - hoc networks . </S>",
    "<S> session automata have an expressiveness partly extending , partly reducing that of classical register automata . </S>",
    "<S> we show that , unlike register automata and their various extensions , session automata are robust : they ( i ) are closed under intersection , union , and ( resource - sensitive ) complementation , ( ii ) admit a symbolic regular representation , ( iii ) have a decidable inclusion problem ( unlike register automata ) , and ( iv ) enjoy logical characterizations . using these results , we establish a learning algorithm to infer session automata through membership and equivalence queries .    </S>",
    "<S> = 1 </S>"
  ]
}