{
  "article_text": [
    "discrete orthogonal transforms and discrete unitary transforms have found various applications in signal , image , and video processing , in pattern recognition , in biocomputing , and in numerous other areas  [ ] .",
    "well - known examples of such transforms include the discrete fourier transform , the walsh - hadamard transform , the trigonometric transforms such as the sine and cosine transform , the hartley transform , and the slant transform .",
    "all these different transforms find applications in signal and image processing , because the great variety of signal classes occuring in practice can not be handeled by a single transform .    on a classical computer , the straightforward way to compute a discrete orthogonal transform of a signal vector of length @xmath1",
    "takes in general @xmath2 operations .",
    "an important aspect in many applications is to achieve the best possible computational efficiency .",
    "the examples mentioned above allow an evaluation with as few as @xmath3 operations or  in the case of the wavelet transforms  even with as little as @xmath4 operations .",
    "in view of the trivial lower bound of @xmath5 operations for matrix - vector - products , we notice that these algorithms are optimal or nearly optimal .    the rules of the game change dramatically when the ultimate limit of computational integration is approached , that is , when information is stored in single atoms , photons , or other quantum mechanical systems .",
    "the operations manipulating the state of such a computer have to follow the dictum of quantum mechanics . however , this is not necessarily a limitation .",
    "a striking example of the potential speed - up of quantum computation over classical computation has been given by shor in 1994 .",
    "he showed that integers can be factored in polynomial time on a quantum computer .",
    "in contrast , there are no polynomial time algorithms known for this problem on a classical computer",
    ".    the quantum computing model does not provide a uniform speed - up for all computational tasks .",
    "in fact , there are a number of problems which do not allow any speed - up at all . for instance",
    ", it can be shown that a quantum computer searching a sorted database will not have any advantage over a classical computer .",
    "on the other hand , if we use our classical algorithms on a quantum computer , then it will simply perform the calculation in a similar manner to a classical computer . in order for a quantum computer to show",
    "its superiority one needs to design new algorithms which take advantage of quantum parallelism .",
    "a quantum algorithm may be thought of as a discrete unitary transform which is followed by some i / o operations .",
    "this observation partially explains why signal transforms play a dominant role in numerous quantum algorithms@xcite .",
    "another reason is that it is often possible to find extremely efficient quantum algorithms for the discrete orthogonal transforms mentioned above .",
    "for instance , the discrete fourier transform of length @xmath6 can be implemented with @xmath0 operations on a quantum computer .",
    "the basic unit of information in classical computation is a bit , a system with two distinguishable states representing logical values 0 or 1 .",
    "we mentioned in the introduction that a quantum computer will store such information in the states of a quantum mechanical system .",
    "suppose that the system has two distinguishable states .",
    "we will denote these states by @xmath7 and @xmath8 , where the notation reminds us that these states represent the logical values 0 and 1 .    a potential candidate for the storage of a single bit is given by a spin-@xmath9 particle , such as an electron , proton , or neutron .",
    "we can choose the state with the rotation vector pointing upward ( spin - up ) and the state with the rotation vector pointing downward ( spin - down ) to represent 0 and 1 , respectively .",
    "however , we know from quantum mechanics that quantum system can be in a superposition of states .",
    "in the case of a spin-@xmath9 particle , a superposition @xmath10 yields a state which rotates about a different axis .",
    "the coefficients @xmath11 in this superposition are complex numbers , which determine this spin axis .    the consequent abstraction of the preceding example leads to the notion of a quantum bit , or shortly qubit , the basic unit of information in quantum computation .",
    "a quantum bit is given by a superposition of the states @xmath7 and @xmath8 such as @xmath12 the value of a quantum bit remains uncertain until it is measured .",
    "a measurement will collapse @xmath13 to either the state @xmath7 or to the state @xmath8 .",
    "the coefficients @xmath14 and @xmath15 determine the probability of outcome of this measurement , namely @xmath16 { \\left|\\psi\\right\\rangle } \\mbox { collapses to } { \\left|0\\right\\rangle } & |a|^2/(|a|^2+|b|^2)\\\\[1ex ] { \\left|\\psi\\right\\rangle } \\mbox { collapses to } { \\left|1\\right\\rangle } & |b|^2/(|a|^2+|b|^2 )     \\end{array}\\ ] ] in either case , we will learn the outcome of the measurement .",
    "since proportional states lead to the same measurement results , it is conventially assumed that the state is normalized to length 1 , i.e. , it is assumed that @xmath17 holds .",
    "the measurement allows to implement a fair coin flip on a quantum computer . indeed , preparing a quantum bit in the state @xmath18 , and measuring the result yields either 0 or 1 .",
    "according to the above rule , either event will occur exactly with probability 1/2 .",
    "this example might suggest that computations on a quantum computer are indeterministic and maybe even somewhat fuzzy .",
    "however , this is not the case .",
    "we will see in a moment that all operations apart from measurements are completely deterministic .",
    "the only operations that might introduce some randomized behaviour are the measurements , which  as penrose puts it  ` magnify an event from the quantum level to the classical level '  [ , pp .  7 - 8 ] .",
    "we discuss now the deterministic operations on a quantum computer .",
    "we begin with the simplest case , the operations which manipulate the state of a single quantum bit .",
    "first of all , it should be noted that the states @xmath7 and @xmath8 can be understood as an orthonormal basis of the complex inner product space @xmath19 .",
    "it is customary to associate the base states @xmath7 and @xmath8 with the standard basis vectors @xmath20 and @xmath21 , respectively .",
    "therefore , a quantum bit in the state @xmath22 is represented by the state vector @xmath23 a deterministic operation has to realize a unitary evolution of the quantum state , following the rules of quantum mechanics . in other words ,",
    "a single quantum bit operation is given by a unitary operator @xmath24 acting on the state of the quantum bit .",
    "there is a graphical notation for quantum operations .",
    "the schematic for such a single qubit operation @xmath25 is shown in figure  [ fig : single ] .",
    "( 50,50 ) setunit 1.5 mm ; qubits(1 ) ;    labels.lft(0,btex @xmath26 etex ) ; wires(0.5 cm ) ; gate(gpos 0 , btex @xmath25 etex ) ; wires(0.5 cm ) ; labels.rt(0,btex @xmath27 etex ) ;    examples of single qubit operations are given by @xmath28 the operation @xmath29 realizes a not operation , @xmath30 and @xmath31 .",
    "the operation @xmath32 implements a phase shift operation , @xmath33 and @xmath34 .",
    "an extremely useful operation is given by the hadamard gate  @xmath35 , which is for instance used to create superpositions , @xmath36 the hadamard gate should be familiar to readers with a background in signal processing or coding theory . in the following , we will keep the notations for these gates without further notice .",
    "the operations get more interesting in the case of multiple quantum bits .",
    "quantum mechanics tells us that the state space of a combined quantum system is given by the tensor product of the state spaces of its parts .",
    "a remarkable consequence of this rule is that the state space of a system with @xmath37 quantum bits is given by the vector space @xmath38 ( @xmath37-fold tensor product ) .",
    "this simply means that the dimension of the state space _ doubles _ with the addition of a single quantum bit .",
    "the state of a system with two quantum bits can thus be described by a vector @xmath39 or , isomorphically , by the vector @xmath40 the latter notation is often abbreviated to @xmath41 .",
    "the label @xmath42 in the dirac ket notation @xmath43 specifies a location in the quantum memory .",
    "a dramatic consequence of the tensor product structure of the quantum memory can be illustrated with a single qubit operation .",
    "suppose that we apply a single qubit operation , say the hadamard gate @xmath35 , on the least significant bit of ( [ eq : twostate ] ) .",
    "the resulting state is @xmath44 in more traditional mathematical notation , we can formulate this as the action of the matrix @xmath45 therefore , the resulting operation is @xmath46 .",
    "although we act only on one quantum bit , we see every single position of the state vector is manipulated .",
    "this is a striking example of quantum parallelism .",
    "we observe that a butterfly structure , well - known from many signal processing algorithms , can be implemented with a single operation on a quantum computer .",
    "the direct generalization to arbitrary single qubit operations is shown in figure  [ fig : twoqubit ] .",
    "in general , a single qubit operation is specified by a unitary @xmath47 matrix @xmath25 , and the position of the target qubit to which @xmath25 is applied .",
    "suppose that the target qubit position is @xmath48 , then each state @xmath49 is unconditionally transformed to @xmath50 , where @xmath51 .",
    "( 50,50 ) setunit 1.5 mm ; qubits(2 ) ; wires(0.5",
    "cm ) ; gate(gpos 0 , btex @xmath25 etex ) ; wires(0.5 cm ) ; qcxcoord : = qcxcoord+2qcstepsize ; wires(0.5 cm ) ; gate(gpos 1 , btex @xmath25 etex ) ; wires(0.5 cm ) ;    we can specify more elaborate gates , which allow to create an interaction between quantum bits .",
    "let @xmath52 and @xmath53 be two disjoint sets of quantum bit positions , neither of which contains the target bit position @xmath48 .",
    "a conditional @xmath25-operation maps the state @xmath54 to the state @xmath50 , in case @xmath55 for all @xmath56 and @xmath57 for all @xmath58 .",
    "the state remains unchanged in all other cases .",
    "the set @xmath52 describes the set of zero - conditions and @xmath53 the set of one - conditions . in the schematics , we will use the symbol @xmath59 to denote a zero - condition and the symbol @xmath60 to denote a one - condition .",
    "figure  [ fig : cnot ] shows the simplest , but most important , conditional quantum gate  the controlled not operation .",
    "( 50,50 ) setunit 1.5 mm ; qubits(2 ) ; cnot(icnd 1 , gpos 0 ) ; label(btex @xmath61 etex , ( qcxcoord+1/2qcstepsize,(qcycoord[0]+qcycoord[1])/2 ) ) ; qcxcoord : = qcxcoord + qcstepsize ; gate(icnd 1 , gpos 0 , btex @xmath29 etex ) ;    we can use controlled not gates to get an interaction between different quantum bits . for example , consider the circuit in figure  [ fig : swap ] .",
    "this circuit swaps the states of the two quantum bits .",
    "( 50,50 ) setunit 1.5 mm ; qubits(2 ) ; labels.lft(0,btex @xmath62 etex,1,btex @xmath63 etex ) ; cnot(icnd 0 , gpos 1 ) ; cnot(icnd 1 , gpos 0 ) ; cnot(icnd 0 , gpos 1 ) ; labels.rt(0,btex @xmath63 etex,1,btex @xmath62 etex ) ;    engineering controlled @xmath25 operations is in general a difficult task",
    ". we will refer to controlled not gates with a single control bit and to single qubit operations as _",
    "elementary gates_. elementary quantum gates are available in all mature quantum computing technologies .",
    "it can be shown that it is possible to implement a general controlled @xmath25 operation with @xmath64 elementary gates.@xcite we will always refer to elementary gates in gate counts , but we will use multiply controlled @xmath25 gates for the sake of brevity in circuit descriptions . there exist standard algorithms which transform these more general gates into a sequence of elementary gates.@xcite",
    "we have seen that a number of powerful operations are available on a quantum computer .",
    "suppose that we want to implement a unitary or orthogonal transform @xmath65 on a quantum computer",
    ". the goal will be to find an implementation of @xmath25 in terms of elementary quantum gates .",
    "usually , our aim will be to find first a factorization of @xmath25 in terms of sparse structured unitary matrices @xmath66 , @xmath67 where , of course , @xmath68 should be small .",
    "the philosophy being that it is often very easy to derive quantum circuits for structured sparse matrices .",
    "for example , if we can find an implementation with few multiply controlled unitary gates for each factor @xmath66 , then the overall circuit will be extremely efficient .",
    "the success of this method depends of course very much on the availability suitable factorization of @xmath25",
    ". however , in the case orthogonal transfroms used in signal processing , there are typically numerous classical algorithms available , which provide the suitable factorizations .",
    "it should be noted that , in principle , an exponential number of elementary gates might be needed to implement even a diagonal unitary matrix .",
    "fortunately , we will see that most structured matrices occuring in practice have very efficient implementations .",
    "in fact , we will see that all the transforms of size @xmath69 discussed in the following can be implemented with merely @xmath70 elementary quantum gates .",
    "we present a simple  but novel  approach to derive such efficient implementations .",
    "this approach is based on a divide - and - conquer technique .",
    "assume that we want to implement a family of unitary transforms @xmath71 , where @xmath6 denotes the length of the signal .",
    "suppose further the family @xmath71 can be recursively generated by a recursive circuit construction , for instance , such as the one shown in figure  [ fig : rec1 ] .",
    "we will give a generic construction for the family of precomputation circuits pre_@xmath72 _ and the family of postcomputation circuits post_@xmath72_. this way , we obtain a fairly economic description of the algorithms .",
    "( 50,50 ) setunit 1.5 mm ; qubits(5 ) ; dropwire(1,2 ) ; wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; wires(2 mm ) ; circuit(2qcheight)(gpos 0,1,2 , btex @xmath71 etex ) ; wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; wires(2 mm ) ; label(btex @xmath61 etex , ( qcxcoord+1/2qcstepsize , qcycoord[0]+3/2qcheight ) ) ; qcxcoord : = qcxcoord + qcstepsize ; wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; wires(2 mm ) ; circuit(2.5qcheight)(gpos 0,1,2,btex @xmath74 etex ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; circuit(2qcheight)(gpos 0,1 , btex @xmath75 etex ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; circuit(2.5qcheight)(gpos 0,1,2,btex @xmath76 etex ) ; wires(2 mm ) ; label(btex",
    "@xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; wires(2 mm ) ;    assume that a total of @xmath77 elementary operations are necessary to implement the precomputation circuit pre@xmath78 and the postcomputation circuit post@xmath78 .",
    "then the overall number @xmath79 of elementary operations can be estimated from the recurrence equation @xmath80 the number of operations @xmath79 for the recursive implementation can be estimated as follows :    lemma . if @xmath81 , then @xmath82 .",
    "we will illustrate the general approach by way of some examples .",
    "our first example is the discrete fourier transform .",
    "a quantum algorithm implementing this transform found a most famous application in shor s integer factorization",
    "algorithm.@xcite recall that the discrete fourier transform @xmath83 of length @xmath6 can be described by the matrix @xmath84 where @xmath85 denotes a primitive @xmath1-th root of unity , @xmath86 .",
    "and @xmath48 denotes a square root of @xmath87 .    the main observation behind the fast quantum algorithm dates at least back to work by danielson and lanczos in 1942 ( and is implicitly contained in numerous earlier works ) .",
    "they noticed that the matrix @xmath83 might be written as @xmath88 where @xmath89 denotes the permutation of rows given by @xmath90 with @xmath91 an @xmath92-bit integer , and @xmath15 a single bit , and @xmath93 denotes the matrix of twiddle factors .",
    "this observation allows to represent @xmath83 by the following product of matrices : @xmath94 this factorization yields an outline of an implementation on a quantum computer .",
    "the overall structure is shown in figure  [ fig : fourierrec ] .",
    "( 50,50 ) setunit 1.5 mm ; qubits(5 ) ; dropwire(1,2 ) ; wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; circuit(3qcheight)(gpos 0,1,2,btex @xmath95 etex ) ; label(btex",
    "@xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; wires(2 mm ) ; qubits(5 ) ; label(btex @xmath61 etex,(qcxcoord+qcstepsize/2,qcycoord[2 ] ) ) ; dropwire(1,2 ) ; qcxcoord : = qcxcoord + qcstepsize ; wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord+1/2qcstepsize , qcycoord[0]+10 mm ) ) ; gate(gpos 2,btex @xmath96 etex ) ; circuit(2qcheight)(icnd 2 , gpos 0,1,btex @xmath97 etex ) ;",
    "label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; qcfgcolor : = 0.7white ; circuit(2qcheight)(gpos 0,1 , btex @xmath98 etex ) ; qcfgcolor : = black ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; qubits(5 ) ; dropwire(2 ) ; draw ( qcxcoord , qcycoord[3])(qcxcoord+qcstepsize , qcycoord[0 ] ) ; draw ( qcxcoord , qcycoord[0])(qcxcoord+qcstepsize , qcycoord[1 ] ) ; draw ( qcxcoord , qcycoord[2])(qcxcoord+qcstepsize , qcycoord[3 ] ) ; dropwire(2 ) ; qcxcoord : = qcxcoord + qcstepsize ; wires(2 mm ) ; label(btex @xmath73 etex , ( qcxcoord-2mm , qcycoord[1]+10 mm ) ) ;    it remains to detail the different steps in this implementation .",
    "the first step is a single qubit operation , implementing a butterfly structure .",
    "the next step is slightly more complicated .",
    "we observe that @xmath97 is a tensor product of diagonal matrices @xmath99 .",
    "indeed , @xmath100 thus , @xmath101 can be realized by controlled phase shift operations , see figure  [ fig : twiddle ] for an example .",
    "we then recurse to implement the fourier transform of smaller size .",
    "the final permutation implements the cyclic rotation of the quantum wires .",
    "( 50,50 ) setunit 1.9 mm ; qubits(4 ) ; circuit(2qcheight)(icnd 3 , gpos 0,1,2 , btex @xmath102 etex ) ; label(btex @xmath61 etex , ( qcxcoord + 1/2qcstepsize , qcycoord[1]+1/4qcheight ) ) ; qcxcoord : = qcxcoord + qcstepsize ; gate(icnd 3 , gpos 2 , btex @xmath103 etex ) ;    gate(icnd 3 , gpos 1 , btex @xmath104 etex ) ; gate(icnd 3 , gpos 0 , btex @xmath105 etex ) ;    the complexity of the quantum fourier transform can be estimated as follows .",
    "if we denote by @xmath106 the number of gates necessary to implement the dft of length @xmath6 on a quantum computer , then figure  [ fig : fourierrec ] implies the recurrence relation @xmath107 which leads to the estimate @xmath108 .",
    "it should be noted that all permutations @xmath109 at the end can be combined into a single permutation of quantum wires .",
    "the resulting permutation is the bit reversal , see figure  [ bitreversal ] .",
    "( 50,50 ) setunit 1.5 mm ; qubits(4 ) ; perm(cyc 0,3 , cyc 1,2 ) ; label(btex @xmath61 etex , ( qcxcoord+1/2qcstepsize , qcycoord[1]+1/2qcheight ) ) ; qcxcoord : = qcxcoord + qcstepsize ; perm(cyc 0,1 ) ; wires(1.5 mm ) ; draw ( qcxcoord , qcycoord[0]-1/2qcheight)(qcxcoord , qcycoord[3]+1/2qcheight ) dashed evenly ; wires(1.5 mm ) ; perm(cyc 2,0,1 ) ; wires(1.5 mm ) ; draw ( qcxcoord , qcycoord[0]-1/2qcheight)(qcxcoord , qcycoord[3]+1/2qcheight ) dashed evenly ; wires(1.5 mm ) ; perm(cyc 3,0,1,2 ) ;    remark .",
    "another explanation of the discrete fourier transform algorithm is contained in [ ] .",
    "note that the row permutations are mistaken in that article .",
    "an approximate version of the discrete fourier transform has been proposed by coppersmith@xcite , which saves some operations .",
    "the walsh - hadamard transform @xmath110 is maybe the simplest instance of the recursive approach .",
    "this transform is defined by the hadamard gates @xmath111 in the case of signals of length 2 . for signals of larger length ,",
    "the transform is defined by @xmath112 this yields the recursive implementation shown in figure  [ fig : walsh ] .",
    "( 50,50 ) setunit 1.5 mm ; qubits(5 ) ; dropwire(1,2 ) ; wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; circuit(2qcheight)(gpos 0,1,2,btex @xmath110 etex ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; wires(2 mm ) ;    label(btex @xmath61 etex , ( qcxcoord + 1/2qcstepsize , qcycoord[0]+2qcheight ) ) ; qcxcoord : = qcxcoord + qcstepsize ; wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord+1/2qcstepsize , qcycoord[0]+10 mm ) ) ; gate(gpos 2 , btex @xmath35 etex ) ; circuit(2qcheight)(gpos 0,1 , btex @xmath113 etex ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; wires(2 mm ) ;    since @xmath114 , the lemma in section  3 shows that the number of operations @xmath115 .",
    "it is of course trivial to see that in this case exactly @xmath116 operations are needed .",
    "the slant transform is used in image processing for the representation of images with many constant or uniformly changing gray levels .",
    "the transform has good energy compaction properties .",
    "it is used in intel s ` indeo ' video compression and in numerous still image compression algorithms .",
    "the slant transform @xmath117 is defined for signals of length @xmath118 by the hadamard matrix @xmath119 and for signals of length @xmath120 , @xmath121 , by @xmath122 where @xmath123 denotes the all - zero matrix , and @xmath124 is given by the matrix product @xmath125 the matrices in ( [ eq : slant ] ) are defined as follows ( see also  [ ] ) : @xmath126 is the identity matrix , @xmath35 is the hadamard matrix , and @xmath127 realizes the transposition @xmath128 , that is , @xmath129 the matrix @xmath130 is defined by @xmath131 for all @xmath91 except in the case @xmath132 , where it yields the phase change @xmath133 .",
    "finally @xmath134 where @xmath135 and @xmath136 are recursively defined by @xmath137 and @xmath138 it is easy to check that @xmath139 is a unitary matrix .",
    "the definition of the slant transform suggests the following implementation .",
    "equation ( [ eq : slantrec ] ) tells us that the input signal of a slant transform of length @xmath1 is first processed by two slant transforms of size @xmath140 , followed by a circuit implementing @xmath124 .",
    "we can write equation ( [ eq : slantrec ] ) in the form @xmath141 the tensor product structure @xmath142 is compatible with our decomposition into quantum bits .",
    "this means that a single copy of the circuit @xmath143 acting on the lower significant bits will realize this part .",
    "it remains to give an implementation for @xmath124 .",
    "equation  ( [ eq : slant ] ) describes @xmath124 as a product of four sparse matrices , which are easy to implement .",
    "indeed , the matrix @xmath144 is realized by conditionally excerting the phase gate @xmath32 . the matrix @xmath145 is implemented by a hadamard gate @xmath35 acting on the most significant bit .",
    "a conditional application of @xmath139 implements the matrix @xmath146 .",
    "a conditional swap of the least and the most significant qubit realizes @xmath127 , that is , three multiply controlled not gates implement @xmath127 . the quantum circuit realizing this implementation is depicted in figure  [ fig : slant ] .",
    "( 50,50 ) setunit 3 mm ; qubits(5 ) ; dropwire(2 ) ;    wires(unit ) ; label(btex @xmath73 etex , ( qcxcoord , qcycoord[1]+14 mm ) ) ; circuit(3*qcheight)(gpos 0,1,2,3,btex @xmath117 etex ) ; label(btex @xmath73 etex , ( qcxcoord , qcycoord[1]+14 mm ) ) ; wires(unit ) ; qubits(5 ) ;",
    "label(btex @xmath61 etex,(qcxcoord+1/2qcstepsize , qcycoord[2 ] ) ) ; qcxcoord : = qcxcoord + qcstepsize ; dropwire(2 ) ; wires(unit ) ; label(btex @xmath73 etex , ( qcxcoord , qcycoord[1]+14 mm ) ) ; circuit(2.5*qcheight)(gpos 0,1,2,btex @xmath143 etex ) ; label(btex @xmath73 etex , ( qcxcoord , qcycoord[1]+14 mm ) ) ; wires(unit ) ; xsave : = qcxcoord ; gate(icnd 3 , ocnd 1,2 , gpos 0,btex @xmath32 etex ) ; gate(gpos 3 , btex @xmath35 etex ) ; gate(icnd 3 , ocnd 1,2 , gpos 0 , btex @xmath139 etex ) ; gate(icnd 0 , ocnd 1,2 , gpos 3 , `` not '' ) ; gate(icnd 3 , ocnd 1,2 , gpos 0 , `` not '' ) ; gate(icnd 0 , ocnd 1,2 , gpos 3 , `` not '' ) ; wires(unit ) ;    qubits(5 ) ; path rec ; rec : = ( xsave , qcycoord[1]+2unit)(xsave+6qcstepsize , qcycoord[1]+2unit)(xsave+6qcstepsize , qcycoord[3]-2unit)(xsave , qcycoord[3]-2unit)cycle ; fill rec withcolor white ; draw rec withcolor white ; label(btex @xmath73 etex,(xsave+1/2qcstepsize , qcycoord[1]+14 mm ) ) ; label(btex @xmath73 etex,(xsave+5/2qcstepsize , qcycoord[1]+14 mm ) ) ; label(btex @xmath73 etex,(xsave+7/2qcstepsize , qcycoord[1]+14 mm ) ) ; label(btex @xmath73 etex,(xsave+9/2qcstepsize , qcycoord[1]+14 mm ) ) ; label(btex @xmath73 etex,(xsave+11/2qcstepsize , qcycoord[1]+14 mm ) ) ;    the slant transform of length @xmath120 can be realized on a quantum computer with at most @xmath0 elementary operations ( that is , controlled not gates and single qubit gates ) , assuming that additional workbits are available .",
    "recall that a multiply controlled gate can be expressed with at most @xmath64 elementary operations as long as additional workbits are available.@xcite it follows from the lemma in section  3 that at most @xmath0 elementary operations are needed to implement the slant transform .",
    "the discrete hartley transform @xmath147 is defined for signals of length @xmath6 by the matrix @xmath148 the discrete hartley transform is very popular in classical signal processing , since it requires only real arithmetic but has similar properties . in particular , there are classical algorithms available , which outperform the fastest fourier transform algorithms .",
    "we derive a fast quantum algorithm for this transform , again based on a recursive divide - and - conquer algorithm . a fast algorithm for",
    "the discrete hartley transform based on a completely different approach has been discussed by klappenecker and rtteler@xcite .",
    "the hartley transform can be recursively represented as@xcite @xmath149 where @xmath124 is the permutation @xmath150 , with @xmath15 a single bit , separating the even indexed samples and the odd indexed samples ; for instance , @xmath151 .",
    "the matrix @xmath152 is given by @xmath153 the equation ( [ eq : hartley ] ) leads to the implementation sketched in figure  [ fig : hartley ] .",
    "( 50,50 )    setunit 1.5 mm ; qubits(5 ) ; dropwire(1,2 ) ; wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; circuit(2qcheight)(gpos 0,1,2 , btex @xmath154 etex ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; wires(2 mm ) ; label(btex @xmath61 etex , ( qcxcoord+1/2qcstepsize , qcycoord[0]+2qcheight ) ) ; qcxcoord : = qcxcoord + qcstepsize ;    qubits(5 ) ; dropwire(2,3 ) ; wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[1]+10 mm ) ) ; draw ( qcxcoord , qcycoord[0])(qcxcoord+qcstepsize , qcycoord[2 ] ) ; draw ( qcxcoord , qcycoord[0]+qcheight)(qcxcoord+qcstepsize , qcycoord[0 ] ) ; draw ( qcxcoord , qcycoord[2])(qcxcoord+qcstepsize , qcycoord[2]-qcheight ) ; qcxcoord : = qcxcoord + qcstepsize ; qubits(5 ) ; dropwire(1,2 ) ; wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; circuit(2qcheight)(gpos 0,1 , btex @xmath155 etex ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; circuit(2qcheight)(icnd 2 , gpos 0,1 , btex @xmath152 etex ) ; label(btex",
    "@xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; gate(gpos 2,btex @xmath35 etex ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+10 mm ) ) ; wires(2 mm ) ;    it remains to describe the implementation of @xmath152 .",
    "it will be instructive to detail the action of the matrix @xmath152 on a state vector of @xmath92 qubits .",
    "we will need a few notations first .",
    "denote by @xmath156 a state vector of @xmath92 qubits , where @xmath15 denotes a single bit and @xmath91 an @xmath157 bit integer .",
    "we denote by @xmath158 the two s complement of @xmath91 .",
    "we mean by @xmath159 the number @xmath160 and by @xmath161 the number @xmath162 , that is , @xmath161 has all bits set and @xmath163 has no bit set .",
    "then the action of @xmath152 on @xmath156 is given by @xmath164 where @xmath165 and @xmath166 .",
    "( 50,50 ) setunit 1.8 mm ; qubits(5 ) ; dropwire(1,2 ) ; wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+12 mm ) ) ; circuit(2qcheight)(gpos 0,1,2 , btex @xmath152 etex ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+12 mm ) ) ; wires(2 mm ) ; label(btex @xmath61 etex , ( qcxcoord+1/2qcstepsize , qcycoord[0]+1.5qcheight ) ) ; qcxcoord : = qcxcoord + qcstepsize ;    wires(2 mm ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+12 mm ) ) ; circuit(2qcheight)(icnd 2 , gpos 0,1 , btex @xmath167 etex ) ; label(btex",
    "@xmath73 etex,(qcxcoord , qcycoord[0]+12 mm ) ) ; gate(gpos 2,btex @xmath32 etex ) ; gate(ocnd 0,1 , gpos 2 , btex @xmath32 etex ) ;    path rec ; rec : = ( qcxcoord-2/3qcstepsize , qcycoord[0]+2 mm ) (qcxcoord-1/3qcstepsize , qcycoord[0]+2 mm ) (qcxcoord-1/3qcstepsize , qcycoord[1]-2 mm ) (qcxcoord-2/3qcstepsize , qcycoord[1]-2mm)cycle ; fill rec withcolor white ; draw rec withcolor white ; draw ( qcxcoord-1/2qcstepsize , qcycoord[0]+2mm)(qcxcoord-1/2qcstepsize , qcycoord[1]-2 mm ) dashed withdots scaled 1/2 ; gate(icnd 1 , gpos 2 , btex @xmath168 etex ) ; draw ( qcxcoord , qcycoord[0 ] ) (qcxcoord+1/2qcstepsize , qcycoord[0 ] ) dashed withdots scaled 1/2 ; draw ( qcxcoord , qcycoord[1 ] ) (qcxcoord+1/2qcstepsize , qcycoord[1 ] ) dashed withdots scaled 1/2 ; draw ( qcxcoord , qcycoord[2 ] ) (qcxcoord+1/2qcstepsize , qcycoord[2 ] ) dashed withdots scaled 1/2 ; qcxcoord : = qcxcoord + 1/2qcstepsize ; gate(icnd 0 , gpos 2 , btex @xmath169 etex ) ; label(btex",
    "@xmath73 etex,(qcxcoord , qcycoord[0]+12 mm ) ) ; circuit(2qcheight)(icnd 2 , gpos 0,1 , btex @xmath167 etex ) ; label(btex @xmath73 etex,(qcxcoord , qcycoord[0]+12 mm ) ) ; wires(2 mm ) ;    we are now in the position to describe the implementation of @xmath152 shown in figure  [ fig : bc ] . in the first step ,",
    "the least @xmath157 qubits are conditionally mapped to their two s complement .",
    "more precisely , the input signal @xmath156 is mapped to @xmath170 if @xmath171 , and does not change otherwise .",
    "thus , the circuit @xmath167 implements the involutary permutation corresponding to the two s complement operation .",
    "this can be done with @xmath172 elementary gates , provided that sufficient workspace is available.@xcite in the next step , a sign change is done if @xmath171 , that is , @xmath173 , unless the input @xmath91 was equal to zero , @xmath174 .",
    "the next step is a conditioned cascade of rotations .",
    "the least significant bits determine the angle of the rotation on the ( @xmath92st ) most significant qubit .",
    "the @xmath68th qubits exerts a rotation , @xmath175 on the most significant qubit .",
    "finally , another two s complement circuit is conditionally applied to the state .",
    "one readily checks that the implementation indeed maps @xmath176 to @xmath177 and @xmath178 to @xmath179 .",
    "the input @xmath180 is mapped to @xmath181 , as desired .",
    "assume that the input is @xmath182 with @xmath183 .",
    "then the state is changed to @xmath184 by the circuit @xmath167 , and after that its sign is changed , which yields @xmath185 .",
    "the rotations map this state to @xmath186 .",
    "the final conditional two s complement operation yields the state @xmath187 , which is exactly what we want .",
    "the inital permutation , the circuit @xmath152 and the hadamard gate in figure  [ fig : hartley ] can be implemented with @xmath188 elementary gates .",
    "it is crucial that additional workbits are available , otherwise the complexity will increase to @xmath189 the lemma in section  3 then completes the proof of the following theorem :    there exists a recursive implementation of the discrete hadamard transform @xmath147 on a quantum computer with @xmath0 elementary gates ( that is , controlled not gates and single qubit gates ) , assuming that additional workbits are available .",
    "we have presented a new approach to the design of quantum algorithms .",
    "the method takes advantage of an divide - and - conquer approach .",
    "we have illustrated the method in the design of quantum algorithms for the fourier , walsh , slant , and hartley transforms .",
    "the same method can be applied to derive fast algorithms for various discrete cosine transforms .",
    "it might seem surprising that divide - and - conquer methods have not been previously suggested in quantum computing ( to the best of our knowledge ) .",
    "one reason might be that the quantum circuit model implements only straight - line programs .",
    "we defined recursions on top of that model , similar to macro expansions in many classical programming languages .",
    "the benefit is that many circuits can be specified in a very lucid way .",
    "it should be emphasized that our divide - and - conquer approach is completely general .",
    "it can be applied to a much larger class of circuits , and is of course not restricted to signal processing applications . moreover",
    ", it should be emphasized that many variations of this method are possible .",
    "we would like to encourage the reader to work out a few examples  quite often this is a simple exercise .",
    "d.  r. simon , `` on the power of quantum computation , '' in _ proceedings of the 35th annual symposium on foundations of computer science _ , pp .  116123 , ieee computer society press , ( los alamitos , ca ) , 1994 .",
    "a.  klappenecker and m.  rtteler , `` on the irresistible efficieny of signal processing methods in quantum computing , '' in _ proceedings of first international workshop on spectral techniques and logic design for future digital systems , tampere , finland , june 2 - 3 , 2000 _ , r.  creutzburg and k.  egiazarian , eds . , _ ticsp _ * 10 * , pp .",
    "483497 , ttkk , ( monistamo ) , 2000 ."
  ],
  "abstract_text": [
    "<S> a quantum computer directly manipulates information stored in the state of quantum mechanical systems . </S>",
    "<S> the available operations have many attractive features but also underly severe restrictions , which complicate the design of quantum algorithms . </S>",
    "<S> we present a divide - and - conquer approach to the design of various quantum algorithms . </S>",
    "<S> the class of algorithm includes many transforms which are well - known in classical signal processing applications . </S>",
    "<S> we show how fast quantum algorithms can be derived for the discrete fourier transform , the walsh - hadamard transform , the slant transform , and the hartley transform . </S>",
    "<S> all these algorithms use at most @xmath0 operations to transform a state vector of a quantum computer of length  @xmath1 . </S>"
  ]
}