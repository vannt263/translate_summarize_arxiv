{
  "article_text": [
    "rbo  @xcite is a simple and efficient method of periodic broadcasting of a large sequence of uniform radio messages for radio receivers with a limited source of energy .",
    "examples of such receivers are battery powered sensors or portable devices . in modern devices ,",
    "the receiver can save the energy by keeping it s radio device switched off for long periods of time .",
    "the broadcaster transmits in a round robin fashion a large sequence of frames .",
    "such sequence is called a _",
    "broadcast cycle_. each frame is of the same length ( we call it a _ time slot _ ) and contains in its header a _",
    "key _ from an arbitrary linearly ordered universe of key values .",
    "the receiver may decide at arbitrary time ( usually somewhere in the middle of the broadcast cycle ) to locate and receive all the frames  in the stream that  contain the keys from some specified range @xmath2 $ ] .",
    "the receiver may _ wake - up _ ( switch on its radio ) at arbitrary time slot to receive the transmitted frame . however , the radio consumes energy while it is switched on .",
    "we want to minimize the energy dissipated by the receiver , i.e. to minimize the number of the wake - ups . in rbo ,",
    "the receiver is able to receive all the requested frames transmitted since that moment . roughly speaking : the receiver listens to some keys of the broadcast cycle and learns the interval of positions in the sorted sequence with the keys in @xmath10 $ ] .",
    "after that , it only listens in the time slots that contain the keys from these positions .",
    "rbo requires that the length of the broadcast cycle is an integer power of two .",
    "this can be achieved by duplicating some of the frames .",
    "if @xmath11 denotes the number of frames that must be transmitted , then the length of the broadcast cycle is @xmath0 , where for integer @xmath1 , @xmath12 .",
    "we assume that the length of each frame is the same , i.e. a single time slot .",
    "however , the same key may be repeated many times in the broadcast cycle .",
    "thus , as single long information attributed with some key can be split among many frames with the same key .",
    "we can also repeat many times , the frames that that should be delivered more frequently to the receivers .",
    "( the frames with the same key are scattered uniformly over the transmission cycle ) .",
    "the keys may be arbitrary values from arbitrary linearly ordered domain .",
    "the receiver does not have any knowledge of the distribution of the keys in the cycle .",
    "rbo is energetically efficient for the receiver ( section  [ section - analysis ] ) , robust to the radio interferences ( section  [ section - unreliable ] ) , and its implementation is very simple and efficient and requires little memory ( section  [ section - implementation ] ) , thus it is suitable even for very weak sensor devices ( see e.g. @xcite ) .",
    "this report updates  @xcite as follows :    new , simpler proof of the main theorem ( theorem  [ first - hit - theorem ] ) is based on a simpler decomposition of the time - slots sequence .",
    "we focus on the application of the rbo to filtering the frames with the keys from specified interval @xmath2 $ ] . in corollary  [ corollary - ee ]",
    "we show that the receiver has to listen to no more than @xmath4 frames with keys outside @xmath2 $ ] , to learn which are the time - slots of the frames with keys in @xmath13 $ ] .",
    "the expected energetic costs for the receiver in unreliable network has been estimated in section  [ section - unreliable ] .",
    "a simpler and more efficient algorithm for computing the next wake - up time slot has been proposed in  section  [ section - implementation ] .",
    "the protocol can be applied to the dissemination of information or to centralized controlling or synchronizing of large populations of energy constrained devices .",
    "some examples are following :    * the keys may be identifiers of records from a huge database transmitted in the stream .",
    "* the keys may be identifiers of the receiver .",
    "the broadcaster may send commands or messages to individual receivers .",
    "* the keys may be identifiers of groups of mutually non - interfering sensors .",
    "each frame with such key would contain only the header , while the rest of the time slot can be used for transmission by the sensors from this group .",
    "* the keys may be coordinates of the objects on the plane encoded by morton z - ordering @xcite .",
    "in such ordering the receiver may limit an approximately square region containing the objects that are interesting to him .",
    "diverse applications could be mixed within a single stream of frames by assigning to them disjoint intervals of key values . the sorted sequence of keys is permuted by bit - reversal permutation ,  which scatters the keys from each interval uniformly over the whole stream .",
    "broadcast scheduling for radio receivers with low _ access time _",
    "( i.e. the delay to the reception of the required record ) and low average _ tuning time _",
    "( i.e. the energetic cost ) was considered by imielinski , viswanathan , and badrinath ( see e.g. @xcite , @xcite , @xcite ) . in @xcite , _ hashing _ and _ flexible indexing _ for finding single records in broadcast cycle have been proposed and compared . in @xcite ,",
    "a distributed index based on a ordered balanced tree has been proposed .",
    "the broadcast sequence consists of two kinds of _",
    "buckets_. groups of _ index buckets _ , containing parts of the index tree , are interleaved with the groups of _ data buckets _ containing proper data and a pointer ( i.e. time offset ) to the next index bucket .",
    "each group of index buckets consists of the copy of upper part of the index tree  together with the relevant fragment of the lower part of the tree .",
    "this mechanism has found useful application even in more complex scenarios of delivering data to mobile users @xcite .",
    "khanna and zhou @xcite proposed a sophisticated version of the index tree aimed at minimizing _",
    "mean _ access and tuning time , for given probability of each data record being requested .",
    "the broadcast cycle contains multiple copies of data items , so that spacing between copies of each item is related to the optimal spacing , minimizing mean access time derived in @xcite .",
    "however the keys are not arbitrary .",
    "the  key of the item is determined by its probability of being requested .",
    "indexing of broadcast stream for  xml documents @xcite or for full text search @xcite have also been considered .",
    "if the broadcast cycle contains indexing tree structure , then  the reception of data in current broadcast cycle depends on the successful reception of the path to this data . instead of separate index buckets",
    "rbo uses short _",
    "headers _ of the frames .",
    "each such header contains the key assigned to the frame . as a consequence ,",
    "in unreliable network the receiver has much more chances of efficient navigation towards the desired frames .    in practical applications , due to imperfect synchronization between the broadcaster and the receiver",
    ",  the header should also contain either  the time - slot number or its bit reversal  the index of the frame . to enable changing the contents and the length of the sequence of the transmitted keys by the broadcaster",
    ", the header may also include the parameter @xmath1 , such that @xmath14 is the length of the broadcast cycle , and some bits used to notify the receiver that the that the sequence of keys has been changed .",
    "for rbo , these issues have been discussed in  @xcite .",
    "recall that each step of the classic _ binary search _",
    "algorithm actually clips the interval of the possible locations of the searched key in the sorted sequence of keys .",
    "the customary presentation is that the keys of the sequence are organized in a balanced _ binary search tree _ , and the searched key",
    "is compared with a sequence of keys from subsequent levels of this tree .",
    "bit - reversal permutes the sorted sequence of keys so that the broadcast cycle is a sequence of the subsequent levels of a balanced binary search tree for the keys .",
    "moreover , each level is recursively so permuted .",
    "we show that it enables efficient search in the periodic transmission of the broadcast cycle even if the search is started at arbitrary time slot .",
    "we also exploit this property in the computation of the next time slot that should be listened by the receiver .",
    "bit - reversal permutation has been found useful  in many contexts .",
    "some examples of its applications are in fft algorithm @xcite @xcite , lock - free extensible hash arrays @xcite distributed arrays in p2p @xcite , address mapping in sdram @xcite , scattering of video bursts in transmission scheduling in mobile tv @xcite . in rbo ,",
    "bit - reversal emerged from updating the recursive definition of the @xmath15 permutation used in the underlying ranking procedure in @xcite in such a way that zero became a fixed point .",
    "the simplicity of bit - reversal computation is a great advantage for practical implementations .",
    "let @xmath16 denote the set of integers .",
    "let @xmath17 denote the set of real numbers . for simplicity and generality , we assume that the keys are from @xmath17 . by",
    "@xmath18 $ ] we denote the interval of real numbers @xmath19 . if @xmath20 then @xmath18 = \\emptyset$ ] . by @xmath21",
    "$ ] we denote we denote @xmath18 \\cap \\mathbbm{z}$ ] ( i.e. interval of integers between @xmath22 and @xmath23 ) . for a set @xmath24",
    ", we denote the number of its elements by @xmath25 .    for @xmath26 , @xmath27 , for @xmath28",
    ", let @xmath29 be the @xmath30th least significant bit of the binary representation of @xmath31 , i.e. @xmath32 . for @xmath33 , a number with binary representation @xmath34 is denoted by @xmath35 , i.e. @xmath36 .",
    "for @xmath37 $ ] let @xmath38 denote the _ bit - reversal _ of @xmath31 , i.e : if @xmath39 then @xmath40  and @xmath41 .    for a set @xmath42 $ ] , @xmath43 denotes the _ image _ of @xmath24 under @xmath44 , i.e @xmath45 .",
    "let @xmath46 denote the length of the broadcast cycle , @xmath0 ,  for integer @xmath47 .",
    "let @xmath48 be a sequence defined as follows :    @xmath49    @xmath50    @xmath51 is a sorted sequence of @xmath46 finite real values of the keys ( i.e. @xmath52 , for   @xmath53 ) .",
    "let @xmath54 ( the set of the values of the keys in the sequence ) .",
    "let @xmath7 and @xmath8 be finite real key values such that @xmath55 . @xmath2 $ ] is the _ interval of the searched keys_.    @xmath56 $ ] denotes expected value of random variable @xmath57 .",
    "the broadcaster at time - slot @xmath58 broadcasts the frame with the key @xmath59 .",
    "the receiver searching for the @xmath2 $ ] has two variables @xmath60 and @xmath61 initialized to @xmath62 and  @xmath63 , respectively .",
    "the receiver may start at arbitrary time slot @xmath64 , and executes the following algorithm :    * while @xmath65 : * * in time - slot @xmath58 if @xmath66 , then the receiver receives the message with the key @xmath67 and * * * if @xmath68 then it sets @xmath60 to @xmath69 , else * * * if @xmath70 then it sets @xmath61 to @xmath71 , else * * * if @xmath72 then it reports reception of the key @xmath73 from @xmath2 $ ] * * if @xmath74 then the receiver reports that @xmath75 \\cap { \\ensuremath{\\operatorname{keys } } } = \\emptyset$ ]    in the above description we used _",
    "broadcaster time slot numbers_. by _ receiver time _ we mean the number of time slots that elapsed since the start of the receiver s protocol .",
    "thus , just before the time slot @xmath64 the receiver time is zero , just after time slot @xmath64 the receiver time is one , an so on .",
    "however , the receiver knows the broadcaster time modulo @xmath46 ( this information may be included in the frame header ) and uses it it to compute the timer  waking - up the radio for next reception of the frame .      in the analysis of the receiver s protocol ( section  [ section - analysis ] )",
    ", we split the sequence of the time slots following the starting slot @xmath64 into segments @xmath76 .",
    "the set @xmath77 is the set of indexes of the elements transmitted during time slots @xmath76 .",
    "we show that the `` density '' of initially transmitted indexes bounds the length of @xmath78 $ ] and the `` sparsity '' of the set of indexes of the next segment bounds the number of needed receptions .",
    "finally we sum up the bounds on receptions in all segments . in section  [ section - implementation ] , we use this decomposition and also the binary search tree on the elements of @xmath79 embedded on the graph of the permutation @xmath44 , for efficient computation of the wake - up timer .    for the starting time slot @xmath80 $ ] , for @xmath28 , let @xmath81 and @xmath82 be defined as follows :    * @xmath83 and  @xmath84 . * for @xmath85 @xmath86  and",
    "@xmath87    @xmath82 is the maximal length of of the suffix of the zero bits in binary representation of @xmath88 .",
    "@xmath89 is the next time slot after @xmath88 ( modulo @xmath46 ) , that has longer such suffix .",
    "note that @xmath90 is a ( possibly empty ) increasing sequence of some integers from @xmath91 $ ] followed by infinite sequence of zeroes .",
    "let @xmath92 .",
    "note that @xmath93 is an increasing sequence of integers from @xmath94 $ ] . for @xmath95 , let @xmath96 $ ] and",
    "let @xmath97 $ ] .",
    "for @xmath98 let @xmath99 .",
    "[ x_i - lemma ]  @xmath100\\}$ ] and @xmath101 .",
    "let @xmath102 , let @xmath103 .",
    "then  @xmath76  is the set of all numbers @xmath104 such that @xmath105 .",
    "thus @xmath106 is the set of all numbers @xmath107 such that @xmath108 .",
    "note that @xmath109 , where @xmath110 .",
    "thus @xmath111 .",
    "this completes the proof of lemma  [ x_i - lemma ] .    for @xmath112 , for @xmath113 ,",
    "let @xmath114 $ ] .",
    "note that @xmath76 is a disjoint union of the sets @xmath115 , for @xmath113 .",
    "for @xmath116 , for @xmath117 , let @xmath118 .",
    "[ x_il - lemma ] for @xmath119 $ ] ,  @xmath120\\}$ ] and @xmath121 .    if @xmath122 , then @xmath123 and ,  @xmath124 and @xmath125 .",
    "consider the case : @xmath126 .",
    "@xmath127 $ ] .",
    "since @xmath128 and @xmath129 , we have @xmath130 and @xmath131 is the set of all numbers @xmath132 such that @xmath133 and @xmath105 .",
    "thus @xmath134 and @xmath135 is the set of all numbers @xmath136 such that @xmath137 and @xmath138 .",
    "[ union - x - lemma]@xmath139\\}$ ] and @xmath111 .",
    "@xmath140)$ ] . since @xmath141",
    ", the proof follows as in the previous lemmas .",
    "let @xmath142 and @xmath143 be defined as follows :    @xmath144 | \\kappa ' \\leq \\kappa_r \\}$ ] , and    @xmath145 | \\kappa_r \\leq \\kappa '' \\}$ ] .    for each @xmath146",
    "$ ] ,  @xmath147 $ ] . if @xmath10 \\cap { \\ensuremath{\\operatorname{keys } } } = \\emptyset$ ] then , for some @xmath148 $ ] , @xmath149 and @xmath150 , and @xmath151 and @xmath152 .",
    "if @xmath2 \\cap { \\ensuremath{\\operatorname{keys } } } \\not=   \\emptyset$ ] then , since @xmath153 , we have  @xmath154 .",
    "let @xmath64 be the first time slot of the receiver s protocol .",
    "we assume w.l.o.g .",
    "that @xmath155 $ ] . for @xmath156",
    ": let @xmath157 and @xmath158 be the values of the variables @xmath60 and @xmath61 , respectively , at receiver time @xmath58 .",
    "( thus @xmath159 and @xmath160 . )",
    "let @xmath161 .",
    "let @xmath162 if @xmath163 and @xmath164 otherwise .",
    "( @xmath162 if the receiver wakes - up the radio at receiver time @xmath58 . )",
    "let @xmath165 if @xmath166 and @xmath167 otherwise .",
    "( @xmath168 if the requested frame is received at receiver time @xmath58 . )",
    "the _ energy _ used in the initial @xmath58 time slots is @xmath169 .",
    "the _ extra energy _ is the energy used for the reception of messages with the keys outside @xmath10 $ ] : @xmath170 .",
    "let  @xmath171\\}$ ] .",
    "@xmath172  is the set of the broadcaster time - slot numbers modulo @xmath46 of the receiver s initial @xmath58 slots .",
    "let @xmath173 .",
    "note that @xmath174 .",
    "history of the lower ( respectively , upper ) bounds up to time @xmath58 for @xmath2 $ ] _ is the sequence  @xmath175 ( respectively , @xmath176 ) .",
    "let @xmath177 .",
    "note that @xmath178 is the time until the first hit or noticing that @xmath2 \\cap { \\ensuremath{\\operatorname{keys } } } = \\emptyset$ ] . by the _ first receiver cycle _ we mean the first @xmath46 slots of the receiver time .  for @xmath179 $ ] ,",
    "let @xmath180 denote the receiver time just before the transmission of the broadcast time slot @xmath181 , in the first receiver cycle , i.e. @xmath182 .",
    "note that , since @xmath183 $ ] , we have @xmath184 .",
    "[ first - hit - theorem]we have @xmath184 and @xmath185 .",
    "we prove lemmas  [ clipped - lemma ] , [ first - tree - lemma ] , [ next - tree - lemma ] , [ total - lemma ] , to show the theorem in the case @xmath2 \\cap { \\ensuremath{\\operatorname{keys } } } = \\emptyset$ ] , and then conclude  the general case .",
    "[ clipped - lemma ] if @xmath2 \\cap { \\ensuremath{\\operatorname{keys } } } =      \\emptyset$ ] , then , for @xmath156 ,  @xmath186      \\subseteq [ [ 0 , n - 1 ] ] \\setminus { \\ensuremath{\\operatorname{hx}}}_t $ ] .",
    "note that the lemma follows directly from the algorithm : @xmath159 , @xmath160 , and , since @xmath2 \\cap { \\ensuremath{\\operatorname{keys } } } = \\emptyset$ ] , for each @xmath187 , either @xmath188 or @xmath189 .",
    "since @xmath1 and @xmath64 are fixed , we use the following notation : @xmath190 , @xmath191 , @xmath192 , @xmath193 , @xmath194 , @xmath195 , and @xmath196 .",
    "[ first - tree - lemma ] if @xmath2 \\cap { \\ensuremath{\\operatorname{keys } } } =      \\emptyset$ ] , then @xmath197 .",
    "since @xmath198 , and only the first time slot congruent modulo @xmath46 to @xmath199 is used , we have @xmath200 .",
    "[ next - tree - lemma ] if @xmath2 \\cap { \\ensuremath{\\operatorname{keys } } } =      \\emptyset$ ] , then , for @xmath215 , @xmath216 .",
    "let @xmath217 .",
    "by lemma  [ clipped - lemma ] , @xmath218 \\subseteq      [ [ 0 , n - 1 ] ] \\setminus { \\ensuremath{\\operatorname{hx}}}_{t''}$ ] .",
    "we have @xmath219 , and , by lemma  [ x_i - lemma ] , @xmath220 contains _ all _ the integers from @xmath205 $ ]  congruent modulo @xmath221 to @xmath222 . thus , @xmath223 . by lemma  [ union - x - lemma ] , @xmath224 contains _ only _ the integers from @xmath205 $ ]  congruent modulo @xmath225 to @xmath226 . hence , we have @xmath227 | \\leq 1 $ ] , and @xmath228 .",
    "thus @xmath239 and the lemma follows .",
    "[ total - lemma ] if @xmath2 \\cap { \\ensuremath{\\operatorname{keys } } } = \\emptyset$ ] , then @xmath240 .",
    "@xmath205 = \\bigcup_{i = 0}^{{\\ensuremath{\\operatorname{last } } } }      y_i$ ] , and @xmath241 @xmath242 .",
    "thus , by lemma  [ first - tree - lemma ] and lemma  [ next - tree - lemma ] , @xmath243 . since @xmath244 is increasing sequence of values from @xmath94 $ ] , we have @xmath245 and @xmath246 .    in lemma",
    "[ total - lemma ] we assumed that @xmath2 \\cap    { \\ensuremath{\\operatorname{keys } } } = \\emptyset$ ] .",
    "note that we have :    * @xmath247 , and * @xmath248  ( since @xmath167 , for @xmath249 ) ,  and * @xmath250 = \\emptyset$ ] .    since @xmath251 \\cap { \\ensuremath{\\operatorname{keys}}}$ ] is finite",
    ", we can choose real number @xmath252 such that @xmath253 and @xmath254 .",
    "since @xmath255 , the respective histories of the bounds up to the time @xmath178 for @xmath2 $ ] and @xmath256 $ ] are identical :    * @xmath257 , and * @xmath258 .",
    "note that , since @xmath259 , the energy needed to notice that @xmath256\\cap { \\ensuremath{\\operatorname{keys } } } = \\emptyset$ ] is at least @xmath260 .",
    "therefore , by lemma  [ total - lemma ] , @xmath261 . we conclude that @xmath261 also when @xmath2    \\cap { \\ensuremath{\\operatorname{keys } } } \\not=   \\emptyset$ ] .",
    "[ corollary - ee]for arbitrary @xmath262 , @xmath263 .",
    "if @xmath2 \\cap { \\ensuremath{\\operatorname{keys } } } =    \\emptyset$ ] , then @xmath264 and , by theorem  [ first - hit - theorem ] , @xmath261 .    consider the case @xmath2 \\cap { \\ensuremath{\\operatorname{keys } } } \\not=   \\emptyset$ ] .",
    "then @xmath265 . let @xmath266 and @xmath267 be such that @xmath268 and @xmath269 .",
    "then , for arbitrary @xmath156 , @xmath270 and @xmath271 .",
    "any reception of the key that is outside @xmath2 $ ] updates either the lower or the upper bound : for @xmath262 , @xmath162 and @xmath167 if and only if either @xmath272 or @xmath273 .",
    "thus @xmath274 is equal to the total number of changes in both @xmath275 and @xmath276 . since @xmath277 \\cap { \\ensuremath{\\operatorname{keys } } } = \\emptyset$ ] , the number of changes in @xmath278 is not greater than @xmath3 .",
    "similarly , the number of changes in @xmath279 is not greater than @xmath3 .",
    "consider a model of the network , where the probability of successful reception is @xmath6 , @xmath280 .",
    "thus the receiver may wake up to listen in some time slot , and still fail to receive the frame with probability @xmath281 .",
    "thus the unit of energy used for the wake - up is lost .",
    "we state that in the case of reception  failure , the receiver s protocol leaves its variables @xmath60 and @xmath61 unchanged and waits for the next time slot from @xmath282 $ ] .",
    "we split the wake - ups of the receiver into _ hits _  the wake - ups in the time slots from @xmath283 $ ] ,  and _ misses _  the remaining wake - ups .",
    "the hits are unavoidable : the requested keys are transmitted during the hits .",
    "the penalty for unreliability here is that the reception rate drops from @xmath284 to @xmath6  which is the highest possible in this model .",
    "another penalty is the increase in the number of the misses .",
    "we show the bound on the number of the misses in unreliable network .",
    "recall that the first wake up of the protocol is in time slot @xmath64 . for @xmath156 ,",
    "let @xmath285 be true if the transmission in the @xmath58th receiver s time slot is successful , and false  otherwise .",
    "[ lemma - expected - trailer]the expected number of misses after the first receiver cycle ( i.e. after the initial @xmath46 time slots ) is not greater than @xmath286 .",
    "the misses in the cycle following the first cycle are the wake - ups during the time slots in @xmath287 \\cup [ [ r '' + 1 ,    { \\ensuremath{\\operatorname{ub}}}_n]])$ ] .",
    "the values of @xmath288 and @xmath289 are the following  random variables :    * @xmath290 \\;|\\ ;      { \\ensuremath{\\operatorname{success } } } ( { \\ensuremath{\\operatorname{tt } } } ( { \\ensuremath{\\operatorname{rev}}}_k ( i))\\}$ ] * @xmath291 \\;|\\ ;      { \\ensuremath{\\operatorname{success } } } ( { \\ensuremath{\\operatorname{tt } } } ( { \\ensuremath{\\operatorname{rev}}}_k ( i))\\}$ ]    each of @xmath292 and @xmath293 can be bound by a random variable with geometric distribution ( see e.g. @xcite ) and expected value @xmath294 . hence ,  @xmath295 , e [ { \\ensuremath{\\operatorname{ub}}}_n - r'']\\ } \\leq 1 / p - 1 = 1 / ( 1 - q ) - 1 $ ] .    after the @xmath296th cycle , for @xmath297 , each position has been tested @xmath296 times .",
    "thus @xmath298 , e [ { \\ensuremath{\\operatorname{ub}}}_{j \\cdot n }    - r'']\\ } \\leq 1 / ( 1 - q^j ) - 1 $ ] and the expected number of misses in the @xmath299st cycle is not greater than @xmath300 .",
    "finally , note that @xmath301 .",
    "the more complex task is to bound the number of misses during  the first cycle .",
    "[ lemma - expected - init]if @xmath302 =    \\emptyset$ ] , then the expected number of wake - ups ( all of them are misses ) during the first cycle is not greater than @xmath303 .    since @xmath302 = \\emptyset$ ]",
    ", we have @xmath304 .",
    "let us use the notation from the proof of theorem  [ first - hit - theorem ] .",
    "first consider the time - slots in  @xmath305 .",
    "there is one wake - up in @xmath306 .",
    "for each  @xmath307 ,  @xmath308 .  hence , by lemma  [ union - x - lemma ] ,    * @xmath309 \\;|\\ ; ( i - { \\ensuremath{\\operatorname{rev}}}_k ( t_0 ) )    { \\ensuremath{\\operatorname{mod } } } 2^{k - l } = 0 \\wedge { \\ensuremath{\\operatorname{success } } } ( { \\ensuremath{\\operatorname{tt } } } ( { \\ensuremath{\\operatorname{rev}}}_k    ( i)))\\}$ ] , and * @xmath310 \\;|\\ ; ( i - { \\ensuremath{\\operatorname{rev}}}_k ( t_0 ) ) { \\ensuremath{\\operatorname{mod } } } 2^{k -    l } = 0 \\wedge { \\ensuremath{\\operatorname{success } } } ( { \\ensuremath{\\operatorname{tt } } } ( { \\ensuremath{\\operatorname{rev}}}_k ( i)))\\}$ ] .",
    "now consider @xmath321 , for @xmath322 $ ] .",
    "since @xmath323 and , by lemma  [ x_i - lemma ] , @xmath220 contains all integers congruent modulo @xmath225 to @xmath324 and , by lemma  [ union - x - lemma ] , @xmath325 , contains only integers congruent modulo @xmath225 to @xmath326 , the expected number of wake - ups in @xmath327 can be bound , as above , by @xmath319 .    for each @xmath328 $ ] , we use @xmath329 , to bound the expected number of wake - ups in @xmath330 by @xmath319 .",
    "thus the expected number of wake - ups in @xmath321 is not greater than @xmath331 .    summing up , as in the proof of lemma  [ total - lemma ] , the expected number of wake - ups during the first cycle is at most @xmath332 .",
    "[ theorem - expected]the expected number of misses during the infinite execution of the protocol is not greater than @xmath333 .",
    "if @xmath302 = \\emptyset$ ] , then the theorem follows directly from lemmas  [ lemma - expected - trailer ] and [ lemma - expected - init ] .",
    "consider the case @xmath302",
    "\\not=   \\emptyset$ ] . as in  corollary",
    "[ corollary - ee ] , let @xmath266 and @xmath267 be key values such that @xmath268 and @xmath334 .",
    "let @xmath335 denotes the expected number of misses in the first cycle when the protocol is started for interval @xmath256 $ ] .",
    "by lemma  [ lemma - expected - trailer ] , @xmath336 .",
    "the expected number of misses during the first cycle of the protocol for @xmath75 $ ] is the sum of the expected number of misses on both sides of @xmath337 $ ] which is not greater than @xmath338 .",
    "we present an efficient algorithm for computing the time slot of the reception of the next frame required by the protocol .",
    "the efficiency of this algorithm is based on the observation that elements of @xmath77 are organized by @xmath44 into subsequent levels of an almost balanced binary search tree .      for @xmath339 , for any sequence @xmath340 ,",
    "let a _ descendant",
    "_ of @xmath31 by path @xmath341 be defined as @xmath342 .",
    "note that @xmath343 .",
    "note that @xmath344 .",
    "level at depth @xmath345 rooted at @xmath31 _ be defined as @xmath346 .",
    "sub - tree of depth @xmath345 rooted at @xmath31 _ be defined as @xmath347 } c \\in \\{- 1 , 1\\}^{d ' } \\}$ ] .",
    "the following properties are easy to note without the proof :                    lemma  [ x - bst ] shows that each @xmath77 is organized by @xmath44 in a binary search tree with the root at @xmath360 , without the left sub - tree and with a totally balanced right sub - tree , see figure  [ bst - fig ] .",
    "lemma  [ x - bst][parent - above - child ] : if @xmath383 then @xmath384 and the lemma follows , since @xmath385 .",
    "otherwise , we have  @xmath386 , @xmath387 and @xmath388 and , by lemma  [ x - bst][x - bst - structure ] , @xmath389 .",
    "thus @xmath390 and @xmath391 . by lemma  [ x - bst][x - bst - level ] , @xmath392  and @xmath393 . to conclude , note that @xmath394 .      in realistic implementation",
    ", after each reception , the receiver has to compute the next time slot with the index of the transmitted key  in the interval @xmath78 $ ] , and switch off the radio for the time remaining to this event .",
    "by @xmath396 we denote the next slot number ( modulo @xmath14 ) after the slot @xmath58 with its @xmath1-bit reversal in @xmath397 $ ] :  for  @xmath398 $ ] , @xmath399 , and @xmath361 $ ] , @xmath400 , where @xmath401\\}$ ] .",
    "let @xmath422 .",
    "let the iterations of the `` repeat - until '' loop be numbered starting from zero . after the @xmath30th iteration , at line [ until - line ] , we have @xmath423 , @xmath424 ,  @xmath425 , @xmath426 , and @xmath427 .",
    "let @xmath428 \\not=   \\emptyset\\}$ ] .",
    "since @xmath429 $ ] ,  @xmath399 , and @xmath430 $ ] , we have @xmath431 .",
    "thus , by lemma  [ x_i - lemma ] , @xmath432 is the number of the first iteration , after which@xmath433 , which is equivalent to @xmath434 .",
    "after the `` repeat - until '' loop finishes , at line [ bin - search - start ] , we have @xmath435 and , by lemma  [ x - bst][x - bst - structure ] , @xmath436 , where either @xmath437 , if @xmath438 , or @xmath439 , if @xmath122 . since @xmath440 \\not= \\emptyset$ ]",
    ", we do a binary search in @xmath441 until we enter the interval @xmath397 $ ] for the first time . by the lemma  [ x - bst][parent - above - child ] ,",
    "the returned value is @xmath442 .",
    "the time complexity : the number of iterations of the `` repeat - until '' loop is never greater than @xmath443 . since the value of @xmath444 never decreases , the total number of iterations of the internal `` while '' loop ( line  [ repeat - line][internal - while ] ) in all iterations of the `` repeat - until '' loop is never grater than @xmath443 . the total number of iterations of the binary search loop ( starting at line  [ bin - search - while ] ) is never greater than @xmath1 . thus the total complexity is @xmath9 elementary operations on @xmath1-bit integers .",
    "multiplication , division and modulo operations by the powers of two can be replaced by shifting or bit - masking operations .",
    "the implementation of this algorithm in programming language , with optimizations of bit - wise operations can be found on @xcite .",
    "tomasz imielinski , s.  viswanathan , and b.  r. badrinath .",
    "power efficient filtering of data an air . in matthias jarke , janis a.  bubenko jr . , and keith  g. jeffery , editors , _ edbt _ , volume 779 of _ lecture notes in computer science _ , pages 245258 .",
    "springer , 1994 .",
    "marcin kik . ranking and sorting in unreliable single hop radio network . in david coudert , david simplot - ryl , and ivan stojmenovic , editors , _",
    "adhoc - now _ ,",
    "volume 5198 of _ lecture notes in computer science _ , pages 333344 .",
    "springer , 2008 .",
    "jun shao and brian  t. davis .",
    "the bit - reversal sdram address mapping . in krishna",
    "m. kavi and ron cytron , editors , _ scopes _ , volume 136 of _ acm international conference proceeding series _ , pages 6271 , 2005 ."
  ],
  "abstract_text": [
    "<S> this report contains revision and extension of some results about rbo from @xcite . </S>",
    "<S> rbo is a simple and efficient broadcast scheduling of @xmath0 uniform frames for battery powered radio receivers . </S>",
    "<S> each frame contains a key from some arbitrary linearly ordered universe . </S>",
    "<S> the broadcast cycle  a sequence of frames sorted by the keys and permuted by @xmath1-bit reversal  is transmitted in a round robin fashion by the broadcaster .  at arbitrary time during the transmission , the receiver may start a simple  protocol that reports to him all the frames with the keys that are contained in a specified interval of the key values @xmath2 $ ] . </S>",
    "<S> rbo receives at most @xmath3 other frames keys before receiving  the first key from @xmath2 $ ] or noticing that there are no such keys in the broadcast cycle . as a simple corollary ,  </S>",
    "<S> @xmath4  is upper bound the number of keys  outside @xmath2 $ ] that will ever be received . in unreliable network </S>",
    "<S> the expected number of efforts to receive such frames is bounded by @xmath5 , where @xmath6 is probability of successful reception , and the reception rate of the frames with the keys in @xmath2 $ ] is @xmath6  the highest possible .    the receiver s protocol state consists of the values @xmath1 , @xmath7 and @xmath8 , one wake - up timer and two other @xmath1-bit variables . </S>",
    "<S> its only nontrivial computation  the computation of the next wake - up time slot  can be performed in @xmath9 simple operations , such as arithmetic / bit - wise operations on @xmath1-bit numbers , using only constant number of  @xmath1-bit variables .    </S>",
    "<S> = 1 </S>"
  ]
}