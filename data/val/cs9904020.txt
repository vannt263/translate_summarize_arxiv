{
  "article_text": [
    "a distributed processing platform provides a method of making a remote procedure call , an rpc , almost transparent to the application developer  see , for example , _ _ tivoli__@xcite and _ orbix _ @xcite  the relatively mature industry standard for both of which is the common object request broker architecture , _ corba _ , from the object management group@xcite , omg ; this defines an object request broker , orb , which is an infrastructure for rpcs .",
    "recently _ sun microsystems _",
    "@xcite have enhanced the remote method invocation package , , for _ java_@xcite as part of the _ java_development kit , jdk , 1.2 .",
    "it now allows connections to be created between a client and a server which can have a different data transfer representation @xcite . as pointed out in the documentation for this feature , this is particularly suitable for implementing the secure socket layer , ssl , @xcite and could also be used to implement the proposed successor to ssl transport level security , @xcite .",
    "[ [ open - distributed - processing - architecture ] ] open distributed processing architecture + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a suitable architecture to exploit this new functionality in and in other distributed processing platforms has been proposed in the open distributed processing standards , iso  odp , @xcite .",
    "[ [ bindings - and - channels ] ] bindings and channels    the prescriptive model , @xcite , generalizes the concept of connection between client and server to be a logical binding which is realized by both client and server using a channel , see also @xcite .",
    "figure [ fig : odp - channel ] illustrates the concepts of bindings and channels .",
    "application objects have bound with one another probably using a naming service ; they have negotiated a channel configuration that requires two objects : a data presentation conversion object and a data transport object .",
    "the channel configuration is fixed by bindings .",
    "the client sends data ; the server receives .",
    "the data is passed from the application object to the channel which carries out the conversion and the transport to the server .    binding : :    a binding is a contract between the client and the server stating the    parameters by which they will communicate .",
    "a binding between two    transport objects would usually specify :    +    * transport layer protocol to be used , _",
    "e.g._udp / ip or tcp / ip or    pipe / unix .",
    "* transport layer parameters    * network addresses for chosen transport layer protocol    +    the presentation layer object would convert from the the local data    representation to a network representation .",
    "the only specification    needed here is the source and target representations . in this case ,    the binding is implicit in the implementation of the objects , they    need not be initialized with parameters .",
    "+    more sophisticated systems will have higher demands and will insist    that other services be used as well , for example :    +    * data security    * transaction management    * call billing    * data compression    * relocation manager    +    these would all require that configuration parameters be specified and    may also demand that they are operate together .",
    "there is no need for channels to be symmetric , the server could implement a call  logging object in its channel without having an object of the same type in the client s channel .",
    "bindings do need to be current .",
    "a transport object might close a connection , in which case , it would no longer be current , but if it were to leave enough information to allow a re  connection , then it is , in effect , still current .    [",
    "[ tripartite - bindings ] ] tri  partite bindings    bindings need not be bi  partite .",
    "an application service that would require a tri  partite binding is relocation management , illustrated in figure [ fig : odp-3binding ] .",
    "the idea of which is that should the server choose to relocate , it would notify a relocation manager of its new addresses and move there . when the client calls the server at its old address and fails to reach it , the relocator object in the client s channel would call the third party and ask for the new address of the server , establish a new set of bindings with it , _ i.e._construct a new channel and destroy the old , and send the message again .",
    "this would all be transparent to the application object .",
    "the relocation object in the channel would need to call the relocation manager for the new addresses and would thus become an application object ; it would need to establish its own channel with the relocation manager .",
    "although the iso  odp defines a flexible architecture , most implementors of distributed processing platforms provide application programmers with inflexible systems : the channel can only contain a presentation and a transport object .    [ [ presentation - stubs - and - skeletons ] ] presentation : stubs and skeletons + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    both _ corba _ orbs and the rmi defined in _ java_make use of `` stubs '' and `` skeletons '' and a stub  compiler .",
    "the term infrastructure will be used for the engineering that realizes an orb or rmi .",
    "stubs : :    these are used by a client when invoking a method on a remote server .    the client does not have a local implementation for the service the    remote server has , but it will have a definition of its interface    which can be used as if it were the implementation of the service .",
    "it    can present the interface definition to a stub  compiler which will    generate code to invoke each method on the remote server .",
    "the stub    acts as a proxy for the remote server in the client s address space",
    ".    the stub for each method needs to do the following things :    +    1 .   construct a request    +    a request object is a container entity that carries the invocation to    the server ; it contains :    * the address of the remote server    * the name of the method being invoked , possibly with version control    information for the interface .    * the parameters for the method    * the return address    +    the stubs can also contain the code to _",
    "_ marshall _ _ the parameters into a universal transfer    presentation . in this form",
    ", the stubs also comprise the presentation    object .    2 .",
    "invoke the request    +    the request , now just a sequence of bytes with an associated address    for the server and a return address for the sender , is passed to the    infrastructrure which sends it to the network socket for the server .",
    "get the reply    +    the server will return a reply in another container type .",
    "construct the reply    +    the reply is then re  constructed or , rather , its contents are    _ un  marshalled _ and returned to the client . again",
    ", this may be part of    the code in the stubs .",
    "infrastructure : :    it might be best now to explain how the infrastructure manages to    provide the rpc service",
    ".    +    1 .   at the server on creation",
    "+    an application programmer defines an interface and produces an    implementation for it .",
    "a program that effectively acts as a loader    issues instructions to the infrastructure to create a socket to    receive requests for that server and will associate the remote server    implementation with that socket .    2 .",
    "at the naming service    +    the application programmer will ensure that the address of his    newly  created remote server is put into a well  known naming service .",
    "the client will then collect the address from the naming service .",
    "3 .   at the client on invocation",
    "+    the address collected at the naming service will contain enough    information to allow the client s infrastructure to send the request    container as a stream of bytes to the socket that the server s    infrastructure has associated with the remote server s implementation .",
    "4 .   at the server on invocation",
    "+    the network socket will be activated by the client s infrastructure ( a    connect and a data send ) and the server s infrastructure will collect    the data at the socket and , because it has recorded the object    responsible for that socket , it can activate the server skeleton .",
    "skeletons : :    [ sec : inflexible:1 ] these are invoked by the server s infrastructure    when the network socket for a server is activated and the data    comprising a call has been collected .",
    "it invokes the implementation of    the method the client wants to use at the server .",
    "a skeleton can    consist of one method that unmarshalls enough of the request container    to be able to look up the method to invoke  this is known as    _",
    "dispatching_.    +    this partial unmarshalling has to be done in this way , because each    method will unmarshall the remainder of the request container    differently to obtain the parameters to pass to the server s method    implementation .",
    "+    after the invocation is made the results will be marshalled into a    reply container which is then sent back to the client .",
    "the stubs and the skeleton effectively form the presentation channel object .",
    "stubs have to be produced by a stub  compiler , but skeletons can be made generic , if the underlying infrastructure supports a reflective invocation mechanism , see or the _ corba _ dynamic invocation interface .",
    "some stubs generated by the _ java _ , remote method interface compiler , are given in appendix [ cha : stubs ] .",
    "these demonstrate the use of reflective language features .",
    "[ [ transport ] ] transport + + + + + + + + +    when the request containers are passed to the infrastructure the transport object is eventually invoked .",
    "most orbs only provide one transport mechanism which sends data through tcp / ip sockets to its destination .",
    "although some systems do allow different protocols : udp / ip or pipe / unix .",
    "[ [ limitations ] ] limitations + + + + + + + + + + +    the problem with this is that if one wants to implement any useful application services  encryption , billing and so forth  the infrastructure does not help . for example , to encrypt and decrypt data sent as part of a remote procedure call , one would have to implement one s own stubs and skeletons , see figure [ fig : odp - channel-0 ] .",
    "the application programmer has to construct a call , marshall the data , encrypt it , send it using a generic method , which will marshall it again . at the server ,",
    "the data would be delivered to the generic method , and the application programmer would then have to decrypt it , unmarshall the decrypted data , reconstruct the call and dispatch it .",
    "after dispatching , collect the results , marshall , encrypt and return the reply .",
    "a more flexible implementation has been provided by _",
    "sun _ in _ java_. it allows a different type of socket to be used as the transport object .",
    "[ [ method ] ] method + + + + + +    the custom socket factories have to implemented in the following way :    1 .",
    "derive and implement classes for the new socket type s datastream from and , call them and .",
    "2 .   derive and implement classes for the new socket types and that use the new streams and .    then create socket factory implementations that can be used by rmi .    1 .   a client - side socket factory that implements and implement the method .",
    "2 .   a server - side socket factory that implements and implement the method .    then one has to ensure that the constructor for the remote server is told to use the new socket factories .",
    "the infrastructure creates the new type of socket when demanded and invokes the create socket methods .",
    "the at the client will then determine that a particular type of socket has to be used and will load the custom socket factory implementations .    [ [ possibilities - implementing - ssl ] ] possibilities : implementing ssl + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    using custom socket factories , it is possible to implement a secure socket layer .",
    "the would be used to perform the key exchange with the server and the custom input and output streams would apply the session key to encrypt on send and decrypt on receive .",
    "[ [ limitations-1 ] ] limitations + + + + + + + + + + +    unfortunately , using custom socket factories only increases the variety of the transport objects that can be employed , it does not allow different kinds of objects to be placed in the channel .",
    "what is needed is a means of placing objects in the channel before and after the presentation object .",
    "these objects should have a simpler instantiation and invocation procedure than using the custom socket method in _",
    "java_.      1 .",
    "different interests system configurable + the objects placed in the channel between client and server are the result of a negotiated agreement between the client , its server and their respective environments .",
    "it is well  known that security requirements for messages depend on the workstation that the client is using @xcite , which may be connected to a secure local area network on which both the the client and server reside and so , for example , no security measures need be taken ; or , the client could be accessing the server remotely from the internet through a modem in which the server might require that the client use encryption . + it would be desirable if the client and the server could both specify their requirements and some negotiation take place that could create a mutually acceptable protocol stack in the software communications channel .",
    "2 .   different methods for different actions +",
    "a request and reply actually require that four different channels be traversed by messages , see figure [ fig : odp-4channels ] : 1 .",
    "request this channel is created by the infrastructure for the client and sends a message over the network .",
    "2 .   indication this channel is used to receive from the network and is created by the infrastructure for the server .",
    "3 .   response created by the infrastructure for the server to return the results of the client s request message .",
    "confirmation receives from the network and is created by the infrastructure for the client .",
    "+ should an error occur at the server it is returned via the response and confirmation messages .",
    "+ the stubs are responsible for managing the thread of execution of the application object : once a message is put onto the request channel , the application object s thread can be suspended whilst it waits for the reply to arrive on the confirmation confirmation channel .",
    "+ if the message is a cast of some kind ( broadcast , multi  cast or one  cast ) there will be no response or confirmation .",
    "3 .   different implementations + most channel objects are derived from the same source and will have the same implementation .",
    "_ java_allows classes implementing different objects to be loaded over the network , so it would be possible for the client and server to agree upon and load the same class implementation , which they would be able to do with the custom socket factories method .",
    "this may not always be the case , some channel objects may be optimized to make use of a different operating system , but provide the same functionality .",
    "audio and video data streaming are good examples of this need : some micro  processors now have support for stream data .",
    "4 .   transparency 1 .",
    "management + it would be desirable if the additional services provided by the channel objects did not need to be initialized or managed by either the client or the server application programs but they were activated by their respective infrastructures .",
    "exception handling + one of the difficulties of developing applications in enterprise environments is that as messaging becomes more sophisticated  supporting for example , confidentiality , authorization , call  billing  the number of possible errors increases because each of these sub ",
    "systems introduces new ones . it must be possible for channel objects to clear down their own errors , so that errors returned to application objects only involve the application .",
    "3 .   using possession rather than inheritance for coupling +",
    "it would also be desirable if the classes for the channel objects did not extend the existing class hierachies of the message transmission sub  system , in the way that custom socket and socket factories do .",
    "extending class hierachies is not as flexible as specifying an order of invocation .",
    "interface definitions suitable for reflection .",
    "+ it would also be desirable if the infrastructures could load channel objects classes remotely and have a simple enough invocation syntax so that reflection mechanisms could be used to invoke the channel objects _ without requiring a stub compiler_. _ java_already does this with its version 1.2 stubs , using package , and _ corba _ has a dynamic invocation interface which can achieve the same goal .",
    "5 .   efficiency + it would also be desirable if the channel objects did not create a large stack of calls ; primarily because some target environments for remote procedure call platforms will be embedded systems on smartcards @xcite .      with the aid of figure [ fig : odp-4channels ] ,",
    "it is possible to be more precise with the terms used :    * initiator : starts a four  phase call sequence ; may also be called the requestor . *",
    "acceptor : accepts the call made upon it ; may also be called the responder , because it generates the response .    both an initiator and an acceptor will send and receive as part of four  phase call sequence .",
    "ordinarily , the client will be the initiator of all calls , but some remote procedure call systems permit call  backs , in which case the server is the initiator and the client the acceptor .",
    "there are basically two types of architecture that could support channel objects .",
    "the custom socket factory architecture is stream  oriented .",
    "it acts upon the data being sent between client and server as a stream applying a data transformation to the data when it is sent and undoing this transformation at the other end .",
    "the data is treated as opaque and can be delivered in packets as small as one byte .",
    "the implementor of the stream handler does not know whether the data has just started or is about to finish .",
    "one of the attractions of this approach is that many of the operations that data networks perform on data can be implemented in software : segmenting , and its converse re  assembling , can be implemented easily and this would allow remote procedure call systems to make use of packet  oriented transmission , such as udp / ip .",
    "segmenting and re  assembly could be implemented as channel objects and data would be segmented and then sent as packets on a udp socket for re ",
    "assembly by another channel object at the server .",
    "streams can be chained  the output of one providing the input for the next .",
    "most operating systems support _ pipes _ to do this : _ java_supports the , and output , classes .",
    "multi  casting could be easily achieved with pipes : simply have a pipe that sends on a socket and echoes its input ; then connect a series of these together .    a stream  oriented architecture is better for real  time data delivery .",
    "all of the processing in the stream  handler is applied to the data  it is not expected to communicate with relocation or transaction managers and incur indeterminate time penalties .",
    "consequently , the emphasis in the design of stream  handlers should be to ensure they introduce a constant latency in transmission and reception .",
    "this architecture implicitly appreciates that the data being delivered is a call .",
    "call  handlers usually add parameters to a remote procedure call .",
    "they do not form part of the message sent by the application object , but set its context .",
    "for example :    * timestamps logging when messages are sent and received by adding an `` time  sent '' parameter to the remote procedure call . *",
    "accounting adding an account identifier to a remote procedure call so that the server can log charges for calls to a particular account . * transactions a transaction might consist of a number of calls to different servers , they could all be identified with a transaction identifier , to synchronize committing and aborting transactions as a whole . *",
    "authorization a privilege certificate could be attached to the call so that the server could check what rights and privileges the caller is allowed to exercise within the server s work  space .",
    "a call  oriented architecture _ should _ be implemented so that it has access to the parameters passed as part of the request .",
    "if this is the case , then as well as being able to add parameters , it would be possible to perform data transformations on parameter values that are part of the call .",
    "for example :    1 .",
    "representation conversions 1 .",
    "wholly + the presentation objects implemented in remote procedure call systems change the data representation of the parameters of a call so that they can be transmitted over the network as a sequence of bytes , with the receiver being responsible for converting the byte  sequence to its local representation .",
    "it may be more efficient to convert to the receiver s format before the data is sent so that the server can use conversion methods available from its native operating system .",
    "2 .   partly + it might be the case that a server has a different data context for a particular data type : internationalization of text strings and currency formats could be converted prior to transmission .",
    "2 .   pseudo  objects + pseudo  objects are usually legacy systems that can be directly controlled by the client s remote procedure call infrastructure , but for the sake of uniformity , and to simplify re  engineering and relocation of services , they are provided with the same interface as remote servers .",
    "the operating system used by a distributed processing platform is itself a legacy system .",
    "+ an example of a pseudo  object that application programmers use is the database driver provided in the _ java_database connectivity package , .",
    "this pseudo  object implementation establishes and drives a connection with the database .",
    "other examples of services that could be implemented as pseudo  objects are directory and naming services that are available through native operating systems .",
    "3 .   stream + a call  oriented architecture could also be used to transform data in the same way that a stream  oriented architecture could .",
    "encryption , compression and checksum insertion could all be performed by marshalling the parameters using a data representation object to produce a sequence of bytes and then applying the stream operation to it .",
    "the output would be opaque and would replace the parameters .",
    "a call  oriented architecture is better suited to recovering from errors , since it is possible to determine which channel object is at fault and it can take measures to recover from the error .      the stream  oriented architecture is ideal for delivering data at high speed with a determinate latency , the call  oriented architecture is ideal for communicating control information .",
    "this is a similar design problem that faced the developers of telephone networks and it was resolved , in the integrated services digital network , isdn @xcite , by having a control channel manage the use of two bearer channels .",
    "figure [ fig : odp-2sources ] illustrates a request made to the server on a control channel and a reply being received on a broadband data channel .",
    "this sort of architecture could be used for controlling the delivery of `` pay  per  view '' television , where the rpc mechanism is used by an application to make a payment over a control network and the data is delivered on differently constructed channels over a broadband network possibly to different hardware .",
    "essentially the differences between the two architectures , with regard to the activation of the channel objects , are :    * synchronizing with the call , and * the opacity of the call s contents    a stream  oriented architecture need not transmit data to the server in a contiguous block that represents the marshalled bytes of a message .",
    "a call  oriented architecture would have each channel object invoked with each call sent .",
    "a stream  oriented architecture only has access to the marshalled bytes that represent a message .",
    "a call  oriented structure sees the method that is invoked and the parameters for it .",
    "the most flexible architecture is the call  oriented one .",
    "but for implementing the transport objects , a stream  oriented architecture should be preferred .",
    "this means that the two architectures fall above and below the marshalling channel object , see figure [ fig : odp - call - stream ] .",
    "this figure attempts to place the channel objects in an open systems interconnection model , @xcite .",
    "objects in the call  oriented architecture provide presentation layer services and , after the marshalling object , which reduces a call to a sequence of bytes , the session objects and finally the network transport object , a socket driver , can operate upon the data as a stream .",
    "the session layer objects would also perform stream  oriented encryption , but a presentation layer object would negotiate keys .",
    "channel objects that are call  oriented will be called _ call  handlers _ and those that are stream  oriented will be called _ stream ",
    "the marshalling object is a call  handler and , if need be , it could invoked a number of time to render the data as a sequence of bytes .",
    "this would be useful for data security , since it may be necessary to encrypt the data and make it unintelligible to other call  handlers .",
    "_ sun _ with _ java_and the socket factory technique have implemented what is described later as a simplex system ,  [ sec : simplex ] : each stream has two channel objects , one for sending  the output stream  and one for receiving  the input stream .",
    "there are two kinds of pairs : the client s , or , more precisely , the initiator s , pair and the server s , or acceptor s , pair .",
    "although there is no explicit code to synchronize the two streams so that only one may be used at a time , it is not expected that an application can simultaneously send and receive .",
    "this limitation could be removed by a suitably designed channel object which could specify a different return address .",
    "as pointed out above , a message passed between a sender and receiver would negotiate four different channels :    1 .",
    "request 2 .",
    "indication 3 .",
    "response 4 .",
    "confirmation    but if the call is a cast of some kind , it need only have two :    1 .",
    "request 2 .",
    "indication    and some parts may not do anything , for example a request handler could log all calls made by the client , but the server need not record all the calls that are made upon it .    when an application programmer makes use of a remote procedure call the infrastructure sends the message to the server and blocks the thread pending the arrival of the confirmation .",
    "one could also implement the channel objects in this way .",
    "this leads to two different architectures :    * either : one channel object for each of request , indication , response and confirmation _ simplex_. * or : two channel objects : one that requests and blocks pending the arrival of a confirmation ; one that receives indications , invokes the service ( and blocks waiting for it ) and then sends the response _",
    "duplex_.    the latter will be discussed first .",
    "one channel object for the initiator performs request and confirmation , another channel object performs indication and response for the acceptor .",
    "this means that every channel object has a bi  directional data  flow with the channel object below it , rather like the application object has with the distinct channels in figure [ fig : odp-4channels ] .",
    "this has the attraction that should the initiator s channel objects for the request and the confirmation need to share state , then this is achieved implicitly because they are the same object .",
    "this has a problem with broadcasts , ( or one  casts ) .",
    "the initiator s channel object ( request and confirmation ) needs to determine if it is to block or not and that would require this information be made available to the channel object , perhaps best supplied as a parameter to the method invocation .",
    "this information is required in _ corba _ , the interface definition language allows methods on interfaces to be marked as , but is not part of the _ java_specification ; although it could be inferred if the definition of the remote method returns no result , in which case , the method can be invoked as a one  cast . however ,",
    "if exceptions are returned by the remote server then the method is a call : the exception , whether raised or not , is a response .      if a channel object is implemented for each stage of the communication , then there are , at most , two pairs of objects : a request and confirmation pair at the initiator ; an indication and response pair at the acceptor . figure [ fig : odp-4channels ]",
    "illustrates the engineering of this .    because the objects are distinct they will need to bind with one another",
    "should they need to share state : an example of the difficulties this might lead to can be seen when communicating and attempting to correct errors .",
    "the infrastructure would block the application programmer s thread of control pending the arrival of the confirmation message from the server containing the results of the call .",
    "ordinarily , the confirmation channel objects will unravel the message returned by the server , instantiate the result for the application programmer s thread and unblock it .",
    "if there is an error in any of the channel objects , then it should be possible for the channel objects to attempt to clear the error and resend the message if need be .",
    "the problem then is that the channel objects in the request channel need to be synchronized with the error results received in the confirmation channel .",
    "if there is a failure in one of the channel objects in the indication channel , then they must be propagated via the response and confirmation channels .",
    "this is a difficult issue and is discussed later at greater length ,  [ sec : exceptions ] .",
    "the important difference between the duplex and simplex methods is the relationship to the state of the call . with the duplex model the request channel retains the state of the call awaiting an acknowledgement from the confirmation channel .",
    "what makes the duplex model retain state is that the channel objects invoke one another and form a stack of calls which can be associated with a thread .",
    "this can be emulated in the engineering of a simplex model without requiring the use of the stack , by passing a call identifier .",
    "this would only be of use if the channel objects were also to retain their internal state when they release control .",
    "[ [ example - a - secured - message - delivery - service ] ] example : a secured message delivery service + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as an example , an encryption and decryption service would require :    1 .",
    "request encrypt 2 .",
    "indication decrypt 3 .",
    "response encrypt 4 .",
    "confirmation decrypt    there are only two functions  encrypt and decrypt  but performed at four locations .",
    "it should be possible to provide just one pair of implementations  an and a located differently .    1 .",
    "* request channel object initiator * response channel object acceptor 2 .   * indication channel object acceptor * confirmation channel object initiator    and would both be implemented as stream  handler channel objects .",
    "encryption is subject to replays of old messages unless the messages are time  stamped and sequenced . usually , time  stamping and sequencing",
    "are implemented as part of the encryption and decryption objects , but with channel objects they can be provided separately .",
    "stamping has two functions :    1 .",
    "request timestamp issue 2 .",
    "indication timestamp check 3 .",
    "response timestamp issue 4 .",
    "confirmation timestamp check    two functions : , ; four locations :    1 .",
    "* request channel object initiator * response channel object acceptor 2 .   * indication channel object acceptor * confirmation channel object initiator    similarly for a sequence number generator and checker .    and",
    "would both be implemented as call  handler channel objects .    because it is difficult to synchronize clocks in a distributed networks , some secure message delivery systems allow some skew on the clocks and use checksums to detect replayed messages . only the acceptor s indication channel and the initiator s confirmation",
    "need deploy a object .",
    "it would be implemented as a call  handler generating a checksum from the marshalled data incoming as an indication or as a confirmation .",
    "there is a greater similarity in the simplex architecture to the engineering underlying the messaging system than in the duplex architecture , but the duplex architecture has some attractive state ",
    "retention properties which should be emulated in a simplex architectureq .",
    "the rest of this discussion will concern itself with a simplex architecture that attempts to retain state across all four phases of a call .",
    "the other great attraction of the simplex architecture is that if the channel objects reside in different channels , then it is easier to relocate the channel .",
    "this would be especially useful when a call uses two different media as the example system in figure [ fig : odp-2sources ] illustrated .",
    "from what has been said above , the _ java_rpc mechanism has a stream  oriented architecture and what follows is a proposed call  oriented architecture for it .",
    "it should serve as an example of how channel objects could be deployed in other _",
    "corba _ rpc systems .",
    "the distributed processing infrastructure will have to determine the order in which the channel objects will be invoked .",
    "there are now two ways in which the methods of the channel objects can be invoked and how they should bind with one another .",
    "* either : have the request object invoke a method on the indication object and block waiting for the response : _ peer  to  peer _ invocation . * or : have the request object perform its work and return a modified call object and return immediately : _ service _ invocation .    the peer  to  peer option requires the duplex architecture which has been dismissed , so only the service method of invocation is left . peer  to ",
    "peer is very attractive , it would allow channel objects to be client ",
    "server pairs and thus be able to use the stub  compiler .",
    "unfortunately , it would demand too much memory to stack all of the calls required to navigate complicated protocol stacks .",
    "the approach taken by _ sun _ in their own implementation of , shipped as as part of the _ java_runtime environment , is suitable for the simplex architecture proposed . referring to the the code fragment given in the appendix ",
    "[ sec : stub ] , the key method is .",
    "it is implemented along the lines given in the next code fragment : note the two comments indicating when the two types of channel objects should be invoked .",
    ".... package sun.rmi.server ;    public class unicastref implements remoteref {      public object invoke(remote r , reflect.method m ,                         object [ ] p , long l ) throws exception      {        // * request channel objects should be invoked now *          // establish a connection using information in remote r          // get the streams associated with the connection        // marshall data onto the stream        // execute the call                //",
    "* confirmation channel objects should be invoked now *          //",
    "unmarshall        //",
    "release the connection        //",
    "return the result      } } ....      the channel objects would be invoked serially and would be passed the same parameters as , collectively call these a object .",
    "the request channel objects would return a object , but these would usually have the original message as one of its parameters .",
    "this is a simple encapsulation procedure and is illustrated in figure [ fig : odp - channel - message-1 ] , where a time  stamping channel object has been passed the application object s message .",
    "the application object wants to invoke method , the channel object passes this message as a parameter of its own message .",
    "that message invokes method .",
    "the two message objects might duplicate target and return addresses , it should be possible to remove this redundancy , but it should still be possible to specify a different target address and a different return address if need be .",
    "the objects located in the indication and confirmation channels would need a skeleton rather like that described above ,  [ sec : inflexible ] , either a dispatcher or use a reflective invocation on the channel object s service implementation .",
    "after the service has completed processing , it would return its results to the skeleton which would then return the message object to the infrastructure .",
    "some channel objects will have counterparts in the remote channel , for example , a time ",
    "stamping request channel object should have a time  stamp checking indication channel object , but some may not , for example a request logging channel object placed in a server s indication channel .",
    "if a channel object sends then its counterpart receives and _ vice ",
    "versa_.    a channel object can have an associate in a local channel .",
    "a request channel object could have an associate in the confirmation channel .",
    "if a channel objects sends then its associate receives and _ vice ",
    "versa_.    figure [ fig : odp - counterparts ] should help to clarify this .    1 .",
    "marshalling and unmarshalling + looking at the marshalling and unmarshalling objects : the marshalling object in the client s request channel has a counterpart in the server s indication channel and an associate in the client s confirmation channel .",
    "2 .   timing + the top layer of channel objects are used for timing : time  stamping and time  checking , they comprise a full complement , where each channel object has an associate and a complement .",
    "usage + the second layer of channel objects is used to record usage statistics and only logs requests and responses , so they have no associates but a counterpart .",
    "clearly , this might prove to be cumbersome , it might be simpler to insist that all channel objects have a counterpart and an associate and have a default implementation which just copies the message over .",
    "any of the channel objects can raise an exception , but part of the function of channel objects is to attempt to clear exceptions , for example :    * relocation objects would obtain new addresses for servers , * key management objects would obtain new keys in the event of expiry . * authorization managers could obtain new privileges .",
    "the channel objects have to retain some state that would allow them to act upon exceptions .",
    "this would require that they place state in a common object that associated channel objects can access .",
    "the state would need to be stored with an identifier unique to the call .",
    "1 .   exception handling in one channel 1 .",
    "clear + when one channel object raises an exception , the infrastructure signals the other channel objects in the same channel , in the reverse order in which they were invoked , asking them to attempt to clear the exception .",
    "2 .   uncleared : undo + if the exception can not be cleared then the channel objects should be signalled to undo their previous actions .",
    "cleared : undo and redo + if the exception can be cleared then the channel objects may need to undo their previous actions and be allowed to redo them .",
    "+ redo is a distinct operation , because it may allow the implementation to be optimized for error recovery .",
    "+ co  ordinating this is a little difficult .",
    "there are two sequences : 1 .",
    "attempt to clear then undo and then redo + each object in turn in ascending order ( _ i.e._reverse order to invocation ) attempts to clear the exception , if any one succeeds then the undo operation is invoked in ascending order to the top of the channel . then the redo operation is invoked in descending order .",
    "2 .   attempt to clear and undo and then redo + each object in turn in ascending order ( _ i.e._reverse order to invocation ) attempts to clear the exception and performs an undo .",
    "if any one succeeds then the undo is invoked on the remaining objects in ascending order and then the redo operation is invoked in descending order .",
    "+ the former might prove more efficient if errors are expected to be cleared , the latter if not .",
    "the idea is communicated in figure [ fig : odp - exceptions ] , but the details of invocation are not .",
    "+    + if the latter scheme ( attempt to clear and undo simultaneously ) is used : channel object @xmath0 raises an exception , it undoes its action , passes back the original message it received to object @xmath1 which also undoes its action and returns the original message it received to @xmath2 .",
    "@xmath2 clears the exception and redoes its action and passes the message on to @xmath1 which also redoes its action and thence to @xmath0 .",
    "exception handling across channels + if a receiving counterpart raises an exception , it should be signalled to the sender : this would be achieved by the receiving counterpart sending a message to its sending associate to raise an exception with its receiving counterpart .",
    "_ java_already has a proven mechanism for this , objects of class can be contained in objects of class .",
    "1 .   exception raised in the indication channel + as an example , see figure [ fig : odp - exceptions-1 ] , a request channel object sends a message which raises an exception in the indication channel , the channel object in the indication channel raises an alert with its associate in the response channel , which sends an exception to its counterpart in the confirmation channel .",
    "+ points to note in figure [ fig : odp - exceptions-1 ] are : 1 .",
    "the indication channel is cleared down 2 .",
    "the server receives no message 3 .",
    "the response channel propagates the exception 4 .",
    "the objects in the confirmation channel can signal their associates in the request channel .",
    "+ it might be possible for the request channel objects to invoke the same procedure as portrayed in figure [ fig : odp - exceptions ] , clear the exception and re  send the message , this would require that they have access to the message as issued by the client",
    "exception raised in the confirmation channel + if a response channel object sends a message which raises an exception in the confirmation channel , then the confirmation channel object would signal its associate in the request channel , which may , if it has retained state , _",
    "i.e._the message it sent , be able to clear the exception and re ",
    "send without intervention by the client application object .",
    "a simple message class is needed to contain the parameters passed to the method and to all the channel objects .    .... package java.lang.rmi.channel ;    import java.rmi . * ; import java.lang.reflect . * ;    public class message {    remote remote ;    method method ;    object [ ] parms ;    long hash ;      public message(remote r , method m , object [ ] p , long h ) {      remote = r ;      method = m ;      parms = p ;      hash = h ;    } } ....      [ [ basic - interface ] ] basic interface + + + + + + + + + + + + + + +    channel objects then all have the same interface and it is their location which determines their function , _ i.e._whether they wrap or unwrap .",
    ".... package java.lang.rmi.channel ;    public interface handler {    public message clear(message m , exception e ) throws exception ;    public message todo(message m ) throws exception ;    public message undo(message m , exception e ) throws clearedexception ;    public message redo(message m ) throws exception ; } ....    both methods of clearing exceptions are covered in this interface because there is a separate method .",
    "[ [ exceptions ] ] exceptions + + + + + + + + + +    the method throws an exception to indicate it has cleared the exception it was passed .",
    ".... package java.lang.rmi.channel ;    public class clearedexception extends exception {        public clearedexception(string s ) {        super(s ) ;      }        public clearedexception(string s , exception ex ) {        super(s , ex ) ;      }    } ....    other exceptions which might make processing more decisive :    1 .",
    "unclearable + it might also prove useful to have raise an exception that the exception can not be cleared and this would allow the infrastructure to request a re ",
    "send decision from the application object .",
    "2 .   rebind + it might also prove useful if the channel objects can demand a rebind and force the destruction of their channel .",
    "this would be useful for a relocation channel object .",
    "[ [ handler - specification ] ] handler specification + + + + + + + + + + + + + + + + + + + + +    the next is an abstract class that provides a container to hold the channel objects which would be loaded by the infrastructue .",
    "it might be wise , for security reasons , to implement the class more fully and make the method final .",
    "the class also provides a means of obtaining associates and counterparts .",
    ".... package java.lang.rmi.channel ;    import java.rmi .",
    "* ;    public abstract class handlers   {    public static final int request = 1 ;    public static final int indication = 2 ;    public static final int response = 3 ;    public static final int confirmation = 4 ;      public handlers ( ) {      ;    }      handler gethandler(int identity ) {      return null ;    }      remote getcounterpart(int identity ) {      return null ;    }      object getassociate(int identity ) {      return null ;    } } ....    [ [ channels ] ] channels + + + + + + + +    channels themselves would be simple containers probably implemented with a vector object which can be easily iterated in the operation .    .... package java.lang.rmi.channel ;    import java.rmi . * ;    public abstract class channel   {    private int identity = -1 ;    private handlers handlers ;      public channel(int i d , channels h ) {      identity = i d ;      handlers = h ;    } } ....      [ [ binding ] ] binding + + + + + + +    channel objects would need to bind with one another , so that they can exchange parameters .",
    "the channel object methods are defined on one interface , they can therefore suppport other methods on another service interface .",
    "[ [ invocation ] ] invocation + + + + + + + + + +    when a channel object is passed a message object , it will need to invoke a method on its counterpart . the easiest way for it to do",
    "this is to use the same stub and skeleton mechanism for dispatching a call as remote procedure calls use .",
    "as can be seen in figure [ fig : odp - channel - message-1 ] , where one channel object adds enough parameters to the message so that when it is received by its counterpart , it can use a local method to pass the parameters and obtain the resulting message object from a local service interface .",
    "if channel objects have to invoke methods upon one another they can either send them with the message or they can go `` out  of  band '' and communicate them directly if they support the interface using their own channel .",
    "_ java_certainly has the functionality to implement channel objects .",
    "the author has already implemented a similar scheme ( using a duplex , peer  to  peer architecture ) for a variant of the _ ansaware _ , @xcite , known as _ dais _ , the distributed processing platform produced by _ icl _ , @xcite , which was _ corba _ compliant .",
    "that implementation , written wholly in _",
    "@xcite , was able to support a _ kerberos _",
    ", @xcite , authentication and confidentiality service invisibly to the application programmer , the channels were constructed according to a template specified by an environment variable .",
    "the author has developed a prototype application which can support the transport level security protocol .",
    "( a fairly rigorous treatment of both it and the _ kerberos _ protocol is given in @xcite . ) a simple channel object is put in place that negotiates the keys , whilst a custom socket is used to perform the encryption .",
    "_ ansaware _ evolved to a product known as _ reflective java _ , @xcite , which supported channel objects , but was designed to provide support to application objects  presentation of data and so forth  and not to provide system services .",
    "the principal difficulty faced in these prototypes is that there is no simple or well  defined mechanism for expressing how two parties should bind with one another .",
    "_ ansaware _ had a well  developed binding model , @xcite , but its final implementation had a limited number of quality of service parameters .    _",
    "java_now has a very well  developed security architecture , @xcite , but currently seems to have no means of specifying the degree of security _ required _ , it seems to be principally oriented towards setting permissions .",
    "( of course , a permission one does not have is a requirement . )",
    "the would appear to be the best  placed component of the _ java_security architecture to negotiate and configure channels .",
    "it will be difficult for any distributed processing platform to achieve any degreee of acceptance in an enterprise  wide data processing environment if it is not possible to implement many of the logging services that have long been available in mainframe systems .",
    "the most pertinent example of which is _ cics _",
    "@xcite , the customer information control system , which was originally a messaging system , but was extended to become a transaction monitor that could manage database enquiries .",
    "hopefully , with channel objects in place , remote procedure calls could do the same across the world  wide web .",
    "the remote method invocation package of _ java_needs to use a stub  compiler to generate stubs .",
    "it no longer needs to generate skeletons for servers .",
    "there is , of course , no need to distribute the stubs , the client can collect them from the server .      [ [ interface ] ] interface + + + + + + + + +    this very simply returns a string , given a string .",
    ".... package rmi.demo ;    public interface answerer extends java.rmi.remote {    string answer(string mesg ) throws java.rmi.remoteexception ; } ....    [ [ implementation ] ] implementation + + + + + + + + + + + + + +    this is the implementation of the interface .",
    "most of the code involves posting the server s reference to the naming service .",
    ".... package rmi.demo ;    import java.rmi .",
    "* ; import java.rmi.server.unicastremoteobject ;    public class answererimpl    extends unicastremoteobject    implements answerer {    private string name ;      public answererimpl(string s ) throws remoteexception {      super ( ) ;      name = s ;    }      //",
    "begin    //",
    "remotely accessible methods    // parameters have to be implementations of serializable       public string answer(string message ) throws remoteexception {      system.out.println(\"received : \" + message ) ;      return new string(\"you said : \" + message ) ;    }      //",
    "end      public static void main(string args [ ] )    {      // create and install a security manager      system.setsecuritymanager(new rmisecuritymanager ( ) ) ;      // without it no new classes can be loaded        try {        system.out.println(\"construct \" ) ;        answererimpl obj = new answererimpl(\"answererserver \" ) ;        system.out.println(\"bind \" ) ;        naming.rebind(\"answererserver \" , obj ) ;        system.out.println(\"bound \" ) ;      } catch ( exception e ) {        system.out.println(\"answererimpl err : \" + e.getmessage ( ) ) ;        e.printstacktrace ( ) ;      }    } } ....      this is the version 1.2 stub for the service interface .    1 .",
    "reflective language features + the most important feature of these stubs is that they make use of the capabilities provided by . when the class is loaded by the client , and it is designed to be loaded from a remote location , the initialization code instantiates the attribute for the stub using the method of .",
    "2 .   instantiating objects that implement + because the client has to use the naming service to locate an object that implements the , the naming service loads the stub class and calls the constructor in it .",
    "the client casts the object the naming service returns to be .",
    "3 .   invoking methods",
    "+ the stub compiler generates proxy implementations of the methods that are declared in .",
    "they use the reflective method variable and the method .    .... //",
    "stub class generated by rmic , do not edit . //",
    "contents subject to change without notice .",
    "package rmi.demo ;    public final class answererimpl_stub    extends java.rmi.server.remotestub    implements rmi.demo.answerer , java.rmi.remote {    private static final long serialversionuid = 2 ;         private static java.lang.reflect.method $ method_answer_0 ;         static {      try {        $ method_answer_0 =          rmi.demo.answerer.class.getmethod(\"answer \" ,                                            new java.lang.class [ ]                                            { java.lang.string.class } ) ;        } catch ( java.lang.nosuchmethodexception e ) {        throw new          java.lang.nosuchmethoderror(\"stub class initialization failed \" ) ;      }    }         //",
    "constructors    public answererimpl_stub(java.rmi.server.remoteref ref ) {      super(ref ) ;    }         //",
    "methods from remote interfaces         // implementation of answer(string )    public java.lang.string answer(java.lang.string $ param_string_1 )      throws java.rmi.remoteexception      {        try {          object $ result =            ref.invoke(this , $ method_answer_0 ,                       new java.lang.object [ ] { $ param_string_1 } ,                       -8351992698817289230l ) ;          return ( ( java.lang.string ) $ result ) ;        } catch ( java.lang.runtimeexception e ) {          throw e ;        } catch ( java.rmi.remoteexception e ) {          throw e ;        } catch ( java.lang.exception e ) {          throw new            java.rmi.unexpectedexception(\"undeclared checked exception \" ,                                         e ) ;        }      } } ....",
    "research was funded by the engineering and physical sciences research council of the united kingdom .",
    "thanks to malcolm clarke , russell  wynn jones and robert thurlby .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ walter eaves + department of electrical engineering , + brunel university + uxbridge , + middlesex ub8 3ph , + united kingdom _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _              tim dierks and christopher allen .",
    "the tls protocol : version 1.0 . in postel @xcite ,",
    "november 1997 .",
    "ftp://ietf.nri.reston.va.us / internet - drafts / draft - ietf - tls - protocol-05% .txt.z[ftp://ietf.nri.reston.va.us",
    "/ internet - drafts / draft - ietf - tls - protoc% ol-05.txt.z[ftp://ietf.nri.reston.va.us / internet - drafts / draft - ietf - tls - protoc% ol-05.txt.z ] ] , expires may 12 , 1998 .",
    "walter  d eaves .",
    "ransport level security : a proof using the gong - needham - yahalom logic .",
    "technical report , e  print archives , april 1999 , http://xxx.lanl.gov / abs / cs.cr/9904005[http://xxx.lanl.gov / abs / cs% .cr/9904005[http://xxx.lanl.gov / abs / cs% .cr/9904005 ] ] .",
    "alan  o. freier , philip karlton , and paul  c. kocher .",
    "the ssl protocol : version 3.0 . in postel",
    "@xcite , november 1995 .",
    "http://www.netscape.com / eng / ssl3/draft302.txt[http://www.netscap% e.com / eng / ssl3/draft302.txt[http://www.netscap% e.com/eng/ssl3/draft302.txt ] ] , expired .",
    "basic reference model : the basic model . in j",
    "day , editor , _ information technology - open systems interconnection _ , number 200 in series x recommendations x.200 to x.900 .",
    "international telecommunication union , international telecommunication union ( itu ) , place des nations , ch-1211 geneva 20 , switzerland , 1994 .",
    "http://info.itu.ch / itudoc / itu - t / rec / x / x200up.html[http://info.it% u.ch / itudoc / itu - t / rec / x / x200up.html[http://info.it% u.ch/itudoc/itu-t/rec/x/x200up.html ] ] .",
    "reference model : architecture ( 10 ) . in herbert",
    "@xcite , number 903 in series x recommendations x.900 to x.1000 , 1995 .",
    "http://info.itu.ch / itudoc / itu - t / rec / x / x500up.html[http://info.it% u.ch / itudoc / itu - t / rec / x / x500up.html[http://info.it% u.ch/itudoc/itu-t/rec/x/x500up.html ] ] .    .",
    "series x recommendations x.900 to x.1000 .",
    "international telecommunication union , international telecommunication union ( itu ) , place des nations , ch-1211 geneva 20 , switzerland , 1997 .",
    "http://info.itu.ch / itudoc / itu - t / rec / x / x500up.html[http://info.it% u.ch / itudoc / itu - t / rec / x / x500up.html[http://info.it% u.ch/itudoc/itu-t/rec/x/x500up.html ] ] .",
    "dave otway .",
    "the ansa binding model .",
    "technical report ar1392.01 , architectural projects management , poseidon park , cambridge , uk , january 1995 .",
    "ftp://ftp.ansa.co.uk / phase3-doc - root / apm.1392.01.ps.gz[ftp://ftp% .ansa.co.uk",
    "/ phase3-doc - root / apm.1392.01.ps.gz[ftp://ftp% .ansa.co.uk / phase3-doc - root / apm.1392.01.ps.gz ] ] .        creating a custom rmi socket factory .",
    "world  wide web , 1998 .",
    "http://java.sun.com / products / jdk/1.2/docs / guide / rmi / rmisocketfactory.d% oc.html[http://java.sun.com / products / jdk/1.2/docs / guide / rmi / rmisocketfac% tory.doc.html[http://java.sun.com / products / jdk/1.2/docs / guide / rmi / rmisocketfac% tory.doc.html ] ] .",
    "java security .",
    "world  wide web , 1998 .",
    "http://java.sun.com / products / jdk/1.2/docs / guide / security/[http:/% /java.sun.com / products / jdk/1.2/docs / guide / security/[http:/% /java.sun.com / products / jdk/1.2/docs / guide / security/ ] ] .",
    "zhixue wu and scarlet schwiderski .",
    "reflective java : making java even more flexible .",
    "technical report ar1936.02 , architectural projects management , poseidon park , cambridge , uk , january 1997 .",
    "/ phase3-doc - root / apm.1936.02.ps.gz[ftp://ftp% .ansa.co.uk",
    "/ phase3-doc - root / apm.1936.02.ps.gz[ftp://ftp% .ansa.co.uk / phase3-doc - root / apm.1936.02.ps.gz ] ] ."
  ],
  "abstract_text": [
    "<S> this paper describes an architecture for a distributing processing system that would allow remote procedure calls to invoke other services as messages are passed between clients and servers . </S>",
    "<S> it proposes that an additional class of data processing objects be located in the software communications channel . the objects in this channel </S>",
    "<S> would then be used to enforce protocols on client  server applications without any additional effort by the application programmers . </S>",
    "<S> for example , services such as key  management , time  stamping , sequencing and encryption can be implemented at different levels of the software communications stack to provide a complete authentication service . </S>",
    "<S> a distributing processing environment could be used to control broadband network data delivery . </S>",
    "<S> architectures and invocation semantics are discussed , example classes and interfaces for channel objects are given in the _ </S>",
    "<S> java_programming language . </S>"
  ]
}