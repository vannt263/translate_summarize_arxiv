{
  "article_text": [
    "enumeration is a fundamental problem in computer science , and many algorithms have been proposed for many problems , such as cycles , paths , trees and cliques@xcite .",
    "however , their application to real world problems has not been researched very much , due to the handling needed for the huge amount of and the high computational cost .",
    "however , this situation is now changing , thanks to the rapid increase in computational power , and the emergence of data centric science .",
    "for example , the enumeration of all substructures frequently appearing in a database , i.e. , frequent pattern mining , has been intensively studied .",
    "this method is adopted for capturing the properties of databases , or for discovering new interesting knowledge in databases .",
    "enumeration is necessary for such tasks because the objectives can not be expressed well in mathematical terms .",
    "the use of good models helps reduce the amount of output , and the use of efficient algorithms enables huge databases to be more easily handled@xcite .",
    "more specifically , introducing a threshold value for the frequency , which enables controlling the number of solutions .",
    "in such areas , minimal / maximal solutions are also enumerated to reduce the number of solutions .",
    "for example , enumerating all cliques is usually not practical while enumerating all maximal cliques , i.e. cliques included in no other cliques , is often practical@xcite . in real - world sparse graphs ,",
    "the number of maximal cliques is not exponential , so , even in large - scale graphs , the maximal cliques can often be enumerated in a practically short time by a stand alone pc even for graphs with millions of vertices .",
    "however , the enumeration of maximum cliques , that have the maximum number of vertices among all cliques , is often not acceptable in practice , since the purpose of enumeration is to find all locally dense structures , and finding only maximum cliques will lose relatively small dense structures , thus it does not cover whole the data .",
    "paths and cycles are two of the most fundamental graph structures .",
    "they appear in many problems in computer science and are used for solving problems , such as optimizations ( e.g. flow problems ) and information retrieval ( e.g. connectivity and movement of objects ) .",
    "paths and cycles themselves are also used to model other objects .",
    "for example , in chemistry , the size and the fusing pattern of cycles in chemical graphs , representing chemical compounds , are considered to be essential structural attributes affecting on several important properties of chemical compounds , such as spectroscopic output , physical property , chemical reactivity , and biological activity .    for a path / cycle @xmath3 ,",
    "an edge connecting two vertices of @xmath3 but not included in @xmath3 is called a chord . a path / cycle without a chord",
    "is called a chordless path / cycle .",
    "since a chordless cycle includes no other cycle as a vertex set , it is considered minimal .",
    "thus , chordless cycles can be used to represent cyclic structures .",
    "for instance , the size and fusing pattern of chordless cycles in chemical graphs as well as other properties of chemical structures are taken into account when selecting data for prediction of nuclear magnetic resonance ( nmr ) chemical shift values@xcite .",
    "most chemical compounds contain cycles . in chemistry ,",
    "the term ` ring ' is used instead of ` cycle ' , for example a cycle consisting of 5 vertices is called 5-membered ring . since the character of ring structures of chemical compounds is assumed to be important to study the nature of the structure - property relationships , the ring perception is one of classical questions @xcite in the context of chemical informatics , so called chemoinformatics .",
    "several kinds of ring structures , such as all rings and the smallest set of smallest ring ( sssr ) are usually included in a basic dataset of chemical information .",
    "nmr chemical shift prediction is a successful case where the information about chordless cycles is employed to improve the accuracy of the prediction .",
    "the path / cycle enumeration is supposed to be useful also for analysis of network systems such as web and social networks .    in this paper , we consider the problem of enumerating all chordless paths ( resp . , cycles ) of the given graph .",
    "while optimization problems for paths and cycles have been studied well , their enumeration problems have not .",
    "this is because there are huge numbers of paths and cycles even in small graphs .",
    "however , we can reduce the numbers so that the problem becomes tractable by introducing the concept of chordless .",
    "the first path / cycle enumeration algorithm was proposed by read and tarjan in 1975@xcite .",
    "their algorithm takes as input a graph @xmath4 and enumerates all cycles , or all paths connecting given vertices @xmath5 and @xmath6 , in @xmath7 time for each .",
    "the total computation time is @xmath8 where @xmath9 is the number of output cycles / paths .",
    "ferreira et al .",
    "@xcite recently proposed a faster algorithm , that takes time linear in the output size , that is the sum of the lengths of the paths .",
    "the chordless version was considered by wild@xcite .",
    "an algorithm based on the principle of exclusion is proposed , but the computational efficiency was not considered deeply . in this paper , we propose algorithms for enumerating chordless cycles and chordless paths connecting two vertices @xmath5 and @xmath6 ( reported in 2003@xcite ) .",
    "note that chordless cycles can be enumerated by chordless path enumeration .",
    "the running time of the algorithm is @xmath7 for each , the same as the read and tarjan algorithm .",
    "we experimentally evaluated the practical performance of the algorithms for random graphs and real - world graphs .",
    "the results showed that its practical computation time is much smaller than @xmath7 , meaning that the algorithms can be used for large - scale graphs with non - huge amount of solutions .",
    "the results also showed that the number of chordless cycles is drastically small compared to the number of usual cycles .",
    "a _ graph _ is a combination of a vertex set and an edge set such that each edge is a pair of vertices .",
    "a graph @xmath10 with vertex set @xmath11 and edge set @xmath12 is denoted by @xmath4 .",
    "an edge @xmath13 of pair @xmath14 and @xmath15 is denoted by @xmath16 .",
    "we say that the edge _ connects _ @xmath15 and @xmath14 , @xmath13 is _ incident _ to @xmath15 and @xmath14 , and @xmath14 and @xmath15 are _ adjacent _ to each other , and call @xmath15 and @xmath14 _ end vertices _ of @xmath13 .",
    "an edge with end vertices that are the same vertex is called a _ self - loop_. two edges having the same end vertices @xmath15 and @xmath14 are called _ multi - edges_. we deal only with graphs with neither a self - loop nor a multi - edge .",
    "this restriction does not lose the generality of the problem formulation .",
    "a path is a graph of vertices and edges composing a sequence @xmath17 + @xmath18 satisfying @xmath19 and @xmath20 .",
    "the @xmath21 and @xmath22 are called the _",
    "end vertices _ of the path .",
    "if the end vertices of @xmath3 are @xmath5 and @xmath6 , the path is called an @xmath5-@xmath6 path .",
    "when @xmath23 holds , a path is called a cycle . here",
    "we represent paths and cycles by vertex sequences , such as @xmath24 .",
    "an edge connecting two vertices of a path / cycle @xmath3 and not included in @xmath3 is called a _ chord _ of @xmath3 .",
    "a path / cycle @xmath3 such that the graph includes no chord of @xmath3 is called _",
    "chordless_. figure [ chordless ] shows examples . in a set system composed of the vertex sets of cycles ( resp .",
    ", @xmath5-@xmath6 paths ) , the vertex set of a chordless cycle ( resp .",
    ", @xmath5-@xmath6 path ) is a minimal element .    for a graph @xmath10 and a vertex subset @xmath25 of @xmath10",
    ", @xmath26 denotes the graph obtained from @xmath10 by removing all vertices of @xmath25 and all edges incident to some vertices in @xmath25 . for a vertex @xmath14",
    ", @xmath27 denotes the _ neighbor _ of @xmath14 , that is , the set of vertices adjacent to @xmath14 . for a vertex set @xmath25 and a vertex @xmath14 , @xmath28 and",
    "@xmath29 denote @xmath30 and @xmath31 , respectively . for a path @xmath3 and its end vertex @xmath14",
    ", @xmath32 denotes the path obtained by removing @xmath14 from @xmath3 .",
    "[ st - exist ] there is a chordless @xmath5-@xmath6 path if and only if there is an @xmath5-@xmath6 path .",
    "a chordless @xmath5-@xmath6 path is an @xmath5-@xmath6 path , thus only if part is true .",
    "if an @xmath5-@xmath6 path exists , a shortest path from @xmath5 to @xmath6 is a chordless @xmath5-@xmath6 path , and thus it always exists .",
    "[ exist ] a vertex @xmath14 is included in a cycle if and only if @xmath14 is included in a chordless cycle .",
    "if @xmath14 is not included in any cycle , it obviously is not included in any chordless cycle .",
    "hence , we investigate the case in which @xmath14 is included in a cycle @xmath0 . if @xmath0 is chordless , we are done .",
    "if @xmath0 has a chord , the addition of the chord splits @xmath0 into two smaller cycles , and @xmath14 is always included in one of them .",
    "we then consider the cycle as @xmath0 .",
    "the cycle with three vertices can not have a chord , thus we always meet a chordless cycle including @xmath14 . for a recursive algorithm ,",
    "an iteration means the computation from the beginning of a recursive call to its end , excluding any computation done in recursive calls generated in the iteration .",
    "if an iteration @xmath33 recursively calls an iteration @xmath34 , @xmath34 is called a _ child _ of @xmath33 , and @xmath33 is called the _ parent _ of @xmath34 .",
    "our enumeration problem is formulated as follows .",
    "+ * chordless @xmath5-@xmath6 path enumeration problem * + for a given graph @xmath4 and two vertices @xmath5 and @xmath6 , enumerate all chordless @xmath5-@xmath6 paths included in @xmath10 .",
    "+ we first observe that chordless cycle enumeration is done with chordless @xmath5-@xmath6 path enumeration by repeating steps ; ( 1 ) for a vertex @xmath5 , enumerate chordless @xmath5-@xmath6 paths in @xmath35 for each vertex @xmath6 adjacent to @xmath5 , and ( 2 ) remove @xmath5 from the graph . here",
    "@xmath35 is the graph obtained from @xmath10 by removing the edge @xmath36 .",
    "this implies that we only have to consider chordless @xmath5-@xmath6 path enumeration .",
    "[ st ] for a vertex @xmath37 , @xmath3 is a chordless @xmath5-@xmath6 path including @xmath14 if and only if @xmath38 is a chordless @xmath14-@xmath6 path of the graph @xmath39 .",
    "if @xmath38 is a chordless @xmath14-@xmath6 path in @xmath40 , @xmath3 is an @xmath5-@xmath6 path all whose chords are incident to @xmath5 .",
    "since @xmath3 has no vertex in @xmath41 , no vertex of @xmath3 other than @xmath14 is adjacent to @xmath5 .",
    "thus , @xmath3 has no chord incident to @xmath5 , and is chordless .",
    "if @xmath3 is a chordless @xmath5-@xmath6 path including @xmath14 , no vertex @xmath42 is included in @xmath3 , since the edge @xmath43 would be a chord if was included .",
    "thus , @xmath38 is a chordless @xmath14-@xmath6 path in @xmath39 .",
    "the set of chordless @xmath5-@xmath6 paths of @xmath10 is partitioned into disjoint sets of chordless @xmath5-@xmath6 paths in the graphs @xmath39 for each @xmath14 .",
    "suppose that @xmath3 is a chordless @xmath5-@xmath6 path in @xmath10 .",
    "then , from lemma [ st ] , @xmath3 includes exactly one vertex among @xmath44 .",
    "if @xmath3 includes @xmath37 , @xmath38 is a chordless @xmath14-@xmath6 path in @xmath39 , thus @xmath3 is a chordless @xmath5-@xmath6 path in @xmath39 .",
    "since @xmath3 is not an @xmath5-@xmath6 path in @xmath45 for any @xmath46 , the statement holds .    from the lemma",
    ", we obtain the following algorithm .",
    "the @xmath47 is the sequence of vertices attached to the paths in the ancestor iterations , and set to be empty at the start of the algorithm .",
    "* enum_chordless_path * ( @xmath48 ) + 1 . *",
    "if * edge @xmath49 exists in @xmath12 * then * output @xmath50 ; * return * + 2 .",
    "* for each * @xmath37 s.t . a @xmath14-@xmath6 path exists in @xmath39 *",
    "do * + 3 .",
    "call * enum_chordless_path * ( @xmath51 ) + 4 .",
    "* end for *    -@xmath6 path enumeration in the graph on left ; bold lines correspond to recursive calls in step 2 , and dotted lines correspond to those in step 6 . ]",
    "when a recursive call is generated in an iteration of the algorithm , @xmath40 is generated from @xmath10 by removing vertices and edges .",
    "the removed vertices and edges are kept in memory so that @xmath10 can be reconstructed from the graph .",
    "a removed edge or vertex is not removed again in the descendants of the iteration .",
    "thus , the accumulated memory usage for these removed vertices and edges is @xmath7 , and the space complexity of the algorithm is @xmath7 .    in step 2 , all vertices @xmath37 such that a @xmath14-@xmath6 path exists in @xmath39",
    "must be listed .",
    "if and only if the condition in step 2 holds , there is a vertex @xmath52 such that a @xmath15-@xmath6 path exists in @xmath53 . thus , those vertices can be listed by computing the connected component including @xmath6 in @xmath54 and checking the condition in step 2 for all @xmath52 for all @xmath37 .",
    "this can be done in @xmath7 time .",
    "the construction of @xmath55 is done in @xmath56 time by constructing it from @xmath53 .",
    "therefore , the time complexity of an iteration is @xmath7 .",
    "let us consider the recursion tree of the algorithm which is a tree representing the recursive structure of the algorithm .",
    "the vertex of the recursion tree corresponds to an iteration , and each iteration and its parent are connected by an edge .",
    "the leaves correspond to the iterations generating no recursive calls , and the algorithm outputs a solution on each leaf . because of",
    "the condition given placed on vertices in step 2 , there is always at least one @xmath5-@xmath6 path in the given graph .",
    "this implies that at least one recursive call occurs when step 2 is executed .",
    "hence , the algorithm outputs a solution at every leaf of the recursion tree .",
    "the depth of the recursion tree is @xmath57 since at least one vertex is removed from the graph to generate a recursive call .",
    "we can conclude from these observations that the time complexity of the algorithm is @xmath58 where @xmath9 is the number of chordless @xmath5-@xmath6 paths in @xmath10 .",
    "next , we discuss the reduction of the time complexity to @xmath59 .",
    "we first rewrite the above algorithm as follows .",
    "we denote the vertex next to @xmath14 in path @xmath3 by @xmath60 .",
    "note that although we introduce several variables , the algorithms are equivalent .",
    "* enum_chordless_path2 * ( @xmath48 ) + 1 .",
    "* if * @xmath5 is adjacent to @xmath6 * then output * @xmath61 ; * return * + 2 .",
    "@xmath62 a chordless @xmath5-@xmath6 path in @xmath10 + 3 .",
    "* call * * enum_chordless_path2 * ( @xmath63 ) + 4 . * for each * @xmath64 * do * + 5 .  *",
    "if * there is a @xmath14-@xmath6 path in @xmath40 * then * + 6 .",
    "* call * * enum_chordless_path2 * ( @xmath65 ) + 7 . *",
    "end for *    we further rewrite the algorithm as follows .",
    "we compute the chordless @xmath5-@xmath6 path @xmath3 computed in step 2 of the above algorithm , before the start of the iteration , i.e. , in its parent , and give it as a parameter to the recursive call .",
    "* enum_chordless_path3 * ( @xmath66 ) + 1 . *",
    "if * @xmath5 is adjacent to @xmath6 * then output * @xmath61 ; * return * + 2 .",
    "* call * * enum_chordless_path3 * ( @xmath67 ) + 3 . * for each * @xmath64 * do * + 4 .  *",
    "if * there is an @xmath14-@xmath6 path in @xmath40 * then * + 5 .",
    "@xmath68 a chordless @xmath14-@xmath6 path in @xmath40 ( found by a breadth first search ) + 6 .",
    "* call * * enum_chordless_path3 * ( @xmath69 ) + 7 .",
    "* end if * + 8 .",
    "* end for *    figure [ p2 ] illustrates an example of the recursive structure of this algorithm .",
    "the tail of an arrow is a parent and the head is its child .",
    "we call the child generated in step 2 _ first child _ , and the arrow pointing at the first child is drawn with a bold line .",
    "we can make a path by following the bold - arrows , and we call a maximal such path a",
    "_ straight path_. since the bottom of a straight path is a leaf , the number of straight paths is bounded by the number of chordless paths . since the head of a non - bold arrow always points an end of a straight path , the number of non - bold arrows , that correspond to the recursive calls done in step 6 , is bounded by the number of straight paths .",
    "from these observations , we infer the following points regarding time complexity .    *",
    "an iteration takes @xmath7 time when a chordless path is output .",
    "this computation time is @xmath7 per chordless path .",
    "* steps 1 and 2 take @xmath70 time where @xmath71 is the number of edges adjacent to vertices in @xmath44 . this time is spent checking the adjacency of @xmath5 and @xmath6 and constructing @xmath40 for all @xmath37 .",
    "this comes from that @xmath40 can be constructed from @xmath72 by adding edges adjacent to @xmath14 in @xmath56 time . *",
    "the number of executions of the for loop in step 3 is bounded by @xmath73 .",
    "their sum over all iterations in a straight path does not exceed the number of edges .",
    "* steps 5 and 6 take @xmath7 time to find a chordless @xmath14-@xmath6 path , and to construct @xmath40 . since the recursive call in step 6 corresponds to a straight path , this computation time is @xmath7 per chordless path . *",
    "the execution time for step 4 is @xmath7 .",
    "we see from the above that the bottle neck in terms of time complexity is step 4 .",
    "the other parts of the algorithm takes @xmath7 time per chordless @xmath5-@xmath6 path .",
    "we speed up step 4 by using the following property .",
    "@xmath74 includes a @xmath14-@xmath6 path for @xmath37 if and only if there is a vertex @xmath75 such that @xmath72 includes a @xmath15-@xmath6 path .    in each iteration we put mark on vertices @xmath15 such that there is a @xmath15-@xmath6 path in @xmath72 .",
    "step 4 is then done in @xmath56 time by looking at the marks on the vertices in @xmath27 .",
    "the marks can be put in short time , by updating the marks put in the first child .",
    "the condition of step 4 is checked by finding all vertices in @xmath72 from which going to @xmath6 is possible .",
    "this also takes @xmath7 time , but the time is reduced by re - using the results of the computation done for the first child . in the first child , marks are put according to the reachability to @xmath6 in @xmath76 .",
    "to put marks for @xmath72 , we find all vertices @xmath15 such that any @xmath15-@xmath6 path in @xmath72 includes a vertex of @xmath77 .",
    "this is done by using a graph search starting from the vertices of @xmath77 that are adjacent to a marked vertex , and visiting only unmarked vertices .",
    "the time taken is linear in the number of edges adjacent to newly marked vertices .",
    "consider the computation time with respect to step 4 , for the iterations in a straight path .",
    "in these operations , a vertex ( resp . , an edge ) gets a mark at most once , i.e. , it never gets a mark twice .",
    "thus , the total computation time for this computation is linear in the sum of the degrees of marked vertices and vertices in @xmath78 , and is bounded by @xmath7 .",
    "the computation time for step 4 is thus reduced to @xmath7 per chordless @xmath5-@xmath6 path .",
    "when a recursive call for a non - first child is made , all marks are deleted .",
    "we then perform a graph search starting from @xmath6 to put the marks .",
    "both steps take @xmath7 time . since this computation is done only when generating non - first child , the total number of occurrences of this computation is bounded by the number of maximal paths , i.e. , the number of chordless paths .",
    "thus , this computation takes @xmath7 time for each chordless path .",
    "the algorithm is written as follows .",
    "* enum_chordless_path4 * ( @xmath66 ) + 1 . *",
    "if * @xmath5 is adjacent to @xmath6 * then output * @xmath61 ; * go to * 11 + 2 .",
    "* call * * enum_chordless_path4 * ( @xmath79 ) + 3 . put mark by graph search on @xmath72 from vertices in @xmath78 + 4 . * for each * @xmath64 * do * + 4 .  *",
    "if * a vertex adjacent to @xmath14 is marked * then * + 5 .",
    "delete marks from all vertices in @xmath10 + 6 .",
    "@xmath68 a chordless @xmath14-@xmath6 path in @xmath40 + 7 .",
    "* call * * enum_chordless_path4 * ( @xmath69 ) + 8 .",
    "recover the marks deleted in step 5 , by graph search starting from @xmath6 on @xmath72 + 9 .",
    "* end if * + 10 . *",
    "end for *    the chordless @xmath5-@xmath6 paths in a given graph @xmath4 can be enumerated in @xmath7 time per chordless path , in particular , polynomial time delay .",
    "we can see the correctness in the above .",
    "the time complexity of an iteration is @xmath7 , and each iteration outputs an @xmath5-@xmath6-path .",
    "moreover , the height of the recursion tree is at most @xmath80 , thus the time between two consecutive output paths is bounded by @xmath81 .",
    "this concludes the theorem .",
    "the chordless cycles in a given graph @xmath4 can be enumerated in @xmath7 time per chordless cycle , in particular , polynomial time delay .",
    ".computational time ( in seconds ) for randomly generated graphs [ cols=\">,>,>,>,>,>,>,>,>,>,>\",options=\"header \" , ]      chordless cycle enumeration has already been implemented as a part of a database system of chemoinformatics@xcite , composed of structural data of chemical compounds . in this system ,",
    "the number of chordless cycles in the chemical graph of a chemical compound is considered to be an attribute of the compound . in response to a query about the chemical structure of a compound , the system searches in the database for structures partially similar to the structure of query compound , and",
    "predict some functions of the query compound .",
    "a chemical graph is usually sparse and is globally a tree or a combination of several large cycles .",
    "small components can be attached to the large cycles .",
    "thus , the number of chordless cycles is not so huge and is tractable in most cases .",
    "the program code was implemented in the cast / cnmr system for predicting the @xmath82c - nmr chemical shift@xcite .",
    "the codes and a more precise description of this system are available at http://research.nii.ac.jp/hsatoh/subjects/nmr-e.html .",
    "the information obtained about chordless cycles is used to improve the accuracy for the predicted values when the ring attributes affects the nmr spectrum . the cast / cnmr system predicts chemical shifts by using a chemical structure - spectrum database , containing mainly natural organic products and their related synthetic compounds .",
    "since most of the compounds include chains of fused rings , enumerating all rings for these compounds would greatly increase the output size , with lots of data useless for nmr prediction .",
    "therefore , the chordless cycle was adopted as a relevant ring attribute for the cast / cnmr system . for accurate nmr prediction for carbon atoms , an error within 1.0 ppm ( parts per million )",
    "is generally required .",
    "use of chordless cycle information reduced error values of -4.1 to 1.6 ppm for some problematic carbon atoms to less than 1.0 ppm@xcite .",
    "we proposed an algorithm for enumerating all chordless @xmath5-@xmath6 paths , that is applicable to chordless cycle enumeration without increasing the time complexity . by reusing the results of the subroutines , the computation time is reduced to @xmath7 for each chordless path .",
    "the results of the computational experiments showed that the algorithm works well for both random graphs and real - world graphs ; the computation time was @xmath57 in dense graphs , and almost constant for sparse graphs .",
    "the results also showed that the number of chordless cycles is small compared to the number of usual cycles .",
    "this algorithm thus paves the way to efficient use of cycle enumeration in data mining .",
    "99 t. asai , h. arimura , t. uno and s. nakano , discovering frequent substructures in large unordered trees , lnai * 2843 * ( proc .",
    "ds 2003 ) , pp .",
    "4761 ( 2003 ) .",
    "a. t. balaban , p. filip , t. s. balaban , computer program for finding all possible cycles in graphs , j. comput . chem . * 6 * , pp 316 - 329 ( 1985 ) .",
    "g.  m.  downs , v.  j.  gillet , j.  d.  holiday , m.  f.  lynch , review of ring perception algorithms for chemical graphs , j. chem .",
    "* 29 * , pp .",
    "172187 ( 1989 )",
    ". g. m. downs , ring perception , the encyclopedia of computational chemistry * 4 * , john wiley & sons , chichester , uk , 1998 .",
    "d. eppstein , finding the k smallest spanning trees , lncs * 447 * , pp .",
    "3847 ( 1990 ) .",
    "r. ferreira , r. grossi , a. marino , n. pisanti , r. rizzi and g. sacomoto , optimal listing of cycles and st - paths in undirected graphs , soda 2013 , t. hanser , p. jauffret , g. gaufmann , a new algorithm for exhaustive ring perception in a molecular graph , j. chem .",
    "sci . * 36 * , pp .",
    "11461152 ( 1996 ) . s. kapoor and h. ramesh , an algorithm for enumerating all spanning trees of a directed graph , algorithmica * 27 * , pp .",
    "120130 ( 2000 ) .",
    "a. inokuchi , t. washio and h. motoda , complete mining of frequent patterns from graphs , machine learning * 50 * , pp .",
    "321354 ( 2003 ) . k. makino and t. uno , new algorithms for enumerating all maximal cliques , lncs * 3111 * ( proc .",
    "swat 2004 ) , pp .",
    "260272 ( 2004 ) .",
    "s. parthasarathy , m. j. zaki , m. ogihara and s. dwarkadas , incremental and interactive sequence mining , cikm 1999 , pp .  251258 ( 1999 ) .",
    "r. c. read and r. e. tarjan , bounds on backtrack algorithms for listing cycles , paths , and spanning trees , networks * 5 * , pp .",
    "237252 ( 1975 ) .",
    "e. tomita , a. tanaka and h. takahashi , the worst - case time complexity for generating all maximal cliques and computational experiments , theo .",
    "* 363 * , pp .",
    "2842 ( 2006 ) .",
    "h. satoh , h. koshino , t. uno , s. koichi , s. iwata and t. nakata , effective consideration of ring structures in cast / cnmr for highly accurate @xmath82c nmr chemical shift prediction , tetrahedron * 61 * , pp .",
    "7431 - 7437 ( 2005 ) .",
    "h. satoh , h. koshino , j. uzawa , t. nakata , cast / cnmr : highly accurate @xmath82c nmr chemical shift prediction system considering stereochemistry , tetrahedron * 59 * , pp 4539 - 4547 ( 2003 ) .",
    "uci machine learning repository , http://archive.ics.uci.edu/ml/ t. uno , a fast algorithm for enumerating bipartite perfect matchings , lncs * 2223 * ( proc .",
    "isaac 2001 ) , pp .",
    "367379 ( 2001 ) .",
    "t. uno , an output linear time algorithm for enumerating chordless cycles , ipsj , sig - al 92 ( 2003 ) ( in japanese , technical report , non - refereed ) .",
    "m. wild , generating all cycles , chordless cycles , and hamiltonian cycles with the principle of exclusion , j. discrete alg .",
    "* 6 * , pp .",
    "93102 ( 2008 ) ."
  ],
  "abstract_text": [
    "<S> a chordless cycle ( induced cycle ) @xmath0 of a graph is a cycle without any chord , meaning that there is no edge outside the cycle connecting two vertices of the cycle . </S>",
    "<S> a chordless path is defined similarly . in this paper </S>",
    "<S> , we consider the problems of enumerating chordless cycles / paths of a given graph @xmath1 and propose algorithms taking @xmath2 time for each chordless cycle / path . in the existing studies , </S>",
    "<S> the problems had not been deeply studied in the theoretical computer science area , and no output polynomial time algorithm has been proposed . </S>",
    "<S> our experiments showed that the computation time of our algorithms is constant per chordless cycle / path for non - dense random graphs and real - world graphs . </S>",
    "<S> they also show that the number of chordless cycles is much smaller than the number of cycles . </S>",
    "<S> we applied the algorithm to prediction of nmr ( nuclear magnetic resonance ) spectra , and increased the accuracy of the prediction . </S>"
  ]
}