{
  "article_text": [
    "over the last few years , model checking based on abstraction - refinement has become a popular technique for the analysis of software . in particular",
    "the abstraction technique of choice is a property preserving over - approximation called predicate abstraction  @xcite and the refinement removes spurious behavior based on automatically analyzing abstract counter - examples .",
    "this approach is often referred to as cegar ( counter - example guided automated refinement ) and forms the basis of some of the most popular software model checkers @xcite .",
    "furthermore , a strength of model checking is its ability to automate the detection of subtle errors and to produce traces that exhibit those errors .",
    "however , over - approximation based abstraction techniques are not particularly well suited for this , since the detected defects may be spurious due to the over - approximation  hence the need for refinement .",
    "we propose an alternative approach based on refinement of under - approximations , which effectively preserves the defect detection ability of model checking in the presence of aggressive abstractions .",
    "the technique uses a combination of ( explicit state ) model checking , predicate abstraction and automated refinement to efficiently analyze increasing portions of the feasible behavior of a system . at each step , either an error is found , we are guaranteed no error exists , or the abstraction is refined . more precisely , the proposed model checking technique traverses the concrete transitions of the system and for each explored concrete state , it stores an abstract version of the state .",
    "the abstract state , computed by predicate abstraction , is used to determine whether the model checker s search should continue or backtrack ( if the abstract state has been visited before ) .",
    "this effectively explores an under - approximation of the feasible behavior of the analyzed system .",
    "hence all counter - examples to safety properties are preserved .",
    "refinement uses weakest precondition calculations to check , with the help of a theorem prover , whether the abstraction introduces any loss of precision with respect to each explored transition .",
    "if there is no loss of precision due to abstraction ( we say that the abstraction is _ exact _ ) the search stops and we conclude that the property holds .",
    "otherwise , the results from the failed checks are used to refine the abstraction and the whole verification process is repeated anew . in general , the iterative refinement may not terminate .",
    "however , if a finite bisimulation quotient  @xcite exists for the system under analysis , then the proposed approach is guaranteed to eventually explore a finite structure that is bisimilar to the original system .",
    "the technique can also be used in a lightweight manner , without a theorem prover , i.e. the refinement guided by the exactness checks is replaced with refinement based on syntactic substitutions @xcite or heuristic refinement .",
    "the proposed technique can be used for systematic testing , as it examines increasing portions of the system under analysis .",
    "in fact , our method extends existing approaches to testing that use abstraction mappings  @xcite , by adding support for automated abstraction refinement .",
    "our approach can be contrasted with the work on predicate abstraction for modal transition systems  @xcite , used in the verification and refutation of branching time temporal logic properties . an abstract model for such logics",
    "distinguishes between _ may _ transitions , which over - approximate transitions of the concrete model , and _ must _ transitions , which under - approximate the concrete transitions ( see also  @xcite ) . as we show in the next section ( and we discuss in more detail in section  [ sec : discussions ] ) , the technique presented here explores and generates a structure which is more precise ( contains more feasible behaviors ) than the model defined by the _ must _ transitions , for the same abstraction predicates .",
    "the reason is that the model checker explores transitions that correspond not only to _ must _ transitions , but also to _ may _ transitions that are feasible .",
    "moreover , unlike  @xcite and over - approximation based abstraction techniques @xcite , the under - approximation and refinement approach does not require the a priori construction of the abstract transition relation , which involves exponentially many theorem prover calls ( in the number of predicates ) , regardless of the size of ( the reachable portion of ) the analyzed system . in our case",
    ", the model checker executes concrete transitions and a theorem prover is only used during refinement , to determine whether the abstraction is exact with respect to each executed transition .",
    "every such calculation makes at most two theorem prover calls , and it involves only the _",
    "reachable _ state space of the system under analysis .",
    "another difference with previous abstraction techniques is that the refinement process is not guided by the spurious counter - examples , since no spurious behavior is explored . instead",
    ", the refinement is guided by the failed exactness checks for the explored transitions .",
    "to the best of our knowledge , the presented approach is the first predicate abstraction based analysis which focuses on automated refinement of under - approximations with the goal of efficient error detection .",
    "we illustrate the application of the approach for checking safety properties in concurrent programs .",
    "the rest of the paper is organized as follows .",
    "section  [ sec : example ] shows an example illustrating our approach .",
    "section  [ sec : background ] gives background information .",
    "section  [ sec : algorithm ] describes the main algorithm for performing concrete model checking with abstract matching and refinement .",
    "section  [ sec : correctnesstermination ] discusses correctness and termination ; section  [ sec : discussions ] discusses other interesting properties for the algorithm .",
    "section  [ sec : extensions ] proposes extensions to the algorithm .",
    "section  [ sec : applications ] illustrates applications of the approach , section  [ sec : related - work ] discusses related work , and section  [ sec : conclusions ] concludes the paper .",
    "= 4.9 in    the example in figure  [ fig : comparison ] illustrates some of the main characteristics of our approach .",
    "figure  [ fig : comparison ] * ( a ) * shows the state space of a concrete system that has only one variable @xmath0 ; states are labelled with the program counter ( e.g. @xmath1 , @xmath2 , @xmath3 ,  ) and the concrete value of  @xmath0 . figure  [ fig : comparison ] * ( b ) * shows the abstract system induced by the _ may _ transitions for predicate @xmath4 .",
    "figure  [ fig : comparison ] * ( c ) * shows the abstract system induced by the _ must _ transitions for predicate @xmath5 .",
    "figure  [ fig : comparison ] * ( d ) * shows the state space explored using our proposed approach , for an abstraction specified by predicate @xmath5 .",
    "dotted circles denote the abstract states which are stored , and used for matching , during the concrete execution of the system .",
    "the approach explores only the _ feasible _ behavior of the concrete system , following transitions that correspond to both _ may _ and _ must _ transitions , but it might miss behavior due to abstract matching .",
    "for example , state @xmath6 is not explored , assuming a breadth - first search , since @xmath7 was matched with @xmath8  both have the same program counter and both satisfy @xmath5 . notice that , with respect to reachable states , the produced structure is a better under - approximation ( it `` covers '' more states ) than the _ must _ abstraction .",
    "figure  [ fig : comparison ] * ( e ) * illustrates concrete execution with abstract matching , after a refinement step , which introduced a new predicate @xmath9 . the resulting structure is an exact abstraction of the concrete system .",
    "to make the presentation simple , we use as a specification language a guarded commands language over integer variables . most of the results extend directly to more sophisticated programming languages .",
    "let @xmath10 be a finite set of integer variables .",
    "expressions over @xmath10 are defined using standard boolean ( @xmath11 ) and binary ( @xmath12 ) operations .    a _ model _",
    "is a tuple @xmath13 .",
    "@xmath14 is a finite set of transitions , where @xmath15 , @xmath16 is a guard and @xmath17 are assignments to the variables represented by tuple @xmath18 .    throughout the paper ,",
    "we write concurrent assignments @xmath19 as sequences , to improve readability .",
    "the semantics of program models uses transition systems .",
    "a _ transition system _ over a finite set of atomic propositions @xmath20 is a tuple @xmath21 where @xmath22 is a ( possibly infinite ) set of states , @xmath23 is a finite set of deterministic transition relations : @xmath24 , @xmath25 is an initial state , and @xmath26 is a labeling function .",
    "state @xmath27 is _ reachable _ if there exists a sequence of zero or more transitions from the initial state such that @xmath28 ( denoted @xmath29 ) .",
    "the set of _ reachable labelings _",
    "@xmath30 is @xmath31 .",
    "the notation @xmath32 means that there is no @xmath33 transition from the state @xmath27 .",
    "[ def : concretesemantics ] the _ concrete semantics _ of model @xmath34 is transition system @xmath35 @xmath36 @xmath37 , @xmath38 , @xmath39 over @xmath20 , where :    * @xmath40 , i.e. states are valuations of variables , * @xmath41 ; the semantics of guards ( boolean expressions ) and updates is as usual ; guards are functions @xmath42 , written as @xmath43 ; updates are functions @xmath44 , * @xmath25 is the zero valuation ( @xmath45 ) , * @xmath46 .",
    "let @xmath47 be a predicate representing a set of states .",
    "then the _ strongest postcondition _ of @xmath47 with respect to transition @xmath33 is @xmath48 ; @xmath49 defines the successors by transition @xmath33 of the states characterized by @xmath47 .",
    "the _ weakest precondition _ of @xmath47 with respect to transition @xmath33 is @xmath50 ; @xmath51 characterizes the largest set of states whose successors by transition @xmath33 satisfy @xmath47 . for guarded commands ,",
    "the weakest precondition can be expressed as @xmath52)$ ] .",
    "we will use the following property  @xcite : @xmath53 iff @xmath54 .",
    "predicate abstraction is a special instance of the framework of abstract interpretation @xcite that maps a ( potentially infinite state ) transition system into a finite state transition system via a set of predicates @xmath55 over the program variables .",
    "let @xmath56 be a set of bitvectors of length  @xmath57 .",
    "we define abstraction function @xmath58 , such that @xmath59 is a bitvector @xmath60 such that @xmath61 .",
    "let @xmath62 be the set of all abstraction predicates that evaluate to _ true _ for a given state @xmath27 , i.e. @xmath63 . for succinctness we sometimes write @xmath59 to denote @xmath64 .",
    "we also give here the definitions of _ may _ and _ must _ abstract transitions . although not necessary for formalizing our algorithm , these definitions",
    "clarify the comparison with related work .",
    "for two abstract states ( bitvectors ) @xmath65 and @xmath66 :    * @xmath67 iff for all concrete states @xmath68 such that @xmath69 , there exists concrete state @xmath70 such that @xmath71 and @xmath72 , * @xmath73 iff there exists concrete state @xmath68 such that @xmath69 and there exists concrete state @xmath70 such that @xmath71 , such that @xmath72 .",
    "algorithms for computing abstractions using over - approximation based predicate abstraction are given in e.g. @xcite ( they compute _ may _ abstract transitions automatically , with the help of a theorem prover ) .",
    "in the worst case , these algorithms make @xmath74 calls to the theorem prover for each program transition .",
    "a symmetric relation @xmath75 is a _ bisimulation relation _",
    "iff for all @xmath76 :    * @xmath77 * for every @xmath78 there exists @xmath79 such that @xmath80    the _ bisimulation _ is the largest bisimulation relation , denoted @xmath81 .",
    "two transition systems are bisimilar if their initial states are bisimilar .",
    "as @xmath81 is an equivalence relation , it induces a _ quotient _ transition system whose states are equivalence classes with respect to @xmath81 and there is a transition between two equivalence classes @xmath1 and @xmath2 if @xmath82 and @xmath83 such that @xmath84 .",
    "figure  [ fig : search - with - check ] shows the reachability procedure that performs model checking with abstract matching ( @xmath85 ) .",
    "it is basically concrete state space exploration with matching on abstract states ; the main modification with respect to classical state space search is that we store @xmath59 instead of @xmath27 .",
    "the procedure uses the following data structures :    * @xmath86 is a set of abstract states visited so far , * @xmath87 is a set of abstract transitions visited so far , * @xmath88 is a set of concrete states to be explored .",
    "search(m , ) _ new = ; s_0 |wait| ; _ ( s_0 )",
    "|states| |wait| s |wait| l(_(s ) ) = \\ { a ap s a } i 1 n s g_i _ ( s ) g_i g_i _ new s = e_i(s ) _ ( s ) _ ( s)[e_i()/ ] _ ( s)[e_i()/ ] _ new _ ( s ) |states|",
    "s |wait| _",
    "( s ) |states| ( _ ( s ) , i , _ ( s ) ) |transitions|    _ ( s ) g_i g_i _ new a = ( |states| , |transitions| , _ ( s_0 ) , l ) ( a , _ new )    the procedure performs validity checking , using a theorem prover , to determine whether the abstraction is _ exact _ with respect to each explored transition  see discussion below .",
    "the set @xmath89 maintains the list of abstraction predicates .",
    "the procedure returns the computed structure and a set of new predicates that are used for refinement .",
    "note that we never abstract the program counter .",
    "figure  [ fig : refinement - search ] gives the iterative refinement algorithm for checking whether @xmath34 can reach an error state described by @xmath90 ( which is a boolean combination of propositions from @xmath20 ) .",
    "the algorithm starts with @xmath20 as the initial set of abstraction predicates . at each iteration of the loop ,",
    "the algorithm invokes procedure @xmath85 to analyze an under - approximation of the system , which either violates the property , it is proved to be correct ( if the abstraction is found to be exact with respect to all transitions ) , or it needs to be refined .",
    "counter - examples are generated as usual ( with depth - first search order using the stack , with breadth - first search order using parent pointers ) .",
    "refinementsearch(m , ) j=1 ; _ j = ap true ( a_i , _",
    "j+1 ) = search(m , _ j ) a_j _ j+1 = _ j j = j+1      we say that abstraction function @xmath91 is _ exact _ with respect to transition @xmath92 iff for all @xmath68 such that @xmath93 there exists @xmath94 such that @xmath95 and @xmath96 . in other words , @xmath92 is exact with respect to @xmath91 iff @xmath97 .",
    "moreover , the abstraction function @xmath91 is _ exact _ with respect to a state @xmath27 iff the following conditions hold : ( 1 ) @xmath91 is exact with respect to all transitions @xmath92 and ( 2 ) if @xmath32 then for all @xmath68 such that @xmath98 we have @xmath99 .",
    "the notion of exactness is related to _ completeness _ in abstract interpretation ( see  @xcite ) , which states that no loss of precision is introduced by the abstraction .",
    "checking that the abstraction is exact with respect to a concrete transition @xmath100 amounts to checking that @xmath101 , equivalent to @xmath102 , is valid .",
    "note that @xmath103)$ ] .",
    "therefore @xmath102 is equivalent to @xmath104)$ ] .",
    "the abstraction is exact with respect to state @xmath27 when the following conditions hold : ( 1 ) @xmath105)$ ] , equivalent to @xmath106)$ ] , is valid for each @xmath33 such that @xmath107 and ( 2 )  @xmath108 is valid for each @xmath33 such that @xmath109 .",
    "checking the validity for these formulas is in general undecidable .",
    "as is customary , if the theorem prover can not decide the validity of a formula , we assume that it is not valid . this may cause some unnecessary refinement , but it keeps the correctness of the approach . if the abstraction can not be proved to be exact with respect to some transition , then the new predicates from the failed formula are added to the set of abstraction predicates . intuitively , these predicates will be useful for proving exactness in the next iteration .",
    "in this section we discuss the main properties of the iterative refinement algorithm .",
    "we first state the main theorems , after which we give the technical lemmas and proofs ( the reader may wish to skip this technical material on the first reading ) .",
    "we first show that , if the iterative algorithm terminates then the result is correct and moreover , if the error state is unreachable , the output structure is bisimilar to the system under analysis :    ( correctness ) [ theorem : correctness ] if   @xmath110 terminates then :    * if it returns a counter - example , then it is a real error , * if it returns ` unreachable ' , then the error state is indeed unreachable in @xmath34 and moreover the computed structure is bisimilar to @xmath35",
    ".    in general , the proposed algorithm might not terminate ( the reachability problem for our modeling language is undecidable ) .",
    "however , the algorithm is guaranteed to eventually find all the reachable labelings ( including all the reachable errors ) of the concrete program , although it might not be able to detect that ( to decide termination ) . moreover ,",
    "if the ( reachable part of the ) system under analysis has a finite bisimulation quotient , then the algorithm eventually produces a finite bisimilar structure .",
    "( termination ) [ th : termination ] let the @xmath85 use breadth - first search order and let @xmath111 , @xmath112 ,  be a sequence of transition systems generated during iterative refinement performed by @xmath110 .",
    "then    * there exists @xmath113 such that @xmath114 , * if the reachable part of the bisimulation quotient is finite , then there exists @xmath113 such that @xmath115 .",
    "note that a consequence of this theorem is that if an error is reachable it is eventually reported by our algorithm . also note that for the second part of the theorem , we do not require that both the reachable and unreachable parts of the system have a finite bisimulation quotient , but only the reachable part needs to be finite ( of course , if both the reachable and unreachable parts are finite , then it follows that the reachable part is also finite ; the converse is not true ) .",
    "here we provide several technical lemmas and the proofs for the two main theorems .",
    "we use the following notation : a state @xmath27 is _ visited _ during the search if it is inserted into @xmath88 ; a state @xmath27 is _ considered _ during the search if it is generated as a successor of some state in the @xmath116 loop ; a state @xmath68 is _ matched _ to a state @xmath70 if the check @xmath117 fails because @xmath118 and @xmath70 was visited before .",
    "we say that transition @xmath92 is exact if @xmath91 is exact with respect to it .",
    "note that sometimes we let @xmath119 denote just the structure @xmath1 computed by the algorithm and not the tuple @xmath120 .",
    "also note that @xmath121 starts with @xmath20 as the initial set of predicates .",
    "for the proofs , we need to refine the definition of bisimulation .    a symmetric relation @xmath122 is a @xmath123-bisimulation relation iff :    * for all @xmath124 * if @xmath125 then there exists @xmath126-bisimulation relation @xmath127 such that for all @xmath128    the @xmath123-bisimulation is the largest @xmath123-bisimulation relation , denoted @xmath129 .",
    "note that the bisimulation is a @xmath123-bisimulation relation for every @xmath123 .",
    "we first show that the reachable labelings computed by the iterative algorithm @xmath121 is indeed an _ under - approximation _ of the reachable labelings of the program under analysis ( lemmas  [ lemma : must - sequences ] and [ lemma : must - search - concrete ] ) .",
    "therefore , all the reported counter - examples correspond to real errors .",
    "we then show that when @xmath121 reports unreachable ( i.e. when the set @xmath89 of predicates returned for the current iteration is equal to the set @xmath130 of predicates from the previous iteration ) then the computed structure @xmath1 is bisimilar to @xmath35 ( lemmas  [ lemma : bisim - ok ] and [ lemma : check - correctness ] ) .",
    "[ lemma : must - sequences ] if a state @xmath27 is reachable in @xmath35 via exact transitions with respect to @xmath91 , then there exists @xmath131 such that @xmath131 is visited during the @xmath119 and @xmath132 .    by induction with respect to the number of exact transitions from the initial state necessary for reaching the state @xmath27 .",
    "basic step ( @xmath133 ) is trivial . for the induction step , suppose that state @xmath27 is reachable via sequence of exact transitions : @xmath134 . by the induction hypothesis there",
    "exists @xmath135 such that @xmath135 is visited and @xmath136 .",
    "because the abstraction is exact with respect to @xmath137 , there must be @xmath131 such that @xmath138 and @xmath139 .",
    "this successor @xmath131 is considered during the visit of @xmath135 .",
    "there are two cases to be analyzed .    1 .",
    "@xmath131 is added to @xmath88 and later visited , 2 .",
    "@xmath131 is matched to a previously visited state @xmath140 such that @xmath141 .    in both cases",
    "we get that some state with the same abstract counterpart as @xmath27 is visited during the search .",
    "@xmath142    [ lemma : must - search - concrete ] @xmath143 .",
    "it is easy to verify that the following is an invariant of the search : @xmath88 is a subset of reachable states in @xmath35 .",
    "the lemma follows .",
    "@xmath142    [ lemma : bisim - ok ] let @xmath144 .",
    "if for all reachable states @xmath145 it holds that @xmath146 , then @xmath147 .",
    "consider relation @xmath148 defined as : @xmath149 iff @xmath150 or @xmath68 is matched to @xmath70 .",
    "then @xmath148 is a bisimulation relation between @xmath151 and @xmath35 .",
    "@xmath142    [ lemma : check - correctness ] let @xmath152 .",
    "if @xmath153 , then .    due to lemma",
    "[ lemma : bisim - ok ] it is sufficient to show that if @xmath153 then @xmath91 induces a bisimulation relation on the reachable part of the transition system  @xmath35 . we first show that every reachable state in @xmath35 is reached by exact transitions .",
    "we proceed on induction by the number of transitions from the initial state to @xmath27 .",
    "basic step ( @xmath133 ) is trivial . for the induction step , suppose that state @xmath27 is reachable via a sequence of exact transitions of length @xmath123 . by lemma  [ lemma : must - sequences ]",
    "some state @xmath131 such that @xmath154 is visited during the search . during the visit of the state @xmath131 we check exactness of the abstraction",
    "( see section  [ sec : check - exact - abstr ] ) .",
    "since @xmath153 it follows that the abstraction is exact for @xmath131 , i.e. , @xmath155 iff @xmath156 and for every outgoing transition @xmath79 and @xmath157 there exists @xmath68 such that @xmath158 and @xmath159 . since @xmath33 is deterministic , it follows that @xmath68 is the only successor of @xmath27 by transition @xmath33 and transition @xmath78 is also exact .",
    "moreover , it satisfies the same criterion for bisimulation , i.e. for all @xmath140 such that @xmath160 there exists @xmath161 such that @xmath162 and @xmath163 .",
    "@xmath142    the first claim follows from the fact that @xmath85 produces an under - approximation ( lemma  [ lemma : must - search - concrete ] ) .",
    "the second claim follows from lemma  [ lemma : check - correctness ] .",
    "@xmath142      in order to prove theorem  2 , we study sequences @xmath164 of transition systems generated during @xmath121 .",
    "we assume that @xmath85 uses breadth - first search order .",
    "the basic idea of the proof is that any two states that are in different bisimulation classes ( @xmath165 ) are eventually distinguished by the abstraction function , i.e. @xmath166 such that @xmath167 ( lemma  [ lemma : states - distinguieshed ] )",
    ". moreover , each bisimulation class of @xmath35 is eventually visited by @xmath121 ( lemma  [ lemma : each - bisim - class - reached ] ) and the finite set of reachable labelings emerges ( lemmas  [ lemma : all - labelings ] and  [ lemma : finite - quotient ] ) .",
    "[ lemma : states - distinguieshed ] let @xmath164 be a sequence of transition systems generated during an infinite run of @xmath121 and @xmath168 there exists infinitely many @xmath113 such that @xmath169 .",
    "if @xmath170 and @xmath171 then there exists @xmath113 such that @xmath172 for all @xmath173 .    by induction with respect to @xmath123 where @xmath123 is the smallest number such that @xmath174 .",
    "basic step : for @xmath133 it means that @xmath175 and therefore @xmath176 .",
    "induction step @xmath177 : let @xmath178 be such that @xmath179 and @xmath180 .",
    "since @xmath27 is visited in infinitely many iterations of @xmath85 , @xmath68 is considered in infinitely many iteration of @xmath85 and therefore one of the following must hold :    1 .",
    ". then we can apply induction hypothesis , i.e. there exits @xmath113 such that @xmath182 for all @xmath183 .",
    "state @xmath68 is matched to some state in infinitely many runs of @xmath85 .",
    "since we use breadth - first order , there are only finitely many states to which it can be matched ( with breadth - first search order the state can be matched only to states with lower or equal distance from the initial state ) . therefore , there exists a state @xmath70 such that @xmath68 is matched to @xmath70 in infinitely many runs of @xmath85 , this means that @xmath184 for all @xmath113 . from the induction hypothesis",
    "we get that @xmath185 and hence @xmath186 . moreover , from the induction hypothesis we get that there exists @xmath187 such that @xmath188 for all @xmath189",
    ". therefore @xmath182 for all @xmath189 .    in both cases",
    "we get that there exists @xmath113 such that @xmath190 is not exact with respect to @xmath78 , therefore @xmath191 will be included in @xmath192 and therefore @xmath193 .",
    "@xmath142    [ lemma : each - bisim - class - reached ] for each reachable bisimulation class @xmath2 of @xmath35 there exists a state @xmath194 such that @xmath27 is visited by @xmath195 infinitely often .",
    "by induction with respect to the length of the shortest path by which some state from @xmath2 is reachable .",
    "basic step is obvious .",
    "induction step : let state from @xmath2 be reachable via path @xmath196 . by induction hypothesis some state @xmath197 is reached during the refinement search infinitely often .",
    "consider state @xmath140 such that @xmath198 .",
    "it holds that @xmath199 and from lemma  [ lemma : states - distinguieshed ] we get that @xmath140 is visited infinitely often .",
    "@xmath142    [ lemma : all - labelings ] let @xmath164 be a sequence of transition systems generated during an infinite run of @xmath110 .",
    "there exists @xmath113 such that @xmath200 .    for each @xmath201",
    "we choose some bisimulation class @xmath2 such that @xmath202 . in this way",
    "we obtain a finite set of bisimulation classes @xmath203 which covers all labels in @xmath204 .",
    "note that @xmath204 is finite because @xmath20 is finite .",
    "now we show that there exists an iteration in which at least one state from each of these classes is visited .",
    "this is done similarly to the proof of lemma  [ lemma : each - bisim - class - reached ] .",
    "@xmath142    [ lemma : finite - quotient ] let @xmath164 be a sequence of transition systems generated during an infinite run of @xmath121 . if the reachable part of the bisimulation quotient is finite , then there exists @xmath113 such that @xmath205 .    by contradiction .",
    "suppose that @xmath206 . from lemma",
    "[ lemma : bisim - ok ] we get that there exists reachable @xmath207 such that @xmath208 and @xmath209 .",
    "we show ( similarly to the proof of lemma  [ lemma : must - sequences ] ) that there exists such @xmath27 which is visited infinitely often . from lemma  [ lemma : states - distinguieshed ]",
    "we get that eventually @xmath210 which is the contradiction .",
    "@xmath142    this theorem is a direct consequence of lemmas  [ lemma : all - labelings ] and  [ lemma : finite - quotient ] .  @xmath142",
    "having discussed correctness and termination , we now turn to other interesting properties of the algorithm .",
    "we should note that the proposed iterative algorithm is not guaranteed to terminate even for a finite state program .",
    "this situation is illustrated by the example from figure  [ fig : incomplete - refinement ] ; @xmath0 and @xmath211 are initialized to zero .",
    "the property that we check is that `` pc=1 '' is unreachable .",
    "although the program is finite state ( and therefore the problem can be easily solved with classical explicit model checking ) , it is quite difficult to solve using abstraction refinement techniques .",
    "the iterative algorithm does not terminate on this example : it keeps adding predicates @xmath212 . note that , in accordance with theorem  [ th : termination ] , it eventually produces a bisimilar structure .",
    "however , the algorithm is not able to detect termination , and it keeps refining indefinitely .",
    "the reason is that the algorithm keeps adding predicates that refine the unreachable part of the system under analysis .",
    "also note that the same problem occurs with over - approximation based abstraction techniques that use refinement based on weakest precondition calculations  @xcite .",
    "those techniques introduce the same predicates .",
    "moreover , unlike our technique , they will keep generating _ spurious _ counter - examples . for this example no may / must abstraction based on predicates and refinement with weakest precondition calculations can produce a structure that is bisimilar to the concrete system ( the concrete system is rather trivial  it has only one state ) .",
    "this example also illustrates another difference between the method presented here and over - approximation based predicate abstraction with refinement , in particular  @xcite . if the analyzed system has a _ reachable _ finite bisimulation quotient then our algorithm",
    "is guaranteed to find it ( see theorem  [ th : termination ] and lemma  [ lemma : finite - quotient ] ) .",
    "in contrast , the method in  @xcite will fail to compute a finite state abstraction for the example ; this result seems to contradict the bisimulation completeness claim ( theorem  3 ) from  @xcite .",
    "we conjecture that the method in  @xcite is not guaranteed to compute a finite state abstraction unless both the _ reachable and unreachable _ quotient is finite .",
    "@xmath213    to solve the problem of non - termination for finite state systems , we propose to use the following heuristic . if there is a transition for which we can not prove that the abstraction is exact in several subsequent iterations of the algorithm , then we add predicates describing the concrete state ; i.e. in the example from figure  [ fig : incomplete - refinement ] we would add predicates @xmath214 and @xmath215 .",
    "the abstraction eventually becomes exact with respect to each transition . and",
    "since the number of reachable transitions is finite , the algorithm must terminate .",
    "if the reachable part of @xmath35 is finite state then the modified algorithm terminates .      the search order used in @xmath85 (",
    "depth - first or breadth - first ) influences the size of the generated structure , the newly computed predicates , and even the number of iterations of the main algorithm . if there are two states @xmath68 and @xmath70 such that @xmath216 but @xmath217 then , depending on whether @xmath68 or @xmath70 is visited first , different parts of the transition system will be explored . for our implementation ,",
    "we use breadth - first search order .    [ cols=\"^,^,^ \" , ]      this is another well - known protocol for mutual exclusion .",
    "the protocol is similar to the ticket protocol ( the ticket protocol requires special hardware instruction like fetch - and - add , whereas the bakery protocol is applicable without any special instructions ) .",
    "the model has 10 variables .",
    "the property of interest is again mutual exclusion .",
    "the state space is infinite with a finite bisimulation quotient .",
    "the property can be proved by the algorithm in three iterations , using 31 predicates .",
    "for this example , we seeded an error by changing a guard @xmath218 into @xmath219 which creates a nontrivial error in the protocol .",
    "the tool can find the error in the first iteration .",
    "this is a `` classic '' example analyzed using predicate abstraction  @xcite .",
    "the property of interest is the correct use of a lock .",
    "our tool can prove that the property holds after one iteration ( using just the predicates from guards ) : the algorithm explores 10 concrete states , 9 abstract states and casts 3 queries to the theorem prover .",
    "for an erroneous version of the driver , the tool finds an error in the first iteration as well .",
    "these preliminary experiments show the merits of our approach .",
    "the approach proves to be effective in computing finite bisimilar structures of non - trivial infinite state systems and in finding errors using under - approximation based predicate abstraction . of course , much more experimentation is necessary to really assess the practical benefits of the proposed technique and a lot more engineering is required to apply it to real programming languages .",
    "extensions for handling complex features such as pointers , arrays and procedures , are tedious but conceptually not very hard .",
    "we also note that in some cases ( e.g. ticket2 , ticket3 and rax ) the number of explored concrete and abstract states stays the same after the first iteration ; however our algorithm needs more than two iterations to discover all the necessary abstraction predicates , according to the exactness criteria that we defined .",
    "the results suggest that it is possible to relax these criteria and still provide a guarantee that the relevant state space of the analyzed program has been explored .",
    "we leave this topic for future work .",
    "we should mention that the application of over - approximation based predicate abstraction to a java version of rax is described in detail in  @xcite . in that work ,",
    "four different predicates were used to produce an abstract model that is bisimilar to the original program .",
    "in contrast , the work presented here allowed more aggressive abstraction to recover feasible counter - examples .",
    "our technique explores transitions that are guaranteed to be feasible .",
    "in contrast , the over - approximation based techniques such as the ones from  @xcite may also explore transitions that are spurious and therefore could require additional refinement before reporting a real counter - example .",
    "as mentioned , over - approximation based abstraction techniques involve exponentially many theorem prover queries ( in the number of predicates ) , at each iteration .",
    "this computation is performed regardless of the size of ( the reachable portion of ) the analyzed system . in our case ,",
    "theorem prover queries are only performed during refinement and they involve only the _",
    "reachable _ state space of the system under analysis . on the other hand ,",
    "over - approximation based techniques are good at proving properties ( as they compute abstractions that are coarser than the bisimulation quotient but sufficient to prove safety properties ) .",
    "we believe however that the technique presented here is _ complementary _ to over - approximation abstractions and it should _ combined _ ( rather than compared ) with such techniques . our technique could be used for discovering efficiently feasible counter - examples in the space bounded by the abstraction predicates ( that are used in the over - approximation analysis ) . in the future",
    ", we plan to study more the strengths and weaknesses of each approach and to investigate their _",
    "throughout the paper , we have already discussed the relationship between our work and predicate abstraction ( see the previous section and also section  [ sec : discussions ] , where we compared our work with over - approximation approaches , in particular the work of namjoshi and kurshan  @xcite , and with under - approximation approaches using _ must _ transitions  @xcite ) .",
    "we discuss here other approaches that are closely related to ours .",
    "the work of grumberg et al .",
    "@xcite uses a refinement of an under - approximation to improve analysis of multi - process systems . the procedure in @xcite checks models with an increasing set of allowed interleavings of the given processes , starting from a single interleaving .",
    "it uses sat - based bounded model checking for analysis and refinement , whereas here we focus on explicit model checking and predicate abstraction , and we use weakest precondition calculations for abstraction refinement .",
    "another closely related work is that of lee and yannakakis  @xcite , which proposes an on - the - fly algorithm for computing the bisimulation quotient of an ( infinite state ) transition system .",
    "similar to our approach , the algorithm from  @xcite traverses concrete transitions while computing _ blocks _ of equivalent states ; if some transition is found to be _ unstable _ the block is _ split _ into sub - blocks .",
    "note however that unlike  @xcite our algorithm is geared towards error detection and it is formulated in terms of predicate abstraction with a clear separation between state exploration and refinement .",
    "there are other important differences between our approach and the work presented in  @xcite .",
    "we use refinement globally while the block splitting in  @xcite is local .",
    "this makes the approach in  @xcite more efficient in the number of visited states . on the other hand ,",
    "the global refinement has the advantage of faster propagating the new predicates across the system but it may lead to unnecessary refinement . as a consequence of this global refinement , our algorithm may not compute _ the _ bisimulation quotient ( as in  @xcite ) but rather just _ a _ bisimilar structure ( due to extra refinement ) .",
    "we view the experimental comparison of the two approaches as an interesting topic for future work .    in previous work",
    "@xcite , we developed a technique for finding feasible counter - examples in abstracted programs .",
    "the technique essentially explores an under - approximation defined by the _ must _ abstract transitions ( although the presentation is not formalized in these terms ) .",
    "the work presented here explores an under - approximation which is more precise than the abstract system defined by the _ must _ transitions . hence it has a better chance of finding bugs while enabling more aggressive abstraction and therefore more state space reduction .",
    "model - driven software verification  @xcite advocates the use of abstraction mappings during concrete model checking in a way similar to what we present here . in their approach",
    ", the abstraction function needs to be provided by the user .",
    "the cmc model checking tool  @xcite also attempts to store state information in memory using aggressive compressing techniques ( which can be seen as a form of abstraction ) , while the detailed state information is kept on the stack .",
    "these techniques allow the detection of subtle bugs which can not be discovered by classical model checking , using e.g. breadth first search or by state - less model checking  @xcite .",
    "while these techniques use abstractions in an ad - hoc manner , our work contributes the automated generation and refinement of abstractions .",
    "directed automated random testing ( dart )  @xcite performs a concrete execution on random inputs and it collects the _ path constraints _ along the executed paths .",
    "these path constraints are then used to compute new inputs that drive the program along alternative paths .",
    "the approach in  @xcite is similar to ours as it combines concrete program execution with a symbolic analysis .",
    "however , dart applies only to sequential programs , not to concurrent programs as we do here .",
    "moreover , dart attempts to cover all the feasible paths through the program , not the reachable ( abstract ) states as we do in our approach .",
    "dart does not perform any state matching , and therefore it can not detect if an ( abstract ) state has been visited before . as a result , dart can potentially explore redundant states , e.g. for looping , reactive , programs . another ( methodological ) difference is that dart uses symbolic evaluation while our method uses predicate abstraction with refinement .",
    "dataflow and type - based analyzes have been used to check safety properties of software ( e.g.  @xcite ) . unlike our work",
    ", these techniques analyze over - approximations of system behavior and may generate false reports due to infeasible paths .",
    "we presented a model checking algorithm based on refinement of under - approximations , which effectively preserves the defect detection ability of model checking in the presence of powerful abstractions .",
    "the under - approximation is obtained by traversing the concrete transition system and performing the state matching on abstract states computed by predicate abstraction .",
    "the refinement is done by checking exactness of abstractions with the use of a theorem prover .",
    "we illustrated the application of the algorithm for checking safety properties of concurrent programs . in the future",
    ", we plan to investigate whether we can extend the algorithm with property driven refinement and with checking liveness properties .",
    "we also plan to investigate the integration of our approach with over - approximation based abstraction refinement and to do an extensive evaluation on large systems .",
    "we thank the anonymous reviewers for their detailed comments that helped us to improve this article significantly .",
    "t.  ball , a.  podelski , and s.  k. rajamani .",
    "boolean and cartesian abstraction for model checking c programs . in _ proceedings of tools and algorithms for the construction and analysis of systems ( tacas 2001 ) _ , volume 2031 of _ lncs _ , pages 268283 .",
    "springer , 2001 .",
    "t.  bultan , r.  gerber , and w.  pugh .",
    "symbolic model checking of infinite state systems using presburger arithmetic . in _ proceedings of computer aided verification ( cav97 )",
    "_ , volume 1254 of _ lncs _ , pages 400411 .",
    "springer , 1997 .",
    "d.  dams and k.  s. namjoshi .",
    "the existence of finite abstractions for branching time model checking . in _ proceedings of logic in computer science ( lics 2004 ) _ , pages 335344 .",
    "ieee computer society , 2004 .",
    "l.  de  alfaro , p.  godefroid , and r.  jagadeesan .",
    "three - valued abstractions of games : uncertainty , but with precision . in _ proceedings of logic in computer science ( lics 2004 ) _ , pages 170179 .",
    "ieee computer society , 2004 .",
    "r.  giacobazzi and e.  quintarelli .",
    "incompleteness , counterexamples and refinements in abstract model checking .",
    "in _ proceedings of the 8th static analysis symposium ( sas01 ) _ , volume 2126 of _ lncs _ , 2001 .",
    "p.  godefroid , m.  huth , and r.  jagadeesan .",
    "abstraction - based model checking using modal transition systems . in _ proceedings of conference on concurrency theory ( concur 01 ) _ , pages 426440 .",
    "springer - verlag , 2001 .",
    "p.  godefroid , n.  klarlund , and k.  sen .",
    "dart : directed automated random testing . in _ proceedings of the 2005 acm sigplan conference on programming language design and implementation _ , pages 213223 .",
    "acm , 2005 .",
    "w.  grieskamp , y.  gurevich , w.  schulte , and m.  veanes .",
    "generating finite state machines from abstract state machines . in _ proceedings of international symposium on software testing and analysis ( issta04 ) _ ,",
    "july 2002 .",
    "o.  grumberg , f.  lerda , o.  strichman , and m.  theobald .",
    "proof - guided underapproximation - widening for multi - process systems . in _ proceedings of the 32nd symposium on principles of programming languages ( popl05 ) _ , 2005 .",
    "m.  musuvathi , d.  y.  w. park , a.  chou , d.  r. engler , and d.  l. dill . : a pragmatic approach to model checking real code . in _ proceedings of the 5th symposium on operating systems design and implementation ( osdi02 ) _ , 2002 .          c.  s. psreanu , r.  pelnek , and w.  visser .",
    "concrete search with abstract matching and refinement . in _ proceedings of computer aided verification ( cav 2005 )",
    "_ , volume 3576 of _ lncs _ , pages 5266 .",
    "springer , 2005 .",
    "s.  shoham and o.  grumberg . a game - based framework for ctl counterexamples and 3-valued abstraction - refinement .",
    "in _ proceedings of computer aided verification ( cav 2003 ) _ , volume 2725 of _ lncs _ , pages 275287 .",
    "springer , 2003 .",
    "s.  shoham and o.  grumberg .",
    "monotonic abstraction - refinement for ctl . in _ proceedings of tools and algorithms for the construction and analysis of systems ( tacas 2004 ) _ ,",
    "volume 2988 of _ lncs _ , pages 546560 .",
    "springer , 2004 ."
  ],
  "abstract_text": [
    "<S> we propose an abstraction - based model checking method which relies on refinement of an under - approximation of the feasible behaviors of the system under analysis . </S>",
    "<S> the method preserves errors to safety properties , since all analyzed behaviors are feasible by definition . </S>",
    "<S> the method does not require an abstract transition relation to be generated , but instead executes the concrete transitions while storing abstract versions of the concrete states , as specified by a set of abstraction predicates . </S>",
    "<S> for each explored transition the method checks , with the help of a theorem prover , whether there is any loss of precision introduced by abstraction . </S>",
    "<S> the results of these checks are used to decide termination or to refine the abstraction by generating new abstraction predicates . </S>",
    "<S> if the ( possibly infinite ) concrete system under analysis has a finite bisimulation quotient , then the method is guaranteed to eventually explore an equivalent finite bisimilar structure . </S>",
    "<S> we illustrate the application of the approach for checking concurrent programs . </S>"
  ]
}