{
  "article_text": [
    "currently , in the most commonly studied classical planning models , all changes to the world are the direct effects of some operator . however , it is possible to model some effects as indirect effects which can be inferred from a set of basic state variables .",
    "derived predicates _ can be expressed in modeling languages such as pddl and formalisms such as sas+ as _ axioms _ , which encode logical rules defining how the derived predicates follow from basic variables .",
    "planners have supported various forms of derived predicates since relatively early systems @xcite , and pddl has supported axioms which specify derived predicates as a logic program with negation - as - failure semantics since version 2.2 @xcite    consider , for example , the well - known single - agent puzzle game , in which the player pushes stones around in a maze .",
    "the goal is to push all the stones to their destinations .",
    "the standard pddl formulation of used in the international planning competition(ipc ) consists of two kinds of operators , and .",
    "lets the player push a box in one direction , while moves the player into an unoccupied location .",
    "@xcite ( @xcite ) proposed a new formulation of sokoban with axioms and showed that this leads to a problem with a smaller search space and shorter plan @xcite .",
    "they remove the operators entirely , and introduce axioms to check whether the player can reach a box to push it .",
    "the reformulated operators now have a derived predicate instead of as their precondition .",
    "the values of the derived predicates are determined by the following axioms :    1 .",
    "@xmath0 2 .",
    "@xmath0 , ,    intuitively , the first axiom means that the current location of the player is reachable .",
    "the second axiom means a location next to a reachable location is also reachable . with axioms ,",
    "the search space only has the transitions caused by operators , resulting in smaller search space and shorter plan .",
    "previous work on derived predicates and axioms for planning has focused on the advantages of expressivity ( compactness ) of domain modeling using axioms , @xcite , as well as forward state - space search algorithms which are aware of axioms @xcite .    while previous work focused solely on axiom - aware state search planners , to our knowledge , little to no work",
    "has been done to evaluate model - based planners on pddl domains with axioms . a standard approach to model - based planning",
    "is to translate a planning problem instance into a @xmath1-step model of other formalisms such as sat and integer programming ( ip ) , where a feasible solution to the @xmath1-step model corresponds to a solution to the original planning problem with @xmath2 `` steps '' .",
    "we propose two axiom - aware model - based planners called asplan and iplan , which are based on answer set programming ( asp ) and integer programming ( ip ) respectively , and show that additional expressivity of axioms help model - based planners as well .",
    "answer set programming ( asp ) is a form of declarative programming based on answer set semantics of logic programming , and thus is a natural candidate for integrating axioms .",
    "early attempts to apply asp to planning @xcite and @xcite predated pddl , and were not evaluated on large sets of benchmarks . to our knowledge ,",
    "the first asp - based planner compatible with pddl is _ plasp _ @xcite .",
    "however , _",
    "plasp _ does not handle axioms .",
    "we developed asplan based on _ plasp _ , but used pddl to sas+ translator of fastdownward @xcite to make it compatible with larger sets of ipc domains including domains with axioms .",
    "iplan is an ip - based planner based on optiplan @xcite .",
    "we integrated axioms into iplan by using the asp to ip translation method by @xcite . to our knowledge ,",
    "asplan and iplan are the first model - based planners which handle axioms .",
    "we introduce a normal logic problem , adopting the notations used in @xcite .",
    "a _ normal logic problem _ ( nlp ) @xmath3 consists of rules of the form @xmath4 where each @xmath5 , @xmath6 , @xmath7 is a ground atom .    given a rule @xmath8",
    ", we denote the head of the rule @xmath5 by @xmath9 , the body @xmath10 as @xmath11 , the positive body literals @xmath12 by @xmath13 and the negative body literals @xmath14 by @xmath15 .",
    "we use @xmath16 for the set of atoms which appear in @xmath3 .    a set of atoms @xmath17 satisfies an atom @xmath5",
    "if @xmath18 and a negative literal not @xmath5 if @xmath19 , denoted @xmath20 and @xmath21 , respectively ; @xmath17 satisfies a set of literals @xmath22 , denoted @xmath23 , if it satisfies each literal in @xmath22 ; @xmath17 satisfies a rule @xmath24 , denoted @xmath25 , if @xmath26 whenever @xmath27 .",
    "a set of atoms @xmath17 is a model of @xmath3 , denoted @xmath28 , if @xmath17 satisfies each rule of @xmath3 .",
    "an answer set of a program is defined through the concept of reduct .    for a normal logic program @xmath3 and a set of atoms @xmath17 , the _ reduct _",
    "@xmath29 is defined by @xmath30    a model @xmath17 of a normal logic program @xmath3 is an _ answer set _",
    "iff @xmath17 is the minimal model of @xmath29 .",
    "we are particularly interested in a class of logic programs called _ locally stratifed programs _ , which disallow negation through recursions .",
    "locally stratified programs were originally introduced in @xcite ( @xcite ) .",
    "a normal logic program @xmath3 is _ locally stratified _ if and only if there is a mapping @xmath31 from @xmath16 to @xmath32 such that :    * for every rule @xmath24 with @xmath33 and every @xmath34 , @xmath35 * for every rule @xmath24 with @xmath33 and every @xmath36 , @xmath37    with stratifications the unique model , called a _ perfect model _ can be computed by a stratified fixpoint procedure @xcite .",
    "it is known that the perfect model for a locally stratified program coincides with the unique answer set of the program @xcite .",
    "we adopt the definition of axiom - enhanced sas+ used in @xcite ( @xcite ) and @xcite ( @xcite ) .    an sas+ problem with axioms",
    "@xmath38 is a tuple @xmath39 where - @xmath40 is a set of _ primary variables_. each variable @xmath41 has a finite domain of values @xmath42",
    ".    - @xmath43 is a set of operators .",
    "each operator @xmath44 has a precondition ( pre(@xmath44 ) ) , which consists of variable assignments of the form @xmath45 where @xmath46 .",
    "we abbreviate @xmath47 as @xmath41 when we know the variable is binary .",
    "an operator @xmath44 is applicable in a state @xmath48 iff @xmath48 satisfies pre(@xmath44 ) .",
    "each operator @xmath44 also has a set of effects ( eff(@xmath44 ) ) . each effect @xmath49eff(@xmath44 )",
    "consists of a tuple ( cond(@xmath50),affected(@xmath50 ) ) where cond(@xmath50 ) is possibly empty variable assignments and affected(@xmath50 ) is a single variable and value pair . applying an operator @xmath44 with an effect @xmath50 to a state @xmath48 where cond(@xmath50 ) is satisfied results in a state ( @xmath51 ) where affected(@xmath50 ) is true .",
    "cost(@xmath44 ) is the associated cost of the operator @xmath44 .",
    "- @xmath52 is an initial assignment over primary variables",
    ".    - @xmath53 is a partial assignment over variables that specifies the goal conditions",
    ".    - @xmath54 is a set of _ secondary variables_. secondary variables are binary and do not appear in operator effects .",
    "their values are determined by axioms after each operator execution .",
    "- @xmath55 is a set of rules of the form ( [ eq : rule ] ) .",
    "axioms and primary variables form a locally stratified logic program . at each state , axioms are evaluated to derive the values of secondary variables .",
    "we denote the result of evaluating a set of axioms @xmath55 in a state @xmath48 as @xmath56 .",
    "note that @xmath56 is guaranteed to be unique due to the uniqueness of the model for locally stratified logic programs .",
    "[ def : sas+axioms ]    a solution ( _ plan _ ) to @xmath38 is an applicable sequence of operators @xmath57 that maps @xmath52 into a state where the @xmath53 holds .      a standard , _ sequential search strategy _ for a mode - based planner first generates a 1-step model ( e.g. , sat / ip model ) , and attempts to solve it .",
    "if it has a solution , then the system terminates .",
    "otherwise , a 2-step model is attempted , and so on @xcite . adding axioms changes the semantics of a `` step '' in the @xmath1-step model .",
    "as noted by dimopoulos et al ( @xcite ) and rintanen et al ( @xcite ) , most model - based planners , including the base iplan / asplan planners we evaluate below , use @xmath58 semantics , where each `` step '' in a @xmath1-step model consists of a set of actions which are independent of each other and can therefore be executed in parallel .",
    "in contrast , _ sequential _ semantics ( @xmath59-semantics ) adds exactly 1 action at each step in the iterative , sequential search strategy . in general , @xmath58 semantics is faster than @xmath59-semantics , since @xmath58 semantics significantly decreases the # of iterations of the sequential search strategy . for the domains with axioms , however , we add a constraint which restricts the number of actions executed at each step to 1 , imposing @xmath59-semantics .",
    "this is because a single operator can have far - reaching effects on derived variables , and establishing independence with respect to all derived variables affected by multiple operators is nontrivial ( future work ) .",
    "we describe our answer set programming based planner asplan .",
    "asplan adapts the encoding of _ plasp _ @xcite to the multi - valued semantics of sas+ . while _",
    "plasp _ directly encodes pddl to asp , asplan first obtains the grounded sas+ model from pddl using the fastdownward translator , and then encodes the sas+ to asp .",
    "using the fastdownward translator makes it easier to handle more advanced features like axioms and conditional effects .",
    "we translate a planning instance to a normal logic program with @xmath1 steps .",
    "having @xmath1-steps means that we have @xmath60 states or `` layers '' to consider .",
    "@xmath61 for each @xmath62 , we introduce the following rule which specifies the initial state .",
    "@xmath63 likewise , for each @xmath64 , we have the following rule .",
    "@xmath65 the next rule ( [ eq : asplan : goal ] ) makes sure that all of the goals are satisfied at the last step .",
    "@xmath66    for each operator @xmath67 and each @xmath45 and @xmath68 in @xmath44 s preconditions and effects respectively , we introduce the following rules .",
    "@xmath69 rules ( [ eq : asplan : demand ] ) and ( [ eq : asplan : add ] ) require that applied operators preconditions and effects must be realized .",
    "@xmath70 @xmath71    inertial axioms ( unchanged variables retain their values ) are represented by rules ( [ eq : asplan : changed])-([eq : asplan : inertial ] ) .",
    "an assignment @xmath72 to a sas+ variable is mapped to an atom f(@xmath73,@xmath74 ) .",
    "@xmath75 @xmath76 note that every primary variable @xmath73 is marked as inertial with the following rule .",
    "@xmath77    with the sequential semantics , the rule ( [ eq : asplan : sequential ] ) ensures that only one operator is applicable in each step .",
    "@xmath78    on the other hand , with @xmath58-semantics , ( [ eq : asplan : all])-([eq : asplan : all3 ] ) requires that no conflicting operators are applicable at the same step .",
    "@xmath79 @xmath80 @xmath81    since variables in sas+ can not take different values at the same time , we introduce the mutex constraint ( [ eq : asplan : mutex ] ) . @xmath82      integrating axioms to asplan is fairly straightforward . for an axiom @xmath83",
    ", we introduce the following rule : @xmath84 we also need the following constraints to realize negation - as - failure semantics while being compatible with the formulations above .",
    "@xmath85 @xmath86      we describe how to integrate conditional effects into asplan . for each operator @xmath44 and its effect @xmath87eff(@xmath44 ) , we introduce the following rule @xmath88 where @xmath89, ... ,@xmath90 are in cond(@xmath50 ) .    with conditional effects ,",
    "applying operators does not necessarily mean their effects get triggered .",
    "we replace the rules ( [ eq : asplan : changed ] ) and ( [ eq : asplan : inertial ] ) with the following rules . @xmath91 @xmath92",
    "we describe our baseline integer - programming planner iplan , which is based on optiplan @xcite .",
    "optiplan , in turn , extends the state - change variable model @xcite , and the optiplan model is defined for af propositional ( strips ) framework .",
    "iplan adapts the optiplan model for the multi - valued sas+ framework , exploiting the fastdownward translator @xcite .",
    "an assignment @xmath72 to a sas+ variable is mapped to a fluent @xmath93 . for all fluents",
    "@xmath93 and time step @xmath94 , optiplan has the following _ state change variables_.",
    "@xmath95 , @xmath96 and @xmath97 denote a set of operators that might require , add , or delete @xmath93 respectively .",
    "intuitively , state change variables represent all possible changes of fluents at time step @xmath94 .",
    "@xmath98    @xmath99    @xmath100    @xmath101    @xmath102    for all operators @xmath44 and time step @xmath94 , optiplan has the operator variables @xmath103    the constraints ( [ eq : iplan : initial ] ) and ( [ eq : iplan : initial2 ] ) represent the initial states constraints .",
    "the constraint ( [ eq : iplan : goal ] ) ensures that the goals are satisfied at the last step @xmath105 .",
    "@xmath106    for all fluents @xmath93 and time step @xmath94 , optiplan has the following constraints to make sure the state change variables have the intended semantics .",
    "@xmath107    @xmath108    @xmath109    @xmath110    the constraints ( [ eq : iplan : para ] ) and ( [ eq : iplan : para2 ] ) restrict certain state changes from ocurring in parallel .",
    "@xmath111    the constraint ( [ eq : iplan : backward ] ) represents the backward chaining requirement .",
    "iplan augments the optiplan model with a new set of mutex constraints .",
    "in addition to the above variables and constraints which are from optiplan , iplan introduces a set of auxiliary binary variables @xmath113 with the following constraints .",
    "@xmath113 corresponds to the value of the fluent @xmath93 at the time step @xmath94 .",
    "@xmath114 @xmath115 @xmath116 @xmath117    using @xmath113 , mutex constraints can be implemented as follows . for",
    "every mutex group @xmath118 ( at most one fluent in @xmath118 can be true at the same time ) found by the fastdownward @xcite translator , iplan adds the following constraint .",
    "we describe how to integrate axioms into an ip - based model . for each time step @xmath94",
    ", axioms form the corresponding normal logic program ( nlp ) @xmath120 .",
    "the models for @xmath120 correspond to the truth values for the derived variables .",
    "we translate each nlp @xmath120 to an integer program ( ip ) using the method by @xcite ( @xcite ) , and add these linear constraints to the iplan model .",
    "translation from a nlp to an ip by @xcite relies on characterizing answer sets using _",
    "level rankings_. intuitively , a level ranking of a set of atoms gives an order in which the atoms are derived .",
    "let @xmath17 be a set of atoms and @xmath3 a normal program .",
    "a function @xmath121 is a _ level ranking _ of @xmath17 for @xmath3 iff for each @xmath18 , there is a rule @xmath122 such that @xmath33 and for every @xmath34 , @xmath123 .",
    "note that @xmath124 is the set of support rules , which are essentially the rules applicable under @xmath17 .",
    "for a program @xmath3 and @xmath125 , @xmath126 is the set of _ support rules_.    the level ranking characterization gives the condition under which a supported model is an answer set .",
    "a set of atoms @xmath17 is a supported model of a program @xmath3 iff @xmath28 and for every atom @xmath18 there is a rule @xmath8 such that @xmath33 and @xmath27 .",
    "let @xmath17 be a supported model of a normal program @xmath3 .",
    "then @xmath17 is an answer set of @xmath3 iff there is a level ranking of @xmath17 for @xmath3 .",
    "@xcite ( @xcite ) defines a dependency graph of a nomal logic program to be used for the translation to ip .",
    "the _ dependency graph _ of a program @xmath3 is a directed graph @xmath53 = @xmath127 where @xmath40 = @xmath16 and @xmath128 is a set of edges @xmath129 for which there is a rule @xmath8 such that @xmath9 = @xmath5 and @xmath34 .    for a program @xmath3 and an atom @xmath130 , respective sets of _ defining rules _ ,",
    "_ externally defining rules _ , and _ internally defining rules _ are defined as follows : @xmath131 @xmath132 @xmath133    the set of _ internally supporting atoms _ is defined as @xmath134      we are now ready to describe how to translate a normal logic program @xmath120 formed by axioms to linear constraints based on the method by @xcite ( @xcite ) .",
    "the translation consists of linear constraints develeped below .    1 .   for each secondary variable @xmath135 ,",
    "introduce a binary variable @xmath136 .",
    "2 .   for each secondary variable @xmath135 , include the following constraint @xmath137 where @xmath138 is a binary variable for each @xmath139 and step @xmath94 .",
    "intuitively , @xmath138 represents whether the body of @xmath24 is satisfied at step @xmath94 .",
    "the constraint ensures that when one of the rules defining @xmath140 ( @xmath141 ) is satisfied , @xmath136 must be true ( @xmath142 ) .",
    "3 .   for each axiom @xmath143 ,",
    "include the following constraints .",
    "@xmath144 @xmath145 constraints ( [ eq : axiom : body ] ) and ( [ eq : axiom : body2 ] )",
    "express the fact that the body of rule @xmath24 is satisfied iff each literal in @xmath11 is satisfied .",
    "4 .   for each secondary variable @xmath135 , include the constraint @xmath146 where @xmath147 is a binary variable for each @xmath148 and each step @xmath94 .",
    "intuitively , the binary variable @xmath147 represents whether the respective ranking constraints for the rule @xmath24 are satisfied in addition to its body .",
    "the constraint requires @xmath136 to be true when one of its externally defining rules is satisfied or one of its internally defining rules is satisfied while respecting the ranking constraints .",
    "5 .   for each secondary variable @xmath135 and each @xmath148 , include the constraints @xmath149 @xmath150 where @xmath151 is a binary variable for each @xmath152 , which represents whether the rank of @xmath140 is greater than tha of @xmath153 .",
    "6 .   for each secondary variable @xmath135 and",
    "each @xmath148 , and each @xmath152 , include the constraint @xmath154 where @xmath155 and @xmath156 are integer variables representing level rankings for @xmath5 and @xmath153 respectively .",
    "the constraint ( [ eq : axiom : gt ] ) guarantees that if @xmath157 then @xmath158 .    with the above constraints",
    ", @xmath136 corresponds to the values of a secondary variable @xmath140 at time step @xmath94 .",
    "since secondary variables only appear in operators preconditions , we only need to make sure applied operators preconditions are satisfied .",
    "@xmath159    for the reasons described earlier , with domains with axioms , we need to add the following constraint to restrict the number of operators executed at each time step to 1 .",
    "all experiments are performed on a xeon e5 - 2670 v3 , 2.3ghz with 2 gb ram and 5 minutes limit . in all experiments ,",
    "the runtime limits include all steps of problem solving , including translation / parsing , and search .",
    "we use clingo4.5.4 , a state - of - the - art asp solver @xcite to solve the asp models produced by asplan .",
    "the ip models produced by iplan are solved using gurobi optimizer 6.5.0 , single - threaded .",
    "the rules and constraints used in each of our planner configurations are summarized in table [ tab : rules ] .",
    "we first evaluated asplan and iplan on pddl domains without axioms to compare them against existing planners .",
    "a thorough comparison of model - based planners is nontrivial because of the multitude of combinations possible of translation schemes , solvers , and search strategies .",
    "the purpose of this experiment is to show that the baseline asplan and iplan planners perform reasonably well compared to _ similar _",
    ", existing model - based planners which ( 1 ) use a simple search strategy which iteratively solves @xmath1-step models , and ( 2 ) use models which are solved by `` off - the - shelf '' solver algorithms , i.e. , this excludes planners that such as madagascar @xcite , which uses a more sophisticated search strategy and customized solver algorithm , as well as the flow - based ip approaches @xcite .",
    "we compared the following : ( 1 ) aplans ( asplan with seq - semantics ) ( 2 ) _ plasp _ ( 3 ) iplans ( iplan with seq - semantics ) ( 4 ) iplan ( iplan with @xmath58-semantics ) ( 5 ) asplan ( asplan with @xmath58-semantics ) ( 6 ) the state of the art csp - based planner tcpp @xcite .",
    "since _ plasp _ uses incremental grounding , we used iclingo @xcite as an underlying solver .",
    "as for tcpp , we could not obtain the souce code from the authors as of this writing , so we use the results from the original paper .",
    "the results are shown in table [ tab : no - axioms ] .",
    "asplans dominated _ plasp _ in every domain , indicating that asplan is a reasonable , baseline asp - based solver .",
    "this is to be expected , since asplans is based on the _ plasp _ model . among @xmath58-semantics solvers",
    "asplan , iplan and tcpp , asplan and iplan are highly competitive with tcpp despite the fact that the results for tcpp were obtained with a significantly longer ( 30min . vs. 5min )",
    "runtime limit ( on a different machine ) .",
    ".results on domains without axioms .",
    "note that for tcpp , the results from the original papaer @xcite on a pc with intel 3.5ghz cpu , 8 gb memory limit and 30 minute timeout are shown .",
    "nan indicates a lack of the results . # denotes the number of instances for each domain . [ cols=\"<,>,>,>,>,>,>,>\",options=\"header \" , ]      we evaluated asplan and iplan on pddl domains with axioms .",
    "the results are shown in table [ tab : axioms ] .",
    "about the domains used in experimental evaluations , has been discussed already .",
    "the new domains are discussed below .",
    "@xcite ( @xcite ) proposed a modeling formalism for capturing high level functional specifications and requirements of reactive control systems .",
    "the formulation consits of two agents , namely the environment which distubs the system , and the controller which tries to return the system to safe state .",
    "if there is a sequence of operators for the environment that leads to an unsafe state , the control system has vulnerability .",
    "we used two compiled versions of the formulation : compilation into strips proposed by @xcite : and compilation into strips with axioms discussed in @xcite .",
    "the adaptive cruise control ( acc ) is a well known driver assistance feature present in many high end automotive systems .",
    "the acc is designed to take away the burden of adjusting the speed of the vehicle from the driver , mostly under light traffic conditions .",
    "is a verification domain for the acc .",
    "the domain is a synthetic planning domain loosely based on cellular automata and incorporates a parallel depth first search protocol for added variety .",
    "note that this domain is completely different from used in ipc .",
    "@xcite ( @xcite ) proposed a framework for handling beliefs in multiagent settings , building on the methods for representing beliefs for a single agent . computing linear multiagent plans for the framework",
    "can be mapped to a classical planning problem with axioms .",
    ", originally from @xcite ( @xcite ) , is a puzzle in which @xmath161 children player together . during their play ,",
    "@xmath1 of the children get mud on their forheads .",
    "each can see the mud on the others , but not their own .",
    "the goal for a child is to know if he or she has mud by sensing the beliefs of the others .",
    "is a rerfomulation of .    in , the goal for an agent is to know a particular block s location .",
    "two agents volunteer information to each other to accomplish a task faster than that would be possible individually .    in",
    ", there are three agents , each with a number on their forehead .",
    "it is known that one of the numbers equals the sum of the other two .",
    "the goal is for one or two selected agents to know their numbers .    is a variant of collaboration through communication where two agents must find out a hidden word from a list of n possible words .",
    "ipc-4 benchmarks contain another domain with axioms called aside from .",
    "the task is to validate properties in systems of communicating processes ( often communication protocols ) .",
    ", encoded in the promela language .",
    "@xcite ( @xcite ) developed an automatic translation from promela into pddl , which was extended to generate the competition examples .",
    "we used verification domains for problem , and the so - called .",
    "the task of ( power supply restoration ) is to reconfigure a faulty power distribution network so as to resupply customers affected by the faults .",
    "the network consists of electronic lines connected by switched and power sources with circuit breaker .",
    "psr has been investigated by the ai community , including the works such as @xcite ( @xcite ) .",
    "we used the version of psr used in ipc-4 , which is a simplified version of @xcite ( @xcite ) with full observability of the world and no numeric optimization .",
    "l|r|r|r|r 2 gb , 5min & # & asplans & iplans & axioms +   + sokoban - axioms & 30 & 5 & 4 & y + sokoban - opt08-strips & 30 & 4 & 0 & n + trapping_game & 7 & 4 & nan & y +   + acc - com & 8 & 0 & 0 & n + acc & 8 & 7 & 1 & y + door - fixed & 2 & 1 & 1 & y + door - broken & 2 & 0 & 0 & y + grid - axiom & 99 & 0 & 0 & y +   + muddy - child - kg & 7 & 1 & nan & y + muddy - children - kg & 5 & 1 & nan & y + collab - and - comm - kg & 3 & 1 & nan & y + wordrooms - kg & 5 & 1 & nan & y +   + psr - middle & 50 & 48 & nan & y + psr - middle - noce & 50 & 43 & 25 & y + psr - middle - com & 50 & 1 & nan & y + psr - large & 50 & 21 & nan & n + optical - telegraphs & 48 & 0 & nan & y + optical - telegraphs - com & 48 & 0 & nan & n + philosophers & 48 & 2 & nan & y + philosophers - com & 48 & 0 & nan & n +    it is interesting to note that in , , , and asplan ( and sometimes iplan ) solved more instances from the formulations with axioms than the compiled formulations without axioms .",
    "this is because compiled instances tend to have longer plans , which model - based planners such as asplan and iplan had difficulty in handling .",
    "we proposed axiom - aware model - based planners asplan and iplan .",
    "asplan is an asp - based planner , which is able to handle axioms and conditional effects .",
    "iplan is an ip - based planner based on optiplan @xcite .",
    "we integrated axioms into iplan using the asp to ip translation method by @xcite .",
    "we evaluated asplan and iplan on pddl domains with axioms and showed that axiom - aware model - based planners can exploit shorter plan with fomulations with axioms .",
    "dimopoulos , y. ; nebel , b. ; and koehler , j. 1997b .",
    "encoding planning problems in nonmonotonic logic programs . in _ recent advances in ai planning , 4th european conference on planning , ecp97 , toulouse , france , september 24 - 26 , 1997 , proceedings _ , 169181 .",
    "edelkamp , s. , and hoffmann . ,",
    "2.2 : the language for the classical part of the 4th international planning competition .",
    "technical report technical report 195 , albert - ludwigs - universitt freiburg , institut fr informatik , 2004 .",
    "gebser , m. ; kaminski , r. ; kaufmann , b. ; ostrowski , m. ; schaub , t. ; and thiele , s. 2008 .",
    "engineering an incremental asp solver . in garcia de la banda , m. , and pontelli , e. , eds .",
    ", _ proceedings of the twenty - fourth international conference on logic programming ( iclp08 ) _ , volume 5366 of _ lecture notes in computer science _ , 190205 .",
    "springer - verlag .",
    "ghooshchi , n.  g. ; namazi , m. ; newton , m. a.  h. ; and sattar , a. 2015 .",
    "transition constraints for parallel planning . in _ proceedings of the twenty - ninth aaai conference on artificial intelligence ,",
    "january 25 - 30 , 2015 , austin , texas , usa . _ , 32683274 ."
  ],
  "abstract_text": [
    "<S> axioms can be used to model derived predicates in domain- independent planning models . formulating models which use axioms </S>",
    "<S> can sometimes result in problems with much smaller search spaces and shorter plans than the original model . </S>",
    "<S> previous work on axiom - aware planners focused solely on state - space search planners . </S>",
    "<S> we propose axiom - aware planners based on answer set programming and integer programming . we evaluate them on pddl domains with axioms and </S>",
    "<S> show that they can exploit additional expressivity of axioms . </S>"
  ]
}