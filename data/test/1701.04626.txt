{
  "article_text": [
    "a basic problem in database theory is _ query evaluation in probabilistic databases _ : given a ( boolean ) query @xmath0 and a probabilistic database @xmath1 , where each tuple has a given probability , compute the probability of the lineage of @xmath0 over @xmath1 .",
    "the problem is computationally hard , even for fixed queries in simple syntactic forms @xcite .",
    "the _ lineage of a ( boolean ) query @xmath0 over a database @xmath1 _ is a monotone boolean function @xmath2 over the tuples in @xmath1 that accepts a subset @xmath3 of tuples of @xmath1 if and only if @xmath0 is true in @xmath3 .",
    "a standard approach to probabilistic query evaluation is _ query compilation _",
    "* chapter  5 ) . here",
    ", the lineage @xmath2 , given as a boolean circuit , which is computable in polynomial time if @xmath0 is fixed , is implemented within a succinct circuit class where its probability is efficiently computable . in other words , to avoid computing the probability of a circuit , which is hard , the circuit is first _",
    "compiled _ to a tamer form .",
    "circuit classes supporting tractable probability computation , and model counting in particular , are central in _ knowledge compilation _",
    "@xcite ; particular emphasis is posed on the hierarchy of deterministic decomposable circuits .",
    "a circuit is _ decomposable _ if its and gates represent independent probabilistic events @xcite , and _ deterministic _ if its or gates represent exclusive probabilistic events @xcite : probability computation is then feasible in linear time on deterministic decomposable circuits .    aimed at a detailed syntactic classification of tractable cases of probabilistic query evaluation , jha and suciu amply explored the compilability of various classes of queries into various classes of deterministic decomposable circuits , fruitfully bridging database theory and knowledge compilation @xcite . in this context , they studied the compilability of queries whose lineages have small circuit treewidth into decision diagrams , obdds in particular @xcite ; a study we continue in this article .    an _ ordered binary decision diagram _ ( obdd ) is a deterministic read - once branching program where every path from the root to a leaf visits the boolean variables in the same order @xcite .",
    "the obdd size of a boolean function is the size ( number of nodes ) of its smallest obdd implementation .",
    "the width of an obdd is the largest number of nodes labeled by the same variable , and the obdd width of a boolean function is the smallest width attained by its obdd implementations .",
    "unifying several known tractable cases of the probability computation problem , jha and suciu introduce a structural parameter for boolean functions , called _ expression width _ @xcite or _ circuit treewidth _ @xcite , that measures , for any boolean function , the smallest treewidth of a circuit computing the function .",
    "they show that a boolean function of @xmath4 variables and circuit treewidth @xmath5 has obdd size @xmath6 where @xmath7 is a fast growing ( double exponential ) function @xcite . the bound is tight in the sense that there are boolean functions of @xmath4 variables and circuit treewidth @xmath5 whose obdd size is @xmath8 @xcite .    the bound ( [ eq : intr-1 ] ) gives polynomial size obdd implementations for circuits of bounded treewidth , but the degree of the polynomial depends ( badly ) on the treewidth .",
    "however , as jha and suciu show @xcite , restricting to functions of small _ circuit pathwidth _ resolves this issue .",
    "indeed , a boolean function of @xmath4 variables and circuit pathwidth @xmath5 has obdd width @xmath9 , hence obdd size @xmath10 and conversely , every boolean function of obdd width @xmath5 has circuit pathwidth @xmath11 .",
    "therefore , _ a class of boolean functions has bounded circuit pathwidth if and only if it has bounded obdd width .",
    "_    as jha and suciu conclude , the quest naturally arises for a similar characterization of bounded circuit treewidth .",
    "the quest involves , for starters , identifying a circuit class ideally as tractable as obdds but more succinct , and therefore capable of matching the bound ( [ eq : intr-2 ] ) .",
    "natural candidates , like fbdds or even nondeterministic read - once branching programs fail @xcite .",
    "the question is natural and nontrivial .",
    "compared to the substantial understanding of the compilability of cnf circuits parameterized by treewidth , or even cliquewidth @xcite , the parameterized compilability of general circuits is relatively unexplored and poorly understood ; which is unsatisfactory because , in theory , the circuit treewidth of a class of boolean functions can be bounded on general circuits and unbounded on cnfs ( * ? ? ?",
    "* example  2.9 ) ; and in practice , query lineages are often presented by circuits rather than by cnfs @xcite .    the only bound on the size of a compilation for a circuit that avoids a dependence on its treewidth in the exponent , like in ( [ eq : intr-2 ] ) as opposed to ( [ eq : intr-1 ] ) , is a compilation of _ size _ @xmath12 circuits into _ decomposable _ forms of size @xmath13 by petke and razgon @xcite , where @xmath14 is an exponential function .",
    "this compilation , however , lacks two features that are either needed by or desirable in its intended application to query compilation .",
    "the crucial missing feature is that decomposable circuits , in the absence of determinism , do not support model counting ( nor , then , probability computation ) . besides , in the upper bound ( [ eq : intr-3 ] ) , the size of the compilation depends on the size of the circuit , @xmath12 , not just on the number of its variables , @xmath4 , and the former can be much larger than the latter . indeed , petke and razgon ask whether decomposable forms of size linear in @xmath4 are attainable for circuits of bounded treewidth ( * ? ? ?",
    "* section  5 ) .      in the first part of the article ( section  [ sect : part1 ] )",
    ", we show that _ a class of boolean functions has bounded circuit treewidth if and only if it has bounded sdd width _ , which perfectly complements the aforementioned characterization of circuit pathwidth via obdd width by jha and suciu .",
    "more precisely , we prove the following ( theorem  [ th : linear - sdd - size ] and surrounding discussion ) .    result  1 .",
    ": :    _ a boolean circuit of @xmath4 variables and treewidth    @xmath5 has sdd width @xmath9 , thus sdd size    @xmath15 where @xmath7 is a triple exponential    function .",
    "conversely , every boolean function of sdd width    @xmath5 has circuit treewidth @xmath11 .",
    "_    introduced by darwiche @xcite , _ sentential decision diagrams _ ( sdds ) are a relaxation of obdds based on a generalized form of shannon decomposition .",
    "an obdd respecting the variable ordering @xmath16 takes a _ binary decision _ of the form @xmath17 , where @xmath18 and @xmath19 are obdds respecting the variable ordering @xmath20 .",
    "intuitively , based on a binary case distinction on @xmath21 , the obdd executes subobdds respecting the subordering @xmath20 .",
    "an sdd respecting the variable tree @xmath22 , whose left and right subtrees split the variables in two disjoint blocks @xmath23 and @xmath24 , takes a _",
    "sentential decision _ of the form @xmath25 .",
    "here , based on an @xmath12-ary ( exhaustive and disjoint ) case distinction on @xmath23 , implemented by the @xmath12 sdds @xmath26 respecting the left subtree of @xmath22 , the @xmath12 sdds @xmath27 respecting the right subtree of @xmath22 are executed .",
    "sdds are theoretically very robust , being essentially as tractable as obdds @xcite but exponentially more succinct @xcite .",
    "they are also appealing in practice since an sdd compiler is reasonable to design and implement ( as opposed to an fbdd compiler for instance , whose design is already fairly elusive ) .",
    "indeed , available sdds compilers already yield more succinct sdds than obdds , leveraging the additional flexibility offered by variable trees compared to variable orders @xcite .",
    "moreover , sdds have canonical forms , and hence carry a natural notion of width which in particular implies , if bounded , linear size implementations , exactly as obdd width does for obdds @xcite .",
    "thus , quite remarkably , our study unveils that circuit treewidth is characterized by an independently introduced , theoretically solid , and practically useful notion of circuit width , namely , sdd width .",
    "( 0,0 )    # 1#2#3#4#5 @font    ( 3284,2549)(6189,-10343 ) ( 7164,-9063)(0,0)[lb ] ( 7793,-8476)(0,0)[lb ] ( 7111,-10231)(0,0)[lb ] ( 7059,-9650)(0,0)[lb ]    figure  [ fig : bf ] illustrates the compilability panorama for boolean functions relative to bounded circuit pathwidth / obdd width , bounded circuit treewidth / sdd width , and polynomial obdd and sdd size .",
    "the class @xmath28 contains all boolean functions of obdd width @xmath29 , and similarly for sdds ; the class @xmath30 contains all boolean functions of circuit treewidth @xmath29 , and similarly for cpw and circuit pathwidth .",
    "we have @xmath31    jha and suciu leave open the question whether the circuit treewidth of a boolean function is computable ( * ? ? ?",
    "* section  6 ) .",
    "using the fact that satisfiability of mso - sentences is decidable on graphs of bounded treewidth @xcite , we answer the question positively ( proposition  [ prop : seese ] ) .",
    "result  2 .",
    ": :    _ the circuit treewidth of a boolean function is computable .",
    "_    ( 0,0 )    # 1#2#3#4#5 @font    ( 3284,2549)(6189,-10343 ) ( 7762,-8479)(0,0)[lb ] ( 7059,-9650)(0,0)[lb ] ( 7111,-10231)(0,0)[lb ] ( 7164,-9063)(0,0)[lb ]    in the second part of the article ( section  [ sect : part2 ] ) , we study the implications of our compilability results in query compilation , refining the picture drawn by jha and suciu for unions of conjunctive queries ( ucqs ) with and without inequalities @xcite .",
    "we prove the following statement ( theorem  [ th : main - ineq ] ) .",
    "result  3 .",
    ": :    _ a union of conjunctive queries with or without inequalities    containing inversions has lineages of exponential deterministic    structured size .",
    "_    introduced by dalvi and suciu @xcite , _ inversion freeness _ is a syntactic property of ucqs and ucqs with inequalities that implies compilability of their lineages in constant width ( linear size ) obdds and polynomial size obdds @xcite . on the other hand , if a query contains inversions , then it has lineages with large obdd @xcite , and even sdd @xcite , implementations .",
    "_ structuredness _ is a strong form of decomposability where not only for every and gate the circuits leading into the gate are defined on disjoint sets of variables @xcite , but their variables are partitioned accordingly to an underlying variable tree @xcite .    as alluded in their informal description above , sdds as well as obdds",
    "are special deterministic structured forms .",
    "therefore result  3 formally generalizes analogous previous incompilability results for sdds and obdds @xcite .",
    "the proof has the main and sole merit to combine proof ideas of jha and suciu together with lower bound techniques for deterministic structured circuits based on single partition communication complexity @xcite .",
    "a careful inspection of the proof shows that result  3 also exponentially separates disjunctive normal forms ( dnfs ) , and even prime implicant forms ( ips ) , from structured deterministic negation normal forms ( nnfs ) . in this interpretation result  3",
    "settles a special case of the much harder problem of separating dnfs ( and ips ) and deterministic decomposable nnfs ( d - dnnfs ) ; which , thanks to the recently established separation of decomposable nnfs ( dnnfs ) and d - dnnfs @xcite , is the last open question about the relative succinctness of the compilation languages considered in the classic article by darwiche and marquis @xcite .",
    "figure  [ fig : ucq ] and figure  [ fig : ucqneq ] give an overview of query compilability for lineages of ucqs with and without inequalities . for lineages of ucqs",
    "we have that @xmath32 because by result  3 inversions imply large structured deterministic forms , hence large sdds ; on the other hand , inversion freeness implies constant width obdds @xcite , so that @xmath33 .",
    "the picture for lineages of ucqs with inequalities is @xmath34 because again result  3 implies large sdds in the presence of inversions , and inversion freeness implies polynomial size obdds @xcite ; thus @xmath35 . in a symmetric fashion , jha and suciu conjecture that , for lineages of ucqs with inequalities , it also holds that @xmath36 .",
    "( 0,0 )    # 1#2#3#4#5 @font    ( 3284,2549)(6189,-10343 ) ( 7762,-8479)(0,0)[lb ] ( 7164,-9063)(0,0)[lb ] ( 7111,-10231)(0,0)[lb ] ( 7059,-9650)(0,0)[lb ]      our bound ( [ eq : int-4 ] ) amounts to a vast improvement of the available bounds .",
    "compared to ( [ eq : intr-1 ] ) , it attains linear size versus ( large degree ) polynomial size compilation on bounded circuit treewidth classes . compared to ( [ eq : intr-3 ] )",
    ", it answers abundantly the quest for linear size decomposable forms for boolean functions of bounded treewidth : our forms are not just linear size and decomposable , but even deterministic and structured .    pushing the dependency of the compilation size down from @xmath12 ( the size of the given circuit , as in ( [ eq : intr-3 ] ) ) to @xmath4 ( the number of its inputs , as in ( [ eq : int-4 ] ) ) required an entirely new compilation idea .",
    "of boolean variables of the query lineage @xmath2 is the ( large ) number of tuples in the database @xmath1 , and @xmath12 is the size of the circuit implementation of @xmath2 .",
    "roughly @xmath37 , where @xmath38 is the size of the query @xmath0 . hence , avoiding a dependence on @xmath12 means obtaining a bound where the degree of the polynomial is a universal constant , not just independent of the circuit treewidth of @xmath2 , but also independent of @xmath0 . ]    the idea used by petke and razgon @xcite to obtain ( [ eq : intr-3 ] ) was the following .",
    "given a circuit @xmath39 of @xmath40 variables and @xmath41 gates , first compute its tseitin cnf @xmath42 ; the circuit treewidth of the latter is ( linearly ) related to the former . to obtain a decomposable form for @xmath39 ,",
    "existentially quantify the ( gate ) variables @xmath43 in a decomposable form @xmath44 for @xmath42 : @xmath45 this indirect approach via tseitin forms , however , introduces two critical issues . on the one hand ,",
    "the size of @xmath44 depends on @xmath46 , so that the size of the compiled form will depend on @xmath12 ( as opposed to depending on @xmath4 only ) . on the other hand , for @xmath47 to have size polynomial in that of @xmath44 , the latter can not be deterministic @xcite ; hence the resulting compiled form will not be deterministic either .",
    "our compilation approach avoids tseitin forms and compiles the circuit directly ; it relies on a new insight on boolean functions , and more specifically on the combinatorics of their _ subfunctions _ or _ cofactors _ @xcite .",
    "dually to the notion of cofactor , we introduce ( definition  [ def : factor ] ) the notion of _ factor _ of a boolean function @xmath48 , that is , a function @xmath49 whose models correspond exactly to the assignments of @xmath24 generating some cofactor of @xmath50 .",
    "we then show ( lemma  [ lemma : factors ] ) that first , the rectangle @xmath51 formed by multiplying any two factors @xmath49 and @xmath52 of @xmath48 is either disjoint from @xmath50 , that is @xmath53 , or contained in @xmath50 , that is @xmath54 . and @xmath52 is a boolean function over @xmath55 whose models are exactly those assignments of @xmath55 whose restriction to @xmath24 ( @xmath56 ) models @xmath57 ( @xmath58 ) . ] and second ( lemma  [ lemma : drc ] ) , the pairs of factors @xmath49 and @xmath52 of @xmath48 satisfying the latter condition , call them implicants , form a disjoint rectangle cover of @xmath50 , that is , @xmath59 where the disjunction is deterministic and the conjunctions are decomposable ( structured , indeed ) .    we then elaborate on the main technical lemma of jha and suciu ( * ? ? ?",
    "* lemma  2.12 ) to turn the above structural insight into a compilation of small size .",
    "we show that a circuit of small treewidth computing a function @xmath50 naturally delivers a variable tree where the number of cofactors of @xmath50 generated by assigning the variables below every node in the tree is small ( lemma  [ lemma : jhasuciu ] ) .",
    "it follows that the disjoint rectangle covers described above are small for every factor of @xmath50 ; we then obtain the desired compilation by an inductive construction up the variable tree ( lemma  [ lemma : dsdnnf - sub ] and theorem  [ th : factorized - forms - main ] ) .",
    "indeed result  1 is proved for a more basic canonical deterministic structured class of circuits ( theorem  [ th : factorized - forms - main ] and proposition  [ prop : fiw - ctw ] ) , which is equivalent to sdds as far as the boundedness of their widths , and reduces to obdds in the special case of linear variable trees ; the class is of independent interest and gives a fresh structural insight into sdds ( see also the conclusion ) .",
    "our construction , significantly shorter to describe and easier to analyze than its precursors , effectively encompasses the construction by jha and suciu in that , if carried out in the special case of circuit pathwidth , it compiles a circuit of @xmath4 variables and pathwidth @xmath5 into an obdd ( not just an sdd ) of width @xmath9 and size @xmath60 .",
    "the article is organized as follows .",
    "the required notions from knowledge compilation and communication complexity are given in section  [ sect : prel ] .",
    "the part of the article devoted to circuit treewidth and sentential decision ( section  [ sect : part1 ] ) deals first with the introduction and the development of the notion of factor and factor width for a boolean function , and the relation of the latter with circuit treewidth ( section  [ sect : fwbf ] ) ; next , it presents the actual compilations in canonical deterministic structured nnfs and sdds ( section  [ sect : impl - sdnnf ] ) .",
    "section  [ sect : part2 ] is devoted to query compilation .",
    "we present questions and directions for future research in section  [ sect : concl ] .",
    "for every integer @xmath61 , we let @xmath62=\\{1,\\ldots , n\\}$ ] .",
    "we refer the reader to a standard source for the notions of treewidth , tree decomposition , and nice tree decomposition @xcite .",
    "we consider ( boolean ) circuits over the standard basis , namely dags whose non - source nodes , called internal gates , are unbounded fanin conjunction ( @xmath63 ) and disjunction ( @xmath64 ) gates and fanin @xmath65 negation ( @xmath66 ) gates , and whose source nodes , called input gates , are pairwise distinct variables or constants ( @xmath67 and @xmath68 ) .",
    "a designated sink node is called the output gate .",
    "a circuit is in _ negation normal form _ , in short an _ nnf _ , if its negation gates are only wired by input gates .",
    "the size @xmath69 of a circuit @xmath70 is the number of its gates .",
    "let @xmath23 be a finite set of variables .",
    "a circuit @xmath70 over @xmath23 is a circuit whose input gates are labelled by variables in  @xmath23 or by constants .",
    "a circuit @xmath70 on @xmath23 computes a boolean function @xmath71 over the boolean variables @xmath23 , @xmath72 in the usual way .",
    "we let @xmath73 denote the models of @xmath70 and @xmath74 .",
    "two circuits @xmath70 and @xmath75 over @xmath23 are equivalent , in symbols @xmath76 , if @xmath77 ; we also write @xmath78 or say that @xmath70 computes @xmath50 if @xmath79 .    for a gate @xmath14 in a circuit @xmath70 over @xmath23 , we let @xmath80 denote the subcircuit of @xmath70 rooted at @xmath14 . in particular , @xmath81 if @xmath14 is the output gate of @xmath70 . for a circuit @xmath70 over variables @xmath23 and a gate @xmath82 , we let @xmath83 denote the variables appearing at input gates of @xmath80 .",
    "let @xmath14 be an @xmath64-gate in a circuit @xmath70 , and let @xmath84 and @xmath85 be two distinct gates wiring @xmath14 in @xmath70 .",
    "then @xmath14 is called _ deterministic _ if @xmath86 , viewing each circuit involved in the equation as a circuit over @xmath87 .",
    "the determinism of @xmath14 in @xmath70 implies that the two subcircuits @xmath88 and @xmath89 are independent  in the sense that @xmath90 where each circuit involved in the equation is viewed as a circuit over @xmath87 .",
    "a circuit where all @xmath64-gates are deterministic is called _",
    "let @xmath24 be a finite nonempty set of variables .",
    "a _ variable tree _ ( in short , a _ vtree _ ) for the variable set @xmath24 is a rooted , ordered , binary tree @xmath22 whose leaves correspond bijectively to @xmath24 ; for simplicity , we identify each leaf in @xmath22 with the variable in @xmath24 it corresponds to . for technical convenience ,",
    "we slightly relax the standard definition not requiring for a vtree to be a full binary tree .    for every internal node @xmath91 of the vtree @xmath22 with two children ,",
    "we let @xmath92 and @xmath93 denote resp .",
    "the left and right child of @xmath91 .",
    "moreover , we denote by @xmath94 the subtree of @xmath22 rooted at node @xmath91 , and by @xmath95 ( the variables corresponding to ) the leaves of @xmath96 .",
    "let @xmath70 be a circuit over the variable set @xmath23 , and let @xmath22 be a vtree for the variable set @xmath24 .",
    "let @xmath14 be a fanin @xmath97 @xmath63-gate in @xmath70 , having wires from gates @xmath84 and @xmath85 , and let @xmath98 have two children @xmath92 and @xmath93 .",
    "we say that @xmath14 is _ structured by @xmath91 _ if @xmath99 and @xmath100 .",
    "we say that @xmath70 _ structured by @xmath22 _ if each @xmath63-gate in @xmath70 ( has fanin @xmath97 and ) is structured by some node in @xmath22 .",
    "a circuit is called _ structured _ if it is structured by some vtree .",
    "a class of structured nnfs is _ canonical _ if , for every boolean function @xmath101 and vtree @xmath102 with @xmath103 , if two circuits @xmath70 and @xmath75 in the class both compute @xmath50 and are structured by @xmath22 , then they are syntactically equal ( not just semantically equivalent )",
    ".    note that if a gate @xmath82 is structured , then it is also _",
    "decomposable _ ,",
    "i.e. , every two distinct gates @xmath84 and @xmath85 wiring @xmath14 satisfy @xmath104 .",
    "the decomposability of @xmath14 in @xmath70 implies that the two subcircuits @xmath88 and @xmath89 are independent  in the sense that @xmath105 when viewing each circuit involved in the equation as a circuit over its own variables .    a _ sentential decision diagram _ , in short _ sdd _ , is a deterministic structured nnf @xmath70 over @xmath23 of the form @xmath106 } ( p_i \\wedge s_i ) \\text{,}\\ ] ] structured by a vtree @xmath102 , @xmath103 , such that the following holds .",
    "there exists a node @xmath98 with two children @xmath107 and @xmath108 structuring each @xmath63-gate appearing in ( [ eq : sdd - def ] ) , the @xmath109 s are sdds over @xmath110 structured by @xmath111 , the @xmath112 s are sdds over @xmath113 structured by @xmath114 , and moreover :    * @xmath115}p_i \\equiv \\top$ ] ; * @xmath116 for all @xmath117 in @xmath118 $ ] .",
    "constants ( @xmath67 and @xmath68 ) are sdds ( over any variable set ) structured by any vtree , and a literal ( @xmath119 or @xmath120 ) is an sdd ( over any variable set containing @xmath119 ) structured by any vtree containing @xmath119 .",
    "sdds become canonical forms if , in addition to the above , the following holds @xcite :    * @xmath121 for all @xmath117 in @xmath118 $ ] .",
    "let @xmath23 be a finite set of variables .",
    "a partition of @xmath23 is a sequence of pairwise disjoint subsets ( blocks ) of @xmath23 whose union is @xmath23 .",
    "let @xmath122 be a partition of @xmath23 .",
    "for @xmath123 and @xmath124 , we let @xmath125 denote the assignment of @xmath23 whose restriction to @xmath126 equals @xmath127 for @xmath128 .",
    "also , for @xmath129 and @xmath130 , we let @xmath131 .",
    "a _ ( combinatorial ) rectangle _ over @xmath23 is a boolean function @xmath132 over the boolean variables @xmath23 such that there exist a partition @xmath122 of @xmath23 and boolean functions @xmath133 for @xmath128 such that @xmath134 .",
    "we also call a subset @xmath135 of @xmath136 a rectangle over @xmath23 , with underlying partition @xmath122 , if there exists a rectangle @xmath137 , with underlying partition @xmath122 , such that @xmath138 .",
    "let @xmath139 be a boolean function over the boolean variables @xmath23 .",
    "a finite set @xmath140\\}$ ] of rectangles over @xmath23 is called a _",
    "rectangle cover _ of @xmath50 if @xmath141 } \\mathsf{sat}(r_i ) \\text{;}\\ ] ] the rectangle cover is called _ disjoint _ if the union in ( [ eq : rect - cover ] ) is disjoint .",
    "disjoint rectangle covers and deterministic structured nnfs are tightly related .",
    "@xcite[th : struct ] let @xmath70 be a ( deterministic ) structured nnf computing a function @xmath139 and respecting a vtree @xmath22 for @xmath23 . for every node @xmath98 , @xmath50 has a ( disjoint ) rectangle cover of size at most @xmath69 where each rectangle has underlying partition @xmath142 .",
    "let @xmath101 be a boolean function , and let @xmath122 be a partition of @xmath23 where @xmath143 .",
    "the _ communication matrix _ of @xmath50 relative to @xmath122 , denoted by @xmath144 is a boolean matrix whose rows and columns are indexed by boolean assignments of @xmath145 and @xmath146 , resp . ,",
    "and whose @xmath147th entry equals @xmath148 .",
    "we regard communication matrices as matrices over the reals .    a basic fact in communication complexity",
    "is that the rank of the communication matrix is a lower bound on the size of disjoint rectangle covers of a function .",
    "* section  4.1)[th : rklb ] let @xmath149 be a partition of the variables of a function @xmath50 , where @xmath143 .",
    "every disjoint rectangle cover of @xmath50 into rectangles with underlying partition @xmath149 contains at least @xmath150 rectangles .",
    "a typical application of the above statement is the _ disjointness function _ , @xmath151 where @xmath152 and @xmath153 .",
    "it is folklore that @xmath154 i.e. , the communication matrix of @xmath155 relative to @xmath156 has full rank ( * ? ? ?",
    "* exercise  7.1 ) .",
    "thus every disjoint rectangle cover of @xmath155 into rectangles with underlying partition @xmath157 has at least @xmath158 rectangles .",
    "in this section , we introduce the notion of factor width of a boolean function , relate it with its circuit treewidth , and show that , when parameterized by its factor width , a boolean function admits a linear size compilation into some natural classes of canonical deterministic structured nnfs ( including sdds ) .",
    "we introduce the notion of _ factor width _ , and recall from the literature the notion of circuit treewidth @xcite .",
    "let @xmath159 be a boolean function over a finite set of variables @xmath23 .",
    "for a set of variables @xmath24 we use the notation @xmath160 to display a partition of the variables of @xmath50 into the two blocks @xmath161 and @xmath162 .",
    "it is intended that if @xmath163 and @xmath164 , then @xmath165 .",
    "the _ cofactor _ ( or _ subfunction _ ) of @xmath50 induced by @xmath163 is the boolean function @xmath166 such that @xmath167 for all @xmath164 .",
    "a function @xmath168 is called a _ cofactor of @xmath101 relative to @xmath162 _ if it is equal to the cofactor of @xmath50 induced by some @xmath163 .",
    "[ ex : cofactors ] let @xmath169 be boolean implication , i.e.  @xmath170 iff @xmath171 , for all @xmath172 .",
    "the cofactors of @xmath50 relative to @xmath173 , induced by boolean assignments of @xmath119 , are @xmath174 and @xmath175 .",
    "the cofactors of @xmath50 relative to @xmath119 , induced by boolean assignments of @xmath173 , are @xmath176 and @xmath177 .",
    "the cofactors of @xmath50 induced by boolean assignments of both @xmath119 and @xmath173 are @xmath178 and @xmath179 .",
    "the only cofactor of @xmath50 induced by boolean assignments of no variables is @xmath180 itself .",
    "we introduce notation to denote the cofactor of a boolean function @xmath101 generated by replacing , in a partition of @xmath23 , the variables in certain blocks by constants .",
    "let @xmath181 be a partition of @xmath23 , let @xmath182 $ ] , and let @xmath183 for all @xmath184 .",
    "we write @xmath185 where @xmath186",
    "if @xmath184 and @xmath187 otherwise , for all @xmath188 $ ] , to denote the cofactor of @xmath50 induced by @xmath189 , i.e.  the boolean function over the variables @xmath190\\setminus l } y_i$ ] defined , for every @xmath190\\setminus l } ( b_i \\colon y_i \\to \\{0,1\\})$ ] , by @xmath191\\setminus l } b_i \\mapsto f(b_1,\\ldots , b_l)\\text{.}\\ ] ]    [ ex : notation ] let @xmath50 be as in example  [ ex : cofactors ] , so that @xmath139 for @xmath192 .",
    "let @xmath193 .",
    "we write @xmath194 .",
    "let @xmath195 .",
    "we write @xmath196 to denote the cofactor of @xmath50 relative to @xmath162 induced by @xmath197 . if @xmath198 , then @xmath199 .",
    "let @xmath200 . intuitively , a factor of @xmath201 is a function @xmath49 whose models correspond exactly to the assignments of @xmath24 that induce some fixed cofactor @xmath202 of @xmath50 .",
    "[ def : factor]let @xmath24 and @xmath23 be finite sets of variables and let @xmath203 be a boolean function .",
    "a boolean function @xmath204 is called a _ factor of @xmath101 relative to @xmath24 _ if there exists a cofactor @xmath205 of @xmath50 such that @xmath206 the factors of @xmath50 relative to @xmath24 are denoted by @xmath207 .",
    "[ ex : factors ] let @xmath169 be boolean implication as in example  [ ex : cofactors ] .",
    "the function @xmath208 is a factor of @xmath50 relative to @xmath119 , because there exists a cofactor of @xmath50 relative to @xmath173 , namely @xmath209 , such that @xmath210 iff @xmath211 .",
    "the function @xmath212 is a factor of @xmath50 relative to @xmath119 , because there exists a cofactor of @xmath50 relative to @xmath173 , namely @xmath213 , such that @xmath210 iff @xmath211 .",
    "note that cofactors and factors of a boolean function relative to a variable set are , in general , distinct .",
    "[ ex : fneqcof ] let @xmath169 be boolean implication as in example  [ ex : cofactors ] . then @xmath208 is a factor of @xmath50 relative to @xmath119 ( example  [ ex : factors ] ) , but it is not a cofactor of @xmath50 relative to @xmath119 , since the only cofactors of @xmath50 relative to @xmath119 are equivalent to @xmath120 and @xmath214 ( example  [ ex : cofactors ] ) .    note that , by definition  [ def : factor ] , @xmath215 but we insist on @xmath24 being an arbitrary set of variables for technical convenience . moreover ,",
    "again by definition  [ def : factor ] , @xmath216 and the union is disjoint . in words , @xmath207 naturally determines a partition of @xmath217 whose blocks , of the form @xmath218 for @xmath219 , correspond to the cofactors of @xmath50 relative to @xmath220 .",
    "finally , we introduce the notion of factor width of a boolean function .",
    "let @xmath139 be a boolean function and let @xmath22 be a vtree for @xmath221 .",
    "the _ factor width of @xmath50 relative to @xmath22 _ , in symbols @xmath222 , is defined by @xmath223 the _ factor width _ of @xmath50 is defined by @xmath224    the _ treewidth of a circuit _ @xmath70 , in symbols @xmath225 , is the treewidth of the undirected graph underlying ( the directed acyclic graph underlying ) @xmath70 .",
    "the _ circuit treewidth _",
    "@xmath226 of a boolean function @xmath50 is the minimum treewidth of a circuit computing @xmath50 .",
    "a crucial fact in our development is that the factor width of a boolean function is bounded above by a function of its circuit treewidth .",
    "the proof is a revisitation of ( * ? ? ?",
    "* lemma  2.12 ) .",
    "[ lemma : jhasuciu ] for all boolean functions @xmath50 , @xmath227    let @xmath70 be a treewidth @xmath228 circuit computing the boolean function @xmath101 .",
    "let @xmath135 be a _",
    "tree decomposition of the gates of @xmath70 , witnessing treewidth @xmath228 ; without loss of generality , the root of @xmath135 is the empty bag , therefore each input gate of @xmath70 ( i.e. , each variable in @xmath23 ) is forgotten exactly once in @xmath135 .",
    "we associate to @xmath135 a vtree @xmath22 for @xmath23 as follows .",
    "let @xmath229 be a set of fresh variables in a bijective correspondence with the leaves of @xmath135 .",
    "label the leaves of @xmath135 by pairwise distinct ( dummy ) variables in @xmath229 .",
    "for every variable @xmath230 , append a fresh leaf labelled @xmath119 to the node forgetting @xmath119 in @xmath135 .",
    "the resulting tree @xmath22 is a vtree for @xmath231 .    for every @xmath98 ,",
    "let @xmath232 denote the variables in @xmath23 appearing in @xmath96 ( or equivalently , the variables in @xmath96 that are not dummy variables ) . in light of ( [ eq : dummyvars ] ) , to show that @xmath233 it is sufficient to prove that @xmath234 matches the bound for all @xmath98 .",
    "if @xmath91 is a leaf in @xmath22 , then @xmath235 for some @xmath230 and @xmath236 , or @xmath91 is labelled by some dummy variable in @xmath229 , so that @xmath237 and @xmath238",
    ". otherwise @xmath91 is a bag @xmath239 in @xmath135 and in this case @xmath232 contains the variables in @xmath23 forgotten by nodes in the subtree of @xmath135 rooted at @xmath91 .    for a gate @xmath14 in @xmath70 ,",
    "let @xmath240 be the gates in @xmath239 with a directed path to @xmath14 in ( the dag underlying ) @xmath70 whose intermediate gates are not in @xmath239 .",
    "namely , @xmath241 iff @xmath242 and there exists a directed path @xmath243 in the dag underlying @xmath70 such that @xmath244 .",
    "let @xmath14 be a gate in @xmath70 .",
    "we freely identify @xmath80 , the subcircuit of @xmath70 rooted at @xmath14 , with the boolean function on @xmath23 it computes .",
    "[ cl : main - cl ] for every @xmath82 , it holds that @xmath245 be a set of fresh variables .",
    "let @xmath246 denote the circuit obtained from @xmath80 by transforming each gate @xmath241 into an input gate labelled by the variable @xmath247 .",
    "we distinguish two cases depending on whether or not @xmath14 is in @xmath239 .",
    "if @xmath248 , then observe that @xmath249 , or @xmath250 ; otherwise , if @xmath251 uses variables in both @xmath232 and @xmath252 then , in the graph underlying @xmath70 , there exists a path from @xmath232 to @xmath252 not intersecting @xmath239 , contradicting the properties of @xmath135 .",
    "if @xmath249 then , for every @xmath253 , @xmath254 is a function of @xmath43 among at most @xmath255 possibilities . otherwise , if @xmath250 , then every @xmath253 yields the same function @xmath256 of @xmath257 .",
    "since each variable @xmath247 in @xmath251 represents the subcircuit @xmath258 of @xmath70 for @xmath241 , it follows that @xmath259    if @xmath260 , then each proper subcircuit of @xmath251 uses only variables in @xmath261 or only variables in @xmath257 ; otherwise we obtain a contradiction as above .",
    "let @xmath262 and @xmath263 be a bipartition of the immediate subcircuits of @xmath251 such that the @xmath264 s only use variables in @xmath261 and the @xmath265 s only use variables in @xmath257 .",
    "if @xmath14 is an @xmath63-gate , then @xmath266 for every @xmath253 , @xmath267 is a function @xmath268 over @xmath43 ; on the other hand , every @xmath253 yields the same function @xmath269 over @xmath257 , namely @xmath270 . therefore , for all @xmath253 , @xmath254 is a function over @xmath257 of the form @xmath271 where @xmath268 is a function over @xmath43 , so that @xmath272 recalling that each variable @xmath247 in @xmath251 represents the subcircuit @xmath258 of @xmath70 for @xmath241 , we have @xmath259    the cases where @xmath14 is a @xmath64-gate or a @xmath66-gate are similar , and the claim is proved .    for all @xmath82 , let @xmath273 . by induction on @xmath274",
    "we prove that for all @xmath260 it holds that latexmath:[\\[\\label{eq : ind }     for the base case , let @xmath260 be such that @xmath276 .",
    "then @xmath277 where the first inequality holds by ( [ eq : rec ] ) as @xmath278 in this case .",
    "for the inductive case , let @xmath260 be such that @xmath279 .",
    "then , resp .  by ( [ eq : rec ] ) and the induction hypothesis as @xmath280 for all @xmath241 , @xmath281 but @xmath282 where @xmath283 justifies the last inequality .",
    "we now conclude the proof .",
    "let @xmath14 be the output gate of @xmath70 , i.e. , @xmath284 . then , justifying the first and second inequalities resp .  by ( [ eq : rec ] ) and by ( [ eq : ind ] ) , @xmath240 and @xmath285 , @xmath286 and",
    "we are done .",
    "we conclude the section observing that circuit treewidth is computable , thus answering a question posed by jha and suciu ( * ? ? ?",
    "* section  6 ) .",
    "[ prop : seese ] the circuit treewidth of a boolean function is computable .",
    "let @xmath287 be a variable set .",
    "say that a graph ( with loops ) @xmath57 _ implements _ a circuit over @xmath23 iff there exists a circuit @xmath70 over @xmath23 such that @xmath57 is ( isomorphic to ) the graph whose edge set @xmath288 is defined relative to @xmath70 as follows :    * for every wire @xmath289 in @xmath70 , add to @xmath288 a path @xmath290 , @xmath291 , @xmath292 from @xmath14 to @xmath293 with a loop on @xmath85 , where @xmath84 and @xmath85 are fresh vertices . *",
    "add to @xmath288 a loop on the output gate @xmath14 of @xmath70 .",
    "* let @xmath294 for every @xmath295-gate @xmath14 in @xmath70 , add to @xmath288 a @xmath296-star @xmath297 , @xmath298 , @xmath299 centered at @xmath14 , where @xmath300 are fresh vertices .",
    "intuitively a graph ( with loops ) @xmath57 implementing a circuit @xmath70 is a faithful representation of @xmath70 in the vocabulary of graphs , where the arcs and labels used to represent @xmath70 in the vocabulary of circuits are suitably expressed by edges ( and loops ) .",
    "let @xmath50 be a boolean function over @xmath23 .",
    "it is a tedious but straightforward exercise to write an mso sentence @xmath301 that is true on a graph ( with loops ) @xmath57 iff @xmath57 implements a circuit @xmath70 on @xmath23 computing @xmath101 ( * ? ? ?",
    "* examples 4.10 , 4.13 , and 4.18 ) .    also note that , if the graph ( with loops ) @xmath57 implements a circuit @xmath70 , then the treewidth of @xmath57 is equal to the treewidth of @xmath70 .",
    "now , let @xmath5 be an upper bound on the circuit treewidth of @xmath50 ( for instance , the treewidth of the dnf whose terms are exactly the models of @xmath50 ) .",
    "seese proves that , given an mso sentence on the vocabulary of graphs , it is decidable whether it is satisfied by a graph ( with loops ) of treewidth @xmath5 @xcite .",
    "we therefore cycle for @xmath302 until we find @xmath303 such that @xmath301 is modeled by a graph of treewidth @xmath304 .",
    "we show that boolean functions of small factor width have implementations of small width within natural canonical subclasses of deterministic structured nnfs ( including canonical sdds ) ; conversely , small width implementations within such circuit classes imply small circuit treewidth .",
    "thus a class of boolean functions has bounded circuit treewidth iff it has bounded width implementations in some natural , canonical classes of deterministic structured nnfs , including sdds .",
    "we introduce the notion of _ factorized implicant _ of a boolean function @xmath48 , roughly @xmath305 where @xmath24 and @xmath56 are disjoint sets of variables , @xmath306 ( resp . , @xmath307 )",
    "is a factor of @xmath50 relative to @xmath24 ( resp .",
    ", @xmath56 ) .",
    "the first key insight is that the rectangle formed by multiplying any two factors @xmath308 and @xmath309 of @xmath48 is either disjoint from @xmath50 or contained in @xmath50 .",
    "[ lemma : factors ] let @xmath139 be a boolean function .",
    "let @xmath24 and @xmath56 be disjoint subsets of @xmath23 .",
    "let @xmath269 , @xmath57 , and @xmath58 be factors of @xmath50 relative to @xmath55 , @xmath24 , and @xmath56 , respectively .",
    "then either @xmath310 or @xmath311    if @xmath312 , then let @xmath313 and @xmath314 be such that @xmath315 .",
    "let @xmath316 and @xmath317 .",
    "it suffices to show that @xmath318 .",
    "below , @xmath319 .",
    "assume for a contradiction that @xmath320 .",
    "therefore , by definition , the cofactors of @xmath50 induced by @xmath321 and @xmath322 are distinct , i.e. , @xmath323    on the other hand , by definition , @xmath324 implies that @xmath325 , and similarly @xmath326 implies that @xmath327 . in particular , @xmath328 and @xmath329 .",
    "then @xmath330 a contradiction .    intuitively , a factorized implicant of a function @xmath48 is a pair of factors @xmath308 and @xmath309 entirely contained in @xmath50 , as in ( [ eq : rect - cont ] ) .",
    "formally ,    let @xmath139 be a boolean function .",
    "let @xmath269 , @xmath57 , and @xmath58 be factors of @xmath50 relative to @xmath55 , @xmath24 , and @xmath56 , resp .",
    ", where @xmath24 and @xmath56 are disjoint subsets of @xmath23 . then @xmath331 is a _",
    "factorized implicant of @xmath269 relative to @xmath332 _ if @xmath57 and @xmath58 satisfy ( [ eq : rect - cont ] ) relative to @xmath269 .",
    "we denote by @xmath333 the set of factorized implicants of @xmath269 relative to @xmath332 .",
    "the second key insight is that the factorized implicants of @xmath48 naturally induce a disjoint rectangle cover for @xmath48 .",
    "[ lemma : drc ] let @xmath139 be a boolean function and let @xmath269 be a factor of @xmath50 relative to @xmath55 , where @xmath24 and @xmath56 are disjoint subsets of @xmath23 .",
    "then @xmath334 forms a disjoint rectangle cover of @xmath269 , i.e. , @xmath335 and the union is disjoint .",
    "a circuit interpretation of lemma  [ lemma : drc ] is that @xmath336 where @xmath337 , @xmath338 , and @xmath339 are circuits using variables in @xmath55 , @xmath24 , and @xmath56 computing @xmath269 , @xmath57 , and @xmath58 , respectively .",
    "the @xmath63-gates are decomposable as @xmath24 and @xmath56 are disjoint , and by lemma  [ lemma : drc ] the @xmath64-gate is deterministic .",
    "we claim that the union on the right of ( [ eq : main - node-1 ] ) is disjoint . indeed if @xmath340 and @xmath341 are distinct implicants in @xmath333 , then @xmath342 or @xmath343 .",
    "if @xmath342 , then @xmath344 because distinct factors of @xmath50 relative to @xmath24 have disjoint models by ( [ eq : part ] ) . similarly , if @xmath343 , then @xmath345",
    "therefore , @xmath346 , and we are done .",
    "we prove the equality in ( [ eq : main - node-1 ] ) . for the nontrivial inclusion ( @xmath347 ) ,",
    "let @xmath348 be in @xmath349 .",
    "by ( [ eq : part ] ) , there exist @xmath219 such that @xmath350 and @xmath351 such that @xmath352 .",
    "then @xmath353 .",
    "it follows by lemma  [ lemma : factors ] that @xmath354 .",
    "then @xmath355 and @xmath197 is contained in the union on the right .",
    "the above insight can be exploited recursively to implement boolean functions within a natural , canonical class of deterministic structured forms .",
    "let @xmath50 be a function and let @xmath22 be a vtree , both over the variables @xmath23 .",
    "for every node @xmath98 and every factor @xmath269 of @xmath50 relative to @xmath232 , we construct a circuit @xmath356 as follows .    if @xmath91 is a leaf of @xmath22 , then @xmath235 for some variable @xmath230 .",
    "there are two cases .",
    "either @xmath357 , or @xmath358 . in the former case ,",
    "@xmath359 and @xmath360 in the latter case , @xmath361 and @xmath362    if @xmath91 is a node of @xmath22 with children @xmath107 and @xmath108 , we put @xmath363    finally we put @xmath364 where @xmath365 is the root of @xmath22 ; note that @xmath50 itself is a factor of @xmath50 relative to @xmath23 ; its models induce the cofactor @xmath366 of @xmath50 , the identically @xmath65 function ( over @xmath367 ) .",
    "[ lemma : dsdnnf - sub ] let @xmath50 be a boolean function and let @xmath22 be a vtree , both over the variables @xmath23 . let @xmath98 and let @xmath368 .",
    "the following holds .",
    "* @xmath356 is a deterministic structured nnf respecting the vtree @xmath96 .",
    "* @xmath356 computes @xmath269 .",
    "the proof is a routine induction on the depth of @xmath91 in @xmath22 .",
    "the base case holds by inspection of ( [ eq : base-1])-([eq : base-3 ] ) .",
    "the inductive case holds by inspection of ( [ eq : main - node ] ) , using ( [ eq : main - node-1 ] ) in lemma  [ lemma : drc ] and the induction hypothesis ; indeed , note that the disjunction arising in ( [ eq : main - node ] ) is deterministic because the union in ( [ eq : main - node-1 ] ) is disjoint , and the conjunctions arising in ( [ eq : main - node ] ) are structured by @xmath96 ( namely the left and right conjuncts are over variables @xmath369 and @xmath370 resp . , where @xmath107 and @xmath108 are the children of @xmath91 in @xmath22 ) by the induction hypothesis",
    ".    note that , by lemma  [ lemma : dsdnnf - sub ] , it follows that @xmath371 is a deterministic structured nnf computing @xmath50 , canonical in that it is uniquely determined by the vtree @xmath22 and @xmath50 ; the notion of _ factorized implicant width _ of @xmath50 relative to @xmath22 arises naturally .",
    "let @xmath50 be a boolean function and let @xmath22 be a vtree , both over the variables @xmath23 .",
    "factorized implicant width of @xmath50 relative to @xmath22 _ , in symbols @xmath372 , is defined by is an @xmath63-gate arising from ( [ eq : main - node ] ) , we say that @xmath14 is _ structured _ by @xmath98 . ]",
    "@xmath373 the _ factorized implicant width _ of @xmath50 , in symbols @xmath374 , is defined by @xmath375    relative to its factorized implicant width , a boolean function ( of @xmath4 variables ) has linear ( in @xmath4 ) size compilations into canonical deterministic structured forms .",
    "[ th : factorized - forms - main ] a boolean function @xmath50 of @xmath4 variables and factorized implicant width @xmath5 has canonical deterministic structured nnfs of size @xmath376 .    let @xmath23 be the variables of @xmath50 , so that @xmath377 , and let @xmath22 be a vtree for @xmath23 witnessing factorized implicant width @xmath5 for @xmath50 .",
    "the circuit @xmath371 in ( [ eq : cft ] ) is a canonical deterministic structured nnf computing @xmath50 by lemma  [ lemma : dsdnnf - sub ] .",
    "moreover , we claim that @xmath371 has size @xmath376 .",
    "the @xmath4 leaves of @xmath22 contribute at most @xmath378 input gates and @xmath4 @xmath66-gates in @xmath371 .",
    "the @xmath379 internal nodes of @xmath22 contribute each at most @xmath5 @xmath63-gates ( by the definition of factorized implicant width ) , and each such gate is linked with at most @xmath380 @xmath64-gates .",
    "hence @xmath371 contains at most @xmath381 gates .",
    "we conclude the section showing that a class of boolean functions has bounded circuit treewidth iff it has bounded factorized implicant width .",
    "it is sufficient to prove that the factorized implicant width of a boolean function is bounded below and above by computable functions of its circuit treewidth .    for the upper bound",
    ", we have @xmath382 where the first inequality is justified by the observation that every @xmath63-gate @xmath14 in @xmath371 , structured by a node @xmath98 , corresponds to a pair of factors of @xmath50 , and the second inequality follows by lemma  [ lemma : jhasuciu ] .    for the lower bound",
    ", we verify that small factorized implicant width implies small circuit treewidth .",
    "[ prop : fiw - ctw ] for all boolean functions @xmath50 , @xmath383    let @xmath22 be a vtree for @xmath23 such that @xmath384 we claim that @xmath385 , so that @xmath386 by lemma  [ lemma : dsdnnf - sub ] .    for every gate @xmath387 ,",
    "let @xmath388 denote the closed neighborhood of @xmath14 in the undirected graph underlying @xmath371 .",
    "we define a tree decomposition for the undirected graph underlying @xmath371 , as follows .",
    "the bags of the tree decomposition have the form @xmath389 for all @xmath98 .",
    "the root of the tree decomposition is @xmath390 .",
    "the bag @xmath391 has an arc to the bag @xmath392 iff @xmath107 has an arc to @xmath108 in @xmath22 . by definition , @xmath393 contains all the @xmath63-gates structured by the node @xmath98 ; there are at most @xmath5 such gates in @xmath371 by definition , and each such gate has indegree @xmath97 and outdegree @xmath65 by construction ( therefore degree @xmath380 in the undirected graph underlying @xmath371 ) . hence @xmath394 .",
    "we check the desired properties .",
    "since every wire of @xmath371 enters or leaves an @xmath63-gate and every @xmath63-gate is structured by some @xmath98 , the edges of the undirected graph underlying @xmath371 are covered by the tree decomposition .",
    "moreover let @xmath14 be a gate of @xmath371 occurring in two distinct bags @xmath391 and @xmath392 .",
    "then @xmath395 where @xmath84 is a @xmath63-gate structured by @xmath107 and @xmath85 is a @xmath63-gate structured by @xmath108 . by construction of @xmath371 ,",
    "either @xmath107 has an arc to @xmath108 in @xmath22 or @xmath108 has an arc to @xmath107 in @xmath22 .",
    "hence @xmath391 and @xmath392 are adjacent .",
    "we show that the notion of factorized implicant lies at the core of ( and provides fresh insight on ) the canonical construction of sdds for boolean functions .",
    "we prepare the actual description of the construction in two steps .",
    "the first step yields , by a straightforward generalization of lemma  [ lemma : drc ] , a factorized implicant decomposition reminiscent of ( [ eq : syntactic - fif ] ) for unions of factors .",
    "[ lemma : union - drc ] let @xmath139 be a boolean function , let @xmath24 and @xmath56 be disjoint subsets of @xmath23 , and let @xmath396",
    ". then @xmath397 forms a disjoint rectangle cover of @xmath398 .    in terms of circuits",
    ", the statement means that @xmath399 where @xmath337 , @xmath338 , and @xmath339 are as in ( [ eq : syntactic - fif ] ) , the @xmath64-gate is deterministic , and the @xmath63-gates are decomposable .",
    "we have @xmath400 where the second equality follows by applying lemma  [ lemma : drc ] to @xmath269 .",
    "we claim that the union is disjoint .",
    "indeed , by ( [ eq : part ] ) , distinct factors of @xmath50 relative to @xmath55 , in particular those in @xmath401 , have disjoint models ; moreover , by lemma  [ lemma : drc ] , distinct implicants of a factor have disjoint models .",
    "the second step enforces the properties of a proper sentential decision over the factorized implicant form ( [ eq : syntactic - sdd ] ) given by lemma  [ lemma : union - drc ] , as follows . for each @xmath219 , let @xmath402 and observe that @xmath403 where empty disjunctions are implemented by @xmath67 , is equivalent to @xmath404 and is a sentential decision form as the factors of @xmath50 relative to @xmath24 partition @xmath405 .    however , ( [ eq : noncanonical - sdd - form ] ) is not a canonical form because distinct @xmath406 and @xmath407 in @xmath207 can give @xmath408 .",
    "let @xmath409 for all @xmath410 $ ] , and @xmath411 it is readily observed that @xmath412 is equivalent to @xmath413 and moreover :    * @xmath414}\\bigvee_{p \\in \\mathcal{p}_i } c_p$ ] ; * @xmath415 for @xmath117 in @xmath118 $ ] ; * @xmath416 for @xmath117 in @xmath118 $ ] .",
    "we now use the above development to describe a recursive construction of a canonical sdd for a given boolean function .",
    "let @xmath50 be a boolean function and let @xmath22 be a vtree , both over @xmath23 .",
    "for every node @xmath98 and every subset @xmath401 of factors of @xmath50 relative to @xmath232 , we construct a circuit @xmath417 , as follows .    if @xmath91 is a leaf of @xmath22 , then @xmath235 for some variable @xmath230 .",
    "there are two cases .",
    "either @xmath357 , or @xmath358 . in the former case , @xmath359 and : @xmath418 ;",
    "@xmath419 . in the latter case , @xmath361 and : @xmath418 ; @xmath420 ; @xmath421 ; @xmath422 .",
    "if @xmath91 is a node of @xmath22 with children @xmath107 and @xmath108 , we put @xmath423    finally we put , where @xmath365 is the root of @xmath22 , @xmath424    [ lemma : sdd - constr - correct ] let @xmath50 be a boolean function and let @xmath22 be a vtree , both over the variables @xmath23 .",
    "let @xmath98 and let @xmath425 .",
    "* @xmath417 is a canonical sdd respecting the vtree @xmath96 .",
    "* @xmath417 computes @xmath426 .    by induction on the depth of @xmath91 in @xmath22 .",
    "the base case holds by construction .",
    "the inductive case holds inspection of ( [ eq : cvh ] ) , using ( [ eq : canonical - sdd - form ] ) together with ( sd1)-(sd3 ) , ( [ eq : noncanonical - sdd - form ] ) , lemma  [ lemma : union - drc ] , and the induction hypothesis .",
    "therefore @xmath427 is the canonical sdd computing @xmath50 , uniquely determined by the vtree @xmath22 .",
    "we recall the notion of _ sentential decision width _ of @xmath50 relative to @xmath22 .",
    "[ def : sdd - width ] let @xmath50 be a boolean function and let @xmath22 be a vtree , both over @xmath23 .",
    "the _ sentential decision width of @xmath50 relative to @xmath22 _ , in symbols @xmath428 , is defined by @xmath429 the _ sdd width _ of @xmath50 , in symbols @xmath430 , is defined by @xmath431    it is well known that obdds are canonical sdds respecting linear vtrees , i.e.  vtrees where every left child is a leaf @xcite ; in this case , the notion of sdd width in definition  [ def : sdd - width ] reduces to the usual notion of obdd width @xcite . moreover , as a boolean function ( of @xmath4 variables ) has linear ( in @xmath4 ) obdd size parameterized by its obdd width , likewise it has linear sdd size parameterized by its sdd width .",
    "[ th : linear - sdd - size ] a boolean function @xmath50 of @xmath4 variables and sdd width @xmath5 has canonical sdd size @xmath376 .",
    "let @xmath23 be the variables of @xmath50 , so that @xmath377 , and let @xmath22 be a vtree for @xmath23 witnessing sdd width @xmath5 for @xmath50",
    ". the circuit @xmath427 in ( [ eq : sdd - root ] ) is a canonical sdd by lemma  [ lemma : sdd - constr - correct ] .",
    "moreover , we claim that @xmath427 has size @xmath376 .",
    "the @xmath4 leaves of @xmath22 contribute at most @xmath432 input or negation gates in @xmath371 .",
    "the @xmath379 internal nodes of @xmath22 contribute each at most @xmath5 @xmath63-gates ( by the definition of sdd width ) , and each such gate is linked with at most @xmath380 @xmath64-gates .",
    "hence @xmath371 contains at most @xmath433 gates .",
    "we conclude observing that , for classes of boolean functions , bounded circuit treewidth and bounded sdd width collapse . indeed ,",
    "on the one hand , the sdd width of a boolean function @xmath50 is bounded above by a computable function of its circuit treewidth , namely , @xmath434 since in the canonical sdd @xmath427 for @xmath22 every @xmath63-gate @xmath14 structured by a node @xmath98 corresponds to a pair of sets of factors of @xmath50 ( plus @xmath67 ) , and @xmath435 is bounded above by @xmath226 as in lemma  [ lemma : jhasuciu ] . on the other hand , for all boolean functions @xmath50 , along the lines of proposition  [",
    "prop : fiw - ctw ] , @xmath436    by combining ( [ eq : fiw - ub])-([eq : fiw - lb ] ) and ( [ eq : sdd - ub])-([eq : sdd - lb ] ) , the factorized implicant width ( resp .",
    ", sdd width ) of a boolean function is squeezed between computable functions of its sdd width ( resp . , factorized implicant width ) .",
    "in this section , we show that inversions in unions of conjunctive queries , with or without inequalities , imply large deterministic structured circuits for their lineages .",
    "let @xmath437 be a relational vocabulary .",
    "union of conjunctive queries ( ucqs ) with inequalities _",
    "@xmath0 is a disjunction of existentially closed conjunctions of atoms @xmath438 and inequalities @xmath439 , where @xmath440 and @xmath119 , @xmath173 , @xmath441 are variables , @xmath410 $ ] .",
    "we call @xmath0 a ucqs if it does not contain inequalities",
    ". the _ lineage of a boolean query @xmath0 over a database @xmath1 _ is a boolean function @xmath2 whose boolean variables are the tuples in @xmath1 such that , for every subdatabase @xmath442 , it holds that @xmath443 iff @xmath444 , where @xmath445 is defined by @xmath446 iff @xmath447 .",
    "a _ lineage of a boolean query _ is a lineage of the query over some database .",
    "we prove the main result . for all @xmath448 , let @xmath449 \\}$ ] , @xmath450 \\}$ ] , @xmath451 \\}$ ] for @xmath452 $ ] , and @xmath453}z^i$ ] . for @xmath454 $ ] , let : @xmath455 } ( x_{l } \\wedge z^1_{l , m})\\text{,}\\\\ h^i_{k , n}(z^i , z^{i+1 } ) & = \\bigvee_{l , m \\in [ n ] } ( z^i_{l , m } \\wedge z^{i+1}_{l , m})\\text{,}\\\\ h^k_{k , n}(z^k",
    ", y ) & = \\bigvee_{l , m \\in [ n ] } ( z^k_{l , m } \\wedge y_{m})\\text{.}\\end{aligned}\\ ] ]    in ( * ? ? ?",
    "* proposition  7 ) and ( * ? ? ? * theorem  3.9 ) jha and suciu show the following , resp .  for ucqs and ucqs with inequalities .",
    "[ lemma : inv - impl - h ] let @xmath0 be a ucqs with or without inequalities . if @xmath0 contains an inversion of length @xmath456 , then for every @xmath61 there exist a lineage @xmath101 of @xmath0 on @xmath457 variables and assignments @xmath458 for @xmath459 and @xmath460 such that @xmath461    as we only need the implication stated in lemma  [ lemma : inv - impl - h ] , we omit the technical definition of the notion of inversion @xcite .",
    "the following statement unifies and generalizes analogous results by jha and suciu for ucqs with inequalities vs.  obdds ( * ? ? ?",
    "* theorem  3.9 ) and by beame and liew for ucqs vs.   sdds ( * ? ? ?",
    "* theorem  4.6 ) .",
    "[ th : main - ineq ] let @xmath0 be a ucqs with or without inequalities . if @xmath0 contains an inversion of length @xmath456 , then for every @xmath61 there exists a lineage @xmath50 of @xmath0 on @xmath457 variables whose deterministic structured nnf size is @xmath462 .",
    "let @xmath0 be a query with inequalities .",
    "if @xmath0 contains an inversion of length @xmath456 , then by lemma  [ lemma : inv - impl - h ] for every @xmath61 there exist a lineage @xmath101 of @xmath0 on @xmath457 variables and assignments @xmath458 for @xmath459 and @xmath460 such that @xmath463 .",
    "let @xmath70 be a deterministic nnf of size @xmath464 computing @xmath50 , structured by the vtree @xmath22 .",
    "then by the properties of deterministic structured nnfs dblp : conf / aaai / pipatsrisawatd08 , it holds that @xmath465 is a deterministic nnf of size @xmath466 that computes @xmath467 and is structured by @xmath22 , for all @xmath460 . by lemma  [ lemma : main - inversion ] , there exists @xmath468 such that @xmath469 has size @xmath470",
    ". therefore @xmath70 has size @xmath462 .",
    "the proof idea is that , if a query @xmath0 contains inversions , then it has a lineage @xmath2 of which each @xmath471 is a cofactor ( @xmath460 ) .",
    "if @xmath70 is a small deterministic form for @xmath2 respecting a vtree @xmath22 , then small deterministic structured forms for each @xmath471 , _ all _ respecting the vtree @xmath22 , can be mined from @xmath70 by suitably assigning its inputs .",
    "but this is impossible for communication complexity reasons ( lemma  [ lemma : main - inversion ] ) .",
    "[ lemma : main - inversion ] for every vtree @xmath22 for @xmath472 and every family @xmath473 of deterministic structured nnfs , where @xmath469 is structured by @xmath22 and computes @xmath471 ( @xmath460 ) , there exists @xmath468 such that @xmath469 has size @xmath462 .",
    "we let @xmath232 denote the variables in @xmath474 , @xmath475 denote the variables in @xmath476 , and @xmath477 denote the variables in @xmath478 .",
    "[ cl : find - node ] there exists @xmath98 such that @xmath479 .",
    "let @xmath480 , for all @xmath98 .",
    "let @xmath481 be a root - leaf path in @xmath22 such that , letting @xmath482 , @xmath483 for all @xmath484 .",
    "let @xmath188 $ ] be minimum such that @xmath485 so that @xmath486 by construction , @xmath487 hence , letting @xmath488 , we have @xmath489 and we are done .    by claim  [ cl : find - node ] ,",
    "let @xmath98 be such that @xmath479 .",
    "let @xmath490 and @xmath491 .",
    "assume without loss of generality that @xmath492 ; otherwise the argument is similar .",
    "it follows by the choice of @xmath91 that @xmath493 and that @xmath494    we enter a case distinction .",
    "the first case is covered by the following claim .",
    "[ cl : h0-hard ] if there exists @xmath495 $ ] such that for all @xmath496 $ ] it holds that @xmath497 implies @xmath498 , then @xmath499 has size @xmath500 .    for @xmath495 $ ] , let @xmath501 . by hypothesis",
    ", there exists @xmath495 $ ] such that @xmath502 .",
    "write @xmath503 then @xmath504 is a deterministic nnf structured by @xmath22 of size @xmath505 @xcite .",
    "it follows from theorem  [ th : struct ] that @xmath506 has a disjoint rectangle cover of size at most @xmath507 where each rectangle has underlying partition @xmath508 .    by the choice of @xmath91",
    ", it holds that @xmath232 contains @xmath509 variables in @xmath23 . for the sake of notation , say that @xmath510 , so that @xmath511",
    ". then , since @xmath512 , we have that @xmath513 note that @xmath514 is the complement of the disjointness function @xmath515 in ( [ eq : df ] ) . therefore the complement of the communication matrix of @xmath506 relative to @xmath508 is equal ( up to a permutation of rows and columns ) to the communication matrix of @xmath516 , i.e. , @xmath517 where @xmath65 denotes the @xmath518 all-@xmath65 matrix .",
    "therefore , by ( [ eq : rkdf ] ) and basic linear algebra , @xmath519 hence @xmath520 therefore , by theorem  [ th : rklb ] and ( [ eq : lb - compl - df ] ) , every disjoint rectangle cover of @xmath506 into rectangles with underlying partition @xmath508 contains at least @xmath521 rectangles .    summarizing , @xmath506 has a disjoint rectangle cover of size at most @xmath507 where each rectangle has underlying partition @xmath508 , but every such rectangle cover contains at least @xmath521 rectangles . hence @xmath522 and we are done ( recall ( [ eq : nx - lb ] ) ) .",
    "the second ( and complementary ) case is covered by the following claim .",
    "[ cl : hkp - hard ] if for all @xmath495 $ ] there exists @xmath496 $ ] such that @xmath497 and @xmath523 , then there exists @xmath524 $ ] such that @xmath525 has size @xmath462 .",
    "define a set @xmath135 of pairs @xmath526 as follows . for",
    "each @xmath495 $ ] such that @xmath527 , choose @xmath496 $ ] such that @xmath523 , and add @xmath526 to @xmath135 .",
    "note that @xmath528 , let @xmath529 be such that @xmath530 iff @xmath531 and @xmath532 . also , let @xmath533 note that @xmath534 form a partition of @xmath135 , so that @xmath535 which implies that there exists @xmath524 $ ] such that @xmath536 , and we are done .",
    "let @xmath537 $ ] . for all @xmath530 ,",
    "it holds that @xmath538 and @xmath532 .",
    "let @xmath539 and @xmath540 .",
    "write @xmath541 and let @xmath542 so that @xmath543 is a deterministic nnf structured by @xmath22 of size @xmath544 @xcite .",
    "it follows from theorem  [ th : struct ] that @xmath543 has a disjoint rectangle cover of size at most @xmath545 where each rectangle has underlying partition @xmath546 .    since @xmath547",
    ", we have that @xmath548 and along the lines of claim  [ cl : h0-hard ] we obtain @xmath549 and we are done .",
    "the third inequality holds by plugging the convex function @xmath550 in jensen s inequality @xmath551 .",
    "claim  [ cl : h0-hard ] and claim  [ cl : hkp - hard ] imply the statement .",
    "we have related the circuit treewidth of a boolean function with the width of its sdd implementation ( and more generally its width in natural canonical classes of deterministic structured forms ) , and we have incorporated constant width sdds and polynomial size sdds in the panorama of query compilation for union of conjunctive queries with and without negations .    the comparison of theorem  [ th : main - ineq ] and ( * ? ? ? * theorem  4.6 ) reiterates the question about the relative succinctness of deterministic structured forms and sdds @xcite . as beame and liew observe , a natural candidate function for an exponential separation is the _ indirect access storage _",
    "( _ isa _ ) function , which is known to have large obdds but whose small deterministic structured forms deviate substantially from the sdd syntax ( * ? ? ?",
    "* section  6 ) .",
    "however , as we prove in appendix  [ app : isaproof ] , isa has small sdd size , which unfortunately leaves us with no candidates for a separation .",
    "the canonical structured deterministic forms induced by factorized implicants , introduced in section  [ sect : fimpldec ] , deserve in our opinion both a direct investigation in the framework of the knowledge compilation map @xcite , and a thorough comparison with the data structures used in _ factorized databases _ , which are more than just reminiscent of structured deterministic forms @xcite .",
    "the question remains whether bounded circuit treewidth lineages imply bounded obdd width for ucqs with inequalities , as conjectured by jha and suciu @xcite .",
    "another intriguing conjecture is that sdds with or gates of bounded fanin are quasipolynomially simulated by obdds .",
    "the containment of bounded width sdds in polynomial size obdds , discussed in the introduction and obtained in section  [ sect : part1 ] , imply a polynomial simulation of bounded width sdds , which have indeed bounded fanin ors , by obdds .",
    "this research was supported by the fwf austrian science fund ( parameterized compilation , p26200 ) .",
    "10    a.  amarilli , p.  bourhis , and p.  senellart .",
    "provenance circuits for trees and treelike instances . in _ proc .  of icalp 2015 _ ,",
    "pages 5668 .",
    "springer , 2015 .",
    "a.  amarilli , p.  bourhis , and p.  senellart .",
    "tractable lineages on treelike instances : limits and extensions . in _ proc .  of pods 2016",
    "_ , pages 355370 .",
    "acm , 2016 .",
    "p.  beame and v.  liew .",
    "new limits for knowledge compilation and applications to exact model counting . in _ proc .  of uai 2015",
    "_ , pages 131140 .",
    "auai press , 2015 .",
    "s.  bova .",
    "sdds are exponentially more succinct than obdds . in _ proc .  of aaai 2016 _ , pages 929935 .",
    "aaai , 2016 .",
    "s.  bova , f.  capelli , s.  mengel , and f.  slivovsky . on compiling cnfs into structured deterministic dnnfs .",
    "in _ proc .  of sat 2015",
    "_ , pages 199214 .",
    "springer , 2015 .",
    "s.  bova , f.  capelli , s.  mengel , and f.  slivovsky .",
    "knowledge compilation meets communication complexity . in _ proc .  of ijcai 2016 _ , pages 10081014 .",
    "ijcai / aaai , 2016 .",
    "r.  e. bryant .",
    "graph - based algorithms for boolean function manipulation .",
    ", 35(8):677691 , 1986 .",
    "a.  choi and a.  darwiche .",
    "dynamic minimization of sentential decision diagrams . in _ proc .  of aaai 2013_. aaai , 2013 .",
    "n.  n. dalvi and d.  suciu .",
    "the dichotomy of conjunctive queries on probabilistic structures . in _ proc .  of pods 2007",
    "_ , pages 293302 .",
    "acm , 2007 .",
    "n.  n. dalvi and d.  suciu .",
    "efficient query evaluation on probabilistic databases .",
    ", 16(4):523544 , 2007 .",
    "a.  darwiche .",
    "decomposable negation normal form .",
    ", 48(4):608647 , 2001 .    a.  darwiche . on the tractable",
    "counting of theory models and its application to truth maintenance and belief revision .",
    ", 11(1 - 2):1134 , 2001 .",
    "a.  darwiche",
    ". new canonical representation of propositional knowledge bases . in _ proc .  of ijcai 2011",
    "_ , pages 819826 .",
    "ijcai / aaai , 2011 .",
    "a.  darwiche and p.  marquis . a knowledge compilation map .",
    ", 17:229264 , 2002 .    g.  v. den broeck and a.  darwiche . on the role of canonicity in knowledge compilation . in _ proc .  of aaai 2015",
    "_ , pages 16411648 .",
    "aaai , 2015 .",
    "j.  flum and m.  grohe . .",
    "springer , 2010 .",
    "e.  grdel , y.  gurevich , and c.  hirsch .",
    "the complexity of query reliability . in _ proc .  of pods 1998",
    "_ , pages 227234 .",
    "acm , 1998 .",
    "t.  j. green , g.  karvounarakis , and v.  tannen .",
    "provenance semirings . in _ proc .  of pods",
    "2007 _ , pages 3140 .",
    "acm , 2007 .",
    "a.  k. jha and d.  suciu .",
    "knowledge compilation meets database theory : compiling queries to decision diagrams . in _ proc .  of icdt 2011 _ , pages 162173",
    "acm , 2011 .",
    "a.  k. jha and d.  suciu . on the tractability of query compilation and bounded treewidth . in _ proc .  of icdt 2012",
    "_ , pages 249261 .",
    "acm , 2012 .",
    "a.  k. jha and d.  suciu .",
    "knowledge compilation meets database theory : compiling queries to decision diagrams .",
    ", 52(3):403440 , 2013 .",
    "s.  jukna . .",
    "springer , 2012 .",
    "t.  kloks . .",
    "springer , 1994 .",
    "s.  mengel .",
    "parameterized compilation lower bounds for restricted cnf - formulas . in _ proc .  of sat 2016",
    "_ , pages 312 .",
    "springer , 2016 .",
    "d.  olteanu .",
    "factorized databases : a knowledge compilation perspective . , 2016 .",
    "u.  oztok and a.  darwiche . a top - down compiler for sentential decision diagrams . in _ proc .  of ijcai 2015",
    "_ , pages 31413148 .",
    "aaai , 2015 .",
    "k.  pipatsrisawat and a.  darwiche .",
    "new compilation languages based on structured decomposability . in _ proc .  of aaai 2008",
    "_ , pages 517522 .",
    "aaai , 2008 .",
    "t.  pipatsrisawat and a.  darwiche",
    ". a lower bound on the size of decomposable negation normal form . in _ proc .  of aaai 2010_. aaai , 2010 .",
    "i.  razgon .",
    "on obdds for cnfs of bounded treewidth . in _ proc .  of kr 2014_. aaai , 2014",
    "i.  razgon . on the read - once property of branching programs and cnfs of bounded treewidth .",
    ", 75(2):277294 , 2016 .",
    "i.  razgon and j.  petke .",
    "cliquewidth and knowledge compilation . in _ proc .  of sat 2013",
    "_ , pages 335350 .",
    "springer , 2013 .",
    "d.  seese .",
    "the structure of models of decidable monadic theories of graphs .",
    ", 53(2):169195 , 1991 .",
    "d.  suciu , d.  olteanu , r.  christopher , and c.  koch . .",
    "morgan & claypool publishers , 2011 .",
    "i.  wegener . .",
    "siam , 2000 .",
    "let @xmath5 and @xmath12 be positive integers such that @xmath552 .",
    "the _ indirect access storage _ ( in short , _ isa _ ) function on @xmath553 variables @xmath554 also displayed as @xmath555 accepts input @xmath556 also displayed as @xmath557 iff , letting @xmath558 be the number whose binary representation is @xmath559 and @xmath560 be the number whose binary representation is @xmath561 , it holds that @xmath562 .",
    "let @xmath565 be the vtree for variables @xmath566 formed by a right - linear subtree @xmath567 whose left leaves correspond to the variables in @xmath568 and whose ( unique ) right leaf @xmath91 is the root of a left - linear subtree @xmath569 whose ( unique ) left leaf corresponds to @xmath570 and whose right leaves correspond ( in a postorder traversal ) to @xmath571 .",
    "for instance , the vtree @xmath572 is depicted in figure  [ fig : isaproof ] .",
    "we liberally identify the leaves of @xmath573 with their labels ( so that we simply call @xmath119 the leaf of @xmath573 labelled by the variable @xmath119 ) . for @xmath452 $ ]",
    ", we let @xmath574 denote the node in @xmath573 whose left child is @xmath575 ; for @xmath576 $ ] , we let @xmath577 denote the node in @xmath573 whose right child is @xmath578 .",
    "a term on @xmath579 is a conjunction of literals on @xmath579 . and a term containing both literals of a variable is denoted by @xmath67 .",
    "] we call a term on @xmath579 _ small _ if it contains at most @xmath580 distinct variables . note that the number of small terms on @xmath579 is @xmath581 since @xmath582 .",
    "we now construct an sdd @xmath70 computing @xmath563 and respecting @xmath573 , where each @xmath63-gate structured by a node of the form @xmath577 ( @xmath576 $ ] ) conjoins one small term on @xmath579 and an input gate ( namely , a literal on @xmath577 or a constant ) .",
    "as @xmath70 has at most @xmath583 input gates , it follows that the number of @xmath63-gates in @xmath70 structured by nodes of the form @xmath584 ( @xmath576 $ ] ) is @xmath585 moreover , @xmath70 is such that the number of @xmath63-gates structured by nodes of the form @xmath574 ( @xmath452 $ ] ) is @xmath586 since @xmath587 .",
    "it follows immediately that @xmath70 has size polynomial in @xmath4 .",
    "indeed , as each @xmath63-gate in @xmath70 contributes a constant number of @xmath64-gates , @xmath70 contains at most @xmath564 internal gates . also , @xmath70 has at most @xmath583 input gates .",
    "hence @xmath588      the upper part of @xmath70 is isomorphic to an obdd respecting the order @xmath589 and having @xmath590 source gates .",
    "each such source , say @xmath591 , corresponds to the boolean assignment @xmath592 , @xmath452 $ ] , of the variables in @xmath568 and implements the cofactor @xmath593 as an sdd respecting the vtree @xmath569 , as follows .",
    "we start observing that each cofactor in ( [ eq : isacof ] ) is expressible as a sentential decision , respecting the root node of @xmath569 and involving only small terms on @xmath579 ( and literals on @xmath594 ) .",
    "case @xmath598 : in this case , we have to implement @xmath599 , which is equivalent to @xmath600 here @xmath601 corresponds to the term @xmath602 where @xmath603 represents @xmath560 in binary , and @xmath604 , @xmath605 , @xmath606 $ ] .",
    "for all @xmath607 and @xmath608 $ ] we say that _",
    "orbits on @xmath304 _ if @xmath610 represents @xmath611 in binary . if @xmath609 orbits on @xmath304 , we let @xmath609 orbits on @xmath304  denote the term @xmath612 by direct inspection , @xmath599 is equivalent to a sentential decision @xmath613 as in ( [ eq : sdd - def ] ) , namely , @xmath614 where @xmath615 ranges over all pairs such that @xmath609 orbits on @xmath304 .    here",
    ", the interesting @xmath63-gates ( marked with @xmath616 ) are structured by the node @xmath617 in @xmath573 . moreover , the @xmath109 s are small terms as they contain @xmath618 variables by construction .",
    "[ ex : hec ] assume @xmath619 , so that we compute @xmath620 . in this case @xmath621 and @xmath622 .",
    "the following lists the disjuncts corresponding to @xmath623 for @xmath624 ( we use @xmath625 and @xmath626 as shortenings ) : @xmath627    if @xmath615 gives @xmath628 , then the corresponding subdisjunction reduces to one disjunct only ; and , if @xmath615 gives @xmath629 , then the corresponding subdisjunction reduces to two disjuncts only , as the following example illustrates .",
    "case @xmath634 : say that @xmath635 represents @xmath636 .",
    "we implement @xmath637 , which is equivalent to @xmath638 where the notation is as in the previous case ; note that @xmath639 .",
    "an equivalent sentential decision of the form ( [ eq : sdd - def ] ) is obtained by disjoining @xmath640 and the following : @xmath641 where the interesting @xmath63-gates ( marked with @xmath616 ) are structured by the node @xmath617 in @xmath573 . moreover , the @xmath109 s are small terms as they contain @xmath580 variables by construction .          the construction implements each gate @xmath591 by the sentential decision given by claim  [ cl : base ] .",
    "we now claim that the construction can continue recursively by implementing the resulting @xmath109 s as sdds respecting subtrees of the subtree of @xmath573 rooted at @xmath648 .",
    "[ cl : isarec ] let @xmath649 be a small term on @xmath579",
    ". then @xmath649 is equivalent to a sentential decision @xmath596 of the form ( [ eq : sdd - def ] ) , where the @xmath63-gates are structured by some @xmath650 ( @xmath576 $ ] ) and the @xmath109 s are small terms .",
    "let @xmath609 be the assignment of @xmath657 to @xmath658 such that @xmath659 by direct inspection , @xmath649 is equivalent to the sentential decision @xmath613 of the form ( [ eq : sdd - def ] ) @xmath660 where @xmath197 ranges over the assignments of @xmath657 in @xmath658 distinct from @xmath609 ."
  ],
  "abstract_text": [
    "<S> the evaluation of a query over a probabilistic database boils down to computing the probability of a suitable boolean function , the lineage of the query over the database . </S>",
    "<S> the method of query compilation approaches the task in two stages : first , the query lineage is implemented ( compiled ) in a circuit form where probability computation is tractable ; and second , the desired probability is computed over the compiled circuit . </S>",
    "<S> a basic theoretical quest in query compilation is that of identifying pertinent classes of queries whose lineages admit compact representations over increasingly succinct , tractable circuit classes .    fostering previous work by jha and suciu @xcite and petke and razgon @xcite , we focus on queries whose </S>",
    "<S> lineages admit circuit implementations with small treewidth , and investigate their compilability within tame classes of decision diagrams . in perfect analogy with the characterization of bounded circuit pathwidth by bounded obdd width @xcite , we show that a class of boolean functions has bounded circuit treewidth if and only if it has bounded sdd width . </S>",
    "<S> sentential decision diagrams ( sdds ) are central in knowledge compilation , being essentially as tractable as obdds @xcite but exponentially more succinct @xcite . by incorporating constant width sdds and polynomial size sdds , </S>",
    "<S> we refine the panorama of query compilation for unions of conjunctive queries with and without inequalities @xcite . </S>"
  ]
}