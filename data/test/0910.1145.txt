{
  "article_text": [
    "low - density parity - check ( ldpc ) codes have been shown to approach theoretical capacity limits for single link communication channels  @xcite . recently , distributed ldpc for cooperative communications",
    "has attracted much attention .",
    "the work of @xcite first explored the the use of bilayer ldpc codes within the cooperative single source channel ( @xmath2 system ) , where full - duplexing relay is used .",
    "although bilayer ldpc is carefully designed to approach the system capacity  @xcite , the performance is decreased as the capacity gap between the source - to - relay channel and the source - to - destination channel becomes larger . in  @xcite ,",
    "multi - edge type ldpc code has been utilized to address this problem  @xcite .",
    "the works of  @xcite consider more practical issues in the @xmath2 system , such as the use of rayleigh fading channels and half - duplexing relays .",
    "however , the above studies on distributed ldpc codes are all limited to the triangle model , which contains only one source . in this paper",
    ", we investigate a network coding  @xcite based ldpc codes designed for the cooperative uplink system with multi - source and one relay ( @xmath1 system ) as shown in fig .",
    "[ fig1 ] . based on existing methods of distributed ldpc design in the triangle model",
    ", an intuitive thought is that the relay serves the sources in a round - robin fashion , optimizing the distributed ldpc for a single source in each round .",
    "unfortunately , such a direct application is not optimal for the following reasons .    1 .",
    "the check digits produced by the relay in the @xmath3-th , @xmath4 , round are only based on the codeword from the source @xmath5 , which is highly correlated with the original check codes already produced by @xmath5 .",
    "network coded check digits enable the joint decoding of all sources data and thus each source can obtain more extrinsic mutual information from the other sources .",
    "the code profile optimization executed by the relay aims only at approaching the capacity for the single source , which leads to a sub - optimal outcome for a multi - source system in terms of network capacity .",
    "we note that  @xcite has studied the network coded ldpc in a multi - source system with fading channels .",
    "but the code design in  @xcite is not optimal .",
    "@xcite also proposes a joint bilayer ldpc scheme in the @xmath1 system .",
    "however , this scheme is constrained by the drawbacks of bilayer ldpc . so it can not deal with the problem where the capacity gap between source - to - relay channel and source - to - destination is large .",
    "also ,  @xcite only considers a scenario where all channel capacities in the model are equal . in this paper , we propose a network coding based multi - edge type ldpc , which we refer to as ncmet - ldpc , for the @xmath1 model which addresses these issues . in our analysis of ncmet - ldpc",
    "we utilize extrinsic mutual information ( emi ) transfer , rather than density evolution ( de ) used in  @xcite , which aids in understanding the code design issues better . through the exit chart",
    ", we see that the network coded parity check digits produced by relay provide more emi for each source , relative to a separate round - robbin scheme .",
    "consider a gaussian relay system with @xmath0-sources , @xmath6-relay and @xmath6 destination as shown in fig .",
    "[ fig1 ] , where sources @xmath7 transmit information to the destination @xmath8 simultaneously with the help of a full - duplex relay @xmath9 .",
    "we assume all sources are randomly distributed around the relay .",
    "suppose that the @xmath3-th source , @xmath5 , transmits its information in the frequency band @xmath10 , and @xmath9 can receive and transmit at @xmath11 .",
    "all the frequency bands are assumed to be orthogonal . with these constraints",
    "the multi - source system can be viewed as @xmath0 independent parallel @xmath2 systems . within each of these channels , a bilayer ldpc scheme  @xcite",
    "can be utilized to approach the @xmath2 system capacity  @xcite .",
    "let us briefly review the achievable rate and code design in the @xmath2 system  @xcite . without loss of generality ,",
    "we focus firstly on a specific @xmath2 system .",
    "this is formed by selecting a specific value of @xmath3 , and constructing a model composed of @xmath12 and @xmath8 , where @xmath13 is the part of @xmath9 operating at @xmath10 . in fig .",
    "[ fig2 ] , @xmath14 is the signal transmitted by @xmath5 , which has the average power @xmath15 , and @xmath16 is the signal transmitted by @xmath13 , which has the average power @xmath17 . the binning scheme is used to achieve the capacity in a gaussian degraded relay channel  @xcite . in this binning scheme , @xmath5 divides its total power @xmath15 into a fraction @xmath18 for the new codeword @xmath19 , and a fraction @xmath20 for the bin index @xmath21 of the previous codeword @xmath22 .",
    "so in the @xmath23-th time slot , @xmath14 is the superposition of @xmath19 and @xmath21 , which will be received by both @xmath13 and @xmath8 .",
    "since @xmath13 has successfully decoded @xmath22 in the previous time slot , @xmath24 will be successfully decoded at the relay with a rate no more than @xmath25 meanwhile , @xmath13 is transmitting @xmath26 to @xmath8 .",
    "thus , @xmath8 receives the interferential signal composed by @xmath14 and @xmath16 in the frequency band @xmath10 . by successive interference cancellation , @xmath8 firstly treats @xmath14 as noise so as to extract the bin index @xmath21 with a rate no more than @xmath27 then combining with @xmath21 , the decoding of @xmath22 at @xmath8 will be successful with a rate no more than @xmath28 combining the above three equations , we get the overall rate for the gaussian relay channel working at @xmath10 as @xmath29 so to maximize @xmath30 , we let @xmath31 by adapting power allocation @xmath32 .    : @xmath14 is power constrained to @xmath15 ; @xmath16 is power constrained to @xmath17.,width=336 ]    for the practical code design , we can utilize the bilayer ldpc scheme for each @xmath33 to approach @xmath34 and @xmath35  @xcite .",
    "for example , the code structure is divided into the lower and the upper graphs and consists of @xmath36 and @xmath37 check nodes , respectively .",
    "both type of check nodes are connected to the same @xmath38 variable nodes . according to  @xcite , in the design of such codes",
    ", one should firstly determine the optimal ldpc code corresponding to the lower graph to achieve rate @xmath34 , and then search over the whole bilayer graph in order to find a good ldpc code that approaches the rate @xmath35 .",
    "so in the multi - source case , a straightforward technique of practical code design is to perform bilayer ldpc individually to each source .",
    "as previously mentioned , such individual processing does not benefit from any joint processing gain at the relay . in the following section , we focus on the network coded multi - edge type ldpc code for the multi - source system .",
    "the principle of multi - edge type ldpc is to introduce more than one edge type to the tanner graph  @xcite , where the graph ensemble is specified through two polynomials , one associated to variable nodes and the other associated to constraint nodes .",
    "the two polynomials are given by @xmath39 where @xmath40 is a multi - edge degree and @xmath41 denotes variables .",
    "similarly , @xmath42 is a received degree , and @xmath43 denotes variables corresponding to received distributions .",
    "we use @xmath44 to denote @xmath45 and @xmath46 to denote @xmath47 . for more details about multi - edge type ldpc codes one can refer to  @xcite .          in this subsection",
    ", we propose a novel multi - edge type ldpc scheme in the @xmath1 system . in the new coding scheme ,",
    "we do not change the power allocation of each transmitter ( i.e network capacity is not altered ) , but propose a new coding scheme to approach the network capacity .",
    "[ fig4 ] compares the proposed scheme with the conventional bilayer ldpc code . in the conventional scheme ,",
    "the additional @xmath37 check digits at @xmath13 are only produced from @xmath5 s frame and transmitted at @xmath10 .",
    "however , in the proposed scheme , the extra @xmath37 bits of information are co - produced from all the sources frames and randomly distributed in all the frequency bands . @xmath9",
    "jointly processes all sources information and produces @xmath48 parity check digits , which can be seen as a super parity check block .",
    "the tanner graph of the multi - edge type ldpc is shown as fig .  [ fig5 ] , where we represent the edge types as @xmath49 with different subscripts .",
    "the edge of the lower graph of @xmath5 is denoted as @xmath50 and the edge of the upper graph is denoted as @xmath51 .",
    "we also assume the frames from all the sources have the same length , i.e. , @xmath52 .",
    "the multi - edge type ldpc code design for an @xmath1 system begins with optimizing the lower tanner graph in fig .",
    "[ fig5 ] at rate @xmath53 for @xmath54 , respectively , which follows the conventional methodology of single link ldpc codes .",
    "so the lower graph ensemble of the multi - edge type ldpc codes for @xmath5 is represented by @xmath55,[d_{1,m}]}x_{1,m}^{d_{1,m } } , \\\\\\mu_m(\\textbf{x})&=\\underset{d_{1,m}=1}{\\overset{d_{c1,m}}{\\boldsymbol{\\sum}}}\\mu_{[d_{1,m}]}x_{1,m}^{d_{1,m } } , \\end{split}\\ ] ] where @xmath56 $ ] is the vector @xmath57 , and @xmath58 $ ] is the vector @xmath59 of ( [ equ:5 ] ) . for vector @xmath57 ,",
    "all variable nodes in the codeword are transmitted through the source - to - relay channel @xmath60 at rate @xmath34 and there are no punctured variables @xmath61 in the codeword .",
    "vector @xmath59 contains only one element since there is only one edge type .",
    "@xmath62 is denoted as the degree of variable nodes and check nodes with the maximum value @xmath63 and @xmath64 , respectively .",
    "the quantity @xmath65 is the the number of variable nodes of type @xmath66 and @xmath67 is the number of check nodes of the type @xmath59 in the graph .",
    "the code rate of the lower graph ensemble for @xmath5 is @xmath68}.\\ ] ] so the sum of code rate for the lower graph ensembles for all the sources is @xmath69}.\\ ] ]    in the next step , we design the overall graph considering the relay jointly processing all of the sources information .",
    "relay @xmath9 will transmit additional @xmath48 parity check digits to @xmath8 within the relay - to - destination channel capacity @xmath70 , in which @xmath71 bits are allocated to @xmath5 .",
    "so the variable and check nodes polynomials for all sources @xmath5 in the overall graph can be written as @xmath72,[d_{1,m},d_{2,m}]}x_{1,m}^{d_{1,m}}x_{2,m}^{d_{2,m}}\\quad\\:\\ ] ] @xmath73}x_{1,m}^{d_{1,m}}+ \\underset{d_{2,m}=1}{\\overset{d_{c2,m}}{\\boldsymbol\\sum}}\\mu_{[0,d_{2,1},\\cdots , d_{2,m}]}x_{2,m}^{d_{2,m } } .\\ ] ] these relations mean that for the overall graph ensemble , all variable nodes in the codeword are transmitted through the source - to - destination channel @xmath60 at rate @xmath35 , and there are no punctured variables @xmath61 .",
    "vector @xmath74 $ ] in ( [ equ:9 ] ) represents the number of the sockets of the two edge types @xmath50 and @xmath51 in a variable node with @xmath62 and @xmath75 respectively .",
    "vector @xmath76 $ ] in ( [ equ:9 ] ) represents the number of the sockets of the edge type @xmath50 in a check node of the lower graph with @xmath62 .",
    "since the check nodes in the lower graph are only connected to @xmath50 , the number of the sockets of other edge types is all zero .",
    "vector @xmath77 $ ] in the second equation of ( [ equ:9 ] ) represents the number of the sockets of the edge types @xmath78 in a check node of the upper graph with @xmath79 .",
    "since the check nodes in the upper graph are not connected to @xmath50 , the number of the sockets of this edge type is zero .",
    "note that for @xmath5 we have @xmath80}- \\underset{d_{2,m}=1}{\\overset{d_{c2,m}}{\\boldsymbol\\sum}}\\:\\:\\underset{\\sim d_{2,m}}{\\boldsymbol\\sum}\\mu_{[0,d_{2,1},\\cdots , d_{2,m}]},\\ ] ] where @xmath81 since the @xmath82 parity check digits are shared by @xmath0 types of edges , their contribution to @xmath5 is @xmath83}d_{2,m}}{\\boldsymbol\\sum_{l=1}^{m}d_{2,l}}.\\ ] ] then we get @xmath84}-r_1^m.\\ ] ] so the code rate of the overall graph ensemble can be computed as follows .",
    "@xmath85}+r_1^m\\right).\\ ] ]    we optimize the whole system by regarding all the sources frames as a super block , which accesses the relay with code rate @xmath86 for the lower graph , and accesses the destination with code rate @xmath87 for the overall graph .",
    "besides ( [ equ:7 ] ) , ( [ equ:12 ] ) and ( [ equ:13 ] ) , there are several constraints that should be satisfied for each @xmath5 as follows ; @xmath88,[d_{1,m}]}=\\underset{d_{2,m=0}}{\\overset{d_{v2,m}}{\\boldsymbol\\sum}}v_{[0,1],[d_{1,m},d_{2,m}]},\\\\&\\mu_{[d_{1,m}]}=\\mu_{[d_{1,m},0,\\cdots,0 ] } \\\\&\\underset{d_{1,m=1}}{\\overset{d_{c1,m}}{\\boldsymbol\\sum}}\\mu_{[d_{1,m}]}d_{1,m}=\\underset{d_{1,m=1}}{\\overset{d_{v1,m}}{\\boldsymbol\\sum}}v_{[0,1],[d_{1,m}]}d_{1,m } \\\\&\\underset{d_{2,m}=1}{\\overset{d_{c2,m}}{\\boldsymbol\\sum}}\\:\\:\\underset{\\sim d_{2,m}}{\\boldsymbol\\sum}\\mu_{[0,d_{2,1},\\cdots , d_{2,m}]}d_{2,m}=\\\\&\\qquad\\qquad\\qquad\\qquad \\underset{d_{1,m=1}}{\\overset{d_{v1,m}}{\\boldsymbol\\sum}}\\:\\:\\underset{d_{2,m=0}}{\\overset{d_{v2,m}}{\\boldsymbol\\sum}}v_{[0,1],[d_{1,m},d_{2,m}]}d_{2,m}. \\end{split}\\ ] ] to deduce the average extrinsic mutual information of each edge type , we characterize the code ensemble of @xmath5 by the degree distribution @xmath89}^{{i , m}}$ ] , for @xmath90 , @xmath91}^{{i , m}}=\\frac{v_{[0,1],[d_{1,m},d_{2,m}]}d_{i , m}}{\\boldsymbol\\sum_{d_{1,l=1}}^{d_{v1,m } } \\boldsymbol\\sum_{d_{2,l=0}}^{d_{v2,m}}v_{[0,1],[d_{1,l},d_{2,l}]}d_{1,l}}.\\ ] ] this defines the percentage of @xmath92 type edges connected to the variable nodes with @xmath62 edges in @xmath50 , and @xmath75 edges in @xmath51 .",
    "we also define another two types of degree distribution .",
    "one is @xmath93}^{1,m}$ ] , which denotes the percentage of @xmath50 type edges connected to the check nodes in the lower graph with @xmath62 edges , i.e. , @xmath94}^{1,m}=\\frac{\\mu_{[d_{1,m}]}d_{1,m}}{\\boldsymbol\\sum_{d_{1,l=1}}^{d_{c1,m}}\\mu_{[d_{1,l}]}d_{1,l}},\\ ] ] and the other is @xmath95}^{2,m}$ ] , which denotes the percentage of @xmath51 type edges connected to the check nodes with the edge vector @xmath77 $ ] , i.e. , @xmath96}^{2,m}=\\frac{\\mu_{[0,d_{2,1},\\cdots , d_{2,m}]}d_{2,m}}{\\boldsymbol\\sum_{d_{2,l}=0}^{d_{c2,m } } \\boldsymbol\\sum_{\\sim d_{2,l}}\\mu_{[0,d_{1},\\cdots , d_{m}]}d_{2,l}}.\\ ] ]",
    "in  @xcite , density evolution ( de ) is applied to the bilayer ldpc code profile optimization . due to the fixed degree of the check nodes in both the lower graph and the upper graphs ,",
    "the complexity of de is tolerable .",
    "however , the fixed degree deteriorates the system performance as mentioned in the introduction .",
    "so in the optimization of the multi - edge type ldpc code , we exploit the extrinsic information transfer ( exit ) functions  @xcite to reduce the code searching complexity .",
    "this will likely lead to better code profiles by canceling the constraints on the check nodes degree as in bilayer ldpc code .",
    "we denote the variable nodes set associated with the codeword bits of @xmath5 as @xmath97 , and the check nodes set associated with the parity check digits of @xmath5 from the lower graph as @xmath98 .",
    "the shared check nodes set in the upper graph is denoted as @xmath99 . since @xmath97 is connect to two edge types , i.e. , @xmath98 and @xmath99 , there are four types of mutual information ( mi ) defined as follows  @xcite .",
    "@xmath100 : the mi between the message sent from @xmath97 to @xmath98 and the associated codeword bit , on each edge in the edge type @xmath50 connecting @xmath97 to @xmath98 .",
    "@xmath101 : the mi between the message sent from @xmath97 to @xmath99 and the associated codeword bit , on each edge in the edge type @xmath51 connecting @xmath97 to @xmath99 .",
    "@xmath102 : the mi between the message sent from @xmath98 to @xmath97 and the associated codeword bit , on each edge in the edge type @xmath50 connecting @xmath98 to @xmath97 .",
    "@xmath103 : the mi between the message sent from @xmath99 to @xmath97 and the associated codeword bit , on each edge in the edge type @xmath51 connecting @xmath99 to @xmath97 .",
    "note that the extrinsic mi on an edge connecting @xmath97 to @xmath104 , at the output of the variable node , is the a - priori mi for @xmath105 , i.e. , @xmath106 .",
    "similarly , the extrinsic mi on an edge connecting @xmath107 to @xmath97 , at the output of the check node , is the a - priori mi for @xmath97 , i.e. , @xmath108 .",
    "then we have the iterative process as follows .",
    "* @xmath109 variable nodes to check nodes update . *",
    "the mean of the extrinsic mi on an edge type @xmath50 connecting @xmath97 to @xmath98 , at the output of the variable node in the @xmath110-th iteration is @xmath111 ^ 2+\\right.\\\\&\\left.d_{2,m}\\left[j^{-1}(i_{av}^{(l)}(2,m))\\right]^2+\\left[j^{-1}(i_{ch}(m))\\right]^2\\right ) \\lambda_{[d_{1,m},d_{2,m}]}^{{1,m } } \\end{split}\\ ] ] also , the mean of the extrinsic mi on an edge of @xmath51 connecting @xmath97 to @xmath99 , at the output of the variable node in the @xmath110-th iteration is @xmath112 ^ 2+\\right.\\\\&\\left.d_{1,m}\\left[j^{-1}(i_{av}^{(l)}(1,m))\\right]^2+\\left[j^{-1}(i_{ch}(m))\\right]^2\\right ) \\lambda_{[d_{1,m},d_{2,m}]}^{{2,m } } \\end{split}\\ ] ] we can now get the mi in the @xmath110-th iteration as @xmath113 and @xmath114 .",
    "* @xmath115 check nodes to variable nodes update . *",
    "the update from check node to variable nodes is more complicated .",
    "we give the approximation according to  @xcite .",
    "the extrinsic mi on an edge type @xmath50 connecting @xmath98 to @xmath97 , at the output of the check node in the @xmath110-th iteration is @xmath116 ^ 2\\rho_{[d_{1,m}]}^{1,m}}\\right ) \\end{split}\\ ] ] the extrinsic mi on an edge type @xmath51 connecting @xmath99 to @xmath97 at the output of the check node in the @xmath110-th iteration is more complicated as more than one source participates in the generation of @xmath99 .",
    "we have @xmath117 ^ 2+\\right.}\\right .",
    "\\\\&\\qquad\\left.\\overline{\\underset{m'\\neq m}{\\underset{m'=1}{\\overset{m}{\\boldsymbol\\sum}}}d_{2,l}\\left[j^{-1}(1-i_{ac}^{(l)}(2,m'))\\right]^2\\bigg)\\rho_{[0,d_{2,1},\\cdots , d_{2,m}]}^{2,m}}\\right ) .",
    "\\end{split}\\ ] ] in each iteration process , we make @xmath118 and @xmath119 for @xmath90 .",
    "@xmath120 is determined according to the snr of the @xmath3-th source - to - destination channel . at the end of the iteration ,",
    "the mi between the @xmath97 and the associated codeword is @xmath121 ^ 2+\\right.}\\right.\\\\&\\left.\\overline{\\left.d_{2,m}\\left[j^{-1}(i_{av}^{(l)}(2,m))\\right]^2+\\left[j^{-1}(i_{ch}(m))\\right]^2\\right ) \\underset{i=1}{\\overset{2}{\\boldsymbol\\sum}}\\lambda_{[d_{1,m},d_{2,m}]}^{m}}\\right ) \\end{split}\\ ] ] where @xmath122}^{{m}}=\\frac{v_{[0,1],[d_{1,m},d_{2,m}]}(d_{1,m}+d_{2,m})}{\\boldsymbol\\sum_{d_{1,l=1}}^{d_{v1,m } } \\boldsymbol\\sum_{d_{2,l=0}}^{d_{v2,m}}v_{[0,1],[d_{1,l},d_{2,l}]}(d_{1,l}+d_{2,l})}.\\ ] ]    according to the design of bilayer ldpc code , we first fix the lower graph codes of all sources , choosing the optimal point - to - point ldpc code to approach capacity @xmath34",
    ". then we optimize the overall graph to approach the capacity of the whole system .",
    "the code optimization involves finding @xmath0 variable node degree distributions , i.e. , @xmath123,[d_{1,m},d_{2,m}]}$ ] for @xmath5 and a check node degree distribution @xmath124}$ ] .",
    "the optimization problem is concluded as minimizing the snr of the whole system , which is a dual problem of maximizing the system threshold .",
    "we can therefore write @xmath125",
    "we choose the @xmath126-sources case to illustrate the design .",
    "the first source has the following capacities : @xmath127 and @xmath128 .",
    "the second source has the following capacities : @xmath129 and @xmath130 . applying the proposed method",
    ", we get the code profile shown in table  [ tab:1 ] .",
    "note that @xmath131 and @xmath132 in table  [ tab:1 ] are the thresholds for @xmath133 and @xmath134 , respectively .",
    "also note that the threshold deduced by exit is always larger than that deduced by de , which has been proved by  @xcite .",
    "so @xmath131 and @xmath132 in the table  [ tab:1 ] are larger than the exact values , which are searched by criterion  ( [ equ:25 ] ) .",
    "+ @xmath123[d_{1,1},d_{2,1}]}$ ] & @xmath135 & @xmath136 & @xmath123[d_{1,2},d_{2,2}]}$ ] & @xmath137 & @xmath138 + @xmath139 & @xmath126 & @xmath140 & @xmath141 & @xmath126 & @xmath140 + @xmath142 & @xmath126 & @xmath6 & @xmath143 & @xmath126 & @xmath6 + @xmath144 & @xmath126 & @xmath145 & @xmath146 & @xmath126 & @xmath126 + @xmath147 & @xmath148 & @xmath140 & @xmath149 & @xmath148 & @xmath140 + @xmath150 & @xmath148 & @xmath148 & @xmath151 & @xmath148 & @xmath6 + & & & @xmath152 & @xmath148 & @xmath126 + & & & @xmath153 & @xmath148 & @xmath154 + @xmath155 & @xmath156 & @xmath140 & @xmath157 & @xmath156 & @xmath140 + @xmath158 & @xmath156 & @xmath145 & @xmath159 & @xmath156 & @xmath126 + @xmath160 & @xmath156 & @xmath161 & & & + @xmath162 & @xmath145 & @xmath140 & @xmath163 & @xmath145 & @xmath140 + @xmath164 & @xmath145 & @xmath126 & @xmath165 & @xmath145 & @xmath145 + @xmath166 & @xmath167 & @xmath148 & @xmath168 & @xmath167 & @xmath140 + @xmath169 & @xmath167 & @xmath145 & @xmath170 & @xmath167 & @xmath6 + & & & @xmath171 & @xmath167 & @xmath148 +   + & @xmath135 & & @xmath137 + & @xmath172 & & @xmath173 +   + & @xmath136 & & @xmath138 + & @xmath148 & & @xmath148 +   + & + & +    first of all , we determine the distributions of @xmath135 and @xmath137 in the lower graphs for @xmath174 and @xmath175 to approach the rate @xmath133 and @xmath134 , respectively .",
    "they are designed as the single link ldpc codes and can be directly obtained from  @xcite .",
    "our main task is to find out the optimal distribution of @xmath136 and @xmath138 , and the corresponding @xmath123[d_{1,1},d_{2,1}]}$ ] , @xmath123[d_{1,2},d_{2,2}]}$ ] and @xmath176}$ ] . by adopting the searching criterion of ( [ equ:25 ] ) and exit curves fitting , we get the three elements with the thresholds @xmath177 and @xmath178 for @xmath174 and @xmath175 , respectively",
    ". the variable node distributions of the two sources , @xmath123[d_{1,1},d_{2,1}]}$ ] , @xmath123[d_{1,2},d_{2,2}]}$ ] , and corresponding degrees are shown in table  [ tab:1 ] .",
    "the check node distribution in the upper graph at the relay is @xmath179}$ ] , which has only one distribution as @xmath179}=r_-^1+r_-^2=0.4 $ ] .",
    "each check node of the relay has the degree @xmath156 , half of which are allocated to @xmath174 and the other half are allocated to @xmath175 .",
    "this is reasonable since @xmath180 .",
    "[ fig6 ] shows the exit charts for the @xmath181 edge types at the system threshold .",
    "[ fig7 ] and fig .",
    "[ fig8 ] show the exit chart at @xmath182 and @xmath183 , respectively .",
    "note that in the three figures , we adopt the same value of the summation of @xmath131 and @xmath132 .",
    "however , the system threshold in fig .",
    "[ fig7 ] is larger than that of fig .",
    "[ fig6 ] , and the system threshold in fig .",
    "[ fig8 ] is smaller than that of fig .",
    "so we can see that the exit curves in fig .",
    "[ fig7 ] intersect at a value smaller than @xmath6 , which means that the iterative decoding at destination will not converge eventually .",
    "the exit curves in fig .",
    "[ fig8 ] as well as fig .",
    "[ fig6 ] intersect at @xmath6 , which means the decoding at destination will succeed .",
    "finally , we investigate the separate ldpc code without network coding . in this case",
    ", each source is only connected to half of the check nodes at the relay , and each check node at relay only contains one edge type , either @xmath184 or @xmath185 . on the other hand ,",
    "we keep the variable node distributions of each source unchanged .",
    "[ fig9 ] shows the exit curves of the two edge types connected to @xmath174 .",
    "obviously , both edge types can not converge at @xmath6 .",
    "so we conclude from this case that the separate ldpc code obtains less extrinsic mutual information from the check nodes at relay than the proposed coding scheme .     with rate @xmath186 and @xmath178 with rate @xmath187.,width=336 ]     @xmath188.,width=336 ]",
    "@xmath189.,width=336 ]     with rate @xmath186 and @xmath178 with rate @xmath187.,width=364 ]",
    "in this paper , we investigate a network coded ldpc design in the multi - source scenario .",
    "we apply the multi - edge ldpc to the system and execute the exit analysis .",
    "we conclude that each source achieves more extrinsic mutual information due to joint processing at the relay .",
    "therefore , our scheme delivers better performance compared to traditional schemes that do not utilize joint processing at the relay .                  c.  li , g.  yue , m.  a.  khojastepour , x.  wang , and m.  madihian , `` ldpc - coded cooperative relay systems : performance analysis and code design , '' _ ieee trans .",
    "_ , vol .",
    "56 , no .",
    "3 , pp .  485 - 496 , mar .",
    "2008 .",
    "x.  bao , j.  li , `` adaptive network coded cooperation ( ancc ) for wireless relay networks : matching code - on - graph with network - on - graph , '' _ ieee trans .",
    "wireless commun .",
    "_ , vol .  7 , no .  2 , pp .  574 - 583 , feb ."
  ],
  "abstract_text": [
    "<S> in this paper we investigate a multi - source ldpc scheme for a gaussian relay system , where @xmath0 sources communicate with the destination under the help of a single relay ( @xmath1 system ) . since various distributed ldpc schemes in the cooperative single - source system , e.g. bilayer ldpc  @xcite and bilayer multi - edge type ldpc ( bmet - ldpc )  @xcite , </S>",
    "<S> have been designed to approach the shannon limit , these schemes can be applied to the @xmath1 system by the relay serving each source in a round - robin fashion . </S>",
    "<S> however , such a direct application is not optimal due to the lack of potential joint processing gain . in this paper , we propose a network coded multi - edge type ldpc ( ncmet - ldpc ) scheme for the multi - source scenario . through an exit analysis </S>",
    "<S> , we conclude that the ncmet - ldpc scheme achieves higher extrinsic mutual information , relative to a separate application of bmet - ldpc to each source . </S>",
    "<S> our new ncmet - ldpc scheme thus achieves a higher threshold relative to existing schemes .    </S>",
    "<S> multi - source ldpc , network coding , network capacity , extrinsic mutual information . </S>"
  ]
}