{
  "article_text": [
    "in this paper we continue the work in @xcite where we began a study of formal definitions of algorithms .",
    "( knowledge of that paper is not necessary for this paper . )",
    "the previous paper generated some interest in the community .",
    "yuri i. manin looked at the structure of programs and algorithms from the operad / prop point of view @xcite ( chapter 9 ) .",
    "see also @xcite where it is discussed in context of renormalization .",
    "the work is currently being extended from primitive recursive functions to all recursive functions in @xcite .",
    "ximo diaz boils has looked at these constructions in relations to earlier papers such as @xcite .",
    "the paper has also been criticized in @xcite ( which will be discussed below . )",
    "figure [ firstpic ] motivates the formal definition of algorithms .",
    "+    on the bottom is the set of computable functions .",
    "two examples of computable functions are given : the sorting function and the find max function .",
    "on top of the diagram is the set of programs . to each computable function on the bottom ,",
    "a cone shows the corresponding set of programs that implement that function .",
    "four such programs that implement the sorting function have been highlighted : @xmath1 , @xmath2 , @xmath3 and @xmath4 .",
    "one can think of @xmath1 and @xmath2 as two implementations of the mergesort algorithm written by ann and bob respectively .",
    "these two programs are obviously similar but they are not the same . in the same way , @xmath3 and @xmath4 are two different implementations of the quicksort algorithm .",
    "these two programs are similar but not the same .",
    "we shall discuss in what sense they are `` similar . ''",
    "nevertheless programs that implement the mergesort algorithm are different than programs that implement the quicksort algorithm .",
    "this leads us to having algorithms as the middle level of figure [ firstpic ] .",
    "an algorithm is to be thought of as an equivalence class of programs that implement the same function .",
    "the mergesort algorithm is the set of all programs that implement mergesort .",
    "similarly , the quicksort algorithm is the set of all programs that implement quicksort .",
    "the set of all programs are partitioned into equivalence classes and each equivalence class corresponds to an algorithm .",
    "this gives a surjective map from the set of programs to the set of algorithms .",
    "one can similarly partition the set of algorithms into equivalence classes .",
    "two algorithms are deemed equivalent if they perform the same computable function .",
    "this gives a surjective function from the set of algorithms to the set of programs .",
    "this paper is employing the fact that equivalence classes of programs have more manageable structure than the original set of programs .",
    "we will find that the set of programs does not have much structure at all .",
    "in contrast , types of algorithms have better structure and the set of computable functions have a very strict structure .",
    "the obvious question is , what are the equivalence relation that say when two programs are `` similar ? '' in @xcite a single tentative answer was given to this question .",
    "certain relations were described that seem universally agreeable . using these equivalence relations , the set of algorithms have the structure of a category ( composition ) with a product ( bracket ) and a natural number object ( a categorical way of describing recursion . )",
    "furthermore , we showed that with these equivalence relations , the set of algorithms has universal properties .",
    "see @xcite for more details .",
    "some of the relations that describe when two programs are `` similar '' were :    * one program might perform @xmath5 first and then perform an unrelated @xmath6 after .",
    "the other program might perform the two unrelated processes in the opposite order .",
    "* one program will perform a certain process in a loop @xmath7 times and the other program will `` unwind the loop '' and perform it @xmath8 times and then perform the the process again outside the loop .",
    "* one program might perform two unrelated processes in one loop , and the other program might perform each of these two processes in its own loops .    a criticism of @xcite was given in @xcite . in that paper , the subjectivity of the question as to when two programs are considered equivalent was emphasized . while writing @xcite , we were aware that the answer to this question is a subjective decision ( hence the word `` towards '' in the title ) , we nevertheless described the structure of algorithms in that particular case . in this paper",
    "we answer that criticism by looking at the _ many _ different sets of equivalence relations that one can have . it is shown that with every set of equivalence relations we get a certain structure .",
    "the main point of this paper is to explore the set of intermediate structures between programs and computable functions using the techniques of galois theory . in galois theory , intermediate fields",
    "are studied by looking at automorphism of fields . here",
    "we study intermediate algorithmic structures by looking at automorphism of programs .",
    "a short one paragraph review of galois theory is in order . given a polynomial with coefficients in a field @xmath9 , we can ask if there is a solution to the polynomial in an extension field @xmath10 .",
    "one examines the group of automorphisms of @xmath10 that fix @xmath9 , i.e. , automorphisms @xmath11 such that for all @xmath12 we have @xmath13 .",
    "this group is denoted @xmath14 . for every normal subgroup @xmath15 of @xmath14",
    "there is an intermediate field @xmath16 . and",
    "similarly for every intermediate field @xmath17 there is a subgroup @xmath18 of @xmath14 .",
    "this correspondence is the essence of the fundamental theorem of galois theory which says that the lattice of subgroups of @xmath14 is isomorphic to the duel lattice of intermediate fields between @xmath9 and @xmath10 .",
    "the properties of @xmath14 mimic the properties of the fields .",
    "the group is `` solvable '' if and only if the polynomial is `` solvable . ''    in order to understand intermediate algorithmic structures we study automorphisms of programs .",
    "consider all automorphisms of programs that respect functionality .",
    "such automorphisms can be thought of as ways of swapping programs for other programs that perform the same function .",
    "a subgroup of the group of all automorphisms is going to correspond to an intermediate structure . and in the other direction , an intermediate algorithmic structure will correspond to a subgroup .",
    "this will be the essence of the fundamental theorem of galois theory of algorithms .",
    "this theorem formalizes the intuitive notion that two programs can be switched for one another if they are considered to be the same algorithm . if you consider every program to be its own algorithm than there is no swapping different programs .",
    "the other extreme is if you consider two programs to be equivalent when they perform the same function . in this case",
    "you can swap many programs for other programs .",
    "we study all the intermediate possibilities .",
    "notice that the vertical arrows in diagram ( [ galofalg ] ) go the opposite direction than the arrows in diagram ( [ classicalgal ] ) and are surjections rather than injections .",
    "in fact the proofs in this paper are similar to the ones in classical galois theory as long as you stand on your head .",
    "we resist the urge to call this work `` co - galois theory . ''",
    "all this is somewhat abstract .",
    "what type of programs are we talking about ?",
    "what type of algorithmic structures are we dealing with ? how will our descriptions be specified ?",
    "rather than choosing one programming language to the exclusion of others , we look at a language of descriptions of primitive recursive functions .",
    "we choose this language because of its beauty , its simplicity of presentation , and the fact that most readers are familiar with this language .",
    "the language of descriptions of primitive recursive functions has only three operations : composition , bracket , and recursion .",
    "we are limiting ourselves to the set of primitive recursive functions as opposed to all computable functions for ease . by limiting ourselves",
    ", we are going to get a proper subset of all algorithms .",
    "even though we are , for the present time , restricting ourselves , we feel that the results obtained are interesting in their own right .",
    "there is an ongoing project to extend this work to all recursive functions @xcite .",
    "another way of looking at this work is from the homotopy point of view .",
    "we can think of the set of programs as a graph enriched over groupoids . in detail ,",
    "the 0-cells are the powers of the natural number ( types ) , the 1-cells are the programs from a power of natural numbers to a power of natural numbers .",
    "there is a 2-cell from one program two another program if and only if they are `` essentially the same '' .",
    "that is the 2-cells are the equivalence relations . by the symmetry of the equivalence relations , the 2-cells are a groupoid .",
    "now we take the quotient , or fraction category where we identify the programs at the end of the equivalences .",
    "this is the graph or category of algorithms .",
    "from this perspective we can promote the extremely sexy mantra :    `` algorithms are the homotopy category of programs . ''",
    "this is a step towards    `` semantics is the homotopy category of syntax . ''",
    "much work remains to be done .",
    "another way of viewing this work is about composition .",
    "compositionality has for many decades been recognized as one of the most valuable tools of software engineering .",
    "there are different levels of abstractions that we use when we teach computation or work in building computers , networks , and search engines .",
    "there are programs , algorithms , and functions .",
    "not all levels of abstraction of computation admit useful structure .",
    "if we take programs to be the finest level then we may find it hard to compose programs suitably .",
    "but if we then pass to the abstract functions they compute , again we run into trouble . in between these two extremes",
    "extreme concreteness and extreme abstractness there can be many levels of abstraction that admit useful composition operations unavailable at either extreme .",
    "it is our goal here to study the many different levels of algorithms and to understand the concomitant different possibilities of composition .",
    "we feel that this work can have great potential value for software engineering .",
    "yet another way of viewing this work is an application and a variation of some ideas from universal algebra and model theory . in the literature",
    ", there is some discussion of galois theory for arbitrary universal algebraic structures ( @xcite section ii.6 ) and and model - theoretic structures ( @xcite . ) in broad philosophical terms , following the work of galois and klein s _ erlangen _ program , an object can be defined by looking at its symmetries .",
    "primitive recursive programs are here considered as a universal algebraic structure where the generators of the structure are the initial functions while composition , bracket and recursion are the operations .",
    "this work examines the symmetries of such programs and types of structures that can be defined from those symmetries .",
    "section 2 reviews primitive recursive programs and the basic structure that they have . in section 3 we define an algorithmic universe as the minimal structure that a set of algorithms can have . many examples are given .",
    "the main theorems in this paper are found in section 4 where we prove the fundamental theorem of galois theory .",
    "we conclude with a list of possible ways that this work might progress in the future .",
    "* acknowledgment*. i thank ximo diaz boils , leon ehrenpreis ( of blessed memory ) , roman kossak , florian lengyel , dustin mulcahey , vaughan pratt , and lou thrall for helpful discussions .",
    "consider the structure of all descriptions of primitive recursive functions . throughout this paper",
    "we shall use the words `` description '' and `` program '' interchangeably .",
    "the descriptions shall form a graph denoted @xmath19 .",
    "the objects of the graph are powers of natural numbers @xmath20 and the morphisms are descriptions of primitive recursive functions",
    ". in particular , there exists descriptions of initial functions : the null function @xmath21 , the successor function @xmath22 , and the projection functions , i.e. , for all @xmath23 and for all @xmath24 there are distinguished descriptions @xmath25 .",
    "there will be three ways of composing edges in this graph :    * composition : for @xmath26 and @xmath27 , there is a @xmath28 notice that this composition need not be associative .",
    "there is also no reason to assume that this composition has a unit .",
    "* recursion : for @xmath26 and @xmath29 , there is a @xmath30 there is no reason to think that this operation satisfies any universal properties or that it respects the composition or the bracket . * bracket : for @xmath26 and @xmath31 , there is a @xmath32 there is no reason to think that this bracket is a functorial ( that is respects the composition ) or is in any way coherent .    at times",
    "we shall use trees to specify the descriptions .",
    "the leaves of the trees will have initial functions and the internal nodes will be marked with * c * , * r * or * b * for composition , recursion and bracket as follows :    .@xmath33 + c .@xmath34 +   .@xmath35 +    just to highlight the distinction between programs and functions , it is important to realize that the following are all legitimate descriptions of the null function :    * @xmath21 * @xmath36 * @xmath37 * etc .",
    "there are , in fact , an infinite number of descriptions of the null function .",
    "in this paper we will need `` macros '' , that is , certain combinations of operations to get commonly used descriptions .",
    "there is a need to generalize the notion of a projection .",
    "the @xmath38 accept @xmath7 inputs and outputs one number .",
    "a multiple projection takes @xmath7 inputs and outputs @xmath39 outputs .",
    "consider @xmath40 and the sequence @xmath41 where each @xmath42 is in @xmath43 .",
    "for every @xmath44 there exists @xmath45 as @xmath46 in other words , @xmath47 outputs the proper numbers in the order described by @xmath44 .",
    "in particular    * if @xmath48 then @xmath49 will be a description of the identity function . * if @xmath50 then @xmath51 is the diagonal map . * for @xmath52 @xmath53 then @xmath47 will be the twist operator which swaps the first @xmath54 elements with the second @xmath55 elements . then by abuse of notation",
    ", we shall write @xmath56    whenever possible , we shall be ambiguous with superscripts and subscripts .",
    "concomitant with the bracket operation is the product operation .",
    "a product of two maps is defined for a given @xmath57 and @xmath58 as @xmath59 the product can be defined using the bracket as @xmath60    given the product and the diagonal , @xmath61 , we can define the bracket as @xmath62^{\\la f , g \\ra } \\ar[rdd]_\\triangle   & & \\n^b \\times \\n^c \\\\ \\\\ & \\n^a \\times \\n^a .",
    "\\ar[ruu]_{f\\times g } } \\ ] ]    since the product and the bracket are derivable from each other , we shall use them interchangeably .",
    "that is enough about the graph of descriptions .",
    "related to descriptions of primitive recursive functions is the set of primitive recursive _",
    "functions_. the set of functions has a lot more structure than @xmath19 .",
    "@xmath63 is the category of primitive recursive functions .",
    "the objects of this category are powers of natural numbers @xmath20 and the morphisms are primitive recursive functions . in particular , there are specific maps @xmath21 , @xmath22 and for all @xmath23 and for all @xmath24 there are projection maps @xmath25 .",
    "since composition of primitive recursive functions is associative and the identity functions @xmath64 are primitive recursive and act as units for composition , @xmath63 is a genuine category .",
    "@xmath63 has a categorically coherent cartesian product @xmath65 .",
    "furthermore , @xmath63 has a strong natural number object .",
    "that is , for every @xmath26 and @xmath66 there exists a _ unique _",
    "@xmath67 that satisfies the the following two commutative diagrams    this category of primitive recursive functions was studied extensively by many people including @xcite .",
    "it is known to be the initial object in the 2-category of categories , with products and strict natural number objects .",
    "other categories in that 2-category will be primitive recursive functions with oracles .",
    "one can think of the oracles as functions put on the leaves of the trees besides the initial functions .",
    "there is a surjective graph morphism @xmath68 that takes @xmath40 to @xmath40 , i.e. , is identity on objects .",
    "@xmath69 takes descriptions of primitive recursive functions in @xmath19 to the functions they describe in @xmath63 . since there are , in general , many descriptions of a primitive recursive function , @xmath69 is surjective on morphisms . another way to say",
    "this is that @xmath63 is a quotient of @xmath19 .",
    "algorithms will be graphs that are `` between '' @xmath19 and @xmath63 .",
    "in the last section we saw the type of structure the set of programs form . in this section",
    "we look at the weakest type of structures a set of algorithms can have .",
    "a * primitive recursive ( p.r . )",
    "algorithmic universe * , @xmath70 , is a graph whose objects are the powers of natural numbers @xmath20 .",
    "we furthermore require that there exist graph morphisms @xmath71 and @xmath72 that are the identity on objects and that make the following diagram of graphs commute : .",
    "the image of the initial functions under @xmath71 will be distinguished objects in @xmath70 :    * @xmath21 * @xmath22 and * for all @xmath23 and for all @xmath24 there are projection maps @xmath25    a p.r .",
    "algorithmic universe _ might _ have the following operations : ( warning : these are not functors because we are not dealing with categories . )    * composition : for @xmath26 and @xmath73 , there is a @xmath28 * recursion : for @xmath26 and @xmath29 , there is a @xmath74 * bracket : for @xmath26 and @xmath31 , there is a @xmath75    these operations are well defined for programs but need not be well defined for equivalence classes of programs .",
    "there was never an insistence that our equivalence relations be congruences ( i.e. respect the operations ) .",
    "we shall study when these operations exist .",
    "notice that although the @xmath69 graph morphism preserves the composition , bracket and recursion operators , we do not insist that @xmath71 and @xmath72 preserve them .",
    "we shall see that this is too strict of a requirement .",
    "let @xmath70 be a p.r .",
    "algorithmic universe .",
    "quotient algorithmic universe * is a p.r .",
    "algorithmic universe @xmath76 and an identity on objects , surjection on edges graph map @xmath77 that makes all of the the following squares and triangles commute    examples of p.r .",
    "algorithmic universe abound :    @xmath19 is the primary example . in fact , all our examples will be quotients of this algorithmic universes . here",
    "@xmath78 and @xmath79 .",
    "@xmath63 is another example of an algorithmic universe . here",
    "@xmath80 and @xmath81 .",
    "@xmath82 is a quotient of @xmath19 .",
    "this is constructed by adding the following relation :    for any three composable maps @xmath83 , @xmath84 and @xmath85 , we have h ( g f ) ~(h g ) f.[compisassoc]in terms of trees , we say that the following trees are equivalent :    .@xmath86 + c @xmath87 .@xmath88 + c    it is obvious that the composition map in @xmath82 is associative .",
    "@xmath89 is also a quotient of @xmath19 that is constructed by adding in the relations that says that the projections @xmath90s act like identity maps .",
    "that means for any @xmath57 , we have f ^a_a ~f ~^b_b f.[composident ]    in terms of trees :    .@xmath91 + c @xmath87 @xmath92 @xmath87 .@xmath93 + c    the composition map in @xmath89 has a unit .",
    "@xmath94 is @xmath19 with both relations ( [ compisassoc ] ) and ( [ composident ] ) .",
    "notice that this ensures that @xmath94 is more than a graph and is , in fact , a full fledged category .",
    "@xmath95 is a quotient of @xmath94 which has a well - defined bracket / product function .",
    "we add the following relations to @xmath94 :    * the bracket is associative . for any three maps @xmath96 and @xmath85 with the same domain",
    ", we have @xmath97 in terms of trees , this amounts to + .@xmath98 +   @xmath87 .@xmath99 + *",
    "composition distributes over the bracket on the right . for @xmath100 , @xmath101 and @xmath102",
    "we have f_1,f_2 g ~f_1 g , f_2 g .[distrib ] + in terms of trees , this amounts to saying that these trees are equivalent : + .@xmath103 + c .@xmath104 + * the bracket is almost commutative .",
    "for any two maps @xmath83 and @xmath84 with the same domain , @xmath105 in terms of trees , this amounts to + .@xmath106 +   @xmath87 .@xmath107 + c * twist is idempotent . @xmath108 * twist is coherent .",
    "that is , the twist maps of three elements to get along with themselves .",
    "@xmath109 this is called the hexagon law or the third reidermeister move .",
    "given the idempotence and hexagon laws , it is a theorem that there is a unique twist map made of smaller twist maps between any two products of elements ( @xcite section xi.4 ) .",
    "@xmath110 is a category with a natural number object .",
    "it is @xmath94 with the following relations :    * left square of diagram ( [ natnumobj ] ) . @xmath111",
    "* right square of diagram ( [ natnumobj ] ) . @xmath112",
    "* natural number object and identity .",
    "if @xmath113 then @xmath114 * natural number object and composition .",
    "this is explained in section 3.5 of @xcite . @xmath115",
    "@xmath116 is a category that has both a product and natural number object .",
    "it can be constructed by adding to @xmath94 all the relations of @xmath95 and @xmath110 as well as the following relations :    * natural number object and bracket .",
    "this is explained in section 3.4 of @xcite @xmath117    putting all these examples together , we have the following diagram of p.r .",
    ".    @xmath118 \\ar@{>>}[dr ] \\\\ & \\pralgc \\ar@{>>}[dr]&&\\pralgi \\ar@{>>}[dl ] \\\\ & & \\pralgcat \\ar@{>>}[ld ] \\ar@{>>}[dr ] \\\\ & \\pralgcatx \\ar@{>>}[dr]&&\\pralgcatn \\ar@{>>}[dl ] \\\\ & & \\pralgcatxn \\ar@{>>}[d ] \\\\ & & \\prfunc\\\\ } \\ ] ]    there is no reason to think that this is a complete list .",
    "one can come up with infinity many more examples of algorithmic universes .",
    "we can take other permutations and combinations of the relations given here as well as new ones .",
    "each such relations will give a different algorithmic universe .",
    "in @xcite , we mentioned other relations which deal with the relationship between the operations and the initial functions .",
    "we do not mention those relations here because our central focus is the existence of well defined operations .    a word about decidability .",
    "the question is , for a given p.r .",
    "algorithmic universe determine whether or not two programs in @xmath19 are in the same equivalence class of that algorithmic universe .",
    "* this is very easy in the algorithmic universe @xmath19 since every equivalence class has only one element .",
    "two descriptions are in the same equivalence relation iff they are _ exactly _ the same . * the extreme opposite is in @xmath63 . by a restriction of rice s theorem , there is no way to tell when two different programs / descriptions are the same primitive recursive function .",
    "so @xmath63 is not decidable . * in between @xmath19 and @xmath63 things get a little hairy .",
    "consider @xmath82 , i.e. , the graph with associative composition .",
    "this is decidable .",
    "all one has to do is change all the contiguous sequences of compositions to associate on the left .",
    "do this for both descriptions and then see if the two modified programs are the same .",
    "* one can perform a similar trick for @xmath89 .",
    "simply eliminate all the identities and see if the two modified programs are the same .",
    "* for @xmath94 one can combine the tricks from @xmath82 and @xmath89 to show that it is also decidable . *",
    "it is believed that @xmath95 is also decidable because of the coherence of the product .",
    "once again , any contiguous sequences of products can be associated to the left .",
    "also , equivalence relation ( [ distrib ] ) insures the naturality of the product so that products and compositions can `` slide across '' each other .",
    "again , each description can be put into a canonical form and then see if the modified programs are the same . *",
    "things are not so clear for @xmath110 and @xmath116 .",
    "the equivalence relations that deal with the @xmath119 operator are far more complicated .",
    "one can think of this as the dividing line between the decidable , syntactical structure of @xmath19 and the undecidable , semantical structure of @xmath63 .",
    "we leave it as an open question to determine if they are decidable or not .",
    "an automorphism @xmath120 of @xmath19 is a graph isomorphism that is the identity on the vertices ( i.e. , @xmath121 . for every @xmath122 @xmath120 basically acts on the edges between @xmath123 and @xmath124 .",
    "we are interested in automorphisms that preserve functionality .",
    "that is , automorphisms @xmath120 , such that for all programs @xmath125 , we have that @xmath125 and @xmath126 perform the same function . in terms of diagram ( [ galofalg ] ) we demand that @xmath127 .",
    "it is not hard to see that the set of all automorphism of @xmath19 that preserve functionality forms a group .",
    "we shall denote this group as @xmath128 .",
    "the lattice of subgroups of @xmath128 is isomorphic to the dual lattice of algorithmic universes between @xmath19 and @xmath63 .",
    "* we shall construct inverse functions between intermediate algorithmic universes and subgroups of @xmath128 .    for a given algorithmic universe",
    "@xmath70 , we construct the subgroup @xmath129 .",
    "@xmath130 this is the set of all automorphisms of @xmath19 that preserve that algorithmic universe , i.e. , automorphisms @xmath120 such that for all programs @xmath125 , we have @xmath125 and @xmath126 are in the same equivalence class in @xmath70 . in terms of diagram ( [ algunidef ] ) , this means @xmath131 . in order to see that it is a subgroup of @xmath128 ,",
    "notice that if @xmath120 is in @xmath132 then we have @xmath133 which means that @xmath120 is in @xmath134 .",
    "in general , this subgroup fails to be normal .",
    "the other direction goes as follows . for @xmath135 , the graph",
    "@xmath136 is a quotient of @xmath19 . @xmath137",
    "the vertices of @xmath136 are powers of natural numbers .",
    "the edges will be equivalence classes of edges from @xmath19 .",
    "the equivalence relation @xmath138 is defined as p ~_h p h ( p)=p [ defofequiv]the fact that @xmath138 is an equivalence relation follows from the fact that @xmath15 is a group . in detail    * reflexivity comes from the fact that @xmath139 .",
    "* symmetry comes from the fact that if @xmath140 then @xmath141 .",
    "* transitivity comes from the fact that if @xmath140 and @xmath142 then @xmath143 .",
    "now to make sure that these two functions respect the lattice structure .",
    "if @xmath144 then there will be a surjective map @xmath145 the way to see this is to realize that there are more @xmath120 in @xmath146 to make different programs equivalent as described in line ( [ defofequiv ] ) .",
    "going the other way , if @xmath147 is a quotient algorithmic universe as in diagram ( [ quotentalg ] ) then @xmath148 this is obvious if you look at @xmath149 then we have that @xmath150 which means that @xmath120 is also in @xmath151    we must show that these two operations are inverse of each other .",
    "let us start with a subgroup @xmath135 . performing both operations we have @xmath152",
    "we must show that @xmath153 .",
    "let @xmath154 .",
    "since @xmath155 takes @xmath125 to @xmath156 we have that in @xmath136 the following equivalence holds @xmath157 .",
    "an automorphism of @xmath19 that preserves @xmath136 will take @xmath125 to something that it is equivalent to in @xmath136 .",
    "@xmath120 is such an automorphism , i.e. , @xmath158 .",
    "now let us start with a @xmath70 . performing both operations",
    "we have @xmath159 let us consider an equivalence class @xmath160 $ ] in @xmath161 .",
    "@xmath162=\\{p'|\\mbox { there exits a } \\phi \\in h_{aut(\\prdesc/\\pralg ) } \\mbox { such that } \\phi(p)=p'\\}\\ ] ] @xmath163 @xmath164_{\\pralg}.$ ] the theorem is proved .",
    "notice that the algorithmic universes that we dealt with in this theorem does not necessarily have well - defined extra structure / operations .",
    "we simply discussed the equivalence relations of @xmath19 and did not discuss congruences of @xmath19 . without the congruence , the operations of composition , bracket and recursion might not be well - defined for the equivalence classes .",
    "this is very similar to classical galois theory where we discuss a single weak structure ( fields ) and discuss all intermediate objects as fields even though they might have more structure .",
    "so too , here we stick to one weak structure .",
    "however we can further . our definition of algorithmic universes is not carved in stone .",
    "one can go on and define , say , a _ composable _ algorithmic universe .",
    "then we can make the fundamental theorem of galois theory for composable algorithmic universes by looking at automorphisms of @xmath19 that preserve the composition operations .",
    "that is , automorphisms @xmath120 such that for all programs @xmath125 and @xmath156 we have that @xmath165 such automorphisms also form a group and one can look at subgroups as we did in the main theorem .",
    "on the algorithmic universe side , we will have to look at equivalence relations that are congruences .",
    "that is , @xmath87 such that if @xmath166 and @xmath167 then @xmath168 such an analogous theorem can easily be proved .",
    "similarly , one can define a _ recursive _ and a _ bracket _ algorithmic universes .",
    "one can still go further and ask that an algorithmic universe has two well - defined operations . in that case the automorphism will have to preserve two operations . if @xmath15 is a group of automorphism , then we can denote the subgroup of automorphisms that preserve composition as @xmath169 .",
    "furthermore , the subgroup that preserves composition and recursion will be denoted as @xmath170 , etc .",
    "the subgroups fit into the following lattice .",
    "it is important to realize that it is uninteresting to require that the algorithmic universe have all three operations .",
    "the only automorphism that preserves all the operations is the identity automorphism on @xmath19 .",
    "one can see this by remembering that the automorphisms preserve all the initial functions and if we ask them to preserve all the operations , then it must be the identity automorphism .",
    "this is similar to looking at an automorphism of a group that preserves the generators and the group operation .",
    "that is not a very interesting automorphism .",
    "one can ask of the automorphisms to preserve all three operations but not preserve the initial operations . similarly , when discussing oracle computation , one can ask the automorphisms to preserve all three operations and the initial functions , but not the oracle functions .",
    "all these suggestions open up new vistas of study .",
    "* extend to all computable functions . *",
    "the first thing worthy of doing is to extend this work to all computable functions from primitive recursive functions .",
    "one need only add in the minimization operator and look at its relations with the other operations .",
    "the study of such programs from our point of view is already underway in @xcite .",
    "however the galois theory perspective is a little bit complicated because of the necessity to consider partial operations .",
    "a study of @xcite will , no doubt , be helpful .",
    "* continuing with galois theory * there are many other classical galois theory theorems that need to be proved for our context .",
    "we need the zassenhaus lemma , the schreier refinement theorem , and culminating in the jordan - hlder theorem . in the context of algorithms",
    "this would be some statement about decomposing a category of algorithms regardless of the order in which the equivalence relations are given .",
    "we might also attempt a form of the krull - schmidt theorem .    * impossibility results . *",
    "the most interesting part of galois theory is that it shows that there are certain contingencies that are impossible or not `` solvable '' .",
    "what would the analogue for algorithms be ?    * calculate some groups . *",
    "its not interesting just knowing that there are automorphism groups",
    ". it would be nice to actually give generators and relations for some of these groups .",
    "this will also give us a firmer grip for any impossibility results .",
    "* universal algebra of algorithms . * in this paper we stressed looking at quotients of the structure of all programs .",
    "however there are many other aspects of the algorithms that we can look at from the universal algebraic perspective .",
    "* subalgebras . *",
    "we considered all primitive recursive programs .",
    "but there are subclasses of programs that are of interest .",
    "we can for example restrict the number of recursions in our programs and get to subclasses like the grzegorczyk s hierarchy .",
    "how does the subgroup lattice survive with this stratification ? other subclasses of primitive recursive functions such as elementary functions and exptime functions can also be studied . *",
    "* we can also look at larger classes of algorithms . as stated above",
    ", we can consider all computable functions by simply adding in a minimization operator .",
    "also , oracle computation can be dealt with by looking at trees of descriptions that in addition to initial functions permit arbitrary functions on their leaves .",
    "again we ask similar questions about the structure of the lattice of automorphisms and the related lattice of intermediate algorithms .",
    "* homomorphisms .",
    "* what would correspond to a homomorphism between classes of computable algorithms ?",
    "they input programs and output programs .",
    "this opens up a whole new can of worms . what does it mean for a compiler to preserve algorithms",
    "when are two compilers similar",
    "? what properties should a compiler preserve ?",
    "how are the lattices of subgroups and intermediate algorithms preserved under homomorphisms / compilers ?",
    "there is obviously much work to be done .",
    "a. blass , n. dershowitz , and y. gurevich .",
    "`` when are two algorithms the same ? '' .",
    "available at http://arxiv.org/ps_cache/arxiv/pdf/0811/0811.0811v1.pdf .",
    "downloaded feburary 5 , 2009 .",
    "a. burroni `` recursivite graphique ( @xmath171 partie ) : categories des fonctions recursives primitives formelles '' .",
    "cahiers de topologie et geometrie differentielle categoriques .",
    "vol xxvii-1(1986 ) .",
    "p.m. cohen _ universal algebra , 2nd edition _",
    "d. reidel publishing company , 1980 .",
    "da costa `` remarks on abstract galois theory '' . on the web ftp://logica.cle.unicamp.br/pub/e-prints/vol.5,n.8,2005.pdf .",
    "da costa , a.a.m .",
    "`` definability and invariance '' , studia logica ( 2007)86 : 1 - 30",
    ". i. fleischer .",
    "`` the abstract galois theory : a survey . '' in proceedings of the international conference on cryptology on algebraic logic and universal algebra in computer science ( sydney , australia ) . c. h. bergman , r. d. maddux , and d. l. pigozzi , eds .",
    "springer - verlag new york , new york , ny , pages 133 - 137 .",
    "saunders mac lane .",
    "_ categories for the working mathematician , _ second edition .",
    "springer , 1998 .",
    "maietti `` joyal s arithmetic universe via type theory '' . electronic notes in theoretical computer science . 69 ( 2003 ) .",
    "_ a course in mathematical logic for mathematicians second edition_. springer .",
    "october 2009 .",
    "`` renormalization and computation i : motivation and background '' on the web http://arxiv4.library.cornell.edu/abs/0904.4921 .",
    "`` renormalization and computation ii : time cut - off and the halting problem '' on the web http://arxiv4.library.cornell.edu/abs/0908.3430 .",
    "i. manin , and n.s .",
    "`` notes on the recursive operad '' .",
    "work in progress .",
    "reinhard pschel.``a general galois theory for operations and relations and concrete characterization of related algebraic structures '' . on the web at .",
    "poeschel / poepublicationspdf / poereport80.pdf l. roman .",
    "`` cartesian categories with natural numbers object . ''",
    "journal of pure and applied algebra .",
    "58 ( 1989 ) , 267 - 278 .",
    "`` galois theory for partial algebras '' .",
    "springer lnm 1004 ( 1981 ) .",
    "f . thibault .",
    "`` prerecursive categories '' , journal of pure and applied algebra , .",
    "24,(1982 ) , 7993 . n.s .",
    "yanofsky `` towards a definition of algorithms '' j logic computation exq016 first published online may 30 , 2010 doi:10.1093/logcom / exq016 ."
  ],
  "abstract_text": [
    "<S> many different programs are the implementation of the same algorithm . </S>",
    "<S> this makes the collection of algorithms a quotient of the collection of programs . </S>",
    "<S> similarly , there are many different algorithms that implement the same computable function . </S>",
    "<S> this makes the collection of computable functions into a quotient of the collection of algorithms . </S>",
    "<S> algorithms are intermediate between programs and functions :    programs @xmath0 algorithms @xmath0 functions .    </S>",
    "<S> galois theory investigates the way that a subobject sits inside an object . </S>",
    "<S> we investigate how a quotient object sits inside an object . by looking at the galois group of programs </S>",
    "<S> , we study the the intermediate types of algorithms possible . along the way </S>",
    "<S> , we formalize the intuition that one program can be substituted for another if they are the same algorithms . </S>"
  ]
}