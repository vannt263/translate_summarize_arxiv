{
  "article_text": [
    "in this paper , we propose a private key cipher , the idea for which comes from frame theory and multiple access communications .",
    "the cipher has similarities to the hill cipher , the one time pad , and the mceliece cipher @xcite .",
    "indeed , one of the design goals for our cipher is to approximate the one time pad .",
    "our design goals include the following :    1 .   include randomness in the encryption process ; 2 .",
    "require the key be shared only once ; 3 .   use a relatively small key size ; 4 .",
    "computationally fast ; 5 .",
    "robust to brute force attacks .",
    "our proposed cipher implements items 1 - 4 above ; the purpose of the present paper is to give some demonstration of item 5 .",
    "we remark here that 5 is not sufficient for the cipher to be a good one , but certainly is necessary .",
    "we will demonstrate that this cipher is vulnerable to a chosen - plaintext attack .",
    "it is unknown if this cipher is robust against a known - plaintext attack .",
    "our cipher can be described as follows : consider a communications channel ; we divide the channel into two subbands , one which will carry the message , and the other which will carry noise , or as we call it in this paper , garbage .",
    "the message , along with the garbage is transmitted over the channel ; the recipient then filters out the garbage , leaving only the message .",
    "this procedure is carried out using orthogonal frames .",
    "the procedure requires the construction of orthogonal frames ; the easiest way to do this is using fourier frames ( also called harmonic frames ) .",
    "however , as will be described , these frames are not good for our purposes here , and so we present several alternative methods for constructing orthogonal frames .    the paper is organized as follows . in section [ s : frames ] , we give a short introduction to frames , and in particular orthogonal frames . in section [",
    "s : schemes ] , we give an account of several methods for constructing orthogonal frames , with remarks regarding our design goals . in section",
    "[ s : results ] , we present the results and conclusions of our numerical experiments and the chosen - plaintext attack . in the appendix , we provide psuedocode to describe the experiments .",
    "frames for hilbert spaces are being used in many signal processing applications such as sampling theory , multiple access communications , etc .",
    "frames provide redundancy via overcompleteness , where bases do not , and it is this redundancy that makes them advantageous to use in these settings . in this paper",
    ", we will utilize this redundancy of frames for the purpose of encryption .",
    "let @xmath0 be a hilbert space over the field @xmath1 with scalar product @xmath2 and norm @xmath3 , where @xmath1 denotes either @xmath4 or @xmath5 .",
    "a frame for @xmath0 is a sequence @xmath6 such that there exist constants @xmath7 such that for all @xmath8 , @xmath9 clearly , a frame spans the hilbert space .",
    "moreover , @xmath10 defines the following _ frame operator _",
    "@xmath11 which is positive and invertible .",
    "define @xmath12 , the _ standard dual _ of @xmath10 by @xmath13 , then for all @xmath8 , @xmath14 if @xmath15 , the frame is said to be _ parseval _ , and then for all @xmath8 , @xmath16 for elementary frame theory , see @xcite .",
    "if @xmath0 is finite dimensional ( @xmath0 will always be assumed to be so from here on , unless specifically stated ) , then a frame sequence ( possibly finite ) is any spanning set @xmath10 such that @xmath17 . if only a finite number of @xmath18 s are non - zero , then @xmath10 is a finite frame , and we will discard those that are zero .",
    "see @xcite for more on finite frames .    for convenience of notation",
    ", we make the following definition .",
    "an @xmath19 real matrix , @xmath20 , is an orthogonal matrix if @xmath21 for some constant @xmath22 .",
    "the ( finite ) parseval frames in @xmath0 are characterized by the following proposition .",
    "[ p : pf ] let @xmath23 , where @xmath0 has dimension @xmath24 .",
    "the following are equivalent :    1 .",
    "@xmath10 is a parseval frame for @xmath0 ; 2 .",
    "the @xmath25 matrix whose @xmath26th row is @xmath27 ( as a row vector ) has columns which are orthonormal ; 3 .   there exists a hilbert space @xmath28 of dimension @xmath29 and vectors @xmath30 such that the @xmath31 matrix formed by @xmath32 is a unitary matrix .",
    "here we write the vectors @xmath27 and @xmath33 as row vectors with respect to any orthonormal bases for @xmath0 and @xmath28 , respectively .",
    "the proof of the equivalence of 1 and 2 is in @xcite .",
    "the proof of the equivalence of 1 and 2 is , for infinite frames , contained in ( * ? ? ?",
    "* corollary 1.3 , theorem 1.7 ) .",
    "the case for finite frames is analogous .",
    "another way to view proposition [ p : pf ] is that @xmath10 is a parseval frame for @xmath0 if and only if @xmath10 is the inner direct summand of an orthonormal basis @xmath34 for some superspace @xmath35 of @xmath0 .",
    "two frames @xmath23 and @xmath36 are _ orthogonal _ if for all @xmath8 , @xmath37 .",
    "[ p : ortho ] suppose @xmath23 and @xmath36 are parseval frames ; they are orthogonal if and only if @xmath38 has columns which form an orthonormal set .",
    "( @xmath39 ) consider the two matrices @xmath40 and @xmath41 whose rows are @xmath10 and @xmath42 , respectively .",
    "a straight forward computation demonstrates that for @xmath8 , @xmath43 where @xmath44 is the conjugate transpose of @xmath41 .",
    "it follows that if the above matrix has orthonormal columns , then @xmath45 , and thus the frames @xmath10 and @xmath42 are orthogonal .",
    "( @xmath46 ) conversely , suppose the parseval frames are orthogonal . note that by proposition 1 , the left part @xmath40 of the above matrix has orthonormal columns ; likewise the right part of the matrix @xmath41 also has orthonormal columns . by equation ( [ e : ortho ] ) , we must have that the columns of the left part of the matrix are orthogonal to the columns of the right part of the matrix . hence",
    ", the columns of the matrix form an orthonormal set .    note that if @xmath10 is orthogonal to @xmath42 , then @xmath42 is orthogonal to @xmath10 .    let @xmath47 ; the analysis operator @xmath48 of @xmath10 is given by : @xmath49 the matrix representation of @xmath48 is given as the matrix @xmath40 in proposition [ p : ortho ] .",
    "the proof of proposition [ p : ortho ] shows that two frames @xmath10 and @xmath42 are orthogonal if and only if their analysis operators @xmath48 and @xmath50 have orthogonal ranges in @xmath51 .",
    "we present here an overview of our proposed private key encryption scheme using orthogonal frames . for motivation , consider that the one - time pad is an unconditionally secure cipher , which is optimal of all unconditionally secure ciphers in terms of key length @xcite .",
    "our encryption scheme , which is similar to a subband coding scheme , is an effort to approximate the one - time pad .",
    "the ( private ) key for this encryption scheme is two orthogonal parseval frames @xmath23 and @xmath36 .",
    "let @xmath48 and @xmath50 respectively denote their analysis operators .",
    "suppose @xmath52 is a message ; let @xmath53 be a non - zero vector chosen at random .",
    "the ciphertext @xmath54 is given as follows : @xmath55 to recover the message , we apply @xmath56 : @xmath57    there are several things to note about our scheme :    1 .   the frame @xmath10 need not be parseval , but parseval frames are in general easier to work with . since the parseval frames form only a small subset of all possible frames , using general frames would allow a much greater choice of specific encryption keys . 2 .   the frame @xmath42 need not be parseval ; it need not even be a frame , though again parseval frames simplify matters . if @xmath42 is not a frame , then @xmath50 has non - trivial kernel , and @xmath58 could be 0 if g is chosen to be in the kernel .",
    "( below we will actually use scalar multiples of parseval frames for both @xmath10 and @xmath42 . )",
    "3 .   just as with the one - time pad , when done properly , encoding a message twice results in two different ciphertexts .",
    "4 .   unlike the one - time pad , in which a brute force attack results in all possible plaintexts , it appears unlikely that a brute force attack on our system would result in the same .",
    "our simulations indicate that an attack produces either a text which is very close to the original plaintext or is gibberish ( see graphs below for more . )",
    "however , at this time , we can not prove why this is so .",
    "if @xmath23 and @xmath36 are orthogonal frames , then @xmath59 .",
    "let @xmath48 and @xmath50 be the respective analysis operators .",
    "note that by the ( lower ) frame inequality in equation [ e : frame ] , both @xmath48 and @xmath50 are one - to - one .",
    "moreover , the orthogonality of the frames is equivalent to the orthogonality of the ranges of @xmath48 and @xmath50 .",
    "combining these two observations establishes the proposition .    for convenience",
    ", we will assume that @xmath60 .",
    "the ciphertext is @xmath61 where @xmath10 and @xmath42 are orthogonal parseval frames .",
    "since they are orthogonal , we write @xmath62 where the matrix @xmath63 is an isometry . therefore",
    ", our encryption procedure involves generating a large orthogonal matrix .",
    "the next section discusses several ways of constructing such matrices .",
    "since the encryption scheme is a private key system , we wish to have a relatively small key size ; that is to say that the entire matrix is too much information to be used as the key . we discuss below some of the strengths and weaknesses of the various construction techniques",
    "the cipher algorithm depends upon generating a pair of random orthogonal frames , each of which is the size of the message .",
    "this is equivalent to producing a random orthogonal matrix of twice the size of the message .",
    "we investigate here several methods for doing so .",
    "the first method takes the view of producing orthogonal frames using fourier frames .",
    "the remaining methods take the view of producing orthogonal matrices .",
    "once the orthogonal frames , or orthogonal matrix , is determined , the encryption and decryption process is the same .",
    "if the frames are given by @xmath64 and @xmath65 , then we write the matrix @xmath66 ; if on the other hand the matrix is @xmath67 , we think of @xmath68 . given a message @xmath69 ,",
    "choose at random a vector @xmath70 , called the `` garbage '' or `` noise '' , and compute @xmath71 to yield the cipher text @xmath72 .",
    "the recipient computes @xmath73 where @xmath28 is the square of the norm of any column of the matrix @xmath48 .",
    "dividing by @xmath28 then reproduces the message .",
    "the first algorithm utilizes the discrete cosine transform .",
    "the original idea came from using the discrete fourier transform , which involves complex exponentials .",
    "the discrete cosine transform , in matrix form , is given by : @xmath74=\\left [ \\lambda_k\\sqrt{\\frac{2}{m } } \\cos \\left\\ { \\frac{k\\pi}{m}(n+1/2 ) \\right\\ } \\right],\\ ] ] where @xmath75 , @xmath76 and @xmath77 for all @xmath78 .",
    "note that this is normalized to be a unitary matrix . assuming that @xmath79",
    ", one can permute the columns of @xmath80 to yield @xmath81 , and divide the resulting matrix in half vertically : @xmath82 the resulting divided matrix can then be viewed as the analysis operators for two orthogonal frames , each for @xmath83 , consisting of cosine bases projected onto smaller subspaces , ( proposition [ p : ortho ] , see also @xcite ) .",
    "moreover , the frame vectors can be weighted , which is accomplished by a diagonal , invertible matrix @xmath84 .",
    "let @xmath40 denote a permutation matrix .",
    "the ( private ) key for the cipher then consists of the matrix @xmath84 ( or simply its diagonal entries ) , and the permutation corresponding to @xmath40 .",
    "the encryption algorithm of a message @xmath69 of length @xmath24 then consists of randomly generating a garbage vector @xmath85 and computing the ciphertext @xmath72 : @xmath86 to decrypt the message , we apply the matrix @xmath87 to the ciphertext , where @xmath41 is the projection of @xmath88 onto the first @xmath24 co - ordinates : @xmath89    we note that the only knowledge unknown to an adversary is @xmath84 and @xmath40 ; the adversary will know @xmath80 .",
    "hence , @xmath80 is irrelevant to the cipher algorithm .",
    "because of this , the algorithm reduces to rearrangement followed by weighting of the entries of the message and the garbage .",
    "we conclude that our first algorithm is a poor one .",
    "the second scheme involves using hadamard arrays to generate orthogonal matrices .",
    "we first start with the definition of hadamard arrays .",
    "we remark here that this scheme is related to linear codes @xcite .",
    "@xcite a hadamard array @xmath90 $ ] based on the indeterminates @xmath91 , with @xmath92 , is an @xmath93 matrix with entries chosen from @xmath94 in such a way that :    1 .   in any row",
    "there are @xmath95 entries @xmath96 , @xmath95 entries @xmath97 , @xmath98 @xmath95 entries @xmath99 , and similarly for the columns .",
    "2 .   the rows and columns are ( formally ) pairwise orthogonal , respectively .",
    "the matrices we use for our encryption scheme are of @xmath100 , @xmath101 .",
    "the only possible hadamard arrays of this type are for @xmath102 @xcite . for indeterminants @xmath67 through @xmath0 , we have the hadamard array @xmath103=\\begin{bmatrix}a&b&c&d&|&e&f&g&h\\\\-b&a&d&-c&|&f&-e&-h&g\\\\-c&-d&a&b&|&g&h&-e&-f\\\\-d&c&-b&a&|&h&-g&f&-e\\\\ -e&-f&-g&-h&|&a&b&c&d\\\\-f&e&-h&g&|&-b&a&-d&c\\\\-g&h&e&-f&|&-c&d&a&-b\\\\-h&-g&f&e&|&-d&-c&b&a\\\\ \\end{bmatrix}.\\ ] ]    for @xmath104 $ ] , @xmath105 where @xmath106 .",
    "the hadamard arrays allow easy construction of matrices ( and hence tight frames ) needed in our encryption schemes .",
    "for the encryption process , we now have only @xmath107 to construct instead of computing the matrices @xmath80 , @xmath84 , and @xmath40 .",
    "the encryption process starts with a message @xmath69 of arbitrary length , and dividing @xmath69 into blocks @xmath108 of length 4 ( padding the last block with @xmath109 s if necessary )",
    ". then random vectors @xmath110 of length 4 are chosen , and the matrix @xmath24 is applied successively to @xmath111 . the ciphertext is then @xmath112    the message is then decrypted by dividing @xmath72 into blocks @xmath113 of size 8 , computing @xmath114 for @xmath115 , and reconstructing the message using the first four entries of these resulting blocks .    because of the ease of construction of the hadamard arrays , the system is quite easy to implement . unlike the first scheme",
    ", the key for the recipient has now been reduced to knowing the chosen entries for @xmath107 , hence in this case the key is the entries @xmath116 of the matrix @xmath107 . since hadamard arrays are small , however , we wish to find an algorithm to generate larger orthogonal matrices .",
    "our next scheme is an attempt to produce larger orthogonal matrices . starting with hadamard arrays @xmath67 and @xmath20 with @xmath117 and @xmath118 for constants @xmath22 and @xmath119",
    ", we construct a new @xmath120 orthogonal matrix @xmath121 repeat this procedure with hadamard arrays @xmath122 and @xmath24 to get @xmath123 the matrices @xmath124 and @xmath125 are then used to construct a @xmath126 orthogonal matrix : @xmath127 this `` blow up '' construction is iterated to get the appropriate size matrix for our plain text .    in this encryption scheme ,",
    "the key is the entries of the matrices @xmath67 , @xmath122 , @xmath20 , @xmath24 , etc . , and their positions in the construction .",
    "this method , however is computationally inefficient .",
    "we first define the tensor product , @xmath128 , of two matrices , @xmath67 and @xmath122 .",
    "the sizes of the matrices is irrelevant .",
    "@xcite let @xmath129 then @xmath130    if @xmath67 is an @xmath131 and @xmath122 is a @xmath132 , then @xmath133 is an @xmath134 matrix",
    ". the tensor product will be the critical element of construction in this and the next scheme .",
    "note that if @xmath67 and @xmath122 are orthogonal matrices , then @xmath135 is also an orthogonal matrix .",
    "a hadamard matrix is a square orthogonal matrix with entries consisting of @xmath136 s .",
    "we start with an hadamard _ matrix _ ( not an array ) , @xmath0 , of a chosen size @xmath137 , and then two hadamard _ arrays _ , @xmath67 and @xmath122 of choice sizes 2,4 , or 8 .",
    "we then construct the new matrix via the tensor products : @xmath138 @xmath80 is now an orthogonal matrix .",
    "this matrix is size adaptive with respect to powers of 2 since each matrix is of some order of 2 , and the size of @xmath0 can be chosen .    however , the hadamard matrix property that @xmath139 is actually a disadvantage .",
    "let @xmath140 then our matrix is @xmath141 @xmath142    the resulting matrix is relatively sparse , which is undesirable for maintaining secrecy .",
    "we choose @xmath119 hadamard arrays @xmath143 .",
    "each array can have its own size , say @xmath144 for @xmath145 , where each @xmath146 is either 2,4 , or 8 .",
    "we then construct our @xmath147-sized matrix @xmath20 by the tensor product of these @xmath119 matrices : @xmath148 the ciphertext then is @xmath149 . with this construction , we eliminate the sparsity that was shown in scheme # 4 .",
    "note that the key in this case is the entries of the first rows of @xmath150 to @xmath151 , hence is an array of numbers of size @xmath152 , and hence is relatively small .",
    "we ran some numerical experiments , using scheme # 5 to obtain information regarding several things :    1 .",
    "we wanted to see if a brute force attack would be a feasible way of defeating the cipher .",
    "the results of the experiments and also the computations below suggest that the answer is no .",
    "one advantage of the one time pad is that a brute force attack results in all possible plaintext messages , forcing an adversary to choose which was the original message .",
    "we wanted to determine if this was also true of our proposed cipher .",
    "the results of our experiments indicate that the answer to this is also no .",
    "3 .   finally , we wanted to determine if the size of the entries of the garbage vector @xmath70 mattered .",
    "the experiments and the computations below suggest that the answer is yes .",
    "the results of our experiments , in the form of graphs , are given below .",
    "we want to know how accurate a guess has to be in order to break the cipher .",
    "we suppose that an adversary knows that we are using scheme # 5 , that is the adversary knows the structure of the matrix @xmath20 , but not the entries .",
    "we let @xmath20 be the original matrix of size @xmath153 , @xmath154 be the adversary s guess , and @xmath155 be the original plaintext @xmath69 concatenated with the garbage @xmath70 ( i.e. @xmath156 ) .",
    "then we consider @xmath157 where @xmath158 . since we assume that the structure of @xmath20 is known by the adversary , we consider @xmath159 , where @xmath40 is a matrix with the same structure as @xmath20 . for simplicity ,",
    "we let @xmath160 denote the @xmath26th row of the matrix @xmath20 and likewise for @xmath40 .",
    "note that @xmath161 since @xmath162 , and @xmath163 .",
    "we rewrite to get the following : @xmath164    let @xmath165 then we have that for @xmath166 : @xmath167    for an adversary s guess to be close , @xmath168 and @xmath169 we break this up into cases .    *",
    "assume @xmath170 is relatively large compared to @xmath171 ; that is , the guess is far from the actual matrix .",
    "we have @xmath172 however , when we look at the @xmath173 coefficients , we see the following : latexmath:[\\[\\left|{\\displaystyle\\frac}{\\langle m_j , m_j\\rangle}{\\langle m_j+p_j , m_j+p_j\\rangle}\\right|= \\left|{\\displaystyle\\frac}{(\\langle m_j , m_j\\rangle/||p_j||^2)}{(||m_i||^2/||p_i||^2)+(2\\langle p_i , m_i\\rangle/",
    "* we assume @xmath170 is small relative to @xmath175 ; that is , the guess is close",
    ". then we have using the same arguments : @xmath176 so , the better the guess , the smaller the ` extra ' coefficients will be . likewise",
    ", for the @xmath177 coefficients , @xmath178    our first question is whether an adversary can figure out how small the perturbation @xmath40 must be in order to get a `` good guess '' .",
    "the adversary knows the size of @xmath20 and @xmath179 ; we assume additionally that the adversary knows the structure of @xmath20 . for convenience ,",
    "assume that the encryption matrix @xmath180 for 3 hadamard arrays , @xmath181 , and @xmath80 .",
    "we then let @xmath182 for ( small norm ) perturbation matrices @xmath183 and @xmath72 .",
    "we reformulate our question : how big can @xmath184 , and @xmath185 be such that @xmath186 , where @xmath187 is some acceptable tolerance for error ? ( here , for a matrix @xmath67 , @xmath188 denotes the operator norm of @xmath67 .",
    "below , @xmath3 shall denote both hilbert space norm for vectors and operator norm for matrices . )",
    "we let @xmath189 and @xmath190 .",
    "we may assume that @xmath191 .",
    "if we write out @xmath154 in terms of the tensor products , we get @xmath192 given any @xmath193 , we choose @xmath194 .",
    "if @xmath195 , then @xmath196    these computations suggest that the larger the entries of the garbage vector @xmath70 are , the closer a guess must be in order to reasonably recover the message .",
    "this is corroborated by the experiments we ran ( see the graphs below ) .",
    "thus , we can control the accuracy an adversary would need in order to break the cipher .",
    "we will demonstrate here a chosen - plaintext attack on the cipher which will break the system .",
    "a chosen - plaintext attack is an attack mounted by an adversary which chooses a plaintext and is then given the corresponding ciphertext .",
    "the encryption algorithm proposed above is vulnerable to a chosen - plaintext attack .",
    "we assume the adversary knows the length of the message band and subsequently the length of the noise band .",
    "let the length of the message band be @xmath197 and the length of the noise band be @xmath198 .",
    "the attack is as follows :    1 .",
    "determine the range of the noise band @xmath28 of @xmath107 .",
    "that is , determine @xmath199 .",
    "choose any plaintext @xmath69 of size @xmath197 .",
    "encode the plaintext twice , with output , say , @xmath200 and @xmath201 .",
    "compute @xmath202 .",
    "notice that this yields a vector @xmath203 in the range of the noise band of @xmath107 .",
    "encode the plaintext a third time , with output @xmath204 , and compute @xmath205 .",
    "compute @xmath206 until the collection @xmath207 contain a linearly independent subset of size @xmath198 .",
    "this determines the range of the noise band @xmath28 of @xmath107 .",
    "2 .   determine the range of the message band @xmath125 of @xmath107 .",
    "that is , determine what is @xmath208 .",
    "choose any plaintext @xmath209 of size @xmath197 ; encode the plaintext , with output @xmath201 ; then project @xmath201 onto the orthogonal complement of @xmath28 .",
    "this yields a vector @xmath210 in @xmath125 .",
    "choose another plaintext @xmath211 and repeat , yielding vector @xmath212 .",
    "repeat until the collection @xmath213 contains a linearly independent subset of size @xmath197 .",
    "this set determines @xmath125 .",
    "3 .   determine the message part of @xmath107 .",
    "that is , determine @xmath48 .",
    "suppose in step 2 , @xmath214 is such that @xmath215 is linearly independent .",
    "if we write @xmath216 , then we now have the following system of equations : @xmath217 given this system of equations , now solve for @xmath48 .",
    "4 .   unencode ciphertexts . given any ciphertext @xmath218",
    ", the adversary computes the following : @xmath219 where @xmath28 is the square of the norm of any column of @xmath48 .",
    "the proposed cipher appears to be robust to brute force attacks , but is not robust against a chosen - plaintext attack .",
    "we mention , however , that we do not know if the scheme is robust to a known - plaintext attack . moreover ,",
    "this is a private symmetric key cipher ; it would be desirable if this method could be altered to be used as a public key cipher .",
    "we reiterate that the mceliece cipher is a public key system and is similar in flavor to the cipher presented here .",
    "the ultimate downfall of the cipher is the linearity .",
    "we suggest that perhaps there is possibly a way of introducing non - linearity into the algorithm to defeat a chosen - plaintext attack . however , at this point , we know of no methods to accomplish this .",
    "1 .   calculate matrix 1 .",
    "input the possible range of entries for a , b , c 2 .",
    "make a , b , c either 4x4 or 8x8 hadamard arrays with entries chosen randomly from the range ( for simplicity , we are using the 4x4 hadamard array ) 3 .",
    "compute tensor product @xmath220 2 .",
    "encode message 1 .",
    "compute @xmath221 by converting the message to ascii and filling @xmath70 with random numbers 2 .",
    "compute @xmath222      hacker.cppthis code attempts a brute force method on a cypher text .    1",
    ".   input min , max , range of key guesses 2 .",
    "input ciphertext 3 .   for all possible values of the twelve variables in use 1 .",
    "fill the matrices with the possible values 2 .",
    "tensor matrices together 3 .",
    "calculate possible text messages 4 .",
    "output text to file for later examination      this code takes the output of hacker.cpp and calculates the frequency of occurrence of every ascii symbol .    1 .   for each line of text , count number of appearances of each ascii value 2 .",
    "output information to text file",
    "this work was done while all three authors were at the university of wyoming , at which time the first author was an undergraduate student , and the third author was a graduate student .",
    "the first and second authors were supported by nsf grant dms-0308634 .",
    "the third author was supported by a basic research grant from the university of wyoming .",
    "we thank bryan shader , eric moorhouse , and cliff bergman for helpful discussions .",
    "how to read the following graphs .",
    "we carried out the following computations to simulate a brute force attack on the cipher :    1 .   for a sample plaintext ,",
    "encode the plaintext using scheme # 5 making the following choices : approximate entry size for the matrices and approximate size for the garbage entries ; 2 .",
    "decode the ciphertext using every combination of key entry and key entry @xmath136 ; 3 .   converted the decoded ciphertext in the previous step to ascii values ; 4 .",
    "counted the appearance of each value in the resulting combinations .",
    "the graphs represent the number of appearances within all possible key guesses from step 2 above .",
    "the plaintext is given in the title of the graph ; the ascii values are the @xmath223-axis of the graph , and the approximate key sizes and garbage sizes are given in the graph captions .",
    "note that in figures 3 and 7 , the key size and garbage size are the same .",
    "the graphs show that most of the characters that appear in the simulated brute force attack are those that are in the original message .",
    "references agaian , s.s . : _ hadamard matrices and their applications_. new york : springer - verlag , 1985 .",
    "aldroubi , a. , d. larson , w.s .",
    "tang , and e. weber , _ geometric aspects of frame representations of abelian groups _ , preprint ( 2002 ) ( available on arxiv.org ; math.fa/0308250 ) .",
    "benedetto , j. and fickus , m. : _ finite normalized tight frames _ , _ adv .",
    "_ * 18 * , ( 2003 ) no",
    ". 2 - 4 , 357385 .",
    "casazza , p. : _ the art of frame theory _ , _ taiwanese math . j. _ * 4 * ( 2000 ) no .",
    "2 , 129201 .",
    "casazza , p. , kovacevi , j. : _ uniform tight frames for signal processing and communications _",
    ", spie proc .",
    "4478 ( 2001 ) , 129135 .",
    "chabaud , f. , _ on the security of some cryptosystems based on error - correcting codes _ _ advances in cryptology ",
    "eurocrypt 94 _ , lecture notes in computer science 950 , springer - verlag , 1995 , pp . 131139 .",
    "delsarte , p. and goethals , j. m. : _ tri - weight codes and generalized hadamard matrices _ , information and control * 15 * ( 1969 ) , p. 196 - 206 .",
    "dykema , k. , freeman , d. , kornelson , k. , larson , d. , ordower , m. , weber , e. : _ ellipsoidal tight frames and projection decompositions of operators _ , preprint ( 2003 ) .",
    "han , d. and larson , d. : _ frames , bases , and group representations _ mem .",
    "soc . * 147 * , ( 2000 ) no .",
    "van lint , j.h . : _ a course in combinatorics _",
    ", cambridge : cambridge university press , 1992 .",
    "menezes , a. , van oorschot , p. and vanstone , s. : _ handbook of applied cryptography _",
    "crc press , 1997 .",
    "wallis , w.d . : _ combinatorics : room squares , sum - free sets , hadamard matrices _ , berlin : springer - verlag , 1972 ."
  ],
  "abstract_text": [
    "<S> we propose a cipher similar to the one time pad and mceliece cipher based on a subband coding scheme . </S>",
    "<S> the encoding process is an approximation to the one time pad encryption scheme . </S>",
    "<S> we present results of numerical experiments which suggest that a brute force attack to the proposed scheme does not result in all possible plaintexts , as the one time pad does , but still the brute force attack does not compromise the system . </S>",
    "<S> however , we demonstrate that the cipher is vulnerable to a chosen - plaintext attack . </S>"
  ]
}