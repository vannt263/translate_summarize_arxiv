{
  "article_text": [
    "code coverage is a common metric in software and hardware testing that measures the degree to which an implementation has been tested with respect to some criterion . in its simplest form ,",
    "one starts with a model of the program , and a partition of the behaviors of the model into _ coverage goals _",
    "test _ is a sequence of inputs that determines a behavior of the program .",
    "the aim of testing is to explore as many coverage goals as possible , ideally as quickly as possible . in this paper , we give complexity results for several coverage problems .",
    "the problems are very basic in nature : they consist in deciding whether a certain level of coverage can be attained in a given system .",
    "it is thus somewhat surprising that the problems have not been considered previously in the literature .",
    "finite - state directed graphs have been used as program models for test generation of reactive systems for a long time ( see @xcite for surveys ) .",
    "a coverage goal is a partition of the states of the graph , and a test is a sequence of labels that determine a path in the graph .",
    "the maximal coverage test generation problem is to hit as many partitions as possible using a minimum number of tests . in the special case",
    "the partitions coincide with the states , the maximal coverage problem reduces to the chinese postman problem for which there are efficient ( polynomial time ) algorithms @xcite . in this paper",
    ", we show that the maximal coverage problem becomes np - complete for graphs with general partitions .",
    "we also distinguish between _ system complexity _ ( the complexity of the problem in terms of the size of the graph ) and the _ coverage complexity _ ( the complexity of the problem in terms of the number of coverage goals ) .",
    "then , the problem is nlogspace in the size of the graph ( but that algorithm uses space polynomial in the number of propositions ) .",
    "we consider the special case where the graph has a special `` reset '' action that takes it back to the initial state .",
    "this corresponds in a testing setting to the case where the system can be re - initialized before running a test . in this case , the maximal coverage problem remains polynomial , even with general partitions .",
    "directed graphs form a convenient representation for deterministic systems , in which all the choices are under the control of the tester .",
    "testing of non - deterministic systems in which certain actions are controllable ( under the control of the tester ) and other actions are uncontrollable lead to _ game graphs _ @xcite .",
    "a game graph is a directed labeled graph where the nodes are partitioned into tester - nodes and system - nodes , and while the tester can choose the next input at a tester node , the system non - deterministically chooses the next state at a system node .",
    "then , the test generation problem is to generate a test set that achieves maximal coverage no matter how the system moves . for general game graphs ,",
    "we show the complexity of the maximal coverage problem is pspace - complete .",
    "however , there is an algorithm that runs in time linear in the size of the game graph but exponential in the number of coverage goals .",
    "again , the re - initializability assumption reduces the complexity of coverage : in case there is a re - initialization strategy of the tester from any system state , the maximal coverage problem for games is co - np - complete .",
    "dually , we show that the problem of whether it is possible to win a safety game while visiting fewer than a specified number of partitions is np - complete .    finally , we consider the coverage problem in bounded time , consisting in checking whether a specified number of partitions can be visited in a pre - established number of steps .",
    "we show that the problem is np - complete for graphs , and is pspace - complete for game graphs .",
    "optimization problems arising out of test generation have been studied before in the context of both graphs and games @xcite . however , to the best of our knowledge , the complexities of the coverage problems studied here have escaped attention so far .",
    "while we develop our theory for the finite - state , discrete case , we can derive similar results for more general models , such as those incorporating incomplete information ( the tester can only observe part of the system state ) or timing . for timed systems modeled as timed automata ,",
    "the maximal coverage problem is pspace - complete . for timed games as well as for ( finite state ) game graphs with incomplete information ,",
    "the maximal coverage problem becomes exptime - complete .",
    "in this section we define _ labeled graphs _ and _ labeled games _ , and then define the two decision problems of coverage , namely , _ maximal coverage _ problem and _ coverage with bounded time _ problem .",
    "we start with definition of graphs and games .",
    "a _ labeled graph _ @xmath0 consists of the following component :    1 .   a finite directed graph with vertex set @xmath1 and edge set @xmath2 ; 2 .   the initial vertex @xmath3",
    "a finite set of atomic propositions @xmath4 ; 4 .   a labeling function @xmath5 that assigns to each vertex @xmath6 the set @xmath7 of atomic propositions true at @xmath8 .",
    "for technical convenience we will assume that for all vertices @xmath9 , there exists @xmath10 such that @xmath11 , i.e. , each vertex has at least one out - going edge .    * paths in graphs and reachability .",
    "* given a labeled graph @xmath12 , a _ path _",
    "@xmath13 in @xmath12 is a infinite sequence of vertices @xmath14 starting from the initial vertex @xmath3 ( i.e. , @xmath15 ) such that for all @xmath16 we have @xmath17 .",
    "a vertex @xmath18 is reachable from @xmath3 if there is a path @xmath19 in @xmath12 and @xmath20 such that the vertex @xmath21 in @xmath13 is the vertex @xmath18 .",
    "a _ labeled game graph _ @xmath22 consists of the components of a labeled graph along with a partition of the finite vertex set @xmath1 into @xmath23",
    ". the vertices in @xmath24 are player  1 vertices where player  1 chooses outgoing edges , and analogously , the vertices in @xmath25 are player  2 vertices where player  2 chooses outgoing edges . again for technical convenience we will assume that for all vertices @xmath9 , there exists @xmath10 such that @xmath11 , i.e. , each vertex has at least one out - going edge .    *",
    "plays and strategies in games . *",
    "a _ play _ in a game graph is a path in the underlying graph of the game .",
    "a strategy for a player in a game is a recipe to specify how to extend the prefix of a play .",
    "formally , a strategy @xmath26 for player  1 is a function @xmath27 that takes a finite sequence of vertices @xmath28 ending in a player  1 vertex @xmath6 , where @xmath29 and @xmath30 , representing the history of the play so far , and specifies the next vertex @xmath31 choosing an out - going edge ( i.e. , @xmath32 .",
    "a strategy @xmath33 is defined analogously .",
    "we denote by @xmath34 and @xmath35 the set of all strategies for player  1 and player  2 , respectively .",
    "given strategies @xmath36 and @xmath37 for player  1 and player  2 , there is a unique play ( or a path ) @xmath38 such that ( a )  @xmath15 ; ( b )  for all @xmath39 , if @xmath40 , then @xmath41 ; and if @xmath42 , then @xmath43 .",
    "* controllably recurrent graphs and games . * along with general labeled graphs and games , we will also consider graphs and games that are _ controllably recurrent_. a labeled graph @xmath12 is _ controllably recurrent _ if for every vertex @xmath18 that is reachable from @xmath3 , there is a path starting from @xmath18 that reaches @xmath3 .",
    "a labeled game graph @xmath12 is _ controllably recurrent _ if for every vertex @xmath18 that is reachable from @xmath3 in the underlying graph , there is a strategy @xmath26 for player  1 such that against all player  2 strategies @xmath37 , the path starting from @xmath18 given the strategies @xmath26 and @xmath37 reaches @xmath3 .",
    "controllable recurrence models the natural requirement that systems under test are _ re - initializable _ , that is , from any reachable state of the system , there is always a way to bring the system back to its initial state no matter how the system behaves .    * the maximal coverage problem . *",
    "the _ maximal coverage problem _ asks whether at least @xmath44 different propositions can be visited .",
    "we now define the problem formally for graphs and games . given a path @xmath45 , let @xmath46 be the set of propositions that appear in @xmath13 .",
    "given a labeled graph @xmath12 and @xmath47 , the maximal coverage problem asks whether there is path @xmath13 such that @xmath48 . given a labeled game graph @xmath12 and @xmath47",
    ", the maximal coverage problem asks whether player  1 can ensure that at least @xmath44 propositions are visited , i.e. , whether @xmath49 such that for all player  2 strategies @xmath50 we have @xmath51 .    the maximal _ state coverage",
    "_ problem is the special case of the maximal coverage problem where @xmath52 and for each @xmath53 we have @xmath54 .",
    "that is , each state has its own label , and there are @xmath55 singleton partitions .",
    "* the coverage with bounded time problem . * the _ coverage with bounded time problem _ asks whether at least @xmath44 different propositions can be visited within @xmath56-steps .",
    "we now define the problem formally for graphs and games . given a path @xmath57 and @xmath58 , we denote by @xmath59 the prefix of the path of length @xmath60 , i.e. , @xmath61 . given a path @xmath57 and @xmath58 , we denote by @xmath62 . given a labeled graph @xmath12 and @xmath47 and @xmath63 , the coverage with bounded time problem asks whether there is path @xmath13 such that @xmath64 . given a labeled game graph @xmath12 and @xmath47",
    ", the maximal coverage problem asks whether player  1 can ensure that at least @xmath44 propositions are visited within @xmath56-steps , i.e. , whether @xmath49 such that for all player  2 strategies @xmath50 we have @xmath65 .",
    "* system - tester game . * a _ system _ @xmath66 consists of the following components :    * a finite set @xmath67 of states with the starting state @xmath68 . * a finite alphabet @xmath69 of input letters .",
    "* a transition relation @xmath70 . * a finite set of atomic propositions @xmath4 and a labeling function @xmath5 that assigns to each state @xmath71 the set of atomic propositions true at @xmath71 .",
    "we consider _ total _ systems such that for all @xmath72 and @xmath73 , there exists @xmath74 such that @xmath75 .",
    "a system is _ deterministic _ if for all @xmath72 and @xmath76 , there exists exactly one @xmath77 such that @xmath75 . the tester selects an input letter at every stage and the system resolves the non - determinism in transition to choose the successor state .",
    "the goal of the tester is to visit as many different propositions as possible .",
    "the interaction between the system and the tester can be reduced to a labeled game graph @xmath78 as follows :    * _ vertices and partition .",
    "_ @xmath79 ; @xmath80 and @xmath81 ; and @xmath82 .",
    "* _ edges .",
    "_ @xmath83 . * _ labeling . _ @xmath84 and @xmath85 .",
    "the coverage question for game between tester and system can be answered by answering the question in the game graph .",
    "also observe that if the system is deterministic , then for all player  2 vertices in the game graph , there is exactly one out - going edge , and hence the game can be reduced to a labeled graph . in this paper",
    "we will present all the results for the labeled graph and game model .",
    "all the upper bounds we provide follow also for the game between tester and system .",
    "all the lower bounds we present can also be easily adapted to the model of the game between system and tester .",
    "in this section we study the complexity of the maximal coverage problem . in subsection",
    "[ subsec : maxexpl : graphs ] we study the complexity for graphs , and in subsection  [ subsec : maxexpl : games ] we study the complexity for game graphs .",
    "we first show that the maximal coverage problem for labeled graphs is np - complete .",
    "[ thrm : maxexpl - graphs ] the maximal coverage problem for labeled graphs is np - complete .",
    "the proof consists of two parts .",
    "we present them below .    1 .   _ in np . _",
    "the maximal coverage problem is in np can be proved as follows . given a labeled game graph @xmath12 , let @xmath86 .",
    "we show first that if there is a path @xmath13 in @xmath12 such that @xmath48 , then there is a path @xmath87 in @xmath12 such that @xmath88 .",
    "if @xmath13 visits at least @xmath44 propositions , and there is a cycle in @xmath13 that does not visit a new proposition that is already visited in the prefix , then the cycle segment can be removed from @xmath13 and still the resulting path visits @xmath44 propositions .",
    "hence if the answer to the maximal coverage problem is `` yes '' , then there is a path @xmath87 of length at most @xmath89 that is a witness to the `` yes '' answer . since @xmath90",
    ", it follows that the problem is in np .",
    "_ np - hardness .",
    "_ now we show that the maximal coverage problem is np - hard , and we present a reduction from the sat - problem .",
    "consider a sat formula @xmath91 , and let @xmath92 be the set of variables and @xmath93 be the set of clauses .",
    "for a variable @xmath94 , let 1 .",
    "@xmath95 be the set of indices of the set of clauses @xmath96 that is satisfied if @xmath97 is set to be true ; and 2 .",
    "@xmath98 be the set of indices of the set of clauses @xmath96 that is satisfied if @xmath97 is set to be false .",
    "+ without loss of generality , we assume that @xmath99 and @xmath100 are non - empty for all @xmath101 ( this is because , for example , if @xmath102 , then we can set @xmath97 to be true and reduce the problem where the variable @xmath97 is not present ) . for a finite set @xmath103 of natural numbers , let @xmath104 and @xmath105 denote the maximum and minimum number of @xmath106 , respectively , for an element @xmath107 that is not the maximal element let @xmath108 denote the next highest element to @xmath109 that belongs to @xmath106 ; i.e. , ( a )  @xmath110 ; ( b )  @xmath111 ; and ( c )  if @xmath112 and @xmath113 , then @xmath114 .",
    "we construct a labeled game graph @xmath115 as follows .",
    "we first present an intuitive description : there are states labeled @xmath116 , and all of them are labeled by a single proposition .",
    "the state @xmath117 is an absorbing state ( state with a self - loop only ) , and all other @xmath118 state has two successors .",
    "the starting is @xmath119 . in every state @xmath118",
    "given the right choice we visit in a line a set of states that are labeled by clauses that are true if @xmath118 is true ; and given the left choice we visit in a line a set of states that are labeled by clauses that are true if @xmath118 is false ; and then we move to state @xmath120 .",
    "we now formally describe every component of the labeled graph @xmath121 .",
    "the set of vertices is @xmath122 there is a vertex for every variable , and a vertex @xmath117 .",
    "there is a vertex @xmath123 iff @xmath124 , and there is a vertex @xmath125 iff @xmath126 , 2 .",
    "the set of edges is @xmath127 we now explain the role if each set of edges .",
    "the first edge is the self - loop at @xmath117 .",
    "the second set of edges specifies that from @xmath128 the next vertex is @xmath129 and similarly , from @xmath130 the next vertex is again @xmath129 .",
    "the third set of edges specifies that from @xmath97 there are two successors that are @xmath123 and @xmath131 where @xmath132 and @xmath133 .",
    "the final sets of edges specifies ( a ) to move in a line from @xmath134 to visit the clauses that are satisfied by setting @xmath97 as true , and ( b ) to move in a line from @xmath135 to visit the clauses that are satisfied by setting @xmath97 as false .",
    "fig  [ fig : np - hardness ] gives a pictorial view of the reduction .",
    "3 .   the initial",
    "vertex is @xmath136 .",
    "@xmath137 , i.e. , there is a proposition @xmath138 for each clause @xmath138 and there is a proposition @xmath139 for all variables ; 5 .",
    "@xmath140 ; i.e. , every variable state is labeled by the proposition @xmath139 ; and we have @xmath141 and @xmath142 , i.e. , each state @xmath123 and @xmath125 is labeled by the corresponding clause that is indexes .",
    "+ the number of states in @xmath115 is @xmath143 , and the reduction is polynomial in @xmath91 . in this graph",
    "the maximal number of propositions visited is exactly equal to the maximal number of satisfiable clauses plus  1 ( since along with the propositions for clauses the proposition @xmath139 for all variables is always visited ) .",
    "the proof of the above claim is as follows .",
    "given a path @xmath13 in @xmath144 we construct an assignment @xmath145 for the variables as follows : if the choice at a vertex @xmath97 is @xmath134 , then we set @xmath97 as true in @xmath145 , else we set @xmath97 as false . hence if a path in @xmath115 visits a set @xmath146 of @xmath147 propositions , then the assignment @xmath145 satisfies @xmath148 clauses ( namely , @xmath149 )",
    "conversely , given an assignment @xmath145 of the variables , we construct a path @xmath150 in @xmath115 as follows : if @xmath97 is true in the assignment @xmath145 , then the path @xmath150 chooses @xmath134 at @xmath97 , otherwise , it chooses @xmath151 at @xmath97 .",
    "if @xmath145 satisfies a set @xmath67 of @xmath148 clauses , then @xmath150 visits @xmath152 propositions ( namely , the set @xmath153 of propositions ) .",
    "hence @xmath91 is satisfiable iff the answer to the maximal coverage problem with input @xmath115 and @xmath154 is true .",
    "the desired result follows .",
    "* hardness of approximation .",
    "* we note that from the proof theorem  [ thrm : maxexpl - graphs ] it follows that the max - sat problem ( i.e. , computing the maximal number of clauses satisfiable for a sat formula ) can be reduced to the problem of computing the exact number for the maximal coverage problem . from hardness of approximation of the max - sat problem  @xcite",
    ", it follows that the maximal coverage problem for labeled graphs is hard to approximate .",
    "the maximal coverage problem for labeled graphs that are controllably recurrent can be decided in ptime .    to solve the maximal coverage problem for labeled graphs that are controllably recurrent ,",
    "we compute the maximal strongly connected component @xmath155 that @xmath3 belongs to . since the graph is controllably recurrent , all states that are reachable from @xmath3 belong to @xmath155 .",
    "hence the answer to the maximal coverage problem is `` yes '' iff @xmath156 .",
    "the result follows .",
    "[ thrm : maxexpl - games ] the maximal coverage problem for labeled game graphs is pspace - complete .",
    "the proof consists of two parts .",
    "we present them below .    1 .",
    "_ in pspace .",
    "_ we argue that the maximal coverage problem for labeled game graph can be reduced to the coverage in bounded time problem .",
    "the reason is as follows : in a labeled game graph with @xmath157 vertices , if player  1 can visit @xmath44 propositions , then player  1 can visit @xmath44 propositions within at most @xmath158 steps ; because player  1 can always play a strategy from the current position that visits a new proposition that is not visited and never needs to go through a cycle without visiting a new proposition unless the maximal coverage is achieved .",
    "hence it follows that the maximal coverage problems for games reduces to the coverage in bounded time problem .",
    "the pspace inclusion will follow from the result of theorem  [ thrm : pspace - bouexpl ] where we show that the coverage in bounded time problem is in pspace .",
    "2 .   _ pspace - hardness . _",
    "the maximal coverage problem for game graphs is pspace - complete , even if the underlying graph is strongly connected .",
    "the proof is a reduction from qbf ( truth of quantified boolean formulas ) that is known to be pspace - complete  @xcite , and it is a modification of the reduction of theorem  [ thrm : maxexpl - graphs ] .",
    "consider a qbf formula @xmath159 defined on the set @xmath92 of variables , and @xmath93 are the clauses of the formula .",
    "we apply the reduction of theorem  [ thrm : maxexpl - graphs ] with the following modification to obtain the labeled game graph @xmath115 : the partition @xmath160 of @xmath161 is as follows . for a variable @xmath97",
    "if the quantifier before @xmath97 is existential , then @xmath162 ( i.e. , for existentially quantified variable , player  1 chooses the out - going edges denoting whether to set the variable true or false ) ; and for a variable @xmath97 if the quantifier before @xmath97 is universal , then @xmath163 ( i.e. , for universally quantified variable , the opposing player  2 chooses the out - going edges denoting whether to set the variable true or false ) .",
    "the state @xmath117 is a player  2 vertex , and all other vertex has an single out - going edges and can be player  1 state .",
    "given this game graph we have @xmath91 is true iff player  1 can ensure that all the propositions can be visited in @xmath164 .",
    "formally , let @xmath165 and @xmath166 denote the set of all strategies for player  1 and player  2 , respectively , in @xmath115 .",
    "then @xmath91 is true iff latexmath:[$\\sup_{{\\pi}_1 \\in { \\pi}_1^\\phi }    \\inf_{{\\pi}_2 \\in { \\pi}_2^\\phi }     observe that since @xmath117 is a player  2 state if we add an edge from @xmath117 to @xmath119 , player  2 will never choose the edge @xmath117 to @xmath119 ( since the objective for player  2 is to minimize the coverage ) .",
    "however , adding the edge from @xmath117 to @xmath119 makes the underlying graph strongly connected ( i.e. , the underlying graph of the game graph becomes controllably recurrent ; but player  1 does not have a strategy to ensure that @xmath119 is reached , so the game is not controllably recurrent ) .",
    "the desired result follows .",
    "* complexity of maximal coverage in controllably recurrent games .",
    "* we will now consider maximal coverage in controllably recurrent games .",
    "our analysis will use fixing memoryless _",
    "randomized _ strategy for player  1 , and fixing a memoryless randomized strategy in labeled game graph we get a labeled markov decision process ( mdp ) .",
    "a labeled mdp consists of the same components as a labeled game graph , and for vertices in @xmath24 ( which are randomized vertices in the mdp ) the successors are chosen uniformly at random ( i.e. , player  1 does not have a proper choice of the successor but chooses all of them uniformly at random ) .",
    "given a labeled game graph @xmath168 we denote by @xmath169 the mdp interpretation of @xmath12 where player  1 vertices chooses all successors uniformly at random .",
    "an _ end component _ in @xmath170 is a set @xmath171 of vertices such that ( i )  @xmath171 is strongly connected and ( ii )  @xmath171 is player  1 _ closed _",
    ", i.e. , for all @xmath172 , for all @xmath173 such that @xmath174 we have @xmath175 ( in other words , for all player  1 vertices , all the out - going edges are contained in @xmath171 ) .",
    "[ lemm - contr - mdp ] let @xmath12 be a labeled game graph and let @xmath169 be the mdp interpretation of @xmath12 . then the following assertions hold .    1 .",
    "let @xmath171 be an end - component in @xmath169 with @xmath176 .",
    "then @xmath177 .",
    "there exists an end - component @xmath178 with @xmath176 such that @xmath179 .",
    "we prove both the claims below .    1 .",
    "if @xmath171 is an end - component in @xmath170 , then consider a memoryless strategy @xmath50 for player  2 , that for all vertices @xmath180 , chooses a successor @xmath175 ( such a successor exists since @xmath171 is strongly connected ) .",
    "since @xmath171 is player  1 closed ( i.e. , for all player  1 out - going edges from @xmath171 , the end - point is in @xmath171 ) , it follows that for all strategies of player  1 , given the strategy @xmath50 for player  2 , the vertices visited in a play is contained in @xmath171 .",
    "the desired result follows .",
    "an optimal strategy @xmath181 for player  1 in @xmath12 is as follows :",
    "1 .   let @xmath182 and @xmath183 ; 2 .   at iteration @xmath184 ,",
    "let @xmath185 represents the set of propositions already visited .",
    "at iteration @xmath184 , player  1 plays a strategy to reach a state in @xmath186 ( if such a strategy exists ) , and then reaches back @xmath3 ( a strategy to reach back @xmath3 always exists since the game is controllably recurrent ) .",
    "3 .   if a new proposition @xmath187 is visited at iteration @xmath184 , then let @xmath188 .",
    "goto step ( b ) for @xmath189 iteration with @xmath190 .",
    "if no state in @xmath186 can be reached , then stop . + the strategy @xmath181 is optimal , and let the above iteration stop with @xmath191 .",
    "let @xmath192 , and let @xmath193 be the set of vertices such that player  1 can reach @xmath139 .",
    "let @xmath194 . then @xmath195 and player  2 can ensure that from @xmath3 the game can be confined to @xmath196 .",
    "hence the following conditions must hold : ( a )  for all @xmath197 , there exists @xmath198 such that @xmath174 ; and ( b )  for all @xmath199 , for all @xmath200 such that @xmath201 we have @xmath202 .",
    "consider the sub - graph @xmath203 where player  2 restricts itself to edges only in @xmath196 .",
    "a bottom maximal strongly connected component @xmath204 in the sub - graph is an end - component in @xmath169 , and we have @xmath205 it follows that @xmath171 is a witness end - component to prove the result .",
    "the desired result follows .",
    "[ thrm : maxexpl - contrgames ] the maximal coverage problem for labeled game graphs that are controallably recurrent is conp - complete .",
    "we prove the following two claims to establish the result .    1 .",
    "_ in conp .",
    "_ the fact that the problem is in conp can be proved using lemma  [ lemm - contr - mdp ] .",
    "given a labeled game graph @xmath12 , if the answer to the maximal coverage problem ( i.e. , whether @xmath206 ) is no , then by lemma  [ lemm - contr - mdp ] , there exists an end - component @xmath171 in @xmath169 such that @xmath207 .",
    "the witness end - component @xmath171 is a polynomial witness and it can be guessed and verified in polynomial time .",
    "the verification that @xmath171 is the correct witness is as follows : we check ( a )  @xmath171 is strongly connected ; ( b )  for all @xmath172 and for all @xmath200 such that @xmath174 we have @xmath208 ; and ( c )  @xmath209 .",
    "hence the result follows .",
    "2 .   _ conp hardness . _",
    "we prove hardness using a reduction from the complement of the _ vertex cover _ problem . given a graph @xmath210 , a set @xmath211 is a _ vertex cover _ if for all edges @xmath212 we have either @xmath213 or @xmath214 . given a graph @xmath215 whether there is a vertex cover @xmath171 of size at most @xmath44 ( i.e. , @xmath216 ) is np - complete  @xcite .",
    "we now present a reduction of the complement of the vertex cover problem to the maximal coverage problem in controallably recurrent games . given a graph @xmath210",
    "we construct a labeled game graph @xmath217 as follows .",
    "let the set @xmath2 of edges be enumerated as @xmath218 , i.e. , there are @xmath219 edges .",
    "the labeled game graph @xmath220 is as follows . 1 .",
    "_ vertex set and partition .",
    "_ the vertex set @xmath221 is as follows : @xmath222 all states in @xmath2 are player  2 states , and the other states are player  1 states , i.e. , @xmath223 , and @xmath224 .",
    "the set @xmath225 of edges are as follows : @xmath226 intuitively , the edges in the game graph are as follows : from the initial vertex @xmath3 , player  1 can choose any of the edges @xmath227 . for a vertex @xmath228 in @xmath221 ,",
    "player  2 can choose between two vertices @xmath229 and @xmath230 ( which will eventually represent the two end - points of the edge @xmath228 ) . from vertices of the form @xmath229 and @xmath230 , for @xmath231 , the next vertex is the initial vertex @xmath3 .",
    "it follows that from all vertex the game always comes back to @xmath3 and hence we have controllably recurrent game .",
    "3 .   _ propositions and labelling . _",
    "@xmath232 , i.e. , there is a proposition for every vertex in @xmath1 and a special proposition @xmath233 .",
    "the vertex @xmath3 and vertices in @xmath2 are labeled by the special proposition @xmath233 , i.e. , @xmath234 ; and for all @xmath227 we have @xmath235 . for a vertex @xmath236 ,",
    "let @xmath237 , where @xmath238 are vertices in @xmath1 , then @xmath239 and @xmath240 .",
    "note that the above proposition assignment ensures that at every vertex that represents an edge , player  2 has the choices of vertices that form the end - points of the edge .",
    "+ the following case analysis completes the proof . * given a vertex cover @xmath171 , consider a player  2 strategy , that at a vertex @xmath241 , choose a successor @xmath236 such that @xmath242 .",
    "the strategy for player  2 ensures that player  1 visits only propositions in @xmath243 , i.e. , at most @xmath244 propositions . *",
    "consider a strategy for player  1 that from @xmath3 visits all states @xmath245 in order .",
    "consider any counter - strategy for player  2 and let @xmath211 be the set of propositions other than @xmath233 visited .",
    "since all the edges are chosen , it follows that @xmath171 is a vertex cover .",
    "hence if all vertex cover in @xmath215 is of size at least @xmath44 , then player  1 can visit at least @xmath154 propositions .",
    "+ hence there is a vertex cover in @xmath215 of size at most @xmath44 if and only if the answer to the maximal coverage problem in @xmath12 with @xmath154 is no .",
    "it follows that the maximal coverage problem in controllably recurrent games is conp - hard .",
    "the desired result follows .",
    "* complexity of minimal safety games .",
    "* as a corollary of the proof of theorem  [ thrm : maxexpl - contrgames ] we obtain a complexity result about _ minimal safety games_. given a labeled game graph @xmath12 and @xmath44 , the minimal safety game problem asks , whether there exists a set @xmath171 such that a player can confine the game in @xmath171 and @xmath171 contains at most @xmath44 propositions .",
    "an easy consequence of the hardness proof of theorem  [ thrm : maxexpl - contrgames ] is minimal safety games are np - hard , and also it is easy to argue that minimal safety games are in np .",
    "hence we obtain that the minimal safety game problem is np - complete .",
    "in this section we study the complexity of the coverage in bounded time problem . in subsection",
    "[ subsec : bouexpl : graphs ] we study the complexity for graphs , and in subsection  [ subsec : bouexpl : games ] we study the complexity for game graphs .",
    "[ thrm : bouexpl - graphs ] the coverage in bounded time problem for both labeled graphs and controllably recurrent labeled graphs is np - complete .",
    "we prove the completeness result in two parts below .    1 .",
    "_ given a labeled graph with @xmath157 vertices , if there a path @xmath13 such that @xmath64 , then there is path @xmath87 such that @xmath246 .",
    "the above claim follows since any cycle that does not visit any new proposition can be omitted .",
    "hence a path of length @xmath247 can be guessed and it can be then checked in polynomial time if the path of length @xmath248 visits at least @xmath44 propositions . 2 .   _ in np - hard .",
    "_ we reduce the _ hamiltonian - path ( ham - path ) _  @xcite problem to the coverage in bounded time problem for labeled graphs . given a directed graph @xmath210 and an initial vertex @xmath6 , we consider the labeled graph @xmath12 with the directed graph @xmath215 , with @xmath6 as the initial state and @xmath249 and @xmath250 for all @xmath251 , i.e.",
    ", each vertex is labeled with an unique proposition .",
    "the answer to the coverage is bounded time with @xmath252 and @xmath253 , for @xmath86 is `` yes '' iff there is a ham - path in @xmath215 starting from @xmath6 .",
    "the desired result follows .    *",
    "complexity in size of the graph .",
    "* we now argue that the maximal coverage and the coverage in bounded time problem on labeled graphs can be solved in non - deterministic log - space in the size of the graph , and polynomial space in the size of the atomic propositions . given a labeled graph @xmath12 , with @xmath157 vertices",
    ", we argued in theorem  [ thrm : maxexpl - graphs ] that if @xmath44 propositions can be visited , then there is a path of length at most @xmath158 , that visits @xmath44 propositions .",
    "the path of length @xmath158 , can be visited , storing the current vertex , and guessing the next vertex , can checking the set of propositions already visited .",
    "hence this can be achieved in non - deterministic log - space in the size of the graph , and polynomial space in the size of the proposition set .",
    "a similar argument holds for the coverage in bounded time problem .",
    "this gives us the following result .",
    "[ thrm : nlogmaxexpl ] given a labeled graph @xmath254 , the maximal coverage problem and the coverage in bounded time problem can be decided in nlogspace in @xmath255 , and in pspace in @xmath256 .",
    "[ thrm : pspace - bouexpl ] the coverage in bounded time problem for labeled game graphs is pspace - complete .    we prove the following two cases to prove the result .    1 .   _ pspace - hardness_. it follows from the proof of theorem  [ thrm : maxexpl - games ] that the maximal coverage problem for labeled game graphs reduces to the coverage in bounded time problem for labeled game graphs .",
    "since the maximal coverage problem for labeled game graphs is pspace - hard ( theorem  [ thrm : maxexpl - games ] ) , the result follows .",
    "2 .   _ in pspace . _",
    "we say that an _ exploration game tree _ for a labeled game graph is a rooted , labeled tree which represents an unfolding of the graph .",
    "every node @xmath257 of the tree is labeled with a pair @xmath258 , where @xmath6 is a node of the game graph , and @xmath259 is the set of propositions that have been visited in a branch leading from the root of the tree to @xmath257 .",
    "the root of the tree is labeled with @xmath260 .",
    "a tree with label @xmath258 has one descendant for each @xmath261 with @xmath262 ; the label of the descendant is @xmath263 . + in order to check if @xmath44 different propositions can be visited within @xmath56-steps , the pspace algorithm traverses the game tree in depth first order .",
    "each branch is explored up to one of the two following conditions is met : ( i )  depth @xmath56 is reached , or ( ii )  a node is reached , which has the same label as an ancestor in the tree .",
    "the bottom nodes , where conditions ( i ) or ( ii ) are met , are thus the leaves of the tree .",
    "in the course of the traversal , the algorithm computes in bottom - up fashion the _ value _ of the tree nodes .",
    "the value of a leaf node labeled @xmath258 is @xmath264 . for player-1 nodes ,",
    "the value is the maximum of the values of the successors ; for player-2 nodes , the value is the minimum of the value of the successors .",
    "thus , the value of a tree node @xmath257 represents the minimum number of propositions that player  1 can ensure are visited , in the course of a play of the game that has followed a path from the root of the tree to @xmath257 , and that can last at most @xmath56 steps .",
    "the algorithm returns yes if the value at the root is at least @xmath44 , and no otherwise .",
    "+ to obtain the pspace bound , notice that if a node with label @xmath265 is an ancestor of a node with label @xmath266 in the tree , we have @xmath267 : thus , along a branch , the set of propositions appearing in the labels increases monotonically . between two increases , there can be at most @xmath268 nodes , due to the termination condition ( ii ) .",
    "thus , each branch needs to be traversed at most to depth @xmath269 , and the process requires only polynomial space .",
    "the result follows .",
    "[ thrm : bouexpl - contrgames ] the coverage in bounded time problem for labeled game graphs that are controllably recurrent is both np - hard and conp - hard , and can be decided in pspace .",
    "it follows from the ( pspace - inclusion ) argument of theorem  [ thrm : maxexpl - games ] that the maximal coverage problem for labeled game graphs that are controllably recurrent can be reduced to the coverage in bounded time problem for labeled game graphs that are controllably recurrent .",
    "hence the conp - hardness follows from theorem  [ thrm : maxexpl - contrgames ] , and the np - hardness follows from hardness in labeled graphs that are controllably recurrent ( theorem  [ thrm : bouexpl - graphs ] ) .",
    "the pspace - inclusion follows from the general case of labeled game graphs ( theorem  [ thrm : pspace - bouexpl ] ) .",
    "theorem  [ thrm : bouexpl - contrgames ] shows that for controllably recurrent game graphs , the coverage in bounded time problem is both np - hard and conp - hard , and can be decided in pspace .",
    "a tight complexity bound remains an open problem .",
    "* complexity in the size of the game . *",
    "the maximal coverage problem can alternately be solved in time linear in the size of the game graph and exponential in the number of propositions . given a game graph @xmath270 , construct the game graph @xmath271 where @xmath272 , @xmath273 iff @xmath274 and @xmath275 , @xmath276 for @xmath277 , @xmath278 , and @xmath279 .",
    "clearly , the size of the game graph @xmath203 is linear in @xmath215 and exponential in @xmath4 . now consider a reachability game on @xmath203 with the goal @xmath280 .",
    "player-1 wins this game iff the maximal coverage problem is true for @xmath215 and @xmath44 propositions . since",
    "a reachability game can be solved in time linear in the game , the result follows .",
    "a similar construction , where we additionally track the length of the game so far , shows that the maximal coverage problem with bounded time can be solved in time linear in the size of the game graph and exponential in the number of propositions .",
    "[ thrm : lintimemaxexpl ] given a labeled game graph @xmath168 the maximal coverage and the coverage in bounded time problem can be solved in linear - time in @xmath281 and in exponential time in @xmath256 .",
    "somewhat surprisingly , despite the central importance of graph coverage in system verification , several basic complexity questions have remained open .",
    "the basic setting of this paper on graphs and games can be extended in various directions , enabling the modeling of other system features .",
    "we mention two such directions .",
    "so far , we have assumed that at each step , the tester has complete information about the state of the system under test . in practice , this may not be true , and the tester might be able to observe only a part of the state .",
    "this leads to graphs and games of _ imperfect information _ @xcite .",
    "the maximal coverage and the coverage in bounded time problem for games of imperfect information can be solved in exptime .",
    "the algorithm first constructs a perfect - information game graph by subset construction  @xcite , and then run the algorithm of theorem  [ thrm : lintimemaxexpl ] , that is linear in the size game graph and exponential in the number of propositions , on the perfect - information game graph .",
    "thus , the complexity of this algorithm is exptime .",
    "the reachability problem for imperfect - information games is already exptime - hard @xcite , hence we obtain an optimal exptime - complete complexity .",
    "second , while we have studied the problem in the discrete , finite - state setting , similar questions can be studied for timed systems modeled as timed automata @xcite or timed game graphs @xcite .",
    "such problems would arise in the testing of real - time systems .",
    "we omit the standard definitions of timed automata and timed games .",
    "the maximal coverage problem for timed automata ( respectively , timed games ) takes as input a timed automaton @xmath282 ( respectively , a timed game @xmath282 ) , with the locations labeled by a set @xmath4 of propositions , and a number @xmath44 , and asks whether @xmath44 different propositions can be visited .",
    "an algorithm for the maximal coverage problem for timed automata constructs the region graph of the automaton  @xcite and runs the algorithm of theorem  [ thrm : nlogmaxexpl ] on the labeled region graph .",
    "this gives us a pspace algorithm .",
    "since the reachability problem for timed automata is pspace - hard , we obtain a pspace - complete complexity .",
    "similar result holds for the coverage in bounded time problem for timed automata .",
    "similarly , the maximal coverage and coverage in bounded time problem for timed games can be solved in exponential time by running the algorithm of theorem  [ thrm : lintimemaxexpl ] on the region game graph .",
    "this gives an exponential time algorithm .",
    "again , since game reachability on timed games is exptime - hard @xcite , we obtain that maximal coverage and coverage in bounded time in timed games is exptime - complete .",
    "e.  brinksma and j.  tretmans .",
    "testing transition systems : an annotated bibliography . in _",
    "movep 00 : modeling and verification of parallel processes _ ,",
    "volume 2067 of _ lecture notes in computer science _ , pages 187195 .",
    "springer , 2000 .",
    "o.  maler , a.  pnueli , and j.  sifakis . on the synthesis of discrete controllers for timed systems . in _ proc . of 12th annual symp . on theor .",
    "asp . of comp .",
    "_ , volume 900 of _ lect .",
    "notes in comp .",
    "_ springer - verlag , 1995 ."
  ],
  "abstract_text": [
    "<S> we study the problem of generating a test sequence that achieves maximal coverage for a reactive system under test . </S>",
    "<S> we formulate the problem as a repeated game between the tester and the system , where the system state space is partitioned according to some coverage criterion and the objective of the tester is to maximize the set of partitions ( or coverage goals ) visited during the game . </S>",
    "<S> we show the complexity of the maximal coverage problem for non - deterministic systems is pspace - complete , but is np - complete for deterministic systems . for the special case of non - deterministic systems with a re - initializing `` reset '' action , which represent running a new test input on a re - initialized system , </S>",
    "<S> we show that the complexity is again co - np - complete . </S>",
    "<S> our proof technique for reset games uses randomized testing strategies that circumvent the exponentially large memory requirement in the deterministic case . </S>"
  ]
}