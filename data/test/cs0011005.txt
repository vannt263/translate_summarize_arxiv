{
  "article_text": [
    "the never ending urge for faster and more robust computers , combined with the existence of cheap processors causes a proliferation of inexpensive multiprocessor machines .",
    "multithreaded applications are needed to exploit the full processing power of these machines , causing a widespread use of parallel applications .",
    "even most contemporary applications that are not cpu - intensive are multithreaded because the multithreaded paradigm makes it easier to develop servers , applications with an mdi ( _ multiple document interface _ ) such as windows programs , etc",
    ".    however , developing multithreaded programs for these machines is not easy as it is harder to get a good view on the state of a parallel program .",
    "this is caused by the fact that there are a number of threads threads executing on a machine with @xmath0 processors .",
    "] running simultaneously .",
    "moreover , the very fact that the computation is split into simultaneous parts can introduce errors that do not exist in sequential programs .",
    "these _ synchronisation errors _ show up because parallel programs are developed in order to let a number of threads work on the same problem , hence they will share data .",
    "it is of paramount importance that the accesses performed by the different threads are properly synchronised .",
    "too much synchronisation will deadlock the program , while a lack of synchronisation will lead to race conditions .",
    "such a _ race condition _ occurs when two or more concurrently executing threads access the same shared memory location in an unsynchronised way , and at least one of the threads modifies the contents of the location .",
    ".... # include < pthread.h >    unsigned global=5 ;    thread1 ( ) {    global = global+6 ; }    thread2 ( ) {    global = global+7 ; }    main ( ) {    pthread_t t1 , t2 ;      pthread_create(&t1 , null , thread1 , null ) ;    pthread_create(&t2 , null , thread2 , null ) ;      pthread_join(t1 , null ) ;    pthread_join(t2 , null ) ; }                            ....    the program depicted in figure  [ sol - vb ] is an example of a program containing a race condition .",
    "the program uses a shared global variable ( global ) , initialised with value 5 .",
    "the first thread ( main ) starts two additional threads , t1 and t2 , executing respectively the functions thread1 and thread2 .",
    "both threads change the global variable .",
    "as the threads do not synchronise , the final value of global will be 18 , 11 or 12 .",
    "the latter two are the result of one of the threads overwriting the new value written by the other thread .",
    "as race conditions are ( most of the time ) considered bugs , they should be removed .",
    "unfortunately , race conditions are difficult to find because their occurrence depends on small timing variations .",
    "although it is possible to detect race conditions using a static approach ( using source code analysis , as done by @xcite ) this is not feasible for nontrivial programs ( it has been shown that detecting race conditions statically is an np complete problem for programs that use synchronisation that is powerful enough to implement mutual exclusion @xcite ) .",
    "therefore , most race detection tools detect race conditions dynamically during an actual program execution .    in this paper , we present and describe @xcite , a tool that detects data races ( data races are harmful race conditions",
    "; see next section ) dynamically .",
    "was implemented for the solaris operating system running on sun multiprocessors with sparc processors . during the test phase of , we have found data races in several programs we tested ( including the splash-2 suite  @xcite , and the athapascan system  @xcite ) .",
    "all of the races that were reported were genuine data races that had stayed undetected until then .    in the next section ,",
    "we start with a few definitions about race conditions followed by a description of data race detection techniques .",
    "the section ends with an overview of our method .",
    "the next section describes our implementation .",
    "this part is followed by an evaluation section containing performance data .",
    "the paper is concluded with an overview of related work .",
    "a _ race condition _ occurs when two threads access the same shared location in an unsynchronised way and at least one access modifies the value at the location .",
    "we distinguish two types of race conditions : race conditions that are used to make a program intentionally nondeterministic : _ synchronisation races _ , and race conditions that were not intended by the programmer ( _ data races _ ) .",
    "we need _ synchronisation races _ to allow for competition between threads to enter a critical section , to lock a semaphore , or to implement load balancing .",
    "removing synchronisation races makes a program completely deterministic .",
    "therefore , in this paper , we do not consider synchronisation races a programming error , but a functional and useful characteristic of a parallel program .",
    "_ data races _ are not intended by the programmer , and are most of the time the result of improper synchronisation . by changing the synchronisation , data races can ( and should )",
    "always be removed .",
    "it is important to notice that the distinction between a data race and a synchronisation race is actually a pure matter of abstraction . at the implementation level of the synchronisation operations ,",
    "a synchronisation race is caused by a genuine data race ( e.g. , spin locks , polling , etc . ) on a synchronisation variable .",
    "if the programmer creates his / her own synchronisation operations , we also have to make a distinction between _ feasible _ races and _ apparent _ races . the difference between them",
    "can be intuitively understood from the following example .    [ cols=\"<,<\",options=\"header \" , ]",
    "table  [ exp3 ] shows why the overhead of recording an execution is limited to about 2% .",
    "this is because rolt effectively succeeds in creating small trace files .",
    "the disk bandwidth needed to store the trace is never bigger than 4 kb / s , which is very low on modern machines . on the average ,",
    "we only need to store about 2.3 bits per synchronisation operation .",
    "although much theoretical work has been done in the field of data race detection  @xcite few implementations for general systems have been proposed .",
    "tools proposed in the past had limited capabilities : they were targeted at programs using one semaphore  @xcite , programs using only post / wait synchronisation  @xcite or programs with nested fork - join parallelism  @xcite .",
    "the tools that come closest to our data race detection mechanism , apart from @xcite for a proprietary system , is an on - the - fly data race detection mechanism for the cvm ( concurrent virtual machine ) system  @xcite .",
    "the tool only instruments the memory references to distributed shared data ( about 1% of all references ) and is unable to perform reference identification : it will return the variable that was involved in a data race , but not the instructions that are responsible for the reference .",
    "race frontier  @xcite describes a similar technique as the one proposed in this paper ( replaying up to the first data race ) .",
    "choi and min prove that it is possible to replay up to the first data race , and they describe how one can replay up to the race frontier .",
    "a problem they do not solve is how to efficiently find the race frontier .",
    "effectively solves the problem of finding the race frontier , but goes beyond this .",
    "it also finds the cause of the data race .",
    "most of the previous work , and also our  tool , is based on lamport s _ happened - before _ relation .",
    "this relation is a partial order on all synchronisation events in a particular parallel _",
    "execution_. therefore , by checking the ordering of all events and monitoring all memory accesses , data races can be detected for one _ particular program execution_.    another approach is taken by a more recent race detector : eraser  @xcite .",
    "it goes slightly beyond work based on the happened - before relation .",
    "eraser checks that a _ locking discipline _ is used to access shared variables : for each variable it keeps a list of locks that were held while accessing the variable . each time",
    "a variable is accessed , the list attached to the variable is intersected with the list of locks currently held and the intersection is attached to the variable . if this list becomes empty , the locking discipline is violated , meaning that a data race occurred .",
    "unfortunately , eraser detects many false data races : as eraser is not based on the happened - before relation it has no timing information whatsoever .",
    "for instance , in theory there is no need to synchronise shared variables before multiple threads are created .",
    "the happens - before relation deals in a natural way with the fact that threads can not execute code ` before ' they have been created but eraser needs special heuristics to support these kind of unlocked accesses .",
    "the support for initialisation makes eraser _ dependent _ on the scheduling order and therefore requires also the checking of all possible executions for each possible input .",
    "the most important problem with eraser is however that its practical applicability is limited as it can only process mutex synchronisation operations and the tool fails when other synchronisation primitives are built on top of these lock operations .    these problems with eraser makes us believe that methods based on the happens - before relation ( like ) are better .",
    "contrary to eraser , it can only detect data races that show up in a particular program run , but it is more general in that it knows how to deal with all common synchronisation operations .",
    "furthermore , it is more reliable because it never reports false data races .",
    "in this paper , we have presented , a practical and effective tool for detecting data races in parallel executions .",
    "therefore , we implemented a highly efficient two - level record / replay system that traces the synchronisation operations , and uses this trace to replay the execution . during replay",
    ", a race detection algorithm is run to notify the programmer when a race occurs . as such",
    ", synchronisation races are replayed while deta races are detected .",
    "using snooped matrix clocks and multilevel bitmaps , we were able to limit the memory consumption .",
    "works on running processes , and is therefore completely independent of any compiler or programming language . moreover , recompiling or relinking the application is not required .",
    "michiel ronsse is sponsored by a goa project ( 12050895 ) from ghent university .",
    "koen de bosschere is a research associate with the fund for scientific research  flanders .",
    "k.  audenaert and l.  levrouw .",
    "space efficient data race detection for parallel programs with series - parallel task graphs . in _ proceedings of the third euromicro workshop on parallel and distributed processing _ , pages 508515 , san remo , january 1995 .",
    "ieee computer society press .",
    "jong - deok choi and sang  lyul min .",
    "race frontier : reproducing data races in parallel - program debugging . in _ proc . of the third acm sigplan symposium on principles & practice of parallel programming _ ,",
    "volume  26 , pages 145154 , july 1991 .",
    "koen de  bosschere and michiel ronsse .",
    "clock snooping and its application in on - the - fly data race detection . in _ proceedings of the 1997 international symposium on parallel algorithms and networks ( i - span97 ) _ , pages 324330 , taipei ,",
    "december 1997 .",
    "ieee computer society .",
    "luk  j. levrouw , koenraad  m. audenaert , and jan  m. van campenhout . a new trace and replay system for shared memory programs based on lamport clocks . in _ proceedings of the second euromicro workshop on parallel and distributed processing _ , pages 471478 . ieee computer society press , january 1994 .",
    "friedemann mattern .",
    "virtual time and global states of distributed systems . in cosnard ,",
    "quinton , raynal , and roberts , editors , _ proceedings of the intl .",
    "workshop on parallel and distributed algorithms _ , pages 215226 .",
    "elsevier science publishers b.v . , north - holland , 1989 .",
    "m.  ronsse and l.  levrouw . on the implementation of a replay mechanism . in l.",
    "bouge , p.  fraigniaud , a.  mignotte , and y.  robert , editors , _ proceedings of europar  96 _ , volume 1123 of _ lncs _ , pages 7073 .",
    "springer - verlag , lyon , august 1996 .",
    "m.  ronsse , l.  levrouw , and k.  bastiaens .",
    "efficient coding of execution - traces of parallel programs . in j.",
    "p.  veen , editor , _ proceedings of the prorisc / ieee benelux workshop on circuits , systems and signal processing _",
    ", pages 251258 .",
    "stw , utrecht , march 1995 .",
    "michiel ronsse and koen de  bosschere . .",
    "in e.  dhollander , f.j .",
    "joubert , and u.  trottenberg , editors , _ proceedings of parco97 : parallel computing : fundamentals , applications and new directions _ , volume  12 of _ advances in parallel computing _ , pages 327334 , bonn , february 1998 .",
    "north holland .",
    "steven  cameron woo , moriyosho ohara , evan torrie , jaswinder  pal singh , and anoop gupta .",
    "the splash-2 programs : characterization and methodological considerations . in _ proc . of the 22nd annual international symposium on computer architecture _ , pages 2436 , june 1995 ."
  ],
  "abstract_text": [
    "<S> this paper presents a practical solution for detecting data races in parallel programs . </S>",
    "<S> the solution consists of a combination of execution replay ( ) with automatic on - the - fly data race detection . </S>",
    "<S> this combination enables us to perform the data race detection on an unaltered execution ( almost no probe effect ) . </S>",
    "<S> furthermore , the usage of multilevel bitmaps and snooped matrix clocks limits the amount of memory used . as the record phase of  </S>",
    "<S> is highly efficient , there is no need to switch it off , hereby eliminating the possibility of heisenbugs because tracing can be left on all the time . </S>"
  ]
}