{
  "article_text": [
    "the minimum - cost flow ( mcf ) problem is a well - studied problem with many applications , for example , modeling transportation and communication networks  @xcite . over the last half century",
    "many algorithms have been developed to solve it .",
    "the first algorithms proposed in the 1960s were all pseudo - polynomial .",
    "these include the out - of - kilter algorithm by minty  @xcite and by fulkerson  @xcite , the cycle canceling algorithm by klein  @xcite , the network simplex ( ns ) algorithm by dantzig  @xcite , and the successive shortest path ( ssp ) algorithm by jewell  @xcite , iri  @xcite , and busacker and gowen  @xcite . in 1972",
    "edmonds and karp  @xcite proposed the capacity scaling algorithm , which was the first polynomial mcf algorithm . in the 1980s",
    "the first strongly polynomial algorithms were developed by tardos  @xcite and by orlin  @xcite .",
    "later , several more strongly polynomial algorithms were proposed such as the minimum - mean cycle canceling ( mmcc ) algorithm by goldberg and tarjan  @xcite and the enhanced capacity scaling algorithm by orlin  @xcite , which currently has the best worst - case running time . for a more complete overview of the history of mcf algorithms",
    "we refer to ahuja et al .",
    "@xcite .    when we compare the performance of several mcf algorithms in theory and in practice , we see that the algorithms that have good worst - case bounds on their running time are not always the ones that perform best in practice .",
    "zadeh  @xcite showed that there exist instances for which the network simplex ( ns ) algorithm has exponential running time , while the minimum - mean cycle canceling ( mmcc ) algorithm runs in strongly polynomial time , as shown by goldberg and tarjan  @xcite . in practice however , the relative performance of these algorithms is completely different .",
    "kovcs  @xcite showed in an experimental study that the ns algorithm is much faster than the mmcc algorithm on practical instances .",
    "in fact , the ns algorithm is even the fastest mcf algorithm of all .",
    "an explanation for the fact that the ns algorithm performs much better in practice than indicated by its worst - case running time is that the instances for which it needs exponential time are very contrived and unlikely to occur in practice . to better understand the differences between worst - case and practical performance for the ns algorithm and the mmcc algorithm",
    ", we analyze these algorithms in the framework of smoothed analysis .    smoothed analysis was introduced by spielman and teng  @xcite to explain why the simplex algorithm usually needs only a polynomial number of iterations in practice , while in the worst case it needs an exponential number of iterations . in the framework of smoothed analysis",
    ", an adversary can specify any instance and this instance is then slightly perturbed before it is used as input for the algorithm .",
    "this perturbation can model , for example , measurement errors or numerical imprecision .",
    "in addition , it can model noise on the input that can not be quantified exactly , but for which there is no reason to assume that it is adversarial .",
    "algorithms that have a good smoothed running time often perform well in practice .",
    "we refer to two surveys  @xcite for a summary of results that have been obtained using smoothed analysis .",
    "we consider a slightly more general model of smoothed analysis , introduced by beier and vcking  @xcite . in this model",
    "the adversary can not only specify the mean of the noisy parameter , but also the type of noise .",
    "we use the following smoothed input model for the mcf problem .",
    "an adversary can specify the structure of the flow network including all nodes and edges , and also the exact edge capacities and budgets of the nodes .",
    "however , the adversary can not specify the edge costs exactly .",
    "for each edge @xmath8 the adversary can specify a probability density @xmath9\\rightarrow [ 0,\\phi]$ ] according to which the cost of @xmath8 is drawn at random .",
    "the parameter @xmath3 determines the maximum density of the density function and can therefore be interpreted as the power of the adversary .",
    "if @xmath3 is large , the adversary can very accurately specify each edge cost and we approach worst - case analysis . if @xmath10 , the adversary has no choice but to specify the uniform density on the interval @xmath11 $ ] and we have average - case analysis .",
    "brunsch et al .",
    "@xcite were the first to show smoothed bounds on the running time of an mcf algorithm .",
    "they showed that the ssp algorithm needs @xmath12 iterations in expectation and has smoothed running time @xmath13 , since each iteration consists of finding a shortest path .",
    "they also provide a lower bound of @xmath14 for the number of iterations that the ssp algorithm needs , which is tight for @xmath15 .",
    "these bounds show that the ssp algorithm needs only a polynomial number of iterations in the smoothed setting , in contrast to the exponential number it needs in the worst case , and explains why the ssp algorithm performs quite well in practice . in order to fairly compare the ssp algorithm with other mcf algorithms in the smoothed setting , we need smoothed bounds on the running times of these other algorithms .",
    "brunsch et al .",
    "@xcite asked particularly for smoothed running time bounds for the mmcc algorithm , since the mmcc algorithm has a much better worst - case running time than the ssp algorithm , but performs worse in practice .",
    "it is also interesting to have smoothed bounds for the ns algorithm , since the ns algorithm is the fastest mcf algorithm in practice .",
    "however , until now no smoothed bounds were known for other mcf algorithms . in this paper",
    "we provide smoothed lower and upper bounds for the mmcc algorithm , and a smoothed lower bound for the ns algorithm .    for the mmcc algorithm we provide an upper bound ( section  [ ubmmcc ] ) for the expected number of iterations that the mmcc algorithm needs of @xmath0 . for dense graphs ,",
    "this is an improvement over the @xmath16 iterations that the mmcc algorithm needs in the worst case , if we consider @xmath3 a constant ( which is reasonable if it models , for example , numerical imprecision or measurement errors ) .",
    "we also provide a lower bound ( section  [ lbconstantphi ] ) on the number of iterations that the mmcc algorithm needs . for every @xmath1 , every @xmath17 , and every @xmath18",
    ", we provide an instance with @xmath19 nodes and @xmath20 edges for which the mmcc algorithm requires @xmath4 iterations . for @xmath21 we can improve our lower bound ( section  [ lbbigphi ] ) .",
    "we show that for every @xmath22 and every @xmath17 , there exists an instance with @xmath19 nodes and @xmath20 edges , and @xmath6 , for which the mmcc algorithm requires @xmath5 iterations .",
    "this is indeed a stronger lower bound than the bound for general @xmath3 , since we have @xmath23 for @xmath6 .    for the ns algorithm we provide a lower bound ( section  [ lbns ] ) on the number of non - degenerate iterations that it requires .",
    "in particular , we show that for every @xmath1 , every @xmath24 , and every @xmath25 there exists a flow network with @xmath19 nodes and @xmath20 edges , and an initial spanning tree structure for which the ns algorithm needs @xmath26 non - degenerate iterations with probability @xmath27 .",
    "the existence of an upper bound is our main open problem .",
    "note that our bound is the same as the lower bound that brunsch et al .",
    "@xcite found for the smoothed number of iterations of the ssp algorithm .",
    "this is no coincidence , since we use essentially the same instance ( with some minor changes ) to show our lower bound .",
    "we show that with the proper choice of the initial spanning tree structure for the ns algorithm , we can ensure that the ns algorithm performs the same flow augmentations as the ssp algorithm and therefore needs the same number of iterations ( plus some degenerate ones ) .",
    "in the rest of our introduction we introduce the mcf problem , the mmcc algorithm and the ns algorithm in more detail . in the rest of our paper ,",
    "all logarithms are base @xmath28 .",
    "a _ flow network _ is a simple directed graph @xmath29 together with a nonnegative capacity function @xmath30 defined on the edges . for convenience ,",
    "we assume that @xmath31 is connected and that @xmath32 does not contain a pair @xmath33 and @xmath34 of reverse edges . for the mcf problem",
    ", we also have a cost function @xmath35 $ ] on the edges and a budget function @xmath36 on the nodes .",
    "nodes with negative budget require a resource , while nodes with positive budget offer it .",
    "@xmath37 is a nonnegative function on the edges that satisfies the capacity constraints , @xmath38 ( for all @xmath39 ) , and flow conservation constraints @xmath40 ( for all @xmath41 ) .",
    "the cost @xmath42 of a flow @xmath43 is defined as the sum of the flow on each edge times the cost of that edge , that is , @xmath44 .",
    "the objective of the minimum - cost flow problem is to find a flow of minimum cost or conclude that no feasible flow exists .    in our analysis",
    "we often use the concept of a _ residual network _ , which we define here . for an edge @xmath45",
    "we denote the reverse edge @xmath34 by @xmath46 . for flow network @xmath31 and flow @xmath43 , the residual network @xmath47 is defined as the graph @xmath48 . here",
    "@xmath49 is the set of _ forward edges _ with capacity @xmath50 and cost @xmath51 .",
    "@xmath52 is the set of _ backward edges _ with capacity @xmath53 and cost @xmath54 . here",
    "@xmath55 is also called the _ residual capacity _ of edge @xmath8 for flow @xmath43 .      the mmcc algorithm works as follows :    * first we find a feasible flow using any maximum - flow algorithm . *",
    "next , as long as the residual network contains cycles of negative total cost , we find a cycle of minimum - mean cost and maximally augment flow along this cycle .",
    "* we stop when the residual network does not contain any cycles of negative total cost .    for a more elaborate description of the mmcc algorithm",
    ", we refer to korte and vygen  @xcite . in the following",
    ", we denote the mean cost of a cycle @xmath56 by @xmath57 .",
    "also , for any flow @xmath43 , we denote the mean cost of the cycle of minimum - mean cost in the residual network @xmath47 by @xmath58 .",
    "goldberg and tarjan  @xcite proved in 1989 that the minimum - mean - cycle canceling algorithm runs in strongly polynomial time .",
    "five years later radzik and goldberg  @xcite slightly improved this bound on the running time and showed that it is tight . in the following",
    "we will focus on the number of iterations the mmcc algorithm needs , that is , the number of cycles that have to be canceled .",
    "a bound on the number of iterations can easily be extended to a bound on the running time , by noting that a minimum - mean cycle can be found in @xmath59 time , as shown by karp  @xcite .",
    "the tight bound on the number of iterations that the mmcc algorithm needs is as follows .",
    "[ strponbound ] the number of iterations needed by the mmcc algorithm is bounded by @xmath60 and this bound is tight .    to prove our smoothed bounds in the next sections , we use another result by korte and vygen  ( * ? ? ?",
    "* corollary  9.9 ) which states that the absolute value of the mean cost of the cycle that is canceled by the mmcc algorithm , @xmath61 , decreases by at least a factor @xmath62 every @xmath63 iterations .",
    "[ logbound ] every @xmath63 iterations of the mmcc algorithm , @xmath61 decreases by at least a factor @xmath62 .",
    "the network simplex ( ns ) algorithm starts with an initial spanning tree structure @xmath64 and associated flow @xmath43 , where each edge in @xmath32 is assigned to exactly one of @xmath65 , @xmath66 , and @xmath67 , and it holds that    * @xmath68 for all edges @xmath69 , * @xmath70 for all edges @xmath71 , * @xmath38 for all edges @xmath72 , * the edges of @xmath65 form a spanning tree of @xmath31 ( if we consider the undirected version of both the edges of @xmath65 and the graph @xmath31 )",
    ".    if the mcf problem has a feasible solution , such a structure can always be found by first finding any feasible flow and then augmenting flow along cycles consisting of only edges that have a positive amount of flow less than their capacity , until no such cycles remain .",
    "note that the structure @xmath64 uniquely determines the flow @xmath43 , since the edges in @xmath65 form a tree .",
    "in addition to the spanning tree structure , the ns algorithm also keeps track of a set of node potentials @xmath73 for all nodes @xmath41 .",
    "the node potentials are defined such that the potential of a specified root node is @xmath74 and that the potential for other nodes is such that the reduced cost @xmath75 of an edge @xmath33 equals @xmath74 for all edges @xmath76 .    in each iteration , the ns algorithm tries to improve the current flow by adding an edge to @xmath65 that violates its optimality condition .",
    "an edge in @xmath66 violates its optimality condition if it has strictly negative reduced cost , while an edge in @xmath67 violates its optimality condition if it has strictly positive reduced cost .",
    "one of the edges @xmath8 that violates its optimality condition is added to @xmath65 , which creates a unique cycle @xmath56 in @xmath65 .",
    "flow is maximally augmented along @xmath56 , until the flow on one of the edges @xmath77 becomes @xmath74 or reaches its capacity .",
    "the edge @xmath78 leaves @xmath65 , after which @xmath65 is again a spanning tree of @xmath31 .",
    "next we update the sets @xmath65 , @xmath66 , and @xmath67 , the flow and the node potentials .",
    "this completes the iteration .",
    "if any edges violating their optimality condition remain , another iteration is performed .",
    "one iteration of the ns algorithm is also called a pivot .",
    "the edge @xmath8 that is added to @xmath65 is called the entering edge and the edge @xmath78 that leaves @xmath65 is called the leaving edge .",
    "note that in some cases the entering edge can be the same edge as the leaving edge .",
    "also , if one of the edges in the cycle @xmath56 already contains flow equal to its capacity , the flow is not changed in that iteration , but the spanning tree @xmath65 still changes .",
    "such an iteration we call degenerate .",
    "note that in each iteration , there can be multiple edges violating their optimality condition .",
    "there are multiple possible pivot rules that determine which edge enters @xmath65 in this case . in our analysis",
    "we use the ( widely used in practice ) pivot rule that selects as the entering edge , from all edges violating their optimality condition , the edge for which the absolute value of its reduced cost @xmath79 is maximum . in case multiple edges in @xmath56 are candidates to be the leaving edge , we choose the one that is most convenient for our analysis .    if a strongly feasible spanning tree structure  @xcite is used , it can be shown that the number of iterations that the ns algorithm needs is finite",
    ". however , zadeh  @xcite showed that there exist instances for which the ns algorithm ( with the pivot rule stated above ) needs an exponential number of iterations .",
    "orlin  @xcite developed a strongly polynomial version of the ns algorithm , which uses cost - scaling .",
    "however , this algorithm is rarely used in practice and we will not consider it in the rest of our paper . for a more elaborate discussion of the ns algorithm",
    "we refer to ahuja et al .",
    "in this section we show an upper bound of @xmath0 for the expected number of iterations that the mmcc algorithm needs starting from the initial residual network @xmath80 for the feasible starting flow @xmath81 for flow network @xmath29 .",
    "note that we assumed in section  [ intromcf ] that @xmath31 is simple and that @xmath32 does not contain a pair @xmath33 and @xmath34 of reverse edges .",
    "this implies that for each pair of nodes @xmath82 , there is always at most one edge from @xmath83 to @xmath84 and at most one edge from @xmath84 to @xmath83 in any residual network @xmath47 .",
    "we first show that the number of cycles that appears in at least one residual network @xmath47 for a feasible flow @xmath43 on @xmath31 , is bounded by @xmath85 , where @xmath86 .",
    "[ numcycles ] the total number of cycles that appears in any residual network @xmath47 for a feasible flow @xmath43 on @xmath31 , is bounded by @xmath85 .    first we show that the number of directed cycles of length @xmath87 ( @xmath88 ) is bounded by @xmath89 .",
    "we identify each cycle @xmath56 of length @xmath87 with a path @xmath90 of length @xmath87 starting and ending at the same arbitrarily chosen node of @xmath56 and then following the edges of @xmath56 in the direction of their orientation .",
    "every such path @xmath90 can be identified with a unique cycle .",
    "the number @xmath91 of possible paths of length @xmath87 is bounded by @xmath92    the first inequality of equation   follows since there are at most @xmath1 possible choices for the first node of the path , at most @xmath93 choices for the second node , etc .",
    "the lemma follows by observing that the number of possible lengths of cycles in residual networks @xmath47 is bounded by @xmath94 .",
    "we next show that the probability that any particular cycle has negative mean cost close to @xmath74 can be bounded . in the rest of this section , @xmath95 .",
    "[ probsmallcost ] the probability that an arbitrary cycle @xmath56 has mean cost @xmath96 can be bounded by @xmath97 .",
    "we can only have @xmath96 if @xmath98 , since @xmath56 consists of at most @xmath1 edges .",
    "we now draw the costs for all edges in @xmath56 except for the cost of one edge @xmath8 .",
    "the cost of cycle @xmath56 depends linearly on the cost of edge @xmath8 , with coefficient @xmath27 if @xmath8 is a forward edge in @xmath56 and coefficient @xmath99 if @xmath8 is a reverse edge in @xmath56 . therefore , the width of the interval from which the cost of @xmath8 must be drawn such that @xmath98 is @xmath100 . since the density function according to which the cost of @xmath8 is drawn has maximum density @xmath3 ,",
    "the probability that the cost of @xmath8 is drawn from this interval is at most @xmath97 .",
    "[ probsmallcostallcycles ] the probability that there exists a cycle @xmath56 with @xmath96 is at most @xmath101 .",
    "the corollary follows directly from lemma  [ numcycles ] and lemma  [ probsmallcost ] .",
    "[ linknumitmeancyclecosts ] if none of the residual networks @xmath47 for feasible flows",
    "@xmath43 on @xmath31 contain a cycle @xmath56 with @xmath96 , then the mmcc algorithm needs at most @xmath102 iterations .",
    "assume to the contrary that none of the residual networks @xmath47 for feasible flows",
    "@xmath43 on @xmath31 contain a cycle @xmath56 with @xmath96 , but the mmcc algorithm needs more than @xmath102 iterations .",
    "let @xmath81 denote the starting flow found using any maximum - flow algorithm .",
    "since all edge costs are drawn from the interval @xmath11 $ ] , we have that @xmath103 . according to theorem  [ logbound ] , after @xmath102 iterations",
    "we have that for the current flow @xmath104 holds that @xmath105 .",
    "now either @xmath106 contradicting the assumption that the mmcc algorithm needs more than @xmath102 iterations , or @xmath107 contradicting the assumption that none of the residual networks @xmath47 for feasible flows",
    "@xmath43 on @xmath31 contain a cycle @xmath56 with @xmath96 .",
    "the expected number of iterations that the mmcc algorithm needs is at most @xmath0 .",
    "let @xmath65 be the expected number of iterations that the mmcc algorithm needs .",
    "we have    @xmath108    here equation   follows from lemma  [ linknumitmeancyclecosts ] .",
    "equation   follows by bounding the probability for the first @xmath109 terms of the summation by @xmath27 and the probability for the other terms using corollary  .",
    "finally , equation   follows from the inequality @xmath110 , which holds for @xmath111 .",
    "in this section we describe a construction that , for every @xmath1 , every @xmath17 , and every @xmath18 , provides an instance with @xmath19 nodes and @xmath20 edges for which the mmcc algorithm requires @xmath4 iterations . for simplicity",
    "we describe the initial residual network @xmath31 , which occurs after a flow satisfying all the budgets has been found , but before the first minimum - mean cycle has been canceled . for completeness",
    ", we will explain at the end of the description of @xmath31 how to choose the initial network , budgets , and starting flow such that @xmath31 is the first residual network .",
    "we now describe how to construct @xmath31 given @xmath1 , @xmath2 , and @xmath3 . in the following , we assume @xmath112 .",
    "if @xmath3 is smaller than @xmath113 , the lower bound on the number of iterations reduces to @xmath114 and a trivial instance with @xmath19 nodes and @xmath20 edges will require @xmath114 iterations .",
    "we define @xmath115 and @xmath116 .",
    "note that this implies that @xmath117 or @xmath118 .",
    "for the edge costs we define intervals from which the edge costs are drawn uniformly at random .",
    "we define @xmath119 as follows ( see figure  [ lbconstruction ] ) .",
    "* @xmath120 , where @xmath121 , @xmath122 , @xmath123 , and @xmath124 .",
    "* @xmath125 . *",
    "@xmath126 is an arbitrary subset of @xmath127 of cardinality @xmath2 .",
    "each edge @xmath128 has capacity @xmath27 and cost interval @xmath129 $ ] .",
    "* @xmath130 contains the edges @xmath131 , @xmath132 contains the edges @xmath133 , @xmath134 contains the edges @xmath135 , and @xmath136 contains the edges @xmath137 ( @xmath138 ) .",
    "all these edges have infinite capacity and cost interval @xmath129 $ ] .",
    "* @xmath139 contains the edges @xmath140 and @xmath141 ( @xmath142 . an edge @xmath140 has capacity @xmath2 and cost interval @xmath129 $ ] . an edge @xmath141 has capacity @xmath2 and cost interval @xmath143 $ ] . *",
    "@xmath144 contains the edges @xmath145 and @xmath146 ( @xmath147 . an edge @xmath145 has capacity @xmath2 and cost interval @xmath129 $ ] . an edge @xmath146 has capacity @xmath2 and cost interval @xmath148 $ ] .",
    "note that all cost intervals have width @xmath149 and therefore correspond to valid probability densities for the edge costs , since the costs are drawn uniformly at random from these intervals .",
    "the edges of the types @xmath141 and @xmath146 have a cost interval that corresponds to negative edge costs .",
    "the residual network with these negative edge costs can be obtained by having the following original instance ( before computing a flow satisfying the budget requirements ) : all nodes , edges , costs and capacities are the same as in @xmath31 , except that instead of the edges of type @xmath141 we have edges @xmath150 with capacity @xmath2 and cost interval @xmath151 $ ] and instead of the edges of type @xmath146 we have edges @xmath152 with capacity @xmath2 and cost interval @xmath153 $ ] .",
    "in addition , node @xmath154 has budget @xmath155 , node @xmath156 has budget @xmath157 , the nodes of the types @xmath158 and @xmath159 have budget @xmath160 and all other nodes have budget @xmath74 .",
    "if we now choose as the initial feasible flow the flow that sends @xmath2 units from @xmath154 to each node of type @xmath158 and from @xmath156 to each node of type @xmath159 then we obtain the initial residual network @xmath31 .",
    "we now show that the mmcc algorithm needs @xmath4 iterations for the initial residual network @xmath31 .",
    "first we make some basic observations .",
    "the minimum - mean cycle @xmath56 never contains the path @xmath161 if the path @xmath162 has positive residual capacity for some @xmath163 , since the mean cost of @xmath56 can be improved by substituting @xmath164 by @xmath165 in @xmath56 .",
    "analogously , @xmath56 never contains the path @xmath166 if the path @xmath167 has positive residual capacity for some @xmath163 .",
    "also , since all cycles considered have mean cost strictly less than @xmath149 , cycles will never include more edges with cost at least @xmath168 than necessary .",
    "in addition , since the edges of type @xmath141 and @xmath146 are saturated in the order cheapest to most expensive , none of these edges will ever be included in reverse direction in the minimum - mean cycle .",
    "the above observations lead to three candidate types for the minimum - mean cycle : cycles of type @xmath169 , of type @xmath170 , and of type @xmath171 . here",
    "@xmath83 and @xmath84 are arbitrary nodes in @xmath67 and @xmath172 , respectively . in the following series of lemmas we compare the mean costs of these cycle types . here",
    "@xmath83 and @xmath84 are again arbitrary nodes in @xmath67 and @xmath172 , possibly different for the cycles that are compared . in our computations",
    "we always assume worst - case realization of the edge costs , that is , if we want to show that a cycle @xmath173 has lower mean cost than a cycle @xmath174 , we assume that all edges in @xmath173 take the highest cost in their cost interval , while all edges in @xmath174 take the lowest cost in their cost interval ( an edge that appears in both @xmath173 and @xmath174 can even take its highest cost in @xmath173 and its lowest cost in @xmath174 in the analysis ) .",
    "[ adbc ] the cycle @xmath175 has lower mean cost than the cycle @xmath176 .",
    "since the cycles have equal length , we can compare their total costs instead of their mean costs .",
    "we have @xmath177 here the second inequality holds since @xmath178 .",
    "[ bcadiplus1 ] the cycle @xmath179 has lower mean cost than the cycle @xmath180 .",
    "since the cycles have equal length , we can compare their total costs instead of their mean costs .",
    "we have @xmath181 here the second inequality holds since @xmath182 .",
    "[ adcycle ] the cycle @xmath183 has lower mean cost than the cycle @xmath184 .",
    "we have @xmath185 here the second inequality holds since @xmath178 .",
    "[ bccycle ] the cycle @xmath179 has lower mean cost than the cycle @xmath186 .",
    "we have @xmath187 here the second inequality holds since @xmath182 .",
    "the above observations and lemmas allow us to determine the number of iterations that the mmcc algorithm needs for residual network @xmath31 .",
    "[ lowerboundg ] the mmcc algorithm needs @xmath188 iterations for residual network @xmath31 , independent of the realization of the edge costs .",
    "for the first iteration only cycles of the types @xmath169 and @xmath189 are available .",
    "according to lemma  [ adcycle ] , all cycles of type @xmath169 have lower mean costs than all cycles of type @xmath189 and therefore the first iteration will augment along a cycle of type @xmath169 .",
    "after the first iteration , an edge from @xmath172 to @xmath67 will become available , and therefore a cycle of the type @xmath170 . according to lemma  [ adbc ]",
    "this cycle has higher mean cost than cycles of the type @xmath169 however , and therefore the first @xmath2 iterations will be of the type @xmath169 .",
    "after the first @xmath2 iterations , the edge @xmath190 , the edge @xmath191 , and all edges in @xmath126 will be saturated .",
    "the available cycle types are now @xmath170 and @xmath192 .",
    "according to lemma  [ bccycle ] , all cycles of type @xmath170 have lower mean cost than all cycles of type @xmath192 .",
    "the next iteration will therefore augment along a cycle of type @xmath170 .",
    "after this iteration , an edge from @xmath67 to @xmath172 becomes available and therefore a cycle of type @xmath193 , but according to lemma  [ bcadiplus1 ] all cycles of type @xmath170 have lower mean cost than cycles of type @xmath193 and therefore in iterations @xmath194 the mmcc algorithm augments along cycles of type @xmath170 .",
    "after @xmath195 iterations , we obtain @xmath31 , except that now edges @xmath190 , @xmath191 , @xmath196 , and @xmath197 are saturated and that there is some flow on the infinite capacity edges of the types @xmath131 , @xmath133 , @xmath135 , and @xmath137",
    ". the mmcc algorithm will keep augmenting among @xmath2 cycles of type @xmath169 followed by @xmath2 cycles of type @xmath170 until all edges of types @xmath141 and @xmath146 are saturated and no negative cost cycles remain .",
    "the total number of iterations the mmcc algorithm needs is therefore @xmath188 .",
    "the instance @xmath31 and theorem  [ lowerboundg ] allow us to state a lower bound on the number of iterations that the mmcc algorithm needs in the smoothed setting .    for every @xmath1 , every @xmath17 , and every @xmath18",
    ", there exists an instance with @xmath19 nodes and @xmath20 edges for which the mmcc algorithm requires @xmath4 iterations , independent of the realization of the edge costs .    follows directly from the instance @xmath31 , theorem  [ lowerboundg ] and the definition of @xmath198 and @xmath199 .",
    "for which the mmcc algorithm needs @xmath200 iterations for @xmath201 , @xmath202 , and @xmath203 .",
    "next to the edges are the approximate edge costs.,scaledwidth=70.0% ]      in section  [ lbconstantphi ] we considered the setting where @xmath3 does not depend on @xmath1 . in this setting",
    "we showed that the mmcc algorithm needs @xmath4 iterations .",
    "we can improve the lower bound if @xmath3 is much larger than @xmath1 . in this section",
    "we consider the case where @xmath21 .",
    "in particular , we show that for every @xmath22 and every @xmath204 there exists an instance with @xmath19 nodes , @xmath20 edges , and @xmath6 for which the mmcc algorithm needs @xmath5 iterations .",
    "the initial residual network @xmath205 that we use to show our bound is very similar to the initial residual network @xmath31 that was used to show the bound in section  [ lbconstantphi ] . below we describe the differences ( see figure  [ lbconstructionbigphi ] for an illustration ) .",
    "we set @xmath206 .",
    "the constant of @xmath207 is large , but for the sake of readability and ease of calculations we did not try to optimize it .    *",
    "the node set @xmath208 now consists of @xmath1 nodes @xmath209 and the node set @xmath91 now consists of @xmath1 nodes @xmath210 . * node @xmath154 is split into two nodes @xmath211 and @xmath212 . from node",
    "@xmath211 to @xmath212 there is a directed path consisting of @xmath1 edges , all with infinite capacity and cost interval @xmath129 $ ] .",
    "edges @xmath131 are replaced by edges @xmath213 with infinite capacity and cost interval @xmath129 $ ] .",
    "edges @xmath141 are replaced by edges @xmath214 with capacity @xmath2 and cost interval @xmath215 $ ] .",
    "* node @xmath156 is split into two nodes @xmath216 and @xmath217 . from node @xmath216 to @xmath217 there is a directed path consisting of @xmath1 edges , all with infinite capacity and cost interval @xmath129 $ ] .",
    "edges @xmath135 are replaced by edges @xmath218 with infinite capacity and cost interval @xmath129 $ ] .",
    "edges @xmath146 are replaced by edges @xmath219 with capacity @xmath2 and cost interval @xmath220 $ ] .",
    "note that this is a valid choice of cost intervals for the edges @xmath214 and @xmath219 and that they all have negative costs , since @xmath221 is the most expensive of them and we have    @xmath222    as in section  [ lbconstantphi ] , there are three candidate types for the minimum - mean cost cycle : cycles of type @xmath223 , cycles of type @xmath224 , and cycles of type @xmath225 .",
    "again we assume worst - case realizations of the edge costs and compare the mean costs of cycles of the different types in a series of lemmas .",
    "[ adbcbigphi ] the cycle @xmath175 has lower mean cost than the cycle @xmath176 .",
    "since the cycles have equal length , we can compare their total costs instead of their mean costs .",
    "we have @xmath226 here the second inequality holds since @xmath227 and @xmath228 for @xmath22 .",
    "[ bcadiplus1bigphi ] the cycle @xmath179 has lower mean cost than the cycle @xmath180 .",
    "since the cycles have equal length , we can compare their total costs instead of their mean costs .",
    "we have @xmath229 here the second inequality holds since @xmath230 and @xmath228 for @xmath22 .",
    "[ adcyclebigphi ] the cycle @xmath183 has lower mean cost than the cycle @xmath184 .",
    "we have @xmath231 here the second inequality holds since @xmath227 and @xmath228 for @xmath22 .",
    "[ bccyclebigphi ] the cycle @xmath179 has lower mean cost than the cycle @xmath186 .",
    "we have @xmath232 here the second inequality holds since @xmath230 and @xmath228 for @xmath22 .",
    "the above lemmas allow us to determine the number of iterations that the mmcc algorithm needs for initial residual network @xmath205 .",
    "[ lowerboundh ] the mmcc algorithm needs @xmath233 iterations for initial residual network @xmath205 , independent of the realization of the edge costs .",
    "the proof is similar to the proof of theorem  [ lowerboundg ] .",
    "since cycles of type @xmath169 have lower mean cost than both cycles of type @xmath170 and of type @xmath189 according to lemma  [ adbcbigphi ] and lemma  [ adcyclebigphi ] , the first @xmath2 iterations will augment flow along cycles of type @xmath169 .",
    "after these @xmath2 iterations , edges @xmath190 and @xmath234 are saturated and the edges in @xmath126 have positive residual capacity only in the direction from @xmath172 to @xmath67 .",
    "since cycles of type @xmath170 have lower mean cost than both cycles of type @xmath193 and cycles of type @xmath192 according to lemma  [ bcadiplus1bigphi ] and lemma  [ bccyclebigphi ] , the next @xmath2 iterations will augment flow along cycles of type @xmath170 .",
    "after the first @xmath195 iterations , the residual network is the same as @xmath205 , except that edges @xmath190 , @xmath234 , @xmath196 , and @xmath235 are saturated and there is some flow on several edges of infinite capacity .",
    "the mmcc algorithm will keep augmenting along @xmath2 cycles of type @xmath169 followed by @xmath2 cycles of type @xmath170 , until all edges of type @xmath214 and type @xmath219 are saturated . at this point",
    "no negative cycles remain in the residual network and the mmcc algorithm terminates after @xmath233 iterations .",
    "initial residual network @xmath205 and theorem  [ lowerboundh ] allow us to state a lower bound for the number of iterations that the mmcc algorithm needs in the smoothed setting for large @xmath3 .    for every @xmath22 and every @xmath17",
    ", there exists an instance with @xmath19 nodes and @xmath20 edges , and @xmath6 , for which the mmcc algorithm requires @xmath5 iterations , independent of the realization of the edge costs",
    ".    follows directly from the instance @xmath205 and theorem  [ lowerboundh ] .",
    "for which the mmcc algorithm needs @xmath5 iterations for @xmath201 , @xmath202 , and @xmath206 .",
    "next to the edges are the approximate edge costs.,scaledwidth=70.0% ]",
    "in this section we provide a lower bound of @xmath26 for the number of iterations that the network simplex ( ns ) algorithm requires in the setting of smoothed analysis .",
    "the instance of the minimum - cost flow problem that we use to show this lower bound is very similar to the instance used by brunsch et al .",
    "@xcite to show a lower bound on the number of iterations that the successive shortest path algorithm needs in the smoothed setting .",
    "the differences are that they scaled their edge costs by a factor of @xmath3 , which we do not , that we add an extra path from node @xmath236 to node @xmath237 , and that the budgets of the nodes are defined slightly differently . for completeness , we describe the construction of the ( slightly adapted ) instance by brunsch et al .  below .",
    "for a more elaborate description of the instance , we refer to the original paper . in the following",
    "we assume that all paths from @xmath236 to @xmath237 have pairwise different costs , which holds with probability 1 , since the edge costs are drawn from continuous probability distributions .    for given positive integers  @xmath1 , @xmath24 , and @xmath25 let @xmath238 and @xmath239 .",
    "like brunsch et al .",
    "we assume that @xmath112 , which implies @xmath240 .",
    "we construct a flow network with @xmath19 nodes , @xmath20 edges , and smoothing parameter @xmath3 for which the ns algorithm needs @xmath241 iterations . the construction of the flow network @xmath31 that we use to show our lower bound consists of three steps .",
    "first we define a flow network @xmath242 .",
    "next we describe how to obtain flow network @xmath243 from flow network @xmath244 . finally , we construct @xmath31 using @xmath245 . as before ,",
    "we give an interval of width at least @xmath149 for each edge from which its costs are drawn uniformly at random .",
    "[ [ construction - ofg_1 . ] ] construction of  @xmath242 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for the first step , consider two sets @xmath246 and @xmath247 of  @xmath1 nodes and an arbitrary set @xmath248 containing exactly @xmath249 edges .",
    "the initial flow network  @xmath242 is defined as @xmath250 for @xmath251 and @xmath252 the edges  @xmath8 from  @xmath253 have capacity  @xmath27 and costs from the interval @xmath254 $ ] .",
    "the edges @xmath255 have capacity equal to the out - degree of  @xmath256 , the edges @xmath257 have capacity equal to the in - degree of @xmath258 and both have costs from the interval @xmath259 $ ] ( see figure  [ g1 ] ) .     with @xmath260 and @xmath261 with capacities different from 1 shown next to the edges and the cost intervals shown below each edge set .",
    "dashed edges are in the initial spanning tree for the network simplex algorithm , while solid edges are not.,scaledwidth=70.0% ]    [ [ construction - ofg_i1-fromg_i . ] ] construction of  @xmath243 from  @xmath262 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    now we describe the second step of our construction . given a flow network @xmath263 , we define @xmath264 , where @xmath265 and @xmath266 let  @xmath267 be the value of the maximum @xmath268-@xmath269 flow in the graph  @xmath262 .",
    "the new edges @xmath270 have capacity @xmath271 and costs from the interval @xmath259 $ ] .",
    "the new edges @xmath272 also have capacity @xmath271 , but costs from the interval @xmath273 $ ] ( see figure  [ giplus1 ] ) .     with @xmath262 as sub - graph with edge costs next to the edges .",
    "dashed edges are in the initial spanning tree for the network simplex algorithm , while solid edges are not.,scaledwidth=70.0% ]    [ [ construction - ofg - fromg_k . ] ] construction of  @xmath31 from  @xmath245 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    let @xmath274 be the value of a maximum @xmath275-@xmath276 flow in @xmath245 .",
    "we will now use @xmath245 to define @xmath29 as follows ( see also figure  [ gnetworksimplex ] ) .    * @xmath277 , with @xmath278 , @xmath279 , @xmath280 , @xmath281 , and @xmath282 . * @xmath283 .",
    "* @xmath130 contains the edges @xmath284 , @xmath285 , with cost interval @xmath286 $ ] and infinite capacity ; @xmath287 , @xmath288 , with cost interval @xmath289 $ ] and capacity @xmath274 ; and @xmath290 with cost interval @xmath291 $ ] and infinite capacity .",
    "* @xmath132 contains the edges @xmath292 , @xmath285 , with cost interval @xmath286 $ ] and infinite capacity ; @xmath293 , @xmath288 , with cost interval @xmath289 $ ] and capacity @xmath274 ; and @xmath294 with cost interval @xmath286 $ ] and infinite capacity . *",
    "@xmath134 contains the edges @xmath295 , @xmath285 , with cost interval @xmath286 $ ] and infinite capacity ; @xmath296 , @xmath288 , with cost interval @xmath289 $ ] and capacity @xmath274 ; and @xmath297 with cost interval @xmath286 $ ] and infinite capacity . *",
    "@xmath136 contains the edges @xmath298 , @xmath285 , with cost interval @xmath286 $ ] and infinite capacity ; @xmath299 , @xmath288 , with cost interval @xmath289 $ ] and capacity @xmath274 ; and @xmath300 with cost interval @xmath291 $ ] and infinite capacity . *",
    "@xmath301 contains the edges @xmath302 , @xmath303 , with cost interval @xmath286 $ ] and infinite capacity ; @xmath304 , with cost interval @xmath286 $ ] and infinite capacity ; and @xmath305 with cost interval @xmath286 $ ] and infinite capacity .     with @xmath245 as sub - graph with approximate edge costs next to the edges .",
    "dashed edges are in the initial spanning tree for the network simplex algorithm , while solid edges are not.,scaledwidth=100.0% ]    the budgets of all nodes are @xmath74 , except for node @xmath236 and @xmath237 , which have budgets @xmath306 and @xmath307 .",
    "we choose as the initial spanning tree @xmath65 for the ns algorithm the edges    * @xmath308 ( @xmath138 ) and @xmath309 ( @xmath138 ) , * @xmath310 ( @xmath311 ) and @xmath312 ( @xmath311 ) , * @xmath313 , @xmath284 ( @xmath314 ) , and @xmath290 , * @xmath297 and @xmath315 ( @xmath314 ) , * @xmath292 ( @xmath314 ) and @xmath294 , * @xmath316 , @xmath300 , and @xmath317 ( @xmath314 ) , * @xmath304 , @xmath318 ( @xmath319 ) , and @xmath305 .",
    "( see figure  [ g1 ] , figure  [ giplus1 ] , and figure  [ gnetworksimplex ] ) .",
    "in addition , @xmath320 and @xmath321 .",
    "spanning tree structure @xmath322 corresponds to the flow that sends @xmath323 units of flow on the path @xmath324 and does not send any flow on other edges .    to prove our lower bound on the number of iterations that the ns algorithm needs for flow network @xmath31 , we link the iterations of the ns algorithm to the iterations of the successive shortest path ( ssp ) algorithm for flow network @xmath205 , where @xmath205 is obtained from @xmath31 by removing all nodes @xmath325 ( @xmath326 ) and all their incident edges . as shown by brunsch et al .",
    "* theorem 23 ) , the ssp algorithm needs @xmath26 iterations for @xmath205 .",
    "we show that each non - degenerate iteration of the ns algorithm on @xmath31 corresponds with an iteration of the ssp algorithm on @xmath205 and that therefore the ns algorithm needs @xmath26 iterations for flow network @xmath31 as well . in our analysis",
    "we use many results on the costs of paths in @xmath205 by brunsch et al .",
    "we will not prove these results again , but refer to the original paper .",
    "we now first observe that path @xmath324 is the most expensive path from @xmath236 to @xmath237 in @xmath31 . since paths from @xmath275 to @xmath276 have cost less than @xmath327  ( * ? ? ?",
    "* lemma 21 ) , the most expensive @xmath328 paths that do not use the nodes @xmath325 are @xmath329 and @xmath330 .",
    "both those paths have the same distribution for their costs .",
    "if we arbitrarily choose path @xmath329 and compare its cost with the cost of path @xmath324 , assuming worst case edge cost realizations , we have @xmath331 by the definition of @xmath87 and @xmath332 and @xmath112 , which shows that path @xmath324 is the most expensive path from @xmath236 to @xmath237 in @xmath31 .",
    "since @xmath324 is the most expensive @xmath328 path , we can obtain a negative cycle @xmath56 by combining the reverse edges of @xmath324 with the edges of another @xmath328 path @xmath90 .",
    "clearly , the cheaper @xmath90 is , the cheaper is @xmath56 .",
    "in addition , if all edges of @xmath56 except for one edge @xmath333 are in the current spanning tree @xmath334 , then edge @xmath333 has reduced cost equal to the cost of @xmath56 , since all edges in @xmath334 have reduced cost @xmath74 . using these two observations",
    ", we can conclude that as long as all negative cycles that can be formed using edges in the current spanning tree @xmath334 plus one edge outside of @xmath334 that has positive residual capacity in the current residual network consist of path @xmath335 plus an @xmath328 path @xmath90 , then the ns algorithm with the most negative edge pivot rule will pivot on the edge that together with the edges in @xmath334 forms the cheapest @xmath328 path .",
    "brunsch et al .",
    "@xcite showed that the ssp algorithm encounters @xmath323 paths on @xmath205 .",
    "let @xmath336 be the paths encountered on @xmath205 by the ssp algorithm , ordered from cheapest to most expensive .",
    "we refer the reader to the paper of brunsch et al .  for a description of these paths . in the following",
    "we show that in the @xmath337 non - degenerate iteration of the ns algorithm on @xmath31 , flow is sent along cycle @xmath338 .",
    "we will not provide all the calculations needed to compare the reduced cost of the candidate edges for addition to the spanning tree in each iteration , but it can be checked by tedious computation that the claimed edge is indeed the one with lowest reduced cost .",
    "if flow is sent over one of the edges in @xmath253 , that edge is always a candidate leaving edge , since edges in @xmath253 have capacity 1 and all other capacities are integral . for simplicity",
    "we assume that in cases where multiple edges in the cycle become saturated simultaneously by the flow augmentation , it is always the edge from @xmath253 that leaves the spanning tree .    in the first iteration of the ns algorithm on @xmath31 ,",
    "all edges in @xmath253 have negative reduced cost and positive residual capacity , and the edge @xmath339 that together with the starting spanning tree @xmath65 contains path @xmath340 is added to @xmath65 , flow is augmented along cycle @xmath341 , and @xmath339 becomes saturated and leaves @xmath65 again .",
    "for the second iteration , edge @xmath339 is saturated and therefore the edge that together with @xmath65 contains @xmath342 will be added to @xmath65 .",
    "this will continue for the first @xmath2 iterations .    at this point ,",
    "the cheapest @xmath328 path using edges in @xmath65 plus one edge with positive residual capacity is the path that is obtained by using either edge @xmath343 or edge @xmath344 ( depending on the realization of the edge costs ) .",
    "the next two iterations will therefore be degenerate .",
    "in one of these iterations @xmath343 is added to the spanning tree , but edge @xmath345 is saturated , prevents any flow being sent along the cycle , and is therefore removed from the spanning tree . in the other iteration @xmath344 is added to the spanning tree and @xmath346 is removed .",
    "after these two iterations the edges in @xmath253 become eligible for augmenting flow in the reverse direction and the next @xmath2 iterations augment flow along the cycles @xmath347 , @xmath348 , @xmath349 .",
    "analogously to the above , every time an edge @xmath350 gets saturated , two degenerate iterations take place in which edges @xmath351 and @xmath352 are added to the spanning tree .",
    "this allows flow to be sent through @xmath262 in reverse direction , that is , from @xmath269 to @xmath268 .",
    "similarly , every time an edge @xmath353 ( that is , the reverse edge of an original edge @xmath351 ) in the residual network gets saturated , two degenerate iterations take place in which edges @xmath354 and @xmath310 are added to the spanning tree .",
    "after @xmath274 iterations , there are no paths with positive residual capacity from @xmath275 to @xmath276 . at this point",
    "another two degenerate iterations take place . in one of them",
    "edge @xmath355 is added to the spanning tree , but no flow is sent since @xmath313 has zero residual capacity and therefore @xmath313 leaves the spanning tree . in the other iteration @xmath356",
    "is added to the spanning tree and @xmath299 leaves .",
    "now the edges in @xmath253 can be added to the spanning tree again and flow is augmented along them in reverse direction during the next @xmath2 iterations .",
    "in particular , in the next iteration flow is augmented along cycle @xmath357 .",
    "analogously to the above , every time an edge @xmath287 gets saturated , two degenerate iterations take place . in one of them",
    "@xmath296 enters the spanning tree and @xmath287 leaves . in the other",
    "@xmath293 enters the spanning tree and @xmath316 leaves .",
    "also , every time an edge @xmath293 gets saturated , two degenerate iterations take place . in one of them",
    "@xmath358 enters the spanning tree and @xmath293 leaves . in the other",
    "@xmath359 enters the spanning tree and @xmath296 leaves .",
    "finally , after @xmath323 iterations none of the edges not in the spanning tree has both negative reduced cost and positive residual capacity and therefore the ns algorithm terminates . from the above discussion",
    "we can conclude that the ns algorithm on @xmath31 needs @xmath323 non - degenerate iterations plus several degenerate ones .",
    "[ networksimplexg ] for flow network @xmath31 and initial spanning tree structure @xmath322 , the ns algorithm needs @xmath323 non - degenerate iterations with probability @xmath27",
    ".    follows immediately from the discussion above .",
    "theorem  [ networksimplexg ] provides a lower bound for the number of iterations that the ns algorithm needs in the smoothed setting .    for every @xmath1 , every @xmath24 , and every @xmath25",
    "there exists a flow network with @xmath19 nodes and @xmath20 edges , and an initial spanning tree structure for which the network simplex algorithm needs @xmath26 non - degenerate iterations with probability @xmath27",
    ".    follows directly from theorem  [ networksimplexg ] and the definition of @xmath332 and @xmath274 .",
    "in section  [ lbns ] we showed a smoothed lower bound of @xmath26 for the number of iterations that the ns algorithm needs .",
    "this bound is the same as the smoothed lower bound that brunsch et al .",
    "@xcite showed for the ssp algorithm .",
    "for the ssp algorithm this lower bound is even tight in case @xmath360 .",
    "still , the ns algorithm is usually much faster in practice than the ssp algorithm .",
    "we believe that the reason for this difference is that the time needed per iteration is much less for the ns algorithm than for the ssp algorithm . in practical implementations ,",
    "the entering edge is usually picked from a small subset ( for example of size @xmath361 ) of the edges , which removes the necessity of scanning all edges for the edge which maximally violates its optimality conditions .",
    "also , the spanning tree structure allows for fast updating of the flow and node potentials , in particular when the flow changes on only a small fraction of the edges . for the ssp algorithm",
    "an iteration consists of finding a shortest path , which takes @xmath362 time .",
    "the experimental results of kovcs  @xcite seem to support this claim , since on all test instances the ssp algorithm is slower than the ns algorithm , but never more than a factor @xmath2 . to allow a better comparison of the ssp algorithm and the ns algorithm in the smoothed setting",
    ", it would be useful to have a smoothed upper bound on the running time of the ns algorithm .",
    "finding such an upper bound is our main open problem .",
    "there is a gap between our smoothed lower bound of @xmath4 ( section  [ lbconstantphi ] ) for the number of iterations that the mmcc algorithm requires and our smoothed upper bound of @xmath0 . since our lower bound for the mmcc algorithm is weaker than the lower bound for the ssp algorithm , while the mmcc algorithm performs worse on practical instances than the ssp algorithm , we believe that our lower bound for the mmcc algorithm can be strengthened .",
    "our stronger lower bound of @xmath5 in case @xmath21 ( section  [ lbbigphi ] ) is another indication that this is likely possible .",
    "tobias brunsch , kamiel cornelissen , bodo manthey , heiko rglin , and clemens rsner . smoothed analysis of the successive shortest path algorithm .",
    "computing research repository 1501.05493 [ cs.ds ] , arxiv , 2015 .",
    "preliminary version at soda 2013 .                                james  b. orlin .",
    "genuinely polynomial simplex and non - simplex algorithms for the minimum cost flow problem .",
    "technical report , sloan school of management , mit , cambridge , ma , 1984 .",
    "technical report no .",
    "1615 - 84 ."
  ],
  "abstract_text": [
    "<S> the minimum - cost flow ( mcf ) problem is a fundamental optimization problem with many applications and seems to be well understood . over the last half century </S>",
    "<S> many algorithms have been developed to solve the mcf problem and these algorithms have varying worst - case bounds on their running time . </S>",
    "<S> however , these worst - case bounds are not always a good indication of the algorithms performance in practice . the network simplex ( ns ) </S>",
    "<S> algorithm needs an exponential number of iterations for some instances , but it is considered the best algorithm in practice and performs best in experimental studies . on the other hand , </S>",
    "<S> the minimum - mean cycle canceling ( mmcc ) algorithm is strongly polynomial , but performs badly in experimental studies .    to explain these differences in performance in practice we apply the framework of smoothed analysis . </S>",
    "<S> we show an upper bound of @xmath0 for the number of iterations of the mmcc algorithm . here </S>",
    "<S> @xmath1 is the number of nodes , @xmath2 is the number of edges , and @xmath3 is a parameter limiting the degree to which the edge costs are perturbed . </S>",
    "<S> we also show a lower bound of @xmath4 for the number of iterations of the mmcc algorithm , which can be strengthened to @xmath5 when @xmath6 . for the number of iterations of the ns algorithm </S>",
    "<S> we show a smoothed lower bound of @xmath7 . </S>"
  ]
}