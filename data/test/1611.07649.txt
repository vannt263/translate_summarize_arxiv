{
  "article_text": [
    "the architectures for big data systems rely on parallel execution techniques like mapreduce @xcite for fast processing . with the growing popularity of real - time data processing in big data environments ,",
    "there is a pressing need to re - imagine the traditional computing techniques .",
    "for example , data locality in popular big data system distributions like hadoop @xcite and spark @xcite is redefined as bringing compute to data instead of the traditional approach of the moving the data that needs to get processed .",
    "this trend of re - inventing the traditional methods do not necessarily transform to the security needs of big data .",
    "the security features implemented in big data systems are still based on traditional methods for systems based on general purpose machines .",
    "user authentication , multi - level data access control and logging are typically used for security in big data @xcite .",
    "data encryption is slowly being adopted in the big data field , but it is limited by big data properties like volume and velocity . as we covered in our previous work @xcite , big data security is premature and there is a lot of scope for improvement in this area .",
    "for instance , the current security standards for big data systems assume system - level consistency which is not necessarily true always .",
    "we demonstrated in our previous work @xcite that big data platforms can be affected by insider attacks . in this work ,",
    "we concentrate on detecting process - level intrusions within big data systems",
    ".    intrusion detection systems ( ids ) can identify malicious use based on their knowledge of possible threats or by learning from the behavior of programs .",
    "knowledge - based ids usually search a program for known threat signatures that are stored in a database . with new and zero - day attacks emerging regularly , it is impractical to have a pre - populated database of all possible threats . even if it is assumed to have such a database , maintaining it would require a lot of resources and running search queries against it would be expensive .",
    "behavior based ids tries to model , analyze and compare application behavior to identify anomalies .",
    "this technique needs more resources and is more complex than signature - based ids but it is more effective in a dynamically changing threat environment .",
    "behavior based ids generally use statistics and rules to detect anomalies .",
    "figure [ fig_tax ] gives a taxonomy of the different types of ids .",
    "in today s internet age , a distributed implementation of ids is needed for which aggregation , communication and cooperation are key factors of success .",
    "distributed ids gives centralized control and detects behavioral patterns even in large networks but it has to be employed at multiple levels : host , network and data @xcite .",
    "hence , using big data in general - purpose distributed ids implementations is recommended for faster processing . in this work ,",
    "we concentrate on ids that can be used for security within big data systems .",
    "ids within a big data system favors anamoly - based ids when compared to knowledge - based ids because of the naturally large and ever increasing scope of threats .    using control - flow graphs for logic level intrusion detection",
    "is a commonly known idea @xcite .",
    "for example , control - flow integrity @xcite is a security mechanism that can identify misuse of application logic bugs , like buffer - overflow attacks .",
    "though cfgs are generally sparse graphs , they can grow very big in size .",
    "hence , it is important to design ids techniques that can work with a reduced representation of cfgs . a minimum spanning tree ( mst ) contains all vertices and only some paths of its source graph and the number of msts for sparse graphs is generally less .",
    "hence , a set of msts extracted from a cfg can be used for ids that detects program level anomalies .    in this paper",
    ", we propose a control - flow based intrusion detection technique for big data systems .",
    "the proposed technique checks for program level anomalies in big data applications by analyzing and comparing the control - flow behavior of all processes running inside a big data system .",
    "the proposed intrusion detection technique is divided into two parts .",
    "first , the control - flow of each process running on a data node in the big data cluster is locally analyzed .",
    "this is done by extracting a set of msts from the instruction level cfg of a compiled program .",
    "the extracted set of msts are hashed and stored in an array called the _ program signature_. then , the stored program signature is encrypted and shared with other replica nodes that run the same program . in the second step ,",
    "the received encrypted program signature is decrypted and matched with the local version to check for coherence . matching two program signatures",
    "involves finding a perfect match for every mst in a signature within the set of msts of the other .",
    "the result of the matching step is then shared with replica nodes for consensus .",
    "our technique is designed to be simple , scalable and efficient in identifying both control - flow and brute - force attacks .",
    "the rest of this paper is organized as follows .",
    "section ii gives some background about big data systems , control - flow graphs and ids .",
    "the various related works are also discussed here .",
    "section iii explains the proposed intrusion detection technique in detail .",
    "experimental setup and results are thoroughly discussed in section iv .",
    "finally , section v gives the conclusion and future work .",
    "in this section , background about the three topics - big data systems , control - flow graphs and intrusion detection is provided .",
    "the related works are briefly outlined here .",
    "big data systems are data driven and their work can be classified into 2 major tasks - writing user data to the disk for storage and ; reading stored data when user requests for it .",
    "typically , this data is quantified in units called _",
    "blocks_. for fast and fault - tolerant service , big data systems rely on replication of data blocks which in turn demands data consistency .",
    "big data systems can not afford to have read or write service - level inconsistency .",
    "the motivation for this work comes from a weak assumption in the big data community that the services used by a big data system to maintain data consistency are never attacked .",
    "it is our knowledge that this problem has not been widely addressed before .    to propose an ids for big data services ,",
    "it is important to understand how the services work . for this",
    ", we picked 2 popular big data services - reads and writes .",
    "when a client ( or user ) wants to write a block , the namenode picks _ n _ data nodes from the big data cluster to complete this task where _ n _ is the replication factor of the cluster .",
    "first the namenode checks if the datanodes are ready .",
    "it sends a ready request to datanode1 which when ready , forwards that request to datanode2 and so on .",
    "when the namenode knows that all _",
    "n _ datanodes are ready , it asks the client to start writing .",
    "the client only writes to datanode1 which is subsequently written on to datanode2 , datanode3 and so on . in case of any failure ,",
    "namenode orders a new datanode to maintain block replicas .",
    "when the client wants to read a block , namenode gives the client a list of all datanodes that have the block and the client picks first datanode .",
    "if there is a problem reading from datanode1 , the client request gets forwarded to the next datanode that has a copy of the same block .      0.45        0.45        0.2     0.2     a control - flow graph ( cfg ) is a directed graph representation of a program and usually a sparse graph .",
    "cfgs include all possible control paths in a program .",
    "this makes cfg a great tool to obtain control - flow behavior of its process .",
    "vertices in a cfg give the level of detail , such as instruction - level or basic block level , that can not be further divided .",
    "edges in cfg represent control jumps and are classified into two types - forward and backward .",
    "branch instructions , function calls , conditional and unconditional jumps account for forward edges .",
    "virtual calls and indirect function calls are also considered as forward edges but their destinations are difficult to determine .",
    "loops and returns generally account for backward edges .",
    "the integrity among duplicate processes that run on replica nodes of a big data system can be verified with the information available in a cfg @xcite .",
    "similarity check between program logic of two programs can be performed by comparing their cfgs for isomorphism .",
    "there are many ways to check for such graph isomorphism @xcite but analyzing the similarity of two processes by conducting cfg level graph isomorphism is hard and time consuming .",
    "graph isomorphism is a complex problem , sometimes known to be np - complete as well @xcite . to reduce the complexity of graph algorithms",
    ", cfgs can be reduced to trees or subgraphs before performing any coherence or integrity checks @xcite .",
    "a cfg can be converted to a tree using methods such as depth - first traversal .",
    "several tree structures like dominator tree , minimumm spanning tree ( mst ) , minimumm spanning arborescence ( msa ) can be extracted form cfgs @xcite . for this work ,",
    "mst and msa can be used interchangeably .",
    "cfgs can be broken into subgraphs using methods like k sub - graph matching and graph coloring .",
    "some popular methods for graph reduction and graph comparison that can be found in the literature are given below ( assume graphs to have n vertices and m edges ) :    * _ based on edit distance _ : using smith - waterman algorithm with levenshtein distance to identify similarity between two graphs represented as strings @xcite .",
    "the time complexity is o(nm ) . * _ based on traversal _ :",
    "( a ) a preorder traversal of a graph g where each node is processed before its descendants .",
    "( b ) a reverse postorder in a dag gives a topological order of the nodes @xcite .",
    "* _ based on dominator trees _ : a data structure built using depth first search or using the method proposed by tarjan in @xcite .",
    "tarjan s method has a time complexity of o((n+m)log(n+m ) ) . *",
    "_ based on reachability _ : transitive reduction of a sparse graph to another graph with fewer edges but same transitive closure @xcite .",
    "the time complexity is o(nm ) .    in this work",
    ", we chose to reduce a cfg to a set of msts because cfgs are generally sparse graphs and hence the size of the set of msts will be finite and small .",
    "edmond s algorithm can be used to extract msts from a digraph @xcite . since",
    "an mst contains all vertices of its graph , there will be no loss in the program instruction data .",
    "depending on the connectedness of the graph , the edge count will defer between the cfg and mst representation of a program .",
    "figure [ fig_ex1 ] shows transformation of a line of java code to basic blocks of bytecode to cfg to set of msas .",
    "vertices b1 , b2 , b3 , b4 are the basic blocks formed from java bytecode .",
    "there exists an o(m + n log n ) time algorithm to compute a min - cost arborescence @xcite .",
    "alternately , another approach for converting a cfg to mst using union find is used by popular compilers like llvm and gcc for security purposes .",
    "one known disadvantage of using cfgs and msts for security is that dynamic link library calls can not be verified .",
    "traditionally , ids checks for known malware in programs by performing signature matching on a threat database @xcite .",
    "signature match using exact string matching is limited in its scope .",
    "this is because variants of same attack will have different signatures .",
    "recently , methods to detect new malwares using statistical machine learning have been proposed .",
    "static analysis using cfg is another efficient way to detect intrusions but it is very complex @xcite . converting a cfg to a string and implementing string matching is another way to deal with this problem but the solution will not be polynomial . also , cfg at basic block level can have basic block variants that look different but perform the same function . to deal with these shortcomings ,",
    "many approximate matching techniques have been proposed . tracing applications to get",
    "their cfg is another approach that is used in applications like xtrace , pivottrace etc @xcite . in case of big data systems ,",
    "data nodes usually have the same processor architecture .",
    "hence it can be assumed that there will be no variants when the cfg is constructed at byte - level .",
    "it is then sufficient to verify similarity among the cfgs of two processes to confirm coherence in the nodes of a big data system .    1        1",
    "in this section , we describe our proposed two - step intrusion detection technique for big data systems .",
    "the first step involves capturing the control - flow of a process running on a datanode of the big data system .",
    "the second step involves process - level similarity check followed by consensus among replica datanodes .      in this work",
    ", we emphasize on process level intrusion detection by observing coherence in the behavior of duplicate processes running on replica datanodes of a distributed big data system . to capture the program behavior , the first step is to identify a representation of the program that has the information we need and filters out all other data .",
    "we call this representation as the program signature .",
    "since our goal is to identify intrusions from control - flow mismatch , our program signatures should contain all possible control flow information of a program .",
    "compiled source code of a program is generally used to generate static cfg .",
    "since most big data frameworks use a virtual machine ( like jvm ) , an instruction level cfg in this context is generated from java byte code . in this work , disassembled object code ( doc ) from java byte code",
    "is used as input to generate the cfg at instruction level .",
    "it is important for the program signature to contain only the information that is necessary .",
    "hence , every cfg is converted into a set of msts that are later used to generate the program signature . in this work",
    ", we propose the idea of representing a program by a set of msts / msas that can be extracted from a byte - level cfg using edmonds algorithm .",
    "this set of msts that are extracted from a cfg are further filtered to only the set of edge - disjoint msts .",
    "there are many versions proposed for edmonds algorithm @xcite and for this work we used a version from networkx graph library @xcite that generates edge disjoint spanning trees from the root vertex of a given digraph .",
    "once a minimal representation of the logic in a program is obtained in the form of an msa , it is converted into a string by listing the node list first followed by edge list , which is in accordance to the dot format representation .",
    "the length of a mst string in dot format is dependent on program size . to make the comparison step faster",
    ", we convert the variable length mst strings of a program to fixed length strings using hashing .",
    "the extracted set of edge - disjoint msts are hashed using popular hashing algorithms like sha or md5 to generate a set of fixed - length hash strings . since a sparse graph like",
    "cfg can have multiple msas , the program signature can be a single hash string or a set of hash strings .",
    "having all possible msas in the program signature makes the graph similarity check more reliable . in the end , a _ program signature _ is a set of fixed - length strings .",
    "program signatures are encrypted before being shared with replica datanodes for tighter security .",
    "the private key for encryption is generated from a harcoded master key if we use secure hardware like the one proposed in our previous work @xcite .",
    "every datanode in a big data system runs the proposed _ profiling method _ for every running process and it includes all the steps involved in converting the compiled binary of a program to its program signature . a pictorial representation of the steps in profiling method is given in figure [ fig_algo ] .",
    "replication property of big data systems opens scope for new methods of implementing application logic level ids techniques .",
    "process similarity check among duplicate nodes of the cluster helps in checking for coherence among the replica datanodes while performing a write or read operation . when a process is scheduled to run on a datanode that hosts the primary copy of a data , a signature for that process is created by the _ profiling method _",
    "( step 1 ) of our proposed ids technique and that signature string is shared with all replica datanodes . in the _ matching method _",
    "( step 2 ) , these signatures received from other datanodes are decrypted and matched with the local versions of the same process . the results are shared with all other replica datanodes for consensus . for secure communication among datanodes",
    ", we intend to use the same secure communication protocol that was proposed in our previous work @xcite .",
    "the most important part of the matching method is to check for similarity ( or dissimilarity ) between two program signatures .",
    "generally , graph similarity check can be performed by checking node similarity and edge similarity .",
    "the following points are considered while comparing msts to check for similarity among programs :    * msts are sparse graphs obtained from byte - level cfgs . hence , checking for path sensitivity is not exponential . *",
    "all edges are assumed to have the same weight of 1 . *",
    "the total number of msts for a cfg is limited ( by cayley s formula @xcite ) .",
    "* by edmond s theorem , a graph which is k - connected always has k edge - disjoint arborescences . *",
    "two msts are a perfect match if their node sets and edge sets match exactly . *",
    "if edge set of one mst is a subset of the edge set of another mst , the source graphs of these msts are not similar . *",
    "two graphs are similar if for every mst in one graph there exists a perfect match in the set of msts of the other graph .",
    "* hashing algorithms like sha1 or md5 are quick and efficient .    based on the points listed above",
    ", the following method is developed for graph similarity check .",
    "let us consider 2 control - flow graphs g1 and g2 .",
    "let @xmath0 represent g1 where n1 is the node set of the graph g1 and e1 is the edge set of the graph .",
    "similarly , @xmath1 represents g2 where n2 is the node set of the graph g1 and e2 is the edge set of the graph . after employing a variation of edmonds algorithm on these cfgs ( such as finding all edge - disjoint msts ) , lets us assume that m1 @xmath2 $ ] is the set of mst / msa for g1 and m2 @xmath3 $ ] is the set of mst / msa for g2 . in order to check for similarity in both graphs g1 and g2 , we check if there is a perfect match in m2 for all msts in m1 . in order to simplify the match function , we propose using a hash function on m1 and m2 that creates a unique hash for every mst .",
    "let h1 be a set of hashes generated from m1 and h2 be the set of hashes from m2 .",
    "if any hash in h1 does not exist in h2 , we deduce that the graphs are not equal .",
    "in this section , the experimental setup and experiments used for testing the proposed technique are provided . the results and some analysis",
    "are also provided .",
    "an amazon ec2 @xcite m4.xlarge instance running ubuntu 14.04 is used to generate msts ( and their hashes ) from cfgs using sagemath .",
    "the proposed technique was implemented and tested on an amazon ec2 big data cluster of 5 t2.micro nodes - 1 master node , 1 secondary master node and 3 datanodes with a replication factor of 3 .",
    "the list of softwares used in conducting our experiments are :    * * sagemath * @xcite is a free open - source mathematics software system for mathematical calculations .",
    "* * graphml * @xcite is a popular graph representation format which can used to represent both cfg and mst . * * graphviz * @xcite is open source graph visualization software that takes input in dot format and makes diagrams in useful formats . * * networkx * @xcite is a python language software package that provides graph algorithms like edmonds and vf2 . * * control - flow graph factory * @xcite is a software that generates cfgs from java bytecode ( class file ) and exports them to graphml or dot formats .",
    "0.48| c | c | l | * e.no*&*name*&*description * + 1 & wordmean & a map / reduce program that counts the average length of the words in the input files . + 2 & pentomino & a map / reduce tile laying program to find solutions to pentomino problems .",
    "+ 3 & distbbp & a map / reduce program that uses a bbp type formula to compute the exact bits of pi .",
    "+ 4 & aggregatewordcount & an aggregate based map / reduce program that counts the words in the input files .",
    "+ 5 & secondarysort & an example defining a secondary sort to the reduce .",
    "+ 6 & aggregatewordhist & an aggregate based map / reduce program that computes the histogram of the words in the input files .",
    "+ 7 & randomwriter & a map / reduce program that writes 10 gb of random data per node .",
    "+ 8 & teravalidate & check the results of the terasort .",
    "+ 9 & qmc & a map / reduce program that estimates the value of pi using a quasi - monte carlo ( qmc ) method .",
    "+ 10 & wordstandarddeviation & a map / reduce program that counts the standard deviation of the length of the words in the input files .",
    "+ 11 & wordmedian & a map / reduce program that counts the median length of the words in the input files .",
    "+ 12 & bbp & a map / reduce program that uses bailey borwein plouffe to compute the exact digits of pi .",
    "+ 13 & teragen & generate data for the terasort .",
    "+ 14 & sudoku & a sudoku solver .",
    "+ 15 & wordcount & a map / reduce program that counts the words in the input files .",
    "+ 16 & multifilewc & a job that counts words from several files .",
    "+      the proposed intrusion detection technique was tested using 16 hadoop map - reduce examples that can be found in all hadoop distributions .",
    "these examples cover a wide range of big data applications as listed in table [ table_examples_hadoop ] .",
    "the class files of these examples are readily available in the hadoop distributions .",
    "first , control - flow graph factory @xcite was used to generate control flow graphs from the class files .",
    "these graphs are stored in graphml format and given as input to a simple sagemath @xcite script that uses networkx library @xcite and computes the edge - disjoint msas and hashes them using md5 .",
    "a c++ application was used to implement encryption and secure communication needed for the proposed ids technique .",
    "the implementation was based on framework from @xcite .",
    "the hashes are fixed length strings and so we restrained to using a basic numeric key based left / right shift for encryption / decryption of messages . since there are no benchmarks for some of these examples , we executed them with minimum input requirements .",
    "* example * & * profiling method * & * cfg to msa set * & * hashing * & * matching method * & * avg hash match * & * consensus * & * proposed * & * exec time * & * % time * +    1 & wordmean & 0.0216 & 0.0216 & 7.89e-05 & 0.0190 & 0.0002 & 0.0187 & 0.0407 & 6.988 & 0.58% + 2 & pentomino & 0.0288 & 0.0288 & 8.70e-05 & 0.0196 & 0.0013 & 0.0182 & 0.0485 & 4.914 & 0.99% + 3 & distbbp * & 0.0567 & 0.0567 & 6.29e-05 & 0.0150 & 0.0019 & 0.0130 & 0.0718 & 28.58 & 0.25% + 4 & aggregatewordcount & 0.0070 & 0.007 & 5.70e-05 & 0.0145 & 0.0002 & 0.0143 & 0.0215 & 19.002 & 0.11% + 5 & secondarysort * & 0.0199 & 0.0199 & 5.10e-05 & 0.0072 & 0.0018 & 0.0054 & 0.0272 & 11.657 & 0.23% + 6 & aggregatewordhist & 0.0066 & 0.0066 & 4.20e-05 & 0.0135 & 0.0012 & 0.0122 & 0.0201 & 18.024 & 0.11% + 7 & randomwriter & 0.2561 & 0.2561 & 8.58e-05 & 0.0217 & 0.0025 & 0.0191 & 0.2779 & 29.111 & 0.95% + 8 & teravalidate & 0.0181 & 0.0181 & 5.20e-05 & 0.0169 & 0.0001 & 0.0168 & 0.0351 & 5.958 & 0.59% + 9 & qmc * & 0.0238 & 0.0238 & 7.39e-05 & 0.0202 & 0.0015 & 0.0186 & 0.0440 & 11.657 & 0.38% + 10 & wordstandarddeviation & 0.0193 & 0.0193 & 7.89e-05 & 0.0098 & 0.0021 & 0.0076 & 0.0292 & 7.112 & 0.41% + 11 & wordmedian & 0.0312 & 0.0312 & 6.20e-05 & 0.0208 & 0.0020 & 0.0187 & 0.0520 & 7.028 & 0.73% + 12 & bbp & 0.0415 & 0.0415 & 9.08e-05 & 0.0118 & 0.0003 & 0.0115 & 0.0534 & 6.865 & 0.78% + 13 & teragen & 0.0169 & 0.0169 & 5.51e-05 & 0.0131 & 0.0023 & 0.0108 & 0.0301 & 4.905 & 0.61% + 14 & sudoku * & 0.0177 & 0.0177 & 5.60e-05 & 0.0156 & 0.0006 & 0.0150 & 0.0334 & 11.657 & 0.29% + 15 & wordcount & 0.3672 & 0.3672 & 6.99e-05 & 0.0221 & 0.0023 & 0.0197 & 0.3893 & 7.034 & 5.54% + 16 & multifilewc & 0.0159 & 0.0159 & 5.20e-05 & 0.0118 & 0.0001 & 0.0116 & 0.0277 & 5.963 & 0.47% + & 0.0593 & 0.0592 & 6.59e-05 & 0.0158 & 0.0013 & 0.0144 & 0.07516 & 11.657 & 0.81% +      table [ table_hadoop_values ] , figures [ fig_r1 ] and [ fig_r2 ] show the results of our experiments . figure [ fig_r1 ] shows the comparison between the time taken to run the hadoop map - reduce examples on a big data cluster and the time taken to run the proposed intrusion detection technique .",
    "the execution times for some examples ( represented by * in table [ table_hadoop_values ] ) are inconsistent among multiple runs .",
    "we can notice from table [ table_hadoop_values ] that only 0.81% of time taken to execute an example is needed to analyze it for intrusion detection .",
    "the time needed to run the proposed detection technique includes ( a ) time taken to create cfg for the main method from the class file ; ( b ) time taken to extract mst set from cfg ; ( c ) time taken to hash the msts and encrypt them and ; ( d ) time taken to check for similarity among duplicate processes by comparing the program signatures . all of these values can be found in table [ table_hadoop_values ] .",
    "the last row of this table gives the average values .",
    "it can be noticed from figure [ fig_r2 ] that the time required by the proposed technique is influenced by the profiling method trying to extract msas from cfg , particularly when there are more than one msas for a cfg . though the matching method performance is directly proportional to the square of the size of the number of edge - disjoint msas in a cfg i.e.  @xmath4 worst case complexity",
    ", we observed that it is rare to have more than a couple of edge - disjoint msas in a cfg because of the sparse nature of cfg .",
    "0.47        0.47",
    "in this paper , we introduced a novel approach to detect program level intrusions in big data systems with help of control flow analysis .",
    "the main idea is to use the replication property of big data systems and check for coherence in program behavior among replica datanodes .",
    "behavior of a program is modeled by extracting a msa set representation of its cfg .",
    "similarity check among duplicate programs is performed by a complete matching among hashed sets of msas .",
    "experiments were conducted on real - world hadoop map - reduce examples and it is observed that the proposed technique takes only 0.8% of execution time to identify intrusions .",
    "the naturally sparse nature of cfgs helps in achieving this low overhead . for future work",
    ", we would like to explore graph string matching and compare the proposed matching method ( step2 ) with other graph isomorphism techniques .    1 dean , jeffrey , and sanjay ghemawat .",
    "`` mapreduce : simplified data processing on large clusters . ''",
    "communications of the acm 51.1 ( 2008 ) : 107 - 113 .",
    "white , tom .",
    "`` hadoop : the definitive guide . ''",
    "oreilly media , inc . , 2012 .",
    "zaharia , matei , et al .",
    "`` spark : cluster computing with working sets . ''",
    "proceedings of the 2nd usenix conference on hot topics in cloud computing . 2010 .",
    "omalley , owen .",
    "`` integrating kerberos into apache hadoop . ''",
    "kerberos conference .",
    "aditham , santosh , and nagarajan ranganathan .",
    "`` a novel framework for mitigating insider attacks in big data systems . '' big data ( big data ) , 2015 ieee international conference on .",
    "ieee , 2015 .",
    "tan , zhiyuan , et al .",
    "`` enhancing big data security with collaborative intrusion detection . ''",
    "cloud computing , ieee 1.3 ( 2014 ) : 27 - 33 .",
    "bruschi , danilo , lorenzo martignoni , and mattia monga .",
    "`` detecting self - mutating malware using control - flow graph matching . ''",
    "detection of intrusions and malware & vulnerability assessment .",
    "springer berlin heidelberg , 2006 .",
    "129 - 143 .",
    "nagarajan , vijay , et al .",
    "`` matching control flow of program versions . '' software maintenance , 2007 .",
    "icsm 2007 .",
    "ieee international conference on .",
    "ieee , 2007 .",
    "dullien , thomas , and rolf rolles .",
    "`` graph - based comparison of executable objects ( english version ) . ''",
    "sstic 5 ( 2005 ) : 1 - 3 .",
    "abadi , martn , et al .",
    "`` control - flow integrity principles , implementations , and applications . ''",
    "acm transactions on information and system security ( tissec ) 13.1 ( 2009 ) : 4 .",
    "amighi , afshin , et al .",
    "`` provably correct control flow graphs from java bytecode programs with exceptions . ''",
    "international journal on software tools for technology transfer ( 2015 ) : 1 - 32 .",
    "gold , robert .",
    "`` reductions of control flow graphs . ''",
    "world academy of science , engineering and technology , international journal of computer , electrical , automation , control and information engineering 8.3 ( 2014 ) : 417 - 424 .",
    "gabow , harold n. , et al .",
    "`` efficient algorithms for finding minimum spanning trees in undirected and directed graphs . ''",
    "combinatorica 6.2 ( 1986 ) : 109 - 122 .",
    "uno , takeaki .",
    "an algorithm for enumerating all directed spanning trees in a directed graph .",
    "springer berlin heidelberg , 1996 .",
    "j. edmonds , optimum branchings , j. res .",
    "standards 71b ( 1967 ) , 233240 .",
    "bunke , horst .",
    "`` on a relation between graph edit distance and maximum common subgraph . '' pattern recognition letters 18.8 ( 1997 ) : 689 - 694 .",
    "sharir , micha .",
    "`` a strong - connectivity algorithm and its applications in data flow analysis . ''",
    "computers & mathematics with applications 7.1 ( 1981 ) : 67 - 72 .",
    "georgiadis , loukas , robert endre tarjan , and renato fonseca f. werneck .",
    "`` finding dominators in practice . ''",
    "j. graph algorithms appl .",
    "10.1 ( 2006 ) : 69 - 94 .",
    "tarjan , robert e. , and mihalis yannakakis .",
    "`` simple linear - time algorithms to test chordality of graphs , test acyclicity of hypergraphs , and selectively reduce acyclic hypergraphs . ''",
    "siam journal on computing 13.3 ( 1984 ) : 566 - 579 .",
    "pathan , al - sakib khan , ed .",
    "the state of the art in intrusion prevention and detection .",
    "crc press , 2014 .",
    "wagner , david , and drew dean .",
    "`` intrusion detection via static analysis . '' security and privacy , 2001 .",
    "s&p 2001 . proceedings .",
    "2001 ieee symposium on .",
    "ieee , 2001 .",
    "wang , william .",
    "end - to - end tracing in hdfs .",
    "carnegie mellon university pittsburgh , pa , 2011 .",
    "mace , jonathan , ryan roelke , and rodrigo fonseca .",
    "`` pivot tracing : dynamic causal monitoring for distributed systems . ''",
    "proceedings of the 25th symposium on operating systems principles .",
    "acm , 2015 .",
    "koutra , danai , et al .",
    "algorithms for graph similarity and subgraph matching . technical report of carnegie - mellon - university , 2011 .",
    "cordella , luigi p. , et al .",
    "`` a ( sub ) graph isomorphism algorithm for matching large graphs . '' pattern analysis and machine intelligence , ieee transactions on 26.10 ( 2004 ) : 1367 - 1372 .",
    "shor , peter w. `` a new proof of cayley s formula for counting labeled trees . ''",
    "journal of combinatorial theory , series a 71.1 ( 1995 ) : 154 - 158 .",
    "amazon , e. c. `` amazon elastic compute cloud ( amazon ec2 ) . ''",
    "amazon elastic compute cloud ( amazon ec2 ) ( 2010 ) .",
    "sage mathematics software ( version 4.0 ) , the sage developers , 2016 , http://www.sagemath.org .",
    "brandes , ulrik et al .",
    "`` graph markup language ( graphml ) . ''",
    "crc ( 2013 ) .",
    "emden r. gansner and stephen c. north .",
    "`` an open graph visualization system and its applications to software engineering . '' software - practice and experience 30.11 ( 2000 ) : 1203 - 1233 .",
    "aric a. hagberg , daniel a. schult and pieter j. swart , `` exploring network structure , dynamics , and function using networkx '' , in proceedings of the 7th python in science conference ( scipy2008 ) , gel varoquaux , travis vaught , and jarrod millman ( eds ) , ( pasadena , ca usa ) , pp . 1115 , aug 2008 alekseev , sergej ,",
    "peter palaga , and sebastian reschke .",
    "`` bytecode visualizer . ''",
    "control flow graph factory .",
    "n.p . , 2008"
  ],
  "abstract_text": [
    "<S> _ security and distributed infrastructure are two of the most common requirements for big data software . </S>",
    "<S> but the security features of the big data platforms are still premature . </S>",
    "<S> it is critical to identify , modify , test and execute some of the existing security mechanisms before using them in the big data world . in this paper , we propose a novel intrusion detection technique that understands and works according to the needs of big data systems . </S>",
    "<S> our proposed technique identifies program level anomalies using two methods - a * profiling method * that models application behavior by creating process signatures from control - flow graphs ; and a * matching method * that checks for coherence among the replica nodes of a big data system by matching the process signatures . </S>",
    "<S> the profiling method creates a process signature by reducing the control - flow graph of a process to a set of minimum spanning trees and then creates a hash of that set . the matching method first checks for similarity in process behavior by matching the received process signature with the local signature and then shares the result with all replica datanodes for consensus . </S>",
    "<S> experimental results show only 0.8% overhead due to the proposed technique when tested on the hadoop map - reduce examples in real - time . _    big data ; intrusion detection ; control - flow graph ; </S>"
  ]
}