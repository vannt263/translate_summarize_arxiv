{
  "article_text": [
    "index coding , introduced in @xcite , considers the problem of efficiently broadcasting a number of messages available at a source , to receivers that already possess some prior knowledge of the messages . in the index coding framework ,",
    "the source is allowed to encode the messages ( and thereby use the channel efficiently ) while satisfying the receiver demands . the general class of _ groupcast _",
    "index coding problems consists of @xmath0 messages generated at a source , where each message is demanded by at least one receiver .",
    "index coding problems where each receiver demands a unique message are called _ single unicast index coding _ problems and are the most widely studied class .",
    "although index coding continues to be open in general , several researchers have made inroads into characterising the _ _ rate of index coding _ _ and presenting achievable schemes .",
    "the landmark paper @xcite famously connected the scalar linear index coding problem to finding a quantity called _ minrank _ associated with the _ side - information graph _ related to the given single unicast index coding problem .",
    "upper and lower bounds on the rate for single unicast index coding have been presented via graph theoretic ideas like clique cover , chromatic number @xcite , local chromatic number @xcite , fractional clique covering and hyperclique covering @xcite , and recently , the ` generalized interlinked cycle cover ' @xcite .",
    "many of these papers naturally lead to constructions of ( scalar and vector ) linear index codes .",
    "linear codes however are not always found to be optimal @xcite .",
    "random coding approaches to index coding were studied in @xcite .",
    "bounds on the rate of groupcast index coding were presented in @xcite .",
    "interference alignment , well known as a powerful tool to study degrees of freedom in wireless interference networks , was employed to the linear index coding problem in @xcite , by modelling the unavailable side - information as interference .",
    "the idea is to assign precoding matrices to the message vectors such that all receivers can decode even in the presence of interference ( thereby requiring some degree of linear independence between the precoding matrices , and hence reducing the rate ) .",
    "however , at the same time the interference at the receivers must be as ` aligned ' as possible ( in order to reduce the amount of linear independence required , i.e. to increase the rate ) .",
    "this technique was further explored in @xcite and several classes of index coding instances with certain feasible rates were identified based on the properties of the interference seen by the receivers .",
    "this work builds primarily upon the results in @xcite . in @xcite , a necessary and sufficient condition for the feasibility of _ _ rate half _",
    "_ ( some finite field ) symbols transmitted through the channel , one @xmath3 symbol of each message is conveyed . ] in a groupcast index coding problem was established based on the properties satisfied by two graphs obtained from the interference structure of the problem , called the _ conflict graph _ and the _ alignment graph_. also , a sufficient ( but not necessary ) condition on the structure of these graphs was given for rate @xmath2 feasibility .",
    "prior work @xcite also gives a necessary ( but not sufficient ) condition for rate @xmath2 feasibility based on the interference structure of the problem .",
    "the relevant details of the prior work are discussed elaborately in the forthcoming sections of this paper .",
    "* firstly , we revise the definition of the conflict graph given in @xcite",
    ". the conflict graph definition in @xcite does not capture the interference structure of the index coding problem sufficiently . in order to rectify this",
    ", we define the _ conflict hypergraph _ , which is shown to capture the interference structure sufficiently .",
    "( subsection [ conflicthypergraphsubsec ] ) * our main result shows that rate @xmath2 is achievable in a given index coding problem under certain conditions on the topology of the alignment graph and conflict hypergraph of the index coding problem .",
    "the sufficient condition which we present for rate @xmath2 feasibility is looser than the sufficient condition shown in @xcite .",
    "therefore , this class of index coding problems is bigger than the previously known class of rate @xmath2 feasible problems .",
    "the achievability of rate @xmath2 in such problems is shown by presenting a construction of an index code by random generation of precoding vectors over a large field .",
    "( subsection [ rateonethirdfeasibleproblems ] ) * towards obtaining our main result , we also obtain a necessary condition for rate @xmath2 feasibility , which is stricter than the prior condition from @xcite ( subsection [ necessaryconditionrateonethirds ] ) .",
    "our feasibility conditions can thus be seen as being midway between those of @xcite and @xcite .    _",
    "notations : _ throughout the paper , we use the following notations .",
    "let @xmath4 $ ] denote @xmath5 .",
    "for a set of vectors @xmath6 , @xmath7 denotes their span . for a vector space @xmath8",
    ", @xmath9 denotes its dimension . an arbitrary finite field",
    "is denoted by @xmath3 .",
    "a vector from the @xmath10-dimensional vector space @xmath11 is said to be picked _ at random _ if it is selected according to the uniform distribution on @xmath11 .",
    "formally , the index coding problem ( over some field @xmath12 ) consists of a broadcast channel which can carry symbols from @xmath3 , along with the following .    * a set of @xmath13 receivers * a source which has messages @xmath14\\}$ ] , each of which is modelled as a vector over @xmath3 . * for each receiver @xmath15 , a set @xmath16 denoting the set of messages demanded by the receiver @xmath15 . * for each receiver @xmath15 , a set @xmath17 denoting the set of side - information messages available at the @xmath18 receiver .",
    "this general class of index coding problems is known as _ groupcast _ index coding problems .",
    "an index code of symmetric rate @xmath1 for a given index coding problem consists of an encoding function @xmath19 for some @xmath20 mapping the @xmath0 @xmath21-length message vectors ( @xmath22 ) to some @xmath23-length codeword which is broadcast through the channel , as well as decoding functions @xmath24 at the receivers @xmath25,$ ] mapping the received codeword and the side - information messages to the demanded messages @xmath26 , i.e. , @xmath27.\\ ] ]    we could in general have different rates for different messages , but in this paper we restrict our attention to symmetric rates .",
    "therefore any rate referred to in this paper is the symmetric rate .    for a given index coding problem , a rate @xmath1 is said to be _ achievable _ if there exists an index code of rate @xmath1 , and the index coding problem is said to be _ rate _ @xmath1",
    "_ feasible_.    if a rate @xmath28 is achievable , the associated index code is a _ scalar index code of length",
    "_ @xmath23 .",
    "if the encoding and decoding functions are linear , then we have a _ linear index code_.    if we have a linear index code of rate @xmath1 , then we can represent the encoding function as follows .",
    "@xmath29 where each @xmath30 is a @xmath31 matrix with elements from @xmath12 . in the case of scalar linear index coding",
    ", we have @xmath32 . finding a scalar linear index code of length @xmath23 ( i.e. , with a feasible rate @xmath33 ) is equivalent to finding an assignment of these @xmath23-length vectors @xmath30s to the @xmath0 messages such that the receivers can all decode their demanded messages , i.e. , @xmath34.\\ ] ] in the case of a scalar linear index code , the encoding function @xmath35 fixes the vectors assigned to the messages . however not every vector assignment is a valid index coding encoding function , as the decoding functions may not exist . in a number of proofs in this paper ,",
    "we start with some vector assignment and show that it leads to an encoding function of a valid index code .",
    "therefore , in such proofs we refer to the initial vector assignment as a valid encoding function @xmath35 by abusing the notation .",
    "we restrict our attention to scalar linear index codes for the rest of this paper .",
    "however we believe that our results can be extended to vector linear index codes as well .      for some receiver @xmath15 and for some message @xmath36 ,",
    "let @xmath37 denote the set of messages ( except @xmath38 ) not available at the receiver @xmath15 .",
    "the sets @xmath39 are called the _ interfering sets at receiver _ @xmath15 .",
    "if receiver @xmath15 does not demand message @xmath38 , then we define @xmath40 .",
    "if a message @xmath41 is not available at a receiver @xmath15 demanding at least one message @xmath42 , then @xmath41 is said to _ interfere at receiver _",
    "@xmath15 , and @xmath41 and @xmath38 are said to be _ in conflict_.    for a set of vertices @xmath43 , let @xmath44 denote the vector space spanned by the vectors assigned to the messages in @xmath6 , under the specified encoding function @xmath35 .",
    "if @xmath45 , we define @xmath44 as the zero vector .    for a given assignment of vectors to the messages ( or equivalently , for a given encoding function @xmath35 ) , we say that _ conflicts within a subset _ @xmath46 _ are resolved _ , if @xmath47,\\end{aligned}\\ ] ] where @xmath48 is the vector assigned to @xmath38 under the encoding function @xmath35 .",
    "if ( [ resolvedconflicts ] ) holds for @xmath49 then _ all the conflicts _ in the given index coding problem _ are said to be resolved_.    we now state a simple lemma , rephrased from @xcite , which is easily proved .",
    "[ lemmasuccessdecoding ] for any encoding function @xmath35 , successful decoding at the receivers is possible if and only if all the conflicts are resolved .",
    "let @xmath48 be the vector assigned to @xmath38 under the encoding function @xmath35 .",
    "_ if part : _ at all receivers @xmath15 , consider that we have @xmath50 $ ] .",
    "what is received at a receiver @xmath15 is the codeword @xmath51 , from which it wants to obtain @xmath38 . as receiver @xmath15",
    "can always subtract the contribution from the side - information messages from @xmath51 , it only remains to be shown that @xmath52 can be decoded from @xmath53 where the equality is because @xmath54 because of the assumption that @xmath55 , receiver @xmath15 can get @xmath38 from ( [ eqn1 ] ) .",
    "_ only if part : _ consider now that there is some receiver @xmath15 and some message @xmath56 such that @xmath57 clearly , solving for @xmath38 from ( [ eqn1 ] ) does not lead to an unique solution . hence decoding fails .",
    "this concludes the proof .    by lemma [ lemmasuccessdecoding ] ,",
    "it should also be clear that if there is an assignment of @xmath23-length vectors @xmath30s to the messages @xmath41s such that the condition in lemma [ lemmasuccessdecoding ] is satisfied , then these vectors naturally define an index code of length @xmath23 for the given index coding problem .",
    "in @xcite , the authors defined the notions of _ alignment graph _ and _ conflict graph _ whose properties were used to characterise index coding problems for which rate @xmath58 is feasible .",
    "both of these graphs have the same vertex set , which is the set of messages @xmath59 .    in the alignment graph , the vertices @xmath41 and",
    "@xmath52 are connected by an edge ( called an _ alignment edge _ , shown in our figures by a solid edge ) when the messages @xmath41 and @xmath52 are not available at a receiver demanding a message other than @xmath41 and @xmath52",
    ". a connected component of the alignment graph is called an _ alignment set_.",
    "it is easy to see that the alignment sets define a partition of the alignment graph . also , the messages in @xmath60 for all messages @xmath56 at all receivers @xmath15 are fully connected in the alignment graph .    in the conflict graph , @xmath41 and @xmath52",
    "are connected by an edge ( called an _ conflict edge _ , shown by a dotted edge ) if @xmath41 is not available at a receiver demanding @xmath52 , or @xmath52 is not available at a receiver demanding @xmath41 .",
    "the following example illustrates that the conflict graph definition does not capture the _ directionality _ of the conflicts .",
    "[ conflictissueexm ] consider two single unicast index coding problems with four messages . in the first problem ,",
    "the interfering sets are as follows @xmath61 . in the second problem ,",
    "@xmath62 all other interfering sets corresponding to the receivers are empty .",
    "these two problems have the same alignment and conflict graphs ( see fig.[fig : conflictgraphsame ] ) . in particular",
    ", the conflict graphs are the same because the definition of the conflict graph does not model the directionality of the absent side - information messages .",
    "note that they both have different solutions .",
    "we leave it to the reader to check that the first problem is rate @xmath58 feasible , while the second problem is not rate @xmath58 feasible , but has a rate @xmath2 solution .    to overcome this issue",
    ", we define the _ conflict hypergraph _ as follows .",
    "the conflict hypergraph is an undirected hypergraph with vertex set @xmath59 ( the set of messages ) , and its hyperedge set defined as follows .",
    "* for any receiver @xmath15 demanding any message @xmath38 , @xmath38 and @xmath63 are connected by a hyperedge , which is denoted by @xmath64 .",
    "for example , the two problems presented in example [ conflictissueexm ] are now represented using different conflict hypergraphs in fig .",
    "[ fig : conflicthyp1 ] and fig .",
    "[ fig : conflicthyp2 ] ( the alignment graphs remains the same ) .",
    "note that even though this definition for the conflict hypergraph does not explicitly contain direction , the directionality of interference seen by any receiver is modelled correctly whenever the number of interfering messages is more than one .",
    "this is sufficiently general as we see in the following lemma .",
    "suppose two index coding problems , denoted by @xmath65 and @xmath66 are modelled by the same conflict hypergraph .",
    "then any index coding solution for @xmath65 is an index coding solution for @xmath67 .",
    "let @xmath68 be the encoding function of the given index code for @xmath65 .",
    "let @xmath48 be the vector assigned to @xmath38 .",
    "by lemma [ lemmasuccessdecoding ] , we must have that for @xmath50,~\\forall j\\in[1:t]$ ] in @xmath65 .",
    "now assume that the same index code is used for @xmath67 .",
    "for any receiver @xmath15 and message @xmath69 with @xmath70 in @xmath67 , the conflict hyperedge @xmath71 present in the conflict hypergraph of @xmath67 is present also in that of @xmath65 as both @xmath65 and @xmath67 have the same conflict hypergraph . in other words ,",
    "message @xmath72 is an interfering set of a receiver @xmath15 in @xmath65 also and hence we must have @xmath73 , which means that @xmath69 is recoverable at @xmath15 in @xmath67 also .",
    "the only case left to check is when @xmath74 in @xmath67 for some receiver @xmath15 and message @xmath69 .",
    "let us assume that @xmath75 because @xmath65 and @xmath67 share the same conflict hypergraphs , this conflict ( in some direction ) is present in @xmath67 also . by assignment @xmath35",
    ", we must have that @xmath30 and @xmath48 are linearly independent , which ensures that this conflict is resolved in @xmath67 also , irrespective of its directionality .      towards showing a necessary and sufficient condition for rate @xmath58 feasibility",
    ", the following definition for _ internal conflicts _ was given in @xcite .",
    "a conflict between two messages within an alignment set is called an _ internal conflict_.    the following theorem",
    "was proved in @xcite on rate @xmath58 feasible index coding problems .",
    "[ ratehalfthm ] an index coding problem is rate @xmath58 feasible if and only if there are no internal conflicts .",
    "the following lemma plays a crucial role in our proof of theorem [ ratehalfthm ] , which is included for the sake of completeness as it is not available in its complete form in prior literature .",
    "we will also see in subsection [ rateonethirdfeasibleproblems ] that it is central to proving our main theorem which deals with the feasibility of rate @xmath2 .",
    "[ intersectingkdimspaces ] let @xmath76 be @xmath77 sets of vectors , such that @xmath78 $ ] . then the space spanned by @xmath79 has dimension @xmath80 if and only if each @xmath81 spans a vector space of dimension @xmath80 .    _",
    "if part : _ suppose each @xmath81 spans a vector space of dimension @xmath80 , and @xmath78.$ ] clearly , all the vector spaces @xmath82s are exactly equal , and thus @xmath83    _ only if part : _ suppose @xmath84 and @xmath85.\\ ] ] by ( [ eqn3 ] ) , @xmath86 . if some @xmath87 , then @xmath88 , and we have a contradiction . thus , we must have that @xmath89 .",
    "we now use lemma [ intersectingkdimspaces ] and lemma [ lemmasuccessdecoding ] to prove theorem [ ratehalfthm ] .",
    "corresponding to any vertex @xmath38 in the alignment graph , let @xmath90 denote the alignment set it belongs to ( this is unique as the alignment sets partition the alignment graph ) .",
    "we first note that in any ( scalar linear ) index coding scheme for the given problem , all the vertices must be assigned some non - zero vectors ( zero vector can not be assigned to any message as this means that the message can not be decoded by any receiver ) .",
    "_ if part : _ suppose that there are no internal conflicts .",
    "we assume a large field @xmath12 . for each alignment set ,",
    "we independently generate a random @xmath91 vector over @xmath3 and assign it to the vertices of the alignment set . because of random generation",
    ", we can assume that any assigned vector is non - zero and any two assigned vectors are linearly independent with high probability ( whp ) .",
    "let @xmath35 denote the associated encoding function and @xmath48 denote the vector assigned to vertex @xmath38 .",
    "since there are no internal conflicts , we only have to check conflicts between alignment sets . for any vertex @xmath38 ,",
    "the set @xmath63 for any receiver @xmath15 which demands @xmath38 belongs to a @xmath92 different and @xmath93 unique alignment set than @xmath90 ( @xmath92 is because there are no internal conflicts , @xmath93 is because all the messages in @xmath63 must be in the same alignment set ) .",
    "since any two alignment sets get independent vectors ( whp ) , we have that @xmath55 , and the same argument is true for all receivers @xmath15 and all messages @xmath38 .",
    "hence this assignment of vectors ensures successful decoding by lemma [ lemmasuccessdecoding ] .    _ only if part : _ suppose that there is some internal conflict ( represented in the conflict graph as an edge between node @xmath94 and node @xmath56 ) in an alignment set @xmath90 .",
    "because @xmath95 are part of the same alignment set ( connected component ) @xmath90 , there lies a path from @xmath94 to @xmath56 , given by an ordered set @xmath96 , such that every adjacent pair of elements ( @xmath97 , etc . )",
    "belong to the interfering set of some receiver .    in some assignment corresponding to a rate @xmath58 solution ,",
    "let @xmath98 be the non - zero vectors assigned to the vertices @xmath96 .",
    "we define the sets , @xmath99 $ ] and @xmath100 .     and @xmath56 are in conflict",
    ", they must be assigned linearly independent vectors .",
    "this requires that at least one of the sets @xmath101 has to be two dimensional.,width=211 ]    suppose some @xmath102 for some @xmath103 .",
    "then a receiver @xmath15 ( at which the messages corresponding to @xmath104 are unavailable ) ` sees ' an interfering space of dimension @xmath105 .",
    "thus we need to assign a vector linearly independent from @xmath104 ( which itself has dimension @xmath105 ) to the corresponding demanded message of receiver @xmath15 .",
    "this can be possible only if the assigned vectors are of length at least @xmath106 , i.e. the rate can be at most @xmath2 .",
    "therefore , for a rate @xmath58 index coding assignment , all @xmath104 should spanning a space of dimension @xmath107 .",
    "thus we have @xmath108 and @xmath109.$ ] by lemma [ intersectingkdimspaces ] , we should thus have @xmath110    however @xmath94 and @xmath56 are in conflict , which means that they should be assigned linearly independent vectors , i.e. , @xmath111 which means that @xmath112 . thus there is a contradiction and thus any internal conflicts forces the rate to be less than @xmath58 .",
    "this concludes the proof .",
    "from section [ sec3 ] , the following is clear .    *",
    "if there are no conflicts ( not even conflicts between two alignment sets ) in the alignment graph , rate @xmath107 is achievable ( this is the case when any receiver demanding a message has all the other messages as side - information ) . * for rate @xmath107 infeasible index coding problems ,",
    "rate @xmath58 is feasible if and only if there are no internal conflicts .    towards obtaining our main result , which characterises a class of index coding problems which are rate @xmath2 feasible",
    ", we first give a prior known necessary condition for feasibility of rate @xmath2 .",
    "suppose there are @xmath113 messages @xmath114 such that message @xmath115 is demanded by some receiver ( say receiver @xmath116 ) and @xmath117 following @xcite , we call such a set of messages @xmath114 as an _ acyclic subset of messages of size _ @xmath113",
    ". the following theorem can be obtained from the results in @xcite .",
    "[ thmmais ] an index coding problem which is rate @xmath2 feasible can not have an acyclic subset of messages of size @xmath113",
    ".     assigned to the four messages must be linearly independent.,width=192 ]    the following example however shows that theorem [ thmmais ] is not a sufficient condition for rate @xmath2 feasibility .    [ ex : onethirdinfeasible ]    consider a single unicast index coding problem with six messages .",
    "the interfering sets are as follows : @xmath118 . the alignment graph and the conflict hypergraph corresponding to the problem",
    "are given in fig .",
    "[ fig : infeasible ] .",
    "it can be seen that the conflict hypergraph of this problem does not have an acyclic subset of messages of size @xmath113 .",
    "if we assume that the problem is rate @xmath2 feasible , then it has to be necessarily true that both @xmath119 and @xmath120 are two dimensional . we leave it to the reader to check that @xmath121 must also be two dimensional .",
    "however , the conflict between the messages @xmath122 and @xmath123 are resolved only if @xmath121 is three dimensional .",
    "thus , the problem is rate @xmath2 infeasible .      in @xcite , the following theorem about the achievability of rate",
    "@xmath2 was proved ( this is a special case of corollary 9 of @xcite ) .",
    "[ thmnocyclesforks ] consider a rate @xmath58 infeasible index coding problem with no acyclic subset of size @xmath124 if none of its alignment sets have both forks ( a _ fork _ is a vertex connected by three or more edges ) and cycles , then the index coding problem is rate @xmath2 feasible .",
    "as mentioned in @xcite , the condition that there are no alignment sets with both forks and cycles of length @xmath106 means that there is no interfering set @xmath63 at any receiver of size @xmath125 , as such a set would mean that there is both a cycle and fork within an alignment set ( since the messages in @xmath63 are fully connected in the alignment set ) . therefore theorem [ thmnocyclesforks ]",
    "characterises a rather limited class of index coding problems which are @xmath2 feasible .",
    "example [ ex : onethirdfeasible ] shows an index coding problem which does not satisfy the conditions of theorem [ thmnocyclesforks ] but is rate @xmath2 feasible .",
    "[ ex : onethirdfeasible ] consider a single unicast index coding problem with six messages .",
    "the interfering sets of the problem are as follows : @xmath126 . the alignment graph and the conflict hypergraph corresponding to the problem",
    "are given in fig .",
    "[ fig : feasible ] . it can be seen that the alignment graph of this problem has both forks and a cycle .",
    "consider @xmath106 linearly independent @xmath127 vectors @xmath128 .",
    "we note that the following assignment of vectors resolves all conflicts : ( i ) vector @xmath129 to messages @xmath130 and @xmath123 , ( ii ) vector @xmath131 to messages @xmath132 and @xmath133 , ( iii ) vector @xmath134 to messages @xmath135 and @xmath136 .",
    "thus , the problem is rate @xmath2 feasible .      in this subsection",
    ", we develop a new framework for studying the rate @xmath2 feasibility of groupcast index coding problems . towards this",
    ", we define the notions of a triangular interfering set and a type-2 alignment set .    a subset @xmath137 of size three of the set of messages @xmath138",
    "is said to be a _ triangular interfering set _",
    "if all the messages in @xmath137 interfere simultaneously at some receiver , and at least two of the messages in @xmath137 are in conflict .",
    "two distinct triangular interfering sets @xmath139 and @xmath140 are said to be _ adjacent _ if they ` meet ' at a conflicting edge , i.e. , @xmath141 such that @xmath41 and @xmath52 are in conflict .",
    "[ type2align ] two triangular interfering sets @xmath139 and @xmath140 are said to be _ connected _ if there exists a _",
    "( i.e. , a sequence ) of adjacent triangular interfering sets starting from @xmath139 and ending at @xmath140 .",
    "type-2 alignment set _ is a maximal set of triangular interfering sets which are connected to each other .",
    "examples to illustrate the above definitions are shown in fig .",
    "[ fig : triangleinterfset ] .",
    "note that the maximality in definition [ type2align ] means that we can not add another triangular interfering set to a type-2 alignment set and still maintain connectivity ( as in definition [ type2align ] ) .    by definition",
    ", every type-2 alignment set must be a subset of a ( regular ) alignment set , and there could be many type-2 alignment sets within any alignment set . given an index coding problem , we can identify type-2 alignment sets as follows . within any alignment set",
    ", we identify a triangular interfering set of messages ( if there is no such set then there is no type-2 alignment set inside that alignment set )",
    ". then we repeatedly add triangular interfering sets which are adjacent to the existing connected triangular interfering sets .",
    "when we can no longer add such adjacent triangular interfering sets , then we have our type-2 alignment set .",
    "we now prove a necessary condition for rate @xmath2 feasibility based on the vectors assigned to type-2 alignment sets .",
    "this theorem is another application of the key lemma , lemma [ intersectingkdimspaces ] .",
    "[ type2sets2dim ] in any rate @xmath2 solution to a given index coding problem , all the messages in any type-2 alignment set must be assigned vectors from a vector space of dimension two .",
    "let @xmath35 be the encoding function of a rate @xmath2 solution . consider a type-2 alignment set @xmath142 with triangular interfering sets @xmath143.$",
    "]    suppose for any triangular interfering set @xmath144 of @xmath142 , we have @xmath145 .",
    "since all the vertices in @xmath144 interfere at some receiver ( say , a receiver which requests some other message @xmath52 ) , the message @xmath52 must be assigned a vector which is linearly independent from those assigned to the messages in @xmath144 , and thus we need at least @xmath113 linearly independent vectors , and hence the rate has to be @xmath146 .",
    "thus no triangular interfering set @xmath144 of @xmath142 has @xmath145 .",
    "however , any triangular interfering set @xmath144 of @xmath142 _ must _ have @xmath147 , as @xmath144 has a conflict .",
    "suppose @xmath148 .",
    "consider three messages @xmath149 and @xmath150 in @xmath151 that have been assigned three linearly independent vectors , belonging to some three triangular interfering sets ( not necessarily different ) , @xmath152 and @xmath153 respectively .",
    "we have already shown that we can not have @xmath154 .",
    "so at least two of the three triangular interfering sets are different .",
    "suppose all three sets @xmath152 and @xmath153 are different . because the three triangular interfering sets are within the same type-2 alignment set , it must be the case that there exists a path consisting of adjacent triangular interfering sets starting from @xmath155 through @xmath156 and upto @xmath157 let @xmath77 be the number of triangular interfering sets on this path ( counted as we go along the path ; repetitions are counted separately )",
    ". for @xmath158 $ ] , let @xmath159 denote the set of @xmath106 vectors assigned to the @xmath160 triangular interfering set in this path .",
    "[ fig : type2assignment ] illustrates this scenario for the type-2 alignment set example shown in fig . [",
    "fig : type2ex ] .    .",
    "to determine the dimension of the span of these messages , consider the following path of triangular interfering sets : @xmath161 and @xmath162 are the sets of @xmath106 vectors assigned to @xmath160 triangular interfering set.,width=249 ]    by the previous arguments , we have that @xmath163 also , @xmath164,$ ] as the @xmath160 and the @xmath165 triangular interfering sets are adjacent by construction of the path .",
    "therefore , by lemma [ intersectingkdimspaces ] , it must be the case that @xmath166 .",
    "however , the vector assigned to the message @xmath167 belongs to @xmath168 for @xmath169 , and according to our assumption the vectors assigned to these three messages are linearly independent vectors .",
    "thus there is a contradiction , which means that we can not have three messages in three different triangular interfering sets which have been assigned linearly independent vectors .",
    "a similar claim can be proved if the three messages come from two different triangular interfering sets .",
    "thus , no three messages in a type-2 alignment set can be assigned linearly independent vectors .",
    "in other words , any type-2 alignment set @xmath142 in a rate @xmath2 solution must have @xmath170 .",
    "theorem [ type2sets2dim ] is stricter than theorem [ thmmais ] , as theorem [ thmmais ] applies only to an acyclic subset of messages of size @xmath171 which basically is equivalent to a triangular interfering set .",
    "theorem [ type2sets2dim ] on the other hand considers a ` connected component ' of such triangular interfering sets , and is therefore more strict",
    ". we leave it to the reader to verify that the problem in example [ ex : onethirdinfeasible ] , while ` passing ' the condition of theorem [ thmmais ] , ` fails ' the condition of theorem [ type2sets2dim ] .",
    "theorem [ type2sets2dim ] prescribes that type-2 alignment sets must be ` two - dimensional ' in a rate @xmath2 code . in this subsection",
    ", we give a necessary and sufficient condition for achieving this two - dimensionality .",
    "for this purpose , we require the notion of a restricted index coding problem .",
    "let @xmath172 denote an index coding problem with message set @xmath59 .",
    "for some @xmath173 , a @xmath142__-restricted index coding problem _",
    "_ is defined as the index coding problem @xmath174 consisting of    * the messages @xmath142 . *",
    "the subset @xmath175 ( of size @xmath176 ) of the receivers of @xmath172 which demand messages in @xmath142 .",
    "* for each @xmath177 the demand sets @xmath178 and the side - information sets @xmath179 are restricted within @xmath142 , i.e. , @xmath180    the alignment graph and the alignment sets of the restricted index coding problem @xmath174 are called the @xmath142-_restricted alignment graph _ and @xmath142-_restricted alignment sets _ respectively . a @xmath142-_restricted internal conflict _",
    "is a conflict between any two messages within a restricted alignment set of @xmath142 .",
    "the proof of the following theorem is a direct application of theorem [ ratehalfthm ] , and hence is skipped .",
    "[ restrictedratehalfthm ] the restricted index coding problem @xmath174 is rate @xmath58 feasible if and only if there are no @xmath142-restricted internal conflicts .",
    "[ 3cross1restrictedcorr ] for a given index coding problem @xmath172 , there exists an assignment of @xmath181 vectors from a two dimensional vector space ( over a large enough field @xmath3 ) to the messages in a subset @xmath142 such that the conflicts within @xmath142 are resolved , if and only if the restricted index coding problem @xmath174 is rate @xmath58 feasible .",
    "we first recall that conflicts within @xmath142 are said to be resolved if ( [ resolvedconflicts ] ) is satisfied .    _ if part : _ the proof for the if - part follows the achievability scheme shown in the proof of theorem [ ratehalfthm ] , with the difference that we assign to the messages in @xmath142 randomly generated @xmath181 vectors ( not @xmath91 vectors as in theorem [ ratehalfthm ] ) from a two dimensional space over a suitably large field @xmath3 . because @xmath174 is rate @xmath58 feasible , such an assignment resolves the conflicts within @xmath142 .    _ only if part : _ suppose there is an assignment of @xmath181 vectors from a two dimensional vector space to messages in @xmath142 such that all conflicts within @xmath142 are resolved .",
    "then we can always obtain a @xmath182 matrix @xmath6 such that premultiplying all the vectors assigned to @xmath142 with @xmath6 gives us a rate @xmath58 ( length 2 ) index coding solution for @xmath174 .",
    "the following theorem gives a necessary and sufficient condition for assigning vectors from a two dimensional space to the type-2 alignment sets ( i.e. , for satisfying the necessary condition of theorem [ type2sets2dim ] ) .",
    "[ norestrconflictstype2 ] let @xmath142 be a type-2 alignment set of the given index coding problem @xmath172 .",
    "if @xmath172 is rate @xmath2 feasible , then @xmath174 must be rate @xmath58 feasible which holds if and only if there are no @xmath142-restricted internal conflicts .",
    "the proof follows by combining the claims of theorem [ type2sets2dim ] , corollary [ 3cross1restrictedcorr ] and theorem [ restrictedratehalfthm ] .",
    "we now prove the main result of this paper , which connects all the previously proved results and widens the class of index coding problems for which rate @xmath2 is achievable .",
    "because of the framework we have developed in the previous subsections , the proof of this theorem is simpler than theorem [ thmnocyclesforks ] , while also subsuming that result .",
    "[ thm : main ] a rate @xmath58 infeasible index coding problem @xmath172 is rate @xmath2 feasible if every alignment set of @xmath172 satisfies _ either _ of the following conditions .    1 .   it does not have both forks and cycles .",
    "it is a type-2 alignment set with no restricted internal conflicts .",
    "we first make some observations before giving the achievable index coding scheme .    _ observation 1 : _ consider an alignment set @xmath183 of @xmath184 which does not contain both forks and cycles and is also not a triangular interfering set .",
    "we claim that there is no triangular interfering set within @xmath183 .",
    "this is because if there is a triangular interfering set ( say @xmath139 ) then there should be at least one more message which is not included within @xmath139 .",
    "however this would mean that there is both a fork and a cycle within @xmath183 , which is not allowed .",
    "_ observation 2 : _ now suppose there are three messages in @xmath183 such that all of them interfere with a particular receiver .",
    "then there must necessarily be no conflicts in - between the three messages .",
    "this is because if there were conflicts in between the three messages , then these three messages will form a triangular interfering set .",
    "thus no three messages from @xmath183 having at least one conflict in - between themselves can interfere at the same receiver .",
    "_ observation 3 : _ by a similar argument as in observation @xmath107 , if @xmath183 has three messages interfering at a receiver , then it can not have any other message than these three messages ( because if it did , then we would have both cycles and forks within @xmath183 .",
    "_ observation 4 : _ consider an alignment set @xmath185 of @xmath184 which does not contain both forks and cycles , but is also a triangular interfering set .",
    "then , by definition @xmath185 must be a type-2 alignment set .",
    "for the sake of this proof , we consider an alignment set such as @xmath186 as being under the class of type-2 alignment sets .",
    "we thus have three kinds of alignment sets in @xmath172 .    1 .",
    "alignment sets which have no three messages interfering at any receiver .",
    "alignment sets which consists only of three messages , all three interfering at some receiver , without any conflicts in - between .",
    "( these three messages may interfere at other receivers also , but at least one common receiver where they all interfere exists ) .",
    "alignment sets which are also type-2 alignment sets without restricted internal conflicts .     are shown . in the type-2 alignment",
    "set , the receivers at which the triangular interfering sets interfere are not explicitly shown in the figure . since there should not be any restricted internal conflict within a type-2 alignment set , no triangular interfering set interferes at a receiver inside the same type-2 alignment set.,width=249 ]    we now give the achievability index coding scheme by assigning vectors independently to each alignment set of @xmath172 , and the technique of assignment , which follows , depends on the type of the alignment set .",
    "_ alignment set which has no three messages interfering at any receiver : _ for each message in such an alignment set , we assign an independently generated random @xmath181 vector ( over a large field @xmath3 ) .",
    "_ alignment set which consists only of three messages interfering at any receiver without any conflicts in - between : _ we randomly generate a @xmath127 vector and assign it to all the messages in such an alignment set .",
    "_ alignment set which is a type-2 alignment set without restricted internal conflicts : _ let @xmath142 be the type-2 alignment set under concern . for each @xmath142-restricted alignment set , we assign an independently generated random @xmath181 vector from a two dimensional space .",
    "note that this resolves all the conflicts between the messages within @xmath142 , by theorem [ restrictedratehalfthm ] and corollary [ 3cross1restrictedcorr ] .",
    "all the messages fall under one of these alignment sets , and hence all of the messages have been assigned vectors at this point .",
    "let @xmath35 denote encoding function corresponding to this assignment and @xmath48 denote the vector assigned to message @xmath38 .",
    "we now show that this assignment resolves all the conflicts in @xmath172 .",
    "consider a receiver @xmath15 which requests a message @xmath38 .",
    "we proceed on a case by case basis , depending on the size of @xmath63 . for each case",
    "we check whether the condition , @xmath55 ( whp ) , is met .",
    "we call this condition as the _ no conflict condition _ for the sake of this proof .",
    "_ case 1 : _",
    "@xmath187 there are two cases here , either @xmath38 and @xmath63 are in the same alignment set or they are in different alignment sets . if @xmath38 and @xmath63 are in different alignment sets , then @xmath38 and the messages @xmath63 have been assigned independently and randomly generated @xmath181 vectors .",
    "thus the no conflict condition is met .",
    "now , @xmath38 and @xmath63 are in the same alignment set .",
    "this can only be an alignment set where no three messages interfere at any receiver , or a type-2 alignment set . in the former case",
    ", the no conflict condition is met as any three messages in such an alignment set are assigned independent vectors ( whp ) . now if it is a type-2 alignment set , the conflict(s ) between @xmath38 and @xmath63 is(are ) within that type-2 alignment set .",
    "because there are no restricted internal conflicts in any type-2 alignment set , it must be the case that @xmath38 and @xmath63 are in different restricted alignment sets . by our scheme , such conflicts should therefore be resolved .",
    "hence , the no conflict condition is met in this case too .    _",
    "case 2 : _ @xmath188",
    "then we have two cases .",
    "the first case is that no two messages in @xmath63 are in conflict .",
    "this means that @xmath63 must be an alignment set which consists only of three messages without any conflicts in - between , and @xmath38 necessarily belongs to another alignment set . by our scheme , @xmath189 is an one - dimensional space generated by a random vector which is independently generated from the vector assigned to @xmath38 .",
    "hence , the no conflict condition is met .",
    "finally we consider the case when @xmath190 and at least one conflict exists within @xmath63",
    ". then @xmath63 must be within some type-2 alignment set ( say @xmath142 ) .",
    "again we have two sub - cases here , i.e. , @xmath38 and @xmath63 are within the same ( type-2 ) alignment set , or @xmath38 is in a different alignment set than @xmath63 which is within a type-2 alignment set . in the former case ,",
    "the conflicts between @xmath38 and @xmath63 are within the type-2 alignment scheme , which is resolved by our scheme ( by the same arguments as in the last subcase of case 1 ) . in the latter case",
    ", we must have that @xmath189 lies within a two dimensional space ( as it is within a type-2 alignment set ) which is generated independently from the vector assigned to @xmath38 .",
    "hence again the no conflict condition is met .    by the previous arguments",
    ", the no conflict condition is met for any receiver @xmath15 and any demand @xmath38 at @xmath15 .",
    "thus , all the conflicts in @xmath172 are resolved .",
    "this proves the theorem .",
    "in this work , we presented a class of index coding problems for which rate @xmath2 is feasible .",
    "this class of problems is larger than what was previously known .",
    "we believe that the framework developed in this work in order to obtain our results can be leveraged to settle the rate @xmath2 feasibility completely .",
    "in particular , we conjecture that the the necessary condition for rate @xmath2 feasibility of theorem [ norestrconflictstype2 ] is also sufficient .",
    "developing conditions for feasibility of rates of the form @xmath191 would also be an interesting area of future study .",
    "the connection to topological interference management problems follows from @xcite . from @xcite , it is known that the length of scalar linear index codes for the single unicast index coding problem is known to be equal to _ minrank _ of the side - information graph .",
    "thus , our results also imply a class of graphs whose minrank is equal to @xmath106 .",
    "this is a promising result as the general minrank problem is known to be np hard @xcite .",
    "160 y. birk and t. kol ,  coding on demand by an informed source ( iscod ) for efficient broadcast of different supplemental data to caching clients  , ieee transactions on information theory , vol .",
    "52 , no . 6 , june , 2006 , pp .",
    "2825 - 2830 .",
    "a. blasiak , r. kleinberg , and e. lubetzky ,  broadcasting with side information : bounding and approximating the broadcast rate  , ieee transactions on information theory , vol .",
    "2013 , pp .",
    "5811 - 5823 ."
  ],
  "abstract_text": [
    "<S> an index coding problem with @xmath0 messages has symmetric rate @xmath1 if all @xmath0 messages can be conveyed at rate @xmath1 . in a recent work </S>",
    "<S> , a class of index coding problems for which symmetric rate @xmath2 is achievable was characterised using special properties of the side - information available at the receivers . in this paper , we show a larger class of index coding problems ( which includes the previous class of problems ) for which symmetric rate @xmath2 is achievable . in the process , we also obtain a stricter necessary condition for rate @xmath2 feasibility than what is known in literature . </S>"
  ]
}