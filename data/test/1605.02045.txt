{
  "article_text": [
    "in the _ tree compatibility problem _ , we are given a collection @xmath4 of rooted phylogenetic trees with partially overlapping taxon sets .",
    "@xmath0 is called a _ profile _ and the trees in @xmath0 are the _ input trees_. the question is whether there exists a tree @xmath1 whose taxon set is the union of the taxon sets of the input trees , such that @xmath1 exhibits the clusterings implied by the input trees .",
    "that is , if two taxa are together in a subtree of some input tree , then they must also be together in some subtree of @xmath1 .",
    "the tree compatibility problem has been studied for over three decades @xcite .    in the original version of the tree compatibility problem ,",
    "only the leaves of the input trees are labeled . here",
    "we study a generalization , called _ ancestral compatibility _ , in which taxa may be _",
    "nested_. that is , the internal nodes may also be labeled ; these labels represent _ higher - order taxa _ , which are , in effect , sets of taxa .",
    "thus , for example , an input tree may contain the taxon _ glycine max _",
    "( soybean ) nested within a subtree whose root is labeled fabaceae ( the legumes ) , itself nested within an angiosperm subtree .",
    "note that leaves themselves may be labeled by higher - order taxa .",
    "the question now is whether there is a tree @xmath1 whose taxon set is the union of the taxon sets of the input trees , such that @xmath1 exhibits not only the clusterings among the taxa , but also the ancestor / descendant relationships among taxa in the input trees . our main result is a @xmath2 algorithm for the compatibility problem for trees with nested taxa , where @xmath3 is the total number of nodes and edges in the trees in @xmath0 .",
    "[ [ background . ] ] background .",
    "+ + + + + + + + + + +    the tree compatibility problem is a basic special case of the _ supertree problem_. a supertree method is a way to synthesize a collection of phylogenetic trees with partially overlapping taxon sets into a single supertree that represents the information in the input trees . the supertree approach , proposed in the early 90s @xcite , has been used successfully to build large - scale phylogenies @xcite .",
    "the original supertree methods were limited to input trees where only the leaves are labeled .",
    "page @xcite was among the first to note the need to handle phylogenies where internal nodes are labeled , and taxa are nested .",
    "a major motivation is the desire to incorporate _ taxonomies _ as input trees in large - scale supertree analyses , as way to circumvent one of the obstacles to building comprehensive phylogenies : the limited taxonomic overlap among different phylogenetic studies @xcite .",
    "taxonomies group organisms according to a system of taxonomic rank ( e.g. , family , genus , and species ) ; two examples are the ncbi taxonomy @xcite and the angiosperm taxonomy @xcite .",
    "taxonomies spanning a broad range of taxa provide structure and completeness that might be hard to obtain otherwise .",
    "a recent example of the utility of taxonomies is the open tree of life , a draft phylogeny for over 2.3 million species @xcite .",
    "taxonomies are not , strictly speaking , phylogenies .",
    "in particular , their internal nodes and some of their leaves are labeled with higher - order taxa .",
    "nevertheless , taxonomies have many of the same mathematical characteristics as phylogenies .",
    "indeed , both phylogenies and taxonomies are _ semi - labeled trees _ @xcite .",
    "we will use this term throughout the rest of the paper to refer to trees with nested taxa .    the fastest previous algorithm for testing ancestral compatibility , based on earlier work by daniel and semple @xcite ,",
    "is due to berry and semple @xcite .",
    "their algorithm runs in @xmath5 time using @xmath6 space . here , @xmath7 is the number of distinct taxa in @xmath0 and @xmath8 , where @xmath9 is the set of internal nodes of @xmath10 , for each @xmath11 , and @xmath12 is the degree of node @xmath13 .",
    "while the algorithm is polynomial , its dependence on node degrees is problematic : semi - labeled trees can be highly unresolved ( i.e. , contain nodes of high degree ) , especially if they are taxonomies .    [",
    "[ our - contributions . ] ] our contributions .",
    "+ + + + + + + + + + + + + + + + + +    the @xmath2 running time of our ancestral compatibility algorithm is independent of the degrees of the nodes of the input trees , a valuable characteristic for large datasets that include taxonomies . to achieve this time bound ,",
    "we extend ideas from our recent algorithm for testing the compatibility of ordinary phylogenetic trees @xcite . as in that algorithm , a central notion in the current paper is the _ display graph _ of profile @xmath0 , denoted @xmath14 .",
    "this is the graph obtained from the disjoint union of the trees in @xmath0 by identifying nodes that have the same label ( see section [ sec : testac ] ) .",
    "the term `` display graph '' was introduced by bryant and lagergren @xcite , but similar ideas have been used elsewhere . in particular , the display graph is closely related to berry and semple s _ restricted descendancy graph _ @xcite , a mixed graph whose directed edges correspond to the ( undirected ) edges of @xmath14 and whose undirected edges have no correspondence in @xmath14 .",
    "the second kind of edges are the major component of the @xmath15 term in the time and space complexity of berry and semple s algorithm .",
    "the absence of such edges makes @xmath14 significantly smaller than the restricted descendancy graph .",
    "display graphs also bear some relation to _ tree alignment graphs _ @xcite .    here",
    ", we exploit the display graph more extensively and more directly than our previous work . although the display graph of a collection of semi - labeled trees is more complex than that of a collection of ordinary phylogenies , we are able to extend several of the key ideas  notably , that of a semi - universal label  to the general setting of semi - labeled trees . as in @xcite ,",
    "the implementation relies on a dynamic graph data structure , but it requires a more careful amortized analysis based on a weighing scheme .    [ [ contents . ] ] contents .",
    "+ + + + + + + + +    section [ sec : prelims ] presents basic definitions regarding semi - labeled trees and ancestral compatibility . .",
    "section [ sec : dispgraph ] introduces the display graph and discusses its properties .",
    "section [ sec : testac ] presents @xmath16 , our algorithm for testing ancestral compatibility .",
    "section [ sec : implementation ] gives the implementation details for @xmath16 .",
    "section [ sec : discussion ] gives some concluding remarks .",
    "for each positive integer @xmath17 , @xmath18 $ ] denotes the set @xmath19 .",
    "let @xmath20 be a graph .",
    "@xmath21 and @xmath22 denote the node and edge sets of @xmath20",
    ". the _ degree _ of a node @xmath23 is the number of edges incident on @xmath13 .",
    "a _ tree _ is an acyclic connected graph . in this paper , all trees",
    "are assumed to be rooted . for a tree @xmath24",
    ", @xmath25 denotes the root of @xmath24 .",
    "suppose @xmath26 .",
    "then , @xmath27 is an _ ancestor _ of @xmath13 in @xmath24 , denoted @xmath28 , if @xmath27 lies on the path from @xmath13 to @xmath25 in @xmath24 .",
    "if @xmath28 , then @xmath13 is a _ descendant _ of @xmath27 .",
    "node @xmath27 is a _ proper descendant _ of @xmath13 if @xmath27 is a descendant of @xmath13 and @xmath29 .",
    "if @xmath30 and @xmath28 , then @xmath27 is the _ parent _ of @xmath13 and @xmath13 is a _ child _ of @xmath27 .",
    "if neither @xmath28 nor @xmath31 hold , then we write @xmath32 and say that @xmath27 and @xmath13 are _ not comparable _ in @xmath24 .",
    "[ [ semi - labeled - trees . ] ] semi - labeled trees .",
    "+ + + + + + + + + + + + + + + + + + +    a _ semi - labeled tree _ is a pair @xmath33 where @xmath24 is a tree and @xmath34 is a mapping from a set @xmath35 to @xmath36 such that , for every node @xmath37 of degree at most two , @xmath38 .",
    "@xmath35 is the _ label set _ of @xmath1 and @xmath34 is the _ labeling function _ of @xmath1 .    for every node @xmath37",
    ", @xmath39 denotes the ( possibly empty ) subset of @xmath35 whose elements map into @xmath13 ; these elements as the _ labels of @xmath13 _ ( thus , each label is a taxon ) . if @xmath40 , then @xmath13 is _ labeled _ ; otherwise , @xmath13 is _",
    "unlabeled_. note that , by definition , every leaf in a semi - labeled tree is labeled .",
    "further , any node , including the root , that has a single child must be labeled .",
    "nodes with two or more children may be labeled or unlabeled .",
    "a semi - labeled tree @xmath33 is _ singularly labeled _ if every node in @xmath24 has at most one label ; @xmath1 is _ fully labeled _ if every node in @xmath24 is labeled .",
    "semi - labeled trees , also known as _",
    "@xmath41-trees _ , generalize ordinary phylogenetic trees , also known as _ phylogenetic @xmath41-trees _ @xcite .",
    "an ordinary phylogenetic tree is a semi - labeled tree @xmath33 where @xmath25 has degree at least two and @xmath34 is a bijection from @xmath35 into leaf set of @xmath24 ( thus , internal nodes are not labeled ) .",
    "let @xmath33 be a semi - labeled tree and let @xmath42 and @xmath43 be two labels in @xmath35 . if @xmath44 , then we write @xmath45 , and say that @xmath43 is a _ descendant _ of @xmath42 in @xmath1 and that @xmath42 is an _ ancestor _ of @xmath43 .",
    "we write @xmath46 if @xmath47 is a proper descendant of @xmath48 .",
    "if @xmath49 , then we write @xmath50 and say that @xmath42 and @xmath43 are _ not comparable _ in @xmath1 . if @xmath1 is fully labeled and @xmath48 is the parent of @xmath47 in @xmath24 , then @xmath42 is the _ parent _ of @xmath43 in @xmath1 and @xmath43 is a _ child _ of @xmath42 in @xmath1 ; two labels with the same parent are _",
    "siblings_.    two semi - labelled trees @xmath33 and @xmath51 are _ isomorphic _ if there exists a bijection @xmath52 such that @xmath53 and , for any two nodes @xmath26 , @xmath54 if and only @xmath55 .",
    "let @xmath33 be a semi - labeled tree .",
    "for each @xmath56 , @xmath57 denotes the set of all labels in the subtree of @xmath24 rooted at @xmath27 ; that is , @xmath58 .",
    "@xmath57 is called a _ cluster _ of @xmath24 .",
    "@xmath59 denotes the set of all clusters of @xmath1 .",
    "it is well known ( * ? ? ?",
    "* theorem 3.5.2 ) that a semi - labeled tree @xmath1 is completely determined by @xmath59 .",
    "that is , if @xmath60 for some other semi - labeled tree @xmath61 , then @xmath1 is isomorphic to @xmath61 .",
    "suppose @xmath62 for a semi - labeled tree @xmath33 .",
    "the _ restriction _ of @xmath1 to @xmath63 , denoted @xmath64 , is the semi - labeled tree whose cluster set is @xmath65 intuitively , @xmath66 is obtained from the minimal rooted subtree of @xmath24 that connects the nodes in @xmath67 by suppressing all vertices of degree two that are not in @xmath67 .",
    "let @xmath33 and @xmath51 be semi - labeled trees such that @xmath68 .",
    "@xmath1 _ ancestrally displays _",
    "@xmath61 if @xmath69 .",
    "equivalently , @xmath1 ancestrally displays @xmath61 if @xmath61 can be obtained from @xmath70 by contracting edges , and , for any @xmath71 , ( i ) if @xmath72 , then @xmath73 , and ( ii ) if @xmath74 , then @xmath75 . the notion of `` ancestrally displays '' for semi - labeled trees generalizes the well - known notion of `` displays '' for ordinary phylogenetic trees @xcite .    for a semi - labelled tree @xmath1 ,",
    "let @xmath76 note that @xmath77 consists of _ ordered _ pairs , while @xmath78 consists of _ unordered _ pairs .",
    "[ lm : dn ] let @xmath1 and @xmath61 be semi - labelled trees such that @xmath68",
    ". then @xmath1 ancestrally displays @xmath61 if and only if @xmath79 and @xmath80 .    [",
    "[ profiles - and - ancestral - compatibility . ] ] profiles and ancestral compatibility .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    throughout the rest of this paper @xmath81 denotes a set where , for each @xmath82 $ ] , @xmath83 is a semi - labeled tree .",
    "we refer to @xmath0 as a _ profile _ , and write @xmath84 to denote @xmath85 } l({\\ensuremath{\\mathcal{t}}}_i)$ ] , the _ label set _ of @xmath0 .",
    "figure  [ fig : profile ] shows a profile where @xmath86 .",
    "we write @xmath87 for @xmath85 } v(t_i)$ ] and @xmath88 for @xmath85 } e(t_i)$ ] , the _ size _ of @xmath0 is @xmath89 .     for the profile of figure [ fig : profile ] .",
    "]     for the profile of figure [ fig : profile ] . ]     for the profile of figure [ fig : profile ] . ]",
    "@xmath0 is _ ancestrally compatible _ if there is a rooted semi - labeled tree @xmath1 that ancestrally displays each of the trees in @xmath0 .",
    "if @xmath1 exists , we say that @xmath1 _ ancestrally displays _",
    "@xmath0 ( see figure [ fig : supertree ] ) .",
    "given a subset @xmath41 of @xmath84 , the _ restriction _ of @xmath0 to @xmath41 , denoted @xmath90 , is the profile @xmath91 .",
    "the proof of the following lemma is straightforward .",
    "[ lm : compatsubprofile ] suppose @xmath0 is ancestrally compatible and let @xmath1 be a tree that ancestrally displays @xmath0",
    ". then , for any @xmath92 , @xmath93 ancestrally displays @xmath94 .",
    "a semi - labeled tree @xmath95 is _ fully labeled _ if every node in @xmath24 is labeled .",
    "suppose @xmath0 contains trees that are not fully labeled .",
    "we can convert @xmath0 into an equivalent profile @xmath96 of fully - labeled trees as follows .",
    "for each @xmath82 $ ] , let @xmath97 be the number of unlabeled nodes in @xmath98 .",
    "create a set @xmath99 of @xmath100 } l_i$ ] labels such that @xmath101 .",
    "for each @xmath82 $ ] and each @xmath102 such that @xmath103 , make @xmath104 , where @xmath42 is a distinct element from @xmath99 .",
    "we refer to @xmath96 as the _ profile obtained by adding distinct new labels to @xmath0 _",
    "( see figure [ fig : profile ] ) .",
    "[ lm : fullyl ] let @xmath96 be the profile obtained by adding distinct new labels to @xmath0 . then",
    ", @xmath0 is ancestrally compatible if and only if @xmath96 is ancestrally compatible .",
    "further , if @xmath1 is a semi - labeled phylogenetic tree that ancestrally displays @xmath96 , then @xmath1 ancestrally displays @xmath0 .    from this point",
    "forward , we shall assume that , for each @xmath82 $ ] , @xmath10 is fully and singularly labeled .",
    "by lemma [ lm : fullyl ] , no generality is lost in assuming that all trees in @xmath0 are fully labeled .",
    "the assumption that the trees are singularly labeled is inessential ; it is only for clarity .",
    "note that , even with the latter assumption , a tree that ancestrally displays @xmath0 is not necessarily singularly labeled .",
    "figure [ fig : supertree ] illustrates this fact .",
    "the _ display graph _ of a profile @xmath0 , denoted @xmath14 , is the graph obtained from the disjoint union of the underlying trees @xmath105 by identifying nodes that have the same label .",
    "multiple edges between the same pair of nodes are replaced by a single edge .",
    "see figure  [ fig : displaygraph ] .",
    "@xmath14 has @xmath106 nodes and edges , and can be constructed in @xmath106 time . by our assumption",
    "that all the trees in @xmath0 are fully and singularly labeled , there is a bijection between the labels in @xmath84 and the nodes of @xmath14 .",
    "thus , from this point forward , we refer to the nodes of @xmath14 by their labels .",
    "it is easy to see that if @xmath14 is not connected , then @xmath0 decomposes into label - disjoint sub - profiles , and that @xmath0 is compatible if and only if each sub - profile is compatible .",
    "thus , we shall assume , without loss of generality , that @xmath14 is connected .",
    "[ [ positions . ] ] positions .",
    "+ + + + + + + + + +    a _ position _ ( for @xmath0 ) is a vector @xmath107 , where @xmath108 , for each @xmath82 $ ] . since labels may be shared among trees , we may have @xmath109 , for @xmath110 $ ] with @xmath111",
    ". for each @xmath82 $ ] , let @xmath112 , and let @xmath113 } { \\ensuremath{\\mathrm{desc}}}_i(u)$ ] .",
    "a position @xmath114 is _ valid _ if , for each @xmath82 $ ] ,    1 .",
    "[ item : v1 ] if @xmath115 , then the elements of @xmath116 are siblings in @xmath10 and 2 .   [ item : v2 ] @xmath117 .",
    "[ lem : v2 ] for any valid position @xmath114 , @xmath118 .    by ( v[item : v2 ] ) , we have that @xmath119 and @xmath120 are isomorphic , for each @xmath82 $ ] .",
    "the lemma then follows from the definition of @xmath121 .    for any valid position @xmath114",
    ", @xmath122 denotes the subgraph of @xmath14 induced by @xmath123 .",
    "[ obs : update1 ] for any valid position @xmath114 , @xmath122 is the subgraph of @xmath14 obtained by deleting all labels in @xmath124 , along with all incident edges .",
    "a valid position of special interest to us is @xmath125 , where @xmath126 , for each @xmath82 $ ] .",
    "that is , @xmath127 is a singleton containing only the label of @xmath128 .",
    "thus , in figure [ fig : displaygraph ] , @xmath129 .",
    "it is straightforward to verify that @xmath125 is indeed valid , that @xmath130 , and that @xmath131 .",
    "[ [ semi - universal - labels . ] ] semi - universal labels .",
    "+ + + + + + + + + + + + + + + + + + + + + +    let @xmath114 be a valid position , and let @xmath42 be a label in @xmath114 .",
    "then , @xmath42 is _ semi - universal in @xmath114 _ if @xmath132 , for every @xmath82 $ ] such that @xmath133 .",
    "it can be verified that in figure [ fig : displaygraph ] , labels @xmath134 and @xmath135 are semi - universal in @xmath125 , but @xmath136 is not , since @xmath136 is in both @xmath137 and @xmath138 , but @xmath139 .    the term `` semi - universal '' , borrowed from peer et al .",
    "@xcite , derives from the following fact .",
    "suppose that @xmath0 is ancestrally compatible , that @xmath1 is a tree that ancestrally displays @xmath0 , and that @xmath42 is a semi - universal label for some valid position @xmath114 .",
    "then , as we shall see , @xmath42 must label the root @xmath140 of a subtree of @xmath1 that contains all the descendants of @xmath42 in @xmath10 , for every @xmath141 such that @xmath133 .",
    "the qualifier `` semi '' is because this subtree may also contain labels that do not descend from @xmath42 in any input tree , but descend from some other semi - universal label @xmath43 in @xmath114 instead . in this case",
    ", @xmath43 also labels @xmath140 .",
    "this property of semi - universal labels is exploited in both our ancestral compatibility algorithm and its proof of correctness ( see section [ sec : testac ] ) .    for each label",
    "@xmath142 , let @xmath143 denote the number of input trees that contain label @xmath42 .",
    "we can obtain @xmath143 for every @xmath142 in @xmath106 time during the construction of @xmath14 .",
    "[ lem : semiu ] let @xmath144 be a valid position . then",
    ", label @xmath42 is semi - universal in @xmath114 if the cardinality of the set @xmath145 : u(i ) = \\{\\ell\\}\\}$ ] equals @xmath143 .    by definition , @xmath132 , for every @xmath146 .",
    "since @xmath147 , the lemma follows .",
    "[ [ successor - positions . ] ] successor positions .",
    "+ + + + + + + + + + + + + + + + + + + +    for every @xmath82 $ ] and every @xmath133 , let @xmath148 denote the set of children of @xmath42 in @xmath149 . for a subset @xmath63 of @xmath149 , let @xmath150 .",
    "let @xmath114 be a valid position , and @xmath151 be the set of semi - universal labels in @xmath114 .",
    "the _ successor of @xmath114 with respect to @xmath151 _ is the position @xmath152 defined as follows . for each @xmath153 and each @xmath82 $ ] , if @xmath132 , then @xmath154 ; otherwise , @xmath155 .    in figure",
    "[ fig : displaygraph ] , the set of semi - universal labels in @xmath125 is @xmath156 . since @xmath157 and @xmath158 , the successor of @xmath125 is @xmath159 .",
    "[ obs : update2 ] let @xmath114 be a valid position , and let @xmath152 be the successor of @xmath114 with respect to the set @xmath151 of semi - universal labels in @xmath114 .",
    "then , @xmath160 can be obtained from @xmath122 by doing the following for each @xmath153 : ( 1 ) for each @xmath82 $ ] such that @xmath132 , delete all edges between @xmath42 and @xmath148 ; ( 2 ) delete @xmath42 .",
    "let @xmath114 be a valid position , and @xmath161 be a subset of @xmath123 .",
    "then , @xmath162 denotes the position @xmath163 . in figure",
    "[ fig : displaygraph ] , the components of @xmath160 , where @xmath152 is the successor of @xmath125 , are @xmath164 and @xmath165 . thus , @xmath166 and @xmath167 . we have the following result .",
    "[ lm : childofu ] let @xmath114 be a valid position , and @xmath151 be the set of all semi - universal labels in @xmath114 .",
    "let @xmath152 be the successor of @xmath114 with respect to @xmath151 , and let @xmath168 be the label sets of the connected components of @xmath160 .",
    "then , @xmath169 is a valid position , for each @xmath170 $ ] .",
    "it suffices to argue that @xmath152 satisfies conditions ( v[item : v1 ] ) and ( v[item : v2 ] ) .",
    "the lemma then follows from the fact that the connected components of @xmath160 are label - disjoint .",
    "@xmath152 must satisfy condition ( v[item : v1 ] ) , since @xmath114 does .",
    "suppose @xmath153 .",
    "then , for each @xmath82 $ ] such that @xmath133 , @xmath171 and @xmath172 .",
    "thus , since ( v[item : v2 ] ) holds for @xmath114 , it also holds for @xmath152 .",
    "@xmath16  ( algorithm [ alg : slbuild ] ) is our algorithm for testing compatibility of semi - labeled trees .",
    "its argument , @xmath114 , is a valid position in @xmath0 such that @xmath173 is connected .",
    "line [ alg : findsemi ] computes the set @xmath151 of semi - universal labels in @xmath114 .",
    "if @xmath151 is empty , then , as argued in theorem [ thm : buildcorrect ] below , @xmath174 is incompatible , and , thus , so is @xmath0 . this fact is reported in line [ alg : s0emptyincompat ] .",
    "line [ alg : s0singleton ] checks if @xmath151 contains exactly one label @xmath42 , with no proper descendants .",
    "if so , by the connectivity assumption , @xmath42 must be the only element in @xmath123 .",
    "therefore , line [ alg : s0singletonreturn ] simply returns the tree with a single node , labeled @xmath42 .",
    "line [ alg : updateu ] updates @xmath114 , replacing it by its successor with respect to @xmath151 .",
    "let @xmath175 be the connected components of @xmath122 after updating @xmath114 . by lemma [ lm : childofu ]",
    ", @xmath176 is a valid position , for each @xmath170 $ ] .",
    "lines [ alg : connected][alg : recurseend ] recursively invoke @xmath177 on @xmath176 for each @xmath170 $ ] , to determine if there is a tree @xmath178 that ancestrally displays @xmath179 .",
    "if any subproblem is incompatible , line [ alg : recurseend ] reports that @xmath0 is incompatible .",
    "otherwise , lines [ alg : ru][alg : finalreturn ] assemble the @xmath178s into a single tree that displays @xmath174 , whose root is labeled by the semi - universal labels in the set @xmath151 of line [ alg : findsemi ] .",
    "let @xmath180 [ alg : findsemi ] replace @xmath114 by the successor of @xmath114 with respect to @xmath151.[alg : updateu ] let @xmath168 be the connected components of @xmath122 [ alg : connected ]    create a node @xmath181 , whose label set is @xmath151 [ alg : ru ] the tree with root @xmath181 and subtrees @xmath182 [ alg : finalreturn ]    next , we argue the correctness of @xmath177 .    [",
    "thm : buildcorrect ] let @xmath183 be a profile and let @xmath184 , where , for each @xmath82 $ ] , @xmath126 . then , @xmath185 returns either ( i ) a semi - labeled tree @xmath1 that ancestrally displays @xmath0 , if @xmath0 is ancestrally compatible , or ( ii ) ` incompatible ` otherwise .",
    "\\(i ) suppose that @xmath185 outputs a semi - labeled tree @xmath1 .",
    "we prove that @xmath1 ancestrally displays @xmath0 . by lemma [ lm : dn ]",
    ", it suffices to show that @xmath186 and @xmath187 , for each @xmath82 $ ] .",
    "consider any @xmath188 .",
    "then , @xmath42 has a child @xmath189 in @xmath10 such that @xmath190 .",
    "there must be a recursive call to @xmath191 , for some valid position @xmath114 , where @xmath42 is the set @xmath151 of semi - universal labels obtained in line [ alg : findsemi ] . by observation [ obs : update2 ] ,",
    "label @xmath189 , and thus @xmath43 , both lie in one of the connected components of the graph obtained by deleting all labels in @xmath151 , including @xmath42 , and their incident edges from @xmath122 .",
    "it now follows from the construction of @xmath1 that @xmath192 .",
    "thus , @xmath186 .",
    "now , consider any @xmath193 .",
    "let @xmath13 be the lowest common ancestor of @xmath194 and @xmath195 in @xmath10 and let @xmath196 be the label of @xmath13 .",
    "then , @xmath196 has a pair of children , @xmath197 and @xmath198 say , in @xmath10 such that @xmath199 , and @xmath200 . because @xmath185 returns a tree",
    ", there are recursive calls @xmath201 and @xmath202 for valid positions @xmath203 and @xmath204 such that @xmath197 is semi - universal for @xmath203 and @xmath198 is semi - universal for @xmath204 .",
    "we must have @xmath205 ; otherwise , @xmath206 , and , thus , neither @xmath197 nor @xmath198 is semi - universal , a contradiction .",
    "further , it follows from the construction of @xmath1 that we must have @xmath207 .",
    "hence , @xmath50 , and , therefore , @xmath208 .",
    "\\(ii ) asssume , by way of contradiction , that @xmath185 returns ` incompatible ` , but that @xmath0 is ancestrally compatible . by assumption , there exists a semi - labeled tree @xmath1 that ancestrally displays @xmath0 . since @xmath185 returns ` incompatible ` , there is a recursive call to @xmath191 for some valid position @xmath114 such that @xmath114 has no semi - universal label , and the set @xmath151 of line [ alg : findsemi ] is empty . by lemma  [ lm : compatsubprofile ]",
    ", @xmath209 ancestrally displays @xmath174 .",
    "thus , by lemma [ lem : v2 ] , @xmath209 ancestrally displays @xmath210 , for every @xmath82 $ ] .",
    "let @xmath42 be any label in the label set of the root of @xmath209 .",
    "then , for each @xmath82 $ ] such that @xmath211 , @xmath42 must be the label of the root of @xmath119 .",
    "thus , for each such @xmath141 , @xmath132 .",
    "hence , @xmath42 is semi - universal in @xmath114 , a contradiction .",
    "here we describe an efficient implementation of @xmath177 .",
    "we focus on two key aspects : finding semi - universal labels in line [ alg : findsemi ] , and updating @xmath114 and @xmath122 in lines [ alg : updateu ] and [ alg : connected ] .    by observation [ obs : update1 ] , at each recursive call , @xmath177 deals with a graph obtained from @xmath14 through edge and node deletions .",
    "to handle these deletions efficiently , we represent @xmath14 using the dynamic graph connectivity data structure of holm et al .",
    "@xcite , which we refer to as _ hdt_. hdt allows us to maintain the list of nodes in each component , as well as the number of these nodes so that , if we start with no edges in a graph with @xmath212 nodes , the amortized cost of each update is @xmath213 .",
    "since @xmath14 has @xmath106 nodes , each update takes @xmath214 time . the total number of edge and node deletions performed by @xmath185  including all deletions in the recursive calls",
    " is at most the total number of edges and nodes in @xmath14 , which is @xmath106 .",
    "hdt allows us to maintain connectivity information throughout the entire algorithm in @xmath215 time .",
    "as deletions are performed on @xmath14 , @xmath177 maintains three data fields for each connected component @xmath216 that is created : @xmath217 , @xmath218 , and @xmath219 .",
    "it also maintains a field @xmath220 , for each @xmath142 .    1 .",
    "@xmath217 equals @xmath221 .",
    "2 .   @xmath218 is a map from a set @xmath222 $ ] to a set of nonempty subsets of @xmath223 .",
    "for each @xmath224 , @xmath225 denotes the set associated with @xmath141 .",
    "3 .   @xmath220 equals the cardinality of the set @xmath226 : y.{\\ensuremath{\\mathtt{map}}}(i ) \\text { is defined and } y.{\\ensuremath{\\mathtt{map}}}(i ) = \\{\\ell\\}\\}$ ] .",
    "( recall that @xmath143 is the number of input trees that contain @xmath42 . )",
    "@xmath227 is a set containing all labels @xmath228 such that @xmath229 .",
    "informally , each set @xmath225 corresponds to a non - empty @xmath116 ; @xmath227 corresponds to the semi - universal labels in @xmath216 .",
    "next , we formalize these ideas .    at the start of the execution of @xmath191 for any valid position @xmath114",
    ", @xmath122 has a single connected component , @xmath230 .",
    "our implementation maintains the following invariant .",
    "inv : : :    at the beginning of the execution of    @xmath191 ,    @xmath231 for each    @xmath82 $ ] such that @xmath232 ,    and @xmath233 is undefined for    each @xmath82 $ ] such that @xmath234 .",
    "thus , @xmath220 equals the number of indices @xmath82 $ ] such that @xmath132 .",
    "along with lemma [ lem : semiu ] , inv implies that , at the beginning of the execution of @xmath191 , @xmath235 contains precisely the semi - universal labels of @xmath114 .",
    "thus , the set @xmath151 of line [ alg : findsemi ] of @xmath191 can be retrieved in @xmath236 time .    to establish inv for the initial valid position @xmath125",
    ", we proceed as follows . by assumption",
    ", @xmath237 has a single connected component , @xmath238 .",
    "since @xmath237 equals @xmath14 , we initialize data fields 14 for @xmath239 during the construction of @xmath14 .",
    "@xmath240 is simply @xmath241 . for each @xmath82 $ ] , @xmath242 is @xmath243 , where @xmath42 is the label of the root of @xmath98 .",
    "we initialize the @xmath244  fields as follows .",
    "first , set @xmath220 to @xmath245 for all @xmath142",
    ". then , iterate through each @xmath82 $ ] , incrementing @xmath220 by one if @xmath246 . finally , @xmath247 consists of all @xmath248 such that @xmath229 .",
    "all data fields can be initialized in @xmath106 time .",
    "we now focus on lines [ alg : updateu ] and [ alg : connected ] of @xmath177 . by observation [ obs : update2 ]",
    ", we can update @xmath114 and @xmath122 jointly as follows .",
    "we use a temporary variable @xmath249 . prior to executing line [ alg : updateu ] , we set @xmath250 .",
    "then , we successively consider each label @xmath153 , and perform two steps : ( i ) initialize data fields 14 in preparation for the deletion of @xmath42 and ( ii ) delete from @xmath249 the edges incident on @xmath42 and then @xmath42 itself , updating data fields 14 as necessary , to maintain inv .",
    "after these steps are executed , @xmath249 will equal @xmath122 for the new set @xmath114 created by line [ alg : updateu ] . steps ( i ) and ( ii ) are done by @xmath251 ( algorithm [ alg : initmarks ] ) and @xmath252 ( algorithm [ alg : dellabel ] ) , respectively .",
    "lines [ alg : delsemi][alg : addpairmap ] of @xmath251 initialize @xmath218 and @xmath227 to reflect the fact that label @xmath153 is leaving @xmath116 , for each @xmath82 $ ] such that @xmath253 , to be replaced by its children in @xmath10 , and will no longer be semi - universal . lines [ alg : initsingleton][alg : foraddalphasemi ] are needed to update certain @xmath254 fields due to the possibility that singleton sets @xmath225 may be created in the preceding steps .",
    "the number of operations on @xmath218 performed by @xmath251 is @xmath255 : \\ell \\in l({\\ensuremath{\\mathcal{t}}}_i ) } |{{\\ensuremath{{\\mathrm{ch}}}}}_i(\\ell)|)$ ] ; i.e. , it is proportional to the total number of children of @xmath42 in all the input trees . since @xmath42 is considered only once , the total number of operations on @xmath256 fields of the various sets @xmath216 considered over the entire execution of @xmath185 is @xmath106 .",
    "the number of updates of @xmath218 done by @xmath251 is at most @xmath143 ; the total over all @xmath42 considered by @xmath185 over its entire execution is @xmath106 .",
    "delete @xmath42 from @xmath227 [ alg : delsemi ]    @xmath252 begins by consulting hdt to identify the connected component @xmath216 that currently contains @xmath42 .",
    "the loop in lines [ alg : forscanedges][alg : endforscanedges ] successively deletes each edge between @xmath42 and a child @xmath257 of @xmath42 , updating the appropriate data fields for the resulting connected components .",
    "line [ alg : testconn ] queries the hdt data structure to determine whether deleting @xmath258 splits @xmath216 into two components .",
    "if @xmath216 remains connected , no updates are needed  the * continue * statement skips the rest of the current iteration and proceeds directly to the next .",
    "otherwise , @xmath216 is split into two parts @xmath259 and @xmath260 .",
    "@xmath261 uses a weighted version of the technique of scanning the smaller component @xcite .",
    "line [ alg : smallerweight ] identifies which of the two components has the smaller @xmath262  field ; without loss of generality , it assumes that @xmath263 .",
    "lines [ alg : delinity1 ] and [ alg : delinity2 ] initialize @xmath264 and @xmath265 to @xmath266  and @xmath267 and @xmath268 to the corresponding fields of @xmath216 .",
    "lines [ alg : forbetay1][alg : addtoj ] , scan each label @xmath269 in @xmath259 , from @xmath270 to @xmath271 , for every @xmath141 such that @xmath272 . set @xmath273 ,",
    "updated in line [ alg : addtoj ] , keeps track of the indices @xmath141 such that @xmath271 and @xmath270 are modified . lines [ alg : forupdatesemi][alg : endforscanedges ] iterate through @xmath273 to determine if any new singleton sets were created in either @xmath259 or @xmath260 .",
    "this operation requires at most one update in each of @xmath265 and @xmath268 ; each update takes @xmath236 time .",
    "after all edges incident on @xmath42 are deleted , @xmath42 itself is deleted ( line [ alg : delell ] ) .",
    "the preceding description of @xmath252 omits the updating of the @xmath274 fields of the connected components created by an edge deletion .",
    "this is done before line [ alg : smallerweight ] , by ( again ) using the technique of scanning the smaller component .",
    "we consult hdt to determine which of @xmath259 and @xmath260 has fewer labels .",
    "assuming , without loss of generality , that @xmath275 , compute @xmath276 in a sequential scan of @xmath259 .",
    "then , @xmath277 .",
    "let @xmath216 be the connected component of @xmath249 that contains @xmath42 [ alg : findy ] delete @xmath42 from @xmath249 [ alg : delell ]    let us track the number of operations on @xmath256 fields in lines [ alg : forbetay1][alg : addtoj ] of @xmath252 that can be attributed to some specific label @xmath278 over the entire execution of @xmath185 .",
    "each execution of lines [ alg : forbetay1][alg : addtoj ] for @xmath269 performs @xmath279 operations on @xmath256 fields .",
    "let @xmath280 be the weight of the connected component containing @xmath269 at the beginning of the loop of lines [ alg : forbetay1][alg : addtoj ] , at the @xmath17th time that @xmath269 is considered in those lines ; thus , @xmath281 .",
    "then , @xmath282 .",
    "the reason is that we only consider @xmath269 if ( i ) @xmath269 is contained in one of the two components that result from deleting an edge in line [ alg : deleteedge ] and ( ii ) the component containing @xmath269 has the smaller weight of the two components .",
    "thus , the number of times @xmath269 is considered in lines [ alg : forbetay1][alg : addtoj ] over the entire execution of @xmath185 is @xmath283 , which is @xmath284 , since @xmath285 .",
    "therefore , the total number of updates of @xmath256 fields over all labels is @xmath286 , which is @xmath287 .",
    "it can be verified that the number of updates to @xmath244  and @xmath288  fields is also @xmath287 .",
    "a similar analysis shows that the total time to update @xmath274 fields over all edge deletions performed by @xmath185 is @xmath287 .",
    "to summarize , the work done by @xmath185 consists of three parts : ( i ) initialization , ( ii ) maintaining connected components , and ( iii ) maintaining the @xmath262 , @xmath289 , and @xmath288 , and fields for each connected component , as well as @xmath220 for each label @xmath42 .",
    "part ( i ) takes @xmath106 time . part ( ii )",
    "involves @xmath106 edge and node deletions on the hdt data structure , at an amortized cost of @xmath214 per deletion . part ( iii ) requires a total of @xmath287 updates to the various fields .",
    "using data structures that take logarithmic time per update , leads to our main result .",
    "[ thm : slbuilda ] @xmath16  can be implemented so that @xmath16@xmath290 runs in @xmath215 time .",
    "like our earlier algorithm for compatibility of ordinary phylogenetic trees , the more general algorithm presented here , @xmath16 , is a polylogarithmic factor away from optimality ( a trivial lower bound is @xmath291 , the time to read the input ) .",
    "@xmath16  has a linear - space implementation , using the results of thorup @xcite .",
    "a question to be investigated next is the performance of the algorithm on real data .",
    "another important issue is integrating our algorithm into a synthesis method that deals with incompatible profiles .            o.  r.  p.",
    "bininda - emonds , m.  cardillo , k.  e. jones , r.  d.  e. macphee , r.  m.  d. beck , r.  grenyer , s.  a. price , r.  a. vos , j.  l. gittleman , and a.  purvis .",
    "the delayed rise of present - day mammals .",
    ", 446:507512 , 2007 .",
    "p.  daniel and c.  semple .",
    "supertree algorithms for nested taxa . in o.  r.  p.",
    "bininda - emonds , editor , _ phylogenetic supertrees : combining information to reveal the tree of life _ , pages 151171 .",
    "kluwer , dordrecht , 2004 .          c.  e. hinchliff ,",
    "s.  a. smith , j.  f. allman , j.  g. burleigh , r.  chaudhary , l.  m. coghill , k.  a. crandall , j.  deng , b.  t. drew , r.  gazis , k.  gude , d.  s. hibbett , l.  a. katz , h.  d. laughinghouse  iv , e.  j. mctavish , p.  e. midford , c.  l. owen , r.  h. reed , j.  a. reesk , d.  e. soltis , t.  williams , and k.  a. cranston .",
    "synthesis of phylogeny and taxonomy into a comprehensive tree of life .",
    ", 112(41):1276412769 , 2015 .",
    "r.  m. page .",
    "taxonomy , supertrees , and the tree of life . in o.  r.  p.",
    "bininda - emonds , editor , _ phylogenetic supertrees : combining information to reveal the tree of life _ , pages 247265 .",
    "kluwer , dordrecht , 2004 ."
  ],
  "abstract_text": [
    "<S> semi - labeled trees are phylogenies whose internal nodes may be labeled by higher - order taxa . </S>",
    "<S> thus , a leaf labeled _ mus musculus _ could nest within a subtree whose root node is labeled rodentia , which itself could nest within a subtree whose root is labeled mammalia . </S>",
    "<S> suppose we are given collection @xmath0 of semi - labeled trees over various subsets of a set of taxa . </S>",
    "<S> the ancestral compatibility problem asks whether there is a semi - labeled tree @xmath1 that respects the clusterings and the ancestor / descendant relationships implied by the trees in @xmath0 . </S>",
    "<S> we give a @xmath2 algorithm for the ancestral compatibility problem , where @xmath3 is the total number of nodes and edges in the trees in @xmath0 . </S>",
    "<S> unlike the best previous algorithm , the running time of our method does not depend on the degrees of the nodes in the input trees . </S>"
  ]
}