{
  "article_text": [
    "the _ suffix tree _ is a well - known data structure which can be used for effectively and efficiently capturing patterns of a string , with a variety of applications  @xcite",
    ". introduced by weiner  @xcite , it reached wider use with the construction algorithm of mccreight  @xcite . ukkonen s algorithm  @xcite resembles mccreight s , but has the advantage of being fully _ online _ , an important property in our work .",
    "farach  @xcite introduced recursive suffix tree construction , achieving the same asymptotic time bound as sorting the characters of the string ( an advantage for large alphabets ) , but at the cost inherently off - line construction . the simpler _ suffix array _",
    "data structure  @xcite can replace a suffix tree in many applications , but can not generally provide the same time complexity , e.g. , for online applications .",
    "arguably the most basic capability of the suffix tree is to efficiently locate a string position matching an arbitrary given pattern . in this work , we are concerned with finding the _ most recent _ ( rightmost ) position of the match , which is not supported by standard suffix trees .",
    "a number of authors have studied special cases of this problem , showing applications in data compression and surveillance  @xcite , but to our knowledge , no efficient algorithm has previously been presented for the general case .",
    "one of the keys to our result is recent advancement in online suffix tree construction by breslauer and italiano  @xcite .",
    "we give algorithms for online support of locating the most recent longest match of an arbitrary pattern @xmath0 in @xmath1 time ( by traversing @xmath2 nodes , one of which identifies the most recent position ) .",
    "when a stream consisting of @xmath3 characters is subject to search , the data structure requires @xmath4 space , and maintaining the necessary position - updated properties takes at most @xmath5 total indexing time .",
    "if only the last @xmath6 characters are subject to search ( a _ sliding window _ ) , space can be reduced to @xmath7 and time to @xmath8 .    in related research , amir , landau and ukkonen  @xcite gave an @xmath9 time algorithm to support queries for the most recent previous string matching a suffix of the ( growing ) indexed string .",
    "the pattern to be located is thus not arbitrary , and the data structure can not support sliding window indexing .",
    "a related problem is that of lempel - ziv factorization  @xcite , where it is desirable to find the most recent occurrence of each factor , in order to reduce the number of bits necessary for subsequent encoding .",
    "for this special case , ferragina et al .",
    "@xcite gave a suffix tree based linear - time algorithm , but their algorithm is not online , and can not index a sliding window .",
    "crochemore et al .",
    "@xcite gave an online algorithm for the rightmost _ equal cost _ problem , a further specialization for the same application .",
    "in section  [ sec - lz ] , we discuss a possible optimization of our algorithm for the special case of lempel - ziv factorization .",
    "we study indexing a string @xmath10 of length @xmath11 , characters @xmath12 drawn from a given alphabet @xmath13 .",
    "( we consistently denote strings with uppercase letters , and characters with lowercase letters . )",
    "@xmath14 is made available as a _ stream _ , whose total length may not be known .",
    "the index is maintained online , meaning that after seeing @xmath15 characters , it is functional for queries on the string @xmath16 . following the majority of previous work , we assume that @xmath17 is a constant .",
    "the data structure supports queries for the most recent longest match in @xmath14 of arbitrary strings that we refer to as _",
    "patterns_. more specifically , given a pattern @xmath18 , a _ match _ for a length-@xmath19 prefix of @xmath0 occurs in position @xmath15 iff @xmath20 for all @xmath21 .",
    "longest _ match iff @xmath19 is maximum , and the _ most recent _ longest match iff @xmath15 is the maximum position of a longest match .      by @xmath22 , we denote the _ suffix tree _",
    "@xcite over the string @xmath23 .",
    "this section defines @xmath22 , and specifies our representation .",
    "a string @xmath24 is a nonempty _ suffix _ ( of @xmath14 , which is implied ) iff @xmath25 for @xmath26 , and a nonempty _ substring _ ( of @xmath14 ) iff @xmath27 for @xmath28 . by convention ,",
    "the empty string @xmath29 is both a suffix and a substring .",
    "edges in @xmath22 are directed , and each labeled with a string .",
    "each point in the tree , either coinciding with a node or located between two characters in an edge label , corresponds to the string obtained by concatenating the edge labels on the path to that point from the root .",
    "@xmath22 represents , in this way , all substrings of  @xmath14 .",
    "we regard a point that coincides with a node as located at the end of the node s edge from its parent , and can thus uniquely refer to the point on an edge of any represented string",
    ". an _ external _ edge is an edge whose endpoint is a leaf ; other edges are _ internal_. the endpoint of each external edge corresponds to a suffix of @xmath14 , but some suffixes may be represented inside the tree .",
    "note that the point corresponding to an arbitrary pattern can be located ( or found non - existent ) in time proportional to the length of the pattern , by scanning characters left to right , matching edge labels from the root down .",
    "we do not require that @xmath14 ends with a unique character , which would make each suffix correspond to some edge endpoint .",
    "instead , we maintain points of implicit suffix nodes using the technique of breslauer and italiano  @xcite ( section  [ sec - case - suffix ] ) .    following ukkonen , we augment the tree with an auxiliary node @xmath30 above the root , with a single downward edge to the root .",
    "we denote this edge @xmath31 and label it with @xmath29 .",
    "( illustration in figure  [ fig - st ] . )",
    "although the root of a tree is usually taken to be the topmost node , we shall refer to the node below @xmath30 ( the root of the unaugmented tree ) as the root node of @xmath22 .",
    "apart from @xmath31 , all edges are labeled with nonempty strings , and the tree represents exactly the substrings of @xmath14 in the minimum number of nodes .",
    "this implies that each node is either @xmath30 , the root , a leaf , or a non - root node with at least two downward edges .",
    "since the number of leaves is at most @xmath3 ( one for each suffix ) , the total number of nodes never exceeds @xmath32 .",
    "we generalize the definition to @xmath33 over the string @xmath34 , where @xmath35 . in iteration",
    "@xmath15 , we execute ukkonen s _ update _ algorithm  @xcite to reshape @xmath36 into @xmath33 , without looking ahead any further than @xmath37 .",
    "when there is no risk of ambiguity , we refer to the current suffix tree simply as @xmath22 , implying that @xmath3 iterations have completed .    for downward tree navigation , we maintain @xmath38 for constant - time access , where @xmath39 and @xmath40 are adjacent edges such that @xmath39 s endpoint coincides with @xmath40 s start node , and the first character in @xmath40 s label is @xmath41 .",
    "note that @xmath41 uniquely identifies @xmath40 among its siblings .",
    "we define the string that _ marks _ @xmath40 as the shortest string represented by @xmath40 ( corresponds to the point just after @xmath41 ) .",
    "we also maintain @xmath42 for constant - time upward navigation .    for linear storage space in @xmath3 ,",
    "edge labels are represented indirectly , as references into @xmath14 . among the many possibilities for representation , we choose the following : for any edge @xmath39 , we maintain @xmath43 , a position in @xmath14 of the string corresponding to @xmath39 s endpoint , and for each _ internal _ edge @xmath39 , we maintain @xmath44 , the length of that same string .",
    "i.e. , @xmath39 is labeled with @xmath45 , where @xmath46 and @xmath47 .",
    "external edges need no explicit @xmath48 representation , since their endpoints always correspond to suffixes of @xmath14 , so @xmath44 for external @xmath39 would always be  @xmath49 .",
    "note that @xmath43 is not uniquely defined for internal @xmath39 .",
    "algorithms given in the following sections update @xmath50 values to allow efficiently finding the most recent occurrence of a pattern .",
    "ukkonen s algorithm operates around the _ active point _ , the point of the longest suffix that also appears earlier in @xmath14 .",
    "this is the deepest point where @xmath22 may need updating in the next iteration , since longer suffixes are located on external edges , whose representations do not change . in iteration @xmath15 , @xmath51 is to be incorporated in @xmath22 .",
    "if @xmath51 is already present just below the active point , the tree already contains all the suffixes ending at @xmath51 , and the active point simply moves down past @xmath51 .",
    "otherwise , a leaf is added at the old active point , which is made into a new explicit node if necessary , and we move to the point of the next shorter suffix . to make this move efficient , typically jumping to a different branch of the tree , the algorithm maintains a _ suffix link _ from any node corresponding to @xmath52 , for some character @xmath41 and string @xmath53 , directly to the node for  @xmath53 .",
    "suffix tree over the string @xmath54 .",
    "dotted lines show edge - oriented suffix links . ]",
    "we choose a representation where suffix links are edge - oriented , rather than node - oriented as in mccreight s and ukkonen s algorithms : for edges @xmath39 and @xmath40 , we let @xmath55 iff @xmath53 marks @xmath40 , and @xmath52 and is the shortest string represented by @xmath39 such that @xmath53 marks an edge .",
    "( illustrated in figure  [ fig - st ] . )",
    "furthermore , we define @xmath56 to denote the _ reverse suffix link _ : @xmath57",
    ". we leave @xmath58 undefined .",
    "note that @xmath52 is the string that marks @xmath39 , unless @xmath39 is a downward edge of the root with an edge label longer than one character .",
    "we have @xmath59 iff @xmath39 s endpoint corresponds to a string of length one .",
    "this variant of suffix links facilitates the description of our _ most recent match _ scheme , but also has practical impact on runtime behavior , due to reduced branch lookup  @xcite .",
    "the change it implies in ukkonen s algorithm is relatively straightforward , and has no impact on its asymptotic time complexity .",
    "we omit the details in this work .",
    "we refer to the path from the active point to @xmath31 , via suffix links and ( possibly ) downward edges , as the _ active path_. all suffixes that also appear as substrings elsewhere in @xmath14 are represented along this path .",
    "we refer to those suffixes as _ active suffixes_. a key to the @xmath4 time complexity of ukkonen s algorithm is that the active path is traversed only in the forward direction .",
    "to answer a most - recent longest - match query for a pattern @xmath60 , we first locate the edge @xmath39 in @xmath22 that represents the longest prefix @xmath0 of @xmath60 . for an _ exact_-match query , we report failure unless @xmath61 . the time required to locate @xmath39 , by traversing edges from the root , while scanning edge labels , is @xmath1  @xcite . in this section , we give suffix tree augmentations that allow computing the most recent match of @xmath0 once its edge is located , while maintaining @xmath1 query time .    [ [ separation - of - cases ] ] separation of cases + + + + + + + + + + + + + + + + + + +    the following identifies two cases in locating the most recent match of a pattern string @xmath0 , which we treat separately .",
    "[ lem - cases ] let @xmath39 be the edge that represents @xmath0 , and let the string corresponding to @xmath39 s endpoint be @xmath62 , @xmath63 .",
    "precisely one of the following holds :    1 .",
    "[ case - unique ] the position of the most recent occurrence of @xmath0 is also the position of the most recent occurrence of @xmath62 .",
    "[ case - suffix ] there exists a suffix @xmath64 , @xmath65 such that @xmath66 .",
    "( proof in appendix  @xcite.)sections [ sec - first - case - unique][sec - last - case - unique ] show how to deal with case  [ case - unique ] , and section  [ sec - case - suffix ] with case  [ case - suffix ] .",
    "[ sec - first - case - unique ]    we begin with considering a naive method , by which we update @xmath43 at any time when the string corresponding to @xmath39 s endpoint reappears in the input .",
    "observe that any string that occurs later in @xmath67 than in @xmath68 must be a suffix @xmath69 , for some @xmath70 .",
    "hence , in each iteration , we need update @xmath43 only if @xmath39 s endpoint corresponds to an active suffix .",
    "this immediately suggests the following : after update iteration @xmath15 , traverse the active path , and for any edge @xmath39 whose endpoint corresponds to a suffix , _ pos - update @xmath39 _ , which we define as setting @xmath43 to @xmath71 .",
    "thereby , we maintain @xmath43 as the most recent position for any non - suffix represented by @xmath39 , and whenever case  [ case - unique ] of lemma  [ lem - cases ] holds , we obtain the most recent position of @xmath0 directly from the @xmath50 value of its edge .",
    "the problem with this naive method is that traversing the whole active path in every iteration results in @xmath72 worst case time .",
    "the following sections describe how to reduce the number of pos - updates , and instead letting the query operation inspect @xmath2 edges in order to determine the most recent position .",
    "to facilitate our description , we define the _ link tree _ @xmath73 as the tree of @xmath22 edges incurred by the suffix links : edges in @xmath22 are nodes in @xmath73 , and @xmath40 is the parent of @xmath39 in @xmath73 iff @xmath55 .",
    "the root of @xmath73 is @xmath31 . in order to keep the relationship between @xmath22 edges and @xmath73 nodes clear",
    ", we use the letters @xmath39 , @xmath40 , @xmath74 , and @xmath75 to denote them in both contexts .",
    "we define @xmath76 as the depth of @xmath39 in @xmath73 . because of the correspondance between @xmath73 nodes and @xmath22 edges",
    ", we have @xmath77 . by the current _ update edge _ in iteration @xmath15 , we denote the edge @xmath39 such that @xmath76 is maximum among the edges , if any , that would be updated by the naive update strategy ( section  [ sec - naive ] ) in that iteration : the maximum-@xmath78 internal edge whose endpoint corresponds to an active suffix .",
    "section  [ sec - bresl - updpoint ] describes how the update edge can be located in constant time .",
    "our update strategy includes pos - updating _ only _ the update edge , leaving @xmath50 values corresponding to shorter active suffixes unchanged .",
    "when no update edge exists , we pos - update nothing .",
    "we introduce an additional value @xmath79 for each internal edge @xmath39 , for which we uphold the following property :    [ prop - repr ] for every node @xmath74 in the suffix link tree , let @xmath39 be the most recently pos - updated node in the subtree rooted at @xmath74 .",
    "then an ancestor @xmath41 of @xmath74 exists such that @xmath80 .    by convention ,",
    "a tree node is both an ancestor and a descendent of itself . for new @xmath73 nodes @xmath39 ( without descendants )",
    ", we set @xmath79 to @xmath31 .",
    "we proceed with first the algorithm that exploits property  [ prop - repr ] , then the algorithm to maintain it .",
    "algorithm @xmath81 scans the @xmath73 path from node @xmath39 to the root in search for any node @xmath74 such that @xmath82 is a descendent of @xmath39 . for each such @xmath40",
    ", it obtains the position @xmath83 , and the value returned from the algorithm is the maximum among the @xmath84 .",
    "@xmath81 :    1 .",
    "let @xmath85 , and @xmath86 .",
    "[ st - mrmfind - loop ] if @xmath74 is @xmath31 , we are done , and terminate returning the value @xmath87 .",
    "if @xmath88 ( i.e. , it has not been set ) , go directly to step  [ st - mrmfind - next ] .",
    "[ st - mrmfind - isancestor ] let @xmath82 .",
    "if @xmath39 is not an ancestor of @xmath40 in @xmath73 , go directly to step  [ st - mrmfind - next ] .",
    "let @xmath83 .",
    "if @xmath89 , set @xmath87 equal to @xmath84 .",
    "[ st - mrmfind - next ] set @xmath74 to @xmath90 , and repeat from step  [ st - mrmfind - loop ] .",
    "the following lemma establishes that when property  [ prop - repr ] is maintained , the most recent occurrence of the string corresponding to @xmath39 s endpoint is among the positions considered by @xmath81 .",
    "[ lem - find - corr ] for an internal edge @xmath39 , let @xmath53 be the string corresponding to @xmath39 s endpoint , and @xmath91 the most recent occurrence of @xmath53 in @xmath14 .",
    "then @xmath39 has a descendent @xmath40 in @xmath73 whose endpoint corresponds to @xmath92 for some string @xmath93 , and @xmath94 .",
    "( proof in appendix  @xcite . )",
    "since @xmath81 returns the maximum among the considered positions , this establishes its validity for finding the most recent position of the string corresponding to @xmath39 s endpoint . under case  [ case - unique ] of lemma  [ lem - cases ] , this is the most recent position of _ any _ string represented by @xmath39 .",
    "hence , given that @xmath39 represents pattern @xmath0 , @xmath81 produces the most recent position of @xmath0 in this case .",
    "[ lem - find - time ] execution time of @xmath81 , where @xmath39 represents a string @xmath0 can be bounded by @xmath1 .",
    "( proof in appendix  @xcite . )",
    "[ sec - last - case - unique ]    since @xmath31 is an ancestor of all nodes in @xmath73 , we can trivially uphold property  [ prop - repr ] in relation to any updated node @xmath39 simply by setting @xmath95 .",
    "but since this ruins the property in relation to other nodes ( unless the _ previous _ value of @xmath96 was an ancestor of @xmath39 ) we must recursively push the overwritten @xmath97 value down @xmath73 to the root of the subtree containing those nodes .    more specifically ,",
    "when @xmath98 is set to @xmath39 , for some @xmath73 nodes @xmath99 and @xmath39 , let @xmath40 be the previous value of @xmath98 . then find @xmath75 , the minimum - depth node that is an ancestor of @xmath40 but not of @xmath39 , and recursively update @xmath100 to @xmath40 . to find @xmath75 ,",
    "we first locate @xmath74 , the lowest common ancestor of @xmath39 and @xmath40 .",
    "figure  [ fig - push ] shows the five different ways in which @xmath39 , @xmath40 , @xmath74 , and @xmath75 can be located in relation to one another . in case",
    "a , @xmath75 lies just under the path between @xmath39 and the root , implying that we need to set @xmath100 to @xmath40 .",
    "we find @xmath75 via a reverse suffix link from @xmath74 .",
    "cases  b ( where @xmath101 ) and  c ( @xmath86 ) are merely special cases of the situation in  a , and are handled in exactly the same way . in case",
    "d ( @xmath102 ) , the overwritten @xmath97 value points to an ancestor of @xmath39 , and the process can terminate immediately .",
    "case  e is the special case of  d where the old and new @xmath97 values are the same .",
    "the following details the procedure .",
    "it is invoked as @xmath103 in order to reestablish property  [ prop - repr ] , where @xmath39 is the current update edge .",
    "@xmath104 :    1 .",
    "let @xmath40 be the old value of @xmath98 , and set its new value to @xmath39 .",
    "if @xmath105 ( i.e. @xmath98 has not been previously set ) , then terminate .",
    "[ st - lca ] let @xmath74 be the lowest common ancestor of @xmath39 and @xmath40 .",
    "4 .   if @xmath102 , terminate .",
    "let @xmath106 , where @xmath107 .",
    "recursively invoke @xmath108 .",
    "cases in @xmath109 : a , b , and c progress down the tree ; d and e terminate . ]",
    "correctness of @xmath109 in maintaining property  [ prop - repr ] , is established by the preceding discussion .",
    "we now turn to bounding the total number of recursive calls .",
    "[ lem - balleaves ] given a sequence @xmath110 of nodes to be updated in a tree @xmath111 with @xmath19 nodes , there exists a tree @xmath112 with at most @xmath113 nodes , such that the depths of any two leaves in @xmath112 differ by at most one , and a sequence of @xmath112 nodes @xmath114 , such that invoking @xmath115 for each @xmath116 results in at least as many recursive @xmath109 calls as invoking @xmath117 for each @xmath118 .",
    "@xmath119 can be replaced by a sequence @xmath120 containing only leaves , and @xmath111 by a balanced binary tree @xmath112 with at most @xmath113 nodes , without increasing the number of recursive @xmath109 calls .",
    "( extended proof in appendix  @xcite . )      to conclude our treatment , we disucss handling case  [ case - suffix ] in lemma  [ lem - cases ] : finding the most recent match of a pattern that corresponds to a point in @xmath22 with an implicitly represented suffix on the same edge .",
    "once such an implicit suffix node is identified , the most recent pattern position is trivially obtained ( the position of the corresponding suffix ) .",
    "furthermore , identifying implicit suffix nodes has a known solution : breslauer and italiano  @xcite describe how ukkonen s algorithm can be augmented with a stack of _ band trees _ , whose nodes map top @xmath22 edges , by which implicit suffix nodes are maintained for amortized constant - time access , under linear - time suffix tree online construction .",
    "( further details in appendix  @xcite . )",
    "[ sec - bresl - updpoint]the band stack scheme has one additional use in our scheme : in each @xmath22 update operation , breslauer and italiano s algorithm pops a number of bands from the stack , and keeps the node that is the endpoint of the last popped edge .",
    "this node is the first explicit node on the active path , and , equivalently , the edge is the maximum-@xmath78 internal edge whose endpoint corresponds an active suffix .",
    "this coincides with our definition of the _ update edge _ in section  [ sec - updstrat ] .",
    "thus , we obtain the current update edge in constant time .",
    "[ th - allnlogn ] a suffix tree with support for locating , in an input stream , the most recent longest match of an arbitrary pattern @xmath0 in @xmath1 time , can be constructed online in time @xmath9 using @xmath4 space , where @xmath3 is the current number of processed characters .    by lemma  [ lem - balleaves ] ,",
    "the number of @xmath109 calls is @xmath9 , each of which takes constant time , using a data structure for constant - time lowest common ancestor queries  @xcite .",
    "this bounds the time for maintenance under case  [ case - unique ] in lemma  [ lem - cases ] to @xmath9 . in case",
    "[ case - suffix ] , we achieve  @xmath4 time by the data structure of breslauer and italiano .",
    "( extended proof in appendix  @xcite . )",
    "we assert that an adversarial input exists that results in @xmath121 recursive calls , and hence this worst - case bound is tight .",
    "( further details in appendix  @xcite . )",
    "a major advantage of online suffix tree construction is its applicability for a _ sliding window _ : indexing only the most recent part ( usually a fixed length ) of the input stream  @xcite .",
    "we note that our augmentations of ukkonen s algorithm can efficiently support most recent match queries in a sliding window of size  @xmath6 :    [ cor - slide ] a suffix tree with support for locating , among the most recent @xmath6 characters of an input stream , the most recent longest match of an arbitrary pattern @xmath0 in @xmath1 time , can be constructed online in time @xmath122 using @xmath7 space , where @xmath3 is the current number of processed characters .",
    "the suffix tree is augmented for indexing a sliding window using @xmath7 space with maintained time bound  @xcite .",
    "deletion from the data structure for ancestor queries takes @xmath123 time  @xcite .",
    "node deletion from band trees takes @xmath123 time using _ pmerge _",
    "@xcite . hence , a @xmath124 ) term obtained analogously to lemma  [ lem - balleaves ] dominates .",
    "( extended proof in appendix  @xcite . )",
    "while our data structure supports arbitrary most - recent - match queries , some related work has considered only the queries that arise in lempel - ziv factorization , i.e. , querying @xmath33 only for the longest match of @xmath125 . the desire for finding the most recent occurrence of each factor",
    "is motivated by an improved compression rate in a subsequent entropy coding pass .",
    "ferragina , nitto , and venturini  @xcite gave an @xmath4 time algorithm for this case , which is not online , and hence can not be applied to a sliding window .",
    "crochemore , langiu , and mignosi  @xcite presented an online @xmath4 time suffix tree data structure that , under additional assumptions , circumvents the problem by replacing queries for most recent match with queries for matches with lowest possible entropy - code length . an interesting question is whether the time complexity of our method can be improved if we restrict queries to those necessary for lempel - ziv factorization .",
    "we now sketch an augmentation for this case .    as characters of one lempel - ziv factor",
    "are incorporated into @xmath22 , we need not invoke @xmath109 for the update edge in each iteration .",
    "instead , we push each update edge on a stack . after the whole factor has been incorporated , we pop edges and invoke @xmath109 for the reverse sequence , updating edge @xmath39 only if it would have increased @xmath43 . in other words ,",
    "we ignore any updates superseded by later updates during the same sequence of edge pops . in experiments we noted drastic reduction in recursive calls , but",
    "whether worst case asymptotic time is reduced is an open question .",
    "( extended discussion in appendix  @xcite . )",
    "we have presented an efficient online method of maintaining most recent match information in a suffix tree , to support optimal - time queries . the question whether the logarithmic factor in the time complexity of our method can be improved upon is , however , still open .",
    "furthermore , precise characteristics of application to restricted inputs or applications ( e.g. lempel - ziv factorization ) is subject to future research , as is the practicality of the result for , e.g. , data compression use ."
  ],
  "abstract_text": [
    "<S> a suffix tree is able to efficiently locate a pattern in an indexed string , but not in general the most recent copy of the pattern in an online stream , which is desirable in some applications . </S>",
    "<S> we study the most general version of the problem of locating a most recent match : supporting queries for arbitrary patterns , at each step of processing an online stream . </S>",
    "<S> we present augmentations to ukkonen s suffix tree construction algorithm for optimal - time queries , maintaining indexing time within a logarithmic factor in the size of the indexed string . </S>",
    "<S> we show that the algorithm is applicable to sliding - window indexing , and sketch a possible optimization for use in the special case of lempel - ziv compression . </S>"
  ]
}