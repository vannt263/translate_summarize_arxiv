{
  "article_text": [
    "a real in the unit interval is _ computably enumerable _ ( _ c.e .",
    "_ ) if it is the limit of a computable , increasing sequence of rationals .",
    "we identify a real with its infinite binary expansion .",
    "in contrast with the case of a computable real , whose bits are given by a computable function , during the process of approximation of a c.e .",
    "real one may never know how close one is to the limit .",
    "a real is ( algorithmic ) random if its binary expansion is an algorithmic random ( infinite ) sequence @xcite .",
    "a prefix - free machine is a turing machine , shortly , _ machine _ , from strings to strings whose domain is a prefix - free set .",
    "a machine is universal if it can simulate every machine .",
    "chaitin @xcite introduced the halting probability @xmath1 of a universal machine @xmath0 , chaitin s omega number @xmath2 and proved that _",
    "@xmath1 is c.e .  and",
    "random_. as shown by calude , hertling , khoussainov , wang @xcite and kuera , slaman @xcite , ( see also @xcite ) there are no other c.e .",
    "random reals :    [ representation : thm]the set of c.e .",
    "random reals coincides with the set of halting probabilities of all universal machines .",
    "random reals have been intensively studied in recent years , with many results summarised in @xcite .",
    "[ gregzfc ] assume that zfc ( zermelo - fraenkel set theory with choice ) is arithmetically sound ( that is , any theorem of arithmetic proved by zfc is true ) .",
    "then , for every universal machine @xmath0 , zfc can determine the value of only finitely many bits of @xmath1 , and one can calculate a bound on the number of bits of @xmath1 which zfc can determine .",
    "the real @xmath1 depends on @xmath0 , and so by tuning this choice one gets :    [ solovay ] we can chose a universal machine @xmath0 so that zfc ( if arithmetically sound ) can not determine any bit of @xmath1 .",
    "this result was generalised as follows :    [ crisincompl ] assume that zfc is arithmetically sound .",
    "let @xmath3 and consider the c.e .",
    "random real @xmath4 then , we can effectively construct a universal machine @xmath0 ( depending upon zfc and @xmath5 ) such that pa ( peano arithmetic ) proves the universality of @xmath0 , zfc can determine at most @xmath6 initial bits of @xmath1 and @xmath7 .",
    "the proof of theorem  [ crisincompl ] in @xcite starts by fixing a universal machine @xmath8 such that the universality of @xmath8 is provable in pa and @xmath9 .",
    "solovay @xcite observed that `` it is by no means evident that there is a universal prefix - free machine whose universality is provable in pa and whose halting probability is @xmath5 '' .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ let @xmath10 be c.e .  and random",
    ". is there any _ representation _ of @xmath5 for which pa can _ prove _ that @xmath11 c.e .  and",
    "random ? _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we give an affirmative answer to this question .",
    "a major step in the proof is to show that theorem  [ representation : thm ] can be proved in pa .",
    "our proof , which is simpler than the standard one , can be used also for the original theorem .",
    "the paper also includes a sharper form of the kraft - chaitin theorem , as well as a formal proof of this theorem written with the proof assistant isabelle . in",
    "what follows proofs will be written in solovay s style @xcite .",
    "all necessary steps are presented in sufficient detail to leave the remaining formalisation routine .",
    "the formalisation of the kraft - chaitin theorem is presented with full details , and then a sketch of the formal proof in isabelle is discussed .",
    "the paper is organised as follows .",
    "sections 2 and 3 present all facts on formal provability and algorithmic information theory needed for this paper .",
    "the kraft - chaitin theorem is presented in section  4 .",
    "section  5 presents three ways to prove randomness , using martin - lf tests , prefix - free complexity , and solovay representation formula . in section  6",
    "we revisit chaitin s theorem on the randomness of the halting probability of a universal machine . in section  7",
    "we prove that a real @xmath12 is provably chaitin - random iff it is provable that @xmath7 for some provably universal machine @xmath0 ( see theorem  [ thm : representation ] ) . in section  8",
    "we prove our main theorem : every c.e .",
    "random real is provably random ( theorem  [ thm : cerandprov ] ) . in section  9",
    "we construct a universal machine @xmath0 based on which pa can not prove the randomness of its halting probability .",
    "section  10 presents a formal proof of the kraft - chaitin theorem written with isabelle .",
    "the final section  11 includes a few general remarks .",
    "by @xmath13 we denote the first - order language of arithmetic whose non - logical symbols consist of the constant symbols 0 and 1 , the binary relation symbol @xmath14 and two binary function symbols @xmath15 ( addition ) and @xmath16 ( multiplication ) .",
    "peano arithmetic ( see @xcite , shortly , pa ) is the first - order theory given by a set of 15 axioms defining discretely ordered rings , together with induction axioms for each formula @xmath17 in @xmath13 : @xmath18 01 this schema retains as much as possible from the second - order induction axiom : @xmath19 where @xmath20 ranges over all subsets of the domain , and @xmath21 range over elements of this domain , but avoids quantification over sets of natural numbers , which is impossible in first - order logic .    in pa",
    "it is not possible to say that any set of natural numbers containing 0 and closed under successor is the entire set of natural numbers , but that any definable set of natural numbers has this property .",
    "the induction schema includes one instance of the induction axiom for every definition of a subset of the naturals .",
    "the structure * n * whose domain is the set of naturals @xmath22 , where the symbols in @xmath13 have the obvious interpretation , satisfies the axioms of pa ; this is the standard model for pa .",
    "there are non - standard models of pa that are not isomorphic to * n*. if @xmath23 is a structure for @xmath13 and @xmath24 is an @xmath13-formula with free - variables @xmath25 and @xmath26 , then we write @xmath27 to mean that `` @xmath28 is true in @xmath23 when each variable @xmath29 is interpreted by @xmath30 '' .",
    "we blur the distinction between @xmath31 and the closed term of @xmath13 , @xmath32 , ( @xmath31 times ) .",
    "a formula @xmath33 of @xmath13 is @xmath34 if all its quantifiers are bounded .",
    "a formula @xmath35 of @xmath13 is @xmath36 if it is of the form @xmath37 with @xmath38 ; @xmath35 of @xmath13 is @xmath39 if it is of the form @xmath40 with @xmath38 .",
    "by pa @xmath41 we mean `` there is a proof in pa for @xmath42 '' .",
    "it is useful to know that pa proves the _ least number principle _ : @xmath43 for each formula @xmath44 of @xmath13 .",
    "an important link between computability and provability is given by the following results .",
    "a partial function from @xmath45 to @xmath45 is partial computable iff its graph is equivalent to a @xmath36 @xmath13-formula .",
    "[ cesets]a set @xmath46 is computably enumerable ( c.e . ) if there is a @xmath36 @xmath13-formula @xmath24 such that for all @xmath47 , @xmath48 iff * n * @xmath49 .",
    "a total function @xmath50 is represented in pa if there is an @xmath13-formula @xmath51 such that for all @xmath52 : +    1 .",
    "pa @xmath53 , and 2 .",
    "if @xmath54 then pa @xmath55 .",
    "+ ( here @xmath56 means `` there exists a unique '' . ) one can show that every total computable function is represented by a @xmath36-formula of pa @xcite .",
    "a function @xmath57 is _ provably computable _",
    "@xcite if there exists a @xmath36-formula of pa @xmath58 such that : +    1 .",
    "@xmath59 , 2 .",
    "pa @xmath60 .",
    "+ in view of corollary  [ cesets ] , any provably computable function has a c.e .",
    "graph , so it is total and computable .",
    "these functions can be viewed as computable functions whose totality is proved by pa .",
    "every primitive recursive function is provably computable , but there exist computable functions which are not provably computable in pa .",
    "if @xmath61 is computable but not provably computable in pa , then the statement `` @xmath61 is total '' is true but unprovable in pa .",
    "in contrast with the case of computable functions , _ c.e .",
    "sets are provably enumerable _ @xcite ( because every non - empty c.e .",
    "set can be enumerated by a primitive recursive function , @xcite , p. 138 ) .    in what follows all computations",
    "will be implemented by primitive recursive functions .",
    "hence , we will work with a special type of @xmath36 formulae . by abuse of language",
    "we say that a formula of pa is @xmath62 if it has the form @xmath63 , for some primitive recursive predicate @xmath64 .",
    "a formula of pa is @xmath65 if it has the form @xmath66 , for some primitive recursive predicate @xmath67 .",
    "our metatheory is zfc .",
    "we fix a ( relative ) interpretation of pa in zfc .",
    "each formula of @xmath13 has a translation into a formula of zfc determined by the interpretation of pa in zfc .",
    "by abuse of language we shall use the phrase `` sentence of arithmetic '' to mean a formula with no free variables of zfc that is the translation of some formula of pa .",
    "we assume that zfc is 1consistent , that is , if it proves a @xmath62 sentence then that sentence is true ( in the standard model of pa ) .",
    "[ solovay @xcite ] every @xmath65 sentence proved by zfc is true .    as a consequence",
    ", it follows that _ if @xmath0 is a machine which _ pa _ can prove universal and zfc can prove the sentence `` the i - th digit of @xmath68 is @xmath69 '' , then the sentence is true_. whenever we talk about the provability of a sentence of arithmetic we mean that pa proves its corresponding translation formula .",
    "if there is a proof in pa for statement @xmath70 we say that @xmath70 provable in pa .",
    "we say that @xmath70 is provably @xmath71 ( where @xmath71 is a property ) if the statement `` @xmath70 has @xmath71 '' is provable in pa .",
    "_ all reals are in the unit interval . _ a c.e .",
    "real @xmath5 is represented by an increasing computable sequence of rationals converging to @xmath5 .",
    "we blur the distinction between the real @xmath5 and the infinite base - two expansion of @xmath5 , i.e.   the infinite sequence @xmath72 ( @xmath73 such that @xmath74 by @xmath75 we denote the string of length @xmath31 , @xmath76 .    the set of ( bit ) strings is denoted by @xmath77 ; @xmath78 denotes the empty string .",
    "if @xmath79 is a string then @xmath80 denotes the length of @xmath79 .",
    "we import the theory of computability from natural numbers to strings by fixing the canonical bijection between @xmath77 and @xmath45 induced by the linear order @xmath81 if @xmath82 or @xmath83 and @xmath79 lexicographically precedes @xmath84 .",
    "a machine @xmath0 is _ universal _ if for every machine @xmath8 there is a constant @xmath85 ( depending upon @xmath0 and @xmath8 ) such that for all strings @xmath86 , if @xmath87 , then @xmath88 for some string @xmath89 of length @xmath90 .",
    "the domain of @xmath0 is the set @xmath91 .",
    "the omega number @xmath92 is halting probability of @xmath0 .",
    "the _ prefix - free complexity _ of the string @xmath93 ( relatively to the machine @xmath94 ) is @xmath95 ( @xmath96 ) . if @xmath0 is a universal machine , then for every machine we can effectively construct a constant @xmath85 ( depending on @xmath0 and @xmath94 ) such that @xmath97 , for all @xmath98 .",
    "a real @xmath5 is _ chaitin - random _ if there exists a universal machine @xmath0 and constant @xmath85 such that for all @xmath99 , @xmath100 .",
    "open set is a c.e .",
    "union of intervals with rationals endpoints @xmath101 and @xmath102 is lebesgue measure .",
    "if @xmath103 is a prefix - free set , then @xmath104 denotes the lebesgue measure of the cylinder denoted by @xmath103 , i.e.  all reals whose infinite binary expansions have a prefix in @xmath103 . to the string",
    "@xmath98 we associate the interval @xmath105 of measure @xmath106 . a martin - lf test ( shortly , ml test ) @xmath70 is a uniformly c.e .",
    "sequence of c.e .",
    "open sets @xmath107 such that for all @xmath108 , @xmath109 .",
    "a real @xmath5 is _ martin - lf - random _ ( shortly , _ ml - random _ ) if for every ml test @xmath70 there exists an @xmath110 such that @xmath111 .",
    "a classical theorem states that _ a real is chaitin - random iff it is ml - random _ @xcite .    note that chaitin and martin - lf definitions apply to any real . in the special case of c.e .",
    "reals the following solovay representation formula stated in @xcite is used : a real @xmath5 is _ c.e .  and random _ if there exists a universal machine @xmath0 , an integer @xmath112 and a c.e .",
    "real @xmath113 such that @xmath114 ( see lemma  [ lem : solovayrepresentation ] ) .",
    "we start by showing that pa can prove the kraft - chaitin theorem @xcite .",
    "[ thm : kc ] suppose @xmath115 is a primitive recursive enumeration of `` requests '' which provably satisfies @xmath116 then there exists a provably prefix - free machine @xmath23 and a primitive recursive enumeration @xmath117 of @xmath118 such that the following is provable in pa : +    1 .",
    "@xmath119 , 2 .",
    "@xmath120 for all @xmath121 , 3 .",
    "@xmath122 for all @xmath121 .",
    "algorithm [ alg : kc ] below enumerates the graph of @xmath23 .",
    "intuitively , @xmath123 keeps track of the tree of prefixes we havent allocated yet . to start with we have allocated nothing , so @xmath124 . at each step",
    "we want a string ( node ) of a given length ( depth ) @xmath125 .",
    "the program selects the deepest leaf it can , then creates the smallest number of new leaves to create the node we need .",
    "+    @xmath124 , @xmath126 , @xmath127 , @xmath128 .",
    "let @xmath129 be the longest element of @xmath103 of length at most @xmath125 .",
    "if no such string exists , terminate .",
    "define @xmath132 .",
    "@xmath135 .",
    "examining algorithm  [ alg : kc ] , it is clear that the sequence @xmath136 is a primitive recursive enumeration of @xmath118 , and whenever @xmath137 is defined we have @xmath122 and @xmath120 . it remains to show that @xmath137 is defined for all @xmath121 ( i.e. the program never terminates ) , that @xmath118 is prefix - free , and @xmath138 .",
    "it suffices to establish , for all @xmath110 , the following invariants : +    1 .",
    "@xmath139 is prefix - free ( which implies that @xmath123 and @xmath140 individually are prefix - free ) , 2 .",
    "@xmath141 , 3 .",
    "@xmath142 , 4 .",
    "@xmath143 , 5 .",
    "if @xmath144 , then @xmath123 contains a string of length at most @xmath31 ( equivalently , @xmath123 contains strings of distinct length ) .",
    "the base case is trivial . for the inductive step ,",
    "first observe that line 3 of algorithm  [ alg : kc ] does nt terminate since @xmath145 by invariant 5 .",
    "we see that @xmath146 which is prefix - free establishing invariant 1 . from this",
    "we can see invariant 2 holds : @xmath147 next observe invariant 3 holds too : @xmath148 which implies that @xmath149 from this follows invariant 4 : @xmath150 finally , since @xmath129 is the longest string of length at most @xmath125 in @xmath151 , and we add strings of distinct length between @xmath152 and @xmath125 to @xmath123 to form @xmath153 , we see that @xmath153 consists of strings of distinct lengths .",
    "this establishes invariant 5 .",
    "in this section we discuss three forms of provability for randomness .",
    "there are two ways to represent a c.e .",
    "real number @xmath12 in pa : 1 ) by giving an increasing 1 - 1 primitive recursive function that enumerates a c.e .  prefix - free set of strings @xmath154 such that @xmath155 , 2 ) by giving an increasing primitive recursive sequence @xmath156 of rationals in the unit interval whose limit is @xmath5 .",
    "it is clear that given the representation 1 ) one can effectively get the representation 2 ) .",
    "the converse is also true .",
    "[ lem : repce ] let @xmath5 be a c.e .",
    "real defined by the increasing primitive recursive sequence @xmath156 of rationals .",
    "then there is a primitive recursive sequence @xmath157 of natural numbers such that pa proves @xmath158    without loss of generality assume @xmath159 .",
    "define the primitive recursive sequences @xmath160 and @xmath161 by @xmath162 and for @xmath163 by @xmath164 since @xmath165 is strictly increasing we can establish by induction the inequality @xmath166 for all @xmath110 , making the logarithm well - defined . by construction",
    "we have @xmath167 define @xmath168 . since @xmath169 we have @xmath170 taking the limit we see that @xmath171 establishing our result .",
    "let @xmath5 be a c.e .",
    "real defined by the increasing primitive recursive sequence @xmath156 of rationals .",
    "then there is a machine @xmath23 such that pa proves that @xmath172 .",
    "use lemma  [ lem : repce ] and theorem  [ thm : kc ] .    in what follows a c.e .",
    "real is given by one of the above representations .",
    "real @xmath5 is _ provably chaitin - random _ if there exists a provably universal machine @xmath0 and constant @xmath85 such that pa proves that for all @xmath99 , @xmath100 .",
    "real @xmath5 is _ provably ml - random _ if for every set",
    "@xmath70 which pa proves to be a ml test and pa proves that there exists an @xmath110 such that @xmath111 .    the classical theorem that states that _ a real is chaitin - random iff it is ml - random _ is provable in pa .",
    "however , for the goal of this paper only one implication is needed :    [ thm : chaitintoml ] every c.e .",
    "provably chaitin - random real is provably ml - random .",
    "take a c.e .",
    "real @xmath5 , a machine @xmath0 which is provably universal and a natural @xmath173 such that pa proves that for all @xmath99 , @xmath174 .",
    "we wish to prove that for every @xmath175 which pa proves to be a ml test there exists an @xmath110 such that pa proves that @xmath111 .",
    "following the proof of proposition  6.3.4 in @xcite it follows that pa proves the existence of a c.e .",
    "set @xmath176 such that each @xmath177 is prefix - free , and by taking @xmath178 we get @xmath179 .",
    "let @xmath180 be a 1 - 1 primitive recursive enumeration of the graph of @xmath0 .",
    "denote by @xmath181 for @xmath182 the projection functions and @xmath183 is a 1 - 1 primitive recursive enumeration of @xmath184 .",
    "note that @xmath185 can be expressed in pa : @xmath186 ,    we have : @xmath187    we can now use theorem  [ thm : kc ] : there exists a provably prefix - free machine @xmath23 such that : @xmath188 , @xmath189 since @xmath0 is provably universal there is a constant @xmath190 such that for all strings @xmath191 , so in particular , pa proves that for all @xmath192 , if @xmath193 , then @xmath194    we are now in a position to find a natural @xmath192 such that pa proves that @xmath195 showing that @xmath5 is provably ml - random .",
    "note that for @xmath192 , pa proves @xmath195 iff for all @xmath196 , pa proves that @xmath197 . for all @xmath196",
    ", pa proves that @xmath198 implies @xmath199 hence , for @xmath200 , pa proves that @xmath201 implies @xmath197 , so because @xmath5 is provably chaitin - random pa proves that @xmath195 .",
    "* comment * the above proof shows that that @xmath202 , where @xmath0 is a provably universal machine , is a provably ml test such that for all @xmath192 and provably ml test @xmath70 there exists @xmath203 such that pa proves the inclusion @xmath204 , i.e. @xmath205 is a provably universal ml test .    to be able to complete our program we need to choose a specific representation for a c.e .  and random real which can be `` understood '' by pa and , even more importantly",
    ", pa can extract from it a proof of the randomness of the real ( c.e .",
    "is obvious ) .",
    "first we work with solovay representation formula discussed at the end of section  [ ait ] .",
    "a real @xmath5 is _ c.e .  and",
    "provably random _ if there exists a representation of @xmath5 in the form @xmath206 where @xmath8 is a provably universal machine , @xmath207 is an integer and @xmath113 is a provably c.e .",
    "theorem  [ lem : solovayrepresentation ] shows that all c.e .",
    "random reals have a representation of this form . in detail",
    ", pa receives an algorithm for a machine @xmath8 , a proof that @xmath8 is prefix - free and universal , an integer @xmath207 and a computable increasing sequence of rational converging to a real @xmath208 .",
    "the goal is to prove that pa can use this information to prove that @xmath209 is c.e .  and random .",
    "chaitin @xcite proved that the halting probability of a universal machine is chaitin - random .",
    "this theorem is provable in pa :    [ thm : chaitin ] suppose @xmath0 is provably universal",
    ". then @xmath210 is provably chaitin - random .",
    "let @xmath180 be a 1 - 1 primitive recursive enumeration of the graph of @xmath0 .",
    "denote by @xmath211 for @xmath182 the projection functions and @xmath183 is a 1 - 1 primitive recursive enumeration of @xmath184 . recall that @xmath185 can be expressed in pa .",
    "01 @xmath212    @xmath213 define the machine @xmath23 by @xmath214 .",
    "since @xmath0 is provably universal , there is a @xmath85 such that for all @xmath98 , @xmath215 this shows that @xmath185 is provably total and @xmath0 is provably onto .",
    "define the primitive recursive sequence of rationals @xmath216 and notice that @xmath217 is provably strictly increasing ; @xmath1 is , by definition , the limit of this sequence .",
    "define @xmath218 if there exist @xmath84,@xmath219 such that +    1 .",
    "@xmath220 ( i.e. @xmath221 ) , 2 .",
    "@xmath84 is the least such that @xmath222 ( i.e. @xmath223 ) , 3 .",
    "@xmath224 is the lexicographically least string such that @xmath225 for all @xmath226 .",
    "this defines a provably prefix - free machine .",
    "observe that if @xmath227 is defined and @xmath228 then @xmath229 . from this",
    "we can establish that whenever @xmath227 is defined we have @xmath230 as @xmath0 is provably universal , there exists an @xmath231 such that for all @xmath232 , @xmath233 is provable in pa",
    ".    denote by @xmath234 the @xmath110th digit of @xmath1 . since @xmath0 is provable onto , for each @xmath31 there",
    "exists a string @xmath235 such that @xmath236 since @xmath237 we know that @xmath238 is defined .",
    "let @xmath84 be the least natural ( found when evaluating @xmath238 ) such that @xmath239 the inequality @xmath240 is easy consequence ,",
    "so for all @xmath241 we have @xmath242 .",
    "since @xmath238 equals @xmath243 for some @xmath241 by construction , we have that for all @xmath31 01 @xmath244 @xmath245 is provable in pa .",
    "that is , @xmath246 is provably chaitin - random .    from theorem  [ thm : chaitin ]",
    "we deduce that pa can prove the implication : `` if @xmath0 is a provably universal machine , then @xmath68 is chaitin - random . ''",
    "we know that every c.e .  and random real is the halting probability of a universal machine , but we need more : _ can any c.e .  and random real be represented as the halting probability of a provably universal machine ?",
    "_ first we have to check whether every universal machine is provably universal .",
    "[ thm : nonprovunivmachine ] there exist a provably universal machine and a universal machine that is not provably universal .",
    "the set of all provably prefix - free machines is c.e .",
    ", so if @xmath247 is a computably enumeration of provably prefix - free machines , then the machine @xmath0 defined by @xmath248 is a provably universal machine .",
    "let @xmath249 be a c.e .",
    "enumeration of all primitive recursive functions @xmath250 and @xmath251 a c.e .",
    "enumeration of all machines .",
    "fix a universal machine @xmath0 and consider the computable function @xmath252 such that :    @xmath253    for every @xmath110 , @xmath254 is a universal machine iff @xmath255 is infinite ( if @xmath255 is finite , then so is @xmath254 ) .",
    "since the set of all indices of primitive recursive functions with infinite range is not c.e.it follows that there is an @xmath110 such that pa can not prove that @xmath256 is universal .",
    "theorem  [ thm : nonprovunivmachine ] does not imply a negative answer for the previous question ; in fact , corollary  [ cor : secondrep ] shows that the answer is affirmative .",
    "theorem  [ thm : nonprovunivmachine ] produces examples of true and unprovable ( in pa ) statements of the form `` @xmath8 is universal '' .",
    "in this section we sharpen theorem  [ representation : thm ] by proving that a real is provably c.e .  and",
    "chaitin - random iff it is provable that the real is the halting probability of a provably universal machine .",
    "01    [ lem : repce ] let @xmath5 be a c.e .",
    "real defined by the increasing primitive recursive sequence @xmath156 of rationals .",
    "then there is a primitive recursive sequence @xmath157 of natural numbers such that pa proves @xmath257    without loss of generality assume @xmath159 .",
    "define the primitive recursive sequences @xmath160 and @xmath161 by @xmath162 and for @xmath163 by @xmath258 since @xmath165 is strictly increasing we can establish by induction @xmath166 for all @xmath110 , making the logarithm well - defined . by construction",
    "we have @xmath259 define @xmath168 . since @xmath260 we have @xmath261 taking the limit we see that @xmath171 establishing our result .",
    "let @xmath5 be a c.e .",
    "real defined by the increasing primitive recursive sequence @xmath156 of rationals .",
    "then there is a machine @xmath23 such that pa proves that @xmath172 .    according to solovay @xcite a c.e .",
    "real @xmath5 _ solovay dominates _ a c.e .",
    "real @xmath262 ( we write @xmath263 ) if there are two computable , increasing sequences @xmath264 and @xmath265 of rationals and a constant @xmath85 with @xmath266 , @xmath267 , and @xmath268 , for all @xmath31 .    for c.e .",
    "reals @xmath269 , pa proves @xmath263 if there are two primitive recursive , increasing sequences @xmath264 and @xmath265 of rationals and a constant @xmath85 such that pa proves @xmath266 , @xmath267 , and @xmath268 , for all @xmath31 .",
    "[ thm : dominates ] if @xmath5 is c.e .  and provably ml - random , and @xmath262 is c.e . , then @xmath270 is provable in pa",
    ".    let @xmath264 and @xmath265 be primitive recursive sequences of rationals with limits @xmath5 and @xmath262 respectively .",
    "let @xmath271 .    for each @xmath31 , for @xmath163",
    "if @xmath272 $ ] then define @xmath273 = [ a_i , a_i + 2^{-n } ( b_i - b_{s^{n } } ) ) , $ ] where @xmath274 \\neq \\emptyset\\}$ ] is the most recent non - empty stage , or @xmath275 if this is the first non - empty stage .",
    "otherwise define @xmath276 = \\emptyset$ ] .",
    "let @xmath277 denote the @xmath219th non - empty stage , wherever that is well - defined , and let @xmath278 .",
    "observe that @xmath279 = \\bigcup_{j\\ge1 } [ a_{s^{n}_j } , a_{s^{n}_j } + 2^{-n } ( b_{s^{n}_j } - b_{s^{n}_{j-1}}))\\ ] ] and that all the sets in the above union are disjoint by construction . as a result @xmath280",
    "so pa proves that @xmath281 is a ml - test .    because @xmath5 is provably ml - random",
    ", pa proves that there exists an @xmath282 such that @xmath283 , so for all @xmath284 we know that @xmath285 is well - defined . by construction",
    "we have the inequality @xmath286 which implies that @xmath287    defining @xmath288 and @xmath289 , we have for all @xmath284 that @xmath290 where @xmath291 and @xmath292 are primitive recursive sequences of rationals which provably converge to @xmath5 and @xmath262 respectively .",
    "so pa proves @xmath270 .",
    "01 * comment * with the notation @xmath293 as below , let    @xmath294 = [ a'_i , a'_i + 2^{-n } ( b'_{i } - b'_{i-1})),\\ ] ]    and observe that @xmath295 $ ] implies that @xmath296 which contradicts the construction of @xmath297 $ ] by virtue of which for all @xmath298 we have @xmath299 $ ] , hence @xmath300 and @xmath301 .",
    "consequently , @xmath302 , so @xmath270 with constant @xmath303 .    [",
    "cor : dominates ] if @xmath5 is c.e .  and provably chaitin - random and @xmath262 is c.e . , then @xmath270 is provable in pa .    see theorems  [ thm : chaitintoml ] and [ thm : dominates ] .",
    "01    [ cor : dominates ] if @xmath12 is c.e .",
    ", ml - random , and @xmath304 is c.e . , then @xmath270 .",
    "[ thm : omegarep ] suppose @xmath8 is a provably universal machine , @xmath5 is c.e . , and @xmath305 is provable in pa",
    ". then there exists a provably universal machine @xmath0 such that @xmath306 is provable in pa .    since @xmath305",
    ", there exist primitive recursive increasing sequences @xmath264 and @xmath265 of rationals , with limits @xmath5 and @xmath307 respectively , and a constant @xmath207 such that for all @xmath31 @xmath308 define @xmath271 .",
    "form the real @xmath309 by equation ( [ th2:ss ] ) the terms of the sum are positive , so @xmath310 is c.e .",
    "applying lemma  [ lem : repce ] to @xmath311 we get a primitive recursive sequence @xmath312 of natural numbers such that @xmath313    let @xmath314 be a 1 - 1 primitive recursive enumeration of @xmath315 , and define the sequence of requests @xmath316 where @xmath224 is an arbitrarily fixed element in @xmath315 .    by theorem  [ thm : kc ]",
    "we get a provably prefix - free machine @xmath23 and a primitive recursive enumeration @xmath117 of @xmath118 such that the following three statements are provable : 1 ) @xmath119 , 2 ) @xmath120 for all @xmath110 , 3 ) @xmath122 for all @xmath110 .",
    "consider the machine @xmath317 .",
    "the machine @xmath0 is provably universal . indeed , @xmath318 and @xmath319 , by construction of @xmath23 . finally , it is provable that @xmath320    using all results above we obtain :    [ thm : representation ] a c.e .",
    "real @xmath5 is provably chaitin - random",
    "iff it is provable that @xmath7 for some provably universal machine @xmath0 .",
    "suppose @xmath5 is provably c.e .  and chaitin - random .",
    "by theorem  [ thm : chaitintoml ] , @xmath5 it is provably ml - random .",
    "take a provably universal machine @xmath8 ( theorem  [ thm : nonprovunivmachine ] ) . from theorem  [ thm : dominates ] we see that @xmath305 is provable in pa . by theorem  [ thm : omegarep ]",
    "we effectively get a @xmath0 which is provably universal and prefix - free such that @xmath7 is provable in pa .",
    "the converse is exactly theorem  [ thm : chaitin ] .",
    "[ cor : provchatinrandimpliesrand ] every provably c.e .  and chaitin - random real is provably random .",
    "if @xmath5 is provably chaitin - random and c.e .",
    "then by theorem  [ thm : representation ] , @xmath7 for some provably universal machine @xmath0 , so @xmath5 satisfies solovay s formula ( [ solovayformula ] ) with @xmath321 .",
    "this section proves its title .",
    "we start with the following result by solovay @xcite :    [ lem : solovayrepresentation ] let @xmath8 be a universal machine . if @xmath5 is c.e .  and ml - random",
    ", then there exists an integer @xmath207 and a c.e .",
    "real @xmath208 such that ( [ solovayformula ] ) is satisfied .",
    "01 @xmath322    using the proof of theorem  [ thm : dominates ] , we deduce that @xmath323 ( because @xmath5 is c.e .  and ml - random ) .",
    "consequently , we can consider the primitive recursive increasing sequences @xmath264 and @xmath265 of rationals , with @xmath271 and converging to @xmath5 and @xmath307 respectively , and a constant @xmath207 such that for all @xmath31 , @xmath324 the c.e .",
    "real @xmath325 is positive and @xmath326    it is not difficult to see that the converse implication in lemma  [ lem : solovayrepresentation ] is also true . in fact , a sharper result can be proved :    [ thm : provablyrandom ] let @xmath8 be provably universal , @xmath207 be an integer , @xmath311 a positive c.e .",
    "then @xmath327 is provably chaitin - random ( ml - random ) .",
    "let @xmath328 be a primitive recursive enumeration of the domain of @xmath8 and @xmath329 be a primitive recursive increasing sequence with limit @xmath311 .",
    "the sequence of rationals @xmath330 is primitive recursive , increasing and converges to @xmath5 .",
    "take @xmath331 and observe that for all @xmath31 , @xmath332 hence pa proves that @xmath333 . using theorem  [ thm : omegarep ]",
    "we can find a provably universal machine @xmath0 such that @xmath306 is provable in pa . by theorem  [ thm :",
    "chaitin ] , @xmath5 is provably chaitin - random and by theorem  [ thm : chaitintoml ] , @xmath5 is provably ml - random .",
    "we can now state our main result :    [ thm : cerandprov ] every c.e .  and random real is provably c.e .  and chaitin - random ( ml - random ) , hence provably c.e .  and random .",
    "start with a provably universal machine @xmath8 ( theorem  [ thm : nonprovunivmachine ] ) . by lemma  [ lem : solovayrepresentation ] there exist @xmath85 and @xmath311 defining the representation ( [ solovayformula ] ) for @xmath5 : @xmath334 since @xmath8 is provably universal , theorem  [ thm : provablyrandom ] shows that that @xmath335 is provably chaitin - random ( ml - random ) .",
    "therefore @xmath5 is provably chaitin - random ( ml - random )",
    ". finally use corollary  [ cor : provchatinrandimpliesrand ] to deduce that @xmath5 is provably random .",
    "theorem  [ thm : representation ] can now be stated in the form :    [ thm : representationfinal ] a real @xmath5 is provably c.e .   and",
    "random iff it is provable that @xmath7 for some provably universal machine @xmath0 .",
    "use theorem  [ thm : cerandprov ] and corollary  [ cor : provchatinrandimpliesrand ] .",
    "[ cor : uu ] for every universal machine @xmath0 there exists a provably universal machine @xmath336 such that @xmath337 .    since @xmath68 is c.e .  and random , by theorem  [ thm : cerandprov ] we deduce that @xmath68 is provably chaitin - random ,",
    "so by theorem  [ thm : representation ] we get a provably universal machine @xmath336 such that @xmath337 .",
    "[ cor : secondrep ] every c.e .  and",
    "random real can be written as the halting probability of a provably universal machine .",
    "use theorems  [ thm : cerandprov ] and [ thm : representationfinal ] .",
    "from the previous two sections we know that every c.e .",
    "random real can be written as the halting probability of a provably universal machine , so it is provable random .",
    "does there exist a universal machine whose halting probability is not provable random ? by theorem  [ thm : chaitin ]",
    "such a machine should not be provably universal ( and such machines exist by theorem  [ thm : nonprovunivmachine ] ) .",
    "we answer in the affirmative this question . to this aim",
    "we fix an effective enumeration of all c.e .",
    "reals in ( 0,1 ) @xmath338 ( for example , by enumerating all increasing primitive recursive sequences of rationals in ( 0,1 ) ) and define the set @xmath339 . a set @xmath340 is called c.e .  if the set @xmath341 is c.e .",
    "note that in @xmath70 we enumerate all indices for all elements in @xmath70 .",
    "[ upp ] @xcite if @xmath340 is c.e .",
    ", then for all c.e .  reals @xmath342 and @xmath343 we have @xmath344 .    let @xmath345 be a c.e .",
    "not computable set of natural numbers enumerated by a primitive recursive function @xmath346 , and for each @xmath31 let @xmath347 be a primitive recursive increasing sequence of rationals in ( 0,1 ) such that @xmath348 .",
    "let @xmath349 and define the function @xmath350 because @xmath343 there exists a natural @xmath351 such that @xmath352 .",
    "if @xmath353 , then there exists an @xmath282 such that @xmath354 , hence @xmath355 , for @xmath356 , so @xmath357 . if @xmath358 , then for all @xmath110 , @xmath359 , so @xmath360 .    because of the uniform definition of @xmath361 we can construct a computable function @xmath61 such that @xmath362",
    ".    finally , let s assume by absurdity that @xmath363 .",
    "the set @xmath364 is c.e .  because @xmath70 is c.e . ,",
    "but in view of the definition of @xmath365 , @xmath366 , a non c.e .",
    "let @xmath367 be a c.e .",
    "enumeration of all universal machines .",
    "consider now the sets @xmath368 and @xmath369 by enumerating proofs in pa we deduce that @xmath370 is c.e .",
    ", so @xmath371 , for some primitive recursive function @xmath61 .",
    "we have : @xmath372 .",
    "is @xmath373 c.e . ?",
    "the answer is negative :    [ thm : haltprobnotprov ] there exists a universal machine @xmath374 such that @xmath375 for all @xmath110 .",
    "take a universal machine @xmath0 such that @xmath376 and construct the c.e .",
    "real @xmath377 , where @xmath378 . as @xmath379 and @xmath262",
    "is not random , @xmath380 , for all @xmath110 , so by lemma  [ upp ] , @xmath381 is not c.e .",
    ", hence the theorem is proved .",
    "* comment * there is no contradiction between corollary  [ cor : uu ] and theorem  [ thm : haltprobnotprov ] : there exist a universal machine @xmath374 and a provably universal machine @xmath382 such that @xmath383 and @xmath384 for all @xmath110 : pa can not prove the randomness of @xmath385 based on @xmath374 , but can prove the randomness of @xmath383 based on @xmath382 .",
    "in the above we gave proofs that various statements , once suitably formalised in the language of first order logic , were derivable from the axioms of pa . in principle , but for lack of space and patience , we could have presented complete pa derivations of each statement proved . instead , as is common practice for all but the simplest of results , we sketched constructions which leave the actual derivations implicit .",
    "recent advances in theorem proving computer programs , such as the proof assistant isabelle @xcite , have allowed complete formal derivations of nontrivial mathematical results . in such systems ,",
    "humans write a sequence of proof commands , and the computer system searches for a complete derivation , if one exists .",
    "essentially , the human user gives a sequence of intermediate lemma with proof directions , and the computer interpolates the full derivation .",
    "( for a recent perspective on the importance of formalising mathematics see @xcite . )    using isabelle , we formalised and proved the kraft - chaitin theorem ( theorem [ thm : kc ] ) , a key result in our above proof . to keep our presentation self - contained , we begin by showing how to formalise and prove a simple result about strings ; for a full introduction to the isabelle system see @xcite .",
    "we follow with a formalisation of the kraft - chaitin theorem , then sketch its formal proof .",
    "the full proof script is available online @xcite .      to illustrate isabelle and its use ,",
    "we will formalise and prove the following simple property of strings :    given strings @xmath386 , if @xmath98 extends @xmath232 then @xmath387 extends @xmath232 .",
    "strings are naturally represented by the isabelle list data - type .",
    "here represents the empty list , and y#ys represents the list formed by concatenating the element y with the list ys . for example , the string @xmath388 is represented by 0 # 0 # 1 # [ ] ( or for short ) .",
    "the following code inductively defines whether the list a extends b , denoted extends a b :    .... fun extends : : \" ' a list = > ' a list = > bool \" where    \" extends [ ] [ ] = true \"        ....    when faced with the above definition , isabelle automatically proves termination ( in this case , by observing that the first argument always decreases in length with each recursive call ) .",
    "let us first prove that any list extends the empty list .",
    "we enter into isabelle :    .... lemma extends1 : \" extends a [ ] \" ....    it responds with the propositions we need to prove :    .... goal ( 1 subgoal ) :   1 . extends a [ ] ....    it is natural to prove this by induction on a , by entering the command ` apply(induct a ) ` .",
    "this results in two proof obligations , one for the base case and the other for the inductive step :    .... goal ( 2 subgoals ) :   1 .",
    "extends [ ] [ ]   2 . ! !",
    "a a. extends a [ ] = = > extends ( a # a ) [ ] ....    the first proposition is one of the cases in our definition of extend . in the second ! !",
    "denotes universal quantification and this similarly follows from one of our definition cases .",
    "we tell isabelle to simplify these expressions with the command ` apply(simp_all ) ` .",
    "isabelle manages to simplify all these expressions down to true , using rewrite rules for simplifying conjunctions , variable identity , and expanding the definition of extends . as a result",
    "we get :    .... goal : no subgoals ! ....    having completed the proof , we compactly store it in the following format :    .... lemma extends1 : \" extends a [ ] \"    apply(induct a ) apply(simp_all ) done ....    we can now attempt our original goal :    .... lemma extends2 : \" extends ( a@b ) a \"    goal ( 1 subgoal ) :   1",
    ". extends ( a @ b ) a ....    the concatenation of lists a and b is denoted a @ b. we again induct with the command ` apply(induct a ) ` , then simplify with the command ` apply(simp_all ) `    .... goal ( 2 subgoals ) :   1 .",
    "extends ( [ ] @ b ) [ ]   2 . ! !",
    "a a. extends ( a @ b ) a = = > extends ( ( a # a ) @ b ) ( a # a )    goal ( 1 subgoal ) :   1 . extends b [ ] ....    since we proved this before , we use the command ` apply(simp only : extends1 ) ` to reuse our previous result , completing the proof . in sum :    .... lemma extends2 : \" extends ( a@b ) a \"    apply(induct a ) apply(simp_all ) apply(simp only : extends1 ) done ....      01    [ thm : kc2 ] suppose @xmath115 is a primitive recursive enumeration of requests such that @xmath389 then there exists a provably prefix - free machine @xmath23 and a primitive recursive enumeration @xmath117 of @xmath118 such that the following is provable in pa :    1 .",
    "@xmath119 , 2 .",
    "@xmath120 for all @xmath121 , 3 .",
    "@xmath122 for all @xmath121 .",
    "@xmath124 , @xmath126 , @xmath127 , @xmath128 .",
    "let @xmath129 be the longest element of @xmath103 of length at most @xmath125 .",
    "if no such string exists , terminate .",
    "@xmath131 . define @xmath132 .",
    "@xmath135 .",
    "the proof of the kraft - chaitin theorem is algorithmic : it describes a particular algorithm ( algorithm  [ alg : kc ] of theorem  [ thm : kc ] ) for selecting strings of the required lengths , and proves that the algorithm is correct . in what follows",
    "we will implement this algorithm in isabelle and will prove its correctness .    the following isabelle code implements algorithm [ alg : kc ] .",
    "we give the definition of each function , then explain what it does .",
    ".... fun extend : : \" nat list = > nat = > nat list list \" where    \" extend l 0 = [ l ] \"                                                  # tl ( extend l n ) \"   ....    for l a binary list representing a binary string , and n a natural number , extend l n computes the list @xmath390.\\ ] ] for example , in isabelle the expression extend [ 0,0,1 ] 5 evaluates to    this corresponds to the set @xmath391 of binary strings .",
    "the set of unallocated prefixes @xmath123 and the set of allocated strings @xmath140 are represented by lists of strings .",
    "the free prefixes are ordered by decreasing length , the allocated strings by the order of allocation .",
    "consider one iteration of the main loop .",
    "let a be the list of previously allocated strings , f the list of free prefixes , and n the length of the string we want to allocate at this step .",
    "( these are denoted @xmath140 , @xmath123 , and @xmath125 in the original algorithm . )",
    "kcstep a f n returns the updated pair of allocated strings and free prefixes ( @xmath153 and @xmath392 ) .",
    ".... consts kcstep : : \" nat list list = > nat list list = > nat                                  = > ( nat list list * nat list list ) \" primrec    \" kcstep a [ ] n        = ( a , [ ] ) \"    ( * fail case * )    \" kcstep a ( f # f ) n   = ( if length f < = n                   then ( ( hd ( extend f ( n - length f ) ) ) # a ,                         ( tl ( extend f ( n - length f ) ) ) @ f )                  else ( fst ( kcstep a f n ) , f # snd ( kcstep a f n ) ) ) \" ....    kcstep searches through the list f of free prefixes for the longest string of length at most n. one it finds it , it calls extend , which returns a list of extended prefixes .",
    "it takes the first string in the list , guaranteed to have exactly length n , and adds it to the allocated strings list . the rest of the strings",
    "are placed on the free prefixes list .",
    "for example , kcstep [ ] [ [ ] ] 2 evaluates to    ( [ [ 0,0 ] ] , [ [ 0,1 ] , [ 1 ] ] )    which corresponds to the list @xmath393 of allocated strings and the set @xmath394 of free prefixes .",
    ".... consts kcloop : : \" nat list = > ( nat list list * nat list list )                              = > ( nat list list * nat list list ) \" primrec    \" kcloop [ ] x = x \"    \" kcloop ( l#ls ) x = ( kcstep ( fst ( kcloop ls x ) ) ( snd ( kcloop ls x ) ) l ) \" ....    for a list of lengths l and a pair ( a , f ) of allocated strings and free prefixes , kcloop l ( a , f ) runs kcstep to allocate strings for every length in l. for example , kcloop [ 3,4,2 ] ( [ ] , [ [ ] ] ) allocates a string of length 2 , then one of length 4 , then one of length 3 , starting from the initial state where no strings are yet allocated ( ) and the empty string is our free prefix ( ) .    for example ,",
    "kcloop [ 3 , 2 ] ( [ ] , [ [ ] ] ) evaluates to    ( [ [ 0,1,0 ] , [ 0,0 ] ] , [ [ 0,1,1 ] , [ 1 ] ] )    which corresponds to the list @xmath395 of allocated strings ( note that we reverse the list ) , and the set @xmath396 of free prefixes .",
    ".... fun kc : : \" nat list = > nat list list \" where      \" kc ls = ( fst ( kcloop ls ( [ ] , [ [ ] ] ) ) ) \" ....    for a list of lengths l , kc l returns the list of strings allocated by running kcloop on the list starting from the initial state where no strings have been allocated .",
    "for example , kc [ 4,3,2 ] evaluates to    which corresponds to the sequence @xmath397 of allocated strings .",
    "this implements kraft - chaitin s algorithm , for we will prove that :    1 .",
    "if our list of lengths obeys kraft s inequality , @xmath398 , then kc ls is a list of strings , and the @xmath110th element of kc ls has length equal to the @xmath110th element of ls .",
    "kc ls is always a prefix - free list ( no two distinct elements of the list are prefixes of each other ) .",
    "if we add new lengths to the start of ls , then this adds new strings to the end of kc ls without changing the old ones .",
    "that is , once a string of a given length is allocated it is not changed .    to prove the above we need to define what a prefix - free list is , a function to evaluate kraft s inequality , a function which checks whether the lengths of one list match the lengths in another , and a tool to check whether one list extends another .",
    ".... fun prefixes : : \" nat list = > nat list = > bool \" where    \" prefixes [ ] x = true \"        consts incomparable : : \" nat list = > nat list list = > bool \" primrec    \" incomparable x [ ] = true \"    \" incomparable x ( y # ys ) = ( ~(prefixes x y ) & ( incomparable x ys ) ) \"    consts prefixfree : : \" nat list list = > bool \" primrec    \" prefixfree [ ] = true \"    \" prefixfree ( x # xs ) = ( ( incomparable x xs ) & ( prefixfree xs ) ) \" ....    if x is a prefix of y , or vice versa , then prefixes x y. for example prefixes",
    "[ 0,0,1 ] [ 0,0 ] is true .",
    "incomparable x a holds if x is not a prefix of any string in a , for instance incomparable [ 0,0 ] [ [ 1,0 ] , [ 1,1,1 ] ] holds .",
    "prefixfree l holds if the list l is prefix - free , for instance prefixfree [ [ 0,0 ] , [ 1,0 ] , [ 1,1,1 ] ] holds .",
    ".... consts expn2 : : \" nat = > rat \" primrec    \" expn2 0 = 1 \"    \" expn2 ( suc n ) = ( 1/2 ) * expn2 n \"    consts meas_nat : : \" nat list = > rat \" primrec    \" meas_nat [ ] = 0 \"    \" meas_nat ( f#f ) = ( expn2 f + meas_nat",
    "f ) \" ....    we define expn2 n equal to @xmath399 . meas_nat f computes the `` measure '' of a sequence of natural numbers f , for example meas_nat [ 4,3,2 ] equals 7/16 .",
    ".... fun lengthsmatch : : \" nat list list = > nat list = > bool \" where    \" lengthsmatch [ ] [ ] = true \"        ....    the expression lengthsmatch x y holds if the lengths of each string in x matches the corresponding number in y. for example , we have lengthsmatch [ [ 0,0 ] , [ 1,0 ] , [ 1,1,1 ] ] [ 2,2,3 ] is true .",
    ".... fun extends : : \" ' a list = > ' a list = > bool \" where    \" extends [ ] [ ] = true \"        ....    finally , extends a b holds if the list a extends the list b , so extends [ 0,1 ] [ 0 ] holds .    with the above definitions we can state the three results which establish correctness :",
    ".... theorem kc_correct1 : \" meas_nat ls < = 1 = = > lengthsmatch ( kc ls ) ls \"    theorem kc_correct2 : \" prefixfree ( kc ls ) \"    theorem kc_extend :    \" extends ( rev ( kc ( l2 @ l1 ) ) ) ( rev ( kc l1 ) ) \" ....    the first says that if ls is a list of natural numbers @xmath125 which satisfies kraft s inequality @xmath400 , then the strings kc ls allocated by running algorithm  [ alg : kc ] on this list have exactly the lengths ls we asked for .    the second says the strings allocated are prefix - free .",
    "the last says that when algorithm  [ alg : kc ] allocates additional strings it does not change strings it has previously allocated . to see this , note that when we run kc l the algorithm allocates strings starting from the end of the list l. this means , the first element of kc l is the last string allocated .",
    "kc ( l2 @ l1 ) is the list of strings allocated if we allocate strings with lengths in l1 then strings with lengths in l2 .    together , establishing these would show that the kc algorithm constructively establishes the kraft - chaitin theorem .",
    "all the above merely formalised the algorithm and stated the theorem we wish isabelle to prove .",
    "this gets the order mixed slightly , since formalising this theorem unearthed a mistake in the algorithm , so the process was mutual . in some sense",
    "this formalisation of the theorem is the major creative work , the rest is just technical detail . as one might guess , however , most of the work is in these details . to prove the above theorems we must guide isabelle to them by establishing numerous intermediate lemmas , and telling isabelle which proof techniques to use to establish each .",
    "often we just advise isabelle to induct on a variable then simplify , but sometimes we must give more detailed guidance .",
    "the isabelle proof follows the proof given for theorem  [ thm : kc ] : we establish that the inner loop preserves some invariants , and use these invariants to establish correctness .",
    "recall the algorithm has two variables : the list of allocated strings and the list of free strings .",
    "each pass through the loop will ( potentially ) add one new allocated string , and modify the free strings .",
    "we then show that these two lists combined remain prefix - free , their joint measure never decreases , and that there are never two free strings of the same length .    for reasons of space",
    "we give only the definitions required to state the above intermediate results and show how they are formalised in isabelle .",
    "the proof in its entirety is available online @xcite .",
    ".... fun strictlysorted : : \" nat list list = > bool \" where    \" strictlysorted [ ] = true \"                                        & ( strictlysorted ( x2 # xs ) ) ) \"   ....    strictlysorted l holds if the strings in l are ordered by ( strictly ) decreasing length .",
    "in particular , this means there can be no two strings of the same length in l.    .... fun inv1 : : \" nat list list * nat list list = > bool \" where    \" inv1 x = strictlysorted ( snd x ) \"    fun inv2 : : \" nat list list * nat list list = > bool \" where    \" inv2 x = prefixfree ( ( fst x ) @ ( snd x ) ) \" ....    the first invariant is that the list of free strings is strictly sorted .",
    "this is needed to show both that there is at most one string of any given length and to show that the algorithm will always select the longest string it is able to .",
    ".... fun inv : : \" nat list list * nat list list = > bool \" where    \" inv x = ( ( inv1 x ) & ( inv2 x ) ) \"    theorem kcstep_inv : \" inv ( a , f ) = = > inv ( kcstep a f n ) \" ....    this says simply that if the invariants held of the variables before running through the loop once , then they hold afterwards .",
    ".... consts meas : : \" nat list list = > rat \"        ( * the measure of a prefix free set * ) primrec    \" meas [ ] = 0 \"    \" meas ( x # xs ) = expn2 ( length x ) + meas xs \" ....    this defines the measure of a list of strings : the usual @xmath401 .",
    ".... lemma kcstep_meas : \" meas ( ( fst ( kcstep a f n ) ) @ ( snd ( kcstep a f n ) ) )                       = meas ( a@f ) \" ....    this says that measure is preserved at each step of the loop .",
    "this measure will be 1 for all the intermediate states of the kc algorithm , but we need this more general result for the inductive proofs to work .    a number of further intermediate results are required both to establish the above invariants and to apply them to the main theorems .",
    "below are three of the most important , which one may recall from the proof of theorem [ thm : kc ] ( in total , there are 102 theorems and lemmas proved ) .",
    ".... theorem meas_alloc : \" [ | expn2 n < = meas f ; strictlysorted f | ]                        = = > length ( last f ) < = n \"    lemma kcstep_correct1 : \" [ |inv ( a , f ) ; expn2 n < = meas f| ]              = = > ( tl ( fst ( kcstep a f n ) ) = a )                 & ( length ( hd ( fst ( kcstep a f n ) ) ) = n ) \"              lemma kcstep_correct2 : \" [ |inv ( a , f ) ; expn2 n < = meas f| ]               = = > meas ( fst ( kcstep a f n ) ) = meas a + expn2 n \" ....    theorem meas_alloc formalises the result that if @xmath399 is smaller than the measure of a set @xmath402 , and that set has no two strings of the same length , then there is a string of length at most @xmath31 in @xmath402",
    ". lemma kcstep_correct1 says that if the invariants are satisfied by the current variables a and f , and the measure of f is at least @xmath399 , then kcstep succeeds .",
    "this means that we allocate one new string of length exactly @xmath31 , leaving the old strings untouched .",
    "lemma kcstep_correct2 expresses an implied result : if the algorithm succeeds , then the measure of the list of allocated strings increases by exactly @xmath399 ( isabelle will often not notice conclusions that seem obvious to the prover ; they must be spelt out ) .",
    "if pa receives an algorithm for a machine @xmath8 , a proof that @xmath8 is universal and prefix - free , an integer @xmath207 , and a computable increasing sequence of rationals converging to a real @xmath113 , then pa can prove that @xmath209 is c.e .  and random .",
    "similarly , if pa receives an algorithm for a machine @xmath0 , a proof that @xmath0 is universal and prefix - free , then it can prove that @xmath1 is c.e .  and random .",
    "this implies that every c.e .",
    "random real is provably c.e .  and",
    "random  as stated in solovay s email @xcite .",
    "we have offered two representations for c.e .  and",
    "random reals from which pa can prove that the real is c.e .  and random .",
    "in the first we fix a provably universal prefix - free machine @xmath8 and we vary the integer @xmath207 and the c.e . real @xmath113 to get via the formula @xmath403 all c.e .  and random reals .",
    "in the second we vary all provably universal prefix - free machines @xmath0 to get via @xmath68 all c.e .  and random reals .",
    "a key result was to show that the theorem that `` a real is c.e .  and",
    "random iff it is the halting probability of a universal machine '' @xcite can be proved in pa .",
    "our proof , which is simpler than the standard one , can be used also for the original theorem .",
    "we proved two negative results showing the importance of the representation for provability of randomness : a ) there exists a universal machine whose universality can not be proved in pa , b ) there exists a universal machine @xmath0 such that , based on @xmath0 , pa can not prove the randomness of @xmath68 .",
    "chaitin @xcite explicitly computed a constant @xmath85 such that if @xmath404 is larger than the size in bits of the program for enumerating the theorems of pa plus @xmath85 , then pa can not prove that a specific string @xmath98 has complexity greater than @xmath404 , @xmath405 .",
    "consequently , pa can not prove randomness of almost all random ( finite ) strings .",
    "our positive result shows an interesting difference between the finite and the infinite cases of ( algorithmic ) randomness .",
    "does our positive result contradict chaitin and solovay s negative results discussed in the introduction ?",
    "the answer is negative because the digits of the binary expansion of a random c.e .",
    "real are not computable",
    ".    our positive result would not be satisfactory without demonstrating our proofs with an automatic theorem prover .",
    "we have chosen isabelle @xcite to obtain an automatic proof of our version of the kraft - chaitin theorem , one of the key results of this paper .",
    "the paper contains a description of the formalisation ( for isabelle ) of the kraft - chaitin theorem and the description of the main steps of the automatic proof ; the full proof is available online @xcite .",
    "finally we speculate about the role of the automatic prover .",
    "how can an automatic theorem prover help understanding / proving a mathematical statement ?",
    "there are at least three possibilities .",
    "a ) use the prover to verify the theorem by discovering a proof , call it `` solovay mode '' ( because this corresponds to the result reported in this paper : bob solovay communicated to one of us the statement to be proved and we found a proof ) .",
    "it is worth observing that the kraft - chaitin theorem has two `` roles '' : one , as an algorithm , to be executed , the other , as a mathematical statement , to be proved .",
    "previous formalisation efforts focused only on the first part ; our present work was directed towards the second .",
    "one could imagine that mathematical journals might use such systems in the process of refereeing @xcite .",
    "b ) the second possibility is to use the prover to verify a human - made proof  a full isabelle proof for all results in this paper is under construction .",
    "c ) the third possibility is to use the prover as some kind of `` assistant '' in an interactive process of discovery / proving . during the work to automate the proof of the kraft - chaitin theorem a mistake in our human - made argument",
    "was unearthed and corrected .",
    "we also used the experience with isabelle to test the adequacy of the representation of a c.e .",
    "random real in meeting the goal : to obtain the pa proof of randomness .",
    "we thank bob solovay for suggesting the result of this paper and useful comments , jeremy dawson for helpful advice on the isabelle proof , and greg chaitin , liam fearnley , bruno grenet , mathieu hoyrup , andr nies , cristobal rojas , frank stephan , garry tee and the anonymous referee for useful comments which improved our paper .",
    "99 w. s. brainerd , l. h. landweber .",
    "_ theory of computation _ , wiley , new york , 1974 .",
    "c.  s.  calude .",
    "chaitin @xmath246 numbers , solovay machines and incompleteness , _ theoret . comput .",
    "_ 284 ( 2002 ) , 269277 .    c. s. calude . a characterization of c.e",
    "random reals , _ theoret .",
    "_ 271 ( 2002 ) , 314 . c. s. calude",
    "_ information and randomness .",
    "an algorithmic perspective _ , 2nd edition , revised and extended , springer verlag , berlin , 2002 .      c.  s.  calude , p.  hertling , b.  khoussainov , and y.  wang .",
    "recursively enumerable reals and chaitin @xmath246 numbers , in : m.  morvan , c.  meinel , d.  krob  ( eds . ) , _ proceedings of the 15th symposium on theoretical aspects of computer science ( paris ) _ , springer ",
    "verlag , berlin , 1998 , 596606 .",
    "full paper in _ theoret .",
    "_ 255 ( 2001 ) , 125149 .",
    "r. m. solovay . a version of @xmath246 for which zfc can not predict a single bit , in c.s .",
    "calude , g. pun ( eds . ) .",
    "_ finite versus infinite .",
    "contributions to an eternal dilemma _ , springer - verlag , london , 2000 , 323334 .",
    "r. m. solovay",
    ". _ draft of a paper ( or series of papers ) on chaitin s work  done for the most part during the period of sept.dec .",
    "1974 _ , unpublished manuscript , ibm thomas j. watson research center , yorktown heights , new york , may 1975 , 215 pp ."
  ],
  "abstract_text": [
    "<S> we prove that every computably enumerable ( c.e . ) </S>",
    "<S> random real is provable in peano arithmetic ( pa ) to be c.e .  random . </S>",
    "<S> a major step in the proof is to show that the theorem stating that `` a real is c.e .  and </S>",
    "<S> random iff it is the halting probability of a universal prefix - free turing machine '' can be proven in pa . </S>",
    "<S> our proof , which is simpler than the standard one , can also be used for the original theorem .    </S>",
    "<S> our positive result can be contrasted with the case of computable functions , where not every computable function is provably computable in pa , or even more interestingly , with the fact that almost all random finite strings are not provably random in pa .    </S>",
    "<S> we also prove two negative results : a ) there exists a universal machine whose universality can not be proved in pa , b ) there exists a universal machine @xmath0 such that , based on @xmath0 , pa can not prove the randomness of its halting probability .    </S>",
    "<S> the paper also includes a sharper form of the kraft - chaitin theorem , as well as a formal proof of this theorem written with the proof assistant isabelle . </S>"
  ]
}