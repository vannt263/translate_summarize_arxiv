{
  "article_text": [
    "ai applications , such as robotics and logistics , rely on a variety of disciplines such as logic , probabilistic reasoning , machine learning and mathematical programming .",
    "these applications are often described in a combination of natural and mathematical language , and need to be engineered for the individual application .",
    "formal languages that allow declarative specifications enable re - use and descriptive clarity .",
    "the subfields of ai have contributed many formalisms for the declarative modeling and effective solving of problems . in knowledge representation and constraint programming , for example , languages such asp @xcite and essence @xcite are prominent , which use sat , smt and mip technology . in machine learning and probabilistic reasoning , statistical relational learning systems and probabilistic programming languages such as markov logic @xcite , church @xcite and problog @xcite",
    "are prominent , which use sampling and model counting methodologies .",
    "finally , in mathematical programming and optimization , disciplined programming @xcite and ampl @xcite have been developed .",
    "be that as it may , it is widely accepted that solving real - world ai problems requires an integration of different disciplines .",
    "consider , for example , that a robot may decide its course of action using a sat - based planner , learn about the world using kalman filters , and grasp objects using geometric optimization technology @xcite . but",
    "contemporary declarative frameworks offer little support for such universality : kr and constraint formalisms mostly focus on model generation for discrete problems , probabilistic programming languages do not handle linear and arithmetic constraints , and finally , optimization frameworks work with linear algebra and algebraic constraints to specify the problem and thus are quite different from the high - level descriptions used in the other disciplines and do not support probabilistic or logical reasoning .",
    "what is lacking here is a universal modeling framework that allows us to declaratively specify problems involving _ logic _ and _ constraints _ , _ mathematical programs _ , as well as _",
    "discrete and continuous probability distributions _ in a simple , uniform , modular and transparent manner .",
    "such a framework would greatly simplify the development and understanding of ai systems with integrated capabilities , and would tame the model building process . in this paper , we propose a new declarative framework called _ semiring programming _ ( sp ) that is an attempt to fill this gap .",
    "eugene freuder ( @xcite ) famously quipped : ",
    "constraint programming represents one of the closest approaches computer science has yet made to the holy grail of programming : the user states the problem , the computer solves it . \"",
    "the underlying idea was summarized in the slogan : @xmath0 the vision of sp builds upon this equation in that : @xmath1 thus a model is expressed in a logical system in tandem with a semiring and a weight function . in its essence , semiring programming rests on three important developments :    * semirings have been successfully shown to unify specifications such as finding a solution versus counting the number of solutions @xcite .",
    "* weighted model counting represents perhaps the simplest approach to reason about weights on possible worlds and elegantly decouples the logical representation from the weight function @xcite .",
    "* probabilistic programming languages like church can appeal to their host languages ( e.g. lisp ) to naturally support composition and abstraction .    as a framework",
    ", sp is set up to allow the modeler to freely choose the logical theory ( syntax and semantics ) and so everything from non - classical logical consequence to real - arithmetic is fair game .",
    "together with a semiring and these weights , a program computes the _",
    "count_. our task will be to show that the usual suspects from ai disciplines , such as sat , csp , bayesian inference , and convex optimization can be : ( a ) expressed as a program , and ( b ) count is a solution to the problem , that is , the count can be a \\{_yes _ , _ no _ } answer in sat , a probability in bayesian inference , or a bound in convex optimization .",
    "in other words , the count is shown to provide abstractions for challenging ai tasks .",
    "we will also demonstrate a variety of more complex problems , such as matrix factorization , and one on compositionality .    the fundamental question , then , is this : how are to we provide a semantics for such a programming language ? it is not possible to piggyback on mathematical accounts of optimization problems in an obvious way , because the language is allowed to be richer than what is usually assumed .",
    "that is a central focus of this paper .    at the outset",
    ", we remark that our concern here is on the formal nature and generality of the framework , in terms of its modeling capabilities .",
    "ideas on solvers are left to a discussion , and their realizations to the future .",
    "the framework is developed in a general way , agnostic about the meaning of sentences .",
    "we adopt ( and assume familiarity with ) terminology from predicate logic @xcite .    a _ theory _",
    "@xmath2 is a triple @xmath3 , where @xmath4 is a set of sentences called the _ language _ of the theory , @xmath5 a set called the _ models _ of the theory , and @xmath6 a subset of @xmath7 called the _",
    "satisfiability relation_.    the set @xmath4 is implicitly assumed to be defined over a vocabulary @xmath8 of relation and function symbols , each with an associated arity .",
    "constant symbols are 0-ary function symbols .",
    "every @xmath4-model @xmath9 is a tuple containing a universe @xmath10 , and a relation ( function ) for each relation ( function ) symbol of @xmath8 . for relation ( constant )",
    "symbol @xmath11 , the relation ( universe element ) corresponding to @xmath11 in a model @xmath12 is denoted @xmath13 for @xmath14 and @xmath15 we write @xmath16 to say that @xmath12 _ satisfies _",
    "@xmath17 we let @xmath18 denote @xmath19 .",
    "finally , the set @xmath20 denotes the literals in @xmath21 and we write @xmath22 to refer to the @xmath4-literals that are satisfied at @xmath12 .",
    "this formulation is henceforth used to instantiate a particular logical system , such as fragments / extensions of first - order logic , as well as non - classical logical consequence .",
    "[ ex : prop theory ] suppose @xmath23 is as follows : @xmath4 is obtained using a set of 0-ary predicates @xmath24 and boolean connectives , @xmath5 are @xmath25 assignments to the elements of @xmath24 , and @xmath6 denotes satisfaction in propositional logic via the usual inductive rules .",
    "then , we obtain a _",
    "propositional theory_.    [ ex : minimal models ] define a theory @xmath26 where @xmath4 is the positive horn fragment from a finite vocabulary , @xmath5 the set of propositional interpretations , and for @xmath27 , define @xmath28 iff @xmath29 ( _ i.e. , _",
    "satisfaction in propositional logic ) and for all @xmath30 this theory can be used to reason about the _",
    "minimal models _ of a formula .",
    "semiring programming draws from the conceptual simplicity of weighted model counting ( wmc ) , which we briefly recap here .",
    "wmc is an extension of # sat , where one simply counts the number of models of a propositional formula @xcite . in wmc ,",
    "one accords a weight to a model in terms of the literals true at the model , and computes the sum of the weights of all models .",
    "[ defn wmc ] suppose @xmath31 is a formula from a propositional language @xmath4 with a finite vocabulary , and suppose @xmath5 is the set of @xmath4-models .",
    "suppose @xmath32 is a weight function",
    ". then :- models @xmath33 we simply write @xmath34 to mean @xmath35 . ]",
    "@xmath36 is called the _ weighted model count _ ( wmc ) of @xmath31",
    ".    the formulation elegantly decouples the logical sentence from the weight function . in this sense , it is clearly agnostic about how weights are specified in the modeling language , and thus , has emerged as an assembly language for bayesian networks  @xcite , and probabilistic programs @xcite , among others .",
    "our programming model is based on algebraic structures called _ semirings _ @xcite ; the essentials are as follows :    a ( commutative ) semiring @xmath37 is a structure @xmath38 where @xmath39 is a set called the _ elements _ of the semiring , @xmath40 and @xmath41 are associative and commutative , @xmath42 is the identity for @xmath43 and @xmath44 is the identity for @xmath45    abusing notation , when the multiplication operator is not used , we simply refer to the triple @xmath46 as a semiring .    the structure @xmath47 is a commutative semiring in that for every @xmath48 @xmath49 @xmath50 , @xmath51 and so on .",
    "in essence , the semiring programming scheme is as follows :    * * input * : a theory @xmath52 , a sentence @xmath53 a commutative semiring @xmath37 , and a weight function @xmath54 * * output * : the _ count _ , denoted @xmath55 .",
    "the scope of these programs is broad , and so we will need different kinds of generality . roughly , the distinction boils down to : ( a ) whether the set of models for a formula is _ finite _ or _",
    "infinite _ , and ( b ) whether the weight function can be",
    "_ factorized _ over the literals or not ( in which case the weight function directly labels the models of a theory ) .",
    "the thrust of this section is : ( a ) to show how these distinctions subsume important model generation notions in the literature , and ( b ) providing rigorous definitions for the count operator . in terms of organization , we begin with the finite case , before turning to the infinite ones .",
    "we present an early preview of some of the models considered in figure [ fig : scope ] .    [ cols=\"<,^,^\",options=\"header \" , ]     ( set - logic pl ) + ( set - algebra [ nat , max,*,0,1 ] ) + ( declare - predicate p ( ) ) + ( declare - predicate q ( ) ) + f = ( p or q ) + ( declare - weight ( p 1 ) ) + ( declare - weight ( ( neg p ) 2 ) ) + ( declare - weight ( q 3 ) ) + ( declare - weight ( ( neg q ) 4 ) ) + ( count f )      here , we generalize the wmc  formulation to semiring labels , but also go beyond classical propositional logic .",
    "we say the theory @xmath56 is _ finite _ if for every @xmath57 @xmath58 is finite .",
    "so , a propositional language with a finite vocabulary is a finite theory , regardless of ( say ) standard or minimal models .",
    "similarly , a first - order language with a finite herbrand base is also a finite theory .",
    "[ defn finite amc ] suppose @xmath52 is a finite theory .",
    "suppose @xmath59 is a commutative semiring .",
    "suppose @xmath60 for any @xmath61 we define : @xmath62 if @xmath63 , then the problem is _ factorized _",
    ", where:@xmath64    essentially , as in wmc , we sum over models and take products of the weights on literals but wrt a particular semiring .    [ ex : sat as amc ] we demonstrate sat and # sat . consider a propositional theory @xmath65 where @xmath66 and suppose @xmath67 letting @xmath5 be standard @xmath4-models , clearly @xmath68 and @xmath69 .",
    "suppose for every @xmath70 @xmath71 is function such that @xmath72 for the semiring @xmath73 : @xmath74    consider the semiring @xmath75 instead . then @xmath76    as with definition [ defn wmc ] , the framework is agnostic about the modeling language .",
    "but for presentation purposes , programs are sometimes described using a notation inspired by the smt - lib standard @xcite .",
    "we demonstrate mpe ( most probable explanation ) and wmc .",
    "consider the theory , semiring and weight function @xmath71 from figure [ fig : sat ] , which specifies , for example , a vocabulary of two propositions @xmath11 and @xmath77 @xmath78 and @xmath79 in accordance with that semiring , the weight of a model , say @xmath80 , of the formula @xmath81 is @xmath82 thus , for the semiring @xmath83 , we have : @xmath84 which finds the most probable assignment .",
    "consider the semiring @xmath85 instead . then : @xmath86 which gives us the weighted model count .",
    "extending the discussion in @xcite , we consider a class of mathematical programs where linear constraints and propositional formulas can be combined freely .",
    "see figure [ fig : logic mathemtical programming ] for an example with non - linear objectives .",
    "formally , quantifier - free linear integer arithmetic and propositional logic are specified as the underlying logical systems , and the domains of constants are typed",
    ". the program declares formulas @xmath87 , @xmath88 , and @xmath89 .",
    "the counting task is non - factorized , and our convention for assigning weights to models is by letting the declare - weight directive also take arbitrary formulas as arguments .",
    "of course , true holds in every model , and so , the weight of every model is determined by the evaluation of @xmath90 at the model , that is , for any @xmath91 its weight is @xmath92 .",
    "for example , a model that assigns 1 to x1 and 1 to x2 is accorded the weight @xmath93 computing the count over @xmath94 then yields a model of @xmath95 with the highest value for @xmath90 .    to see this program in action , consider that every model of @xmath95 must satisfy @xmath96 and so must admit @xmath97 and @xmath98 since @xmath99 can only take values @xmath100 , given the constraints , the desired model must assign @xmath101 and @xmath102 to @xmath103 and @xmath104 respectively .",
    "then , its weight is @xmath105    ( set - logic qf_lia;pl ) + ( set - algebra [ nat , max,0 ] ) + ( set - type int=\\{1, ... ,10 } ) + ( declare - function x1 ( ) int ) + ( declare - predicate p1 ( ) ) + ... / * declare x2 and p2 analogously * / + f = ( ( p1 or p2 ) = > 3*x1",
    "< = 4 ) + g = ( p2 = > ( 2*x2 < = 5 ) ) + h = ( ( f and g ) and p2 ) + ( declare - weight true x1*x2 ) + ( count h )    encoding finite domain constraint satisfaction problems as propositional satisfiability is well - known . the benefit , then , of appealing to our framework is the ability to easily formulate counting instances :    [ thm : csp ] suppose @xmath106 is a csp over variables @xmath107 , domains @xmath108 and constraints @xmath109 . there is a first - order theory @xmath110 , a @xmath4-sentence @xmath31 and a weight function @xmath71 such that @xmath111 over @xmath112 iff @xmath106 has a solution .",
    "furthermore , @xmath106 has @xmath113 solutions iff @xmath114 over @xmath115    constraints are boolean - valued functions @xcite , and so constraints over @xmath107 can be encoded as @xmath4-sentences .",
    "we omit the details , but do an example .",
    "see figure [ fig : graph coloring ] for a counting instance of graph coloring : @xmath116 determines there is an edge between x and y , node(x ) says that x is a node , and color(x , y ) says that node @xmath117 is assigned the color @xmath118 the actual graph is provided using the formula @xmath119 which declares a fully connected 3-node graph . also , cons is a conjunction of the usual coloring constraints , _",
    "an edge between nodes @xmath117 and @xmath120 means that they can not be assigned the same color .",
    "let @xmath5 be a set of first - order structures for the vocabulary @xmath121 , respecting types from figure [ fig : graph coloring ] .",
    "the interpretation of \\{edge , node } is assumed to be the same for all the models in @xmath5 and is as given by @xmath122 basically , then , the models differ in their interpretation of @xmath123 .",
    "one model of @xmath124 ( data and cons ) , for example , is @xmath125 .",
    "the weights of all models is 1 , and so , for @xmath75 we get : @xmath126    to summarize , the following result is easily shown for semiring programs :    suppose @xmath127 .",
    "suppose @xmath128 is a solution to @xmath129 in that @xmath130 for sat and csp , and @xmath131 for the rest .",
    "then for any @xmath132 , there is a @xmath65 , @xmath133 @xmath71 and @xmath134 such that @xmath135    ( set - logic fol ) + ( set - algebra [ nat,+,0 ] ) + ( set - type color=\\{r , b , g } ) + ( set - type node=\\{1,2,3 } ) + ( declare - predicate node ( node ) ) + ( declare - predicate edge ( node , node ) ) + ( declare - predicate color ( node , color ) ) + n = ( node(1 ) and node(2 ) and node(3 ) ) + e = ( edge(1,2 ) and edge(2,3 ) and edge(3,1 ) ) + data = ( n and e ) + cons = / * coloring constraints ( omitted ) * / + ( declare - weight true 1 ) + ( count ( data and cons ) )      defining measures @xcite on the predicate calculus is central to logical characterizations of probability theory @xcite .",
    "we adapt this notion for semirings to introduce a general form of counting . for technical reasons , we assume that the universe of the semirings is @xmath136 .",
    "( if required , the range of the weight function can always be restricted to any subset of @xmath137 )    [ defn amc measure simple ] let @xmath138 be any semiring and @xmath52 a theory .",
    "let @xmath139 be a @xmath140-algebra over @xmath5 in that @xmath141 is a @xmath140-finite measurable space wrt the measure @xmath142 respecting @xmath143 that is , for all @xmath144 @xmath145 @xmath146 and @xmath147 is closed under complement and countable unions : for all pairwise disjoint countable sets @xmath148 we have @xmath149 moreover , because the spaces are @xmath140-finite , @xmath5 is the countable union of measurable sets with finite measure . then for any @xmath53 @xmath150    [ ex : convex ]",
    "we demonstrate convex optimization .",
    "suppose @xmath65 is a first - order theory only containing constants @xmath151 with domains @xmath152 suppose @xmath153 is a conjunction of formulas of the form @xmath154 , for real numbers @xmath155 , and thus describing a polyhedron .",
    "in other words , for every @xmath156 @xmath157 and so , @xmath12 is a real - valued assignment to @xmath158 in particular , if @xmath159 then @xmath160 is a point inside the polyhedron @xmath31 .",
    "let @xmath139 be a @xmath140-algebra over @xmath5 and so every @xmath161 is a measurable set of points .",
    "suppose @xmath162 is a convex function that we are to minimize .",
    "consider the semiring @xmath163 and a measure @xmath147 such that for any @xmath161 : @xmath164 which finds the infimum of the @xmath165-values across the assignments in @xmath166 then , @xmath167 gives the minimum of the convex function in the feasible region determined by @xmath17    suppose @xmath165 is a concave function that is to be maximized .",
    "we would then use @xmath168 instead , which finds the supremum of the @xmath165-values across assignments in @xmath169 .",
    "more generally , the same construction is easily shown to be applicable for other families of mathematical programming ( _ e.g. , _",
    "non - linear optimization ) as follows :    [ thm math programming ] suppose @xmath170 is a set of real - valued variables .",
    "suppose @xmath171 is the feasible region of an optimization problem of the form @xmath172 for @xmath173 where @xmath174 and @xmath175 .",
    "suppose @xmath176 is a function to be maximized ( minimized ) .",
    "then there is a @xmath177 and @xmath134 such that @xmath178 is the maximum ( minimum ) value for @xmath165 in the feasible region @xmath179    [ ex matrix factorization ] for a non - trivial example , consider the problem of matrix factorization , a fundamental concern in information retrieval and computer vision @xcite . given a matrix @xmath180 , we are to compute matrices @xmath181 and @xmath182 , such that @xmath183 is minimized .",
    "( here , @xmath184 denotes the frobenius norm . ) using real arithmetic , we provide a formulation in figure [ fig : matrix factorization ] .",
    "( free variables are assumed to be implicitly quantified from the outside . )",
    "let @xmath65 be the theory of real arithmetic , where @xmath4 includes the following function symbols : @xmath185 here , @xmath186 is a real - valued function such that @xmath187 and @xmath188 in that @xmath189 is the entry at the @xmath190 row and the @xmath191 column of the matrix @xmath192 ; these entries are specified by @xmath122 letting @xmath193 ( data and f and g ) , the set @xmath194 are those @xmath4-models whose interpretation of @xmath195 is fixed by @xmath122 basically , these models vary in their interpretations of @xmath196 , which determines their interpretations for @xmath197 and @xmath198 . here ,",
    "app computes the product of the matrices left and @xmath199 and err computes the frobenius norm wrt app and input .",
    "let @xmath139 be a @xmath140-algebra over @xmath200 the weight function in figure [ fig : matrix factorization ] determines a measure @xmath147 such that for any @xmath169 : @xmath201 therefore , @xmath202 yields the lowest @xmath198 value ; the model @xmath12 such that @xmath203 is one with the best factorization of matrix @xmath204    ( set - logic lra ) + ( set - algebra [ real , inf,0 ] ) + ( declare - function input ( int , int ) real ) + ... / * declare left , right , app * / + ( declare - function err ( ) real ) + data = / * entries in input matrix ( omitted ) * / + f = app(x ,",
    "y ) = = sum\\{e } left(x , e)*right(e , y ) + g = err = = norm(sum\\{x , y } input(x , y ) - app(x , y ) ) + ( declare - weight true err ) + ( count ( data and f and g ) )      despite the generality of the above definition , we would like to address the factorized setting for a number of applications , the most prominent being probabilistic inference in hybrid graphical models @xcite .",
    "consider , for example , a joint distribution on the probability space @xmath205 . here",
    ", it is natural to define weights for each random variable separately , prompting a factorized formulation of counting .",
    "more generally , in many robotic applications , such hybrid spaces are common @xcite .",
    "the main idea then is to apply our definition for counting by measures to each variable independently , and construct a measure for the entire space by _ product measures _ @xcite .",
    "a second technicality is that in the finite case , the set of literals true at a model was finite by definition .",
    "this is no longer the case .",
    "for example , suppose @xmath206 is a real - valued variable in a language @xmath4 , and @xmath12 is a @xmath4-model that assigns @xmath207 to @xmath208 then , @xmath209 but also @xmath210 @xmath211 and so on .",
    "thus , for technical reasons , we assume that @xmath4 only consists of constant symbols @xmath212 with fixed ( possibly infinite ) domains @xmath213 ; the measures are defined for these domains .",
    "[ defn measure amc ] let @xmath214 be any semiring , @xmath215 any theory where @xmath216 over fixed domains @xmath217 suppose @xmath218 suppose @xmath219 is a @xmath140-algebra over @xmath220 in that @xmath221 is a @xmath140-finite measurable space wrt the measure @xmath222 respecting @xmath223 ( as in definition [ defn amc measure simple ] ) . define the product measure @xmath224 on the measurable space @xmath225 satisfying :- finite assumption via the hahn - kolmogorov theorem @xcite . ]",
    "@xmath226 for all @xmath227 finally , define @xmath228 ) \\end{array}\\ ] ] where @xmath229 =    { \\left\\ { x{_}1\\su m \\times \\ldots \\times x{_}k\\su m \\mid m \\in { { \\cal m}}(\\phi )   \\right\\}}.   $ ]    intuitively , @xmath230 capture sets of assignments , and the product measure considers the algebraic product of the weights on assignments to terms . as before , for @xmath231 @xmath232 finally , precisely because the measures are defined on the domains of the terms , we obtain these for all of the satisfying interpretations using the construction @xmath233 .",
    "$ ]    [ ex polyhedron ] we demonstrate the problem of finding the volume of a polyhedron , needed in the static analysis of probabilistic programs @xcite .",
    "suppose @xmath65 and @xmath134 is as in example [ ex : convex ] , that is , @xmath31 defines a polyhedron . for every 0-ary function symbol @xmath234 with domain @xmath235",
    "let @xmath236 be the set of all borel subsets of @xmath237 and let @xmath238 be the lebesgue measure .",
    "thus , for any @xmath239 @xmath240 gives the length of this line .",
    "then , for the semiring @xmath241 , the @xmath242 operator sums the lengths of lines for each variable , and @xmath243 computes the products of these lengths .",
    "thus , @xmath244 is the volume of @xmath31 .    to see this in action ,",
    "suppose @xmath245 then @xmath246 , that is , all assignments to @xmath206 and @xmath247 such that @xmath248 is a valid expression in arithmetic .",
    "therefore , @xmath249 = { \\left\\ { ( n , m ) \\mid n\\in [ 1,2.5 ] , m \\in [ 0,2 ] , n \\in { { \\mathbb{r } } } , m\\in { { \\mathbb{r}}}\\right\\}}.\\ ] ] assuming @xmath250 is the lebesgue measure for all borel subsets of the domain of @xmath251 we have @xmath252 , n\\in { { \\mathbb{r}}}\\right\\ } } ) = 1.5.\\ ] ] analogously , @xmath253 , m\\in { { \\mathbb{r}}}\\right\\ } } ) = 2 .",
    "$ ] then , the volume is @xmath254 ) =    1.5 \\times 2 = 3 .",
    "$ ]    we demonstrate probabilistic inference in hybrid models @xcite by extending example [ ex polyhedron ] .",
    "consider a probabilistic program : @xmath255 in english : @xmath256 is drawn uniformly from [ 0,1 ] and @xmath257 is the outcome of a coin toss . if @xmath258 and @xmath259 is not 1 , the program terminates successfully .",
    "suppose we are interested in the probability of done , which is expressed as the formula : @xmath260 suppose @xmath65 is the theory of linear real arithmetic , with @xmath261 , @xmath262 and @xmath263 as in example [ ex polyhedron ] , let @xmath264 be the set of all borel subsets of @xmath136 and @xmath265 the lebesgue measure .",
    "let @xmath266 be the set of all subsets of @xmath25 and @xmath267 be the counting measure , _",
    "@xmath268 and @xmath269 .",
    "so @xmath270 and : @xmath271 = { \\left\\ { ( n , m ) \\mid n{>}.6 ,   0\\leq n \\leq 1 , n\\in { { \\mathbb{r } } } , m\\in { \\left\\ { 0,1 \\right\\ } } \\right\\ } } \\cap \\\\",
    "\\quad\\quad\\quad { \\left\\ { ( n , m ) \\mid 0\\leq n\\leq 1 , n\\in { { \\mathbb{r } } } , m\\neq 1 , m\\in { \\left\\ { 0,1 \\right\\ } } \\right\\}}. \\end{array}\\ ] ] this means that @xmath272 \\right\\ } } ) = .4 $ ] and also @xmath273 .",
    "thus , @xmath274 ) = .4\\times 1 .",
    "$ ] analogously , @xmath275 ) = 2 .",
    "$ ] therefore , the probability of done is @xmath276    in general , we have a variant of theorem [ thm math programming ] @xcite :    suppose @xmath170 is any set of real - valued variables .",
    "suppose @xmath277 is any countable set .",
    "suppose @xmath278 , where @xmath279 is any region given by conjunctions of expressions of the form @xmath280 and @xmath281 , where @xmath282 , @xmath283 , @xmath284 and @xmath285 then there is a @xmath177 and @xmath134 such that @xmath178 is the volume of @xmath179",
    "a noteworthy feature of many logic - based knowledge representation formalisms is their compositional nature . in semiring programming , using the expressiveness of predicate logic , it is fairly straightforward to combine theories over possibly different signatures ( _ e.g. , _  propositional logic and linear arithmetic ) , as seen , for example , in smt solvers @xcite .",
    "a more intricate flavor of compositionality is when the new specification becomes difficult ( or impossible ) to define using the original components .",
    "this is a common occurrence in large software repositories , and has received a lot of attention in the ai community @xcite .    in this section ,",
    "we do not attempt to duplicate such efforts , but propose a different account of compositionality that is closer in spirit to semiring programming .",
    "it builds on similar ideas for csps @xcite , and is motivated by machine learning problems where learning ( _ i.e. , _  optimization ) and inference ( _ i.e. , _  model counting ) need to be addressed in tandem .",
    "more generally , the contribution here allows us to combine two semiring programs , possibly involving different semirings . for simplicity of presentation",
    ", we consider non - factorized and finite problems .",
    "suppose @xmath286 and @xmath287 are any two semirings .",
    "we define their _ composition _ @xmath288 as :    * @xmath289 ; * @xmath290 ; * for every @xmath291 and @xmath292 , let @xmath293 .",
    "that is , the composition of the semirings is formed from the cartesian product , respecting the summation operator for the individual structures .",
    "[ defn theory compose ] suppose @xmath294 and @xmath295 are theories , where @xmath296 and @xmath297 do not share atoms , @xmath298 and @xmath299 semirings , and @xmath300 and @xmath301 weight functions for @xmath302 and @xmath303 respectively .",
    "given the environments @xmath304 and @xmath305 , we define its _ composition _ as @xmath306 , where @xmath37 is a composition of @xmath298 and @xmath299 and @xmath65 :    * @xmath134 is obtained over boolean connectives from @xmath307 . * @xmath308 * the meaning of @xmath134 is defined inductively : * * @xmath309 for atom @xmath11 iff @xmath310 if @xmath311 and @xmath312 otherwise ; * * @xmath313 iff @xmath314 ; * * @xmath315 iff @xmath316 for @xmath317 . * for any @xmath318 + @xmath319 .",
    "in essence , the cartesian product for the semirings is extended for arbitrary theories and weight functions .",
    "the meaning of formulas rests on the property that @xmath296 and @xmath297 do not share atoms .",
    "it is now easy to see that the counting for problem for @xmath2 works as usual : that is , for any @xmath134 , @xmath320    we demonstrate a ( simple ) instance of combined learning and inference .",
    "imagine a robot navigating a world by performing",
    "_ move _ actions , and believes its actuators need repairs .",
    "but before it alerts the technician , it would like to test this belief . a reasonable test , then",
    ", is to inspect its trajectory so far , and check whether the expected outcome of a move action in the current state matches the behavior of the very first move action .",
    "more precisely , the robot needs to appeal to linear regression to estimate its expected outcome , and query its beliefs based on the regression model .",
    "we proceed as follows .",
    "let @xmath321 be the theory of real arithmetic with @xmath322 .",
    "suppose that by performing a _ move _ action , the robot s position changes from @xmath323 to @xmath324 let @xmath325 be as follows : @xmath326 the idea is that the values of @xmath323 are the explanatory variables in the regression model and @xmath327 are the response variables , that is , the trajectory data is of the form @xmath328 .    consider a weight function @xmath329 that is , the weight of a model @xmath12 is the universe element corresponding to the constant @xmath330 in @xmath12 , analogous to figure [ fig : logic mathemtical programming ] .",
    "( for simplicity , we assume that the coefficients of the regression model are natural numbers . ) for the semiring @xmath331 : @xmath332 in other words , models in @xmath302 interpret @xmath323 as given by the data , and models differ in their interpretation of @xmath333 and thus , @xmath334 for the data in @xmath335 we would have a model @xmath12 where @xmath336 , @xmath337 and @xmath338 , and so @xmath339      let @xmath340 be a propositional theory , where @xmath341 imagine a weight function @xmath301 as follows : @xmath342 and @xmath343 that is , the robot believes that repairs are needed with a higher probability . indeed , for the semiring @xmath344 : @xmath345",
    "let @xmath306 be the composition of the two environments with @xmath65 and @xmath288 .",
    "suppose @xmath346 is as follows : @xmath347 the final conjunct basically checks whether the expected change in position matches what was happening initially , and if not , _ repair _ should be true .    to see definition [ defn theory compose ] in action , observe that for any @xmath348 @xmath349 , the formulas @xmath350 and those involving @xmath323 are interpreted in @xmath351 but _ repair _ in @xmath352 the weight function is as follows .",
    "given @xmath349 and @xmath353 , we have : @xmath354 then the robot can obtain the weight of _ repair _ and @xmath31 using : @xmath355 where , of course , the first argument is the error of the regression model and the second is 0 because @xmath356 is inconsistent .",
    "that can be contrasted to the count below : @xmath357 it is also easy to see that @xmath358    as in wmc @xcite , suppose the robot obtains the probability of a query @xmath359 given @xmath31 using : @xmath360 where the division is carried out by ignoring the regression error .",
    "then the probability of @xmath361 given @xmath31 is 1 .",
    "thus , no repairs are needed .",
    "the upshot of semiring programming is that it encourages us to inspect strategies for a unified inferential mechanism @xcite .",
    "this has to be done carefully , as we would like to build on scalable methodologies in the literature , by restricting logical theories where necessary . in this section",
    ", we discuss whether our programming model can be made to work well in practice .",
    "let us consider two extremes :    * * option 1 : * at one extreme is a solver strategy based on a single computational technique .",
    "probabilistic programming languages , such as church @xcite , have made significant progress in that respect for generative stochastic processes by appealing to markov chain monte carlo sampling techniques .",
    "unfortunately , such sampling techniques do not scale well on large problems and have little support for linear and logical constraints . *",
    "* option 2 : * at the other extreme is a solver strategy that is arbitrarily heterogeneous , where we develop unique solvers for specific environments , that is , @xmath362 pairs .",
    "we believe the most interesting option is in between these two extremes . in other words , to identify the smallest set of computational techniques , and effectively integrate them is both challenging and insightful .",
    "this may mean that such a strategy is less optimal than option 2 for the environment , but we would obtain a simpler and more compact execution model . to that end , let us make the following observations from our inventory of examples :    * * finite versus infinite : * variable assignments are taken from finite sets versus infinite or uncountable sets . * * non - factorized versus factorized : * the former is usually an optimization problem with an objective function that is to be maximized or minimized .",
    "the latter is usually a counting problem , where we would need to identify one or all solutions .",
    "* * compositionality : * locally consistent solutions ( _ i.e. , _  in each environment @xmath363 ) need to be tested iteratively for global consistency .",
    "thus , option 3 would be realized as follows :    * factorized problems need a methodology for effective enumeration , and therefore , advances in model counting  @xcite , such as knowledge compilation , are the most relevant . for finite theories ,",
    "we take our cue from the problog family of languages @xcite , that have effectively applied arithmetic circuits for tasks such as wmc and mpe .",
    "in particular , it is shown in @xcite how arbitrary semiring labels can be propagated in the circuit .",
    "see @xcite for progress on knowledge compilation in csp - like environments .",
    "+ for infinite theories , there is growing interest in effective model counting for linear arithmetic using smt technology @xcite . like in @xcite , however , we would need to extend these counting approaches to arbitrary semirings . * for non - factorized problems , a natural candidate for handling semirings",
    "does not immediately present itself , making this is a worthwhile research direction . appealing to off - the - shelf optimization software @xcite is always an option , but they embody diverse techniques and the absence of a simple high - level solver strategy makes adapting them for our purposes less obvious . in that regard , solvers for _ optimization modulo theories _ ( omt ) @xcite are perhaps the most promising .",
    "omt technology extends smt technology in additionally including a cost function that is be maximized ( minimized ) . in terms of expressiveness ,",
    "csps @xcite and certain classes of mathematical programs can be expressed , even in the presence of logical connectives . in terms of a solver strategy ,",
    "they use binary search in tandem with lower and upper bounds to find the maximum ( minimum ) .",
    "this is not unlike dpll traces in knowledge compilation , which makes that technology the most accessible for propagating arbitrary semiring labels .",
    "* compositional settings are , of course , more intricate . along with omt , and classical iterative methods like _ expectation maximization _ @xcite",
    ", there are a number of recent approaches employing branch - and - bound search strategies to navigate between local and global consistency @xcite . which of these can be made amenable to compositions of sp programs remains to be seen however .",
    "overall , we believe the most promising first step is to limit the vocabulary of the logical language to propositions and constants ( _ i.e. , _",
    "0-ary functions ) , which make appealing to knowledge compilation and omt technology straightforward .",
    "it will also help us better characterize the complexity of the problems that sp attempts to solve . at first glance",
    ", sp is seen to naturally capture # p - complete problems in the factorized setting , both in the finite case @xcite and the infinite one  @xcite . in the non - factorized",
    "setting , many results from omt and mathematical programming are inherited depending on the nature of the objective function and the domains of the program variables @xcite . by restricting the language",
    "as suggested , the applicability of these results can be explored more thoroughly .",
    "semiring programming is related to efforts from different disciplines within ai , and we discuss representative camps .      formal languages for generative stochastic processes , such as church @xcite and blog @xcite , have received a lot of attention in the learning community .",
    "such languages provide mechanisms to compactly specify complex probability distributions , and appeal to sampling for inference .    closely related to such proposals",
    "are probabilistic logic programming languages such as problog @xcite that extends prolog with probabilistic choices and uses wmc for inference @xcite .",
    "in particular , a semiring generalization of problog , called aproblog @xcite , was the starting point for our work and employs a semiring variation of wmc for inference @xcite , but none addresses matrix factorization , convex optimization and compositionality .",
    "the use of semirings in machine learning is not new to aproblog , see _",
    "@xcite , and programming languages such as dyna @xcite .",
    "dyna is based on datalog ; our logical setting is strictly more expressive than datalog and its extensions ( _ e.g. , _  non - horn fragment , constraints over reals ) .",
    "dyna also labels proofs but not interpretations , as would sp ( thus capturing weighted model counting , for example ) .",
    "the constraints literature boasts a variety of modeling languages , such as essence @xcite , among others @xcite .",
    "( see @xcite , for example , for a proposal on combining heterogeneous solvers . ) on the one hand , sp is more expressive from a logical viewpoint as constraints can be described using arbitrary formulas from predicate logic , and we address many problems beyond constraints , such as probabilistic reasoning . on the other hand ,",
    "such constraint languages make it easier for non - experts to specify problems while sp , in its current form , assumes a background in logic .",
    "such languages , then , would be of interest for extending sp s modeling features .",
    "a notable line of csp research is by @xcite and his colleagues @xcite . here",
    ", semirings are used for diverse csp specifications , which has also been realized in a clp framework @xcite . in particular",
    ", our account of compositionality is influenced by @xcite . under some representational assumptions , sp and such accounts",
    "are related , but as noted , sp can formulate problems such as probabilistic inference in hybrid domains that does not have an obvious analogue in these accounts .",
    "closely related to the constraints literature are the techniques embodied in mathematical programming more generally .",
    "there are three major traditions in this literature that are related to sp .",
    "modeling languages such as ampl @xcite are fairly close to constraint modeling languages , and even allow parametrized constraints , which are ground at the time of search .",
    "the field of disciplined programming @xcite supports features such as object - oriented constraints .",
    "finally , relational mathematical programming @xcite attempts to exploit symmetries in parametrized constraints .    from a solver construction perspective , these languages present interesting possibilities . from a framework point of view , however , there is little support for logical reasoning in a general way .",
    "declarative problem solving is a focus of many proposals , including asp @xcite , model expansion @xcite , among others @xcite .",
    "these proposals are ( mostly ) for problems in np , and so do not capture # p - hard problems like model counting and wmc . indeed , the most glaring difference is the absence of weight functions over possible worlds , which is central to the formulation of statistical models .",
    "weighted extensions of these formalisms , _",
    "@xcite , are thus closer in spirit .",
    "the generality of sp also allows us to instantiate many such proposals , including formalisms using linear arithmetic fragments @xcite .",
    "consider omt for example .",
    "omt can be used to express quantifier - free linear arithmetic sentences with a linear cost function , and a first - order structure that minimizes the cost function is sought . from a specification point of view , sp does not limit the logical language , does not require that objective functions be linear , and a variety of model comparisons , including counting , are possible via semirings .",
    "compositionality in sp , moreover , goes quite beyond this technology .",
    "finally , there is a longstanding interest in combining different ( logical ) environments in a single logical framework , as seen , for example , in modular and multi - context systems @xcite . in such frameworks",
    ", it would be possible to get a ilp program and asp program to communicate their solutions , often by sharing atoms .",
    "in our view , section [ sec : combining_theories ] and these frameworks emphasize different aspects of compositionality .",
    "the sp scheme assumes the modeler will formalize a convex optimization problem and a sat problem in the same programming language since they presumably arise in a single application ( _ e.g. , _  a task and motion planner ) ; this allows model reuse and enables transparency .",
    "in contrast , modular systems essentially treat diverse environments as black - boxes , which is perhaps easier to realize . on the one hand",
    ", it would be interesting to see whether modular systems can address problems such as combined inference and learning .",
    "on the other , some applications may require that different environments share atoms , for which our account on compositionality could be extended by borrowing ideas from modular systems .",
    "in a nutshell , sp is a framework to declaratively specify three major concerns in ai applications :      to its strengths , we find that sp is _ universal _ ( in the above sense ) and _ generic _ ( in terms of allowing instantiations to particular logical languages and semirings ) .",
    "thus , we believe sp represents a simple , uniform , modular and transparent approach to the model building process of complex ai applications .",
    "sp comes with a rigorous semantics to give meaning to its programs . in that sense",
    ", we imagine future developments of sp would follow constraint programming languages and probabilistic programming languages in providing more intricate modeling features which , in the end , resort to the proposed semantics in the paper .",
    "perhaps the most significant aspect of sp is that it also allows us to go beyond existing paradigms as the richness of the framework admits novel formulations that combine theories from these different fields , as illustrated by means of a combined regression and probabilistic inference example . in the long term , we hope sp will contribute to the bridge between learning and reasoning ."
  ],
  "abstract_text": [
    "<S> to solve hard problems , ai relies on a variety of disciplines such as logic , probabilistic reasoning , machine learning and mathematical programming . </S>",
    "<S> although it is widely accepted that solving real - world problems requires an integration amongst these , contemporary representation methodologies offer little support for this .    in an attempt to alleviate this situation </S>",
    "<S> , we introduce a new declarative programming framework that provides abstractions of well - known problems such as sat , bayesian inference , generative models , and convex optimization . </S>",
    "<S> the semantics of programs is defined in terms of first - order structures with semiring labels , which allows us to freely combine and integrate problems from different ai disciplines . </S>"
  ]
}