{
  "article_text": [
    "the field of _ computational learning theory _ deals with the abilities and limitations of algorithms that learn functions from data .",
    "many models of how learning algorithms access data have been considered in the literature . among these ,",
    "two of the most prominent are via _ membership queries _ and via _",
    "random examples_. membership queries are `` black - box '' queries ; in a membership query , a learning algorithm submits an input @xmath9 to an oracle and receives the value of @xmath10 . in models of learning from random examples , each time the learning algorithm queries the oracle it receives a labeled example @xmath11 where @xmath9 is independently drawn from some fixed probability distribution over the space of all possible examples .",
    "( we give precise definitions of these , and all the learning models we consider , in section  [ sec : jprelim ] . )    in recent years a number of researchers have considered quantum variants of well - studied models in computational learning theory , see e.g. @xcite . as we describe in section  [",
    "sec : jprelim ] , models of learning from quantum membership queries and from fixed quantum superpositions of labeled examples ( we refer to these as _ quantum examples _ ) have been considered ; such oracles have been studied in the context of _ quantum property testing _ as well @xcite .",
    "one common theme in the existing literature on quantum computational learning and testing is that these works study algorithms whose only access to the function is via some form of quantum oracle such as the quantum membership oracle or quantum example oracles mentioned above . for instance",
    ", @xcite modifies the classical harmonic sieve algorithm of @xcite so that it uses only uniform quantum examples to learn @xmath12 formulas .",
    "@xcite considers the problem of quantum property testing using quantum membership queries to give an exponential separation between classical and quantum testers for certain concept classes .",
    "@xcite studies the information - theoretic requirements of exact learning using quantum membership queries and probably approximately correct ( pac ) learning using quantum examples .",
    "many other articles such as @xcite could further extend this list .    as the problem of building large scale quantum computers remains a major challenge ,",
    "it is natural to question the technical feasibility of large scale implementation of the quantum oracles considered in the literature .",
    "it is desirable to minimize the number of quantum ( as opposed to classical ) oracle queries or examples required by quantum algorithms .",
    "thus motivated , in this paper we are interested in designing testing and learning algorithms with access to both quantum and classical sources of information ( with the goal of minimizing the quantum resources required ) .",
    "all of our positive results are based on a quantum subroutine due to @xcite , which we will refer to as an @xmath2 ( fourier sample ) oracle call .",
    "as explained in section  [ sec : jprelim ] , a call to the @xmath2 oracle yields a subset of @xmath13 ( this set should be viewed as a subset of the input variables @xmath14 of @xmath3 ) drawn according to the fourier spectrum of the boolean function @xmath3 . as demonstrated by @xcite , such an oracle",
    "can be implemented using @xmath15 uniform quantum examples from a uniform distribution quantum example oracle .",
    "in fact , all of our algorithms will be purely classical apart from their use of the @xmath2 oracle .",
    "thus , all of our algorithms can be implemented within the ( uniform distribution ) quantum pac model first proposed by @xcite .",
    "this model is a natural quantum extension of the classical pac model introduced by valiant @xcite , as described in section  [ sec : jprelim ] .",
    "we emphasize that no membership queries , classical or quantum , are used in our algorithms , only uniform quantum superpositions of labeled examples , and we recall that such uniform quantum examples can not efficiently simulate even classical membership queries in general ( see @xcite ) .",
    "our approach of focusing only on the @xmath2 oracle allows us to abstract away from the intricacies of quantum computation , and renders our results useful in any setting in which an @xmath2 oracle can be provided to the user .",
    "in fact , learning and testing with @xmath2 oracle queries may be regarded as a new distinct model ( which may possibly be weaker than the uniform distribution quantum example model ) .",
    "we are primarily interested in the information theoretic requirements ( i.e. the number of oracle calls needed ) of the learning and testing problems that we discuss .",
    "we give upper and lower bounds for a range of learning and testing problems related to _",
    "@xmath0-juntas _ ; these are boolean functions @xmath16 that depend only on ( an unknown subset of ) at most @xmath0 of the @xmath1 input variables @xmath14 .",
    "juntas have been the subject of intensive research in learning theory and property testing in recent years , see e.g.  @xcite .",
    "our first result , in section  [ sec : testjuntas ] , is a @xmath0-junta testing algorithm which uses @xmath17 @xmath2 oracle calls .",
    "our algorithm uses fewer queries than the best known classical junta testing algorithm due to fischer _",
    "@xcite , which uses @xmath18 membership queries . however , since the best lower bound known for classical membership query based junta testing ( due to chockler and gutfreund @xcite ) is @xmath19 , our result does not rule out the possibility that there might exist a classical membership query algorithm with the same query complexity .    to complement our @xmath2 based testing algorithm , we establish a new lower bound : any @xmath0-junta testing algorithm that uses only a @xmath2 oracle requires @xmath6 calls to the @xmath2 oracle",
    "this shows that our testing algorithm is not too far from optimal .",
    "finally , we consider algorithms that can both make @xmath2 queries and also access classical random examples . in section  [ sec : learnjuntas ] we give an algorithm for learning @xmath0-juntas over @xmath20 that uses @xmath7 @xmath2 queries and @xmath21 random examples . since any classical learning algorithm requires @xmath22 examples ( even if it is allowed to use membership queries )",
    ", this result illustrates that it is possible to reduce the classical query complexity substantially ( in particular , to eliminate the dependence on @xmath1 ) if the learning algorithm is also permitted to have some very limited quantum information .",
    "moreover most of the consumption of our algorithm is from classical random examples which are considered quite `` cheap '' relative to quantum examples . from another perspective",
    ", our result shows that for learning @xmath0-juntas , almost all the quantum examples used by the algorithm of bshouty and jackson @xcite can in fact be converted into ordinary classical random examples .",
    "we show that our algorithm is close to best possible by giving a nearly matching lower bound .      in section  [ sec : jprelim ]",
    "we describe the models and problems we will consider and present some useful preliminaries from fourier analysis and probability .",
    "section  [ sec : testjuntas ] gives our results on testing juntas and section  [ sec : learnjuntas ] gives our results on learning juntas .",
    "in keeping with standard terminology in learning theory , a _ concept _ @xmath3 over @xmath23 is a boolean function @xmath24 , where @xmath25 stands for true and @xmath26 stands for false .",
    "concept class _ @xmath27 is a set of concepts where @xmath28 consists of those concepts in @xmath29 whose domain is @xmath30 for ease of notation throughout the paper we will omit the subscript in @xmath28 and simply write @xmath31 to denote a collection of concepts over @xmath20 .",
    "the concept class we will chiefly be interested in is the class of _ @xmath0-juntas_.",
    "a boolean function @xmath32 is a @xmath0-junta if @xmath3 depends only on @xmath0 out of its @xmath1 input variables .",
    "we are interested in the following computational problems :    pac learning under the uniform distribution : : :    given any _",
    "target concept _ @xmath33 , an    _ @xmath34-learning algorithm for concept class    @xmath31 _ under the uniform distribution outputs a _ hypothesis _",
    "function @xmath35 which ,    with probability at least @xmath36 , agrees with    @xmath37 on at least a @xmath38 fraction of the    inputs in @xmath30 this is a widely studied    framework in the learning theory literature both in classical ( see for    instance @xcite ) and in quantum ( see @xcite ) versions .",
    "property testing : : :    let @xmath3 be any boolean function @xmath39 .",
    "a _ property testing    algorithm for concept class @xmath31 _ is an algorithm which ,    given access to @xmath3 , behaves as follows :    +    * if @xmath33 then the algorithm outputs accept with    probability at least @xmath36 ;    * if @xmath3 is _ @xmath34-far _ from any concept    in @xmath31 ( i.e. for every concept @xmath40 ,    @xmath3 and @xmath41 differ on at least an    @xmath34 fraction of all inputs ) , then the algorithm    outputs reject with probability at least @xmath36 .",
    "+    the notion of property testing was first developed by @xcite and    @xcite .",
    "quantum property testing was first studied by buhrman _",
    "et    al . _",
    "@xcite , who first gave an example of an exponential separation    between the query complexity of classical and quantum testers for a    particular concept class .    note that a learning or testing algorithm for @xmath31 `` knows '' the class @xmath31 but does not know the identity of the concept @xmath3 .",
    "while our primary concern is the number of oracle calls that our algorithms use , we are also interested in _ time efficient _ algorithms for testing and learning ; for the concept class of @xmath0-juntas , these are algorithms running in poly@xmath42 time steps .      in order for learning and testing algorithms to gather information about the unknown concept @xmath3",
    ", they need an information source called an _",
    "oracle_. the number of times an oracle is queried by an algorithm is referred to as the _ query complexity_. sometimes our algorithms will be allowed access to more than one type of oracle in our discussion .    in this paper we will consider the following types of oracles that provide classical information :    membership oracle @xmath43 : : :    for @xmath3 a boolean function , a _ membership oracle _",
    "@xmath44 is an oracle which , when queried with    input @xmath9 , outputs the label @xmath10 assigned    by @xmath3 to @xmath45 uniform random example oracle @xmath46 : : :    a query @xmath47 of the random example oracle    returns an ordered pair @xmath48 where @xmath9    is drawn uniformly random from the set @xmath49 of all    possible inputs .",
    "clearly a single call to an @xmath43 oracle can simulate the random example oracle @xmath46 .",
    "indeed @xmath46 oracle queries are considered `` cheap '' compared to membership queries .",
    "for example , in many settings it is possible to obtain random labeled examples but impossible to obtained the label of a particular desired example ( consider prediction problems dealing with phenomena such as weather or financial markets ) .",
    "we note that the set of concept classes that are known to be efficiently pac learnable from uniform random examples only is rather limited , see e.g. @xcite .",
    "in contrast , there are known efficient algorithms that use membership queries to learning important function classes such as @xmath12 ( disjunctive normal form ) formulas @xcite .",
    "we will consider the following quantum oracles , which are the natural quantum generalizations of membership queries and uniform random examples respectively .",
    "quantum membership oracle @xmath50 : : :    the quantum membership oracle @xmath51 is the    quantum oracle whose query acts on the computational basis states as    follows :    @xmath52 uniform quantum examples @xmath53 : : :    the uniform quantum example oracle @xmath54 is    the quantum oracle whose query acts on the computational basis state    @xmath55 as follows :    @xmath56 the action of a    @xmath54 query is undefined on other basis    states , and an algorithm may only invoke the    @xmath54 query on the basis state    @xmath57 .",
    "it is clear that a @xmath50 oracle can simulate a @xmath53 oracle or an @xmath43 oracle , and a @xmath53 oracle can simulate an @xmath46 oracle .",
    "the model of pac learning with a uniform quantum example oracle was introduced by bshouty and jackson in @xcite .",
    "several researchers have also studied learning from a more powerful @xmath51 oracle , see e.g.  @xcite . turning to property testing ,",
    "we are not aware of prior work on quantum testing using only the @xmath54 oracle ; instead researchers have considered quantum testing algorithms that use the more powerful @xmath51 oracle , see e.g.  @xcite .",
    "we will make use of the fourier expansion of real valued functions over @xmath23 .",
    "we write @xmath58 $ ] to denote the set of variables @xmath59 .",
    "consider the set of real valued functions over @xmath23 endowed with the inner product @xmath60 = { \\frac 1 { 2^n } } \\sum_x f(x ) g(x)\\ ] ] and induced norm @xmath61 .",
    "for each @xmath62 $ ] , let @xmath63 be the parity function @xmath64 it is a well known fact that the @xmath65 functions @xmath66\\}$ ] form an orthonormal basis for the vector space of real valued functions over @xmath23 with the above inner product .",
    "consequently , every @xmath67 can be expressed uniquely as : @xmath68 }   { \\hat{f}(s)}\\chi_s(x)\\ ] ] which we refer to as the _ fourier expansion _ or _ fourier transform _ of @xmath3 .",
    "alternatively , the values @xmath69 \\ } $ ] are called the _ fourier coefficients _ or the _ fourier spectrum _ of @xmath3 .",
    "_ parseval s identity _ , which is an easy consequence of orthonormality of the basis functions , relates the values of the coefficients to the values of the function :    [ bparseval ] for any @xmath67 , we have @xmath70 } |{\\hat{f}(s)}|^2= { { \\bf e}}[f^2]$ ] .",
    "thus for a boolean valued function @xmath70 } |{\\hat{f}(s)}|^2=1 $ ] .",
    "we will use the following simple and well - known fact :    [ kmfact ] for any @xmath32 and any @xmath71 , we have @xmath72\\leq{{\\bf e}}_{x}[{(f(x)-g(x))}^{2}]=\\sum_{s\\subseteq[n]}|{\\hat{f}(s)}-\\hat{g}(s)|^{2}\\ ] ]    recall that the _ influence _ of a variable @xmath73 on a boolean function @xmath3 is the probability ( taken over a uniform random input @xmath9 for @xmath3 ) that @xmath3 changes its value when the @xmath74-th bit of @xmath9 is flipped , i.e. @xmath75.\\ ] ] it is well known ( see e.g. @xcite ) that @xmath76      [ dpi]let @xmath77 be two random variables over the same domain .",
    "for any ( possibly randomized ) algorithm @xmath78 , one has that @xmath79    let @xmath80 be random variables corresponding to sequences of draws taken from two different distributions over the same domain . by the above inequality ,",
    "if @xmath81 is known to be small , then the probability of success must be small for any algorithm designed to distinguish if the draws are made according to @xmath82 or @xmath83",
    ".    we will also use standard chernoff bounds on tails of sums of independent random variables :    let @xmath84 be i.i.d .",
    "random variables with mean @xmath85 taking values in the range @xmath86 $ ] .",
    "then for all @xmath87 we have @xmath88\\leq 2 \\exp(\\frac{-2\\lambda^2 m}{(b - a)^2})$ ] .",
    "let @xmath89 be a boolean function .",
    "the _ fourier sampling oracle _",
    "@xmath90 is the classical oracle which , at each invocation , returns each subset of variables @xmath91 with probability @xmath92 , where @xmath93 denotes the fourier coefficient corresponding to @xmath94 as defined in section  [ sec : bfour ]",
    ".    this oracle will play an important role in our algorithms .",
    "note that by parseval s identity we have @xmath95 }    @xmath96 indeed has total weight 1 .    in @xcite",
    "bshouty and jackson describe a simple constant - size quantum network ` qsamp ` , which has its roots in an idea from @xcite . ` qsamp ` allows sampling from the fourier spectrum of a boolean function using @xmath15 @xmath53 oracle queries :    [ bjfact ] for any boolean function @xmath3 , it is possible to simulate a draw from the @xmath90 oracle with probability @xmath97 using @xmath98 queries to @xmath54 .",
    "all the algorithms we describe are actually classical algorithms that make @xmath2 queries .",
    "fischer _ et al . _",
    "@xcite studied the problem of testing juntas given black - box access ( i.e. , classical membership query access ) to the unknown function @xmath3 using harmonic analysis and probabilistic methods .",
    "they gave several different algorithms with query complexity independent of @xmath1 , the most efficient of which yields the following :    [ s1thm1]there is an algorithm that tests whether an unknown @xmath89 is a @xmath0-junta using @xmath18 membership queries .",
    "fischer _ et al .",
    "_ also gave a lower bound on the number of queries required for testing juntas , which was subsequently improved by chockler _",
    "_ to the following :    [ s1thm2 ] any algorithm that tests whether @xmath3 is a @xmath0-junta or is @xmath99-far from every @xmath0-junta must use @xmath19 membership queries .",
    "we emphasize that that both of these results concern algorithms with classical membership query access .      in this section",
    "we describe a new testing algorithm that uses the @xmath2 oracle and prove the following theorem about its performance :    [ s1qthm1]there is an algorithm that tests the property of being a @xmath0-junta using @xmath5 calls to the @xmath2 oracle .    as described in section  [ sec : jprelim ] , the algorithm can thus be implemented using @xmath100 uniform quantum examples from @xmath54 .",
    "consider the following algorithm @xmath101 which has @xmath2 oracle access to an unknown function @xmath32 .",
    "algorithm @xmath101 first makes @xmath102 calls to the @xmath2 oracle ; let @xmath103 denote the union of all the sets of variables received as responses to these oracle calls .",
    "algorithm @xmath101 then outputs `` accept '' if @xmath104 and outputs `` reject '' if @xmath105 .",
    "it is clear that if @xmath3 is a @xmath0-junta then @xmath101 outputs `` accept '' with probability 1 . to prove correctness of the test it suffices to show that if @xmath3 is @xmath4-far from any @xmath0-junta then @xmath106 outputs `` reject''@xmath107 \\geq { \\frac 2 3}.$ ]    the argument is similar to the standard analysis of the coupon collector s problem",
    "let us view the set @xmath103 as growing incrementally step by step as successive calls to the @xmath2 oracle are performed .",
    "let @xmath108 be a random variable which denotes the number of @xmath2 queries that take place starting immediately after the @xmath109-st new variable is added to @xmath103 , up through the draw when the @xmath74-th new variable is added to @xmath103 . if the @xmath109-st and @xmath74-th new variables are obtained in the same draw then @xmath110 .",
    "( for example , if the first three queries to the @xmath2 oracle are @xmath111 @xmath112 , @xmath113 , then we would have @xmath114 , @xmath115 , @xmath116 , @xmath117 , @xmath118 . )    since @xmath3 is @xmath4-far from any @xmath0-junta , we know that for any set @xmath119 of @xmath120 variables , it must be the case that @xmath121 ( since otherwise if we set @xmath122 and use fact  [ kmfact ] , we would have @xmath123\\leq{{\\bf e}}_{x}[{(f(x)-g(x))}^{2 } ] = \\sum_{s \\not\\subseteq \\mathcal{t } } \\hat{f}(s)^2 < \\epsilon\\ ] ] which contradicts the fact that @xmath3 is @xmath4-far from any @xmath0-junta ) .",
    "it follows that for each @xmath124 , if at the current stage of the construction of @xmath103 we have @xmath125 , then the probability that the next @xmath2 query yields a new variable outside of @xmath103 is at least @xmath4 .",
    "consequently we have @xmath126 \\leq { \\frac 1 { \\epsilon}}$ ] for each @xmath127 , and hence @xmath128 \\leq { \\frac { ( k+1 ) } { \\epsilon}}.\\ ] ] by markov s inequality , the probability that @xmath129 is at least @xmath130 , and therefore with probability at least @xmath130 it will be the case after @xmath102 draws that @xmath105 and the algorithm will consequently output `` reject . ''",
    "note that the @xmath100 uniform quantum examples required for algorithm @xmath101 improves on the @xmath131 query complexity of the best known classical algorithm .",
    "however our result does not conclusively show that @xmath53 queries are more powerful than classical membership queries for this problem since it is conceivable that there could exist an as yet undiscovered @xmath100 classical membership query algorithm .        as a first attempt to obtain a lower bound on the number of @xmath2 oracle calls required to test @xmath0-juntas",
    ", it is natural to consider the approach of chockler _ et al . _ from @xcite . to prove theorem  [ s1thm2 ] , chockler _ et al . _",
    "show that any classical algorithm which can successfully distinguish between the following two probability distributions over black - box functions must use @xmath19 queries :    * * scenario i : * the distribution @xmath132 is uniform over the set of all boolean functions over @xmath1 variables which do not depend on variables @xmath133 * * scenario ii : * the distribution @xmath134 is defined as follows : to draw a function @xmath3 from this distribution , first an index @xmath74 is chosen uniformly from @xmath135 , and then @xmath3 is chosen uniformly from among those functions that do not depend on variables @xmath136 or on variable @xmath74 .",
    "the following observation shows that this approach will not yield a strong lower bound for algorithms that have access to a @xmath2 oracle :    with @xmath137 queries to a @xmath2 oracle , it is possible to determine w.h.p . whether a function @xmath3 is drawn from scenario i or scenario ii .",
    "it is easy to see that a function drawn from scenario i is simply a random function on the first @xmath138 variables .",
    "the fourier spectrum of random boolean functions is studied in @xcite , where it is shown that sums of squares of fourier coefficients of random boolean functions are tightly concentrated around their expected value . in particular , proposition  6 of @xcite directly implies that for any fixed variable @xmath139 we have : @xmath140 < \\exp(-2^{k+1}/2592).\\ ] ] thus with overwhelmingly high probability , if @xmath3 is drawn from scenario i then each @xmath2 query will `` expose '' variable @xmath74 with probability at least @xmath99 .",
    "it follows that after @xmath137 queries all @xmath138 variables will have been exposed ; so by making @xmath137 @xmath2 queries and simply checking whether or not @xmath138 variables have been exposed , one can determine w.h.p .",
    "whether @xmath3 is drawn from scenario i or scenario ii .    thus we must adopt a more sophisticated approach to prove a strong lower bound on @xmath2 oracle algorithms .",
    "our main result in this section is the following theorem :    [ s1qthm2 ] any algorithm that has @xmath2 oracle access to an unknown @xmath3 must use @xmath6 oracle calls to test whether @xmath3 is a @xmath0-junta .",
    "let @xmath0 be such that @xmath141 for some positive integer @xmath142 we let @xmath143 denote @xmath144 the _ addressing function _ on @xmath145 variables has @xmath146 `` addressing variables , '' which we shall denote @xmath147 and @xmath148 `` addressee variables '' which we denote @xmath149 the output of the function is the value of variable @xmath150 where the `` address '' @xmath151 is the element of @xmath152 whose binary representation is given by @xmath153 .",
    "figure  1 depicts a decision tree that computes the addressing function in the case @xmath154 .",
    "formally , the addressing function @xmath155 is defined as follows : @xmath156    [ fig : tree ] [ @xmath157[@xmath158 [ @xmath159 [ @xmath160 [ @xmath161 ] [ @xmath159 [ @xmath162 [ @xmath163 ] ] [ @xmath158 [ @xmath159 [ @xmath164 [ @xmath165 ] [ @xmath159 [ @xmath166 ] [ @xmath167 ] ] ]    intuitively , the addressing function will be useful for us because as we will see the fourier spectrum is `` spread out '' over the @xmath143 addressee variables ; this will make it difficult to distinguish the addressing function ( which is not a @xmath0-junta since @xmath168 and as we shall see is in fact far from every @xmath0-junta ) from a variant which is a @xmath0-junta .",
    "let @xmath169 be the @xmath1 variables that our boolean functions are defined over .",
    "we now define two distributions @xmath170 , @xmath171 over functions on these variables .    the distribution @xmath170 is defined as follows : to make a draw from @xmath170 ,    1 .",
    "first uniformly choose a subset @xmath172 of @xmath143 variables from @xmath173 ; 2 .",
    "next , replace the variables @xmath174 in the function @xmath175 with the variables in @xmath172 ( choosing the variables from @xmath172 in a uniformly random order ) .",
    "return the resulting function .    note that step ( 2 ) in the description of making a draw from @xmath170 above corresponds to placing the variables in @xmath172 uniformly at the leaves of the decision tree for @xmath176 ( see figure  1 ) .",
    "equivalently , if we write @xmath177 to denote the following function _ over @xmath1 variables _ @xmath178 a draw from @xmath170 is a function chosen uniformly at random from the set @xmath179 where @xmath180 ranges over all permutations of @xmath181    it is clear that every function in @xmath182 ( the support of @xmath170 ) depends on @xmath145 variables and thus is not a @xmath0-junta .",
    "in fact , every function in @xmath182 is far from being a @xmath0-junta :    every @xmath3 that has nonzero probability under @xmath170 is @xmath183-far from any @xmath0-junta .",
    "fix any such @xmath3 and let @xmath41 be any @xmath0-junta .",
    "it is clear that at least @xmath184 of the `` addressee '' variables of @xmath3 are not relevant variables for @xmath41 . for a @xmath185 fraction of all inputs to @xmath3 ,",
    "the value of @xmath3 is determined by one of these addressee variables ; on such inputs the error rate of @xmath41 relative to @xmath3 will be precisely @xmath186    fix any function @xmath177 in @xmath182 .",
    "we now give an expression for the fourier representation of @xmath177 .",
    "the expression is obtained by viewing @xmath177 as a sum of @xmath143 subfunctions , one for each leaf of the decision tree , where each subfunction takes the appropriate nonzero value on inputs which reach the corresponding leaf and takes value 0 on all other inputs : @xmath187 @xmath188 note that whenever @xmath189 , the sum on the rhs of equation   has precisely one non - zero term which is @xmath190 .",
    "this is because the rest of the terms are annihilated since in each of these terms there is some index @xmath191 such that @xmath192 which makes @xmath193 .",
    "consequently this sum gives rise to exactly the addressing function in equation   which is defined as @xmath194 and consequently the equality in equation   follows .",
    "equation   follows easily from rearranging  .",
    "now we turn to @xmath195    the distribution @xmath171 is defined as follows : to make a draw from @xmath171 ,    1 .",
    "first uniformly choose a subset @xmath172 of @xmath196 variables from @xmath173 ; 2 .",
    "next , replace the variables @xmath197 in the function @xmath175 with the variables in @xmath172 ( choosing the variables from @xmath172 in a uniformly random order ) .",
    "3 .   finally ,",
    "for each @xmath198 do the following : if variable @xmath199 was used to replace variable @xmath200 in the previous step , let @xmath201 be a fresh uniform random @xmath202 value and replace variable @xmath203 with @xmath204 .",
    "return the resulting function .",
    "observe that for any integer @xmath205 with binary expansion @xmath206 , we have that the binary expansion of @xmath207 is @xmath208 . thus steps ( 2 ) and ( 3 ) in the description of making a draw from @xmath171 may be restated as follows in terms of the decision tree representation for @xmath176 :    * place the variables @xmath209 randomly among the leaves of the decision tree with index less than @xmath196 . * for each variable @xmath209 placed at the leaf with index @xmath210 above , throw a @xmath202 valued coin @xmath201 and place @xmath211 at the antipodal leaf location with index : @xmath212 .",
    "equivalently , if we write @xmath213 to denote the following function _ over @xmath1 variables _ @xmath214 a draw from @xmath171 is a function chosen uniformly at random from the set @xmath215 where @xmath180 ranges over all permutations of @xmath216 and @xmath217 ranges over all of @xmath218 .",
    "it is clear that every function in @xmath219 depends on at most @xmath220 variables , and thus is indeed a @xmath0-junta .    by considering the contribution to the fourier spectrum from each pair of leaves @xmath221 of the decision tree",
    ", we obtain the following expression for the fourier expansion of each function in the support of @xmath171 : @xmath222 @xmath223}\\quad = \\frac{1}{2^{r-1}}\\sum_{\\mathbf{i}=0}^{r/2 - 1}\\begin{cases}\\displaystyle      \\sum_{x\\subseteq\\{x_1,\\ldots , x_r\\ } , |x|\\ \\text{even } } ( -1)^{(\\sum_{x_{j}\\in x } i_{j } ) } y_{\\tau(\\mathbf{i } ) } \\chi_{x } & \\text{if $ s_{\\mathbf{i}}=1$;}\\\\       \\displaystyle \\sum_{x\\subseteq\\{x_1,\\ldots , x_r\\ } , |x|\\ \\text{odd } }   ( -1)^{(\\sum _ { x_{j}\\in x } i_{j } ) } y_{\\tau(\\mathbf{i } ) } \\chi_{x } & \\text{if $ s_{\\mathbf{i}}=-1$.}\\\\ \\end{cases}\\ ] ] just as in the equation  , whenever @xmath224 , the sum on the rhs of equation   has precisely one non - zero term which is @xmath190 if @xmath225 and @xmath226 if @xmath227 .",
    "therefore this sum gives rise to exactly the addressing function in equation   which is defined as @xmath213 and consequently the equality in equation   follows .",
    "it follows that for each @xmath228 in the support of @xmath171 and for any fixed @xmath199 , all elements of the set @xmath229 will have the same parity .",
    "moreover , when draws from @xmath171 are considered , for every distinct @xmath199 this odd / even parity is independent and uniformly random",
    ".    now we are ready to prove theorem  [ s1qthm2 ] .",
    "recall that a @xmath2 oracle query returns @xmath96 with probability @xmath230 for every subset @xmath96 of input variables to the function . considering the equations and , for any @xmath3 in @xmath219 or @xmath182 its @xmath2 oracle will return a pair of the form @xmath231 .",
    "let us define a set @xmath232 of `` typical '' outcomes from @xmath2 oracle queries .",
    "fix any @xmath233 , and let @xmath232 denote the set of all sequences @xmath234 of length @xmath235 which have the property that _ no @xmath236 occurs more than once among @xmath237_.    note that for any fixed @xmath238 , every non - zero fourier coefficient @xmath239 satisfies @xmath240 due to equation  .",
    "therefore after @xmath194 is drawn , for any fixed @xmath199 the probability of receiving a response of the form @xmath241 as the outcome of a @xmath2 query is either    @xmath242 , : :    if @xmath194 is not a function of @xmath199 , i.e.    @xmath243 ; or @xmath244 , : :    if @xmath245 .",
    "this is because    each of the @xmath246 responses @xmath241    occurs with probability @xmath247 .",
    "similarly , for any fixed @xmath248 , every non - zero fourier coefficient @xmath249 satisfies @xmath250 due to equation  .",
    "therefore after @xmath228 is drawn , for any fixed @xmath199 the probability of receiving a response of the form @xmath241 as the outcome of a @xmath2 query is either    @xmath242 , : :    if @xmath228 is not a function of    @xmath199 , i.e.    @xmath251 ; or @xmath252 , : :    if @xmath253 .",
    "this is because    each of the @xmath254 responses @xmath241    occurs with probability @xmath255 .",
    "now let us consider the probability of obtaining a sequence from @xmath232 under each scenario .    *",
    "if the function is drawn from @xmath170 : the probability is at least @xmath256}.\\ ] ] * if the function is from @xmath171 : the probability is at least @xmath257}\\ ] ]    now the crucial observation is that whether the function is drawn from @xmath170 or from @xmath171 , each sequence in @xmath232 is equiprobable by symmetry in the construction . to see this , simply consider the probability of receiving a fixed @xmath258 for some new @xmath259 in the next @xmath2 query of an unknown function drawn from either one of these distributions . using the above calculations for @xmath260",
    ", one can directly calculate that these probabilities are equal in either scenario .",
    "alternatively , for a function drawn from @xmath171 one can observe that since each successive @xmath259 is `` new '' , a fresh random bit determines whether the support is an @xmath258 with @xmath261 odd or even ; once this is determined , the choice of @xmath262 is uniform from all subsets with the correct parity .",
    "thus the overall draw of @xmath241 is uniform over all @xmath262 s .",
    "considering that the subset of relevant variables @xmath263 is uniformly chosen from @xmath264 , this gives the equality of the probabilities for each @xmath241 with a new @xmath259 when the function is drawn from @xmath171 .",
    "the argument for the case of @xmath170 is clear .",
    "consequently the statistical difference between the distributions corresponding to the sequence of outcomes of the @xmath235 @xmath2 oracle calls under the two distributions is at most @xmath265 .",
    "now fact  [ dpi ] implies that no algorithm making only @xmath235 oracle calls can distinguish between these two scenarios with high probability .",
    "this gives us the result , and concludes the proof of theorem  [ s1qthm2 ] .",
    "intuitively , under either distribution on functions , each element of a sequence of @xmath235 @xmath2 oracle calls will `` look like '' a uniform random draw @xmath262 from subsets of @xmath266 and @xmath191 from @xmath267 where @xmath191 and @xmath262 are independent . note that this argument breaks down at @xmath268 .",
    "this is because if the algorithm queried the @xmath2 oracle @xmath269 times it will start to see some @xmath270 s more than once with constant probability ( again by the birthday paradox ) .",
    "but when the functions are drawn from @xmath171 the corresponding @xmath108 s will always have a fixed parity for a given @xmath270 whereas for functions drawn from @xmath170 the parity will be random each time .",
    "this will provide the algorithm with sufficient evidence to distinguish with constant probability between these two scenarios .",
    "the problem of learning an unknown @xmath0-junta has been well studied in the computational learning theory literature , see e.g. @xcite .",
    "the following classical lower bound will be a yardstick against which we will measure our results .",
    "[ s2lem1 ] any classical membership query algorithm for learning @xmath0-juntas to accuracy @xmath271 must use @xmath22 membership queries .    consider the restricted problem of learning an unknown function @xmath10 which is simply a single boolean variable from @xmath272 .",
    "since any two variables disagree on half of all inputs , any @xmath271-learning algorithm can be easily modified into an algorithm that exactly learns an unknown variable with no more queries .",
    "it is well known that any set of @xmath1 concepts requires @xmath273 queries for any exact learning algorithm that uses membership queries only , see e.g. @xcite .",
    "this gives the @xmath273 lower bound .    for the @xmath274 lower bound",
    ", we may suppose that the algorithm `` knows '' that the junta has relevant variables @xmath275 .",
    "even in this case , if fewer than @xmath276 membership queries are made the learner will have no information about at least @xmath277 of the function s output values .",
    "a straightforward application of the chernoff bound shows that it is very unlikely for such a learner s hypothesis to be @xmath271-accurate , if the target junta is a uniform random function over the relevant variables .",
    "this establishes the result .",
    "learning juntas from uniform random examples @xmath47 is a seemingly difficult computational problem .",
    "simple algorithms based on exhaustive search can learn from @xmath278 examples but require @xmath279 runtime .",
    "the fastest known algorithm in this setting , due to mossel _",
    "et al . _ , uses @xmath280 examples and runs in @xmath280 examples time , where @xmath281 is the matrix multiplication exponent @xcite .",
    "bshouty and jackson @xcite gave an algorithm using uniform quantum examples from the @xmath53 oracle to learn general @xmath12 formulas .",
    "their algorithm uses @xmath282 calls to @xmath53 to learn an @xmath217-term @xmath12 over @xmath1 variables to accuracy @xmath4 . since any @xmath0-junta is expressible as a @xmath12 with at most @xmath283 terms , their result immediately yields the following statement .",
    "[ s2thm2 ] there exists an @xmath34-learning quantum algorithm for @xmath0-juntas using @xmath284 quantum examples under the uniform distribution quantum pac model .",
    "note that @xcite did not try to optimize the quantum query complexity of their algorithms in the special case of learning juntas .",
    "in contrast , our goal is to obtain a more efficient algorithm for juntas .",
    "the lower bound of ( * ? ? ?",
    "* observation  6.3 ) for learning with quantum membership queries for an arbitrary concept class can be rephrased for the purpose of learning @xmath0-juntas as follows .",
    "[ s2fac1 ] any algorithm for learning @xmath0-juntas to accuracy @xmath285 with quantum membership queries must use @xmath274 queries .    since we are proving a lower bound we may assume that the algorithm is told in advance that the junta depends on variables @xmath286 consequently we may assume that the algorithm makes all its queries with nonzero amplitude only on inputs of the form @xmath287 .",
    "now ( * ? ? ?",
    "* observation  6.3 ) states that any quantum algorithm which makes queries only over a shattered set ( as is the set of inputs @xmath288 for the class of @xmath0-juntas ) must make at least vc - dim(@xmath31)/100 @xmath50 queries to learn with error rate at most @xmath289 ; here vc - dim(@xmath31 ) is the vapnik - chervonenkis dimension of concept class @xmath31 .",
    "since the vc dimension of the class of all boolean functions over variables @xmath275 is @xmath290 , the result follows .",
    "this shows that a @xmath50 oracle can not provide sufficient information to learn a @xmath0-junta using @xmath291 queries to high accuracy .",
    "it is worth noting that there are other similar learning problems known where an @xmath235-query @xmath50 algorithm can exactly identify a target concept whose description length is @xmath292 bits .",
    "for instance , a single @xmath2 oracle call ( which can be implemented by a single @xmath50 query ) can potentially give up to @xmath0 bits of information ; if the concept class @xmath31 is the class of all @xmath290 parity functions over the first @xmath0 variables , then any concept in the class can be exactly learned by a single @xmath2 oracle call .",
    "note that all the results we have discussed in this subsection concern algorithms with access to only one type of oracle ; this is in contrast with the algorithm we present in the next section .",
    "the motivating question for this section is : `` is it possible to reduce the classical query / sample complexity drastically for the problem of junta learning if the learning algorithm is also permitted to have very limited quantum information ? '' we will give an affirmative answer to this question by describing a new algorithm that uses both @xmath2 queries ( i.e. quantum examples ) and classical uniform random examples .",
    "[ s1qlem1 ] let @xmath32 be a function whose value depends on the set of variables @xmath293 .",
    "then there is an algorithm querying the @xmath2 oracle @xmath294 times which w.h.p .",
    "outputs a list of variables such that    * the list contains all the variables @xmath73 for which @xmath295 ; and * all the variables @xmath296 in the list have non - zero influence : @xmath297 .",
    "the algorithm simply queries the @xmath2 oracle @xmath298 many times and outputs the union of all the sets of variables received as responses to these queries .",
    "if @xmath295 then the probability that @xmath73 never occurs in any response obtained from the @xmath235 @xmath2 oracle calls is at most @xmath299 the union bound now yields that with probability at least @xmath130 , every @xmath73 with @xmath295 is output by the algorithm .",
    "[ s2thm3 ] there is an efficient algorithm @xmath34-learning @xmath0-juntas with @xmath7 queries of the @xmath2 oracle and @xmath300 random examples .",
    "we claim algorithm  1 satisfies these requirements .    *",
    "input : * @xmath301 . *",
    "stage 1 : * construct a set containing all variables of @xmath3 with an influence at least @xmath302 using the algorithm in lemma  [ s1qlem1 ] .",
    "let @xmath78 be the final result .",
    "* stage 2 : * @xmath304 draw from @xmath47 .",
    "let @xmath305 denote the projection of @xmath9 onto the variables in @xmath78 .",
    "@xmath306 . .",
    "output the hypothesis : @xmath307    assume we are given a boolean function @xmath3 whose value depends on the set of variables @xmath293 with @xmath308 .",
    "by lemma  [ s1qlem1 ] , @xmath7 queries of the @xmath2 oracle will reveal all variables with influence at least @xmath302 with high probability during stage 1 .",
    "assuming the algorithm of lemma  [ s1qlem1 ] was successful , we group the variables as follows :    [ cols=\"^,^\",options=\"header \" , ]     note that @xmath309 by lemma  [ s1qlem1 ] and by the assumption that @xmath3 is a @xmath0-junta .",
    "we reorder the variables of @xmath3 so that the new order is @xmath310 for notational simplicity , i.e. @xmath3 is now considered to be over @xmath311 .",
    "we will denote an assignment to these variables by @xmath312 .    in stage 2",
    "the algorithm draws random examples until at least @xmath313 fraction of all assignments to the variables in @xmath78 are observed .",
    "let us call this set of assignments by @xmath103 , and for every @xmath314 , let us denote the first example @xmath315 drawn in stage 2 for which @xmath316 by @xmath317 . at the end of the algorithm ,",
    "the following hypothesis is produced as the output : @xmath318 in other words , the value of the hypothesis only depends on the setting of the variables in @xmath78 .",
    "observe the probability that any given setting of a fixed set of variables in @xmath78 has not been seen can be made less than @xmath319 using @xmath320 uniform random examples .",
    "therefore the linearity of expectation implies that after @xmath320 random examples , the expected fraction of unseen assignments is @xmath321 .",
    "thus by markov s inequality the fraction of unseen assignments will be @xmath322 w.h.p . hence stage 2",
    "will terminate w.h.p .",
    "after @xmath320 random examples .",
    "consequently , the whole algorithm terminates with high probability with the desired query consumption .",
    "all we need to verify is that the hypothesis constructed is @xmath34-accurate .",
    "* the hypothesis @xmath323 is @xmath34-accurate with high probability : *    we introduce some notation : let @xmath324 ; and given two strings @xmath325 , let @xmath326 denote the bitwise multiplication between @xmath327 ; and let @xmath328 denote the total number of @xmath25 s in @xmath329",
    ". also let @xmath330 denote the indicator function that takes value @xmath26 if @xmath331 holds and value @xmath332",
    "if @xmath331 is false .    we start with the following fact :    [ fac : stupidfact ] for any @xmath333 , we have @xmath334 } < { \\epsilon}/10 $ ] .",
    "given any string @xmath335 , clearly there exists a sequence of @xmath336 strings : @xmath337 therefore , @xmath338 } \\\\",
    "& \\leq\\frac{1}{2^{n } } \\displaystyle\\sum_{\\mathbf{a}\\in\\mathbb{b}^{|\\mathcal{a}| } }          \\sum_{\\mathbf{b}\\in\\mathbb{b}^{|\\mathcal{b}| } } \\sum_{\\mathbf{c}\\in\\mathbb{b}^{|\\mathcal{c}|}}\\sum_{i=1}^{|s|}\\mathbf{1}_{[f(\\mathbf{a},\\mathbf{b}\\odot u^{i+1},\\mathbf{c})\\neq f(\\mathbf{a},\\mathbf{b}\\odot u^{i},\\mathbf{c } ) ] } \\\\          & = \\sum_{i=1}^{|s|}\\underbrace{\\left(\\frac{1}{2^{n } } \\displaystyle\\sum_{\\mathbf{a}\\in\\mathbb{b}^{|\\mathcal{a}| } }          \\sum_{\\mathbf{b}\\in\\mathbb{b}^{|\\mathcal{b}| } } \\sum_{\\mathbf{c}\\in\\mathbb{b}^{|\\mathcal{c}|}}\\mathbf{1}_{[f(\\mathbf{a},\\mathbf{b}\\odot u^{i}\\odot u^{i+1},\\mathbf{c})\\neq f(\\mathbf{a},\\mathbf{b},\\mathbf{c})]}\\right)}_{=\\text{the influence of the unique variable $ b_{j(i)}$ that takes value $ -1 $ in $ u^{i+1}\\odot u^{i}$}}\\\\          & < { \\epsilon}/10.\\quad [ \\text{since every $ b_j\\in\\mathcal{b}$ has influence $ < \\frac{{\\epsilon}}{10k}$ and $ |\\mathcal{b}|\\leq k$ } ]      \\end{aligned}\\ ] ]    for each @xmath339 , consider a fixed setting of strings @xmath340 , @xmath341 . let us call the list of all these assignments @xmath342 , i.e. @xmath343 for any such `` list of assignments '' @xmath342 , we define the function @xmath344 as follows : @xmath345 .",
    "the error incurred by approximating @xmath3 by @xmath346 is : @xmath347          = { \\mathbf{pr}}_{(\\mathbf{a},\\mathbf{b},\\mathbf{c})}[f(\\mathbf{a},\\mathbf{b}^{\\mathbf{a}},\\mathbf{c}^{\\mathbf{a}})\\neq f(\\mathbf{a},\\mathbf{b},\\mathbf{c})]\\ ] ] @xmath348\\quad          [ \\text{since $ f$ does not depend on the variables in $ \\mathcal{c}$}]\\ ] ] @xmath349 }          = \\frac{1}{2^{n } } \\displaystyle\\sum_{\\mathbf{a}\\in\\mathbb{b}^{|\\mathcal{a}| } } \\sum_{s\\in\\mathbb{b}^{|\\mathcal{b}| } } \\sum_{\\mathbf{c}\\in\\mathbb{b}^{|\\mathcal{c}|}}\\mathbf{1}_{[f(\\mathbf{a},\\mathbf{b}^{\\mathbf{a}},\\mathbf{c})\\neq f(\\mathbf{a},\\mathbf{b}^{\\mathbf{a}}\\odot s,\\mathbf{c})]}\\label{eqn : fgamma}\\ ] ]    therefore if we consider the expected value of the incurred error @xmath350 $ ] over all `` lists of assignments ''",
    "@xmath342 , equation   implies that : @xmath351&=\\frac{1}{2^{|\\mathcal{b}|}}\\sum_{s\\in\\mathbb{b}^{|\\mathcal{b}|}}\\underbrace{\\left(\\frac{1}{2^{n } } \\displaystyle\\sum_{\\mathbf{a}\\in\\mathbb{b}^{|\\mathcal{a}| } }          \\sum_{\\mathbf{b}^{\\mathbf{a}}\\in\\mathbb{b}^{|\\mathcal{b}| } } \\sum_{\\mathbf{c}\\in\\mathbb{b}^{|\\mathcal{c}|}}\\mathbf{1}_{[f(\\mathbf{a},\\mathbf{b}^{\\mathbf{a}}\\odot s,\\mathbf{c})\\neq f(\\mathbf{a},\\mathbf{b}^{\\mathbf{a}},\\mathbf{c})]}\\right ) } _ { < { \\epsilon}/10,\\ \\text{due to fact~\\ref{fac : stupidfact}}}\\\\          & < { \\epsilon}/10 .",
    "\\end{aligned}\\ ] ] consequently , the expected error of approximating @xmath3 by a uniformly chosen @xmath346 is less than @xmath352 .",
    "this also implies that for a uniformly chosen subset @xmath103 of assignments to variables in @xmath78 with size @xmath353 , the expected error over @xmath103 satisfies : @xmath354 < { \\epsilon}/10 $ ] .",
    "therefore by markov s inequality , we obtain the following observation :    [ obs : jlproof]for a uniformly chosen subset @xmath103 and @xmath346 as described above , @xmath346 will agree with @xmath3 on @xmath355 fraction of the coordinates @xmath356 with probability at least @xmath357 .",
    "now if we go back and recall what the algorithm does in stage 2 , we will observe that the generation of the hypothesis in stage 2 is equivalent to drawing a uniform @xmath346 and @xmath103 as described and resetting the values of @xmath346 at those coordinates @xmath358 to true .",
    "this is because the algorithm only draws classical random examples during stage 2 .",
    "therefore due to observation  [ obs : jlproof ] , the hypothesis will disagree with @xmath3 on at most @xmath359 fraction of the inputs with overall probability at least @xmath36 .",
    "this gives the desired result .",
    "note that this algorithm    * uses only a moderate number of quantum examples ; * has overall query complexity with no dependence on @xmath1 , in contrast with known lower bounds ( lemma  [ s2lem1 ] ) for learning from classical membership queries ; * uses the @xmath46 oracle as its only source of classical information ( @xmath43 queries are not used ) ; and * is computationally efficient .",
    "one can compare this result to that of theorem  [ s2thm2 ] which requires @xmath284 quantum examples to learn @xmath0-juntas .",
    "in contrast , our algorithm uses not only substantially fewer quantum examples but also fewer uniform random examples , which are considered quite cheap .",
    "intuitively , this means that for the junta learning problem , almost all the quantum queries used by the algorithm of bshouty and jackson @xcite can in fact be converted into ordinary classical random examples .",
    "the algorithm of theorem  [ s2thm3 ] is optimal in the following sense :    [ obsjlrn ] any @xmath360-learning quantum membership query algorithm for @xmath0-juntas that uses only @xmath361 classical @xmath43 queries must additionally use @xmath362 @xmath50 queries .",
    "this statement easily follows from fact  [ s2fac1 ] since a classical membership query can be simulated by a @xmath50 query .",
    "contrasting our junta learning algorithm with observation  [ obsjlrn ] , we see that if the allowed number of classical examples or queries is decreased even slightly from the @xmath363 used by our algorithm to @xmath361 , then an additional @xmath362 quantum queries are required , even if @xmath50 queries are allowed .",
    "we have given some results on learning and testing @xmath0-juntas using both quantum examples and classical random examples .",
    "it would be interesting to develop other testing and learning algorithms that combine these two sorts of oracles , with the goal of minimizing the number of quantum oracle calls required .",
    "another interesting goal for future work is to further explore the power of the @xmath2 oracle .",
    "can the gap between our @xmath100-query upper bound and our @xmath6-query lower bound for the @xmath2 oracle be closed ?",
    "a. blum , _ learning a function of @xmath146 relevant variables ( open problem ) _ , proceedings of the 16th annual conference on learning theory and 7th kernel workshop , pp .  731733 ( 2003 ) .",
    "h. buhrman , l. fortnow , i. newman , h. rhrig , _ quantum property testing _ , proceedings of 14th soda , pp .",
    "480488 ( 2003 ) .",
    "n. bshouty , r. cleve , r. gavald , s. kannan and c. tamon . _",
    "oracles and queries that are sufficient for exact learning _ , j. comput",
    ", vol  * 52 * , no .  3 , pp . 421 - 433 ( 1996 ) .",
    "r. lipton , e. markakis , a. mehta , n. vishnoi , _ on the fourier spectrum of symmetric boolean functions with applications to learning symmetric juntas _ , proceedings of the 20th annual ieee conference on computational complexity , pp .",
    "112119 ( 2005 ) .",
    "e. mossel , r. odonnell and r.  a. servedio , _ learning functions of @xmath0 variables _ , journal of computer and system sciences , vol .",
    "* 69 * , no .  3 , pp .",
    "421434 ( 2004 ) .",
    "m. nielsen and i. chuang , _ quantum computation and quantum information _ , cambridge university press ( 2000 ) .",
    "r. odonnell , r.  a. servedio , _ extremal properties of polynomial threshold functions _ , journal of computer & system sciences , to appear .",
    "available at http://www.cs.columbia.edu/`~`rocco/papers/ccc03.html .",
    "preliminary version appeared in eighteenth annual ieee conference on computational complexity , pp .",
    "312 ( 2003 ) .",
    "r. rubinfeld and m. sudan , _ robust characterizations of polynomials with applications to program testing _",
    ", siam journal on computing , * 25*(2 ) : pp .",
    "252271 ( 1996 ) ."
  ],
  "abstract_text": [
    "<S> in this article we develop quantum algorithms for learning and testing _ juntas _ , i.e. boolean functions which depend only on an unknown set of @xmath0 out of @xmath1 input variables . </S>",
    "<S> our aim is to develop efficient algorithms :    whose sample complexity has no dependence on @xmath1 , the dimension of the domain the boolean functions are defined over ;    with no access to any classical or quantum membership ( `` black - box '' ) queries . instead , </S>",
    "<S> our algorithms use only classical examples generated uniformly at random and fixed quantum superpositions of such classical examples ;    which require only a few quantum examples but possibly many classical random examples ( which are considered quite `` cheap '' relative to quantum examples ) .    </S>",
    "<S> our quantum algorithms are based on a subroutine @xmath2 which enables sampling according to the fourier spectrum of @xmath3 ; the @xmath2 subroutine was used in earlier work of bshouty and jackson on quantum learning . </S>",
    "<S> our results are as follows :    we give an algorithm for testing @xmath0-juntas to accuracy @xmath4 that uses @xmath5 quantum examples . </S>",
    "<S> this improves on the number of examples used by the best known classical algorithm .    </S>",
    "<S> we establish the following lower bound : any @xmath2-based @xmath0-junta testing algorithm requires @xmath6 queries .    </S>",
    "<S> we give an algorithm for learning @xmath0-juntas to accuracy @xmath4 that uses @xmath7 quantum examples and @xmath8 random examples . </S>",
    "<S> we show that this learning algorithms is close to optimal by giving a related lower bound . </S>"
  ]
}