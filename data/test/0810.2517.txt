{
  "article_text": [
    "in this paper , we present a multirate method that is suited for integrating systems of ordinary differential equations ( odes ) which arise from step models describing nanostructure evolution . the strength of our method , in comparison to other existing multirate schemes , is its order of accuracy : our method is fourth order provided solutions are sufficiently smooth .",
    "a multirate method is basically one that takes different step sizes for different components of the solution @xcite . when might such a need for different time steps arise ?",
    "one situation where multirate methods may be more efficient than single rate ones is when a few of the components contain time singularities or are _ locally stiff_. in this case , ( explicit ) single rate methods are likely to use small time steps for all the components , whereas a multirate one uses small time steps just for singular / locally stiff ones .",
    "we believe that this strategy significantly improves the efficiency of solution .",
    "integration by our multirate method occurs in two stages .",
    "we first use an `` outer '' integrator to handle the non - singular/ non - stiff components and then an `` inner '' integrator to handle the singular / stiff ones . to perform the second inner integration",
    ", a small number of components from the outer solution must be interpolated .",
    "the high order of accuracy of the multirate scheme relies on the interpolation being of a sufficiently high order .",
    "one of our key results in this paper is that for a multirate method to be @xmath0 order , the interpolation must be @xmath1 order .",
    "we demonstrate our method by using a fourth order runge - kutta method ( with error control ) for the inner and outer schemes and coupling them together with cubic interpolants .",
    "multirate schemes were first studied by gear and wells  @xcite .",
    "further treatments can be found in  @xcite , and the references therein .",
    "however , considering the wide variety of methods which researchers have used to improve the performance and accuracy of integration codes , it is surprising to learn that multirate schemes have received only modest attention .",
    "this is even more surprising , given that algorithms using somewhat similar concepts are well developed for the numerical solution of pdes  e.g. adaptive mesh refinement ( amr ) in the field of hyperbolic pdes  @xcite .",
    "the applications of multirate methods seem mostly confined to @xmath2-body problems  @xcite , and equations arising from electrical networks  @xcite .",
    "the work presented here is , as far as we are aware , the first instance of a multirate scheme applied to a problem in surface evolution .",
    "our method is fairly similar to the one described in  @xcite , which is second order .",
    "for example : we first advance and interpolate the slow components , and then integrate the fast components  this is the `` slowest first '' paradigm described in  @xcite .",
    "we also automatically detect the fast components by looking at the error estimates produced using an embedded formula .",
    "the main differences are that : ( i ) our method is fourth order in time for sufficiently smooth solutions and ( ii ) our method is most effective when applied to the types of odes that commonly arise in models of step surface evolution",
    ". we will discuss ( ii ) in more detail later on in the paper , but for now we make the comment that a necessary but not sufficient condition for our method to work is that the ode system be locally coupled .",
    "the strengths of our method are that automatic step size selection is simple to implement , and that there is a lower overhead cost because we do not have to interpolate all the slow components of the solution  this is one of the benefits of specializing to locally coupled systems .",
    "the outline of this paper is as follows : in section [ sec : physical_motivation ] , we discuss why step models are studied and explain the physics behind the equations . in section [ sec02:governing ]",
    "we present the step equations , and in section [ sec03:properties ] we describe features of the equations that require special attention . in section [ sec04:code ]",
    "we give the details of the numerical method and in particular , we discuss the important issue of interpolation in section [ interpolation ] .",
    "we validate our code and present our results in section [ sec05:implementation ] and summarize our findings with a conclusion in section [ sec61:discussion ] .",
    "the surface dynamics of crystal structures has received much recent attention  @xcite because of its relevance to the fabrication of nano - scale electronic devices , such as quantum dots  @xcite . of interest to us here",
    "is the behavior of _ vicinal _ surfaces below the roughening temperature @xmath3 . for",
    "any given material , a surface forming a small angle with a high symmetry plane of the crystal is called vicinal .",
    "the roughening temperature is the critical temperature below which steps become thermodynamically stable .",
    "thus , a microscope image    of a surface below @xmath4 , with a slight miscut angle , appears as made from a series of terraces separated by steps of atomic height  see figure  [ fig : silicon ] for an example in silicon .",
    "as the surface evolves , the steps move and change their shape , but the steps are well defined and have a lifetime that is long enough to be directly observable . when the temperature is increased above @xmath4 , a _",
    "kosterlitz - thouless _ phase transition occurs  @xcite , and the surface becomes statistically rough  as characterized by the divergence of the height  height correlation function  @xcite . for many physical applications ( such as epitaxy ) the operating temperatures are below @xmath3 , and this mesoscale description of a surface in terms of steps and their evolution is very useful .",
    "a step model can account for finite size effects occurring at the atomic scale , while remaining computationally simple  simulations with step models can be done over much longer time periods than , for example , with atomistic models of the surfaces .",
    "the step s shape can , in general , be very complicated .",
    "thus , quantitative descriptions for how steps interact with one another can be very difficult to derive , and a complete description of an arbitrarily shaped nanostructure in terms of its steps is currently not available . as a result , theoretical studies have been restricted to simple nanostructure geometries and step shapes .",
    "the bcf model , proposed by burton , cabrera and frank  @xcite in 1951 , deals with a monotonic step train consisting of an infinite number of parallel steps  see figure  [ fig : geombcf ] . in this model ,",
    "the steps edges are separated by atomically smooth terraces , and each step position is uniquely described by a single scalar quantity @xmath5  where the index @xmath6 labels the step . using this model , burton , cabrera and frank were able to describe the evolution of a ( 1 dimensional ) stepped surface , under non - equilibrium conditions , in terms of its steps .    in 1988 ,",
    "rettori and villain @xcite considered a 2d array of circular mounds , and incorporated the effects of step line tension into the bcf model .",
    "the nanostructures that they studied consist of a finite number of concentric circular layers , in a `` wedding cake '' configuration  see figure  [ fig : wedcake ] .",
    "this step system can also be used to describe the `` healing '' of small circular pits @xcite produced by scanning tunneling microscopes .",
    "the    radius of each layer @xmath7 is assumed to be a continuous function of time .",
    "physical considerations then lead to a set of locally coupled odes for the radii .",
    "similar sets of equations can be found in @xcite .",
    "there are two main competing physical processes that take place on a stepped surface , in the absence of evaporation and desorption .",
    "the first one is the diffusion of adsorbed atoms ( `` adatoms '' ) across terraces , which is characterized by a diffusivity @xmath8 .",
    "the second one is the attachment - detachment of adatoms at step edges , which is characterized by the kinetic coefficients @xmath9 and",
    "@xmath10  see figure  [ fig : tranprostepsurf ] .",
    "experimental evidence  @xcite suggests that , for some materials , attachment from the terrace above requires overcoming a higher activation energy barrier than attachment from the terrace below , so that @xmath11 .",
    "however , in this paper we consider only @xmath12 , and disregard this ( possible ) asymmetry in the step attachment - detachment  known in the literature as an ehrlich - schwoebel ( es ) barrier  @xcite .",
    "furthermore , we neglect the diffusion of adsorbed vacancies and the diffusion of adatoms along step edges @xcite .",
    "in this section , we present the ( non - dimensional ) evolution equations for a finite axisymmetric nanostructure with @xmath13 steps , relaxing in the absence of deposition and evaporation  see figure  [ fig : wedcake ] .",
    "derivations of these equations can be found in @xcite .",
    "every step in the structure is subject to two physical effects that drive its motion .",
    "the first is a _ step - line tension _ , arising from a gibbs - thomson mechanism  @xcite .",
    "an isolated , circular step of radius @xmath14 , on top of an infinite substrate , initially devoid of adatoms , reduces its perimeter ( and hence its radius ) by emitting adatoms at a rate proportional to its curvature  @xcite  i.e. @xmath15 .",
    "the second effect is a _ repulsive interaction with neighboring steps _ , characterized by a potential function that is inversely proportional to the square of the distance between the steps  @xcite .",
    "steps in the bulk of the structure ( with a smaller curvature ) tend to be less affected by the step - line tension compared to steps near the top .",
    "let @xmath16 @xmath17 be the positions of the steps  numbered starting from the top of the nanostructure .",
    "thus @xmath18 , with @xmath19 the radius of the innermost step and @xmath20 the radius of the outermost step .",
    "define @xmath21 , @xmath22 , and @xmath23 , by : @xmath24{4.6in}{{${\\displaystyle \\left .",
    "\\begin{array}{lclcl }       \\lambda_1 & = & \\lambda(\\rho_{1 } , \\rho_{2})\\/,\\\\       \\lambda_n & = & \\lambda(\\rho_{n-1 } , \\rho_{n } ) +                       \\lambda(\\rho_{n } , \\rho_{n+1})\\/ ,                       \\quad \\mbox{for } \\;\\ ; 2 \\leq n \\leq n-1\\/,\\\\       \\lambda_n & = & \\lambda(\\rho_{n-1 } , \\rho_{n})\\/ ,    \\end{array } \\ ; \\right\\}\\/$}}}\\ ] ] @xmath25{4.6in}{{${\\displaystyle        \\hspace*{0.50 in } \\mbox{where } \\quad       \\lambda(\\rho_i , \\rho_j ) = \\frac{2\\,\\rho_i}{\\rho_i+\\rho_j}\\ ,       \\frac{1}{(\\rho_i-\\rho_j)^3 } + \\frac{1}{\\rho_j}\\ ,       \\left(\\frac{\\rho_i}{\\rho_i^2-\\rho_j^2}\\right)^2\\,,}\\/$}}\\ ] ] @xmath26 @xmath27 where @xmath28 , @xmath29 , and @xmath30 ( as well as @xmath31 below ) are non - dimensional constants . then the step - flow equations are @xmath32 the non - dimensional constants are as follows :    * the parameter @xmath33 measures the strength of the step - step interactions relative to the strength of the step line tension .",
    "it is given by @xmath34 where @xmath35 is the step - step interaction coefficient  @xcite , @xmath36 is the step stiffness  @xcite , @xmath37 is the height of a single step , and @xmath38 is a typical value for the radii  for example , it could be the initial radius of the final step in the structure . _",
    "we note that , in many experimental situations , @xmath39_. * the parameters @xmath40 are given by @xmath41 where @xmath42 is the adatom attachment - detachment coefficient at a step , and @xmath43 is the adatom terrace diffusivity .",
    "the ratio @xmath44 where @xmath45 and @xmath46 is a typical terrace width , measures the competition between diffusion and attachment - detachment  see equation ( [ eqn : sec20:deltan ] ) .",
    "* the dimensionless parameter @xmath31 is given by @xmath47 where @xmath48 is the atomic area , @xmath49 is the boltzmann constant , @xmath50 is the absolute temperature , @xmath51 is the equilibrium density of adatoms at a straight , isolated , step and @xmath52 is a typical bulk step velocity .",
    "we note that , of the physical parameters involved in the definitions of the non - dimensional constants above , some  such as the terrace diffusivity @xmath43 , have been extensively tabulated @xcite , while others  such as @xmath51 and @xmath52 , can be inferred from experiments @xcite .",
    "however , for the purposes of simulation , we can take @xmath53 without loss of generality , by an appropriate rescaling of the step radii and time",
    ".    equations ( [ eqn : sec20:eqnrho1 ] )  ( [ eqn : sec20:eqnrhon ] ) constitute a pentadiagonal system , of the form @xmath54 where all the @xmath55 have the same functional form , with the exception of @xmath56 , @xmath57 , @xmath58 , and @xmath59  which govern the behavior of the first and final two steps .",
    "notice that if @xmath60 denotes the common rate function for the bulk of the steps ( @xmath61 ) , then @xmath62 in this paper , we present a multirate method for integrating the equations ( [ eqn : sec20:eqnrho1 ] )  ( [ eqn : sec20:eqnrhon ] ) , when @xmath63 . however , we believe that the method presented here should be applicable to _ general sets _ of locally coupled odes , which are _ locally stiff _ ( see section [ local ] ) .",
    "in fact , our multirate method was designed to specifically tackle this problem .",
    "let us now turn our attention to the difficulties that arise when solving equations ( [ eqn : sec20:eqnrho1 ] )  ( [ eqn : sec20:eqnrhon ] ) numerically .",
    "the axisymmetric step - flow equations possess a number of peculiar properties which pose problems for standard integrators  hence the need for a multirate algorithm .",
    "for example , the singular collapse of the innermost step and stiffness , localized to only a few of the components , are two ( different ) situations under which a standard integrator is forced to use small time steps . in these cases ,",
    "a single rate method uses small time steps for all components .",
    "in contrast , a multirate method will use small time steps only when it has to , so that most of the components are integrated with a large time step .",
    "this strategy improves the efficiency of the integration .",
    "the singular collapse of the innermost step causes a loss in accuracy for most high order integrators near the point of collapse .",
    "hence , we implement a low - order simple euler routine for the innermost step and its neighbors . away from the singular step ,",
    "we implement a fourth order multirate method with error control , which is able to efficiently integrate locally stiff components .      equations ( [ eqn : sec20:eqnrho1 ] )  ( [ eqn : sec20:eqnrhon ] ) have the property that @xmath64 in a finite time .",
    "the top step always undergoes a monotonic collapse because its radius always decreases under the effect of step - line tension . as the top step shrinks",
    ", it emits adatoms , causing the radii of the second and subsequent steps to grow as these are absorbed .",
    "when the top step completely disappears , the number of layers in the structure is reduced by one . as a result of the sequential collapse of top steps , a macroscopically flat region called a facet forms and grows on the top of the structure .",
    "provided that the collapse of the top steps is tracked accurately , and the topmost @xmath65 is removed at each collapse , the growth of the facet is automatically accounted for .",
    "when the first collapse occurs , @xmath66 , @xmath67 , @xmath68 and @xmath69 replace @xmath70 , @xmath68 , @xmath71 and @xmath72 in ( [ eqn : sec20:eqnrho1 ] ) , and ( [ eqn : sec20:eqnrhon ] ) applies when @xmath73 . a similar replacement occurs for the second and subsequent collapses . in this way ,",
    "a given index tracks always the same step throughout the integration .",
    "let @xmath74 be the collapse time for @xmath19",
    ". then it can be shown  @xcite that as @xmath75 , @xmath76 for some constants @xmath77 and @xmath78 .",
    "the square root behavior in ( [ square_root ] ) comes from the fact that the leading order behavior for @xmath79 in equation ( [ eqn : sec20:eqnrho1 ] ) stems from a line tension : @xmath80 .",
    "thus the derivatives of @xmath19 are divergent at the time of collapse .",
    "since ( [ eqn : sec20:eqnrho1 ] )  ( [ eqn : sec20:eqnrhon ] ) is a locally coupled set of equations , we also expect @xmath81 , for @xmath82 , to be singular but for the solutions to become more regular near @xmath83 as @xmath84 becomes larger .",
    "since the accuracy of high order integrators usually relies on the solution having enough bounded derivatives , this means that standard high order solvers will lose accuracy near the time of collapse .",
    "for example , consider a method with truncation error @xmath85 for smooth solutions @xmath86 , and time step @xmath87 .",
    "let @xmath88 be a time @xmath89 steps away from @xmath83 , so that @xmath90 .",
    "then , given the square root singularity in ( [ square_root ] ) , the error near @xmath83 will be increased to @xmath91 furthermore , consider the issue of automatic time step selection in an adaptive integration code .",
    "this is usually done by estimating the local truncation error , and updating the time step size with a formula for the truncation error that assumes a smooth solution .",
    "for example , consider a runge - kutta scheme using an embedded higher order formula to estimate the local truncation error .",
    "such an algorithm updates the time step size using a formula like @xcite @xmath92 where @xmath93 is the order of the integrator .",
    "equation ( [ stepsizecontrol ] ) is invalid near a time singularity , because from ( [ eq100 ] ) , the error near @xmath83 does not scale as @xmath94 .",
    "the resulting behavior is somewhat unpredictable : an adaptive integrator may take a very large number of tiny steps  rendering it very inefficient  or it may simply abort , stating that the specified error tolerance is not achievable .",
    "the aim of this subsection is to attempt to quantify the classes of systems for which the approach in this paper is effective . before explaining what we mean by local stiffness , we first introduce some notation . for @xmath95 ,",
    "let @xmath96 be the solution of the ode system for some initial condition @xmath97 .",
    "for some integer @xmath98 , let @xmath99 be the solution with initial condition @xmath100 , where @xmath101 is the kronecker delta , and @xmath102 is small .",
    "finally , let @xmath103 and @xmath104 .",
    "we say that the @xmath105 component of the ode system is _ strongly local _ if ( i ) the system is locally coupled and ( ii ) given any @xmath106 , for all @xmath107 , there exists an integer @xmath108 independent of @xmath107 such that for @xmath109 , @xmath110 .",
    "if every component is strongly local , we say that the ode _ system _ is strongly local .",
    "therefore , a system is strongly local if a small perturbation to any one of its components remains localized in component number .",
    "now we explain local stiffness .",
    "recall that an ode is stiff when the ratio of the slowest and fastest time scales is much greater than one .",
    "the simplest example of this is a situation where the solution of interest is strongly stable , so that small perturbations decay very rapidly , relative to the principal time scale of evolution .",
    "now consider again the perturbation described in the previous paragraph .",
    "we say that the @xmath105 component of an ode system is _ locally stiff _ if ( i ) it is strongly local and ( ii ) @xmath111 rapidly in time , relative to the principal time scale of evolution .",
    "hence , the @xmath105 component of the solution is locally stiff if a perturbation to it remains localized in component number _ and _ decays rapidly in time .",
    "if every component is locally stiff , the the solution is globally stiff .    once strong",
    "locality has been established in an ode system , individual solution _ components _ can be designated as either being ( locally ) stiff or non - stiff .",
    "for the rest of this paper , when we refer to `` stiff components '' of the solution , we mean that the components are locally stiff .",
    "a `` non - stiff component '' is one that evolves on a time scale comparable to the principal time scale . with this in mind",
    ", we can design multirate strategies that handle stiff and non - stiff components separately .",
    "for example , we expect to be able to integrate all non - stiff components with large time steps using explicit solvers .",
    "if the number of stiff components is relatively small , we can use the same explicit method on the stiff components also , but with much smaller time steps because of stability constraints .",
    "if on the other hand the number of stiff components is fairly large , we should resort to a fully implicit stiff solver . at this point",
    "it is worth comparing our approach with other work in the literature dealing with problems involving disparate time scales .",
    "gear and kevrikidis  @xcite propose their `` projective integration '' method to deal with situations where there is a _ gap _ in the spectrum of time scales : the main evolution of a ( stable ) solution occurs slowly , with perturbations decaying much more quickly . for a linear problem , this corresponds to a situation where the eigenvalues can be separated into two groups : one set of moderate sized eigenvalues , and another set with large negative real parts .",
    "projective integration requires two ode solvers : an `` inner '' and an `` outer '' integrator .",
    "the idea is to take many small steps using the inner solver  so that the fast modes are damped out , followed by a large _ projective _ step with the outer integrator .",
    "the process is then repeated .",
    "this method ( which is not multirate ) is well - suited to handling problems where many , or all , of the solution components are rapidly attracted to a slowly varying manifold . note that there is no notion of `` locality '' in this approach : the fast modes can potentially be coupled with all the slow ones .",
    "our multirate method also involves an `` inner '' and an `` outer '' integrator . as discussed above",
    ", the property of local stiffness means that a certain subset of the solution components have much stronger stability than the others .",
    "these stiff components are handled by an `` inner '' integrator while the non - stiff ones are taken care of using an `` outer '' solver .",
    "however , in contrast to the work of gear and kevrikidis , our method is more suited to systems where a small fraction of the components is stiff at any time during the integration . in fact , in terms of the ode s evolution in time , one can think of projective integration as using the inner / outer integrators in `` series '' , whereas our multirate method uses them in `` parallel '' .      we will now show that @xmath112 , the radius of a bulk step , in ( [ eqn : sec20:eqnrhon ] ) is strongly local provided @xmath113 and hence , away from the facet and the substrate , any stiffness that arises is localized . for a bulk step ,",
    "the physical origin of the rapid decay comes from the nature of step interactions in equation ( [ eqn : sec20:lambda ] ) .",
    "steps strongly repel each other when they get too close together .",
    "consider a configuration where some of the steps in the bulk are tightly bunched together , and most of the other steps are widely spaced apart . in this case , a step strictly ( two steps away , at least , from the edge ) inside a bunch is strongly stable , and hence stiff , because small perturbations in its trajectory are opposed by strong interactions from the neighboring steps .",
    "on the other hand , widely spaced steps do not experience such large forces , and respond to perturbations on much slower time scales .",
    "it turns out that these `` step bunching '' configurations are quite common in practice and are produced by the natural time evolution of the system .",
    "in fact , the step bunching instability  @xcite is a well - studied phenomenon in epitaxial growth , with applications in quantum dot technology  @xcite and nanolithography  @xcite .    to analyze the decay of solutions",
    ", the direct approach would be to compute the jacobian matrix and analyze its eigenspectrum .",
    "unfortunately , while the jacobian for the system in ( [ eqn : sec20:eqnrho1 ] )  ( [ eqn : sec20:eqnrhon ] ) can be computed analytically by linearizing at any fixed set of radii @xmath114 , the expressions involved are very complicated , and do not give much insight as to why the equations should be stiff .",
    "instead , we present below a less rigorous calculation , which allows us to relate the degree of local stiffness to the step spacing . our approach is based on the fact that the number of equations , @xmath2 , is generally rather large , and that the solutions of interest have a step spacing that is , piecewise , nearly constant . by this",
    "we mean that the step spacing @xmath115 changes slowly with @xmath116 , except for a few places where it may change abruptly  the effect of these changes is much harder to analyze , and our method of attack ignores them since it is only valid far away from these rapid transition regions .",
    "however , the results of our numerical calculations indicate that their presence does not invalidate our analysis .",
    "we begin by considering a configuration of steps which has a nearly constant step spacing , and expand the solution in the form @xmath117 + @xmath118 , where @xmath119 is a constant , @xmath120 is the ( constant ) leading order step spacing and @xmath121 . substituting this expression into the step flow equations , and ignoring the equations for the boundary steps ( corresponding to @xmath122 and @xmath123 ) , results in the following leading order equation for the perturbation @xmath124 @xmath125 where @xmath126 is the discrete laplacian : @xmath127 . to show that equation  ( [ conststepspacingpert ] ) has the property of strong locality",
    ", we consider the solution to the problem with the initial condition @xmath128 , given by @xmath129 with @xmath130 .",
    "when @xmath131 , @xmath132 exponentially because the integrand in ( [ conststepspacingiv ] ) is @xmath133-periodic .",
    "hence the delta function initial condition remains localized for all @xmath107 . also , note that equation  ( [ conststepspacingpert ] ) has free normal modes given by @xmath134 and @xmath135 is the wave - number .",
    "it follows that the time scales behave like the fourth power of the step spacing .",
    "hence , widely spaced steps evolve on a slow time scale whereas step bunches , which consist of sets of tightly packed steps , give rise to fast time scales and local stiffness .",
    "the goal of our method is to efficiently solve a system of locally coupled odes where only a few of the components are stiff .",
    "a standard explicit integrator would take small time steps for all components of the solution .",
    "in contrast , our multirate method takes large steps for the non - stiff components , and small steps for the stiff ones .",
    "the algorithm starts by taking an explicit , global time step , say : from @xmath136 to @xmath137 .",
    "an embedded formula is then used to obtain an estimate of the local truncation error ( lte ) for each component of the solution . in general",
    ", some of the ltes will be unacceptably large ( because the associated solution components are stiff ) , while others will have acceptable sizes .",
    "the algorithm checks if the components with acceptable ltes satisfy the preset tolerance levels .",
    "if they do not , the step size is reduced and another global time step is attempted . if they do , a second round of integration is performed to correct the components with large ltes .",
    "hence , the algorithm is as follows :       * take a step from @xmath138 to @xmath139 .",
    "* let @xmath140 be the lte for the @xmath141-th component , let @xmath142 be the @xmath143 percentile of all the ltes , and let @xmath144 be the required error tolerance for @xmath84-th component .",
    "for example , if @xmath145 , then @xmath146 of the errors are larger than @xmath147 . if @xmath148 , @xmath147 is the median .",
    "* for some real number @xmath42 , flag all the components whose ltes are greater than @xmath149 ( our code uses @xmath150 ) as being possibly stiff .",
    "* check if the unflagged solution components satisfy the tolerance requirements , i.e. @xmath151 where @xmath152 is taken over all unflagged components only . *",
    "* * if they do , the step is successful .",
    "the step size is increased using the formula ( [ stepsizecontrol ] ) with @xmath153 as the ratio of errors .",
    "* * perform a second integration to correct the flagged components ( see figure [ fig4 ] ) . * * increase the step size according to formula ( [ stepsizecontrol ] ) .",
    "increase @xmath154 and go back to step 1 . * * * if they do not , the step is not successful .",
    "reduce the step size according to ( [ stepsizecontrol ] ) with @xmath155 as the ratio of errors .",
    "* * do not increase @xmath154 and go back to step 1 .",
    "[ algorithm2 ]    the second integration is basically done only for the stiff components , and it involves many small sub - steps within the interval @xmath156}\\/$ ] to ensure stability .",
    "although this second round of integration takes a large number of steps , it only needs to be done for a small subset of the solution components .    to perform the second integration ,",
    "values for the non - stiff components at all times @xmath157 along the boundaries of any stiff set of steps are needed  see figure [ fig4 ] .",
    "for example , in the case of a pentadiagonal system , the values of two non - stiff components are needed on each side of a stiff region .",
    "one way to generate dense output from the non - stiff components , between @xmath158 and @xmath159 , is through interpolation . in this paper",
    "we use cubic interpolatants which are generated by using the intermediate stage function evaluations in a runge - kutta method . in section [ interpolation ] , we give more details on the construction of these interpolants and demonstrate that cubic interpolation is consistent with a multirate method that is globally fourth order .",
    "once solution components have been flagged as requiring re - integration , the local coupling means that some of the non - stiff components may also have to be re - integrated . because ( [ eqn : sec20:eqnrho1 ] )  ( [ eqn : sec20:eqnrhon ] ) is a pentadiagonal system of equations , if only @xmath160 and @xmath161 are stiff components with large ltes , then all three of the components @xmath162 and @xmath161 must be re - integrated as a set , using the dense output from @xmath163 , @xmath164 , @xmath165 and @xmath166 as ` boundary conditions ' .",
    "hence , the algorithm is slightly wasteful in that although @xmath167 was deemed accurate enough , it still had to be integrated for a second time .",
    "note that our algorithm uses the lte in a different way from conventional embedded rk methods : instead of immediately scaling the time step if the smallest lte is greater than the tolerance level , we make a note of _ which _ components had the largest ltes by analyzing their distribution : it might not be efficient to retake the time step for every component , if only a few of them are inaccurate .",
    "the largest ltes ( in the sense of being larger than @xmath168 in algorithm [ algorithm2 ] ) are discarded , and then the time step scaled according to the largest of the remaining errors .",
    "hence , we get a larger time step for a majority of the solution components , and the way that this time step is adjusted throughout the course of the integration is not affected by the presence of a few either rapidly varying or stiff components .    for the rest of this paper , we will call the first time stepper @xmath169 ( used to generate the ltes in the first place ) , and the second time stepper @xmath170 ( used to re - integate stiff components with large ltes ) . in general ,",
    "@xmath169 and @xmath170 do not have to be the same method , or of the same order , but @xmath169 has to be able to generate estimates of the local truncation error . in our code , @xmath169 is a cash - karp runge - kutta formula @xcite and @xmath170 depends on the solution component : if the re - integration involves the innermost step ( see section [ treatment ] ) , we take @xmath170 to be a simple - euler routine which adjusts its step size by step doubling ; otherwise @xmath171 . in other words , there are two possibilities which can arise when performing the re - integration with @xmath170 :    1 .",
    "the re - integration involves solution components which include the innermost step . in the following analysis",
    ", we will assume this is @xmath70 .",
    "[ case1 ] 2 .",
    "the re - integration does not involve the innermost step .",
    "[ case2 ]    the reason to distinguish between these two cases is that ( [ case1 ] ) will involve integration of singular trajectories ( see equation ( [ square_root ] ) ) , but in general , ( [ case2 ] ) will not . using step doubling in ( [ case1 ] ) is a fairly crude way of adjusting the time step .",
    "however , resorting to an embedded formula is not possible when ( [ stepsizecontrol ] ) breaks down , so using step doubling to monitor the quality of the solution is reasonable in this case .      from equation ( [ square_root ] )",
    ", we have seen that @xmath172 in a singular fashion , causing problems for standard high order integrators .",
    "our treatment uses a simple euler method whenever the re - integration of @xmath70 and neighboring singular components is involved : this is `` optimal '' in the sense that simple euler produces results that have the same accuracy as higher order methods ( due to the singular nature of @xmath70 ) but is computationally cheaper .",
    "furthermore , we are able to extract the time of collapse , @xmath173 , using linear interpolation , which is consistent with simple euler s order of accuracy .",
    "our method involves solving for @xmath174 instead of @xmath175 .",
    "note that from ( [ square_root ] ) , @xmath176    as @xmath75 ( the collapse time ) for some constants @xmath177 and @xmath178 , which means that @xmath179 has exactly one derivative at @xmath83 .",
    "our main reason for solving for @xmath179 , instead of @xmath70 , is not to improve accuracy , but rather to enable the algorithm to ` step through ' the singularity at @xmath180 , and use linear interpolation to obtain @xmath83 , the time of collapse of the innermost step .",
    "taking square roots to recover @xmath70 will will result in a drastic loss in accuracy near @xmath83 . at time @xmath107 close to @xmath83 , consider taking a time step of size @xmath181 with component @xmath179 using simple euler .",
    "let @xmath182 be the result of taking this time step using a ` perfect ' integrator , producing the exact solution at @xmath183 , given @xmath184 . then , since the truncation error in simple euler is @xmath185 from ( [ rho_sq ] ) , we have    @xmath186    therefore , if @xmath187 ( @xmath107 sufficiently far away from the singularity ) then the lte for @xmath70 , @xmath188 , is @xmath189 .",
    "however , if @xmath190 ( @xmath107 is very close to @xmath173 ) , then the lte for @xmath70 is @xmath191 , which is not a big improvement over ( [ eq100 ] ) .",
    "note that these estimates for the lte are independent of the order of @xmath170 .",
    "when @xmath170 has ` overstepped ' @xmath83 resulting in @xmath192 and @xmath193 for times @xmath194 ( @xmath195 ) , we set @xmath196 as an approximation to the collapse time",
    ". once @xmath70 has collapsed at @xmath83 , it is removed from the system ( [ eqn : sec20:eqnrho1 ] )  ( [ eqn : sec20:eqnrhon ] ) , the number of equations drops by one , and @xmath197 replaces @xmath184 as the new top step .",
    "the key to making our multirate method high order lies in the ability to generate dense output from the non - stiff components with high accuracy .",
    "one way to generate dense output is to use interpolation and @xmath139 , the function that we derive does not actually pass through @xmath139 .",
    "hence strictly speaking , it is not an interpolant , though we will continue to refer to these approximating functions as `` interpolants '' for convenience . ] . for some integrators , such as backward differentiation formulae ( bdf ) ,",
    "is it obvious how to derive an interpolant that is consistent in order with the underlying integrator ",
    "bdf use extrapolation to advance the solution in time . for other integrators , such as runge - kutta schemes ,",
    "constructing the interpolant is less obvious and this is the focus of the section .",
    "note that we need to generate interpolants _ during run time _ using only the function evaluations that have already been computed by the integrator within each time step .",
    "the extra constraint of generating the interpolants during run time adds a non - trivial complication to the `` traditional '' interpolation problem , which has been studied extensively @xcite .",
    "having successfully integrated the non - stiff components from @xmath138 to @xmath139 , we have the point values @xmath198 and the derivative @xmath199 at our disposal to construct the interpolant between @xmath138 and @xmath139 .",
    "we do _ not _ have information about the derivative @xmath200 .",
    "however , because we are constructing these interpolants during run time , we are at liberty to use the intermediate function evalulations inherent in the application of runge - kutta : this is valuable information that is not usually available in the traditional interpolation problem .",
    "we have seen that our method performs integration in two phases : first we integrate a large number of non - stiff components , then we integrate a small number of stiff ones .",
    "ideally , we would like the two integrations to have the same order .",
    "this is only possible if the interpolation of the non - stiff components is of a sufficiently high order  otherwise large interpolation errors will contaminate the accuracy in the stiff components . in the following paragraphs , when we generate dense output between points @xmath107 and @xmath183",
    ", we define an interpolant to be order @xmath201 when the interpolation error is @xmath202 .",
    "let us assume that our inner and outer solvers are both @xmath0 order .",
    "first of all , let us calculate @xmath201 in terms of @xmath154 if we want our method to be globally @xmath0 order . for simplicity , we assume in this calculation that the effects of round - off error are negligible . consider",
    "the ode system @xmath203 let us assume that we have taken a macro step of size @xmath181 and advanced the non - stiff components @xmath204 successfully from time @xmath107 to @xmath183 .",
    "also assume that we have taken @xmath2 micro steps of size @xmath205 , @xmath95 , for the stiff components @xmath206 so that @xmath207 .",
    "after taking these @xmath2 steps , the total error in @xmath206 will be @xmath208 the first term is the sum of the local truncation errors caused by taking @xmath2 steps each of size @xmath205 .",
    "the second term is the sum of the interpolation errors : note that to advance @xmath209 , an evaluation of @xmath210 in between @xmath107 and @xmath183 , in general , is required for the non - stiff neighbours of @xmath209 and this incurs an interpolation error of size @xmath202 . therefore the error in @xmath211 is also @xmath202 and the error in @xmath209 is @xmath212 .",
    "it is clear that ( [ toterr ] ) simplifies to @xmath213 and so for our multirate method to be globally @xmath0 order , we require @xmath214  that is , we can afford for the order of the interpolation to be one less than the order of the integrator .",
    "for example , if our integrator is fourth order ( @xmath215 ) , we need to be able to construct cubic interpolants during run time .",
    "if our integrator is second order , then linear interpolation should be sufficient  as observed in @xcite .",
    "we will now illustrate how these interpolants are constructed by taking the classical 4th order ( non - adaptive ) runge - kutta formula as an example and applying it to the autonomous ode system @xmath216 :    .coefficients in classical rk4 [ cols= \" < , < ,",
    "< , < , < \" , ]      we used our multirate code to solve the simple wave equation @xmath217 . by discretizing using the method of lines and one - sided ( `` upwind '' ) differences in space , we obtained @xmath2 coupled ordinary differential equations which were solved using the initial condition @xmath218 and periodic boundary conditions .",
    "unlike the axisymmetric step equations , this discretization of the wave equation does not have any time singularities and we expect fourth order convergence for every component .",
    "this is confirmed in figure [ fig : convergence ] .",
    "although @xmath181 and @xmath219 constantly change because our algorithm uses adaptive step size control , we take @xmath220 as a measure of the average step size where @xmath221 is the final integration time . for the single rate method ,",
    "@xmath2 is the number of steps and for the multirate method , @xmath2 is the total number of micro - steps . in the multirate code",
    ", a maximum macro - stepsize @xmath222 was imposed , and all but the first and final macro - steps had size 1 .",
    "the exact solution comes from solving the linear system of odes exactly using an eigenfunction expansion .",
    "as the integration progresses , the fraction of components that has to be reintegrated increases gradually as the solution broadens and its amplitude decreases : see figure [ fig : wave ] .",
    "a matlab multirate code that produces the results in figure [ fig : wave ] is given in the appendix .",
    "figure [ fig5](a ) shows the results of an integration with @xmath223 .",
    "note that only those steps which are near the facet tend to pack closely together , but steps which are far away move relatively slowly and do not deviate significantly from their initial uniform configuration .",
    "this expanding front of closely packed steps represents the @xmath224 expansion of the facet radius @xcite .",
    "figure [ fig5](b ) illustrates the separation in time scales of the solution components and shows which components of the solution are integrated for a second time .",
    "as expected , our algorithm takes large time steps for components which are far away from the facet .",
    "near the facet and the collapsing top step , many relatively small steps are taken .",
    "for the rapidly varying components in this figure , only a representative sample of the meshpoints @xmath138 from the @xmath170 integration are shown .",
    "in contrast , when @xmath225 , steps can be closely packed even away from the facet . the plots in figure [ fig6 ] show that a step bunching instability arises when @xmath226 is sufficiently small and are qualitatively very different to those in figure [ fig5 ] .",
    "the instability originates from steps with smaller radii and gradually spreads outwards so that more and more steps bunch up .",
    "our multirate scheme performs a second integration when bunching and local stiffness arise : therefore , our algorithm gradually becomes less efficient over time .",
    "however , as long as the fraction of bunched steps is not too large , our algorithm remains competitive compared to a standard adaptive 4th/5th order runge - kutta code .",
    "when the fraction of bunched steps becomes close to unity , the optimal strategy is to have the algorithm detect this automatically , and then switch to a fully implicit , single - rate stiff solver .",
    "we leave this as future work , noting that inversion of the pentadiagonal jacobian only costs @xmath227 operations ( where @xmath2 is the total number of existing steps ) .",
    "in this paper , we present a multirate integration scheme that is designed to efficiently solve the systems of odes that arise in the relaxation of crystal mounds .",
    "these odes have two properties that call for a multirate strategy : the singular collapse of the innermost step and local stiffness .",
    "our method automatically detects singular / stiff components in the solution and disregards them when computing the size of the bulk ( macro ) time step .",
    "the result is that the bulk timestep can be much larger than in a single rate method .",
    "the trade - off is a re - integration of the stiff components which usually consists of a small fraction of the total number of equations in the ode system .",
    "our method is globally fourth order when applied to odes which have sufficiently smooth solutions  for example , the step equations studied in  @xcite and the wave equation discretized through the method of lines in section [ subsec : error - spread ] .",
    "however , the time singularities present in the axisymmetric step - flow equations mean that near times of collapse , the integration of steps near the facet suffers a loss in accuracy . to specifically deal with the singular inner trajectories , our method couples a simple euler routine to the bulk solver . given that the truncation error reduces to @xmath228 near the collapse time , independent of the method order , simple euler is the preferred method because it is computationally cheaper .",
    "furthermore , the use of linear interpolation to extract collapse times is consistent with the method s order .",
    "the high order accuracy of our algorithm ( when applied to bulk steps ) relies on the ability to generate high order interpolants during the run - time of a one - step integration method .",
    "our algorithm generates these interpolants by using the intermediate stage function evaluations of an embedded runge - kutta ( rk ) formula .",
    "specifically , our method computes @xmath229 order interpolants that are consistent with the @xmath230 order accuracy of the integrator .",
    "however , for general @xmath0 order rk formulae , we do not know if it is always possible to construct interpolants that have order @xmath231 .    we see four main possible extensions to this work . the first is to generalize our multirate paradigm so that it can be used for ( i ) higher order runge - kutta formulae and ( ii ) multistep methods ( e.g. bdf , adams etc . ) we believe that it should be possible to make _ any _ method multirate  the main obstacle in doing this is to derive interpolants of a suitably high order .    the second is to explore in more detail the types of pdes that our multirate method can apply to",
    ". typically , large systems of odes result from discretizations of pdes and it is for large ode systems that our method becomes competitive with single rate methods .",
    "we think that a basic requirement of the discretization is that it should be strongly local",
    ". however , we have not fully explored which discretizations are strongly local and which are not .",
    "for example , a one - sided , upwind discretization @xmath232 of the advection equation @xmath233 is strongly local only when @xmath234 . for @xmath235 ,",
    "a kronecker delta initial condition is unstable and does _ not _ remain localized . a discretization using centered differences @xmath236 yields a system of odes that is never strongly local for any @xmath237 . for nonlinear equations , our method seems to be efficient for step - flow like odes with repulsive dipolar step - step interactions .",
    "we were able to show that the linearized step flow odes are strongly local ; however , we do not know if linearizing an ode system is always sufficient to show strong locality .",
    "the third is to explore how the choice of parameters @xmath238 and @xmath239 in algorithm [ algorithm2 ] affect the efficiency of the integration and if there are optimal values of @xmath238 and @xmath239 . a `` good '' choice for @xmath238 and @xmath239 will result in small number of re - integrated components and a large macro - time step .",
    "if @xmath238 is too large and @xmath239 too small , the algorithm behaves like a single rate method . on the other hand ,",
    "if @xmath238 is too small and @xmath239 is too large , many non - stiff components will be re - integrated along with the stiff ones , rendering the method inefficient .",
    "furthermore , our choice of @xmath147 as the @xmath143 percentile of the ltes is somewhat arbitrary ( but seems to generate reasonable results ) .",
    "another possibility is to take the mean  this amounts to increasing the sensitivity of the bulk step size to the presence of one or two extremely stiff components .",
    "clearly , the performance of our multirate method is tied to the distribution of ltes , its moments , and identification of the `` largest errors '' .",
    "quantification of the `` largest errors '' and deciding which moments to use is work in progress . in summary",
    ", this work contributes to the currently growing body of research in multirate methods .",
    "we hope that the strategies adopted in this paper can be carried over to other physical problems and used to improve the efficiency and accuracy of future multirate algorithms .",
    "* acknowledgements * + we thank dionisios margetis for many helpful discussions and meetings .",
    "rrr was partially supported by nsf grant dms-0813648 .",
    "here we give the details of a matlab multirate code to solve a wave equation .",
    "% parameters for integrator desired_error = 1e-6 ; % desired error per step mr = 1 ; % set mr=1 for multirate mode , mr=0 for single rate t= 20 ; t = 0 ; dt = 0.1 ; dt_max = 1.0 ; k = -3 ; p = 30 ; % approx percentage of components to reintegrate safety = 0.95 ;          while t < t      [ unew , error , k ] = rk_onestep(t , u , dt,[1 n ] ) ;           % % % % % start of multirate modification % % %      if mr = = 1               % flag large errors          flags = error > 10^k*percentile(error , p ) ;                  for i=1:length(flags )              if flags(i ) = = 1                  r = i ;                  break ;              end          end          for j = length(flags):-1:1              if flags(j ) = = 1                  s = j ;                  break ;              end          end          % just to be safe          r = r - w ;          s = s+w ;          [ unew , num_micro_steps ] = micro_integrate(t , t+dt , u , unew , ...",
    "[ r s],k , desired_error*1e-3 ) ;      end      % % % end of multirate modification % % %            max_error = max ( max(error(1:r-1 ) ) , max(error(s+1:end ) ) ) ;      r = ( desired_error / max_error ) ^(1/5 ) ;           if r<1 % step failed          dt = dt*safety*max(0.1,r ) ;           trynum = trynum+1 ;          if trynum>10              sprintf('10 failed attempts ! ' )              return          end      elseif r>1 % step succeeded          [ r s ( s - r ) ( s - r)/n ]          t = t+dt ;          u = unew ;          trynum = 0 ;          numsteps = numsteps+1 ;               dt = dt*safety*min(5,r ) ;                           if t+dt > t              dt = ( t - t ) ;          end                   if dt > dt_max              dt = dt_max ;          end             end             if t > t1 & & plot_number = = 1                  subplot(4,2,1 )          plot(x , unew,'linewidth',2 ) ;          xlabel('x ' ) ; ylabel('u(x , t ) ' ) ;          tit = sprintf('t=%f',t1 ) ;           title(tit ) ;          axis([-l/2 l/2 0 1 ] ) ;          subplot(4,2,3 )          spy(flags,20 )          title('flagged components ' ) ;          plot_number = 2 ;      elseif t > t2 & & plot_number = = 2          subplot(4,2,2 )          plot(x , unew,'linewidth',2 ) ;          xlabel('x ' ) ; ylabel('u(x , t ) ' ) ;          tit = sprintf('t=%f',t2 ) ;           title(tit ) ;          axis([-l/2 l/2 0 1 ] ) ;          subplot(4,2,4 )          spy(flags,20 )          title('flagged components ' ) ;          plot_number=3 ;      elseif t > t3 & & plot_number = = 3          subplot(4,2,5 )          plot(x , unew,'linewidth',2 ) ;          xlabel('x ' ) ; ylabel('u(x , t ) ' ) ;          tit = sprintf('t=%f',t3 ) ;           title(tit ) ;          axis([-l/2 l/2 0 1 ] ) ;          subplot(4,2,7 )          spy(flags,20 )          title('flagged components ' ) ;          plot_number=4 ;      elseif t > t4 & & plot_number = = 4          subplot(4,2,6 )          plot(x , unew,'linewidth',2 ) ;          xlabel('x ' ) ; ylabel('u(x , t ) ' ) ;          tit = sprintf('t=%f',t4 ) ;           title(tit ) ;          axis([-l/2 l/2 0 1 ] ) ;          subplot(4,2,8 )          spy(flags,20 )          title('flagged components ' )      end       end            y_current = y1 ; t = t1 ; trynum = 0 ; numsteps = 0 ; while t < t2           [ y_new , error ] = rk_onestep(t , y_current , dt,[r-2,s+2 ] ) ;           r = ( desired_error / max(error(r : s ) ) ) ^(1/5 ) ;      if r<1 % step failed          dt = dt*max(0.1,r ) ; trynum = trynum+1 ;          if trynum>10              sprintf('10 failed attempts ! ' )              return          end      elseif r>1 % step succeeded          t = t+dt ; numsteps = numsteps+1 ;          trynum = 0 ;                   y_new(r-2 ) = interpolate(t , y1(r-2),y2(r-2),t1,t2,k(r-2 , : ) ) ;          y_new(r-1 ) = interpolate(t , y1(r-1),y2(r-1),t1,t2,k(r-1 , : ) ) ;          y_new(s+1 ) = interpolate(t , y1(s+1),y2(s+1),t1,t2,k(s+1 , : ) ) ;          y_new(s+2 ) = interpolate(t , y1(s+2),y2(s+2),t1,t2,k(s+2 , : ) ) ;                           y_current = y_new ;          dt = dt*min(5,r ) ;                    if t+dt > t2              dt = ( t2-t ) ;          end               end end y2 = y_current ;              a2 = 1/5 ; a3 = 3/10 ; a4 = 3/5 ; a5 = 1 ; a6 = 7/8 ; b21 = 1/5 ; b31 = 3/40 ; b32 = 9/40 ; b41 = 3/10 ; b42 = -9/10 ; b43 = 6/5 ; b51 = -11/54 ; b52 = 5/2 ; b53 = -70/27 ; b54 = 35/27 ; b61 = 1631/55296 ; b62 = 175/512 ; b63 = 575/13824 ;   b64 = 44275/110592 ; b65 = 253/4096 ;         k1 = dt*f(t , y , cpt ) ; k2 = dt*f(t+a2*dt , y+b21*k1,cpt ) ; k3 = dt*f(t+a3*dt , y+b31*k1+b32*k2,cpt ) ; k4 = dt*f(t+a4*dt , y+b41*k1+b42*k2+b43*k3,cpt ) ; k5 = dt*f(t+a5*dt , y+b51*k1+b52*k2+b53*k3+b54*k4,cpt ) ; k6 = dt*f(t+a6*dt , y+b61*k1+b62*k2+b63*k3+b64*k4+b65*k5,cpt ) ; k = [ k1 ' k2 ' k3 ' k4 ' k5 ' k6 ' ] ;                                                    m.  kitamura , m.  nishioka , j.  oshinowo , y.  arakawa , in - situ fabrication of self - aligned ingaas quantum dots on gaas multiatomic steps by metalorganic chemical vapor deposition , appl .",
    "66  ( 26 ) ( 1995 ) 36633665 .",
    "j.  g. mclean , b.  krishnamachari , d.  r. peale , e.  chason , j.  p. sethna , b.  h. cooper , decay of isolated features driven by the gibbs - thomson effect in an analytic model and a simulation , phys . rev .",
    "b 55  ( 3 ) ( 1997 ) 1811  1823 .        a.  ichimiya , y.  tanaka , k.  ishiyama , quantitative measurements of thermal relaxation of isolated silicon hillocks and craters on the si(111)-(7x7 ) surface by scanning tunneling microscopy , phys .",
    "76  ( 25 ) ( 1996 ) 4721  4724 ."
  ],
  "abstract_text": [
    "<S> we present a multirate method that is particularly suited for integrating the systems of ordinary differential equations ( odes ) that arise in step models of surface evolution . </S>",
    "<S> the surface of a crystal lattice , that is slightly miscut from a plane of symmetry , consists of a series of terraces separated by steps . under the assumption of axisymmetry , </S>",
    "<S> the step radii satisfy a system of odes that reflects the steps response to step line tension and step - step interactions . </S>",
    "<S> two main problems arise in the numerical solution of these equations . </S>",
    "<S> first , the trajectory of the innermost step can become singular , resulting in a divergent step velocity . </S>",
    "<S> second , when a step bunching instability arises , the motion of steps within a bunch becomes very strongly stable , resulting in `` local stiffness '' . </S>",
    "<S> the multirate method introduced in this paper ensures that small time steps are taken for singular and locally stiff components , while larger time steps are taken for the remaining ones . </S>",
    "<S> special consideration is given to the construction of high order interpolants during run time which ensures fourth order accuracy of scheme for components of the solution sufficiently far away from singular trajectories .    </S>",
    "<S> multirate , runge kutta , interpolation , stiffness , step equations    65l05 , 65l06 , 82d25 </S>"
  ]
}