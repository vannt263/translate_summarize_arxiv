{
  "article_text": [
    "this article is on the one hand on models of weak arithmetics and on the other on proof complexity , i.e. the question of how long formal proofs of tautologies have to be in given proof systems .",
    "therefore the introduction will consist of two parts , one for each subject .",
    "models of weak arithmetics , like @xmath3 , have been extensively studied for several reasons .",
    "they are possibly the simplest objects whose theories bear enough strength to do a good part of mathematics in , yet they are weak enough to allow for a certain kind of constructiveness . the latter has been demonstrated over and over again by various results connecting weak arithmetic theories with complexity classes and computability .",
    "we are interested in the strength of the theory obtained by restricting our objects of reasoning to a small initial part of a given model .",
    "since a two - sorted theory , such as , is much stronger on its number part than on its set part , it is likely that such a cut is a model of a supposedly much stronger theory .",
    "indeed we will see in section  [ sec : polylog cuts ] that certain cuts of models of  are models of the provably stronger theory @xmath1 .",
    "this strengthens a result by paris and wilkie @xcite@xcite , who show that such cuts are models of @xmath4 .",
    "in fact they work in a more general setting and , following our argumentation , their result readily implies the sub exponential simulation of @xmath5-frege by @xmath2-frege from bonet , domingo , gavald , maciel , and pitassi @xcite .",
    "proof complexity , on the other hand , more or less began when cook and reckhow @xcite discovered the close connection between the lengths of formal proofs in propositional proof systems and standard complexity classes .",
    "this connection yields a possibility of dealing with the @xmath6 question by asking , whether there exists a propositional proof system that is polynomially bounded .",
    "we will not directly address this question here , but rather explore the relative strengths of two major proof systems , frege and bounded depth frege .",
    "these proof systems have been extensively studied , due to their natural appearance as classical calculi , such as gentzen s pk , and it is well known that frege systems are stronger than bounded depth frege systems , as the former system has polynomial size proofs for the pigeonhole principle ( see @xcite ) , while the latter does not ( see @xcite and @xcite ) . lately ,",
    "filmus , pitassi and santhanam @xcite have proved a sub exponential simulation of frege by bounded depth frege using a combinatoric argument . in section  [ sec : impl proof cmpl ] we will obtain the same result by an application of our result about cuts to the provability of the reflection principle for frege in bounded depth frege . currently cook , ghasemloo and nguyen @xcite are working on a purely syntactical proof that gives a slightly better result with respect to the strength of the simulated proof system .",
    "the paper is built - up as follows . in section [ sec : preliminaries ] we briefly recapture some basics about complexity theory , bounded arithmetic , proof complexity and the various connections between them .",
    "as this is only expository it might be helpful to consult some of the references for a more detailed introduction ( see @xcite , @xcite and @xcite ) .",
    "after that , in section  [ sec : polylog cuts ] we prove a formalization of nepomnjascij s theorem in the polylogarithmic cut of a model of @xmath0 . using a standard algorithm for evaluating circuits and then applying the formalized version of nepomnjascij s theorem we can conclude that this cut is indeed a model of @xmath1 .",
    "finally , in section  [ sec : impl proof cmpl ] , we apply this result to prove that a version of the bounded reflection principle of frege is provable in @xmath0 .",
    "this , together with a standard argument linking the provability of reflection principles with simulation results , yields the sub exponential simulation of frege by bounded depth frege .",
    "we assume familiarity with turing machines , circuits and standard complexity classes such as @xmath7 , @xmath8 , @xmath9 , @xmath10 , @xmath11 and so on .",
    "see for example @xcite for an introduction .",
    "we will not work a lot within these classes , but rather apply known relations between such classes and weak arithmetic theories .",
    "we will work in a two - sorted arithmetic setting , having one sort of variables representing numbers and the second sort representing bounded sets of numbers .",
    "we identify such bounded subsets with strings .",
    "see @xcite for a thorough introduction .",
    "the underlying language , denoted , consists of the following relation , function and constant symbols:@xmath12    an -structure @xmath13 consists of a first - sort universe @xmath14 of numbers and a second - sort universe @xmath15 of bounded subsets of numbers .",
    "if @xmath13 is a model of the two - sorted theory @xmath0 ( see [ sec vz ] ) , then the functions @xmath16 and @xmath17 are the addition and multiplication on the universe of numbers . @xmath18 and @xmath19 are interpreted as the appropriate elements zero and one with respect to addition and multiplication .",
    "the relation @xmath20 is an ordering relation on the first - sort universe .",
    "the function @xmath21 maps an element of the set sort to its largest element plus one ( i.e. to an element of the number sort ) .",
    "the relation @xmath22 is interpreted as equality between numbers , @xmath23 is interpreted as equality between bounded sets of numbers .",
    "the relation @xmath24 holds for a number @xmath25 and a set of numbers @xmath26 if and only if @xmath25 is an element of @xmath26 .",
    "the standard model of two - sorted peano arithmetic will be denoted as @xmath27 .",
    "it consists of a first - sort universe @xmath28 and a second - sort universe @xmath29 of all finite subsets of @xmath30 .",
    "the symbols are interpreted in the usual way .",
    "we denote the first - sort ( number ) variables by lower - case letters @xmath31 , and the second - sort ( set ) variables by capital letters @xmath32 . in case",
    "it helps to describe the meaning of a variable we will use lower case words for first - sort and words starting with a capital letter for second - sort variables .",
    "we can build formulas in the usual way , using two sorts of quantifiers , number quantifiers and string quantifiers . a number quantifier @xmath33 ( @xmath34 )",
    "is bounded if it is of the form @xmath35 ( @xmath36 ) for some number term @xmath37 .",
    "a string quantifier @xmath38 ( @xmath39 ) is bounded if it is of the form @xmath40 ( @xmath41 ) for some number term @xmath37 .",
    "a formula is bounded iff all its quantifiers are .",
    "all formulas in this paper will be bounded .",
    "a formula @xmath42 is in @xmath43 ( or @xmath44 ) if it uses no string quantifiers and all number quantifiers are bounded .",
    "a formula @xmath42 is a @xmath45 ( or @xmath46 ) if it is of the form @xmath47 ( or @xmath48 ) , where @xmath49 ( or @xmath50 , respectively ) .",
    "if a relation or predicate can be defined by both a @xmath51 and a @xmath52 formula , then we call it @xmath53 definable",
    ". the _ depth _ of a formula is the maximal number of alternations of its logical connectives and quantifiers .    as mentioned before we will represent a bounded set of numbers @xmath26 by a finite string @xmath54 such that @xmath55 if and only if @xmath56 .",
    "we will abuse notation and identify bounded sets and strings , i.e. @xmath26 and @xmath57 .",
    "further , we will encode monotone propositional formulas inductively as binary trees in the standard way , giving a node the value @xmath19 if it corresponds to a conjunction and the value @xmath18 , if it corresponds to a disjunction .",
    "binary trees are encoded as strings as follows .",
    "if position @xmath58 contains the value of a node @xmath59 , then the value of its left successor is contained in position @xmath60 , while the value of its right successor is in @xmath61 .",
    "we restate some basic definitions introduced in @xcite .",
    "[ def pps ] a _ propositional proof system ( pps ) _ is a surjective polynomial - time function @xmath62 , where @xmath63 is the set of propositional tautologies ( in some natural encoding ) .",
    "a string @xmath64 with @xmath65 is called a _ @xmath66-proof _ of @xmath67 .",
    "we can define a quasi ordering on the class of all pps as follows .",
    "[ def : simulation ] let @xmath68 be propositional proof systems .",
    "@xmath69    @xmath66 simulates @xmath70 ( in symbols @xmath71 ) , iff there is a polynomial @xmath72 , such that for all @xmath73 there is a @xmath74 with @xmath75 , such that for all @xmath76 with @xmath77 , @xmath78 .",
    "if there is a polynomial time machine that takes @xmath70-proofs and produces @xmath66-proofs for the same formula we say that @xmath66 p - simulates @xmath70 ( in symbols @xmath79 ) .",
    "if @xmath66 and @xmath70 mutually ( p-)simulate each other , we say that they are ( p-)equivalent ( in symbols @xmath80 and @xmath81 , respectively ) .    in this article we will be mainly interested in bounded depth frege systems and some of their extensions .",
    "a frege system is a typical textbook proof system , such as gentzen s propositional calculus pk .",
    "we will only sketch a single rule of such a system as an example and refer the interested reader to standard logic textbooks .",
    "here , @xmath82 and @xmath83 are sets of formulas while @xmath84 is a formula .",
    "@xmath85 is read as `` the conjunction of all formulas in @xmath83 implies the disjunction of all formulas in @xmath82 '' .",
    "the cut rule therefore says that , if @xmath83 implies @xmath84 or @xmath82 , and @xmath83 and @xmath84 imply @xmath82 , then @xmath83 already implies @xmath82 .",
    "the formula @xmath84 is called the _ cut formula_.    in a bounded depth frege system the depths of all formulas in a derivation are bounded by some global constant .",
    "this is equivalent to being representable by an @xmath2 circuit .",
    "thus we also call bounded depth frege @xmath2-frege .",
    "if the formulas are unbounded , we speak of @xmath86-frege or simply of frege .",
    "we readily get    @xmath87 .",
    "a pps @xmath66 is _ polynomially bounded _",
    "iff there is a polynomial @xmath72 such that every tautology @xmath67 has a @xmath66-proof @xmath64 with @xmath88 .",
    "we are interested in the existence of polynomially bounded pps .",
    "this is , at least in part , due to the following theorem .",
    "@xmath89    an easier task than searching for a polynomially bounded pps might be to find some pps with sub exponential bounds to the lengths of proofs .",
    "this corresponds to the question , whether sub exponential time nondeterministic turing machines can compute @xmath90-complete languages . to explore the existence of such systems we generalize definition  [ def : simulation ] .",
    "let @xmath68 be propositional proof systems and @xmath91 a family of increasing functions on @xmath30 .",
    "@xmath69    @xmath66 @xmath91-simulates",
    "@xmath70 ( in symbols @xmath92 ) , iff there is a function @xmath93 , such that for all @xmath73 there is a @xmath74 with @xmath75 , such that for all @xmath76 with @xmath77 , @xmath94 .    if there is an @xmath95-machine that that takes @xmath70-proofs and produces @xmath66-proofs for the same formula we say that @xmath66 @xmath91-computably simulates @xmath70 ( in symbols @xmath96 ) .",
    "if @xmath66 and @xmath70 mutually @xmath91-(computably ) simulate each other , we say that they are @xmath91-(computably ) equivalent ( in symbols @xmath97 and @xmath98 , respectively ) .",
    "we say a pps @xmath66 _ sub exponentially simulates _ a pps @xmath70 iff the above @xmath91 can be chosen as a class of @xmath99 functions .",
    "the base theory we will be working with is @xmath0 .",
    "it consists of the following axioms :    here , the axioms * basic 1 * through * basic 12 * are the usual axioms used to define peano arithmetic without induction ( @xmath100 ) , which settle the basic properties of addition , multiplication , ordering , and of the constants 0 and 1 .",
    "the axiom * l1 * says that the length of a string coding a finite set is an upper bound to the size of its elements .",
    "* l2 * says that @xmath101 gives the largest element of @xmath102 plus @xmath103 .",
    "* se * is the extensionality axiom for strings which states that two strings are equal if they code the same sets . finally , * @xmath43-comp * is the comprehension axiom schema for @xmath43-formulas ( it is an axiom for each such formula ) and implies the existence of all sets , which contain exactly the elements that fulfill any given @xmath43 property .",
    "the theory  proves the induction axiom schema for @xmath43 formulas @xmath104 : @xmath105    when speaking about theories we will always assume that the theories are two - sorted theories as in @xcite .",
    "the following is a basic notion :    [ def : two - sorted definabilty ] let @xmath106 be a theory over the language @xmath107 and let @xmath104 be a set of formulas in the language @xmath108 .",
    "a number function @xmath37 is @xmath109-definable in a theory @xmath110 iff there is a formula @xmath111 in @xmath104 such that @xmath110 proves @xmath112 and it holds that @xmath113 a string function @xmath91 is @xmath109-definable in a theory @xmath110 iff there is a formula @xmath114 in @xmath104 such that @xmath110 proves @xmath115 and it holds that @xmath116 finally , a relation @xmath117 is @xmath109-definable iff there is a formula @xmath118 in @xmath119 such that it holds that @xmath120    moreover we wish to talk about sequences coded by strings or numbers . for a string @xmath102 we let",
    "@xmath121 $ ] be the @xmath122th bit of @xmath102 . assuming a tupling function @xmath123 we can also talk of @xmath124-ary relations for any constant @xmath124 .",
    "we refer to @xmath125 $ ] , to say that the objects @xmath126 are in the relation @xmath102 ( which is equivalent to saying that the predicate @xmath102 holds for the number @xmath127 , i.e. that the @xmath102 contains that number as an element ) . for the sake of simplicity we also refer to @xmath128 $ ] by @xmath129 $ ] .    using @xmath124-ary relations we can also encode sequences of bounded numbers @xmath130 by @xmath131x[\\langle i,1\\rangle]\\dots x[\\langle i , k\\rangle]$ ] in binary .",
    "matrices and so on can obviously be formalized in the same way .    given a string",
    "@xmath132 $ ] representing a @xmath124-ary relation , we denote the @xmath133-ary substring with parameters @xmath134 by @xmath135 $ ] .",
    "for example we refer to the element @xmath136 of a given matrix @xmath137 $ ] as @xmath138 $ ] , a string representing @xmath136 in binary .",
    "observe that this substring can be @xmath43 defined in @xmath0 .",
    "given a number @xmath58 we denote by @xmath139 the @xmath140th number in the sequence encoded by @xmath58 .",
    "to do this we assume a fixed @xmath43 definable encoding of numbers that is injective .",
    "the sequence itself will be addressed as @xmath141 .",
    "as above , we can also talk about matrices , etc . in this way , i.e. read such a sequence as a sequence of @xmath124-tuples .",
    "we want to identify strings of short length with sequences of numbers .",
    "thus , given a string @xmath102 of length @xmath142 we can @xmath43-define ( in @xmath0 ) a number @xmath143 that codes a sequence @xmath141 , such that @xmath121=\\langle x\\rangle_i$ ] for all @xmath144 and vice versa .",
    "we will use @xmath145 and @xmath146 $ ] to denote the above identification .",
    "observe that @xmath25 has to be very small in order to be able to do the above in @xmath0 .      given",
    "a polynomially bounded turing machine @xmath84 in a binary encoding , we can @xmath147 define a predicate @xmath148 , that states that @xmath102 is accepted by @xmath84 .",
    "this can readily be observed , since , provided some machine @xmath84 , there is a constant number of states @xmath149 and the whole computation can be written into a matrix @xmath150 of polynomial size . that @xmath150 is indeed a correct computation",
    "can then be easily checked , because the computations are only local .",
    "more precisely let @xmath151 be given , where the @xmath152 are different states , with @xmath153 being the initial state and @xmath154 being the accepting state and @xmath155 is the transition function with domain @xmath156 and range @xmath157 , which describes what the machine does .",
    "i.e. if @xmath158 , then if the machine is in state @xmath159 and reads @xmath160 , it replaces @xmath160 by @xmath161 , goes into state @xmath162 and moves one position on the tape in the direction @xmath163 .",
    "for our formalization we will assume a function @xmath164 and interpret it in the following way , @xmath165 , where we identify @xmath166 .",
    "let the polynomial @xmath72 bound the running time of @xmath84 , then we can formalize @xmath148 as follows @xmath167\\rangle_1 = x[i]\\land i > 0\\rightarrow \\langle      w[\\langle 0,i,\\cdot \\rangle]\\rangle_2 = 0 \\land \\langle w[\\langle 0,0,\\cdot      \\rangle]\\rangle_2=1)\\land\\\\ & i\\geq{\\left\\vertx\\right\\vert}\\rightarrow(\\langle w[\\langle 0,i,\\cdot \\rangle]\\rangle_1 = 0 \\land      \\langle w[\\langle 0,i,\\cdot\\rangle]\\rangle_2=0)\\land\\\\ & \\langle w[\\langle j , i,\\cdot \\rangle]\\rangle_2      = 0\\rightarrow ( \\langle w[\\langle j+1,i,\\cdot \\rangle]\\rangle_1=      \\langle w[\\langle j , i,\\cdot \\rangle]\\rangle_1)\\land\\\\ &      \\langle w[\\langle j , i,\\cdot \\rangle]\\rangle_2      = \\alpha\\rightarrow ( \\langle w[\\langle j+1,i,\\cdot \\rangle]\\rangle_1=      \\langle\\delta(\\alpha,\\langle w[\\langle j , i,\\cdot \\rangle]\\rangle_1)\\rangle_2\\land\\\\ &      \\hspace{0.2cm}(\\langle\\delta(\\alpha,\\langle w[\\langle j , i,\\cdot \\rangle]\\rangle_1)\\rangle_3=0 \\rightarrow      \\langle w[\\langle j+1,i,\\cdot \\rangle]\\rangle_2=      \\langle\\delta(\\alpha,\\langle w[\\langle j , i,\\cdot \\rangle]\\rangle_1)\\rangle_1)\\land\\\\ &      \\hspace{0.2cm}(\\langle\\delta(\\alpha,\\langle w[\\langle j , i,\\cdot \\rangle]\\rangle_1)\\rangle_3=1 \\rightarrow      \\langle w[\\langle j+1,i{\\mathbin{\\setbox0\\hbox{$-$}\\setbox2\\hbox to\\wd0{\\hss$^{\\mkern1mu\\cdot}$\\hss}\\wd2=0pt\\box2\\box0}}1,\\cdot \\rangle]\\rangle_2=      \\langle\\delta(\\alpha,\\langle w[\\langle j , i,\\cdot \\rangle]\\rangle_1)\\rangle_1)\\land\\\\ &      \\hspace{0.2cm}(\\langle\\delta(\\alpha,\\langle w[\\langle j , i,\\cdot \\rangle]\\rangle_1)\\rangle_3=2 \\rightarrow      \\langle w[\\langle j+1,i+1,\\cdot \\rangle]\\rangle_2=      \\langle\\delta(\\alpha,\\langle w[\\langle j , i,\\cdot \\rangle]\\rangle_1)\\rangle_1))\\land\\\\ &      ( i\\neq i'\\rightarrow ( \\langle w[\\langle j , i,\\cdot \\rangle]\\rangle_2>0\\rightarrow      \\langle w[\\langle j , i',\\cdot \\rangle]\\rangle_2=0))\\land      w[\\langle p({\\left\\vertx\\right\\vert}),i,\\cdot \\rangle]\\rangle_2 = k ) .    \\end{split}\\ ] ]    thus , in plain english , @xmath148 says that there exists a matrix @xmath150 of pairs of numbers that witnesses an accepting computation of @xmath84 . here ,",
    "@xmath168\\rangle$ ] is supposed to code the @xmath140th cell on the turing machine s tape after @xmath122 steps of computations on input @xmath102 .",
    "as noted above , @xmath168\\rangle_1 $ ] is a binary number , which is the value of the cell , @xmath169\\rangle_2 $ ] is a number coding the state the machine is in iff the pointer is on that cell .",
    "the second and third line of the definition say that the tape in the initial step contains @xmath102 padded with zeroes in the end to get the proper length @xmath170 and that the read / write head is in its starting state and position .",
    "the fourth line says that if the read / write head is not on cell @xmath122 , then nothing happens to the content of cell @xmath122 .",
    "the fifth line says that the content of the cell , where the read / write head is in step @xmath140 , is changed according to @xmath155 .",
    "the next three lines tell us where the read / write head moves .",
    "the last line says that there is at most one position on the tape where the read / write head may be at any step and that the state after the last step is accepting .",
    "we also define a @xmath147-predicate @xmath171 that says that @xmath84 reaches configuration @xmath172 from configuration @xmath173 in at most @xmath174 many steps .",
    "this is essentially the same predicate as @xmath175 , with the constraints on the initial and accepting state lifted and instead a constraint added that the first line of computation is @xmath173 and the last is @xmath172 .",
    "we omit the details as it does not severely differ from the above definition of @xmath175 .",
    "the theory  serves as our base theory to describe complexity classes by arithmetical means .    the problem , whether a given monotone formula @xmath176 of size @xmath177 and depth @xmath178 is satisfiable under a given assignment @xmath179 is @xmath2-complete for @xmath86 .",
    "therefore cook and nguyen ( @xcite ) define the class @xmath1 as @xmath0 augmented by the axiom @xmath180 , where @xmath181 so , @xmath182 states that there is an evaluation @xmath173 of the monotone formula represented by @xmath183 under the assignment given by @xmath179 of length at most @xmath184 . more specifically , @xmath183 is a tree - encoding of the formula , where @xmath185 is true , if node @xmath58 is @xmath186 and false , if @xmath58 is @xmath187 .",
    "the evaluation @xmath173 takes the value of the variables given by @xmath179 and then evaluates the formula in a bottom - up fashion using a standard tree encoding .",
    "thus , the value of the formula can be read at @xmath188 .",
    "it is interesting to observe that @xmath182 does not hold in @xmath0 .",
    "this is , since an application of the witnessing theorem for @xmath0 to a proof of @xmath182 would yield an @xmath2-definition of satisfaction for monotone @xmath86 circuits .",
    "this implies that monotone @xmath189 , which is known to be false .      in this section we will remind the reader of a connection between the theory @xmath0 and some of its extensions and certain propositional proof systems ( see also @xcite@xcite ) .",
    "the following predicates will be subsequently used .",
    "they are definable with respect to @xmath0 ( see @xcite ) .",
    "@xmath69    @xmath190 is a @xmath43 formula that says that the the string @xmath102 codes a formula .",
    "@xmath191 is the @xmath192 definable property that the truth assignment @xmath193 satisfies the formula @xmath102 .",
    "@xmath194 is the @xmath195 formula @xmath196 , where @xmath197 is an upper bound to the number of variables in formulas coded by strings of length @xmath101 .",
    "@xmath198 is a @xmath43 definable predicate meaning @xmath199 is a depth @xmath161 frege proof for @xmath84 .",
    "@xmath200 is a @xmath43 definable predicate meaning @xmath199 is a frege proof for @xmath84 .    the following holds    [ fact : vz and bd frege ] the theory @xmath0 proves that @xmath2-frege is sound , i.e. for every @xmath161 @xmath201    [ fact : vnc1 and nc1 frege ] the theory @xmath1 proves that frege is sound , i.e. @xmath202    on the other hand , provability of the universal closure of @xmath43 formulas in @xmath0 and @xmath1 implies the existence of polynomial size proofs of their propositional translations in @xmath2-frege and frege , respectively .",
    "the propositional translation @xmath203 of a @xmath43 formula @xmath204 is a family of propositional formulas built up inductively ( on the logical depth ) as follows .",
    "if @xmath176 is atomic and does not contain second sort variables , we evaluate @xmath176 in @xmath27 , if it contains second sort variables , we have to introduce propositional variables . if @xmath176 is a boolean combination of formulas @xmath205 of lower depth , the translation is simply the same boolean combination of the translations of the @xmath205 . if @xmath176 is @xmath206 or @xmath207 we translate it to the disjunction or conjunction of the translations , respectively . for a proper definition see @xcite .",
    "[ fact : polynomial simulation ] there exists a polynomial @xmath72 such that for all @xmath43 formulas @xmath204 the following holds    @xmath69    if @xmath208 , then there exist bounded depth frege proofs of all @xmath209 of length at most @xmath210 , for any @xmath211 .",
    "if @xmath212 , then there exist frege proofs of all @xmath209 of length at most @xmath210 , for any @xmath211 .    these proofs are effective in the sense that for any such @xmath176 there exists a polynomial - time computable function @xmath213 that maps any tuple @xmath214 to the above proofs of @xmath215 .",
    "facts  [ fact : vz and bd frege ] and [ fact : vnc1 and nc1 frege ] are examples of general principles , the so called _ reflection principles _ , which are defined as follows .",
    "[ reflection principle ] let @xmath66 be a pps . then the _ reflection principle _ for @xmath66 , @xmath216 , is the @xmath217-formula ( w.r.t .",
    "@xmath0 ) @xmath218 where @xmath219 is a @xmath192-predicate formalizing @xmath66-proofs .",
    "reflection principles condense the strength of propositional proof systems . in what follows we will summarize some such results for the proof systems and theories used here .",
    "a detailed exposition can be found in @xcite , chapter x , or in @xcite , chapter 9.3 .",
    "[ thm simulation by reflection ] if @xmath220 then bounded depth frege p - simulates frege",
    ".    we will only give a brief sketch of the proof here and leave out the technical details .",
    "let @xmath176 be a formula and @xmath221 a frege proof of @xmath176 which is witnessed by a turing machine @xmath222 ( cf def  [ def pps ] ) .",
    "since @xmath0 proves @xmath223 , by facts  [ fact : vz and bd frege ] and [ fact : polynomial simulation ] we have polynomial size proofs of its translations @xmath224 in bounded depth frege . bounded depth frege itself , however , is strong enough to verify that a proper encoding of the computation of @xmath222 on input @xmath225 is correct .",
    "thus it can verify that @xmath221 is a frege - proof and , using the translation of the reflection principle and the cut rule , conclude @xmath226 . from this",
    "@xmath176 follows , cf .",
    "@xcite lemma  9.3.7 .",
    "given a term @xmath197 and a variable @xmath58 , we can also introduce the @xmath197-bounded version of the reflection principle for some given pps @xmath66 , @xmath227 that claims soundness only for @xmath197-bounded proofs .",
    "[ bounded reflection ] let @xmath197 be a @xmath228-term , @xmath58 a first - sort variable and @xmath66 a pps .",
    "then the _ bounded reflection principle _",
    "@xmath227 is the formula @xmath229    we can now generalize theorem  [ thm simulation by reflection ] in the following way .",
    "[ thm simulation by bounded reflection ] let @xmath197 be a @xmath228-term and @xmath58 a number variable . if @xmath230 for @xmath58 large enough and if @xmath231 then for every propositional formula @xmath176 with a frege proof of length @xmath232 there is a bounded depth frege proof of @xmath176 of length @xmath233 .",
    "this proof can be efficiently constructed .",
    "the proof is the same as that of theorem  [ thm simulation by reflection ] . using the bounded reflection principle",
    "we can encode frege proofs of length @xmath232 as bounded depth frege proofs of length @xmath233 .    as a corollary we get",
    "if @xmath234 for all @xmath235 , then bounded depth frege sub exponentially simulates frege : for all @xmath236 exists @xmath237 , such that the existence of a frege proof of length @xmath238 of a depth @xmath239 formula implies the existence of a depth @xmath161 frege proof of length at most @xmath240 .",
    "we will first introduce the notion of a cut @xmath242 of a given two - sorted arithmetic model @xmath243 . this model theoretic approach provides a very good insight on what actually happens semantically with the small elements of arithmetical models .    [ cut ]",
    "let @xmath244 be a two - sorted arithmetic theory and @xmath245 a model of @xmath244 .",
    "@xmath246 of @xmath26 is any substructure such that    @xmath69    @xmath247 , @xmath248 ,    @xmath249 , @xmath250 ,    @xmath251 is closed under @xmath252 and downwards with respect to @xmath253 ,    @xmath254 , and    @xmath255 is the restriction of @xmath256 to @xmath251 and @xmath257 for all relation and function symbols @xmath258 .",
    "we call this cut the _ polylogarithmic cut _ iff @xmath259    to examine the strength of the theory of such cuts of models of @xmath0 , we will show that a formal connection between efficient computability and @xmath43-definability holds .",
    "this stands in contrast to general bounded subsets , where the connection is presumably only with respect to @xmath147-definability via the predicate @xmath175 ( see on page ) .",
    "the intended theorem is a formalization of nepomnjascij s theorem @xcite ( see also @xcite pg.20 ) .",
    "we will sketch the original proof before starting the formalization .",
    "[ thm nepomnjascij ] let @xmath260 and @xmath261 be constants .",
    "then if the language @xmath262 , the relation @xmath263 is definable by a @xmath43-formula over @xmath30 .",
    "we will prove the theorem by induction on @xmath124 for @xmath264 .",
    "let @xmath265 and @xmath266 .",
    "for any @xmath267 the whole computation can be coded by a number @xmath268 of size @xmath269 .",
    "the existence of such a computation gives the desired @xmath43-definability .",
    "for @xmath270 we write a sequence @xmath271 of intermediate results coding the computation , where @xmath272 codes the starting configuration on input @xmath58 , such that we can verify that @xmath273 is computable from @xmath274 in @xmath275 . by assumption",
    "there exists a @xmath43-formula @xmath276 such that @xmath277 holds iff @xmath273 is computed from @xmath274 . additionally , the whole sequence has length @xmath142 and so we can write the sequence of intermediate results @xmath274 as a number @xmath268 of length @xmath142 . now ,",
    "the @xmath43-definition of @xmath263 is simply @xmath278    we will now formalize this result in @xmath0 as follows    [ thm nepomnjascij_formalized ] let @xmath279 .",
    "let @xmath280 for some @xmath281 and let @xmath282 and @xmath283 . if @xmath284 ( for strings of length @xmath238 ) is computed by turing machine @xmath84 , then there exists a @xmath43 definition in @xmath26 of the @xmath147-predicate @xmath285 on the interval @xmath286 $ ] .",
    "i.e. any @xmath287 , bounded by @xmath288 is @xmath43-definable in @xmath26 and therefore exists in the polylogarithmic cut of @xmath26 .    the following version of the proof stems from a discussion with stephen cook and neil thapen during the sas programme in cambridge .",
    "it is more explicit than the original one and clarifies the argument .",
    "we will inductively on @xmath161 define a @xmath43 relation @xmath289 that states that the @xmath290th cell of the work tape of @xmath84 , starting on configuration @xmath179 and computing for @xmath291 steps via the computation @xmath292 is @xmath293 .",
    "we will bound the quantifiers in such a way that we can conclude that both variables can be of the number sort .",
    "as @xmath161 depends only on @xmath84 and @xmath124 we will be doing this induction outside of the theory to construct @xmath161 many formulas .",
    "we will then prove the above mentioned properties of @xmath294 by @xmath43 induction on @xmath295 .",
    "keep in mind that a cell is given as a pair @xmath296 , where @xmath297 is the actual value of the cell and @xmath298 is a number @xmath299 coding the state the turing machine is in iff the pointer is on that cell and @xmath18 otherwise . as before the transition function",
    "is denoted by @xmath155 .",
    "we let @xmath179 be a string coding the input at the start of the computation .",
    "that is , @xmath179 is a sequence of length @xmath300 , such that @xmath301=1 $ ] , @xmath302=0 $ ] for all @xmath303 and @xmath304 $ ] is the @xmath140th input bit .",
    "we let @xmath305 be a sequence encoding the computation of @xmath84 , such that @xmath306 is the state , the machine is in after @xmath140 steps ( 0 denotes that the read / write head is not on cell @xmath307 , while a greater number gives the state and witnesses that the read / write head is on cell @xmath307 ) .",
    "@xmath308 is the value of cell @xmath307 after @xmath140 steps of the computation .",
    "observe that this also implies that the computation can be encoded as a number , that is , it has to be very short .",
    "this is straight forward from the quantifier bounds .",
    "we can now define @xmath309\\land        \\langle\\mathsf{comp}\\rangle_{\\langle 1,j',1\\rangle } \\approx        i[j',1]{\\large ) } \\land\\\\   & \\phantom{{}\\equiv { } }        [ \\forall j<\\lceil len(i)^{\\frac{1-k\\epsilon}{k}}\\rceil , j'<\\lceil          len(i)^{\\epsilon}\\rceil,\\alpha<{\\left\\verta\\right\\vert}\\\\ & \\phantom{{}\\equiv{}}\\hspace{16pt }        ( \\langle\\mathsf{comp}\\rangle_{\\langle j , j',1\\rangle } = 0\\rightarrow ( \\langle\\mathsf{comp }        \\rangle_{\\langle j , j',0\\rangle } = \\langle\\mathsf{comp}\\rangle_{\\langle        j+1,j',0\\rangle}))\\land\\\\   & \\phantom{{}\\equiv{}}\\hspace{16pt }        ( \\langle\\mathsf{comp}\\rangle_{\\langle j , j',1\\rangle } =        \\alpha\\rightarrow(\\\\ & \\phantom{{}\\equiv{}}\\hspace{24pt }        ( \\langle \\delta(\\alpha,\\langle\\mathsf{comp}\\rangle_{\\langle          j , j',0\\rangle})\\rangle_3=0\\rightarrow       ( \\langle\\mathsf{comp}\\rangle_{\\langle j+1,j',1\\rangle}=\\langle \\delta(\\alpha,\\langle\\mathsf{comp}\\rangle_{\\langle        j , j',0\\rangle})\\rangle_1 \\land\\\\ & \\hspace{183 pt }        \\langle\\mathsf{comp}\\rangle_{\\langle j+1,j',0\\rangle}=\\langle \\delta(\\alpha,\\langle\\mathsf{comp}\\rangle_{\\langle        j , j',0\\rangle})\\rangle_2))\\land\\\\ & \\phantom{{}\\equiv{}}\\hspace{24pt }        ( \\langle \\delta(\\alpha,\\langle\\mathsf{comp}\\rangle_{\\langle          j , j',0\\rangle})\\rangle_3=1\\rightarrow       \\langle\\mathsf{comp}\\rangle_{\\langle j+1,j'{\\mathbin{\\setbox0\\hbox{$-$}\\setbox2\\hbox to\\wd0{\\hss$^{\\mkern1mu\\cdot}$\\hss}\\wd2=0pt\\box2\\box0}}1,1\\rangle}=\\langle \\delta(\\alpha,\\langle\\mathsf{comp}\\rangle_{\\langle        j , j',0\\rangle})\\rangle_1 \\land\\\\ & \\hspace{179 pt }        \\langle\\mathsf{comp}\\rangle_{\\langle j+1,j',0\\rangle}=\\langle \\delta(\\alpha,\\langle\\mathsf{comp}\\rangle_{\\langle        j , j',0\\rangle})\\rangle_2))\\land\\\\ & \\phantom{{}\\equiv{}}\\hspace{24pt }        ( \\langle \\delta(\\alpha,\\langle\\mathsf{comp}\\rangle_{\\langle          j , j',0\\rangle})\\rangle_3=2\\rightarrow       \\langle\\mathsf{comp}\\rangle_{\\langle j+1,j'+1,1\\rangle}=\\langle \\delta(\\alpha,\\langle\\mathsf{comp}\\rangle_{\\langle        j , j',0\\rangle})\\rangle_1 \\land\\\\ & \\hspace{179 pt }        \\langle\\mathsf{comp}\\rangle_{\\langle j+1,j',0\\rangle}=\\langle \\delta(\\alpha,\\langle\\mathsf{comp}\\rangle_{\\langle        j , j',0\\rangle})\\rangle_2))))\\land\\\\ & \\phantom{{}\\equiv{}}\\hspace{16pt }        \\forall\\ell\\neq\\ell'<\\lceil len(i)^{\\epsilon}\\rceil (        \\langle\\mathsf{comp}\\rangle_{\\langle j,\\ell,1\\rangle}>0\\rightarrow        \\langle\\mathsf{comp}\\rangle_{\\langle          j,\\ell',1\\rangle}=0)]\\land\\\\ & \\phantom{{}\\equiv { } }        ( \\langle \\mathsf{cell}\\rangle_1 = \\langle\\mathsf{comp}\\rangle_{\\langle p_1,p_2,0\\rangle})\\land        ( \\langle \\mathsf{cell}\\rangle_2 = \\langle\\mathsf{comp}\\rangle_{\\langle p_1,p_2,1\\rangle } ) .",
    "\\end{split}\\ ] ] it is straightforward to prove by induction on the number of lines in @xmath292 that @xmath292 is uniquely defined by @xmath310 .",
    "we let @xmath311 where @xmath312 is some polynomial depending on the encoding . here",
    "it is vital that @xmath312 can be defined such that @xmath313 is a number in @xmath26 .",
    "this is possible due to the quantifier bounds we used when defining @xmath310 .",
    "thus , @xmath314 is defined by a @xmath43 formula .",
    "informally @xmath314 formalizes that there is a computation @xmath315 that is correct in the sense that we can verify that we get from line to line via the transition function of @xmath84 and gives the appropriate values of the cell at @xmath316 .",
    "observe that the size of the whole computation as presented above is linear in @xmath238 , i.e. that it can be coded as a number in @xmath26 .",
    "we will now proceed by inductively defining @xmath294 and @xmath317 .",
    "assume that @xmath318 has already been defined by a @xmath43 formula over @xmath26 .",
    "we then let @xmath319\\land        \\langle\\mathsf{comp}\\rangle_{\\langle 1,j',1\\rangle } \\approx        i[j',1])\\land\\\\   & \\phantom{{}\\equiv { } }        ( \\forall j<\\lceil len(i)^{\\frac{1-k\\epsilon}{k}}\\rceil\\exists\\mathsf{comp'}<q(len(i))\\forall j'<\\lceil        len(i)^{\\epsilon}\\rceil\\exists \\mathsf{cell}'<{\\left\\verta\\right\\vert}\\forall        j''<{\\left\\verta\\right\\vert}\\\\ & \\phantom{{}\\equiv { } }        ( \\langle\\mathsf{comp}\\rangle_{\\langle          j+1,j',j''\\rangle}\\leftrightarrow \\langle        \\mathsf{cell}'\\rangle_{j''})\\land\\\\ & \\phantom{{}\\equiv { } }        \\mathsf{reach}^{d{\\mathbin{\\setbox0\\hbox{$-$}\\setbox2\\hbox to\\wd0{\\hss$^{\\mkern1mu\\cdot}$\\hss}\\wd2=0pt\\box2\\box0}}1}_a(\\langle \\mathsf{comp}\\rangle_{\\langle        j,\\cdot,\\cdot\\rangle},m^{\\frac{1-k\\epsilon}{k } } ,        j',\\mathsf{cell}',\\mathsf{comp'}))\\land\\\\ & \\phantom{{}\\equiv { } }        ( \\langle \\mathsf{cell}\\rangle_1\\leftrightarrow\\langle\\mathsf{comp}\\rangle_{\\langle p_1,p_2,0\\rangle})\\land        ( \\langle \\mathsf{cell}\\rangle_2=\\langle\\mathsf{comp}\\rangle_{\\langle p_1,p_2,1\\rangle } ) .",
    "\\end{split}\\ ] ] again , we can prove uniqueness of the computation by induction on the number of its lines and let @xmath320 that this is a @xmath43 definition follows by induction and the same argument as for @xmath314 . here",
    ", the predicate @xmath321 takes the role of the transition function in witnessing that each line follows from the preceding one .",
    "the total size again is linear in @xmath238 .",
    "we now can give a @xmath43 definition of the predicate @xmath322 $ ] coding the computation as in @xmath285 on input @xmath102 of length @xmath288 .",
    "we let @xmath322=\\mathsf{cell}\\equiv$ ] @xmath323 where @xmath72 is a polynomial depending on the encoding and @xmath324 is the starting configuration of @xmath84 on input @xmath102 .",
    "informally the above formula says that we compute the configurations of @xmath84 by using the predicates @xmath317 through @xmath314 .",
    "that is , after the application of @xmath317 ( i.e. after making the biggest steps ) we have reached configuration @xmath325 , which we plug into @xmath326 to get configuration @xmath327 and so on .",
    "it remains to show that this definition of @xmath328 $ ] coincides with the real one , i.e. that @xmath329 $ ] follows from an application of the transition function of @xmath84 from @xmath330 $ ] .",
    "we will prove this inductively , depending on @xmath122 .",
    "again let @xmath331 be such that @xmath332 . if @xmath333 the assumption follows straightforwardly from the definition of @xmath314 .",
    "now for bigger @xmath122 . if the @xmath334 , given as above , is bigger then @xmath18 then again the assumption follows from the definition of @xmath310 .",
    "now let @xmath335 be the first index with @xmath336 .",
    "we the have to argue that @xmath337 has the desired property .",
    "this , however , follows straightforward if we can verify this assertion for @xmath337 .",
    "observe that @xmath161 is a constant depending only on @xmath84 and @xmath124 , so we need to make this argument only a constant number of steps to reach @xmath310 , where we know that the assertion holds .",
    "since we can code the whole computation as a @xmath43-formula ( in @xmath26 ) , we can easily deduce a @xmath43-definition of the related set by simply stating that the computation accepts ( i.e. that in the last line of the computation the state is accepting ) .",
    "this concludes the proof .",
    "we can now prove our main result .",
    "[ thm : conclusion nepo ] let @xmath338 and @xmath339 be the polylogarithmic cut",
    ". then @xmath340 .",
    "we have to prove that for all strings @xmath341 , representing a formula @xmath176 as a tree and assignments @xmath342 to its variables ( i.e. leafs in the tree representation ) a string @xmath173 exists in @xmath257 that contains all values of @xmath176 s subformulas as in the definition of @xmath182 in section  [ sec : ext of vz ] and satisfies the inductive conditions of @xmath182 .",
    "however , by @xmath43-comprehension and the formalized nepomnjascij s theorem it suffices to describe an algorithm that computes , for given @xmath343 and @xmath179 , whether @xmath122 belongs to @xmath173 in @xmath344 for some @xmath235 and @xmath345 .",
    "the following is a recursive algorithm computing the value of @xmath346 $ ] , given @xmath347 and @xmath122 . `",
    "nodevalue(g , i , i ) `    * ` boolean left ; boolean right ; ` * ` if i>2`@xmath348`|g| ` * * ` output ( 0 ) ; end ; ` * ` else if i>|g| ` * * ` output ( i[i-|g| ] ) ; end ; ` * ` else if g[i]=1 ` * * ` left : = nodeval(g , i,2i ) ; ` * * ` right : = nodeval(g , i,2i+1 ) ; ` * * ` output ( left and right ) ; end ; ` * ` else if g[i]=0 ` * * ` left : = nodeval(g , i,2i ) ; ` * * ` right : = nodeval(g , i,2i+1 ) ; ` * * ` output ( left or right ) ; end ; ` * ` else ` * * ` output ( 0 ) ; end ; `    observe that the algorithm at any given point only stores a constant amount of data per level of the tree @xmath183 and therefore uses only @xmath349 space .",
    "the number steps the algorithm makes is clearly polynomial in the size of @xmath183 .",
    "therefore by theorem  [ thm nepomnjascij_formalized ] , for every monotone formula @xmath176 , representable as a tree in @xmath13 , we get a @xmath43 formula @xmath350 , such that @xmath351 $ ] .",
    "observe that @xmath350 depends on the size of @xmath176 and on its logical depth , as the first is essentially the size of the input for the machine , that @xmath352 codes , while the latter determines the longest iterations in the recursive algorithm .",
    "applying the comprehension schema in @xmath0 , i.e. in @xmath26 , this verifies the existence of a @xmath173 as in @xmath182 for all formulas represented by trees in @xmath13.therefore @xmath182 holds in @xmath13 and so @xmath353 .",
    "we now wish to apply the above results to propositional proof systems .",
    "more precisely we wish to show that theories of small cuts of a model of a given theory @xmath110 correspond to stronger proof systems than @xmath110 does .",
    "an elegant way of showing such a statement is via the _ reflection principles _ of the given proof systems , i.e. the statement that the proof system is correct , as explained in section  [ sec : rel ba pps ] . with their help",
    "we can conclude the following recent result of filmus , pitassi and santhanam @xcite .",
    "[ thm filpitsat ] every frege system is sub exponentially simulated by @xmath2-frege systems .    by theorem  [ thm simulation by bounded reflection ]",
    "we have to prove the polylogarithmically bounded reflection principle for frege in @xmath0 .",
    "this , by theorem  [ thm : conclusion nepo ] however , corresponds to proving the reflection principle for frege in @xmath1 , which holds by fact  [ fact : vnc1 and nc1 frege ] .",
    "it also follows from theorem  [ thm simulation by bounded reflection ] that this proof can be efficiently computed from the frege proof .",
    "another , related , application is in the separation of propositional proof systems . in @xcite",
    "we proved the following .",
    "[ prop iddo me ] for almost every random 3cnf @xmath84 with @xmath25 variables and @xmath354 clauses , where @xmath162 is a large constant , @xmath355 has polynomially bounded @xmath5-frege proofs .    on the other hand it is well known ( see for example @xcite ) that such formulas have no subexponential refutation in resolution .",
    "thus , this yields an average case separation between resolution and @xmath5-frege . we can now extend this result to an average case separation between resolution and @xmath2-frege as follows .    for almost every random 3cnf @xmath84 with @xmath25 variables and @xmath354 clauses , where @xmath162 is a large constant , @xmath355",
    "has subexponentially bounded @xmath2-frege proofs .    by theorem  [ thm : conclusion nepo ]",
    "the polylogarithmic cut of any @xmath0-model is a model of @xmath1 , therefore also of @xmath4 .",
    "this yields , as in our proof of theorem  [ thm filpitsat ] , that @xmath2-frege subexponentially simulates @xmath5-frege .",
    "the result now follows from proposition  [ prop iddo me ] .",
    "as we have seen cuts of models of weak arithmetics constitute an appropriate way for reasoning about super - polynomial simulations between proof systems .",
    "an advantage in comparison to syntactic arguments is the possible applicability of results in model theory and a more uniform treatment .",
    "this can readily be observed as with our argument , e.g. the work of paris and wilkie @xcite@xcite immediately imply the simulation results from bonet et al .",
    "@xcite .",
    "this leads to interesting possibilities for further research , especially towards the weak automatizability of weak propositional proof systems such as resolution . the underlying theory , which was @xmath0 in our argument ,",
    "must be significantly weakened , however .",
    "if we could take @xmath356 as our base theory , we could reason about whether @xmath357 has the feasible interpolation property in the same way as kraj ' iek and pudl ' ak @xcite , bonet , pitassi and raz @xcite or bonet , domingo , gavald , maciel , and pitassi @xcite .",
    "now , if @xmath357 does not have quasi - polynomial feasible interpolation we know by a result from atserias and bonet @xcite that resolution is not weakly automatizable , so we would be finished .",
    "whether we can actually do it depends on the strength of the theory the polylogarithmic cut of @xmath356 models and if we can formalize some sort of iterated multiplication ( such as in @xcite ) in that theory . also , the security of diffie - hellman seems to be a more appropriate assumption than that of rsa , as the computational power needed to verify the correctness of diffie - hellman seems to be lower .",
    "i want to thank steve cook , jan kraj ' iek and neil thapen for helpful suggestions and discussion , emil je ' abek for his comments and for answering my questions and the participants of the maloa special semester in proof complexity in prague 2011 for enduring a sloppy and sometimes faulty exposition of this proof and still coming up with helpful comments .",
    "i also want to thank the anonymous referees for pointing out various mistakes and for giving interesting suggestions .",
    "a similar construction can be extracted from @xcite and leads to similar results , if perceived in the way we did it here .",
    "i want to thank leszek kolodziejczyk for pointing this out ."
  ],
  "abstract_text": [
    "<S> we study initial cuts of models of weak two - sorted bounded arithmetics with respect to the strength of their theories and show that these theories are stronger than the original one . </S>",
    "<S> more explicitly we will see that polylogarithmic cuts of models of @xmath0 are models of @xmath1 by formalizing a proof of nepomnjascij s theorem in such cuts . </S>",
    "<S> this is a strengthening of a result by paris and wilkie .    </S>",
    "<S> we can then exploit our result in proof complexity to observe that frege proof systems can be sub exponentially simulated by bounded depth frege proof systems . </S>",
    "<S> this result has recently been obtained by filmus , pitassi and santhanam in a direct proof . as an interesting observation </S>",
    "<S> we also obtain an average case separation of resolution from @xmath2-frege by applying a recent result with tzameret . </S>"
  ]
}