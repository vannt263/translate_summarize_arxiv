{
  "article_text": [
    "justification logic is a family of logics of justified beliefs . where epistemic modal logic treats formulas of the form @xmath1 with the intended meaning that an agent knows / believes @xmath2 , in justification logic we consider formulas of the form @xmath3 with the intended meaning that @xmath4 is a justification for @xmath2 - or that the agent has justification @xmath4 for @xmath2 .",
    "the first justification logic was lp , the logic of proofs , and appeared in @xcite by artemov , but it has since developed in a wide system of explicit epistemic logics with notable complexity properties that significantly differ from the corresponding modal logics : while every single - agent justification logic whose complexity has been studied has its derivability problem in @xmath5 ( the second level of the polynomial hierarchy ) , the corresponding modal logics have -complete derivability problems .",
    "furthermore certain significant fragments of these justification logics have an even lower complexity- , or even   in some cases . for an overview of justification logic see @xcite . for an overview of complexity results of ( single - agent ) justification logic , see @xcite .    in epistemic situations we often have multiple agents , so",
    "as it is the case with modal logic , there is a need for a multi - agent justification logic . in @xcite , yavorskaya presents two - agent variations of lp .",
    "these logics feature interactions between the two agents justifications : for @xmath6 , for instance , every justification for agent 1 can be converted to a justification for agent 2 for the same fact and we have the axiom @xmath7 , while @xmath8 comes with the extra axiom @xmath9 , so agent 2 is aware of agent 1 s justifications .    in @xcite",
    ", we extended yavorskaya s logics to two - agent variations of other justification logics , as well as to combinations of two different justification logics .",
    "we then gave tableau procedures to prove that most of these logics were in the second step of the polynomial hierarchy , an expected result which mimics the ones for single - agent justification logics from @xcite .",
    "for some cases , however , we were able to prove -completeness , which was a new phenomenon for justification logic .",
    "in this paper we continue our work from @xcite .",
    "we provide a general family of multi - agent logics .",
    "each member of this family we call @xmath10 , where @xmath11 are parameters of the logic . for @xmath10 we consider @xmath12 agents and the interactions between the agents justifications are described by binary relations on agents , @xmath13 and @xmath14 .",
    "furthermore , not all agents are equally reliable : @xmath15 and @xmath16 are sets of agents , all agents in @xmath15 have consistent beliefs and all agents in @xmath16 have true beliefs .",
    "these concepts are made precise in section [ multidefinitions ] .",
    "it is our goal to provide a flexible system capable of modelling situations of many diverse agents , or diverse types of justifications , allowing for reasonably general interactions among their justifications .    for this family of logics",
    "we provide semantics and a general tableau procedure and then we make observations on the complexity of the derivation problem for its members . in particular , we demonstrate that all logics in this family have their satisfiability problem in - under reasonable assumptions .",
    "this family demonstrates significant variety , as it also includes - and -complete members , while of course some of its members have their satisfiability problem in @xmath17 .",
    "this is a somewhat surprising result , as all single - agent justification logics whose complexity is known have their satisfiability problem in @xmath17 .",
    "this paper is organised as follows . in section [ multidefinitions ] ,",
    "we give the base definitions of the syntax , axioms and semantics for each logic in the family .",
    "then we reintroduce the star calculus , an invaluable tool , and our first complexity results , mirroring the ones for single - agent justification logic ( see @xcite ) .",
    "the version of the star calculus we provide is somewhat different than the usual ones in that it is based on a given frame .",
    "if the frame includes a single world , we get the usual , more familiar version . in section [ tableaux ]",
    "we give general tableau rules for each of our logics .",
    "naturally , the rules are parameterized by the logic s parameters , including the interactions between the agents , so special attention is given in that section to these interactions .",
    "we then go on and further optimize the tableau procedure with respect to the number of world - prefixes it produces ; this results in a @xmath17 upper bound for the satisfiability of a general class of logics .",
    "in this section we present the system we study in this paper , its semantics and the basic tools we will need later on .",
    "most of the proofs for the claims here can be adjusted from the one- or two- agent versions of justification logic .",
    "the reader can see @xcite or @xcite for an overview of single - agent justification logic and @xcite for a two - agent version of this system .      in this paper , if @xmath18 , @xmath19 $ ] will be the set @xmath20 . for every @xmath21",
    ", the justification terms of the language @xmath22 will include all constants @xmath23 and variables @xmath24 and if @xmath25 and @xmath26 are terms , then the following are also terms : @xmath27 , [ t_1\\cdot t_2 ] , ! t_1 $ ] .",
    "the set of terms will be referred to as @xmath28 .",
    "we also use a set @xmath29 of propositional variables , or sentence letters .",
    "these will usually be @xmath30",
    ". formulas of the language @xmath22 include all propositional variables and if @xmath31 are formulas , @xmath32 $ ] and @xmath4 is a term , then the following are also formulas of @xmath22 : @xmath33 . the remaining propositional connectives , whenever needed ,",
    "are treated as constructed from @xmath34 and @xmath35 in the usual way .",
    "the operators @xmath36 and @xmath37 are explained by the following axioms .",
    "intuitively , @xmath38 applies a justification for a statement @xmath39 to a justification for @xmath40 and gives a justification for @xmath41 . using @xmath42 we can combine two justifications and have a justification for anything that can be justified by any of the two initial terms - much like the concatenation of two proofs .",
    "finally , @xmath37 is a unary operator called the proof checker . given a justification @xmath4 for @xmath2",
    ", @xmath43 justifies the fact that @xmath4 is a justification for @xmath2 .",
    "let @xmath18 , @xmath44 $ ] and @xmath45^{2}$ ] .",
    "the logic @xmath46 is the logic with modus ponens as a derivation rule and the following axioms :    propositional axioms : : :    finitely many schemes of classical propositional logic ; application : : :    @xmath47   \\colon_{i } \\ ! }",
    "\\psi)$ ] ; concatenation : : :    @xmath48   \\colon_{i } \\ ! } \\phi$ ] ,    @xmath49   \\colon_{i } \\ ! } \\phi$ ] ; @xmath16-factivity : : :    for every @xmath50 ,    @xmath51 ; @xmath15-consistency : : :    for every @xmath52 ,    @xmath53 ; @xmath13-verification : : :    for every @xmath54 ,    @xmath55 ; @xmath14-conversion : : :    for every @xmath56 ,    @xmath57 ,    where in the above , @xmath2 and @xmath58 are formulas in @xmath22 , @xmath59 are terms and @xmath60 $ ] .",
    "@xmath16-factivity and @xmath15-consistency are the usual factivity and consistency axioms for every agent in @xmath16 and @xmath15 respectively .",
    "positive introspection is seen as a special case of @xmath13-verification - in this context , if agent @xmath61 has positive introspection , then @xmath62 .",
    "a constant specification for @xmath63 is any set @xmath64\\}.\\ ] ] we say that axiom @xmath40 is justified by a constant @xmath65 for agent @xmath61 , when @xmath66 .",
    "a constant specification is : _ axiomatically appropriate with respect to @xmath67 $ ] _ if for every @xmath68 , each axiom is justified by at least one constant , _ schematic _",
    "if every constant justifies only a certain number of schemes from the ones above ( as a result , if @xmath65 justifies @xmath40 for @xmath61 and @xmath41 results from @xmath40 and substitution , then @xmath65 justifies @xmath41 for @xmath61 ) and _ schematically injective _ if it is schematic and every constant justifies at most one scheme .",
    "let @xmath69 be the smallest set such that @xmath70 and for every @xmath71 , it is the case that for every @xmath72 $ ] , @xmath73 .",
    "@xmath74 is @xmath75 , where @xmath76 just outputs all elements of @xmath69 .",
    "@xmath77 is consistent : just map each formula to the propositional formula that is the result of removing all terms from the original one ; then , all axioms are mapped to propositional tautologies and modus ponens preserves this mapping .",
    "we now introduce models for our logic . in the single - agent cases , m - models ( introduced in @xcite ) and f - models ( introduced in @xcite )",
    "are used ( also in @xcite for two - agent logics ) and they are both important in the study of complexity issues . in this paper",
    "we are mostly interested in f - models , which we will usually just call models . these are essentially kripke models with an additional machinery to accommodate justification terms .",
    "let @xmath78 .",
    "then , an f - model @xmath79 for @xmath80 is a quadruple @xmath81 } , ( { { \\mathcal{a}}}_i)_{i \\in [ n]},{\\mathcal{v}})$ ] , where @xmath82 is a set , for every @xmath83 $ ] , @xmath84 is a binary relation on @xmath85 , @xmath86 and for every @xmath83 $ ] , @xmath87 .",
    "@xmath85 is called the _ universe _ of @xmath79 and its elements are the worlds or states of the model .",
    "@xmath88 assigns a subset of @xmath85 to each propositional variable , @xmath89 , and @xmath90 assigns a subset of @xmath85 to each pair of a justification term and a formula .",
    "furthermore , @xmath91}$ ] will often be seen and referred to as @xmath92\\times tm \\times l_n { \\longrightarrow}2^{w}$ ] and @xmath93 is called an admissible evidence function .",
    "additionally , @xmath93 must satisfy the following conditions :    application closure : for any @xmath83 $ ] , formulas @xmath31 , and justification terms @xmath94 , + @xmath95    sum closure : for any @xmath83 $ ] , formula @xmath2 , and justification terms @xmath94 , + @xmath96    @xmath97-closure : for any formula @xmath71 , @xmath98 .",
    "@xmath13-verification closure : if @xmath54 , then @xmath99    @xmath14-conversion closure : if @xmath56 , then @xmath100    @xmath13-distribution : for any formula @xmath2 , justification term @xmath4 , @xmath54 and @xmath101 , if @xmath102 and @xmath103 , then @xmath104 .",
    "the accessibility relations , @xmath105 , must satisfy the following conditions :    * if @xmath106 , then @xmath105 must be reflexive . * if @xmath107 , then @xmath105 must be serial ( @xmath108 ) . * if @xmath109 , then for any @xmath110 , if @xmath111 , we also have @xmath112 .",
    "has positive introspection ( i.e. @xmath113 ) , then @xmath105 is transitive . ] * for any @xmath56 , @xmath114 .",
    "truth in the model is defined in the following way , given a state @xmath115 :    * @xmath116 and if @xmath89 is a propositional variable , then @xmath117 iff @xmath118 . * if @xmath31 are formulas , then @xmath119 if and only if @xmath120 , or @xmath121 . *",
    "if @xmath2 is a formula and @xmath4 a term , then @xmath122",
    "if and only if @xmath103 and @xmath123 for all @xmath124 such that @xmath125 .    a formula @xmath126 is called satisfiable if there are some @xmath127 ; we then say that @xmath79 satisfies @xmath2 in @xmath115 .",
    "if @xmath97 is axiomatically appropriate with respect to @xmath15 , then @xmath77 is sound and complete with respect to its models ; it is also sound and complete with respect to its models that have the _ strong evidence property : _ @xmath122 iff @xmath128 _ _ ; furthermore , if @xmath2 is satisfiable , then it is satisfied by a model @xmath79 of at most @xmath129 states - and in fact , it is satisfied by a model @xmath79 of at most @xmath129 states that has the strong evidence property ( see @xcite for proofs of all the above that can be easily adjusted for this general case ) .",
    "a pair @xmath130})$ ] as above is called a frame for @xmath77 .",
    "we present the @xmath131-calculi for @xmath77 .",
    "the @xmath131-calculi for the single - agent justification logics have proven to be an invaluable tool in the study of the complexity of these logics .",
    "this concept and results were adapted to the two - agent setting in @xcite and here we extend them to the general multi - agent setting .",
    "although the calculi have significant similarities to the ones of the single - agent justification logics , there are differences , notably that each calculus depends upon a frame and operates upon @xmath131-expressions ( defined below ) prefixed by states of the frame .",
    "a @xmath131-calculus was first introduced in @xcite , but its origins can be found in @xcite .    if @xmath4 is a term , @xmath2 is a formula , and @xmath83 $ ] , then @xmath132 is a star - expression ( @xmath131-expression ) . given a frame @xmath133})$ ] and @xmath134 ^ 2 $ ] and constant specification @xmath97 , the @xmath135 calculus on the frame @xmath136 is a calculus on @xmath131-expressions prefixed by worlds from @xmath85 with the axioms and rules that are shown in figure [ fig : starcalc ] . +    [ cols=\"^,^\",options=\"header \" , ]     notice that the calculus rules correspond to the closure conditions of the admissible evidence functions .",
    "in fact and because of this , given a frame @xmath137 and a set @xmath138 of @xmath131-expressions prefixed by states of the frame , the function @xmath93 such that @xmath139 is an admissible evidence function and in fact it is the minimal admissible evidence function such that for every @xmath140 , @xmath141 in the sense that always @xmath142 for any other admissible evidence function @xmath143 such that for every @xmath140 , @xmath144 .",
    "therefore , given a frame @xmath137 and two set @xmath145 of @xmath131-expressions prefixed by states of the frame there is an admissible evidence function @xmath93 on @xmath146 such that for every @xmath147 , @xmath141 and for every @xmath148 , @xmath149 , if and only if there is no @xmath150 such that @xmath151 .",
    "this observation yields the following .",
    "[ prp : proofbystarcalc ] for any holds , but to prove it we need to introduce m - models , but we do not use m - models anywhere else .",
    "thus , the reader can see @xcite , or @xcite for a proof of proposition [ prp : proofbystarcalc ] for all constant specifications . ]",
    "constant specification @xmath97 , frame @xmath146 with universe @xmath85 and @xmath152 , @xmath153 .",
    "[ thm : calccompnew ] let @xmath154 be a schematic constant specification in @xmath155 and @xmath134 ^ 2 $ ] . then , the following problem is in @xmath156 : given a finite frame @xmath157})$ ] and a finite set @xmath138 of @xmath131-expressions prefixed by worlds from @xmath85 , a formula @xmath2 , a term @xmath4 , a @xmath158 and @xmath32 $ ] , is it the case that @xmath159    the proof of this proposition is very similar to the one that can be found in @xcite .",
    "what is different here is the additional assignment of a state set to each node of the derivation tree , which does not change things a lot .    for this proof and",
    "every @xmath160 $ ] , let @xmath161 , s.t .",
    "for every @xmath162 , @xmath163 .",
    "* nondeterministically construct a rooted tree with pairs of the form @xmath164 , where @xmath160 $ ] and @xmath165 is a subterm of @xmath4 , as nodes , such that @xmath166 is the root and the following conditions are met .",
    "node @xmath164 can be the parent of @xmath167 or of both @xmath167 and @xmath168 as long as there is a rule @xmath169 or @xmath170 , respectively , of the @xmath131-calculus and as long as @xmath171 . to keep this structure a tree",
    ", we can ensure at this step that there are no cycles , which would correspond to consecutive applications of @xmath131c@xmath172 and which would be redundant .",
    "* nondeterministically assign to each leaf , @xmath173 , either * * some formula @xmath58 and the closure under @xmath174 of some set @xmath175 , s.t .",
    "for every @xmath176 , @xmath177 or , * * as long as @xmath178 is of the form @xmath179 , where @xmath65 a constant , @xmath180 , then we can also assign some @xmath181 and @xmath182 , where @xmath40 an axiom scheme , s.t . @xmath183 . * if for some node @xmath184",
    "all its children , say @xmath185 have been assigned some scheme or formula @xmath186 and world sets @xmath187 , assign to @xmath188 some scheme or formula @xmath189 , such that @xmath190 can be unified to @xmath191 such that @xmath192 is a rule in the @xmath193-calculus and world set @xmath13 , where @xmath13 is the closure of @xmath194 under @xmath174 .",
    "apply this step until the root of the tree has been assigned some scheme or formula and a @xmath195 subset of @xmath85 .",
    "* unify @xmath2 with the formula assigned to @xmath166 and verify that @xmath196    if some step is impossible , the algorithm rejects .",
    "otherwise , it accepts . using efficient representations of schemes using dags and robinson s unification algorithm",
    ", the algorithm runs in polynomial time .",
    "we can see that as the tree is constructed , if @xmath197 is assigned scheme @xmath189 and set @xmath13 , then the construction effectively describes a valid derivation of any expression of the form @xmath198 , where @xmath199 and @xmath58 an instance of @xmath189 .",
    "therefore , if the algorithm accepts , there exists a valid @xmath200-calculus derivation of @xmath201 . on the other hand",
    "if there is some @xmath200-calculus derivation for @xmath202 from @xmath138 , then the algorithm in the first two steps can essentially describe this derivation by producing the derivation tree and the formulas / schemes by which the derivation starts .",
    "therefore , the algorithm accepts if and only if there is a @xmath200-calculus derivation for @xmath202 from @xmath138 .",
    "see @xcite and @xcite for a more detailed analysis .",
    "the number of nondeterministic choices made by the algorithm in the proof of proposition [ thm : calccompnew ] is bounded by @xmath203 , where @xmath204 .",
    "therefore , if there is some formula @xmath58 such that @xmath205 is a subformula of @xmath58 and for every @xmath206 , @xmath207 is a subformula of @xmath58 , then @xmath208 and therefore we can simulate all nondeterministic choices in time @xmath209 .",
    "thus the algorithm can be turned into a deterministic one running in time @xmath210 .",
    "this observation , the fact that a satisfiable @xmath2 can be satisfied by a model of at most @xmath129 states ( see the previous subsection ) and the previous two propositions give the following results :    let @xmath211 , where @xmath212 is schematic . then ,    1 .   deciding for @xmath205 that @xmath213 is in . 2 .",
    "if @xmath97 is axiomatically appropriate with respect to @xmath15 , then the satisfiability problem for @xmath80 is in .",
    "additionally notice that if the term @xmath4 has no @xmath42 , @xmath97 is schematically injective and @xmath214 , we have essentially eliminated nondeterministic choices from the procedure above .",
    "thus , we conclude ( for the original result , see @xcite ) :    let @xmath211 , where @xmath212 is schematically injective . then , deciding for @xmath205 , where @xmath4 has no ` @xmath42 ' , that @xmath213 is in .",
    "in this section we give a general tableau procedure for every logic which varies according to each logic s parameters .",
    "we can then use the tableau for a particular logic and make observations on its complexity , as we do in the following section .",
    "a version of the tableau which is more efficient for some cases follows after . to develop the tableau procedure we need to examine the relations on the agents more carefully than we have so far . for this section and the following one fix some @xmath215 and we assume @xmath97 is axiomatically appropriate with respect to @xmath15 and schematic .",
    "if @xmath216 are binary relations on the same set , then @xmath217 is the binary relation on the same set , such that @xmath218 if and only if there are @xmath219 in the set , such that @xmath220 .",
    "if @xmath40 is a binary relation , then @xmath221 is the reflexive , transitive closure of @xmath40 ; if @xmath40 is a set ( but not a set of pairs ) , then @xmath221 is the set of strings from @xmath40 .",
    "we also use the following relation on strings : @xmath222 iff there is some string @xmath65 such that @xmath223 . we define the following subsets of and relations on @xmath19 $ ] .",
    "@xmath224 : :    @xmath225 | ( \\exists j \\in d \\cup f ) \\",
    "i c^ * j \\}$ ]    attempts to capture exactly those agents that require a serial    accessibility relation ; from now and on these agents monopolize our    attention ; @xmath226 : :    @xmath225 | ( \\exists j \\in f ) \\ i c^ * j \\}$ ] attempts    to capture exactly those agents that require a reflexive accessibility    relation ; @xmath227 : :    @xmath228 notice that if    @xmath229 , and @xmath230 , then    @xmath231 ; in    @xmath232 is to indicate that @xmath232 is a variation    of @xmath14 influenced by the agents in @xmath16 , not    that it is available with other subscripts ] @xmath233 : :    @xmath234 : if @xmath235 , then    @xmath61 s justifications somehow affect @xmath236 s    justifications ; conversely , @xmath236 s accesibility relations    somehow affect @xmath61 s accessibility relations ; @xmath237 : :    @xmath238 : @xmath239 if    and only if @xmath240 and @xmath241 ; we    can easily see that @xmath242 is an equivalence relation    and that if @xmath243 , then @xmath61 and    @xmath236 have the same accessibility relations ; similarly ,    for the above equivalence relations we can define equivalence classes on @xmath138 , @xmath244 .",
    "@xmath245 is the equivalence class @xmath246 s.t .",
    "we can define relations @xmath248 and @xmath249 on @xmath250 in the following way : @xmath251 iff @xmath252 s.t . @xmath253 and @xmath254 iff @xmath252 s.t . @xmath255 .",
    "also , @xmath256 iff @xmath257 and @xmath258 and similarly for @xmath259 .",
    "then , define @xmath260 iff there are @xmath261 and @xmath262 s.t .",
    "@xmath263 , that is , there are @xmath264 , where @xmath265",
    ". @xmath266 iff @xmath260 and @xmath267 .",
    "let @xmath32 $ ] .",
    "then , @xmath268 and @xmath269 s.t . @xmath270 .",
    "the formulas used in the tableau will have the form @xmath271 , where @xmath272 or is a @xmath131-expression , @xmath273 ( the world prefixes are strings of equivalence classes of agents ) , @xmath274 is ( either the empty string or ) of the form @xmath275 , @xmath276 $ ] , and @xmath277 .",
    "furthermore , @xmath278 will be called a world - prefix or state - prefix , @xmath165 a truth - prefix and world prefixes will be denoted as @xmath279 , instead of @xmath280 , where for all @xmath281 $ ] , @xmath282 .",
    "a tableau branch is a set of formulas of the form @xmath283 , as above .",
    "a branch is complete if it is closed under the tableau rules ( they follow ) .",
    "it is propositionally closed if @xmath284 and @xmath285 are both in the branch .",
    "we say that a tableau branch is constructed by the tableau rules from @xmath2 , if it is a closure of @xmath286 under the rules .    for every @xmath287 , @xmath288 if there are some @xmath289 such that @xmath290 , @xmath291 and @xmath292 .",
    "the tableau rules will include certain classical rules to cover propositional cases of formulas , as well as the ones that follow :    @xmath293{\\sigma\\ t\\ { t   \\colon_{i } \\!}\\psi}{\\sigma\\ t\\ * _ i(t,\\psi ) \\\\\\\\",
    "\\sigma\\ t\\ \\box_i\\psi } \\ ] ]    if @xmath294 ;    @xmath295{\\sigma\\ t\\ { t   \\colon_{i } \\!}\\psi } {   \\sigma.\\chi(j)\\ f\\ \\bot } \\ ] ]    if @xmath294 , @xmath296 , and @xmath297 ;    @xmath298{\\sigma\\",
    "t\\ { t   \\colon_{i } \\!}\\psi}{\\sigma\\ t\\ * _ i(t,\\psi)}\\ ] ]    if @xmath299 ;    @xmath300{\\sigma\\ f\\ { t   \\colon_{i } \\!}\\psi}{\\sigma\\ f\\ * _ i(t,\\psi)}\\ ] ]    @xmath301{\\sigma.\\chi(j ) \\ f \\ \\bot } { \\sigma.\\chi(j).\\chi(i ) \\ f \\ \\bot}\\ ] ]    if @xmath288 ;    @xmath302{\\sigma\\ t\\ \\box_{i}\\psi}{\\sigma.\\chi(i)\\ t\\ \\psi}\\ ] ]    if @xmath303 has already appeared ;    @xmath304{\\sigma\\ t\\ \\box_{i}\\psi}{\\sigma\\ t\\ \\psi}\\ ] ]    if @xmath106 ;    @xmath305{\\sigma\\ t\\ \\box_{i}\\psi}{\\sigma\\ t\\ \\box_{j}\\psi}\\ ] ]    if @xmath306 ;    @xmath307{\\sigma\\ t\\ \\box_{i}\\psi}{\\sigma\\ t\\ \\box_{j}\\box_i\\psi}\\ ] ]    if @xmath308 .",
    "we do not explicitly mention it anywhere else , but of course , we need a set of rules to cover propositional cases as well . in",
    "particular we can use +    @xmath309    and    @xmath310    the separator @xmath311 indicates a nondeterministic choice between the two options it separates .",
    "if @xmath312 is a tableau branch , then here and wherever else it may appear is the set @xmath313 . ]",
    "@xmath314 let @xmath315}$ ] be such that for every @xmath32 $ ] , @xmath316 then @xmath317})$ ] , where @xmath318}$ ] is the closure of @xmath319}$ ] under the conditions of frames for the accessibility relations , except for seriality .",
    "@xmath318}$ ] is constructed in the following way : for every @xmath32 $ ] , let @xmath320 and for every @xmath321 , @xmath322 and then , @xmath323})$ ] .",
    "finally , let @xmath324 and @xmath325 .",
    "a branch @xmath312 of the tableau is rejecting when it is propositionally closed or there is some @xmath326 such that @xmath327 .",
    "otherwise it is an accepting branch .    by induction on the construction of @xmath328 ,",
    "it is not hard to see that for every @xmath329 , it must be the case that @xmath240 or that @xmath330 and @xmath331 . by induction on the frame construction",
    "we can see that if @xmath332 appears in @xmath312 and @xmath333 , then @xmath334 appears in @xmath312 .",
    "[ prp : tableaucomplete ] if there is a complete accepting tableau branch @xmath335 , then the formula @xmath2 is satisfiable by a model for @xmath336 .",
    "let @xmath337 } , { { \\mathcal{a } } } , { \\mathcal{v}})$ ] , where @xmath130 } ) = { \\mathcal{f}}(b)$ ] , @xmath338 , and @xmath339 .",
    "let @xmath340},({{\\mathcal{a}}}_i)_{i\\in[n]},{\\mathcal{v}})$ ] , where for every @xmath32 $ ] , if @xmath294 , then @xmath341 s.t . @xmath342 and @xmath343 , otherwise .",
    "@xmath344 is an f - model for @xmath336 : @xmath345}$ ] easily satisfy the appropriate conditions , as the extra pairs of the accessibility relations do not affect the @xmath131-calculus derivation , and we can prove the same for @xmath346}$ ] . if @xmath347 and @xmath348 , if @xmath349 , then @xmath350 and thus @xmath351 .",
    "if @xmath352 , then , from rule s , there must be some @xmath353 , so @xmath354 and thus , @xmath355 .",
    "if @xmath356 and @xmath357 , then , trivially , whether @xmath352 or not , @xmath358 .",
    "by induction on @xmath359 , we prove that for every formula @xmath359 and @xmath360 , if @xmath361 , then @xmath362 and if @xmath363 , then @xmath364 .",
    "propositional cases are easy . if @xmath365 and @xmath363 , then @xmath366 , so @xmath367 . on the other hand , if @xmath368 , then @xmath369 and by rule trd , for every @xmath370 such that @xmath240 , there is some @xmath371 .",
    "therefore , for every @xmath372 , it is the case that @xmath373 , so by rule trb , a previous observation about formulas of the form @xmath374 , and the inductive hypothesis , for every @xmath375 , @xmath376 and therefore , @xmath377",
    ".    now we can prove the following proposition .",
    "[ prp : tableaux ] let @xmath126 .",
    "@xmath2 is @xmath77-satisfiable if and only if there is a complete tableau branch @xmath312 that is produced from @xmath378 , such that    * for all @xmath379 , not both @xmath380 and @xmath381 appear in @xmath312 and * for any @xmath382 , @xmath383 .",
    "the `` if '' direction was handled by proposition [ prp : tableaucomplete ]",
    ". we will prove the `` only if '' in the following .",
    "let @xmath79 be an f - model , @xmath384},({{\\mathcal{a}}}_i)_{i\\in [ n]},{\\mathcal{v}})$ ] that has the strong evidence property and a state @xmath385 such that @xmath386 .",
    "furthermore , fix some @xmath387 , such that @xmath388 and the following conditions are met . for any @xmath389",
    ", @xmath390 is some element of @xmath85 s.t .",
    "@xmath391 . let @xmath392 \\}$ ] . given a state @xmath115 of the model , and @xmath393 , @xmath394 has the usual , modal interpretation , @xmath394 iff for every @xmath352 ,",
    "@xmath395    we can see in a straightforward way and by induction on the tableau derivation that there is a branch , such that if @xmath396 appears in the branch and @xmath397 , then @xmath398 , if @xmath399 appears in the branch and @xmath397 , then @xmath400 , if @xmath401 appears in the branch , then @xmath402 and if @xmath403 appears in the branch , then @xmath404 .",
    "the proposition follows .      by taking a closer look at the interactions between the agents we can further improve the efficiency of our tableau procedure and we do that in this section .",
    "we use this improvement to prove an upper bound on the complexity of a general class of logics .",
    "we need the following definitions and lemma [ lem : clusters ] , which is a generalization of a result from @xcite and has appeared in simpler forms in @xcite .",
    "first we define an additional equivalence relation : @xmath405 . as an equivalence relation ,",
    "this one too gives equivalence classes on @xmath138 and they are @xmath406 . notice that as @xmath407 , @xmath408 and therefore @xmath250 is a refinement of @xmath409 .",
    "we ll call @xmath410 . furthermore ,",
    "notice that for any @xmath411 , either @xmath412 s.t .",
    "@xmath413 , or @xmath246 .",
    "in the first case , @xmath414 will be called a _ v - class _ of agents and in the second case it will be called a _ c - class _ of agents . for each agent",
    "@xmath32 $ ] , @xmath415 will be the equivalence class @xmath411 s.t . @xmath247 and to help keep the relationship between the sets of equivalence classes in mind , notice that @xmath416 $ ] .",
    "furthermore , we can extend relations @xmath248 and @xmath249 on @xmath189 in the same way they were defined on @xmath250 .",
    "[ lem : clusters ] let @xmath337 } , ( { { \\mathcal{a}}}_i)_{i\\in [ n ] } , { \\mathcal{v}})$ ] be a @xmath77 f - model of at most @xmath129 states , @xmath417 a v - class of agents , and @xmath418 .",
    "then , there are states of @xmath85 , @xmath419 , such that    1 .   for any @xmath420 , @xmath421 .",
    "2 .   for any @xmath422 ,",
    "@xmath423 , if @xmath424 , then @xmath425 .",
    "@xmath419 will be called _ a @xmath426-cluster for @xmath427_.    for this proof we need to define the following .",
    "let @xmath32 $ ] , @xmath428 .",
    "_ an @xmath429-path ending at @xmath61 _ ( and starting at @xmath430 ) from @xmath431 to @xmath432 is a finite sequence @xmath433 , such that for some @xmath434 $ ] , @xmath435 , where for some @xmath436 $ ] @xmath437 and @xmath438 ( and @xmath439 ) , for every @xmath440 $ ] , @xmath441 and if @xmath442 , then @xmath443 , while if @xmath444 , then @xmath445 and @xmath446 , @xmath447 , @xmath448 .",
    "the @xmath429-path _ covers _ a set @xmath449 $ ] if @xmath450 .",
    "for this path and @xmath451 $ ] , @xmath452 is a @xmath453-state .",
    "notice that if there is an @xmath429 path ending at @xmath61 from @xmath431 to @xmath432 and some @xmath454 and @xmath455 such that the path covers @xmath165 and @xmath456 , it must also be the case that @xmath457 .",
    "let @xmath458 { \\longrightarrow}p_a$ ] be such that @xmath459 , @xmath460 = p_a$ ] and for every @xmath461 $ ] , either @xmath462 or @xmath463 and there is some @xmath461 $ ] such that @xmath463 .",
    "for any @xmath385 , @xmath464 let @xmath465 be the following : @xmath466 , for all @xmath467 $ ] , @xmath468 will be such that there is an @xmath429 path ending at @xmath469 from @xmath165 to @xmath468 and covering @xmath426 and if @xmath470 , @xmath471 is such that @xmath472 is an @xmath429 path ending at @xmath473 .",
    "let @xmath474 , x\\in { \\ensuremath{\\mathbb{n}}}},(a^x_i)_{i \\in [ m ] , x\\in { \\ensuremath{\\mathbb{n}}}}$ ] be defined in the following way . for every",
    "@xmath475 $ ] , @xmath476 and for every @xmath464 , @xmath477 .",
    "finally , for @xmath478 , @xmath474}$ ] is defined in the following way . if there are some @xmath479 , @xmath422 , such that @xmath480 , @xmath481 and not @xmath482 , then for all @xmath420 , @xmath483 .",
    "otherwise , @xmath484 . by induction on @xmath485",
    ", we can see that for every @xmath486 , @xmath420 , if @xmath487 , then @xmath488 . since the model has a finite number of states ,",
    "there is some @xmath464 such that for every @xmath489 , @xmath490 .",
    "therefore , we can pick appropriate @xmath419 among @xmath491 that satisfy conditions 1 , 2 .",
    "we recursively define relation @xmath34 on @xmath492 :    * if @xmath493 then @xmath494 ; * if @xmath348 , then @xmath495 ; * if @xmath496 , then @xmath497 .",
    "@xmath498 is the reflexive , transitive closure of @xmath34 .",
    "@xmath498 tries to capture the closure of the conditions on the accessibility relations of a frame .",
    "this is made explicit by observing that if for some frame @xmath130})$ ] , @xmath499 and @xmath500 , then @xmath501 .",
    "furthermore , if , in addition , @xmath502 , then for every @xmath503 $ ] , @xmath504 . for every agent @xmath294",
    ", we introduce a new agent , @xmath505 and we extend @xmath498 , so that when @xmath415 a v - class , then @xmath506 for every @xmath507 such that @xmath508 . for each @xmath246",
    ", we fix some @xmath509 and @xmath510 . furthermore , if @xmath511 , then @xmath512 @xmath513 . this extended definition of @xmath498 tries to capture the closure of the conditions on the accessibility relations of a frame like the ones that will result from a tableau procedure as defined in the following .",
    "let @xmath411 and @xmath514 be a finite string of elements from @xmath250 .",
    "then , @xmath414 is _ visible _ from @xmath278 if and only if there is some @xmath515 , some @xmath516 and some @xmath517 such that @xmath518 and @xmath519 ; @xmath520 is then called the @xmath414-view from @xmath514 .",
    "notice that there is a similarity between this definition and the statement of lemma [ lem : clusters ] - this will be made explicit later on .",
    "then we adjust the tableau by altering rules trd and s and introduce rule svb :    @xmath295{\\sigma\\ t\\ { t   \\colon_{i } \\!}\\psi } {   \\sigma.\\chi(j)\\ f\\ \\bot } \\ ] ]    if @xmath294 , @xmath296 , @xmath297 , and @xmath521 is not a @xmath13-class visible from @xmath514 ;    @xmath301{\\sigma.\\chi(j ) \\ f \\ \\bot } { \\sigma.\\chi(j).\\chi(i ) \\ f \\ \\bot}\\ ] ]    if @xmath288 and it is not the case that @xmath415 is a @xmath13-class visible from @xmath522 ;    @xmath523{\\sigma\\ t\\ \\box_{i}\\psi}{\\tau.\\chi(i)\\ t\\ \\psi}\\ ] ]    if @xmath524 a @xmath13-class , visible from @xmath514 , @xmath525 is the @xmath415-view from @xmath514 and @xmath520 has already appeared in the tableau",
    ".    then we have to redefine the frame @xmath328 .",
    "let @xmath315}$ ] be such that for every @xmath32 $ ] , @xmath316 @xmath526 @xmath527 and @xmath317})$ ] , where @xmath318}$ ] is the closure of @xmath319}$ ] as it was defined before .",
    "proposition [ prp : tableaucomplete ] and its proof remain the same . to prove proposition [ prp : tableaux ] for this version of the rules , follow the same proof , but for every @xmath360 and v - class @xmath414 fix some @xmath414-cluster for @xmath115 and if @xmath415 is a @xmath13-class , then for @xmath528 , the fixed @xmath414-cluster for @xmath529 , @xmath530 - and observe that if @xmath415 a @xmath13-class , visible from @xmath514 and @xmath525 is the @xmath415-view from @xmath514 , then in model @xmath79 there is some @xmath432 such that @xmath531 , which by the definition of clusters in turn means that @xmath532 .",
    "the remaining proof is the same .",
    "notice that if for every appearing world - prefix @xmath303 , @xmath61 is always in the same v - class @xmath414 , then all prefixes are of the form @xmath533 , where @xmath534 . in that case",
    "we can simplify the box rules and in particular just ignore rule v and end up with the following result .",
    "[ cor : easycasesinpi2 ] when there is some v - class @xmath414 such that for every @xmath535 there is some @xmath536 such that @xmath537 , then @xmath77-satisfiability is in @xmath17 .",
    "in this section we look into some more specific cases of multi - agent justification logics and demonstrate certain jumps in the complexity of the satisfiability problem for these logics .",
    "we first revisit the two - agent logics from @xcite . like in the previous sections ,",
    "we assume our constant specifications are schematic and axiomatically appropriate ( and in   for upper bounds ) .",
    "our definition here of @xmath77 allows for more two - agent logics than the ones that were studied in @xcite .",
    "it is not hard , though , to extend those results to all two - agent cases of @xmath77 : when there are @xmath538 $ ] , @xmath539 , @xmath540 , @xmath541 , and @xmath542 , then @xmath543-satisfiability is -complete ; otherwise it is in @xmath17 ( see @xcite ) .",
    "we will further examine the following two cases .",
    "@xmath544 are defined in the following way .",
    "@xmath545 ; @xmath546 ; @xmath547 ; @xmath548 , @xmath549 ; @xmath550 ; finally , for @xmath551 $ ] , @xmath552 , where @xmath553 is some axiomatically appropriate and schematic constant specification .    by an adjustment of the reductions in @xcite , as it was done in @xcite , it is not hard to prove that @xmath554 is -hard and @xmath555 is -hard . would correspond to what is defined in @xcite as @xmath556 and @xmath557 to @xmath558 .",
    "then we can pick a justification variable @xmath485 and we can either use the same reductions and substitute @xmath559 by @xmath560 , or we can just translate each diamond - free fragment to the corresponding justification logic in the same way .",
    "it is not hard to see then that the original modal formula behaves exactly the same way as the result of its translation with respect to satisfiability - just consider f - models where always @xmath98 . ]",
    "notice that the way we prove @xmath561-hardness for @xmath562 is different in character from the way we prove the same result for the two - agent logics in @xcite .",
    "for @xmath562 we use the way the tableau prefixes for it branch , while for @xmath563 the prefixes do not branch , but they increase to exponential size . in fact , we can see that @xmath562 is -complete , while @xmath557 is -complete . the respective tableau rules as they turn out for each logic are - notice that neither logic has any @xmath564-maximal v - classes :                    notice that the maximum length of a world prefix is at most @xmath566 , since the depth ( nesting of terms ) of the formulas decrease whenever we move from @xmath514 to @xmath565 . also notice that when we run the @xmath131-calculus , there is no use for rule @xmath131v - dis , so we can simply run the calculus on one world - prefix at the time , without needing the whole frame .",
    "therefore , we can turn the tableau into an alternating polynomial time procedure , which uses a nondeterministic choice when the tableau would make a nondeterministic choice ( when we apply the propositional rules ) and uses a universal choice to choose whether to increase prefix @xmath514 to @xmath567 or to @xmath568 .",
    "this means that @xmath562-satisfiability is -complete .          for the tableau procedure of @xmath557",
    "we have no such bound on the size of the largest world - prefix , so we can not have an alternating polynomial time procedure .",
    "as before , though , the @xmath131-calculus does not use rule @xmath131v - dis , so again we can run the calculus on one world - prefix at the time . furthermore , for every prefix @xmath431 , @xmath569 is polynomially bounded ( observe that we do not need more than two boxes in front of any formula ) , so in turn we have an alternating polynomial space procedure .",
    "therefore , @xmath557-satisfiability is -complete .",
    "antonis achilleos .",
    "a complexity question in justification logic . in _ proceedings of the 18th international conference on logic , language ,",
    "information and computation _",
    ", wollic11 , pages 819 , berlin , heidelberg , 2011 .",
    "springer - verlag .",
    "roman kuznets . on the complexity of explicit modal logics . in peter clote and helmut schwichtenberg , editors ,",
    "_ csl _ , volume 1862 of _ lecture notes in computer science _ ,",
    "pages 371383 .",
    "springer , 2000 .",
    "errata concerning the explicit counterparts of  @xmath570 and  @xmath571 are published as  @xcite .",
    "roman kuznets .",
    "complexity through tableaux in justification logic . in _",
    "plenary talks , tutorials , special sessions , contributed talks of logic colloquium ( lc 2008 ) , bern , switzerland _ , pages 3839 , 2008",
    ".    roman kuznets .",
    "self - referentiality of justified knowledge .",
    "in edward  a. hirsch , alexander  a. razborov , alexei  l. semenov , and anatol slissenko , editors , _ csr _ , volume 5010 of _ lecture notes in computer science _ , pages 228239 .",
    "springer , 2008 .",
    "alexey mkrtychev .",
    "models for the logic of proofs . in sergei adian and anil nerode , editors , _ logical foundations of computer science , 4th international symposium , lfcs97 , yaroslavl , russia , july 612 , 1997 , proceedings _ ,",
    "volume 1234 of _ lecture notes in computer science _ , pages 266275 .",
    "springer , 1997 ."
  ],
  "abstract_text": [
    "<S> the logic of proofs , lp , and its successor , justification logic , is a refinement of the modal logic approach to epistemology in which proofs / justifications are taken into account . in 2000 </S>",
    "<S> kuznets showed that satisfiability for lp is in the second level of the polynomial hierarchy , a result which has been successfully repeated for all other one - agent justification logics whose complexity is known .    </S>",
    "<S> we introduce a family of multi - agent justification logics with interactions between the agents justifications , by extending and generalizing the two - agent versions of the logic of proofs introduced by yavorskaya in 2008 . </S>",
    "<S> known concepts and tools from the single - agent justification setting are adjusted for this multiple agent case . </S>",
    "<S> we present tableau rules and some preliminary complexity results . in several cases </S>",
    "<S> the satisfiability problem for these logics remains in the second level of the polynomial hierarchy , while for others it is or -hard . </S>",
    "<S> furthermore , this problem becomes -hard even for certain two - agent logics , while there are @xmath0-hard logics of three agents . </S>"
  ]
}