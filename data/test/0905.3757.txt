{
  "article_text": [
    "global constraints are a vital component of constraint toolkits .",
    "they permit users to model common patterns and to exploit efficient propagation algorithms to reason about these patterns .",
    "a promising mechanism to implement such global constraints is to develop decompositions into sets of primitive constraints that do not hinder propagation .",
    "for example , bacchus has shown how to decompose global propagators for the generic constraint , as well as for the , and constraints into conjunctive normal form ( cnf ) @xcite .",
    "such decompositions can then be used in sat solvers , allowing us to profit from techniques like clause learning and backjumping . in recent years",
    ", many other decompositions have been proposed for a wide range of global constraints including and @xcite , @xcite , @xcite , and @xcite .",
    "many other global constraints can be decomposed using and , which can themselves be propagated effectively using some simple decompositions @xcite .",
    "finally , many global constraints specified by automata can be decomposed into signature and transition constraints without hindering propagation @xcite .",
    "this raises the important open question of which global constraints can be effectively propagated using simple encodings @xcite .",
    "we show that circuit complexity can be used to resolve this question .",
    "our main result is that there is a polynomial sized decomposition of a constraint propagator into cnf if and only if the propagator can be computed by a polynomial size monotone boolean circuit .",
    "it follows therefore that bounds on the size of monotone boolean circuits give bounds on the size of decompositions of global constraints into cnf .",
    "for instance , a super - polynomial lower bound on the size of a boolean circuit for perfect matching in a bipartite graph gives a super - polynomial lower bound on the size of a cnf decomposition of the domain consistency propagator for the constraint .",
    "our results directly extend to decompositions into csp constraints of bounded arity with domains given in extension since such decompositions can be translated into clauses of polynomial size @xcite .",
    "the tools of circuit complexity are thus useful in understanding the limits of what we can achieve with decompositions .",
    "[ [ csp . ] ] csp .",
    "+ + + +    a constraint satisfaction problem ( csp ) @xmath0 consists of a set of variables @xmath1 , each of which has a finite domain @xmath2 , and a set of constraints @xmath3 .",
    "assignment _ to a variable @xmath4 is a mapping of @xmath4 to a value @xmath5 , called literal , and written @xmath6 .",
    "we write @xmath7 ( resp .",
    "@xmath8 ) for sets of literals @xmath9 ( resp .",
    "@xmath10 ) and @xmath11 for the set of all such sets .",
    "an assignment to a set of variables @xmath1 is a set that contains exactly one assignment to each variable in @xmath1 .",
    "a constraint @xmath12 has a _",
    ", denoted @xmath13 and allows a subset of the possible assignments to the variables @xmath14 , called _",
    "solutions _ of @xmath15 .",
    "a solution of @xmath0 is an assignment of one value to each variable such that all constraints are satisfied .",
    "a propagator for a constraint @xmath15 is an algorithm which takes as input the domains of the variables in @xmath14 and returns _ restrictions _ of these domains .",
    "following  @xcite , we can formally define a propagation algorithm as a function :    [ defn : propagator ] a propagator @xmath16 for a constraint @xmath15 is a polynomial time computable function @xmath17 , such that @xmath16 is _ monotone _",
    ", i.e. , @xmath18 , _ contracting _ ,",
    "i.e. , @xmath19 , and _ idempotent _ , i.e. , @xmath20 . if a literal @xmath6 is in @xmath21 then @xmath6 does not belong to any solution of @xmath15 given @xmath7 .",
    "if @xmath16 detects that @xmath15 has no solutions under @xmath7 then @xmath22 .",
    "a propagator _ detects dis - entailment _ if when no possible assignment is a solution of @xmath15 then @xmath23 .",
    "a propagator enforces _ domain consistency ( dc ) _ when @xmath24 implies that there exists a solution of @xmath15 that contains @xmath6 .",
    "we also define the _ consistency checker _ for a constraint @xmath15 as a function that returns 0 when it detects that no possible assignment is a solution of the constraint and 1 otherwise , rather than restricting domains .",
    "[ defn : consistency - checker ] a consistency checker @xmath16 for a constraint @xmath15 is a polynomial time computable function @xmath25 such that @xmath16 is monotone , i.e. , @xmath26 . if @xmath27 then no possible assignment under @xmath7 is a solution of @xmath15 .",
    "we can obtain a polynomial time consistency checker @xmath28 of a constraint @xmath15 from a polynomial time propagator @xmath29 for @xmath15 and vice versa  @xcite .",
    "given the propagator @xmath30 , the corresponding consistency checker @xmath28 is defined as : @xmath31 conversely , given @xmath28 , the propagator @xmath29 is @xmath32 where @xmath33 .",
    "[ [ sat . ] ] sat .",
    "+ + + +    the boolean satisfiability problem ( sat ) is a special case of the csp where variables are boolean . for each boolean variable @xmath34 there",
    "exist two _ literals _ @xmath34 and @xmath35",
    ". constraints in conjunctive normal form ( cnf ) are disjunctions of literals , called _ clauses _ and sometimes written simply as tuples of literals .    unit propagation _ forces _ a literal to trueif it appears in a clause where all other literals are falseand continues until a fix - point is reached .",
    "if all literals in a clause are made false , we say that the empty clause is produced",
    ". a stronger form of inference is the _ failed literal test _  @xcite . for each literal @xmath36 of an unset variable @xmath37 ,",
    "the failed literal test sets @xmath36 to true , performs unit propagation , checks whether the empty clause was produced and retracts @xmath36 and its consequences .",
    "if the empty clause was produced , @xmath36 is set to false .",
    "a csp instance can be encoded as a sat instance .",
    "the most widely used mapping of csp variables to boolean variables is the _ direct encoding_. each csp variable @xmath4 with domain @xmath2 is encoded in sat as a set of propositions @xmath38 , @xmath39 such that @xmath40 .",
    "the property that each csp variable has at most one value is enforced by the set of clauses @xmath41 for all @xmath42 and the property that each csp variable has at least one value is enforced by the set of clauses @xmath43 .",
    "we denote this propositional representation of @xmath7 as @xmath44 .",
    "note that the propositional representation @xmath45 represents the _ current state _ of the domains @xmath7 during search .",
    "this means that when the domains change , we need to be able to make the corresponding change in the direct encoding .",
    "consequently , the fact @xmath46 is represented by @xmath38 being _ unset _ , rather than true . when the value @xmath6 is pruned , then @xmath38 is set to false . only when @xmath6 is the only possible assignment for @xmath4 is @xmath38 set to true .",
    "this means that the same domain can be represented by different partial instantiations of the direct encoding .",
    "for example , given the csp variable @xmath47 with initial domain @xmath48 , the instantiation @xmath49 ( with @xmath50 unset ) corresponds to the same domain as @xmath51 , which is @xmath52 .",
    "[ [ boolean - circuits . ] ] boolean circuits .",
    "+ + + + + + + + + + + + + + + + +    a boolean circuit @xmath53 is a directed acyclic graph ( dag ) .",
    "each source vertex of the dag is an _ input gate _ and the unique sink of the dag is the output gate .",
    "each non - input vertex is labelled with a logical connective , such as and ( @xmath54 ) , or ( @xmath55 ) and not ( @xmath56 ) .",
    "an _ input _",
    "@xmath57 to the circuit is an assignment of a _ value _ 0 or 1 to each input gate .",
    "the value of a non - input gate is computed by applying the connective that it is labelled with to the values of its ancestor gates .",
    "the value of the circuit @xmath58 is the value of its output gate .",
    "any polynomial time decision algorithm can be encoded as a boolean circuit of polynomial size for a fixed length input  @xcite .    in this paper",
    ", we will use a restriction of boolean circuits to and , called _",
    "monotone circuits_. the family of functions that are computable by monotone circuits is exactly all the monotone boolean functions .",
    "note that there exist families of polynomial time computable monotone boolean functions such that the smallest monotone circuit that computes them is super - polynomial in size  @xcite .",
    "[ defn : monotone - boolean - function ] a boolean function @xmath16 is monotone iff @xmath59 implies @xmath60 for all @xmath61 , where @xmath62 is the pairwise vector comparison , i.e. , @xmath63 for all @xmath64 .",
    "a consistency checker @xmath28 , previously defined as a monotone function over sets , can also be formalised as a monotone boolean function whose input is the characteristic function of the set @xmath7 .",
    "literals @xmath6 are mapped to arguments @xmath65 of the function , with @xmath66 iff @xmath67 .",
    "we use @xmath68 to denote the setting of the @xmath65 inputs for a given set of domains @xmath7 .",
    "in this section , we define formally a _ cnf decomposition _ of a propagator and of a consistency checker . as with propagators and consistency checkers  @xcite",
    ", we show that there exists a polynomial time conversion between the cnf decompositions of a propagator and of the corresponding consistency checker .",
    "[ defn : decomp - prop ] a cnf decomposition of a propagation algorithm @xmath29 is a formula in cnf @xmath69 over variables @xmath70 such that    * the _ input variables _",
    "@xmath71 are the propositional representation @xmath44 of @xmath7 and @xmath72 is a set of auxiliary variables whose size is polynomial in @xmath73 . *",
    "@xmath38 is set to falseby unit propagation if and only if @xmath74 . * unit propagation on @xmath69 produces the empty clause when @xmath75 .",
    "[ exm : def_prop ] to illustrate definition  [ defn : decomp - prop ] , consider a constraint over the variables @xmath76 with @xmath77 and the satisfying assignments : @xmath78 .",
    "@xcite decomposes such a constraint into cnf using the following set of clauses : @xmath79 where @xmath80 , @xmath81 , @xmath82 is the propositional representation @xmath44 of @xmath7 and @xmath83 , @xmath84 are auxiliary variables that correspond to satisfying tuples .",
    "note that we have extended bacchus s encoding with the clause @xmath85 to detect failure .",
    "suppose the value @xmath86 is removed from the domain of @xmath47 .",
    "the assignment @xmath87 forces the variable @xmath88 to false , which in turn causes the variable @xmath89 to false , removing the value @xmath86 from the domain of @xmath90 as well .",
    "in example  [ exm : def_prop ] , we have decomposed a constraint into clauses by introducing variables . in general ,",
    "an encoding might be exponentially bigger if auxiliary variables are not used ( e.g. , the parity function  @xcite ) .    _ * ( cnf decomposition of a consistency checker ) * _ [ defn : cnf - decomposition ] a cnf decomposition of a consistency checker @xmath28 is a cnf @xmath91 over variables @xmath92 such that    * the input variables @xmath71 are the propositional representation @xmath44 of @xmath7 and @xmath72 is a set of auxiliary variables whose size is polynomial in @xmath73 .",
    "the variable @xmath93 is the _ output variable_. * unit propagation on @xmath91 never forces any variable from @xmath71 or generates the empty clause if no variable in @xmath72 is set externally to @xmath91 , i.e. , every variable @xmath94 is either unset or forced by a clause in @xmath91 .",
    "* @xmath93 is set to falseby unit propagation if and only if @xmath95 .    [ exm : def_con_checker ] consider the constraint from example  [ exm : def_prop ] .",
    "we construct a cnf decomposition of a consistency checker using the cnf decomposition of a propagator .",
    "the clauses that cause pruning of input variables domains are removed and the last clause is augmented with the output variable @xmath93 to avoid generation of the empty clause in the case of failure : @xmath96 in this case , if the value @xmath86 is removed from the domain of @xmath47 , unit propagation will not deduce that @xmath86 has to be removed from the domain of @xmath90 . consider instead the case when the values @xmath86 and @xmath97 are removed from the domains of @xmath47 and @xmath90 , respectively .",
    "the literals @xmath98 and @xmath99 force the auxiliary variables @xmath88 , @xmath100 and @xmath101 to be false .",
    "therefore , the output variable @xmath93 is forced to false , signalling that the constraint does not have a solution under @xmath7 .    in example",
    "[ exm : def_con_checker ] , we transformed the propagator of example  [ exm : def_prop ] into a consistency checker in an ad - hoc manner .",
    "the next theorem shows that this can be done in a generic way .",
    "we give a polynomial transformation of cnf decompositions of a propagator into consistency checkers this mirrors the results of  @xcite for cnf decompositions .",
    "[ thm : flt_transformation ] there exists a polynomial time and space conversion between the cnf decomposition of a propagator @xmath29 and that of the corresponding consistency checker @xmath28 .",
    "@xmath102 we construct @xmath91 as a transformation of @xmath69 such that the output variable @xmath93 of @xmath91 is falseiff unit propagation on @xmath69 produces the empty clause .",
    "let the set of clauses of @xmath69 be @xmath103 .",
    "for each variable @xmath104 , we introduce 2 variables @xmath105 and @xmath106 in @xmath91 so that @xmath107 and @xmath108 are true if @xmath109 is forced to trueor false , respectively : @xmath110    then , we simulate unit propagation for each clause @xmath111 by replacing it with 3 implications that contain the variables @xmath105 and @xmath106 rather than @xmath109 .",
    "for example , to simulate unit propagation for the clause @xmath112 , we replace it with @xmath113    unit propagation on can never derive the empty clause , because the true and false values of @xmath109 are encoded in different variables @xmath107 and @xmath108 , which may be true simultaneously .",
    "when this happens , unit propagation on @xmath69 would generate the empty clause , therefore we must set the output variable @xmath93 to false , using the following clauses : @xmath114    the union of the clauses , and is a cnf decomposition of @xmath28 with size @xmath115 , therefore the transformation is polynomial .",
    "@xmath116 we outline the proof here .",
    "we replicate the equation   by simulating the failed literal test on @xmath117 . for each literal @xmath38",
    "we create a copy of @xmath91 , denoted by @xmath118 , in which all literals @xmath119 are false .",
    "we use @xmath118 to record the results of unit propagation when @xmath6 .",
    "when unit propagation sets the output variable @xmath120 of the copy @xmath118 to false then the propositional literal @xmath38 is made falseby the additional clause @xmath121 .",
    "the decomposition @xmath69 is then the union of the copies of @xmath91 and the clauses @xmath121 : @xmath122 the size of @xmath69 is @xmath123 , therefore the transformation is polynomial .    using the encoding of theorem  [ thm : flt_transformation ] , a cnf decomposition of a consistency checker that detects dis - entailment can be made into a propagator that enforces domain consistency . as an example , consider the cnf decomposition of a propagator that detects dis - entailment for the constraint , proposed in  @xcite .",
    "the size of this decomposition is @xmath124 , where @xmath125 is the number of variables in the constraint .",
    "these variables are binary , hence the transformation of theorem  [ thm : flt_transformation ] yields a decomposition of a dc propagator with size @xmath126 .",
    "this is also the complexity of the dc propagator proposed in @xcite .    since all definitions of cnf decompositions that we introduced in this section are polynomially equivalent , in the remainder of this paper we only prove results for cnf decompositions of consistency checkers .",
    "in this section , we show our main result , which establishes a connection between cnf decompositions of constraints and circuit complexity .",
    "[ thm : cnf_mc_equiv ] a consistency checker @xmath28 can be decomposed to a cnf of polynomial size if and only if it can be computed by a monotone circuit of polynomial size .",
    "the proof of theorem  [ thm : cnf_mc_equiv ] is constructive .",
    "we will first show the reverse direction , using the tseitin encoding  @xcite of a monotone circuit .",
    "the tseitin encoding of a circuit @xmath53 into clausal form has one propositional variable for each input of @xmath53 and for each gate of @xmath53 .",
    "w.l.o.g , we assume all gates have fan - in 2 . for each @xmath127 with inputs @xmath128 ,",
    "@xmath129 , the tseitin encoding contains the clauses @xmath130 , @xmath131 , @xmath132 and for each it contains the clauses @xmath133 , @xmath134 , @xmath135 .",
    "given any complete instantiation of the input variables , unit propagation on the tseitin encoding sets the variable corresponding to the output gate of @xmath53 to trueif the circuit computes 1 and to falseotherwise .",
    "suppose that a consistency checker @xmath28 can be encoded into a monotone circuit @xmath136 of polynomial size .",
    "the tseitin encoding of @xmath136 turns out to be a cnf decomposition of @xmath28 .",
    "this is a direct consequence of the following lemma .",
    "[ lemma : mc_cnf ] let @xmath136 be a monotone circuit and @xmath91 be its tseitin encoding .",
    "let @xmath137 be a partial instantiation of the input variables @xmath71 of @xmath91 and @xmath57 be the corresponding input to @xmath136 , where @xmath138 iff @xmath139 .",
    "then , unit propagation on @xmath91 with @xmath137 forces the output variable @xmath93 to falseif and only if @xmath140 .",
    "@xmath102 this follows from the correctness of the tseitin encoding .",
    "suppose that @xmath140 , but the output variable @xmath93 is not forced to falseby unit propagation under @xmath137 .",
    "consider an instantiation @xmath141 of the input variables of @xmath91 , which is the same as @xmath137 with unset variables fixed to true .",
    "let @xmath142 be an auxiliary variable that is unset under @xmath137 .",
    "all such variables correspond to a gate in @xmath136 .",
    "since @xmath91 is an encoding of the monotone circuit @xmath136 , @xmath143 will be set to trueunder @xmath141 .",
    "this means that the output variable @xmath93 is also set to true . by the correctness of the tseitin encoding , @xmath144 ,",
    "a contradiction .",
    "let @xmath136 be a monotone circuit and @xmath91 be its tseitin encoding .",
    "let @xmath137 be a partial instantiation of the input variables @xmath71 of @xmath91 .",
    "then , unit propagation on @xmath91 with @xmath137 forces the output variable @xmath93 to falseif and only if @xmath140 , for all @xmath57 where @xmath57 is the input to @xmath136 that corresponds to any extension of @xmath137 to a complete instantiation .",
    "this follows from lemma  [ lemma : mc_cnf ] and the fact that @xmath136 is a monotone circuit .",
    "interestingly , lemma  [ lemma : mc_cnf ] can not be generalised to non - monotone boolean circuits .",
    "the next example shows that there exists a non - monotone boolean circuit @xmath53 that computes a monotone function , and a partial instantiation @xmath137 with @xmath57 the corresponding input to @xmath53 , such that @xmath145 but unit propagation on the tseitin encoding of @xmath53 under the instantiation @xmath137 does not set the output variable to false .",
    "+    consider the non - monotone circuit @xmath53 shown in figure  [ fig : bad_circuit ] .",
    "note that @xmath53 computes a monotone function .",
    "the tseitin encoding of @xmath53 introduces three boolean variables @xmath146 , @xmath147 and @xmath148 for the gates @xmath149 , @xmath150 and @xmath151 , respectively , and the clauses @xmath152 , @xmath153 , @xmath154 , @xmath155 , @xmath156 , @xmath157 , @xmath158 , @xmath159 , @xmath160 .",
    "now suppose that @xmath161 . then , @xmath162 and @xmath145 .",
    "since @xmath53 computes a monotone function , all possible extensions of @xmath71 evaluate to 0 .",
    "but in the tseitin encoding , setting @xmath128 to falsedoes not make any clauses unit , therefore unit propagation does not set @xmath148 to false .",
    "we now show the forward direction of theorem  [ thm : cnf_mc_equiv ] : every cnf decomposition @xmath91 of a consistency checker @xmath28 can be converted to a monotone circuit that computes @xmath28 with at most a polynomial increase in size .",
    "this transformation exploits two properties of cnf decompositions , namely , that only positive literals of input variables appear in @xmath91 , and that unit propagation only makes auxiliary variables false .",
    "we show the former property in lemma  [ lemma : input var polarity ] and the latter in lemma  [ lemma : extra_var_values ] .",
    "[ lemma : input var polarity ] let @xmath91 be the cnf decomposition of a consistency checker @xmath28 .",
    "there exists a polynomial size cnf decomposition @xmath163 of @xmath28 such that negative literals of the input variables do not appear in any clause in @xmath163 .",
    "we construct @xmath163 by removing from @xmath91 all clauses that contain a negative literal of an input variable .",
    "we show by contradiction that unit propagation on @xmath163 and @xmath91 produces identical results for the output variable @xmath93 .",
    "let @xmath137 be a partial instantiation of the input variables such that unit propagation on @xmath91 under @xmath137 sets @xmath93 to falsebut leaves @xmath93 unset on @xmath163 .",
    "since unit propagation on @xmath91 and @xmath163 produces different results , at least one of the removed clauses becomes unit under @xmath137 in @xmath91 . by definition ,",
    "@xmath91 never forces any literal of an input variable , so for any removed clause to become unit , all the literals of input variables in it have to be false .",
    "since at least one of these literals is negative , at least one input variable has to be set to truein @xmath137 .",
    "we construct another partial instantiation @xmath141 from @xmath137 by setting the same literals to falseas @xmath137 and leaving the rest unset , i.e. , @xmath164 .",
    "the partial instantiations @xmath137 and @xmath141 represent the same domains @xmath7 , because the mapping from partial instantiation to domain depends only on the literals that are false . by this and the fact that @xmath91 is a decomposition of @xmath28 , unit propagation on @xmath91 under @xmath141 forces the output variable @xmath93 to the same value as under @xmath137 , false .",
    "consider the result of unit propagation on @xmath163 under @xmath141 . recall that by definition @xmath91 does not modify input variables and @xmath141 does not have literal set to trueby construction .",
    "hence , none of the clauses that we remove from @xmath91 to get @xmath163 can become unit after performing up on @xmath91 under @xmath141 .",
    "hence , unit propagation in @xmath163 under @xmath141 sets @xmath93 to falseas in @xmath91 . on the other hand",
    ", @xmath137 sets a superset of the literals that @xmath141 sets , so unit propagation on @xmath163 under @xmath137 also sets @xmath93 to false , a contradiction , since we assumed that @xmath163 leaves @xmath93 unset under @xmath137 .    in practice ,",
    "a cnf decomposition of a consistency checker may not be self contained and may depend on the existence of clauses in the direct encoding of variable domains . in this case",
    ", we can not just remove clauses that contain negative literals of input variables , as lemma  [ lemma : input var polarity ] suggests .",
    "however , using the clauses of the direct encoding , we can substitute negative literals with the disjunction of positive literals .",
    "for instance , consider a variable @xmath90 with the domain @xmath165 and a clause @xmath166 in @xmath91 .",
    "the literal @xmath167 can make this clause unit .",
    "the direct encoding of @xmath168 includes a clause @xmath169 .",
    "note that the literal @xmath167 is trueif and only if literals @xmath170 and @xmath171 are false .",
    "therefore , the literal @xmath172 can be replaced with the disjunction @xmath173 and the clause @xmath166 is transformed to the clause @xmath174 .",
    "the next step is to show that we can transform a cnf decomposition so that each auxiliary variable is unset or falsefor _ all _ inputs that make the output variable false .",
    "the transformation is a renaming of the auxiliary variables .",
    "lemma  [ lemma : extra_var_values ] describes the property that allows this transformation .",
    "[ lemma : extra_var_values ]",
    "let @xmath91 be a cnf decomposition of a consistency checker @xmath28 over the variables @xmath175 , @xmath176 be the propositional representations of any two domain settings such that unit propagation on @xmath91 forces @xmath93 to falseunder both @xmath177 and @xmath178 .",
    "for any variable @xmath179 , if @xmath143 is forced to false(true ) by unit propagation under @xmath177 then it is not forced to true(false ) by unit propagation under @xmath178 .",
    "let a variable @xmath143 be forced to trueby unit propagation under @xmath177 and to falseunder @xmath178 , but @xmath93 is falseunder both @xmath177 and @xmath178 .",
    "consider the partial instantiation @xmath137 such that if a variable @xmath180 is falsein either @xmath177 or @xmath178 , it is also falsein @xmath137 , otherwise it is unset .",
    "since @xmath137 fixes a superset of the literals that are fixed in either @xmath177 or @xmath178 , all clauses that became unit by either @xmath177 or @xmath178 will also be unit in @xmath137 .",
    "therefore , unit propagation under @xmath137 will force at least the union of the sets of literals forced by @xmath177 and @xmath178 .",
    "this means that unit propagation under @xmath137 will make both @xmath143 and @xmath181 true , which generates the empty clause .",
    "this is a contradiction , as @xmath91 can never produce the empty clause .",
    "[ cor : extra_var_false ] a cnf decomposition @xmath91 of a consistency checker @xmath28 over variables @xmath182 , can be polynomially converted into a decomposition @xmath163 of @xmath28 such that every variable in @xmath72 is either unset or falsewhen @xmath93 is false .",
    "we construct @xmath163 from @xmath91 by flipping the polarity of those variables that are set to truewhen @xmath93 is false .",
    "lemma  [ lemma : input var polarity ] and corollary  [ cor : extra_var_false ] allow us to precisely characterize the form of the clauses in a cnf decomposition .",
    "[ lemma : anti - horn ] let @xmath91 be a cnf decomposition of a consistency checker @xmath28 . the variables of @xmath91 can be renamed so that each clause has exactly one negative literal .    by lemma  [ lemma : input var polarity ] ,",
    "all input variables are positive literals in the decomposition and by definition [ defn : cnf - decomposition ] they are never forced by unit propagation on @xmath91 .",
    "in addition , by corollary  [ cor : extra_var_false ] , we can rename the auxiliary variables so that unit propagation on @xmath91 may only ever set them to false .",
    "then , in any clause that consists of input variables and one auxiliary variable @xmath143 , @xmath143 must be negative , otherwise it may be set to true , a contradiction .",
    "suppose there exists a clause @xmath183 with two auxiliary variables @xmath88 and @xmath100 and both are negative in @xmath183 .",
    "since neither @xmath88 nor @xmath100 can ever be made true , this clause can never become unit and can be ignored .",
    "suppose the literals of both @xmath88 and @xmath100 are positive in @xmath183 .",
    "then , if @xmath183 becomes unit , it makes one of the auxiliary variables true , a contradiction .",
    "thus , exactly one of the literals of @xmath88 and @xmath100 is negative in @xmath183 .",
    "the same reasoning can be extended to clauses with more than two auxiliary variables .",
    "the condition described by corollary  [ lemma : anti - horn ] is similar to @xmath91 being re - nameable anti - horn , but is stronger as it requires _ exactly _ one negative literal in each clause , rather than at most one .",
    "this condition allows us to build a monotone circuit from a decomposition , using the construction of the next lemma .",
    "[ lemma : cnf - to - mc ] let @xmath91 be a cnf decomposition of a consistency checker @xmath28 .",
    "then , there exists a monotone circuit @xmath136 of size @xmath184 that computes @xmath28 .",
    "+    we assume that @xmath91 is in the form described in corollary  [ lemma : anti - horn ] .",
    "the inputs of the circuit correspond to the input variables of @xmath91 . for each input variable @xmath38 of @xmath91",
    ", there exists an input @xmath65 of @xmath136 which is 0 if @xmath38 is falseand 1 otherwise .",
    "internal gates of the circuit correspond to auxiliary variables after a certain number of unit propagation steps , using the same mapping .",
    "we create a circuit with @xmath185 _ layers _ @xmath186 .",
    "let @xmath187 be the clauses of @xmath91 .",
    "the @xmath188 layer of the circuit contains an @xmath189 for each clause @xmath190 , called _ clause gates _ and an @xmath191 for each auxiliary variable @xmath192 , called _",
    "variable gates_. consider a clause @xmath190 which contains @xmath181 as the sole negative literal ( recall that corollary  [ lemma : anti - horn ] ensures that this is the case ) , the positive literals of input variables @xmath193 and the positive literals of auxiliary variables @xmath194 .",
    "the inputs of each gate @xmath195 are @xmath196 and @xmath197 .",
    "let the clauses with @xmath198 as the sole negative literal be @xmath199 .",
    "then , the inputs of each gate @xmath191 are @xmath200 .",
    "the output of the circuit is @xmath201 .",
    "note that in this construction the inputs of some the gates may not be defined .",
    "this is the case , for example , for the gate @xmath202 , where the clause @xmath203 contains the positive literals of some auxiliary variables .",
    "if this happens for a clause gate , we omit it , while if it happens for a variable gate , we omit the undefined input . if all the inputs of a variable gate are undefined , we omit the gate .",
    "this construction computes one breadth first application of unit propagation at each layer .",
    "specifically , the gate @xmath191 is 0 iff @xmath192 is forced to falseafter @xmath64 or fewer breadth first steps of unit propagation , while the gate @xmath189 is 0",
    "iff the negated variable in @xmath190 is forced to falseafter @xmath64 or fewer breadth first steps of unit propagation .",
    "we show this by induction . for the first layer ,",
    "there exist gates only for clauses with no positive literals of auxiliary variables .",
    "consider any such gate @xmath190 which contains the negative literal @xmath198 .",
    "all the propositional variables in @xmath190 except @xmath192 are false iff the corresponding inputs are 0 . thus @xmath204 is 0 iff @xmath192 is falseafter unit propagation of @xmath190 .",
    "if many clauses contain the negative literal @xmath198 , then at least one of them sets @xmath192 to falsein one breadth first step iff there exists a clause gate that is 0 and is an input to the variable gate @xmath205 , which is an and is thus 0 . for the inductive step ,",
    "assume that the layers @xmath206 compute @xmath207 breadth first steps of unit propagation .",
    "the same reasoning as for the base case shows that the results of unit propagation are correctly computed for the @xmath208 layer .",
    "note that the @xmath208 layer may also contain gates that were omitted at previous levels .",
    "since the inputs of these gates are correctly computed by the inductive hypothesis , the gates that are new to the @xmath208 layer are also correctly computed .    to conclude the proof ,",
    "observe that in the extreme case , unit propagation will set one more literal at every breadth first step , thus after @xmath185 steps it must either arrive at a fixpoint or set all literals .",
    "since the circuit has @xmath185 layers , it will correctly compute the result of unit propagation on @xmath91 .",
    "we illustrate the construction of lemma  [ lemma : cnf - to - mc ] with an example .",
    "[ ex : cnf - to - mc ] consider the cnf decomposition @xmath209 , where @xmath210 , @xmath211 , @xmath212 , @xmath213 , @xmath214 .",
    "we construct a monotone circuit @xmath136 from @xmath91 , ( figure  [ fig : good_circuit ] ) . for a given instantiation of the input variables ,",
    "this circuit computes 0 for the corresponding boolean inputs if and only if unit propagation on @xmath91 forces the output variable to false .",
    "the circuit consists of 3 layers , with gates 1 and 2 in the first layer , 38 in the second and gate 9 in the third .",
    "the gates 16 and 9 are clause gates , while gates 7 and 8 are variable gates .",
    "a strict application of the construction of lemma  [ lemma : cnf - to - mc ] would also have variable gates in layers 1 and 3 , but we omit them here as they would be single - input gates .",
    "note that in figure  [ fig : good_circuit ] , inputs are replicated at each layer to reduce clutter .",
    "we note also that the layered construction of lemma  [ lemma : cnf - to - mc ] is necessary . a circuit that attempts to capture unit propagation on all clauses without using layers would have to contain a cycle between the gates that compute @xmath88 and @xmath100 , because @xmath88 would need to be an input of the clause gate @xmath215 that computes @xmath100 and @xmath100 would need to an input of the clause gate @xmath216 that computes @xmath88 .",
    "constructing a layered circuit allows us to remove such cycles .",
    "the proof of theorem  [ thm : cnf_mc_equiv ] is now immediate from lemmas  [ lemma : mc_cnf ] and [ lemma : cnf - to - mc ] .",
    "since cnf decompositions of consistency checkers can be converted in polynomial time to and from cnf decompositions of propagators , theorem  [ thm : cnf_mc_equiv ] also holds for propagators .",
    "corollary  [ cor : alldiff ] now uses an existing circuit complexity result to show that , unsurprisingly , there is no polynomial size cnf decomposition of the domain consistency propagator for the constraint .",
    "this also applies to generalizations of , such as .",
    "[ cor : alldiff ] there is no polynomial sized cnf decomposition of the domain consistency propagator .",
    "rgin  @xcite showed that an constraint has a solution iff the corresponding bipartite value graph ( i.e. , the graph where the node representing a variable has an edge to every node that represents a value in its domain ) has a perfect matching .",
    "in addition , every bipartite graph corresponds to the value graph of an constraint and dc propagators detect dis - entailment .",
    "thus , if there exists a polynomial size cnf decomposition of the dc propagator , we can construct a monotone circuit that computes whether a bipartite graph has a perfect matching .",
    "but razborov  @xcite showed that the smallest monotone circuit that computes whether there exists a perfect matching for a bipartite graph is super - polynomial in the number of vertices in the graph .",
    "therefore , the smallest cnf decomposition of the dc propagator is super - polynomial in size .",
    "on the other hand , bound and range consistency propagators of can be decomposed , as we argue in  @xcite .",
    "in this paper we have shown how the tools of circuit complexity can be used to study decompositions of global propagators into cnf .",
    "our results directly extend to decompositions into csp constraints of bounded arity with domains given in extension since such decompositions can be translated into clauses of polynomial size .",
    "an interesting next step is to consider the decomposability of constraint propagators into more expressive primitive constraints where domains are represented in logarithmic space via their bounds .",
    "csp solvers provide this feature which is missing in cnf .",
    "we conjecture that there exists an equivalence between such csp decompositions of constraint propagators and monotone arithmetic circuits that are generalizations of boolean monotone circuits to real numbers and gates for addition and multiplication . since lower bound results on monotone circuits usually transfer to monotone arithmetic circuits",
    ", this would imply that the domain consistency propagator for can not be decomposed to constraints that exploit ( exponentially ) large domains .                c. bessiere , e. hebrard , b. hnich , z. kiziltan and t. walsh .",
    "the range constraint : algorithms and implementation . in _",
    "3rd int . conf . on integration of ai and or techniques in cp ( cp - ai - or ) _ , 5973 , 2006 .          c. bessiere , g. katsirelos , n. narodytska , c .- g . quimper and t. walsh .",
    "decompositions of all different , global cardinality and related constraints . in _",
    "joint conf . on ai",
    "_ , 2009 . s. brand , n. narodytska , c .- g .",
    "quimper , p. stuckey and t. walsh .",
    "encodings of the sequence constraint . in _",
    "13th int . conf . on principles and practice of cp ( cp2007 )",
    "_ , 210224 ."
  ],
  "abstract_text": [
    "<S> we show that tools from circuit complexity can be used to study decompositions of global constraints . </S>",
    "<S> in particular , we study decompositions of global constraints into conjunctive normal form with the property that unit propagation on the decomposition enforces the same level of consistency as a specialized propagation algorithm . </S>",
    "<S> we prove that a constraint propagator has a a polynomial size decomposition if and only if it can be computed by a polynomial size monotone boolean circuit . </S>",
    "<S> lower bounds on the size of monotone boolean circuits thus translate to lower bounds on the size of decompositions of global constraints . for instance </S>",
    "<S> , we prove that there is no polynomial sized decomposition of the domain consistency propagator for the constraint . </S>"
  ]
}