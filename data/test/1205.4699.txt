{
  "article_text": [
    "the disciplined software engineering relies on software architectures to describe systems  @xcite . for modeling a software architecture ,",
    "the academy proposed the architecture description language ( adl ) and their toolsets  @xcite .",
    "also , the industry has used adls to develop systems .",
    "industry examples are ( i ) @xmath0-adl has been used to architect and refine federated knowledge management systems in engineering ingegneria informatica - italy  @xcite ; ( ii ) and aadl ( architecture analysis & design language ) is a standard language for the society of automotive engineers  @xcite . according to the state - of - the - art  @xcite ,",
    "the following concepts are relevant to describe software architectures : components and connectors ( respectively computational and communication elements ) , architectural constraints , non functional properties , and behaviour .",
    "software systems evolve over their life time  @xcite .",
    "dynamic reconfiguration is when the evolution is performed at runtime with no service disruption .",
    "the dynamic reconfiguration can be handled by architectural concepts in an adl . however among many existing adls , only few allow modeling dynamic reconfiguration .",
    "@xmath0-adl  @xcite , acme / plastik  @xcite , c2sadl  @xcite , daop - adl  @xcite , darwin  @xcite , dynamic wright  @xcite , rapide  @xcite , weaves  @xcite , and xadl  @xcite are typical examples .",
    "nevertheless , there is no current consensus about how adls should address reconfiguration , e.g. , what language constructs should be provided .    in this work ,",
    "the goal is twofold : ( i ) to investigate the adls support for handling dynamic reconfiguration in the literature ; and , ( ii ) to illustrate how four well - known adls support dynamic reconfiguration : @xmath0-adl , acme , c2 sadl and dynamic wright .",
    "we chose these four languages because they rely on different paradigms : the higher order typed @xmath0-calculus  @xcite , first order predicate logic  @xcite , compo - nent- and event - based  @xcite , and , graph grammars and communicating sequential processes ( csp )  @xcite , respectively .",
    "they also complement each other as @xmath0-adl models the behavior of architectures , acme focuses on the structure , c2sadl make the attention for components and their concurrent events , and dynamic wright supports the definition of structure and behavior .",
    "this work is structured as follows .",
    "section  [ section : motivation ] motivates this work thanks to the example of a tcp / ip stack system .",
    "three scenarios illustrate three facets of dynamic reconfiguration .",
    "section  [ section : concepts ] presents the basics concepts of software architecture and dynamic reconfiguration .",
    "section  [ section : related - works ] details the related works about dynamic reconfiguration at the architecture level .",
    "section  [ section : comparison ] compares the four above - mentioned adls in the light of our example of section  [ section : motivation ] .",
    "section  [ section : conclusion ] concludes the paper with open issues that we note in the adl support for dynamic reconfiguration .",
    "dynamic reconfiguration aims at modifying the software systems at runtime with no service disruption .",
    "critical systems usually want to benefit of a dynamic reconfiguration because any service disruption may have substantial consequences .",
    "examples of critical systems are stock market quotation systems , telecommunications systems , safety systems , and air traffic control systems . however , there is no current consensus about how the software architecture should address dynamic reconfiguration at architecture level .",
    "does regular syntax for dynamic architectures allow the same reconfigurations as specific language constructs ? should the state of components and connectors be taken into account at the architecture level ?    to support this work ,",
    "we rely on a simplified version of the tcp / ip stack ( fig .",
    "[ fig : tcpip - stack ] ) .",
    "each of the four layers ( application , transport , internet , and link ) is modeled as a component ( fig .",
    "[ fig : tcpip - system ] ) .",
    "we consider the three following reconfigurations :    1 .",
    "_ switch the application component .",
    "_ assume two alternatives : mpeg - decoder and h263-decoder .",
    "mpeg - decoder is used if _ bandwidth _ is high ( fig .",
    "[ fig : tcpip - mpeg ] ) . otherwise h263-decoder is selected ( fig  [ fig : tcpip - h263 ] ) .",
    "switching between mpeg and h263 starts a new stream .",
    "therefore , no state in the decoder needs be kept .",
    "we can therefore replace one component by another .",
    "insertion of a new component type .",
    "_ presume that the internet protocol version 6 ( ipv6 ) replace the version 4 ( ipv4 ) ( fig .",
    "[ fig : tcpip - ipv6 ] ) .",
    "the ipv6 component has backward compatibility with the ipv4 component .",
    "so it has the ports for both ipv4 ( for compatibility reason ) and for ipv6 ( new feature ) .",
    "therefore , the type of the component at the internet layer is changed : it has 2 additional ports .",
    "_ update a component type . _",
    "assume that the algorithm of error control of the transport component is improved .",
    "when the error control algorithm is changed , the new behaviour needs to know the status of each packet ( acknowledged , sent , timeout , ... ) as well as the content of non - acknowledged packets ( in order to resend them ) .",
    "therefore , only the behaviour part of the component should be replaced .",
    "the state of the component should be unchanged .",
    "these scenarios cover a wide spectrum .",
    "they can either be programmed at design - time or be discovered at run - time .",
    "they feature reconfiguration at both type and instance level .",
    "they target both the structure and the behaviour of the architecture .",
    "we investigate the adls literature in order to illustrate how reconfiguration is supported in these scenarios .    in this paper",
    ", we focus on four adls that are representative of the main trends .",
    "each adls complement the other . the complement at the sense for describing an initial architecture as well as dynamic reconfiguration .",
    "we choose @xmath0-adl because it provides both description with behaviours thanks to its @xmath0-calculus roots . whilst the acme / plastik is a declarative language with focus on the architecture structure for both descriptions . while c2sadl is used to compose architectures based on component and dynamic reconfiguration based on architectural events",
    ". finally , dynamic wright provides support for architectural description based in graph - grammars and dynamic reconfiguration specification with a variant of communicating sequential processes ( csp ) .",
    "[ [ software - architecture - concepts ] ] software architecture concepts + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    software architectures + describe systems by specifying their elements and the interactions between them  @xcite . in this work , we use the basics concepts defined in  @xcite : a _ component _ is an unit of computation and storage ; a _ connector _ is an unit of communication ; and , a _ configuration _ is a specification of a software architecture in terms of components , connectors , and relationship between them .    ports , roles , behaviours , constraints , and non - functional properties are other concepts defined in  @xcite used to describe these architectural elements .",
    "ports and roles are used to define the way of interaction , ports for configurations and components , and roles for connectors .",
    "behaviours are the architectural element internal computation . and",
    "the last two concepts , constraints and non - functional properties , are used to denote the assertions , invariants , quality of service that architectural elements are expected to meet .    also , we consider types and instances of configurations , components , and connectors for modelling a software architectures  @xcite .",
    "the types are abstractions like classes in the object - oriented paradigm which encapsulate both the structure and the behaviours that can be performed on its structure .",
    "these types will be used to build the instances and these instances will be used to describe software architectures .    fig .",
    "[ code : tcpip - acme ] illustrates in acme the basics concepts with our example tcp / ip stack system ( sec .",
    "[ section : motivation ] fig .",
    "[ fig : tcpip - system ] ) at instance and type level .",
    "the types are defined in the ` family ` statement block ( lines 1 - 18 ) while the instance level in ` system ` ( lines 20 - 30 ) .",
    ".... family tcpip_mf {    . .",
    "connector type tcpip_conn2layers {      providedrole source ;      requiredrole sink ;    } ;    component type tcpip_component {      port type datafrom extends providedport with { } ;      port type datato extends revidedport with { } ;      property type layer = enum{application , transport , internet , link }    } ;    component type tcpip_application extends tcpip_component with {      port datareceivedfromtransport : datafrom ;      port requiredservice : datato ;      property layer = \" application \" ;    } ;    . .",
    "}    system decoderstream : tcpip_mf = new tcpip_mf extended with {    component application : tcpip_application ;    component transport : tcpip_transpot ;    component internet : tcpip_internet ;    component link : tcpip_link ;        connector       application2transport , transport2internet , internet2link : conn2layers ;    attchments {      application.requiredservice to application2transport.source ;      application2transport.sink to transport.service ;        transport.requiredservice to transport2internet.source ;      transport2internet.sink to internet.service ;        internet.requiredservice to internet2link.source ;      internet2link.sink to link.service ;    }    . .",
    "} ....    [ [ dynamic - reconfiguration - concepts ] ] dynamic reconfiguration concepts + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a dynamic reconfiguration is a set of operations to modify an existing configuration at runtime . at the software architecture level",
    ", the operation is defined in terms of the architectural elements at type or instance level .",
    "scenario 1 is an example of reconfiguration at the instance level ( mpeg and h263 share the same type ) ; and scenario 2 is an example of reconfiguration at the type level ( ipv6 extends the type of ipv4 ) .    also , the dynamic reconfiguration can be foreseen or unforeseen  @xcite .",
    "the foreseen is a programmed dynamic reconfiguration specified at design time . while the unforeseen is an ad - doc defined at runtime .",
    "example of foreseen and unforeseen is the scenario 1 and 3 , respectively . in the scenario 1 ,",
    "the architect specify at design time that the system modify itself when the bandwidth change . whereas the behaviour improvement is built at runtime as defined in scenario 3 .",
    "medvidovic and taylor  @xcite created a classification framework based on architectural elements and illustrated them with the following adls : acme , aesop , c2 , darwin , metah , rapide , sadl , unicon , weaves , and wright .",
    "however , this work has no focus on the dynamic reconfiguration .",
    "hence , its discussion about dynamic reconfigurations is limited , e.g. all adls were assessed only at the instance level , not at the type level .",
    "kacem _ et al . _",
    "@xcite described the capabilities of darwin , archjava , olan , rapide , wright , and acme to support dynamic reconfiguration .",
    "they classify the adls as configuration and description language .",
    "the configuration language supports the description of a software system and limited dynamic reconfigurations , while the description language supports the specification of modifications to be applied to an existing architecture . despite this work focus",
    "is on dynamic reconfiguration , it also presents some limitations such as the fact that the evolution is applied only at instance level and do not take into account the behaviour of the architectural elements .",
    "bradbury  @xcite and bradbury _ et al . _",
    "@xcite proposed a framework to compare fourteen formal specification approaches which support dynamic software architectures . amongst the criteria , bradbury _ et al .",
    "_ considered the basic operations , how they can be composed and whether they apply to variable sets of architectural element types .",
    "about the basic operations ( addition and removal of components and connectors ) , bradbury et al",
    ". showed that most approaches support them . also , they considered the criterion of operations composition ( basic , sequence , choice , and iteration ) . only 3 approaches",
    "( community , dynamic wright , and gerel ) provide full support while the other only support basic composition .",
    "finally , bradury _ et al .",
    "_ mentioned that all approaches support only the types of architectural elements defined prior runtime , fixed sets of architectural elements .",
    "while adl surveys have reached good understanding of the concepts underlying software architectures ( medvidovic and taylor  @xcite ) , this is not true regarding dynamic reconfiguration at the architecture level .",
    "even bradbury  @xcite and bradbury _ et al . _",
    "@xcite , probably the most complete surveys , do not consider operations such as insertion of configuration and behaviour modification .",
    "they do not recognize _ link _ and _ unlink _ as basic operations .",
    "however , they present the examples of these operations on some approaches , like gerel and c2sadl . considering the scenarios of section  [ section :",
    "motivation ] , these related works address only the first scenario ( partially ) but not the two last .",
    "consequently , it is clear that to discuss the three scenarios presented in section  [ section : motivation ] is essential to have a better understanding of the dynamic reconfiguration issues .",
    "these scenarios consider both instance and type levels , the basic operations include configurations , components , and connectors , as well as their structures and behaviours .",
    "in this subsection , we describe the scenarios defined in sec .",
    "[ section : motivation ] in all four adls : @xmath0-adl ( subsection  [ sec : pi - adl ] ) , acme / plastik ( subsection  [ sec : acme ] ) , c2sadl ( subsection  [ sec : c2sadl ] ) , and dynamic wright ( subsection  [ sec : wright ] ) . for each adl",
    "we show the purpose , the tcp / ip stack system , a solution for three scenarios , and discussion about this implementation .      [ [ purpose - of - the - adl ] ] purpose of the adl + + + + + + + + + + + + + + + + + +    @xmath0-adl is based on @xmath0-calculus and it is designed to describe the concurrent and mobile systems  @xcite . the description of architectural elements is mainly represented by ports and behaviour .",
    "[ [ dynamic - reconfiguration - support ] ] dynamic reconfiguration support + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    this adl provides + support for foreseen and unforeseen dynamic reconfiguration .",
    "the foreseen can be described in the behaviour of any architectural elements . while unforeseen needs some support , e.g. , in the virtual machine ( vm ) , in order to obtain a root reference to the reconfigured system . in archware , this issue is addressed by the deep intrication between the toolset ( including the visual and textual editors ) and the vm thanks to the hyper - code technology  @xcite .",
    "[ [ initial - architecture ] ] initial architecture + + + + + + + + + + + + + + + + + + + +    the implementation of tcp / ip stack system is shown in fig .",
    "[ code : tcpip - piadl ] .",
    "the configuration is composed at lines 1 - 18 basically with a behaviour , statement ` behaviour ` is ... where ... ! ( lines 2 - 17 ) .",
    "this architectural behaviour defines the instances of components ( lines 3 - 6 ) and connectors ( lines 7 - 9 ) .",
    "the statement ` where ` in behaviour specifies the connections between components and connectors ( lines 11 - 16 ) .",
    "the example of component ` tcpip_application ` is partially showed at lines 20 - 35 : two ports and a behaviour .",
    "the component behaviour is implemented with two internal methods ( lines 24 - 25 ) and the definition of communication between its ports ( lines 27 - 33 ) .    .... archictecture tcpip is abstraction ( ) {    behaviour is compose {      application is tcpip_application ( )      and transport   is tcpip_transport ( )      and net         is tcpip_internet ( )      and link        is tcpip_link ( )      and app2transp is conn2layers ( )      and transp2net is conn2layers ( )      and net2link    is conn2layers ( )    } where {      appliation::request     unifies app2transp::source      and app2transp::sink    unifies transport::service      and transpost::request unifies transp2net::source      and transp2net::sink    unifies net::service      and net::request        unifies net2link::source      and net2link::sink      unifies link::service    } }    component tcpip_application is abstraction ( ) {     port service is { ... } .     port request is { ... } .     behaviour is {        processrequest is function(d : datatype):datatype { unobservable}.        processresponse is function(d : datatype):datatype { unobservable}.          choose {           via service::wait receive entrydata : datatype .           via request::call send processrequest(entrydata ) .        or           via request::response receive replydata : datatype .",
    "via service::reply send processresponse(replydata ) .        }     } }    component tcpip_transport is abstraction ( ) { ... }    component tcpip_internet is abstraction ( ) { ... }    component tcpip_link is abstraction ( ) { ... }    connector conn2layers is abstraction ( ) {    ...    port source is { ... }    port sink is { ... }      behaviour is { ... } } ....    [ [ scenario-1 ] ] scenario 1 + + + + + + + + + +    the implementation of scenario 1 in @xmath0-adl is composed by a component that performs the dynamic reconfiguration ( fig .",
    "[ code : scenario1-piadl ] ) .",
    "this component has two parameters : the application component and the system component .",
    "both are represented as a behaviour .",
    "the application component is a mpeg - decoder or h263-decoder .",
    "still , this component is structured with seven `` variables '' and a behaviour , lines 2 - 4 and 5 - 27 , respectively .",
    "the variables are used for behaviours of components and connectors . to perform the modification ,",
    "the behaviour component use the following steps : decomposition the system behaviour ( line 6 ) ; assign the behaviours to variables ( lines 8 - 14 ) ; compose a new system behaviour ( lines 16 - 26 ) with a replaced application component ( line 20 ) .",
    ".... component reconfiguration is abstraction(application : behaviour , system : behaviour ) {     behaviours : sequence[behaviour ] .",
    "transport : behaviour .",
    "net : behaviour .",
    "link : behaviour .",
    "app2transp : behaviour .",
    "transp2net : behaviour .",
    "net2link : behaviour .",
    "behaviour is {        behaviours : = decompose system .",
    "transport : = behaviours::1::bhvr .",
    "net : = behaviours::2::bhvr .",
    "link : = behaviours::3::bhvr .",
    "app2transp : = behaviours::4::bhvr .",
    "transp2net : = behaviours::5::bhvr .",
    "net2link : = behaviours::6::bhvr .",
    "compose {           application and transport and net and link           and app2transp and transp2net and net2link        } where {           appliation::request     unifies app2transp::source           and app2transp::sink    unifies transport::service           and transpost::request unifies transp2net::source           and transp2net::sink    unifies net::service           and net::request        unifies net2link::source           and net2link::sink      unifies link::service        }     } } ....    [ [ scenario-2 ] ] scenario 2 + + + + + + + + + +    the implementation for the unforeseen scenario 2 is shown in fig .",
    "[ code : scenario2-piadl ] .",
    "this code is applied in a system at runtime to deploy the two new component `` type '' .",
    "first , the component type is a new protocol _ ipv6 _ ( lines 1 - 3 ) , and the second is a component to perform dynamic reconfiguration ( lines 4 - 32 ) . in order to execute this dynamic reconfiguration two steps are applied : ( i ) to obtain the root behaviour of the system , and ( ii ) to invoke the computation of the reconfiguration component .",
    "both operations are aided by toolset and hyper - code .",
    "the code of the reconfiguration component is described using the following steps : ( i ) to decompose the behaviours of the system in components and connectors ( lines 9 ) ; ( ii ) to assign to `` variables '' the instances of components that represent application , transport , and link ( lines 11 - 13 ) ; ( iii ) to attribute connectors to `` variables '' ( lines 15 - 17 ) ; ( iv ) to compose a new system behaviour ( lines 19 - 30 ) with a new instance of the protocol ipv6 component ( line 21 ) .",
    "as in the scenario 1 , when performing a new composition , the behaviour of the system is automatically updated .",
    ".... component tcpip_ipv6 is abstracion ( ) {    ... } component reconfiguration is abstraction(system : behaviour ) {     behaviours : sequence[behaviour ] .",
    "application : behaviour .",
    "transport : behaviour .",
    "link : behaviour .",
    "app2transp : behaviour .",
    "transp2net : behaviour .",
    "net2link : behaviour .",
    "behaviour is {        behaviours : = decompose system .",
    "application : = behaviours::0::bhvr .",
    "transport : = behaviours::1::bhvr .",
    "link : = behaviours::3::bhvr .",
    "app2transp : = behaviours::4::bhvr .",
    "transp2net : = behaviours::5::bhvr .",
    "net2link : = behaviours::6::bhvr .",
    "compose {           application and transport and link           and net is tcpip_v6           and app2transp and transp2net and net2link        } where {           appliation::request     unifies app2transp::source           and app2transp::sink    unifies transport::service           and transpost::request unifies transp2net::source           and transp2net::sink    unifies net::service           and net::request        unifies net2link::source           and net2link::sink      unifies link::service        }     } } ....    [ [ scenario-3 ] ] scenario 3 + + + + + + + + + +    in the scenario 3 it is also used the process of decomposition , modification , and composition , as showed above .",
    "we use the archware virtual machine facility to get a reference to the root of the target transport component .",
    "after , we make a modification into the behaviour of the component . at last , the archware virtual machine synchronize the system with this modification .    [",
    "[ summary - of - pi - adl ] ] summary of @xmath0-adl + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    with these implementations , some issues are identified on @xmath0-adl support for dynamic reconfiguration :    1 .",
    "changing types needs external help , e.g. toolset , hyper - code and @xmath0-arl .",
    "toolset and hyper - code are used for capturing , specifying the changes , and applying the changes . while @xmath0-arl is a language to specify refinements in the system ; 2 .",
    "instances modifications can be specified in architectural elements or also with toolset and hyper - code help . at first , usually the dynamic reconfiguration is tangled with nominally behaviour .",
    "however , we used other approach with a specific component to specify dynamic reconfiguration ; 3 .   for the third scenario ,",
    "the @xmath0-adl do not provide a mechanism to design the intermediate states for updating the instances with the improvement of behaviour .",
    "however , if we use the @xmath0-arl approach , we can have better control ; 4 .   also with @xmath0-arl is possible build constraints and non - functional properties for architectural elements .",
    "however , it s not used to assess dynamic reconfiguration .",
    "[ [ purpose - of - the - adl-1 ] ] purpose of the adl + + + + + + + + + + + + + + + + + +    acme / armani is a declarative language based on the first - order predicate logic  @xcite .",
    "its initial purpose was to define a common interchange language for architecture design tools .",
    "also , its statements are designed to describe the architectural structures at instance and type levels .",
    "the extensions  @xcite to support dynamic reconfiguration preserves these initials purpose , and are named as acme / plastik .",
    "thereafter , any configuration and dynamic reconfiguration specified using this extension ( acme / plastik ) are based on the structure of an architecture .",
    "[ [ dynamic - reconfiguration - support-1 ] ] dynamic reconfiguration support + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    acme / plastik permits to describe foreseen and unforeseen dynamic reconfiguration . to unforeseen reconfiguration",
    "it is possible to describe as a specific behaviour of a configuration with the ` on ( $ conditional\\_expression$ ) do { $ operations$ } ` statement .",
    "unforeseen reconfiguration can be expressed in a script that will be applied in the system at runtime aided by a toolset provided by the plastik framework . both , @xmath1 and script are composed with acme statements and its acme / plastik extension .",
    "the @xmath2 is composed in the armani language  @xcite .",
    "[ [ initial - architecture-1 ] ] initial architecture + + + + + + + + + + + + + + + + + + + +    the example of the tcp / ip stack system in acme is showed in fig .",
    "[ code : tcpip - acme ] .",
    "the types are specified in the ` family ` statement while the instances are in the ` system ` statement . for types , a connector ( lines 3 - 6 ) and two components",
    "( lines 7 - 11 and 12 - 16 ) are implemented as example .",
    "the configuration is composed by the component instances ( lines 21 - 24 ) , connector instances ( lines 26 - 27 ) , and the connections between them ( lines 28 - 37 ) .",
    "[ [ scenario-1 - 1 ] ] scenario 1 + + + + + + + + + +    the implementation in acme / plastik of scenario 1 is showed in fig .",
    "[ code : scenario1-acme ] .",
    "the configuration is named with ` streamdecodersystem ` and it extends the ` tcpip_mf ` and ` plastikmf ` .",
    "the ` tcpip_mf ` is showed in fig .  [ code : tcpip - acme ] while ` plastik_mf ` in  @xcite .",
    "such configuration consists of : the insertion of two new components ( type and instance ) in lines 2 - 5 and line 6 ; the instantiation of components and connectors ( omitted with comment and @xmath3 in lines 7 - 8 ) ; the linking of components and connectors ( omitted with comment and @xmath3 in lines 7 - 8 ) ; and the specification of two dynamic reconfiguration situations , lines 12 - 19 and 21 - 28 .",
    "both dynamic reconfigurations use the same similar description .",
    "first , the conditional expressions are ` link.bandwidth = = ' low ' ` and ` link.bandwidth = = ' high ' ` .",
    "second , the @xmath1 are described as two unlinking ( lines 13 - 14 , 22 - 23 ) and one linking ( lines 15 - 18 , 24 - 27 ) statements .",
    "these @xmath1 specified the replacement of an instance of the component .",
    ".... system streamdecodersystem : tcpip_mf , plastikmf {    component mpeg - decoder : tcpip_mpegdecoder = new tcpip_application extend with {      property decoder - type = \" mpeg \" ;      property algorithm = ... ;    }    component h263-decoder : tcpip_h263decoder = new tcpip_application extend with { ... } // other instances of component and connector    ... //",
    "initial attachments    ... // programmed dynamic reconfiguration to low bandwidth    on ( link.bandwidth = = ' low ' ) do {      detach mpeg-decoder.requiredservice to application2transport.source ;      detach transport2application.sink to mpeg-decoder.datareceivedfromtransport ;      attachments {        h263-decoder.requiredservice to application2transport.source ;        transport2application.sink to h263-decoder.datareceivedfromtransport ;      }    } // programmed dynamic reconfiguration to high bandwidth    on ( link.bandwidth = = ' high ' )",
    "do {      detach h263-decoder.datato to application2transport.source ;      detach transport2application.sink to h263-decoder.datareceivedfromtransport ;      attachments {        mpeg-decoder.requiredservice to application2transport.source ;        transport2application.sink to mpeg-decoder.datareceivedfromtransport ;      }    } } ....    [ [ scenario-2 - 1 ] ] scenario 2 + + + + + + + + + +    the scenario 2 , an unforeseen insertion of a new component type , is describe with an acme / plastik script in fig .  [",
    "code : scenario2-acme ] . for this scenario ,",
    "the script is composed by : the insertion of a type and instance of a component ( lines 1 - 3 ) , the unlinking of the old component instance ( lines 5 - 6 ) and the linking of the new component ( lines 7 - 10 ) .    .... component ipv6 : tcpip_ipv6 = new tcpip_internet extended with {    ... }    detach ipv4.requiredservice to internet2link.source ; detach link2internet.sink to ipv4.datareceivedfromlink ; attachments {    ipv6.requiredservice to internet2link.source ;    link2internet.sink to ipv6.datareceivedfromlink ; } ....    [ [ scenario-3 - 1 ] ] scenario 3 + + + + + + + + + +    the unforeseen upgrade of a behaviour in scenario 3 can be described by the script illustrated in fig .",
    "[ code : scenario3-acme ] .",
    "this script defines a new version of a component with an improvement on its behaviour .",
    "the behaviour in acme / plastik is expressed as a property and it can be also described in other languages , such as external formal languages , see lines 3 - 5 in fig .",
    "[ code : scenario3-acme ] .",
    ".... component type tcpip_transport extends tcpip_component with {    ...    property behaviour = {       \\\\ description of behaviour in other languages , e.g. csp    }    ... } ....    [ [ summary - of - acmeplastik ] ] summary of acme / plastik + + + + + + + + + + + + + + + + + + + + + + +    the dynamic reconfiguration issues for acme can be summarized as follows :    1 .",
    "dynamic reconfiguration in terms of structure is supported by acme / plastik . in terms of behaviour",
    ", dynamic reconfiguration is described using any external language embedded inside the property element .",
    "usually , this is used for foreseen reconfiguration .",
    "this approach is limited in the sense that components and connectors usually needs the dynamic reconfiguration of their behaviour but as acme / plastik does not provides elements for behaviour specification , the architect has to rely on an external language .",
    "e.g. if the ` tcpip_transport ` component needs to decide if it has a buffer or not , and if it uses a error detecting or not , and so on .",
    "these situations have to be described using an external language ( in general formal languages such as csp ) .",
    "2 .   acme / plastik does not provide a mechanism to control the intermediate states of a reconfiguration .",
    "e.g. the implementation of the scenario 3 , the architect can not define the approach used to update the instances .",
    "3 .   for unforeseen",
    "reconfiguration acme / plastik relies on external scripts .",
    "this approach requires an external interpreted associated to the adl to interpret the external script in order to reconfigure the system .",
    "[ [ purpose - of - the - adl-2 ] ] purpose of the adl + + + + + + + + + + + + + + + + + +    initially , the purpose of c2 was to describe the architecture of a software based on a graphical user interface ( gui )  @xcite . therefore , the adl is based on hierarchically concurrent components .",
    "c2 also allows the use of messages to notify the architectural elements .",
    "c2 is subdivided in 2 languages : c2 idl ( interface description language ) for describing the components types , and c2 adl to specify the configurations .",
    "for components it is possible to specify top and bottom ports , to declare internal methods , and to specify the behaviour of its ports .",
    "the implementation of the internal methods is done by the developer in the source code generated by a toolset . with c2",
    "adl it is possible to define instances of components and connectors , as well as links between them .    [",
    "[ dynamic - reconfiguration - support-2 ] ] dynamic reconfiguration support + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the architectural + modification language ( aml ) was created to extend c2 for supporting dynamic reconfiguration  @xcite .",
    "aml is a declarative language that uses the structure view of an existing configuration and messages to notify this configuration about a dynamic reconfiguration .",
    "this language provides statements to build the scripts that specify dynamic reconfiguration .",
    "however , in these scripts it is not possible to determine the moment to apply a dynamic reconfiguration . because that , human intervention is needed via a toolset to trigger dynamic reconfiguration .",
    "[ [ initial - architecture-2 ] ] initial architecture + + + + + + + + + + + + + + + + + + + +    the tcp / ip stack system is described in c2 idl in fig .",
    "[ code : tcpip - c2idl ] and c2 adl in fig .",
    "[ code : tcpip - c2adl ] .    ....     ...     component tcpip_transport is        interface //",
    "define the component ports           top_domain is //",
    "ports to link high level connectors              out                 ...",
    "in                 receivedata(package : applicationpackage ) ;           bottom_domain is // ports to link low level connectors              out                 sendtointernt(package : transportpackage ) ;              in                 ...        methods //",
    "define interfaces of internal behaviours           function pack(data : applicationpackage ) : transportpackage ) ;           ...        behaviour // describe the external behaviour            ...           received_messages receivedata ;              invoke_methods pack ;              always_genarate sendtointernet ;           ...     end tcpip_transport     ... ....    ....     architecture decoderstream is        component_intances {           mpeg instantiates tcpip_mpegdecoder ;           h263 instantiates tcpip_h263decoder ;           transport instantiates tcpip_transport ;           internet instantiates tcpip_internet ;           link instantiates tcpip_link ;        }        connectors {           application2transport ;           transport2internet ;           internet2link ;        }        topology {           connector application2transport {              top_ports { mpeg filter no_filtering ; }              bottom_ports { transport filter no_filtering ; }           }           connector transport2internet {              top_ports { transport filter no_filtering ; }              bottom_ports { internet filter no_filtering ; }           }           connector internet2link {              top_ports { internet filter no_filtering ; }              bottom_ports { link filter no_filtering ; }           }        }     end decoderstream ; ....    [ [ scenario-1 - 2 ] ] scenario 1 + + + + + + + + + +    for scenario 1 , for changing the component according to the low or high bandwidth state , it is necessary two c2sadl scripts . in fig .",
    "[ code : scenario1-c2sadl ] is described the script for dynamic reconfiguration when bandwidth is low .",
    "this script uses two statements , a ` unweld ` for unlinking the @xmath4 instance and ` weld ` for linking the @xmath5 instance .",
    "other aml s statements are ` addcomponent ` , ` addconnector ` , ` removecomponent ` , and ` removeconnector ` .",
    "all these statements are used with a defined configuration , e.g. line 2 and 3 in fig .",
    "[ code : scenario1-c2sadl ] with the configuration named as ` decoderstream ` . despite of the fact that aml statements are based on services of the archstudio tool suite ,",
    "there are services that are not provided by the aml language , e.g. ` start ( ) ` and ` stop ( ) ` .",
    ".... \\\\ bandwidth is low decoderstream.unweld(mpeg , application2transport ) ; decoderstream.weld(h263 , application2transport ) ; ....    [ [ scenario-2 - 2 ] ] scenario 2 + + + + + + + + + +    the second scenario , the unforeseen insertion of component instance and type , is inferred as shown in fig .",
    "[ code : scenario2-c2sadl ] .",
    "inference because both work about aml  @xcite stated that it is possible to make insertion and deletion of types .",
    "however , they only show examples how to build dynamic reconfiguration at the instance level .",
    "et al . _",
    "@xcite mention types and subtypes but at design level .",
    "dynamic reconfiguration in fig .",
    "[ code : scenario2-c2sadl ] specifies : the insertion of a new type of component ( lines 2 - 5 ) , the creation a new instance of component ( line 9 ) , the unlinking of the instance of ipv4 ( lines 12 - 13 ) , and the linking of the instance of ipv6 ( lines 16 - 17 ) .",
    "the component type name is inferred by a toolset before performing dynamic reconfiguration .    .... \\\\ creata a new type of component component tcpip_ipv6 is subtype    all < = all tcpip_internet ( ... )    ... end tcpip_ipv6    // create a new instance of component //    the name of the type is implicitly discovered decoderstream.addcomponent(tcpip_ipv61 ) ;    // unlink the instance of component ipv4 decoderstream.unweld(trasport2internet , tcpip_ipv41 ) ; decoderstream.unweld(tcpip_ipv41 , internet2link ) ;    // link the instance of component ipv6 decoderstream.weld(trasport2internet , tcpip_ipv61 ) ; decoderstream.weld(tcpip_ipv61 , internet2link ) ; ....    [ [ scenario-3 - 2 ] ] scenario 3 + + + + + + + + + +    the third scenario is an improvement of the behaviour that can be modeled by the ` behaviour ` statement via a sequence of invocations to internal methods .",
    "example of this change , see line 6 in fig .",
    "[ code : scenario3-c2sadl ] , the invocation is modified to verify the received and packed data before sending a transport package to the internet layer . if the change is an improvement of an internal method , it is not possible to describe with c2sadl .    ....",
    "component tcpip_transport is        ...        behaviour // describe the external behaviour            ...           received_messages receivedata ;              invoke_methods verifydata , pack ;              always_genarate sendtointernet ;           ...     end tcpip_transport     ... ....    [ [ summary - of - c2sadl ] ] summary of c2sadl + + + + + + + + + + + + + + + + +    after the c2sadl implementation of the three scenarios , we identified these issues :    1 .",
    "archstudio tool provides some services for supporting dynamic reconfiguration , e.g. to start and to stop architectural elements .",
    "however , these services are not available in aml .",
    "thus , the dynamic reconfiguration specification in aml is limited .",
    "2 .   foreseen dynamic reconfiguration needs human intervention because c2sadl do not provide statements for the system apply dynamic reconfiguration .",
    "3 .   it does not support the specification of dynamic reconfiguration inside of the architectural elements . because that , the foreseen dynamic reconfiguration is implemented only at the implementation level ; 4 .",
    "it does not provide a mechanism for controlling and monitoring the intermediate states of a dynamic reconfiguration ; 5 .",
    "it also does not support the assessment of dynamic reconfiguration .",
    "[ [ purpose - of - the - adl-3 ] ] purpose of the adl + + + + + + + + + + + + + + + + + +    dynamic wright has focus on the structure and behaviour of an architecture  @xcite .",
    "dynamic wright supports the description of the architectural elements types structures and behaviours , and initial configuration .",
    "structure , initial configuration , instances , and links are described in a declarative form , while behaviours are specified in a graph - based and a variant of the communicating sequential process ( csp ) form .    [ [ dynamic - reconfiguration - support-3 ] ] dynamic reconfiguration support + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    dynamic wright only supports foreseen dynamic reconfiguration .",
    "it is built as a special behaviour of the initial configuration .",
    "it has the same base of a `` nominally '' behaviour of architectural elements .",
    "the extension described in  @xcite proposes additional statements and control events .",
    "the statements are ` new ` , ` remove ` , ` attach ` , and ` detach ` .",
    "the control events are used to define the specific moment to perform a dynamic reconfiguration .",
    "as dynamic wright does not support unforeseen reconfiguration , the scenarios 2 and 3 can not be implemented .",
    "[ [ initial - architecture-3 ] ] initial architecture + + + + + + + + + + + + + + + + + + + +    the initial configuration of the tcp / ip stack system is illustrated in fig .",
    "[ code : scenario1-wright ] .",
    "the component and connector types are specified in the ` style ... endstyle ` ( lines 1 - 16 ) statements . the implementation of the ` tcpip_``mpeg - decoder ` component is described with two ports ( lines 3 - 4 ) and a behaviour ( lines 6 - 7 ) . the configuration is described with the ` configuror ... endconfiguror ` statement . the initial configuration instances and connections",
    "are specified at lines 18 - 27 .",
    "[ [ scenario-1 - 3 ] ] scenario 1 + + + + + + + + + +    fig .",
    "[ code : scenario1-wright ] also illustrates the specification of scenario 1 .",
    "it uses the ` configuror [ initial configuration ] where [ behaviours ] ` statement . _",
    "behaviours _ are special named behaviours of the configuration for specifying dynamic reconfiguration . in this case , there are two specification : lines 29 - 36 for low bandwidth and lines 37 - 44 for high bandwidth .",
    "the following steps were used to define the first and the second dynamic reconfiguration situations :    1 .   to define a name ( lines 29 and 37 ) .",
    "2 .   to specify the control events that define the moment for performing the operations of dynamic reconfiguration ( lines 30 and 38 ) .",
    "3 .   to determine the type of configuration to use ( lines 31 and 39 ) .",
    "dynamic wright use the term ` style ` for this purpose .",
    "4 .   to specify the operations to perform dynamic reconfiguration ( lines 32 - 35 and 40 - 43 ) . 5 .   to use the statements of the external choice ( @xmath6 ) and successfully terminate ( @xmath7 ) , lines 36 and 44 .",
    ".... style tcpip - style     component tcpip_mpeg - decoder        port datareceivedfromtransport = ...        port requiredservice = ...            [ describe the port behaviour using a variant of csp ]        computation = ...            [ describe the component behaviour using a variant of csp ]     ...     connector conn2layers        role source = ...        role sink = ...        glue = ...            [ describe the connector behaviour using a variant of csp ]     constraints        ... endstyle configuror decoderstream    style tcpip - style      new.mpeg : tcpip_mpeg - decoder      $ \\rightarrow$ new.h263 : tcpip_h263-decoder      ... [ other component instances ]      $ \\rightarrow$ new.app2trans : conn2layers      $ \\rightarrow$ new.trans2net : conn2layers      $ \\rightarrow$ new.net2link : conn2layers      $ \\rightarrow$",
    "attach.mpeg.requiredservice.to.app2trans.source      $ \\rightarrow$ attach.app2trans.sink.to.transport.service      ... [ other attachments ]    where      waitforbandwidthlow = (      link.control.bandwidthdown $ \\rightarrow$ mpeg.control.off $ \\rightarrow$ h263.control.on      $ \\rightarrow$ style tcpip - style        detach.mpeg.requiredservice.to.app2trans.source        $ \\rightarrow$ attach.h263.requiredservice.to.app2trans.source        $ \\rightarrow$ detach.trans2app.sink.to.mpeg.datareceivedfromtransport        $ \\rightarrow$ attach.trans2app.sink.to.h263.datareceivedfromtransport      ) $ \\box$ $ \\s$      waitforbandwidthhigh = (         link.control.bandwidthup $ \\rightarrow$ h263.control.off $ \\rightarrow$ - > mpeg.control.on         $ \\rightarrow$ style tcpip - style            detach.h263.requiredservice.to.app2trans.source            $ \\rightarrow$ attach.mpeg.requiredservice.to.app2trans.source            $ \\rightarrow$ detach.trans2app.sink.to.h263.datareceivedfromtransport            $ \\rightarrow$ attach.trans2app.sink.to.mpeg.datareceivedfromtransport       ) $ \\box$ $ \\s$ endconfiguror ....",
    "[ [ summary - of - dynamic - wright ] ] summary of dynamic wright + + + + + + + + + + + + + + + + + + + + + + + + +    the following issues are identified after the implementation of the scenario 1 :    1",
    ".   it does not provide operations to define dynamic reconfiguration for the type level of architectural elements ; 2 .",
    "this adl provides a refined mechanism of control events to determine the moment to perform a dynamic reconfiguration .",
    "although , it does not provide a mechanism to control and monitor the intermediate states .",
    "e.g. if the application of the scenario 1 is a banking system , the state must be copied from the instance of the replaced component to the new component .",
    "dynamic wright does not provide operations for this purpose .",
    "3 .   despite of providing the specification of behaviour for components and connectors ,",
    "it is not possible to define dynamic reconfiguration for this architectural elements ; 4 .",
    "similarly to the other adls , dynamic wright does not provide a mechanism for the assessment of dynamic reconfiguration .",
    "the summary of the four adls support for dynamic reconfigurations is shown in tab .",
    "[ tab : reconfiguration ] .",
    "@xmath0-adl and acme / plastik are the only adls that support both foreseen and unforeseen dynamic reconfigurations .",
    "as c2sadl with the aml language do not provide a way to specify an internal initiation of dynamic reconfiguration , foreseen dynamic reconfiguration can not be automatically triggered .",
    "dynamic wright supports only foreseen reconfiguration by defining the special behaviour of a configuration .",
    ".foreseen and unforeseen dynamic reconfiguration support in adls . [ cols=\"<,<,<\",options=\"header \" , ]",
    "none of the four adls has a mechanism for assessing the system .",
    "@xmath0-adl can rely on @xmath0-aal for defining and analyzing the architectural constraints and non - functional properties . while acme / plastik has armani . even though it has no formal semantics , and therefore , it is not liable to rigorous analysis  @xcite .",
    "c2sadl provides type verification for events communication .",
    "dynamic wright provides a refined mechanism of control events to determine the moment to perform a dynamic reconfiguration .",
    "although , the assessment of dynamic reconfiguration is not provided on four adls .",
    "in this paper we analysed the support of adls for handling dynamic reconfigurations .",
    "we started with a motivation example and some reconfiguration scenarios and we described the example and the scenarios using four well - known adls .",
    "we used the example and the specifications to discuss the following issues : ( i ) how each adl addresses the issue of consistently reconfiguring both instances and types ; ( ii ) how each adl takes into account the behaviour of the architectural elements during reconfiguration ; and ( iii ) how each adl supports the assessing of dynamic reconfiguration .    in comparison to related works , we analysed some important issues for the dynamic reconfiguration support at the architectural level : foreseen and unforeseen changes ; instance and type level modifications ; structure and behaviour for all architectural elements ; definition of nominally and dynamic reconfiguration behaviour for all architectural elements ; and , the analysis of dynamic reconfiguration .    we can conclude that some issues still remain open as no adl provides support for all of them together : how to apply the changes made in type level to their respective instances ?",
    "how to control the set of intermediate states of a software system during a dynamic reconfiguration ?",
    "how to assess dynamic reconfiguration ?",
    "special thanks to collge doctoral international ( cdi)/uni - versit europenne de bretagne ( ueb ) for financial support this work .",
    "r.  allen , r.  douence , and d.  garlan . specifying and analyzing dynamic software architectures . in _ proceedings of the 1998 conference on fundamental approaches to software engineering ( fase98 )",
    "_ , lisbon , portugal , march 1998 . an expanded version of a the paper `` specifying dynamism in software architectures , '' which appeared in the proceedings of the workshop on foundations of component - based software engineering , september 1997 .",
    "t.  v. batista , a.  t.  a. gomes , g.  coulson , c.  chavez , and a.  f. garcia . on the interplay of aspects and dynamic reconfiguration in a specification - to - deployment environment . in _ proceedings of the 2nd european conference on software architecture _ , ecsa 08 , pages 314317 , berlin , heidelberg , 2008 .",
    "springer - verlag .",
    "k.  h. bennett and v.  t. rajlich . software maintenance and evolution : a roadmap . in _ proceedings of the conference on the future of software engineering _ , icse 00 , pages 7387 , new york",
    ", ny , usa , 2000 .",
    "acm .",
    "d.  garlan , r.  monroe , and d.  wile .",
    "acme : an architecture description interchange language . in _ proceedings of the 1997 conference of the centre for advanced studies on collaborative research_. ibm press , 1997 .",
    "a.  gomes , t.  v. batista , a.  joolia , and g.  coulson . .",
    "in r.  de  lemos , c.  gacek , and a.  romanovsky , editors , _ architecting dependable systems iv _ , volume 4615 of _ lecture notes in computer science _ ,",
    "pages 237261 .",
    "springer berlin / heidelberg , berlin , heidelberg , 2007 .        j.  magee and j.  kramer .",
    "self organising system structuring . in _",
    "joint proceedings of the second international software architecture workshop ( isaw ) and international workshop on multiple perspectives in software development ( viewpoints 96 ) on sigsoft 96 workshops _ , isaw 96 , pages 3538 , new york , ny , usa , 1996 .",
    "acm press .",
    "n.  medvidovic , p.  oreizy , j.  e. robbins , and r.  n. taylor .",
    "using object - oriented typing to support architectural design in the c2 style . in _ proceedings of the 4th acm",
    "sigsoft symposium on foundations of software engineering _ , sigsoft 96 , pages 2432 , new york , ny , usa , 1996 .",
    "acm .",
    "p.  oreizy , m.  m. gorlick , r.  n. taylor , d.  heimbigner , g.  johnson , n.  medvidovic , a.  quilici , d.  s. rosenblum , and a.  l. wolf .",
    "an architecture - based approach to self - adaptive software .",
    ", 14(3):5462 , may / june 1999 .",
    "p.  oreizy , n.  medvidovic , and r.  n. taylor .",
    "architecture - based runtime software evolution . in _ proceedings of the 20th international conference on software engineering _ , icse 98 , pages 177186 , washington , dc , usa , 1998 .",
    "ieee computer society .",
    "p.  oreizy and r.  n. taylor . on the role of software architectures in runtime system reconfiguration . in _ configurable distributed systems , 1998 .",
    "fourth international conference on _ , pages 6170 , may 1998 .",
    "m.  pinto , l.  fuentes , and j.  m. troya .",
    "daop - adl : an architecture description language for dynamic component and aspect - based development . in",
    "_ proceedings of the 2nd international conference on generative programming and component engineering _ , gpce 03 , pages 118137 , new york , ny , usa , 2003 .",
    "springer - verlag new york , inc .",
    "r.  n. taylor , n.  medvidovic , k.  m. anderson , j.  whitehead , e.  james , j.  e. robbins , k.  a. nies , p.  oreizy , and d.  l. dubrow .",
    "a component- and message - based architectural style for gui software . , 22(6):390406 , june 1996 .",
    "j.  vera , l.  perrochon , and d.  c. luckham .",
    "event - based execution architectures for dynamic software systems . in _ proceedings of the tc2 first working ifip",
    "conference on software architecture ( wicsa ) _ , wicsa , pages 303318 , deventer , the netherlands , the netherlands , 1999 .",
    "kluwer , b.v .",
    "p.  waewsawangwong .",
    "a constraint architectural description approach to self - organising component - based software systems . in _ proceedings of the 26th international conference on software engineering _",
    ", icse 04 , pages 8183 , washington , dc , usa , 2004 . ieee computer society ."
  ],
  "abstract_text": [
    "<S> dynamic reconfiguration is the action of modifying a software system at runtime . </S>",
    "<S> several works have been using architectural specification as the basis for dynamic reconfiguration . indeed adls ( architecture description languages ) </S>",
    "<S> let architects describe the elements that could be reconfigured as well as the set of constraints to which the system must conform during reconfiguration . in this work </S>",
    "<S> , we investigate the adl literature in order to illustrate how reconfiguration is supported in four well - known adls : @xmath0-adl , acme , c2sadl and dynamic wright . from this review , we conclude that none of these adls : ( i ) addresses the issue of consistently reconfiguring both instances and types ; ( ii ) takes into account the behaviour of architectural elements during reconfiguration ; and ( iii ) provides support for assessing reconfiguration , e.g. , verifying the transition against properties . </S>"
  ]
}