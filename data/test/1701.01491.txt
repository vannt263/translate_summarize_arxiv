{
  "article_text": [
    "the proliferation of mobile devices and the surge of a myriad of multimedia applications has resulted in an exponential growth of the mobile data traffic . in this context",
    ", wireless caching has emerged as a powerful technique to overcome the backhaul bottleneck , by reducing the backhaul rate and the delay in retrieving content from the network .",
    "the key idea is to store popular content closer to the end users . in @xcite , a novel system architecture named _",
    "femtocaching _ was proposed .",
    "it consists of deploying a number of small base stations ( bss ) with large storage capacity , in which content is stored during periods of offpeak traffic .",
    "the mobile users can download content from the small bss , which results in a higher throughput per user . in @xcite , it was proposed to store content directly in the mobile devices .",
    "users can then retrieve content from neighboring devices using device - to - device ( d2d ) communication or , alternatively , from the serving bs .    in both scenarios",
    ", content may be stored using an erasure correcting code , which brings gains with respect to uncoded caching @xcite .",
    "the use of erasure correcting codes establishes an interesting link between distributed caching for content delivery and distributed storage ( ds ) for reliable data storage .",
    "the key difference is that in the wireless network scenario , data can be downloaded from the storage nodes ( the small bss or the mobile devices ) but also from a serving macro bs , which has always the content available .",
    "therefore , the reliability requirements in ds for reliable data storage can be relaxed . in @xcite ,",
    "the placement of content encoded using a maximum distance separable ( mds ) code to small bss was investigated and it was shown that a careful placement allows to significantly reduce the backhaul rate . in @xcite , for the scenario where content is stored directly in the mobile devices , the repairing of the lost data when a device storing data leaves the network was considered . assuming instantaneous repair , the communication cost of data download and repair was investigated . in @xcite , a repair scheduling where repair is performed periodically was introduced and analytical expressions for the overall communication cost of content download and data repair as a function of the repair interval were derived . using these expressions , the overall communication cost entailed by storing content using mds codes , regenerating codes @xcite , and locally repairable codes @xcite was evaluated in @xcite and it was shown that storing content using erasure correcting code can reduce the overall communication cost with respect to the scenario where content is downloaded solely from the bs .    in this paper",
    ", we consider a similar cellular network scenario as the one in @xcite , where content is stored in a number of mobile devices using an erasure correcting code .",
    "mobile devices roam in an out of a cell according to a poisson random process .",
    "however , as opposed to @xcite , where the download of a single file is considered , here we consider that users may request files , of different popularity , from a library of files .",
    "our focus is on the delay of retrieving content from the network , which was not considered in @xcite .",
    "we derive analytical expressions for the download delay if content is stored in the mobile devices using mds codes and show that mds - coded distributed caching can significantly reduce the download delay with respect to the case where content is solely downloaded from the bs and the case where uncoded caching is used .",
    "the download delay of a single file was analyzed in  @xcite .",
    "the remainder of the paper is organized as follows .",
    "the system model is introduced in section  [ s : system_model ] .",
    "the average download delay incurred when mds - coded distributed caching is used is analyzed in sections  [ s : download ] and section  [ s : d2d ] . section  [ sec : numericalresults ] presents and discusses numerical results and finally some conclusions are drawn in section  [ sec : conclusions ] .",
    "_ notation .",
    "_ the probability density function ( pdf ) of a random variable @xmath0 is denoted by @xmath1 and the expectation with respect to @xmath0 is denoted by @xmath2 .",
    "probability is denoted by @xmath3 and @xmath4 represents the all - ones vector of length @xmath5 .",
    "we denote by @xmath6 the stationary distribution of an @xmath7 queueing system described by a poisson birth - death process with arrival rate @xmath8 and departure rate per node @xmath9 , which is given by @xmath10 where @xmath11 .",
    "we consider a single cell in a cellular network where @xmath12 mobile devices , referred to as nodes , request files , each of size @xmath13 bits , from a library of @xmath14 files .",
    "the files have different popularities and accordingly have a given probability to be requested .",
    "depending on the placement strategy , some files are encoded and stored into @xmath15 mobile devices , referred to as storage nodes .",
    "for ease of language , the set of storage nodes is referred to as the ds network and nodes not storing any content are referred to as _",
    "regular _ nodes .",
    "a copy of each encoded file is also available at the bs serving the cell .",
    "a node requesting a file attempts to retrieve it from the storage nodes using d2d communication , and , if the file can not be completely retrieved from the ds network , the bs assists in providing the missing data . in order to increase the system efficiency ,",
    "we allow multiple d2d communications to coexist if they are sufficiently far apart in space .",
    "therefore , we divide the cell in @xmath16 virtual clusters and assume that the size of the cluster and the transmit power are properly chosen such that only one d2d communication can be established between any two nodes in the cluster and the interference across different clusters can be neglected .",
    "a similar model is considered in  @xcite .",
    "_ data allocation and coding strategy .",
    "_ we adopt a deterministic allocation strategy , where the @xmath17 most popular files are cached in a distributed fashion in @xmath18 storage nodes in the cell , according to the storage capacity of the devices .",
    "these files are partitioned into @xmath19 packets , called symbols , of @xmath20 bits each and are encoded into @xmath18 coded symbols using an @xmath21 mds erasure correcting code of rate @xmath22 .",
    "we use the same code for every file in order to simplify the analysis .",
    "we assume that each storage node stores a single symbol for each of the @xmath23 most popular files .",
    "overall , @xmath24 symbols are stored in @xmath18 storage nodes and no two storage nodes store the same symbol .",
    "we model the popularity of the files in the library using the time - invariant zipf distribution  @xcite .",
    "accordingly , the probability that the @xmath5th file is requested is @xmath25 where parameter @xmath26 regulates the relative popularity of the files . in the following , the set of @xmath23 files stored in the cache of the mobile devices will be referred to as the ds library .",
    "we assume that the mobile devices are free to move inside the cell .",
    "we consider a uniform spatial distribution of the nodes in the cell , and hence there are @xmath27 devices per cluster on average and among them @xmath28 storage nodes .",
    "we focus on a single cluster in isolation , and assume that the devices roam in and out of it .",
    "the arrival , departure and request model of the nodes are borrowed from @xcite .",
    "the considered scenario is shown in fig .",
    "[ f : cluster ] .    _ arrival - departure model .",
    "_ we assume that nodes arrive to the cluster according to a poisson random process with exponential independent , identically distributed ( i.i.d . ) random inter - arrival times @xmath29 with pdf @xmath30 where @xmath31 is the expected arrival rate and @xmath32 is time , measured in time units ( t.u . ) .",
    "the nodes stay in the cluster for an i.i.d . exponential random lifetime @xmath33 with pdf @xmath34 where @xmath35 is the expected departure rate per node .",
    "we assume that @xmath36 , which implies that the expected number of nodes in the cluster is @xmath37 .",
    "this model corresponds to an @xmath7 queuing model and the probability that there are @xmath5 nodes in the cluster is @xmath38 .",
    "the arrival of storage nodes to the cluster can also be described as a poisson random process . in particular , the inter - arrival times @xmath39 of the set of storage nodes has pdf @xmath40 the related lifetime is described by  ( [ e : departure ] ) and the probability that there are @xmath5 storage nodes in the cluster is @xmath41 .. more precisely , the only guarantee is that there are on average @xmath42 storage nodes per cluster , but there are no constraints on their instantaneous number , which can even exceed @xmath18 . on the other hand , the probability of having a high number of storage devices in one cluster is generally very low . for @xmath43 , we have @xmath44 , @xmath45 and @xmath46 .",
    "the same consideration holds for the total number of mobile devices . ]     mobile devices , and @xmath42 storage nodes among them ( red circles ) , caching one different coded symbol for each of the most popular files .",
    "a device requesting a file ( pink circle ) , must collect @xmath19 symbols .",
    "it attempts to recover them by using the ds network if the requesting file is stored in the devices .",
    "it uses the bs to collect the symbols that it is not able to download from the devices .",
    "the download of a symbol from a storage node takes @xmath47 t.u . , and from the bs @xmath48 t.u .. ,width=332 ]    _ ds network update .",
    "_ we assume that the nodes storing content that arrive to the cluster from neighboring clusters are not immediately available for download , but the bs serving the cell keeps track of them and periodically updates and broadcasts to all mobile devices the list of storage nodes in the cell every @xmath49 t.u .. in the sequel , parameter @xmath49 is referred to as the update interval and the set of storage nodes in the list broadcasted by the bs as the ds list .    _ data delivery . _",
    "nodes request the file at random times with i.i.d .",
    "random inter - request time @xmath50 with pdf @xmath51 where @xmath52 is the expected request rate per node .",
    "we focus on the download process .",
    "the node that requests a file attempts to retrieve it from the ds network using d2d communication .",
    "thanks to the mds property , an encoded file can be reconstructed by accessing any @xmath19 encoded symbols .",
    "if the file can not be completely retrieved from the ds network , the bs assists in providing the missing coded symbols .",
    "the download of a coded symbol from a storage node incurs @xmath47 t.u . and from the bs @xmath48 t.u .. we assume that @xmath53 due to the congestion of the bs - to - node link and the fact that d2d communication occurs over a better channel due to the reduced distance between the involved nodes .",
    "we further assume that only one d2d link at a time can be established , and that the d2d communication does not interfere with the communication between the bs and the nodes .",
    "we say that the d2d network is _ idle _ if there is no active d2d communication in the cluster . if the d2d network is not idle when one node requests the file , the whole file is downloaded from the bs .",
    "moreover , to simplify the analysis , we assume that multiple bs - to - node links can coexist .",
    "we investigate the average time that is required to retrieve one file from the wireless network , referred to as the download delay . if a requested file is stored in the ds library , the requesting node attempts to retrieve it from the ds network using d2d communication , otherwise the file is entirely downloaded from the bs .",
    "therefore , we introduce the binary random variable ( rv ) @xmath54 which describes the hitting of the ds cache , i.e. , @xmath55 if a file of the ds library is requested and @xmath56 otherwise . moreover , the d2d network can be used only if it is idle , i.e. , if there are no active d2d communications .",
    "accordingly , we introduce the binary rv @xmath57 that describes the status of the d2d network . @xmath58 if the network is idle and @xmath59 otherwise .",
    "if the d2d network is idle , the requesting node tries to collect the necessary coded symbols from the nodes of the ds list provided by the bs using d2d communication .",
    "if the requesting node is a storage node of the ds list , it needs to download @xmath60 symbols , otherwise @xmath19 symbols must be downloaded .",
    "we thus introduce the binary rv @xmath61 , which represents the type of request , i.e. , @xmath62 for requests originating from a node that belongs to the ds list and @xmath63 for the other requests .",
    "the download from the storage nodes can be either fully successful or partially accomplished , in which case the requesting node turns to the bs to recover the missing symbols . on the other hand ,",
    "if the d2d network is not idle and the requested file is stored in the ds library , the node downloads @xmath19 or @xmath60 symbols from the bs , depending on the type of node . from the discussion above , the average file download delay , @xmath64 , may be formalized as    the average file download for the cellular network described in section  [ s : system_model ] where the @xmath23 most popular files are stored in the mobile devices using an @xmath21 mds code is @xmath65 where @xmath66 is the average number of coded symbols downloaded per request using d2d communication and @xmath67 , referred to as the average d2d download delay , is the corresponding delay .",
    "the computation of @xmath66 , @xmath67 and @xmath68 is addressed in section  [ s : d2d ] .",
    "the probability of hitting the cache can be expressed as @xmath69 where the probabilities @xmath70 are given in  ( [ e : zipf ] ) .",
    "it follows that @xmath71 if @xmath72 .",
    "the next step is the computation of the probability that the d2d network is idle .",
    "let @xmath73 be the status of the network at the time of the @xmath74th request .",
    "it follows @xmath75 in order to compute @xmath76 , we introduce the rv @xmath77 that denotes the time instant of the @xmath78th request .",
    "also , let @xmath79 be the time during which the d2d network is occupied by the @xmath78th request .",
    "the d2d network is idle at the time of the @xmath74th request if none of the previous requests is still using d2d communication .",
    "therefore , @xmath80 and @xmath81 assuming that if the d2d network is not idle at time @xmath82 is because of the @xmath83th request , the product in ( [ e : p_i exact ] ) reduces to the term involving the @xmath83th request only , i.e. , @xmath84 since the requests are i.i.d . with inter - request time distributed as in ( [ e : request time ] ) and on average there are @xmath37 nodes in the cluster , we can compute @xmath85 and ( [ e : p_i approx1 ] ) can be written as @xmath86 if @xmath87 , @xmath88 and @xmath89 in  ( [ e : idle_ell ] ) , we used the fact that the probability of hitting the cache and the average d2d download delay are independent of the request index ( if @xmath74 is sufficiently large ) , as it is proven in lemma  [ l : tdd_ell ] in section  [ s : d2d ] . substituting ( [ e : idle_ell ] ) in ( [ e : idle ] ) and after some simple calculations , we obtain @xmath90",
    "in this section , we consider the computation of the average d2d download delay @xmath67 and the average number of coded symbols @xmath66 downloaded per request using d2d communication .",
    "we assume that a node can not download in parallel from multiple nodes , but it serially tries to download the coded file symbols from the nodes in the ds list .",
    "when a node requests the file , if the d2d network is idle and the requested file belongs to the ds library , it randomly chooses one of the storage nodes from the list supplied by the bs .",
    "after each downloaded symbol , the requesting node randomly chooses another storage node from the ds list and still alive .",
    "we assume that a requesting node that has collected fewer than the @xmath19 symbols necessary to reconstruct the file turns to the bs when all the reference storage nodes left or when the download of a symbol fails , even if other storage nodes are available . to simplify the analysis",
    ", we assume that both cases ( the failed symbol download and the absence of storage nodes ) incur @xmath47 t.u .",
    ", even if the node could contact the bs earlier .",
    "we also assume that the download from the d2d network fails if the requesting node itself leaves the cluster before collecting @xmath19 symbols . in this case",
    ", the download is also completed from the bs .    to derive the average d2d download delay , we introduce three rvs describing the number of nodes of different type that are present in the cluster at the instant of a request : the number of storage nodes of the ds list , the total number of storage nodes ( belonging or not to the list , the latter corresponding to the storage nodes that arrive to the cluster after the ds list update and that have not left the cluster at the time of the request ) , and the number of regular nodes . in particular , we denote by @xmath91 the rv that describes the number of storage nodes of the ds list when a request arrives .",
    "we describe by the rvs @xmath92 and @xmath93 the total number of storage nodes and the number of regular nodes at the instant of a request , respectively .",
    "moreover , we denote by @xmath94 the rv that represents the total number of storage nodes ( belonging or not to the ds list ) at the beginning of the update interval of length @xmath49 . in the following three lemmas , we give a probabilistic description of the above rvs .",
    "[ l : px1 ] the probability that there are @xmath95 storage nodes of the ds list at the time of a request is @xmath96 where @xmath97 is the probability that @xmath98 is equal to @xmath99 , given that @xmath100 storage nodes are in the cluster at the beginning of the update interval of length @xmath49 , and is @xmath101 where @xmath102 and @xmath103 .    the proof is given in appendix  [ app : prooflem1 ] .",
    "[ l : pq ] the probability that there are @xmath104 storage nodes in the cluster at the time of a request is given by @xmath105    the proof follows the same lines as the proof of lemma  [ l : px1 ] .    [ l : pv ] the probability that there are @xmath106 regular nodes in the cluster at the time of a request is given by @xmath107    the proof follows the same lines as the proof of lemma  [ l : px1 ] .    based on the above lemmas",
    ", we can compute the probability that the request originates from a storage node of the ds list and the probability of having a given number of storage nodes in the ds list at the time of the request conditioned to the type of request .    using bayes rule , the probability that there are @xmath108 storage node of the ds list alive at the time of a request , conditioned to the type of request , is given by @xmath109 the probability @xmath110",
    "is given in lemma  [ l : px1 ] .",
    "we now compute @xmath111 and @xmath112 .",
    "we start with the probability of having one request from the ds list conditioned to the number of storage nodes in the ds list at the time of the request . for @xmath113",
    ", it can be written as @xmath114 clearly , the condition @xmath115 implies that the request can not originate from a storage node of the ds list , therefore @xmath116 .",
    "we approximate the probability that there are @xmath117 storage nodes at the instant of the request , given the number of nodes of the ds list alive , by using the steady state probability of a poisson birth - death process with arrival rate @xmath118 and departure rate @xmath119 .",
    "in particular , we compute @xmath120 where the expectations @xmath121 and @xmath122 are obtained starting from the probabilities  ( [ e : pq ] ) and ( [ e : px1 ] ) , respectively .",
    "the number of regular nodes @xmath123 is independent of the number of storage nodes at the instant of the request , therefore we finally have @xmath124 where @xmath125 is given in lemma  [ l : pv ] .",
    "note that in the expression above , with some abuse of notation , we used equal sign to avoid carrying all the way the approximation sign due to the approximation introduced in ( [ e : pq_approx ] ) .",
    "starting from this result , we compute the probability that the request originates from the ds list as @xmath126 where @xmath127 is given in lemma  [ l : px1 ] .",
    "the probability @xmath128 is easily computed as @xmath129 .",
    "similarly , we have @xmath130 . following the same approach for the proof of lemma  [ l : px1 ] , it is easy to show that @xmath131 and @xmath132 are independent of the specific request ( when @xmath74 grows large ) , where @xmath133 is the binary rv describing the type of the @xmath74th request .",
    "the case @xmath134 represents the case of instantaneous update , where the nodes contact directly the bs when they request a file and receive the list of the storage nodes through a dedicated link .",
    "for instantaneous update , the number of storage nodes at the instant of the request and the type of request is described by the following probabilities @xmath135 the probability that there are @xmath95 storage nodes at the time of the request given the type of request can be computed by replacing the above probabilities in  ( [ e : px1cond ] ) .    in order to describe the d2d download , let @xmath136 be the binary rv that describes the success of the download at the first attempt .",
    "more precisely , @xmath137 represents the successful download of the coded symbol from the first contacted storage node . if the download is not successful from the first contacted storage node , @xmath138 .",
    "similarly , we denote by @xmath139 the binary rv describing the download at the @xmath78th attempt and we denote by @xmath140}$ ] , @xmath141 the random vector ( @xmath142 ) . in the following , in lemmas  [ l : s1 ] ,",
    "[ l : sk ] , and [ l : sj ] , we derive the probability that no symbols can be downloaded from the d2d network , @xmath143 , the probability that the content is fully recovered from the ds network , @xmath144}={\\mathbf{1}}_{k - i } | r\\ } $ ] , and the probability that it is only partially recovered , @xmath145}={\\mathbf{1}}_{j } , s_{j+1}=0 | r\\}$ ] , respectively .",
    "[ l : s1 ] the probability that no symbols are downloaded through d2d communication , conditioned to the type of request , is given by @xmath146 where @xmath147 is given in  ( [ e : px1cond ] ) and @xmath148 with @xmath102 .",
    "the proof is given in appendix  [ app : prooflem4 ] .",
    "[ l : sk ] the probability that the file can be completely retrieved from the ds network , i.e. , the probability that k symbols are downloaded through d2d communication when @xmath63 , or @xmath60 when @xmath62 , conditioned to the type of request , is given by @xmath149 } = { \\mathbf{1}}_{k - i } |r = i\\ } =   e^{-(k - i)\\mu { t_\\mathrm{d } } }    \\sum_{g = 1}^\\infty \\sum_{d=0 } ^{g } \\frac{g - d}{g } \\gamma_{k - i}(g , d , i )   , i=0,1,\\ ] ] where @xmath150 is defined by the recursion @xmath151 for @xmath152 and @xmath153 , with initial condition @xmath154 and where @xmath155 the function @xmath156 is given in  ( [ e : theta ] ) , and @xmath157 is given in  ( [ e : px1cond ] ) .    the proof is given in appendix  [ app : prooflem5 ] .",
    "[ l : sj ] the probability of consecutively download @xmath158 symbols and to fail the download of the @xmath159th one is @xmath160}={\\mathbf{1}}_{j } , s_{j+1}=0 |r = i \\ } =   \\gamma_{j+1}(0,0,i)a_{j+1 } +   \\sum_{g=1}^\\infty \\sum_{d=0}^d \\big (   \\frac{d}{g } \\gamma_{j+1}(g , d , i)a_{j+1 } + \\frac{g - d}{g } \\gamma_{j}(g , d , i)b_{j+1 }   \\big )    \\nonumber\\ , , \\ ] ] where @xmath161 , @xmath162 , and @xmath163 is given in  ( [ e : gamma ] ) .",
    "the proof follows the same lines as the proof of lemma  [ l : sk ] .    finally , the average d2d download delay and the average number of downloaded symbols from ds network are given in the following theorem .",
    "[ t : t_ni ] consider the network described in section  [ s : system_model ] , where an @xmath21 mds erasure correcting code is employed and where there are @xmath42 storage nodes in the cluster on average .",
    "let @xmath47 be the time to download a symbol through d2d communication .",
    "the average d2d download delay and the corresponding average number of downloaded symbols are given by @xmath164 where @xmath165 is the probability that the request comes from a storage node of the ds list , and @xmath166}={\\mathbf{1}}_{k - i } | r = i\\ }   + \\sum_{j=1}^{k-1-i } j    \\pr \\{{\\mathbf{s}}_{[j]}={\\mathbf{1}}_{j } , s_{j+1}=0| r = i \\ } \\ , , \\nonumber\\\\ { \\overline{t}_i   } = & { t_\\mathrm{d}}\\big ( { \\eta_i } +   c_{k , i}\\pr \\{\\ s_{1}=0 | r = i\\ } + \\sum_{j=0}^{k-1-i }    \\pr \\{{\\mathbf{s}}_{[j]}={\\mathbf{1}}_{j } , s_{j+1}=0 | r = i\\ } \\big)\\ , , \\qquad \\qquad i=0,1 \\nonumber   \\end{aligned}\\ ] ] where @xmath167 for @xmath168 and @xmath169 otherwise .",
    "the average d2d download delay is obtained as the sum of the average d2d delays in the case of requests originated from the ds list and of requests originating from the other nodes , weighted by the probabilities @xmath170 and @xmath171 , respectively .",
    "the same approach is used for the corresponding average number of downloaded symbols . according to our model",
    ", the requesting node completes the download of @xmath172 symbols from the ds network in @xmath173 t.u . with probability @xmath144}={\\mathbf{1}}_k",
    "| r = i \\ } $ ] , while the partial download of @xmath174 symbols happens with probability and incurs @xmath175 t.u .. for @xmath168 , in the computation of the average d2d download delay , we also consider the case where download from the ds network completely fails .",
    "the corresponding probability is @xmath176 and the delay is @xmath47 .",
    "when the request originates from the ds list and @xmath177 , i.e. @xmath178 , no symbols need to be downloaded , therefore @xmath179 and @xmath180 are equal to zero .    [",
    "l : tdd_ell ] the average d2d download time for the @xmath74th request , @xmath181 , is independent of the specific request if the index @xmath74 is sufficiently large .    similarly to the average d2d download delay , @xmath181 is @xmath182 where @xmath183}={\\mathbf{1}}_{k - i } | r^{(\\ell)}=i\\ } +   c_{k , i}\\pr \\{\\",
    "s^{(\\ell)}_{1}=0 | r^{(\\ell)}=i\\ } \\nonumber\\\\                & + \\sum_{j=0}^{k-1-i } ( j+1 )   \\pr \\{{\\mathbf{s}}^{(\\ell)}_{[j]}={\\mathbf{1}}_{j } , s^{(\\ell)}_{j+1}=0 | r^{(\\ell)}=i\\ } \\big)\\ , , \\qquad \\qquad i=0,1 \\nonumber \\end{aligned}\\ ] ] the lemma follows from the fact that the probabilities in the expressions above are independent of @xmath74 , when @xmath74 grows large .",
    "in this section , we evaluate the average download delay when content is cached using mds codes for a cluster with @xmath184 nodes on average , departure rate @xmath185 , and request rate @xmath186 . we compare the average file download delay @xmath64 of the considered network with mds - coded ds with the delay of the traditional scenario where the content is solely downloaded from the bs , denoted by @xmath187 and with uncoded caching . in the following , with no loss of generality",
    ", we set @xmath188 t.u ..    we recall that each file that is cached in the ds library is divided into @xmath19 symbols , and encoded using an ( @xmath189 ) mds code , where @xmath18 is the number of storage nodes in the cell .",
    "the code parameters are chosen such that @xmath190 . in this way ,",
    "the _ average storage overhead _ in a cluster , @xmath191 , is positive , which increases the probability that the content is downloaded through d2d communication only .",
    "alternatively , we can use the same @xmath192 mds code for each cluster , but in this case the bs must continuously restore the initial state of reliability of the ds network when storage nodes leave the clusters  @xcite .",
    "we first consider the special case where @xmath72 , therefore the probability of hitting the cache @xmath193 is @xmath194 . in figs .",
    "[ f:0.1][f:0.001 ] , we show the gain that can be achieved using mds - coded caching , by reporting the ratio between @xmath195 and @xmath64 as a function of the update interval @xmath49 .",
    "the infinite series involved in the computation of @xmath64 are truncated to a given value @xmath32 , chosen according to @xmath196 when involving the number of storage nodes and to @xmath197 when involving the number of nodes in general .",
    "we fix the ratio @xmath198 to be @xmath199 , and consider several mds codes .",
    "moreover , we also consider an uncoded scenario where one storage node on average in the cluster stores the uncoded files . in figs .",
    "[ f:0.1 ] , [ f:0.01 ] , and [ f:0.001 ] , @xmath47 is @xmath200 , @xmath201 , and @xmath202 times , respectively , smaller than @xmath48 . in the figures ,",
    "the solid lines correspond to the analytical closed - form expressions derived in the previous sections and markers correspond to simulation results .",
    "it is observed that the analytical expressions predict very well the actual performance , which shows the goodness of the approximations introduced in  ( [ e : approxi ] ) and ( [ e : pq_approx ] ) .",
    "the results clearly show that mds - coded ds can greatly improve the performance in terms of content download delay with respect to the case where content is downloaded from the bs , provided that the update interval , @xmath49 , is sufficiently small .",
    "for example , for @xmath203 and @xmath204 , a speed - up factor of around @xmath205 in the download is achieved with respect to the case of downloading from the bs using a @xmath206 mds code .",
    "interestingly , the results also show that the performance improves when @xmath19 increases .",
    "in particular , simple replication ( repetition coding ) is very inefficient and much better performance are achieved using larger mds codes ( of the same rate ) .",
    "we now consider the more general case where only part of the library of files is cached in the devices .",
    "we assume that the library has a size of @xmath207 files , and each storage node stores one symbol for each of the @xmath23 most popular files .",
    "we assume that the each file is of size @xmath201 mb , which corresponds to a @xmath200-minutes video .",
    "we further assume that each storage node makes @xmath208 gb available for caching . in this case , the number of cached files @xmath23 , that corresponds to the number of symbols cached by each storage node , increases by increasing @xmath19 , since the size of one encoded symbols is @xmath201mb@xmath209 and @xmath23 is clearly obtained by dividing the storage capacity of the node by the symbol size . in fig .",
    "[ f : sigma ] , we show the download speedup factor @xmath210 as a function of the parameter @xmath26 , which regulates the relative popularity of the files .",
    "for example , a large value of @xmath26 represents the case where few popular files are responsible for the majority of the download traffic .",
    "the figure refers to the case where @xmath211 and @xmath212 .",
    "the results confirm the gain that can be achieved by mds - coded distributed caching , but highlight another important aspect .",
    "when the whole library is not cached in the network , i.e. , @xmath213 , the gain reduction is not negligible , especially for low values of @xmath26 .",
    "this fact suggests that the adopted deterministic allocation , where the @xmath23 most popular files are equally stored in the ds network , is suboptimal .    .",
    "solid lines show analytical results and markers simulation results . ]    .",
    "solid lines show analytical results and markers simulation results . ]    .",
    "solid lines show analytical results and markers simulation results . ]    . @xmath214 and @xmath212 . ]",
    "in this paper , we considered the cache of popular content in the mobile devices of a cellular network using maximum distance separable erasure correcting codes to speed - up content delivery .",
    "we derived analytical expressions for the average download delay and showed that mds - coded distributed caching may dramatically reduce the download delay with respect to the traditional case where content is always downloaded from the base station .",
    "we denote by @xmath215 the number of storage nodes available for download at the time of the @xmath74th download request , i.e. , the number of storage nodes of the ds list that have not left the cluster at the time of the request .",
    "we compute @xmath127 by averaging over an infinite number of requests , @xmath216 similarly , let @xmath217 be the number of storage nodes at the beginning of the update interval wherein the @xmath74th request arrives , denoted by @xmath218 .",
    "we have @xmath219 in  @xcite , it was shown that the probability @xmath220 does not depend on @xmath74 ( when @xmath74 grows large ) , and is given by  ( [ e : px_j ] ) .",
    "its derivation is based on the observation that the number of storage nodes available for download in the update interval is described by a poisson death process .",
    "the probability @xmath221 can be written as @xmath222 where in the second equality we used bayes rule . in  ( [ e : y ] ) , @xmath223 is the number of storage nodes at the beginning of the update interval , which is described by a birth - death poisson process , thus @xmath224 .",
    "the probability @xmath225 is the probability that there is at least one request in @xmath218 .",
    "it depends on the inter - request time , which in turn depends on the number of nodes in the cluster .",
    "therefore , we compute @xmath226 where @xmath227 is the probability that the inter - request time is shorter than @xmath49 when @xmath228 nodes are present in the cluster . similarly , we compute @xmath229 as @xmath230 where @xmath231 is the probability that there are @xmath228 nodes in the cluster , given that there are @xmath232 storage nodes .",
    "since these probabilities are independent of the specific request , we conclude that @xmath221 is also independent of @xmath74 . substituting ( [ e : y ] ) into ( [ e : x1l ] ) , we observe that @xmath233 is also independent of @xmath74 and using  ( [ e : x1 ] ) we prove the lemma .",
    "we compute the conditional probability that no symbols are downloaded by averaging over an infinite number of requests , @xmath234 where @xmath235 is the rv describing the download of the first symbol for the @xmath74th request .",
    "we now consider the computation of @xmath236 .",
    "the recovery of the first symbol fails with probability @xmath194 if the requesting node leaves the cell before completing the download .",
    "it also fails if the requesting node stays in the cluster but no storage nodes are available or if it chooses to download from a storage node which departs before @xmath47 t.u . from the start of the download",
    "let @xmath237 be the departure time of the node which places the @xmath74th request and let @xmath238 be the event that the node which places the @xmath74th request stays in the network for more than @xmath239 t.u . from the start of the download .",
    "the corresponding probability does not depend on @xmath74 and is easily computed as @xmath240 .",
    "similarly , the probability that the requesting node departs before @xmath47 t.u . from the start of the download is @xmath241 .",
    "therefore , the conditional probability that the @xmath74th request fails the first symbol download is @xmath242 let @xmath243 be the number of storage nodes useful for download for the @xmath74th request , i.e. , the number of storage nodes in the ds list that have not left the cluster at the time of the @xmath74th request , excluding the requesting node itself if it belongs to the ds list .",
    "let @xmath244 the number of departures in @xmath47 t.u . among the @xmath245 storage nodes .",
    "the probability @xmath246 can be written as @xmath247 equation  ( [ e : s1cond ] ) is obtained by observing that @xmath248 the probability that the download of the first symbol fails conditioned to @xmath249 and @xmath250 is independent of the type of request , and that @xmath251 the number of useful storage nodes and the number of departures in @xmath47 t.u . among them is independent of the departure of the requesting node .",
    "the probability @xmath252 is equal to 1 if there are no useful storage nodes , i.e. , @xmath253 .",
    "otherwise , it equals the probability to choose one of the @xmath254 storage nodes that leave the cell in @xmath47 t.u .",
    ", i.e. , @xmath255 , with @xmath256 .",
    "we observe that the number of departures of useful storage nodes conditioned to their number is independent of the type of request and that the number of storage nodes useful for download @xmath249 is related to @xmath257 by @xmath258 since when the request originates from a storage node of the ds list , the requesting node itself is not counted among the useful storage nodes . therefore , the probability @xmath259 can be written as @xmath260 we denote by @xmath156 the probability @xmath261 , given in  ( [ e : theta ] ) .",
    "its derivation is similar to that of @xmath262  @xcite .",
    "the probability @xmath263 is independent of the specific request and is given by  ( [ e : px1cond ] ) .",
    "after simple manipulations , we finally obtain @xmath264 since the probabilities involved in  ( [ e : ps1 ] ) are all independent of @xmath74 , the lemma is proved .",
    "to evaluate the probability of complete download from the ds network , we start with the following limit , @xmath265 } = { \\mathbf{1}}_{k - i}| r = i \\}= \\lim_{l \\to \\infty }    \\frac{1}{l } \\sum_{\\ell=1}^l \\pr\\ {   { \\mathbf{s}}_{[k - i]}^{(\\ell)}={\\mathbf{1}}_{k - i}|r^{(\\ell)}=i \\}\\ , , \\ ] ] where @xmath266}^{(\\ell)}= (   s_1^{(\\ell ) } , \\dots , s_j^{(\\ell)})$ ] and @xmath267 describes the successful symbol download at the @xmath5th attempt of the @xmath74th request .",
    "we consider the @xmath74th request and , similarly to the proof of lemma  [ l : s1 ] , we will find that this probability is independent of @xmath74 .",
    "we denote by the rv @xmath268 the number of storage nodes useful for download at the time of the @xmath78th attempt of the @xmath74th request , i.e. , the storage nodes of the ds list not yet contacted , excluding the requesting node if it belongs to the ds list .",
    "we denote by the rv @xmath269 the number of departures in @xmath47 t.u . among the @xmath270 nodes .",
    "we also denote by @xmath271 the event that the node which places the @xmath74th request stays in the network for more than @xmath272 t.u . from the start of the download .",
    "the corresponding probability does not depend on @xmath74 and is given by @xmath273 .",
    "the probability of complete download is zero if the requesting node departs before @xmath274 t.u . from the start of the download , therefore we can write @xmath275}^{(\\ell)}={\\mathbf{1}}_{k - i}|r^{(\\ell)}=i \\}=e^{-(k - i)\\mu { t_\\mathrm{d } } } \\pr\\ {   { \\mathbf{s}}_{[k - i]}^{(\\ell)}={\\mathbf{1}}_{k - i}|\\mathcal{a}_{k - i}^{(\\ell ) } , r^{(\\ell)}=i   \\}\\,.\\ ] ] the probability @xmath276}^{(\\ell)}={\\mathbf{1}}_{k - i}|\\mathcal{a}_{k - i}^{(\\ell ) } , r^{(\\ell)}=i   \\}$ ] can be written as @xmath277}^{(\\ell)}={\\mathbf{1}}_{k - i}|\\mathcal{a}_{k - i}^{(\\ell ) } , r^{(\\ell)}=i   \\}=\\nonumber\\\\ & = \\sum_{g } \\sum_{d } \\pr\\{s^{(\\ell)}_{k - i}=1|   \\mathcal{a}_{k - i}^{(\\ell ) } , g_{k - i}^{(\\ell)}=g , d_{k - i}^{(\\ell)}=d   \\ } \\pr\\ {   g_{k - i}^{(\\ell)}=g , d_{k - i}^{(\\ell)}=d,{\\mathbf{s}}_{[k - i-1]}^{(\\ell)}={\\mathbf{1}}_{k - i-1 } |   \\mathcal{a}_{k - i}^{(\\ell ) } , r^{(\\ell)}=i \\}\\nonumber \\\\ & = \\sum_{g=1}^\\infty \\sum_{d=0}^{g } \\frac{g - d}{g } \\gamma^{(\\ell)}_{k - i}(g , d , i)\\ , .",
    "\\label{e : gamma1 } \\end{aligned}\\ ] ] the last equality is obtained by observing that the probability @xmath278 for @xmath279 and @xmath280 equals the probability to choose one of the storage nodes of the ds list that remains in the cluster , i.e. , @xmath281 .",
    "moreover , we have defined @xmath282}^{(\\ell)}={\\mathbf{1}}_{j-1 } |   \\mathcal{a}_{j}^{(\\ell ) } , r^{(\\ell)}=i \\}$ ] , that can be computed as @xmath283}^{(\\ell)}={\\mathbf{1}}_{j-2 } |   \\mathcal{a}_{j-1}^{(\\ell ) } , r^{(\\ell)}=i \\}\\ , , \\nonumber\\end{aligned}\\ ] ] for @xmath284 .",
    "we also define @xmath285 , which is equal to one if @xmath286 and @xmath287 , and zero otherwise .",
    "the condition @xmath286 follows from the fact that the number of useful storage nodes after a successful symbol download is equal to the number of useful storage nodes still alive , , minus the storage node just used .",
    "the condition @xmath287 comes from the fact that the @xmath288th symbol download is assumed to be successful , i.e. , @xmath289 .",
    "it is easy to prove by induction that the probability in  ( [ e : gamma1 ] ) does not depend on @xmath74 . by defining @xmath290",
    ", we obtain the recursion  ( [ e : gamma ] ) , with initial condition  ( [ e : gammaic ] ) .",
    "the probabilities @xmath291 , @xmath158 , are equal to zero for @xmath292 .",
    "k.  shanmugam , n.  golrezaei , a.  g. dimakis , a.  f. molisch , and g.  caire , `` femtocaching : wireless content delivery through distributed caching helpers , '' _ ieee trans .",
    "theory _ , vol .",
    "59 , no .  12 , pp . 84028413 , dec .",
    "n.  golrezaei , p.  mansourifard , a.  f. molisch , and a.  g. dimakis , `` base - station assisted device - to - device communications for high - throughput wireless video networks , '' _ ieee trans .",
    "wireless commun .",
    "_ , vol .  13 , no .  7 , pp",
    "36653676 , july 2014 .",
    "j.  pedersen , a.  graell i amat , i.  andriyanova , and f.  brnnstrm , `` repair scheduling in wireless distributed storage with d2d communication , '' in _ proc .",
    ". theory work .",
    "( itw ) _ , jeju island , korea , 2015 .",
    "j.  pedersen , a.  graell i amat , i.  andriyanova , and f.  brnnstrm , `` distributed storage in mobile wireless networks with device - to - device communication , '' _ ieee trans . commun .",
    "_ , vol .",
    "64 , no .  11 , pp . 48624878 , nov .",
    "2016 .",
    "a.  piemontese and a.  graell i amat , `` mds - coded distributed storage for low delay wireless content delivery , '' in _ proc .",
    "turbo codes & iterative inform .",
    "( istc ) _ , brest , france , sep ."
  ],
  "abstract_text": [
    "<S> we investigate the use of maximum distance separable ( mds ) codes to cache popular content to reduce the download delay of wireless content delivery . </S>",
    "<S> in particular , we consider a cellular system where devices roam in an out of a cell according to a poisson random process . </S>",
    "<S> popular content is cached in a limited number of the mobile devices using an mds code and can be downloaded from the mobile devices using device - to - device communication . </S>",
    "<S> we derive an analytical expression for the delay incurred in downloading content from the wireless network and show that distributed caching using mds codes can dramatically reduce the download delay with respect to the scenario where content is always downloaded from the base station and to the case of uncoded distributed caching . </S>"
  ]
}