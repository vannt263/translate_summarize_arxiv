{
  "article_text": [
    "in this paper we consider the problem of online update of a pareto archive composed of mutually non - dominated solutions when a new candidate solution shows up .",
    "this problem is also referred to as dynamic non - dominance problem  @xcite .",
    "online update of a pareto archive is typically used in multiobjective metaheuristics ( momhs ) , e.g. multiobjective evolutionary algorithms , whose goal is to generate a good approximation of the pareto front .",
    "most of the nowadays momhs use an external archive of potentially efficient solutions , i.e. pareto archive containing solutions not dominated by any other solutions generated so far .",
    "we consider here momhs that generate iteratively new candidate solutions and use them to immediately update pareto archive .",
    "updating pareto archive with a new solution @xmath0 means that :    * all solutions dominated by @xmath0 are removed from pareto archive , * @xmath0 is added to pareto archive if it was non - dominated w.r.t .",
    "to any solution in pareto archive .",
    "online update of a pareto archive may also be used as an intermediate step of other methods .",
    "for example drozdk et al .",
    "@xcite propose to use the online updated pareto archive to speed - up non - dominated sorting procedure used in many multiobjective evolutionary algorithms .",
    "the time needed to update pareto archive generally grows with growing number of objectives and growing number of solutions . in some cases it may become a crucial part of the total running time of a momh .",
    "the simplest data structure for storing pareto archive is a plain list .",
    "when a new solution @xmath0 is added , @xmath0 is compared to all solutions in pareto archive until either all solutions are checked or a solution dominating @xmath0 was found .    in order to speed - up the process of updating a pareto archive some authors proposed the use of specialized data structures and algorithms , e.g. quad - trees .",
    "however , the results of computational experiments reported in the literature are not conclusive and in some cases such data structures may in fact increase the update time compared to simple list .    the direct motivation for us to revisit the issue of updating pareto archive comes from special properties of pareto local search ( pls ) method  @xcite .",
    "pls works directly with the pareto archive . for each solution in the archive its neighborhood is searched to find new potentially efficient solutions and update the archive .",
    "standalone pls starting from random solutions is very inefficient since it spends a lot of time generating large numbers of solutions being still very far from the pareto front .",
    "pls , however , is used as a crucial component in some of the best methods for multiobjective knapsack  @xcite , biobjective traveling salesperson problem ( btsp )  @xcite and set covering problem  @xcite .",
    "the general idea of such methods is to start pls from a set of high quality solutions generated by some other methods , e.g. the powerful lin - kernighan heuristic for tsp  @xcite .",
    "pls has also been used in other contexts , e.g. for solving scheduling problems  @xcite , multi - agent problems  @xcite or multiobjective markov decision processes  @xcite .",
    "the importance of pls may be explained by the fact that unlike most other momhs it is especially good in the search for new solutions along pareto front . in order to generate a good approximation of the pareto front",
    "a momh has to achieve two different goals : the solutions generated by such method should both approach the pareto front and cover all areas along this front . in other words ,",
    "the momh has to search both towards and along pareto front  @xcite .",
    "pls seems to be especially good in search along pareto front , i.e. when started from a sample of solutions located very close to the true pareto front , pls may generate a large number of new potentially efficient solutions in a very short time .    from the point of view of updating pareto archive",
    ", pls has some special characteristics :    * pls generates large number of new candidate solutions in a very short time ( as the neighborhood solutions for many problems may be quickly generated ) .",
    "in particular , before a neighbor solution is added to the archive only the new values of objectives are needed .",
    "these values may often be efficiently calculated using changes of the objectives .",
    "for example , in the case of tsp , the typical two edges exchange move requires only removing two edges and adding two other edges to the solution .",
    "so , the calculation of change of each objective requires just few arithmetic operations .",
    "this means that the time needed to generate a new solution may be much shorter than the time needed to update the archive .",
    "* since the new candidate solutions are neighbors of potentially efficient solutions they are usually quite good , i.e. even if the new solution is dominated there are only relatively few dominating solutions . in this case",
    "the plain list is especially inefficient since the first dominating solution will on average be found after checking large fraction of solutions .",
    "* pareto archive is a crucial element of pls .",
    "new solutions are accepted or rejected based on the comparison to the archive .",
    "so pareto archive has to be updated online , while in some other momhs it is at least potentially possible to store all candidate solutions and only at the end to filter out the dominated ones .",
    "based on these motivations , we propose a new method , called nd - tree , for updating a pareto archive .",
    "a thorough experimental study will show that we can obtain substantial computational time reductions comparing to state - of - the - art methods .",
    "the remainder of the paper is organized as follows .",
    "basic definitions related to multiobjective optimization are given in section 2 . in section 3 ,",
    "we present a state of the art of the methods used for online updating a pareto archive .",
    "the new method nd - tree is described in section 4 . finally , computational experiments are reported and discussed in section 5 .",
    "we consider in this section a general multiobjective combinatorial optimization problem , defined as follows : @xmath1 @xmath2    a combinatorial structure is associated to this problem , which can be path , tree , flow , tour , etc .",
    "we denote by @xmath3 the feasible set in decision space , defined by @xmath4 . the image of the feasible set in objective space",
    "is called @xmath5 and is defined by @xmath6 . due to the contradictory features of the objectives ,",
    "there does not exist a feasible solution simultaneously minimizing each objective ( that is why the word is placed between quotation marks ) but a set of feasible solutions called _",
    "efficient solutions_. we present below some definitions that characterize these efficient solutions .",
    "we first define dominance relations :    pareto dominance relation : we say that a vector @xmath7 _ dominates _ a vector @xmath8 if , and only if , @xmath9 .",
    "we denote this relation by @xmath10 .",
    "we can now define an efficient solution , a non - dominated point , the efficient set and the pareto front .",
    "efficient solution : a feasible solution @xmath11 is called _ efficient _ if there does not exist any other feasible solution @xmath12 such that @xmath13 . for the sake of simplicity",
    "we will use the dominance relation w.r.t .",
    "solutions as well , i.e. @xmath14 .    non - dominated point : the image @xmath15 in objective space of an efficient solution @xmath16 is called a non - dominated point .",
    "efficient set : the efficient set denoted by @xmath17 contains all efficient solutions .",
    "pareto front : the image of the efficient set in @xmath5 is called the pareto front ( or non - dominated frontier / set ) , and is denoted by @xmath18 .    since in many places we will need dominance or equality relation we define it as coverage relation .",
    "coverage relation : we say that a point @xmath19 _ covers _ a point @xmath20 if @xmath10 or @xmath21 .",
    "we denote this relation by @xmath22 .",
    "we will also use the coverage relation w.r.t .",
    "solutions as well , i.e. @xmath23 .    please note that coverage relation is sometimes referred to as weak dominance  @xcite .",
    "the terminology , however , is not consistent and other authors use weak dominance as the synonym of pareto dominance  @xcite ( in contrast to strong dominance where a solution is better on all objectives ) . thus to avoid confusion we use the name `` coverage '' .    to define a pareto archive , we need to introduce the mutually non - dominated relation :    mutually non - dominated relation : we say that two solutions are _ mutually non - dominated _ or _ non - dominated w.r.t . each other _",
    "if none of the two solutions covers the other one .",
    "we can now define the pareto archive :    pareto archive : set of solutions such that any pair of solutions of the set are mutually non - dominated .    in the context of momhs , the pareto archive contains thus the mutually non - dominated solutions generated so far ( i.e. at a given iteration of a momh ) .",
    "we will denote @xmath24 the pareto archive generated by a momh . in other words @xmath24 contains solutions that are potentially efficient at a given iteration .",
    "the new method nd - tree is based on _ local _ ideal and nadir points that we define below .",
    "local ideal point of a subset @xmath25 denoted as @xmath26 is the point in the objective space composed of the best coordinates of all solutions belonging to @xmath27 , i.e. @xmath28 .",
    "naturally , local ideal point covers all solutions in @xmath27 .    local nadir point of a subset @xmath25 denoted as @xmath29 is the point in the objective space composed of the worst coordinates of all solutions belonging to @xmath27 , i.e. @xmath30 .",
    "naturally , local nadir point is covered by all solutions in @xmath27 .",
    "approximations of these two points will be also used in nd - tree :    approximate local ideal point of a subset @xmath25 denoted as @xmath31 is a point in the objective space such that @xmath32 .",
    "naturally , approximate local ideal point also covers all solutions in @xmath27 .",
    "approximate local nadir point of a subset @xmath25 denoted as @xmath33 is a point in the objective space such that @xmath34 .",
    "naturally , approximate nadir ideal point is also covered by all solutions in @xmath27 .",
    "we present here a number of methods for the online update of pareto archive presented in the literature and used in the comparative experiment .",
    "this review is not supposed to be exhaustive .",
    "other methods can be found in  @xcite and reviews in  @xcite .",
    "we describe two popular methods : linear list and quad - tree , the composite points method  @xcite and one recent method , m - front  @xcite , when used as a part of the non - dominated sorting procedure gave excellent performances compared to jensen - fortin s algorithm  @xcite , one of the fastest non - dominated sorting algorithm .        in this structure ,",
    "a new solution is compared to all solutions of the list until a covering solution is found or all solutions are checked .",
    "the solution is only added if it is non - dominated w.r.t .",
    "all the solutions in the list , that is we need to browse whole list before adding a solution .",
    "the complexity in terms of number of pareto dominance check is thus in @xmath35 with @xmath36 the size of the list .",
    "when only two objectives are considered , we can use the following special property : if we sort the list according to one objective ( let s say the first ) , the non - dominated list is also sorted according to the second objective .",
    "therefore , roughly speaking , updating of the list can be efficiently done in the following way .",
    "let us consider two minimized objectives .",
    "the list is kept sorted according to the first objective .",
    "we first determine the potential position of the new candidate solution in the sorted list according to its value for the first objective , with a binary search .",
    "please note that in this case , it is more efficient to code the list with a dynamic array to get a constant access to the solutions of the list .",
    "once the place of the new solution is found and it is not equal to some existing solution , it is enough to use these two procedures :    * we compare the new solution to the preceding one ( if there is one ) in the sorted list : this solution has a better value according to the first objective compared to the new solution .",
    "therefore , if the preceding solution has also a better value according to the second objective , the new solution is dominated and can not be added . *",
    "if the solution is not dominated by the preceding solution , the solution can be added since the next solutions have a higher value for the first objective and can not thus dominated the solution .",
    "we then need to check if there are some dominated solutions : we browse the next solutions of the list , until finding a solution that has a better evaluation according to the second objective compared to the new solution .",
    "all the solutions found that have a worse evaluation according to the second objective have to be removed since there are dominated by the new solution .",
    "the worst - case complexity is still in @xmath35 since it can happen that a new solution has to be compared to all the other solutions ( in the special case where we add a new solution in the first position and all the solutions of the sorted list are dominated by this new solution ) .",
    "but on average , experiments show that the behavior of this structure for handling two objectives updating problems is much better than a simple list since the worst - case scenario rarely occurs .",
    "the use of quad - tree for storing potentially efficient solutions was proposed by habenicht  @xcite and further developed by sun and steuer  @xcite , and mostaghim and teich  @xcite . in quad - tree",
    ", solutions are located in both internal nodes and leafs . each node may have @xmath37 sons corresponding to each possible combination of results of comparisons on each objective where a solution can either be better or not worse . in the case of mutually non - dominated solutions in fact",
    "@xmath38 sons are possible since the combinations corresponding to dominating or covered solutions are not possible .",
    "quad - tree allows for a fast checking if a new solution is dominated or covered .",
    "a weak point of this data structure is that when an existing solution is removed its whole sub - tree has to be re - inserted to the structure .",
    "thus , removal of a dominated solution is in general costly . in this paper",
    "we use quad - tree2 version as described by mostaghim and teich  @xcite .",
    "m - front has been proposed relatively recently by drozdk et al .",
    "@xcite as a part of method for non - dominated sorting problem .",
    "the idea of of m - front is as follows .",
    "assume that in addition to the new solution @xmath0 a reference solution @xmath39 relatively close to @xmath0 and belonging to the pareto archive @xmath24 is known .",
    "the authors define two sets :    @xmath40    @xmath41    and prove that if a solution @xmath42 is dominated by @xmath0 then it belongs to @xmath43 and if @xmath44 dominates @xmath0 then it belongs to @xmath45 .",
    "thus , it is sufficient to compare the new solutions to sets @xmath43 and @xmath45 only . to find all solutions with objective values in a certain interval",
    "m - front uses additional indexes one for each objective .",
    "each index sorts the pareto archive according to one objective .    to find a reference solution being close to @xmath0",
    "m - front uses the k - d tree data structure .",
    "the k - d tree is a binary tree in which each intermediate node divides the space into two parts based on a value of one objective . while going down the tree the algorithm cycle over particular objectives , selecting one objective for each level .",
    "drozdk et al .",
    "@xcite suggest to store references to solutions in leaf nodes only , while intermediate nodes keep only split values . to insert a solution k - d tree selects either lower or upper - or - equal half - space .",
    "please note , that the paper of drozdk et al .",
    "@xcite does not give the precise algorithm of k - d tree .",
    "in our implementation when a leaf is reached a new division is made using the average value of the current level objective .",
    "the split value is average between the value for new solution and the solution in the leaf .",
    "also alike drozdk et al .",
    "@xcite approximate nearest neighbor is found exactly as in the standard exact nearest neighbor search , but only four evaluations of the distance are allowed .",
    "we do not use the rebalancing of the k - d tree described in  @xcite since it would never be activated in the case of all data sets used in this paper and is very unlikely to be used in the case of solutions generated by pls .      while implementing m - front for the purpose of computational experiment we noticed that a number of elements can be improved to reduce further the running time .",
    "the improvement is in our opinion significant enough to call the new method m - front - ii ( see algorithm  [ mfrontupdate ] ) .",
    "the modifications we introduced are as follows :    * in original m - front the sets @xmath43 and @xmath45 are built explicitly and only then the solutions contained in these sets are compared to @xmath0 . in m - front - ii",
    "we build them only implicitly , i.e. we immediately compare the solutions that would be added to the sets to @xmath0 . * we analyze the objectives such that we start from objectives for which @xmath46 . in other words",
    "we start with solutions from set @xmath45 .",
    "since many new solutions are dominated it allows to stop the search immediately when a solution dominating @xmath0 was found .",
    "note that a similar mechanism is in fact used in original m - front but only after the sets @xmath43 and @xmath45 are explicitly built . *",
    "the last modification is more technical .",
    "m - front uses linked lists ( ` std::list ` in c++ ) to store the indexes and a hash - table ( ` std::unordered_map ` in c++ ) to link solutions with their positions in these lists .",
    "we observed , however , that even basic operations like iterating over the list are much slower with linked lists than with dynamic arrays ( like ` std::vector ` in c++ ) .",
    "thus we use dynamic arrays for the indexes . in this case , however , there is no constant iterator that could be used to link the solutions with their positions in these indexes .",
    "so , we use the fast binary search to locate a position of a solution in the sorted index whenever it is necessary .",
    "the overhead of the binary search is anyway smaller than the savings due to use of faster hash - table .",
    "parameter @xmath47 : a pareto archive @xmath24 with @xmath48 indexes @xmath49 , i.e. lists containing references to all solutions sorted incrementally according to objective @xmath50 and @xmath51 a k - d tree containing references to all solutions parameter @xmath52 : new candidate solution @xmath0    add @xmath0 to @xmath24 and its reference to all indexes @xmath53 and to @xmath51 find reference solution @xmath39 using approximate nearest neighbor search in @xmath51 stop : @xmath0 is rejected -@xmath54-@xmath55 comparison to set @xmath45 find @xmath56 , i.e. position of @xmath39 in index @xmath53 using binary search decrement @xmath56 to the last position where @xmath57_k = ref_k$ ] stop : @xmath0 is dominated it++ insert @xmath0 to @xmath53 right before @xmath56    -@xmath54-@xmath55 comparison to set @xmath43 find @xmath56 , i.e. position of @xmath39 in index @xmath53 using binary search increment @xmath56 to the last position where @xmath57_k = ref_k$ ] remove @xmath57 $ ] from @xmath24 , indexes @xmath53 and @xmath51 it insert @xmath0 to @xmath53 right after @xmath56    @xmath58 add @xmath0 to @xmath51      the composite points method has been developed by fieldsend  _ et al _",
    "@xcite in 2003 .",
    "they introduce two new data structures called dominated tree and non - dominated tree .",
    "the dominated tree allows to detect if a new solution should be included into the pareto archive ( that is the new solution is not covered ) and the non - dominated tree allows to determine which solutions of the pareto archive are dominated by the new solution .",
    "some particular points , called _ composite points _ , are used to build the trees .",
    "these points are based on the maximal and minimal coordinates of the points of the pareto archive , and are built such that a total order between the composite points is obtained , according to the coverage relation .",
    "a binary search among the composite points of each tree allows then to update the pareto archive when a new candidate point is added .",
    "this method has been compared to the simple list for standard multiobjective continuous problems ( zdt test functions  @xcite ) but no significant difference in speed has been achieved .",
    "the new method proposed in this paper is based on the following idea that allows to reduce the number of comparisons to be made .",
    "consider a subset @xmath59 composed of mutually non - dominated solutions and a new candidate solution @xmath0 .",
    "assume that some approximate local ideal @xmath31 and approximate local nadir points @xmath33 are known .",
    "we can define the following simple properties :    1 .",
    "if @xmath0 is covered by @xmath33 , then @xmath0 is covered by each solution in @xmath27 and thus can be rejected .",
    "+ this property is a straightforward consequence of the transitivity of the coverage relation .",
    "if @xmath0 covers @xmath31 , then each solution in @xmath27 is covered by @xmath0 .",
    "+ this property is also a straightforward consequence of the transitivity of the coverage relation .",
    "3 .   if @xmath0 is non - dominated w.r.t . both @xmath33 and @xmath31 , then @xmath0 is non - dominated w.r.t .",
    "each solution in @xmath27 .",
    "+ if @xmath0 is non - dominated w.r.t .",
    "@xmath33 then there is at least one objective on which @xmath0 is worse than @xmath33 and thus worse than each solution in @xmath27 . if @xmath0 is non - dominated w.r.t .",
    "@xmath31 then there is at least one objective on which @xmath0 is better than @xmath31 and thus better than each solution in @xmath27 .",
    "so , there is at least one objective on which @xmath0 is better and at least one objective on which @xmath0 is worse than each solution in @xmath27 .",
    "4 .   if none of the above holds , i.e. @xmath0 is neither covered by @xmath33 , does not cover @xmath31 , nor is non - dominated w.r.t . both @xmath33 and @xmath31 , then all situations are possible , i.e. @xmath0 may either be non - dominated w.r.t .",
    "all solutions in @xmath27 , covered by some solutions in @xmath27 or dominate some solutions in @xmath27 . +",
    "this property can be proven by showing examples of each of the situation .",
    "consider for example a set @xmath60 with @xmath61 and @xmath62 .",
    "a new solution @xmath63 dominates a solution in @xmath27 , a new solution ( 1 , 1 , 2 ) is dominated ( thus covered ) by a solution in @xmath27 , and solutions @xmath64 and @xmath65 are non - dominated w.r.t . all solutions in @xmath27 .",
    "the properties are graphically illustrated for the biobjective case in figure  [ fig : properties ] . as can be seen in this figure , in the biobjective case ,",
    "if @xmath0 is covered by @xmath31 and @xmath0 is non - dominated w.r.t .",
    "@xmath33 then @xmath0 is dominated by at least one solution in @xmath27 .",
    "note , however , that this does not hold in the case of three and more objectives as shown in the example used in the proof - the point @xmath66 is covered by @xmath67 , non - dominated w.r.t . @xmath68 and @xmath66",
    "is not dominated by any points in @xmath27 .",
    "in fact it is possible to distinguish more specific situations if property 4 holds , e.g. situation when a new solution may be covered but can not dominate any solution , but since we do not distinguish them in the proposed algorithm we do not define them formally .     based on comparisons to @xmath31 and @xmath33 only . ]",
    "the above properties allow in some cases to quickly compare a new candidate solution @xmath0 to all solutions in a set @xmath27 without the need for further comparisons to individual solutions belonging to @xmath27 .",
    "such further comparisons are necessary only if the situations described by property 4 hold .",
    "intuitively , the closer the approximate local ideal and nadir points the stronger are these properties , i.e. it is more likely that the further comparisons can be avoided . to obtain close approximate local ideal and nadir points",
    "we should :    * split the whole set of potentially efficient solutions into subsets of solutions located close in the objective space . *",
    "have good approximations of the exact local ideal and nadir points . on the other hand calculation of the exact points",
    "may be computationally demanding and a reasonable approximation may assure the best overall efficiency .",
    "based on these properties , we can now define the nd - tree structure .",
    "nd - tree data structure is a tree with the following properties :    1 .   with each node @xmath69",
    "is associated a set of solutions @xmath70 .",
    "2 .   each leaf node contains a list @xmath71 of solutions and @xmath72 .",
    "3 .   for each internal node @xmath69 , @xmath70 is the union of sets associated with all sons of @xmath69 .",
    "each node @xmath69 stores an approximate ideal point @xmath73 and approximate nadir point @xmath74 .",
    "5 .   if @xmath75 is a son of @xmath69 , then @xmath76 and @xmath77 .",
    "the algorithm to update a pareto archive with nd - tree is given in algorithm  [ algoupdate ] ( ` update ` ) .",
    "the idea of the algorithm is as follows .",
    "we start by checking if the new solution @xmath0 is dominated , covered or non - dominated w.r.t .",
    "all solutions in @xmath24 by going through the nodes of nd - tree and skipping sons ( and thus their sub - trees ) for which property 4 does not hold .",
    "this procedure is presented in algorithm  [ algoupdatenode ] ( ` updatenode ` ) .",
    "the new solution is first compared to the approximate ideal point @xmath78 and nadir point ( @xmath74 of the current node . if the new solution is dominated by @xmath79 it is immediately rejected ( * property 1 * ) . if @xmath80 is covered , the node is deleted and its whole sub - tree as well ( * property 2 * ) . otherwise if @xmath81 or @xmath82 ( * property 4 * ) and if @xmath69 is a leaf node , @xmath0 may be dominated by or dominate some solutions of @xmath69 and it is necessary to browse the whole list @xmath71 of the node @xmath69 . if a solution dominating @xmath0 is found , @xmath0 is rejected , and if a solution dominated by @xmath0 is found , the solution is deleted from @xmath71 .",
    "if after checking nd - tree the new solution was found to be non - dominated it is inserted by adding it to a close leaf ( algorithm  [ algoinsert ] ` insert ` ) . to find a proper leaf we start from the root and always select a son with closest distance to @xmath0 . as a distance measure we use the euclidean distance to the middle point between approximate ideal and approximate nadir points .",
    "the middle point is a point with individual coordinates equal to the average of corresponding coordinates in approximate ideal and approximate nadir points .",
    "such distance measure is very fast to compute based on the two points only .",
    "since we do not need the value of the euclidean distance but just the order induced by this distance , we used squared euclidean distance to avoid calculation of the root .",
    "once we have reached a leaf node , we add the solution @xmath0 to the list @xmath71 of the node and possibly update the ideal and nadir points of the node @xmath69 ( algorithm  [ algoupdateidealnadir ] ` updateidealnadir ` ) .",
    "however , if the size of @xmath71 became larger than the maximum allowed size of a leaf set , we need to split the node into a predefined number of sons ( algorithm  [ algosplit ] ` split ` ) .",
    "we first select one solution of @xmath71 for each new subnode .",
    "the first solution selected is the one with the highest euclidean distance to all other solutions in @xmath71 .",
    "then we select the solution with the highest average euclidean distance to all the solutions contained in all subnodes already created .",
    "we continue this procedure until the required number of subnodes is created . finally , we add each remaining solution of @xmath71 to the closest subnode .",
    "we use as distance measure the euclidean distance to the middle point between approximate ideal and approximate nadir points , as done in the ` insert ` algorithm .",
    "the approximate local ideal and nadir points are updated only when a solution is added .",
    "we do not update them when solution(s ) are removed since it is a more complex operation .",
    "this is why we deal with approximate ( not exact ) local ideal and nadir points .",
    "please note that our goal is to propose a practically fast method .",
    "we do not present any analysis of worst case complexity but we will show that this method performs well in computational experiments .",
    "parameter @xmath47 : a pareto archive @xmath24 organized as nd - tree parameter @xmath52 : new candidate solution @xmath0    create a leaf node @xmath69 with an empty list set @xmath71 and use it as a root ` \\mathcal{l}(n ) \\leftarrow \\mathcal{l}(n ) + x ` @xmath83 root node ` updatenode`(@xmath84,@xmath85 ) ` insert`(@xmath84,@xmath85 )    parameter @xmath47 : a node @xmath69 parameter @xmath52 : new candidate solution @xmath0 compare @xmath0 to @xmath73 and @xmath74 -@xmath54-@xmath55 property 1 stop : @xmath0 is rejected -@xmath54-@xmath55 property 2 remove @xmath69 and its whole sub - tree -@xmath54-@xmath55 property 4 stop :",
    "@xmath0 is rejected remove @xmath44 ` updatenode ` ( @xmath86,@xmath85 ) remove @xmath75    parameter @xmath47 : a node @xmath69 parameter @xmath52 : new candidate solution @xmath0    ` \\mathcal{l}(n ) \\leftarrow \\mathcal{l}(n ) + x ` ` updateidealnadir ` ( @xmath87,@xmath85 ) ` split ` ( @xmath87 ) find subnode @xmath75 of @xmath69 being closest to @xmath0 ` insert`(@xmath86,@xmath85 )    parameter @xmath47 : a node @xmath69    find the solution @xmath88 with the highest average euclidean distance to all other solutions in @xmath71 create a new subnode @xmath75 with an empty list set @xmath89 @xmath90 ` updateidealnadir ` ( @xmath91,@xmath92 ) @xmath93 create a new subnode @xmath75 with an empty list set @xmath89 @xmath90 ` updateidealnadir ` ( @xmath91,@xmath92 ) @xmath93 @xmath94 first solution in @xmath71 find subnode @xmath75 of @xmath69 being closest to @xmath44 @xmath90 ` updateidealnadir ` ( @xmath91,@xmath92 ) @xmath93    parameter @xmath47 : a node @xmath69 parameter @xmath52 : new candidate solution @xmath0    check in any component of @xmath0 is lower than corresponding component in @xmath73 or greater than corresponding component in @xmath74 and update the points if necessary @xmath95 parent of @xmath69 ` updateidealnadir ` ( @xmath96,@xmath85 )",
    "we will show results obtained with nd - tree and other methods in three different cases :    1 .",
    "results for sets artificially generated , which allow us to easily control the number of solutions of the sets and the quality of the solutions .",
    "results when nd - tree is integrated into pls for solving the multiobjective traveling salesperson problem .",
    "results for sets coming from solutions generated by pls for solving the multiobjective traveling salesperson problem .    to avoid the influence of implementation details",
    "all methods were implemented from the scratch in c++ and c in as much homogeneous way as possible , i.e. when possible the same code was used to perform the same operations like pareto dominance checks .",
    "the code , as well as test instances and data sets , are available from the authors upon request .",
    "most of the results have been obtained on an intel core i7 - 5500u cpu at 2.4 ghz .",
    "the results involving pls ( section  [ secpls ] ) were obtained on an i5 - 450 m cpu at 2.4 ghz .",
    "the artificial sets are composed of @xmath69 points with @xmath48 objectives to minimize .",
    "the sets are created as follows .",
    "we generate randomly @xmath69 points @xmath97 in @xmath98 with the following constraint ( otherwise there can be few non - dominated points , all located near to the point @xmath99 ) : @xmath100 . with these constraints , all the non - dominated points will be close to the hypersphere of center @xmath101 and with a radius of length equal to @xmath102 . in order to control",
    "the quality of the points generated , we also add a quality constraint : @xmath103 . with a small @xmath104 ,",
    "only high - quality solutions will be generated and this simulates well the behavior of a momh .",
    "we have generated data sets composed of 100 000 and 200 000 points , with @xmath105 , and for @xmath106 to 6 . in the main experiment we use data sets with 100 000 points because for the larger sets running times of some methods became very long .",
    "for each value of @xmath48 , five different quality sets are considered :    * quality = 1 , @xmath107 * quality = 2 , @xmath108 * quality = 3 , @xmath109 * quality = 4 , @xmath110 * quality = 5 , @xmath111    the fraction of non - dominated solutions grows both with increasing quality and number of objectives and in extreme cases all solutions may be non - dominated ( see table  [ tab : numbersnd ] ) .    [",
    "tab : numbersnd ]    .numbers of non - dominated solutions in artificial sets [ cols=\"^,^,^\",options=\"header \" , ]",
    "according to the results of the computational experiments nd - tree should be a method of choice for storing and updating a pareto archive in the case of three and more objectives problems .",
    "in biobjective case the best choice remains the sorted list .",
    "we believe that with the proposed method for updating a pareto archive , new state - of - the art results could be obtained for many moco problems ( with @xmath112 ) and some momhs could be adapted to this special data structure in order to improve their results .",
    "in fact in this paper we were able to apply pls to motsp instances with up to 6 objectives while according to our knowledge so far pls was applied to biobjective and three - objective instances only .",
    "an interesting direction for further research is to adapt nd - tree to be able to deal with archives of a relatively large but limited size .",
    "finally , it would be interesting to study how nd - tree could be modified to update archives with stronger dominance relations than the pareto dominance ( e.g. sorted - pareto dominance  @xcite or lorenz dominance  @xcite ) . in this way",
    ", preferences of a decision maker could be integrated and methods such as pls will not be limited by the high number of pareto efficient solutions when solving many - objective combinatorial optimization problems .",
    "the research of andrzej jaszkiewicz was funded by the the polish national science center , grant no .  umo-2013/11/b",
    "/ st6/01075 .",
    "a.lara , sanchez , g. , coello , c.  c. , schtze , o. , feb 2010 .",
    "hcs : a new local search strategy for memetic multiobjective evolutionary algorithms .",
    "ieee transactions on evolutionary computation 14  ( 1 ) , 112132",
    ".      angel , e. , bampis , e. , gourvs , l. , 2004 . a dynasearch neighborhood for the bicriteria traveling salesman problem . in : gandibleux , x. , sevaux , m. , srensen , k. , tkindt , v. ( eds . ) , metaheuristics for multiobjective optimisation .",
    "lecture notes in economics and mathematical systems vol .",
    "535 , berlin , pp .",
    "153176 .",
    "brockhoff , w. , 2010 .",
    "theory of randomized search heuristics : foundations and recent developments .",
    "world scientific publishing company , ch .",
    "theoretical aspects of evolutionary multiobjective optimization , pp . 101139 .",
    "coelho , v.  n. , souza , m. j.  f. , coelho , i.  m. , guimares , f.  g. , lust , t. , cruz , r.  c. , 2012 .",
    "multi - objective approaches for the open - pit mining operational planning problem .",
    "electronic notes in discrete mathematics 39 , 233240 .",
    "fortin , f .- a .",
    ", grenier , s. , parizeau , m. , 2013 . generalizing the improved run - time complexity algorithm for non - dominated sorting . in : proceedings of the 15th annual conference on genetic and evolutionary computation .",
    "gecco 13 .",
    "acm , new york , ny , usa , pp .",
    "615622 .",
    "habenicht , w. , 1983 . essays and surveys on multiple criteria decision making : proceedings of the fifth international conference on multiple criteria decision making , mons , belgium , august 913 , 1982 .",
    "springer berlin heidelberg , ch .",
    "quad trees , a datastructure for discrete vector optimization problems , pp . 136145 .",
    "inja , m. , kooijman , c. , de  waard , m. , roijers , d. , whiteson , s. , september 2014 .",
    "queued pareto local search for multi - objective optimization . in : ppsn 2014 : proceedings of the thirteenth international conference on parallel problem solving from nature .",
    ". 589599 .",
    "kooijman , c. , de  waard , m. , inja , m. , roijers , d. , whiteson , s. , april 2015 .",
    "pareto local policy search for momdp planning . in : esann 2015 : proceedings of the 23rd european symposium on artificial neural networks , special session on emerging techniques and applications in multi - objective reinforcement learning .",
    ". 5358 .",
    "mostaghim , s ;  teich , j. , 2004 .",
    "quad - trees : a data structure for storing pareto sets in multiobjective evolutionary algorithms with elitism . in : abraham ,",
    "a ;  jain , l. g.  r. ( ed . ) , evolutionary multiobjective optimization , book series : advanced information and knowledge .",
    "springer - verlag london ltd , pp .",
    "81104 .",
    "mostaghim , s. , teich , j. , tyagi , a. , 2002 .",
    "comparison of data structures for storing pareto - sets in moeas . in : evolutionary computation , 2002 .",
    "proceedings of the 2002 congress on .",
    "vol .  1 .",
    "843848 .",
    "omahony , c. , wilson , n. , 2013 . sorted - pareto dominance and qualitative notions of optimality . in : gaag , l.  c. ( ed . ) , symbolic and quantitative approaches to reasoning with uncertainty : 12th european conference , ecsqaru 2013 , utrecht , the netherlands , july 8 - 10 , 2013 .",
    "springer berlin heidelberg , pp .",
    "449460 .",
    "paquete , l. , chiarandini , m. , sttzle , t. , 2004 .",
    "pareto local optimum sets in the biobjective traveling salesman problem : an experimental study . in : gandibleux , x. , sevaux , m. , srensen , k. , tkindt , v. ( eds . ) , metaheuristics for multiobjective optimisation .",
    "lecture notes in economics and mathematical systems vol . 535 , berlin , pp . 177199 .",
    "schtze , o. , 2003 . a new data structure for the nondominance problem in multi - objective optimization . in : proceedings of the 2nd international conference on evolutionary multi - criterion optimization .",
    "springer - verlag , berlin , heidelberg , pp .",
    "509518 .",
    "schtze , o. , mostaghim , s. , dellnitz , m. , teich , j. , 2003 .",
    "covering pareto sets by multi - level evolutionary subdivision techniques . in : proceedings of the second int .",
    "conf . on evolutionary multi - criterion optimization .",
    "springer , berlin , pp .",
    "118132 .",
    "teixeira , c. , covas , j. , sttzle , t. , gaspar - cunha , a. , 2009 .",
    "application of pareto local search and multi - objective ant colony algorithms to the optimization of co - rotating twin screw extruders . in : viana ,",
    "a. , et  al .",
    "( eds . ) , proceedings of the eu / meeting 2009 : debating the future : new areas of application and innovative approaches .",
    ". 115120 ."
  ],
  "abstract_text": [
    "<S> in this paper we propose a new method called nd - tree for fast online update of a pareto archive composed of mutually non - dominated solutions . </S>",
    "<S> nd - tree uses a tree structure in which each node represents a subset of solutions contained in a hypercube defined by its local approximate ideal and nadir points . </S>",
    "<S> a leaf is a subset of solutions organized as a simple list , and an internal node is subset of solutions composed of the union of all its sub - nodes . using heuristic rules we build subsets , either leafs or internal nodes , containing solutions located close in the objective space . using basic properties of local ideal and nadir points </S>",
    "<S> we can efficiently avoid searching many branches in the tree . </S>",
    "<S> nd - tree may be used in any multiobjective metaheuristics e.g. in an multiobjective evolutionary algorithm to update the external archive of potentially efficient solutions . </S>",
    "<S> we experimentally compare nd - tree to simple list , quad - tree , and m - front methods using artificial and realistic benchmarks . </S>",
    "<S> finally we apply nd - tree within two - phase pareto local search for traveling salesperson problems instances with up to 6 objectives . </S>",
    "<S> we show that with this new method substantial reduction of the computational time can be obtained .    </S>",
    "<S> multiobjective optimization , pareto archive , quad - tree , pareto local search , many - objective optimization </S>"
  ]
}