{
  "article_text": [
    "this paper addresses a theoretical problem arising in a novel approach to network traffic measurement the authors and their collaborators have recently developed .",
    "we refer the reader to @xcite for technological background , motivation , related literature and other details . in order to keep this paper",
    "self - contained , we summarize the background and restrict the literature survey to what is relevant for the results of this paper .    * background . * measuring the sizes of network flows on high speed links is known to be a technologically challenging problem @xcite . the nature of the data to be measured is as follows : at any given time several 10s or 100s of thousands of flows can be active on core internet links .",
    "packets arrive at the rate of one in every 40 - 50 nanoseconds on these links which currently run at 10 gbps . finally , flow size distributions are heavy - tailed , giving rise to the well - known decomposition of flows into a large number of short `` mice '' and a few large `` elephants . '' as a rule of thumb , network traffic follows an `` 80 - 20 rule '' : 80% of the flows are small , and the remaining 20% of the large flows bring about 80% of the packets or bytes .",
    "this implies that measuring flow sizes accurately requires a large array of counters which can be updated at very high speeds , and a good counter management algorithm for updating counts , installing new counters when flows initiate and uninstalling them when flows terminate .",
    "since high - speed large memories are either too expensive or simply infeasible with the current technology , the bulk of research on traffic measurement has focused on approximate counting methods .",
    "these approaches aim at detecting elephant flows and measuring their sizes",
    ".    * counter braids . * in @xcite",
    "we develop a novel counter architecture , called `` counter braids '' , which is fast , very efficient with memory usage and gives an accurate measurement of _ all _ flow sizes , not just the elephants .",
    "we will briefly review this architecture using the following simple example .",
    "suppose we are given 5 numbers and are told that four of them are no more than 2 bits long while the fifth can be 8 bits long .",
    "we are not told which is which",
    "!    figures [ fig : simplecounters ] and [ fig : counterbraid ] present two approaches for storing the values of the 5 numbers .",
    "the first one corresponds to a traditional array of counters , whereby the same number of memory registers is allocated to each measured variable ( flow ) .",
    "the structure in fig .",
    "[ fig : counterbraid ] is more efficient in memory , but retrieving the count values is less straightforward , requiring a flow size estimation algorithm .",
    "( -148,80)@xmath0 ( -148,61.5)@xmath1 ( -148,42)@xmath2 ( -148,23.5)@xmath0 ( -152,4)@xmath3    ( -158,78)@xmath0 ( -158,59.5)@xmath1 ( -158,41)@xmath2 ( -158,23)@xmath0 ( -162,4.5)@xmath3    viewed from an information - theoretic perspective , the design of an efficient counting scheme and a good flow size estimation is equivalent to the design of an efficient _ source code _ @xcite .",
    "however , the applications we consider impose a stringent constraint on such a code : each time the size of a flow changes ( because a new packet arrives ) a small number of operations must be sufficient to update the stored information .",
    "this is not the case with standard source codes , where changing a single letter in the source stream may alter completely the compressed version .    in this paper",
    "we prove that , under a probabilistic model for the flow sizes ( namely that they form a vector of iid random variables ) , counter braids achieve a compression rate equal to the entropy of the flow sizes distribution , in the large system limit .",
    "namely , for any rate larger than the flow entropy , the flow sizes can be recovered from the counter values , with error probability vanishing in the large system limit .",
    "further , we prove optimal compression can be achieved by using braids that are _ sparse_. the result is non - obvious , since counter braids form a pretty restrictive family of architectures .",
    "our treatment makes use of techniques from the theory of low - density parity check codes , and the whole construction is inspired by that of ldpc @xcite .",
    "the construction of ldpc codes has an analogy in the source coding problem thanks to standard equivalence between coding over discrete memoryless symmetric channels , and compressing iid discrete random variables @xcite .",
    "however , the key ideas in the present paper have been developed to deal with the problem that the flow sizes are _ a priori _ unbounded . in the channel coding language",
    ", this would be equivalent to use a countable but infinite input alphabet .    finally , we insist on using sparse braids for two reasons .",
    "first , this allows the stored values to be updated with a _ small _ ( typically bounded ) number of operations .",
    "second , it is easy to realize that ml decoding of counter braids is np - hard , since it has ml decoding of linear codes as a special case @xcite .",
    "however , thanks to the sparseness of the underlying graph , one may use iterative message passing techniques @xcite .",
    "indeed , a simple message passing algorithm for estimating flow sizes is described and analyzed using real and synthetic network traces in @xcite .",
    "a _ counter braid _ is a couple @xmath4 where @xmath5 is an integer ( register capacity ) and @xmath6 is a directed acyclic graph on vertex sets @xmath7 ( input nodes ) and @xmath8 ( registers ) , with the input nodes having in - degree zero . we write @xmath9 , with @xmath10 the set of directed edges in @xmath6 .    for any node @xmath11",
    ", we will denote by @xmath12 the set of descendants of @xmath13 , and by @xmath14 the set of parents of @xmath13 .",
    "finally @xmath15 .    in the following",
    "we shall often omit the explicit reference to the register capacity and write @xmath6 for @xmath4 .",
    "the input size of the braid is @xmath16 , and its storage size @xmath17 .",
    "an important parameter is its rate , which we measure in bits @xmath18 we will say that a sequence of counters braids @xmath19 is @xmath20 if the number of edges per input node @xmath21 is bounded .",
    "a _ state _ ( or _ configuration _ of the counter braid @xmath22 , with is an assignment @xmath23 of non - negative integers to the nodes in @xmath6 , with @xmath24 , and @xmath25 .",
    "the state @xmath23 is _ valid _ if @xmath26 for any register @xmath27 .",
    "notice that a valid register configuration can be regarded as an element of @xmath28 ( where @xmath29 is the group of integers modulo @xmath30 . )",
    "we denote by @xmath31 the zero vector in @xmath32 .",
    "we want now to describe the braid behavior when one of the input nodes is incremented by one unity ( i.e. when a packet arrives at input node @xmath33 . ) assume the braid @xmath4 to be in a valid state @xmath23 .",
    "given @xmath33 , we define the new state @xmath34 by letting @xmath35 , @xmath36 for any @xmath37 , and @xmath38 be defined by the following procedure .",
    "ll + & + 1 : & @xmath39 for @xmath40 , + & and @xmath41 otherwise .",
    "+ 2 : & set @xmath42 .",
    "+ 3 : & * while * @xmath43 is not valid + 4 : & let @xmath44 be such that @xmath45 ; + 5 : & set @xmath46 ; + 6 : & for any @xmath47 , set @xmath48 ; + 7 : & for any @xmath49 , set @xmath50 ; + 8 : & increment @xmath51 ; + 9 : & * end * + 10 : & * return * @xmath43 .",
    "+    notice that this definition is ambiguous in that we did not specify which register to pick among the ones with @xmath45 at step 4 in the registers update routine .",
    "however this is not necessary , as stated in the following lemma ( the proof is omitted from this extended abstract ) .    the update procedure above halts after a finite number of steps .",
    "further its output @xmath52 does not depend on the order of update of the registers .    with an abuse of notation we shall write @xmath53 , @xmath54 , when @xmath34 .",
    "when input values @xmath55 are incremented sequentially , the stored information @xmath56 is updated according to the above procedure . from now on we shall take a static view and assume a certain input @xmath55 .",
    "the corresponding stored information @xmath56 is obtained through the mapping defined below .",
    "given a counter braid @xmath4 , the associated _ storage function _",
    "@xmath57 returns , for any input configuration @xmath58 a register configuration @xmath59 defined as follows .",
    "let @xmath60 , @xmath61 , @xmath62 be a sequence of input configurations such that @xmath63 is obtained from @xmath64 by incrementing its entry @xmath65 . then @xmath66    we shall drop the subscript @xmath6 from @xmath67 whenever clear from the context . a priori",
    "it is not obvious that the mapping @xmath67 is well defined . in particular",
    ", it is not obvious that it does not depend on the order in which input values are incremented , i.e. on the sequence @xmath68 .",
    "this is nevertheless the case ( the proof is omitted . )    given a counter braid @xmath4 , a _ reconstruction _ ( or _ decoding _ ) _ function _ is a function @xmath69 .      throughout this paper",
    ", we shall model the input values as iid integer random variables @xmath70 ( identifying @xmath71 $ ] ) with common distribution @xmath72 .",
    "the ( binary ) entropy of this distribution will be denoted by @xmath73 .",
    "a sequence of counters braids @xmath19 , with @xmath74 has _ design rate _",
    "@xmath75 if @xmath76 it is _ reliable _ for the distribution @xmath72 if there exists a sequence of reconstruction functions @xmath77 such that , for @xmath78 a random input and @xmath79 @xmath80    shannon s source coding theorem implies that there can not exist reliable counter braids with asymptotic rate @xmath81 .",
    "however , the achievability of such rates is far from obvious , since counter braids are a fairly specific compression scheme .",
    "the main theorem of this paper establishes achievability , even under the restriction that the braid is sparse .    in order to avoid technical complication , we make two assumptions on the input distribution @xmath72 :    1 .   it has _ at most power - law tails_. by this we mean that @xmath82 for some @xmath83 .",
    "2 .   it has _ decreasing digit entropy_. let @xmath84 be the @xmath30-ary expansion of @xmath85 , and @xmath86 be the @xmath30-ary entropy of @xmath87 .",
    "then @xmath86 is monotonically decreasing in @xmath88 for any @xmath30 large enough .",
    "we call a distribution @xmath72 with this two properties _ admissible_. while this class does not cover all possible distributions , it is likely to include any case of practical interest .",
    "[ thm : mainthm ] for any admissible input distribution @xmath72 , and any rate @xmath89 there exist a sequence of reliable sparse counter braids with asymptotic rate @xmath75 .",
    "as stressed above , we insist on the braid being sparse for two reasons : @xmath90 it allows to update the registers content @xmath56 with a small number of operations , whenever one entry of @xmath55 is incremented ( i.e. the storage function can be efficiently recomputed ) ; @xmath91 it opens the way to using low - complexity message passing algorithms for estimating the input vector @xmath55 , given the stored information ( i.e. for evaluating the recovery function @xmath92 ) .",
    "we will consider _ layered _ architectures . by this",
    "we mean that the set of register is the disjoint union of @xmath93 layers @xmath94 and that directed edges are either from @xmath7 to @xmath95 or from @xmath96 to @xmath97 for some @xmath98 ( we shall sometimes adopt the convention @xmath99 ) .",
    "we denote by @xmath100 the vector of register values in layer @xmath88 .",
    "we further let @xmath101 denote the size of the @xmath88-th layer ( with @xmath102 ) .",
    "the graph structure is conveniently encoded in @xmath93 matrices @xmath103 , ",
    "@xmath104 , whereby @xmath105 is the @xmath106 adjacency matrix of the subgraph induced by @xmath107 .",
    "we further let @xmath108 .",
    "the storage function @xmath109 can be characterized as follows .",
    "[ lemma : expansion ] consider an @xmath93-layers counters braid , let @xmath55 be its input , and define the sequence of vectors @xmath110 , by @xmath111 and @xmath112 ( the division and floor operation being component - wise on the vector @xmath113 . )",
    "then , the register values are @xmath114 .",
    "we now describe the recovery function @xmath115 .",
    "since in this paper we are only interested in achievability , we will neglect complexity considerations .",
    "let us start from a one - layer braid and assume the inputs to be iid with common distribution @xmath116 supported on @xmath117 .",
    "then the register values are @xmath118 @xmath119 , where @xmath120 is the adjacency matrix of the braid .",
    "fix @xmath121 .",
    "we say that the input @xmath122 is _ typical _ , and write @xmath123 if its type @xmath124 satisfies @xmath125 ( here the kullback - leibler divergence is computed in natural base ) .",
    "denote by @xmath126 the set of input vectors that are typical and such that @xmath127 @xmath119 .",
    "the ` typical set decoder ' returns a vector @xmath128 if this is the the unique element in @xmath126 and a standard error message otherwise . in formulae",
    "@xmath129      consider now a multi - layer braid and @xmath130 ( inputs not restricted to be smaller than @xmath30 ) with @xmath131 s distributed independently according to @xmath72 .",
    "it is convenient to write the input vector in base @xmath30 @xmath132 where @xmath133 with @xmath134 .",
    "notice that , for each @xmath135 , the vector @xmath136 has iid entries .",
    "let @xmath137 be the distribution on @xmath138 when @xmath131 has distribution @xmath72 .",
    "we ll apply typical set decoding recursively , determining the @xmath30-ary vectors @xmath139 , @xmath140 , @xmath141 , @xmath142 in this order .",
    "consider first @xmath139 .",
    "it is clear from lemma [ lemma : expansion ] that @xmath143 @xmath119 .",
    "we then apply typical set decoding to the determination of @xmath139 .",
    "more precisely , we look for a solution of @xmath144 @xmath119 that is typical under distribution @xmath145 . if there is a unique such solution ,",
    "we declare it our estimate of @xmath139 and denote by @xmath146 .",
    "otherwise we declare an error .",
    "consider now the determination of @xmath147 and assume the lower order terms in the expansion ( [ eq : xexpansion ] ) have already been estimated to be @xmath146 , @xmath148 , @xmath142 , @xmath149 .",
    "let @xmath150 , and @xmath151 , @xmath152 be determined through the same recursion as in eq .",
    "( [ eq : zrecursion ] ) .",
    "further let @xmath153 ( this are nothing but the register values on input @xmath154 ) .",
    "assume the estimates @xmath146 , @xmath148 , @xmath142 , @xmath149 to be correct .",
    "it is then easy to realize that @xmath155 for @xmath156 .",
    "further @xmath157 @xmath119 , hence @xmath158 we therefore proceed to compute @xmath159 @xmath119 .",
    "if the linear system @xmath160 @xmath161 admits more than one or no solution that is typical with respect to the distribution @xmath162 , an error is returned .",
    "otherwise , the next term in the expansion ( [ eq : xexpansion ] ) is estimated through the unique typical solution of such linear system .",
    "the recovery algorithm is summarized below , with one improvement with respect to the description above . instead of recomputing @xmath154 , @xmath163 , at stage @xmath88",
    "we only compute the vector @xmath164 that is needed at the present stage .",
    "ll + & + 1 : & initialize @xmath165 for @xmath135 ; + 2 : & * for @xmath166 * + 3 : & set @xmath167 @xmath119 ; + 4 : & let @xmath168 be the set of @xmath162-typical + & solutions of @xmath169 , @xmath119 ; + 5 : & if @xmath170 let @xmath171 + & otherwise if @xmath172 return error ; + 6 : & set @xmath173 ; + 7 : & * end * + 8 : & * return * @xmath174 . +      the optimal compression rate in theorem [ thm : mainthm ] is achieved with the following random sparse graph construction .",
    "fix the registers capacity @xmath30 and an integer @xmath175 .",
    "then for @xmath176 the graph induced by vertices @xmath177 has a random edge set that is sampled by connecting each @xmath178 to @xmath179 iid uniformly random vertices in @xmath180 ( all edges being directed from @xmath181 to @xmath180 ) . in other words , the @xmath106 , @xmath182 matrix @xmath183 has independent columns , each sampled by incrementing @xmath179 iid positions .",
    "the choice of this ensemble is motivated by implementation concerns . in the flow counting problem , we do not know a priori the exact number of flows that needs to be stored .",
    "the above structure , this number can be changed without modifying existing links .",
    "further , for each new flow , the subset of @xmath179 registers it is connected to can be chosen through a simple hash function .    to these @xmath184 stages , we add further @xmath185 stages , all of the same size @xmath186 , with edges connecting each node in @xmath181 to a different node in @xmath187 .",
    "equivalently , we take @xmath105 to be the identity matrix in these stages .    it remains to specify the number of stages @xmath184 , @xmath185 and their sizes @xmath188 , ",
    ", @xmath189 .",
    "let @xmath162 be the distribution of the @xmath88-th least significant digit in the @xmath30-ary expansion of @xmath85 . recall that we defined @xmath86 to be the @xmath30-ary entropy of the distribution @xmath162 ,",
    "i.e. @xmath190 finally , in the achievability proof , we shall assume that @xmath30 is a prime number , large enough for @xmath86 to be monotonically decreasing .",
    "[ lemma : entropy ] assume @xmath191 .",
    "then there exists constants @xmath192 that only depend on @xmath193 , such that for all @xmath194 , and all @xmath30 large enough @xmath195    the proof of this simple lemma is deferred to section [ sec : lemmas ] .",
    "[ lemma : typicalsize ] let @xmath116 be a distribution over @xmath196 , with @xmath30-ary entropy @xmath197 , and @xmath198 be the set of @xmath116-typical vectors defined as in sec [ sec : recovery ] . let @xmath199 be the size of this set . recall that @xmath123 if its type @xmath124 satisfies @xmath125 . then , for any @xmath200 , there exists @xmath201 such that @xmath202 further , if @xmath203 is a vector with iid entries with common distribution @xmath116 @xmath204    in the following we will consider @xmath205 and @xmath206 fixed once and for all , for instance by @xmath207 and @xmath208 .",
    "fix some @xmath209 , and let @xmath210 be a suitably large constant , we let , for @xmath176 , @xmath211 the number of stages is such that @xmath212 this implies , by lemma [ lemma : entropy ] , @xmath213 . to this",
    "we add @xmath214 stages within the second group , of size @xmath215 .",
    "the total number of registers is therefore upper bounded as @xmath216 , and therefore the asymptotic rate of this architecture @xmath217 since the right hand side can be made arbitrarily close to @xmath218 by lemma [ lemma : entropy ] , theorem [ thm : mainthm ] follows from the following .",
    "[ thm : rephrasing ] for any input distribution @xmath72 with at most power - law tails and any choice of @xmath5 and @xmath209 , there exists @xmath175 such that the multi - layer braid described above is reliable .",
    "in order to prove our main theorem or , equivalently , theorem [ thm : rephrasing ] , we need first to prove a few preliminary results concerning a one - layer architecture .",
    "the proof here follows the technique of @xcite , the main tool being an estimate of the distance enumerator as in @xcite .",
    "distance enumerators for non - binary ldpc codes have been estimated in @xcite .",
    "unhappily we can not here limit ourselves to citing these works , because the graph ensemble is different from the regular ones treated there .    throughout this section",
    "the source is a vector @xmath219 with iid entries taking values in @xmath220 and distribution @xmath116 ( in the application to multi - layer schemes @xmath116 will coincide with @xmath162 for some @xmath221 ) .",
    "we let @xmath120 be an @xmath222 matrix whose columns are independent vectors with integer entries .",
    "each column is obtained by choosing @xmath179 positions independently and uniformly at random ( eventually with repetition ) and incrementing the corresponding entry by one . in other words , @xmath120 is distributed as the adjacency matrix of a given layer in the multi - layer architecture .",
    "our first result is a simple combinatorial calculation .",
    "let @xmath223 be a vector in @xmath224 .",
    "it is convenient to introduce the random variable @xmath225 taking values in @xmath226 .",
    "the joint distribution of @xmath227 ( to be denoted by @xmath228 ) is the one of @xmath229 poisson random variables with means ( respectively ) @xmath230 , conditioned on @xmath231 , @xmath119 .    [ lemma : probsol ] let @xmath232 be an input vector with @xmath233 entries equal to @xmath234 , for @xmath235 , and @xmath120 be a random matrix as above .",
    "define @xmath236 .",
    "for any @xmath237 , let @xmath238,  @xmath239 be @xmath240 iid vectors with distribution @xmath241 .",
    "then the probability that @xmath242 @xmath119 is @xmath243 where @xmath244 is the probability that @xmath245 , @xmath119 for independent poisson random variables with means @xmath246 .",
    "further , for some universal constant @xmath247 , and @xmath248 , and @xmath249 @xmath250\\ , , \\\\",
    "r(m , n ) & = & \\min\\left\\{1 , ( cq^2n / m)^{n}\\right\\ } \\label{eq : boundprob3 } \\ ] ]    due to the symmetry of the distribution of @xmath120 with respect to permutation in its columns , @xmath251 does depend on @xmath55 only through the number of ones , twos , etc . without loss of generality we can assume the first @xmath252 coordinates to be ones , the next @xmath253 to be twos , and so on , and neglect the last @xmath254 columns , corresponding to zeros .",
    "think now of filling the matrix , by choosing its non - zero entries ( edges in the associated graph ) . if we associate to each such entry the value of the corresponding coordinate in @xmath55 , we want the probability for the sum of labels on each row to be @xmath31 @xmath119 .",
    "since entries are independent and uniformly random , this is equal to the probability that each of @xmath240 urns is filled with balls whose labels add to @xmath31 , when we throw @xmath255 balls labeled with @xmath0 , @xmath256 labeled with @xmath1 , and so on .",
    "it is an exercise in combinatorics to show that this is @xmath257 equation ( [ eq : exactprob ] ) is then obtained by evaluating @xmath241 and showing that it yields the above combinatorial expression .    in order to get eq .",
    "( [ eq : boundprob ] ) , we denote @xmath258 by @xmath8 , and use @xmath259 , thus leading to @xmath260 equation ( [ eq : boundprob ] ) follows from the observation that @xmath261 for some universal constant @xmath247 .    in order to prove eq .",
    "( [ eq : boundprob2 ] ) , notice that , by discrete fourier transform @xmath262 the claim is proved by singling out the @xmath263 term and bounding the others using @xmath264 .",
    "let us finally prove eq .",
    "( [ eq : boundprob3 ] ) .",
    "obviously @xmath265 since it is an upper bound on the probability @xmath258 .",
    "if we let @xmath266 , we can therefore assume , without loss of generality , that @xmath267 is an integer with @xmath268 .",
    "let @xmath269 be distributed as @xmath270 conditioned on @xmath269 being an integer .",
    "then the probability @xmath258 is upper bounded by @xmath271 recalling the definition of @xmath269 , we have @xmath272 but @xmath273 .",
    "further , @xmath274 only if @xmath275",
    ". therefore we get @xmath276 the proof is completed by noticing that @xmath277 .    in the following ,",
    "given a vector @xmath278 , we shall denote by @xmath279 is number of non - zero entries .",
    "[ lemma : smallweigth ] let @xmath120 be a random @xmath222 matrix distributed as above , with column weight @xmath179 .",
    "assume @xmath179 not to be a multiple of @xmath30 , @xmath280 , @xmath281 and @xmath282 .",
    "then , there exists a constant @xmath283 , @xmath284 , such that , if @xmath285 then @xmath286 ( where it is understood that @xmath287 . )    throughout the proof , @xmath288 will denote a generic constant depending only on @xmath30 that can be chosen large enough to make the inequalities below hold .",
    "let @xmath289 be such that @xmath290 .",
    "we will upper bound the probability that @xmath291 @xmath119 in different ways depending whether @xmath292 or @xmath293 , where @xmath294 with @xmath295 a function to be determined .",
    "notice that , under our hypotheses , @xmath296 is bounded away from @xmath31 ( as @xmath297 for @xmath298 . )    for @xmath299 ( and @xmath300 ) we use lemma [ lemma : probsol ] , eq .",
    "( [ eq : boundprob ] ) , where we set @xmath301 , @xmath302 and @xmath303 .",
    "further we assumed @xmath304 , which holds without loss of generality if we take @xmath305 in eq .",
    "( [ eq : l0definition ] ) , thus getting @xmath306 since @xmath307 , we have ( by properly adjusting @xmath288 ) @xmath308 for @xmath309 , we use eq .",
    "( [ eq : boundprob ] ) with @xmath310 . since @xmath311 is bounded away from @xmath31 by eq .",
    "( [ eq : l0bound ] ) , we have @xmath312 for some @xmath313 and therefore @xmath314 there are at most @xmath315 vectors @xmath234 with @xmath316 .",
    "if we denote by @xmath317 the probability of the event @xmath318 , the probability in eq .",
    "( [ eq : boundsmalldist ] ) is upper bounded by @xmath319 ( notice that if @xmath179 is not a multiple of @xmath30 , @xmath291 is impossible for @xmath320 ) . by union",
    "bound we have @xmath321 where ( using @xmath322 and eventually adjusting the constant @xmath288 ) @xmath323 for @xmath324 , and choosing @xmath295 small enough in eq .",
    "( [ eq : l0definition ] ) , we obtain @xmath325 thus leading to @xmath326",
    ".    finally consider the contribution of vectors @xmath327 .",
    "proceeding as above , we have @xmath328 here we bounded @xmath329^{an}\\le ( an / e)^{e}$ ] , using the fact that @xmath330 is an increasing function of @xmath55 for @xmath331 , and that @xmath332 is smaller than @xmath333 for @xmath247 small enough .",
    "finally we bound @xmath334 and @xmath335 ( which holds for @xmath240 large enough ) , thus getting @xmath336 if we take @xmath337 , we get @xmath338 , which is smaller than @xmath339 for a properly chosen constant @xmath340 and @xmath341 ( indeed @xmath342 would be enough for any @xmath343 . )",
    "let @xmath344 denote the probability that @xmath88-th term in the @xmath30-ary expansion of @xmath55 is decoded incorrectly by the decoder in section [ sec : recovery ] ( i.e. that @xmath345 ) given that @xmath139 ,  , @xmath346 have been correctly recovered .",
    "we will prove that @xmath347 for some @xmath348 .",
    "since the multi - layer architecture involves at most @xmath349 layers , this implies the thesis .",
    "further , we shall consider only the first @xmath184 layers , since it will be clear from the derivation below that the error probability is decreasing for the last @xmath185 layers .",
    "let @xmath55 be the input .",
    "since we are focusing on the @xmath88-th term in the @xmath30-ary expansion of the input , we will drop the index @xmath88 , and take @xmath350 .",
    "this is just a vector whose entries are iid with distribution @xmath162 .    the error probability @xmath344 is upper bounded by the probability that @xmath351 plus the probability that there exists @xmath352 with @xmath353 @xmath119 .",
    "the first contribution is bounded by lemma [ lemma : typicalsize ] , and we can therefore neglect it .",
    "denoting the second contribution as @xmath354 , and writing @xmath355 , @xmath356 for ( respectively ) expectation with respect to @xmath55 and probability with respect to the matrices @xmath103 , ",
    "@xmath105 , we have ( matrix multiplications below are understood to be modulo @xmath30 ) @xmath357 since , @xmath358 , it is sufficient to show @xmath359 . in @xmath360",
    "we can separate error events due to input @xmath361 such that @xmath362 and the other ones . as",
    "a consequence @xmath360 is upper bounded by @xmath363 here @xmath234 is understood to be a @xmath364 dimensional vector with entries in @xmath365 .",
    "notice that @xmath366 .",
    "next we choose @xmath367 with @xmath368 as in the statement of lemma [ lemma : smallweigth ] . as a consequence",
    "the first term above is upper bounded by @xmath369 where we used @xmath370 and @xmath371 .",
    "the constant @xmath247 that depends uniquely on @xmath30 , @xmath179 , @xmath372 , but not on @xmath373 .",
    "it remains to bound the second contribution , due to inputs @xmath361 with @xmath374 .",
    "using lemma [ lemma : typicalsize ] ( to bound @xmath375 ) and [ lemma : probsol ] ( to bound @xmath376 for @xmath377 ) @xmath378\\right\\}^{m_t}\\ , , \\ ] ] by eventually enlarging the constant @xmath288 ( in a way that depends on @xmath30 ) , we can get rid of the term @xmath379 . by further using @xmath380",
    "we can upper bound the above by @xmath381 where @xmath382 with @xmath383 .",
    "notice that @xmath384 can be made arbitrarily large by taking @xmath179 large enough .",
    "in particular , we can choose @xmath385 such that @xmath386 for any @xmath387 .",
    "for such @xmath179 , and using the fact that @xmath388(1+\\delta)$ ] @xmath389\\ , .",
    "\\ ] ] summing the various contributions , we obtain , for any @xmath390 @xmath391 which proves the thesis .",
    "first consider eq .",
    "( [ eq : digitentropy1 ] ) .",
    "let @xmath392 be an integer random variable with distribution @xmath72 , @xmath393 its @xmath88-th least significant @xmath30-ary digit and @xmath394 the indicator function on @xmath395 .",
    "from @xmath396 it follows that , for @xmath397 : @xmath398 choosing @xmath30 large enough so that @xmath399 for all @xmath194 , we can upper bound @xmath400 by @xmath401 , thus getting @xmath402 which implies eq .",
    "( [ eq : digitentropy1 ] ) for @xmath403 . )    in order to prove eq .",
    "( [ eq : digitentropy2 ] ) , first notice that @xmath404 whence @xmath405 . by the same argument @xmath406",
    ". the thesis follows by bounding @xmath407 using eq .",
    "( [ eq : digitentropy1 ] ) .",
    "the number of vectors with type @xmath408 is upper bounded by @xmath409 . since there are at most @xmath410 distinct types , @xmath411 where @xmath412 the bound @xmath413 and @xmath414 @xcite",
    ".    equation ( [ eq : sanov ] ) is just sanov theorem .",
    "yi lu is supported by the cisco stanford graduate fellowship .",
    "99 s.  dharmapurikar , a.  kabbani , y.  lu , a.  montanari and b.  prabhakar .",
    "`` passing messages through counter braids : a novel approach to traffic measurement . ''",
    "technical report , tr06-isl012201 , march , 2007 .",
    "c.  estan and g.  varghese .",
    "`` new directions in traffic measurement and accounting : focusing on the elephants , ignoring the mice . ''",
    "_ acm trans . on comp .",
    "_ , 21:270313 , 2003 .",
    "t.  cover and j.  a.  thomas , _ elements of information theory _ , wiley interscience , new york , 1991 robert  g. gallager . _ low - density parity - check codes_. mit press , cambridge , massachussetts , 1963 .",
    "t.  richardson and r.  urbanke , _ modern coding theory _",
    ", draft available at http://lthcwww.epfl.ch/mct/index.php g.  caire , s.  shamai , and s.  verd .",
    "`` noiseless data compression with low density parity check codes . '' in p.  gupta and g.  kramer , editors , _ dimacs series in mathematics and theoretical computer science _ , pages 224235 .",
    "ams , 2004 .",
    "e.  berlekamp , r.  j. mceliecee , and h.  c.a .",
    "van tilborg .",
    "`` on the inherent intractability of certain coding problems . '' _",
    "ieee  trans .  inform .  theory _ , it-29:384386 , 1978 . f.  r.  kschischang , b.  j.  frey and h - a .",
    "loeliger , `` factor graphs and the sum - product algorithm '' ( 2001 ) , _ ieee  trans .",
    "theory _ * 47 * , 498 - 519 .",
    "s.  aji , h.  jin , a.  khandekar , d.  j.c .",
    "mackay , and r.  j.  mceliece .",
    "`` bsc thresholds for code ensembles based on ` typical pairs ' decoding . '' in brian marcus and joachim rosenthal , editors , _ codes , systems and graphical models _ , pages 195210 .",
    "springer , 2001 ."
  ],
  "abstract_text": [
    "<S> measuring network flow sizes is important for tasks like accounting / billing , network forensics and security . </S>",
    "<S> per - flow accounting is considered hard because it requires that many counters be updated at a very high speed ; however , the large fast memories needed for storing the counters are prohibitively expensive . </S>",
    "<S> therefore , current approaches aim to obtain approximate flow counts ; that is , to detect large _ elephant _ flows and then measure their sizes .    </S>",
    "<S> recently the authors and their collaborators have developed @xcite a novel method for per - flow traffic measurement that is fast , highly memory efficient and accurate . at the core of this method </S>",
    "<S> is a novel counter architecture called `` counter braids . '' in this paper , we analyze the performance of the counter braid architecture under a maximum likelihood ( ml ) flow size estimation algorithm and show that it is optimal ; that is , the number of bits needed to store the size of a flow matches the entropy lower bound . </S>",
    "<S> while the ml algorithm is optimal , it is too complex to implement . in @xcite </S>",
    "<S> we have developed an easy - to - implement and efficient message passing algorithm for estimating flow sizes . </S>"
  ]
}