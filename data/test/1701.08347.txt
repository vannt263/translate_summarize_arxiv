{
  "article_text": [
    "recent progress of storage media has been creating interests on coding techniques to ensure reliability of the media and to lengthen the life of storage media .",
    "write - once - memory ( wom ) codes are getting renewed interests as one of promising coding techniques for storage media . in the scenario of the binary wom codes , the binary wom storage ( or channel ) is assumed as follows .",
    "a storage cell has two states 0 or 1 and the initial state is 0 .",
    "if a cell changes its state to 1 , then it can not be reset to 0 any more .",
    "punch cards and optical disks are examples of the binary wom storages .",
    "the celebrated work by rivest and shamir in 1982 @xcite presented the first binary wom codes and their codes induced subsequent active researches in the field of the binary wom codes @xcite @xcite @xcite .",
    "a memory cell in recent flash memories has multiple levels such as 4 or 8 levels and the number of levels are expected to be increased further in the near future .",
    "this trend has produced motivation to the research activities on the non - binary wom codes that are closely related to the multilevel flash memories @xcite @xcite @xcite @xcite .",
    "there are two threads of researches on the non - binary wom codes .",
    "the first one is _ variable rate codes _ and the other is _ fixed rate codes_.    the variable rate codes are the non - binary wom codes such that message alphabets used in a sequence of writing processes are not necessarily identical .",
    "this means that writing rate can vary at each writing attempt .",
    "fu and vinck @xcite proved the channel capacity of the variable rate non - binary wom codes .",
    "recently , shpilka @xcite proposed a capacity achieving construction of non binary wom codes .",
    "moreover , gabrys et al .",
    "@xcite presented a construction of the non - binary wom codes based on known efficient binary - wom codes .    although the variable rate codes are efficient because they can fully utilize the potential of a wom storage , fixed - rate codes that have a fixed message alphabet is more suitable for practical implementation into storage devices",
    "this is because a fixed amount of binary information is commonly sent from the master system to the storage .",
    "kurkoski @xcite proposed a construction of fixed rate wom codes using two dimensional lattices .",
    "bhatia et al .",
    "@xcite showed a construction of non - binary wom codes that relies on the lattice continuous approximation .",
    "cassuto and yaakobi @xcite proposed a construction of fixed rate non - binary wom codes using lattice tiling .    recently , fixed rate wom code for reducing inter - cell interference ( ici ) is proposed by hemo and cassuto @xcite .",
    "it is known that ici causes drift of the threshold voltage of a flash cell according to the voltages of adjacent flash cells @xcite .",
    "the drift of threshold voltage degrades the reliability of the flash cell and it should be avoided .",
    "one promising approach to reduce ici is to use an appropriate constraint coding to avoid certain patterns incurring large ici .",
    "the wom codes presented in @xcite not only have large @xmath1 but also satisfy certain ici reducing constraints .    in the case of fixed rate codes , systematic constructions for efficient non - binary wom codes are still open to be studied .",
    "especially , perusing optimal codes with practical parameters is an important subject for further studies .",
    "furthermore , it is desirable to develop a construction of fixed rate wom codes that have wide range of applicability ; this means that a new construction should be applicable to wide classes of wom devises such as wom devices with ici constraint as well .    in this paper , we propose a novel construction of fixed rate non - binary wom codes .",
    "the target of storage media is modeled by a memory device with restricted state transitions , i.e. , a state of the memory can change to another state according to a given state transition graph .",
    "the model is fairly general and it includes a common model of multilevel flash memories .",
    "the proposed construction has two notable features .",
    "first , it possesses a systematic method to determine the sets called the encoding regions that are required for encoding processes .",
    "this is a critical difference between ours and the prior work using lattice tiling @xcite and @xcite .",
    "second , the proposed construction determines an encode table used for encoding by integer programming .",
    "in this section , we first introduce several basic definitions and notation used throughout the paper .",
    "let @xmath4 be a directed graph where @xmath5 is the set of vertices and @xmath6 is the set of edges .",
    "if there does not exist a directed edge or a path from a vertex to itself , then the graph @xmath7 is said to be a directed acyclic graph , abbreviated as dag .",
    "a dag is used as a _ state transition graph _ in this paper . the left figure in fig .",
    "[ fig : dm ] is an example of dag .",
    "we express the dag as @xmath8 .",
    "the symbol @xmath9 represents the root of dag .",
    "if for any node @xmath10 there exists the directed edge or path from @xmath11 to @xmath12 , we denote @xmath13 . in this case",
    ", we say that @xmath12 is _ reachable _ from @xmath11 .",
    "assume that dag @xmath14 .",
    "a wom device @xmath15 associated with the graph @xmath7 can store any @xmath16 as its state .",
    "the initial state of @xmath15 is assumed to be @xmath9 .",
    "we can change the state of @xmath15 from @xmath17 to @xmath18 , if there exists a directed edge or a path from @xmath17 to @xmath18 .",
    "the message alphabet to be written in @xmath15 is denoted by @xmath19 . in our scenario",
    ", we want to write several messages in @xmath20 into @xmath15 .",
    "namely , a sequence of messages is sequentially written in @xmath15 .",
    "when we write a message @xmath21 , we must change the state of @xmath15 .",
    "after that , we get a written message @xmath22 in @xmath15 by reading the state of @xmath15 .      in this paper , we assume that an encoder has a unit memory to keep a previous input message , and that a corresponding decoder has no memory .    in order to write input messages into the wom device @xmath15",
    ", we need an encoding function .",
    "the definition of the encoding function is given as follows .",
    "[ defi : enco ] assume that a function @xmath23 is given .",
    "the symbol fail represents a failure of an encoding process .",
    "if for any @xmath17 and @xmath21 , @xmath24 or @xmath25 then the function @xmath26 is called an _ encoding function_.    the following definition on the decoding function is used to retrieve the message @xmath21 from @xmath15 .",
    "[ defi : deco ] assume that a function @xmath27 is given .",
    "if for any @xmath21 and @xmath17 , the consistency condition @xmath28 is satisfied , then the function @xmath29 is called a _ decoding function_.    assume that a sequence of input messages @xmath30 are sequentially encoded .",
    "we also assume that the initial node is @xmath31 .",
    "the encoder encodes the incoming message @xmath32 by @xmath33 for @xmath34 .",
    "the output of the encoder , @xmath35 , is then written into @xmath15 as the next node , i.e. , next state .",
    "the following definition gives the worst number of consecutive writes to @xmath15 for a pair of encoding and decoding functions @xmath36 .",
    "assume that a sequence of messages of length @xmath37 , @xmath38 , is given .",
    "let @xmath39 be the state sequence defined by @xmath40 under the assumption @xmath41 .",
    "if for any @xmath42 $ ] , @xmath43 , then the pair @xmath36 is said to be @xmath37 writes achievable .",
    "worst number of writes _",
    "@xmath1 is defined by @xmath44    in other words , the pair @xmath36 ensures consecutive @xmath1 writes of fixed size messages in the worst case . of course",
    ", in terms of efficient use of the device @xmath15 , we should design @xmath36 to maximize @xmath1 .",
    "in this section , we prepare basic definitions required for precise description of our encoding algorithm used in the encoding function .      the _ reachable region _ @xmath45 is the set of the all nodes to which a node can change from @xmath11 .",
    "the precise definition is given as follows .",
    "[ defi : reachable ] the reachable region @xmath45 is defined as @xmath46    encoding regions and a message function defined below play a critical role in an encoding process .",
    "[ defi : patition ] assume that a family of subsets in @xmath47 , @xmath48    is given .",
    "let @xmath49 be a positive integer satisfying @xmath50 . if the family satisfies the following two conditions :    1 .",
    "@xmath51 2 .",
    "@xmath52 or @xmath53 ,    then the family @xmath54 is said to be the _",
    "encoding regions_.    a message function defined below is used to retrieve a message .",
    "[ defi : g ] assume that a family of encoding regions @xmath55 is given .",
    "let @xmath56 be a function : @xmath57 if for any @xmath21 and for any @xmath58 , there exists @xmath59 satisfying @xmath60 then the function @xmath56 is called a _ message function _ corresponding to the family of encoding regions @xmath54 .",
    "we can consider the message function as the labels attached to the nodes . in following encoding and decoding processes , the label , i.e. , the value of the message function corresponds to the message associated with the node .",
    "this definition implies that we can find arbitrary message @xmath21 in arbitrary encoding region @xmath61 @xmath62 .",
    "an example of encoding regions and a message function is shown in the right - hand of fig .",
    "[ fig : dm ] .",
    "we use the above definitions of the encoding regions and the message function to encode given messages . in order to write a sequence of messages",
    ", we must connect several nonempty encoding regions to make _",
    "layers_. we here define frontiers and layers as follows .",
    "[ defi : ft ] for a subset of nodes @xmath63 , the _ frontier _ of @xmath64 , @xmath65 , is defined by @xmath66    if @xmath67 is hold for @xmath68 , then there exists @xmath69 which is reachable from @xmath70 , i.e. , @xmath71 .",
    "a layer consists of a union set of encoding regions .",
    "[ defi : bset ] assume that a family of encoding regions @xmath54 is given .",
    "the _ layer _",
    "@xmath72 is recursively defined by @xmath73 @xmath9 represents the root of dag .",
    "assume that for integer @xmath74 , @xmath75 is given .",
    "the _ start point set _ @xmath76 is defined by @xmath77    figure [ fig : fe ] shows an example of frontiers and layers .      in this subsection , we explain the encoding algorithm to realize an encoding function . the algorithm presented here is similar to the algorithm presented in the reference @xcite .",
    "the encoding algorithm is shown in algorithm [ alg1 ] .",
    "input : @xmath17 ( current state ) input : @xmath21 ( message ) output : @xmath78 ( next state , or @xmath79 ) @xmath80 $ ] @xmath81 @xmath82 @xmath83 $ ] go to line 5 output @xmath12 and quit .",
    "suppose that we have the two inputs , a state @xmath11 which represents the current node in the state transition graph , and a message @xmath22 .",
    "the main job of this encoding algorithm is to find @xmath84 satisfying @xmath85 for a given message @xmath22 .",
    "the encoding region @xmath86 can be considered as the current _ encoding window _ in which the candidate of the next state is found .",
    "the variable @xmath87 is called a _",
    "start point _ of the encoding window .",
    "if such @xmath88 can be written in @xmath15 or is reachable from @xmath11 ( i.e. , @xmath89 ) , then the next state is set to @xmath90 in line 10 of algorithm [ alg1 ] .",
    "otherwise , the current encoding window should move to another encoding region in the next layer ( line 13 ) .",
    "the new start point @xmath91 is chosen in the frontier @xmath92 and @xmath87 is updated as @xmath93 .",
    "( @xmath86 is the current encoding window ) , there exists @xmath94 satisfying @xmath95 . ] the layer index @xmath96 is the minimum index satisfying @xmath97 .",
    "the decoding function associated with the encoding function @xmath26 realized by algorithm [ alg1 ] is given by @xmath98 from the definition of the message function and the procedure of algorithm [ alg1 ] , it is evident that this function satisfies the consistency conditions .",
    "we here explain an example of an encoding process by using the state transition graph presented in fig .",
    "[ fig : fe ] .",
    "assume that an input message sequence @xmath99 is given .",
    "in the beginning of an encoding process , the current state is initialized as @xmath100 .",
    "since the initial message is @xmath101 , the pair @xmath102 is firstly given to algorithm [ alg1 ] .    in this case , we have @xmath103 in line 4 .",
    "since @xmath104 is satisfied in @xmath105 in line 8 , the candidate of the next state @xmath106 is obtained .",
    "because @xmath107 holds , we obtain @xmath108 in line 10 .",
    "the encoding process outputs @xmath109 and then quits the process .",
    "let us consider the second encoding process for @xmath110 .",
    "we start a new encoding process with inputs @xmath111 . from line 4",
    ", we have @xmath112 .",
    "this means that we set the encoding window to @xmath105 . in this case",
    ", the encoder finds @xmath113 and lets @xmath114",
    ". however , the condition @xmath115 is not satisfied , i.e. , @xmath114 can not be the next state because the node can not change from @xmath116 to @xmath117 . in order to find the next state , we need to change the encoding window . from line 13 , the new start point of the encoding window @xmath118 is chosen from the frontier as @xmath119 = 3 $ ] .",
    "this operation means that we change the encoding window from @xmath105 to @xmath120 . from the new encoding window @xmath120 ,",
    "we can find @xmath121 satisfying @xmath122 . because @xmath123 holds ( i.e. , @xmath124 is reachable from @xmath125 )",
    ", we finally have the next state @xmath126 .",
    "the performance and efficiency of the wom codes realized by the encoding and decoding functions described in the previous section depend on the choice of the encoding regions . in this section ,",
    "we propose a method to create a family of the encoding regions and a method to determine labels of nodes , i.e , the message function by using integer programming .      in this subsection , we propose a method for creating a family of the encoding regions based on a greedy rule .",
    "the proposed wom codes described later exploit a family of the encoding regions defined based on the following sets .",
    "[ defi : omega ] assume that an integer @xmath127 is given .",
    "let us denote the elements in the reachable region @xmath128 by @xmath129 where the index of @xmath130 satisfies @xmath131 the set @xmath132 is defined by @xmath133    in the above definition , a tie break rule is not explicitly stated .",
    "if @xmath134 holds , we will randomly choose @xmath135 or @xmath136 to break a tie .",
    "figure [ fig : pro - en ] shows an example of a greedy process for generating an encoding region .",
    "the underlying idea in the greedy process is simply to enlarge future writing possibilities .",
    "the set @xmath132 is determined by a greedy manner in terms of the size of reachable regions . in other words , we want to postpone a state transition to a state with the smaller reachable region as late as possible .",
    "this is because such a transition would lead to a smaller number of writes .    in the following part of this paper",
    ", we will use the encoding regions defined by @xmath137      in the previous subsection , we saw how to determine the family of the encoding regions .",
    "the remaining task is to find appropriate message labels of nodes .",
    "namely , we must find an appropriate message function satisfying the required constraint described in definition [ defi : g ] . in this subsection",
    ", we will propose a method to find a message function based on integer programming .",
    "the solution of the following integer linear programming problem provides a message function .",
    "[ defi : ip ] assume that a family of the encoding regions @xmath138 is given .",
    "let @xmath139)$ ] be a set of value assignments of an optimal solution of the following integer problem : @xmath140 } y_\\ell \\\\ \\nonumber & & { \\rm subject\\ to }   \\\\ & & \\forall   i \\in v^ * ,    \\forall   \\ell \\in",
    "[ 1,k],\\quad   \\sum_{j \\in \\omega(i ) } x_{j,\\ell } \\ge y_{\\ell } ,   \\\\   \\label{eq : xy } & & \\forall j \\in \\gamma,\\quad \\sum_{\\ell \\in   [ 1,k ] } x_{j,\\ell } = 1,\\\\ & & \\forall j \\in \\gamma , \\forall   \\ell \\in [ 1,k ] ,   \\quad   x_{j,\\ell } \\le y_{\\ell } , \\\\ & & \\forall j \\in \\gamma , \\forall   \\ell \\in [ 1,k],\\quad x_{j,\\ell } , y_{\\ell } \\in \\{0,1 \\ } , \\end{aligned}\\ ] ] where @xmath141 . the maximum value of the objective function is denoted by @xmath142 .    the symbol @xmath143 represents @xmath144 }   \\mathbb{i } [ x^*_{j , \\ell } = 1],\\ ] ] where the indicator function @xmath145 $ ] takes the value one if @xmath146 is true ; otherwise it takes the value zero .",
    "if we regard @xmath147 as a color put on the node @xmath148 , the above ip problem can be considered as an ip problem for a coloring problem . in our case , the coloring constraint is as follows : for every node @xmath11 ( i.e. , state ) in @xmath76 , the neighbor of @xmath11 including itself contains @xmath142-colors .",
    "this problem has close relationship to the _ domatic partition problem_.    in the following arguments , we set the maximize number of message @xmath0 equal to @xmath142 .",
    "assume that a function @xmath149 is defined by @xmath150 where the mapping @xmath151 is an arbitrary bijection .",
    "the set @xmath152 is defined as @xmath153 \\mid y_\\ell^ * = 1   \\}.\\ ] ]    the following theorem means that the determination of the message function can be done by solving the above integer programming problem .",
    "the function @xmath7 is a message function .",
    "we assume that arbitrary @xmath21 and @xmath154 are given .",
    "first , we consider @xmath155 . from the definition of the set @xmath152 , we have @xmath156 .",
    "the optimal solution satisfies @xmath157 . because @xmath158 , there exists @xmath159 satisfying @xmath160 . by the definition of the function @xmath7 , the equation @xmath161 holds .",
    "this satisfies the condition for the message function .    in the following , we use this message function @xmath7 in the encoding function ( algorithm 1 ) and the decoding function .",
    "the worst number of writes @xmath1 provided by the encoding algorithm with the encoding regions and the message function defined above is given by @xmath162 this statement appears clear from the definition of the encoding algorithm .",
    "figure [ fig : wn ] presents an example for @xmath163 .",
    "in this section , we will construct several classes of fixed rate wom codes based on the proposed construction .",
    "we used the ip solver ibm cplex for solving the integer programming problem .",
    "multilevel flash memories consist of a large number of cells .",
    "each of cell can store electrons in itself .",
    "it is assumed that the level of a cell can be increased but can not be decreased . in this paper , we assume that @xmath164 cells that can keep @xmath2 level values from the alphabet @xmath165 .",
    "the state transitions of @xmath2 level multilevel flash memories of @xmath164 cells can be represented by a state transition graph ( directed square grid graph ) presented in fig .",
    "[ fig : flash ] .",
    "figure [ fig : flash ] presents the state transition graph for multilevel flash memory @xmath166 and the encoding regions constructed by the proposed method . in this case",
    ", we can always write 5 messages for each write operation and the worst number of writes is @xmath163 in this case .",
    ".worst numbers of writes @xmath1 of proposed wom codes for @xmath2 level flash memories with @xmath167 cells . [ cols=\"^,^,^,^,^,^\",options=\"header \" , ]",
    "in this paper , we proposed a construction of fixed rate non - binary wom codes based on integer programming . the novel wom codes with",
    "@xmath168 achieve the worst numbers of writes @xmath1 that meet the known upper bound in the range @xmath169 $ ] .",
    "we discovered several new efficient wom codes for @xmath2 level flash memories when @xmath170 .",
    "for instance , our @xmath171 wom code provides a larger worst number of writes than that of the known code with the parameters @xmath172 @xcite .",
    "in addition , we constructed several wom codes with @xmath87 imbalance constraint for reducing ici .",
    "our wom codes with @xmath173 achieve the worst numbers of writes @xmath1 that meet the known upper bound in the range @xmath169 $ ] .",
    "this implies the efficiency of the wom codes constructed by our construction .",
    "another notable advantage of the proposed construction is its flexibility for handling high dimensional cases .",
    "it is easy to construct for the codes with modestly large @xmath164 when the integer programming problem can be solved with reasonable time .",
    "the proposed construction can be applied to various storage devices , to various dimensions ( i.e , number of cells ) , and various kind of additional constraints .",
    "this work was supported by jsps grant - in - aid for scientific research grant number 16k14267 .    99 r.l.rivest and a.shamir , `` how to reuse a ` write - once ' memory , '' information and control , vol .",
    "13 , pp . 119 , 1982 .",
    "g.d.cohen , p.godlewski , and f.merkx , `` linear binary code for write - once memories , '' ieee trans .",
    "theory , vol.32 , no.5 , pp.697700 , september 1986 .",
    "a.fiat and a.shamir , `` generalized write - once memories , '' ieee trans .",
    "theory , vol .",
    "470480 , september 1984 .",
    "e.yaakobi , s.kayser , p.h.siegel , a.vardy , and j.k.wolf , `` efficient two - write wom - codes , '' ieee inf .",
    "theory workshop , ireland , aug .",
    "r.gabrys , e.yaakobi , l.dolecek , p.h.siegel , a.vardy , and j.k.wolf , `` non - binary wom - codes for multilevel flash memories , '' in ieee inf .",
    "theory workshop , paraty , brazil , pp . 4044 ,",
    "oct . 1620 , 2011 .",
    "e.yaakobi and a.shpilka , `` high sum - rate three - write and nonbinary wom codes , '' ieee trans .",
    "theory , vol .",
    "11 , pp . 70067015 , nov .",
    "y.cassuto and e.yaakobi , `` short q - ary fixed - rate wom codes for guaranteed rewrites and with hot / cold write differentiation , '' ieee trans .",
    "theory , vol .",
    "7 pp . 39423958 , jul .",
    "f.fu and a.h.vinck , `` on the capacity of generalized write once memory with state transitions described by an arbitrary directed acyclic graph , '' ieee trans .",
    "theory , vol .",
    "1 , pp . 308313 , jan .",
    "a. shpilka , `` capacity achieving multiwrite wom codes , '' ieee trans .",
    "theory , vol .",
    "60 , no . 3 pp . 14811487 , mar .",
    "a.bhatia , m.qin , a.r.iyengar , b.m.kurkoski , p.h.siegel , `` lattice - based wom codes for multilevel flash memories , '' ieee journal on selected areas in communications , vol .",
    "5 , may 2014 .",
    "b. m. kurkoski `` rewriting codes for flash memories based upon lattices and an example using the e8 lattice , '' in proceedings ieee global telecommunications conference ( miami usa ) , pp .",
    "1923 - 1927 , ieee december 2010 .",
    "e.hemo and y.cassuto , `` d - imbalance wom codes for reduced inter - cell - interference in multi - level nvms , '' ieee international symposium on information theory , barcelona , 2016 ."
  ],
  "abstract_text": [
    "<S> in this paper , we propose a construction of non - binary wom ( write - once - memory ) codes for wom storages such as flash memories . </S>",
    "<S> the wom codes discussed in this paper are fixed rate wom codes where messages in a fixed alphabet of size @xmath0 can be sequentially written in the wom storage at least @xmath1-times . in this paper , a wom storage is modeled by a state transition graph . </S>",
    "<S> the proposed construction has the following two features . </S>",
    "<S> first , it includes a systematic method to determine the encoding regions in the state transition graph . </S>",
    "<S> second , the proposed construction includes a labeling method for states by using integer programming . </S>",
    "<S> several novel wom codes for @xmath2 level flash memories with 2 cells are constructed by the proposed construction . </S>",
    "<S> they achieve the worst numbers of writes @xmath1 that meet the known upper bound in the range @xmath3 . </S>",
    "<S> in addition , we constructed fixed rate non - binary wom codes with the capability to reduce ici ( inter cell interference ) of flash cells . </S>",
    "<S> one of the advantages of the proposed construction is its flexibility . </S>",
    "<S> it can be applied to various storage devices , to various dimensions ( i.e , number of cells ) , and various kind of additional constraints . </S>"
  ]
}