{
  "article_text": [
    "* for an integer @xmath0 we will use @xmath1 to denote an integer less than or equal to @xmath0 , and @xmath2 an integer at least as large as @xmath0 .",
    "* we use the @xmath3 operator to refer to the bitwise binary xor operation .",
    "for example , @xmath4 . * other notation common to combinatorial game theory is mentioned below .",
    "two - player games with alternating turns , perfect information , and no random elements are known as _",
    "combinatorial games_. combinatorial game theory concerns determining which of the players has a winning move from any _ position _ ( game state ) .",
    "some important considerations here follow .    *",
    "this paper only considers games under _ normal play _ conditions , meaning that the last player to make a move wins .",
    "( if a player ca nt make a legal move on their turn , they lose . )",
    "* the sum of two game positions is also a game where a legal move consists of moving on one of the two position summands .",
    "the value of a game sum is simply the sum of the values of the summands . *",
    "many of the sections require the reader to be moderately comfortable with number values , nimbers ( or grundy values ) , and outcome classes ( specifically , @xmath5 and @xmath6 ) .",
    "* understanding of the game - set notation ( e.g. @xmath7 ) is necessary for understanding lemma [ lem : numbersplusstar ] .",
    "the authors recommend @xcite and @xcite for background texts on combinatorial game theory .",
    "algorithmic combinatorial game theory concerns the computational difficulty in determining the winnability , outcome class , or value of game positions .",
    "given a position , how long does it take for an algorithm to determine whether the next player has a winning strategy ? for many rulesets , this can be solved in time polynomial in the size of the representation of the position .",
    "these `` easy '' rulesets usually allow some sort of closed formula to determine the winner .    for others ,",
    "the problem is known to be intractable .",
    "for example , solving is known to be -complete@xcite , meaning that unless an efficient algorithm is found to solve all other problems in , no polynomial - time algorithm can determine the winnability of all positions . for these `` hard '' games ,",
    "usually the majority of the induced game tree must be inspected in order to determine the winner .    in algorithmic combinatorial game theory ,",
    "a ruleset is considered _ solved _ if either the polynomial time `` trick '' is known , or if it has been shown to be intractable .",
    "many rulesets remain unsolved : it is unknown whether they can be evaluated efficiently or not .    in this paper , we discuss known algorithmic results about each ruleset .",
    "data structures are logical structures used to store digital data in computing systems .",
    "different structures facilitate different operations .",
    "for example , a max - heap can quickly add and remove elements , but is restricted to removing only the greatest element .",
    "a data structures course in computer science is a common course in the basic programming sequence in many undergraduate curricula .",
    "the topics cover many logical structures to store digital data .",
    "this paper covers games based on : arrays , sets , stacks , queues , priority queues , linked lists , and binary trees .",
    "we define each of these in the following sections .",
    "the following 7 sections are each devoted to a ruleset based on a particular data structure .",
    "we provide table [ table : organization ] as a handy key to corresponding data structures , ruleset names , and section numbers .",
    ".corresponding data structures , rulesets , and sections . [ cols=\"<,<,<\",options=\"header \" , ]",
    "an array is a linear data structure addressable by the natural numbers .",
    "each array element is stored in a cell so that the first @xmath8 elements have respective addresses @xmath9 .",
    "is a simple combinatorial game that has been well - studied@xcite .",
    "[ def : nim ] is an impartial combinatorial game where each position is represented by a list of natural numbers : @xmath10 , @xmath11 .",
    "the position represented by @xmath12 is an option of @xmath13 if @xmath14    * @xmath15 , and * @xmath16    the grundy value of any position can be found in linear time : @xmath17 .",
    "there is a winning move from position @xmath13 exactly when the grundy value , @xmath18 , is not zero.@xcite",
    "a set is a data structure where there is no implicit order on the elements , and copies of elements are not recorded , ( each element appears at most once ) .      instead of keeping a list ( or bag ) of heaps as in",
    ", we employ a set . in the resulting",
    ", each turn consists of choosing a heap from the set , removing some number of sticks from that heap , then replacing the original heap with the new heap .",
    "( if the resulting heap has no sticks , we do nt bother to add it back . )",
    "the catch here is that each heap is simply a natural number , so if there is already a heap of that size in the set , the new heap is forgotten about ; that player might as well have taken all the sticks in that heap .",
    "we provide a formal description in definition [ def : antonim ] .",
    "[ def : antonim ] is an impartial combinatorial game where each position is represented by @xmath19 .",
    "the position represented by @xmath20 is an option of @xmath21 if :    * @xmath22 such that @xmath23 , or * @xmath24 such that @xmath25 and @xmath26    finding the outcome class for has already been solved for positions with up to three piles @xcite .",
    "these rules are as follows :    * @xmath27 is a terminal position ; so the position is in @xmath28 .",
    "* one pile : @xmath29 , as there is always a winning move ( by taking all sticks ) .",
    "* two piles : @xmath30 * three piles : @xmath31    this last case can be proven inductively or by a reduction to standard nim .",
    "a winning move is to add one stone to each heap , make an appropriate move in nim , then remove a stone from each heap .",
    "the appropriate nim move will not eliminate any heap entirely since that would require two equal - sized heaps to be present , which is not possible in antonim .",
    "play continues until the game is down to two heaps .",
    "there is currently no known polynomial time algorithm for determine the outcome class for an antonim position containing four or more heaps , and computer analysis has not yet shed light on a possible method .",
    "a stack is a data structure where elements are added and removed .",
    "each remove operation pulls out the most recently - added element .",
    "we can represent this with a list where items are added and removed from the same end , called the top . the remove operation ( called _ pop _ ) then always fetches the most recently added ( _ pushed _ ) element .",
    "consider the following stack ( the top is on the right - hand side ) : @xmath32 .",
    "if we pop an element off the stack , @xmath33 will remain .",
    "if we then push @xmath34 followed by @xmath35 , followed by another , pop , the resulting stack will be @xmath36 .",
    "is another spin - off of .",
    "the difference here is that the heaps are arranged linearly .",
    "a move consists of removing sticks from the top ( or front ) heap .",
    "if all sticks in one heap are removed , then that heap is removed from the stack .",
    "is similar to @xcite but with the added restriction that only one end is accessible .",
    "we formalize this in definition [ def : towernim ] .",
    "[ def : towernim ] is an impartial ruleset where positions are described by a list of non - zero natural numbers : @xmath37 .",
    "the position represented by @xmath38 is an option of @xmath39 if either    * @xmath40 , or * @xmath41 such that @xmath42 and @xmath43 .    after a handful of games ,",
    "it becomes clear that the winnability of the game is often determined by whether the top heap has 1 stick .",
    "[ obs : stackallones ] for games with a stack of all ones , @xmath44 , the nimber is the xor - sum of all heaps .",
    "[ lem : towernimbigtop ] when only the top is non - one , the position is always in @xmath45 .",
    "let @xmath46 represent a position , @xmath47 , of , where @xmath48 .",
    "there are two cases , based on the length of the list .    *",
    "if the position has an even number of heaps , then the next player can take @xmath49 sticks , reducing the game to a zero position . *",
    "if the position has an odd number of heaps , then the next player can take all @xmath0 sticks in the top heap , reducing the number of sticks to an even amount , a zero position .",
    "since the current player always has a winning move , @xmath47 must be in @xmath45 .",
    "[ corol : toweronesontop ] let @xmath50 represent a position , @xmath47 , of , where @xmath48 and @xmath8 is the number of 1-heaps above @xmath0 .",
    "then the nimber of @xmath47 is the parity of @xmath8 .",
    "after @xmath8 turns , the current position must be represented by @xmath51 , which is in @xmath45 .",
    "let @xmath52 represent a position , @xmath47 , of .",
    "there are two cases for the nimber of @xmath47 :    * then either @xmath53 or @xmath54 .",
    "* then @xmath55 .    the first case is taken care of for us , using the previous corollary .",
    "the second case can be proven by strong induction on @xmath0 . in the base case",
    ", @xmath47 has both @xmath56 and @xmath57 and options , by the previous corollary , and must equal @xmath58 . for the inductive case , when @xmath59 , it has all the children that @xmath60 has @xmath61 , as well as @xmath62 , but does not include @xmath63 .",
    "thus , by the mex rule , @xmath64 .",
    "let @xmath65 , where @xmath66 , represent a position , @xmath47 , of .",
    "there are two cases for the nimber of @xmath47 :    * then @xmath67 . * then @xmath68 .",
    "the first case occurs because the only option is a non - zero position as described in the previous lemma .",
    "the second case occurs because the first case is an option .    with these results",
    ", we can determine the outcome class of any position by counting the number of consecutive size-1 heaps on top of the stack and whether there is a bigger heap underneath the consecutive 1-heaps .",
    "the outcome class of any position can be determined in .",
    "consider a position @xmath69 . then :    * if @xmath70 then , by observation [ obs : stackallones ] @xmath71 * otherwise , let @xmath72 be the non - one heap closest to the top .",
    "now , by corollary [ corol : toweronesontop ] @xmath73",
    "queues are another data structure very similar to stacks .",
    "the only difference is that the remove operation extracts the least - recently added element .",
    "we can represent this as a list : queues push elements to the _ back _ of the list and pop from the _ front _ , the opposite end .",
    "consider the following queue ( the front is the left - hand side , the back is on the right ) : @xmath32 .",
    "if we pop an element from the queue , @xmath74 will remain .",
    "if we then push @xmath34 followed by @xmath35 , followed by another , pop , the resulting queue will be @xmath75 .",
    "is the queue - counterpart to . in this game",
    ", the next player removes sticks from the heap in the front of the queue .",
    "then , if there are any sticks left in that heap , it s queued back in to the back of the line .",
    "we formalize this in definition [ def : rotisserienim ] .",
    "this is equivalent to , which is itself a special case of played on a directed cycle@xcite .",
    "[ def : rotisserienim ] is an impartial ruleset where positions are described by a list of non - zero natural numbers : @xmath76 .",
    "the position represented by @xmath38 is an option of @xmath39 if either    * @xmath77 , or * @xmath41 such that @xmath78 and @xmath79 .",
    "we begin by characterizing two heap games .",
    "[ thm : adjtwoheaps ] if @xmath80 , then @xmath81 iff @xmath82 .",
    "first , assume @xmath82 .",
    "the next player can move to the position @xmath83 , and continue to match the other player s moves until reaching the terminal position .",
    "next , assume that @xmath84 .",
    "the only move from @xmath39 is to a position of the form @xmath85 . since @xmath86 , this is an @xmath45-position by the above argument , and therefore @xmath87 .",
    "the following theorem , proven in @xcite , completely characterizes the classes @xmath28 and @xmath45 where each heap has size at least two .",
    "[ thm : adjnim ] let @xmath88 be a position in , and let @xmath89 . then @xmath81 iff @xmath8 is odd or the smallest index @xmath90 for which @xmath91 is even .",
    "we extend this to some small positions with heaps of size one .",
    "[ thm : adjthreeheaps1 ] if @xmath92 then @xmath87 if @xmath93 .",
    "assume @xmath93 and @xmath92 .",
    "the only valid move is to @xmath94 which is in @xmath45 by theorem [ thm : adjtwoheaps ] .    in order to complete the characterization of all three heap positions in we",
    "must first prove the following lemma .",
    "[ lem : adjstrategy ] let @xmath95 is a position in .",
    "if @xmath96 then :    * if @xmath97 is odd and @xmath81 then @xmath98 , and * if @xmath97 is even and @xmath81 then @xmath99 .",
    "if @xmath39 has an even number of heaps , then the same player who encounters heap @xmath100 will also encounter what remains of this heap on a subsequent turn .",
    "therefore , if removing the entire heap does not move the game into a @xmath28-position then there is no advantage to removing more than a single stick .",
    "similarly , with an odd number of heaps there is no advantage to leaving more than a single stick for the other player to encounter on a subsequent turn .",
    "lemma [ lem : adjstrategy ] provides an interesting strategy , which leads to a win of if @xmath81 . using this strategy we prove another lemma necessary to complete our characterization of three heap games .",
    "[ lem : adjcompare ] if @xmath101 then so is @xmath102 .",
    "assume to the contrary that @xmath87 and @xmath103 .",
    "therefore there is a move from @xmath38 to a @xmath28-position @xmath104 .",
    "that means that a similar move can take @xmath39 to @xmath105 since @xmath106 .",
    "in fact , each move to a position in @xmath28 from the starting position of @xmath38 can be copied by the first player in the starting position @xmath39 , and hence @xmath81 .",
    "this contradicts our assumption , hence @xmath107 as well .",
    "[ thm : adjthreeheaps2 ] if @xmath108 then @xmath87 iff @xmath109 and @xmath110 .",
    "assume @xmath111 . since @xmath112 by theorem [ thm : adjtwoheaps ] , lemma [ lem : adjstrategy ] tells us that the first move should be to the position @xmath113 .",
    "the second player can then move to @xmath114 , which is in @xmath28 .",
    "therefore , @xmath87 . by lemma [ lem : adjcompare ] , @xmath115",
    "whenever @xmath116 .",
    "next , assume @xmath117 and @xmath93 . because @xmath118 by theorem [ thm : adjtwoheaps ] , by lemma [ lem : adjstrategy ] the first player will move to position @xmath119 .",
    "similarly , because @xmath120 the next player will move to @xmath121 .",
    "the first player can then move to @xmath122 .",
    "therefore , @xmath123 when @xmath117 and @xmath93 , and hence when @xmath108 , the position @xmath124 iff @xmath110 .    finally , consider the case where @xmath108 and @xmath125 . since @xmath126 by theorem [ thm : adjtwoheaps ] , t@xmath123 .",
    "therefore , if @xmath108 then @xmath124 iff @xmath109 and @xmath110 .",
    "priority queues are similar to stacks and queues , except that the order of elements does not necessarily determine the order they will be removed . when a remove - operation is called , the largest element is always removed .",
    "consider the following priority queue : @xmath32 .",
    "if we remove an element from the queue , @xmath74 will remain .",
    "if we then add @xmath34 followed by @xmath35 , followed by another , remove , the resulting priority queue will be @xmath127 .",
    "is a ruleset just like , except that players must choose from a heap with the greatest size to remove sticks from@xcite .",
    "we give a formal version in definition [ def : greedynim ] .",
    "[ def : greedynim ] is an impartial ruleset where positions are described by a multiset of non - zero natural numbers , @xmath128 .",
    "@xmath129 is an option of @xmath128 exactly when @xmath130 and @xmath131 and either :    * @xmath132 either @xmath133 or @xmath134 , or * @xmath135 and @xmath136 either @xmath133 or @xmath134 .",
    "this game has already been solved ; a polynomial - time algorithm exists to determine the outcome class of the game@xcite .",
    "a position , @xmath47 , is in @xmath28exactly when there are an even number of heaps with the greatest size .",
    "a linked list is a data structure with more explicit structure than a stack , queue , or priority queue . instead of describing which element",
    "gets removed , a linked list is a method for organizing elements .",
    "indeed , stacks and queues can both be implemented using linked lists .",
    "each element in a linked list exists inside a list node , which also includes a reference to the next list node .",
    "( we consider only singly - linked lists , meaning each node does not have a reference to the previous node . ) in other terms , a linked list is like a directed path graph , with a value at each vertex .",
    "[ sec : myopiccol][sec : myopiccol][sec : myopiccol][sec : myopiccol ]    there are many choices of rulesets that could be used on directed paths . in order to deviate from impartial games ,",
    "we use a variant of , .    in , a turn consists of a player choosing an uncolored vertex and painting it their own color ( blue or red ) .",
    "however , they not allowed to choose a vertex adjacent to another vertex with their color .",
    "is played on a directed graph instead of undirected .",
    "when a player chooses a vertex , they are only restricted from choosing vertices with arcs pointing _ to _ neighboring vertices of their color .",
    "arcs directed towards the chosen vertex do not need to be considered .    as with other games discussed",
    ", we provide a rigorous definition .",
    "[ def : myopiccol ] is a combinatorial game where positions are described by a directed graph , @xmath137 , and a coloring of vertices either uncolored or painted red or blue , @xmath138 .",
    "each arc , @xmath139 points from @xmath140 to @xmath141 .",
    "another graph - coloring pair @xmath142 is an option of @xmath143 for player @xmath144 exactly when both    * @xmath145 , and * @xmath146 * * @xmath147 , and * * @xmath148 and @xmath149 and @xmath150    the positions we consider in this section are on paths . ...",
    "consider a positions on a paths described as a list of the colors .",
    "for example , @xmath151 represents path with five vertices with arcs going from - left - to - right .",
    "note that the game on a path with an arc from a colored vertex to another vertex is equivalent to the sum of two paths created by removing that arc .",
    "thus , we must only consider situations where there is at most one colored vertex , and that vertex is at the end of the path .    before we prove things about the col paths , we need a general lemma about games with numeric and star values :    [ lem : numbersplusstar ] @xmath152 @xmath153    first we prove @xmath154 : @xmath155    next we prove @xmath156 by showing that @xmath157 .",
    "notice that either player loses by playing on @xmath158 , because @xmath159 .",
    "however , since @xmath160 is a number and @xmath158 is not , it is still better for both players to make that losing move .",
    "thus , the sum is a loss for both players and equals @xmath56 .",
    "[ lem : pathmyopiccolvalues ] let @xmath47 be a myopic col game played on a path with @xmath8 uncolored vertices , possibly followed by a colored vertex , @xmath161 .",
    "then @xmath162    we proceed by strong induction on @xmath8 :    base case : @xmath163 .",
    "all three cases hold . in the first case ,",
    "there is only one vertex that either can play on , so @xmath54 , as the lemma states . in the second case",
    ", there is a single vertex only right can color .",
    "thus , @xmath164 . in the third case , @xmath165 by the same logic .",
    "inductive case : assume @xmath166 and both lemmas are true for all @xmath167 .",
    "consider @xmath47 , the game played on a path with @xmath8 uncolored vertices .",
    "the moves for left can be derived from the inductive hypotheses .",
    "starting by coloring the head , these are : @xmath168 except for the first one , these are all equal to @xmath169 . since @xmath170 , they are all dominated by that first move .",
    "thus , the best move for left is to color the head of the path .",
    "the same logic holds to show that right s best move is also to color the head of the path .",
    "thus , @xmath171 .",
    "now consider the case where @xmath47 is a path of @xmath8 uncolored vertices followed by a single blue vertex . again",
    "consider the moves for left , starting with playing at the head and continuing down the tail : @xmath172 all but the first simplify to @xmath173 , worse for left than the first option , @xmath169 .",
    "right has one more option : @xmath174 all but the first and last simplify to @xmath175 .",
    "@xmath176 , so right s best move is also to @xmath169 .",
    "now , @xmath177 the same steps can be used to show that a path ending in a red vertex has value @xmath178 .    on a path with @xmath8 uncolored vertices ,",
    "it is always optimal to color the head .    for all of our cases in our analysis above",
    ", the best move was always to color the vertex at the head .",
    "now we can evaluate any path graph ( or collection of paths ) .",
    "the total value of the game is    [ corol : pathmyopiccol ] for a graph that consists only of paths , @xmath47 , the total value of @xmath128 , the position on @xmath47 equals @xmath179 , where :    * @xmath140 is the number of uncolored vertices that either have no outgoing arc or have an outgoing arc that leads to another uncolored vertex .",
    "* @xmath141 is the number of uncolored vertices with their outgoing arc leading to a red vertex .",
    "* @xmath180 is the number of uncolored vertices with their outgoing arc leading to a blue vertex .",
    "we can break each path into sections by removing edges leaving colored vertices .",
    "by lemma [ lem : pathmyopiccolvalues ] , this splitting does not change the values of the positions at all . now",
    "the final formula , @xmath179 , is just the sum of all of the sums generated by using lemma [ lem : pathmyopiccolvalues ] on each piece .",
    "this formula is easy to evaluate , so we can solve this game efficiently .",
    "the winnability of when played on path graphs can be determined in .",
    "the formula from corollary [ corol : pathmyopiccol ] can be evaluated in @xmath181 time , where @xmath8 is the number of vertices in the graph .    in the next section",
    ", we put to work again , but on slightly more complex graphs .",
    "the computational complexity there is not yet known .",
    "in the same way that a linked list is a directed path graph , a binary tree is a directed tree graph with at most two outgoing arcs per vertex .",
    "each node in the tree ( each vertex ) contains a value in the data structure , as well as up to two references to other nodes .",
    "binary trees are used to implement quickly - searchable structures on ordered data , as well as heaps , which can be used for fast priority queues .",
    "we can reuse the ruleset for from section [ sec : myopiccol ] , and now consider the game played on binary trees .",
    "unlike on paths , on binary trees has non integer / integer - plus - star values .",
    "other dyadic rationals exist , such as @xmath182 and @xmath183 .",
    "it seems natural that in a tree with an uncolored node as the root with two uncolored nodes as children of the root , coloring the root is the best move for both players , just as for a path that begins with two uncolored vertices .",
    "consider a directed tree @xmath184 where the root vertex , @xmath185 , is uncolored , and the child trees of @xmath185 , @xmath186 and @xmath187 , are both non - null and have uncolored roots .",
    "for any tree @xmath188 , let @xmath189 be the position on @xmath188",
    ". then @xmath190 .",
    "graphs covered in a data structures course are exactly the same as mathematical graphs with vertices , edges ( or directed arcs ) , and values embedded in the vertices and/or edges .",
    "there are a wide host of rulesets on graphs ( @xcite , , @xcite , @xcite , and more ) .",
    "some games , such as , are in @xcite ; others , such as , are -complete@xcite .",
    "this paper presents game rulesets that rely heavily on different common data structures .",
    "when relevant rulesets did not exist , new rulesets have been created : , and .",
    "we show polynomial - time algorithms that solve both and on paths .",
    "three open problems exist concerning the computational difficulty of games presented here : , , and on binary trees .",
    "is a classic game that has resisted a solution .",
    "recent work reduces the problem to a dynamic programming form@xcite . unfortunately ,",
    "since integers can be represented with a logarithmic number of bits for even a small number of heaps , the size of the table can be exponential in the number of bits needed to describe the game .",
    "therefore , it remains unknown whether a polynomial - time algorithm to determine the outcome class of an position exists ."
  ],
  "abstract_text": [
    "<S> in this paper , we consider combinatorial game rulesets based on data structures normally covered in an undergraduate computer science data structures course : arrays , stacks , queues , priority queues , sets , linked lists , and binary trees . </S>",
    "<S> we describe many rulesets as well as computational and mathematical properties about them . </S>",
    "<S> two of the rulesets , and , are new . </S>",
    "<S> we show polynomial - time solutions to and to on paths . </S>"
  ]
}