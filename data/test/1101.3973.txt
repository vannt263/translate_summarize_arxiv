{
  "article_text": [
    "the recent development in the autonomy and the capabilities of mobile robots greatly increases the number of applications suitable for a team of autonomous agents .",
    "particular interest has been received by those tasks requiring continual execution , such as the monitoring of oil spills @xcite , the detection of forest fires @xcite , the track of border changes @xcite , and the patrol ( surveillance ) of an environment @xcite .",
    "the surveillance of an area of interest requires the robots to continuously and repeatedly travel the environment , and the challenging problem consists in scheduling the robots trajectories so as to optimize a certain performance criteria .",
    "the reader familiar with network location , multiple traveling salesman , or graph exploration problems may observe a close connection with the patrolling problem we address , e.g. , see @xcite .",
    "it is worth noting , however , that these classical optimization problems do not capture the repetitive , and hence dynamic , aspect of the patrolling problem , nor the synchronization issues that arise when a timing among the visits of certain zones is required .",
    "a precise formulation of the patrolling problem requires the characterization of the robots capabilities , of the environment to be patrolled , and of the performance criteria . in this work , we assume the robots to be identical and capable of sensing and communicating within a certain spatial range , and of moving according to a first order integrator dynamics with bounded speed .",
    "we represent the environment as a graph , in which the vertices correspond to physical and strategically important locations , and in which the edges denote the possibility of moving and communicating between locations .",
    "we assume that , when a robot is placed at each of the graph vertices , the union of the sensor footprints provides complete sensor coverage of the environment . regarding the performance criteria of a patrolling trajectory , we consider ( i ) the time gap between any two visits of the same region , called",
    "_ refresh time _ , and ( ii ) the time needed to inform the team of robots about an event occurred in the environment , called _",
    "latency_. loosely speaking , refresh time and latency reflect the effectiveness of a patrolling team in detecting events in the environment and in organizing remedial actions . for both the refresh time and latency optimization problem , we focus on the worst case analysis , even though the average refresh time and the average latency cases are also of interest .",
    "notice that for the latency to be finite , the motion of the robots needs to be synchronized .",
    "for instance , if two robots are allowed to communicate only when they simultaneously occupy two adjacent vertices of the graph , then they need to visit those vertices at the same time in a finite latency trajectory .    the patrolling problem is receiving increasing attention because of its fundamental importance in many security applications , e.g. , see @xcite .",
    "although many solutions have been proposed , the problem of designing minimum refresh time and latency team trajectories for a general environment is , to date , an open problem .",
    "almost all traditional approaches rely on space decomposition , and traveling salesperson tour computation @xcite . in @xcite",
    "an empirical evaluation of existing patrolling heuristics is performed . in @xcite two classes of strategies",
    "are presented , namely the cyclic- and the partition - based strategy . in the cyclic - based strategy , the robots",
    "compute a closed route through the viewpoints , and travel repeatedly such route at maximum speed .",
    "clearly , in the case of a single robot , if the tour is the shortest possible , then the cyclic - based strategy performs optimally with respect to the refresh time and latency criteria . in the partition - based strategy",
    ", the viewpoints are partitioned into @xmath0 subsets , being @xmath0 cardinality of the team , and each robot is responsible for a different set of viewpoints . to be more precise , each robot computes a closed tour visiting the viewpoints it is responsible for , and it repeatedly moves along such tour at maximum speed . still in @xcite ,",
    "the two classes of strategies are compared , and it is qualitatively shown that cyclic - based strategies are to be preferred whenever the ratio of the longest to the shortest edge of the graph describing the environment is small , while , otherwise , partition - based policies exhibit better performance . in @xcite and @xcite , an efficient and distributed solution to the perimeter patrolling problem for robots with zero communication range is proposed . by means of some graph partitioning and graph routing techniques , we extend the results along these directions , e.g. , by considering the case of a nonzero communication range for the perimeter patrolling , and by characterizing optimal strategies for different environment topologies . an important variant of the patrolling problem is known as persistent surveillance , e.g. , see @xcite . differently to our setup",
    ", a dynamically changing environment is considered for the persistent surveillance problem , and performance guarantees are offered only under a certain assumption on the rate of change of the regions to be visited .",
    "it is worth mentioning that a different approach to the design of patrolling trajectories relies on the use of pebbles or chemical traces to mark visited regions , e.g. , see @xcite .",
    "these techniques , although effective even without a global representation of the environment , and with severe communication constraints , do not explicitly deal with the optimality of the patrolling trajectories , and they represent therefore a complementary area of research with respect to this work .",
    "the main contributions of this work are as follows .",
    "we introduce and mathematically formalize the concept of refresh time and latency of a team trajectory , and we formally state the patrolling optimization problem .",
    "we propose a procedure to build a graph ( roadmap ) to represent the topological structure of the area to be patrolled , and we study separately the case of a chain , tree , and cyclic ( not acyclic ) graph .",
    "we exhaustively discuss the case of a chain roadmap .",
    "first , we characterize a family of minimum refresh time and latency team trajectories , which can be computed by optimally partitioning the chain graph among the robots .",
    "second , we derive a centralized polynomial time algorithm to compute an optimal partition , and , ultimately , to design an optimal team trajectory . our partitioning procedure is based upon a bisection method , and it is also amenable to distributed implementation .",
    "third , we develop a distributed procedure for the robots to converge and synchronize along an optimal trajectory , so as to minimize the refresh time and latency criteria .",
    "fourth and finally , we test the robustness of our methods through a simulation study . when the roadmap has a tree or cyclic structure , we focus on the refresh time optimization problem , and we do not consider the latency optimization nor the design of distributed algorithms . for the case of a tree roadmap , we reduce the minimum refresh time patrolling problem to a known graph optimization problem .",
    "we show that the computational complexity of the minimum refresh time patrolling problem is polynomial in the number of vertices of the roadmap , and , under the assumption of a fixed and finite number of robots , we identify a polynomial time centralized algorithm to compute a minimum refresh time team trajectory . for the case of a cyclic roadmap",
    ", we show that the patrolling problem is an _ np - hard _ optimization problem .",
    "we propose two approximation algorithms , and we characterize their performance .",
    "the first approximate solution is extremely easy to compute , but its performance depends upon the ratio between the longest and the shortest edge in the graph representing the environment .",
    "the second approximation algorithm is based on a polynomial time path - covering procedure , and it allows us to compute a team trajectory whose refresh time is within a factor of @xmath1 from the minimum refresh time for the given environment ( cf .",
    "[ fig : path_cover ] for an example ) . to the best of our knowledge",
    ", this algorithm is the first constant factor approximation algorithm for the _ np - hard _ minimum refresh time patrolling problem .    a preliminary version of this work appeared in @xcite .",
    "with respect to the latter manuscripts , in this current work we introduce and solve the latency optimization problem , we perform a numerical study to analyze the robustness of our algorithmic procedures , and we improve the presentation of the results on the refresh time optimization problem .",
    "the rest of the paper is organized as follows .",
    "the notation and the problem under consideration are in section [ sec : prob_set ] , where we also show that the patrolling problem is , generally , computationally hard .",
    "section [ sec : refr_time ] , [ sec : latency ] , and [ sec : distr_alg ] contain our results for the patrolling of a chain environment .",
    "we characterize a minimum refresh time and latency team trajectory , and we derive a centralized and a decentralized algorithm for its computation . in section [ sec : simulations ] we perform a simulation study to show some robustness and reconfigurability properties of our distributed procedure .",
    "section [ sec : tree_patrol ] contains our results for the patrolling of a tree environment .",
    "we describe a minimum refresh time team trajectory on a tree roadmap , and we characterize the complexity of computing an optimal solution .",
    "section [ sec : heurist ] deals with the general case of cyclic environment , and it contains our approximation procedures .",
    "our conclusion and final remarks are in section [ sec : future_work ] .",
    "we will be using the standard motion planning notation , and we refer the reader to @xcite for a comprehensive treatment of the subject . we are given a team of @xmath2 identical robots , capable of sensing , communicating , and moving in a connected environment .",
    "we make the following combined assumptions on the robot capabilities and on the environment to be patrolled .    regarding sensing , we assume that the environment can be completely covered by simultaneously placing a robot at each of a set of @xmath3 _ viewpoints _ in the configuration space . in other words ,",
    "if @xmath4 robots were available and placed at the @xmath5 viewpoints , then the union of the sensors footprint of the robots would provide complete sensor coverage of the environment .",
    "we assume that each viewpoint is required for complete sensor coverage .",
    "finally , we assume @xmath3 so that at least one robot needs to visit more viewpoints for the entire environment to be monitored over time .    regarding communication , we associate an undirected graph @xmath6 with the environment , whose vertices are the @xmath5 viewpoints , and in which there is an edge between two vertices if two robots placed at those viewpoints are able to communicate to each other .",
    "we assume that @xmath6 is connected . in what follows we",
    "design cooperative patrolling algorithms with sporadic communication , in the sense that two robots are required to communicate only when they occupy adjacent vertices .",
    "the occurrence of additional communication links can be easily incorporated into the algorithms and can not decrease their performance .",
    "regarding motion , we assume that the robots are holonomic , i.e. , they are modeled as first order integrators and move at most at unit speed .",
    "additionally , we turn the graph @xmath6 into a robotic roadmap  @xcite and a metric weighted graph as follows : to each pair of viewpoints that are neighbors in @xmath6 , we associate a unique path connecting them .",
    "we select these paths so that the set of path lengths , adopted as edge weights , verify the triangle inequality .",
    "( for example , the shortest paths between viewpoints constitute a suitable choice . )",
    "we assume that each robot remains always on the roadmap .    in summary ,",
    "the combined assumptions on the robot capabilities and on the environment are that : the vertices of @xmath6 provide complete sensor coverage of the environment and each edge of @xmath6 corresponds to both a communication edge and a motion path .",
    "hence , we refer to @xmath6 as a roadmap with sensor coverage and communication connectivity .",
    "the problem of constructing a roadmap from an environment is here discussed .",
    "assume that the robots are holonomic vehicles moving at bounded speed , and equipped with an omnidirectional sensing device , and a line - of - sight communication device .",
    "if a map of the environment is available , then a valid roadmap is obtained by solving an art gallery problem with connectivity @xcite .",
    "a solution to the art gallery problem with connectivity is a set of locations , called guards , with the following two properties : each point in the environment is visible by at least one guard and the visibility graph of the guards is connected .",
    "an example roadmap is given in fig .",
    "[ fig : commgraph ] .",
    "( a distributed sensor - based algorithm for the art gallery problem with connectivity is given in  @xcite . )",
    "the edges of the roadmap denote the possibility for the @xmath7 robots of both moving and communicating between pair of connected viewpoints .",
    "the weight of each edge corresponds to its length.,title=\"fig : \" ] +    if the environment is unknown , then an exploration algorithm should be used to obtain a representation of the environment , see for example  @xcite .",
    "while or after exploring the environment , a robot should select viewpoints to provide full sensor coverage . by construction , the existence of a path between two viewpoints is automatically guaranteed by the exploration algorithm .",
    "moreover , if communication between two path - connected viewpoints @xmath8 is not guaranteed , then the graph may be augmented with additional viewpoints along the path connecting @xmath9 and @xmath10 .",
    "the roadmap resulting from these steps features sensor coverage and communication connectivity .",
    "the following remarks are in order .",
    "first , a roadmap representing the environment is in general not unique , and the patrolling performance depends upon the particular choice . in this work",
    ", we do not address the problem of choosing the roadmap that yields optimal performance .",
    "instead , we present efficient algorithms for the patrolling problem , which can also be used to compare different roadmaps on the basis of the corresponding patrolling performance .",
    "second , for the implementation of our algorithms , a robot does not need to travel exactly along the roadmap .",
    "indeed , a robot only needs to arrive sufficiently close to a viewpoint , or to be able to circle around it to provide sensor coverage .",
    "a related example is in section [ sec : simulations ] , where the arrival delay of a robot can be interpreted as the uncertainty in the motion of the robots .",
    "third , the global knowledge of the roadmap may not be required for the execution of a patrolling trajectory .",
    "indeed , in general , each robot only visits a subpart of the roadmap .",
    "fourth and finally , collisions are prevented by letting two robots exchange their roles every time they are about to collide .",
    "indeed , since no robot is assigned to a specific viewpoint , if robot @xmath11 is about to collide with robot @xmath12 at time @xmath13 , then , without affecting the performance of the team trajectory , collision is avoided by redefining the @xmath11-th and @xmath12-th trajectory as @xmath14 and @xmath15 for @xmath16 ; see the notion of order invariant trajectory below . communication or sensing devices can be used to detect and prevent possible collisions .",
    "for a team of @xmath0 robots with specific capabilities , let @xmath17 be a robotic roadmap with sensor coverage and communication connectivity .",
    "a _ team trajectory _",
    "@xmath18 is an array of @xmath0 continuous and piecewise - differentiable trajectories @xmath19 defined by the motion of the robots on the roadmap @xmath6 , i.e. , @xmath20 \\mapsto g$ ] , for @xmath21 , where @xmath22 is a time horizon of interest , much larger than the time required by a single robot to visit all viewpoints .",
    "we say that a viewpoint @xmath23 is visited at time @xmath24 by robot @xmath11 if @xmath25 .",
    "we define the _ refresh time _ of a team trajectory @xmath18 , in short @xmath26 , as the longest time interval between any two consecutive visits of any viewpoint , i.e. , @xmath27 where @xmath28 ^ 2 , t_1    \\le t_2 ,   \\ ; | \\ ; x_i(t)\\neq v , \\forall i\\in{\\{1,\\dots , m\\ } } , t_1 < t < t_2\\}}$ ] .",
    "we claim that there exists a team trajectory with minimum refresh time and prove it as follows . without loss of generality ,",
    "we restrict our attention to team trajectories in which each robot moves at maximum speed along the edges and stops for certain durations , possibly equal to zero , at the viewpoints .",
    "thus , a team trajectory can be described as a tuple of the form @xmath29 , where @xmath30 contains the sequence of viewpoints visited by robot @xmath11 , and @xmath31 contains the waiting times at the visited vertices .",
    "notice that the time horizon @xmath32 is finite , the length of each edge is positive , the number of vertices is finite , and the speed of the robots is bounded .",
    "it follows that the length of each sequence @xmath30 is finite , and , therefore , each @xmath30 takes value in a finite set .",
    "now , for each possible sequence of visited vertices , the refresh time is a continuous function of only the waiting times , and each waiting time lies in the compact interval @xmath33 $ ] .",
    "because any continuous function defined over a compact region admits a point of minimum value , we conclude that there exists a team trajectory with minimum refresh time .",
    "[ prob : minrt ] given a roadmap and a team of robots , find a minimum refresh time team trajectory .    in section [ sec : latency ]",
    "we present a different optimization problem , which deals with the possibility for a robot to communicate , possibly with multiple hops , with every other robot in the team .",
    "we now conclude this section with our first result on the computational complexity of the team refresh time problem . for a detailed discussion of the main aspects of the computational complexity theory ,",
    "we refer the interested reader to @xcite .",
    "recall that an optimization problem is said to be _ np - hard _ if it is , informally , as hard as the hardest problem in the class _ np _ , for which no polynomial time algorithm is known to compute an optimal solution .",
    "[ thm : complexity ] the _ team refresh time _ problem is _ np - hard_.    this statement can be shown by reduction from the traveling salesman problem @xcite .",
    "in fact , if @xmath34 , since the speed of the robots is bounded , then a minimum refresh time trajectory consists of moving the robot at maximum speed along a shortest closed tour visiting the viewpoints .",
    "the problem of finding a shortest tour through a set of points in the plane , also known as traveling salesman problem , is an _ np - hard _",
    "problem @xcite . hence , by restriction ,",
    "the team refresh time problem is also _ np - hard_.    following theorem  [ thm : complexity ] , the minimum refresh time optimization problem is generally computationally hard . in this work ,",
    "we first identify two roadmap structures for which there exists an efficient solution to the team refresh time problem , and then we describe two approximation algorithms to deal with the general case .",
    "we characterize in this section an optimal refresh time team trajectory when the roadmap associated with the environment has a chain structure .",
    "let @xmath35 denote the neighbor set of the vertex @xmath11 , and let @xmath36 denote the degree of @xmath11 , i.e. , the cardinality of the set @xmath35 .",
    "a chain roadmap is an undirected , connected , and acyclic roadmap , in which every vertex has degree two , except for two vertices which have degree one . without losing generality ,",
    "we assume that the @xmath5 vertices are ordered in a way that @xmath37 , @xmath38 , and @xmath39 for each @xmath40 . we define a relative order of the robots according to their position on the roadmap .",
    "a team trajectory is _ order invariant _ if the order of the robots does not change with time , i.e. , if @xmath41 for each @xmath42 and for every instant @xmath43 $ ] , where @xmath44 denotes the distance at time @xmath24 on the roadmap from the first vertex of the chain to the position of the @xmath11-th robot .",
    "[ prop : eqv_traj ] let @xmath18 be a team trajectory .",
    "there exists an order invariant team trajectory @xmath45 such that @xmath46 .",
    "let @xmath18 be a team trajectory , and consider the permutation matrix @xmath47 , that keeps track of the order of the robots at time @xmath24 , i.e. , such that the @xmath48-th entry of @xmath47 is @xmath49 if , at time @xmath24 , the @xmath11-th robot occupies the @xmath12-th position in the chain of robots , and it is @xmath50 otherwise . since @xmath18 is continuous , anytime the function @xmath47 is discontinuous , the positions of the robots directly involved in the permutation overlap .",
    "therefore , the order invariant team trajectory @xmath51 is a feasible team trajectory , and it holds @xmath52 .",
    "let @xmath53 be the set of viewpoints visited over time by the agent @xmath11 with the trajectory @xmath54 , and let the _ image _ of the team trajectory @xmath18 be the set @xmath55 .",
    "notice that different team trajectories may have the same image . throughout the paper ,",
    "let @xmath56 , @xmath57 , and @xmath58 .",
    "finally , let @xmath59 .",
    "a team trajectory is _ non - overlapping _ if @xmath60 for all @xmath61 .",
    "[ prop : disjoint_sets ] given a chain roadmap , there exists an order invariant and non - overlapping team trajectory with refresh time @xmath62 .",
    "let @xmath63 be a minimum refresh time team trajectory , and let @xmath18 be the order invariant team trajectory obtained from @xmath63 as in proposition [ prop : eqv_traj ] .",
    "clearly @xmath64 .",
    "let @xmath55 be the image of @xmath18 , and note that @xmath65 .",
    "consider the partition of @xmath66 defined as @xmath67 for every nonempty @xmath68 , let @xmath69 , @xmath70 , and @xmath71 .",
    "note that , by construction , the viewpoint @xmath72 is visited by the robot @xmath11 and , possibly , by the robots @xmath73 .",
    "also , because @xmath18 is order invariant , we have @xmath74 .",
    "it follows that @xmath75 .",
    "consider now the team trajectory @xmath45 with image @xmath76 , and assume that the robots sweep periodically at maximum speed their segment .",
    "then @xmath77 , so that @xmath78 is an order invariant and non - overlapping team trajectory with minimum refresh time .    given a chain graph on the viewpoints @xmath66 , let @xmath79 be an _",
    "@xmath0-partition _ of @xmath66 , i.e. , @xmath80 is a collection of subsets of @xmath66 such that @xmath81 whenever @xmath61 , and @xmath82 .",
    "additionally , let the dimension of the partition @xmath83 equal the longest distance between any two viewpoints in the same cluster , i.e. , @xmath84 , where @xmath85 if @xmath86 .",
    "following proposition [ prop : disjoint_sets ] , there exists a minimum refresh time team trajectory whose image coincide with an @xmath0-partition of @xmath66 .",
    "we now show that the minimum refresh time equals twice the dimension of an optimal @xmath0-partition .",
    "[ thm : min_refre_time ] let @xmath6 be a chain roadmap , and let @xmath0 be the number of robots",
    ". then @xmath87 .    as a consequence of propositions [ prop : eqv_traj ] and [ prop : disjoint_sets ] , there exists a minimum refresh time team trajectory whose image coincides with an @xmath0-partition @xmath83 . since each robot",
    "is assigned a different cluster , and the speed of the robots is bounded by @xmath49 , we have @xmath88 .",
    "consider a team trajectory @xmath18 in which each robot continuously sweeps at maximum speed the cluster it is assigned to .",
    "clearly , @xmath89 .",
    "@xmath90 for @xmath91 @xmath92 for @xmath93    we have shown that a minimum refresh time trajectory consists of letting the robot sweep at maximum speed a part of the chain graph .",
    "such a trajectory is more formally described for the @xmath11-th robot in trajectory [ algo : max_sweep ] , where we only characterize the instants of time at which robot @xmath11 changes its velocity vector , and we assume that it moves at maximum speed otherwise .    by removing the longest edges in the chain the average length of the clusters is minimized . in general , such partition",
    "does not minimize the dimension of the @xmath0-partition , and hence it is not optimal in our sense .",
    "an example is in fig .",
    "[ fig : average ] .",
    "+   +      in the remaining part of the section we describe an algorithm to compute an optimal @xmath0-partition . for a set of viewpoints @xmath66 , we call _ left - induced _ partition of length @xmath94 the partition @xmath95 defined recursively as ( cf . fig .",
    "[ fig : leftinduc ] ) @xmath96 where @xmath97 the cardinality @xmath98 corresponds to the integer @xmath12 such that .",
    "observe that the function @xmath99 is monotone , non - increasing , and right - continuous ( cf .",
    "[ fig : leftinduccard ] ) .",
    "let @xmath100 be the discontinuity points of the function @xmath99 , then , for @xmath101 , @xmath102 note that two or more discontinuity points of @xmath103 may coincide , so that the function @xmath103 may not assume all the values in the set @xmath104 , e.g. , in fig .",
    "[ fig : leftinduccard ] the value @xmath103 is never equal to @xmath105 .",
    "[ thm : optimal_partition ] let @xmath6 be a chain roadmap .",
    "let @xmath83 be an @xmath0-partition of @xmath6 , and let @xmath106 be the left - induced partition of length @xmath107 of @xmath6 .",
    "then @xmath108    let @xmath83 be an @xmath0-partition , and let @xmath109 be the left induced partition of length @xmath107 of a chain roadmap @xmath6 .",
    "let @xmath110 .",
    "we want to show that @xmath111 is one of the discontinuity points of the function @xmath103 , i.e. , that @xmath111 verifies the conditions .    by contradiction , if @xmath112 and @xmath113 , then an @xmath0-partition with dimension smaller than the optimal would exists .",
    "therefore we have @xmath114 if @xmath112 .",
    "suppose now that @xmath115 , and let @xmath116 be an @xmath0-partition with minimum dimension .",
    "notice that @xmath117 , because the cluster @xmath118 contains all the viewpoints within distance @xmath107 from @xmath119 , and hence also within distance @xmath111 .",
    "it follows that @xmath120 , and also that @xmath121 . by repeating the same procedure to the remaining clusters ,",
    "we obtain that @xmath122 , so that , if @xmath123 and @xmath124 , then @xmath125 .    following theorem [ thm : optimal_partition ] , an optimal left - induced partition of cardinality ( at most ) @xmath0 is also an optimal @xmath0-partition .",
    "notice that for the computation of an optimal left - induced partition only the lengths @xmath107 corresponding to the discontinuity points of @xmath106 need to be considered .",
    "since each discontinuity point coincides with the distance between a pair of vertices , only @xmath126 values need to be tested .",
    "therefore , an optimal left - induced partition can be computed with complexity @xmath127 . in what follows",
    "we describe an @xmath128-approximation algorithm with linear complexity for any @xmath129 .",
    "notice that @xmath128-approximation algorithms with linear complexity are often more convenient for a practical implementation than exact algorithms with higher complexity @xcite .",
    "we now present our algorithm for the computation of an optimal @xmath0-partition .",
    "since the function @xmath99 is monotone and continuous , a bisection method is effective for finding its discontinuity points , and , therefore , for determining the shortest length of a left - induced partition of cardinality @xmath0 .",
    "a bisection based procedure to compute an optimal left - induced partition is in algorithm [ algo : partition ] , where the function _ left - induced(@xmath130,@xmath107 ) _ returns the left - induced partition defined in equation .",
    "we next characterize the convergence properties of algorithm [ algo : partition ] .",
    "[ thm : conv_alg_part ] let @xmath6 be a chain roadmap , and let @xmath83 denote an @xmath0-partition of @xmath6 .",
    "let @xmath131 .",
    "algorithm [ algo : partition ] with tolerance @xmath128 returns a left - induced partition of dimension at most @xmath132 and cardinality at most @xmath0 .",
    "moreover , the time complexity of algorithm [ algo : partition ] is @xmath133 .",
    "algorithm [ algo : partition ] searches for the minimum length @xmath111 that generates a left - induced partition of cardinality at most @xmath0 .",
    "because of theorem [ thm : optimal_partition ] , the length @xmath111 coincides with one of the discontinuity points of the function @xmath103 , and it holds @xmath134 .",
    "indeed , @xmath135 because @xmath136 , and @xmath137 , because @xmath138 .",
    "recall from that @xmath114 for every @xmath112 , and that the function @xmath139 is monotone .",
    "note that the interval @xmath140 $ ] , as updated in algorithm [ algo : partition ] , contains the value @xmath111 at every iteration .",
    "the length of the interval @xmath140 $ ] is divided by 2 at each iteration , so that , after @xmath141 , the value @xmath111 is computed with precision @xmath128 . since the computation of @xmath103 can be performed in @xmath142 operations , the time complexity of algorithm [ algo : partition ]",
    "is @xmath133 .    as a consequence of proposition [ prop : disjoint_sets ] and theorem [ thm : min_refre_time ] , in what follows we only consider team trajectories whose image coincide with an @xmath0-partition .",
    "therefore , for ease of notation , we use the set @xmath55 to denote both the image set of a team trajectory and an @xmath0-partition of the chain graph .",
    "we conclude this section with a summary of the presented results .",
    "[ thm : summary_chain_rt ] let @xmath6 be a chain graph with @xmath5 viewpoints and let @xmath143 be the number of robots .",
    "let @xmath144 be an optimal @xmath0-partition of @xmath6 computed by means of algorithm [ algo : partition ] with tolerance @xmath128 .",
    "let @xmath145 be the dimension of @xmath144 .",
    "a team trajectory with image @xmath144 , and minimum refresh time @xmath146 is computed as in trajectory [ algo : max_sweep ] . moreover ,",
    "the time complexity of designing such trajectory is @xmath133 .",
    "the previous section considers the problem of designing team trajectories with optimal refresh time on a chain graph . in a patrolling mission",
    "it may be important for the robots to communicate with each other in order to gather information about the status of the entire environment .",
    "for instance , messages could be sent by a unit to ask for reinforcement , or to spread an alarm .",
    "informally , we call _ latency _ of a team trajectory @xmath18 , in short @xmath147 , the shortest time interval necessary for a message generated by any robot to reach all the other robots . in other words , given our communication model , the latency of a team trajectory is a measure of how fast a message spreads to all robots . in this section",
    "we describe team trajectories with minimum refresh time and latency .",
    "we now give a more formal definition of @xmath147 .",
    "recall that , by assumption , two robots are allowed to communicate when they lie on two adjacent viewpoints . in a chain roadmap , for a message to reach every robot in the chain , every pair of adjacent robots needs to communicate . for @xmath148 ,",
    "let @xmath149 denote the union of the set of times at which the robots @xmath150 and @xmath11 communicate and @xmath151 .",
    "the _ up - latency _ of @xmath18 , in short @xmath152 , is the longest time interval between any two consecutive communications between the robots @xmath153 and @xmath154 .",
    "precisely , @xmath155 where @xmath156 .",
    "analogously , we call _ down - latency _ the quantity @xmath157 where @xmath158 .",
    "finally , we define the latency of a team trajectory as @xmath159 notice that our definitions of latency hold for @xmath160 , and that , if @xmath161 , then we have @xmath162 for every team trajectory @xmath18 .",
    "we envision that the up- and down - latency performance criteria should be adopted when it is of interest to report the status of the monitored area to a base station located at one end of the chain environment .",
    "the latency minimization problem is more appropriate for fully distributed scenarios . in this section",
    "we design synchronized team trajectories with the following two features .",
    "first , since a minimum refresh time trajectory is determined by an optimal partition of the chain graph , we aim at finding team trajectories associated with the same optimal partition .",
    "second , we design synchronized team trajectories with minimum up - latency ( resp .",
    "down - latency ) or latency .",
    "we start by showing a lower bound for @xmath163 and @xmath164 .",
    "recall that , for a partition @xmath55 , we have @xmath56 , @xmath165 , @xmath58 , and @xmath166 .    [ lower_bound ] let @xmath6 be a chain roadmap , and let @xmath55 be an @xmath0-partition of @xmath6 .",
    "the latency of a team trajectory with image @xmath55 is lower bounded by @xmath167 .",
    "the proposition follows from the fact that the robots speed is bounded by @xmath49 , and that the robots need to travel their segment to communicate with the neighboring robots .    for the up - latency of a team trajectory to equal the lower bound in lemma [ lower_bound ]",
    ", each robot @xmath11 needs to transfer a message from robot @xmath150 to robot @xmath168 in time @xmath169 . in order to do so , each robot @xmath11 needs to communicate with its neighbor @xmath168 as soon as @xmath170 .",
    "let @xmath6 be a chain graph with @xmath5 viewpoints and let @xmath143 be the number of robots .",
    "let @xmath144 be an optimal @xmath0-partition of @xmath6 computed by means of algorithm [ algo : partition ] with tolerance @xmath128 .",
    "let @xmath145 be the dimension of @xmath144 , and let @xmath169 be the length of the @xmath11-th cluster .",
    "a team trajectory with image @xmath144 , minimum refresh time @xmath171 , and minimum up - latency @xmath172 is computed as in trajectory [ algo : min_base ] .",
    "moreover , the time complexity of designing such trajectory is @xmath133 .",
    "the theorem follows by observing that the trajectory is @xmath173-periodic , and that no robot @xmath11 waits at @xmath174 to communicate with the neighboring robot @xmath168 .",
    "the up - latency equals the lower bound in lemma [ lower_bound ] , and it is therefore minimum . regarding the computational complexity , notice that it is determined by the computation of the optimal @xmath0-partition @xmath144 , and hence , by lemma [ thm : conv_alg_part ] , it equals @xmath133 .",
    "an example of a team trajectory with minimum refresh time and minimum up - latency is in fig .",
    "[ fig : traj3 ] .",
    "finally , observe that the minimization of the down - latency can be achieved in an analogous way .",
    "@xmath175 for @xmath176 and for @xmath177    @xmath178 for @xmath179    .",
    "notice that each robot @xmath11 communicates with the neighboring robot @xmath168 as soon as @xmath180 .",
    "a team trajectory with minimum down - latency is obtained by shifting in time the trajectory of robot @xmath49 , in a way that robot @xmath181 communicates with robot @xmath49 as soon as @xmath182 . ]",
    "let @xmath55 be an optimal @xmath0-partition , and suppose that @xmath183 for all @xmath184 .",
    "then the up - latency and the down - latency can be made minimum and equal to @xmath185 by arranging the robots trajectories to be in opposite phase .",
    "specifically , for @xmath186 , we set @xmath187 if @xmath11 is odd , and @xmath188 if @xmath11 is even .",
    "because of lemma [ lower_bound ] , the above trajectory has minimum latency .",
    "this particular case was studied in @xcite .",
    "we now consider the minimization of the latency criterion , and we restrict our attention to periodic team trajectories . to be more precise ,",
    "let @xmath55 be an optimal @xmath0-partition of the environment , and let @xmath189 denote the longest length of the clusters .",
    "we aim at finding a @xmath190-periodic team trajectory with image @xmath55 and minimum latency .",
    "notice that , by imposing a periodicity of @xmath190 , the refresh time of the trajectory , if finite , is also minimized .",
    "we start by considering the pedagogical situation in which @xmath191 for all @xmath192 . in the next lemma",
    ", we show that the frequency of message exchange among the robots is limited by the periodicity of the trajectory .",
    "[ lemma : exchange_rate ] consider a @xmath190-periodic team trajectory , and let @xmath193 for all @xmath192 .",
    "for any @xmath194 $ ] and for any @xmath195 , there exist no two distinct sequences @xmath196 and @xmath197 , with @xmath198 , @xmath199 , such that @xmath200 moreover , for any @xmath201 , there exist no two sequences @xmath202 and @xmath203 with @xmath198 , @xmath204 , such that @xmath205    since @xmath206 , it follows @xmath207 .",
    "let @xmath208 .",
    "by contradiction , if two distinct sequences @xmath196 and @xmath197 exist , with @xmath209 , @xmath210 , @xmath211 and @xmath212 , then the @xmath213-th robot travels its cluster four times .",
    "since the speed of the robots is bounded by one , robot @xmath168 can not travel its cluster four times in a period of @xmath190 ( cf .",
    "[ fig : frequency_exchange ] ) .",
    "the second part of the theorem follows from an analogous reasoning .",
    ", at most one communication sequence is possible within each period of length @xmath214 . here @xmath215 . ]",
    "notice that in the above lemma the index @xmath11 belongs to the set @xmath216 ( resp .",
    "@xmath217 ) because we consider @xmath7 consecutive communication instants , and because @xmath149 denotes the sequence of times at which robots @xmath150 and @xmath11 communicate .",
    "because of lemma [ lemma : exchange_rate ] , in a @xmath190-periodic team trajectory with @xmath218 only one message can be passed from robot @xmath11 to robot @xmath219 in a period of time of @xmath190 .",
    "this limitation determines a lower bound on the latency of a periodic trajectory .",
    "notice that eventual communication instants @xmath220 , with @xmath221 , do not influence the latency , since all information can be transmitted at time @xmath222 without affecting the latency performance .",
    "[ lemma : lower_bound_latency ] let @xmath18 be a @xmath190-periodic team trajectory with @xmath223 for all @xmath192 .",
    "then @xmath224    because of lemma [ lemma : exchange_rate ] , a message can be transfered from robot @xmath11 to robot @xmath219 in at most @xmath190 instants of time , by traveling the clusters @xmath225 and @xmath226 . without losing generality ,",
    "we let @xmath189 be the time to pass a message form @xmath168 to @xmath227 , and from @xmath227 to @xmath219 .",
    "notice that the same reasoning holds also for the time to transfer a message from @xmath219 to @xmath11 .",
    "therefore , the latency is lower bounded by @xmath185 .",
    "we now consider the situation in which an optimal @xmath0-partition does not verify the constraint @xmath218 for all @xmath228 .",
    "intuitively , for what concerns the latency , two consecutive clusters with length @xmath169 and @xmath229 may be regarded as one single cluster of length @xmath230 .",
    "therefore , in order to use lemma [ lemma : exchange_rate ] and lemma [ lemma : lower_bound_latency ] , we partition the clusters @xmath55 into groups such that the sum of the length of the clusters of two consecutive groups is greater than @xmath189 . in other words , let @xmath231 be the set of _ right - extreme _ viewpoints of the partition @xmath55 defined recursively as @xmath232 where @xmath233 such that @xmath234 .",
    "let @xmath235 be the set of _ left - extreme _ viewpoints defined recursively as @xmath236 additionally , define the set of aggregated clusters @xmath237 , where @xmath68 contains all the clusters within @xmath72 and @xmath238 , and let @xmath239 be the sum of the length of the clusters in @xmath240 .",
    "[ thm : lat_general ] let @xmath18 be a @xmath190-periodic team trajectory with image @xmath55 , and let @xmath241 be the number of aggregated clusters .",
    "then , @xmath242    consider the clusters defined by the right extreme viewpoints , and notice that they verify @xmath218 .",
    "then , the theorem follows from lemma [ lemma : lower_bound_latency ] , and from the fact that the minimum latency on the image @xmath243 equals the minimum latency on the image @xmath55 .",
    "the terms @xmath244 and @xmath245 are due to the fact that we are interested in delivering a message from robot @xmath49 to robot @xmath0 in the original configuration , and not on the aggregated chain .      a team trajectory with minimum refresh time and minimum latency is formally presented in trajectory [ algo : opt_traj ] , where we specify the instants of time at which a robot changes its velocity , and we assume that it moves at maximum speed otherwise . an example",
    "is reported in fig .",
    "[ example_latency_opt ] , and here we give an informal description .",
    "let @xmath55 be an optimal @xmath0-partition of a chain graph , and let @xmath246 be the set of aggregated clusters .",
    "recall that @xmath247 is a subset of @xmath55 , and that the sum of the length of two consecutive elements is larger than @xmath189 .",
    "the procedure in trajectory [ algo : opt_traj ] ( lines @xmath248 and @xmath249 ) is such that the robots in the same group behave as a single robot assigned to the whole set of viewpoints . in other words ,",
    "the motion of the robots in the same group is determined by a token passing mechanism , in which robot @xmath168 moves towards @xmath250 only when @xmath180 and @xmath251 , and , analogously , robot @xmath11 moves towards @xmath252 only when @xmath253 and @xmath254 .",
    "instead , lines @xmath255 and @xmath256 in trajectory [ algo : opt_traj ] guarantee the transfer of one message in a period of @xmath190 between three consecutive groups , and , consequently , the minimization of the latency .",
    "indeed , since the sum of the length of two consecutive groups is larger than @xmath189 , because of lemma [ lemma : exchange_rate ] , no more than one message can be transferred between three consecutive groups in a period of @xmath190 .",
    "let @xmath6 be a chain graph with @xmath5 viewpoints and let @xmath143 be the number of robots .",
    "let @xmath144 be an optimal @xmath0-partition of @xmath6 computed by means of algorithm [ algo : partition ] with tolerance @xmath128 .",
    "let @xmath145 be the dimension of @xmath144 , and let @xmath257 ( resp .",
    "@xmath258 ) be the length of the first ( resp .",
    "last ) cluster in @xmath144 .",
    "let @xmath241 be the number of aggregated clusters , and let @xmath259 ( resp .",
    "@xmath260 ) be the length of the first ( resp .",
    "last ) aggregated cluster .",
    "a team trajectory with image @xmath144 , minimum refresh time @xmath146 , and minimum latency @xmath261 is computed as in trajectory [ algo : opt_traj ] . moreover ,",
    "the time complexity of designing such trajectory is @xmath133 .    by inspection ,",
    "the team trajectory described in trajectory [ algo : opt_traj ] is @xmath190-periodic , and therefore it has minimum refresh time .",
    "moreover , by construction , the communications at the extreme viewpoints happen every @xmath190 instants of time , so that the latency is equal to @xmath262 , and hence , by lemma [ thm : lat_general ] , minimum .",
    "regarding the computational complexity , notice that it is determined by the computation of the optimal @xmath0-partition @xmath144 , and hence , by lemma [ thm : conv_alg_part ] , it equals @xmath133 .     and",
    "minimum latency @xmath263 is here reported . a message with delivery time equal to @xmath264",
    "is reported in red .",
    "the right - extreme viewpoints are @xmath265 , the left - extreme viewpoints are @xmath266 , and @xmath267 .",
    "the represented team trajectory has minimum refresh time @xmath268 and minimum latency @xmath269 .",
    "a message with delivery time equal to @xmath264 is reported in red . ]",
    "in the previous sections we have shown that , for the computation of a minimum refresh time and latency team trajectory , first an optimal @xmath0-partition of the roadmap needs to be found , and , then , a synchronization of the motion of the robots needs to be achieved to ensure communication between neighboring robots .",
    "the distributed computation of an optimal @xmath0-partition follows directly from algorithm [ algo : partition ] , by letting the robots compute the left - induced partition of length @xmath270 in a distributed way . a simple solution consists of the following three operation :    1 .",
    "the robots gather at the leftmost viewpoint , and 2 .",
    "determine the cardinality of the team and elect a leader ; 3 .",
    "the leader computes an optimal left - induced partition , and assigns a different cluster to each robot .",
    "notice that , by only assuming the capability of detecting the viewpoints in the roadmap ( in particular the leftmost and rightmost viewpoint ) the robots can distributively compute an optimal partition .",
    "indeed , the leader can simply travel the roadmap , and evaluate if , for a given length @xmath107 , the cardinality of the corresponding left - induced partition is greater , equal , or smaller than the cardinality of the team .",
    "we believe that , by simple programming operations , the above procedure can be improved , so as to handle reconfigurations due to addition or removal of robots in the team . in this section",
    "we focus instead on the design of a distributed feedback law to synchronize the motion of the robots so as to guarantee the minimization of the latency of the trajectory .",
    "recall that @xmath271 denotes the position on the chain of the robot @xmath11 at time @xmath24 .",
    "moreover , let the @xmath11-th cluster of an optimal @xmath0-partition be delimited by @xmath272 and @xmath174 .",
    "let @xmath273 denote the direction of motion of robot @xmath11 .",
    "c - time _ denote the current time of simulation , let _ a - time _ be the time at which a robot arrives at his right extreme .",
    "n - meet(i , j ) _ be a function that returns the number of times that the robots @xmath11 and @xmath12 have communicated .",
    "timer(@xmath274 ) _ be a function that returns @xmath49 after a time interval of length @xmath274 .",
    "an algorithm for the robots to distributively converge to a minimum refresh time and latency team trajectory is in algorithm [ algo : synchro ] .",
    "it should be noticed that the algorithm assumes the knowledge of an optimal partitioning of the chain graph , and of the left- and right - extreme sets .",
    "algorithm [ algo : synchro ] is informally described as follows .",
    "first , the velocity of a robot changes only when its position coincides with the leftmost or the rightmost of the assigned viewpoints .",
    "when a robot reaches an extreme viewpoint , it waits until a communication with the neighboring robot happens ( lines @xmath275 ) .",
    "this mechanism determines the feedback behavior of our procedure .",
    "the behavior of a robot after a communication is determined by the lines @xmath276 , which reproduce the optimal behavior described in trajectory [ algo : opt_traj ] . to be more precise , the function _",
    "token(@xmath277 ) _ coordinates the motion of the robots in the same group ( see section [ sec : realistic_case ] ) , so that they move as if there was a single robot sweeping the viewpoints in the same group . the function _",
    "timer(@xmath278 ) _ , instead , ensures the maximum frequency of messages exchange between consecutive groups , so as to minimize the latency of the resulting trajectory .",
    "[ thm : latency ] let @xmath18 be the team trajectory generated by algorithm [ algo : synchro ] .",
    "there exists a finite time after which @xmath18 has minimum refresh time and latency .",
    "let @xmath55 be an optimal @xmath0-partition , let @xmath279 be the set of right - extreme viewpoints , and let @xmath280 be the set of left - extreme viewpoints .",
    "let @xmath281 denote the set of robots patrolling a viewpoint between @xmath72 and @xmath238 , where @xmath72 and @xmath238 are as previously defined .",
    "first , notice that robot @xmath49 ( resp .",
    "@xmath0 ) sets @xmath282 ( resp .",
    "@xmath283 ) as soon as @xmath284 ( resp .",
    "@xmath285 ) .",
    "second , the function @xmath286 guarantees that , when @xmath287 communicate , exactly one robot among @xmath288 maintains a zero velocity and in an alternate way .",
    "therefore , after a finite time @xmath289 , independent of the initial robots motion direction , the velocities of the robots in @xmath281 are such that , upon communication , @xmath290 and @xmath291 . in other words , after @xmath289 , the robots in @xmath281 behave as a single robot sweeping the segments between @xmath72 and @xmath238 . finally , the function @xmath292 and the parameter @xmath293 guarantee that the communications at the extreme viewpoints happen every @xmath294 instants of time .",
    "we conclude that the trajectory generated by algorithm [ algo : synchro ] converges in finite time to a team trajectory with minimum refresh time and latency .",
    "it should be observed that , differently from the team trajectories presented in the previous sections , algorithm [ algo : synchro ] contains a feedback procedure to synchronize the motion of the robots .",
    "our algorithm is independent of the initial configuration , and , as it is shown in the next section , it is robust to a certain class of robot failures .",
    "+    given the theoretical nature of this work , in this section we propose a simulation study to show the effectiveness of our procedures .",
    "for our simulations , we use the matlabsimulation environment , and we model the robots as holonomic vehicles of zero dimension .",
    "the communication edges and the motion paths are described by a given roadmap .",
    "consider the chain roadmap with @xmath295 viewpoints in fig .",
    "[ fig : simulation ] .",
    "suppose that @xmath296 robots are assigned to the patrolling task . in order to obtain a team trajectory with minimum refresh time ,",
    "an optimal @xmath296-partition of the roadmap is computed ( cf .",
    "[ fig : simulation ] ) . additionally , to obtain a minimum latency team trajectory , each robot",
    "is assigned to a different cluster , its initial position is chosen randomly inside its cluster , and its velocity is initialized randomly .",
    "the motion of each robot is then determined by algorithm [ algo : synchro ] .",
    "the resulting team trajectory is in fig .",
    "[ fig : trajectories ] , where the team of robots synchronize on a minimum refresh time and latency team trajectory after a finite transient .",
    ", the team trajectory obtained with algorithm [ algo : synchro ] is reported here .",
    "the dashed lines denote a communication among two neighboring robots . at time",
    "@xmath297 the robots have synchronized their motion , and from that moment up to time @xmath298 the team trajectory has minimum refresh time and latency . from time",
    "@xmath298 up to time @xmath299 , robot @xmath300 undergoes a temporary failure , causing all the other robots to lose synchronization .",
    "the team of robots synchronizes again when robot @xmath300 resume its motion . at time @xmath301 , the failure of robot @xmath300 is detected by the remaining robots , which compute and synchronize on a new partition.,title=\"fig : \" ] +    we now test the robustness of our synchronization procedure . as first case study , we consider a temporary stopping failure , in which a robot stops for a certain time interval .",
    "for instance , suppose that robot @xmath300 stops from time @xmath302 up to time @xmath303 ( cf .",
    "[ fig : trajectories ] ) .",
    "notice that , after the failure , each robot @xmath12 , with @xmath304 , gathers at @xmath305 , and each robot @xmath306 , with @xmath307 , gathers at @xmath308 waiting for a communication with the corresponding neighboring robot .",
    "as soon as robot @xmath300 resumes its functionalities , the team of robots recover the desired synchronization .",
    "notice that the transient failure of robot @xmath300 can be easily detected by its neighbors by means of a timer mechanism with a predefined threshold .    as a second case study",
    ", we let the robots actuation be affected by noise , so that the speed of the robots becomes a random variable with a certain distribution .",
    "precisely , let @xmath309 be the equation describing the dynamics of robot @xmath11 , where @xmath310 is a zero mean gaussian variable with variance @xmath311 @xmath312 $ ] .",
    "we let @xmath313 and we run @xmath314 simulations for each possible value of @xmath311 on the roadmap of fig .",
    "[ fig : simulation ] . the refresh time and the latency of the team trajectories obtained with algorithm [ algo : synchro ]",
    "are plotted in fig .",
    "[ refresh_error ] and in fig .",
    "[ latency_error ] , respectively , as a function of @xmath311 .",
    "note that the performance degrade gracefully with the noise magnitude .    as third and final case study",
    ", we consider the situation in which a robot definitively stops .",
    "the remaining robots need to compute a new optimal partition and to synchronize in order to guarantee an optimal patrolling of the environment .",
    "notice that for the computation of such a partition by algorithm [ algo : partition ] the chain graph and the number of the robots is required .",
    "suppose that the failure of the robot @xmath300 is detected at time @xmath315 by the well - behaving robots , and assume that each robot knows the chain roadmap and the number of operative robots .",
    "algorithm [ algo : partition ] and algorithm [ algo : synchro ] allow the team to synchronize on a new team trajectory with minimum refresh time and latency .",
    "notice that the initial and the final partitions do not coincide .",
    "the problem of designing minimum refresh time and latency team trajectories on a chain roadmap has been discussed . in this section",
    "we consider the more general cases of tree and cyclic roadmap , we characterize the computational complexity of determining optimal trajectories , and we describe two approximation methods with performance guarantees .",
    "the results we are going to present are intended for a team of more than one robot .",
    "indeed , if only one robot is assigned to the patrolling task , then a minimum refresh time trajectory follows from the computation of the shortest tour through the viewpoints , for which efficient approximation algorithms already exist @xcite .",
    "let @xmath316 denote an undirected , connected , and acyclic roadmap ( tree ) . recall that a vertex path is a sequence of vertices such that any pair of consecutive vertices in the sequence are adjacent .",
    "a tour is a vertex path in which the start and end vertices coincide , and in which every vertex of @xmath13 appears at least once in the sequence .",
    "a depth - first tour of @xmath13 is a tour that visits the vertices @xmath66 in a depth - first order @xcite .",
    "let dft@xmath317 denote the length of a depth first tour of @xmath13 .",
    "notice that the length of a depth - first tour of a connected tree equals twice the sum of the length of the edges of the tree , and that any depth - first tour is a shortest tour visiting all the vertices .",
    "we now show that , for the case of tree roadmap , the set of cyclic - based and partition - based trajectories described in @xcite does not contain , in general , a minimum refresh time trajectory .",
    "recall that in a cyclic - based strategy the robots travel at maximum speed and equally spaced along a minimum length tour visiting all the viewpoints .",
    "consider the tree roadmap of fig .",
    "[ tree_1 ] , and suppose that two robots are assigned to the patrolling task",
    ". clearly , the minimum refresh time is @xmath318 , while the refresh time of a cyclic strategy equals @xmath319 .",
    "consider now the tree roadmap in fig .",
    "[ tree_equal ] , where the edges have unit length , and assume that two robots are in charge of the patrolling task .",
    "observe that any partition of cardinality @xmath181 contains a chain of length @xmath181 , so that , since only one robot is assigned to each cluster , the minimum refresh time that can be obtained is @xmath320 .",
    "suppose , instead , that the robots visit the vertices of the roadmap as specified in table [ table : visiting_order ] , where @xmath321 denotes the position of a robot at time @xmath24 . since the refresh time of the proposed trajectory is @xmath7 , we conclude that neither the cyclic - based nor the partition - based strategy may lead to a minimum refresh time team trajectory on a tree roadmap .    [ cols=\"^,^,^,^,^,^,^,^,^\",options=\"header \" , ]     [ table : visiting_order ]    we now introduce some definitions .",
    "let @xmath18 be a team trajectory on the tree roadmap @xmath13 .",
    "we say that the edge @xmath322 is _ used _ by @xmath18 if there exists @xmath184 and @xmath323 ^ 2 $ ] such that @xmath324 and @xmath325 , and it is _ unused _ otherwise .",
    "note that , because in a tree there exists only one path connecting two vertices , the above condition ensures that the edge @xmath326 is traveled by the robot @xmath11 .",
    "let @xmath327 denote the set of unused edges , and let @xmath328 be the forest obtained from @xmath13 by removing the edges @xmath327 from @xmath329 , i.e. , the collection of vertex - disjoint subtrees @xmath330 , with @xmath331 , such that @xmath332 and @xmath333 , for each @xmath334 .",
    "let @xmath335 be the number of robots that visit at least one vertex of @xmath289 in the interval @xmath336 $ ] , and note that @xmath337 in a finite refresh time trajectory .",
    "let @xmath338 .",
    "notice that the same subtree collection can be associated with different team trajectories .",
    "we say that a team trajectory is _ efficient _ if its refresh time is the smallest among all the team trajectories associated with the same subtree collection .",
    "[ eff_team ] let @xmath339 be the subtree collection associated with the team trajectory @xmath18 on the tree roadmap @xmath13 , where @xmath340 , and @xmath338 .",
    "then , @xmath18 is efficient if @xmath341    let @xmath342 , and let @xmath335 be the number of robots assigned to @xmath289 .",
    "notice that the robots in @xmath289 travel , in total , at least @xmath343 to visit all the vertices .",
    "since the speed of the robots is bounded by @xmath49 , the smallest refresh time for the vertices of @xmath289 is @xmath344 .",
    "an efficient team trajectory , can be computed with the following procedure .",
    "see table [ table : visiting_order ] for an example .",
    "[ lemma_team ] let @xmath339 be a subtree collection of a tree roadmap , where @xmath340 , and @xmath338 .",
    "an efficient team trajectory is as follows : for each @xmath334 ,    1 .",
    "compute a depth - first tour @xmath345 of @xmath289 , 2 .",
    "equally space @xmath335 robots along @xmath345 , and 3 .",
    "move the robots clockwise at maximum speed on @xmath345 .",
    "since every vertex of @xmath346 appears at least once in a depth first tour @xmath345 of @xmath289 , and the robots move with maximum speed and equally spaced along @xmath345 , every vertex is visited at most every @xmath347 .",
    "the statement follows .",
    "let @xmath348 be the partition set of @xmath0 , i.e. , the set of all the sequences of integers whose sum is @xmath0 .",
    "the following problem is useful to characterize the complexity of designing minimum refresh time trajectories on a tree roadmap .",
    "[ prob : optimal_forest ] let @xmath13 be a tree roadmap and let @xmath0 be the number of robots . find a subtree collection @xmath339 that minimizes @xmath349 subject to @xmath350 and @xmath351 .",
    "[ equiv_prob ] for the case of a tree roadmap , the team refresh time problem and the optimal subtree collection problem are equivalent .    as a consequence of theorem",
    "[ eff_team ] , the minimum refresh time on a tree roadmap @xmath13 can be written as @xmath352 , where @xmath353 is a subtree collection of @xmath13 , and @xmath354 .",
    "it follows that a solution to problem [ prob : minrt ] can be derived in polynomial time from a solution to problem [ prob : optimal_forest ] by using the procedure described in lemma [ lemma_team ] .",
    "suppose now we have a solution to problem [ prob : minrt ] .",
    "then an optimal subtree collection follows from the identification of the unused edges .",
    "we conclude that the two optimization problems are equivalent .",
    "we now state our main result on the design of minimum refresh time team trajectory on a tree roadmap .",
    "[ complexity ] let @xmath13 be a tree roadmap with @xmath5 vertices , and let @xmath0 be the number of robots .",
    "a minimum refresh time team trajectory on @xmath13 can be computed in @xmath355 time .",
    "recall from @xcite that an optimal subtree collection can be computed in @xmath355 .",
    "then , by using lemma [ equiv_prob ] and lemma [ lemma_team ] , the claimed statement follows .    as a consequence of theorem [ complexity ] , the problem of designing minimum refresh time team trajectories on a tree roadmap is computationally _ easy _ for any finite number of robots . in our design procedure , we first compute an optimal subtree collection of the given tree , and then we schedule the robots trajectory according to lemma [ lemma_team ] .      in this section",
    "we propose two approximation methods for the team refresh time problem in the case of a cyclic , i.e. , not acyclic , roadmap .",
    "these solutions are obtained from a transformation of the cyclic roadmap into an acyclic roadmap .",
    "let @xmath17 , with @xmath356 , be an undirected and connected roadmap .",
    "note that there exists an open tour @xmath293 with at most @xmath357 edges that visits all the vertices .",
    "edges that visits all the vertices can be constructed starting from a leaf of a spanning tree of @xmath6 . ]",
    "we construct a chain roadmap @xmath358 from @xmath293 by doubling its repeated vertices and edges , so that @xmath358 has at most @xmath359 vertices and at most @xmath357 edges , and such that the length of the @xmath11-th edge of @xmath358 equals the length of the @xmath11-th edge of @xmath293 ( cf .",
    "[ fig : treechain ] ) .",
    "our first approximation method consists of applying algorithm [ algo : synchro ] to an optimal @xmath0-partition of @xmath358 .    [ thm : perf_ratio ] let @xmath6 be a connected roadmap , let @xmath5 be the number of vertices of @xmath6 , and let @xmath360 be ratio of the longest to the shortest length of the edges of @xmath6 . let @xmath62 be the minimum refresh time on @xmath6 .",
    "let @xmath293 be an open tour with @xmath357 edges that visits all the @xmath5 vertices , and let @xmath358 be the chain roadmap associated with @xmath293 .",
    "let @xmath361 be the minimum refresh time on @xmath358 .",
    "then @xmath362    let @xmath363 be the shortest length of the edges of @xmath6 , and note that the length of @xmath358 is upper bounded by @xmath364 .",
    "it follows that @xmath365 . since @xmath366 by assumption",
    ", some robots need to move along @xmath6 for all the viewpoints to be visited .",
    "because each robot can visit only a vertex at a time , at least @xmath367 steps are needed to visit all the vertices of @xmath6 , and therefore @xmath368 . by taking the ratio of the two quantities the statement follows .",
    "it should be noticed that , when @xmath360 grows , the performance of our procedure might degrade .",
    "for instance , suppose that the roadmap is as in fig .",
    "[ fig : ratio_inf ] , and suppose that @xmath320 robots are assigned to the patrolling task . as long as @xmath369 , a minimum refresh time strategy requires one robot to patrol the viewpoints @xmath370 , while the second , third , and fourth robot stay on the viewpoints @xmath371 , @xmath372 , and @xmath373 respectively .",
    "it follows that @xmath374 . on the other hand ,",
    "an optimal @xmath0-partition of any chain graph associated with a tour that visits all the viewpoints has dimension at least @xmath49 .",
    "consequently , the refresh time of the team trajectory obtained with algorithm [ algo : synchro ] equals @xmath181 , and the ratio @xmath375 grows proportionally to @xmath376 .",
    ", then the performance ratio @xmath377 grows with @xmath376.,title=\"fig : \" ] +    we next describe a polynomial time constant factor approximation algorithm for the minimum refresh time problem . given a roadmap @xmath17 and a positive integer @xmath378",
    ", we define a path cover of cardinality @xmath306 as the collection of paths @xmath379 such that @xmath380 .",
    "let the cost of a path equal the sum of the lengths of its edges .",
    "the min - max path cover problem asks for a minimum cost path cover for the input graph , where the cost of a cover equals the maximum cost of a path in the cover .",
    "the following result is known .",
    "[ result_path_cover ] there exists a @xmath320-approximation polynomial algorithm for the _ np - hard _ min - max path cover problem .    following theorem [ result_path_cover ] , given a graph @xmath6 , there exists a polynomial time algorithm that computes a path cover of @xmath6 with cost at most @xmath320 times greater than the cost of any path cover of @xmath6 .",
    "we now state our approximation result for the _ np - hard _ team refresh time problem .",
    "[ 4_approx ] there exists an @xmath1-approximation polynomial algorithm for the _ np - hard _ team refresh time problem .",
    "let @xmath381 be a @xmath320-approximation path cover of the graph @xmath6 .",
    "note that the length of each path is within @xmath382 .",
    "indeed , in a minimum refresh time team trajectory starting at time @xmath50 and with unitary velocity , every vertex is visited within time @xmath62 .",
    "let @xmath18 be a team trajectory obtained by letting robot @xmath11 sweep at maximum speed the path @xmath383 . clearly , @xmath384 .",
    "because of theorem [ result_path_cover ] , the team trajectory @xmath18 can be computed in polynomial time .",
    "robots for the patrolling of a part of the ucsb campus .",
    "the viewpoints ( red circles ) are chosen so as to provide sensor coverage of the whole area .",
    "for the design of the patrolling trajectory , a roadmap is first constructed as described in section [ sec : prob_set ] .",
    "then , a path covering of cardinality @xmath300 is computed with the procedure in @xcite , and each robot is assigned a different path . finally , the trajectory of each robot consists in sweeping at maximum speed the tour obtained by shortcutting the assigned path .",
    "the refresh time of the proposed team trajectory is proven to be within a factor of @xmath1 of the minimum refresh time for the given roadmap . ]    following lemma [ 4_approx ] , for any given roadmap and any number of robots , a team trajectory with refresh time within a factor of @xmath1 of the optimal refresh time can be constructed by computing a path covering of the roadmap , and by assigning a different path to each robot .",
    "an example is in fig .",
    "[ fig : path_cover ] , a movie of which is included in the multimedia material .    several existing heuristics can be used to improve upon the trajectories in fig .",
    "[ fig : path_cover ] .",
    "for instance , since the robots move in a metric space , shortcutting techniques may be applied @xcite .",
    "because these heuristics do not guarantee an improvement of the optimality gap of our trajectories , they are not considered in this work , and they are left as the subject of future investigation .",
    "the design of team trajectories to cooperatively patrol an environment has been discussed . after defining the problem and the performance criteria , we analyze the computational complexity of the design problem as a function of the shape of the environment to be patrolled . for the case of a chain environment , we describe a polynomial algorithm to compute minimum refresh time and latency team trajectories . for the case of a tree environment ,",
    "under the technical assumption of a constant number of robots , we identify a polynomial time algorithm to compute minimum refresh time team trajectories .",
    "finally , the general case of cyclic environment is shown to be _ np - hard _ , and two approximation algorithms with performance guarantees have been proposed .",
    "interesting aspects requiring further investigation include a throughout study of the latency optimization problem for cyclic roadmaps , the development of more efficient approximation algorithms , and the introduction of a more general communication framework , in which the robots are allowed to communicate while traveling the edges of the roadmap .",
    "the study of average performance criteria and the extension to dynamically changing environments are also of interest .",
    "finally , an hardware implementation of our algorithms would further strengthen our theoretical findings .",
    "y.  elmaliach , a.  shiloni , and g.  a. kaminka , `` a realistic model of frequency - based multi - robot polyline patrolling , '' in _ international conference on autonomous agents _ , estoril , portugal , may 2008 , pp .",
    "6370 .",
    "m.  batalin and g.  s. sukhatme , `` the design and analysis of an efficient local algorithm for coverage and exploration based on sensor network deployment , '' _ ieee transactions on robotics _ , vol .",
    "23 , no .  4 , pp . 661675 , 2007 .",
    "f.  amigoni , n.  basilico , and n.  gatti , `` finding the optimal strategies for robotic patrolling with adversaries in topologically - represented environments , '' in _ ieee int . conf .  on robotics and automation _ ,",
    "kobe , japan , may 2009 , pp .",
    "20052010 .",
    "a.  marino , l.  parker , g.  antonelli , and f.  caccavale , `` behavioral control for multi - robot perimeter patrol : a finite state automata approach , '' in _ ieee int .",
    "conf .  on robotics and automation",
    "_ , kobe , japan , may 2009 , pp .",
    "33503355 .",
    "a.  almeida , g.  ramalho , h.  santana , p.  tedesco , t.  menezes , v.  corruble , and y.  chevaleyre , `` recent advances on multi - agent patrolling , '' in _ advances in artificial intelligence - sbia 2004_.1em plus 0.5em minus 0.4emspringer , 2004 , vol .",
    "3171 , pp .",
    "474483 .",
    "a.  machado , g.  ramalho , j.  d. zucker , and a.  drogoul , `` multi - agent patrolling : an empirical analysis of alternative architectures , '' in _ multi - agent - based simulation ii _",
    "lecture notes in computer science.1em plus 0.5em minus 0.4emspringer , 2003 , pp . 155170 .              i.  a. wagner , m.  lindenbaum , and a.  m. bruckstein , `` efficiently searching a graph by a smell - oriented vertex process , '' _ annals of mathematics and artificial intelligence _",
    "24 , no .  1 ,",
    "211223 , 1998 .          k.  j. obermeyer , a.  ganguli , and f.  bullo , `` multi - agent deployment for visibility coverage in polygonal environments with holes , '' _ international journal on robust and nonlinear control _ , sep .",
    "2010 , to appear .",
    "i.  a. wagner , m.  lindenbaum , and a.  m. bruckstein , `` mac vs. pc : determinism and randomness as complementary approaches to robotic exploration of continuous unknown domains , '' _ international journal of robotics research _ , vol .",
    "19 , no .  1 ,",
    "1231 , 2000 .",
    "a.  franchi , l.  freda , g.  oriolo , and m.  vendittelli , `` the sensor - based random graph method for cooperative robot exploration , '' _ ieee / asme transactions on mechatronics _ ,",
    "14 , no .  2 ,",
    "pp . 163175 , 2009 ."
  ],
  "abstract_text": [
    "<S> the subject of this work is the patrolling of an environment with the aid of a team of autonomous agents . </S>",
    "<S> we consider both the design of open - loop trajectories with optimal properties , and of distributed control laws converging to optimal trajectories . as performance criteria , </S>",
    "<S> the _ refresh time _ and the _ latency _ are considered , i.e. , respectively , time gap between any two visits of the same region , and the time necessary to inform every agent about an event occurred in the environment . </S>",
    "<S> we associate a graph with the environment , and we study separately the case of a chain , tree , and cyclic graph . for the case of chain graph , we first describe a minimum refresh time and latency team trajectory , and we propose a polynomial time algorithm for its computation . </S>",
    "<S> then , we describe a distributed procedure that steers the robots toward an optimal trajectory . for the case of tree graph , </S>",
    "<S> a polynomial time algorithm is developed for the minimum refresh time problem , under the technical assumption of a constant number of robots involved in the patrolling task . </S>",
    "<S> finally , we show that the design of a minimum refresh time trajectory for a cyclic graph is _ np - hard _ , and we develop a constant factor approximation algorithm . </S>"
  ]
}