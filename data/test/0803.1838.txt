{
  "article_text": [
    "a typical scientific research project requires a variety of computational tasks to be performed . at the very heart of every investigation",
    "is the generation of data to test hypotheses .",
    "an experimental physicist builds instruments to collect light scattering data ; a crystallographer collects x - ray diffraction data ; a biologist collects fluorescence intensity data for reporter genes , or dna sequence data for these genes ; and a computational researcher writes programs to generate simulation data .",
    "all of these scientists use computer programs to control instruments or perform simulations to collect and manage data in an electronic format .",
    "once data is collected , the next task is to analyze it in the context of hypothesis - driven models that help them understand the phenomenon they are studying . in the case of light , or x - ray scattering data , there is a well - proven physical theory that is used to process the data and calculate the observed structure function of the material being studied @xcite .",
    "this structure function is then compared to predictions made by the hypotheses begin tested . in the case of biological reporter gene data , light intensity is matched up with phenotypic traits or dna sequences , and statistically analyzed for trends that might explain the observed patterns .",
    "as these examples illustrate , across science , the original raw data of each investigation is extensively processed by computational programs in an effort to understand the underlying phenomena .",
    "visualization tools to create a variety of scientific plots are often a preferred tool for both troubleshooting ongoing experiments , and creating publication - quality scientific plots and charts . these plots and charts",
    "are often the final product of a scientific investigation in the form of data - rich graphics that demonstrate the truth of a hypothesis compared to its alternatives @xcite .",
    "unfortunately , all too often scientists resort to a grab - bag of tools to perform these varied computational tasks . for physicists and theoretical chemists ,",
    "it is common to use c or fortran to generate simulation data , and c code is used to control experimental apparatus ; for biologists , perl is the language of choice to manipulate dna sequence data @xcite .",
    "data analysis is performed in separate , external software packages such as matlab or mathematica for equation solving @xcite , or stata , spss or r for statistical calculations @xcite .",
    "furthermore , separate data visualization packages can be used , making the scientific programming toolset extremely varied .",
    "such a mixed bag of tools is an inadequate solution for a variety of reasons . from a computational perspective",
    ", most of these tools can not be pipelined easily which necessitates many manual steps or excessive glue code that most scientists are not trained to write .",
    "far more important than just an inconvenience associated with gluing these tools together is the extreme burden placed on the scientist in terms of data management .",
    "in complicated systems , there are often a plethora of different data files in several different formats residing at many different locations .",
    "most tools do not produce adequate metadata for these files , and scientists typically fall back on cryptic file naming schemes to indicate what type of data the files contain and how it was generated .",
    "such complications can easily lead to mistakes .",
    "this in turn provides poor at best data provenance when it is in fact of utmost importance in scientific studies where data integrity is the foundation of every conclusion reached and every fact established .",
    "furthermore , when data files are manually moved around from tool to tool , it is not clear if an error is due to program error , or human error in using the wrong file .",
    "analyses can only be repeated by following work flows that have to be manually recorded in a paper or electronic lab notebook .",
    "this practice makes steps easily forgotten , and hard to pass on to future generations of scientists , or current peers trying to reproduce scientific results .    the python programming language and associated community tools",
    "@xcite can help scientists overcome some of these problems by providing a general scientific programming platform that allows scientists to generate , analyze , visualize and manage their data within the same computational framework .",
    "python can be used to generate simulation data , or control instrumentation to capture data .",
    "data analysis can be accomplished in the same way , and there are graphics libraries that can produce scientific charts and graphs .",
    "furthermore python code can be used to glue all of these python solutions together so that visualization code resides alongside the code that generates the data it is applied to .",
    "this allows streamlined generation of data and its analysis , which makes data management feasible .",
    "most importantly , such a uniform tool set allows the scientist to record the steps used in data work flows to be written down in python code itself , allowing automatic provenance tracking .    in this paper",
    ", we outline a recent comparative genomics case study where python and associated community libraries were used as a complete scientific programming platform .",
    "we introduce several specific python libraries and tools , and how they were used to facilitate input of standardized biological data , create scientific plots , and provide solutions to speed bottle - necks in the code . throughout",
    ", we provide detailed tutorial - style examples of how these tools were used , and point to resources for further reading on these topics .",
    "we conclude with ideas about how python promotes good scientific programing practices , and tips for scientists interested in learning more about python .",
    ".... locus        nc_001416               48502 bp     dna      linear    phg 28-nov-2007 definition   enterobacteria phage lambda , complete genome .",
    "accession    nc_001416 version      nc_001416.1   gi:9626243 project      genomeproject:14204 keywords     .",
    "source       enterobacteria phage lambda    organism   enterobacteria phage lambda              viruses ; dsdna viruses , no rna stage ; caudovirales ; siphoviridae ;              lambda - like viruses .",
    "reference    1   ( sites )    authors    chen , c.y . and richardson , j.p .",
    "title      sequence elements essential for rho - dependent transcription              termination at lambda tr1    journal    j. biol .",
    "( 23 ) , 11292 - 11299 ( 1987 )     pubmed    3038914 ... features              location / qualifiers       source           1 .. 48502                       /organism=\"enterobacteria phage lambda \"                       /mol_type=\"genomic dna \"                       /specific_host=\"escherichia coli \"                       /db_xref=\"taxon:10710 \"",
    "gene             191 .. 736                       /gene=\"nu1 \"                       /locus_tag=\"lambdap01 \"                       /db_xref=\"geneid:2703523 \"       cds              191 .. 736                       /gene=\"nu1 \"                       /locus_tag=\"lambdap01 \"                       /codon_start=1                       /transl_table=11",
    "/product=\"dna packaging protein \"                       /protein_id=\"np_040580.1 \"                       /db_xref=\"gi:9626244 \"                       /db_xref=\"geneid:2703523 \"                       /translation=\"mevnkkqladifgasirtiqnwqeqgmpvlrgggkgnevlydsa                       avikwyaerdaeieneklrreveelrqaseadlqpgtieyerhrltraqadaqelkna                       rdsaevvetafctfvlsriageiasildglplsvqrrfpelenrhvdflkrdiikamn                       kaaaldelipgllseyieqsg \" ... origin                1 gggcggcgac ctcgcgggtt ttcgctattt atgaaaattt tccggtttaa ggcgtttccg         61 ttcttcttcg tcataactta atgtttttat ttaaaatacc ctctgaaaag aaaggaaacg        121 acaggtgctg aaagcgaggc tttttggcct ctgtcgtttc ctttctctgt ttttgtccgt        181 ggaatgaaca atggaagtca acaaaaagca gctggctgac attttcggtg cgagtatccg        241 taccattcag aactggcagg aacagggaat gcccgttctg cgaggcggtg gcaagggtaa        301 tgaggtgctt tatgactctg ccgccgtcat aaaatggtat gccgaaaggg atgctgaaat        361 tgagaacgaa aagctgcgcc gggaggttga agaactgcgg caggccagcg aggcagatct        421 ccagccagga actattgagt acgaacgcca tcgacttacg cgtgcgcagg ccgacgcaca ...",
    "....    recently we performed a comparative genomics study of the genomic dna sequences of the 74 sequenced bacteriophages that infect _ e. coli _ , _",
    "p. aeruginosa _ , or _ l. lactis _ @xcite .",
    "bacteriophages are viruses that infect bacteria",
    ". the dna sequences of these bacteriophages contain important clues as to how the relationship with their host has shaped their evolution .",
    "each virus that we examined has a dna genome that is a long strand of four nucleotides called adenine ( a ) , threonine ( t ) , cytosine ( c ) , and guanine ( g ) .",
    "the specific sequences of a s , t s , c s and g s encode for proteins that the virus uses to take over the host bacteria and create more copies of itself . each protein is encoded in a specific region of the genomic dna called a gene .",
    "proteins are made up of linear strings of 20 amino acids .",
    "there are 4 bases encoding for 20 amino acids , and the translation table that governs the encoding , called the genetic code , is comprised of 3 base triplets called codons .",
    "each codon encodes a specific amino acid .",
    "since there are 64 possible codons , and only 20 amino acids , there is a large degeneracy in the genetic code . for more information on the genetic code , and the biological process of converting dna sequences into proteins ,",
    "see @xcite .",
    "because of this degeneracy , each protein can be ` spelled ' as a sequence of codons in many possible ways .",
    "the particular sequence of codons used to spell a given protein in a gene is called the gene s ` codon usage ' . as we found in @xcite , bacteriophages genomes favor certain codon spellings of genes over the other possibilites .",
    "the primary question of our investigation was - does the observed spellings of the bacteriophage genome shed light onto the relationship between the bacteriophage and its host @xcite ?    to address this question , we examined the codon usage of the protein coding genes in these bacteriophages for any non - random patterns compared to all the possible spellings , and performed statistical tests to associate these patterns with certain aspects about the proteins .",
    "the computational requirements of this study included :    * downloading and parsing the genome files for viruses from genbank in order to get the genomic dna sequence , the gene regions and annotations : genbank @xcite is maintained by the national center of biotechnology information ( ncbi ) , and is a data wharehouse of freely available dna sequences .",
    "for each virus , we needed to obtain the genomic dna sequence , the parts of the genome that code for genes , and the annotated function of these genes .",
    "figure 1 displays this information for lambda phage , a well - studied bacteropphage that infects _ e. coli _",
    "@xcite , in genbank format , obtained from ncbi .",
    "once these files were downloaded and stored , they were parsed for the required information . * storing the genomic information : the parsed information was stored in a custom genome python class which also included methods for retrieving the dna sequences of specific genes . *",
    "drawing random genomes to compare to the sequenced genome : for each genome , we drew random genomes according to the degeneracy rules of the genetic code so that each random genome would theoretically encode the same proteins as the sequenced genome .",
    "these genomes were then visually compared to the sequenced genome through zero - mean cumulative sum plots discussed below .",
    "* visualize the comparisons through ` genome landscape ' plots : genome landscapes are zero - mean cumulative sums , and are useful visual aids when comparing nucleotide frequency properties of the genomes they are constructed from ( see @xcite for more information ) .",
    "genome landscapes were computed for both the sequenced genome , and each drawn genome .",
    "the genome landscape of the sequenced genome was compared to the distribution of genome landscapes generated from the random genomes to detect regions of the genomes that have extremely non - random patterns in codon usage .",
    "* statistically analyzing the non - random regions with annotation and host information : to understand the observed trends , we performed analysis of variance ( anova ) @xcite analysis to detect correlations between protein function annotation or host lifestyle information with these regions .",
    "python was used in every aspect of this computational work flow .",
    "below we discuss in more detail how python was used in several of these areas specifically , and provide illustrative tutorial - style examples . for more information on the details of the computational work flow , and the biological hypotheses we tested ,",
    "see @xcite . for specific details on the versions of software used in this paper , and links to free downloads , see materials and methods .",
    "biopython is an open - source suite of bioinfomatics tools for the python language @xcite .",
    "the suite is comprehensive in scope , and offers python modules and routines to parse bio - database files , facilitate the computation of alignments between biological sequences ( dna and protein ) , interact with biological web - services such as those provided by ncbi , and examine protein crystallographic data to name a few .    in this project ,",
    "biopython was used both to download and parse genomic viral dna sequence files from the ncbi genbank database @xcite as outlined in listing [ genbank_code ] .    .... # genbank.py - utilities for downloading and parsing genbank files    from bio import genbank # ( 1 ) from bio import seqio    def download(accession_list ) :      ' ' ' download and save all genbank records in accession_list . ' ''           try :          handle = genbank.download_many(accession_list ) # ( 2 )      except :          print \" are you connected to the internet ? \"          raise           genbank_strings = handle.read().split('//\\n ' ) # ( 3 )      for i in range(len(accession_list ) ) :            # save raw file as .gb",
    "gb_file_name = accession_list[i]+'.gb '                 f = open(gb_file_name,'w ' )          f.write(genbank_strings[i ] ) # ( 4 )          f.write('//\\n ' )          f.close ( )     def parse(accession_list ) :      ' ' ' parse all records in accession_list . ' ''           parsed = [ ]      for accession_number in accession_list :          gb_file_name = accession_number+'.gb '          print ' parsing ... ' , accession_number          try :              gb_file = file(gb_file_name,'r ' )          except ioerror :              print ' is the file % s downloaded ? ' % gb_file_name              raise                   gb_parsed_record = seqio.parse(gb_file,\"genbank\").next ( ) # ( 5 )          gb_file.close ( )                   print gb_parsed_record.id   # ( 6 )          print gb_parsed_record.seq                   parsed.append(gb_parsed_record ) # ( 7 )           return parsed     import genbank # ( 8) genbank.download(['nc_001416 ' ] ) genbank.parse(['nc_001416 ' ] )     # ( 1 ) the biopython module is called bio .   the bio.genbank module is used to download records from genbank , and the bio.seqio module provides a general interface for parsing a variety of biological formats , including genbank .",
    "# ( 2 ) the bio.genbank.download\\_many method is used in the genbank.download method to download genbank records over the internet .",
    "it takes a list of genbank accession numbers identifying the records to be downloaded .",
    "# ( 3 ) genbank records are separated by the character string \\verb=//\\n=.   here we manually separate genbank files that are part of the same character string .",
    "# ( 4 ) when we save the genbank records as individual files to disk , we include the \\verb=//\\n= separator again .",
    "# ( 5 ) the bio.seqio.parse method can parse a variety of formats .",
    "here we use it to parse the genbank files on our local disk using the \" genbank \" format parameter .",
    "the method returns a generator , who 's next ( ) method is used to retrieve an object representing the parsed file .",
    "# ( 6 ) the object representing the parsed genbank file has a variety of methods to extract the record i d and sequence .",
    "see listing \\ref{genome_code } for more details .",
    "# ( 7 ) the genbank.parse method returns a listed of parsed objects , one for each input sequence file .",
    "# ( 8) to run the code in genbank.py , biopython 1.44 must first be installed ( see materials and methods ) .",
    "executing the following code should create a file called ` nc\\_001416.gb ' on the local disk ( see figure \\ref{lambda - genbank } ) , as well as produce the following output :    ' '' parsing ...",
    "nc_001416 nc_001416.1 seq('gggcggcgacctcgcgggttttcgctatttatgaaaattttccggtttaaggcgtttccg ... ' , iupacambiguousdna ( ) ) ' '' ....    the benefits of using biopython in this project were several including :    1 .",
    "not having to write or maintain this code ourselves .",
    "this is an important point as the number of web - available databases and services grows .",
    "these often change rapidly , and require rigorous maintenance to keep up with tweaks to api s and formats - a monumental task that is completed by an international group of volunteers for the biopython project .",
    "2 .   the biopython parsing code can be wrapped in custom classes that make sense for a particular project .",
    "listing [ genome_code ] illustrates the latter by outlining a custom genome class used in this project to store the location of coding sequences for genes ( cds_seq ) .    ....",
    "# genome.py - a custom genome class which wraps biopython parsing code    import genbank # ( 1 ) from bio import seq from bio.alphabet import iupac    class genome(object ) :      \" \" \" genome - representing a genomic dna sequence with genes           genome.genes[i ] returns the cds sequences for each gene i. \" \" \"           def _ _ init__(self ,",
    "accession_number ) :                   genbank.download([accession_number ] ) # ( 2 )          self.parsed_genbank = genbank.parse([accession_number])[0 ]                   self.genes = [ ]                   self._parse_genes ( )                    def _",
    "parse_genes(self ) :          \" \" \" parse out the cds sequence for each gene . \" \" \"                   for feature in self.parsed\\_genbank.features : # ( 3 )              if feature.type = = ' cds ' :                                   # build up a list of ( start , end ) tuples that will                  # be used to slice the sequence in self.parsed\\_genbank.seq                  #                  # biopython locations are zero - based so can be directly                  # used in sequence splicing                    locations = [ ]                  if len(feature.sub_features ) : # ( 4 )                      # if there are sub\\_features , then this gene is made up                      # of multiple parts .   store the start and end positins                      # for each part .                      for sf in feature.sub_features :",
    "locations.append((sf.location.start.position ,                                            sf.location.end.position ) )                  else :                      # this gene is made up of one part .",
    "store its start and                       # end position .",
    "locations.append((feature.location.start.position ,                                        feature.location.end.position ) )                     # store the joined sequence and nucleotide indices forming                  # the cds .",
    "seq = '' # ( 5 )                  for begin , end in locations :                      seq + = self.parsed_genbank.seq[begin:end].tostring ( )                    # reverse complement the sequence if the cds is on                  # the minus strand                    if feature.strand = = -1 :   # ( 6 )                    seq_obj = seq.seq(seq,iupac.ambiguous_dna )                    seq = seq_obj.reverse_complement().tostring ( )                    # append the gene sequence                  self.genes.append(seq ) # ( 7 )    # ( 1 ) here we import the genbank module outlined in listing \\ref{genbank_code } , along with two more biopython modules .",
    "the bio.seq module has methods for creating dna sequence objects used later in the code , and the bio.alphabet module contains definitions for the types of sequences to be used .",
    "in particular we use the bio.alphabet.iupac definitions .",
    "# ( 2 ) we use the genbank methods to download and parse the genbank record for the input accession number .",
    "# ( 3 ) the parsed object stores the different parts of the genbank file as a list of features .",
    "each feature has a type , and in this case , we are looking for features with type ' cds ' , which stores the coding sequence of a gene .",
    "# ( 4 ) for many organisms , genes are not contiguous stretches of dna , but rather are composed of several parts .   for genbank files ,",
    "this is indicated by a feature having sub\\_features .",
    "here we gather the start and end positions of all sub features , and store them in a list of 2-tuples .   in the case",
    "that the gene is a contiguous piece of dna , there is only one element in this list .",
    "# ( 5 ) once the start and end positions of each piece of the gene are obtained , we use them to slice the seq of the parsed\\_genbank object , and collect the concatenated sequence into a string .",
    "# ( 6 ) since dna has polarity , there is a difference between a gene that is encoded on the top , plus strand , and the bottom , minus strand .",
    "the strand that the gene is encoded in is stored in feature.strand .",
    "if the strand is the minus strand , we need to reverse compliment the sequence to get the actual coding sequence of the gene .",
    "to do this we use the bio.seq module to first build a sequence , then use the reverse\\_complement ( ) method to return the reverse compliment .",
    "# ( 7 ) we store each gene as an element of the genome.genes list .",
    "the cds of the ith gene is then retrievable through genome.genes[i ] . ....    for a more detailed introduction to the plethora of biopython features , as well as introductory information into python",
    "see @xcite .",
    "matplotlib @xcite is a suite of open - source python modules that provide a framework for creating scientific plots similar to the matlab @xcite graphical tools . in this project ,",
    "matplotlib was used to create genome landscape plots both to have a quick look at data as it was generated , and to produce publication quality figures .",
    "genome landscapes are cumulative sums of a zero - mean sequence of numbers , and are useful visualization tools for understanding the distribution of nucleotides across a genome ( see @xcite for more information ) .",
    "listing [ landscape_code ] outlines how matplotlib was used to quickly generate graphics to test raw simulation data as it was being generated .    .... # landscape.py - plotting a zero - mean cumulative sum of numbers    import fileinput # ( 1 ) import numpy from matplotlib import pylab    def plot(filename ) :      \" \" \" read single - column numbers in filename and plot zero - mean cumulative sum \" \" \"           numbers = [ ]      for line in fileinput.input(filename ) : # ( 2 )          numbers.append(float(line.split('\\n')[0 ] ) )           mean = numpy.mean(numbers ) # ( 3 )      cumulative_sum = numpy.cumsum([number - mean for number in numbers ] )           pylab.plot(cumulative_sum[0::10],'k- ' ) # ( 4 )      pylab.xlabel('i ' )      pylab.title('zero mean cumulative sum ' )           pylab.savefig(filename+'.png ' ) # ( 5 )      pylab.show ( )    # ( 1 ) we use several python community modules to plot the zero - mean cumulative sum .   as part of the python standard library",
    ", fileinput can be used as a quick an easy solution to reading in a file containing a column of entries .",
    "numpy is a comprehensive python project aimed at providing numerical routines for scientific applications \\cite{numpy}.   finally we import the matplotlib.pylab module which provides a matlab - like plotting environment .    # ( 2 ) here we use fileinput to read successive lines of the input file , which takes care of opening and closing the input file automatically .",
    "notice that we split each line by the newline character \\verb=\\n= , and take everything to the left of it , assuming that each line contains a single number .",
    "# ( 3 ) the numpy module provides many convenient methods such as mean to compute the \\verb = mean= of a list of numbers , and \\verb = cumsum= which computes the cumulative sum .   to shift the input numbers by the mean",
    ", we use a python list comprehension to subtract the mean from each number , and then input the shifted list to numpy.cumsum .",
    "# ( 4 ) the pylab module presents a matlab - like plotting environment .",
    "here we use several methods to create a basic line plot with an xlabel and title .",
    "# ( 5 ) to view the plot , we use pylab.show ( ) , after we have saved the figure as a png file using pylab.savefig .",
    "the following script uses the genome class outlined in listing \\ref{genome_code } , along with the landscape class to plot the gc - landscape for the lambda phage genome .",
    "the genome class is used to download and parse the genbank file for lambda phage .   each gene sequence",
    "is then scanned for ' g ' or ' c ' nucleotides .",
    "for every ' g ' or ' c ' nucleotide encountered , a 1 is appended to the list gc ; for every ' a ' or ' t ' encountered , a 0 is appended .",
    "this sequence of 1 's and 0 's representing the gc - content of the lambda phage genome is saved in a file , and input into the landscape.plot method .",
    "a plot corresponding to executing this script is shown in figure \\ref{lambda - landscape}.    import genome , landscape lambda_phage = genome.genome('nc_001416 ' ) gc = [ ] for gene_sequence in lambda_phage.genes :      for nucleotide in gene_sequence :          if nucleotide = = ' g ' or nucleotide = = ' c ' :              gc.append(1 )          else :              gc.append(0 )    f = file('nc_001416.gc','w ' ) for num in gc :      f.write('%i\\n ' % num ) f.close ( )    landscape.plot('nc_001416.gc ' ) ....    .[lambda - landscape ] ]    matplotlib was also used to make custom graphics classes for creating publication - quality plots . to do this",
    ", we used the object oriented interface to matplotlib plotting routines to inherit funcionality in our classes .",
    "the benefits of using matplotlib in this project were several :    1 .",
    "the code that produced the scientific plots resided alongside the code that produced the underlying data for the plots .",
    "the importance of this can not be stressed enough as having the code structured in this way removed many opportunities for human error involved in manually shuffling raw data files into separate graphical programs .",
    "moreover , the instructions for producing the plots from the underlying raw data was _ python code _ , which not only described these instructions , but could be executed to produce the plots .",
    "imagine instead the often practiced use of spreadsheets to create plots from raw data - in these spreadsheets , formulas are hidden by the results of the calculations , and it is often very confusing to construct a picture of the computational flow used to produce a specific plot .",
    "2 .   having the graphics instructions in code allowed for quick trouble shooting when creating the plots , or evaluating raw data as it was generated .",
    "complicated plots were easily regenerated by tweaking the code for particular graphical plots .",
    "the simple wrapper and interface generator ( swig ) @xcite , is an easy - to - use system for extending python . in particular",
    ", it allows the speed up of selected parts of an application by writing these routines in another more low - level language such as c or c++ .",
    "furthermore , swig implements the use of this low - level code using the standard python module importing structure .",
    "this allows developers to first prototype code in python , then re - implement the code in c and swig causing _ no change _ in the python code that uses the re - implemented module .",
    "this project relied heavily on drawing random numbers from an input discrete distribution .",
    "for example , we often needed to draw a sequence of a s , t s , c s or g s corresponding to the nucleotide sequence of the genome , but preserving the genomic distribution of these four nucleotide bases . for some viruses ,",
    "the distribution might look like : @xmath0 , @xmath1 , @xmath2 , @xmath3 , with @xmath4 .",
    "listing [ random_python_code ] illustrates the outline of a python module that has methods to draw numbers according to a discrete distribution with 4 possible outcomes .",
    "it also illustrates how this module could be implemented in c , and included in a python module with swig .",
    ".... # module discrete\\_distribution.py - drawing numbers from a discrete probability distribution    import random # ( 1 )    def seed ( ) : # ( 2 )      random.seed ( )       def draw(distribution ) : # ( 3 )    ' ' ' drawing an index according to distribution .",
    "distribution is a list of floating point numbers ,    one for each index number , representing the probability     of drawing that index number .",
    "example : [ 0.5 , 0.5 ] would represent equal probabilities    of returning a 0 or 1 .    ' ''    sum = 0 # ( 4 )    r = random.random ( )    for i in range(0,len(distribution ) ) :        sum + = distribution[i ]        if r < sum :            return i     import discrete_distribution # ( 5 ) discrete_distribution.seed ( ) print sum([discrete_distribution.draw([0.2,0.2,0.3,0.3 ] ) for x in range(10000)])/10000 .",
    "# ( 1 ) import the random number generator .",
    "# ( 2 ) we use the discrete\\_distribution.seed ( ) method to seed the random number generator .   if no arguments are supplied to random.seed ( ) , the system time is used to seed the number generator \\cite{python - random}.    # ( 3 ) the draw function takes an argument distribution , which is a list of floating point numbers .",
    "# ( 4 ) the algorithm for drawing a number according to a discrete distribution is to draw a number , r , from a uniform distribution on [ 0,1 ] ; compute a cumulative sum of the probabilities in the discrete distribution for successive indices of the distribution ; when r is less than this cumulative sum , return the index that the cumulative sum is at .",
    "# ( 5 ) to test this code , plug in a distribution [ 0.2,0.2,0.3,0.3 ] , draw 10000 numbers from this distribution , and compute the mean , which theoretically should be $ 0 * 0.2 + 1 * 0.2 + 2 * 0.3 + 3 * 0.3 = 1.7$.   in this case , when this code was executed , the result $ 1.7013 $ was returned . ....    in listing [ random_c_code ] , we implement this routine using c , and use swig to create a python module of the c implementation .",
    "....    //c\\_discrete\\_distribution.c - a c implementation of the discrete\\_distribution.py module    # include \" stdlib.h \" // ( 1 ) # include \" stdio.h \" # include \" time.h \"    void seed ( ) {      srand((unsigned ) time(null ) * getpid ( ) ) ;   }    int draw(float distribution[4 ] ) { // ( 2 )      float r= ( ( float ) rand ( ) / ( float ) rand_max ) ;      float sum = 0 . ;      int i = 0 ;      for(i = 0 ; i < 4 ; i++ ) {          sum + = distribution[i ] ;    if ( r lt sum ) {              return i ;    }      } }    // ( 1 ) here we define two functions , seed and draw , which correspond to the python methods in discrete\\_distribution.py .   note that the python implementation of discrete\\_distribution.draw ( ) worked with distributions of arbitrary numbers of elements .",
    "for simplicity , we are restricting the c implementation to work with distributions of length 4 .    //",
    "( 2 ) the draw routine is implemented using the same algorithm as in the python implementation .   for simplicity",
    ", we use the c standard library rand ( ) routine , although there are more advanced random number generators that would be more appropriate for scientific applications \\cite{random}. ( note that the ` lt ' symbol should be replaced by ` < ' when executing the code . )    //",
    "c\\_discrete\\_distribution.i - a swig interface file for the c\\_discrete\\_distribution module //",
    "( 3 )    % module c_discrete_distribution // ( 4 )    //",
    "grab a 4 element array as a python 4-list // ( 5 ) % typemap(in ) float[4](float temp[4 ] ) {    // temp[4 ] becomes a local variable    int i ;    if ( pylist_check($input ) ) {      pyobject * input_to_tuple = pylist_astuple($input ) ;      if ( ! pyarg_parsetuple(input_to_tuple,\"ffff\",temp , temp+1,temp+2,temp+3 ) ) {        pyerr_setstring(pyexc_typeerror,\"tuple must have 4 elements \" ) ;        return null ;      }      $ 1 = & temp[0 ] ;    } else {      pyerr_setstring(pyexc_typeerror,\"expected a tuple . \" ) ;      return null ;    } }    void seed ( ) ; // ( 6 ) int draw(float distribution[4 ] ) ;      // ( 3 ) to use swig , we create a swig interface file that describes how to translate python inputs to the c code , and c outputs to the python code .    //",
    "( 4 ) swig directives are preceded by the \\% sign .",
    "here we declare that the module we are going to make is called c\\_discrete\\_distribution .   in general , the module name , the c source name , and the interface file name should all be the same outside of the file extension .    //",
    "( 5 ) swig will automatically handle the conversion of many data - types from python to c and c to python .   for illustration purposes , we create an explicit typemap which converts a 4-element python list into a 4 element c list of floats .",
    "since we are using the typemap(in ) directive , swig knows that we are converting python to c.   the rest of the code checks that a list was passed from python to c , and the list has 4 elements .",
    "if these conditions are not met , python errors are thrown .",
    "if they are met , an array of floats called temp is called , and passed to c.   this conversion is adapted from the swig reference manual \\cite{swig}.    // ( 6 ) the last thing to do in the swig interface file is to declare the function signatures of the c implementation . ....    to use this module outlined in listing [ random_c_code ] , we have to call swig to generate wrapper code , then compile and link our code with the wrapper code . with swig installed",
    ", the procedure would look something like    .... swig -python -o",
    "c_discrete_distribution_wrap.c c_discrete_distribution.i ....    we first use swig to generate the wrapper code . using the c_discrete_distribution.i interface file ,",
    "swig will generate c_discrete_distribution_wrap.c using the python c api , since we specified the -python flag .",
    "in addition , swig will also generate c_discrete_distribution.py , which we will use to import the module into our code .",
    ".... gcc -c c_discrete_distribution.c c_discrete_distribution_wrap.c      -i / usr / include / python2.5 -i / usr / lib / python2.5 ....    next we use a c compiler to compile each of the c files ( our c source , and the swig generated wrapper ) .",
    "we have to include the python header files and libraries for the python version we are using . in our case , we used python 2.5 .",
    "after this procedure completes , we should have two additional files : c_discrete_distribution.o and c_discrete_distribution_wrap.o .",
    ".... gcc -bundle -flat_namespace -undefined suppress",
    "-o _ c_discrete_distribution.so",
    "c_discrete_distribution.o c_discrete_distribution_wrap.o ....    the final step is to link them all together .",
    "the linking options are platform dependent , and the official swig documentation should be consulted @xcite . for mac os",
    "x , we use the `` -bundle -flat_namespace -undefined suppress '' options for gcc .",
    "when this step is done , the file _",
    "c_discrete_distribution.so is created .",
    "the python module file c_discrete_distribution.py can be used in the same way as in listing [ random_python_code ] above ,    .... import c_discrete_distribution as discrete_distribution discrete_distribution.seed ( ) print sum([discrete_distribution.draw([0.2,0.2,0.3,0.3 ] ) for x in range(10000)])/10000 .   ....    which produces the number 1.6942 .",
    "the benefits of using swig in this project were several :    1 .",
    "we used all the benefits of python with the increased speed for critical bottlenecks of our simulation code .",
    "the parts that were sped up were used in the exact same context through the python module import structure , removing the need for glue code to tie in external c - programs .",
    "more generally , swig allows scientists using python to leverage experience in other languages that they typically have , while staying within the python framework with all its benefits outlined above .",
    "this promotes a scientific work flow which consists of prototyping simulation code using the more simple python , then profiling the python code to identify the speed bottlenecks .",
    "these can then be re - implemented in c or c++ and wrapped into the existing python code using swig .",
    "this is a much preferred methodology than writing unnecessarily complicated and error - prone c programs , and using glue code to integrate them within the larger simulation methodology .",
    "there are several practical conclusions to draw for scientists .",
    "the first is that python , and its associated modules supported by the python community , offer a general platform for computing that is useful accross a broad range of scientific disciplines .",
    "we have only outlined several such tools in this article , but there exist many more relevant to scientists @xcite . the second is that python and its community modules can _ easily _",
    "be used by scientists .",
    "the clean nature of the code is quick to learn , and its high - level features make complicated tasks quick to accomplish . we have not discussed the interactive programming environments offered by python@xcite , which when combined with the power of the language makes prototyping ideas and algorithms extremely easy .",
    "the bigger picture conclusion is that python promotes good scientific practice .",
    "the code readability and package structure enables code to be easily understood by different researchers working on the same project .",
    "in fact , python code is often self - documenting which allows researchers to go back to code they wrote in the past and easily understand it .",
    "python and its community modules provide a consistent framework to generate data , and shuttle it to the various analysis tasks .",
    "this in turn promotes data provenance through a written record _ in code _ of every step used to analyze specific data , which removes many manual steps , and thus many errors .    finally , by using python",
    ", scientists can start to use other community tools and practices originally designed for professional programmers , but also useful to scientists .",
    "the most important of these , but not discussed in this article , is unit testing , whereby test code is written alongside scientific code that tests to see if that code is working properly .",
    "this allows scientists to re - write aspects of the code , perhaps using a different algorithm , and to re - run the tests to see if it still works as they think it should . for large projects",
    "this is critical , and removes the need for often - used ad - hoc practices of looking at some sample data by eye , which is not only tedious , but not guaranteed to uncover subtle numerical bugs that could cause crucial mis - interpretation of scientific data .    since python is a well - established language and has a large and active community , the resources available for beginners can be overwhelming . for the scientist interested in learning more about scientific programming in python , we recommend visiting the web page and mailing lists of the scipy project for an introduction to scientific modules @xcite , and @xcite for excellent introductory python tutorials .",
    "all code examples in this paper were written by the author .",
    "the particular versions of the relevant software used were : python 2.5 , biopython 1.44 , matplotlib 0.91.2 , and swig 1.3.33 .",
    "documentation and free downloads of this software are available at the following urls :    * python - http://python.org * biopython - http://biopython.org * matplotlib - http://matplotlib.sourceforge.net * swig - http://www.swig.org/    the source code for all the listings above , as well as the original and maintained version of this article can be found at ` http://openwetware.org/wiki/julius_b._lucks/projects/python_all_a_scientist_needs ` .",
    "the author would like to thank adrian del maestro , joao xavier , david thompson and stanley qi for helpful comments during the preparation of this manuscript .",
    "the author also thanks the miller institute for basic research in science at the university of california , berkeley for support .",
    "10    j. b. lucks , d. r. nelson , g. kudla , j. b. plotkin . _ genome landscapes and bacteriophage codon usage _",
    ", plos computational biology , * 4 * , .1000001 , 2008 .",
    "( http://dx.doi.org/10.1371/journal.pcbi.1000001[doi:10.1371/journal.pcbi.1000001 ] )                                                f. perez and b. granger .",
    "_ ipython : a system for interactive scientific computing _  , computing in science and engineering , 2007 ."
  ],
  "abstract_text": [
    "<S> any cutting - edge scientific research project requires a myriad of computational tools for data generation , management , analysis and visualization . </S>",
    "<S> python is a flexible and extensible scientific programming platform that offered the perfect solution in our recent comparative genomics investigation @xcite . in this paper </S>",
    "<S> , we discuss the challenges of this project , and how the combined power of biopython @xcite , matplotlib @xcite and swig @xcite were utilized for the required computational tasks . </S>",
    "<S> we finish by discussing how python goes beyond being a convenient programming language , and promotes good scientific practice by enabling clean code , integration with professional programming techniques such as unit testing , and strong data provenance . </S>"
  ]
}