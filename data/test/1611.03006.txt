{
  "article_text": [
    "over the past few years , advances in genomics and genome sequencing are not only enabling progress in medicine and healthcare , but are also bringing genetic testing to the masses , as an increasing number of `` direct to consumer '' ( dtc ) companies have entered , and sometimes disrupted , the market .",
    "for instance , 23andme.com offers a $ 99/129 assessment of inherited traits , genealogy , and congenital risk factors , through genotyping of a saliva sample posted via mail , and ancestry.com also offers low - cost genotyping - based dna tests .    in this paper",
    ", we focus a popular test offered by many dtc companies , namely , genetic relatedness test ( grt ) .",
    "this is used to identify whether or not a pair of individuals are closely related , genetically speaking . the standard approach to relative identification is to detect the identity - by - descent ( ibd ) segments between the individuals , and further identify the degree of relatedness via the amount of shared ibd segments  @xcite .",
    "the quantity of shared ibd segments is then detected from the phased haplotypes ( note a haplotype is a group of genes within an organism that was inherited together from a single parent ) of ( a pair of ) individuals , which are the specific groups of genes that a progeny inherits from one parent and consists of a fixed number of single nucleotide polymorphisms ( snps are the most common form of dna variation occurring when a single nucleotide differs between members of the same species or paired chromosomes of an individual  @xcite ) .",
    "nevertheless , grt services available today require individuals to send their genetic data ( in plaintext ) to possibly untrusted dtc companies . furthermore , collected genetic data is often impossible to anonymize  @xcite and hard to protect from intentional or accidental leakage .",
    "privacy risks from individual genetic exposure have been studied extensively  @xcite , thus motivating the need to design a grt algorithms that can operate without accessing genetic data in the clear and violating individuals privacy .",
    "we focus on genomic data that has already been phased into haplotypes and assume that the haplotypes of a pair of individuals with the same length are both interpreted by letters `` a , g , c , t '' , so that the problem of detecting ibd shared segments is reduced to the identification of the shared positions of two equal - length strings .",
    "dynamic programming can then be used to calculate shared positions , e.g. , edit distance , hamming distance and longest common subsequence ( lcs ) algorithms .",
    "overall , the research community has dedicated a lot of attention to genomic privacy , and proposed cryptographic techniques for privacy - preserving genetic testing  @xcite .",
    "prior work on secure ( two - party ) computation could also be used to protect privacy in relatedness test protocol building on traditional cryptographic primitives like homomorphic encryption ( e.g.  @xcite ) , private set intersection ( e.g.  @xcite ) , and garbled circuits based secure computation ( e.g.  @xcite ) .",
    "some existing two - party secure distance computation protocols could also come to help here , for example , private set intersection  @xcite , privacy - preserving approximating edit distance  @xcite based on garbled circuit and oblivious transfer , oblivious transfer based hamming distance system  @xcite , or a homomorphic computation of edit distance  @xcite .",
    "these two - party computation tools can be extended into a cloud - based context involving a trusted cloud server ( with fully access to an online database consisting of a number of individuals genetic data ) and a relatedness test service ( client ) with its own genetic information .",
    "the client could use a additively homomorphic encryption scheme , e.g. , paillier cryptosystem  @xcite , to encrypt a haplotype and send it ( along with the public key ) to the server .",
    "the server would then encrypt each haplotype in its database using the same encryption algorithm , `` subtract '' client s encryption by the encrypted haplotype , and return the results to the client .",
    "the latter could then decrypt and identify the quantity of shared positions by checking the number of 0 s decrypted .",
    "two recent works  @xcite open a new perspective for privacy - friendly grt by using fuzzy encryption technique . in these systems ,",
    "each individual first compresses its haplotype into a 0/1 string , called private genome sketch , and then `` encrypts '' the sketch by using a random row of a given error correct code matrix .",
    "one may detect if user @xmath0 is relative by downloading @xmath0 s encrypted sketch , and next `` decrypting '' the sketch with its own private genome sketch .",
    "if the decryption closely leads to a row in the matrix , the haplotypes of both individuals are approximately matched . however ,",
    "all the aforementioned computation approaches do not really scale well in practice , as they all suffer from an important limitation , i.e. , the client is burdened with heavy computation and communication overhead , as it has to download all related `` encrypted '' results from the server and perform a huge numbers of decryption to identify the relatedness .",
    "how to design scalable privacy - preserving grt that can scale on both server and client side constitutes the main motivation for our work .",
    "this paper presents a novel , efficient privacy - preserving genetic relatedness test ( ppgrt ) protocol that relies on the cloud s computational power . generally speaking",
    ", we allow the cloud to perform grt by only given an encrypted genetic database and an encrypted personal haplotype , as opposed to the traditional context where the cloud is able to fully access the database . before instantiating the protocol",
    ", we first discuss how ppgrt protocol can be generically constructed on top of a public key searchable encryption ( e.g.  @xcite ) and a symmetric key encryption cryptosystems .",
    "next , we propose a concrete construction building on searchable encryption technique  @xcite . specifically , we encode the haplotypes stored on the cloud server as a bunch of search trapdoors , and the haplotype uploaded by a test issuer ( i.e. , the client ) is interpreted as a set of search indices .",
    "an ibd shared segment detection is then reduced to a searchable matching problem , i.e. , finding a match indicating a shared segment .",
    "note that the method does not leak information to cloud server even if the server knows the length of shared segment as long as the secrecy of haplotypes is guaranteed .",
    "it is worth mentioning that the paper is the first to explore searchable encryption technique into relatedness test .",
    "we hope this work will inspire a new perspective for the future genomic privacy research .",
    "we assume a genetic data sequence is represented as a haplotype consisting of five basic letters @xmath1 , where @xmath2 denotes a piece of unknown / unmarked information , and assume the length of each letter is @xmath3 . as illustrated in fig .",
    "[ fig:1 ] , there are four parties in a genetic relatedness test ( grt ) system , which mirrors the one introduced by ayday et al . in  @xcite , specifically :    1 .",
    "* system users ( sus ) . * system users plain genetic information are collected and phased into haplotypes by a trusted and certified institution , e.g. local health / medical center .",
    "* certified institution ( ci ) . *",
    "a trusted ci collects system users plain genetic data to form a genome database ( @xmath4 ) , and encrypts @xmath4 to an @xmath5 .",
    "later , ci outsources @xmath5 to a storage and processing unit in which genetic relatedness testing is performed .",
    "3 .   * storage and processing unit ( spu ) . *",
    "a spu stores @xmath5 locally and meanwhile , it is mainly responsible for running relatedness test as well as returning the test result to a test issuer .",
    "note that spu knows nothing about the underlying data stored in @xmath5 .",
    "* test issuer ( ti ) . *",
    "a ti encrypts its phased haplotype via an _ asymmetric _ key encryption mechanism , and sends the encryption to the spu . after the test",
    ", the spu returns the result to the ti without learning any ( underlying haplotype ) information .        * algorithms . *",
    "the system consists of the following algorithms :    1 .",
    "@xmath6 : on input a security parameter @xmath7 , output public parameter and secret key for the system .",
    "@xmath8 : on input secret key @xmath9 , public parameter @xmath10 and a plain genome database , output an encrypted genome database @xmath5 .",
    "we assume that @xmath4 consists of a list of plain haplotypes , i.e. @xmath11 , and @xmath5 is a list of index / encrypted haplotype pairs , i.e. @xmath12 , where @xmath13 , and @xmath14 is the total number of haplotypes .",
    "@xmath15 : on input public parameter @xmath10 and a plain haplotype information , output an encrypted haplotype @xmath16 .",
    "@xmath17 : on input public parameter @xmath10 , @xmath5 and an encrypted query , output a set @xmath18 whereby the set includes @xmath14 test results between an encrypted query @xmath16 and each encrypted haplotype in @xmath5 .",
    "we highlight that privacy - preserving genetic relatedness testing ( ppgrt ) can be generically constructed from a public key based searchable encryption ( pkse ) and a symmetric encryption scheme . using  @xcite s definition for pkse , and given a pkse ( @xmath19 , @xmath20 , @xmath21 ( note we assume that randomness is already taken in algorithms @xmath22 and @xmath23 , so that each trapdoor and each index `` look '' uniformly random in the view of spu . ) , @xmath24 ) , a symmetric encryption ( @xmath25 , @xmath26 , @xmath27 ) , we can build a generic ppgrt construction as follows :    1 .",
    "@xmath28 : run @xmath29 algorithm to generate ( @xmath30 , @xmath31 ) , and @xmath32 algorithm to generate @xmath33 , and set @xmath34 and @xmath31 to be @xmath9 and @xmath10 , respectively .",
    "@xmath35 : run @xmath36 algorithm @xmath14 times to encrypt each plaintext haplotype @xmath37 to become an encrypted value @xmath38 , and further run @xmath39 algorithm to build a searchable trapdoor @xmath40 for each letter @xmath41 in a haplotype @xmath37 , where @xmath42 $ ] .",
    "we have @xmath43 , @xmath44 .",
    "@xmath45 : run @xmath46 to generate a search index @xmath47 for each letter @xmath48 in the haplotype @xmath49 , and further set @xmath50 , where @xmath51 $ ] .",
    "@xmath52 : given two - equal length `` sequences '' @xmath53 and @xmath54 , the calculation of shared ( positions ) length is reduced to the counting of the number of `` 0 '' output by the algorithm @xmath55 .",
    "some dynamic distance programming algorithms ( e.g. hamming / edit distance ) can be used here . by intaking an index sequence @xmath16 and a trapdoor sequence @xmath56 ( with equal length ) , for @xmath57 to @xmath58 , the algorithm checks the output of @xmath59 . if the algorithm outputs 0 , indicating there is a mismatch for the corresponding @xmath60-th position ( of both sequences ) , we add 1 to the distance . we calculate the shared length ( between @xmath16 and @xmath38 ) by subtracting @xmath58 with the distance , and store the result as an @xmath61-th tuple in @xmath18 .",
    "after @xmath14 rounds of the test , output @xmath18 .    * ppgrt security .",
    "* a secure ppgrt system needs to guarantee that : ( 1 ) @xmath5 must not leak the underlying encrypted sensitive haplotype data to spu , ( 2 ) spu can not learn the underlying haplotype embedded in the search index @xmath56 , and ( 3 ) the underlying haplotype can not be compromised from the test result @xmath18 by spu .    under the assumption that the underlying symmetric key encryption is chosen plaintext secure , and the underlying pkse is secure against chosen keyword attacks with trapdoor privacy  @xcite , the above generic construction is secure .",
    "since the generic construction ppgrt consists of two parts , namely encrypted data and encrypted search index structure , its security mainly depends on two aspects : one is the security of the underlying symmetric key encryption , and the other one is the security of the pkse .",
    "the chosen plaintext security of the symmetric encryption guarantees the secrecy of the underlying haplotype .",
    "the security holding against chosen keyword attacks is used to ensure the query haplotype search index ( issued by ti ) to be hidden from the view of search server .",
    "the trapdoor privacy of the pkse is to protect the haplotype embedded in the searchable trapdoor from being known by the `` curious '' server .",
    "the security of the whole ppgrt construction can be proved by following the universally composable model ( introduced in  @xcite ) with the above security assumption .",
    "below we review the paillier encryption .",
    "please refer to @xcite for more definition and technical details .",
    "we let @xmath62 be a safe number , @xmath63 be the set of elements of order @xmath64 , @xmath65 be their disjoint union for @xmath66 , where @xmath67 , @xmath68 , @xmath69 are large primes , carmichael s function @xmath70 , and set @xmath71 to be @xmath72 .",
    "suppose @xmath73 is a base of @xmath65 , and set @xmath74 .",
    "in paillier encryption system , we set @xmath75 as public parameters , and @xmath72 as secret key .",
    "the encryption algorithms works as @xmath76 where @xmath77 is the ciphertext , @xmath78 is the message , @xmath79 is a random value , and @xmath80 , @xmath81 .",
    "the decryption algorithm runs as @xmath82 where the ciphertext @xmath83 .",
    "the paillier encryption supports the following homomorphic properties : @xmath84      following the generic construction , we now build a concrete system for ppgrt ( via the usage of lcs ) on top of a single keyword equality variant of the searchable encryption scheme  @xcite . in the construction ,",
    "we revise the lcs algorithm ( note our lcs algorithm is revised from the one given in http://introcs.cs.princeton.edu/java/96optimization/lcs.java . ) so that it only outputs the shared length between a pair of encrypted haplotypes but not the lcs sequence .",
    "* * setup(@xmath85 ) : * the ci chooses two target collision resistant hash functions @xmath86 ,",
    "@xmath87 , @xmath88 , a cyclic group @xmath89 with order @xmath90 ( @xmath91 is a base of the group , the computation is based on the modulus @xmath90 ) , sets @xmath92 , @xmath93 , where @xmath94 are parameters in paillier encryption ( please refer to the previous section and  @xcite for more details ) , and euler s totient function @xmath95 , and @xmath96 . the ci sets system public key as @xmath97 , sets its secret key as @xmath98 , and sends spu a public key tuple @xmath99 . * * genedb(@xmath9 , @xmath10 , @xmath4 ) : * before delivering a @xmath4 to an spu , the ci encrypts it as follows .",
    "below we use @xmath100 to denote a plain haplotype .",
    "1 .   for @xmath101 to @xmath102 ,",
    "the ci runs as 1 .",
    "given @xmath10 and a haplotype @xmath100 with length @xmath103 , the ci works as follows .",
    "to randomize each letter , for each @xmath104 ( @xmath105 $ ] ) , the ci randomly chooses new random @xmath106 , and sets @xmath107 and @xmath108 .",
    "the haplotype s encrypted index sequence @xmath56 now is represented by a set of @xmath109 in which @xmath110 . for convenience , we use a notation @xmath111 later , where @xmath112 , @xmath113 stores random factors @xmath114 and @xmath115 is with a set of random @xmath116 .",
    "note that ci will choose a pair of distinct random factors ( @xmath117 , @xmath118 ) for each letter so as to avoid the case where the repeated letters share with the same random pair .",
    "for example , for a two - bit string @xmath119 , ci chooses random factors @xmath120 and @xmath121 for the first and second @xmath0 , respectively .",
    "the ci also encrypts @xmath100 by using a symmetric key encryption system @xmath122 , @xmath123 , @xmath124 .",
    "it sets @xmath125 , and computes @xmath126 .",
    "we suppose the length of @xmath33 is identical to that of @xmath100 , such that the symmetric encryption is a perfect one - time pad to @xmath100 .",
    "the ci finally outputs an @xmath127 . *",
    "* genquery(@xmath10 , @xmath49 ) : * before sending its haplotype sequence @xmath49 to the spu for relatedness test , the ti encrypts the sequence as follows .",
    "suppose @xmath128 , and @xmath129 .",
    "the ti sets @xmath130 , and interprets the sequence as @xmath131 , where @xmath132 , @xmath133 is a paillier encryption for @xmath134 , and @xmath135 .",
    "each @xmath136 is hidden ( with uniformly random value @xmath137 ) by the paillier probabilistic encryption . *",
    "* test(@xmath138 , @xmath5 , @xmath16 ) : * given an encrypted @xmath5 and an encrypted haplotype sequence @xmath16 , the spu first extracts a tuple @xmath139 of an encrypted haplotype @xmath140 from the @xmath5 , where @xmath141 $ ] and @xmath142 . from @xmath143 to @xmath14 , the spu runs the algorithm @xmath144 ( see the privacy - preserving longest common subsequence algorithm  [ a1 ] ) , and finally outputs the length of the shared positions between @xmath140 and @xmath16 . note that we use @xmath145 $ ] and @xmath146 $ ] to denote the @xmath61-th element in array @xmath147 and @xmath148 , respectively .",
    "note that the lcs algorithm here is revised from the one shared in princeton java library ( http://introcs.cs.princeton.edu/java/96optimization/lcs.java . ) .",
    "+ int @xmath149 $ ] ; + for @xmath150 to @xmath103 do @xmath151 @xmath152=0 $ ] ; @xmath153 + for @xmath154 to @xmath155 do @xmath151 @xmath156=0 $ ] ; @xmath153 + for @xmath101 to @xmath103 do @xmath151 for @xmath57 to @xmath155 do @xmath151 + if ( ) @xmath151 @xmath157 = 1 + w[i-1 , j-1]$ ] ; @xmath153 + else if @xmath158 \\ge w[i , j-1 ] ) $ ] @xmath151 @xmath157= w[i-1 , j]$ ] ; @xmath153 + else @xmath151 @xmath157= w[i , j-1]$ ] ; @xmath153 + @xmath153 + @xmath153 + return @xmath159 $ ] ;    since the correctness mainly follows that of  @xcite , we can have the check below .",
    "one may verify the equality of @xmath160^{\\beta \\cdot b_z[i]}\\ mod\\ n^2)==s_z[i]\\ ( mod\\ n)\\ ) $ ] to see if the letter @xmath161 in @xmath146 $ ] is equal to the letter @xmath136 in the encryption @xmath162 $ ] as in  @xcite . since the decryption algorithm of paillier encryption system can be represented as @xmath163^\\xi)^{\\lambda}\\ mod\\ n^2)}{l(g^{\\lambda } \\",
    "mod\\ n^2 ) } \\",
    "( mod\\ n)$ ] , we have @xmath164^\\xi)^{\\lambda}\\ mod\\ n^2)\\ ( mod\\ n)$ ] . set @xmath165 , we have @xmath166^{\\rho_i   \\sigma   h_0(\\eta_i p)})^{\\lambda}\\ mod\\ n^2)\\ ( mod\\ n)\\\\ & \\rho_i   h(x_j ) h_0(\\eta_i p ) \\sigma",
    "l(g^{\\lambda } \\",
    "mod\\ n^2 )   =   l(c[j]^{\\rho_i \\sigma   h_0(\\eta_i p ) \\lambda}\\ mod\\ n^2)\\ ( mod\\ n)\\\\ & \\rho_i   h(x_j ) h_0(\\eta_i p )",
    "\\gamma   =   l(c[j]^{b[i ] \\beta}\\ mod\\ n^2)\\ ( mod\\ n)\\end{split}\\ ] ] if the letter @xmath167 ( on the left hand side of the equation ) is equal to the letter @xmath136 embedded in the encryption @xmath162 $ ] , we then definitely have @xmath168^{b[i ] \\beta}\\ mod\\ n^2)\\ ( mod\\ n)$ ] , so that @xmath169   =   l(c[j]^{b[i ] \\beta}\\ mod\\ n^2)$ ] @xmath170 .",
    "we note that the equation can be checked by spu without knowing @xmath9 .",
    "the concrete construction above is secure assuming the underlying symmetric encryption is secure , the paillier encryption is secure and @xcite is secure with trapdoor privacy in the indistinguishability of ciphertext from random game .",
    "we note that the details of the proof follow that of  @xcite .      in the previous section ,",
    "a basic concrete construction for our generic ppgrt is built based on the searchable encryption scheme  @xcite .",
    "it is not fully secure yet because of suffering from deterministic identifier and offline keyword guessing attacks .",
    "below we present some solutions to tackle the attacks and meanwhile , we show that the construction can be extended to friendly support edit and hamming distance algorithms .      from the construction of the haplotype encrypted index sequence",
    ", we can see that @xmath171 and @xmath172 are constructed as @xmath173 and @xmath174 , respectively .",
    "recall that the tuple ( @xmath171 , @xmath172 ) is given to the spu . here , a malicious spu can easily obtain @xmath175 . taking two distinct @xmath176 and @xmath177 ,",
    "the malicious spu can compute @xmath178 to recover @xmath179 .",
    "with knowledge of @xmath179 , it may correctly guess the haplotype sequence , since the message space ( @xmath180 ) is relatively small in our context . to prevent the attack ,",
    "the ci may choose to add random factor into the hash function .",
    "it can choose a random value , say @xmath181 , so that @xmath182 , where @xmath183 is a new target collision resistance hash function so that @xmath184 .",
    "now , even being able to achieve @xmath185 , the malicious spu may not easily guess what is the input of the hash function .",
    "this naive solution , however , incurs another deterministic issue .",
    "while the input of the hash function is identical - meaning that a snps letter is repeated , the hash output leads to the same value , for example , @xmath186 .",
    "in such a case , the malicious spu may make use of some statistical analysis ( e.g. , 70% of the repetition occurs for the letter @xmath0 or @xmath16 ) to reveal the whole haplotype sequence .",
    "a better countermeasure is to bring more random factors into the construction of @xmath172 .",
    "specifically , the ci may set @xmath187 , @xmath188 , where @xmath189 , @xmath190 and @xmath191 .",
    "note the @xmath56 now includes ( @xmath113 , @xmath115 , @xmath192 ) , where @xmath192 is the set of all @xmath193 .",
    "accordingly , the equality check needs to be revised as @xmath160^{\\beta \\cdot b_z[i]+ k_z[i]}\\ mod\\ n^2)==s_z[i]\\ ( mod\\ n)\\ ) $ ] .",
    "one may check the correctness by setting @xmath194 .",
    "note we will talk about the random factor @xmath172 later .",
    "since the message space of haplotype is relative small , @xmath1 , it is extremely important for ci to produce randomly indistinguishable index sequence in the privacy point of view .",
    "recall that this index sequence can be exactly seen as a searchable trapdoor ( in our generic ppgrt construction ) .",
    "therefore , the privacy of the index sequence is now reduced to the trapdoor privacy .",
    "there have been some research works that introduce effective methods to tackle the trapdoor privacy issue , e.g.  @xcite . the crucial idea behind trapdoor privacy is to disable spu s ability of telling / identifying the relationship between ( any ) two given trapdoors ( with respective keywords inside ) .",
    "it is much like the anonymity feature in the context of identity - based encryption .",
    "the premise of doing so is to ensure a fresh randomness to each trapdoor .",
    "we here recommend readers to take a public key - based searchable encryption system with trapdoor privacy as an input building block to our generic ppgrt `` compiler '' , while attempting to construct a concrete scheme , so as to guarantee the privacy of haplotype encrypted index sequence .",
    "int @xmath195 ;    if @xmath196 @xmath197 @xmath198 @xmath151 _ please input equal length segments .",
    "_ @xmath153 //recall that @xmath199 which is the test issuer s encrypted sequence , while @xmath142 which is the genomic index sequence , and @xmath147 is the random factor sequence .",
    "else for @xmath101 to @xmath103 do @xmath151    if ( ) @xmath151 @xmath200 ; @xmath153    @xmath153    return @xmath201 ;      since the paillier encryption algorithm is publicly known , the spu may launch offline keyword dictionary attack to guess the information of the haplotypes stored in its database . specifically , the spu can randomly choose a haplotype sequence @xmath202 , and further runs the algorithm @xmath203 to generate an encrypted sequence @xmath204 . by running the algorithm @xmath55 with input @xmath204 and a client s haplotype - hidden index @xmath56 stored in @xmath5 , the spu may learn how similarity the two sequences share with .",
    "accordingly , the client s haplotype information definitely suffers from a leakage risk . to thwart this possible attack ,",
    "our system allows the ci to share a secret information @xmath205 , being seen as an extra input for the hash function , with the ti via a well - studied and efficient diffie - hellman key exchange protocol ( in des way ) with ebc mode , so that the ti will construct each encrypted element @xmath133 ( of the corresponding letter @xmath136 ) as @xmath206 .",
    "accordingly , the secret information @xmath205 has to be put in the index element @xmath172 by the ci as well . the spu will fail to launch effective offline keyword dictionary attack , since it can not compute a valid hash value without knowledge of the shared secret @xmath205 .",
    "the key exchange protocol above can be seen as a permission granted from the ci , so that the ti can proceed to the test phase .",
    "imagine that in practice , a public tester usually needs to request a test permission from the edb owner , i.e. the ci , even the edb is outsourced to the spu .",
    "if the ci grants the permission , it will share the secret information with the ti ; otherwise , nothing will be shared .    to keep consistency with the revision introduced in the previous subsection , a random factor @xmath205 is replaced with a @xmath207 , where @xmath208 and @xmath209 $ ] .",
    "we note that there is no need for the ci and the ti to share with the whole vector @xmath210 in the exchange protocol .",
    "for example , the ci may leverage the equation @xmath211 to calculate the value @xmath172 , where @xmath212 and @xmath167 is some `` common '' information that the ti knows as well ( e.g. @xmath213 , where @xmath214 is the current position of the letter @xmath136 on the sequence ) . in this case",
    ", the ci will only need to share @xmath215 with the ti in the key exchange protocol .",
    "int @xmath216 ; int @xmath217 ; int @xmath218 ;    if ( @xmath219 ) @xmath151 @xmath220 ; @xmath153    else @xmath151 @xmath221 ; @xmath153    int [ ] [ ] @xmath222 = new int [ @xmath223 [ @xmath224 ;    for @xmath150 to @xmath225 do @xmath151 @xmath226[0]=i$ ] ; @xmath153    for @xmath154 to @xmath227 do @xmath151 @xmath228[j]=j$ ] ; @xmath153    for @xmath150 to @xmath229 do    for @xmath154 to @xmath230 do @xmath151    if ( ) @xmath151 @xmath231[j+1]=dp[i][j]$ ] ; @xmath153    else @xmath151    int @xmath232[j]+1 $ ] ;    int @xmath233[j+1]+1 $ ] ;    int @xmath234[j]+1 $ ] ;    int @xmath235 ;    @xmath236 ;    @xmath231[j+1 ] = min$ ] ;    @xmath153    @xmath153    return @xmath237[len2]$ ] ;      we state that our concrete construction is naturally compatible with edit distance and hamming distance algorithms .",
    "the intuition is to see the equation highlighted in the box in algorithm  [ a1 ] as a condition for distance counting  that is , if the equation does not hold ( indicating a mismatch ) , we proceed to a distance adding operation  and , meanwhile , the final output is set to only show the shared length of two given strings .",
    "the privacy - preserving hamming distance algorithm is shown in  algorithm  [ a3 ] , in which we assume that each segment of the test issuer s encrypted sequence ( being taken into the algorithm ) is with the same length of the genomic index .",
    "the privacy - preserving variant for edit distance algorithm is presented in  algorithm  [ a2 ] .",
    "we note that the output of our privacy - preserving edit distance algorithm is somewhat different from that of the original edit distance algorithm  outputting the number of the `` difference '' of two strings .    [",
    "cols=\"^,^\",options=\"header \" , ]     we further assume that there is a pair of haplotypes , one encrypted by ci , and the other encrypted by ti : both encryptions will be sent to spu for two groups of test - one group of test is for original ( non - privacy - preserving ) lcs , edit and hamming distance algorithms , and the other is for privacy - preserving ones .",
    "note that both test groups will intake the identical haplotype sample .",
    "our pair of haplotypes are in the `` a , g , c , t '' format with the length 36@xmath238500 letter bits ( note in this paper we refer one letter to as a letter bit , e.g. `` ag '' are two letter bits ) . for matching 1000 genomes data format , we cut a total 18,000 letter bits haplotype into 500 segments of which contains 36 letter bits .",
    "note that the running times of each algorithm are averaged over 100 executions .",
    "the running time of non - privacy - preserving distance algorithms is depicted in figure  [ fg2 ] .",
    "it can be seen that hamming distance algorithm significantly outperforms edit distance algorithm , while the lcs suffers from the worst performance .",
    "the running time test here appropriately show the efficiency of the three algorithms .",
    "the running time of privacy - preserving hamming distance algorithm ( in figure  [ fg3 ] ) only takes approximately 900s to finish the test by intaking two encrypted haplotypes with 36@xmath238500 snps letter bits , while the privacy - preserving lcs and edit distance ( nearly overlapped ) requires over @xmath239s .",
    "accordingly , dealing with phased haplotype , it is better to leverage hamming distance algorithm as a secure building block for our ppgrt .",
    "we here state that the matching result of using privacy - preserving algorithms is identical to that of using original algorithms by inputing the same sample , 36@xmath238500 snps .",
    "note that please refer to our supplement test materials .",
    "we therefore conclude that the privacy - preserving algorithms maintain the exact test accuracy compared to the ones without any privacy protection .    however , the privacy - preserving algorithms , specially for edit distance and lcs , suffer from huge efficiency loss as a price to maintain privacy .",
    "this research work creates an interesting open problem on how to improve the test efficiency without loss of privacy .",
    "this research work introduced an interesting observation about how to generically construct a privacy preserving relatedness test protocol based on public key searchable encryption , and next proposed a concrete construction as well as its performance evaluation .",
    "the evaluation showed that our construction built on top of hamming distance algorithm is very efficient , while the designs for edit distance and lcs suffer from efficiency loss .",
    "the simulation also leverages real - world genetic database ( 1000 genomes ) to show the test accuracy of the system .",
    "the efficiency improvement of the construction will be seen as a future work .",
    "this paper also leave the academic and industrial communities followings interesting open problems - to improve the efficiency , can we make use of a symmetric searchable encryption to achieve the same grt test function without loss of privacy ; is it possible to directly use a normal but not reversed searchable encryption technique in our context ; how can we protect the haplotype ( encrypted and outsourced to spu ) even in the case where spu colludes with a group of tis ; how does ci `` update '' edb ( which is outsourced to spu ) but also `` control '' which parts of the edb to be `` performed '' test tasks by the spu ; what if there are different encryption formats in the back - end of the spu , how does it perform efficient and effective test .",
    "* acknowledgments . *",
    "the authors wish to thank alexandros mittos for presenting the paper at the genopri workshop .",
    "this work is supported by a google faculty award grant and eu project h2020-msca - itn `` privacy & us '' ( grant no ."
  ],
  "abstract_text": [
    "<S> an increasing number of individuals are turning to direct - to - consumer ( dtc ) genetic testing to learn about their predisposition to diseases , traits , and/or ancestry . </S>",
    "<S> dtc companies like 23andme and ancestry.com have started to offer popular and affordable ancestry and genealogy tests , with services allowing users to find unknown relatives and long - distant cousins . </S>",
    "<S> naturally , access and possible dissemination of genetic data prompts serious privacy concerns , thus motivating the need to design efficient primitives supporting private genetic tests . in this paper , we present an effective protocol for privacy - preserving genetic relatedness test ( ppgrt ) , enabling a cloud server to run relatedness tests on input an encrypted genetic database and a test facility s encrypted genetic sample . </S>",
    "<S> we reduce the test to a data matching problem and perform it , `` privately '' , using searchable encryption . </S>",
    "<S> finally , a performance evaluation of hamming distance based pp - grt attests to the practicality of our proposals . </S>"
  ]
}