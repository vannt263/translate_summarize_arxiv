{
  "article_text": [
    "a major problem in physical implementation of quantum computation is that errors are usually unavoidable in practical situation . to protect the computing process against errors ,",
    "the method of fault - tolerant quantum computation  @xcite has been introduced and developed in the last eighteen years . by employing many techniques of quantum error correction  @xcite , this method often leads to results in a form of threshold theorem  @xcite : a quantum computer can be successfully implemented with high probability if each component of the system only fails with probability less than a threshold .",
    "the fault - tolerant quantum computation is usually used when the errors are caused by environment noises .",
    "the threshold condition is possibly satisfied in this case , as the interaction between the quantum system and the environment may be reduced by other physical techniques , such as  @xcite .    in the present paper ,",
    "we propose a so - called `` debugging '' method to deal with another type of errors that are not caused by environment noises but by `` bugs '' , which mean unknown defects in the physical system itself .",
    "the prior techniques for fault - tolerant computation would generally become ineffective for such errors , since the error threshold is mostly broken . for example , suppose a hadamard gate is by mistake used as a not gate in a quantum computer , then this small defect will greatly change the computing result in most cases .",
    "a more reasonable strategy here is to find the nature and exact position of this defect , and then repair it . to this end",
    ", quantum measurements should be applied to monitoring the computing process so that errors can be detected as soon as possible after the component with bugs being executed .",
    "remarkably , a debugging method like this plays an indispensable role and attracts intense studies  @xcite in the implementation of classical computing systems .    unfortunately , due to the fundamental difference between the physical behavior of quantum measurements and that of classical ones , debugging for quantum systems is much more difficult than for classical systems , and thus classical debugging method",
    "does not work in the quantum scenario . specifically , in quantum mechanics , observation of a quantum system would make the system state collapse .",
    "this interaction between observing apparatus and quantum systems on the one hand allows quantum measurements to drive target systems as quantum operations  @xcite , in applications like teleportation  @xcite , entanglement distillation  @xcite , control of quantum systems  @xcite , and one - way quantum computing  @xcite ; but on the other hand , it makes many tasks much harder than in the classical world , particularly when quantum measurements are used to extract ( classical ) information of given systems .",
    "the well known indistinguishability between nonorthogonal states can somehow be seen as a simple example .",
    "the quantum debugging task considered here is actually another instance , where measurements monitor the system state for possible errors .",
    "this can be easily done for a classical process , because the trajectory of a classical system is unchanged by measurements .",
    "however , a problem in monitoring a quantum process is that once the system had been measured , the system state may be disturbed and then be useless for further processing .",
    "this problem has been demonstrated to be very serious in the quantum zeno effect  @xcite , that a quantum process can be completely obstructed by continuing measuring .",
    "therefore , similar tasks are usually achieved by quantum tomography techniques  @xcite in the literature , in which the system state is measured only once to keep the outcome faithful , but instead , a large number of copies of the process are required .    in the debugging method proposed in this paper ,",
    "quantum measurements are used in a different way : they are constantly taken to monitor a quantum process but without disturbances on the system state , until an error is detected .",
    "a basic scheme is described as follows .",
    "consider a quantum system that is established to run some computing process .",
    "it is designed to be in state @xmath0 initially , and then evolves under the controlled hamiltonian @xmath1 . in this way",
    ", the trajectory @xmath2 of the system state would be as anticipated .",
    "the time for the whole process is considered to be infinite , as it is usually much longer than the time for a single component ( like a gate ) acting .",
    "now suppose a bug of the system will be involved in the process at time @xmath3 , then the system hamiltonian will not truly be @xmath1 for @xmath4 in the practical execution .",
    "this causes errors in system state , so we write @xmath5 for the density operator of the actual state at time @xmath6 . to debug the process , we need to find a projection operator @xmath7 of the system and a sequence of time points @xmath8 , such that @xmath9 for all @xmath10 .",
    "the condition of @xmath11 means that nothing can be detected by @xmath12 if the system state is @xmath13 as anticipated .",
    "we monitor the process at time @xmath14 , using a measurement apparatus formalized by @xmath12 .",
    "this measurement is called a monitoring measurement . then with probability @xmath15 the error state would be detected at time @xmath16 .",
    "if it really happens , then an error is detected in the state . in this case",
    ", @xmath3 is more likely in @xmath17 $ ] and the relevant components should be carefully checked .",
    "practically , the time points @xmath14 are determined by a classical program @xmath18 .",
    "then the debugging protocol is visualized as fig .",
    "[ fig:1 ] . obviously , the key step of debugging a process is to find the required projection operator @xmath12 .",
    "the condition of @xmath11 guarantees that the anticipated process is not disturbed by @xmath12 . on the other hand",
    ", it implies that the protocol is conclusive ; i.e. , no errors would be reported when the process runs correctly .",
    "is sending to @xmath18 during the execution of the process . then at any time @xmath6 , @xmath18 can decide whether or not @xmath11 according to the control history . and if is it will drive @xmath12 to detect possible errors . ]",
    "the aim of this paper is to develop the debugging method for quantum systems outlined above .",
    "the paper is organized as follows . in sec .",
    "[ sec : proto ] , we first consider an example debugging protocol for quantum search algorithm . after that",
    ", we propose a general debugging scheme and show that it can be reduced to a simpler scheme described as in fig  [ fig:1 ] .",
    "then we formally define this simplified debugging protocols in the case of discrete time evolution . in sec .",
    "[ sec : resu ] , we completely solve the debugging problem for quantum processes with time independent hamiltonians .",
    "more precisely , we find an algorithm to construct all of the debugging protocols for this kind of quantum processes by employing the celebrated skolem  mahler ",
    "lech theorem .",
    "a brief conclusion is drawn in sec .",
    "[ sec : conclu ] .",
    "to show how can the debugging method be truly applied , let us first consider a simple example  debugging for the computational process of quantum search  @xcite . here , we adopt the description of the grover algorithm in @xcite .",
    "the quantum computer consists of @xmath10 qubits with @xmath19 as the initial state ( for simplicity , we omit the auxiliary qubits of the oracle ) . a black box oracle @xmath20 of form @xmath21",
    "is provided as input , where @xmath22 is the index we want to find .",
    "the computer first applies @xmath23 , and then successively applies the grover iteration @xmath24 for @xmath25 times , where @xmath26 at last , @xmath27 can be obtained with probability @xmath28 by measurement in the computational basis @xmath29 on each qubit . here",
    ", we use @xmath30 and @xmath31 to denote the identity and hadamard gates , respectively .    to debug this process",
    ", we note that the system state immediately after each grover iteration should be always in the two - dimensional subspace @xmath32 , where @xmath33 .",
    "so , we can use a measurement apparatus formalized by @xmath34 to detect errors .",
    "the protocol is as follows : randomly choose an integer @xmath27 and provide the corresponding oracle at the beginning , and then execute the algorithm . immediately after each grover iteration @xmath35 , take the monitoring measurement @xmath12 to detect errors .",
    "if an error system state is detected at some time point , then the debugging protocol stops the process and reports this error .",
    "now we particularly discuss the following two kinds of bugs :    1 .",
    "the system was not initialized .",
    "we write @xmath36 for the density operator of the initial system state and write @xmath37 for the fidelity of @xmath36 and @xmath19 .",
    "then it is easy to verify that with probability @xmath38 an error can be detected just by the first measurement of @xmath12 .",
    "the grover iterator was implemented with some bugs , so it is not @xmath35 but some unitary operator @xmath39 . in most cases , the two subspaces @xmath40 and @xmath41 have no common state .",
    "so @xmath42 for all @xmath43 .",
    "we write @xmath44 for the maximal value of all @xmath45 . then at each measurement of @xmath12",
    ", an error will be detected with a positive probability at least @xmath46 .",
    "two advantages of the quantum debugging method are demonstrated in this example : ( 1 ) an error may be detected soon after the bugs involved .",
    "so , the process can be just partly executed and a lot of time would be saved ; ( 2 ) a single execution of the process is usually sufficient to detect an error , whereas a large number of copies of the process are needed in other approaches .",
    "we now consider a general scheme of debugging protocols for quantum processes , in which quantum measurements are in the most general form , and different measurements can be used at different time points to detect errors .",
    "first , we impose a _ compatibility _ constraint to each monitoring measurement , such that the target system state keeps unchanged under its action .",
    "formally , the compatibility can be stated as follows : let @xmath47 be a state and @xmath48 be a measurement .",
    "we say that @xmath49 is compatible with @xmath47 if for all @xmath50 , @xmath51 is essentially the same as @xmath47 or vanish ; that is , @xmath47 is an eigenstate of every measurement operator of @xmath52 : @xmath53 in fact , this constraint simulates the physical behavior of a classical measurement : the states of a classical system can be thought of as an orthonormal basis @xmath54 , and we consider a classical measurement @xmath55 with @xmath56 .",
    "then the compatibility is automatically satisfied : @xmath57 for each @xmath50 and @xmath58 .",
    "a general protocol for debugging a quantum process using monitoring quantum measurements consists of three steps :    1 .   set a sequence of breakpoints at time @xmath14 during the process ; 2 .   execute the process , and at each breakpoint of time @xmath16 , insert a measurement @xmath59 that is compatible with the anticipated system state @xmath60 .",
    "we write @xmath61 for the outcomes @xmath50 that should not occur at time @xmath16 if the process behaves as anticipated ; 3 .   an error is detected if the measurement outcome at @xmath16 is some element @xmath62 . in this case",
    "we stop the execution and report @xmath50 and @xmath16 to specify the error type and the error position , respectively .",
    "we can actually simplify this general debugging scheme without loss of generality .",
    "first , we show that at each breakpoint of time @xmath6 , the general quantum measurement @xmath63 can be replaced with the two - outcome povm @xmath64 , where @xmath65 is used to indicate errors and @xmath66 indicates correctness . here",
    "@xmath67 is the identity operator of the system .",
    "in fact , this povm performs mostly the same as @xmath68 : they are both compatible with @xmath13 and detect errors with the same probability @xmath69 . here we denote by @xmath5 the system state with errors . the only disadvantage of such replacement is that different error types @xmath50 in @xmath70 are not distinguished",
    ". however , this would not be a problem because after an error being detected , the type can be specified by further measurement .",
    "moreover , it is even better to use the projective measurement @xmath71 with @xmath72 being the projection operator into the support of @xmath73 .",
    "this is because the measurement also satisfies the compatibility , and it detect errors with probability @xmath74 .",
    "therefore , it suffices to detect errors using monitoring measurements formalized by projection operators @xmath72 .",
    "we will call them error detectors in what follows .    secondly",
    ", we assert that all of the error detectors @xmath72 should be chosen only from a finite set ; otherwise , the protocol would be useless .",
    "the reason is that if infinitely many detectors are used , then to decide which one is chosen at a breakpoint , the amount of information we needed would become infinite .",
    "a specific instance is helpful to understand this situation : at each breakpoint of time @xmath6 , we simply use @xmath75 as the error detector .",
    "obviously , it is compatible with @xmath13 and any error of this system state can be detected using it .",
    "however , to construct this detector we need the complete information of @xmath13 by classical computation ; namely , the debugging protocol requires a classical simulation of the quantum process , which is clearly unreasonable .",
    "so , the requirement of finiteness is crucial for effective debugging protocols .",
    "we write all the detectors as @xmath76 .",
    "then there is a strategy @xmath18 for the protocol to call one of them at each breakpoint .",
    "now we can divide the strategy @xmath18 into @xmath77 parts @xmath78 , where @xmath79 is a strategy that only call @xmath80 at corresponding breakpoints and keeps silent at the others .",
    "then the original debugging protocol can be decomposed as @xmath77 protocols @xmath81 , each of which monitors the process at a part of breakpoints . in particular",
    ", some of the protocols will constantly work at an infinite subsequence of the breakpoints .",
    "therefore , we only need to investigate the debugging protocols of such a form : it consists of an error detector @xmath12 and a strategy @xmath18 ; at a sequence of time points specified by @xmath18 , @xmath12 is taken to detect possible errors of the system state .",
    "we note that this simplified protocol is exactly that visualised in fig .",
    "[ fig:1 ] .",
    "if all protocols in this scheme can be found for a given quantum process , then a general debugging task can be achieved by a simple combination of them , with certain further analysis about the detected errors .      since an error detector @xmath12 is discretely taken in the debugging described above , it is reasonable to consider the discrete time evolution of the system . specifically , we assume that the compatibility constraint is only checked by strategy @xmath18 at given points @xmath82 of time",
    ". then it suffices to considering the corresponding states @xmath83 , and the state transformations between them , which are formalized by unitary operations . in this way",
    ", the design of a quantum process can be depicted as @xmath84 where @xmath85 for every @xmath86 , and @xmath87 describes the evolution of the system from time @xmath88 to @xmath16 . for realizability",
    ", we can assume that all of these unitary operators can be chosen from a finite set @xmath89 .",
    "then we have @xmath90 for every @xmath91 .",
    "obviously , a circuit model of quantum computation can be seen as a quantum process like this , where @xmath92 are the gates in the circuit .",
    "quantum walk  @xcite can be considered as another example of quantum processes in this form .",
    "now we rigorously define the debugging protocol @xmath93 for quantum processes formulated by such a system .",
    "an error detector @xmath12 is a projection operator in the state hilbert space @xmath94 , and a strategy @xmath18 is a function that to each finite sequence @xmath95 of indices in @xmath96 , assigns a result of `` yes '' or `` no '' .",
    "intuitively , @xmath97``yes '' ( resp .",
    "`` no '' ) means that @xmath12 is ( resp . not )",
    "used to detect errors immediately after the execution of the action sequence @xmath98 .",
    "for simplicity , we write @xmath99 for the composition of the corresponding unitary actions . to warrant the protocol actually realizable , the following three conditions are necessary :    1 .",
    "( compatibility ) @xmath97``yes '' implies @xmath100 .",
    "2 .   ( computability )",
    "a classical algorithm can be found to compute @xmath18 .",
    "( liveness ) for any infinite sequence @xmath101 of indices @xmath102 there are infinitely many @xmath10 s such that @xmath103``yes '' .",
    "the first two conditions are easy to understand .",
    "the liveness comes from the fact that @xmath12 should constantly be applied in the process represented by @xmath101 , so that bugs involved at any time could be detected .",
    "based on the above definition of debugging protocol , a debugging problem can be formally stated as follows :    * given an initial state @xmath104 and a set of unitary operations @xmath105 that describe the discrete - time evolution of a quantum process , how can we find all the protocols @xmath93 satisfying compatibility , computability and liveness ?",
    "we now solve the debugging problem for the case where the designed hamiltonian is time independent . specifically , our solution consists of the following three steps :    1 .",
    "we find a method to check whether or not a given projection operator @xmath12 can be used as an error detector ; 2 .   for each eligible @xmath12",
    ", we show that a strategy @xmath18 can be constructed as a periodic function ; 3 .",
    "we present a procedure that can compute all the debugging protocols @xmath93 for any given process .",
    "let @xmath94 be the state hilbert space of the system , and @xmath106 the system hamiltonian which is time independent . to define debugging protocols @xmath93",
    ", we consider the discrete time evolution of the system between a sequence of time points @xmath107 , where @xmath108 is a fixed period of time which can be appropriately chosen in practice . then at time @xmath109 , the anticipated system state is @xmath110 , where @xmath0 is the initial state and @xmath111 is the unitary transformation of time evolution in a single period . as defined in subsec .",
    "[ sec : proto]-c , a debugging protocol for this system consists of an error detector @xmath12 which is an projection operator of @xmath94 , and a strategy @xmath18 which is a function specifying ( by assigning `` yes '' ) an infinite sequence of integers @xmath112 such that @xmath113 for all @xmath10 . our task is to find the detector @xmath12 and the strategy @xmath18 .",
    "obviously , a necessary condition of @xmath12 being an error detector is that @xmath114 for infinitely many @xmath10 . to investigate how this condition can be satisfied , we need the following theorem :    [ the : main]let @xmath0 be a vector , @xmath115 a unitary operator and @xmath12 a projection operator in a finite dimensional space @xmath94 .",
    "if @xmath116 is an infinite set , then an arithmetic progression @xmath117 can be algorithmically found in @xmath118 .",
    "the proof of theorem  [ the : main ] is postponed to next subsection . here",
    "we see how this theorem can be used in our investigation of a debugging protocol @xmath93 .",
    "first , the infiniteness condition of @xmath118 can be checked , as it is equivalent to the existence of the arithmetic progression .",
    "second , this condition is not only necessary but also sufficient for @xmath12 being an error detector .",
    "in fact , if it holds for @xmath12 , then we can construct a strategy @xmath18 as a periodic function that assigns `` yes '' to the integers @xmath119 , @xmath120 , and `` no '' to the others .",
    "moreover , by making the arithmetic progression @xmath117 exist in @xmath118 , we have a procedure to compute all the error detectors @xmath12 .",
    "such a procedure will be carefully described in subsec .",
    "[ sec : resu]-c based on the proof of the theorem .      a key step in the proof of theorem  [ the : main ] is to explore the implication of the infiniteness of @xmath118 .",
    "for this purpose , we employ some techniques from the previous research on the famous skolem s problem  @xcite . consider a linear recurrent sequence @xmath121 , which satisfies the linear recurrence relation : @xmath122 for all @xmath123 .",
    "let @xmath124 be the set of indices of null elements of @xmath125 .",
    "a way relating the above linear recurrent sequence to the behavior of a quantum system is putting @xmath126 for two quantum states @xmath127 and a quantum operation @xmath49 of a @xmath128 dimensional quantum system .",
    "remarkably , this technique has already been successfully used to solve several important problems in quantum information theory .",
    "for example , the condition @xmath129 is interpreted as the acceptance condition of finite quantum automata in @xcite for @xmath49 being a unitary operator , and as the occurrence of specific quantum measurement outcomes in @xcite for @xmath49 being a measurement operator , respectively .",
    "the decision problems considered in  @xcite are similar to the skolem s emptiness problem  @xcite .",
    "what we need in the proof of our result is the following  @xcite :    [ the : sml ] in a field of characteristic 0 , let a sequence @xmath121 satisfy a recurrence relation of form eq .",
    "( [ equ : recurrence ] ) , then the set @xmath118 of indices of null elements of this sequence is semi - linear , namely , is a union of a finite set and finitely many arithmetic progressions .    to apply this theorem to our problem , we decompose @xmath130 , where states @xmath131 form an orthonormal basis of the image space of @xmath12 .",
    "let @xmath132 be the characteristic polynomial of @xmath115 .",
    "then for each @xmath131 , we can invoke theorem  [ the : sml ] for @xmath133 and assert that the set @xmath134 is semi - linear .",
    "furthermore , we see that @xmath135 is also semi - linear . thus , the infiniteness of @xmath118 in theorem  [ the : main ] actually implies that it contains at least one arithmetic progression .",
    "there is still a gap between the existence of the arithmetic progression in theorem  [ the : main ] and its algorithmic construction .",
    "here we further present an algorithm to find @xmath136 and @xmath137 such that @xmath138 for all @xmath120 .",
    "of course we should assume that all operators and states are represented by matrices and vectors of rational complex numbers .",
    "_ finding number @xmath136 : _ we can algorithmically find a positive integer @xmath136 satisfying the following condition :    * for any two eigenvalues @xmath139 and @xmath140 of @xmath115 , @xmath141 provided @xmath142 for some integer @xmath10 .",
    "indeed , it suffices to find the smallest positive integer @xmath10 satisfying @xmath142 for each fixed pair of @xmath143 , and then @xmath136 can be chosen as the least common multiple of all these @xmath10 .",
    "we note that all roots of the characteristic polynomial @xmath144 of @xmath145 are exactly all quotients @xmath146 of two eigenvalues of @xmath115 .",
    "moreover , for each quotient @xmath146 , if @xmath10 is the smallest positive integer number satisfying @xmath142 , then @xmath146 should be a root of the @xmath10th cyclotomic polynomial @xmath147 , and @xmath147 should be a divisor of @xmath144 since @xmath147 is irreducible in the field of rational numbers .",
    "therefore , all of such @xmath10 can be obtained by checking whether or not @xmath148 .",
    "moreover , we prove that the number @xmath136 enjoys an property : for any subspace @xmath149 of @xmath94 , @xmath150 provided @xmath151 for some integer @xmath10 .",
    "we observe that @xmath151 if and only if a set of eigenvectors of @xmath152 forms a basis of @xmath149 . from this observation",
    ", it suffices to prove that any eigenvector of @xmath152 is an eigenvector of @xmath153 .",
    "more generally , we show that any eigenspace @xmath154 of @xmath152 is included in some eigenspace of @xmath153 .",
    "we note that all eigenvectors of @xmath115 are eigenvectors of @xmath152 , so we can choose a set of eigenvectors of @xmath115 to form a basis @xmath155 of @xmath154 .",
    "consider any two of these vectors , written as @xmath47 and @xmath156 , and we write @xmath139 and @xmath140 , respectively , for the corresponding eigenvalues of @xmath115 .",
    "then we have @xmath157 , and according to our choice of @xmath136 , @xmath141 .",
    "so @xmath47 and @xmath156 are in the same eigenspace of @xmath153 .",
    "as these two states are arbitrarily chosen , it implies that all of the vectors in @xmath155 are in the same eigenspace of @xmath153 .",
    "thus @xmath154 is included in it .",
    "_ finding number @xmath137 : _ let @xmath158 be the kernel space of @xmath12 .",
    "for any integer @xmath44 , we write @xmath159 for the maximal subspace of @xmath149 satisfying @xmath160",
    ". then @xmath159 can be calculated by the iteration @xmath161 , putting @xmath162 initially . on the other hand , we show that @xmath163 first , for any state @xmath164 , one can easily verify from the definition of @xmath159 that @xmath165 for all @xmath10 . secondly , if some state @xmath47 satisfies @xmath166 for all @xmath10 , then we consider the subspace of @xmath149 : @xmath167 .",
    "we have @xmath168 , and thus @xmath169 from the maximality of @xmath159 .",
    "therefore , eq .  ( [ equ : kq ] ) holds .    to make @xmath170 for all @xmath171 , it suffices to calculate @xmath172 and then find @xmath137 from @xmath173 such that @xmath174 .",
    "now we only need to prove the following claim :    * whenever there exists an arithmetic progression @xmath175 in @xmath118 , the number @xmath137 can be found as above .",
    "in fact , by eq .",
    "( [ equ : kq ] ) , @xmath176 means that @xmath177 .",
    "we note that @xmath178 implies @xmath179 by the property of @xmath136 stated above .",
    "thus , @xmath180 due to the maximality of @xmath172 .",
    "so we have @xmath181 . if we put @xmath182 as the remainder of @xmath183 divided by @xmath136 , then @xmath184 .",
    "so @xmath137 can be obtained in the algorithm .",
    "this completes the proof of theorem  [ the : main ] .",
    "now we can construct all debugging protocols @xmath93 for a given process using the proof of theorem  [ the : main ] .",
    "a necessary and sufficient condition of error detectors @xmath12 is that @xmath185 for the integer @xmath136 and some @xmath186 . so the construction of @xmath93 is achieved in four steps :    1 .",
    "compute the number @xmath136 from the given unitary operator @xmath115 .",
    "an algorithm for finding @xmath136 was already presented in the proof of theorem  [ the : main ] .",
    "2 .   arbitrarily choose a number @xmath186 , and compute the subspace @xmath187 where @xmath128 is the dimension of the system .",
    "@xmath12 can be chosen as any projection operator satisfying @xmath188 .",
    "in particular , we choose it as the one with image space @xmath189 , since it is of the maximal rank and thus can detect as many as possible errors . 4 .",
    "@xmath18 is constructed as the periodic function that specifies the arithmetic progression @xmath117 .    as an instance",
    ", we show how the above procedure can be used to construct a debugging protocol for the quantum search process in subsec .",
    "[ sec : proto]-a .",
    "the computational process of quantum search can be formalized in our model : the hilbert space @xmath94 is of dimension @xmath190 , the initial state is @xmath191 and the unitary transformation is @xmath192 where @xmath193 is a given integer .",
    "then the number @xmath136 , number @xmath137 , and projection operator @xmath12 are determined as follows :    1 .   to obtain the number @xmath136",
    ", we calculate the characteristic polynomial of @xmath35 that is @xmath194 we only consider the case of @xmath195 .",
    "it is easy to verify that for any two eigenvalues @xmath139 , @xmath140 of @xmath35 , if @xmath142 for some @xmath10 then @xmath196 .",
    "so we have @xmath197 .",
    "@xmath186 can only be @xmath198 because @xmath197 . then @xmath199 where @xmath200 .",
    "we choose @xmath34 to make the condition @xmath201 be satisfied .",
    "as @xmath197 and @xmath202 , @xmath12 is applied immediately after each action of @xmath35 .",
    "we see that this protocol constructed by the procedure presented in this subsection is exactly that given in subsection [ sec : proto]-a .",
    "in this paper , we proposed a scheme for debugging a quantum process , in which quantum measurements are used to monitor the system without disturbances on its behaviour .",
    "we discovered a procedure to construct all debugging protocols in this scheme for quantum processes with time independent hamiltonians .",
    "however , the problem of debugging quantum processes is still open for the case of time dependent hamiltonians .",
    "we are grateful to runyao duan , yuan feng and nengkun yu for useful discussions .",
    "this work was partly supported by the australian research council ( grant no : dp110103473 and dp130102764 ) .",
    "99 p. w. shor , in proc .",
    "37th annual symposium on foundations of computer science , 56 - 65 ( ieee press , los alamitos , 1996 ) .",
    "a. y. kitaev , russ .",
    "surv . * 52 * , 1191 ( 1997 ) .",
    "p. w. shor , phys .",
    "a * 52 * , 2493 ( 1995 ) .",
    "a. m. steane , phys .",
    "lett . * 77 * , 793 ( 1996 ) .",
    "m. a. nielsen and i. l. chuang , _ quantum computation and quantum information _",
    "( cambridge university press , 2000 ) .",
    "e. knill , r. laflamme , and w. h. zurek , science * 279 * , 342 ( 1998 ) .",
    "j. zhang , a. m. souza , f. d. brandao , and d. suter , phys .",
    "lett . * 112*. 050502 ( 2014 ) .",
    "m. leucker and c. schallhart , journal of logic and algebraic programming , * 78 * , 293 ( 2009 ) ; g. j. myers , _ the art of software testing _ ( john wiley and sons , inc . 1979 ) .",
    "r. y. duan , y. feng , and m. s. ying , phys .",
    "lett . * 103 * , 210501 ( 2009 ) . c. h. bennett , g. brassard , c. crpeau , r. jozsa , a. peres , and w. k. wootters , phys .",
    "* 70 * , 1895 ( 1993 ) . c. h. bennett , g. brassard , s. popescu , b. schumacher , j. a. smolin , and w. k. wootters , phys .",
    "76 * , 722 ( 1996 ) . c. altafini , and f. ticozzi , ieee transactions on automatic control , * 57 * , 1898 ( 2012 ) .",
    "r. raussendorf and h. j. briegel , phys .",
    "lett . * 86 * , 5188 ( 2001 ) .",
    "b. misra and e. c. g. sudarshan , j. math",
    ". phys . * 18 * , 756 ( 1977 ) .",
    "j. f. poyatos , j. i. cirac , and p. zoller , phys .",
    "lett . * 78 * , 390 ( 1997 ) ; i. l. chuang and m. a. nielsen , j. mod . opt . * 44 * , 2455 ( 1997 ) .",
    "l. grover , in proc .",
    "28th annual acm symposium on the theory of computing , 212 - 219 ( acm press , new york , 1996 ) .",
    "a. ambainis , e. bach , a. nayak , a. vishwanath , and j. watrous , in proc .",
    "33rd annual acm symposium on the theory of computing , 37 - 49 ( acm press , new york , 2001 ) .",
    "t. skolem , in proc .",
    "8th congress of scandinavian mathematicians , 163 - 188 , ( stockholm , 1934 ) . v. d. blondel , e. jeandel , p. koiran and n. portier , siam j. comput . * 34 * , 1464 ( 2005 ) .",
    "j. eisert , m. p. mller and c. gogolin , phys .",
    "lett . * 108 * , 260501 ( 2012 ) .",
    "v. halava , t. harju , m. hirvensalo and j. karhumaki , tucs technical report , 683 ( 2005 ) . c. lech , ark",
    ". mat . * 2 * , 417 - 421 ( 1953 ) ."
  ],
  "abstract_text": [
    "<S> since observation on a quantum system may cause the system state collapse , it is usually hard to find a way to monitor a quantum process , which is a quantum system that continuously evolves . </S>",
    "<S> we propose a protocol that can debug a quantum process by monitoring , but not disturb the evolution of the system . </S>",
    "<S> this protocol consists of an error detector and a debugging strategy . </S>",
    "<S> the detector is a projection operator that is orthogonal to the anticipated system state at a sequence of time points , and the strategy is used to specify these time points . as an example , we show how to debug the computational process of quantum search using this protocol . by applying the skolem  </S>",
    "<S> mahler  </S>",
    "<S> lech theorem in algebraic number theory , we find an algorithm to construct all of the debugging protocols for quantum processes of time independent hamiltonians . </S>"
  ]
}