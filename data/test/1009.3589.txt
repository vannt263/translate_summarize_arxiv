{
  "article_text": [
    "* deep learning * has emerged as a promising new area of research in statistical machine learning ( see  @xcite for a review ) . learning algorithms for deep architectures",
    "are centered on the learning of useful representations of data , which are better suited to the task at hand , and are organized in a hierarchy with multiple levels .",
    "this is in part inspired by observations of the mammalian visual cortex , which consists of a chain of processing elements , each of which is associated with a different representation of the raw visual input .",
    "in fact , it was found recently that the features learnt in deep architectures resemble those observed in the first two of these stages ( in areas v1 and v2 of visual cortex )  @xcite , and that they become more and more invariant to factors of variation ( such as camera movement ) in higher layers  @xcite . learning a hierarchy of features increases the ease and practicality of developing representations that are at once tailored to specific tasks , yet",
    "are able to borrow statistical strength from other related tasks ( e.g. , modeling different kinds of objects ) .",
    "finally , learning the feature representation can lead to higher - level ( more abstract , more general ) features that are more robust to unanticipated sources of variance extant in real data .",
    "* self - taught learning *  @xcite is a paradigm that combines principles of semi - supervised and multi - task learning : the learner can exploit examples that are unlabeled and possibly come from a distribution different from the target distribution , e.g. , from other classes than those of interest . it has already been shown that deep learners can clearly take advantage of unsupervised learning and unlabeled examples  @xcite , but more needs to be done to explore the impact of _ out - of - distribution _ examples and of the multi - task setting ( one exception is  @xcite , which uses a different kind of learning algorithm ) .",
    "in particular the _ relative advantage _ of deep learning for these settings has not been evaluated .",
    "the hypothesis discussed in the conclusion is that a deep hierarchy of features may be better able to provide sharing of statistical strength between different regions in input space or different tasks .",
    "whereas a deep architecture can in principle be more powerful than a shallow one in terms of representation , depth appears to render the training problem more difficult in terms of optimization and local minima .",
    "it is also only recently that successful algorithms were proposed to overcome some of these difficulties .",
    "all are based on unsupervised learning , often in an greedy layer - wise `` unsupervised pre - training '' stage  @xcite .",
    "one of these layer initialization techniques , applied here , is the denoising auto - encoder  ( da )  @xcite ( see figure  [ fig : da ] ) , which performed similarly or better than previously proposed restricted boltzmann machines in terms of unsupervised extraction of a hierarchy of features useful for classification .",
    "each layer is trained to denoise its input , creating a layer of features that can be used as input for the next layer .    in this paper",
    "we ask the following questions :    @xmath0 do the good results previously obtained with deep architectures on the mnist digit images generalize to the setting of a much larger and richer ( but similar ) dataset , the nist special database 19 , with 62 classes and around 800k examples ?",
    "@xmath0 to what extent does the perturbation of input images ( e.g. adding noise , affine transformations , background images ) make the resulting classifiers better not only on similarly perturbed images but also on the _ original clean examples _ ?",
    "we study this question in the context of the 62-class and 10-class tasks of the nist special database 19 .",
    "@xmath0 do deep architectures _ benefit * more * from such out - of - distribution _",
    "examples , i.e. do they benefit more from the self - taught learning  @xcite framework ? we use highly perturbed examples to generate out - of - distribution examples .",
    "@xmath0 similarly , does the feature learning step in deep learning algorithms benefit * more * from training with moderately _ different classes _",
    "( i.e. a multi - task learning scenario ) than a corresponding shallow and purely supervised architecture ?",
    "we train on 62 classes and test on 10 ( digits ) or 26 ( upper case or lower case ) to answer this question .",
    "our experimental results provide positive evidence towards all of these questions , as well as classifiers that reach human - level performance on 62-class isolated character recognition and beat previously published results on the nist dataset ( special database 19 ) . to achieve these results ,",
    "we introduce in the next section a sophisticated system for stochastically transforming character images and then explain the methodology , which is based on training with or without these transformed images and testing on clean ones .",
    "we measure the relative advantage of out - of - distribution examples ( perturbed or out - of - class ) for a deep learner vs a supervised shallow one .",
    "code for generating these transformations as well as for the deep learning algorithms are made available at http://hg.assembla.com/ift6266 .",
    "we estimate the relative advantage for deep learners of training with other classes than those of interest , by comparing learners trained with 62 classes with learners trained with only a subset ( on which they are then tested ) . the conclusion discusses the more general question of why deep learners may benefit so much from the self - taught learning framework . since out - of - distribution data ( perturbed or from other related classes ) is very common , this conclusion is of practical importance .",
    "l0.15     + * original *    this section describes the different transformations we used to stochastically transform @xmath1 source images ( such as the one on the left ) in order to obtain data from a larger distribution which covers a domain substantially larger than the clean characters distribution from which we start .",
    "although character transformations have been used before to improve character recognizers , this effort is on a large scale both in number of classes and in the complexity of the transformations , hence in the complexity of the learning task .",
    "the code for these transformations ( mostly python ) is available at http://hg.assembla.com/ift6266 .",
    "all the modules in the pipeline share a global control parameter ( @xmath2 ) that allows one to modulate the amount of deformation or noise introduced .",
    "there are two main parts in the pipeline .",
    "the first one , from slant to pinch below , performs transformations .",
    "the second part , from blur to contrast , adds different kinds of noise .         +    to change character *",
    "thickness * , morphological operators of dilation and erosion  @xcite are applied .",
    "the neighborhood of each pixel is multiplied element - wise with a _ structuring element _ matrix .",
    "the pixel value is replaced by the maximum or the minimum of the resulting matrix , respectively for dilation or erosion .",
    "ten different structural elements with increasing dimensions ( largest is @xmath3 ) were used . for each image",
    ", randomly sample the operator type ( dilation or erosion ) with equal probability and one structural element from a subset of the @xmath4 smallest structuring elements where @xmath5 for dilation and @xmath6 for erosion ( to avoid completely erasing thin characters ) . a neutral element ( no transformation )",
    "is always present in the set .",
    "+    to produce * slant * , each row of the image is shifted proportionally to its height : @xmath7 .",
    "@xmath8 $ ] .",
    "the shift is randomly chosen to be either to the left or to the right .",
    "a @xmath9 * affine transform * matrix ( with parameters @xmath10 ) is sampled according to the @xmath11 .",
    "output pixel @xmath12 takes the value of input pixel nearest to @xmath13 , producing scaling , translation , rotation and shearing .",
    "marginal distributions of @xmath10 have been tuned to forbid large rotations ( to avoid confusing classes ) but to give good variability of the transformation : @xmath14 and @xmath15 @xmath16 $ ] , @xmath17 and @xmath18 @xmath19 $ ] , and @xmath20 and @xmath21 $ ] .",
    "+          the * local elastic deformation * module induces a `` wiggly '' effect in the image , following  @xcite , which provides more details .",
    "the intensity of the displacement fields is given by @xmath22{complexity } \\times 10.0 $ ] , which are convolved with a gaussian 2d kernel ( resulting in a blur ) of standard deviation @xmath23{complexity}$ ] .",
    "+    the * pinch * module applies the `` whirl and pinch '' gimp filter with whirl set to 0 .",
    "a pinch is `` similar to projecting the image onto an elastic surface and pressing or pulling on the center of the surface '' ( gimp documentation manual ) . for a square input image ,",
    "draw a radius-@xmath24 disk around its center @xmath25 .",
    "any pixel @xmath26 belonging to that disk has its value replaced by the value of a `` source '' pixel in the original image , on the line that goes through @xmath25 and @xmath26 , but at some other distance @xmath27",
    ". define @xmath28 and @xmath29 , where @xmath30 is a parameter of the filter .",
    "the actual value is given by bilinear interpolation considering the pixels around the ( non - integer ) source position thus found . here",
    "@xmath31 $ ] .",
    "the * motion blur * module is gimp s `` linear motion blur '' , which has parameters @xmath32 and @xmath33 .",
    "the value of a pixel in the final image is approximately the mean of the first @xmath32 pixels found by moving in the @xmath33 direction , @xmath34 $ ] degrees , and @xmath35 .",
    "+    the * occlusion * module selects a random rectangle from an _ occluder _ character image and places it over the original _ occluded _ image .",
    "pixels are combined by taking the max(occluder , occluded ) , i.e. keeping the lighter ones .",
    "the rectangle corners are sampled so that larger complexity gives larger rectangles . the destination position in the occluded image",
    "are also sampled according to a normal distribution .",
    "this module is skipped with probability 60% .          with the * gaussian smoothing * module ,",
    "different regions of the image are spatially smoothed .",
    "this is achieved by first convolving the image with an isotropic gaussian kernel of size and variance chosen uniformly in the ranges @xmath36 $ ] and @xmath37 $ ] .",
    "this filtered image is normalized between @xmath38 and @xmath39 .",
    "we also create an isotropic weighted averaging window , of the kernel size , with maximum value at the center . for each image",
    "we sample uniformly from @xmath40 to @xmath41 pixels that will be averaging centers between the original image and the filtered one .",
    "we initialize to zero a mask matrix of the image size . for each selected pixel",
    "we add to the mask the averaging window centered on it .",
    "the final image is computed from the following element - wise operation : @xmath42 .",
    "this module is skipped with probability 75% .",
    "this module * permutes neighbouring pixels*. it first selects a fraction @xmath43 of pixels randomly in the image .",
    "each of these pixels is then sequentially exchanged with a random pixel among its four nearest neighbors ( on its left , right , top or bottom ) .",
    "this module is skipped with probability 80% .",
    "+          the * gaussian noise * module simply adds , to each pixel of the image independently , a noise @xmath44 . this module is skipped with probability 70% .          following  @xcite , the * background image * module adds a random background image behind the letter , from a randomly chosen natural image , with contrast adjustments depending on @xmath11 , to preserve more or less of the original character image .",
    "the * salt and pepper noise * module adds noise @xmath45 $ ] to random subsets of pixels .",
    "the number of selected pixels is @xmath46 .",
    "this module is skipped with probability 75% .       +    the * scratches * module places line - like white patches on the image .",
    "the lines are heavily transformed images of the digit `` 1 '' ( one ) , chosen at random among 500 such 1 images , randomly cropped and rotated by an angle @xmath47 ( in degrees ) , using bi - cubic interpolation .",
    "two passes of a grey - scale morphological erosion filter are applied , reducing the width of the line by an amount controlled by @xmath11 .",
    "this module is skipped with probability 85% .",
    "the probabilities of applying 1 , 2 , or 3 patches are ( 50%,30%,20% ) .          the * grey level and contrast * module changes the contrast by changing grey levels , and may invert the image polarity ( white to black and black to white ) .",
    "the contrast is @xmath48 $ ] so the image is normalized into @xmath49 $ ] .",
    "the polarity is inverted with probability 50% .",
    "much previous work on deep learning had been performed on the mnist digits task  @xcite , with 60  000 examples , and variants involving 10  000 examples  @xcite .",
    "the focus here is on much larger training sets , from 10 times to to 1000 times larger , and 62 classes .",
    "the first step in constructing the larger datasets ( called nistp and p07 ) is to sample from a _ data source _ : * nist * ( nist database 19 ) , * fonts * , * captchas * , and * ocr data * ( scanned machine printed characters ) . once a character is sampled from one of these sources ( chosen randomly ) , the second step is to apply a pipeline of transformations and/or noise processes described in section [ s : perturbations ] .    to provide a baseline of error rate comparison",
    "we also estimate human performance on both the 62-class task and the 10-class digits task .",
    "we compare the best multi - layer perceptrons ( mlp ) against the best stacked denoising auto - encoders ( sda ) , when both models hyper - parameters are selected to minimize the validation set error .",
    "we also provide a comparison against a precise estimate of human performance obtained via amazon s mechanical turk ( amt ) service ( http://mturk.com ) .",
    "amt users are paid small amounts of money to perform tasks for which human intelligence is required .",
    "mechanical turk has been used extensively in natural language processing and vision .",
    "amt users were presented with 10 character images ( from a test set ) and asked to choose 10 corresponding ascii characters .",
    "they were forced to choose a single character class ( either among the 62 or 10 character classes ) for each image .",
    "80 subjects classified 2500 images per ( dataset , task ) pair .",
    "different humans labelers sometimes provided a different label for the same example , and we were able to estimate the error variance due to this effect because each image was classified by 3 different persons .",
    "the average error of humans on the 62-class task nist test set is 18.2% , with a standard error of 0.1% .",
    "our main source of characters is the nist special database 19  @xcite , widely used for training and testing character recognition systems  @xcite .",
    "the dataset is composed of 814255 digits and characters ( upper and lower cases ) , with hand checked classifications , extracted from handwritten sample forms of 3600 writers .",
    "the characters are labelled by one of the 62 classes corresponding to `` 0''-``9'',``a''-``z '' and `` a''-``z '' .",
    "the dataset contains 8 parts ( partitions ) of varying complexity .",
    "the fourth partition ( called @xmath50 , 82587 examples ) , experimentally recognized to be the most difficult one , is the one recommended by nist as a testing set and is used in our work as well as some previous work  @xcite for that purpose .",
    "we randomly split the remainder ( 731668 examples ) into a training set and a validation set for model selection .",
    "the performances reported by previous work on that dataset mostly use only the digits . here",
    "we use all the classes both in the training and testing phase .",
    "this is especially useful to estimate the effect of a multi - task setting .",
    "the distribution of the classes in the nist training and test sets differs substantially , with relatively many more digits in the test set , and a more uniform distribution of letters in the test set ( whereas in the training set they are distributed more like in natural text ) .",
    "* fonts . * in order to have a good variety of sources we downloaded an important number of free fonts from : http://cg.scs.carleton.ca/~luc/freefonts.html . including the operating system s ( windows 7 ) fonts , there is a total of @xmath51 different fonts that we can choose uniformly from .",
    "the chosen ttf file is either used as input of the captcha generator ( see next item ) or , by producing a corresponding image , directly as input to our models . *",
    "captchas . *",
    "the captcha data source is an adaptation of the _ pycaptcha _ library ( a python based captcha generator library ) for generating characters of the same format as the nist dataset .",
    "this software is based on a random character class generator and various kinds of transformations similar to those described in the previous sections . in order to increase the variability of the data generated ,",
    "many different fonts are used for generating the characters .",
    "transformations ( slant , distortions , rotation , translation ) are applied to each randomly generated character with a complexity depending on the value of the complexity parameter provided by the user of the data source . * ocr data . * a large set ( 2 million ) of scanned , ocred and manually verified machine - printed characters where included as an additional source .",
    "this set is part of a larger corpus being collected by the image understanding pattern recognition research group led by thomas breuel at university of kaiserslautern ( http://www.iupr.com ) , and which will be publicly released .",
    "all data sets contain 32@xmath5232 grey - level images ( values in @xmath53 $ ] ) associated with a label from one of the 62 character classes .",
    "* this is the raw nist special database 19  @xcite .",
    "it has \\{651668 / 80000 / 82587 } \\{training / validation / test } examples .",
    "* this dataset is obtained by taking raw characters from all four of the above sources and sending them through the transformation pipeline described in section [ s : perturbations ] . for each new example to generate ,",
    "a data source is selected with probability @xmath54 from the fonts , @xmath55 from the captchas , @xmath55 from the ocr data and @xmath56 from nist .",
    "we apply all the transformations in the order given above , and for each of them we sample uniformly a _ complexity _ in the range @xmath57 $ ] .",
    "it has \\{81920000 / 80000 / 20000 } \\{training / validation / test } examples .",
    "* this one is equivalent to p07 ( complexity parameter of @xmath58 with the same proportions of data sources ) except that we only apply transformations from slant to pinch .",
    "therefore , the character is transformed but no additional noise is added to the image , giving images closer to the nist dataset .",
    "it has \\{81920000 / 80000 / 20000 } \\{training / validation / test } examples .",
    "the experiments are performed using mlps ( with a single hidden layer ) and sdas .",
    "_ hyper - parameters are selected based on the * nistp * validation set error",
    ". _    * multi - layer perceptrons ( mlp ) . *",
    "whereas previous work had compared deep architectures to both shallow mlps and svms , we only compared to mlps here because of the very large datasets used ( making the use of svms computationally challenging because of their quadratic scaling behavior ) .",
    "preliminary experiments on training svms ( libsvm ) with subsets of the training set allowing the program to fit in memory yielded substantially worse results than those obtained with mlps . for training on nearly a billion examples ( with the perturbed data ) , the mlps and sda are much more convenient than classifiers based on kernel methods .",
    "the mlp has a single hidden layer with @xmath59 activation functions , and softmax ( normalized exponentials ) on the output layer for estimating @xmath60 .",
    "the number of hidden units is taken in @xmath61 .",
    "training examples are presented in minibatches of size 20 .",
    "a constant learning rate was chosen among @xmath62 .    *",
    "stacked denoising auto - encoders ( sda ) .",
    "* various auto - encoder variants and restricted boltzmann machines ( rbms ) can be used to initialize the weights of each layer of a deep mlp ( with many hidden layers )  @xcite , apparently setting parameters in the basin of attraction of supervised gradient descent yielding better generalization  @xcite . this initial _ unsupervised pre - training phase _",
    "uses all of the training images but not the training labels .",
    "each layer is trained in turn to produce a new representation of its input ( starting from the raw pixels ) .",
    "it is hypothesized that the advantage brought by this procedure stems from a better prior , on the one hand taking advantage of the link between the input distribution @xmath63 and the conditional distribution of interest @xmath64 ( like in semi - supervised learning ) , and on the other hand taking advantage of the expressive power and bias implicit in the deep architecture ( whereby complex concepts are expressed as compositions of simpler ones through a deep hierarchy ) .",
    "here we chose to use the denoising auto - encoder  @xcite as the building block for these deep hierarchies of features , as it is simple to train and explain ( see figure  [ fig : da ] , as well as tutorial and code there : http://deeplearning.net/tutorial ) , provides efficient inference , and yielded results comparable or better than rbms in series of experiments @xcite . during training ,",
    "a denoising auto - encoder is presented with a stochastically corrupted version of the input and trained to reconstruct the uncorrupted input , forcing the hidden units to represent the leading regularities in the data .",
    "here we use the random binary masking corruption ( which sets to 0 a random subset of the inputs ) .",
    "once it is trained , in a purely unsupervised way , its hidden units activations can be used as inputs for training a second one , etc .",
    "after this unsupervised pre - training stage , the parameters are used to initialize a deep mlp , which is fine - tuned by the same standard procedure used to train them ( see previous section ) .",
    "the sda hyper - parameters are the same as for the mlp , with the addition of the amount of corruption noise ( we used the masking noise process , whereby a fixed proportion of the input values , randomly selected , are zeroed ) , and a separate learning rate for the unsupervised pre - training stage ( selected from the same above set ) .",
    "the fraction of inputs corrupted was selected among @xmath65",
    ". another hyper - parameter is the number of hidden layers but it was fixed to 3 based on previous work with sdas on mnist  @xcite .",
    "the size of the hidden layers was kept constant across hidden layers , and the best results were obtained with the largest values that we could experiment with given our patience , with 1000 hidden units .",
    "the models are either trained on nist ( mlp0 and sda0 ) , nistp ( mlp1 and sda1 ) , or p07 ( mlp2 and sda2 ) , and tested on either nist , nistp or p07 , either on the 62-class task or on the 10-digits task . training ( including about half for unsupervised pre - training , for das ) on the larger datasets takes around one day on a gpu-285 .",
    "figure  [ fig : error - rates - charts ] summarizes the results obtained , comparing humans , the three mlps ( mlp0 , mlp1 , mlp2 ) and the three sdas ( sda0 , sda1 , sda2 ) , along with the previous results on the digits nist special database 19 test set from the literature , respectively based on artmap neural networks  @xcite , fast nearest - neighbor search  @xcite , mlps  @xcite , and svms  @xcite .",
    "more detailed and complete numerical results ( figures and tables , including standard errors on the error rates ) can be found in appendix .",
    "the deep learner not only outperformed the shallow ones and previously published performance ( in a statistically and qualitatively significant way ) but when trained with perturbed data reaches human performance on both the 62-class task and the 10-class ( digits ) task .",
    "17% error ( sda1 ) or 18% error ( humans ) may seem large but a large majority of the errors from humans and from sda1 are from out - of - context confusions ( e.g. a vertical bar can be a `` 1 '' , an `` l '' or an `` l '' , and a `` c '' and a `` c '' are often indistinguishible ) .",
    "in addition , as shown in the left of figure  [ fig : improvements - charts ] , the relative improvement in error rate brought by self - taught learning is greater for the sda , and these differences with the mlp are statistically and qualitatively significant .",
    "the left side of the figure shows the improvement to the clean nist test set error brought by the use of out - of - distribution examples ( i.e. the perturbed examples examples from nistp or p07 ) .",
    "relative percent change is measured by taking @xmath66 ( original model s error / perturbed - data model s error - 1 ) .",
    "the right side of figure  [ fig : improvements - charts ] shows the relative improvement brought by the use of a multi - task setting , in which the same model is trained for more classes than the target classes of interest ( i.e. training with all 62 classes when the target classes are respectively the digits , lower - case , or upper - case characters ) . again , whereas the gain from the multi - task setting is marginal or negative for the mlp , it is substantial for the sda .",
    "note that to simplify these multi - task experiments , only the original nist dataset is used .",
    "for example , the mlp - digits bar shows the relative percent improvement in mlp error rate on the nist digits test set is @xmath67 ( single - task model s error / multi - task model s error - 1 ) .",
    "the single - task model is trained with only 10 outputs ( one per digit ) , seeing only digit examples , whereas the multi - task model is trained with 62 outputs , with all 62 character classes as examples .",
    "hence the hidden units are shared across all tasks . for the multi - task model , the digit error rate",
    "is measured by comparing the correct digit class with the output class associated with the maximum conditional probability among only the digit classes outputs .",
    "the setting is similar for the other two target classes ( lower case characters and upper case characters ) .",
    "as previously seen , the sda is better able to benefit from the transformations applied to the data than the mlp . in this experiment",
    "we define three tasks : recognizing digits ( knowing that the input is a digit ) , recognizing upper case characters ( knowing that the input is one ) , and recognizing lower case characters ( knowing that the input is one ) .",
    "we consider the digit classification task as the target task and we want to evaluate whether training with the other tasks can help or hurt , and whether the effect is different for mlps versus sdas .",
    "the goal is to find out if deep learning can benefit more ( or less ) from multiple related tasks ( i.e. the multi - task setting ) compared to a corresponding purely supervised shallow learner .",
    "we use a single hidden layer mlp with 1000 hidden units , and a sda with 3 hidden layers ( 1000 hidden units per layer ) , pre - trained and fine - tuned on nist .",
    "our results show that the mlp benefits marginally from the multi - task setting in the case of digits ( 5% relative improvement ) but is actually hurt in the case of characters ( respectively 3% and 4% worse for lower and upper class characters ) .",
    "on the other hand the sda benefited from the multi - task setting , with relative error rate improvements of 27% , 15% and 13% respectively for digits , lower and upper case characters , as shown in table  [ tab : multi - task ] .",
    "we have found that the self - taught learning framework is more beneficial to a deep learner than to a traditional shallow and purely supervised learner .",
    "more precisely , the answers are positive for all the questions asked in the introduction . @xmath0",
    "* do the good results previously obtained with deep architectures on the mnist digits generalize to a much larger and richer ( but similar ) dataset , the nist special database 19 , with 62 classes and around 800k examples * ?",
    "yes , the sda _ systematically outperformed the mlp and all the previously published results on this dataset _",
    "( the ones that we are aware of ) , _ in fact reaching human - level performance _ at around 17% error on the 62-class task and 1.4% on the digits , and beating previously published results on the same data .",
    "@xmath0 * to what extent do self - taught learning scenarios help deep learners , and do they help them more than shallow supervised ones * ?",
    "we found that distorted training examples not only made the resulting classifier better on similarly perturbed images but also on the _ original clean examples _ , and more importantly and more novel , that deep architectures benefit more from such _ out - of - distribution _ examples .",
    "mlps were helped by perturbed training examples when tested on perturbed input images ( 65% relative improvement on nistp ) but only marginally helped ( 5% relative improvement on all classes ) or even hurt ( 10% relative loss on digits ) with respect to clean examples . on the other hand ,",
    "the deep sdas were significantly boosted by these out - of - distribution examples .",
    "similarly , whereas the improvement due to the multi - task setting was marginal or negative for the mlp ( from + 5.6% to -3.6% relative change ) , it was quite significant for the sda ( from + 13% to + 27% relative change ) , which may be explained by the arguments below . in the original self - taught learning framework",
    "@xcite , the out - of - sample examples were used as a source of unsupervised data , and experiments showed its positive effects in a _ limited labeled data _ scenario . however , many of the results by @xcite ( who used a shallow , sparse coding approach ) suggest that the _ relative gain of self - taught learning vs ordinary supervised learning _ diminishes as the number of labeled examples increases .",
    "we note instead that , for deep architectures , our experiments show that such a positive effect is accomplished even in a scenario with a _ large number of labeled examples _ ,",
    "i.e. , here , the relative gain of self - taught learning is probably preserved in the asymptotic regime .    *",
    "why would deep learners benefit more from the self - taught learning framework * ?",
    "the key idea is that the lower layers of the predictor compute a hierarchy of features that can be shared across tasks or across variants of the input distribution",
    ". a theoretical analysis of generalization improvements due to sharing of intermediate features across tasks already points towards that explanation  @xcite .",
    "intermediate features that can be used in different contexts can be estimated in a way that allows to share statistical strength .",
    "features extracted through many levels are more likely to be more abstract ( as the experiments in  @xcite suggest ) , increasing the likelihood that they would be useful for a larger array of tasks and input conditions .",
    "therefore , we hypothesize that both depth and unsupervised pre - training play a part in explaining the advantages observed here , and future experiments could attempt at teasing apart these factors . and why would deep learners benefit from the self - taught learning scenarios even when the number of labeled examples is very large ? we hypothesize that this is related to the hypotheses studied in  @xcite . whereas in  @xcite it was found that online learning on a huge dataset did not make the advantage of the deep learning bias vanish , a similar phenomenon may be happening here .",
    "we hypothesize that unsupervised pre - training of a deep hierarchy with self - taught learning initializes the model in the basin of attraction of supervised gradient descent that corresponds to better generalization . furthermore",
    ", such good basins of attraction are not discovered by pure supervised learning ( with or without self - taught settings ) , and more labeled examples does not allow the model to go from the poorer basins of attraction discovered by the purely supervised shallow models to the kind of better basins associated with deep learning and self - taught learning .",
    "a flash demo of the recognizer ( where both the mlp and the sda can be compared ) can be executed on - line at http://deep.host22.com .",
    "these tables correspond to figures 2 and 3 and contain the raw error rates for each model and dataset considered .",
    "they also contain additional data such as test errors on p07 and standard errors .",
    ".overall comparison of error rates ( @xmath68 std.err . ) on 62 character classes ( 10 digits + 26 lower + 26 upper ) , except for last columns  digits only , between deep architecture with pre - training ( sda = stacked denoising autoencoder ) and ordinary shallow architecture ( mlp = multi - layer perceptron ) .",
    "the models shown are all trained using perturbed data ( nistp or p07 ) and using a validation set to select hyper - parameters and other training choices .",
    "\\{sda , mlp}0 are trained on nist , \\{sda , mlp}1 are trained on nistp , and \\{sda , mlp}2 are trained on p07 .",
    "the human error rate on digits is a lower bound because it does not count digits that were recognized as letters . for comparison ,",
    "the results found in the literature on nist digits classification using the same test set are included . [ cols=\"<,>,>,>,>\",options=\"header \" , ]"
  ],
  "abstract_text": [
    "<S> recent theoretical and empirical work in statistical machine learning has demonstrated the importance of learning algorithms for deep architectures , i.e. , function classes obtained by composing multiple non - linear transformations . </S>",
    "<S> self - taught learning ( exploiting unlabeled examples or examples from other distributions ) has already been applied to deep learners , but mostly to show the advantage of unlabeled examples . here </S>",
    "<S> we explore the advantage brought by _ out - of - distribution examples_. for this purpose we developed a powerful generator of stochastic variations and noise processes for character images , including not only affine transformations but also slant , local elastic deformations , changes in thickness , background images , grey level changes , contrast , occlusion , and various types of noise . </S>",
    "<S> the out - of - distribution examples are obtained from these highly distorted images or by including examples of object classes different from those in the target test set . </S>",
    "<S> we show that _ deep learners benefit more from out - of - distribution examples than a corresponding shallow learner _ , at least in the area of handwritten character recognition . </S>",
    "<S> in fact , we show that they beat previously published results and reach human - level performance on both handwritten digit classification and 62-class handwritten character recognition . </S>"
  ]
}