{
  "article_text": [
    "in - network function computation is one of the fundamental paradigms that increases the efficiency of sensor networks vs - a - vs conventional data networks .",
    "sensor nodes , in addition to sensing and communication capabilities , are often equipped with basic computational capabilities . depending on the task for which they are deployed",
    ", a sensor network can be viewed as a distributed platform for collecting and computing a specific function of the sensor data .",
    "for example , a sensor network for environment monitoring may only be concerned with keeping track of the average temperature and humidity in a region .",
    "similarly ` alarm ' networks , such as those for detecting forest fires , require only the maximum temperature .",
    "the baseline approach for performing such tasks is to aggregate all the data at a central node and then perform offline computations ; the premise of in - network computation is that distributed computation schemes can provide sizable improvement in the performance of the network .",
    "however , from the perspective of designing network algorithms , in - network function computation poses a greater challenge than data networks as the freedom to combine and compress packets , as long as the desired information is preserved , destroys the flow conservation laws central to data networks .",
    "the network has a lot more flexibility , so much so as to make quantifying its performance much more challenging @xcite .",
    "our focus in this paper is to develop a queue - based framework for such systems , and use it to design and analyze network algorithms . by network algorithms ,",
    "we refer to cross layer algorithms that jointly perform the following tasks :    1 .   _ aggregating _ the data at nodes via in - network computation , 2 .",
    "_ routing _ packets between nodes , and 3 .",
    "_ scheduling _ links between nodes for packet transmission .",
    "cross - layer algorithms for data networks , although very successful in both theory and increasingly in real - system implementation , are concerned only with the scheduling and routing aspects .",
    "hence , there is a need for a new framework and new algorithms for in - network function computation in sensor networks . keeping in mind the lessons learnt from the success of data networks ,",
    "our aim is to design network algorithms that are _ dynamic _",
    "( i.e. , the algorithm should not be designed assuming static network parameters , but rather , use the network state to adaptively learn the network parameters ) , _ robust _",
    "( i.e. , the algorithm adapts to temporal changes in traffic and network topology ) , _ capable of dealing with a large class of functions _",
    "( i.e. , if the function being computed by the network changes , then one should only need to make minor changes to the scheduling and routing algorithms ) , and _",
    "generalizable to all network topologies_.    due to the wide range of potential applications , there are many existing models for such networks , and many different perspectives from which they are analyzed .",
    "some representative works in this regard are as follows :    * the pioneering work of giridhar and kumar @xcite considers the function computation problem from the point of view of the capacity scaling framework of gupta and kumar @xcite .",
    "in particular , they quantify scaling bounds for certain classes of functions ( symmetric , divisible , type - sensitive , and type - threshold ) under the protocol model of wireless communications and for collocated graphs and random geometric graphs . *",
    "other papers consider the function computation problem from the point of view of information theory @xcite and communication complexity @xcite , characterizing various metrics ( refresh rate , number of messages , etc . ) for different functions in terms of certain properties of the graph , the function to be computed , and the underlying data correlation .",
    "all the above works take an idealized ` bottom - up ' approach to determine the fundamental limits of the problem , and hence are not directly suitable for designing practical network algorithms . *",
    "similar in spirit to the above papers , another approach is to study function computation from the perspective of source coding@xcite .",
    "these works characterize bounds and show the existence of coding schemes for noiseless , wireline networks . as with the previous algorithms , these policies tend to be idealized , using more complex coding - based schemes instead of simple routing and aggregation ( we will later show that such simple strategies suffice for optimal in - network computation of a number of functions of interest ) ; further , these papers do not have explicitly defined policies but rather existence results for such policies .",
    "* in contrast to the ` bottom - up ' approach of all the above works , krishnamachari et al .",
    "@xcite adopt a more ` top - down ' approach whereby they formulate network models that abstract out some of the complexity while allowing quantification of performance gains ( in their case , energy and delay ) .",
    "their models do not , however , achieve the optimal throughput and also do not allow for the design of dynamic network algorithms .",
    "* an alternate model of sensor networks is to assume that nodes are capable of in - network _ compression _ , wherein only the compression ( and not merging ) of flows is permitted .",
    "for example , baek et al .",
    "@xcite consider routing algorithms for power savings in hierarchical sensor networks .",
    "similarly , sharma et al .",
    "@xcite design energy - efficient queue - based algorithms under the assumption that the only operation allowed in addition to routing and scheduling is compression of packets at the source node .",
    "the queue - based model for data networks has proved to be an essential tool in designing provably - efficient algorithms for such systems .",
    "this model has provided a common framework for understanding various aspects of data network performance such as throughput @xcite , delay @xcite , flow utility maximization @xcite , network utility maximization @xcite , distributed algorithms @xcite , among others ( for an overview , refer to @xcite ) . in addition , these algorithms have been implemented in real systems @xcite , including in sensor networks @xcite , with good results . however ,",
    "these algorithms are designed for data networks , and can not exploit any potential benefit from in - network computation .",
    "more recently , this framework has been extended to fork - and - join networks with fixed routing@xcite , and resource allocation in processing networks@xcite .",
    "using fixed routing in a network usually leads to suboptimal operations as the routes may not be designed to optimize the network performance ; in general , even choosing the single best fixed route can perform arbitrarily worse than with dynamic routing ( see example in section  [ sec : refrate ] ) .",
    "further , static routing is not robust to temporal changes in the network .",
    "however , introducing dynamic routing with in - network computation destroys the flow conservation equations that exist in data networks and networks with fixed flows , as the flow out of a node depends both on inflow as well as ( dynamic ) packet aggregation at that node .",
    "thus , there is a need to come up with a new queue - based framework and algorithms for efficient function computation in sensor networks , and our paper is a step in this direction .",
    "our main contributions in this paper are as follows :    * we identify a class of functions , the fully - multiplexible or fmux functions , for which we provide a tight characterization of the maximum refresh rate with in - network computation , i.e. , the maximum rate at which the sensors can generate data such that the computation can be performed in a stable manner .",
    "more formally , we show that for these functions , if the refresh rate exceeds a certain graph parameter ( the stochastic min - min - cut , which we define formally in section [ sec : refrate ] ) , then the system is transient under _ any _ algorithm , whereas for any rate lower than this parameter , we construct a policy that can stabilize the system . * leveraging the results of massouli et al .",
    "@xcite on _ broadcasting _ , we obtain a wireline routing algorithm for _ aggregation _ via in - network computation of fmux functions in directed acyclic graphs .",
    "our approach is based on the observation that broadcasting and aggregation are in some sense , duals , of each other .",
    "more technically , the duality occurs between isolation of packets in aggregation ( i.e. , a packet does not have neighboring packets to aggregate with ) and that of multiple receptions of the same packet ( from different neighbors ) in broadcasting . by suitably modifying the approach in @xcite",
    ", we are able to develop an in - network aggregation algorithm for which routing is completely decentralized , and simple random packet forwarding and aggregation suffices for throughput - optimality . * for general wireless networks",
    "we develop dynamic algorithms based on a centralized allocation of routes ( dynamic flow splitting ) and maxweight - type scheduling .",
    "in particular , we show that loading rounds on trees in a greedy manner ( whereby an incoming round is loaded on the least weighted aggregation tree ) , coupled with an appropriate scheduling rule , is throughput - optimal for computing fmux functions .",
    "the analysis of this algorithm is unique in that in addition to an appropriate lyapunov function , it requires the construction of appropriate tree - packings of the network graph in order to show the throughput - optimality of this routing scheme .",
    "notation : throughout the paper , we use calligraphic fonts ( @xmath1 , etc . ) to denote sets and the corresponding capital letter ( @xmath2 , etc . ) to denote their cardinality .",
    "we interchangeably use @xmath3 or @xmath4 for adding elements to sets , and @xmath5 for deleting elements from sets , and sometimes for brevity of exposition , use the element @xmath6 to denote the singleton set @xmath7 when the meaning is clear from the context ( in particular , for a set @xmath8 and element @xmath6 , @xmath9 ) .",
    "we also use the shorthand notation @xmath10\\triangleq\\{1,2,\\ldots , n\\}$ ] .",
    "in this section we describe the system model we study in the rest of the paper . at a high level ,",
    "the system consists of a network of @xmath11 nodes , one of which is the data aggregator and the rest are sensors .",
    "sensor nodes are capable of three tasks : sensing the environment , transmitting to and receiving data from other nodes , and performing computations on the data .",
    "the sensors are assumed to _ sense the environment in a synchronous manner _ , and the overall purpose of the system is to compute a specific function of the synchronously generated sensor data and forward it to the aggregator .",
    "further , the function computation is assumed to be done in a repeated manner , and the metric used to quantify the efficacy of an algorithm is the maximum synchronous rate at which the sensors can generate data such that the required function of the data can be forwarded to the aggregator in a stable manner .",
    "this rate is henceforth referred to as the _ maximum refresh rate _ of the network .",
    "before we describe the queueing framework for function computation , we first outline the general communication model that we consider in this work .",
    "this model is the same as that considered for studying data networks @xcite . in the next section , we will outline the modifications we make in order to capture the in - network computation aspect of a sensor network .    *",
    "communication graph : * we model the topology of the sensor network as a directed graph @xmath12 , where @xmath13 is a set of @xmath11 nodes , and @xmath14 is a set of @xmath15 directed links which determine the connectivity between nodes .",
    "there is a special node , @xmath16 , referred to as the _ aggregator _ , and the rest of the nodes in @xmath13 are sensor nodes .",
    "directed link @xmath17 represents that there exists a communication channel from node @xmath6 to node @xmath18 ( in wireline this corresponds to a physical channel , while in wireless it represents the fact that the nodes are in radio range ) .",
    "* transmission model : * following the convention in literature @xcite , we consider a continuous time system in case of wireline systems , whereas in the case of wireless networks , we assume that time is slotted , and state all rates in bits per slot . in wireline networks ,",
    "we define a vector of link rates @xmath19 ; one bit is assumed to traverse a link @xmath20 with a random transit time with distribution _ _ exponential__@xmath21 .",
    "the transit times are independent across links and across packets crossing the same link .    for wireless networks ,",
    "we make the following assumptions / definitions @xcite :    * we assume that the channels between nodes are constant ( but can extend to time varying channels with added notation , see @xcite ) .",
    "the wireless nature of the network is reflected in the interference constraints . * for transmission schedule @xmath22",
    ", @xmath23 denotes the link - rate vector of transmission rates over the links under the chosen schedule .",
    "* @xmath24 is the set of valid schedules that obey the interference constraints ( henceforth referred to as independent sets ) .",
    "@xmath25 is said to be _",
    "admissible _ if the link - rates can be achieved simultaneously in a time slot .",
    "@xmath26 is the set of all admissible @xmath25 and is assumed to be time invariant as stated above .",
    "further , we assume that @xmath27 .",
    "* @xmath28 is said to be _ obtainable _ if @xmath29 , the convex hull of @xmath30 .",
    "an obtainable link - rate vector can be achieved by time sharing over admissible link - rate vectors .",
    "* from the definition of the convex hull , we have that for every obtainable rate vector @xmath29 , there exists a probability measure @xmath31 over @xmath32 such that @xmath33 .",
    "the vectors @xmath34 are called static service split ( or sss ) rules@xcite , and represent time sharing fractions between different independent sets in order to achieve the rate @xmath28 .    up to this point ,",
    "the system is identical to one considered for data networks . to highlight the unique features of a physical sensor network performing function computation ( and how they affect the modeling of such a system ) , we consider the following example . in the process",
    ", we also indicate the gains achievable via in - network computation versus data download and processing at the aggregator .",
    "[ cols= \" < \" , ]      finally we present the complete dynamic algorithm for fmux computation .",
    "the algorithm separates the routing and scheduling components as follows : when a round of packets arrives in the network , we first ` load ' all packets of the round on an aggregation tree ( thereby fixing the routing ) ; next , in each time slot , scheduling is done according to a modified maxweight policy .",
    "the routing is performed using a _ greedy tree - loading policy _ , wherein all incoming rounds in a time slot are loaded on the tree with smallest sum useful - queue , i.e. , least number of useful packets .",
    "formally , we have :    [ algo : treechoosealgo ] calculate @xmath35\\right)$ ] for all @xmath36 .",
    "+ find the minimum loaded tree @xmath37 $ ] as : @xmath38=\\arg\\min_{\\tau\\in\\mathcal{t } } w_{\\tau}[t].\\ ] ] assign all incoming rounds to aggregation tree @xmath37 $ ] .",
    "the scheduling algorithm is similar to the maxweight policy@xcite , in that it picks a maximum independent set with weights given by the product of the rate and the maximum queue across an edge .",
    "formally we have the following algorithm :    [ algo : compbpalgo1 ] place packets arriving on tree @xmath39 at node @xmath40 in @xmath41 $ ] for non - leaf nodes , and @xmath42 $ ] for leaf nodes .",
    "+ calculate @xmath43=\\max_{\\tau\\in\\mathcal{t}:(i , j)\\in\\tau}q_i^{\\tau , u}[t]$ ] .",
    "also define @xmath44 $ ] as the tree which maximizes @xmath43 $ ] .",
    "+ compute schedule @xmath45 $ ] as : @xmath46=\\arg\\max_{\\mathbf{c}\\in\\gamma}\\sum_{(i , j)\\in\\mathcal{l}}p_{ij}[t]c_{ij}[t].\\ ] ] + consider link @xmath47 .",
    "if @xmath48>0 $ ] , then transmit the first @xmath49 , q_i^{\\tau^*(i , j)[t],u}[t])$ ] packets from @xmath50,nu}[t]$ ] .",
    "for the sake of completeness , we note that in all the above algorithms , tie - breaking rules as well as the service discipline ( i.e. , among a set of multiple packets suitable for transmission , which one gets priority ) are assumed to be random ; this is done for the sake of convenience , and we note that there are many possible tie - breaking rules and service disciplines which would suffice .",
    "now we can state and prove the throughput optimality of this algorithm .",
    "[ thm : treesss ] the dynamic queue based policy consisting of greedy tree loading ( algorithm [ algo : treechoosealgo ] ) and maxweight scheduling ( algorithm [ algo : compbpalgo1 ] ) stabilizes the system for any refresh rate @xmath51 that is less than the maximum refresh rate @xmath52 .    before proceeding further , we point out a particular novel aspect of the proof of this theorem .",
    "similar to previous papers @xcite , we use a quadratic lyapunov function for showing stability ; however our technique for bounding the lyapunov drift is quite different from those used for point - to - point data .",
    "the difficulty arises from the fact that although edmonds theorem guarantees the existence of an optimal tree - packing for the network , the trees in this optimal packing are unknown to the algorithm ; consequently it is unclear whether routing over all trees could lead to instability via packet accumulation on trees not involved in the optimal packing .",
    "we circumvent this by showing the existence of some intermediate tree packings between the optimal and the desired refresh rates , which allow uniform bounding of the lyapunov drift .",
    "we now present the complete proof .",
    "we define a candidate lyapunov function @xmath53 $ ] as @xmath54=\\sum_{i\\in\\mathcal{n}}\\sum_{\\tau\\in\\mathcal{t}}q_i^{\\tau , u}[t]^2,\\end{aligned}\\ ] ] with corresponding lyapunov drift given by @xmath55=\\mathbb{e}[v[t+1]-v[t]|\\mathbf{q}[t]].\\ ] ] similar to before , we have that @xmath53\\geq 0 $ ] for all states of the system , and that @xmath56<\\infty$ ] . we now need to show that given @xmath57 , there exists @xmath58 such that if @xmath59>q_{\\max}$ ] for some @xmath40 , then @xmath56<-\\delta$ ] .",
    "now we have @xmath55=\\sum_{i\\in\\mathcal{n}}\\sum_{\\tau\\in\\mathcal{t}}\\mathbb{e}\\left[(\\delta q_i^{\\tau , u}[t])^2 + 2q_i^{\\tau , u}[t]\\delta q_i^{\\tau , u}[t]|\\mathbf{q}[t]\\right],\\ ] ] and defining @xmath60 $ ] to be arrival of useful packets on tree @xmath39 to node @xmath40 , we have @xmath61=a_i^{\\tau , u}[t]-d_{(i , p^{\\tau}(i))}^{\\tau}[t],\\ ] ] and thus @xmath62)^2\\leq m_a + ( lc_{\\max})^2 $ ] ( due to external arrivals plus inter - node transmissions ) .",
    "let @xmath63 .",
    "then we have @xmath55\\leq m_2 + 2\\sum_{i\\in\\mathcal{n}}\\sum_{\\tau\\in\\mathcal{t}}q_i^{\\tau , u}[t]\\mathbb{e}\\left[a_i^{\\tau , u}[t]-d_{(i , p^{\\tau}(i))}^{\\tau}[t]|\\mathbf{q}[t]\\right].\\ ] ]    from the definition of @xmath52 , we know that there exists an optimal rate point @xmath64 and the corresponding optimal sss rule @xmath65 that maximizes the min - mincut .",
    "consider now a refresh rate @xmath51 less than the @xmath52 , such that @xmath66 .",
    "note that the algorithm can potentially split the incoming flow @xmath51 over _ every spanning tree _ of the network , in order to dynamically arrive at the optimal packing . to uniformly bound the lyapunov drift",
    ", we first need to construct two tree packings : an ` achievable ' packing @xmath67 such that @xmath68 which serves as a proxy for the flow - splitting , and a ` near - optimal ' packing @xmath69 such that @xmath70 and further which has the property that @xmath71 _ uniformly over all spanning trees _ ( for some @xmath72 which we define below ) .",
    "we do so as follows .",
    "assume that there exists @xmath73 such that if any edge @xmath20 is scheduled alone ( i.e. @xmath74 ) , then @xmath75 ( this is simply a formal definition of existence of a link ) .",
    "we can now perturb the optimal sss rule to get a new rate point @xmath76 with the following two properties :    1 .",
    "every edge @xmath20 has capacity @xmath77 .",
    "2 .   the min - mincut of the network at the rate point @xmath78 is @xmath79 .",
    "this helps ensure that the ` near - optimal ' tree packing @xmath80 can have some mass on each edge of the graph .    to construct the perturbed sss rule @xmath81 ,",
    "consider the optimal sss rule @xmath82 .",
    "we define @xmath83 ( i.e. , the set of independent sets that have some mass under @xmath65 ) and @xmath84 ( which is @xmath85 as the cardinality of @xmath86 is finite ) .",
    "now we reduce each @xmath87 by @xmath88 .",
    "this reduces the min - mincut by at most @xmath89 . to see this , note that the capacity of any edge @xmath90 reduces from @xmath91 to @xmath92 where : @xmath93 further , the maximum number of edges across the min - mincut is bounded by @xmath15 .",
    "thus the min - mincut of the network at the rate point @xmath78 is @xmath79 .",
    "next , suppose @xmath94 is the set of edges with zero flow under @xmath65 .",
    "we now complete the definition of the perturbed sss rule @xmath81 ( using the fact that singleton edges are valid independent sets ) as follows : @xmath95 to see that this is a valid sss rule , note that @xmath96 , which is the weight we have distributed equally over all links in @xmath94 .",
    "the rate point under this sss rule is henceforth denoted as @xmath97 .",
    "then for edges in @xmath94 we have @xmath98 .",
    "now since there are only @xmath15 edges , each with positive capacity @xmath92 , therefore there exists some @xmath99 such that every edge @xmath20 has capacity @xmath100 under sss rule @xmath81 .",
    "finally , applying edmonds theorem ( theorem  [ thm : edmonds ] ) on the network under @xmath81 , we get a packing @xmath101 such that we have @xmath102 before proceeding further , we need the following definitions :    * @xmath103 .",
    "* @xmath104 .",
    "* @xmath105 . * @xmath106 .",
    "note that @xmath107 as @xmath108 and the packing is not tight on the finite set @xmath109 .",
    "similarly , @xmath110 .",
    "finally we can construct the tree packings ( on the network under sss rule @xmath81 ) that we need to bound the lyapunov drift :    1 .",
    "the ` achievable ' tree packing , @xmath111 is defined as : @xmath112 then clearly @xmath113 is a packing ( as we are only removing mass from a valid packing ) and further : @xmath114 2 .",
    "the ` near - optimal ' tree packing , @xmath115 is defined as : @xmath116 first we need to show that this is a valid tree packing .",
    "to see this , note that the maximum load added on any edge is bounded by @xmath117 ( since in the worst case , all the trees in @xmath118 can contain some edge ) . for any edge in @xmath109 , this is less than the slack ( @xmath119 by definition ) that was already present .",
    "for an edge in @xmath120 , we know at least one tree in @xmath121 contained it ( as every edge in the graph has positive capacity under the sss rule @xmath81 ) , and hence we subtract a load of at least @xmath122 , which is again greater than the amount of load we add .",
    "thus @xmath115 is a valid packing .",
    "+ further we have that @xmath123 .",
    "+    in addition , defining @xmath124 we get that @xmath125 .",
    "thus we have constructed the two tree packings we need .",
    "we now return to bounding the lyapunov drift . from above",
    ", we have @xmath55\\leq m_2 + 2\\sum_{i\\in\\mathcal{n}}\\sum_{\\tau\\in\\mathcal{t}}q_i^{\\tau , u}[t]\\mathbb{e}\\left[a_i^{\\tau , u}[t]-d_{(i , p^{\\tau}(i))}^{\\tau}[t]|\\mathbf{q}[t]\\right].\\ ] ] now , let @xmath126 $ ] be the rate for packets on aggregation tree @xmath39 on link @xmath127 allocated by the policy in time slot @xmath128 ( thus @xmath129=c_{(i , p^{\\tau}(i))}[t]$ ] ) .",
    "then we have @xmath130\\mathbb{e}&\\left[d_{(i , p^{\\tau}(i))}^{\\tau}[t]|\\mathbf{q}[t]\\right]\\\\ & = \\sum_{i\\in\\mathcal{n}}\\sum_{\\tau\\in\\mathcal{t}}q_i^{\\tau , u}[t]\\mathbb{e}\\left[c_{ip^{\\tau}(i)}^{\\tau}[t]-\\max\\{c_{ip^{\\tau}(i)}^{\\tau}[t]-q^{\\tau , u}_i[t],0\\}|\\mathbf{q}[t]\\right]\\\\ & \\geq\\sum_{i\\in\\mathcal{n}}\\sum_{\\tau\\in\\mathcal{t}}q_i^{\\tau , u}[t]\\mathbb{e}\\left[c_{ip^{\\tau}(i)}^{\\tau}[t]-\\max\\{c_{\\max}-q^{\\tau , u}_i[t],0\\}|\\mathbf{q}[t]\\right]\\\\ & \\geq\\sum_{i\\in\\mathcal{n}}\\sum_{\\tau\\in\\mathcal{t}}q_i^{\\tau , u}[t]\\mathbb{e}\\left[c_{(i , p^{\\tau}(i))}^{\\tau}[t]\\right]-nl|\\mathcal{t}|c_{\\max}^2.\\end{aligned}\\ ] ] further , from the definition of the policy , we know that @xmath130\\mathbb{e}&\\left[c_{(i , p^{\\tau}(i))}^{\\tau}[t]|\\mathbf{q}[t]\\right]\\\\ & = \\mathbb{e}\\left[\\max_{\\mathbf{c}\\in\\gamma}\\sum_{(i , j)\\in\\mathcal{l}}\\max_{\\tau\\in\\mathcal{t}:(i , j)\\in\\tau}\\left\\{q_i^{\\tau , u}[t]\\right\\}c_{ij}[t]|\\mathbf{q}[t]\\right]\\\\ & \\geq\\max_{\\mathbf{c}\\in\\gamma}\\sum_{(i , j)\\in\\mathcal{l}}\\max_{\\tau\\in\\mathcal{t}:(i , j)\\in\\tau}\\left\\{q_i^{\\tau , u}[t]\\right\\}\\mathbb{e}\\left[c_{ij}[t]|\\mathbf{q}[t]\\right]\\\\ & \\geq\\max_{\\mathbf{c}\\in\\mathcal{ch}(\\gamma)}\\sum_{(i , j)\\in\\mathcal{l}}\\max_{\\tau\\in\\mathcal{t}:(i , j)\\in\\tau}\\left\\{q_i^{\\tau , u}[t]\\right\\}\\mathbb{e}\\left[c_{ij}[t]|\\mathbf{q}[t]\\right]\\\\ & \\geq\\max_{\\mathbf{c}\\in\\mathcal{ch}(\\gamma)}\\sum_{(i , j)\\in\\mathcal{l}}\\sum_{\\tau\\in\\mathcal{t}:(i , j)\\in\\tau}q_i^{\\tau , u}[t]\\mathbb{e}\\left[c_{ij}^{\\tau}[t]|\\mathbf{q}[t]\\right]\\\\ & \\mbox{(where $ c_{ij}^{\\tau}[t]$ is any tree - packing of a given $ \\mathbf{c}\\in\\mathcal{ch}(\\gamma)$)}\\\\ & \\geq\\sum_{(i , j)\\in\\mathcal{l}}\\sum_{\\tau\\in\\mathcal{t}:(i , j)\\in\\tau}q_i^{\\tau , u}[t]\\hat{c}_{ij}^{\\tau},\\end{aligned}\\ ] ] where for any edge @xmath47 , @xmath131 represents any valid split of @xmath132 between trees lying on that edge , i.e. , @xmath133 .",
    "in particular , therefore , we can use the tree packing @xmath115 to get @xmath134\\mathbb{e}\\left[c_{(i , p^{\\tau}(i))}^{\\tau}[t]|\\mathbf{q}[t]\\right ] \\geq\\sum_{i\\in\\mathcal{n}}\\sum_{\\tau\\in\\mathcal{t}}q_i^{\\tau , u}[t]\\hat{\\lambda}^{\\tau}.\\end{aligned}\\ ] ] combining inequalities , and defining @xmath135 we get @xmath136\\leq m_3 + 2\\sum_{i\\in\\mathcal{n}}\\sum_{\\tau\\in\\mathcal{t}}q_i^{\\tau , u}[t]\\left(\\mathbb{e}\\left[a_i^{\\tau}[t]|\\mathbf{q}[t]\\right]-\\hat{\\lambda}^{\\tau}\\right).\\end{aligned}\\ ] ]    finally , define @xmath137 $ ] to be the rate of rounds arriving on tree @xmath39 . then from the greedy round - tree assignment algorithm , and using the fact that each round results in exactly one useful packet at each node , we get    _ i_q_i^,u[t ] & + & = _ i_q_i^,u[t ] + & = + & _ \\{a^[t]}_i_q_i^,u[t ] + & _",
    "i_q_i^,u[t]_.    thus we get @xmath136&\\leq m_3 - 2\\sum_{i\\in\\mathcal{n}}\\sum_{\\tau\\in\\mathcal{t}}q_i^{\\tau , u}[t](\\hat{\\lambda}_{\\tau}-\\lambda_{\\tau}')\\\\ & \\leq m_3 - 2\\epsilon_4\\sum_{i\\in\\mathcal{n}}\\sum_{\\tau\\in\\mathcal{t}}q_i^{\\tau , u}[t].\\end{aligned}\\ ] ] in order to have @xmath56<-\\delta$ ] if @xmath138\\geq q_i^{\\tau , u}[t]>q_{\\max}$ ] for some @xmath139 , we can choose @xmath140 .",
    "thus @xmath53 $ ] is a valid lyapunov function and by foster s theorem , our policy is stabilizing for any @xmath141 .",
    "we have presented a queueing - based framework for in - network function computation .",
    "we have used this framework to gain insights into designing dynamic and distributed algorithms for in - network function computation and to quantify the performance gains over data - download .",
    "we have focused on a class of functions , the fmux functions , which exhibit maximum compression on aggregation , and for which we have used the parity and max functions as representative examples . for such functions we have developed scheduling and routing algorithms under different settings . for wireline networks ,",
    "we have extended the random routing scheme of massouli et al .",
    "@xcite for aggregation . for wireless networks , we have provided a fixed - routing via dynamic flow splitting along with maxweight - like scheduling , which is shown to be throughput - optimal .",
    "the wireless algorithm , as presented , requires routing on all aggregation trees in order to achieve throughput optimality ; this may not be practical in many networks due to the potentially exponential number of trees .",
    "however , as we showed in the example with the complete graph , one can obtain optimal tree packings with a much smaller number of trees ( of the order of @xmath15 ) and one direction of future work is to show how such trees can be selected using simple rules in different networks .    generalizing these algorithms to deal with a broader class of functions , as well as studying the performance of the algorithms with respect to other metrics ( delay , energy consumption , among others ) are other topics for future work .",
    "this work was supported in part by afosr under grant fa9550 - 09 - 1 - 0317 , nsf grants cns-0519535/0519401 ( collaborative grant ) and cns-0964391 .",
    "10    a.  giridhar and p.  r. kumar , `` computing and communicating functions over sensor networks , '' _ ieee journal on selected areas in communications _ ,",
    "23 , no .  4 , pp .",
    "755764 , 2005 .",
    "p.  gupta and p.  r. kumar , `` the capacity of wireless networks , '' _ ieee transactions on information theory _ , vol .",
    "46 , no .  2 , pp .",
    "388404 , 2000 .",
    "a.  orlitsky and j.  r. roche , `` coding for computing , '' _ ieee transactions on information theory _ , vol .",
    "47 , no .  3 , pp .",
    "903917 , 2001 .",
    "n.  ma , p.  ishwar , and p.  gupta , `` information - theoretic bounds for multiround function computation in collocated networks , '' _ corr _ , vol .",
    "abs/0901.2356 , 2009 .",
    "h.  kowshik and p.  r. kumar , `` optimal computation of symmetric boolean functions in tree networks , '' in _ ieee international symposium on information theory  isit 2010 _ , ieee , july 2010 .",
    "r.  appuswamy , m.  franceschetti , n.  karamchandani , and k.  zeger , `` network coding for computing part i : cut - set bounds , '' _ corr _ , vol .",
    "abs/0912.2820 , 2009 .",
    "t.  moscibroda , `` the worst - case capacity of wireless sensor networks , '' in _ internat .",
    "workshop on inform .",
    "processing in sensor networks ( ipsn ) _ , pp .  110 , 2007 .",
    "b.  krishnamachari , d.  estrin , and s.  b. wicker , `` the impact of data aggregation in wireless sensor networks , '' in _ proc .",
    "the 26th ieee internat .",
    "conf . distributed computing systems ( icdcs ) _ , pp .  575578 , 2002 .",
    "n.  karamchandani , l.  keller , c.  fragouli , and m.  franceschetti , `` function computation via subspace coding , '' in _ proc .",
    "information theory ( isit ) _ , ieee , july 2010 .",
    "s.  j. baek , g.  de  veciana , and x.  su , `` minimizing energy consumption in large - scale sensor networks through distributed data compression and hierarchical aggregation , '' _ ieee journal on selected areas in communications _ ,",
    "22 , no .  6 , pp .",
    "11301140 , 2004 .",
    "a.  sharma , l.  golubchik , r.  govindan , and m.  j. neely , `` dynamic data compression in multi - hop wireless networks , '' in _ proc .",
    "acm sigmetrics / performance conf .",
    "_ , pp .  145156 , 2009 .",
    "l.  tassiulas and a.  ephremides , `` stability properties of constrained queueing systems and scheduling policies for maximum throughput in multihop radio networks , '' _ ieee transactions on automatic control _ , vol .  4 , pp .",
    "19361948 , december 1992 .",
    "m.  andrews , k.  kumaran , k.  ramanan , a.  l. stolyar , r.  vijayakumar , and p.  whiting , `` scheduling in a queueing system with asynchronously varying service rates , '' _ probability in engineering and informational sciences _ , vol .  14 , pp .  191217 , 2004 .",
    "l.  bui , r.  srikant , and a.  l. stolyar , `` novel architectures and algorithms for delay reduction in back - pressure scheduling and routing , '' in _ proc .",
    "ieee infocom .",
    "_ , pp .  29362940 , 2009 .",
    "m.  j. neely , `` delay analysis for maximal scheduling with flow control in wireless networks with bursty traffic , '' _ ieee / acm trans .",
    "_ , vol .",
    "17 , no .  4 , pp .",
    "11461159 , 2009 .",
    "x.  lin , n.  shroff , and r.  srikant , `` a tutorial on cross - layer optimization in wireless networks , '' _ ieee journal on selected areas in communications _ , pp .  14521463 , august 2006 .",
    "l.  bui , r.  srikant , and a.  l. stolyar , `` optimal resource allocation for multicast flows in multihop wireless networks , '' _ proc .",
    "acm sigmetrics / performance evaluation review conf .",
    "_ , vol .",
    "35 , no .  3 , p.  43",
    ", 2007 .",
    "l.  lin , n.  b. shroff , and r.  srikant , `` energy - aware routing in sensor networks : a large system approach , '' _ ad hoc netw .",
    "_ , vol .  5 , no .  6 , pp .",
    "818831 , 2007 .",
    "l.  ying , s.  shakkottai , and a.  reddy , `` on combining shortest - path and back - pressure routing over multihop wireless networks , '' in _ proc .",
    "ieee infocom .",
    "_ , pp .  16741682 , 2009 .",
    "a.  l. stolyar , `` maximizing queueing network utility subject to stability : greedy primal - dual algorithm , '' _ queueing syst .",
    "_ , vol .",
    "50 , no .  4 , pp .",
    "401457 , 2005 .",
    "l.  jiang , d.  shah , j.  shin , and j.  c. walrand , `` distributed random access algorithm : scheduling and congesion control , '' _ corr _ , vol .",
    "abs/0907.1266 , 2009 .",
    "l.  georgiadis , m.  j. neely , and l.  tassiulas , `` resource allocation and cross - layer control in wireless networks , '' _ foundations and trends in networking _ , vol .  1 , pp .  1144 , 2006 .",
    "u.  akyol , m.  andrews , p.  gupta , j.  d. hobby , i.  saniee , and a.  l. stolyar , `` joint scheduling and congestion control in mobile ad - hoc networks , '' in _ proc .",
    "ieee infocom .",
    "_ , pp .  619627 , 2008 .",
    "j.  ryu , v.  bhargava , n.  paine , and s.  shakkottai , `` design , implementation and evaluation of back - pressure routing / rate control for intermittently connected networks , '' in _ acm int .",
    "conf . on mobile computing and networking ( mobicom ) _ ,",
    "s.  moeller , a.  sridharan , b.  krishnamachari , and o.  gnawali , `` routing without routes : the backpressure collection protocol , '' in _ internat .",
    "workshop on inform .",
    "processing in sensor networks ( ipsn ) _ , pp .  279290 , 2010 .",
    "h.  zhao , c.  h. xia , z.  liu , and d.  towsley , `` a unified modeling framework for distributed resource allocation of general fork and join processing networks , '' in _ proc .",
    "acm sigmetrics conf .",
    "_ , 2010 .",
    "l.  jiang , and j.  c. walrand , `` stable and utility - maximizing scheduling for stochastic processing networks , '' _ proc .",
    "allerton conf .",
    "communication , control , and computing _",
    ", 2009 .",
    "l.  massouli , a.  twigg , c.  gkantsidis , and p.  rodriguez , `` randomized decentralized broadcasting algorithms , '' in _ proc .",
    "ieee infocom .",
    "_ , pp .  10731081 , 2007 .",
    "h.  kowshik and p.  r. kumar , `` zero - error function computation in sensor networks , '' in _ proc .",
    "conf . on decision and control",
    "_ , pp .  37873792 , 2009 .",
    "s.  madden , m.  j.  franklin , j.  m.  hellerstein , and w.  hong , `` tag : a tiny aggregation service for ad - hoc sensor networks , '' in _ sigops oper .",
    "_ , vol .",
    "36 , pp .  131146 , 2002 .",
    "j.  edmonds , `` edge - disjoint branchings . '' in _ combinatorial algorithms _ , 1972 .",
    "we now present the complete proof for the throughput - optimality of algorithm [ algo : wlinerpfalgo ] in directed acyclic graphs .",
    "since the proof closely follows the proof of massouli et al.@xcite , we do not go into complete details , but try mainly to highlight the modifications we make in order to perform aggregation rather than broadcast .",
    "first we need a lemma that ensures that under the useful packet transmission rule , each round of packets follows a spanning tree .",
    "recall that the footprint of a round of packets is defined as the set of nodes in which the packets of that round is present .",
    "further , recall that a set @xmath8 is said to be a valid footprint set if each node in @xmath8 has a path to @xmath142 in the subgraph induced by @xmath8 ; the collection of such sets is denoted by @xmath143 .",
    "we assume throughout that @xmath144 , for otherwise the min - mincut is @xmath145 .",
    "note that since we operate in continuous time , only one packet transmission ocurs at a given time with probability @xmath146 ; further , we require that the local state information is available at the time of making routing decision .",
    "now we have the following lemma :      since the underlying graph is directed acyclic , we re - label the nodes as @xmath149 according to their topological ordering , where node @xmath145 is the aggregator @xmath142 , and all edges are from a higher numbered node to a lower numbered node .",
    "further , given a round of packets on a valid footprint set @xmath8 , we have that each node @xmath150 has at least one route to @xmath142 using only nodes in @xmath8 ; for short , we refer to such a route as a _ path from @xmath151 to @xmath142 in @xmath8_.    since we are operating in continuous time , with probability @xmath146 only one packet transmission occurs at a given time .",
    "now suppose a useful packet is transmitted on edge @xmath152 , where @xmath153 , resulting in a new footprint set @xmath154 . for @xmath148 to be a valid footprint ,",
    "we need that even after the transmission , each node @xmath155 has a path to @xmath142 in @xmath148 . to do this",
    ", we need to consider a partition of the nodes in @xmath148 into @xmath156 classes :    * node @xmath155 such that @xmath157 in the topological order : due to the topological ordering property , a path from @xmath151 to @xmath142 in @xmath8 is clearly unaffected by the packet transmission from @xmath158 to @xmath40 . *",
    "node @xmath159 such that there exists a path from @xmath151 to @xmath142 in @xmath8 which does not include @xmath158 : such a path is also unaffected by the packet transmission from @xmath158 to @xmath40 and hence is still present in @xmath148 .",
    "* node @xmath159 such that _ all paths _ from @xmath151 to @xmath142 in @xmath8 pass through @xmath158 : we show by contradiction that this case is impossible under the rules of useful packet transmission .",
    "for any path from @xmath151 to @xmath142 in @xmath8 , let @xmath160 be the node immediately before @xmath158 ( i.e. , the path is @xmath161 ) .",
    "then @xmath162 has no path to @xmath142 in @xmath8 that does not pass through @xmath158 , for otherwise we have a path from @xmath151 to @xmath162 , and then to @xmath142 , which does not pass through @xmath158 .",
    "this means that @xmath162 becomes isolated upon transmission of packet from @xmath158 to @xmath40 , which violates the non - isolation condition of useful packet forwarding .      the main idea behind the proof in @xcite was to define the ` footprint counter ' variables to represent the state of the system , and considering an appropriate function of these that allowed translating the local decisions of the nodes in terms of global graph parameters .",
    "in order to modify the proof for broadcast , we defined a similar collection of counter variables in section [ sec : algo1 ] , and now define their associated dynamics as follows .",
    "* arrival of new round : @xmath163 ( this corresponds to adding a packet to the queue with footprint @xmath13 , as a packet of the new round is simultaneously generated at all the nodes ) .",
    "* completion of packet transfer : this is only for active packets , i.e. , those currently under transmission . for active packet @xmath164 with corresponding @xmath165 and @xmath166 , we have : @xmath167 ( the first equation corresponds to removing the edge over which packet transmission was completed , and also updating the footprint of the packet to include the new node .",
    "the second updates the list of idle packets in case there is no other instance of this packet being transmitted . ) .",
    "* initiation of a new transfer at an idle link .",
    "the new packet is selected uniformly at random among the set of useful packets at the node .",
    "if @xmath168 , then a new packet transfer is formally described as follows : * * select a useful packet of an idle round with footprint @xmath169 , with probability @xmath170 select a useful packet of an active round @xmath164 with @xmath171 with probability @xmath172 * * if idle packet with footprint @xmath8 is selected : @xmath173 , with @xmath174 .",
    "if packet of active round @xmath175 is selected , then @xmath176    we note here that the node itself does not need to know these global counters to perform packet selection ; rather , this emerges from the use of the random useful packet forwarding rule .",
    "the idea of relating the local packet selection rule to the global counters is crucial in proving the optimality of the algorithm . the local rules for checking whether a packet is useful or not corresponds to selecting packets whose global footprint obeys certain properties ; picking a useful packet uniformly at random therefore corresponds to picking a packet from such a useful global footprint with a probability proportional to the corresponding counter variable .",
    "observe that in order to determine the flow into a footprint set @xmath8 , we need to consider the collection of sets which include @xmath8 and have one extra node .",
    "we now define the fluid limits of the system .",
    "this is similar in spirit to the fluid limit of the system in @xcite , so we try to use similar notation .",
    "the existence of the limit also follows immediately from their convergence results , so we omit it due to lack of space and refer interested readers to @xcite for technical details .",
    "* @xmath178 @xmath179 * work conservation : at almost every @xmath180 is differentiable and if @xmath181 ( where @xmath182 is the fluid trajectory associated with @xmath183 ) , then we have @xmath184 * @xmath185 are non - decreasing , lipschitz continuous , with lipschitz constant @xmath186 , and @xmath187 is @xmath186-lipschitz .",
    "for any @xmath188 set of all fluid trajectories with initial condition @xmath189 , and further , we define @xmath190 as the state of the mc with initial conditions @xmath191 , @xmath192 .",
    "now , as in @xcite , for a sequence of initial conditions @xmath193 s.t . for a sequence of positive numbers @xmath194 and",
    "the limit @xmath195 exists in @xmath196 , we have that @xmath197 : @xmath198}||y^n(t)-f(t)||\\geq\\epsilon]=0.\\ ] ]      next we define the candidate lyapunov function that we use to analyze the stability of the system . in @xcite ,",
    "the function was defined in terms of queues ( or counters ) that counted all the packets whose footprint was contained inside a set @xmath8 .",
    "the advantage of these queues for studying broadcast was that their rate of increase was controlled by external arrivals to the system , while they were drained due to transfers across the cut defined by the set @xmath8 .    for the purpose of studying aggregation ,",
    "we need to identify an equivalent set of queues to reflect the unique dynamics of the system .",
    "in particular , we consider for each set @xmath8 a queue of all rounds whose footprints _ are not entirely contained within @xmath8_. these queues ( counters ) exhibit similar properties to the ones considered for broadcast in that every incoming round is counted by all these queues ( as every node in the network generates a packet ) , while the drain of these queues is controlled by flow across the cut defined by the set @xmath8 .",
    "formally , we have the following theorem :      as in @xcite , before proving this theorem we first we need a combinatorial lemma .",
    "this lemma and its proof parallels a corresponding lemma in @xcite , with modifications to deal with aggregation and the @xmath206 counter variables we have defined above .        note that lemma [ lem : counting ] does not depend on the algorithm , or the fluid model in any way .",
    "it is a pure combinatorial property of the way that the quantities are defined .",
    "in other words , any function mapping the sets @xmath147 to @xmath217 obeys the lemma _ for any @xmath218_. later we use the ability to control @xmath219 to obtain uniform bounds on the lyapunov drift .    for the first condition ,",
    "consider @xmath169 such that @xmath220 then we have @xmath221 and thus @xmath222 however , from the definition of the @xmath223 , we have that @xmath224 for all @xmath225 .",
    "hence we have that @xmath226    for the second condition , consider @xmath147 such that@xmath227 .",
    "further , consider set @xmath148 such that @xmath228 and satisfying @xmath229 then we have @xmath230 thus for our condition , we need @xmath231 and noting the fact that @xmath223 are increasing with @xmath40 , it is sufficient to ensure @xmath232 this in fact holds with equality because of our choice of @xmath223 . thus , given any @xmath218 , we can construct @xmath223 such that the two conditions hold .",
    "( proof of theorem [ thm : lyap ] ) given @xmath218 , we define @xmath223 as in lemma [ lem : counting ] . then , or any @xmath233 , if @xmath234 is a set which belongs to arg - max of @xmath235 , then @xmath236 ( unless all the fluid sample paths are identically @xmath145 ) .",
    "next we use the optimality of @xmath234 to obtain some relations between @xmath237 and the weight across its cut - edges .",
    "@xmath238 such that @xmath17 , we have from the contrapositive of the first condition of lemma [ lem : counting ] ( as @xmath234 is in the arg - max ) that @xmath239 similarly from condition @xmath240 , @xmath241 such that @xmath242 , we have that @xmath243 now we have @xmath244\\\\ = & \\lambda-\\sum_{v\\in s^ * , u\\notin s^*}c_{uv}\\left[1-\\sum_{s'\\nsubseteq s^ * , v\\in s ' , u\\notin s'}\\frac{x_{s'+u}}{x_{+u - v}}\\right],\\\\ & \\mbox{(from defn of fluid trajectories)}\\\\ \\leq & \\lambda-\\sum_{u\\in s^ * , v\\notin s^*}c_{uv}+\\sum_{u\\in s^ * , v\\notin s^*}c_{uv}\\sum_{s'\\nsubseteq s^ * , v\\in s ' , u\\notin s'}\\alpha\\\\ & \\mbox{(from previous observation)}\\\\ \\leq & \\lambda-\\sum_{v\\in s^ * , u\\notin s^*}c_{uv}+\\max_{(u , v)\\in \\mathcal{l}}c_{uv}|\\mathcal{l}|2^k\\alpha.\\end{aligned}\\ ] ] if we choose @xmath219 and @xmath245 as follows : @xmath246 then we get that , for all @xmath247 , @xmath248 to argue that this implies negative drift of the lyapunov function , i.e. @xmath249 , we observe that by definition @xmath250 . finally , using the lipschitz continuity of the trajectories ,",
    "it is sufficient to show this property holds for the sets @xmath247 ."
  ],
  "abstract_text": [
    "<S> we seek to develop network algorithms for function computation in sensor networks . </S>",
    "<S> specifically , we want dynamic joint aggregation , routing , and scheduling algorithms that have analytically provable performance benefits due to in - network computation as compared to simple data forwarding . to this end </S>",
    "<S> , we define a class of functions , the fully - multiplexible functions , which includes several functions such as parity , max , and @xmath0-order statistics . for such functions </S>",
    "<S> we characterize the maximum achievable refresh rate of the network in terms of an underlying graph primitive , the min - mincut . in acyclic wireline networks , we show that the maximum refresh rate is achievable by a simple algorithm that is dynamic , distributed , and only dependent on local information . in the case of wireless networks , we provide a maxweight - like algorithm with dynamic flow splitting , which is shown to be throughput - optimal . </S>"
  ]
}