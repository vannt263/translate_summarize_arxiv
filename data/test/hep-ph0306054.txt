{
  "article_text": [
    "for many years , the gold standard in minimization packages used by high energy physicists has been the fortran program minuit  @xcite .",
    "this code contains algorithms which are well - suited for many hep uses , especially when there is a large data set and minimization is needed to find a multi - parameter fit .",
    "the principal algorithm , called migrad , is a variable metric method .",
    "this exploits the idea that althought a costly second derivative computation is needed to move to the function minimum , that matrix need not be computed accurately for early steps ( since it will be changing significantly anyway ) .",
    "instead , it can be iteratively improved , so that by the time the method gets near the actual minimum , the matrix is accurate and rapid convergence occurs .",
    "another prime capability is a set of routines for analyzing the solution : the hesse method of supplying the parameter error correlation matrix , the minos method of nonparabolic chi - suqare error intervals , and contour , which depicts the shape of a fixed - sigma error curve around the solution point for functions which may not be well - described as bi - linear forms .",
    "minuit , however , is getting a bit stale .",
    "it is written in fortran , which is no longer the _ lingua franca _ of computing in hep ; it can be awkward to link c++ code with code from a different language . and",
    "modern users would like certain advantages relating to treating a minimization problem and its function , algorithms and domains , as objects .",
    "one such advantage is the option of performing multiple independant minimizations in tandem .",
    "the minuit code is difficult to maintain , as evidenced by the fact that there have been no enhancements since a major overhaul done by f. james about a decade ago , and no major algorithm improvements for some time before that .",
    "the hep community knows of promising alternative methods , such as fumili  @xcite and the related leamax  @xcite , and certainly the field has advanced in these years , with simulated annealing and genetic algorithms maturing .",
    "the fact that nobody has seen fit to incorporate these as options in minuit can be taken as evidence that such changes would be hard to make .    even assuming that minuit needs no maintenance because all bugs have been eliminated and that its capabilities are forever adequate , what happens when all the cernlib fortran modules start becoming awkward to bring forward ? there is reason to fear that minuit might fall into functional obsolecence .",
    "we asked a group of hep physicists who work heavily with c++ computation whether it would be a good idea to produce a c++ object - oriented minimization package with minuit s capabilities .",
    "about 40% reacted positively : `` it s about time we had this . ''",
    "some of these physicists had faced a tougher time accomplishing an actual project , for lack of a good stand - alone c++ minimizer .",
    "others reacted with some variant of `` are you out of your mind ?",
    "sombody must already have done this !",
    "'' we will argue below that nobody actually has delivered an adequate object - oriented minimizer with the capabilities required .",
    "most commercial minimization packages fall short in capability aspects . in some cases ,",
    "their algorthms are not as appropriate as migrad for the sort of problems which occur in hep ; more often they lack solution analysis methods equivalent to contour and minos .",
    "also , non - trivial licensing issues can hinder the adoption of commercial codes as _ de facto _ standards in the hep community .",
    "a more promising approach is to translate minuit directly into c or c++ .",
    "several analysis packages , including root  @xcite , provide fitting in this manner .",
    "another approach is to place a wrapper around the minuit code , to allow the interface to be expressed in c++ , and package the compiled fortran code along with the wrapper as an integrated library .",
    "gemini  @xcite does this , providing a shell over a choice of minuit or the commercial nag c minimizer .",
    "either approach solves the problem of inter - language awkwardness , but they do not address the issue of maintainability and ease of enhancement . and fundamentally , a minimization problem still can not be treated as a first - class object .    the root team , in particular , has done significant work both in cleaning up the _",
    "f2c _ translation of minuit and in removing deficiencies involving multiple minimizations .",
    "but not everybody welcomes the requirement of linking to the large body of root code , when all that is needed is a minimizer .",
    "one other c++ object - oriented minimizer is definitely worth mentioning .",
    "matthias winkler , mentored by fred james at cern , is working on an `` object - oriented re - implementation of minuit in c++ '' under the auspices of the seal programme .",
    "clearly two nearly - identical good c++ minimizers are not needed .",
    "we have been in contact with dr .",
    "james , and intend to coordinate the two parallel efforts , hoping to emerge with a single package of superior design and implementation quality .",
    "it is worth saying a few things about the concept of a minimizer as opposed to a fitter .",
    "since most applications of minimization in hep are motivated by multi - parameter fits to data , the two can be confused .",
    "most of the packages which wrap minuit tend to be fitters , that is , they present a convenient way to provide a function form and a data set , and go about using minimization to optimize the parameters in a fit to that data .",
    "when the function @xmath0 is a chi - squared sum , the resulting minimization procedure is specialized , in the sense that the nature of the fitting problem assigns a meaning and a natural scale for differences in values of @xmath1 . algorithms ( such as migrad ) which yield a meaningful estimated distance above the true minimum can exploit a natural termination condition , since the value of @xmath1 assumed to be accurate only to some small fraction of a unit in chi - squared . and analysis of the estimated shape of @xmath1",
    "can meaningfully be translated to statistical statements about correlations among the parameters .",
    "however , the kernel operation of minimizing an arbitrary function is a valid capability to ask for . by design ,",
    "the c++ minimization package under development is a minimizer , not a fitter .",
    "one can automate the steps to turn a fitting task into a minimization problem .",
    "several others have done this in c++ , and though it may become convenient to package such a fitter adaptor with the minimizer , this adaptor need not be considered part of the development of the minimizer .",
    "the requirements guiding the developement of this package are driven by the goal of acceptance and widespread use in the hep community .",
    "this will require providing a significant set of capabilities , discussed below .",
    "the package must not to be deficient , with respect to minuit , in any capability .",
    "also , attention must be paid to certain performance considerations .",
    "the package must be clean to use and self - contained , and should not depend on other packages . and stringent testing will be required , to ensure that the package is robust .    at the same time , we wish to provide interfaces which will encourage code which is clear and readable and which does not deviate from the classical c++ coding idioms accepted by top practitioners .",
    "our goal is to provide a package that can be used for many years .",
    "it is impractical to provide something which is `` so good it will never need to change . '' instead , we strive to organize and code the package such that enhancements and maintenance changes will be as easy to incorporate as possible .    in order to stand the test of time",
    ", we feel the minimization package must include complete and easily understood user documentation , as well as full mathematical documentation of all algorithms used .",
    "the key requirement is that every capability present in minuit must be matched in our minimization package .",
    "it could be that minuit is the ideal minimizer for hep _ per se_. or perhaps the way physicists have grown accustomed to doing data analysis has evolved in tandem with minuit to take advantage of its capabilities .",
    "the point is moot  any package which can not match the capabilities present in minuit will be unacceptable to the hep community .",
    "these capabilities lie in several areas .",
    "clearly , the minuit algorithms ( migrad , simplex , minimize ) must be present . and user code must be able to control steps taken and selection of ( and switching among ) algorithms .",
    "code must be the able to establish limits on some or all of the function parameters , and fix and release their values . and the methods for error analysis , nonparabolic error intervals , and two - parameter contour lines ( analogous to hesse , minos , and contour ) must be provided .",
    "it is tempting , along the way , to make any tweaks that are noticed to be pure improvements .",
    "some of these are pure extensions , such as the ability to define parameters which have only an upper or lower limit .",
    "others might be minor algorithm improvements , such as a theoretically superior finite difference step size when numerically computing derivatives .",
    "in such cases , it is required that default behavior precisely mimic the procedures used by minuit .",
    "the minuit - matching requirement is a matter of capability , and not of interface .",
    "minuit assumes one of two usage paradigms :    1 .",
    "the minimizer is a static facility , which the user code explicitly initializes to embark on a problem .",
    "the user program then controls this facility by calling various subroutines .",
    "a commanding minimizer program is supplied with `` cards , '' each directing an aspect of initialization or an element of control",
    ".    clearly , both of these paradigms are obsolete in the context of a c++ , object - oriented package .",
    "the experienced minuit user may miss the mantra of calling mnexcm and the nine - argument calls to mnparm ; these will be replaced by methods which are more readable and which assigns one easily understood purpose to each method called .",
    "still , when the user constructs a minimization problem and invokes problem methods , she is logically employing capabilities which encompass the same set as was available in minuit .      to make best use of the object oriented abilities provided by c++ ,",
    "it is not enough merely to ensure that a minimization problem can be used as an independant entity .",
    "we must use the tools at our disposal to make the setup and control of a minimization problem as clear and flexible as possible .",
    "the focus is on user code readability , and on avoiding traps where the user can do something which looks sensible but may have disasterous ( or worse , subtly incorrect ) consequences .",
    "this means isolating conceptually distinct areas of control , and providing ways of excercising control of one aspect of execution at a time .",
    "thus the user will be able to interact with termination conditions associated with a problem , and separately with the domain restricting ranges of parameters , and with the selection of algorithms .",
    "in each of these areas , the user controls behavior by interacting with specialized versions of objects .",
    "the minimization problem then interacts with these objects via by their base class interfaces .",
    "an example is in order :    to control how parameters are limited in range , the problem will own an instance of a domain .",
    "domain methods takes care of such necessities as translating points and gradients between internal unrestricted cartesian coordinates used by the algorithm , and external parameters known to the function . but",
    "domain by itself is merely a base interface class ; the actual domain attached to the problem would ( by default ) be a rectilineardomain , which provides the capabilities present in minuit : restricting the upper and/or lower limits on each parameter individually .",
    "rectilineardomain inherits from domain .",
    "the user who desires to alter these limits would obtain a pointer to the domain , and invoke methods of rectilineardomain such as setupperlimit(n , x ) .",
    "now suppose another user has a problem which should be restricted to a region delimited by arbitrary planes in parameter space .",
    "this user would provide a different sort of object inheriting from domain  say linearconstraintsregion .",
    "and then she might call methods of that class , such as forcelessthan(coefficients , maximum ) .",
    "the algorithm does not care which type of domain is in place .    in providing the user interface",
    ", it is tempting to parallel the control made available to minuit .",
    "this is good only insofar as there are nt opportunities to improve on the semantics provided by the minuit subroutines .",
    "we are finding that there is a tendency to rely too heavily on doing what minuit does , and we need to be careful to look for opportunities to provide interfaces which would be clearer to people who are not steeped in minuit usage .",
    "to paraphrase stroustrup , this package should be `` as close to minuit as possible , _ but no closer_. ''      the design of the package must be such that as new algorithms and anaylsis methods are developed , or as new types of termination conditions or domains are required , they can be added either to the package itself , or to one s local version of the package .",
    "we can not insist that the work associated with such an enhancement be small , because in principle coding some new algorithm might inherently involve a lot of effort .",
    "what we can , and do , insist on  and this drives the entire package design  is that the additional work imposed by being part of this minimizaztion package is a very small fraction of the typical work needed to create the new algorithm or domain itself .",
    "this `` additional work '' includes    * understanding all the steps one needs to do . *",
    "following the logic of existing package code if necessary . *",
    "discovering precisely where modifications will be needed , and what the nature of any new classes must be . *",
    "coding any c++ boilerplate needed to support the enhancement .",
    "these are the tasks which represent a barrier to putting an enhancement into any of the various c++ minuit translations , and we must ensure that this barrier is small .    moreover , we must see to it that the enhancer , who may well be an expert in algorithm coding , need not also be an expert in c++ .    the way to accomplish these goals is to carefully design the system such that any two concepts that need not be logically intertwined ,",
    "are expressed as distinct classes which interact as little as possible .",
    "the overall package must be split into distinct subsystems , and dependencies carefully controlled .",
    "if this is done properly , then the enhancer need only be concerned about the small corner of the package this enhancement will involve . thus all the code to be examined in creating a new algorithm class would be in the algorithm base class , and all the boilerplate involved would be found in classes in the algorithm subsystem .",
    "the same philosophy that leads to ease of enhancement without undue tracing through an entanglement of code , will also greatly reduce the burden of maintenance . over the long term for a non - commercial package ,",
    "one has to assume that any maintainer might well lose familiarity with the internals of the system .",
    "so it is crucial that proper coding idioms be employed , to avoid setting subtle traps . and",
    "good separation of functionality and control of dependencies are critical , so that when changes need to be introduced , they will be localized and not have tendrils of effect throughout the package .",
    "also , each class should have self - contained ( and easy - to - automate ) unit tests ; each subsystem should have integration tests only involving it and any subsystems it depends on ; and a good suite of regression integration tests should be provided to help catch any errors introduced .",
    "having set a goal of easy enhancement , we must recognize that there are different sorts of enhancements which will normally be performed by different levels of developers .",
    "a user might well want to create some new form of termination condition ; this must be very straightforward .",
    "more rarely , a more experienced coder might want to derive a new type of domain ( for example , a rectilineardomain but replacing the arcsin mapping function with some sort of sigmoid ) . still more rarely , adding a fundamentally new algorithm is the sort of ehancement which might be assisted by the principal package maintainers .      in the `` low - ceremony '' tight design iteration process",
    "so often sucessfully used in high energy physics code development , certain fundamental design considerations are often overlooked .",
    "two such considerations are the required levels of agility and efficiency under various circumstances .",
    "in the course of designing this package , there will be opportunities for tradeoffs among areas such as coding style , levels of agility when faced with minor changes in needs , and performance efficiency .",
    "an up - front grasp of the goals in these area will allow the developer to make intelligent choices .",
    "we have discussed above the agility considerations , in terms of extensibility and maintainability goals . as to efficiency",
    ", the typical first reaction is to say `` of course this should be as efficient as possible , '' but that is an inappropriate goal for this package . taken to the extreme , a total focus on efficiency might dictate unmaintainable coding tricks , avoidance of sound accepted c++ techniques , and ultimately abandoning the object - oriented paradigm .",
    "some aspects of performance efficiency are critical , but the design goals should permit other forms of efficiency to be sacrificed in favor of better modularity , semantic clarity , or other desirable features .",
    "the hep minimization problem has a natural set of performance goals , and these induce an efficiency philosophy which is implied in minuit , and which we state implicitly for our package : it is assumed that the work involved in an invocation of the function being minimized is very large compared to the overheads of bookkeeping , argument passing , and transformations of parameters .",
    "thus tradeoffs which involve attaining beneficial properties at the cost of incuring extra work in these bookkeeping areas are considered positive .",
    "furthermore , it is also assumed that the number @xmath2 of parameters for tractable minimization problems of the nature we are considering will not be too large . by this , we mean that even in an algorithm which requires operations ( such as inversion ) involving @xmath3 matrices , the time spent for such operations does not dominate the time needed to evaluate the fuction in forming those matrices .      this minimization package will perform well on problems in which the dominant time cost is that of evaluating the function . because of the tradeoffs between some forms of efficiency and other desirable features , this package may not perform efficiently for certain other classes of problems .",
    "it is tempting to say that such problems  which involve inexpensive function calls  are so low - cost that nobody should care about performance , so that this minimization package is suitable for all uses .",
    "we should realize that the above rationalization is a bit facile ; there are actually at least four cases in which efficiency considerations may become important :    1 .",
    "each call to evaluate the function is expensive .",
    "this is the case in most hep fitting applications , and is the case which our package will deal with well .",
    "some problems are potentially expensive not because each function call is costly , but because there are a large numbers of parameters , such that matrix operations or even variable transformations begin to become dominant .",
    "when the number of parameters is huge , the algorithm may require a huge number of function calls .",
    "if function calls are inexpensive relative to the number of parameters , then bookkeeping overhead can become significant . the minimization problems appearing in lattice qcd to find fermion propagators are of this nature .",
    "the overall scientific problem being solved may involve solving large numbers of easy minimization problems .",
    "thus , while no single minimization is costly , performance on each problem might remain a critical consideration . in that case , problem initialization costs can become important .",
    "the efficiency requirement laid on this minimization package , or for that matter on minuit , is that it is appropriate for efficient solution of problems in the first of the above categories .",
    "this has been found to meet the fitting and other minimization needs of most hep applications other than lattice qcd .",
    "the immediate preferences of potential hep users can come into tension with the desired use of classical c++ coding idioms accepted by top practitioners .",
    "concepts which are legacies from the fortran days lead physicsts to become comfortable with coding techniques which are today recognized as poor use of c++ . in such cases , it is better to use the accepted modern idiom , rather than to deliver inferior  but temporarily more familiar  interfaces .",
    "thus for example , it would be unwise to shun the use of auto_ptr when that is the appropriate way to convey the passing of responsibility for an object .",
    "the assumption is made that physicists who may at first be uncomfortable due to unfamiliarity with this idiom will quickly pick up on it . and the benefits in using concepts which have been battle - tested by the world of developers , and which match the understandings of skilled programmers , are considerable .",
    "few of the decisions discussed in this section were black and white , and some may change in the course of coordinating with the cern effort , but after some consideration , the following principles were adopted :      how does the user supply the function to be minimized ?",
    "the naive mechanism is that the user passes to the problem a global - scope function of some specified signature ( for example , taking a vector of coordinates and returning a value ) .",
    "in fact , this notion is so obvious to the physicist coming from fortran , that we must support it in some manner .",
    "but there are considerable advantages to being able to supply a functor ( a instance of a class that has an operator ( ) so that it looks like it can be called as a function ) instead .",
    "one advantage to suppying a functor is that unlike the global function , an instance of a functor may have internal state , and the class may provide methods to influence the function behavior .",
    "( for example , one may wish to sum errors over fewer data points early in a minimization problem , and more later . )",
    "this natural concept in c++ replaces the awkward nature of fcn in minuit , which contains six arguments .",
    "only two arguments are fundamental to the notion of a function to be minimized : the vector xval of coordinates , and the result fval . by allowing for a functor class ,",
    "we obviate the need for iflag and futil ; and by separating the gradient method we eliminate the grad argument .",
    "the package has several situations in which behavior is defined by hooking into user code .",
    "two examples are the functor representing the function to be minimized , and a domain object implementing limits on cooordinates .",
    "the pattern of allowing a user to control behavior , by supplying a class which overrides one or more `` hook '' methods , resonates well with physicist coders .",
    "were we to say that the user constructs a problem supplying a reference or pointer to an instance of some class derived from function , the hep community would not complain . and",
    "if we further warned the user not to allow this function to go out of scope while the problem still needs it , most users would find that an obvious caution .",
    "however , the consequence of violating that stricture are dire : when the problem calls ( by pointer ) the out - of - scope method , confusion will reign , with no sensible diagnostic to point out why .",
    "good library developers protect against this by copying the vulnerable object .",
    "the problem , then , will _ own _ the function and domain , and not risk having those objects `` pulled out from under it . ''",
    "this notion is expressed by the user passing an auto_ptr to a new object ( on the heap ) ; the problem assumes responsibility for deleting that object when it no longer needs it .",
    "having made that decision , we must provide a way for the user to invoke controlling methods on the instance of the functor owned by the problem . the original object that the user supplied to the problem",
    "wo nt do , since the problem will be using a copy of it ; in fact , if the correct mantra was used to pass ownership to the problem , the user code should no longer be able to access the original object .",
    "instead , the correct recipe is :    * the user obtains a pointer to the base class ( in this example , function ) by calling a method of problem ( in this case , getfunction ( ) ) .",
    "* this pointer is dynamic cast into the class the user needs to control .",
    "the user can then invoke any control methods applicable for that class . *",
    "the pointer is now allowed to go out of scope , without the user calling delete on it .    the suggested syntax , which automatically obeys this recipe , involves using the returned pointer as a temprary variable which never is valid outside a single statement . the syntax can look like :    ....    dynamic_cast < rectilineardomain >      myproblem.getdomain()- >        setupperlimit(paramnumber , 35.1 ) ; ....    because this mantra may not be immediately familiar to our users",
    ", it is important that the package stick to the same rules ( _ never _ use delete on a pointer which problem has supplied ) for every case of object access .",
    "the powerful template facility in c++ would allow clever ways to improve the user interface and/or implementation of the minimization package . to give one example",
    ", methods giving a choice of supplying a user function or functor to act as the minimization target could be unified by expressing problem as a template , taking the function class as a template parameter .",
    "the use of templates has several adverse consequences which we perfer to avoid where practical : it makes it a bit tougher for a user to comprehend a header file , it can make maintenance more difficult , it makes compilation error messages much less readable , it introduces quirky linking issues , and it risks harming portability on certain weak compilers .",
    "there are valid answers to each of these objections ; still , absent compelling benefits , the package design avoids the use of templates .",
    "on the other hand , existing templated classes in the standard library are used freely .",
    "our philosophy concerning clever and subtle patterns to which convey minor benefits is that it is sometimes possible to be _ too _ clever .",
    "for example , the design of the function base class ( discussed in section [ function ] ) makes it possible to supply a gradient ( ) method but forget to override gradientavailable ( ) . that is a bit of a trap  the algorithm would ignore the user - supplied method when it needed a gradient .",
    "( the same trap is present in minuit , if the user forgets to call setgradient ) .",
    "we could finesse this by using a variant on the visitor pattern : when the algorithm needs a gradient , it requests it from the function object but the signature of the gradient ( ) method also supplies the address of the algorithm s finite difference gradient - computing method . the base class gradient ( )",
    "invokes this method ; if the user s functor class overrides gradient ( ) that routine replaces the finite difference method behavior .",
    "this pattern incurs some efficiency loss , but since that is merely a matter of an extra argument passed around , and an extra subroutine call , that cost would ( by the definition in section [ efficiency ] ) be acceptable .",
    "however , the pattern looks complicated and mysterious ; it might make maintenance more difficult and it might worry potential users who havent put in the time to understand it .",
    "since the gain is relatively slight , we have come down on the side of the simpler gradientavaliable ( ) solution .      in many cases , there may be multiple concepts for which the natural expression in bits and bytes will look like identical data structures .",
    "for example , both the set of coordinates identifying a point , and the set of values representing the components of the gradient of a function , are underneath indexed collections of doubles .",
    "the question is , should the design introduce distinct classes to represent the distinct concepts , or should it use a vector of doubles for both ?",
    "good c++ design takes the view that if two concepts are distinct , they should be represented by two distinct classes .",
    "the idea is that you ca nt be sure in advance that you will never alter the way you work with one of the concepts , and if they are represented by distinct classes , making such a change will be much less of a maintenance headache . introducing a distinct class to represent each distinct concept also provides some measure of type safety , in that you ca nt accidently use one concept when you mean the other . and naming each concept leads to superior code readability . in a package that emphasizes extensibility , these three advantages are significant .",
    "the disadvantage in introducing such classes is limited to the need to write some boilerplate code writing to provide their headers and near - trivial implementations .",
    "therefore , especially concerning minimization package internals , we tend to introduce distinct classes for distinct concepts , particularly in the area of geometric concepts ( see section [ geometric ] ) such as point and gradient .",
    "the minimization package must be a good c++ citizen . by that , we mean it must not step on potential user symbols ; we place everthing into a namespace to guard against this .",
    "other items we avoid are the use , in headers , of macro definitions ( which may clash with user defines ) and of using statements ( which defeat the purpose of the namespace protection if they appear in an included header ) .",
    "namespace use has been approved for the clhep library , which has severe portability requirements , so we are not concerned on that issue for the minimization package .",
    "the package is divided into several subsystems .",
    "a subsystem is defined as some group of classes and responsibilities , such that each subsystem depends on a minimal number of other subsystems , and such that these dependencies can be expressed as cleanly as possible . the first step in logical",
    "design was to identify the concepts present in minuit .",
    "it is no coincidence that each subsystem coresponds to one major concept in the minimization realm .",
    "the benefit of a good separation into subsystems comes during development of various classes , and later during enhancement implementation , because the coder can have in mind a smaller `` overall picture '' when deciding how to do things .",
    "good isolation of subsystems makes it possible to develop the more detailed package design one part at a time , without constantly having to consider the ramifications of each decision on every other part of the design .",
    "finally , the up - front thought about subsystem components has yielded immediate benefits in the form of solidifying the collection of concepts involved in the minimization package .    in principle a `` subsystem '' need not be tied to a group of classes . however ,",
    "each identified subsystem in the minimization package is characterised by a key class embodying the interface of that subsystem to the user and/or to the other subsystems .",
    "this section will outline the responsibilities and dependancies of each subsystem , and discuss associated design issues .",
    "the problem subsystem has the responsibility for the user interface to a minimization process .",
    "it contains the problem class , which takes ownership of algorithm , domain , and termination objects , and contains the problemstate .",
    "minimizing involves the problem repeatedly requesting steps from the currently associated algorithm .",
    "after each step , it determines whether the user - supplied termination condition is satisfied , or whether the algorithm itself has declared that it ca nt profitably proceed further .",
    "if termination is reached , control returns to the user code , which may change the algorithm , the domain ( for example , releasing some parameters and fixing others ) , and/or the termination conditions , and again invoke the problem s minimize ( ) method .",
    "problemstate is a structure containing information about the state of solution which is not peculiar to any one algorithm or domain .",
    "for example , the concept of the current best guess is inherent in the nature of minimization ; it is applicable whehter the algorithm producing it was migrad or simplex .",
    "the user indirectly interacts with problemstate , via methods of problem , when she needs to inspect this information .",
    "subsystems of the minimization package interact with problemstate more directly .",
    "for example , termination conditions inspect its data to decide whether to terminate , and the algorithm subsystem is dependant upon problemstate , reading and altering its data .",
    "there is danger that problemstate can act as a catch - all for data that violates reasonable encapsulation goals , effectively replicating  with all its flaws  the notion of a big global common area .",
    "there is some art in restricting the contents to those items genuinely inherent in the minimization concept , and keeping those items which are associated with an algorithm in the specific algorithm classes .",
    "the algorithm base class provides interface between the problem and subclasses implementing specific minimization algorithms .",
    "this base class also standardizes ways for its derived classes to access the function and domain objects .",
    "for example , the mantra for obtaining a function gradient involves finding out whether the function object can provide it analytically , and if not , utilizing the algorithm s own finite difference methodology ; this mantra is encapsulated in algorithm .",
    "any given algorithm class has an iterate ( ) method , which `` takes a step , '' improving the state of solution .",
    "it also decides whether to declare that this algorithm is finished in the sense that no further meaningful improvement is forseen . between steps",
    ", the problem applies user - supplied termination conditions which may declare victory well before the algorithm declares exhaustion .",
    "this subsystem depends on the function and domain subsystems : algorithms , of course , repeatedly requests values of the function ( and if available its gradient and second derivatives ) , and utilize the domain to map its internal coordinates into external parameters to supply to those function calls .",
    "this subsystem has the responsibility for the various solution analysis tools such as minos , hesse , and contour .",
    "such tools have roughly the same needs and dependencies as algorithms , but a class derived from analysis can in addition also depend on algorithms which it needs to call .",
    "the function subsystem has the responsibility for providing function values and , if available , analytic gradient and second derivatives .",
    "the primary class is the abstract interface function .",
    "commonly , users will have an ordinary function ( taking a constant refernce to a point or to a vector of doubles , and returning a double ) to minimize .",
    "such users can make use of the free method userfunction ( ) , to supply this function when constructing the problem , as in :    ....    double f(const vector < double > v ) {      assert ( v.size()=nargs ;       // ... do work to return a value }    problem myprob ( userfunction ( nargs , f ) ) ; ....    an alternative signature would take both the function and a method to compute the gradient , if direct gradient computation is available .",
    "the user can also optionally supply global methods to compute second derivatives .",
    "userfunction ( ) constructs a function object on the heap , and returns an auto_ptr to it ; in the example code , this is immediately passed to the constructor of the problem .",
    "alternatively , a user can inherit from function to form his own `` functor '' class , and supply an instance of that when constructing a problem . in that case",
    "the functor class must override the method which returns the function value at a point .",
    "it may also override the gradient ( ) method , and if it does , it should override gradientavailable ( ) to return true  this replaces minuit s setgradient command , and more importantly , obviates the need for the user function to be passed an iflag argument to tell it what do do .",
    "similarly , the functor class may override the hessian ( ) and hessianavailable ( ) methods .",
    "the functor is to be created on the heap and an auto_ptr supplied to the problem so that there is no danger of the user getting mysterious errors due to the functor going out of scope while the problem is depending on it .",
    "the user can later recover a pointer to this function object and thus invoke its methods :    ....    class myfunct : public function {      myfunct ( ) : function(nargs ) { }      double operator()(const point & p ) ;      changestuff(int c ) ;      ... } ;    problem myprob ( auto_ptr < function >                    ( new myfunct )        ) ;    ( dynamic_cast < myfunct * >       ( myprob.getfunction()))->changestuff(3 ) ;       ....    the function subsystem depends only on the geometric concepts subsystem .",
    "the domain subsystem has the responsibility for providing mappings between the internal coordinates that an algorithm works with , and the external parameters that a function deals with .",
    "this solidifies the decoupling , already present in minuit , between the algorithm and any restrictions on the parameter values .",
    "that is , it would be too difficult to invent an algorithm that could deal with any arbitrary sort of variable restrictions ; instead , the algorithms themselves work with clean , unrestricted cartesian coordinates , and all the complexity involving restrictions is separated off into the domain classes .",
    "the domain base class provides the interface for algorithms and other parts of the package to transform variables .",
    "there is , of course , the complication that geometric objects of different kinds transform differently under the mappings provided by a domain .",
    "thus specific domain derived classes provide methods to map various geometric concepts : points , gradients , hessians , characteristicscales , ( error ) correlations , and whatever else algorithms and analyses may need .",
    "the base domain class supplies these methods in terms of virtual functions which supply the map s value and derivatives .",
    "domain encapsulates the minuit concepts of parameter limits and of fixing / releasing parameter values .",
    "half the interface of minuit is devoted to manipulating the way parameters can vary .",
    "most of this control belongs in the domain subsystem .",
    "the exemplar of a domain ( and the one associated with a problem by default ) is the rectilineardomain , which provides the mapping functions and capabilities present in minuit .",
    "a user could fairly easily create a class inheriting from rectilineardomain in order to modify the mapping functions used .",
    "rectilineardomain has the property that its individual components map in a separable way , that is , the map of each internal component depends on only one variable external parameter .",
    "algorithms can query a domain about this property .",
    "for example , when migrad utilizes diagonal second derivatives to avoid the need for computing the full hessian , it relies on this separablity property ; and in more complex domains , additional work may be needed .",
    "unlike functors derived from function , which need only supply the fundamental value - suppying method ( and may optionally supply gradient etc . )",
    ", each domain subclass is required to supply all the geometric concepts mapping methods . while typical users are expected to create functors deriving from function",
    ", we can assume that those who embark on defining new types of domains are somehwhat more expert .",
    "the domain subsystem depends only on the geometric concepts subsystem .",
    "the termination subsystem has the responsibility for conditions conditions which the problem can apply , to determine whether to terminate the minimization iteration and return control to the user .",
    "the termination base class also defines an interface for potential user - created termination conditions .",
    "the subsystem contains termination classes corresponding to each of the criteria applicable in minuit , plus a time - based criterion .",
    "time - based termination is often preferable to a count of function calls , but has a potential disadvantage with respect to portability .",
    "however , the standard library does provide for timing at the one - second granulaty level , and almost all systems are compliant in this respect .",
    "termination also comes with methods to build `` compound '' termination objects as by logically combining ( and , or ) more basic termination objects . such a compound criterion could , without too much difficulty , be coded by each user as a class deriving from termination .",
    "but the desire to apply a group of criteria , terminating ( say ) if either the accuracy criterion is met , _ or _ the number of function calls is excessive , will be a very common case .",
    "so it was decided to make life easy for such users by supporting these combinations .",
    "we supply the logical combiners and and or , as this will satisfy the vast majority of applications .",
    "the termination subsystem depends on problemstate .",
    "the minimization process deals with a number of geometric concepts , which are logically distinct and not interchangeable .",
    "most of these behave like a vector of doubles . for example , a point in exterior coordinate space is not interchangeable with a gradient of the function at some point , even though they both have the same number of components . and",
    "neither is the same as an `` interiorpoint '' which is a set of coordinates in the cartesian space in which the algorithm is working .",
    "although the package code utilizes these geometric concept classes , there is good reason to provide user interfaces for common operations which deal with the familiar vector of doubles .",
    "for example , the userfunction ( ) method can accept a function of a std::vector where a point is logically called for :    ....    double f ( const std::vector < double > params ) ;    problem myprob ( userfunction ( nargs , f ) ) ; ....    the exterior concepts identified are point , gradient , secondderivatives , hessian , characteristicscale , and correlations .",
    "there are also classes corresponding to each of these , representing internal - coordinate concepts .",
    "the geometric concepts subsystem contains the collection of such classes .",
    "it depends on no other subsystem .",
    "the initial release of the minimization package is , by definition , to include all minuit functionality .",
    "of course , the object nature of a minimization problem will allow modes of usage which would be awkward with the fortran minuit , but basically the capabilities will at that point be those of minuit . however , certain extensions will be in the initial release .",
    "these appear in situations where the nature of a potential extension is obvious , and the implementation is straightforward . if the extension is clear in definition , and we have a firm idea of how it should by implemented , then there is no reason to delay that capability unitl a later release .    in the domain subsystem ,",
    "the rectilineardomain class will immediately support half - open intervals for parameter limits ( that is , having only an upper or lower limit for a paramenter ) .",
    "it will also be easy to substitute for the arcsin mapping functions .    in the function subsystem , the package will allow supplying second derivatives ( either diagonal or full matrix ) along with the gradient .    in the termination subsystem ,",
    "several new basic choices will be provided , including a time - based termination , and arbitrary logical combinations of termination conditions will be supported .",
    "a preliminary partial implementation of this package has been done , to obtain familiarity with the minuit algorithms and concepts , and to get a feel for the design issues .",
    "( a spin - off of this work is a set of heavily - commented minuit fortran `` source '' code , and some mathematical documentation of the minuit algorithms . )",
    "the cern effort ( as discussed with f. james ) is at the point where the minimization algorithms ( but not all of the analysis algorithms ) have first - pass implementions , again in a familiarization phase .",
    "since the two efforts are at comparable stages , the prospects for coordination seem reasonable ."
  ],
  "abstract_text": [
    "<S> a portion of the hep community has perceived the need for a minimization package written in c++ and taking advantage of the object - oriented nature of that langauge . to be acceptable for hep , such a package must at least </S>",
    "<S> encompass all the capabilities of minuit . aside from the slight plus of not relying on outside fortran compilation , </S>",
    "<S> the advantages that a c++ package based on o - o design would confer over the multitude of available c++ minuit - wrappers include : easier extensibility to different algorithms and forms opf constraints ; and usage modes which would not be available in the global - common - based minuit design . </S>",
    "<S> an example of the latter is a job persuing two ongoing minimization problems simultaneously . </S>",
    "<S> we discuss the design and implementation of such a package , which extends minuit only in minor ways but which greatly diminishes the programming effort ( if not the algorithm thought ) needed to make more significant extensions . </S>"
  ]
}