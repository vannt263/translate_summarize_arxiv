{
  "article_text": [
    "the idea behind flow control in data networks is to regulate the source rates in order to prevent network overload , and provide fair allocation of resources . in recent years",
    ", extensive research has been devoted to the problem of network utility maximization , with the objective of optimizing network resource allocation through a combination of source - based flow control , routing , and scheduling .",
    "the common theme is to assign a utility , as a function of the source rate , to a flow specified by a source - destination pair , and formulate an optimization problem that maximizes the sum of utilities ( e.g. , see  @xcite ) .",
    "the optimal network control policy is revealed as the algorithm that solves the utility maximization problem .",
    "source - based flow control implicitly requires all sources to react properly to congestion signals such as packet loss or delay .",
    "congestion - insensitive traffic , however , is pervasive in modern networks .",
    "udp - based applications such as video streaming or voip are increasingly popular and do not respond to congestion .",
    "moreover , greedy or malicious users can inject excessive data into the network to either boost self - performance or bring down high - profile websites . in these circumstances",
    ", the network can be temporarily overloaded and congestion - aware applications , e.g. , tcp - based traffic , may be adversely affected or even starved . in this context , source - based flow control may not be adequate .",
    "there are other scenarios in which optimizing the source rates of data flows on a per - flow basis is ineffective .",
    "the internet nowadays is vulnerable to distributed denial of service ( ddos ) attacks  @xcite , in which an attacker creates a large number of flows with different source addresses to overwhelm prominent websites .",
    "similarly , in a multi - player online game , thousands of users require continuous access to the game servers .",
    "there are also occasions in which a large number of users seek access to a website that broadcasts live events  @xcite ; this is the so - called _ flash crowd _",
    "phenomenon  @xcite . in these situations ,",
    "source - based flow control is ineffective because each individual flow uses little bandwidth , but their aggregate traffic can lead to severe link congestion near the service provider , and may starve other users in the network . a flow control scheme that can optimize a utility assigned to a collection of flows as opposed to optimizing the sum of per - flow",
    "utilities can be used to cope with such scenarios . moreover , in order to cope with uncooperative flows , it is necessary to relocate the flow control functionality from untrusted network hosts to more secure ones , such as the web servers that provide service at the receiver end .    in this paper , we develop such _ receiver - based flow control _ policies using tools from stochastic network optimization  @xcite .",
    "our main contributions are three - fold .",
    "first , we formulate a utility maximization problem that can assign utilities to an aggregate of flows , of which the usual per - flow - based utility maximization is a special case .",
    "second , given an arbitrary arrival rate matrix ( possibly outside the network s stability region ) , we characterize the corresponding achievable throughput region in terms of queue overflow rates .",
    "third , using a novel decomposition of the utility functions , we design a network control policy consisting of : ( i ) a set of flow controllers at the receivers ; ( ii ) packet dropping mechanism at internal nodes ; and ( iii ) back - pressure routing at intermediate nodes .",
    "the receiver - based flow controllers adjust throughput by modifying the differential backlogs between the receivers and their neighboring nodes  a small ( or negative ) differential backlog is regarded as a _ push - back _ mechanism to slow down data delivery to the receiver . to deal with data that can not be delivered due to network overload , we design a threshold - based packet dropping mechanism that discards data whenever queues grow beyond certain thresholds .",
    "surprisingly , we show that our threshold - based packet dropping scheme , without the use of flow control , is sufficient to maximize the weighted sum throughput . moreover , the combined flow control and packet dropping mechanism has the following properties : ( i ) it works with finite - size buffers .",
    "( ii ) it is nearly utility - optimal ( throughput - optimal as a special case ) and the performance gap from the optimal utility goes to zero as buffer sizes increase .",
    "( iii ) it does not require the knowledge of arrival rates and therefore is robust to time - varying arrival rates that can go far beyond the network s stability region .",
    "in addition , our control policy can be implemented only in parts of the network that include the receivers , treating the rest of the network as exogenous data sources ( see fig .",
    "[ fig:105 ] for an example ) , and thus might be an attractive flow control solution for web servers .    , @xmath0 , and @xmath1 on the right , where @xmath1 is the only receiver .",
    "the rest of the network on the right may be controlled by another network operator or follow a different network control scheme.,width=336 ]    there has been a significant amount of research in the general area of stochastic network control .",
    "utility - optimal policies that combine source - end flow control with back - pressure routing have been studied in  @xcite ( and references therein ) .",
    "these policies optimize per - flow utilities and require infinite - capacity buffers .",
    "however , they are not robust in the face of uncooperative users who may not adhere to the flow control scheme . a closely related problem to",
    "that studied in this paper is that of characterizing the queue overflow rates in lossless networks in overload . in a single - commodity network ,",
    "a back - pressure policy is shown to achieve the most balanced queue overflow rates  @xcite , and controlling queue growth rates using the max - weight policy is discussed in  @xcite .",
    "the queue growth rates in networks under max - weight and @xmath2-fairness policies are analyzed in  @xcite .",
    "we finally note that the importance of controlling an aggregate of data flows has been addressed in  @xcite , and rate - limiting mechanisms in front of a web server to achieve some notion of max - min fairness against ddos attacks have been proposed in  @xcite .",
    "an outline of the paper is as follows .",
    "the network model is given in section  [ sec:601 ] .",
    "we formulate the utility maximization problem and characterize the achievable throughput region in terms of queue overflow rates in section  [ sec:602 ] .",
    "section  [ sec:801 ] introduces a threshold - based packet dropping policy that maximizes the weighted sum throughput without the use of flow control .",
    "section  [ sec:501 ] presents a receiver - based flow control and packet dropping policy that solves the general utility maximization problem .",
    "simulation results that demonstrate the near - optimal performance of our policies are given in sections  [ sec:801 ] and  [ sec:501 ] .",
    "we consider a network with nodes @xmath3 and directed links @xmath4 .",
    "assume time is slotted . in every slot ,",
    "packets randomly arrive at the network for service and are categorized into a collection @xmath5 of classes .",
    "the definition of a data class is quite flexible except that we assume packets in a class @xmath6 have a shared destination  @xmath7 .",
    "for example , each class can simply be a flow specified by a source - destination pair .",
    "alternatively , computing - on - demand services in the cloud such as amazon ( elastic compute cloud ; ec2 ) or google ( app engine ) can assign business users to one class and residential users to another . media streaming applications may categorize users into classes according to different levels of subscription to the service provider . while classification of users / flows in various contexts",
    "is a subject of significant importance , in this paper we assume for simplicity that the class to which a packet belongs can be ascertained from information contained in the packet ( e.g. , source / destination address , tag , priority field , etc . ) .",
    "let @xmath8 be the number of exogenous class  @xmath9 packets arriving at node @xmath10 in slot @xmath11 , where @xmath12 is a finite constant ; let @xmath13 for all @xmath11 .",
    "we assume @xmath14 are independent across classes @xmath9 and nodes @xmath15 , and are i.i.d . over slots with mean @xmath16 = { \\lambda_{n}^{(c)}}$ ] .    in the network ,",
    "packets are relayed toward the destinations via dynamic routing and link rate allocation decisions .",
    "each link @xmath17 is used to transmits data from node @xmath10 to node @xmath18 and has a fixed capacity @xmath19 ( in units of packets / slot ) . under a given control policy ,",
    "let @xmath20 be the service rate allocated to class  @xmath9 data over link @xmath21 in slot @xmath11 .",
    "the service rates must satisfy the link capacity constraints @xmath22    at a node @xmath15 , class @xmath9 packets that arrive but not yet transmitted are stored in a queue ; we let @xmath23 be the backlog of class  @xmath9 packets at node @xmath10 at time @xmath11 .",
    "we assume initially @xmath24 for all @xmath10 and @xmath9 .",
    "destinations do not buffer packets and we have @xmath25 for all @xmath9 and @xmath11 . for",
    "now , we assume every queue @xmath23 has an infinite - capacity buffer ; we show later that our control policy needs only finite buffers . to resolve potential network congestion due to traffic overload",
    ", a queue @xmath23 , after transmitting data to neighboring nodes in a slot , discards @xmath26 packets from the remaining backlog at the end of the slot .",
    "the drop rate @xmath26 is a function of the control policy to be described later and takes values in @xmath27 $ ] for some finite @xmath28 .",
    "the queue @xmath23 evolves over slots according to @xmath29^{+ } \\\\ &",
    "\\quad+ { a_{n}^{(c)}}(t ) + \\sum_{a } \\mu_{an}^{(c)}(t ) , \\quad \\forall c,\\ \\forall n\\neq d_{c } , \\end{split}\\ ] ] where @xmath30 .",
    "this inequality is due to the fact that endogenous arrivals may be less than the allocated rate @xmath31 when neighboring nodes do not have sufficient packets to send .    for convenience ,",
    "we define the maximum transmission rate into and out of a node by @xmath32 throughout the paper , we use the following assumption .    [ assu:601 ] we assume @xmath33 .    from",
    ", the sum @xmath34 is the largest amount of data that can arrive at a node in a slot ; therefore it is an upper bound on the maximum queue overflow rate at any node .",
    "assumption  [ assu:601 ] ensures that the maximum packet dropping rate @xmath28 is no less than the maximum queue overflow rate , so that we can always prevent the queues from blowing up .",
    "we assign to each class @xmath35 a utility function @xmath36 . given an ( unknown ) arrival rate matrix @xmath37 , let @xmath38 be the set of all achievable throughput vectors @xmath39 , where @xmath40 is the aggregate throughput of class @xmath9 received by the destination @xmath7 .",
    "note that @xmath38 is a function of  @xmath41 .",
    "we seek to design a control policy that solves the global utility maximization problem @xmath42 where the region @xmath38 is presented later in lemma  [ lem:201 ] .",
    "we assume all @xmath36 functions are concave , increasing , and continuously differentiable .",
    "for ease of exposition , we also assume the functions @xmath36 have bounded derivatives such that @xmath43 for all @xmath44 , where @xmath45 are finite constants .",
    "that have unbounded derivatives as @xmath46 can be approximated by those with bounded derivatives .",
    "for example , we may approximate the proportional fairness function @xmath47 by @xmath48 for some small @xmath49 . ]    as an example , consider the tree network in fig .",
    "[ fig:102 ] that serves three classes of traffic destined for node @xmath1 .",
    "class  @xmath50 data originates from two different sources @xmath51 and @xmath52 , and may represent the collection of users located in different parts of the network sending or requesting information from node @xmath1 . if class @xmath50 traffic is congestion - insensitive and overloads the network , without proper flow control class @xmath53 and @xmath54 will be starved due to the presence of class @xmath50 .",
    "a utility maximization problem here is to solve @xmath55 where @xmath56 denotes the throughput of class @xmath50 data originating from @xmath51 ; @xmath57 , @xmath58 , and @xmath59 are defined similarly . note that this utility maximization  - is very different from , and generalizes , the traditional per - flow - based utility maximization .",
    "the next lemma characterizes the set @xmath38 of all achievable throughput vectors in  .",
    "[ lem:201 ] under i.i.d .",
    "arrival processes with an arrival rate matrix @xmath60 , let @xmath38 be the closure of the set of all achievable throughput vectors @xmath39",
    ". then @xmath61 if and only if there exist flow variables @xmath62 and queue overflow variables @xmath63 such that @xmath64 in other words , @xmath65    see appendix  [ appendix:201 ] .    in lemma  [ lem:201 ] ,",
    "equation   is the flow conservation constraint stating that the total flow rate of a class into a node is equal to the flow rate out of the node plus the queue overflow rate .",
    "equation   is the link capacity constraint .",
    "the equality in   shows that the throughput of a class is equal to the sum of exogenous arrival rates less the queue overflow rates .",
    "lemma  [ lem:201 ] is closely related to the network capacity region @xmath66 defined in terms of admissible arrival rates ( see definition  [ defn:101 ] ) ; their relationship is shown in the next corollary .",
    "[ defn:101 ] the capacity region @xmath66 of the network is the set of all arrival rate matrices @xmath67 for which there exists nonnegative flow variables @xmath68 such that @xmath69    [ lem:501 ] an arrival rate matrix @xmath70 lies in the network capacity region @xmath66 if there exist flow variables @xmath71 such that flow conservation constraints   and link capacity constraints   hold with @xmath72 for all @xmath10 and @xmath9 .",
    "corollary  [ lem:501 ] shows that @xmath70 is achievable if and only if there exists a control policy yielding zero queue overflow rates . in this case",
    "the throughput of class @xmath9 is @xmath73 .",
    "we remark that the solution to the utility maximization  - activates the linear constraints  ; thus the problem  - is equivalent to @xmath74 let @xmath75 be the optimal throughput vector that solves  - . if the arrival rate matrix @xmath70 is in the network capacity region @xmath66 , the optimal throughput is @xmath76 from corollary  [ lem:501 ] . otherwise , we have @xmath77 , where @xmath78 is the optimal queue overflow rate .      our control policy that solves  - has two main features .",
    "first , we have a packet dropping mechanism discarding data from the network when queues build up .",
    "an observation here is that , in order to optimize throughput and keep the network stable , we should drive the packet dropping rate to be equal to the optimal queue overflow rate .",
    "second , we need a flow controller driving the throughput vector toward the utility - optimal point . to convert the control objective   into these two control features ,",
    "we define , for each class @xmath35 , a utility function @xmath79 related to @xmath36 as @xmath80 where @xmath81 are control parameters to be decided later . using  , we have @xmath82.\\ ] ] since @xmath83 are unknown constants , maximizing @xmath84 is the same as maximizing @xmath85.\\ ] ] this equivalent objective   can be optimized by jointly maximizing the new utility @xmath86 at the receivers and minimizing the weighted queue overflow rates ( i.e. , the weighted packet dropping rates ) @xmath87 at each node @xmath10 .",
    "optimizing the throughput at the receivers amounts to controlling the amount of data _ actually delivered_. this is difficult because the data available to the receivers at their upstream nodes is highly correlated with control decisions taken in the rest of the network . optimizing the packet dropping rates depends on the data available at each network node , which has similar difficulties . to get around these difficulties ,",
    "we introduce auxiliary control variables @xmath88 and @xmath89 and consider the optimization problem @xmath90 \\label{eq:901 } \\\\",
    "\\text{subject to } & \\quad r_{c } = \\nu_{c } , \\quad \\forall\\ , c\\in { \\mathcal{c}}\\label{eq:210 } , \\\\",
    "& \\quad { q_{n}^{(c)}}\\leq { \\varphi_{n}^{(c ) } } , \\quad \\forall\\ , c\\in { \\mathcal{c}},\\",
    "n\\neq d_{c}. \\label{eq:211 } \\\\ & \\quad \\text{\\eqref{eq:213}-\\eqref{eq:605 } hold",
    ". } \\label{eq:902}\\end{aligned}\\ ] ] this is an equivalent problem to  - .",
    "the constraints   and   can be enforced by stabilizing virtual queues that will appear in our control policy .",
    "the new control variables @xmath91 and @xmath92 to be optimized can now be chosen freely unconstrained by past control actions in the network . introducing auxiliary variables and setting up virtual queues are at the heart of using lyapunov drift theory to solve network optimization problems .",
    "for ease of exposition , we first consider the special case of maximizing the weighted sum throughput in the network .",
    "for each class @xmath35 , we let @xmath93 for some @xmath94 .",
    "we present a threshold - based packet dropping policy that , together with back - pressure routing , solves this problem .",
    "surprisingly , flow control is not needed here .",
    "this is because maximizing the weighted sum throughput is equivalent to minimizing the weighted packet dropping rate . indeed , choosing @xmath95 in  , we have @xmath96 for all classes @xmath9 , under which maximizing the equivalent objective   is the same as minimizing @xmath97 . in the next section , we will combine the threshold - based packet dropping policy with receiver - based flow control to solve the general utility maximization problem .      to optimize packet dropping rates , we set up a _ drop queue _ @xmath98 associated with each queue @xmath23 .",
    "the packets that are dropped from @xmath23 in a slot , denoted by @xmath99 , are first stored in @xmath98 for eventual deletion . from",
    ", we have @xmath100.\\ ] ] note that the quantity @xmath99 is the _ actual _ packets dropped from @xmath23 , which is strictly less than the allocated drop rate @xmath101 if queue @xmath23 does not have sufficient data .",
    "packets are permanently deleted from @xmath98 at the rate of @xmath102 $ ] in slot @xmath11 .",
    "the queue @xmath98 evolves according to @xmath103^{+}+ { \\widetilde{d}_{n}^{(c)}}(t).\\ ] ] assume initially @xmath104 for all @xmath10 and @xmath9 , where @xmath105 is a control parameter . to be finite .",
    "our choice of @xmath106 avoids unnecessary packet dropping in the initial phase of the system . ]",
    "if queue @xmath98 is stabilized , then minimizing the service rate of @xmath98 effectively minimizes the time average of dropped packets at @xmath23 .",
    "we propose the following policy .    ' '' ''    overload resilient algorithm ( @xmath107 )    ' '' ''    _ parameter selection : _",
    "choose @xmath108 for all classes @xmath35 , where @xmath109 .",
    "choose a parameter @xmath105 .",
    "_ backpressure routing : _ over each link @xmath110 , let @xmath111 be the subset of classes that have access to link @xmath112 . compute the differential backlog @xmath113 for each class @xmath114 , where @xmath115 at the receiver @xmath7 . define @xmath116 we allocate the service rates @xmath117 let @xmath118 for all classes @xmath119 .    _",
    "packet dropping : _ at queue @xmath23 , allocate the packet dropping rate @xmath101 ( see  ) according to @xmath120 where @xmath121 is a constant chosen to satisfy assumption  [ assu:601 ] . at the drop queue @xmath98 ,",
    "allocate its service rate @xmath122 according to @xmath123    _ queue update : _ update queues @xmath23 according to   and update queues @xmath98 according to  - in every slot .    ' '' ''    the packet dropping subroutine in this policy is threshold - based .",
    "the @xmath107 policy uses local queueing information and does not require the knowledge of exogenous arrival rates .",
    "it is notable that network overload is autonomously resolved by each node making local decisions of routing and packet dropping .",
    "[ lem:402 ] for each class @xmath35 , define the constants @xmath124 in the @xmath107 policy , queues @xmath23 and @xmath98 are deterministically bounded by @xmath125 in addition , we have @xmath126 for all @xmath10 , @xmath9 , and @xmath11 .",
    "see appendix  [ appendix:601 ] .",
    "in lemma  [ lem:402 ] , the value of @xmath127 is the finite buffer size sufficient at queue @xmath23 .",
    "the parameter @xmath128 controls when queue @xmath23 starts dropping packets .",
    "indeed , due to @xmath129 , the @xmath107 policy discards packets from @xmath23 only if @xmath130 .",
    "the quantity @xmath131 is a controllable threshold beyond which we say queue @xmath23 is overloaded and should start dropping packets . as we see next , the performance of the @xmath107 policy approaches optimality as the buffer sizes increase .",
    "[ thm:501 ] define the limiting throughput of class @xmath9 as @xmath132,\\ ] ] where @xmath133 denotes the class @xmath9 packets received by node @xmath7 over link @xmath134 .",
    "the @xmath107 policy yields the limiting weighted sum throughput satisfying @xmath135 where @xmath75 is the optimal throughput vector that solves  - under the linear objective function @xmath136 , @xmath105 is a control parameter , and @xmath0 is a finite constant defined as @xmath137,\\ ] ] where @xmath138 denotes the cardinality of a set @xmath139 .",
    "we omit the proof of theorem  [ thm:501 ] because it is similar to that of theorem  [ thm:502 ] presented later in the general case of utility maximization . from  , the @xmath107 policy yields near - optimal performance by choosing the parameter @xmath128 sufficiently large .",
    "correspondingly , a large @xmath128 implies a large buffer size of @xmath140 .",
    "as shown in corollary  [ lem:501 ] , if the arrival rate matrix @xmath70 lies in the network capacity region @xmath66 , then the optimal throughput for class @xmath9 is @xmath76 and   reduces to @xmath141 that we can choose @xmath128 arbitrarily large leads to the next corollary .",
    "[ cor:601 ] the @xmath107 policy is ( close to ) throughput optimal .",
    "we conduct simulations for the @xmath107 policy in the network shown in fig .",
    "[ fig:101 ] .        the directed links @xmath142 and @xmath143 have the capacity of @xmath50 packet / slot .",
    "there are three classes of traffic to be served ; for example , class 1 data arrives at node @xmath0 and is destined for node @xmath52 .",
    "classes @xmath50 and @xmath53 compete for service over @xmath143 ; classes @xmath53 and @xmath54 compete for service over @xmath142 . each simulation below is run over @xmath144 slots .      in each class , we assume a bernoulli arrival process whereby @xmath145 packets arrive to the network in a slot with probability @xmath146 , and no packets arrive otherwise .",
    "the arrival rate of each class is 2 packets / slot , which clearly overloads the network .",
    "let @xmath40 be the throughput of class @xmath9 .",
    "consider the objective of maximizing the weighted sum throughput @xmath147 ; the weights are rewards obtained by serving a packet in a class .",
    "the optimal solution is : ( i ) always serve class @xmath50 at node @xmath0 because it yields better rewards than serving class @xmath53 .",
    "( ii ) always serve class @xmath54 at node @xmath51although class @xmath53 has better rewards than class @xmath54 , it does not make sense to serve class @xmath53 at @xmath51 only to be dropped later at @xmath0 .",
    "the optimal throughput vector is therefore @xmath148 .",
    "consider another objective of maximizing @xmath149 . here , class @xmath53 has a reward that is better than the sum of rewards of the other two classes .",
    "thus both nodes @xmath51 and @xmath0 should always serve class @xmath53 ; the optimal throughput vector is @xmath150 .",
    "table  [ table:601 ] shows the near - optimal performance of the @xmath107 policy in both cases as @xmath128 increases .",
    "we show that the @xmath107 policy is robust to time - varying arrival rates .",
    "suppose class @xmath50 and @xmath54 have a fixed arrival rate of @xmath151 packets / slot .",
    "the arrival rate of class @xmath53 is @xmath53 packets / slot in the interval @xmath152 and is @xmath146 packets / slot elsewhere .",
    "we consider the objective of maximizing @xmath149 .",
    "the network is temporarily overloaded in the interval @xmath153 ; the optimal time - average throughput in @xmath153 is @xmath150 as explained in the above case .",
    "the network is underloaded in the interval @xmath154 , in which the optimal throughput is @xmath155 .",
    "we use the following parameters here : @xmath156 , @xmath157 , @xmath158 , and @xmath159 .",
    "table  [ table:603 ] shows the near - optimal throughput performance of the @xmath107 policy .",
    "figure  [ fig:103 ] shows the sample paths of the queue processes @xmath160 , @xmath161 , @xmath162 , and @xmath163 in the simulation .",
    "clearly the queues suddenly build up when the network enters the overload interval @xmath153 , but the backlogs are kept close to the upper bound @xmath140 without blowing up .",
    ".the throughput performance of the @xmath107 policy under time - varying arrival rates . [ cols= \"",
    "< , < , < \" , ]",
    "in this paper we develop a receiver - based flow control and an in - network packet dropping strategy to cope with network overload .",
    "our scheme is robust to uncooperative users who do not employ source - based flow control and malicious users that intentionally overload the network .",
    "a novel feature of our scheme is a receiver - based backpressure / push - back mechanism that regulates data flows at the granularity of traffic classes , where packets can be classified based on aggregates of data flows .",
    "this is in contrast to source - based schemes that can only differentiate between source - destination pairs .",
    "we show that when the receiver - based flow control scheme is combined with a threshold - based packet dropping policy at internal network nodes , optimal utility can be achieved .",
    "10 [ 1]#1 url@samestyle [ 2]#2 [ 2]l@#1=l@#1#2    m.  chiang , s.  h. low , a.  r. calderbank , and j.  c. doyle , `` layering as optimization decomposition : a mathematical theory of network architectures , '' _ proc .",
    "ieee _ , vol .",
    "95 , no .  1 ,",
    "255312 , jan . 2007 .",
    "kelly , a.  k. maulloo , and d.  k.  h. tan , `` rate control in communication networks : shadow prices , proportional fairness and stability , '' _ journal of the oper .",
    "_ , vol .",
    "49 , pp . 237252 , 1998 .",
    "kelly , `` charging and rate control for elastic traffic , '' _",
    "european trans . telecommunications _",
    ", vol .  8 , pp . 3337 , 1997 .",
    "s.  h. low and d.  e. lapsley , `` optimization flow control  i : basic algorithm and convergence , '' _ ieee / acm trans .",
    "_ , vol .  7 , no .  6 , pp .",
    "861874 , dec .",
    "a.  l. stolyar , `` maximizing queueing network utility subject to stability : greedy primal - dual algorithm , '' _ queueing syst .",
    "_ , vol .",
    "50 , no .  4 , pp . 401457 , 2005 .",
    "m.  j. neely , e.  modiano , and c .- p .",
    "li , `` fairness and optimal stochastic control for heterogeneous networks , '' _ ieee / acm trans .",
    "_ , vol .  16 , no .  2 , pp .",
    "396409 , apr .",
    "a.  eryilmaz and r.  srikant , `` joint congestion control , routing , and mac for stability and fairness in wireless networks , '' _ ieee j. sel .",
    "areas commun . _ ,",
    "24 , no .  8 , pp .",
    "15141524 , aug .",
    " , `` fair resource allocation in wireless networks using queue - length - based scheduling and congestion control , '' _ ieee / acm trans .",
    "_ , vol .  15 , no .  6 , pp .",
    "13331344 , dec . 2007 .",
    "x.  lin and n.  b. shroff , `` joint rate control and scheduling in multihop wireless networks , '' in _ ieee conf . decision and control ( cdc )",
    "2004 , pp . 14841489 .",
    "r.  k.  c. chang , `` defending against flooding - based distributed denial - of - service attacks : a tutorial , '' _ ieee commun . mag .",
    "_ , vol .",
    "40 , no .",
    "4251 , oct . 2002 .",
    "a.  srivastava , b.  b. gupta , a.  tyagi , a.  sharma , and a.  mishra , `` a recent survey on ddos attacks and defense mechanisms , '' in _ advances in parallel distributed computing _",
    "communications in computer and information science.1em plus 0.5em minus 0.4emspringer berlin heidelberg , 2011 , vol .",
    "570580 .",
    "j.  borland , `` net video not yet ready for prime time , '' feb .",
    "[ online ] .",
    "available : http://news.cnet.com/2100-1033-221271.html    r.  mahajan , s.  m. bellovin , s.  floyd , j.  ioannidis , v.  paxson , and s.  shenker , `` controlling high bandwidth aggregates in the network , '' _ acm computer communication review _",
    "32 , pp . 6273 , 2002 .",
    "l.  georgiadis , m.  j. neely , and l.  tassiulas , `` resource allocation and cross - layer control in wireless networks , '' _ foundations and trends in networking _ ,",
    "vol .  1 , no .  1 , 2006 .    m.  j. neely , _",
    "stochastic network optimization with application to communication and queueing systems_.1em plus 0.5em minus 0.4em morgan & claypool , 2010 .",
    "l.  georgiadis and l.  tassiulas , `` optimal overload response in sensor networks , '' _ ieee trans .",
    "inf . theory _",
    "52 , no .  6 , pp . 26842696 , jun",
    ". 2006 .    c.  w. chan , m.  armony , and n.  bambos , `` fairness in overloaded parallel queues , '' 2011 , working paper .",
    "d.  shah and d.  wischik , `` fluid models of congestion collapse in overloaded switched networks , '' _ queueing syst . _ ,",
    "69 , pp . 121143 , 2011 .",
    "r.  egorova , s.  borst , and b.  zwart , `` bandwidth - sharing in overloaded networks , '' in _ conf .",
    "information science and systems ( ciss ) _ , princeton , nj , usa , mar .",
    "2008 , pp . 3641 .",
    "d.  k.  y. yau , j.  c.  s. lui , f.  liang , and y.  yam , `` defending against distributed denial - of - service attacks with max - min fair server - centric router throttles , '' _ ieee / acm trans .",
    "_ , vol .  13 , no .  1 ,",
    "2942 , feb .",
    "2005 .    c.  w. tan , d .-",
    "chiu , j.  c.  s. lui , and d.  k.  y. yau , `` a distributed throttling approach for handling high bandwidth aggregates , '' _ ieee trans .",
    "parallel distrib .",
    "_ , vol .  18 , no .  7 ,",
    "pp . 983995 , jul .",
    "s.  chen and q.  song , `` perimeter - based defense against high bandwidth ddos attacks , '' _ ieee trans .",
    "parallel distrib .",
    "_ , vol .  16 , no .  6 , pp . 526537 , jun . 2005",
    ".    m.  j. neely , e.  modiano , and c.  e. rohrs , `` dynamic power allocation and routing for time - varying wireless networks , '' _ ieee j. sel .",
    "areas commun . _ ,",
    "23 , no .  1 ,",
    "89103 , jan .",
    "2005 .    m.  j. neely , `` super - fast delay tradeoffs for utility optimal fair scheduling in wireless networks , '' _ ieee j. sel . areas",
    "_ , vol .",
    "24 , no .  8 , pp . 14891501 ,",
    "first we show  - are necessary conditions . given a control policy ,",
    "let @xmath164 be the amount of class @xmath9 packets transmitted over link @xmath165 in the interval @xmath166 $ ] , and @xmath23 be the class @xmath9 packets queued at node @xmath10 at time @xmath11 . from the fact that the difference between incoming and outgoing packets at a node in @xmath166 $ ] is equal to the queue backlog at time @xmath11 , we have @xmath167 which holds for all nodes @xmath15 for each class @xmath168 . taking expectation and time average of",
    ", we obtain @xmath169 } = \\frac{{\\mathbb{e}\\left[{q_{n}^{(c)}}(t)\\right]}}{t } + \\frac{1}{t } { \\mathbb{e}\\left[\\sum_{b } f_{nb}^{(c)}(t)\\right]}.\\ ] ] the link capacity constraints lead to @xmath170 } \\leq { \\mu_{\\text{max}}}^{ab } , \\quad\\forall\\ , ( a , b)\\in { \\mathcal{l}}.\\ ] ] consider the sequences @xmath171/t$ ] and @xmath172/t$ ] indexed by @xmath11 in  . for each @xmath35 and @xmath173 , the sequence @xmath174/t , t\\in{\\mathbb{z}}^{+}\\}$ ]",
    "is bounded because the capacity of each link is bounded .",
    "it follows from   that the sequence @xmath175/t , t\\in{\\mathbb{z}}^{+}\\}$ ] is also bounded .",
    "there is a subsequence @xmath176 such that limit points @xmath68 and @xmath177 exist and satisfy , as @xmath178 , @xmath179 } & \\to f_{ab}^{(c ) } , \\quad \\forall\\,c\\in{\\mathcal{c}},\\ \\forall\\ , ( a , b)\\in{\\mathcal{l } } ,   \\label{eq:601 } \\\\",
    "\\frac{1}{t_{k}}{\\mathbb{e}\\left[{q_{n}^{(c)}}(t_{k})\\right ] } & \\to { q_{n}^{(c ) } } , \\quad \\forall\\,c\\in{\\mathcal{c}},\\ \\forall\\,n\\neq d_{c}. \\label{eq:602}\\end{aligned}\\ ] ] applying  - to  - results in   and  .",
    "define the throughput @xmath40 of class @xmath9 as @xmath180}.\\ ] ] the inequality in   follows   and  . the equality in   results from summing   over @xmath15 .",
    "to show the converse , it suffices to show that every interior point of @xmath38 is achievable .",
    "let @xmath181 be an interior point of @xmath38 , i.e. , there exists @xmath182 such that @xmath183 .",
    "there exist corresponding flow variables @xmath68 and @xmath177 such that @xmath184 in the flow system  - , by removing the subflows that contribute to queue overflows , we obtain new reduced flow variables @xmath185 and @xmath186 such that @xmath187 , @xmath188 , and @xmath189 define @xmath190 \\frac{r_{c}}{\\sum_{n } \\hat{\\lambda}_{n}^{(c)}-\\epsilon/2}.\\ ] ] from  , we have @xmath191 and @xmath192 .",
    "it is not difficult to check that @xmath193 , @xmath194 , and @xmath195 .",
    "combined with  - , we obtain @xmath196 where the first inequality is a strict one .",
    "these inequalities show that the rate matrix @xmath197 is an interior point of the network capacity region @xmath66 in definition  [ defn:101 ] , and therefore is achievable by a control policy , such as the back - pressure policy  @xcite . therefore , the aggregate rate vector @xmath39 , where @xmath198 , is also achievable .",
    "we prove lemma  [ lem:402 ] by induction .",
    "first we show @xmath98 is deterministically bounded .",
    "assume @xmath199 for some @xmath11 , which holds at @xmath200 because we let @xmath106 .",
    "consider the two cases :    1 .   if @xmath201 , then from   we obtain @xmath202 where the second inequality uses  .",
    "2 .   if @xmath203 , then the @xmath107 policy chooses @xmath204 at queue @xmath98 and we have @xmath205^{+ } + { d_{\\text{max}}}\\\\ & \\leq \\max[{d_{n}^{(c)}}(t ) , { d_{\\text{max } } } ] \\leq { d_{\\text{max}}}^{(c)},\\end{aligned}\\ ] ] where the last inequality uses the induction assumption .    from these two cases ,",
    "we obtain @xmath206 .    similarly , we show @xmath23 is bounded .",
    "assume @xmath207 for some @xmath11 , which holds at @xmath200 because we let @xmath208 .",
    "consider the two cases :    1 .   if @xmath209 , then from   we get @xmath210 where the second inequality uses assumption  [ assu:601 ] .",
    "2 .   if @xmath211 , the @xmath107 policy chooses @xmath212 at queue @xmath23 and we have @xmath213 where the third inequality uses induction assumption .",
    "we conclude that @xmath214 .    finally , we show @xmath129 for all slots .",
    "assume this is true at some time @xmath11 ; this holds when @xmath200 because we assume @xmath106 .",
    "consider the two cases :    1 .   if @xmath215 , the @xmath107 policy chooses @xmath216 at queue @xmath98 and we have @xmath217 by induction assumption .",
    "2 .   if @xmath218 , the @xmath107 policy chooses @xmath219 and we have @xmath220    the proof is complete .",
    "[ [ appendix:501 ] ]    we construct a proper lypuanov drift inequality that leads to the @xmath221 policy .",
    "let @xmath222 be the vector of all physical and virtual queues in the network . using the parameters @xmath223 and @xmath224 given in the policy",
    ", we define the lyapunov function @xmath225^{2 } + \\frac{1}{2}\\sum_{c , n\\neq d_{c } } \\bigl[d_{n}^{(c)}(t)\\bigr]^{2 } \\\\",
    "+ \\sum_{c\\in{\\mathcal{c } } } \\big(e^{w{\\big(z_{c}(t)-q\\big ) } } + e^{w{\\big(q - z_{c}(t)\\big ) } } \\big).\\end{gathered}\\ ] ] the last sum is a lyapunov function whose value grows exponentially when @xmath226 deviates in both directions from the constant @xmath224 .",
    "this exponential - type lyapunov function is useful for both stabilizing @xmath226 and guaranteeing there is sufficient data in @xmath226 .",
    "such exponential - type lyapunov functions are previously used in  @xcite to study the optimal utility - delay tradeoff in wireless networks .",
    "we define the lyapunov drift @xmath227},\\ ] ] where the expectation is with respect to all randomness in the system in slot @xmath11 .",
    "define the indicator function @xmath228 if @xmath229 and @xmath230 otherwise ; define @xmath231 .",
    "define @xmath232 .",
    "the next lemma is proved in appendix  [ appendix:202 ] .",
    "[ lem:401 ] the lyapunov drift @xmath233 under any control policy satisfies @xmath234 } \\notag \\\\   & + v\\sum_{nc}\\theta_{c } \\,{\\mathbb{e}\\left[{\\varphi_{n}^{(c)}}(t)\\mid h(t)\\right ] } \\leq b + \\sum_{nc } { q_{n}^{(c)}}(t ) { \\lambda_{n}^{(c)}}\\notag\\\\ & -\\sum_{nc } { q_{n}^{(c)}}(t ) { \\mathbb{e}\\left[\\sum_{b } \\mu_{nb}^{(c)}(t ) + d_{n}^{(c)}(t ) - \\sum_{a } \\mu_{an}^{(c)}(t ) \\mid h(t)\\right ] } \\notag \\\\ & - \\sum_{nc } { d_{n}^{(c)}}(t ) { \\mathbb{e}\\left[{\\varphi_{n}^{(c)}}(t)-{d_{n}^{(c)}}(t ) \\mid h(t)\\right ] } \\notag \\\\ & -v \\sum_{c } { \\mathbb{e}\\left[h_{c}\\big(\\nu_{c}(t)\\big ) \\mid h(t)\\right ] } + v\\sum_{nc } \\theta_{c}\\ , { \\mathbb{e}\\left[{\\varphi_{n}^{(c)}}(t)\\mid h(t)\\right ] } \\notag \\\\ & - w \\sum_{c }   { 1_{c}^{\\text{r}}}(t ) e^{w(z_{c}(t)-q ) } \\big({\\mathbb{e}\\left[\\delta_{c}(t)\\mid h(t)\\right ] } - \\frac{\\epsilon}{2 } \\big ) \\notag \\\\ & + w \\sum_{c } { 1_{c}^{\\text{l}}}(t ) e^{w(q - z_{c}(t))}\\big({\\mathbb{e}\\left [ \\delta_{c}(t ) \\mid h(t)\\right ] } + \\frac{\\epsilon}{2 } \\big),\\label{eq:227}\\end{aligned}\\ ] ] where @xmath0 is a finite constant defined by @xmath235 + \\\\ & \\quad 2 { \\left|{\\mathcal{n}}\\right|}{\\left|{\\mathcal{c}}\\right| } { d_{\\text{max}}}^{2 } + { \\left|{\\mathcal{c}}\\right|}\\big [ w(2{\\delta_{\\text{max}}}+\\epsilon ) + e^{w({\\nu_{\\text{max}}}+{\\mu_{\\text{max}}^{\\text{in } } } ) } + e^{wq } \\big ] . \\end{split}\\ ] ]    by isolating decisions variables in  , it is not difficult to verify that the @xmath221 policy observes the current network state @xmath236 and minimizes the right - hand side of   in every slot .",
    "[ [ appendix:202 ] ]    we establish the lyapunov drift inequality in  .",
    "applying to   the fact that @xmath237^{+ } = ( a - b - c)^{+}$ ] for nonnegative reals @xmath238 , @xmath239 , and @xmath9 , and using lemma  [ lem:101 ] in appendix  [ appendix:203 ] , we have @xmath240^{2 } - \\big[q_{n}^{(c)}(t)\\big]^{2 } \\big ) \\leq b_{q } - \\\\ & q_{n}^{(c)}(t)\\ , \\big ( \\sum_{b } \\mu_{nb}^{(c)}(t ) + d_{n}^{(c)}(t )   - a_{n}^{(c)}(t ) - \\sum_{a } \\mu_{an}^{(c)}(t ) \\big ) , \\end{split}\\ ] ] where @xmath241 is a finite constant . from   and  , we get @xmath242^{+}+ { d_{n}^{(c)}}(t).\\ ] ] similarly , we obtain for queue @xmath98 @xmath243^{2 } - \\big[d_{n}^{(c)}(t)\\big]^{2 } \\big ) \\\\ \\leq b_{d } - d_{n}^{(c)}(t)\\ , \\big ( \\varphi_{n}^{(c)}(t ) - d_{n}^{(c)}(t ) \\big),\\end{gathered}\\ ] ] where @xmath244 is a finite constant .",
    "[ lem:202 ] given fixed constants @xmath245 and @xmath246 , we define @xmath247 then @xmath248,\\end{gathered}\\ ] ] @xmath249.\\end{gathered}\\ ] ]    define @xmath250 and @xmath251 ; we have @xmath252 and @xmath253 . equation   yields @xmath254 since @xmath255 , we have @xmath256 because the first term is bounded by the second term if @xmath257 , and is bounded by the third term otherwise .",
    "multiplying both sides by @xmath258 yields @xmath259,\\end{gathered}\\ ] ] where the last term follows the taylor expansion of @xmath260 .",
    "if we have @xmath261 then plugging   into   leads to  .",
    "indeed , by definition of @xmath223 in   we get @xmath262 which uses @xmath263 .    also ,   leads to @xmath264 define the event @xmath265 as @xmath266 i.e. , all upstream nodes of @xmath7 have sufficient data to transmit , in which case we must have @xmath267 .",
    "it follows @xmath268 where the second case follows that queue @xmath226 is always non - negative .",
    "similar as  , from   we obtain @xmath269 , \\end{split}\\ ] ] in which we use the taylor expansion of @xmath270 . bounding the last term of   by   and multiplying the inequality by @xmath271",
    ", we obtain  .",
    "now , define the indicator function @xmath228 if @xmath229 and @xmath230 otherwise .",
    "define @xmath231 .",
    "then for any real number @xmath238 , @xmath272 similarly , we have @xmath273 using @xmath274 in   and @xmath275 in  , inequalities   and   lead to @xmath276,\\end{gathered}\\ ] ] @xmath277.\\end{gathered}\\ ] ]    finally , summing   and   over @xmath15 for each @xmath168 , summing   and   over @xmath168 , and taking conditional expectation , we have @xmath278 } \\\\ - \\sum_{nc } { d_{n}^{(c)}}(t ) { \\mathbb{e}\\left[{\\varphi_{n}^{(c)}}(t)-{d_{n}^{(c)}}(t ) \\mid h(t)\\right ] } \\\\ - w \\sum_{c } { 1_{c}^{\\text{r}}}(t ) e^{w(z_{c}(t)-q ) } \\big({\\mathbb{e}\\left[\\delta_{c}(t)\\mid h(t)\\right ] } - \\frac{\\epsilon}{2 } \\big ) \\\\ + w \\sum_{c } { 1_{c}^{\\text{l}}}(t ) e^{w(q - z_{c}(t))}\\big({\\mathbb{e}\\left[\\delta_{c}(t)\\mid h(t)\\right ] } + \\frac{\\epsilon}{2 } \\big),\\end{gathered}\\ ] ] where @xmath0 is a finite constant defined as @xmath279 .",
    "\\label{eq:1208}\\end{aligned}\\ ] ] the constants @xmath280 and @xmath281 are defined right after   and  , respectively .",
    "adding to both sides of   @xmath282 } +   v\\sum_{nc } \\theta_{c}\\ , { \\mathbb{e}\\left[{\\varphi_{n}^{(c)}}(t)\\mid h(t)\\right]}\\ ] ] yields  .",
    "the boundedness of the queues @xmath23 and @xmath98 follows the proof of lemma  [ lem:402 ] . for the queues @xmath226",
    ", we again prove by induction .",
    "suppose @xmath283 , which holds at @xmath200 because we let @xmath284 .",
    "consider the two cases :    1 .   if @xmath285 , then by   @xmath286 2 .   if @xmath287 , then from   we obtain @xmath288 where the last inequality follows our choice of @xmath128 satisfying @xmath289 as mentioned in section  [ sec:1201 ] . as a result , in",
    "we have @xmath290 where the inequality follows @xmath291 in  .",
    "since all queues @xmath23 for @xmath15 are deterministically bounded by @xmath127 , we have @xmath292 for all nodes @xmath10 such that @xmath293 .",
    "consequently , the @xmath221 policy does not transmit any class @xmath9 packets over the links @xmath294 and the virtual queue @xmath226 has no arrivals .",
    "therefore @xmath295 .",
    "we conclude that @xmath296 .",
    "the proof is complete .",
    "let the throughput vector @xmath75 and the flow variables @xmath297 be the optimal solution to the utility maximization  - .",
    "we consider the stationary policy that observes the current network state @xmath236 and chooses in every slot :      the first part is a feasible allocation because the value of @xmath78 is at most @xmath302 , which is less than or equal to @xmath28 by assumption  [ assu:601 ] .",
    "the second part is feasible because the link rates @xmath303 satisfy the link capacity constraints  .",
    "the third part is feasible because we assume @xmath304 .    under this stationary policy , by using the equality in   and using",
    ", we have @xmath305 in every slot . as a result , @xmath306 } &",
    "= \\mathbb{e}\\big[\\nu_{c}^{*}(t ) - \\sum_{a } \\mu_{ad_{c}}^{(c)*}(t )   \\mid z_{c}(t ) \\geq q\\big ] \\\\ & = { \\mathbb{e}\\left[\\nu_{c}^{*}(t ) - r_{c}^ { * } \\mid z_{c}(t ) \\geq q\\right ] } = \\frac{\\epsilon}{2 } , \\\\ { \\mathbb{e}\\left[\\delta_{c}^{*}(t)\\mid z_{c}(t ) < q\\right ] } & = 0.\\end{aligned}\\ ] ] the @xmath221 policy minimizes the right - hand side of   in every slot .",
    "using the decisions in the stationary policy , we can upper bound   under the @xmath221 policy by @xmath307 } + v\\sum_{nc } \\theta_{c}\\,{\\mathbb{e}\\left[{\\varphi_{n}^{(c)}}(t)\\mid h(t)\\right ] } \\notag \\\\ & \\leq b + { \\left|{\\mathcal{c}}\\right| } \\frac{w\\epsilon}{2 } e^{wq}- v \\sum_{c } h_{c}(\\nu_{c}^{*}(t ) ) + v \\sum_{nc } \\theta_{c}\\ , q_{n}^{(c ) * } \\notag \\\\ & \\ -\\sum_{nc } { q_{n}^{(c)}}(t ) \\big ( \\sum_{b } f_{nb}^{(c ) * } + q_{n}^{(c ) * } - { \\lambda_{n}^{(c)}}- \\sum_{a } f_{an}^{(c)*}\\big ) \\notag \\\\ & = b_{1 } - v \\sum_{c } h_{c}(\\nu_{c}^{*}(t ) ) + v \\sum_{nc}\\theta_{c}\\ , q_{n}^{(c ) * } , \\label{eq:404}\\end{aligned}\\ ] ] where we define @xmath308 and @xmath0 is given in  . the last equality in   is because the variables @xmath309 and @xmath78 satisfy the flow conservation constraints  .",
    "the utility functions @xmath36 are assumed to have bounded derivatives with @xmath43 for all @xmath44 . thus , the utility functions @xmath79 have bounded derivatives with @xmath310 for all @xmath44 . using @xmath311 , we have @xmath312 if @xmath301 then it is trivial . if @xmath313 then by mean - value theorem there exists @xmath314 such that @xmath315 using   in   yields @xmath307 } + v\\sum_{nc } \\theta_{c}\\,{\\mathbb{e}\\left[{\\varphi_{n}^{(c)}}(t)\\mid h(t)\\right ] } \\notag \\\\ & \\leq b_{1 } - v \\sum_{c } h_{c}(r_{c}^ { * } ) + v \\sum_{nc } \\theta_{c}\\,q_{n}^{(c ) * } + \\frac{v\\epsilon}{2 } \\sum_{c } ( m_{c}+\\theta_{c } ) \\notag \\\\ & = b_{1 } - v\\sum_{c } g_{c}(r_{c}^ { * } ) + v\\sum_{nc } \\theta_{c}\\,{\\lambda_{n}^{(c)}}+ \\frac{v\\epsilon}{2 } \\sum_{c } ( m_{c}+\\theta_{c } ) ,   \\label{eq:905}\\end{aligned}\\ ] ] where the last equality uses @xmath316 and @xmath317 in  .",
    "the next lemma is useful .",
    "the value of @xmath321 is the solution to the convex program  - . if @xmath229 , then we have @xmath322 and @xmath323 .",
    "if @xmath324 , the problem  - reduces to @xmath325 for all @xmath326 , we have by mean - value theorem @xmath327 where the first inequality results from the choice of @xmath328 that yields @xmath329 for all @xmath330 . rearranging terms in  , for all @xmath326 we have @xmath331 therefore ,",
    "the solution to the problem  - must satisfy @xmath332 . since @xmath333",
    ", we conclude @xmath320 .",
    "now , from lemma  [ lem:403 ] we have @xmath334 if @xmath335 then this is trivial . otherwise , if @xmath336 then by mean - value theorem we obtain for some @xmath337 that @xmath338 plugging   into   and rearranging terms yield @xmath339 } \\notag \\\\ & \\qquad+ v\\sum_{nc } \\theta_{c}\\,{\\mathbb{e}\\left[{\\varphi_{n}^{(c)}}(t)\\mid h(t)\\right ] } \\notag \\\\ & \\leq b_{1 } + \\frac{3v \\epsilon}{2 } \\sum_{c } ( m_{c}+\\theta_{c } ) - v\\sum_{c } g_{c}(r_{c}^ { * } ) + v\\sum_{nc } \\theta_{c}\\,{\\lambda_{n}^{(c)}}. \\label{eq:411}\\end{aligned}\\ ] ] define the time average @xmath340}.\\ ] ] define @xmath341 , @xmath342 , and @xmath343 similarly . taking expectation and time average over @xmath344 in  , dividing by @xmath128 , rearranging terms , and applying jensen s inequality to the functions @xmath79 , we get @xmath345}}{vt } - \\frac{3\\epsilon}{2 } \\sum_{c}(m_{c}+\\theta_{c}).\\end{gathered}\\ ] ] adding and subtracting @xmath346 at the left - hand side of   and using the definition of @xmath79 yield @xmath347}}{vt } - \\frac{3\\epsilon}{2 } \\sum_{c } ( m_{c}+\\theta_{c}).\\end{gathered}\\ ] ] from   and   we have @xmath348 taking expectation and time average yields @xmath349/t , \\label{eq:412 } \\\\",
    "\\overline{\\widetilde{\\nu}_{c}(t ) } = \\sum_{a } \\overline{\\widetilde{\\mu}_{ad_{c}}^{(c)}(t ) } + \\mathbb{e}\\big[z_{c}(0)-z_{c}(t)\\big]/t . \\label{eq:413}\\end{gathered}\\ ] ] now , by the law of flow conservation , the sum of exogenous arrival rates must be equal to the sum of delivered throughput , time averages of dropped packets , and queue growth rates .",
    "in other words , we have for each class @xmath168 and for all slots @xmath11 @xmath350.\\ ] ] combining  - yields @xmath351 } + \\frac{1}{t } \\sum_{n } { \\mathbb{e}\\left[{d_{n}^{(c)}}(t)+{q_{n}^{(c)}}(t)\\right]}.\\end{gathered}\\ ] ]    finally , using the boundedness of queues @xmath23 , @xmath98 , and @xmath226 in lemma  [ lem:502 ] and the continuity of @xmath36 , we obtain from   and   that @xmath352 where the last equality of   uses the definition in  . taking a limit of   as @xmath353 and using   and",
    ", we obtain @xmath354 where the constant @xmath355 , defined in  , is @xmath356 \\\\ & \\quad + { \\left|{\\mathcal{c}}\\right| } \\big [ w ( 2{\\delta_{\\text{max}}}+ \\epsilon )   +   e^{w({\\nu_{\\text{max}}}+ { \\mu_{\\text{max}}^{\\text{in } } } ) } + \\frac{w\\epsilon}{2}e^{wq } + e^{wq}\\big ] .",
    "\\end{split}\\ ] ] the proof is complete .",
    "[ lem:101 ] if a queue process @xmath357 satisfies @xmath358 where @xmath359 and @xmath360 are nonnegative bounded random variables with @xmath361 and @xmath362 , then there exists a positive constant @xmath0 such that @xmath363"
  ],
  "abstract_text": [
    "<S> we consider utility maximization in networks where the sources do not employ flow control and may consequently overload the network . in the absence of flow control at the sources , some packets will inevitably have to be dropped when the network is in overload . to that end , we first develop a distributed , threshold - based packet dropping policy that maximizes the weighted sum throughput . </S>",
    "<S> next , we consider utility maximization and develop a receiver - based flow control scheme that , when combined with threshold - based packet dropping , achieves the optimal utility . </S>",
    "<S> the flow control scheme creates virtual queues at the receivers as a _ push - back _ mechanism to optimize the amount of data delivered to the destinations via back - pressure routing . </S>",
    "<S> a novel feature of our scheme is that a utility function can be assigned to a collection of flows , generalizing the traditional approach of optimizing per - flow utilities . </S>",
    "<S> our control policies use finite - buffer queues and are independent of arrival statistics . </S>",
    "<S> their near - optimal performance is proved and further supported by simulation results . </S>"
  ]
}