{
  "article_text": [
    "in recent years , a large number of characterizations of complexity classes based on logics and lambda calculi have appeared .",
    "at least three different principles have been exploited , namely linear types  @xcite , restricted modalities in the context of linear logic  @xcite and non - size - increasing computation  @xcite . although related one to the other , these systems have been studied with different , often unrelated methodologies and few results are known about relative intentional expressive power .",
    "we believe that this area of implicit computational complexity needs unifying frameworks for the analysis of quantitative properties of computation .",
    "this would help to improve the understanding on existing systems .",
    "more importantly , unifying frameworks can be used _ themselves _ as a foundation for controlling the use of resources inside programming languages .",
    "in this paper , we introduce a new semantical framework which consists of an innovative modification of realizability . the main idea underlying our proposal lies in considering bounded - time algorithms as realizers instead of taking plain turing machines as is usually the case in realizability constructions .",
    "bounds are expressed abstractly as elements of a monoid .",
    "we can define a model for a given ( logical or type ) system by choosing a monoid flexible enough to justify all the constructs in the system .",
    "the model can then be used to study the class of representable functions .",
    "this allows us to give new proofs of soundness ( all representable functions on base types lies in certain complexity classes ) for light affine logic ( lal , @xcite ) , elementary affine logic ( eal , @xcite ) , lfpl  @xcite and soft affine logic ( sal , @xcite ) . while being the first entirely semantical proof of polytime soundness for light logics , our proof also provides a notable simplification of the original already semantical proof of polytime soundness for lfpl  @xcite .",
    "a new result made possible by the semantic framework is the addition of polymorphism and a modality to lfpl .",
    "[ [ related - work ] ] related - work + + + + + + + + + + + +    realizability has been used in connection with resource - bounded computation in several places .",
    "the most prominent is cook and urquhart work  @xcite , where terms of a language called @xmath0 are used to realize formulas of bounded arithmetic .",
    "the contribution of that paper is related to ours in that realizability is used to show `` polytime soundness '' of a logic .",
    "there are important differences though .",
    "first , realizers in cook and urquhart  @xcite are typed and very closely related to the logic that is being realized .",
    "second , the language of realizers @xmath0 only contains first order recursion and is therefore useless for systems like lfpl  or lal .",
    "in contrast , we use untyped realizers and interpret types as certain partial equivalence relations on those .",
    "this links our work to the untyped realizability model heo ( due to kreisel  @xcite ) .",
    "this , in turn , has also been done by crossley et al .",
    "there , however , one proves externally that untyped realizers ( in this case of bounded arithmetic formulas ) are polytime . in our work , and this happens for the first time , the untyped realizers are used to give meaning to the logic and obtain polytime soundness as a corollary .",
    "thus , certain resource bounds are built into the untyped realizers by their very construction .",
    "such a thing is not at all obvious , because untyped universes of realizers tend to be turing complete from the beginning to due definability of fixed - point combinators .",
    "we get around this problem through our notion of a resource monoid and addition of a certain time bound to kleene applications of realizers . indeed",
    ", we consider this as the main innovation of our paper and hope it to be useful elsewhere .",
    "in this section , we introduce the category of length spaces and study its properties .",
    "lengths will not necessarily be numbers but rather elements of a commutative monoid .",
    "a _ resource monoid _ is a quadruple @xmath1 where    @xmath2 is a commutative monoid ;    @xmath3 is a pre - order on @xmath4 which is compatible with @xmath5 ;    @xmath6 is a function such that for every @xmath7 @xmath8 and , moreover , for every @xmath9 there is @xmath10 such that @xmath11 .    given a resource monoid @xmath1 , the function @xmath12 is defined by putting @xmath13 .",
    "we abbreviate @xmath14 ( @xmath15 times ) as @xmath16 .",
    "let us try to give some intuition about these axioms .",
    "we shall use elements of a resource monoid to bound data , algorithms , and runtimes in the following way : an element @xmath17 bounds an algorithm @xmath18 if @xmath19 and , more importantly , whenever @xmath10 bounds an input @xmath20 to @xmath18 then there must be a bound @xmath21 for the result @xmath22 and , most importantly , the runtime of that computation must be bounded by @xmath23 .",
    "so , in a sense , we have the option of either producing a large output fast or to take a long time for a small output .",
    "the `` inverse triangular '' law above ensures that the composition of two algorithms bounded by @xmath24 and @xmath25 , respectively , can be bounded by @xmath26 or a simple modification thereof . in particular , the contribution of the unknown intermediate result in a composition cancels out using that law .",
    "another useful intuition is that @xmath27 behaves like the difference @xmath28 , indeed , @xmath29 .",
    "a _ length space _ on a resource monoid @xmath1 is a pair @xmath30 , where @xmath31 is a set and @xmath32 is a ( infix ) relation satisfying the following conditions :    if @xmath33 , then @xmath34 ;    for every @xmath35 , there are @xmath36 such that @xmath33    if @xmath33 and @xmath37 , then @xmath38 ;    if @xmath33 and @xmath39 , then @xmath40 .",
    "the last requirement implies that each element of @xmath31 is uniquely determined by the ( nonempty ) set of it realisers and in particular limits the cardinality of any length space to the number of partial equivalence relations on @xmath41 .",
    "a _ morphism _ from length space @xmath30 to length space @xmath42 ( on the same resource monoid @xmath1 ) is a function @xmath43 such that there exist @xmath44 , @xmath45 with @xmath19 and whenever @xmath46 , there must be @xmath47 such that    @xmath48 ;    @xmath21 ;    @xmath49 ;    @xmath50    we call @xmath18 a realizer of @xmath51 and @xmath17 a majorizer of @xmath51 .",
    "the set of all morphisms from @xmath52 to @xmath53 is denoted as @xmath54 .",
    "if @xmath51 is a morphism from @xmath52 to @xmath53 realized by @xmath18 and majorized by @xmath17 , then we will write @xmath55 or @xmath56 .",
    "[ remark : oldstuff ] it is possible to alter the time bound in the definition of a morphism to @xmath57 .",
    "this allows one to accommodate linear time operations by padding the majorizer for the morphism .",
    "all the subsequent proofs go through with this alternative definition , at the expense of simplicity and ease of presentation ,    given two length spaces @xmath30 and @xmath42 on the same resource monoid @xmath58 , we can build @xmath59 ( on @xmath58 ) where @xmath60 iff @xmath34 and there are @xmath61 with @xmath62 @xmath63 is a well - defined length space due to the axioms on @xmath58 .",
    "given @xmath52 and @xmath53 as above , we can build @xmath64 where @xmath65 iff @xmath51 is a morphism from @xmath52 to @xmath53 realized by @xmath18 and majorized by @xmath10 .",
    "length spaces and their morphisms form a symmetric monoidal closed category with tensor and linear implication given as above .    a length space @xmath66 is defined by @xmath67 and @xmath68 when @xmath34 . for each length space @xmath52",
    "there are isomorphisms @xmath69 and a unique morphism @xmath70 .",
    "the latter serves to justify full weakening .",
    "we can now formally show that second order multiplicative affine logic ( i.e. multiplicative linear logic plus full weakening ) can be interpreted inside the category of length spaces on any monoid @xmath58 .",
    "doing this will simplify the analysis of richer systems presented in following sections .",
    "formulae of ( intuitionistic ) multiplicative affine logic are generated by the following productions : @xmath71 where @xmath10 ranges over a countable set of atoms .",
    "rules are reported in figure  [ figure : mal ] .",
    "a _ realizability environment _ is a partial function assigning length spaces ( on the same resource monoid ) to atoms .",
    "realizability semantics @xmath72 of a formula @xmath52 on the realizability environment @xmath73 is defined by induction on @xmath52 : @xmath74 where @xmath75}^\\mathscr{r } } } } a}\\end{aligned}\\ ] ] here @xmath76 stands for the class of all length spaces .",
    "a little care is needed when defining the product since strictly speaking it does not exist for size reasons .",
    "the standard way out is to let the product range over those length spaces whose underlying set equals the set of equivalence classes of a partial equivalence relation on @xmath41 . as already mentioned , every length space is isomorphic to one such .",
    "when working with the product one has to insert these isomorphisms in appropriate places which , however , we elide to increase readability .    if @xmath77 and @xmath78 are formulas , the expression @xmath79 stands for @xmath66 if @xmath80 and @xmath81 if @xmath82 .",
    "in this section , we define a resource monoid @xmath83 such that elementary affine logic can be interpreted in the category of length spaces on @xmath83 .",
    "we then ( re)prove that functions representable in eal  are elementary time computable .    a _ list",
    "_ is either @xmath84 or @xmath85 where @xmath9 and @xmath86 is itself a list .",
    "the sum @xmath87 of two lists @xmath86 and @xmath88 is defined as follows , by induction on @xmath86 : @xmath89 for every @xmath90 , binary relations @xmath91 on lists can be defined as follows    @xmath92 ;    @xmath93 iff there is @xmath94 such that    @xmath95 ;    @xmath96 .    for every @xmath18 and for every lists @xmath86 and @xmath88 with @xmath97 , we define the natural number @xmath98 as follows : given a list @xmath86 , @xmath99 stands for the list @xmath100 . the depth @xmath101 of a list @xmath86",
    "is defined by induction on @xmath86 : @xmath102 while @xmath103 .",
    "@xmath104 stands for the maximum integer appearing inside @xmath86 , i.e. @xmath105 and @xmath106 . for every natural number @xmath15 , @xmath107_{\\mathcal{l}}}$ ]",
    "stands for @xmath108 .",
    "@xmath109 will denote the set of all lists , while @xmath110 will denote @xmath111 and @xmath112 , respectively .",
    "[ lemma : elsresource ] @xmath113 is a resource monoid .",
    "an _ elementary length space _ is a length space on the resource monoid @xmath114 .",
    "given an elementary length space @xmath30 , we can build the length space @xmath115 , where @xmath116 iff @xmath117 and @xmath118 .",
    "the construction @xmath119 on elementary length spaces serves to capture the exponential modality of elementary affine logic .",
    "indeed , the following two results prove the existence of morphisms and morphisms - forming rules precisely corresponding to axioms and rules from eal .    if @xmath55 , then there is @xmath120 such that @xmath121    elementary bounds can be given on @xmath122 depending on @xmath104 and @xmath101 :    [ prop : ealbound ] for every @xmath9 there is an elementary function @xmath123 such that @xmath124 .",
    "we emphasize that proposition  [ prop : ealbound ] does not assert that the mapping @xmath125 is elementary .",
    "this , indeed , can not be true because we know eal  to be complete for the class of elementary functions . if , however , @xmath126 is such that @xmath127 implies @xmath128 for a fixed @xmath129 , then @xmath130 is elementary and it is in this way that we will use the above proposition .",
    "eal  can be obtained by endowing multiplicative affine logic with a restricted modality .",
    "the grammar of formulae is enriched with a new production @xmath131 while modal rules are reported in figure  [ figure : eal ] .",
    "realizability semantics is extended by @xmath132 .",
    "[ theo : eal ] elementary length spaces form a model of eal .    now , consider the formula @xmath133 binary lists can be represented as cut - free proofs with conclusion @xmath134 .",
    "suppose you have a proof @xmath135 .",
    "from the denotation @xmath136 we can build a morphism @xmath137 from @xmath138 to @xmath139 by internal application to @xmath140 .",
    "this map then induces a function @xmath141 as follows : given @xmath142 , first compute a realizer for the closed proof corresponding to it , then apply @xmath137 to the result .",
    "[ remark : bounddepth ] notice that elements of @xmath139 can all be majorized by lists with unit depth .",
    "similarly , elements of @xmath138 corresponding to binary lists can be majorized by lists with bounded depth .",
    "this observation is essential to prove the following result .",
    "let @xmath143 be an eal  proof with conclusion @xmath144 and let @xmath145 be the function induced by @xmath136 .",
    "then @xmath51 is computable in elementary time .",
    "the function @xmath51 in the previous result equals the function denoted by the proof @xmath143 in the sense of @xcite .",
    "this intuitively obvious fact can be proved straightforwardly but somewhat tediously using a logical relation or similar , see also @xcite .",
    "in  @xcite one of us had introduced another language , lfpl , with the property that all definable functions on natural numbers are polynomial time computable .",
    "the key difference between lfpl  and other systems is that a function defined by iteration or recursion is not marked as such using modalities or similar and can therefore be used as a step function of subsequent recursive definitions .    in this section",
    "we will describe a resource monoid @xmath146 for lfpl , which will provide a proof of polytime soundness for that system .",
    "this is essentially the same as the proof from  @xcite , but more structured and , hopefully , easier to understand .",
    "the new approach also yields some new results , namely the justification of second - order quantification , a !",
    "-modality , and a new type of binary trees based on cartesian product which allows alternative but not simultaneous access to subtrees .",
    "lfpl  is intuitionistic , affine linear logic , i.e. , a linear functional language with @xmath147 . unlike in the original presentation",
    "we also add polymorphic quantification here .",
    "in addition , lfpl  has basic types for inductive datatypes , for example unary and binary natural numbers , lists , and trees .",
    "there is one more basic type , namely @xmath148 , the resource type .",
    "the recursive constructors for the inductive datatypes each take an additional argument of type @xmath148 which prevents one to invoke more constructor functions than one .",
    "dually to the constructors one has iteration principles which make the @xmath148-resource available in the branches of a recursive definition .",
    "for example , the type @xmath149 of @xmath150-labelled binary trees has constructors @xmath151 and @xmath152 .",
    "the iteration principle allows one to define a function @xmath153 from closed terms @xmath52 and @xmath154 .    in this paper",
    "we `` internalise '' the assumption of closedness using a @xmath119-modality .    using this iteration principle one can encode recursive definitions by ml - style pattern matching provided recursive calls",
    "are made on structurally smaller arguments only .",
    "here is a fragment of an lfpl  program for `` treesort '' written in functional notation : the additional arguments of type @xmath148 are supplied using @. note that the insert function takes an extra argument of type @xmath148 .",
    ".... let insert x t d = match t with      leaf - > node(x , leaf , leaf)@d   | node(y , l , r)@d ' - >     if x<=y then node(y , insert x l d , r)@d '             else node(y , l , insert x r d)@d '    let extract t = match t with      leaf - > nil   | node(x , l , r)@d - >     append ( extract l ) ( cons(x , extract r)@d )   ....      the underlying set of @xmath146 is the set of pairs @xmath155 where @xmath156 is a natural number and @xmath157 is a monotone polynomial in a single variable @xmath20 .",
    "the addition is defined by @xmath158 , accordingly , the neutral element is @xmath159 .",
    "we have a submonoid @xmath160 .    to define the ordering we set @xmath161 iff @xmath162 and @xmath163 is monotone and nonnegative for all @xmath164 . for example , we have @xmath165 , but @xmath166 .",
    "the distance function is defined by @xmath167 we can pad elements of @xmath146 by adding a constant to the polynomial .",
    "the following is now obvious .",
    "both @xmath146 and @xmath168 are resource monoids .",
    "a simple inspection of the proofs in section  [ bloed ] shows that the realisers for all maps can be chosen from @xmath168 .",
    "this is actually the case for an arbitrary submonoid of a resource monoid .",
    "we note that realisers of elements may nevertheless be drawn from all of @xmath146 .",
    "we are thus led to the following definition .",
    "an lfpl - space is a length space over the resource monoid @xmath146 .",
    "a morphism from lfpl  length space @xmath52 to @xmath53 is a morphism between length spaces which admits a majorizer from @xmath168 .",
    "lfpl  length spaces with their maps form a symmetric monoidal closed category .",
    "let @xmath52 be an lfpl  space and @xmath169 .",
    "the lfpl  space @xmath170 is defined by @xmath171 and @xmath172 iff @xmath173 for some @xmath174 such that @xmath38 .",
    "so , @xmath170 corresponds to the subset of @xmath175 consisting of those tuples with all @xmath15 components equal to each other .",
    "the factor @xmath176 ( `` modified difference '' ) instead of just @xmath15 is needed in order to justify the linear time needed to compute the copying involved in the obvious morphism from @xmath177 to @xmath178 .",
    "let @xmath66 be an index set and @xmath179 be @xmath66-indexed families of lfplspaces .",
    "a uniform map from @xmath180 to @xmath181 consists of a family of maps @xmath182 such that there exist @xmath183 with the property that @xmath184 for all @xmath185 .",
    "recall that , in particular , the denotations of proofs with free type variables are uniform maps .    for each @xmath52",
    "there is a uniform ( in @xmath186 ) map @xmath187 .",
    "moreover , @xmath188 is isomorphic to @xmath52 .    the lfpl - space @xmath148 is defined by @xmath189 and put @xmath190 if @xmath191 .    for each lfpl - space @xmath52",
    "we define lfpl - space @xmath192 by @xmath193 and @xmath194 if there exists @xmath195 with @xmath196 and @xmath197 .",
    "[ bangprop ] there is an lfpl  space @xmath148 and for each lfpl  space @xmath52 there is an lfpl  space @xmath192 with the following properties :    @xmath198 .    if @xmath199 then @xmath200",
    ".    @xmath201    the obvious functions @xmath202 are a uniform map .",
    "the last property means intuitively that with @xmath15 `` diamonds '' we can extract @xmath15 copies from an element of type @xmath192 and get the @xmath15 `` diamonds '' back for later use .",
    "[ [ remark ] ] remark + + + + + +    we remark at this point that we obtain an alternative resource monoid @xmath203 for sal  whose underlying set and ordering are as in @xmath146 , but whose addition is given by addition as @xmath204",
    ". length spaces over @xmath203 with maps majorised by @xmath203 ( not @xmath168 ) then also form a sound model of sal .",
    "this points to a close relationship between lfpl  and sal  and also shows a certain tradeoff between the two systems .",
    "the slightly more complex model is needed for lfpl since in lfpl  the c - rule of sal  is so to say internalised in the form of the uniform map @xmath205 .",
    "notice that sal s map @xmath206 can not be uniform .",
    "this uniformity of lfpl  allows for an internal implementation of datatypes and recursion as we now show .",
    "let @xmath207 be a family of lfpl  spaces such that @xmath208 independent of @xmath185 .",
    "the lfpl  space @xmath209 is defined by @xmath210 and @xmath211 if @xmath212 for some @xmath185 .    note that if we have a uniform family of maps @xmath213 where @xmath214 does not depend on @xmath185 then we obtain a map @xmath215 ( existential elimination ) .",
    "conversely , if we have a uniform family of maps @xmath216 then we get a uniform family of maps @xmath217 ( existential introduction ) .",
    "we will use an informal `` internal language '' to denote uniform maps which when formalised would amount to an extension of lfpl  with indexed type dependency in the style of dependent ml @xcite .      in order to interpret unary natural numbers ,",
    "we define @xmath218 where @xmath219 we can internally define a successor map @xmath220 as follows : starting from @xmath221 and @xmath222 we obtain a member of @xmath223 ( from @xmath224 and @xmath225 ) and we define @xmath226 as @xmath227 . from this , we obtain a map @xmath228 by existential introduction and elimination .",
    "of course , we also have a constant zero @xmath229 yielding a map @xmath230 by existential introduction .",
    "finally , we can define an iteration map @xmath231 as follows : given @xmath232 and @xmath233 we unpack @xmath234 using proposition  [ bangprop ] to yield @xmath235 as well as @xmath236 . feeding these `` diamonds '' one by one to the components of @xmath237 we obtain @xmath238 .",
    "but then @xmath239 yields the required element of @xmath240 .",
    "existential elimination now yields a single map @xmath241",
    "we have given a unified semantic framework with which to establish soundness of various systems for capturing complexity classes by logic and programming .",
    "most notably , our framework has all of second - order multiplicative linear logic built in , so that only the connectives and modalities going beyond this need to be verified explicitly .",
    "while resulting in a considerable simplification of previous soundness proofs , in particular for lfpl  and lal , our method has also lead to new results , in particular polymorphism and a modality for lfpl .    the method proceeds by assiging both abstract resource bounds in the form of elements from a resource monoid and resource - bounded computations to proofs ( respectively , programs ) .",
    "in this way , our method can be seen as a combination of traditional kleene - style realisability ( which only assigns computations ) and polynomial and quasi interpretation known from term rewriting ( which only assigns resource bounds ) .",
    "an altogether new aspect is the introduction of more general notions of resource bounds than just numbers or polynomials as formalised in the concept of resource monoid .",
    "we thus believe that our methods can also be used to generalise polynomial interpretations to ( linear ) higher - order .",
    "patrick baillot and virgile mogbil .",
    "soft lambda - calculus : a language for polynomial time computation . in _ proceedings of the 7th international conference on foundations of software science and computational structures _ , 2004 .",
    "paolo coppola and simone martini .",
    "typing lambda terms in elementary logic with linear constraints . in _ proceedings of the 6th international conference on typed lambda - calculus and applications _ ,",
    "pages 7690 , 2001 ."
  ],
  "abstract_text": [
    "<S> we give new proofs of soundness ( all representable functions on base types lies in certain complexity classes ) for elementary affine logic , lfpl  ( a language for polytime computation close to realistic functional programming introduced by one of us ) , light affine logic and soft affine logic . </S>",
    "<S> the proofs are based on a common semantical framework which is merely instantiated in four different ways . </S>",
    "<S> the framework consists of an innovative modification of realizability which allows us to use resource - bounded computations as realisers as opposed to including all turing computable functions as is usually the case in realizability constructions . </S>",
    "<S> for example , all realisers in the model for lfpl  are polynomially bounded computations whence soundness holds by construction of the model . </S>",
    "<S> the work then lies in being able to interpret all the required constructs in the model . while being the first entirely semantical proof of polytime soundness for light logics , our proof also provides a notable simplification of the original already semantical proof of polytime soundness for lfpl . </S>",
    "<S> a new result made possible by the semantic framework is the addition of polymorphism and a modality to lfpl  thus allowing for an internal definition of inductive datatypes . </S>"
  ]
}