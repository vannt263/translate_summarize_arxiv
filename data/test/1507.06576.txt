{
  "article_text": [
    "version  4.0 of the asp grounder gringo was released in march of 2013 . ]",
    "@xcite defined the semantics of a subset of its input language in terms of stable models of infinitary propositional formulas @xcite .",
    "that subset does not include , however , several constructs that are frequently used in asp programs .",
    "one such construct is integer intervals .",
    "take , for instance , the asp solution to the @xmath0-queens problem shown in table  [ kappa ] .",
    "( it is similar to one of the solutions in the language of version  3 presented by @xcite . )",
    "[ kappa ]    l + % place queens on the chess board + \\ { q(1 .. n,1 .. n ) } .",
    "+   + % exactly 1 queen per row / column + : - x = 1 .. n , not # count\\ { y : q(x , y ) } = 1 .   + : - y = 1 .. n , not # count\\ { x : q(x , y ) } = 1 .",
    "+   + % pre - calculate the diagonals + d1(x , y , x - y+n ) : - x = 1 .. n , y = 1 .. n .   + d2(x , y , x+y-1 ) : - x = 1 .. n , y = 1 .. n .   +   +",
    "% at most one queen per diagonal + : - d = 1 .. n*2 - 1 , 2 \\",
    "{ q(x , y ) : d1(x , y , d ) } .",
    "+ : - d = 1 .. n*2 - 1 , 2 \\",
    "{ q(x , y ) : d2(x , y , d ) } .",
    "+   +    intervals are used in each rule of this program . to include intervals",
    ", we have to modify the semantics from @xcite in two ways .",
    "first , we have to say that an arithmetic term denotes , generally , a finite set of integers , not a single integer .",
    "( and it is not necessarily a set of consecutive integers , because the language of gringo allows us to write ( 1 .. 3)*2 , for instance .",
    "this expression denotes the set @xmath1 . )",
    "second , in the presence of intervals we can not treat a choice rule \\{a } as shorthand for the disjunctive rule a @xmath2 not@xmath3 a as proposed by @xcite .",
    "indeed , the first rule of the program in table  [ kappa ] has @xmath4 stable models ; the rule @xmath5 has only 2 stable models .",
    "another feature of gringo not covered by @xcite , which is somewhat similar to integer intervals , is pooling .",
    "pooling is used , for instance , in the head of the rule @xmath6 ( note that a semicolon , not a comma , separates x from y in the head . )",
    "this rule has the same meaning as the pair of rules @xmath7 pooling is often used to abbreviate a set of facts . for instance , instead of @xmath8 we can write @xmath9 in this paper , we talk about `` pools''groups of terms such as    yet another limitation of the proposal from @xcite is related to the difference between `` dlv - style '' aggregates , such as in the second rule of the program shown in table  [ kappa ] , and `` lparse - style '' aggregates , such as in the last rule of the program . both expressions have to do with counting .",
    "syntactically , the difference is that in expression  ( [ dlv ] ) both the name of the aggregate ( # count ) and the binary relation applied to the result of counting and a constant ( =) are shown explicitly ; in  ( [ lparse ] ) , the fact that the constant  2 occurs on the left , in the lower bound position , tells us that the relation @xmath10 is applied to that number and to the result of counting .",
    "more importantly , there is a difference between the kinds of objects that we count . in case of expression  ( [ dlv ] ) we count , for a given value of x , the values of the variable  y such that q(x , y ) belongs to the stable model . in case of  ( [ lparse ] ) we count , for a given value of  d , the atoms q(x , y ) that belong to the stable model and satisfy an additional condition : d2(x , y , d ) belongs to the model as well .",
    "thus the atom in front of the colon in  ( [ lparse ] ) plays two roles : it tells us what to count , and it gives a condition on the stable model that needs to be checked .",
    "the language studied by @xcite does not include lparse - style aggregates .",
    "the easiest way to add such aggregates is to treat them as abbreviations .",
    "for instance ,  ( [ lparse ] ) can be viewed as shorthand for the dlv - style expression @xmath11 ( in this paper we adopt a more elaborate translation that allows us to accommodate negated atoms in front of the colon . ) in this expression , the first occurrence of q(x , y ) is syntactically a term , and the second is an atom . thus treating  ( [ lparse ] ) as an abbreviation depends on the possibility of using the same symbol as a function and as a predicate .",
    "this is customary in prolog , but not in first - order logic , and this was not allowed by @xcite .",
    "our goal is to define the syntax and semantics of the language ag ( short for _ abstract gringo_)a large subset of the input language of gringo that includes the features mentioned previously and a few other constructs not described by @xcite .",
    "this is similar to the work that has led to the definition of the asp core language @xcite ..",
    "]@xmath12    the semantics of ag defined in this paper serves a specification for gringo from version  4.5 on .",
    "it can be used to prove the correctness of programs written in its input language .",
    "as an example , in the electronic appendix we prove the correctness of the program shown in table  [ kappa ] .",
    "ag is abstract in the sense that its definition disregards some details related to representing programs by strings of ascii characters .",
    "for example , semicolons are used in the input language of gringo in at least three ways : to denote disjunction in the head of a rule , conjunction in the body , and pooling within an atom . in ag ,",
    "three different symbols play these different roles .",
    "the richer alphabet of ag makes it easier to define the semantics of the language and to reason about asp programs .",
    "we assume that five sets of symbols are selected : _ numerals _ , _ symbolic constants _ , _ negated constants _ , _ variables _ , and _",
    "aggregate names_. we assume that a 11 correspondence between the set of symbolic constants and the set of negated constants is chosen . for every symbolic constant @xmath13 , the corresponding negated constant will be called its _ strong negation _ and denoted by @xmath14 .",
    "further , we assume that these sets do not contain the symbols + -/ .. -.5 cm = = , ; : ( ) \\ { } and that they are pairwise disjoint .",
    "all these symbols together form the alphabet of ag , and ag rules will be defined as strings over this alphabet .",
    "when a symbol is represented in ascii , its type is determined by its first two characters .",
    "for instance , a numeral starts with a digit or  - followed by a digit .",
    "a symbolic constant starts with a lower - case letter . a negated",
    "constant starts with  - followed by a lower - case letter .",
    "a variable starts with an upper - case letter , and an aggregate name starts with  # .",
    "( the strings # false , # inf , and  # sup , which represent @xmath15 , _ inf _ , and _ sup _ , also start with  # . ) the symbols @xmath16 and @xmath17 ( which are used to indicate the boundaries of a tuple within a term ) correspond to the ascii characters ( and ) . , is represented in ascii , a comma is appended to the tuple : ( a , ) . ]",
    "each of the symbols ( [ ops])([punct ] ) except for @xmath18 and  @xmath19 has a unique ascii representation ; the symbols @xmath18 and @xmath19 can be represented by semicolons and in some cases also by commas .",
    "we assume that a 11 correspondence between the set of numerals and the set  @xmath20 of integers is chosen .",
    "for every integer  @xmath0 , the corresponding numeral will be denoted by  @xmath21 .",
    "_ terms _ are defined recursively , as follows :    * all numerals , symbolic constants , and variables are terms ; * if  @xmath22 is a symbolic constant and  @xmath23 is a tuple of terms then @xmath24 is a term ; * if @xmath25 and @xmath26 are terms and @xmath27 is one of the symbols  ( [ ops ] ) then @xmath28 is a term ; * if @xmath23 is a tuple of terms then @xmath29 is a term .    in a term of the form @xmath30 the parentheses can be dropped , so that every symbolic constant can be viewed as a term . in a term of the form @xmath28 we will drop the parentheses when it should not lead to confusion .",
    "a term of the form @xmath31 can be abbreviated as @xmath32 .",
    "a term , or a tuple of terms , is _ precomputed _ if it contains neither variables nor symbols  ( [ ops ] ) .",
    "we assume a total order on precomputed terms such that _ inf _ is its least element , _ sup _ is its greatest element , and , for any integers @xmath33 and @xmath0 , @xmath34 iff @xmath35 .",
    "we assume that for each aggregate name  @xmath36 a function @xmath37 is chosen that maps every set of tuples of precomputed terms to a precomputed term.this understanding of @xmath37 is different from that given by ( * ? ? ?",
    "* section  3.3 ) .",
    "there , @xmath37 is understood as a function that maps tuples of precomputed terms to elements of @xmath38 . ]",
    "the ag counterparts of the aggregates implemented in version 4.5 of gringo are defined below using the following terminology .",
    "if the first member of a tuple  @xmath39 of precomputed terms is a numeral @xmath21 then we say that the integer  @xmath0 is the _ weight _ of  @xmath39 ; if @xmath39 is empty or its first member is not an integer then the weight of  @xmath39 is  0 . for any set  @xmath40 of tuples of precomputed terms ,    *",
    "@xmath41 is the numeral corresponding to the cardinality of  @xmath40 if  @xmath40 is finite , and @xmath42 otherwise ; * @xmath43 is the numeral corresponding to the sum of the weights of all tuples in  @xmath40 if  @xmath40 contains finitely many tuples with non - zero weights , and @xmath44 otherwise ; * @xmath45 is the numeral corresponding to the sum of the weights of all tuples in  @xmath40 whose weights are positive",
    "if  @xmath40 contains finitely many such tuples , and _ sup _ otherwise ; * @xmath46 is  @xmath42 if  @xmath40 is empty , the least element of the set consisting of the first elements of the tuples in @xmath40 if @xmath40 is a finite non - empty set , and _ inf _ if  @xmath40 is infinite ; * @xmath47 is  _ inf _ if  @xmath40 is empty , the greatest element of the set consisting of the first elements of the tuples in @xmath40 if @xmath40 is a finite non - empty set , and _ sup _ if  @xmath40 is infinite .",
    "a _ pool _ is an expression of the form @xmath48 where @xmath49 and each @xmath50 is a tuple of terms .",
    "is neither a term nor a pool . ] in particular , every tuple of terms is a pool .",
    "an _ atom _ is a string of one of the forms @xmath51 where @xmath13 is a symbolic constant and @xmath52 is a pool . in an atom of the form @xmath53 or @xmath54 the parentheses",
    "can be dropped , so that all symbolic constants and all negated constants can be viewed as atoms .    for any atom  @xmath55 , the strings a  a  a are _ symbolic literals_. has two stable models @xmath56 , @xmath57 ( see section  [ sem : inf ] )",
    "; the latter will disappear if we drop @xmath58 . ]",
    "an _ arithmetic literal _ is a string of the form @xmath59 where  @xmath25 ,  @xmath26 are terms and @xmath60 is one of the symbols ( [ comps ] ) .",
    "conditional literal _ is a string of the form @xmath61 where @xmath62 is a symbolic or arithmetic literal or the symbol @xmath15 and @xmath63 is a tuple of symbolic or arithmetic literals .",
    "if @xmath63 is empty then we will drop the colon , so that every symbolic or arithmetic literal can be viewed as a conditional literal .",
    "is empty is required . ]",
    "an _ aggregate atom _ is a string of one of the forms @xmath64 ( @xmath65 ) , where    * @xmath36 is an aggregate name , * each @xmath50 is a tuple of terms , * each @xmath66 is a tuple of symbolic or arithmetic literals ( if @xmath66 is empty and @xmath50 is nonempty then the preceding colon may be dropped ) , * each of @xmath60 , @xmath67 , @xmath68 is one of the symbols  ( [ comps ] ) , * each of @xmath69 , @xmath70 , @xmath71 is a term .    for any aggregate atom  @xmath55 ,",
    "the strings  ( [ ls ] ) are _ aggregate literals_.    a _ literal _ is a conditional literal or an aggregate literal .",
    "a _ choice expression _ is a string of the form @xmath72 where @xmath55 is an atom .",
    "a _ rule _ is a string of the form h_1h_k b_1b_m or of the form c b_1b_m ( @xmath73 ) , where each  @xmath74 is a symbolic or arithmetic literal , may be any conditional literal . ]",
    "@xmath75 is a choice expression , and each  @xmath76 is a literal .",
    "the expression @xmath77 is the _ body _ of the rule ; @xmath78 is the _",
    "head _ of ( [ rule3 ] ) ; @xmath75 is the _ head _ of ( [ rule4 ] ) .",
    "if the body of a rule is empty and the head is not then the arrow can be dropped .",
    "for instance , here are the first five rules of the program from table  [ kappa ] written in the syntax of  ag : @xmath79 the other two rules use abbreviations introduced in the next section .",
    "a _ program _ is a finite set of rules .",
    "let @xmath75 be an expression of the form s_1_1 \\{*t*_1 : l_1 : * l*_1;  ;*t*_n : l_n : * l*_n } _ 2s_2 ( @xmath80 ) , where each @xmath81 is a symbolic literal of one of the forms p(*t * ) p(*t * ) p(*t * ) ( @xmath13 is a symbolic or negated constant and @xmath23 is a tuple of terms ) and @xmath36 , @xmath50 , @xmath66 , @xmath67 , @xmath68 , @xmath70 , and @xmath71 are as in the definition of an aggregate atom .",
    "then a string of the form c b_1b_m ( @xmath82 ) , where each  @xmath76 is a literal , is shorthand for the set of rules consisting of the rule b_1b_m",
    "s_1_1 \\{*t*_1 : l_1 , * l*_1;  ;*t*_n : l_n , * l*_n } _ 2s_2 and , for each @xmath81 in ( [ chexp ] ) such that @xmath81 is an atom , the rule \\{l_i } b_1b_mc_i where  @xmath83 is the conjunction of the members of  @xmath66 .    in both ( [ choice2 ] ) and ( [ choice1 ] ) , the conjunction sign shown after  @xmath84 should be dropped if @xmath85 ; in ( [ choice1 ] ) it should also be dropped if @xmath83 is empty .",
    "the parts @xmath86 and @xmath87 in ( [ chexp ] ) are optional ; if one of them is missing then it is dropped from  ( [ choice2 ] ) as well ; if both are missing then rule  ( [ choice2 ] ) is dropped from the set altogether . if @xmath85 in ( [ choice ] ) then the arrow can be dropped .",
    "the _ term representations _ of literals ( [ forms ] ) are the tuples @xmath88 of terms .",
    "( each of them is indeed a tuple of terms , because @xmath89 can be viewed as a term . )",
    "also viewed as an abbreviation is any expression of the form s_1\\{l_1:*l*_1;  ;l_n:*l*_n}s_2 ( @xmath90 ) , where @xmath70 , @xmath71 are terms , each  @xmath81 is a symbolic literal of one of the forms ( [ forms ] ) that does not contain @xmath91 , and each  @xmath66 is a tuple of symbolic or arithmetic literals . is empty",
    "then the colon after  @xmath81 is dropped .",
    "] such an expression is understood differently depending on whether it occurs in the head or the body of a rule . in the head of a rule ,  ( [ cardc ] ) is understood as shorthand for an expression of the form ( [ chexp ] ) : s_1\\{*t*_1 : l_1 : * l*_1;",
    " ;*t*_n : l_n : * l*_n } s_2 where @xmath50 is the term representation of @xmath81 .",
    "if either or both of the terms  @xmath70 ,  @xmath71 are missing , the abbreviation is understood in a similar way .",
    "( note that choice expressions that do not contain  @xmath92 are expressions of the form ( [ cardc ] ) where both @xmath70 and @xmath71 are missing , @xmath93 , @xmath94 is of the form @xmath89 , and @xmath95 is empty . in this case , we do not view ( [ cardc ] ) as an abbreviation . )    in the body of a rule ( [ cardc ] ) is understood as shorthand for the aggregate atom @xmath96 where @xmath50 is the term representation of @xmath81 .",
    "is empty then the comma after  @xmath81 in this expression should be dropped . ]",
    "if either of the terms  @xmath70 ,  @xmath71 in ( [ cardc ] ) is missing , the abbreviation is understood in a similar way .",
    "these abbreviations can be used , for instance , to represent the last two rules of the program from table  [ kappa ] in the syntax of  ag : @xmath97 written out in full , these expressions become @xmath98",
    "we will define the semantics of ag using a syntactic transformation  @xmath99 .",
    "the function  @xmath99 converts rules into infinitary formulas formed from atoms of the form @xmath89 or @xmath100 , where  @xmath13 is a symbolic constant , and  @xmath23 is a tuple of precomputed terms .",
    "then the stable models of a program will be defined in terms of stable model semantics of infinitary formulas in the sense of @xcite , which is reviewed below .",
    "let @xmath101 be a propositional signature , that is , a set of propositional atoms .",
    "the sets are defined as follows :    * @xmath102 , * @xmath103 is obtained from @xmath104 by adding expressions @xmath105 and @xmath106 for all subsets @xmath107 of @xmath108 , and expressions for all @xmath109 .    the elements of @xmath110 are called _ ( infinitary ) formulas _ over @xmath101 .    in an infinitary formula ,",
    "the symbols @xmath111 and @xmath15 are understood as abbreviations for  @xmath112 and @xmath113 respectively ; @xmath114 stands for @xmath115 , and @xmath116 stands for .",
    "subsets of a signature  @xmath101 will also be called its _ interpretations_. the satisfaction relation between an interpretation and a formula is defined recursively as follows :    * for every atom @xmath13 from @xmath101 , @xmath117 if @xmath118 .",
    "* @xmath119 if for every formula @xmath120 in  @xmath107 , @xmath121 . *",
    "@xmath122 if there is a formula @xmath120 in  @xmath107 such that @xmath121 .",
    "* @xmath123 if @xmath124 or @xmath125 .",
    "we say that an interpretation satisfies a set @xmath107 of formulas , or is a _ model _ of @xmath107 , if it satisfies every formula in @xmath107 .",
    "two sets of formulas are _ equivalent _ if they have the same models .    the _ reduct _ @xmath126 of a formula  @xmath120 w.r.t .",
    "an interpretation  @xmath127 is defined as follows :    * for @xmath128 , @xmath129 if @xmath130 ; otherwise @xmath131 .",
    "* @xmath132 .",
    "* @xmath133 . * @xmath134 if @xmath135 ; otherwise .",
    "an interpretation  @xmath127 is a _ stable model _ of a set @xmath107 of formulas if it is minimal w.r.t .  set inclusion among the interpretations satisfying the reducts of all formulas from  @xmath107 .",
    "for instance , if @xmath136 then @xmath137 if @xmath138 then @xmath139 in both cases ,  @xmath127 is a minimal model of the reduct .",
    "consequently , both  @xmath56 and @xmath57 are stable models of @xmath140 .",
    "a term is _ ground _ if it does not contain variables .",
    "the definition of `` ground '' for pools , symbolic literals , and arithmetic literals is the same .",
    "semantically , every ground term  @xmath141 represents a finite set of precomputed terms  @xmath142 $ ] , which is defined recursively :    * if @xmath141 is a numeral or a symbolic constant then @xmath142 $ ] is @xmath143 ; * if @xmath141 is @xmath144 then @xmath142 $ ] is the set of terms @xmath145 for all @xmath146 , \\dots,$ ] @xmath147 $ ] ; * if @xmath141 is @xmath148 then @xmath142 $ ] is the set of numerals @xmath149 for all integers @xmath150 such that @xmath151 $ ] and @xmath152 $ ] ; similarly when @xmath141 is @xmath153 or @xmath154 ; * if @xmath141 is @xmath155 then @xmath142 $ ] is the set of numerals @xmath156 for all integers",
    "@xmath150 such that @xmath151 $ ] , @xmath152 $ ] , and @xmath157 ; * if @xmath141 is @xmath158 then @xmath142 $ ] is the set of numerals  @xmath159 for all integers @xmath33 such that , for some integers @xmath160 @xmath161 , \\qquad \\overline{n_2 } \\in [ t_2 ] , \\qquad   n_1 \\leq m \\leq n_2;\\ ] ] * if @xmath141 is @xmath162 then @xmath142 $ ] is the set of terms @xmath163 for all @xmath146,\\dots,$ ] @xmath147 $ ] .",
    "this definition is extended to an arbitrary ground pool  @xmath52 ; @xmath164 $ ] is a finite set of precomputed tuples :    * if @xmath52 is a tuple @xmath165 of terms @xmath166 then @xmath164 $ ] is the set of tuples @xmath167 for all ; * if @xmath52 is a pool @xmath168 @xmath169 then @xmath164 $ ] is @xmath170 \\cup \\dots \\cup [ { \\bf t}_n]$ ] .    for instance , @xmath171 $ ] is the set @xmath172 .",
    "it is clear that if a ground term @xmath141 contains neither symbolic constants nor the symbols  @xmath16 and  @xmath17 then every element of @xmath142 $ ] is a numeral .",
    "if a tuple  @xmath23 of ground terms is precomputed then @xmath173 $ ] is  @xmath174 .",
    "the set  @xmath142 $ ] can be empty .",
    "for example , @xmath175 = [ 1/0 ] = [ 1+a ] = \\emptyset$ ] .    about a tuple of terms that does not contain ..",
    "we say that it is _ interval - free_. it is clear that if a tuple  @xmath23 of ground terms is interval - free then the cardinality of the set @xmath173 $ ] is at most  @xmath176 .      for any ground ( symbolic or arithmetic ) literal @xmath177 we will define two translations , @xmath178 and @xmath179 .",
    "the specific translation function applied to an occurrence of a symbolic or arithmetic literal in a rule depends on the context , as we will see in the following sections .",
    "we will first consider symbolic literals .",
    "for any ground atom @xmath55 ,    * if @xmath55 is @xmath180 then @xmath181 is the conjunction of atoms @xmath89 over all tuples @xmath39 in  @xmath164 $ ] , and @xmath182 is the disjunction of these atoms ; * if @xmath55 is @xmath183 then @xmath181 is the conjunction of atoms @xmath100 over all tuples @xmath39 in  @xmath164 $ ] , and @xmath182 is the disjunction of these atoms ; * @xmath184 is @xmath185 , and @xmath186 is @xmath187 ; * @xmath188 is @xmath189 , and @xmath190 is @xmath191 .",
    "the definitions of @xmath192 and @xmath193 for arithmetic literals are as follows :    * @xmath194 is @xmath111 if the relation @xmath60 holds between the terms @xmath195 and @xmath196 for all @xmath197 $ ] and @xmath198 $ ] , and @xmath15 otherwise ; * @xmath199 is @xmath111 if the relation @xmath60 holds between the terms @xmath195 and @xmath196 for some @xmath200 such that @xmath146 $ ] and @xmath198 $ ] , and @xmath15 otherwise .",
    "for instance , @xmath201 is @xmath202 , and @xmath203 is @xmath111 .    for any tuple @xmath63 of ground literals",
    ", @xmath204 stands for the conjunction of the formulas @xmath179 for all members @xmath177 of @xmath63 .",
    "the expressions @xmath205 and @xmath206 both stand for @xmath15 .",
    "it is clear that if @xmath55 has the form @xmath89 or @xmath100 , where @xmath23 is a tuple of precomputed terms , then each of the formulas @xmath207 and @xmath208 is @xmath55 .",
    "the result of applying @xmath99 to a choice expression @xmath209 is the conjunction of the formulas @xmath210 over all tuples @xmath23 in @xmath164 $ ] . similarly , the result of applying @xmath99 to a choice expression @xmath211 is the conjunction of the formulas @xmath212 over all tuples @xmath23 in @xmath164 $ ] .",
    "for instance , the result of applying @xmath99 to rule @xmath213 ( see section  [ rp ] ) is _ 1 i , j n ( q(i , j ) q(i , j ) ) .      about a variable",
    "we say that it is _ global _    * in a conditional literal @xmath61 , if it occurs in  @xmath62 but does not occur in  @xmath63 ; * in an aggregate literal @xmath55 , @xmath214 , or @xmath215 , where @xmath55 is of one of the forms  ( [ ag1])([ag3 ] ) , if it occurs in  @xmath216 or @xmath71 ; * in a rule  ( [ rule3 ] ) , if it is global in at least one of the expressions  @xmath74 ,  @xmath76 ; * in a rule  ( [ rule4 ] ) , if it occurs in @xmath75 or is global in at least one of the expressions  @xmath76 .",
    "an _ instance _ of a rule  @xmath217 is any rule that can be obtained from  @xmath217 by substituting precomputed terms for all global variables .",
    "this definition differs slightly from that given by ( * ? ? ?",
    "* section  3.3 ) .",
    "there , substitutions that yield symbolic constants in the scope of arithmetical operators do not form instances . in a similar way",
    ", we treat variables in conditional literals and aggregate literals ( sections  [ sem : cond ] and  [ sem : ag ] ) differently than how they are treated by @xcite . ] a literal or a rule is _ closed _ if it has no global variables .",
    "it is clear that any instance of a rule is closed .",
    "for example , @xmath218 is global in the rule @xmath219 from section  [ rp ] , so that the instances of @xmath219 are rules of the form @xmath220 for all precomputed terms @xmath221 .",
    "the variables @xmath218 and @xmath222 are global in @xmath223 ; instances of @xmath223 are @xmath224 for all precomputed terms @xmath221 and @xmath69 .",
    "if  @xmath141 is a term ,  @xmath225 is a tuple of distinct variables , and  @xmath226 is a tuple of terms of the same length as  @xmath225 , then the term obtained from  @xmath141 by substituting  @xmath226 for  @xmath225 will be denoted by @xmath227 .",
    "similar notation will be used for the result of substituting  @xmath226 for  @xmath225 in expressions of other kinds , such as literals and tuples of literals .",
    "the result of applying @xmath99 to a closed conditional literal @xmath61 is the conjunction of the formulas @xmath228 where @xmath225 is the list of variables occurring in  @xmath61 , over all tuples @xmath226 of precomputed terms of the same length as  @xmath229 .    for instance , the result of applying @xmath99 to the arithmetic literal @xmath230 , where  @xmath221 is a precomputed term , is @xmath231 , where @xmath232 is the tuple of length @xmath44 .",
    "the antecedent of this implication is @xmath111 .",
    "the consequent is  @xmath111 if @xmath221 is one of the numerals @xmath233 and @xmath15 otherwise .      in this section ,",
    "the semantics of ground aggregates proposed by ( * ? ? ?",
    "* section  4.1 ) is adapted to closed aggregate literals .",
    "let  @xmath234 be a closed aggregate atom of one of the forms ( [ ag1])([ag3 ] ) , and let  @xmath235 be the list of variables occurring in  @xmath236 .",
    "by  @xmath237 we denote the set of tuples  @xmath226 of precomputed terms of the same length as  @xmath235 . by @xmath55",
    "we denote the set @xmath238 .",
    "let @xmath239 be a subset of @xmath55 .",
    "then by @xmath240 $ ] we denote the union of the sets @xmath241 $ ] for all pairs @xmath242 .",
    "we say that @xmath239 _ justifies _",
    "@xmath234 if    * @xmath234 is of the form ( [ ag1 ] ) and the relation @xmath60 holds between @xmath243 $ ] and @xmath141 for at least one precomputed term @xmath244 $ ] , or * @xmath234 is of the form ( [ ag2 ] ) and the relation @xmath60 holds between @xmath141 and @xmath245 $ ] for at least one precomputed term @xmath244 $ ] , or * @xmath234 is of the form ( [ ag3 ] ) , the relation @xmath67 holds between @xmath25 and @xmath246 $ ] for at least one precomputed term @xmath247 $ ] , and the relation @xmath68 holds between @xmath248 $ ] and @xmath26 for at least one precomputed term @xmath249 $ ] .",
    "we define @xmath250 as the conjunction of the implications _ ( i , * r*)_((*l*_i)^*x*_i_*r * ) _",
    "( i,*r*)a_((*l*_i)^*x*_i _ * r * ) over all sets @xmath239 that do not justify  @xmath234 .",
    "for instance , if @xmath234 is @xmath251 then @xmath250 is the implication expressing that @xmath252 holds for at least one precomputed term @xmath221 : @xmath253    if @xmath177 is an aggregate literal of the form @xmath254 where @xmath234 is an aggregate atom then @xmath255 is @xmath256 ; if @xmath177 is of the form @xmath257 then @xmath258 is @xmath259 .",
    "for any rule  @xmath217 of form ( [ rule3 ] ) , @xmath260 stands for the set of the formulas @xmath261 for all instances  ( [ rule3 ] ) of  @xmath217 . for a rule of form ( [ rule4 ] ) , @xmath260 stands for the set of the formulas @xmath262 for all instances  ( [ rule4 ] ) of  @xmath217 .",
    "for any program  @xmath263 , @xmath264 stands for the union of the sets @xmath260 for all rules  @xmath217 of  @xmath263 .",
    "a _ stable model _ of a program  @xmath263 is any stable model of  @xmath265 ( in the sense of section  [ sem : inf ] ) that does not contain any pair of atoms of the form @xmath89 , @xmath100 .",
    "when we investigate the stable models of an ag program , it is often useful to simplify the formulas obtained by applying transformation  @xmath99 to its rules . by simplifying an infinitary propositional formula we mean turning it into a strongly equivalent formula that has simpler syntactic structure .",
    "the definition of strong equivalence , introduced by   @xcite , is extended to infinitary formulas by   @xcite .",
    "corollary  1 from that paper shows that the stable models of an infinitary formula are not affected by simplifying its parts .",
    "proofs of the theorems stated in this section are outlined in the electronic appendix .",
    "when a rule contains aggregate atoms , we can sometimes simplify the implications  ( [ agdef ] ) in the corresponding infinitary formula using the theorems on monotone and anti - monotone aggregates from ( * ? ? ?",
    "* section  6.1 ) .",
    "the monotonicity or non - monotonicity of an aggregate atom  ( [ ag1 ] ) can sometimes be established simply by looking at its aggregate name  @xmath36 and its relation symbol  @xmath60 .",
    "if  @xmath36 is one of the symbols _ count _ , _ sum+ _ , _ max _ , then  ( [ ag1 ] ) is monotone when  @xmath60 is @xmath266 or @xmath10 , and anti - monotone when  @xmath60 is @xmath267 or @xmath268 .",
    "it is the other way around if  @xmath36 is _",
    "min_.    our semantics of aggregates is somewhat different from that adopted by ( * ? ? ?",
    "* section  3.5 ) , as explained in footnote  [ ft3 ] ( and also in view of the difference in the treatment of variables discussed in footnote  [ ft2 ] ) . nevertheless",
    ", the statements and proofs of the two theorems mentioned above remain essentially the same in the framework of ag .",
    "the theorems show that the antecedent in ( [ agdef ] ) can be dropped if @xmath234 is monotone , and that the consequent can be replaced by  @xmath15 if @xmath234 is anti - monotone .",
    "these simplifications produce strongly equivalent formulas .",
    "if  @xmath60 in an aggregate atom  ( [ ag1 ] ) is @xmath269 then the following proposition can be useful , in combination with the facts reviewed in section  [ sec : mon ] :    [ lem : equality ] let @xmath234 be a closed aggregate atom of the form @xmath270 where @xmath69 is an interval - free term . if @xmath271 is @xmath272 and @xmath273 is @xmath274 then @xmath250 is strongly equivalent to @xmath275 .    without the assumption that  @xmath69 is interval - free",
    "the assertion of theorem  [ lem : equality ] would be incorrect : if @xmath234 is @xmath276 then @xmath250 is @xmath277 , but each of the formulas @xmath278 , @xmath279 is the empty conjunction  @xmath111 .      for any set @xmath280 , by @xmath281",
    "we denote the cardinality of @xmath280 if @xmath280 is finite , and @xmath282 otherwise .",
    "[ lem : geq ] for any closed aggregate atom  @xmath234 of the form @xmath283 where @xmath33 is an integer and each @xmath50 is interval - free , @xmath250 is strongly equivalent to _ a = m _ ( i,*r * ) _ ( ( * l*_i)^*x*_i_*r * ) .",
    "[ lem : leq ] for any closed aggregate atom @xmath234 of the form @xmath284 where @xmath33 is an integer and each @xmath50 is interval - free , @xmath250 is strongly equivalent to _ a = m+1 _ ( i , * r * ) _ ( ( * l*_i)^*x*_i_*r * ) .    without the assumption that each @xmath50 is interval - free the assertions of the theorems would be incorrect .",
    "for instance , if @xmath234 is @xmath285 then @xmath250 is @xmath286 , and ( [ trans_geq ] ) is  @xmath15 .    in the special ( but common ) case when @xmath234 has the form @xmath287 , where @xmath225 is a tuple of variables and each variable occurring in @xmath63 occurs also in @xmath225 , the condition @xmath288",
    "\\rvert = m$ ] in ( [ trans_geq ] ) can be replaced by @xmath289 . indeed , in this case @xmath239 and @xmath240 $ ] have the same cardinality because @xmath240 $ ] is the set of tuples @xmath226 of terms such that @xmath290 .",
    "similarly , the condition @xmath288 \\rvert = m+1 $ ] in ( [ trans_leq ] ) can be replaced by @xmath291 if @xmath234 has the form @xmath292 .",
    "we proposed a definition of stable models for programs in the language ag and stated a few theorems that facilitate reasoning about them .",
    "this definition can be viewed as a specification for the answer set system clingo ( see footnote  [ ft1 ] ) and other systems with the same input language . if such a system terminates given the ascii representation of an ag program  @xmath263 as input , and produces neither error messages nor warnings , then its output is expected to represent the stable models of  @xmath263 .",
    "we are grateful to the anonymous referees for useful comments .    ,",
    "faber , w. , gebser , m. , ianni , g. , kaminski , r. , krennwallner , t. , leone , n. , ricca , f. , and schaub , t. 2012 . : input language format .",
    "available at https://www.mat.unical.it/aspcomp2013/files/asp-core-2.0.pdf .          ,",
    "lifschitz , v. , pearce , d. , and valverde , a. 2015 .",
    "infinitary equilibrium logic and strong equivalence . in _ proceedings of international conference on logic programming and nonmonotonic reasoning ( lpnmr)_.",
    "; to appear .    , lifschitz , v. , and yang , f. 2014 .",
    "the semantics of gringo and infinitary propositional formulas . in _ proceedings of international conference on principles of knowledge representation and reasoning ( kr)_.        \\2012 .",
    "connecting first - order asp and the logic fo(id ) through reducts . in _",
    "correct reasoning : essays on logic - based ai in honor of vladimir lifschitz _ , e.  erdem , j.  lee , y.  lierler , and d.  pearce , eds .",
    "springer , 543559 ."
  ],
  "abstract_text": [
    "<S> this paper defines the syntax and semantics of the input language of the asp grounder gringo . </S>",
    "<S> the definition covers several constructs that were not discussed in earlier work on the semantics of that language , including intervals , pools , division of integers , aggregates with non - numeric values , and lparse - style aggregate expressions . </S>",
    "<S> the definition is abstract in the sense that it disregards some details related to representing programs by strings of ascii characters . </S>",
    "<S> it serves as a specification for gringo from version 4.5 on .    to appear in theory and practice of logic programming ( tplp ) , proceedings of iclp 2015 </S>"
  ]
}