{
  "article_text": [
    "since its introduction in a centralized context  @xcite , the minimum spanning tree ( or mst ) problem gained a benchmark status in distributed computing thanks to the seminal work of gallager , humblet and spira  @xcite .    the emergence of large scale and dynamic systems revives the study of scalable algorithms .",
    "scalable _ algorithm does not rely on any global parameter of the system ( e.g. upper bound on the number of nodes or the diameter ) .    in the context of dynamic systems , after a topology change a minimum spanning tree previously computed is not necessarily a minimum one ( e.g. , an edge with a weight lower than the existing edges can be added ) .",
    "a mechanism must be used to replace some edges from the constructed tree by edges of lower weight .",
    "park et al .",
    "@xcite proposed a distributed algorithm to maintain a mst in a dynamic network using the gallager , humblet and spira algorithm . in their approach , each node know its ancestors and the edges weight leading to the root in the tree .",
    "moreover , the common ancestor between two nodes in the tree can be identified . for each non - tree edge @xmath4 ,",
    "the tree is detected as not optimal by @xmath5 and @xmath6 if there exist a tree edge with a higher weight than @xmath7 between @xmath5 ( resp .",
    "@xmath6 ) and the common ancestor of @xmath5 and @xmath6 . in this case",
    ", the edge of maximum weight on this path is deleted .",
    "this yields to the creation of several sub - trees , from which a new mst can be constructed following the merging procedure given by gallager et al .",
    "flocchini et al .",
    "@xcite considered another point of view to address the same problem .",
    "the authors were interested to the problem of precomputing all the replacement minimum spanning trees when a node or an edge of the network fails .",
    "they proposed the first distributed algorithms to efficiently solve each of these problems ( i.e. , by considering either node or edge failure ) .",
    "additional techniques and algorithms related to the construction of light weight spanning structures are extensively detailed in  @xcite .",
    "large scale systems are often subject to transient faults . _ self - stabilization _ introduced first by dijkstra in  @xcite and later publicized by several books  @xcite deals with the ability of a system to recover from catastrophic situation ( i.e.",
    ", the global state may be arbitrarily far from a legal state ) without external ( e.g. human ) intervention in finite time .",
    "although there already exist self - stabilizing solutions for the mst construction , none of them considered the extension of the gallager , humblet and spira algorithm ( ghs ) to self - stabilizing settings . interestingly , this algorithm unifies the best properties for designing large scale msts : it is fast and totally decentralized and it does not rely on any global parameter of the system .",
    "our work proposes an extension of this algorithm to self - stabilizing settings .",
    "our extension uses only poly - logarithmic memory and preserves all the good characteristics of the original solution in terms of convergence time and scalability .",
    "antonoiu and srimani , and gupta and srimani presented in  @xcite the first self - stabilizing algorithm for the mst problem .",
    "the mst construction is based on the computation of all shortest paths ( for a certain cost function ) between all pairs of nodes . while executing the algorithm , every node stores the cost of all paths from it to all the other nodes . to implement this algorithm",
    ", the authors assume that every node knows the number @xmath8 of nodes in the network , and that the identifiers of the nodes are in @xmath9 .",
    "every node @xmath5 stores the weight of the edge @xmath4 placed in the mst for each node @xmath10",
    ". therefore the algorithm requires @xmath11 bits of memory at node @xmath5 .",
    "since all the weights are distinct integers , the memory requirement at each node is @xmath12 bits .",
    "the main drawback of this solution is its lack of scalability since each node has to know and maintain information for all the nodes in the system .",
    "note that the authors introduce a time complexity definition related to the transmission of beacon in the context of ad - hoc networks . in a round ,",
    "each node receives a beacon from all its neighbors .",
    "so , the @xmath13 time complexity announced by the authors stays only in the particular synchronous settings . in asynchronous",
    "setting , a node is activated at the reception of a beacon from each neighbor leading to a @xmath1 time complexity .",
    "a different approach for the message - passing model was proposed by higham and liang  @xcite .",
    "the algorithm works roughly as follows : every edge checks whether it should belong to the mst or not . to this end , every non tree - edge @xmath14 floods the network to find a potential cycle , and when @xmath14 receives its own message back along a cycle , it uses the information collected by this message ( i.e , the maximum edge weight of the traversed cycle ) to decide whether @xmath14 could potentially be in the mst or not .",
    "if the edge @xmath14 has not received its message back after the time - out interval , it decides to become tree edge .",
    "the memory used by each node is @xmath3 bits , but the information exchanged between neighboring nodes is of size @xmath15 bits , thus only slightly improving that of @xcite .",
    "this solution also assumes that each node has access to a global parameter of the system : the diameter .",
    "its computation is expensive in large scale systems and becomes even harder in dynamic settings .",
    "the time complexity of this approach is @xmath16 rounds where @xmath17 and @xmath18 are the number of edges and the upper bound of the diameter of the network respectively , i.e. , @xmath19 rounds in the worst case . + in @xcite we proposed a self - stabilizing loop - free algorithm for the mst problem .",
    "contrary to previous self - stabilizing mst protocols , this algorithm does not make any assumption on the network size ( including upper bounds ) or the uniqueness of the edge weights .",
    "the proposed solution improves on the memory space usage since each participant needs only @xmath3 bits while preserving the same time complexity as the algorithm in @xcite .",
    "clearly , in the self - stabilizing implementation of the mst algorithms there is a trade - off between the memory complexity and their time complexity ( see table [ tableresume ] ) .",
    "the challenge we address in this paper is to design fast and scalable self - stabilizing mst with little memory .",
    "our approach brings together two worlds : the time efficient mst constructions and the memory compact informative labeling schemes .",
    "we do this by extending the ghs algorithm to the self - stabilizing setting while keeping it memory space compact , but using a self - stabilizing extension of the nearest common ancestor labeling scheme  @xcite .",
    "note that labeling schemes have already been used in order to maintain compact information linked with vertex adjacency , distance , tree ancestry or tree routing  @xcite , however none of these schemes have been studied in self - stabilizing settings ( except for the tree routing ) .",
    "our contribution is therefore twofold .",
    "we propose for the first time in self - stabilizing settings a @xmath0 bits scheme for computing the nearest common ancestor .",
    "furthermore , based on this scheme , we describe a new self - stabilizing algorithm for the mst problem .",
    "our algorithm does not make any assumption on the network size ( including upper bounds ) or the existence of an a priori known root .",
    "the convergence time is @xmath1 asynchronous rounds and the memory space per node is @xmath20 bits .",
    "interestingly , our work is the first to prove the effectiveness of an informative labeling scheme in self - stabilizing settings and therefore opens a wide research path in this direction .",
    "the description of our algorithm is _ explicit _ , in the sense that we describe all procedures using the formal framework @xmath21    the recent paper @xcite announces an improvement of our results , by sketching the _ implicit _ description of a self - stabilizing algorithm for mst converging in @xmath13 rounds , with a memory of @xmath3 bits per node .",
    "this algorithm is also based on an informative labeling scheme .",
    "the approach proposed by korman et al .",
    "@xcite is based on the composition of many sub - algorithms ( some of them not stabilizing ) presented in the paper as black boxes and the composition of all these modules was not proved formally correct in self - stabilizing settings up to date .",
    "the main feature of our solution in comparison with  @xcite is its straightforward implementation .",
    "we consider an undirected weighted connected network @xmath22 where @xmath23 is the set of nodes , @xmath24 is the set of edges and @xmath25 is a positive cost function .",
    "nodes represent processors and edges represent bidirectional communication links .",
    "the processors asynchronously execute their programs consisting of a set of variables and a finite set of rules .",
    "we consider the local shared memory model of computation bits per node by considering also the local copies of neighbors variables , with @xmath26 the maximum degree of a node in the network . ] .",
    "the variables are part of the shared register which is used to communicate with the neighbors",
    ". a processor can read and write its own registers and can read the shared registers of its neighbors .",
    "each processor executes a program consisting of a sequence of guarded rules .",
    "each _ rule _ contains a _ guard _ ( boolean expression over the variables of a node and its neighborhood ) and an _ action _ ( update of the node variables only ) .",
    "any rule whose guard is _ true _ is said to be _",
    "enabled_. a node with one or more enabled rules",
    "is said to be _ enabled _ and may execute the action corresponding to the chosen enabled rule .",
    "a _ local state _ of a node is the value of the local variables of the node and the state of its program counter .",
    "configuration _ of the system @xmath27 is the cross product of the local states of all nodes in the system .",
    "the transition from a configuration to the next one is produced by the execution of an action at a node .",
    "computation _ of the system is defined as a _ weakly fair , maximal _ sequence of configurations , @xmath28 , where each configuration @xmath29 follows from @xmath30 by the execution of a single action of at least one node . during an execution step ,",
    "one or more processors execute an action and a processor may take at most one action . _ weak fairness _ of the sequence means that if any action in @xmath31 is continuously enabled along the sequence , it is eventually chosen for execution .",
    "_ maximality _ means that the sequence is either infinite , or it is finite and no action of @xmath31 is enabled in the final global state . in this context , a _ round _ is the smallest portion of an execution where every process has the opportunity to execute at least one action . in the sequel we consider the system can start in any configuration .",
    "that is , the local state of a node can be corrupted .",
    "we do nt make any assumption on the number of corrupted nodes . in the worst case all the nodes in the system may start in a corrupted configuration . in order to tackle these faults we use self - stabilization techniques .",
    "the definition hardly uses the legitimate predicate .",
    "a legitimate predicate is defined over the configurations of a system and describes the set of correct configurations .",
    "let @xmath32 be a non - empty _ legitimate predicate _ of an algorithm @xmath33 with respect to a specification predicate @xmath34 such that every configuration satisfying @xmath32 satisfies @xmath34 .",
    "algorithm @xmath33 is _ self - stabilizing _ with respect to @xmath34 iff the following two conditions hold : + every computation of @xmath33 starting from a configuration satisfying @xmath35 preserves @xmath35 and verifies @xmath34 ( _ closure _ ) . +",
    "every computation of @xmath33 starting from an arbitrary configuration contains a configuration that satisfies @xmath35 ( _ convergence _ ) .    to compute the time complexity",
    ", we use the definition of _ round _",
    "given a computation @xmath14 ( @xmath36 ) , the _ first round _ of @xmath14 ( let us call it @xmath37 ) is the minimal prefix of @xmath14 containing the execution of one action ( an action of the protocol or a disabling action ) of every enabled processor from the initial configuration .",
    "let @xmath38 be the suffix of @xmath14 such that @xmath39 .",
    "the _ second round _ of @xmath14 is the first round of @xmath38 .",
    "we propose to extend the gallager , humblet and spira ( ghs ) algorithm  @xcite , to self - stabilizing settings via a compact informative labeling scheme .",
    "thus , the resulting solution presents several advantages appealing to large scale systems : it is compact since it uses only memory whose size is poly - logarithmic in the size of the network , it scales well since it does not rely on any global parameter of the system .    the notion of a _",
    "fragment _ is central to the ghs approach .",
    "a fragment is a sub - tree of the graph , i.e. , a fragment is a tree which spans a subset of nodes .",
    "note that a fragment can be limited to a single node .",
    "an outgoing edge of a fragment @xmath40 is an edge with a single endpoint in @xmath40 .",
    "the minimum - weight outgoing edge of a fragment @xmath40 is an outgoing edge of @xmath40 with minimum weight among outgoing edges of @xmath40 , denoted in the following as @xmath41 . in the ghs construction , initially each node is a fragment . for each fragment @xmath40 , the ghs algorithm in  @xcite identifies the @xmath41 and merges the two fragments endpoints of @xmath41 .",
    "it is important to mention that with this scheme , more than two fragments may be merged concurrently .",
    "the merging process is repeated in a iterative fashion until a single fragment remains .",
    "the result is a mst .",
    "the above approach is often called _ blue rule _ for mst construction  @xcite .",
    "this approach is particularly appealing when transient faults create a forest of fragments ( which are sub - trees of a mst ) .",
    "the direct application of the blue rule allows the system to reconstruct a mst and to recover from faults which have divided the existing mst .",
    "however , when more severe faults hit the system the process states may be corrupted leading to a configuration of the network where the set of fragments are not sub - trees of some mst .",
    "this may include , a spanning tree but not a mst or spanning structure containing cycles .",
    "in these different types of spanning structures , the application of the _ blue rule _ is not always sufficient to reconstruct a mst . to overcome this difficulty",
    ", we combine the _ blue rule _ with another method , referred in the literature as the _ red rule _",
    "the _ red rule _ considers all the possible cycles in a graph , and removes the heaviest edge from every cycle , the resulting is a mst . to maintain a mst regardless of the starting configuration , we use the _ red rule _ as follows .",
    "let @xmath42 denote a spanning tree of graph @xmath31 , and @xmath14 an edge in @xmath31 but not in @xmath42 .",
    "clearly , if @xmath14 is added to @xmath42 , this creates a ( unique ) cycle composed by @xmath14 and some edges of @xmath42 .",
    "this cycle is called a _ fundamental cycle _ , and denoted by @xmath43 . according to the _ red rule _",
    ", if @xmath14 is not the edge of maximum weight in @xmath43 , then there exists an edge @xmath44 in @xmath43 , @xmath45 such that @xmath46 . in this case , @xmath47 can be removed since it is not part of any mst .",
    "our solution , called in the following algorithm , combines both the _ blue rule _ and _ red rule_. the application of the _ blue rule _ needs that each node identifies the fragment it belongs to .",
    "the _ red rule _ also requires that each node can identify the fundamental cycle associated to each of its adjacent non - tree - edges .",
    "note that a simple scheme broadcasting the root identifier in each fragment ( of memory size @xmath3 bits per node ) can be used to identify the fragments , but this can not allow to identify fundamental cycles . in order to identify fragments or fundamental cycles",
    ", we use a self - stabilizing labeling scheme , called @xmath48 .",
    "this scheme provides at each node a distinct label . for two nodes @xmath5 and @xmath6 in the same fragment , the comparison of their labels provides to these two nodes their * nearest common ancestor * in a tree ( see section  [ sec : label ] ) .",
    "thus , the advantage of this labeling is twofold .",
    "first the labeling scheme helps each node to identify the fragment it belongs to .",
    "second , given any non - tree edge @xmath49 , the path in the tree going from @xmath5 to the nearest common ancestor of @xmath5 and @xmath6 , then from there to @xmath6 , and finally back to @xmath5 by traversing @xmath14 , constitute the fundamental cycle @xmath43 .    to summarize , algorithm will use the _ blue rule _ to build a spanning tree , and the _ red rule _ to recover from invalid configurations . in both cases , it uses our algorithm to identify both fragments and fundamental cycles .",
    "note that , in  @xcite distributed algorithms using the _ blue _ and _ red rules _ to construct a mst in a dynamic network are proposed , however these algorithms are not self - stabilizing .",
    "in this section we fix some general assumptions used in the current paper .",
    "let @xmath22 be an undirected weighted graph , where @xmath23 is the set of nodes , @xmath24 is the set of edges and the weight of each edge is given by a positive cost function @xmath25 .",
    "we consider w.l.o.g . that the edges weight are polynomial in @xmath50 .",
    "moreover , the nodes are allowed to have unique identifiers denoted by @xmath51 encoded using @xmath3 bits where @xmath52 .",
    "no assumption is made about the fact that edges weight must be distinct . in the current paper @xmath53",
    "denotes the set of all neighbors of @xmath6 in @xmath31 , for any node @xmath54 .",
    "each node @xmath6 maintains several information a pointer to one of its neighbor node called _ the parent_. the set of these pointers induces a spanning tree if the spanning structure is composed with all the nodes and contains no cycle .",
    "we denote by @xmath55 the path from @xmath5 to @xmath6 in the tree . for handling the nearest common ancestor labeling scheme we will define some notations .",
    "let @xmath56 be the label of a node @xmath6 composed by a list of pairs of integers , where each pair is an identifier and a distance .",
    "$ ] denotes the @xmath58th pair of the list , and for every pair @xmath58 the first element is denoted by @xmath57[0]$ ] and the second one by @xmath57[1]$ ] .",
    "the last pair of the list is denoted by @xmath59 .",
    "previously , we explained that our algorithm needs to identify fragments , internal and outgoing edges of each fragment and the presence of cycles . to achieve this identification",
    "we use a nearest common ancestor labeling scheme .",
    "this section is dedicated to the presentation of a self - stabilizing version of the distributed algorithm proposed by peleg  @xcite .",
    "the self - stabilizing algorithm is called in the following .",
    "algorithm can be used to solve other tasks than constructing a mst , hence we present this part in a separate section .    in  @xcite",
    ", peleg gives a nearest common ancestor labeling scheme for a tree structure with a memory complexity of @xmath60 bits .",
    "we will first give in this section a self - stabilizing version of this scheme , that is the encoder and decoder part related to the labeling scheme , and finally we prove the correctness and the complexity of our self - stabilizing algorithm .",
    "for simplicity , we assume in this current section that all the nodes of the network belong to a single tree .",
    "it is easy to see that without a tree structure , the nodes can not have a common ancestor .",
    "therefore , in the next section we have to deal with the general case in which cycles can be contained in the starting configuration .      before presenting the nearest common ancestor labeling scheme",
    ", we describe below the variables used by the labeling scheme .",
    "each node @xmath61 maintains three variables :    * a parent pointer to a neighbor of @xmath6 stored in @xmath62 defining the spanning tree .",
    "* @xmath63 is a pair of integers , whose the first element is an estimation of the number of nodes in the sub - tree of @xmath6 and the second one is the identifier of the child of @xmath6 with the subtree of highest size . if @xmath6 has no child then @xmath63 is equal to @xmath64 .",
    "note that , the first integer of the pair is referenced by @xmath65 $ ] , while the second integer by @xmath66 $ ] . *",
    "the label of @xmath6 ( composed of a list of pairs of integers where each pair is an identifier and a distance ( described below ) ) is stored in variable @xmath56 .",
    "we will now present the manner the nearest common ancestor scheme computes the label of each node in a spanning tree .",
    "the main idea of this protocol is to divide a tree structure in sub - paths to minimize the label size of each node .",
    "let us describe more precisely our self - stabilizing version of this protocol .",
    "in a rooted tree , a _ heavy _ edge is an edge between a node @xmath5 and one of its children @xmath6 with the highest number of nodes in its sub - tree .",
    "the other edges between @xmath5 and its other children are tagged as _ light _ edges .",
    "we extend this edge designation to the nodes , a node @xmath6 is called _ heavy node _ if the edge between @xmath6 and its parent is a heavy edge ( see predicate @xmath67 in figure  [ fig : predicates1 ] ) , otherwise @xmath6 is called _ light node _",
    "( see predicate @xmath68 in figure  [ fig : predicates1 ] ) .",
    "moreover , the root of a tree is a heavy node .",
    "the idea of the scheme is as follows .",
    "a tree is recursively divided into paths of disjoint edges : _ heavy _ and _ light _ paths .",
    "remark : any child of highest number of nodes can be selected as heavy node , so among these children the one of highest identifier can be selected .    to label the nodes in a tree @xmath69 ,",
    "the size of each subtree rooted at each node of @xmath69 is needed to identify heavy edges leading the heaviest subtrees at each level of @xmath69 . to this end , each node @xmath6 maintains a variable named @xmath63 which is a pair of integers .",
    "the first integer is the local estimation of the number of nodes in the subtree rooted at @xmath6 . for a node @xmath6 this value",
    "is computed by summing up all the estimated values of its children plus one .",
    "the value of @xmath63 is processed in a bottom - up fashion from the leaves to the root of the tree ( see predicate @xmath70 in figure  [ fig : predicates1 ] and rule @xmath71 ) .",
    "the second integer is the identifier of a child of @xmath6 with maximum number of nodes in its sub - tree , which indicates the heavy edge .",
    "we suppose w.l.o.g that , in case of equality between the size of the children s subtrees the child with the minimum identity is chosen .",
    "the variable @xmath63 is setted to @xmath64 for a leaf node @xmath6 ( see predicate @xmath72 in figure  [ fig : predicates1 ] ) .    based on the heavy and light nodes in a tree @xmath69 indicated by variable @xmath63 at each node @xmath73",
    ", each node of @xmath69 can compute its label ( see rule @xmath74 in figure  [ fig : algo_lab ] ) .",
    "the label of a node @xmath6 stored in @xmath56 is a list of pair of integers .",
    "each pair of the list contains the identifier of the node which is the root of the heavy path ( i.e. , a path including only heavy edges ) that @xmath6 belongs to and the distance to it . for the root @xmath6 of a fragment ,",
    "the label @xmath56 is the following pair @xmath75 , respectively the identifier of @xmath6 and the distance to itself , i.e. , zero ( see predicate @xmath76 in figure  [ fig : predicates1 ] ) . when a node @xmath5 is tagged by its parent as a heavy node ( i.e. , @xmath77={\\mbox{\\sf id}}_u$ ] ) , then the node @xmath5 takes the label of its parent but it increases by one the distance of the last pair of the parent label ( see predicate @xmath78 in figure  [ fig : predicates1 ] ) . + otherwise , a node @xmath5 is tagged by its parent @xmath6 as a light node ( i.e. , @xmath77 \\neq { \\mbox{\\sf id}}_u$ ] ) , then the node @xmath5 becomes the root of a heavy path and it takes the following label : the label of its parent to which @xmath5 concatenates to a new pair composed by its identifier and a zero distance ( we note the step of concatenation by the operator `` . '' ) . + examples of theses cases are given in figure  [ fig : label ] , where integers inside the nodes are node identifiers and lists of pairs of values are node labels",
    ".     corresponds to the label of @xmath6 .",
    "the integer inside each node corresponds to the node s identifier , while the other notation corresponds to the variable @xmath79 . ]",
    "algorithm is composed by the rules @xmath71 and @xmath74 given in figure  [ fig : algo_lab ] which correct the variables and respectively if needed .",
    "let us now describe the decoder for the nearest common ancestor .",
    "this decoder is given in  @xcite , but for simplicity we present it using our own notations ( see predicate @xmath80 in figure  [ fig : nca ] ) .",
    "let us consider two nodes @xmath5 and @xmath6 , we denote by @xmath81 the label of the nearest common ancestor of @xmath5 and @xmath6 . for the remainder of this paper , we define the following notations : @xmath82 and @xmath83 .",
    "the nearest common ancestor of @xmath5 and @xmath6 is composed by the common part of the label of @xmath5 and @xmath6 ( @xmath84 ) and by the smaller pair following the lexicographic order of the last pair of their labels ( i.e. , minimum between @xmath85 $ ] and @xmath86 $ ] ) . in the other case @xmath5 and @xmath6 have not common ancestor .    on the example defined on figure  [ fig : label ] , the labels of nodes @xmath87 and @xmath88 are respectively @xmath89 and @xmath90 . in this case , we have for the defined notations on labels : @xmath91 , @xmath92 and @xmath93 . since we have @xmath94[1]<{\\mbox{\\rm $ \\ell$}}'_{10,9}[0][1]$ ] then on this example @xmath95 .",
    "this subsection is dedicated to the correctness of the self - stabilizing nearest common ancestor labeling scheme .",
    "let @xmath96 be the set of all possible configurations of the system .",
    "in order to prove the correctness of the @xmath97 algorithm , we denote @xmath98 the set of configurations in @xmath96 such that variables @xmath79 are correct in the system .",
    "more precisely , we define the following function @xmath99 : @xmath100 be the function defined by @xmath101 - 1)-\\mathlarger{\\sum}_{\\mathsmaller{u\\in \\mathcal{c}(v ) } } { \\mbox{\\it size}}_u[0]\\big)|.\\ ] ] note that @xmath102 , and the variable @xmath79 has a correct value at node @xmath6 if and only if @xmath103 . in the following ,",
    "we show that any execution of the system converges to a configuration in @xmath98 , and the set of configurations @xmath98 is closed .",
    "the following lemma establishes the former property .",
    "we assume that all the nodes of the system belongs to the tree @xmath42 and we define below a legitimate configuration for the informative labeling scheme considered in this section .",
    "a configuration @xmath104 is called legitimate if the following conditions are satisfied :    1 .",
    "the root node @xmath105 of the tree @xmath42 has label equal to @xmath106 , 2 .",
    "every _ heavy _",
    "node @xmath107 has a label equal to @xmath108 , { \\mbox{\\rm $ \\ell$}}^{-1}_{{\\mbox{\\it p}}_v}[1]+1)$ ] , 3 .   every _ light _",
    "node @xmath107 has a label equal to @xmath109 .",
    "starting from an arbitrary configuration @xmath110 , the system reaches a configuration in @xmath111 in @xmath112 rounds , where @xmath113 is the depth of the tree @xmath42 .",
    "[ lem : size_convergence ]    first , we define the following potential function @xmath114 .",
    "we denote by  @xmath113 the depth of the tree @xmath42 , i.e. , the length of the longest path from the root to the leaves .",
    "let @xmath110 be a configuration , and let @xmath96 be the set of all configurations .",
    "let @xmath115 be the function defined by @xmath116 where @xmath117 is the number of nodes @xmath6 at depth @xmath118 in @xmath42 with @xmath119 .",
    "note that @xmath120 , and @xmath121 . also , the variable @xmath79 has a correct value at every node if and only if @xmath122 .",
    "let @xmath123 denotes the configuration of the system after round @xmath124 .",
    "let @xmath125 be the largest index such that @xmath126 .",
    "since we use a weakly fair scheduler , all the nodes are scheduled during the execution of round @xmath127 .",
    "every node @xmath6 at depth @xmath128 does not change its value of variable @xmath79 ( see the predicate @xmath129 ) , and therefore @xmath130 remains zero , so @xmath131 remains zero as well .",
    "the nodes at depth @xmath125 change their variable @xmath79 according to the variable @xmath79 of their children .",
    "let @xmath6 be a node at depth @xmath125 .",
    "the children of @xmath6 ( if any ) are at depth @xmath128 .",
    "thus , their variable @xmath79 has not changed , and therefore @xmath130 becomes zero after round @xmath127 . as a consequence , @xmath132 .",
    "therefore , we get @xmath133 and thus the system will eventually reach a configuration in @xmath98 . to measure",
    "the number of rounds it takes to get into @xmath134 , observe that @xmath113 decreases by at least one at each round.starting from any arbitrary configuration , the system reaches a configuration in @xmath98 in @xmath112 rounds .",
    "starting from a configuration in @xmath98 the system can only reach configurations in @xmath98 .",
    "[ lem : size_closure ]    according to algorithm @xmath48 , the variable @xmath79 is modified only by rule @xmath71 .",
    "consider a configuration @xmath135 such that variables @xmath79 are correct .",
    "for each node @xmath6 , we have @xmath103 and predicate @xmath70 is true .",
    "thus , rule @xmath71 can not be executed by a node @xmath6 and we have @xmath103 which implied that @xmath136 .",
    "therefore , for any execution starting from a configuration @xmath135 , the system remains in a configuration in @xmath98 .",
    "[ lem : label_convergence ] starting from an illegitimate configuration , algorithm reaches in @xmath112 rounds a legitimate configuration , where @xmath113 is the depth of the tree @xmath42 .",
    "let us introduce some notations that we will use throughout in the proof .",
    "let be the pairs list of the node s label @xmath6 such that the last pair is removed , and @xmath137 the number of pairs in the label of @xmath6 .",
    "for two labels @xmath56 and @xmath138 the step @xmath139 is defined by : @xmath140[0]-{\\mbox{\\rm $ \\ell$}}_u[i][0]| + |{\\mbox{\\rm $ \\ell$}}_v[i][1]-{\\mbox{\\rm $ \\ell$}}_u[i][1]|.\\ ] ]    we first define a first function @xmath141 on the state of each node @xmath61 as following :    @xmath142-{\\mbox{\\rm $ \\ell$}}^{-1}_{{\\mbox{\\it p}}_v}[0]| + |{\\mbox{\\rm $ \\ell$}}^{-1}_v[1]-{\\mbox{\\rm $ \\ell$}}^{-1}_{{\\mbox{\\it p}}_v}[1]-1| & \\mbox{if } { \\mbox{\\it size}}_{{\\mbox{\\it p}}_v}[1]={\\mbox{\\sf id}}_v\\\\ s(v)+||{\\mbox{\\rm $ \\ell$}}_v|-|{\\mbox{\\rm $ \\ell$}}_{{\\mbox{\\it p}}_v}|-1|+(\\bar { \\mbox{\\rm $ \\ell$}}_v\\circleddash{\\mbox{\\rm $ \\ell$}}_{{\\mbox{\\it p}}_v})+({\\mbox{\\rm $ \\ell$}}^{-1}_v\\circleddash({\\mbox{\\sf",
    "id}}_v,0 ) ) & \\mbox{otherwise } \\end{array } \\right.\\ ] ]    note that @xmath143 and when @xmath144 the variable @xmath145 has a correct value for a node @xmath6 .",
    "let @xmath146 : @xmath147 be the function defined by , @xmath148 where @xmath149 is the number of nodes @xmath6 at depth @xmath118 in @xmath42 with @xmath150 .",
    "remark that @xmath151 , and @xmath152 . also , the variable @xmath145 has a correct value at every node if and only if @xmath153 .",
    "let @xmath123 denote the configuration of the system after round @xmath124 , and suppose that @xmath154 . by lemma  [ lem : size_convergence ] and lemma  [ lem : size_closure ]",
    "we prove that @xmath155 .",
    "it is important to mention that , in @xmath123 all node @xmath6 can check if it is a heavy node or light node ( see variable @xmath79 ) .",
    "let @xmath125 be the smallest index such that @xmath156 .",
    "since we use a weakly fair scheduler , all the nodes are scheduled during the execution of round @xmath127 .",
    "every node @xmath6 at depth @xmath157 does not change its value of variable @xmath145 ( see the predicate @xmath158 ) , and therefore @xmath141 remains zero , so @xmath159 remains zero as well .",
    "the nodes at depth @xmath125 change their variable @xmath145 according to the variables @xmath145 and @xmath160 $ ] of their parent ( see rule @xmath74 ) .",
    "let @xmath6 be a node at depth @xmath125 .",
    "the parent of @xmath6 is at depth @xmath157 .",
    "thus , its variable @xmath145 have not changed , and therefore @xmath141 becomes zero after round @xmath127 . as a consequence , @xmath161 .",
    "therefore , we get @xmath162 and thus the system will eventually reach a legitimate configuration for algorithm @xmath48 . to measure",
    "the number of rounds it takes to get into a legitimate configuration for algorithm @xmath48 , observe that @xmath163 decreases by at least one at each round .",
    "since @xmath164 for every @xmath165 , we get that , starting from any configuration in @xmath98 configuration , the system reaches a legitimate configuration for algorithm @xmath48 in @xmath112 rounds . using lemma  [ lem : size_convergence ] and lemma  [",
    "lem : size_closure ] , we can conclude starting from any arbitrary configuration , the system reaches a legitimate configuration for algorithm @xmath48 in @xmath112 rounds .",
    "[ lem : label_closure ] the set of legitimate configurations for is closed .",
    "that is , starting from any legitimate configuration , the system remains in a legitimate configuration .    according to algorithm @xmath48 ,",
    "the labeling procedure is done using only rule @xmath74 .",
    "let @xmath166 a legitimate configuration .",
    "for each node @xmath6 in @xmath166 , we have @xmath122 and @xmath153 .",
    "moreover in @xmath166 , predicates @xmath70 and @xmath167 are true and rules @xmath74 and @xmath71 can not be executed by any node @xmath61 . in conclusion ,",
    "starting from a legitimate configuration for algorithm @xmath48 the system remains in a legitimate configuration .",
    "the following theorem is a direct consequence from lemmas  [ lem : label_convergence ] and [ lem : label_closure ] .",
    "[ thm : self - stab_lab ] algorithm @xmath48 is self - stabilizing for the informative nearest common ancestor labeling scheme .",
    "]    in this section we describe our self - stabilizing algorithm for constructing the minimum spanning tree , called algorithm .",
    "our algorithm uses the  blue rule \" to construct a spanning tree and the  red rule \" to recover from invalid configurations ( see section [ sec : over ] ) . in both cases , it uses algorithm to identify fragments and fundamental cycles .",
    "we assume in the following that the _ merging _ phases have a higher priority than the _ recovering _ phases .",
    "that is , the system recovers from an invalid configuration if and only if no merging is possible .",
    "unfortunately , due to arbitrary initial configuration , the structure induced by the parent pointer of all nodes may contain cycles .",
    "we use first a well known approach to break cycles before giving a detailed description of merging and recovering phases .",
    "figure  [ fig : schemarules ] illustrates the different phases of algorithm @xmath168 . starting from an arbitrary configuration , first all the cycles",
    "are destroyed then fragments are defined and correctly labeled using the parent pointers . based on the label of nodes , the minimum _ outgoing edge _",
    "( i.e. , edge whose extremities belong to different fragments ) of each fragment is computed in a bottom - up fashion , and allowing to a pair of fragments which have selected the same outgoing edge to be merged together through this edge . a _ merging step _",
    "gives a new fragment which is the result of the merging of a pair of fragments .",
    "when a new fragment is created , the nodes of this fragment have to compute their new label .",
    "this process is repeated until there is only one remaining fragment spanning all the nodes of the network . in this case",
    ", the recovering phase can begin by detecting that no outgoing edge can be selected . to handle this phase",
    "each fragment has to compute its _ internal edges _ ( i.e. , edges whose extremities belong to the same fragment ) and to identify the _ nearest common ancestor _",
    "based on the labels of the edge extremities .",
    "the weight of the internal edges are broadcasted up in the tree from the leaves to the root .",
    "let @xmath49 an internal edge of tree @xmath42 , due to the  red rule \" if an edge @xmath47 of the path @xmath169 in @xmath42 has a weight bigger than @xmath14 , then @xmath14 is an _ valid edge _ since @xmath14 is part of an @xmath170 ( by `` red rule '' ) .",
    "more precisely , if during the bottom - up transmission of the weight of @xmath14 , a node @xmath5 has a parent link edge @xmath47 such that @xmath46 then @xmath47 is deleted from the tree @xmath42 and @xmath5 becomes the root of a new fragment .",
    "we present first the variables used by algorithm @xmath168 , then we describe the approach used to delete the cycles , followed by the merging and recovering phases .",
    "finally , we show the correctness and the time and memory complexities of the algorithm .",
    "we list below the eight variables maintained at each node @xmath61 :    * the three variables described in section  [ sec : label ] are used , i.e. , variables @xmath171 and @xmath56 . *",
    "the distance of each node @xmath6 from the root of the fragment is stored in variable @xmath172 .",
    "* for handling the _ blue rule _ mentioned in section  [ sec : over ] , the minimum outgoing edge of each fragment is stored in variable @xmath173 .",
    "this edge is composed of three elements : the edge weight , and the identifiers of the edge extremities . the @xmath58-th element of @xmath173 is accessed by @xmath174 $ ] with @xmath175 . * finally to broadcast the internal edges in the recovering phase , a last variable @xmath176 stores three elements related to an internal edge : the edge weight , and the labels of the edge extremities . as for variable @xmath173 ,",
    "the @xmath58-th element of @xmath176 is accessed by @xmath177 $ ] with @xmath175 .",
    "the previous section was dedicated to the labeling procedure for an unique tree , due to the arbitrary starting configuration , the network can contain a forest of subtrees ( several fragments ) and cycles .",
    "therefore , the labeling procedure described in previous section ( using rules @xmath71 and @xmath74 ) is executed separately in each subtree in algorithm @xmath168 .",
    "however , to apply this procedure it is crucial to detect the cycles in the fragments induced by the parent pointers . to this end",
    ", we use a common approach used to break cycles in a spanning structure  @xcite .",
    "each node computes its distance ( in hops ) to the root by using the distance of its parent plus one . by following this procedure ,",
    "there is at least a node which has a distance higher or equal than the distance of its parent in the fragment .",
    "therefore , this condition is used at each node to detect a cycle . in this case , a node @xmath6 deletes its parent pointer by selecting no parent and a new fragment rooted at @xmath6 is created .",
    "unfortunately , due to the arbitrary initial configuration a cycle can be falsely detected because of erroneous distances values at @xmath6 and its parent .",
    "this mechanism based on distances ensures that after @xmath13 rounds the network is cycle free .",
    "the destruction of cycles is managed by rule @xmath178 .    when all the cycles have been deleted , the labeling procedure is applied in algorithm @xmath168 .",
    "note that the cycle detection must have a higher priority over the labeling procedure . to this",
    "end , rule @xmath178 is the first rule to execute and in exclusion with rules @xmath71 and @xmath74 in algorithm @xmath168 .",
    "furthermore , the labeling scheme must also have a higher priority over the merging and recovering phases .",
    "indeed , the label of the nodes are used to identify the internal and outgoing edges of a fragment ( see figure  [ fig : fusion ] ) . to guarantee the execution priority",
    ", the rules of the labeling scheme can only be executed when predicate @xmath179 is satisfied at node @xmath6 .",
    "in the same way , the rules of merging and recovering phases can only be executed at a node @xmath6 when predicate @xmath180 is satisfied at @xmath6 .    * if * @xmath181 * then * + @xmath182 + * if * @xmath183 * then * @xmath184 + * if * @xmath185 * then * @xmath186 + * if * @xmath187 * then * @xmath188    we give below the rules associated with the labeling encoder ( given in the previous section ) . in order to use these two rules for the mst construction , we add predicate @xmath189 in the guards .",
    "this allow to disable these rules when a cycle is detected with rule @xmath178 .    * if * @xmath190 * then * + * if * @xmath191 * then * @xmath192 + * else * @xmath193    * if * @xmath194 * then * + * if * @xmath77={\\mbox{\\sf id}}_v$ ] @xmath195:={\\mbox{\\rm $ \\ell$}}^{-1}_v[1]+1;$ ] + * else * @xmath196      when the graph induced by the parent pointers is cycle free and every node @xmath6 of a fragment @xmath40 has a correct label ( see predicate @xmath180 ) , then every node @xmath197 is able to determine if @xmath40 spans all the nodes of the network or not",
    ". this knowledge is given by the label of the nodes , more precisely using the decoder given in subsection  [ subsec : decoder ] .",
    "indeed , given a non - tree edge @xmath49 , if the nodes @xmath5 and @xmath6 have no common ancestor then @xmath5 and @xmath6 are in two distinct fragments .",
    "in this case , the merging phase can be executed at @xmath5 and @xmath6 . a merging phase is composed of several _ merging steps _ in which at least two fragments are merged .",
    "each merging step is performed following four steps :    1 .",
    "the root of each fragment @xmath40 identifies the minimum - weight outgoing edge @xmath198 of its fragment ( see rule @xmath199 ) .",
    "2 .   after the computation of @xmath14 each node @xmath200 on the path between the root of @xmath40 and @xmath197 computes in variable",
    "@xmath201 its future parent ( see rule @xmath202 ) . the nodes in the sub - tree rooted at every node @xmath200 executes also rule @xmath202 .",
    "3 .   when the two merging fragments have finished the two first steps , then each node of these two fragments can compute their future distance ( see rule @xmath203 ) .",
    "4 .   finally , every node @xmath6 belonging to these two fragments copies the content of its variables @xmath204 ( resp .",
    "@xmath205 ) into variable @xmath62 ( resp .",
    "@xmath172 ) .    let us proceed with a more detailed description of the these steps .",
    "we process the computation of the minimum - weight outgoing edge of each fragment in a bottom - up manner ( see rule @xmath199 ) .",
    "each node @xmath6 can identify its adjacent outgoing edges @xmath49 by computing locally that @xmath14 has no nearest common ancestor using the labels of @xmath5 and @xmath6 .",
    "this is done via the decoder given in subsection  [ subsec : decoder ] and macro @xmath206 at @xmath6 .",
    "each node @xmath6 computes the minimum - weight outgoing edge of its sub - tree ( given by macro @xmath207 ) by selecting the edge of minimum - weight among its adjacent outgoing edges ( given by macro @xmath208 ) and the one given by its children ( given by macro @xmath209 ) .",
    "the weight and the identifier of the extremities of the minimum - weight outgoing edge are stored in variable @xmath173 at @xmath6 .",
    "all these information will be used for the merging step .",
    "figure  [ fig : fusion ] depicts the selection of the minimum outgoing edge for two fragments",
    ".     corresponds to the label of the node .",
    "the black bubble at each node represent the selection of minimum outgoing edge .",
    "the information under the node corresponds to the variable @xmath79 and the information on top of the node represent the distance of the node from the root . ]    when the computation of the minimum - weight outgoing edge @xmath198 is finished at the root @xmath105 of a fragment @xmath40 ( i.e. , @xmath210 ) , then @xmath105 can start the computation of the future parent pointers in @xmath40 ( predicate @xmath211 is satisfied ) , done in a top - down manner ( see rule @xmath202 ) .",
    "let @xmath5 be the extremity of @xmath14 of minimum identity between @xmath5 and @xmath6 .",
    "if @xmath14 is selected as the minimum - weight outgoing edge of two fragments @xmath40 and @xmath212 , then @xmath5 will become the new root of fragment @xmath213 resulting from the merging between @xmath40 and @xmath212 .",
    "otherwise , @xmath14 is the minimum - weight outgoing edge selected only by a single fragment , w.l.o.g .",
    "let @xmath40 . in this case , @xmath40 will wait for that @xmath14 is selected as the minimum - weight outgoing edge of @xmath212 . in the two cases , every node @xmath6 of a fragment in a merging step computes its future parent pointer in variable @xmath173 .",
    "each node on the path from the root of the fragment leading to the minimum - weight outgoing edge selects its child on this path as its future parent , while the other nodes select their actual parent .",
    "when @xmath14 is selected as the minimum - weight outgoing edge by @xmath40 and @xmath212 and the computation of the future parent is done ( i.e. , @xmath214 is satisfied ) , then the future distance is computed in variable @xmath205 by each node @xmath6 in @xmath215 ( predicate @xmath216 is satisfied ) , in a top - down manner following the parent relation given by variable @xmath204 ( see rule @xmath203 ) . note that the extremity of @xmath14 with the minimum identifier becomes the root of the new fragment with a zero distance .",
    "finally , when the future parent and distance are computed by every node @xmath6 in @xmath215 then @xmath6 can execute rule @xmath217 ( see predicate @xmath218 ) to copy the content of variable @xmath204 ( resp .",
    "@xmath205 ) into variable @xmath62 ( resp .",
    "@xmath172 ) . note that this is done in a bottom - up fashion following the parent relation given by variable @xmath204 in order to not destabilize fragment @xmath40 or @xmath212 .",
    "@xmath199 : [ * minimum computation * ] + * if * @xmath219 \\neq { \\mbox{\\rm candidate}}(v ) \\neq",
    "\\emptyset \\big )   $ ] * then * + @xmath220 +    @xmath202 : [ * merging * ] + * if * @xmath219 = { \\mbox{\\rm candidate}}(v ) \\neq \\emptyset \\big ) \\wedge changenewp(v )   $ ] * then * + @xmath221 + * if * @xmath222 * then * @xmath223 + * else * @xmath224 +    @xmath203 : [ * new distance * ] + * if * @xmath225 * then * + @xmath226 +    @xmath217 : [ * end of merging * ] + * if * @xmath227 * then * + @xmath228 + * if * @xmath229 * then * @xmath230      this subsection is dedicated to the description of the recovering phase .",
    "recall that , since the system can start from an arbitrary configuration @xmath166 , edges which do not belong to any mst can be part a fragment in @xmath166 . given a fragment @xmath40 ,",
    "the addition of an edge @xmath198 which do not belong to @xmath40 creates a unique cycle , called _ fundamental cycle _ related to @xmath14 and denoted @xmath43 ( i.e. , @xmath231 ) .",
    "thus , the `` red rule '' may not be satisfied for every constructed fragment , i.e. , for some fundamental cycle defined by an internal edge of a fragment the maximum edge weight belong to the fragment .",
    "to identify these edges , we verify that for each internal edge @xmath14 there is no edge in the fundamental cycle @xmath43 with a higher weight than @xmath232 . to this end , in a fragment @xmath40 the label of the nodes are used to identify the edges @xmath49 which do not belong to @xmath40 such that @xmath5 and @xmath6 have a common ancestor .",
    "let us consider a fragment @xmath40 and an edge @xmath233 belonging to @xmath40 such that @xmath234 .",
    "if @xmath46 then @xmath14 must become an edge of @xmath40 .",
    "consequently , we need to verify all the edge weights of @xmath235 . to achieve this task ,",
    "the weight of @xmath198 is sent up in @xmath40 along the two paths @xmath169 and @xmath236 . clearly , to maintain low space complexity , the nodes can not store the information about all internal edges . consequently , we decide that each node stores only the information of a single internal edge at a time .",
    "specifically , we need to organize the circulation of the internal edges .",
    "a natural question to ask at this point is whether the information of all non - tree edges are needed . to answer to this question , we first make some observations .",
    "first , suppose the following case ( see figure  [ fig : idemnca ] ) : let @xmath49 and @xmath237 be internal edges such that , and @xmath238 and @xmath239 are closer to @xmath81 than @xmath5 and @xmath6 . on @xmath240 and @xmath241 only the internal edge with the smallest weight is needed . to justify this assertion ,",
    "let us consider without loss of generality that @xmath242 and @xmath243 is a tree edge such that @xmath244 . moreover",
    ", suppose that all edges in a @xmath245 and @xmath246 have a weight smaller than @xmath232 .",
    "consequently , @xmath47 is not part of the mst , and if we delete @xmath47 , the minimum outgoing edge of the fragment composed by the @xmath247 is edge @xmath14 .",
    "consider now , the case when several adjacent edges of node @xmath6 have the same common ancestor ( see figure  [ fig : idemnca2 ] ) . in this case",
    "only the internal edge with the smallest weight is relevant on the @xmath248 to avoid the maximum weight of the fundamental cycles .",
    "the last case considered is the following ( see figure  [ fig : upedges ] ) .",
    "consider a path between two nodes @xmath5 and @xmath6 , and @xmath249 such that @xmath250 and @xmath251 .",
    "let @xmath252 be an edge such that @xmath253 and @xmath254 an edge such that @xmath255 . if @xmath256 , the weight of @xmath257 is needed to verify if the weights of the edges on @xmath258 have a higher weight than @xmath257 .",
    "however , the weight of @xmath14 is needed to verify the weight of edge @xmath47 .",
    "consequently , we need to collect all the outgoing edges from the leaves to the root , from the farthest to the nearest of the root .",
    "the rule for collecting the relevant internal edges is based on the above observations ( see rule @xmath259 ) .",
    "the internal edges are sent up in the fragment from the leaves to the root using variable @xmath176 at every node @xmath6 .",
    "the internal edges are collected locally by beginning from the edge with the farthest nearest common ancestor to the edge with the nearest common ancestor , i.e. , following the lexicographical order on the nearest common ancestor labels and beginning by the smallest one . in case there",
    "exist several edges with the same nearest common ancestor , only the edge with the smallest weight is kept . the list of the ordered internal edges at node @xmath6 is given by macro @xmath260 .",
    "this list is computed by different predicates ( see macros in figure  [ fig : predicatesin ] ) .",
    "each node @xmath6 compares the weight stored in variable @xmath261 $ ] with the weight of the edge leading to its parent .",
    "if @xmath261<w(v,{\\mbox{\\it p}}_v)$ ] then @xmath6 knows that the internal edge indicated by @xmath176 must belong to the mst .",
    "consequently @xmath6 deletes the edge @xmath262 from the fragment ( only if @xmath6 is not the nearest common ancestor of the internal edge given by @xmath176 ) , and @xmath6 becomes the root of the new fragment ( see rule @xmath259 ) .",
    "a node @xmath6 can select a new internal edge by executing rule @xmath259 in the following case ( i.e. , predicate @xmath263 is satisfied ) : ( i ) the internal edge of @xmath6 is propagated up by its parent and @xmath6 has no more child propagating the same internal edge ( see predicate @xmath264 ) , ( ii ) @xmath6 is the nearest common ancestor of the adjacent internal edge actually selected ( see predicate @xmath265 ) , or ( iii ) @xmath6 is neither the root of the fragment nor the nearest common ancestor of the selected internal edge @xmath257 and its parent propagates an internal @xmath266 related with the same common ancestor but @xmath267 ( see predicate @xmath268 ) .",
    "this allows to obtain a piplined propagation of the internal edges .",
    "figure  [ fig : recovering ] illustrates the bottom - up spread of the internal edges .    * if * @xmath269 * then *    @xmath270    * if * @xmath271,{\\mbox{\\it in}}_v[2 ] ) \\neq { \\mbox{\\rm $ \\ell$}}_v \\wedge w(v,{\\mbox{\\it p}}_v)>{\\mbox{\\it in}}_v[0]$ ] * then * @xmath272     corresponds to the label of the node .",
    "the black bubble at each node represents the internal edges . ]",
    "this subsection is dedicated to the correctness of the self - stabilizing minimum spanning tree construction .",
    "we can define a minimum spanning tree as in definition  [ def : mst ] .",
    "[ def : mst ] let @xmath273 be a network with @xmath23 the set of nodes , @xmath24 the set of undirected links and the function @xmath274 .",
    "a graph @xmath275 of @xmath31 is called a _ minimum spanning tree _",
    "if the following conditions are satisfied :    1 .   @xmath276 and @xmath277 , and 2 .",
    "@xmath278 is a connected graph ( i.e. , there exists a path in @xmath278 between any pair of nodes @xmath279 ) and @xmath280 , and 3 .",
    "there exists no spanning tree @xmath281 of @xmath31 whose the weight @xmath282 is lower than @xmath283 .",
    "we give a formal specification to the problem of constructing a minimum spanning tree , stated in specification  [ spec : mst ] .",
    "[ spec : mst ] let @xmath96 be the set of all possible configurations of the system .",
    "an algorithm @xmath284 solving the problem of constructing a stabilizing mst tree satisfies the following conditions :    * starting from any configuration in @xmath96 , algorithm @xmath284 reaches in finite time a set of configurations @xmath285 which satisfies definition  [ def : mst ] , and * from every configuration @xmath286 , algorithm @xmath284 can only reach a configuration in @xmath287 .",
    "let @xmath96 be the set of all possible configurations of the system .",
    "a fragment @xmath288 rooted at node @xmath289 is a subtree such that for every node @xmath290 there is a path to @xmath289 and predicate @xmath189 is true . in the following theorem",
    "we start by showing that until a legitimate configuration is reached there is no deadlock in the system .",
    "[ thm : no_deadlock ] let the set of configurations @xmath291 such that every configuration @xmath292 satisfies definition  [ def : mst ] .",
    "@xmath293 such that @xmath6 is enabled in @xmath166 .",
    "assume by the contradiction , that @xmath294 such that @xmath295 no rule is enabled at @xmath6 in @xmath166 . since @xmath296 , there is either a cycle , several fragments , or a single fragment which is not a mst in @xmath166 .",
    "if there is a cycle or incorrect distances in @xmath166 then there exists a node @xmath6 such that @xmath297 .",
    "this implies that predicate @xmath189 is not satisfied and rule @xmath178 is enabled at @xmath6 , a contradiction .",
    "otherwise , @xmath295 predicate @xmath179 is satisfied .",
    "if there exists a node @xmath6 in @xmath166 with an incorrect label , then either predicate @xmath70 or @xmath167 is satisfied and rule @xmath71 or @xmath74 is enabled at @xmath6 ( see proofs of section  [ subsec : corlabel ] for more details ) , a contradiction . otherwise , predicate @xmath180 is satisfied @xmath298 in @xmath166 .",
    "if there are several fragments in @xmath166 then there is at least one node @xmath61 such that macro @xmath299 .",
    "if there is a node @xmath6 in @xmath166 which has not computed the correct outgoing edge of its subtree ( i.e. , @xmath300 \\neq { \\mbox{\\rm candidate}}(v)$ ] ) , then rule @xmath199 is enabled at @xmath6 , a contradiction .",
    "otherwise , in each fragment @xmath40 in @xmath166 we have @xmath301={\\mbox{\\rm candidate}}(v)$ ] .",
    "consider first a node @xmath6 in a fragment @xmath40 in @xmath166 which is on the path between the root of @xmath40 and the minimum outgoing edge of @xmath40 ( i.e. , @xmath302 ) .",
    "if there exists such a node @xmath6 with @xmath303 and predicate @xmath222 is satisfied , then predicate @xmath304 rule @xmath202 is enabled at @xmath6 , a contradiction . otherwise , consider the other node @xmath6 in @xmath40 which are not on the path between the root and the minimum outgoing edge of @xmath40 ( i.e. , @xmath305 ) .",
    "if there exist such a node @xmath6 such that @xmath306 then predicate @xmath304 is satisfied and rule @xmath202 is enabled at @xmath6 , a contradiction .",
    "otherwise in each fragment @xmath40 in @xmath166 , we have @xmath307 . either for the future root @xmath6",
    "( i.e. , @xmath308 ) of a fragment @xmath40 in @xmath166 we have @xmath309 then predicate @xmath216 is satisfied and rule @xmath203 is enabled at @xmath6 , a contradiction . or for the other node @xmath6 in @xmath40 we have @xmath310 then predicate @xmath216 is satisfied and rule @xmath203 is enabled at @xmath6 , a contradiction .",
    "otherwise , we have @xmath311 in @xmath166 . if in a fragment @xmath40 in @xmath166 there is a node @xmath6 such that every of its future children @xmath5 after the merging ( given by macro @xmath312 ) in the fragment satisfies @xmath313 and @xmath314 , then predicate @xmath218 is satisfied and rule @xmath217 is enabled at @xmath6 , a contradiction .",
    "finally , otherwise there is only a single fragment @xmath40 in @xmath166 and we have @xmath315 . moreover , for every node @xmath61 predicate @xmath263 is satisfied , since @xmath316 .",
    "therefore , rule @xmath259 is enabled at every @xmath6 in @xmath166 . by contradiction",
    "the fragment @xmath40 in @xmath166 is not a mst , so there exists a node @xmath6 in @xmath166 such that @xmath317 and @xmath6 is adjacent of an internal edge with a weight lower than @xmath318 ( i.e.,@xmath319 $ ] ) .",
    "thus , @xmath6 becomes the root of a new fragment when @xmath6 executes rule @xmath259 , a contradiction .",
    "we denote by @xmath320 the set of configurations in @xmath96 such that there are no cycles in the subgraph induced by parent link relations ( i.e. , for every @xmath321 we have @xmath322 ) .",
    "[ lem : time_cf ] starting from any arbitrary configuration , the system reaches in @xmath13 rounds a configuration in @xmath320 .",
    "[ lem : cycle free ]    this lemma can be proved using the same arguments given in  @xcite .",
    "+      we now define some notations and predicates which will be used in the following proofs . given a configuration @xmath110 , we note the set of all fragments in @xmath166 by @xmath323 . moreover , we define below several sets of fragments with different properties and the notion of _ attractor _ , introduced by gouda and multari  @xcite , will be used to show that during the convergence of algorithm @xmath168 each fragment gains additional properties .",
    "we define five sets of fragments in a configuration @xmath110 :    * let @xmath324 be the set of fragments in @xmath166 in which all the nodes are correctly labeled .",
    "* let @xmath325={\\mbox{\\rm candidate}}(v ) \\neq \\emptyset)\\}$ ] be the set of fragments correctly labeled in @xmath166 in which every node has computed its minimum - weight outgoing edge of its subtree for the merging phase .",
    "* let @xmath326 be the set of fragments correctly labeled in @xmath166 in which every node has computed its future parent used when the merging phase is done .",
    "* let @xmath327 be the set of fragments correctly labeled in @xmath166 in which every node has computed its future distance used when the merging phase is done .",
    "* let @xmath328 be the set of fragments in @xmath166 for which the merging phase is done .",
    "we obtain the following lemma by applying rules @xmath71 and @xmath74 according to lemmas  [ lem : size_convergence ] to  [ lem : label_closure ] and theorem  [ thm : self - stab_lab ] .",
    "[ lem : labelmst ] starting from any configuration @xmath329 , after @xmath13 rounds the system reaches a configuration @xmath330 such that for each fragment @xmath331 we have @xmath332 .",
    "[ lem : min ] let any fragment @xmath333 in a configuration @xmath321 .",
    "in @xmath334 rounds , we have @xmath335 , with @xmath336 and @xmath337 the height of @xmath40 . [ lem : min_convergence ]    in the following we define the potential function @xmath338 .",
    "first , let @xmath339 : @xmath100 be the function defined by : @xmath340-\\min\\big ( \\min\\{{\\mbox{\\it out}}_u[0]:u\\in{\\mbox{c}}(v)\\ } , \\min\\{w\\{v , u\\ } : ( u , v ) \\in { \\mbox{\\rm o\\hspace*{-0,05cm}e}}(v)\\}\\big ) |.\\ ] ] note that , we have @xmath341 .",
    "variable @xmath173 has a correct value at node @xmath6 if and only if @xmath342 .",
    "let a fragment @xmath333 in a configuration @xmath321 , and @xmath343 be the function defined by : @xmath344 where @xmath345 is the number of nodes @xmath6 at height @xmath118 in @xmath40 with @xmath346 .",
    "we denote @xmath347 the number of nodes in fragment @xmath40 .",
    "note that @xmath348 , and @xmath349 .",
    "moreover , the variable @xmath350 has a correct value at every node in @xmath40 if and only if @xmath351 .",
    "we note @xmath123 the configuration of the system after round @xmath124 .",
    "let @xmath125 be the largest index such that @xmath352 .",
    "since we use a weakly fair scheduler , all the nodes of fragment @xmath40 are scheduled during the execution of round @xmath127 .",
    "every node @xmath6 at height @xmath128 does not change the value of its variable @xmath350 ( see rule @xmath199 ) , and therefore @xmath353 remains equal to zero , so @xmath354 is equal to zero as well .",
    "the nodes @xmath6 at height @xmath125 change their variable @xmath173 according to the variable @xmath355 of their children @xmath356 ( see rule @xmath199 ) .",
    "let @xmath6 be a node at height @xmath125 .",
    "the children of @xmath197 ( if any ) are at height @xmath128 .",
    "thus , their variable @xmath350 has not changed , and therefore @xmath353 becomes zero after round @xmath127 . as a consequence , @xmath357 .",
    "therefore , we get @xmath358 and thus the system will eventually reach a configuration where all the variables @xmath350 contains the minimum outgoing edge of the sub - fragment rooted at @xmath197 ( see predicate @xmath359 ) .    to measure the number of rounds it takes to converge ,",
    "observe that @xmath118 decreases by at least one at each round .",
    "since @xmath360 , we get that starting from any configuration @xmath321 with @xmath333 the system reaches a configuration where for every node @xmath6 in fragment @xmath40 the variable @xmath173 is correct after @xmath361 rounds .",
    "[ lem : merging_two_frag ] in every configuration @xmath321 , there are at least two fragments @xmath362 and @xmath363 , @xmath364 which select the same minimum - weight outgoing edge for merging .",
    "assume , by the contradiction , that there exists a configuration @xmath321 with less than two fragments in @xmath365 which select the same minimum - weight outgoing edge .",
    "this implies in @xmath166 that either at least one fragment @xmath366 which has not computed its minimum - weight outgoing edge , or every fragment @xmath367 has selected a different minimum - weight outgoing edge . in the former case",
    ", there is a contradiction since according to lemma  [ lem : min ] in @xmath361 additional rounds the system reaches a configuration @xmath330 in which at least two fragments @xmath362 and @xmath363 , @xmath364 which select the same minimum - weight outgoing edge for merging .",
    "otherwise , let @xmath368 denotes the number of fragments in the set @xmath365 in @xmath166 . in the latter case ,",
    "exactly @xmath368 minimum - weight outgoing edges have been selected in @xmath166 .",
    "however , we can observe that we can define a total order on the outgoing edges in each configuration in @xmath320 based on the tuple defined by the edges weight and the identifiers of the extremities of the edges . by using this total order",
    ", @xmath8 fragments could select at most the @xmath369 minimum outgoing edges .",
    "thus , since algorithm @xmath168 uses these method to select the minimum - weight outgoing edge of each fragment ( see macros @xmath359 and @xmath370 ) then at most @xmath371 different outgoing edges are selected in @xmath166 .",
    "so , there are at least two fragments @xmath364 which select the same minimum outgoing edge , a contradiction .",
    "[ lem : compute_newp ] let any fragment @xmath372 of a configuration @xmath321 . if @xmath367 then every computation suffix starting from @xmath166 contains a configuration @xmath336 such that @xmath373 .",
    "assume , by the contradiction , that there exists a suffix @xmath266 starting from @xmath166 with no configuration @xmath336 such that @xmath373 in computation @xmath374 .",
    "consider the configuration @xmath166 . since @xmath367 and @xmath375 , only rule @xmath202 could be enabled at a node @xmath197 ( by definition of @xmath365 and according to the guards of rules given in the formal description of algorithm @xmath168 ) .",
    "moreover , as @xmath375 there exists at least one node @xmath197 such that predicate @xmath304 is satisfied at @xmath6 . consider a computation step @xmath376 of @xmath14 .",
    "assume that rule @xmath202 is enabled at @xmath6 in @xmath166 and not in @xmath377 but @xmath6 did not execute rule @xmath202 . if @xmath6 is the root of @xmath40 ( i.e. , @xmath378 ) or @xmath6 is on the path between the root of @xmath40 and the selected minimum - weight outgoing edge then @xmath214 implies that @xmath379 , a contradiction since rule @xmath202 is the only rule in @xmath166 which can change variable @xmath204 .",
    "otherwise , for every other node @xmath197 , @xmath214 implies that @xmath380 , a contradiction since rule @xmath202 is the only rule in @xmath166 which can change variable @xmath204 . by weakly - fairness assumption on the daemon ,",
    "every node @xmath197 executes rule @xmath202 and satisfies @xmath214 .",
    "finally , we can observe that the set of fragments @xmath381 is included in the set @xmath365 by definition in a configuration @xmath166 .",
    "[ lem : time_mwoe ] let any fragment @xmath367 in a configuration @xmath321 . in @xmath361 rounds , we have @xmath373 , with @xmath336 and @xmath337 the height of @xmath40 .",
    "let @xmath382 denotes the height of @xmath6 in @xmath40 .",
    "we show by induction the following proposition : in at most @xmath383 rounds , we have @xmath384 \\vee newp_v={\\mbox{\\it p}}_v)$ ] .    in base case @xmath385 .",
    "consider the root @xmath6 of fragment @xmath40 ( i.e. , @xmath378 ) . if @xmath303 then rule @xmath202 is enabled at @xmath6 in round 0 , since @xmath386 .",
    "therefore , since the daemon is weakly fair then in the first configuration of round 1 , @xmath6 executes rule @xmath202 and we have @xmath379 at @xmath6 which verifies the proposition .",
    "induction case : we assume that in round @xmath387 we have @xmath388 \\vee newp_v={\\mbox{\\it p}}_v)$ ] . we have to show that in round @xmath389 we have @xmath390 \\vee newp_v={\\mbox{\\it p}}_v)$ ] . consider any node @xmath197 of height @xmath389 in @xmath40 . by induction hypothesis",
    ", we have either @xmath391 or @xmath305 . in the former case ,",
    "if @xmath303 and @xmath392 then rule @xmath202 is enabled at @xmath6 in round @xmath393 ( because @xmath394 ) . in the latter case , if @xmath306 and @xmath395 then rule @xmath202 is enabled at @xmath6 in round @xmath393 ( because @xmath396 ) . thus , since the daemon is weakly fair then in the first configuration of round @xmath389 @xmath6 executes rule @xmath202 .",
    "so , we have @xmath397 \\vee newp_v={\\mbox{\\it p}}_v)$ ] at @xmath6 . therefore ,",
    "in at most @xmath361 rounds we have @xmath398 \\vee [ { \\mbox{\\it out}}_{{\\mbox{\\it p}}_v } \\neq { \\mbox{\\it out}}_v \\wedge newp_v={\\mbox{\\it p}}_v])$ ] and this implies that @xmath399 .    [",
    "lem : merging_two_frag_dist ] let any two fragments @xmath362 and @xmath363 , @xmath400 of a configuration @xmath321 . if @xmath401 and the same minimum - weight outgoing edge is selected by the two fragments then every computation suffix starting from @xmath166 contains a configuration @xmath336 such that @xmath402 .",
    "assume , by the contradiction , that there exists a suffix @xmath266 starting from @xmath166 with no configuration @xmath336 such that @xmath402 in computation @xmath374 .",
    "as rule @xmath203 is the only rule to modify variable @xmath205 such that @xmath403 is satisfied when executed , this implies that there exists a node @xmath404 which never executes rule @xmath203 in the computation suffix @xmath266 .",
    "consider the configuration @xmath166 . according to the formal description of algorithm ,",
    "rules @xmath405 , and @xmath259 are disabled for any node @xmath404 since @xmath401",
    ". moreover , rule @xmath217 is disabled at any node @xmath404 as we have @xmath406 for every node @xmath407 , because @xmath408 and @xmath409 by the execution of rule @xmath202 .",
    "so , only rule @xmath203 could be enabled at every node @xmath404 .",
    "this implies that rule @xmath203 is disabled for every node @xmath404 ( i.e. , we have @xmath403 ) .",
    "consider without loss of generality fragment @xmath410 .",
    "note that @xmath411 and @xmath412 we have @xmath409 due to the execution of rule @xmath202 . if @xmath197 is the future root of @xmath40 ( after the merging phase ) then either @xmath413 , a contradiction because @xmath362 and @xmath363 have selected the same minimum - weight outgoing edge , or @xmath414 , a contradiction since @xmath415 .",
    "if @xmath197 is any other node in @xmath40 then we have @xmath416 , a contradiction since @xmath415 .",
    "therefore , the system reaches a configuration @xmath336 in which for every node @xmath197 we have @xmath403 , so @xmath417 .",
    "finally , we can observe that the set of fragments @xmath418 is included in the set @xmath381 by definition in a configuration @xmath166 .",
    "[ lem : time_f4 ] let any fragment @xmath419 in a configuration @xmath321 . in @xmath361 rounds , we have @xmath417 , with @xmath336 and @xmath337 the height of @xmath40",
    ".    we can show by induction on the height of @xmath40 that in @xmath361 rounds every node @xmath197 satisfies @xmath420 ) using the same method as in proof of lemma  [ lem : time_mwoe ] .",
    "[ lem : merging_two_frag_end ] let any fragment @xmath421 of a configuration @xmath321 . if @xmath422 then every computation suffix starting from @xmath166 contains a configuration @xmath336 such that @xmath423 .",
    "assume , by the contradiction , that there exists a suffix @xmath266 starting from @xmath166 with no configuration @xmath336 such that @xmath373 in computation @xmath374 .",
    "consider the configuration @xmath166 .",
    "since @xmath422 , only rule @xmath217 could be enabled at a node @xmath197 ( by definition of @xmath418 and according to the guards of rules given in the formal description of algorithm @xmath168 ) . moreover , as @xmath424 there exists at least one node @xmath197 such that predicate @xmath218 is satisfied at @xmath6 .",
    "consider a computation step @xmath376 of @xmath14 .",
    "assume that rule @xmath217 is enabled at @xmath6 in @xmath166 and not in @xmath377 but @xmath6 did not execute rule @xmath217 .",
    "if @xmath197 is a leaf and @xmath6 is not adjacent to the minimum - weight outgoing edge of @xmath40 then @xmath425 implies that @xmath426 ( because @xmath6 has no neighbor @xmath427 ) , a contradiction since rule @xmath217 is the only rule which could copy the value of @xmath204 ( resp .",
    "@xmath205 ) in @xmath62 ( resp .",
    "@xmath172 ) .",
    "otherwise for every other node @xmath197 , @xmath425 implies that either @xmath426 or @xmath428 such that @xmath429 . in the former case",
    ", there is a contradiction since rule @xmath217 is the only rule which could copy the value of @xmath204 ( resp .",
    "@xmath205 ) in @xmath62 ( resp .",
    "@xmath172 ) . in the latter case ,",
    "there is a neighbor @xmath407 which modified its variable @xmath430 or @xmath431 by executing rule @xmath178 or @xmath259 , a contradiction since only rule @xmath217 could be enabled at a node @xmath197 in @xmath166 . by weakly - fairness assumption on the daemon ,",
    "every node @xmath197 executes rule @xmath217 and satisfies @xmath425 .",
    "finally , we can observe that the set of fragments @xmath432 is included in the set @xmath418 by definition in a configuration @xmath166 .",
    "[ lem : time_f5 ] let any fragment @xmath422 in a configuration @xmath321 . in @xmath361 rounds , we have @xmath423 , with @xmath336 and @xmath337 the height of @xmath40",
    ".    we can show by induction on the height of @xmath40 that in @xmath361 rounds every node @xmath197 satisfies @xmath425 ) using the same method as in proof of lemma  [ lem : time_mwoe ] .",
    "[ lem : nb_frag_diminution ] let a configuration @xmath321 such that @xmath433 .",
    "we have @xmath434 for any configuration @xmath336 obtained after a merging step in every computation suffix starting from @xmath166 .",
    "assume , by the contradiction , that there exists a suffix @xmath266 starting from @xmath166 with a configuration @xmath336 obtained after a merging step for which @xmath435 in computation @xmath374 . this implies that in @xmath266 either there are no two fragments @xmath436 which can merge together using the same minimum - weight outgoing edge , or @xmath362 and @xmath363 does not belong to the same fragment after a merging step .",
    "first of all , by lemmas  [ lem : labelmst ] and  [ lem : min ] every fragment @xmath366 which does not satisfies @xmath180 and @xmath300={\\mbox{\\rm candidate}}(v)$ ] executes rules @xmath437 and @xmath199 to belong to @xmath365 .",
    "so , we consider that every fragment in @xmath323 belongs to @xmath365 . in the first case , this is a contradiction with lemma  [ lem : merging_two_frag ] which shows that in @xmath166 there are at least two fragments @xmath362 and @xmath363 , @xmath364 which select the same minimum - weight outgoing edge for merging . in the latter case , by lemma  [ lem : compute_newp ]",
    "every fragment @xmath367 computes its future parent after the merging step , so @xmath401 .",
    "moreover , by lemma  [ lem : merging_two_frag_dist ] we have @xmath402 in @xmath266 .",
    "so , by lemma  [ lem : merging_two_frag_end ] every node @xmath404 can execute rule @xmath217 and then rules @xmath71 and @xmath74 to form a new fragment in @xmath438 composed of @xmath362 and @xmath363 in @xmath266 , a contradiction .",
    "note that for each fragment @xmath439 in @xmath321 , we have that each node @xmath197 satisfies predicate @xmath189 but does not satisfies predicate @xmath180 ( because of the merging step the labels of each node @xmath6 is no more correct ) .",
    "so , every node @xmath197 can execute again rules @xmath71 and @xmath74 .",
    "let any fragment @xmath439 of a configuration @xmath321 such that @xmath315 .",
    "if @xmath40 does not span all the nodes of the system , then rule @xmath199 is enabled in at least one node @xmath197 in @xmath166 .",
    "first of all , predicate @xmath180 is satisfied at every node @xmath197 because @xmath440 .",
    "assume , by the contradiction , that @xmath40 does not spans all the nodes of the system in @xmath166 and rule @xmath199 is disabled at every node @xmath197 .",
    "this implies that there is a node @xmath197 which adjacent to an edge @xmath4 such that @xmath441 .",
    "so , we have @xmath442 . moreover , since @xmath440 , @xmath6 has executed rule @xmath217 and we have @xmath443 .",
    "therefore , rule @xmath199 is enabled at @xmath6 , a contradiction .",
    "[ lem : time_merging ] starting from any configuration @xmath110 which contains several fragments , the system reaches a configuration @xmath336 which contains a single fragment spanning all the nodes of the system in @xmath1 rounds , with @xmath8 the network size .",
    "first of all , according to lemmas  [ lem : time_cf ] and  [ lem : labelmst ] in @xmath13 rounds the system reaches a configuration @xmath444 in which each fragment @xmath445 .",
    "moreover , according to lemmas  [ lem : min_convergence ] ,  [ lem : time_mwoe ] ,  [ lem : time_f4 ] and  [ lem : time_f5 ] by summing up the complexities each merging step is performed using at most @xmath13 rounds ( since @xmath8 is an upper bound for the height of any fragment ) .",
    "finally , in a configuration we can not have more than @xmath8 fragments so to obtain a spanning tree we can perform at most @xmath369 merging phases ( attained when only two fragments can be merged at each step ) .",
    "moreover , by lemma  [ lem : nb_frag_diminution ] after each merging step the number of fragments is decreased by at least one .",
    "therefore , by the above elements we obtain that a spanning tree is constructed in @xmath1 rounds starting from an arbitrary configuration .",
    "[ lem : disable_merge_rules ] in every configuration @xmath321 which contains a single fragment @xmath446 spanning all the nodes of the system and correctly labeled , then for every node @xmath447 no rule of algorithm @xmath168 , except rule @xmath259 , is enabled at @xmath6 .",
    "assume , by the contradiction , that there is an enabled rule , except rule @xmath259 , of algorithm @xmath168 in a node @xmath447 in @xmath166 .",
    "for every node @xmath447 predicate @xmath189 is satisfied in @xmath321 ( by definition of @xmath320 ) , so rule @xmath178 is disabled at @xmath6 , a contradiction . since @xmath278 is correctly labeled , we have @xmath448 , so rules @xmath71 and @xmath74 are disabled at @xmath6 , a contradiction .",
    "since @xmath278 spans all the nodes of the system , for every node @xmath447 we have @xmath449 and rule @xmath199 is disabled at @xmath6 , a contradiction . finally , we have that @xmath446 and by definition of @xmath432 rules @xmath450 , and @xmath259 are disabled at @xmath6 , a contradiction .",
    "let a configuration @xmath321 such that @xmath451 and @xmath40 be the fragment of @xmath323 .",
    "at least one node @xmath197 can execute rule @xmath259 .",
    "first of all , we consider that every node @xmath197 the distance and the label are correct ( i.e. , @xmath180 and @xmath425 are satisfied which implies we have @xmath452 ) . assume , by the contradiction , that rule @xmath259 is disabled for every node @xmath197 .",
    "this implies that for every node @xmath197 we have either @xmath453 , or another internal edge can not be selected . in the first case , by hypothesis of the lemma",
    "there is only one fragment in @xmath323 , so for every node @xmath197 we have @xmath454 , a contradiction . in the second case",
    ", this implies that an internal edge of minimum - weight associated to the common ancestor of the edge is not propagated up in @xmath40 .",
    "if @xmath6 is the common ancestor of a locally internal edge ( given by macro @xmath455 ) , then we have @xmath456 and rule @xmath259 is enabled at @xmath6 , a contradiction . if @xmath6 has selected a local internal edge ( i.e. , @xmath457 and @xmath458 ) and the internal edge has been propagated by @xmath62 ( @xmath459 ) , then this implies we have @xmath460 and rule @xmath259 is enabled at @xmath6 , a contradiction .",
    "otherwise , for an internal edge propagated by a child @xmath5 in @xmath40 either @xmath6 is the common ancestor , or the internal edge has been propagated by @xmath62 ( @xmath459 ) and @xmath5 has selected another internal edge ( i.e. , @xmath458 ) .",
    "this implies we have @xmath460 and rule @xmath259 is enabled at @xmath6 , a contradiction .",
    "[ cor : propag_internal_edge ] in any configuration @xmath321 such that @xmath451 , by executing rule @xmath259 every node @xmath197 sends up in @xmath40 the internal edges selected by @xmath6 and its descendants ordered locally on the nearest common ancestors ( given by macro @xmath260 ) , with @xmath40 the fragment in @xmath323 .",
    "[ lem : end_propag_ie ] let a configuration @xmath321 such that @xmath451 and @xmath40 be the fragment of @xmath323 .",
    "every internal edge related to the nearest common ancestor @xmath200 is not propagated up in @xmath40 .    according to corollary  [ cor : propag_internal_edge ] , @xmath200 propagates up in @xmath40 the internal edges selected by its descendants and itself .",
    "assume , by the contradiction , that the parent @xmath200 of the nearest common ancestor @xmath461 related to an internal edge @xmath462 propagates up in @xmath40 the internal edge @xmath198 , described by its weight @xmath7 and the labels of its extremities @xmath138 and @xmath56 stored in variable @xmath463 at @xmath461 .",
    "this implies that when @xmath200 executes rule @xmath259 then macro @xmath464 returns edge @xmath14 .",
    "macro @xmath464 returns an edge from the union set of edges given by macros @xmath465 and @xmath466 .",
    "we must consider only macro @xmath466 since @xmath461 is the common ancestor of @xmath14 .",
    "however , according to the formal description of algorithm @xmath168 macro @xmath466 contains only internal edges @xmath467 whose the nearest common ancestor related to @xmath47 has a label higher or equal to @xmath200 s label following the lexicographical order ( i.e. , @xmath468 ) .",
    "thus , we have @xmath469 , a contradiction .    [",
    "lem : create_new_frag ] let a configuration @xmath321 such that @xmath451 and @xmath40 be the fragment of @xmath323 . if a node @xmath197 selects by executing rule @xmath259 an internal edge @xmath470 such that @xmath471 and @xmath6 is not the common ancestor related to @xmath472 then the edge @xmath262 is deleted by @xmath6 from @xmath40 .",
    "assume , by the contradiction , that @xmath197 selects by executing rule @xmath259 an internal edge @xmath470 such that @xmath471 but the edge @xmath262 is not deleted from @xmath40 . according to the formal description of algorithm @xmath168",
    ", a node can delete an edge of a fragment by executing rule @xmath259 .",
    "so , this implies that by executing rule @xmath259 the edge @xmath262 is not deleted from @xmath40 by @xmath197 .",
    "consider the internal edge @xmath470 stored in @xmath176 by executing rule @xmath259 at @xmath6 such that @xmath261<w(v,{\\mbox{\\it p}}_v)$ ] . by description of rule @xmath259",
    ", @xmath6 does not delete the edge @xmath262 only if @xmath271,{\\mbox{\\it in}}_v[2])={\\mbox{\\rm $ \\ell$}}_v)$ ] , which is a contradiction with the hypothesis of the lemma .",
    "[ lem : time_recover ] starting from any configuration @xmath321 which contains a single spanning tree @xmath278 , the recovering phase is performed in @xmath1 rounds , @xmath8 the network size .",
    "first of all , every node @xmath447 sends up in @xmath278 the internal edge of minimum weight associated to each common ancestor @xmath473 , given by macro @xmath260 based on macro @xmath474 .",
    "moreover , by lemma  [ lem : end_propag_ie ] every internal edge @xmath14 is not propagated by the ancestors of the common ancestor @xmath14 in @xmath278 . by lemma  [ cor : propag_internal_edge ]",
    ", every node @xmath447 sends up in the tree the internal edges selected by @xmath6 and its descendants ordered locally on the nearest common ancestors , that is following the lexicographical order on the label of nearest common ancestors .",
    "observe that every node @xmath447 is the common ancestor of at most @xmath475 internal edges selected to be propagated up in @xmath278 , with @xmath475 the height of @xmath278 .",
    "furthermore , each propagated internal edge reaches its related nearest common ancestor in @xmath476 rounds .",
    "however , the propagation of the internal edges is pipelined in @xmath278 , since a node @xmath447 can execute rule @xmath259 when its parent propagates its internal edge or the nearest common ancestor is reached ( see predicate @xmath477 ) .",
    "thus , for every nearest common ancestor @xmath447 the propagation of the internal edges related to @xmath6 is performed in @xmath476 rounds . finally ,",
    "there are at most @xmath8 nearest common ancestors in the spanning tree @xmath278 , so the propagation of all the internal edges of @xmath278 is performed in @xmath478 rounds .",
    "[ lem : mst_preserved ] starting from every configuration @xmath321 satisfying definition  [ def : mst ] , the system can only reach a configuration @xmath336 which satisfies definition  [ def : mst ] .    by lemma  [ lem : disable_merge_rules ] , in every configuration @xmath321 every rule of algorithm @xmath168 , except rule @xmath259 , is disabled at @xmath61 .",
    "consider any configuration @xmath321 which satisfies definition  [ def : mst ] .",
    "this implies that there is only a single spanning tree @xmath278 in @xmath166 and in every fundamental cycle defined by each internal edge of @xmath278 lemma  [ lem : create_new_frag ] can not be applied .",
    "therefore , by executing rule @xmath259 at any node @xmath447 no new fragment is created and the constructed minimum spanning tree @xmath278 is preserved .",
    "algorithm @xmath168 is a self - stabilizing algorithm for specification  [ spec : mst ] under a weakly fair daemon with a convergence time of @xmath1 rounds and memory complexity of @xmath20 bits per node , with @xmath8 the network size .",
    "we have to show first that starting from any configuration the execution of algorithm @xmath168 verifies property [ tc1 ] and [ tc2 ] of specification  [ spec : mst ] .",
    "first of all , by theorem  [ thm : no_deadlock ] while the system does not reach a configuration satisfying definition  [ def : mst ] , there is a rule enabled , except rule @xmath259 , at a node @xmath61 . according to lemmas  [ lem : nb_frag_diminution ] ,  [ lem : create_new_frag ] ,",
    "[ lem : time_merging ] and  [ lem : time_recover ] , from any configuration algorithm @xmath168 reaches a configuration @xmath110 satisfying definition  [ def : mst ] in finite time , which verifies property [ tc1 ] .",
    "moreover , according to lemma  [ lem : mst_preserved ] from a configuration @xmath110 satisfying definition  [ def : mst ] algorithm @xmath168 can only reach a configuration in @xmath96 satisfying definition  [ def : mst ] , which verifies property [ tc2 ] of specification  [ spec : mst ] .",
    "we consider now the convergence time and memory complexity of algorithm @xmath168 .",
    "according to lemmas  [ lem : time_merging ] and  [ lem : time_recover ] , each part of the algorithm ( merging and recovering part ) have a convergence time of at most @xmath1 rounds to construct a minimum spanning tree .",
    "moreover , algorithm @xmath168 maintains height variables at every node @xmath61 , composed of six variables of size @xmath479 bits ( variables @xmath480 , and @xmath173 ) and two variables of size @xmath481 bits used to stored labels of nodes ( variables @xmath56 and @xmath176 ) . according to @xcite , variable @xmath56 necessitates @xmath482 bits of memory at every node @xmath61 .",
    "therefore , no more than @xmath481 bits per node are necessary .",
    "we extended the gallager , humblet and spira ( ghs ) algorithm , @xcite , to self - stabilizing settings via a compact informative labeling scheme .",
    "thus , the resulting solution presents several advantages appealing for large scale systems : it is compact since it uses only poly - logarithmic in the size of the network memory space ( @xmath481 bits per node ) and it scales well since it does not rely on any global parameter of the network .",
    "the convergence time of the proposed solution is @xmath1 rounds .",
    "quite recently , another self - stabilizing algorithm was proposed by korman et al .",
    "@xcite for the mst problem with a convergence time of @xmath13 rounds and memory complexity of @xmath483 bits .",
    "however , this approach requires the use of several sub - algorithms leading to a complex solution to be used in a practical situation , comparing to our algorithm .",
    "llia blin , shlomi dolev , maria gradinariu potop - butucaru and stephane rovedakis fast self - stabilizing minimum spanning tree construction - using compact nearest common ancestor labeling scheme . ,",
    "volume 6343 of _ lecture notes in computer science _ ,",
    "pages 480494 , 2010 .",
    "llia blin , maria potop - butucaru , stephane rovedakis and sbastien tixeuil . a new self - stabilizing minimum spanning tree construction with loop - free property . ,",
    "volume 5805 of _ lecture notes in computer science _ , pages 407422 .",
    "springer 2009 .",
    "gheorghe antonoiu and pradip k. srimani .",
    "distributed self - stabilizing algorithm for minimum spanning tree construction . ,",
    "volume 1300 of _ lecture notes in computer science _ , pages 480 - 487 .",
    "springer 1997 .",
    "lisa higham and zhiying liang .",
    "self - stabilizing minimum spanning tree construction on message - passing networks . in _",
    "15th international conference on distributed computing ( disc ) _ , volume 2180 of _ lecture notes in computer science _ , pages 194208 , 2001 .",
    "amos korman and shay kutten and toshimitsu masuzawa .",
    "fast and compact self stabilizing verification , computation , and fault detection of an mst . in _",
    "30th annual acm symposium on principles of distributed computing ( podc ) _ , pages 311320 , 2011 .",
    "paola flocchini and toni mesa enriquez and linda pagli and giuseppe prencipe and nicola santoro .",
    "distributed computation of all node replacements of a minimum spanning tree . ,",
    "volume 4641 of _ lecture notes in computer science _ , pages 598 - 607 .",
    "springer 2007 ."
  ],
  "abstract_text": [
    "<S> we present a novel self - stabilizing algorithm for minimum spanning tree ( mst ) construction . </S>",
    "<S> the space complexity of our solution is @xmath0 bits and it converges in @xmath1 rounds . </S>",
    "<S> thus , this algorithm improves the convergence time of previously known self - stabilizing asynchronous mst algorithms by a multiplicative factor @xmath2 , to the price of increasing the best known space complexity by a factor @xmath3 . </S>",
    "<S> the main ingredient used in our algorithm is the design , for the first time in self - stabilizing settings , of a labeling scheme for computing the nearest common ancestor with only @xmath0 bits . </S>"
  ]
}