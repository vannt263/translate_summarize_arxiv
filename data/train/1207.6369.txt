{
  "article_text": [
    "it is a well - known aspiration to exclusively use methods which guarantee the correctness of the developed program with respect to the problem @xcite posed , that is , what makes it essential to find abstract mathematical definition of programming notions . at etvs lornd university , a relational model of programming which treats the most important , fundamental notions of programming ",
    "problem , program , state space , variable , data type , etc.in a uniform and consistent way @xcite has been built for thirty years .",
    "the base of the abstract definitions of programming notions is the state space and their tool is the mathematical relation .",
    "the problem , for example , is a homogeneous binary relation over the state space that maps from the possible initial states to the appropriate goal states .",
    "the program is defined as all of its executions , so it can be described by the relation that maps from any state to the executions starting from one , where an execution is the sequence of the states concerned .",
    "the effect of a program is also a homogeneous binary relation where its domain contains the states from which the program surely terminates , i.e. the executions starting from these states are finite , and maps to states where these executions stop .",
    "the definition of the solution ( when a program is said to solve a problem ) establishes the main connection between the relations of the problem and the effect of the program .",
    "this theoretical approach makes it possible to investigate the concept and correctness of several kinds of program - designer methods such as program synthesis , analogous programming , etc .",
    "the main characteristic of this relational model is the special static point of view in which the concept of the program is a mapping and not a working , nonetheless it is originally dynamic .",
    "the advantage of this static point of view is the simple definition of the solution . although it is not self - evident if the number of the components of the state space of a problem and that of a program are different . to prove the correctness , in this case",
    ", the program and the problem must be transformed into a new common state space @xcite .    in the present model however , the state space is persistent , i.e. all variables of the program are global and static ( the scope and life time of the variables involve the whole program ) , the so - called local variables can not be created and destroyed during an execution . in absence of local variables ,",
    "the concept of real subprograms can not be introduced into our programming model .",
    "( only macros can be defined . )",
    "namely , the power of a subprogram is what permits creating new local auxiliary variables as well as parameter variables , and it is not supported by the present concept of the program .",
    "it is not a serious problem if simply the correctness is wanted to be proved but it is a great difficulty if our aim is to design a program .",
    "unfortunately , the programming method , which is based on our programming model to synthetize correct programs , can not produce subprograms with parameter variables , so their creation remains in the sphere of the implementation instead of the designing .",
    "it is an additional disadvantage that , without the concept of subprograms , recursive calling can not be used in our programming model .",
    "the aim of this paper is to remedy this shortcoming of the definition of the program , and to preserve the earlier results of the programming model .",
    "all definitions of the programming model are based on the state space .",
    "the concept of the state space has already been interpreted in several ways . for many people ,",
    "the state space is a model of a von neumann type computer ; others , e.g. dijkstra @xcite , associate this notion with the problem to be solved , where a state is a compound of the values of the main data types .",
    "so , the program is `` outside '' of the state space operating on it . in our programming model ,",
    "this second meaning is used . in @xcite ,",
    "the notion of the state space is a cartesian product of the value set of data types .",
    "the only mistake of this obvious definition is that it imposes an order on the components . in @xcite , where the _ * state space * _ is a direct product , this mistake",
    "is repaired .",
    "here it is the definition of the direct product and the notions related to it .",
    "let @xmath0 be a finite set named as index set .",
    "let @xmath1 s ( @xmath2 ) be arbitrary sets .",
    "the set @xmath3 is the direct product of the sets @xmath4 ( @xmath2 ) .",
    "the @xmath1 s are the components of the direct product @xmath5 .",
    "the number of the components is finite .",
    "the direct product is the empty set if the set @xmath0 is empty .",
    "let @xmath6 and @xmath7 be direct products where @xmath0 and @xmath8 are finite sets , @xmath1 s ( @xmath9 ) and @xmath10 s ( @xmath11 ) are arbitrary sets .",
    "the @xmath12 and @xmath13 are equivalent if there exists a bijection @xmath14 so that @xmath15 . in other words , b is the renamed a.    if @xmath16 and @xmath17 then @xmath13 is the subspace of @xmath12 , i.e. @xmath18 .",
    "the function @xmath19 is a projection if @xmath18 and @xmath20 .",
    "not only one state but a set or sequence of states can also be projected if it is done one by one . if @xmath21 then the function @xmath22 is named as @xmath23 variable and @xmath23 is the variable name .",
    "the most important notion of the programming model is the program . in our explanation ,",
    "the program is not a collection of some statements that can be executed on a computer .",
    "the statements could only describe a program but the program is the complex of its executions . an execution is a sequence of states .",
    "a program , by definition , can always begin , i.e. at least one execution has to start from each state .",
    "if several executions start from the same start state , it means that the program is non - deterministic : nobody knows which execution will happen .    in the original programming model , every state of",
    "the progam belongs to the same state space .",
    "now we are going to permit that the state space can be permanently changed ; the inner states of the executions may have got new components .",
    "the other novelty of our new definition is the idea of the _ * base state space * _ of the program .",
    "the first state ( start state ) of all executions and the last , if the execution is finite , are in this base state space .    before giving the formal definition of the program",
    ", some notions must be introduced .",
    "let @xmath24 denote the set of all finite and infinite sequences of the elements of set @xmath25 .",
    "@xmath26 includes the infinite sequences ; @xmath27 contains the finite ones .",
    "so , @xmath28 and @xmath29 .",
    "the length of the sequence @xmath30 is @xmath31 , the value of which is @xmath32 if the sequence is infinite .",
    "let @xmath12 be the so - called base state space and @xmath33 be the set of all states which belong to the state spaces @xmath13 whose subspace is @xmath12 , i.e. @xmath34 . the relation @xmath35 is a _ * program * _ over @xmath12 , if    1 .",
    "@xmath36 ( domain of @xmath37 ) , 2 .",
    "@xmath38 ( the last state of the finite executions of the range of @xmath37 ) , 3 .",
    "@xmath39 and @xmath40 and @xmath41 .",
    "the variables of the base state space are the _ * base variables * _ ; the other variables are the _ * auxiliary variables * _ of the program .",
    "the concept of the program allows to create and destroy new components ( variables ) during an execution , so the state space changes dynamically .",
    "all new components have to be destroyed at the termination , at the very latest , but the base variables should never be removed .",
    "the current state always contains the components of the base state space .",
    "the following three definitions will outline that the base state space of any program is denoted arbitrarily .",
    "the base variables of a program can be extended , restricted or renamed without changing the essence of the program .",
    "the base variables of any program can be renamed easily without the execution of the program is changed . however ,",
    "if the new name of a base variable would be identical to an auxiliary variable s name then this auxiliary variable is given a new , unique name .",
    "let the statespace @xmath12 and @xmath13 be equivalent , i.e. if @xmath6 and @xmath7 then there exists a bijection @xmath14 so that @xmath42 .",
    "let @xmath37 be a program over the state space @xmath12 .",
    "let the name of the auxiliary variables of @xmath37 be @xmath43 ( @xmath44 ) and a bijection @xmath45 so that @xmath46",
    ". the program over @xmath13 is called the _ * variable renaming of s onto @xmath47 * _ if its executions are identical to the executions of @xmath37 , but in their all states , the variable name @xmath2 is replaced by @xmath48 and the variable name @xmath49 is replaced by @xmath50 .    not only can the name of the variables be changed but also the number of the components of the base state space : this state space can be extended with new variables , or some base variables can be degraded to auxiliary varibles .",
    "the next definition shows that the base state space can be extended with a new component .",
    "the states of the executions can be extended with this new component if it is not the auxiliary variable of the original program .",
    "otherwise if this component was an auxiliary variable , then it becomes a base variable ; it should not be created and destroyed it , its life expands over the whole execution .",
    "let @xmath37 be a program over the state space @xmath6 and the variable name @xmath51 where @xmath52 .",
    "( this @xmath51 may denote one of the auxiliary variables of @xmath37 or a totally new variable . )",
    "let @xmath53 be the statespace @xmath54 .",
    "the _ * extension of s onto @xmath55 * _ is the program ( denoted by @xmath56 ) whose base state space is @xmath53 and for all @xmath57    @xmath58 = @xmath59:$ ] + if @xmath60 then @xmath61 and @xmath62 + if @xmath63 then @xmath64 .",
    "it is easy to generalize this definition in case the state space @xmath12 is a subspace of the state space @xmath53 .    the following definition shows how a base variable can be degraded to an auxiliary variable : the first step creates it and the last step destroys it .    let @xmath37 be a program over the state space @xmath6 and let @xmath53 be the subspace of a. the _ * restriction of s onto @xmath55 * _ is the program ( denoted by @xmath65 ) whose base state space is @xmath53 and for all @xmath66 :    @xmath67 = = = \\ { @xmath68 where @xmath69 } + @xmath70 \\ { @xmath71 where @xmath72 } .",
    "the base state space of a program can be renamed , extended or restricted several times , thus the base state space can be totally transformed .",
    "but these transformations can change only the base state space and not the program .",
    "the essence of the executions of the program remains the same .",
    "the renamed , extended and restricted program hardly differs from its original version .",
    "two programs are _ * identical * _ if they can transform into the same program , using extensions , restrictions and renaming .",
    "we have introduced a new concept of the program . now let us observe what kinds of effects this modification has on the original programming model .",
    "the new concept of the program smuggles the dynamic property of the program back to the static programming model @xcite developed at etvs lornd university .",
    "certainly , the fact that a program can create and destroy auxiliary variables is not a brilliant discovery .",
    "the difficulty of our investigation was to find out how this dynamic property can be embedded into the programming model described in the static point of view .",
    "the most important element of our concept is the base state space .",
    "it can be seen as the interface of the program .",
    "it determines the components through which the program can communicate , and can make contact with its environment .",
    "only the base variables can get value from outside before the program starts , and their value can be asked after the termination .",
    "the program becomes very flexible because its base state space can be changed easily .",
    "this property is reflected in the fact that the same program can possess different interfaces depending on the problem to be solved .",
    "the aim of a program can be changed by altering its base state space whereas its operation can not be changed .      despite the above modification , the definition of the solution",
    "can be preserved @xcite .",
    "the only thing that must be done is to redefine the concept of the _ * effect * _ of the program because the definition of the solution relies on it .",
    "now we will repeat all definitions that are important to describe the concept of solution .",
    "let the problem generally be a relation @xmath73 where @xmath12 is a state space .",
    "let @xmath37 be a program over @xmath12 .",
    "the relation @xmath74 is the effect of @xmath37 if    1 .",
    "@xmath75 2 .",
    "@xmath76 .    the program @xmath37 is said to solve the problem @xmath77 if    1 .",
    "@xmath78 2 .",
    "@xmath79    the definition of the _ * solution * _ supposes that the state space of the problem is identical to the base state space of the program . as the base state space can be chosen arbitrarily , the program can be extended , restricted or renamed in order that its base state space is identical to the state space of the problem .",
    "since programs of this kind are identical , if one of them can solve the problem , so can the others .    moreover , if the effects of the programs @xmath80 and @xmath81 are identical over all common base state spaces ( @xmath82 ) and if one of them can solve a problem , so can the others",
    ". in this case these programs are called _ * equivalent*_. this relation is reflexive , symmetrical and transitive , thus it is an equivalence relation .",
    "consequently , if one program belonging to an equivalence class can solve a problem , then every program derived from this class can also solve it .    in the original programming model , the definition of the solution",
    "must be generalized @xcite when the state spaces of the problem and the program are different .",
    "now , our new concept is used to avoid this .",
    "it is enough to fit the base state space of the program to the state space of the problem and transform the program onto this common state space .",
    "the original programming model contains many important results that can be used in the verification of programs .",
    "it is apparent that these results are not based directly on the concept of the program ; except for the effect of the program .",
    "the definition of the effect of the program has not been changed because the new definition of the program fixes that the start state and the end state of the finite execution are in the same state space ( that is , the base state space ) .",
    "accordingly , all earlier results , namely dijkstra s weakest precondition @xcite , the theorem of the specification or the derivation rules @xcite of the program constructions @xcite are used in unalterable forms .    certainly , in the definitions of program constructions , the components ( programs and conditions ) which are the parts of the construction have to be on the same base state space . accordingly , before making one of the constructions , this common base state space has to be agreed on .",
    "the concept of real subprograms , which have got parameter variables , could not be introduced into the original programming model because the program has got an unvarying state space , thus local variables can not be created during the execution , so parameter variables , which are local variables , can not be used .",
    "now , the situation is changed . in our new programming model , the concept of the subprograms may be defined .",
    "first and foremost the subprogram is a program . it can be executed independently ; it has got own base state space .",
    "its only speciality is that it can be built into another program .",
    "( this is the host program . )",
    "each program , including subprograms , is equivalent to an assignment .",
    "this assignment is appropriate to identify the subprogram that is equivalent to it .",
    "accordingly , in an arbitrary program description language , a subprogram can be denoted with this assignment .",
    "the variables of this assignment , which are the formal parameters , form the base state space of the subprogram .",
    "the variables at the left - hand side of the assignment are the output parameter variables ; the ones at the right - hand side are the input parameter variables .",
    "( for simplicity s sake , we shall restrict our consideration to assignments where a parameter variable does not occur more than once . )",
    "this assignment can be also used as a calling statement in the description of the host program .",
    "certainly , in the calling statement , the parameter variables can be substituted by actual parameters ( arguments ) , which are the expressions ( often , they are only variables ) of the host program .",
    "an output variable can not be changed by an expression more general than a variable .",
    "the number and the type of the formal and current parameters must be the same . at this calling statement ,",
    "the execution of the host program is interrupted , the control switches over the subprogram , the values of current parameters are given to the formal parameter variables , and the subprogram is executed .",
    "after the termination of the subprogram , the values of the output parameter variables are recopied to the appropriate current parameter variables .",
    "( here , two kinds of parameter passing have been defined : passing by value and passing by value - result but other passing methods may be introduced . )    the base state space of the subprogram is the interface between the subprogram and the host program . at the beginning of the subprogram , the variables of this base state space will get their initial values from the current state of the host program . at the end of it",
    "these variables give their values to the variables of the host program .",
    "the parameter variables and other local variables of the subprogram are created when the subprogram is called and destroyed at the termination of the subprogram .",
    "in addition , the usage of subprograms permits recursive callings because a subprogram can call itself . after each calling , the parameter and the local variables of the subprogram are created again and again without the error message  out of memory  because the memory of the abstract program is infinite .    during planning , it is convenient that all the current variables of the host program are treated as global with respect to the subprogram that is called by the host program .",
    "the applied programming style and the facilities of the selected programming language determine if these global variables can be used directly in the subprogram or not . obviously , their use has to be forbidden if we want to guarantee the independency of the subprogram",
    ".    we can make difference between the calling statement and the calling expression . in the latter case",
    ", only the right - hand side of the subprogram s head appears inside an expression of the host program , which contains actual parameters instead of formal parameter variables .",
    "after the termination , the result value of the left - hand side of the head is given back to the place of the calling expression in the host program .",
    "certainly , the abstract program description language which is used for planning has to be extended with the notation of the subprogram and of its calling including the connection between the actual parameters and the parameter variables .    to sum up",
    "the introduction of the concept of the subprograms makes it possible to design subprograms during planning and not only during implementation .",
    "this paper is supported by the european union and co - financed by the european social fund ( grant agreement no .",
    "tmop 4.2.1/b-09/1/kmr-2010 - 0003 ) .",
    "link:fa@inf.elte.hu[fthi ] , http://aszt.inf.elte.hu/~hz/[z .",
    "horvth ] , j. nyky - gaizler , a relational model of transformation in programming , _ proc .",
    "3th international conference on applied informatics _",
    ", eger - noszvaj , hungary , august 2428 .",
    "1997 .",
    "workgroup on relational models of programming   .",
    "link:fa@inf.elte.hu[fthi ] et al . , some concepts of a relational model of programming , l. varga ed . , _ proc .",
    "4th symposium on programming languages and software tools _ , visegrd , hungary , june 8 - 14 , 1995 , 434446 ."
  ],
  "abstract_text": [
    "<S> the aim of this paper is to alter the abstract definition of the program of the theoretical programming model which has been developed at etvs lornd university for many years in order to investigate methods that support designing correct programs . </S>",
    "<S> the motivation of this modification was that the dynamic properties of programs appear in the model . </S>",
    "<S> this new definition of the program gives a hand to extend the model with the concept of subprograms while the earlier results of the original programming model are preserved . </S>"
  ]
}