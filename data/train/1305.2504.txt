{
  "article_text": [
    "the hereditary material of individuals is arranged along structures called chromosomes which may be linear or circular .",
    "the latter of these are found in bacteria and we focus here only on the linear case . within a species",
    "each individual has a number of copies of each of a number of homologous ( i.e. matching ) chromosomes .",
    "thus , for example , humans have 22 homologous pairs ( called diploid ) while many organisms exist with four ( tetraploid ) , six ( hexaploid ) or eight ( octaploid)chromosomes .",
    "less commonly there may be an odd number of chromosomes .",
    "the implication of the hereditary units ( genes ) being arranged along chromosomes is that mendel s 2nd law ( that distinct characters are transmitted independently ) is violated .",
    "for ease we consider a diploid individual and suppose we have a particular homologous pair of chromosomes and some @xmath0 genes arranged along that chromosomes . during the formation of germ cells ( meiosis ) a new chromosome is formed from the pair .",
    "if we denote the genes along the chromosome of the individual obtained from its mother as @xmath1 and from its father as @xmath2 ( where each vector is of length @xmath0 ) then the chromosome formed will be some binary string e.g. @xmath3 with some associated probability .",
    "thus the genes are recombined i.e. mixed from the grandparents while the order is ( generally ) conserved .",
    "further the genes will take values referred to as alleles , and the alleles along the chromosomes will be transmitted to the germ cell unchanged unless some mutation occurs .",
    "there are two important features of the recombination process .",
    "the first is that this structure creates correlations between the transmission of genes which are , in some sense , close to each other along the chromosome .",
    "this has both the potential to allow blocks of genes to be inherited together as recombination is suppressed in certain regions , and also to rearrange alleles into potentially evolutionarily advantageous combinations .",
    "we can also potentially infer the close linkage ( position ) of genes through the detection of correlations .",
    "there is however , as proved in @xcite , a steady weakening of these correlations through time and the asymptotic mutual independence of the allele frequencies , in the absence of selection .",
    "thus the correlations can only be used for a limited time from founder population in which a correlation fortuitously existed .",
    "quite a while later @xcite established bounds on the actual rates of convergence towards the independence of the allele frequencies .",
    "the idea of using geiringer theorem in evolutionary computation with the aim of predicting the outcome of repeated applications of crossover has been introduced in @xcite and motivated the development of edas ( estimation of distribution algorithms ) .",
    "the classical version of the theorem is stated in terms of a discrete - time quadratic system  infinite population \" model very much as follows : let @xmath4 denote the search space of a given genetic algorithm .",
    "( intuitively , @xmath0 is the number of loci and @xmath5 is the set of alleles corresponding to the @xmath6th gene . )",
    "denote by @xmath7 the collection of all probability distributions on @xmath8 .",
    "now fix a probability distribution @xmath9 and consider the sequence of probability distributions @xmath10 where @xmath11 and @xmath12 denotes the probability of obtaining the individual @xmath13 from the parents @xmath6 and @xmath14 after crossover . here",
    "crossover can be thought of as an operator which takes a pair of elements of the search space ( the parents ) and produces another element of the search space ( the child ) by mingling the alleles of the parents .",
    "this will be discussed in more detail later in the paper .",
    "denote by @xmath15 the marginal distribution of @xmath16 on @xmath5 .",
    "the classical geiringer theorem says that @xmath17 ( meaning that the frequency of occurrence of an individual @xmath18 under the limiting distribution @xmath19 is just the product of the frequencies of @xmath20 under the distributions @xmath15 ) . in @xcite",
    "this theorem has been generalized to cover the cases of variable - length ga s and homologous linear gp crossover .",
    "the limiting distributions of the frequency of occurrence of individuals belonging to a certain schema under these algorithms have been computed .",
    "an alternative approach that provides estimates on the convergence rates towards the limiting distribution of the quadratic dynamical system @xmath21 is provided in @xcite .",
    "a rather general and powerful finite - population version of geiringer theorem based on the unique uniform stationary distribution of the markov chain of populations on the orbit of the  joint \" group action of bijective recombination transformations has been established in @xcite .",
    "knowing that the stationary distribution of this markov chain is uniform , for the most types of traditional gas and gp with homologous recombination it is quite routine to derive the the limiting frequency of occurrence of various schemata and , not in vain , the corresponding formulas come out exactly the same as in the infinite - population model . intuitively speaking",
    ", this happens due to the fact that as the sample size gets larger and larger , sampling with replacement ( i.e. binomial sampling ) approaches in distribution sampling without replacement ( i.e. hypergeometric sampling ) .",
    "a rigorous argument does require careful analysis and will be presented in a sequel research paper .",
    "apart from the already established infinite - population versions of the geiringer theorems , the methodology for deriving such theorems allows one to obtain a formula for the limiting frequency of occurrence of various schemata for non - linear gp with homologous recombination ( see @xcite ) without much effort .",
    "gieringer - like theorems for non - homologous recombination remained an open question until recently , see @xcite , when such a theorem has been derived in the setting of pomdps ( partially observable markov decision processes ) and model - free reinforcement learning with the aim of enhancing action evaluation at the chance nodes .",
    "the technical challenges have been overcome thanks to a lovely application of the classical and extremely useful triviality known as the markov inequality ( see , for instance , @xcite ) and enhancing the methodology for deriving the geiringer - like results in @xcite through exploiting a slightly extended lumping quotients of markov chains technique that has been successfully developed , improved and exploited to estimate stationary distributions of markov chains modeling eas in a series of articles : @xcite , @xcite , @xcite and @xcite .",
    "finally , the later version of the theorem has been further generalized to allow recombination over arbitrary set covers , rather than being limited to equivalence relations using the particular case in @xcite in conjunction with the tools mentioned above in @xcite .",
    "while the original purpose of the last two finite - population geiriger - like theorems is taking advantage of the intrinsic similarities within the state - action set encountered by a learning agent to evaluate actions with the aim of selecting an optimal one , the parallel algorithms on the evolving digraph where the nodes are states and actions are edges from a current state to the one obtained upon executing an action , that are motivated by the theorems exhibit similarities to the way hebbian learning takes place in biological neural networks that is further supported by andree ehresmann s category - theoretic model of cognitive processes called a",
    " memory evolutive system \" ( see , for instance , @xcite , @xcite , @xcite , @xcite and many more related articles ) . in the current article",
    "we explain the new theorems as well as the algorithms they motivate , how such algorithms may fit the memory evolutive systems model that hopefully provides a deeper understanding of cognitive processes and makes a further step in the development of intelligent computational systems .",
    "a great number of questions in machine learning , computer game intelligence , control theory , and in cognitive processes in general involve decision - making by an agent under a specified set of circumstances . in the most general",
    "setting , the problem can be described mathematically in terms of the state and action pairs as follows .",
    "a state - action pair is an ordered pair of the form @xmath22 where @xmath23 is the set of actions ( or moves , in case the agent is playing a game , for instance ) that the agent is capable of taking when it is in the state ( or , in case of a game , a state might be sometimes referred to as a position ) @xmath24 .",
    "due to randomness , hidden features , lack of memory , limitation of the sensor capabilities etc , the state may be only partially observable by the agent .",
    "mathematically this means that there is a function @xmath25 ( as a matter of fact , a random variable with respect the unknown probability space structure on the set @xmath26 ) where @xmath26 is the set of all states which could be either finite or infinite while @xmath27 is the set ( usually finite due to memory limitations ) of observations having the property that whenever @xmath28 ( i.e. whenever the agent can not distinguish states @xmath29 and @xmath30 ) then the corresponding state action pairs @xmath31 and @xmath32 are such that @xmath33 ( i.e. the agent knows which actions it can possibly take based only on the observation it makes ) .",
    "the general problem of reinforcement learning is to decide which action is best suited given the agent s knowledge ( that is the observation that the agent has made as well as the agent s past experience ) . in case when immediate payoffs are not known , self - simulated random trials , named _",
    "rollouts _ by the monte - carlo tree search community , until the terminal state ( or until a payoff value is available ) are implemented and , based on a sufficiently large sample of such rollouts , an agent has to decide which actions are most advantageous in which states . under a reasonable assumption that adaptation and unsupervised learning in biological organisms takes place largely based on trial followed by reward mechanisms ,",
    "the corresponding learning models are very much similar . thus ,",
    "suppose a sequence of independent rollouts has been simulated or , in case of adoptive learning agents , such as robots or biological systems , gained via some learning experience .",
    "due to alterations within competitor s , opponent s or enemy s strategies and unavailability of immediate feedback , reward or payoff , the combinatorial explosion in the number of possibilities that could take place after an execution of the same action at a given state , even in case when the learning agent has just several actions to choose from at a given state , is tremendous .",
    "the situation is significantly exacerbated due to the unknown information and randomness within the environment , that is likely to cause drastic differences in the eventual payoffs after the same action starting at a specified observable state has been taken . at the same time , only a limited sample of rollouts ( or trials ) is available for action evaluation .",
    "needless to say , optimal action evaluation under such circumstances is an extremely complex and challenging task . while the unfortunate reality that the total number of observable states is often drastically limited comparing to the total overall number of states ( i.e. when the non - observable information is taken into account ) , contributes to the overall complexity , it turns out , that this could also be exploited to design more effective action - evaluation policies and the design of such policies is motivated by the geiringer - like theorems . for the sake of completeness , we now explain these ideas and state the geiringer - like theorem established in @xcite in a mathematically rigorous fashion .",
    "let @xmath26 denote the set of states ( enormous but finite in this framework ) .",
    "formally each state @xmath34 is an ordered pair @xmath35 where @xmath36 is the set of actions an agent can possibly take when in the state @xmath37 .",
    "let @xmath38 be an equivalence relation on @xmath26 .",
    "without loss of generality we will denote every equivalence class by an integer @xmath39 so that each element of @xmath26 as an ordered pair @xmath40 where @xmath41 and @xmath42 with @xmath43 being some finite alphabet . with this notation @xmath44 iff @xmath45 . intuitively , @xmath26 is the set of all possible states and @xmath38 is the similarity relation on @xmath26 where two states are equivalent under @xmath38 if and only if they contain identical observable information .",
    "we will also require that for two equivalent states @xmath46 and @xmath47 under @xmath38 there are bijections @xmath48 and @xmath49 . for the time being , these bijections should be obvious and natural from the representation of the environment ( and actions ) and reflect the similarity between these actions .    [ treerootedbychancenode ]",
    "suppose we are given a state @xmath50 and a sequence @xmath51 of actions in @xmath36 ( it is possible that @xmath52 for @xmath53 ) .",
    "we may then call @xmath37 a _ root state _ , or a _ state in question _ , the sequence @xmath51 , the _ sequence of actions under evaluation _ and the set of actions @xmath54 for some @xmath6 with @xmath55 , the set of actions under evaluation .    [ rolloutdefn ] a _ rollout _ with respect to the state in question @xmath50 and an action @xmath56 is a sequence of states following the action @xmath57 and ending with a terminal label @xmath58 where @xmath59 is an arbitrary set of labels represents a terminal state that we can assign a numerical value to via a function @xmath60 .",
    "the reason we introduce the set @xmath59 of formal labels as opposed to requiring that each terminal label is a rational number straight away , is to avoid confusion in the upcoming definitions ] , which looks as @xmath61 . for technical reasons that will become obvious later we will also require that @xmath62 for @xmath53 ( it is possible and common to have @xmath63 though ) . we will say that the total number of states in a rollout ( which is @xmath64 in the notation of this definition ) is the _ height _ of the rollout .    [ crossoverconvrepresrem ] in the paragraph preceding definition  [ treerootedbychancenode ] we have introduced a convenient notation for states to emphasize their respective equivalence classes . with such notation a typical rollout would appear as a sequence @xmath65 with @xmath66 while @xmath67 . according to the requirement in definition  [ rolloutdefn ] , @xmath68 for @xmath69 .",
    "as mentioned in the beginning of the current section , a single rollout provides rather little information about an action particularly due to the combinatorial explosion in the branching factor of possible actions of the agent , randomness , unavailable information etcetera .",
    "normally a large , yet comparable with total resource limitations , number of rollouts ( or trials ) is simulated ( or attempted ) to evaluate the actions at various states . the challenging question that the geiringer - like theorem in @xcite addresses is how one can take the full advantage of the available limited size sample of rollouts ( or trials ) . in the language of evolutionary computing community",
    "such samples are known as _",
    "populations_.    [ popofrolloutsdefn ] given a state in question @xmath50 and a sequence @xmath51 of actions under evaluation ( in the sense of definition  [ treerootedbychancenode ] ) then a _ population _",
    "@xmath70 with respect to the state @xmath50 and the sequence @xmath51 is a sequence of rollouts @xmath71 where @xmath72 .",
    "just as in definition  [ rolloutdefn ] we will assume that @xmath73 whenever @xmath53 ( which , in accordance with definition  [ rolloutdefn ] , is as strong as requiring that @xmath73 whenever @xmath53 or @xmath74 ) moreover , we also assume that the terminal labels @xmath75 are also all distinct within the same population , i.e. for @xmath53 the terminal labels @xmath76 , yet the complexity of the statements of our main theorems will be mildly alleviated . ] in a very special case when @xmath77 we will say that the population @xmath70 is _",
    "homologous_. loosely speaking ,",
    "a homologous population is one where equivalent states can not appear at different  heights \" .",
    "[ popofrolloutsrem ] each rollout @xmath78 in definition  [ popofrolloutsdefn ] is started with the corresponding move @xmath79 of the sequence of moves under evaluation ( see definition  [ treerootedbychancenode ] ) .",
    "it is clear that if one were to permute the rollouts without changing the actual sequences of states the corresponding populations should provide identical values for the corresponding actions under evaluation .",
    "in fact , most authors in evolutionary computation theory ( see @xcite , for instance ) do assume that such populations are equivalent and deal with the corresponding equivalence classes of multisets corresponding to the individuals ( these are sequences of rollouts ) . nonetheless , when dealing with finite - population geiringer - like theorems it is convenient for technical reasons which will become clear when the proof is presented ( see also @xcite and @xcite ) to assume the _ ordered multiset model _",
    "i.e. the populations are considered formally _",
    "distinct _ when the individuals are permuted . incidentally , ordered multiset models are useful for other types of theoretical analysis in @xcite and @xcite .",
    "[ poprolloutex ] a typical population with the convention as in remark  [ popofrolloutsrem ] might look as in figure  [ popofrollsfig ] .",
    "the height of the leftmost rollout in figure  [ popofrollsfig ] would then be @xmath80 since it contains @xmath80 states .",
    "the reader can easily see that the heights of the rollouts in this population read from left to right are @xmath80 , @xmath81 , @xmath82 , @xmath80 , @xmath82 , @xmath83 and @xmath81 respectively .    .",
    "distinct actions under evaluation ( see definition  [ treerootedbychancenode ] ) are denoted by different letters of greek alphabet.,height=377 ]    the main idea is that equivalent states should be interchangeable due to the unavailable information , as discussed above . in the language of evolutionary computing , such a swap of states",
    "is called a crossover . in order to obtain the most out of a sample ( population in our language ) of the parallel rollouts",
    "it is desirable to explore all possible populations obtained by making various swaps of the corresponding rollouts at the equivalent positions .",
    "computationally this task seems expensive if one were to run the type of genetic programming described precisely below , yet , it turns out that we can predict exactly what the limiting outcome of this  mixing procedure \" would be .",
    "we now continue with the rigorous definitions of crossover .",
    "representation of rollouts suggested in remark  [ crossoverconvrepresrem ] is convenient to define crossover operators for two given rollouts .",
    "we will introduce two crossover operations below .",
    "[ rolloutpartcrossdefn ] given two rollouts @xmath84 and @xmath85 of lengths @xmath86 and @xmath87 respectively that share no state in common ( i.e. , as in definition  [ rolloutdefn ] , ) there are two ( non - homologous ) crossover ( or recombination ) operators we introduce here . for an equivalence class label @xmath88 and letters",
    "@xmath89 define the _ one - point non - homologous crossover _",
    "transformation @xmath90 where + @xmath91 and + @xmath92 if [ @xmath93 and either @xmath94 and @xmath95 or @xmath96 and @xmath97 and @xmath98 otherwise .",
    "likewise , we introduce a _ single position swap crossover _",
    "@xmath99 where + @xmath100 + while + @xmath101 if [ @xmath93 and either @xmath94 and @xmath95 or @xmath96 and @xmath97 and @xmath102 otherwise .",
    "in addition , a singe swap crossover is defined not only on the pairs of rollouts but also on a single rollout swapping equivalent states in the analogous manner : if @xmath103@xmath104 and [ @xmath68 and either @xmath105 and @xmath106 or @xmath107 and @xmath108 then @xmath109@xmath110 and , of course , @xmath111 fixes @xmath112 ( i.e. @xmath113 ) otherwise .    [ distconvrem ]",
    "notice that definition  [ rolloutpartcrossdefn ] makes sense thanks to the assumption that no rollout contains an identical pair of states in definition  [ rolloutdefn ] .",
    "just as in case of defining crossover operators for pairs of rollouts , thanks to the assumption that all the states in a population of rollouts are formally distinct ( see definition  [ popofrolloutsdefn ] ) , it is easy to extend definition  [ rolloutpartcrossdefn ] to the entire populations of rollouts . intuitively , the one - point crossover transformations correspond to the fact that due to the unavailable and unpredictable information , either of the alternative courses of events could take place following either of the indistinguishable states ( i.e. equivalent states ) while the single swap crossovers correspond to the fact that either of the non - observable components of the state could have arose .",
    "thus , to get the most informative picture out of the sample of rollouts one would want to run the genetic programming routine without selection and mutation and using only the crossover operators specified above for as long as possible and then , in order to evaluate a certain action @xmath57 , collect the weighted average of the terminal values ( i. e. the values assigned to the terminal labels via some real - valued assignment function ) of all the rollouts starting with the action @xmath57 that ever occurred in the process .",
    "we now describe precisely what the process is and give an example .",
    "[ recombactonpopsdef ] given a population @xmath70 and a transformation of the form @xmath114 , there exists at most one pair of distinct rollouts in the population @xmath70 , namely the pair of rollouts",
    "@xmath115 and @xmath116 such that the state @xmath117 appears in @xmath115 and the state @xmath118 appears in @xmath116 .",
    "if such a pair exists , then we define the recombination transformation @xmath119 where @xmath120 is the population obtained from @xmath70 by replacing the pair of rollouts @xmath121 with the pair @xmath122 as in definition  [ rolloutpartcrossdefn ] . in any other case we do not make any change , i.e. @xmath123 . the transformation @xmath124 is defined in an entirely analogous manner with one more amendment : if the states @xmath117 and @xmath118 appear within the same individual ( rollout ) , call it @xmath125 and the state @xmath117 precedes the state @xmath118 , then these states are interchanged obtaining the new rollout @xmath126 of course",
    ", it could be that the state @xmath118 precedes the state @xmath117 instead , in which case the definition would be analogous : if @xmath127 then replace the rollout @xmath112 with the rollout @xmath128    [ bijectrem ] it is very important for the general finite - population geiringer theorem that each of the crossover transformations @xmath114 and @xmath129 is a bijection on their common domain , that is the set of all populations of rollouts ( see @xcite or @xcite for details on the finite - population version of the theorem that s based on markov chains induced by group actions ) . as a matter of fact , the reader can easily verify by direct computation from definitions  [ recombactonpopsdef ] and [ rolloutpartcrossdefn ] that each of the transformations @xmath114 and @xmath129 is an involution on its domain , i.e. @xmath130 we have @xmath131 where @xmath132 is the identity transformation .",
    "examples below illustrate the important extension of recombination operators to arbitrary populations pictorially .",
    "[ popcrossex1 ] continuing with example  [ poprolloutex ] , suppose we were to apply the recombination ( crossover ) operator @xmath133 to the population of seven rollouts pictured in figure  [ popofrollsfig ] .",
    "the unique location of states @xmath134 and @xmath135 in the population is emphasized by the boxes in figure  [ popofrollsfigsq1 ] below . after applying the crossover operator @xmath133",
    "we obtain the population pictured on figure  [ popofrollsaftercross1 ] .     and",
    "@xmath135 in the population pictured in figure  [ popofrollsfig ] are enclosed in dashed squares.,height=377 ]     and @xmath135 in the population pictured in figure  [ popofrollsfigsq1 ] are pruned and then swapped.,height=377 ]    on the other hand , applying the crossover transformation @xmath136 to the population in figures  [ popofrollsfig ] and [ popofrollsfigsq1 ] results in the population pictured on figure  [ popofrollsaftercross2 ] .     and",
    "@xmath135 are enclosed within the dashed squares in figure  [ popofrollsfigsq1 ] are swapped.,height=377 ]    [ popcrossex2 ] consider now the population @xmath137 pictured in figure  [ popofrollsfig2 ] .",
    "suppose we apply the transformations @xmath138 and @xmath139 to the population @xmath137 .",
    ".,height=377 ]    the states @xmath140 and @xmath141 are enclosed within the dashed squares in figure  [ popofrollsfig3 ] .     and @xmath141 are enclosed within the dashed squares.,height=377 ]    since these states appear within the same rollout , according to definition  [ recombactonpopsdef ] , the crossover transformation @xmath138 fixes the population @xmath137",
    "( i.e. @xmath142 ) . on the other hand ,",
    "the population @xmath143 is pictured on figure  [ popofrollsaftercross3 ] .     and",
    "@xmath141 which are enclosed within the dashed squares on figure  [ popofrollsfig3 ] are interchanged to obtain the population @xmath143 pictured above.,height=377 ]    evidently , running the ",
    "genetic programming \" routine with recombination only , as described above , for a very long time is computationally expensive , but , fortunately , thanks to to the geiringer - like theorem in @xcite we can predict the limiting frequency of occurrence of various  schemata \" or rollouts as the iteration time @xmath144 . furthermore , this prediction leads to dynamic parallel action - evaluation algorithms based on an exponentially larger sample of rollouts obtained after such an  infinitely long time \" gp - routine , that resemble hebbian learning mechanisms as we intend to demonstrate through andree ehresmann s  memory evolutive systems \" model , the essentials of which will be briefly described in the next section .",
    "we now proceed with the relevant definitions .",
    "[ schemaformctpopdefholland ] given a state @xmath35 in question ( see definition  [ treerootedbychancenode ] ) , a rollout _ holland - poli schema _ is a sequence consisting of entries from the set@xmath145 of the form @xmath146 for some @xmath147 such that for @xmath148 we have @xmath149 , @xmath150 when @xmath151 represents an equivalence class of states , and @xmath152 could represent either a terminal label if it is a member of the set of terminal labels @xmath59 , or any substring defining a valid rollout if it is a @xmath153 sign . for @xmath154 there is a unique schema of the form @xmath153 .",
    "every schema uniquely determines a set of rollouts @xmath155 that fit the schema in the sense mentioned above .",
    "we will often abuse the language and use the same word schema to mean either the schema @xmath156 as a formal sequence as above or schema as a set @xmath157 of rollouts which fit the schema .",
    "for example , if @xmath156 and @xmath158 is a schema , we will write @xmath159 as a shorthand notation for @xmath160 where @xmath161 denotes the usual intersection of sets . just as in definition",
    "[ rolloutdefn ] , we will say that @xmath64 , the number of states in the schema @xmath156 is the _ height _ of the schema @xmath156 .",
    "we illustrate the important notion of a schema with an example below :    [ schemadefex ] suppose we are given a schema @xmath162 .",
    "then the rollouts + @xmath163 and @xmath164 or one could say that both of them fit the schema @xmath156 . on the other hand the rollout @xmath165 ( or does not fit the schema @xmath156 ) unless @xmath166 .",
    "a rollout @xmath167 does not fit the schema @xmath156 either since @xmath168 .",
    "neither of the rollouts above fit the schema @xmath169 since the appropriate terminal label is not reached in the @xmath170 position .",
    "an instance of a rollout which fits the schema @xmath158 would be @xmath171 .    in evolutionary computation geiringer - like results",
    "address the limiting frequency of occurrence of a set of individuals fitting a certain schema after repeated applications of crossover transformations as in definition  [ recombactonpopsdef ] .",
    "( see @xcite , @xcite , @xcite and @xcite ) .",
    "the finite population geiringer theorem , originated in @xcite and extended to non - homogenous time markov processes in section 6 of @xcite , states that the unique stationary distribution of the markov chain of all populations potentially encountered in the process of repeated crossover transformations is the uniform distribution and holds under rather mild assumptions on the family of all such recombination transformations .",
    "we invite the readers to study @xcite for an in - depth understanding . in the current paper",
    "we present only a very brief description of the corresponding markov chain and the notion of the  limiting frequency of occurrence \" that is sufficient for a surface - level understanding of what the theorem says . the geiringer - like theorem that motivates the novel parallel algorithms resembling hebbian learning mechanisms",
    "is stated purely in terms of the quantities appearing in the following few definitions .",
    "[ popstatecountdowndef ] for any action under evaluation @xmath57 define a set - valued function @xmath172 from the set @xmath173 of populations of rollouts to the power set of the set of natural numbers @xmath174 as follows : @xmath175 and at least one of the rollouts in the population @xmath70 fits the holland schema @xmath176 .",
    "likewise , for an equivalence class label @xmath41 define a set valued function on the populations of size @xmath177 , as @xmath178 and @xmath179 and a rollout @xmath112 in the population @xmath70 such that @xmath180 and @xmath181 an @xmath182 and a rollout @xmath112 in the population @xmath70 such that @xmath183 . in words , the set @xmath184 is the set of all equivalence classes together with the terminal labels which appear after the equivalence class @xmath6 in at least one of the rollouts from the population @xmath70 .",
    "finally , introduce one more function , namely @xmath185 by letting @xmath186 , that is , the total number of terminal labels ( which are assumed to be all formally distinct for convenience ) following the equivalence class @xmath6 in a rollout of the population @xmath70 .",
    "we illustrate definition  [ popstatecountdowndef ] in example  [ popschemadownfunctex ] below .",
    "[ popschemadownfunctex ] continuing with example  [ poprolloutex ] , we return to the population @xmath70 in figure  [ popofrollsfig ] . from the picture",
    "we see that the only equivalence class @xmath6 such that a rollout from the population @xmath70 fits the holland schema @xmath187 is @xmath188 so that @xmath189 . likewise , the only equivalence class following the action @xmath190 is @xmath191 , the only equivalence class following the action @xmath192 is @xmath81 and the only one following @xmath193 is @xmath82 so that @xmath194 , @xmath195 and @xmath196 .",
    "the only equivalence classes @xmath6 following the action @xmath197 in the population @xmath70 are @xmath198 and @xmath199 so that the set @xmath200 .",
    "likewise the fragment @xmath201 appears in the first ( leftmost ) rollout in @xmath70 , @xmath202 in the second rollout , @xmath203 in the forth tollout and @xmath204 in the last , seventh rollout .",
    "no other equivalence class or a terminal label follows the equivalence class of the state @xmath83 in the population @xmath70 and so it follows that @xmath205 and @xmath206 .",
    "likewise , equivalence class @xmath83 follows the equivalence class @xmath191 in the second rollout , @xmath207 follows @xmath191 in the forth rollout , @xmath81 follows @xmath191 in the fifth rollout and @xmath208 follows @xmath191 in the last , seventh rollout .",
    "the only terminal label that follows the equivalence class @xmath191 is @xmath209 in the @xmath210 rollout .",
    "thus we have @xmath211 and @xmath212 .",
    "we leave the reader to verify that @xmath213 @xmath214 @xmath215 @xmath216 and , finally , @xmath217 .    [ totalnumberoftermlblsrem ] note that according to the assumption that all the terminal labels within the same population are distinct ( see definition  [ popofrolloutsdefn ] together with the comment in the footnote there ) .",
    "but then , since every rollout ends with a terminal label , we must have @xmath218 ( of course , only finitely many summands , namely these equivalence classes that appear in the population @xmath70 may contribute nonzero values to @xmath219 ) where @xmath177 is the number of rollouts in the population @xmath70 , i.e. the size of the population @xmath70 .",
    "for instance , in example  [ popschemadownfunctex ] @xmath220 and there are totally @xmath207 equivalence classes , namely @xmath221 and @xmath207 that occur within the population in figure  [ popofrollsfig ] so that we have @xmath222 .",
    "another important and related definition we need to introduce is the following :    [ popstateorderseqdef ] given a population @xmath70 and integers @xmath6 and @xmath223 representing equivalence classes , let @xmath224 loosely speaking , @xmath225 is the total number of times the equivalence class @xmath14 follows the equivalence class @xmath6 within the population of rollouts @xmath70 .    likewise , given a population of rollouts @xmath70 , an action @xmath57 under evaluation and an integer @xmath223 , let @xmath226 alternatively , @xmath227 is the number of rollouts in the population @xmath70 fitting the rollout holland schema @xmath228 .",
    "we now provide an example to illustrate definition  [ popstateorderseqdef ] .",
    "[ popstateorderex ] continuing with example  [ popschemadownfunctex ] and population @xmath70 appearing in figure  [ popofrollsfig ] , we recall that @xmath189 .",
    "we immediately deduce that @xmath229 unless @xmath230 .",
    "there are two rollouts , namely the first and the forth , that fit the schema @xmath231 so that @xmath232 .",
    "likewise , @xmath194 and exactly one rollout , namely the second one , fits the holland schema @xmath233 so that @xmath234 unless @xmath235 while @xmath236 . continuing in this manner ( the reader may want to look back at example  [ popschemadownfunctex ] )",
    ", we list all the nonzero values of the function @xmath237 for the population @xmath70 in figure  [ popofrollsfig ] : @xmath238 .    likewise , recall from example  [ popschemadownfunctex ] , that @xmath205 so that @xmath239 unless @xmath240 or @xmath241 or @xmath242 or @xmath230 .",
    "it happens so that a unique rollout exists in the population @xmath70 fitting each fragment @xmath243 for @xmath240 , @xmath241 , @xmath242 and @xmath235 respectively , namely the first , the second , the forth and the last ( seventh ) rollouts .",
    "according to definition  [ popstateorderseqdef ] , we then have @xmath244 .",
    "analogously , @xmath211 so that @xmath245 unless @xmath246 or @xmath208 .",
    "the only rollout in the population @xmath70 involving the fragment with @xmath83 following @xmath191 is the second one , the only one involving @xmath207 following @xmath191 is the forth , the only one involving @xmath81 following @xmath191 is the fifth , and the only one involving @xmath208 following @xmath191 is the last ( the seventh ) rollouts respectively so that @xmath247",
    ". continuing in this manner , we list all the remaining nonzero values of the  order \" function introduced in definition  [ popstateorderseqdef ] for the population @xmath70 in figure  [ popofrollsfig ] : @xmath248 @xmath249 @xmath250    [ equivclassindeprem ] it must be noted that all the functions introduced in definitions  [ popstatecountdowndef ] and [ popstateorderseqdef ] remain invariant if one were to apply the  primitive \" recombination transformations as in definition  [ recombactonpopsdef ] to the population in the argument . more explicitly , given any population of rollouts @xmath137 that s obtained from the initial population @xmath70 after repeated application of recombination transformations in definition [ recombactonpopsdef ] , an action @xmath57 under evaluation , an equivalence class @xmath41 , a holland - poli schema @xmath251 an integer @xmath14 with @xmath252 , we have @xmath253@xmath254 indeed , the reader may easily verify that performing a swap of the elements of the same equivalence class , or of the corresponding subtrees pruned at equivalent labels , preserves all the states which are present within the population and creates no new ones .",
    "moreover , the equivalence class sequel is also preserved and hence the invariance of the functions @xmath172 and @xmath255 etc . follows .",
    "we now briefly describe what the  limiting frequency \" of a schema of rollouts is as follows : suppose we put a probability distribution , call it @xmath256 , on the the set of all possible compositions of crossover transformations in definition  [ recombactonpopsdef ] such that identity transformation ( i.e. the transformation that does not do anything , for instance , the composition of a one point crossover with itself ) is chosen with a positive ( it can be very tiny ) probability .",
    "now start with a population @xmath257 of rollouts , select a composition of recombination transformation @xmath258 with probability @xmath256 , apply it to the population @xmath70 and obtain a new population @xmath259 . again select another transformation @xmath260 with probability @xmath256 , apply it to the population @xmath261 , obtain a new population @xmath262 .",
    "continue in this manner so that the new population at time @xmath263 , @xmath264 . given a holland - poli schema @xmath156 of rollouts , for every population of rollouts @xmath137",
    "let @xmath265 denote the total number of rollouts in the population @xmath137 that fit the schema @xmath156 . since every one of the populations @xmath266 contains @xmath267 rollouts , the total number of rollouts encountered up to time @xmath263 is @xmath268 .",
    "the total number of rollouts fitting the holland - poli rollout schema @xmath156 up to the time @xmath263 is @xmath269 .",
    "we define the frequency of occurrence of the schema @xmath156 up to time @xmath263 as @xmath270 and the limiting frequency of occurrence of the holland - poli schema @xmath156 to be @xmath271 according to the general geiringer theorem of @xcite ( see also the mildly extended version in @xcite as in the previous footnote ) , the limiting frequency of occurrence of any schema ( and , in fact , any specified subset ) of rollouts always exists and is independent of the specific stochastic sample run with probability @xmath83 .",
    "computing this limit seems to be a very difficult ( if not impossible ) task for any given initial population @xmath257 , however , if we  inflate \" the population @xmath257 by a factor of @xmath272 ( i.e @xmath272-plicate every rollout in the population @xmath257 : more explicitely , construct the new population @xmath70 by extending the alphabet by a factor of @xmath272 and for every rollout @xmath20 adding @xmath273 copies of the rollout @xmath20 to the population @xmath257 , thereby obtaining a new population @xmath274 ) by a factor of @xmath275 preserves all of the stochastic information within the population of samples : it only  emphasizes \" this information by a factor of @xmath272 . ] and then take the limit of the limiting frequencies of occurrence @xmath276 as the inflation factor @xmath277 , then the limit can be computed purely in terms of the quantities in definitions  [ popstatecountdowndef ] and [ popstateorderseqdef ] as follows : if @xmath251 , where @xmath152 is a given holland - poli schema then @xmath278 with probability @xmath83 , where @xmath279 where @xmath280 ( we write  lf \" as short for  last factor \" ) .",
    "furthermore , in the special case when the initial population @xmath257 is homologous ( see definition  [ popofrolloutsdefn ] ) , one does not need to take the limit as @xmath277 in the sense that @xmath281 is a constant independent of @xmath272 and its value is given by the right hand side of equation  [ geiringerthmmaineq ] .",
    "an important comment is in order here : it is possible that the denominator of one of the fractions involved in the product is @xmath282 .",
    "however , in such a case , the numerator is also @xmath282 and we adopt the convention ( in equation  [ geiringerthmmaineq ] ) that if the numerator is @xmath282 then , regardless of the value of the denominator ( i.e. even if the denominator is @xmath282 ) , then the fraction is @xmath282 . as a matter of fact , a denominator of some fraction involved is @xmath282 if and only if one of the following holds : @xmath283 or if there exists an index @xmath284 with @xmath285 such that no state in the equivalence class of @xmath286 appears in the population @xmath70 ( and hence in either of the inflated populations @xmath287 ) .",
    "the geiringer - like theorem above naturally motivates the following dynamic parallel algorithm for action evaluation after a number of simulations has been completed . just as in monte - carlo tree search ,",
    "as the learning agent keeps simulating rollouts ( trials or random self - plays ) , it stores and dynamically updates a weighted labeled directed graph where the nodes are the similarity classes while a directed edge from a similarity class @xmath6 to the similarity class @xmath14 is added when some state from the similarity class @xmath14 follows a state from the similarity class @xmath6 within one of the simulated rollout . after being added the edge has weight @xmath83 .",
    "whenever a state with observable information @xmath14 follows a state with observable information @xmath6 again , the edge weight from @xmath6 to @xmath14 is incremented by @xmath83 .",
    "loops ( or edges from a similarity class @xmath6 to itself ) are allowed and their weights are incremented according to exactly the same rule with @xmath288 .",
    "the same exactly rule applies to the terminal labels following a given edge .",
    "either concurrently or periodically after a certain number of simulations ( trials ) independent agents , let s call them bugs , traverse the dynamically constructed digraph starting at various actions under evaluation and traveling through the digraph according to the following simple rule : if an agent is at the state labeled by @xmath6 , the agent travels to a state labeled by @xmath289 with the probability proportional to the directed edge weight from @xmath6 to @xmath14 that is , by construction , @xmath290 where @xmath70 is the current sampled population . of course , the situation is analogous if the bug starts at the actions under evaluation or travels to the terminal states ( where it receives payoffs ) .",
    "the bug finishes its journey at terminal states and then updates the values @xmath291 of the actions under evaluation that it has started traveling at according to the following simple rule : @xmath292 where @xmath293 is the total number of times that the bugs updated the action value @xmath291 up to the current , @xmath294st , bug and @xmath295 is the numerical value of the payoff where the current , @xmath294st , bug has finished its trip .",
    "the value @xmath291 has been updated by the @xmath294st bug that started ( or traveled ) through that action under evaluation , increment @xmath293 by @xmath83 , i.e. update @xmath296 .",
    "it is not hard to see from equation  [ geiringerthmmaineq ] and the law of large numbers that as the number of bugs updating the payoff values of the action @xmath57 of the observable state under evaluation increases , the action value @xmath291 approaches the expected payoff when the rollout schemata are sampled with the probabilities equaling to their limiting frequencies of occurrence as in equation  [ geiringerthmmaineq ] rather rapidly unless the payoff values are truly huge in size .",
    "a pictorial diagram appears in figure[illustratealgorithmpic ] : when writing @xmath297 ( i.e. we write @xmath297 in place of @xmath298 ) since the population @xmath70 plays no explicit role in the dynamic parallel algorithm described above .",
    "moreover , as the new rollouts are simulated so that the weights along the digraph are incremented accordingly and potential new nodes are added , the initial population of simulated rollouts changes accordingly and yet , this does has no relevance to the algorithmic implementation . ]     and @xmath190 denote the actions under evaluation while @xmath299 are the equivalence classes of states.,height=377 ]    let s say a  bug \" has started its trip at the action @xmath57 under evaluation .",
    "then the bug travels to the similarity class @xmath300 with probability @xmath301 while it travels to the node @xmath302 with probability @xmath303 .",
    "likewise , if the bug is at the similarity class @xmath304 then it remains at @xmath304 with probability @xmath305 , travels to @xmath306 with probability @xmath307 and to @xmath308 with probability @xmath309 .",
    "notice that if the bug ended up at the state @xmath306 , it travels to the terminal label @xmath310 with probability @xmath83 .",
    "a  memory evolutive system \" ( see @xcite for a detailed exposition by the inventors of the model ) is a dynamical system of evolving multilayered digraphs with extra structure of associative composition of links ( such mathematical structures are known as categories : see @xcite , or , for a gentler introduction that s more suitable to computer scientists , @xcite ) that are meant to model evolving cognitive processes in biological neural networks .",
    "one can think of a biological neural network as a directed graph where neurons are the nodes ( called objects in a category - theoretic language ) and synapses from neuron @xmath6 to neuron @xmath14 are links ( called morphisms or arrows , in the language of category theory ) .",
    "furthermore , this category has a further extra structure : it is a weighted category in the sense that the arrows ( the synapsis ) have varying strengths and the strengths vary with time so that one is looking at an entire collection of weighted categories that evolves over time : @xmath311 . another crucial component of the model is the hierarchy : the idea is that the concept formation is a multistage process , that takes place according to a few common computational mechanisms based on hebbian learning i.e. the process of increasing or decreasing the strength between the synapses based on the presence or absence of signals from one neighboring neuron to another@xcite .",
    "concepts form gradually as clusters of interconnected neurons that collectively influence another neuron or another cluster of interconnected neurons",
    ". such clusters initially form _ cocone _ diagrams and gradually  converge \" towards _ colimit _ diagrams ( see @xcite , @xcite or any other textbook on category theory for rigorous definitions ranging in a variety of levels of comprehension ) .",
    "an important reason why the notion of a colimit diagram is selected to model a conceptual cluster of neurons ( or a cluster of conceptual clusters of neurons in a higher level ) is that an entire collection of various arrows ( in case of simple neurons synapses ) corresponds uniquely to what s called a  collective link \" or collective arrow from one cluster of neurons to the other . in this manner",
    "we can think of sophisticated pre - learned concepts as objects on a higher level of development while the arrows from one such object to another are collective links representing an entire family of lower - level collective links ( a collection of synapses from one neuron in the cluster to another one in the cluster when a previous level of development is the lowest one ) .",
    "returning back to the parallel algorithms described in the previous section , imagine that the conceptual clusters of neurons that are modeled as colimit diagrams represent states while collective links from these states towards other , motor - related conceptual clusters of neurons , represent actions at these states much like on the diagram in figure  [ conseptdiagrp ] below .",
    "eventually , a state - action sequence leads to a state that has a numerical payoff measured by the intensity of a feedback signal thereby resembling the notion of a rollout in monte - carlo tree search and pomdps .",
    "it is conceivable then that the action evaluation mechanisms for the collective links towards the motor - related clusters of neurons are implemented in a similar manner as described at the end of the previous section .",
    "moreover , the newest generalized geiringer - like theorem in @xcite that allows recombination over arbitrary set cover , leads to new fascinating insights into payoff - based clustering algorithms that resemble self - organizing maps and may also play a significant role in the concept - formation .",
    "these algorithms are the subject of sequel papers .",
    "in the most general setting , geiringer - like theorems address the limiting frequency of occurrence of various generalized  genetic material \" that ranges from alleles in genomic expressions to functions in genetic programming or , even more interestingly , observable states in computational intelligence in the long run after repeated application of recombination ( or crossover ) transformations . in the current paper",
    "we describe a rather simple dynamic algorithm motivated by one of the latest theorems in @xcite to take advantage of randomness and incomplete information by predicting the outcome of the limiting frequency of occurrence of various states after an  infinitely long \" recombination process as described in section  [ frameworkandalgorithmsect ] . not only such algorithms are anticipated to have a tremendous impact when coping with pomdps ( partially observable markov decision processes ) , a link has been exhibited between such algorithms for decision making in the environments with randomness and incomplete information and the corresponding algorithms in biological neural networks through an elegant and well - developed category - theoretic model of cognition in @xcite .",
    "the most recent version of the theorem in @xcite motivates further extensions of the dynamic algorithms in the current paper for payoff - based clustering and will be investigated in the sequel papers .",
    "this work has been supported by the epsrc ep / i009809/1  evolutionary approximation algorithms for optimization : algorithm design and complexity analysis \" grant .",
    "r.  poli , c.  stephens , a.  wright , and j.  rowe . a schema - theory - based extension of geiringer s theorem for linear gp and variable - length gas under homologous crossover .",
    "in _ foundations of genetic algorithms ( foga 2002 ) _ , pages 4562 , 2002 .",
    "b.  mitavskiy and j.  rowe . a schema - based version of geiringer theorem for nonlinear genetic programming with homologous crossover . in _",
    "foundations of genetic algorithms 8 ( foga-2005 ) _ , pages 156175 .",
    "springer , lecture notes in computer science 3469 , 2005 .",
    "b.  mitavskiy and c.  cannings . exploiting quotients of markov chains to derive properties of the stationary distribution of the markov chain associated to an evolutionary algorithm . in _ simulated evolution and learning ( seal-2006 ) _ , 2006 .",
    "b.  mitavskiy , j.  rowe , a.  wright , and l  schmitt .",
    "quotients of markov chains and asymptotic properties of the stationary distribution of the markov chain associated to an evolutionary algorithm . , 17(3):109123 , 2008 .",
    "b.  mitavskiy , j.  rowe , a.  wright , and l  schmitt .",
    "an improvement of the quotient construction method and further asymptotic results on the stationary distribution of the markov chains modeling evolutionary algorithms . in _",
    "ieee congress on evolutionary computation ( cec-2007 ) _ , 2007 .",
    "b.  mitavskiy and j.  he",
    ". a further generalization of the finite - population geiringer - like theorem for pomdps to allow recombination over arbitrary set covers . in _ foundations of genetic algorithms 12 ( foga-2013)_. acm press , 2013 .",
    "ehresmann and p.  smeonov .",
    "wlimes : towards a theoretical framework for wandering logic intelligence memory evolutive systems . in p.",
    "l. simeonov , l.  s. smith , and a.  c. ehresmann , editors , _ integral biomathics : tracing the road to reality_. springer - verlag , 2012 .",
    "poli r , c.  stephens , a.  wright , and j.  rowe .",
    "a schema theory based extension of geiringer s theorem for linear gp and variable length gas under homologous crossover . in _ foundations of genetic algorithms 7 ( foga-2003)_. springer , lecture notes in computer science 3469 , 2003 ."
  ],
  "abstract_text": [
    "<S> the classical geiringer theorem addresses the limiting frequency of occurrence of various alleles after repeated application of crossover . </S>",
    "<S> it has been adopted to the setting of evolutionary algorithms and , a lot more recently , reinforcement learning and monte - carlo tree search methodology to cope with a rather challenging question of action evaluation at the chance nodes . </S>",
    "<S> the theorem motivates novel dynamic parallel algorithms that are explicitly described in the current paper for the first time . </S>",
    "<S> the algorithms involve independent agents traversing a dynamically constructed directed graph that possibly has loops . a rather elegant and profound category - theoretic model of cognition in biological neural networks developed by a well - known french mathematician , professor andree ehresmann jointly with a neurosurgeon , jan paul vanbremeersch over the last thirty years provides a hint at the connection between such algorithms and hebbian learning . </S>"
  ]
}