{
  "article_text": [
    "the aim of _ discrete tomography _ is the retrieval of geometrical information about a physical structure , regarded as a finite set of points in the integer square lattice @xmath4 , from measurements , generically known as _ projections _ , of the number of atoms in the structure that lie on lines with fixed scopes ( see @xcite for a survey ) .",
    "a common simplification is to represent a finite physical structure as a binary matrix , where an entry is @xmath5 or @xmath6 according as an atom is present or absent in the structure at the corresponding point of the lattice .",
    "the challenge is then to reconstruct key features of the structure from a small number of scans of projections @xcite , eventually using some a priori information as convexity @xcite @xcite , and periodicity @xcite .",
    "our interest here , following @xcite , is to probe the structure , not with lines of fixed scope , but with their natural two dimensional analogue , rectangles of fixed scope , much as we might examine a specimen under a microscope or magnifying glass . for each position of our rectangular probe , we count the number of visible atoms , or , in the simplified binary matrix version of the problem , the number of @xmath5 in the prescribed rectangular window , which we term its _",
    "luminosity_. in the matrix version of the problem , these measurements can themselves be organized in matrix form , called the _ rectangular scan _ of the original matrix .",
    "our first objective is then to furnish a strategy to reconstruct the original matrix from its rectangular scan . in the sequel",
    ", we will address this problem to as _ reconstruction_@xmath7 , where @xmath8 is the rectangular scan , and @xmath9 and @xmath10 are the dimension of the rectangular windows . as we also note , our investigation is closely related to results on tiling by translation in the integer square lattice discussed in @xcite .    to be more precise ,",
    "let @xmath11 be an @xmath1 integer matrix , and , for fixed @xmath9 and @xmath10 , with @xmath12 , consider a @xmath13 window @xmath14 allowing us to view the intersection of any @xmath9 consecutive rows and @xmath10 consecutive columns of @xmath11 .",
    "then , the number @xmath15 $ ] on view when the top left hand corner of @xmath14 is positioned over the @xmath16-entry , @xmath17 $ ] , of @xmath11 , is given by summing all the entries on view : @xmath18=\\sum_{r=0}^{p-1 } \\sum_{c=0}^{q-1 } m[i+r , j+c ] , \\quad 1\\leq i\\leq m - p+1,\\quad 1\\leq j\\leq n - q+1.\\ ] ] thus , we obtain an @xmath19 matrix @xmath20 called the _ @xmath21-rectangular scan _ of @xmath11 ; when @xmath9 and @xmath10 are understood , we write @xmath22 , and speak more simply of the _ rectangular scan_. ( this terminology is a slight departure from that found in @xcite . ) in the special case when @xmath23 has all entries equal , say @xmath24 , we say that the matrix @xmath11 is _ homogeneous _ of _ degree _ @xmath24 , simply @xmath24-homogeneous .    furthermore , we define an @xmath25 matrix @xmath26 by setting , for @xmath27 : @xmath28=m[i , j]+m[i+p , j+q]-m[i+p , j]-m[i , j+q].\\ ] ] as usual , when @xmath9 and @xmath10 can be understood without ambiguity , we suppress them as subscripts . in the event that the matrix @xmath29 is a zero matrix ,",
    "the matrix @xmath11 is said to be _",
    "smooth_. notice that the homogeneous matrices are _ properly _ included in the smooth matrices , as shown by the matrix @xmath11 of fig .",
    "[ figrev ] , which is smooth , and non homogeneous .    simplifying the rules of the game",
    ", thought the paper we will consider the matrix @xmath11 ( representing a physical structure ) as a _ binary one _ ; under this assumption , the rectangular scan @xmath23 turns out to be a positive matrix whose values are in the set @xmath30 , and the matrix @xmath31 turns out to have values in the set @xmath32 ( see fig .  [ figchi ] ) .",
    "we conclude this introductory section with three observations which are direct consequences of the given definitions and to which we shall have frequent recourse in what follows . since their proofs are a matter of simple computations , they are omitted .",
    "[ rem1 ] if @xmath33 and @xmath34 are two @xmath1 binary matrices , then @xmath35    [ lem0 ] if @xmath11 is a binary matrix , then @xmath36    thus the rectangular scan @xmath23 of a binary matrix @xmath11 already contains sufficient information to compute @xmath31 and so to decide whether @xmath11 is smooth .",
    "notice that , with a certain terminological inexactitude , we can also say , in the case where @xmath11 is smooth , that @xmath23 is smooth ( more precisely , @xmath23 is @xmath37-smooth , while @xmath11 itself is @xmath21-smooth , as our more careful statement of the lemma  [ lem0 ] makes clear ) .",
    "an appeal to symmetry and induction yields the following generalization of ( * ? ? ?",
    "* lemma 2.2 ) .",
    "[ lem1 ] if @xmath11 is a smooth matrix then , for any integers @xmath38 and @xmath39 such that @xmath40 and @xmath41 , @xmath42+m[i+\\alpha p , j+\\beta q]=m[i+\\alpha p , j]+m[i , j+\\beta q].\\ ] ]    finally , we say that an entry @xmath17 $ ] of the matrix @xmath11 is _ @xmath21-invariant _",
    "if , for any integer @xmath38 such that @xmath43 and @xmath44 , @xmath45=m[i , j].\\ ] ] if all the entries of @xmath11 are @xmath21-invariant , then @xmath11 is said to be @xmath21-invariant .",
    "in this section we extend the studies about homogeneous matrices started in @xcite to the class of smooth matrices : first we furnish a series of simple results which link smoothness and invariance , then we proceed along a path leading through a decomposition theorem for smooth matrices to their reconstruction .",
    "[ lem2 ] if @xmath11 is a smooth matrix , then each of its elements is @xmath46-invariant or @xmath47-invariant .    since @xmath11 is smooth , for each @xmath48 and @xmath49 , it holds @xmath42+m[i+p , j+q]=m[i+p , j]+m[i , j+q].\\ ] ] let us consider the following three possibilities for the element @xmath17 $ ] :    @xmath50 @xmath17 \\not= m[i+p , j]$ ] : by lemma  [ lem1 ] , for @xmath51 and for all @xmath52 such that @xmath53 , it holds @xmath54=m[i , j]$ ] and @xmath55=m[i+p , j]$ ] , so @xmath17 $ ] is @xmath47-invariant .",
    "@xmath56 @xmath17\\not= m[i , j+q]$ ] : by reasoning similarly to @xmath50 , we obtain that @xmath17 $ ] is @xmath46-invariant .",
    "@xmath57 @xmath17=m[i , j+q]=m[i+p , j]$ ] : if there exists @xmath58 such that @xmath59\\not = m[i , j]$ ] , again reasoning as in @xmath50 , we obtain that @xmath17 $ ] is @xmath47-invariant .    on the other hand , if for all @xmath60 it holds that @xmath61 = m[i , j]$ ] , then @xmath17 $ ] is @xmath46-invariant .",
    "finally , if @xmath62 and @xmath63 , a similar reasoning leads again to the thesis .    the reader can check that each entry of the smooth matrix @xmath11 in fig .",
    "[ figrev ] is @xmath64-invariant ( the highlighted ones ) or @xmath65-invariant .",
    "a first decomposition result follows :    [ decompm ] a matrix @xmath11 is smooth if and only if it can be obtained by summing up a @xmath46-invariant matrix @xmath33 and a @xmath47-invariant matrix @xmath34 such that they do not have two entries @xmath5 in the same position .",
    "( @xmath66 ) let @xmath33 and @xmath34 contain the @xmath46-invariant and the @xmath47-invariant elements of @xmath11 , respectively .",
    "by lemma  [ lem2 ] , the thesis is achieved .",
    "( @xmath67 ) since @xmath33 is @xmath46-invariant , then for each @xmath48 , @xmath68 it holds @xmath69=m_1[i , j]+m_1[i+p , j+q]-m_1[i+p , j]-m_1[i , j+q]=\\\\",
    "\\\\ = m_1[i , j]+m_1[i , j+q]-m_1[i , j]-m_1[i , j+q]=0 \\end{array}\\ ] ]    so , by definition , @xmath33 is smooth .",
    "the same result holds for @xmath34 and , by lemma  [ rem1 ] , for @xmath70 .",
    "we can go further on by reformulating this last theorem in terms of the rectangular scans of the matrices @xmath33 and @xmath34 :    [ lem3 ] the following statements hold :    @xmath50 if @xmath11 is @xmath47-invariant , then @xmath23 has constant rows ;    @xmath56 if @xmath11 is @xmath46-invariant , then @xmath23 has constant columns .",
    "@xmath50 for each @xmath71 and @xmath68 , we prove that @xmath72=r(m)[i , j+1]$ ] : @xmath73= \\sum_{r=0}^{p-1 } \\sum_{c=0}^{q-1 } m[i+r , j+1+c]=\\\\ \\\\",
    "= \\sum_{r=0}^{p-1 } \\sum_{c=1}^{q-1 } m[i+r , j+c]+\\sum_{r=0}^{p-1 } m[i+r , j+q]= \\end{array}\\ ] ] since @xmath11 is @xmath47-invariant @xmath74+\\sum_{r=0}^{p-1 } m[i+r , j]=r(m)[i , j].\\ ] ]    @xmath56 the proof is similar to @xmath50 .    after observing that each matrix having constant rows or columns is smooth , a direct consequence of theorem  [ decompm ] and lemma  [ lem3 ] is the following :    [ decomp2 ] a binary matrix @xmath11 is smooth if and only if @xmath23 can be decomposed into two matrices @xmath75 and @xmath76 having constant rows and columns , respectively .    fig .",
    "[ figrev ] shows that the converse of the two statements of lemma  [ lem3 ] does not hold in general .",
    "however , we can prove the following weaker version :    [ lem4 ] let @xmath11 be a binary matrix .",
    "the following statements hold :    @xmath50 if @xmath23 has constant columns , then there exists a @xmath46-invariant matrix @xmath33 such that @xmath77 ;    @xmath56 if @xmath23 has constant rows , then there exists a @xmath47-invariant matrix @xmath34 such that @xmath78 .",
    "@xmath50 we define the matrix @xmath33 as follows : the first @xmath9 rows of @xmath33 are equal to those of @xmath11 , and the other entries of @xmath33 are set according to the desired @xmath46-invariance .",
    "it is easy to verify that @xmath79 .",
    "@xmath56 a definition of @xmath34 similar to that in @xmath50 for @xmath33 can be easily given .",
    "a first approach to the general reconstruction problem consists in the definition of the following algorithm which suites only for a binary smooth matrix whose @xmath21-rectangular scan has constant rows :    recconstrows@xmath7    * input : * an integer matrix @xmath8 of dimension @xmath81 , having constant rows , and two integers @xmath9 and @xmath10 .",
    "* output : * a @xmath47-invariant matrix @xmath11 , of dimension @xmath1 , where @xmath82 and @xmath83 , having @xmath8 as @xmath21-rectangular scan , if it exists , else return failure .",
    "* procedure : *    step @xmath5 : create the @xmath84 matrix @xmath11 and the vector @xmath85 ( storing the @xmath86artial number of @xmath87ries 1 in each row of @xmath11 ) of dimension @xmath2 , to support the computation .",
    "initialize the entries both of @xmath11 and @xmath85 to @xmath6 .    for each row @xmath88 ,    step @xmath89 : * if * @xmath90\\leq a[i+1,1]$ ] * then *    @xmath91 @xmath92=\\dots = m[i+p , a[i+1,1]-a[i,1]+pent[i]]=1;$ ]    @xmath91 @xmath93=a[i+1,1]-a[i,1]+pent[i].$ ]    * if * @xmath93>q$ ] * then * failure .",
    "step @xmath94 : * if * @xmath90>a[i+1,1]$ ] and @xmath95\\geq a[i,1]-a[i+1,1]$ ] * then *    @xmath91 @xmath92=\\dots = m[i+p , a[i+1,1]-a[i,1]+pent[i]]=1;$ ]    @xmath91 @xmath93=a[i+1,1]-a[i,1]+pent[i].$ ]    step @xmath96 : * if * @xmath90>a[i+1,1]$ ] and @xmath95 < a[i,1]-a[i+1,1]$ ] * then *    @xmath91 @xmath97-a[i+1,1]-pent[i];$ ]    @xmath91 for each @xmath98 , @xmath99    @xmath100 @xmath101 + 1]=\\dots = m[i',pent[i']+k]=1;$ ]    @xmath100 @xmath102=pent[i']+k;$ ]    @xmath100 * if * @xmath102>q$ ] * then * failure .",
    "step @xmath103 : let @xmath104-pent[1]- \\dots - pent[p]$ ]",
    ".    for each @xmath105 , search one of the upper leftmost @xmath13 positions of @xmath11 , say @xmath16 , such that , for each @xmath99 , @xmath106 , it holds @xmath107=0 $ ] .    *",
    "if * such a position does not exist * then * failure ,    * else * set all the entries @xmath107 $ ] to the value @xmath5 , and increase @xmath108 by one .",
    "step @xmath109 : complete the entries of @xmath11 according to the @xmath47-invariance constraint , and return @xmath11 as output .    as regard the correctness of this reconstruction algorithm",
    ", it relies on the analysis of what stored in @xmath11 after step @xmath5 : at that stage , in fact , the entries in first column of its rectangular scan @xmath23 differ from those of @xmath8 by the same constant value , without overcoming .",
    "the formal counterpart of what sketched above is in the following lemmas :    [ lem : recrow ] after performing step @xmath5 of recconstrows@xmath7 , for each @xmath110 , it holds @xmath111-r(m)[i+1,1]=a[i,1]-a[i+1,1].\\ ] ]    let us first inspect the entries placed in the rows @xmath112 and @xmath113 of @xmath11 during step @xmath5 of recconstrows@xmath7 , for a generic index @xmath110 :    if @xmath90\\leq a[i+1,1]$ ] , then in row @xmath113 of @xmath11 are added @xmath114-a[i,1]+pent[i]$ ] entries @xmath5 .",
    "since row @xmath112 of @xmath11 contains @xmath95 $ ] entries @xmath5 , then , at that step , it holds @xmath115-r(m)[i+1]=a[i,1]-a[i+1,i];\\ ] ]    if @xmath90 > a[i+1,1]$ ] , and @xmath95\\geq a[i,1]-a[i+1,1]$ ] , then in row @xmath113 of @xmath11 are added @xmath95 - a[i,1]+ a[i+1,1]$ ] entries @xmath5 , so equation ( [ eq1 ] ) still holds ;    if @xmath90 > a[i+1,1]$ ] , and @xmath95 < a[i,1]-a[i+1,1]$ ] , then in row @xmath112 of @xmath11 are added @xmath90-a[i+1,1]-pent[i]$ ] entries @xmath5 in addition to the @xmath95 $ ] ones already present , so equation ( [ eq1 ] ) is again satisfied .    for each @xmath116",
    ", step @xmath5 eventually changes some entries from row @xmath117 to row @xmath118 of @xmath11 .",
    "so , both @xmath119 $ ] and @xmath120 $ ] increase their value of the same amount , without compromising the validity of equation ( [ eq1 ] ) .    finally , if @xmath121 , then step @xmath96 may modify the values of @xmath119 $ ] and @xmath120 $ ] , but again of the same amount , since the ( eventually ) added entries @xmath5 respect the @xmath46-invariance in the rows of index less than @xmath122 , so equation ( [ eq1 ] ) definitively holds , and we obtain the thesis .    [ lem : maxim ] let us consider the vector @xmath85 as updated at the end of step @xmath5 of recconstrows@xmath7 . for each matrix",
    "@xmath11 such that @xmath123 , and for each @xmath124 , it holds @xmath125+\\dots + m[i , p]\\geq pent[i].\\ ] ]    by contradiction , we assume that there exists an index @xmath126 and a matrix @xmath127 such that @xmath125+\\dots + m[i , p]+k= pent[i],\\ ] ] with @xmath123 and @xmath128 .",
    "by lemma  [ lem : recrow ] , the same equation holds for each row @xmath99 .",
    "let @xmath129 be the first index such that    @xmath91 @xmath130 ;    @xmath91 for each @xmath99 , it holds @xmath131\\leq pent[i']$ ] .",
    "if @xmath132 , then the minimality of the value of @xmath131 $ ] assures that @xmath131=0 $ ] before step @xmath5 reached row @xmath129 , and , consequently , that @xmath133\\leq a[i_0 + 1,1]$ ] .",
    "as soon as step @xmath89 reaches the row index @xmath129 , it eventually increases the value @xmath134 $ ] , leaving unchanged that of @xmath131 $ ] . again the minimality of @xmath131 $ ] assures that no changes will be performed to the value of @xmath131 $ ] till the end of step @xmath5 .",
    "hence , the assumption @xmath135+\\dots + m[i_0,p]+k= pent[i_0 ] $ ] , with @xmath128 , generates a contradiction .",
    "if @xmath136 , then a similar argument holds , and so we get the thesis .    now , also step @xmath103 of recconstrows @xmath7 can be better understood : the @xmath24 elements @xmath6 which change their value to @xmath5 and which are added in the upper leftmost @xmath13 positions of @xmath11 , fill the gap among @xmath119 $ ] and @xmath90 $ ] , so that the output matrix @xmath11 has the desired property @xmath123 .",
    "each row @xmath112 of a matrix @xmath11 having @xmath8 as rectangular scan contains at least @xmath95 $ ] elements which are @xmath46-invariant , and not @xmath47-invariant .",
    "a procedure which reconstructs a smooth matrix whose @xmath21-rectangular scan @xmath8 has constant columns , say recconstcols@xmath7 , can be easily inferred from recconstrows , so , in the sequel , we will consider it as already defined .    from lemmas [ lem : recrow ] and [ lem : maxim ] , it is straightforward that    [ comprec ] the problem @xmath137 can be solved in @xmath138 , when @xmath8 has constant rows or constant columns .",
    "[ ex0 ]    let us follow the computation recconstrows@xmath139 , with @xmath8 depicted in fig.[figxmp0 ] .",
    "step @xmath5 : the matrix @xmath11 is created , and its first four columns , together with the vector @xmath85 , are modified as shown in fig  [ figexmp41 ] .",
    "more precisely ,    @xmath140 + 2=a[1,2]$ ] requires step @xmath89 to place two entries @xmath5 in ( the leftmost positions of ) row @xmath141 , fig  [ figexmp41 ] , ( a ) ;    @xmath142=a[1,3]+1 $ ] requires step @xmath96 to place one entry @xmath5 in row @xmath103 , fig  [ figexmp41 ] , ( b ) ;    @xmath143 + 2=a[1,4]$ ] requires step @xmath89 to place two entries @xmath5 in row @xmath144 , fig  [ figexmp41 ] , ( c ) ;    @xmath140=a[1,2]+3 $ ] requires step @xmath96 to add one entry @xmath5 both in row @xmath5 and in row @xmath141 , fig  [ figexmp41 ] , ( d ) .",
    "step @xmath103 places the remaining @xmath104-pent[1]-pent[2]-pent[3]=3 $ ] entries @xmath5 in the upper leftmost @xmath13 submatrix of @xmath11 , and propagates them according to the @xmath145-invariance , paying attention that no collisions occur ( see fig .",
    "[ figexmp42 ] @xmath146 ) .",
    "step @xmath109 completes @xmath11 according to the @xmath147-invariance , giving the final solution depicted in fig .",
    "[ figexmp42 ] @xmath148 .    _ the general reconstruction algorithm _    theorem  [ decomp2 ] allows one to foresee the use of the procedures recconstrows and recconstcols to solve _ reconstruction _",
    "@xmath7 , when @xmath8 is @xmath37-smooth : the algorithm at first will split the matrix @xmath8 into two parts having constant rows and columns , respectively , then it will apply to each of them the appropriate reconstruction procedure , and finally it will merge the two outputs . performing the merging stage a conflict occurs when the same position in two output matrices has value @xmath5 . to prevent it small refinements to the outputs of recconstrows and recconstcols will be required .",
    "so , let us start by showing in the next lemma a quick way of finding all the possible decompositions of a @xmath37-smooth matrix into two parts having constant rows and columns , respectively .",
    "[ lem5 ] let @xmath8 be a @xmath1 integer matrix .",
    "if @xmath8 is @xmath37-smooth , then it admits @xmath149 different decompositions into two matrices having constant rows and columns , with @xmath24 being the minimum among all the elements of @xmath8 .",
    "the thesis is achieved by defining a procedure which gives as output a complete list of couples of matrices @xmath150 , with @xmath151 , each of them representing a decomposition of @xmath8 into two parts having constant rows and columns , and successively , by proving its correctness :    decompose @xmath152    * input : * an integer @xmath1 matrix @xmath8 .",
    "* output : * a sequence of different couples of matrices @xmath153 , with @xmath24 being the minimum element of @xmath8 , such that , for each @xmath154 , @xmath155 has constant rows , @xmath156 has constant columns , and @xmath157 .",
    "if such a sequence does not exist , then return failure .",
    "* procedure : *    step 1 : initialize all the elements of two @xmath1 matrices @xmath158 and @xmath159 to the value @xmath6 .",
    "let @xmath24 be the minimum among the entries of @xmath8 .",
    "from each element of @xmath8 , subtract the value @xmath24 and store the result in @xmath158 ;    step 2 : for each @xmath160    step 2.1 : compute @xmath161\\ : : \\ : 1\\leq j \\leq n\\};\\ ] ]    step 2.2 : subtract the value @xmath162 from each element of @xmath158 ;    step 2.3 : set all the elements of row @xmath112 of @xmath159 to the value @xmath162 ;    step 3 : * if * the matrix @xmath158 has not constant columns * then * failure    * else * for each @xmath151 , create the matrices @xmath155 and @xmath156 such that @xmath163=a_r[i , j]+t \\hspace{20pt}\\mbox { and } \\hspace{20pt } a_c^t[i , j]=a_c[i , j]+k - t,\\ ] ] with @xmath160 and @xmath164 .    give the sequence",
    "@xmath165 as output .",
    "example  [ ex1 ] shows a run of the algorithm . by construction ,",
    "each couple @xmath150 is a decomposition of @xmath8 , and furthermore , @xmath155 has constant rows .",
    "what remains to prove is that the matrix @xmath158 updated at the end of step @xmath103 has constant columns ( and , consequently , the same hold for all the matrices @xmath156 ) .",
    "let us denote by @xmath166 the common value of the elements of the @xmath112-th row of @xmath159 , and let us proceed by contradiction , assuming that @xmath158 has not constant columns . since @xmath8 is the sum of a column constant and a row constant matrix , and for all @xmath71 and @xmath167 , it holds @xmath168=r_i + a_c[i , j]+k$ ] , then @xmath158 is also the sum of a column constant matrix , and a row constant matrix , this last having at least one row , say @xmath129 , whose elements have value @xmath169 .",
    "this situation generates an absurd , since @xmath170 computed in step @xmath171 turns out no longer to be the minimum of row @xmath129 in @xmath158 , updated to that step .    since a matrix having constant rows ( resp .",
    "columns ) can not be obtained as sum of a matrix having constant rows and a matrix having constant columns unless the latter is a constant matrix , then the @xmath149 decompositions listed by the algorithm are all the possible ones .",
    "[ ex1 ]    let us follow the steps of the procedure decompose@xmath152 , with the matrix @xmath8 depicted in fig.[smooth21 ] .",
    "step @xmath5 : we subtract from all the elements of @xmath8 , the value @xmath172 , i.e. its minimum element , and we store the obtained result in the matrix @xmath158 .",
    "step @xmath103 : for each @xmath71 , we find the minimum value @xmath162 among the elements of row @xmath112 of @xmath158 ( step @xmath171 ) , we subtract it from all these elements ( step @xmath173 ) , and finally , we set the elements in row @xmath112 of @xmath159 to the value @xmath162 ( step @xmath174 ) . in our case ,",
    "the minimums are @xmath175 , @xmath176 , @xmath177 and @xmath178 .",
    "step @xmath109 : the matrix @xmath158 updated at the end of step @xmath103 has constant columns , so the three different decompositions of @xmath8 can be computed and listed .",
    "the output is depicted in fig .",
    "[ smooth22 ] .",
    "now we are finally able to define a general procedure which solves the problem _ reconstruction _",
    "@xmath7 , when @xmath8 is @xmath37-smooth :    recsmooth @xmath7    * input : * an integer @xmath37-smooth matrix @xmath8 of dimension @xmath179 and two integers @xmath9 and @xmath10 .",
    "* output : * a binary matrix @xmath11 of dimension @xmath1 , with @xmath82 and @xmath83 , having @xmath8 as @xmath21-rectangular scan , if it exists , else return failure .",
    "* procedure : *    step @xmath5 : run decompose@xmath152 , and let @xmath180 be its output .",
    "set @xmath181 ;    step @xmath89 : run step @xmath5 of recconstrows @xmath182 .",
    "let @xmath183 and @xmath184 , with @xmath85 and @xmath24 updated at the end of the step .",
    "define @xmath185 to be the vector having @xmath9 elements , and such that : @xmath186=max\\{pent_{row}[i ' ] : i'=(i)mod_p\\},\\ ] ] with @xmath187 , and @xmath188 .",
    "step @xmath94 : run step @xmath5 of recconstcols@xmath189 .",
    "let @xmath190 and @xmath191 , with @xmath85 and @xmath24 updated at the end of the step , and let @xmath192 be the vector having @xmath10 entries , and such that : @xmath193=max\\{pent_{col}[j ' ] : j'=(j)mod_q\\},\\ ] ] with @xmath194 , and @xmath195 ;    step @xmath96 : among all the possible @xmath13 matrices whose entries are in @xmath196 , choose one , say @xmath197 , such that :    @xmath50 the number of entries @xmath198 in its @xmath112-th row is @xmath199 $ ] .",
    "@xmath56 the number of entries @xmath86 in its @xmath200-th column is @xmath201 $ ] ;    @xmath57 the number of entries @xmath5 is @xmath202 .    *",
    "if * @xmath197 does not exist and @xmath203 * then * set @xmath204 , and return to step  @xmath89 .    *",
    "if * @xmath197 does not exist and @xmath205 * then * failure ;    step @xmath103 : create the @xmath1 matrix @xmath11 , and initialize its entries as follows :    step @xmath171 : for each @xmath124 and for each @xmath206 ,    * if * @xmath207\\not=0 $ ] and @xmath208=q$ ] , with @xmath99 * then * set both @xmath17=q$ ] and @xmath207= pent_{row}[i]-1 $ ] ;    step @xmath173 : for each @xmath209 and for each @xmath210 ,    * if * @xmath211\\not=0 $ ] and @xmath212=p$ ] , with @xmath213 * then * set both @xmath17=p$ ] and @xmath211=pent_{col}[j]-1 $ ] ;    step @xmath174 : for each @xmath214 and for each @xmath206 ,    * if * @xmath215=1 $ ] , * then * set @xmath17=1 $ ] ;    step @xmath216 : fill the matrix @xmath11 imposing the @xmath47-invariance of its entries @xmath198 and @xmath5 , and the @xmath46-invariance of its entries @xmath86 and @xmath5 ;    step @xmath109 : change the values @xmath86 and @xmath198 to @xmath5 , and set the remaining entries of @xmath11 with the value @xmath6 ; finally , give @xmath11 as output .",
    "the problem @xmath80 @xmath7 , with @xmath8 being @xmath37-smooth , admits a solution if and only if recsmooth @xmath7 does not return failure .",
    "@xmath217 let @xmath11 be a solution of @xmath80 @xmath7 , and let us assume that @xmath70 , with @xmath33 and @xmath34 being @xmath47-invariant and @xmath46-invariant , respectively .",
    "let @xmath218 be one of the decomposition of @xmath8 such that @xmath219 and @xmath220 .",
    "lemma  [ lem : maxim ] implies that , for each @xmath221 , the value @xmath207 $ ] indicates the minimum number of elements of @xmath11 which are @xmath47-invariant and not @xmath46-invariant , and which lie in the first @xmath10 columns of the solution ; a symmetrical property holds for @xmath222 .",
    "let us construct a @xmath13 matrix @xmath223 as follows :    - for each @xmath160 and @xmath194 , if @xmath17=1 $ ] is @xmath47-invariant and not @xmath46-invariant , then set @xmath224=q$ ] , with @xmath99 ;    - for each @xmath187 and @xmath164 , if @xmath17=1 $ ] is @xmath46-invariant and not @xmath47-invariant , then set @xmath224=p$ ] , with @xmath213 ;    - for each @xmath187 and @xmath194 , if @xmath17=1 $ ] is @xmath46-invariant and @xmath47-invariant , then set @xmath225=1 $ ] .",
    "obviously , by definition of invariance , in @xmath223 there are no positions which are first set to a value and then modified to another .",
    "so , the existence of matrix @xmath223 implies that of a matrix @xmath197 satisfying the constraints imposed in step @xmath96 .",
    "@xmath226 immediate .",
    "[ ex3 ] let us describe a run of recsmooth @xmath227 starting from the decomposition of @xmath8 into the couple of matrices depicted in fig .",
    "[ sm8 ] .",
    "step @xmath89 produces the vectors @xmath228 while step @xmath94 produces the vectors @xmath229    among the matrices which are compatible with the requirements of step @xmath96 we choose that depicted in fig .",
    "[ newfigexmp2 ] , ( a ) .",
    "steps @xmath171 , @xmath173 and @xmath174 produce the matrix @xmath11 in fig .",
    "[ newfigexmp2 ] , ( b ) ( notice that the entries @xmath86 are @xmath46-invariant , while the entries @xmath198 are @xmath47-invariant as desired ) . finally , step @xmath216 produces the matrix in fig .",
    "[ newfigexmp2 ] , ( c ) , and , consequently , step @xmath109 the output .",
    "the following theorem holds :    [ teo1 ] the computational complexity of recsmooth@xmath7 is polynomial in @xmath2 and @xmath3 .",
    "we obtain the thesis by analyzing the complexity of each step of recsmooth :    step @xmath5 : the procedure decompose clearly acts in @xmath230 time ( remind that @xmath231 is the minimum among the elements of @xmath8 ) ;    step @xmath89 and step @xmath94 are repeated at most @xmath24 times , and , each time , they ask for a run of recconstrows and of recconstcols which are both performed in @xmath138 .",
    "the computation of @xmath185 and @xmath192 does not increase the complexity of these two steps .",
    "step @xmath96 is carried on in constant time with respect to @xmath2 and @xmath3 .",
    "steps @xmath103 and @xmath109 require @xmath138 to create matrix @xmath11 .    hence , the total amount of time is @xmath138 .",
    "we are aware that step @xmath96 of recsmooth @xmath7 , i.e. the search of the matrix @xmath197 , can be carried on in a smarter way , but this will bring no effective contribution to the decreasing of the computational complexity of the reconstruction , and , on the other hand , it will add new lemmas and proofs to the current section .    the first part of the paper devoted to the analysis and the reconstruction of smooth matrices is now completed .",
    "this last section concerns the matrices which are not smooth : in particular , for each non smooth matrix @xmath11 , we consider the matrix @xmath31 and we define a polynomial time algorithm which lists all the matrices consistent with it .",
    "finally we will integrate it with the algorithm for reconstructing a smooth matrix defined in the previous section , and we will achieve the solution of the general reconstruction problem .",
    "unfortunately , the definitions introduced up to now are not specific enough to describe these further studies , and a final effort is required to the reader : what follows has the appearance of a stand alone part inside this section , but the feeling of a final possible usage will never be frustrated .    hence , let @xmath232 and @xmath233 be two indexes such that @xmath234 , @xmath235 , and @xmath8 be an integer @xmath1 matrix .",
    "we define the _ @xmath236-subgrid _ of @xmath8 to be the submatrix @xmath237=a[a+(i-1)\\ : p , b+(j-1)\\ : q]\\ ] ] with @xmath238 and @xmath239 ( see fig .  [ figgrid ] ) . if we consider again a binary matrix @xmath11 , by definition it holds that @xmath240=s(\\chi(m))_{a , b}[i , j]=\\\\ \\\\ = s(m)_{a , b}[i , j]+s(m)_{a , b}[i+1,j+1]-s(m)_{a , b}[i+1,j]- s(m)_{a , b}[i , j+1 ] .",
    "\\\\ \\end{array}\\ ] ] the binary matrix @xmath241 of dimension @xmath242 is said to be a _ valuation _ of @xmath243 if , for each @xmath244 , @xmath164 ,          [ lem8 ] let @xmath249 and @xmath250 be two subgrids whose valuations are @xmath241 and @xmath251 , respectively . if @xmath252 or @xmath253 , then for each @xmath160 and @xmath164 , @xmath247=1 $ ] implies @xmath254=0 $ ] .",
    "[ lem6 ] let @xmath241 be a valuation of @xmath243 , and let @xmath129 be a row [ column ] of @xmath255 having all the elements equal to @xmath5 .",
    "the matrix @xmath251 such that @xmath256 is equal to @xmath255 except in the elements of the row [ column ] @xmath129 which are all set to @xmath6 , is again a valuation of @xmath243 .",
    "if @xmath241 and @xmath251 are two valuations as in lemma  [ lem6 ] , then we say that the valuation @xmath241 is _ greater than _ the valuation @xmath251 .",
    "this relation can be easily extended to a finite partial order on the valuations of the subgrids of @xmath31 .",
    "[ lem7 ] given a binary matrix @xmath11 , for each couple of integers @xmath260 , @xmath261 , the number of minimal elements in the partial ordering of the valuations of @xmath249 is polynomial with respect to the dimensions @xmath2 and @xmath3 of @xmath11 .",
    "furthermore , each minimal element can be reconstructed in polynomial time with respect to them .",
    "let @xmath243 have dimension @xmath179 .",
    "we order the ( positions of the ) non zero elements of @xmath243 according to the numbering of its columns ( from left to right ) , and , in the same column , according to the numbering of its rows ( from up to bottom ) , and let @xmath262 be the obtained sequence .",
    "we prove the thesis by induction on the number @xmath263 of elements of the sequence , i.e. we prove that the addition of new nonzero elements in @xmath243 does not increase  too much \" the number of its possible minimal valuations .",
    "we first observe that , by remark  [ rem_uniq ] , the presence of entries @xmath103 or @xmath259 in @xmath243 does not increase the number of minimal valuations , so we are allowed to focus our attention exactly on the elements of value @xmath5 or @xmath264 . as one can expect , the symmetry of the two cases allows us to show the details of one ( in particular when the element to add has value @xmath5 ) , and let the reader infer the other :    * base @xmath265 : * if @xmath266 and @xmath267=1 $ ] , then the four possible valuations of @xmath243 are depicted in fig .",
    "[ figp1 ] . among them , only @xmath268 and @xmath269 are minimal : they can be reached both from @xmath270 and from @xmath271 by deleting the rows or the columns entirely filled with entries @xmath5 , as stated in lemma  [ lem6 ] .",
    "* step @xmath272 * : let @xmath249 have a sequence @xmath273 of nonzero points , with @xmath274 , and @xmath275=1 $ ] .",
    "let @xmath241 be a valuation of the first @xmath276 points in @xmath243 .",
    "it is straightforward that , for all @xmath277 and @xmath278 it holds @xmath279=s(v)_{a , b}[i',j']$ ] .",
    "hereafter , we show _ all _ the possible ways of extending @xmath241 to the valuation @xmath251 which includes the point @xmath280 . some pictures are supplied in order to make the different cases transparent .                    if row @xmath122 is a @xmath281-row , then change from @xmath5 to @xmath6 the value of each entry of @xmath255 in position @xmath285 , with @xmath287 , so that it becomes a @xmath283-row or a @xmath6-row .",
    "if a @xmath6-row is created , then discard the obtained valuation @xmath256 , since it has been already obtained in a previous step ( easy check ) ;          we define the valuation @xmath256 as follows : for each @xmath291 , change from @xmath6 to @xmath5 the value of each entry of @xmath255 in position @xmath285 , with @xmath292 , so that it becomes a @xmath281-row .",
    "discard such a valuation if a row having all the entries equal to @xmath5 has eventually been created , in order to maintain minimality ( remind lemma  [ lem6 ] ) ;        _ remark : _ if the point @xmath280 has value @xmath264 , then a further check is needed in the analogous of case @xmath50 : it may happen that there exists a @xmath283-row @xmath122 , with @xmath297 , which is turned into a @xmath281-row after the addition of @xmath280 , so that a non minimal configuration is created .",
    "the four configurations above described are exhaustive with respect to the addition of the single point @xmath280 of value @xmath5 to the valuation @xmath255 .",
    "however , a case has not yet been considered : it appears when two points @xmath280 and @xmath298 are added to @xmath255 , under the assumption that they have different value , and they lie in the same column .",
    "@xmath303 all the rows from @xmath112 to @xmath122 are not @xmath281-rows of @xmath255 , and there exists a @xmath281-row with index greater than @xmath122 ( this last condition prevent @xmath255 from being extended to @xmath256 by means of @xmath57 ) .",
    "so , what remains to prove is that the number of the different minimal valuations for a given matrix @xmath243 is polynomial in its dimensions @xmath310 and @xmath311 ( and consequently in the dimensions @xmath2 and @xmath3 of @xmath11 ) .",
    "we achieve this aim by showing that the number of valuations @xmath255 which admit more than a single minimal extension is bounded by @xmath310 .",
    "some properties are needed :    [ prop:1 ] each valuation @xmath255 admits at most two different minimal extensions both when adding a single point @xmath280 ( see fig.[sm52 ] ) , and when adding two points @xmath280 and @xmath298 , under the assumptions of @xmath303 .",
    "[ prop:4 ] the @xmath6-rows of each valuation which extends @xmath255 are a subset of those of @xmath255 . furthermore ,",
    "if @xmath255 extends in two minimal ways , then the two extensions do not share any @xmath6-row .",
    "hence , property [ prop:5 ] assures that each matrix @xmath243 has at most @xmath310 different minimal valuations containing @xmath6-rows . from property [ prop:3 ] , if we add one or two new points to them , then at most @xmath2 new minimal valuations may arise . as a neat consequence",
    ", we obtain that the number of minimal valuations of a given matrix @xmath243 is polynomial in @xmath310 and @xmath311 , and so it is the complexity of their reconstruction .",
    "the computation is represented in fig .",
    "[ sm28 ] , by using a tree whose root is the matrix having all the entries equal to @xmath6 , and which represents the @xmath236 subgrid of the valuation of a @xmath6-homogeneous matrix",
    ". the nodes at level @xmath24 are all the possible @xmath236 subgrids of the valuations of the first @xmath24 entries different from @xmath6 of @xmath243 .",
    "@xmath57 at least one occurrence of each entry in @xmath317 and at least one occurrence of each entry in @xmath318 is present .",
    "furthermore , all the entries with pedex @xmath86 [ resp .",
    "@xmath198 ] , and having the same index must lie in the same column [ resp .",
    "row ] .                      as a final observation",
    ", one may wonder the meaning of the indexed entries @xmath331 and @xmath332 inside each matrix : the elements @xmath331 [ resp .",
    "@xmath332 ] having the same index mark the positions where a set of entries whose rectangular scan is @xmath5-homogeneous , can be placed .",
    "the choice of all the possible sets of positions for the placement of the @xmath202-homogeneous part of @xmath8 constitutes a key point in the definition of the final reconstruction algorithm which follows :                                * if * @xmath107=0 $ ] , for each position @xmath351 , with @xmath99 , * then * set @xmath107=1 $ ] , and change to @xmath6 the remaining entries in column @xmath200 of @xmath346 having value @xmath352 * else * set @xmath353=0 $ ] , and , if no other elements @xmath352 are in column @xmath200 , set @xmath349 and return to step @xmath343 ;      * if * @xmath355=0 $ ] , for each position @xmath356 , with @xmath213 , * then * set @xmath355=1 $ ] , and change to @xmath6 the remaining entries in row @xmath112 of @xmath346 having value @xmath357 * else * set @xmath358=0 $ ] , and , if no other elements @xmath357 are in row @xmath112 , set @xmath349 and return to step @xmath343 ;        the correctness of the procedure is straightforward , since we create _ all _ the possible minimal valuations for the entries of @xmath8 which prevent it from being smooth , and successively , we merge them with _ all _ the possible solutions for its remaining smooth entries .      however , one can ask whether such a search always produces an output in an amount of time which is polynomial in the dimensions @xmath2 and @xmath3 of the solution .",
    "the answer is given in the proof of the following          step @xmath103 : the procedure asks for summing in all possible ways an element from each of the @xmath360 sequences of valuations created in step @xmath5 .",
    "since each sum is performed in @xmath230 , then the total complexity remains polynomially bounded by @xmath2 and @xmath3 .",
    "step @xmath109 : the computation of the matrix @xmath361 , the polynomial procedure recsmoothall and the merging process of @xmath345 with @xmath346 are performed a polynomial number of times , without increasing the total complexity of the algorithm ."
  ],
  "abstract_text": [
    "<S> a binary matrix can be scanned by moving a fixed rectangular window ( sub - matrix ) across it , rather like examining it closely under a microscope . with each viewing , </S>",
    "<S> a convenient measurement is the number of @xmath0 visible in the window , which might be thought of as the _ luminosity _ of the window . the _ rectangular scan _ of the binary matrix is then the collection of these luminosities presented in matrix form . we show that , at least in the technical case of a _ smooth _ </S>",
    "<S> @xmath1 binary matrix , it can be reconstructed from its rectangular scan in polynomial time in the parameters @xmath2 and @xmath3 , where the degree of the polynomial depends on the size of the window of inspection . for an arbitrary binary matrix </S>",
    "<S> , we then extend this result by determining the entries in its rectangular scan that preclude the smoothness of the matrix .    </S>",
    "<S> _ keywords : _ discrete tomography , reconstruction algorithm , computational complexity , projection , rectangular scan . </S>"
  ]
}