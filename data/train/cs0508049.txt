{
  "article_text": [
    "whenever information is transmitted across a channel , we have to ensure its integrity against errors .",
    "while data may originate in a multitude of applications , at some core level of the communication system , it is usually encoded as a string of zeros and ones of fixed length .",
    "protection against transmission errors is provided by intelligently adding redundant bits to the information symbols , thus effectively restricting the set of possibly transmitted sequences of bits to a fraction of all possible sequences .",
    "the set of all possibly transmitted data vectors is called a code , and the elements are called codewords . a classical measure of goodness of a code is the code s _ minimum hamming distance _ , i.e. , the minimum number of coordinates in which any two distinct codewords differ .",
    "in fact , a large part of traditional coding theory is concerned with finding the fundamental trade - offs between three parameters : the length of the code , the number of codewords in the code , and the minimum distance of the code .",
    "it is well - known that the minimum hamming distance @xmath0 of a code reflects its guaranteed error - correcting capability in the sense that any error pattern of weight at most @xmath1 can be corrected .",
    "however , most codes can , with high probability , correct error patterns of substantially higher weight .",
    "this insight is the cornerstone of modern coding theory which attempts to capitalize on the full correction capability of a code .",
    "one of the most successful realizations of this phenomenon is found in binary low - density parity - check ( ldpc ) codes .",
    "these codes come equipped with an iterative message - passing algorithm to be performed at the receiver s end which is extremely efficient and corrects , with high probability , many more error patterns than guaranteed by the minimum distance .    in this situation ,",
    "we are left with the problem of finding new mathematically precise concepts that can take over the role of minimum hamming distance for such high performance codes .",
    "one of the main contributions of this paper is the identification of such a concept , namely , the _ fundamental cone _",
    "@xcite of a code .",
    "interestingly , the same cone appears when one is considering low - complexity decoding approaches based on solving relaxations of linear programs for maximum - likelihood decoding @xcite .",
    "we give here a brief motivation of the concept .    as a binary linear code",
    ", an ldpc code @xmath2 is defined by a parity - check matrix @xmath3 .",
    "the strength of the iterative decoding algorithm , i.e. , its low complexity , comes from the fact that the algorithm operates locally on a so - called tanner graph representing the matrix @xmath3 .",
    "however , this same fact also leads to a fundamental weakness of the algorithm : because it acts locally , the algorithm can not distinguish if it is acting on the graph itself or on some finite unramified cover of the graph .",
    "this leads to the notion of _ pseudo - codewords _ , which arise from codewords in codes corresponding to the covers and which compromise the decoder . thus to understand the performance of ldpc codes",
    ", we must understand the graph covers and the codes corresponding to them . as will be seen later in the paper ,",
    "this is tantamount to understanding a cone in @xmath4 defined by inequalities arising from @xmath3 , called the _ fundamental cone_. we show that the pseudo - codewords of @xmath2 ( with respect to @xmath3 and the associated tanner graph ) are precisely the integral points in the cone which , modulo 2 , reduce to the codewords of @xmath2 .",
    "we emphasize below a few properties of the fundamental cone which appear to be central to a crisp mathematical characterization .",
    "a recurring theme is that these properties depend upon the representation of the code as the kernel of a given parity - check matrix , and not solely upon the code itself as a vector space .",
    "this showcases the modern viewpoint of coding theory : whereas , classically , the quality of a code was measured in terms of properties ( e.g. , length , dimension , minimum distance ) of the collection of codewords comprising the code , the quality of a code is now measured in terms of properties ( e.g. , existence of pseudo - codewords of small weight ) of a particular representation of the code .",
    "thus , from the modern , algorithmic point of view , a given collection of codewords might be described by two different parity check matrices , one of which might be considered to be very good while another would be very bad .    *",
    "the fundamental cone depends on the representation chosen for the code in terms of a parity - check matrix .",
    "note that a linear code has many different parity - check matrices and hence many different cones .",
    "this reflects the property of message - passing algorithms that both the complexity and the performance are functions of the structure and , in particular , the sparsity of the parity - check matrix . *",
    "the fundamental cone is an essentially geometric concept relating only to the parity - check matrix and independent of the channel on which the code is employed .",
    "thus we can study codes and their parity - check matrices independently of a specific application . *",
    "the fundamental cone has close ties with well - established mathematical objects . if the parity - check matrix is chosen to be the ( highly redundant ) matrix containing all words in the dual of the given code , it is readily identified as the metric cone of a binary matroid ( * ? ? ?",
    "* ch.27 ) , and it is well - studied in this special case . furthermore , for the particular class of ldpc codes called _ cycle codes _ , it is shown in @xcite that the fundamental cone is identified with the newton polyhedron of hashimoto s _ edge zeta function _",
    "@xcite of the _ normal graph _ associated to the tanner graph of the code .",
    "the last bullet above implies that the pseudo - codewords of a cycle code can be read off from the monomials occurring in the power series expansion of the associated zeta function .",
    "this gives another characterization of the pseudo - codewords for cycle codes .",
    "inspired by this result , we draw an analogous connection between the pseudo - codewords of a general ldpc code ( with respect to a given parity - check matrix ) , and the monomials of a certain type occurring in the power series expansion of the edge zeta function of the associated tanner graph .    in summary , we believe that the here - begun study of codes from the perspective of their efficient representation , as reflected in the fundamental polytope , holds the key to a thorough understanding of high performance codes and message - passing decoding algorithms .    the remainder of this paper is organized as follows . in section  [ section : ldpc ] , we give background on ldpc codes and pseudo - codewords .",
    "section  [ section : liftings ] provides a technical yet crucial result about graph covers and their associated matrices .",
    "a characterization of pseudo - codewords in the general case via the fundamental cone is given in section  [ section : fundamental : cone ] . in section",
    "[ section : cycle : codes ] we restrict our attention to the special case of cycle codes and draw the connection to hashimoto s edge zeta function .",
    "we return to the general case in section  [ section : bit - even ] , where we show that every ldpc code can be realized as a punctured subcode of a code of the type considered in the previous section .",
    "using the results of section  [ section : cycle : codes ] , we then characterize the pseudo - codewords in the general case .",
    "we begin with a definition .",
    "any subspace @xmath2 of @xmath5 is called a _ binary linear code _ of _ length _ @xmath6 .",
    "if @xmath2 is described as the null space of some matrix @xmath3 , i.e. , @xmath7 then @xmath3 is called a _ parity - check matrix _ for @xmath2 .",
    "if @xmath3 is sparse of @xmath8 matrices with @xmath9 growing increasingly large but @xmath10 remaining fixed , `` sparse '' means that the number of 1 s in the columns of the @xmath11 is bounded by some constant . ] , we call @xmath2 a _ low - density parity - check ( ldpc ) _ code .",
    "notice that the columns of @xmath3 correspond to the coordinates , i.e. , _ bits _ , of the codewords of @xmath2 , and the rows of @xmath3 give relations , i.e. , _ checks _ , that these coordinates must satisfy .",
    "although every code has many parity - check matrices , we will always fix a parity - check matrix @xmath3 for each code we discuss .",
    "the iterative decoding algorithms mentioned in section  [ section : overview ] operate on a bipartite graph , called the _ tanner graph _ , associated to the matrix @xmath3 .",
    "[ def : graph ] an _ undirected graph _ @xmath12 consists of a set @xmath13 of _ vertices _ and a collection @xmath14 of 2-subsets of @xmath13 called _",
    "edges_. we say @xmath15 has _ multiple edges _ if some 2-subset @xmath16 of @xmath13 appears in @xmath14 at least twice .",
    "we say two vertices @xmath17 are _ adjacent _ if the set @xmath16 is an edge . in this case",
    ", we say the edge @xmath16 is _ incident _ to both @xmath18 and @xmath19 . for @xmath20",
    ", we write @xmath21 for the _ neighborhood _ of @xmath18 , i.e. , the collection of vertices of @xmath15 which are adjacent to @xmath18 .",
    "a _ bipartite graph _ with _ partitions _",
    "@xmath22 and @xmath23 is an undirected graph @xmath12 such that @xmath13 can be written as a disjoint union @xmath24 with no two vertices in @xmath22 ( resp . , @xmath23 )",
    "adjacent .",
    "we make the following conventions : unless otherwise specified , our graphs will always be undirected and our bipartite graphs will never have multiple edges .",
    "[ def : ldpc ] let @xmath25 be the ldpc code determined by the ( sparse ) @xmath26 matrix @xmath27 .",
    "the _ tanner graph _",
    "@xmath28 is the bipartite graph defined as follows .",
    "the vertex set consists of the _ bit nodes _ @xmath29 and the _ check nodes _ @xmath30 . the set @xmath31 is an edge if and only if @xmath32 .",
    "notice that the bit nodes in the tanner graph correspond to the columns of @xmath3 , the check nodes correspond to the rows of @xmath3 , and the edges record which bits are involved in which checks .",
    "in other words , the graph @xmath28 records the matrix @xmath3 , and hence the code @xmath2 , graphically : a binary assignment of the bit nodes @xmath33 is a codeword in @xmath2 if and only if the binary sum of the values at the neighbors of each check node is zero .",
    "because we have fixed a parity - check matrix @xmath3 for @xmath2 from the start , we will also refer to @xmath34 as the tanner graph of the code @xmath2 .",
    "[ example : dumbbell : code ] let @xmath2 be the binary linear code of length @xmath35 with parity - check matrix @xmath36     of example  [ example : dumbbell : code].,width=288 ]    two representations of the tanner graph @xmath34 associated to @xmath3 are given in figure  [ fig : dumbbell : code ] , where bit and check nodes are represented by empty circles and filled squares , respectively .",
    "the graph on the left is a traditional rendering of a bipartite graph , but the one on the right is easier to work with .",
    "the vector @xmath37 is a codeword in @xmath2 .",
    "this can be checked either by computing @xmath38 or by assigning the value @xmath39 to each bit node @xmath40 in @xmath41 and verifying that the binary sum of the values at the neighbors of each check node @xmath42 in @xmath41 is zero .",
    "@xmath43    any iterative message - passing decoding algorithm , roughly speaking , operates as follows ; see @xcite for a more precise description .",
    "a received binary word gives an assignment of @xmath44 or @xmath45 together with a reliability value at each of the bit nodes on the tanner graph .",
    "each bit node then broadcasts this bit assignment and reliability value to its neighboring check nodes .",
    "next , each check node makes new estimates based on what it has received from the bit nodes and sends these estimates back to its neighboring bit nodes . by iterating this procedure ,",
    "one expects a codeword to emerge quickly .",
    "notice that the algorithm is acting _ locally _ , i.e. , at any stage of the algorithm , the decision made at each vertex is based on information coming only from the neighbors of this vertex .",
    "it is this property of the algorithm which causes both its greatest strength ( speed ) and its greatest weakness ( non - optimality ) . in order to quantify this weakness",
    ", we will need another definition .",
    "[ def : cover ] an _ unramified , finite cover _ , or , simply , a _ cover _ of a graph @xmath12 is a graph @xmath46 along with a surjection @xmath47 which is a graph homomorphism ( i.e. , @xmath48 takes adjacent vertices of @xmath49 to adjacent vertices of @xmath15 ) such that for each vertex @xmath20 and each @xmath50 , the neighborhood @xmath51 of @xmath52 is mapped bijectively to @xmath21 .",
    "a cover is called an _ @xmath53-cover _ , where @xmath53 is a positive integer , if @xmath54 for every vertex @xmath18 in @xmath13 .",
    "[ example : dumbbell : code : cover ]    -cover of the code @xmath2 from example  [ example : dumbbell : code ] , as described in example  [ example : dumbbell : code : cover].,width=288 ]    we return to the code @xmath2 with chosen parity - check matrix @xmath3 of example  [ example : dumbbell : code ] ; the corresponding tanner graph @xmath34 was given in figure  [ fig : dumbbell : code ] .",
    "an example of a 2-cover ( or _ double - cover _ ) @xmath55 of @xmath41 is given in figure  [ fig : dumbbell : code : cover ] .",
    "the bipartite graph @xmath55 is the tanner graph for a code @xmath56 of length @xmath57 .",
    "the parity - check matrix @xmath58 for the code @xmath56 associated to @xmath55 is the @xmath59 matrix @xmath60 where @xmath61 the rows are ordered to correspond to the check nodes @xmath62 , @xmath63 ,  , @xmath64 , @xmath65 , and",
    "the columns are ordered to correspond to the bit nodes @xmath66 , @xmath67 ,  , @xmath68 , @xmath69 .",
    "@xmath43    suppose @xmath41 is a tanner graph for the binary linear code @xmath70 and @xmath55 is an @xmath53-cover of @xmath41 for some @xmath71 .",
    "let @xmath72 be the binary linear code determined by @xmath55 . to indicate that the coordinates of @xmath73 are ordered as in example  [ example : dumbbell : code : cover ] with each successive block of @xmath53 coordinates lying above a single coordinate of @xmath5 , we will write an element @xmath74 of @xmath73 as @xmath75 every codeword in @xmath2 yields a codeword in @xmath56 by `` lifting '' : if @xmath76 is in @xmath2 , then the vector @xmath77 where @xmath78 for @xmath79 and @xmath80 , is in @xmath56 . however , there are also codewords in @xmath56 which are _ not _ liftings of codewords in @xmath2 .",
    "[ example : dumbbell : code : cover : codewords ] once again , let @xmath2 be the code of examples  [ example : dumbbell : code ] and [ example : dumbbell : code : cover ] , and let @xmath56 be the code corresponding to the double - cover @xmath55 of the tanner graph @xmath41 for @xmath2 , as in example  [ example : dumbbell : code : cover ]",
    ". the codeword @xmath81 of @xmath2 lifts to the codeword @xmath82 of @xmath56 .",
    "although it is easily checked that the vector @xmath83 is a codeword in @xmath56 , it is certainly not a lifting of any codeword in @xmath2 .",
    "@xmath43    notice that , in general , if @xmath84 is a codeword in the code corresponding to some @xmath53-cover @xmath55 of @xmath41 , then for any permutations @xmath85 ,  , @xmath86 on @xmath87 , there is an @xmath53-cover @xmath88 of @xmath41 such that @xmath89 is a codeword in the code corresponding to @xmath88 .",
    "this motivates the next definition .",
    "[ def : pseudo - codeword ] let @xmath90 be a binary linear code with tanner graph @xmath41 and let @xmath84 be a codeword in the code @xmath56 corresponding to some @xmath53-cover @xmath55 of @xmath41 .",
    "the _ unscaled pseudo - codeword _ corresponding to @xmath91 is the vector @xmath92 where , for @xmath93 , @xmath94 is the number of nonzero @xmath95 , @xmath96 .",
    "the _ normalized pseudo - codeword _ corresponding to @xmath91 is the vector @xmath97 where each @xmath98 is a rational number , @xmath99 , given by @xmath100 for @xmath101 .",
    "[ example : dumbbell : code : pseudocodewords ] the unscaled pseudo - codeword corresponding to the codeword @xmath91 on the @xmath102-cover of example  [ example : dumbbell : code : cover : codewords ] is @xmath103 .",
    "the corresponding normalized pseudo - codeword is @xmath104 .",
    "@xmath43    notice that if @xmath105 is a codeword in our original code and @xmath106 is the lifting of this codeword to the code corresponding to some finite cover of the tanner graph , then @xmath107 .",
    "indeed , the entries of a normalized pseudo - codeword will be entirely 0 s and 1 s",
    "if and only if it comes from the lifting of some actual codeword . otherwise , there will be at least one entry which is non - integral .",
    "the key issue with graph covers is that locally , any cover of a graph looks exactly like the original graph .",
    "thus , the fact that the iterative message - passing decoding algorithm is operating locally on the tanner graph @xmath34 means that the algorithm can not distinguish between the code defined by @xmath41 and any of the codes defined by finite covers of @xmath41 .",
    "this implies that all the codewords in all the covers are competing to be the best explanation of the received vector .",
    "to make this more precise , we assume for simplicity that we are operating on the binary symmetric channel ; the situation for other channels is similar ( see @xcite ) . under this assumption , a transmitted bit",
    "is received correctly with probability @xmath108 and incorrectly with probability @xmath109 where @xmath110 .",
    "the goal of any decoder is to find the codeword @xmath111 that best explains ( in some sense ) the received vector @xmath112 . for the binary symmetric channel , a _",
    "maximum likelihood _ decoder will find the codeword which is closest in hamming distance to @xmath113 . on the other hand , because the iterative decoder of an ldpc code acts locally on the tanner graph associated to the code , it allows all codewords from all finite covers to compete to be the best explanation of @xmath113 . in a sense",
    ", it automatically lifts @xmath113 to vectors @xmath114 for every @xmath71 and searches for a codeword @xmath91 in some code @xmath72 corresponding to some @xmath53-cover of the tanner graph , for some @xmath115 , such that @xmath116 times the hamming distance from ( the appropriate ) @xmath117 to @xmath91 is minimal among all codewords in all codes corresponding to all finite covers of the tanner graph .",
    "note that even if fewer than @xmath1 errors have occurred ( where @xmath118 is the minimum hamming distance of the code ) , there may be codewords in covers which are at least as close , in this sense , to @xmath113 as is the unique closest codeword .",
    "[ example : dumbbell : code : decoding ] consider again the code @xmath2 from examples  [ example : dumbbell : code ] , [ example : dumbbell : code : cover ] , and [ example : dumbbell : code : cover : codewords ] .",
    "assume that we are transmitting over a binary symmetric channel and we receive the vector @xmath119 .",
    "one can check that the codeword @xmath81 satisfies @xmath120 and that the hamming distance from @xmath113 to any other codeword in @xmath2 is larger than @xmath121 .",
    "therefore , a maximum - likelihood decoder would output the codeword @xmath105 when @xmath113 is received .",
    "but the iterative message - passing decoding algorithm allows all the codewords in all the codes corresponding to all the finite covers to compete .",
    "in particular , the vector @xmath122 from example  [ example : dumbbell : code : cover ] lies in the code @xmath56 corresponding to the double cover @xmath55 of @xmath41 and is hence a competitor .",
    "letting @xmath123 be the lifting of @xmath113 to @xmath124 , we see that @xmath125 times the hamming distance from @xmath117 to @xmath91 is also 3 .",
    "hence @xmath91 is just as attractive to the iterative decoder as @xmath105 is .",
    "the iterative decoder becomes confused .",
    "@xmath43    the situation observed in example  [ example : dumbbell : code : decoding ] happens in general : one can easily exhibit a received vector @xmath113 and a codeword @xmath91 in an @xmath53-cover for some @xmath53 such that @xmath116 times the distance from @xmath117 to @xmath91 is at most @xmath126 for any codeword @xmath105 in the original code . as mentioned above",
    ", there is nothing special about the binary symmetric channel , and so the above statements can easily be generalized to other channels .",
    "thus , in order to understand iterative decoding algorithms , it is crucial to understand the codewords in the codes corresponding to all finite covers of @xmath28 .",
    "the remainder of this paper is devoted to this task .",
    "we saw in section  [ section : ldpc ] above that understanding finite covers of graphs is crucial to understanding the performance of the iterative decoding algorithm used for ldpc codes .",
    "the main result of this section , theorem  [ theorem : general : path : lifting ] , will help us to reach this goal .",
    "though it is rather technical , the remainder of the paper hinges upon it .",
    "we first state a lemma , the proof of which follows immediately from the definition of an @xmath53-cover ( definition  [ def : cover ] ) .",
    "[ lemma : permutation ] let @xmath127 be the parity - check matrix associated to the tanner graph @xmath41 and let @xmath55 be an @xmath53-cover of @xmath41 .",
    "let @xmath128 , @xmath80 and @xmath129 , be the parity - check matrix associated to @xmath55 . then for each @xmath130 and @xmath131 , there is a permutation @xmath132 on @xmath133 such that @xmath134 if and only if @xmath32 and @xmath135 .",
    "conversely , choosing permutations @xmath132 on @xmath133 for all @xmath130 and @xmath131 uniquely and completely determines an @xmath53-cover @xmath55 of @xmath41 and its corresponding parity - check matrix @xmath58 .",
    "a simple interpretation of lemma  [ lemma : permutation ] is that if @xmath3 has associated tanner graph @xmath41 and @xmath55 is an @xmath53-cover of @xmath41 , then the matrix @xmath58 associated to @xmath55 can be obtained by replacing each 0 of @xmath3 with an @xmath136 matrix of 0 s and each 1 of @xmath3 with a suitably chosen @xmath136 permutation matrix .",
    "we need one more definition before we can state the main result of this section .",
    "[ def : path : backtrackless : edge - disjoint ] let @xmath137 be a graph . fix an ordering of the edges , so that we have @xmath138 .",
    "a sequence of edges @xmath139 of @xmath15 is a _ path _ on @xmath15 if the edges @xmath140 can be directed so that @xmath141 terminates where @xmath142 begins for @xmath143 .",
    "we say the path is _ backtrackless _ if for no @xmath144 do we have @xmath145 .",
    "we say two paths are _ edge - disjoint _ if they do not share an edge .",
    "the next theorem is the main result of this section .",
    "it gives conditions under which a collection of edges , with multiplicities , on a graph may be lifted to a union of edge - disjoint paths on some finite cover of the graph .",
    "it will be used in section  [ section : fundamental : cone ] to show that every vector of nonnegative integers which lies in the fundamental cone and which reduces modulo 2 to a codeword must be a pseudo - codeword , and that result will be used in turn in section  [ section : bit - even ] to characterize pseudo - codewords in the case in which all bit nodes in the tanner graph have even degree .",
    "the proof is constructive , providing an algorithm to produce the desired paths .",
    "[ theorem : general : path : lifting ] let @xmath146 be a bipartite graph .",
    "suppose that to each @xmath147 there is assigned a nonnegative integer @xmath148 such that    1 .",
    "[ hypoth : m_x ] for each @xmath149 , there is a nonnegative integer @xmath150 such that @xmath151 for every edge @xmath152 incident to @xmath153 .",
    "[ hypoth : sum : m_x : even ] for each @xmath154 , the sum @xmath155 is even .",
    "[ hypoth : ineq ] for each @xmath154 and each @xmath156 , we have @xmath157 .",
    "then there is a finite cover @xmath158 and a union @xmath159 of backtrackless paths @xmath160 on @xmath55 such that the endpoints of each @xmath160 are in @xmath161 and such that    1 .",
    "[ concl : tf : at : most : once ] each @xmath162 occurs in @xmath163 at most once .",
    "[ concl : edge : at : most : once ] each @xmath164 occurs in @xmath163 at most once .",
    "[ concl : empty : or : full ] at each @xmath165 , either all or none of the edges incident to @xmath166 in @xmath55 occur in @xmath163 .",
    "[ concl : pi(delta)=gamma ] for each @xmath147 , we have @xmath167 .",
    "we will refer to @xmath168 as the set of bit nodes of @xmath41 and to @xmath169 as the set of check nodes of @xmath41 .",
    "let @xmath170 be the multiset of edges of @xmath41 which contains , for each @xmath147 , a total of @xmath148 copies of @xmath152 . for each @xmath154 ,",
    "let @xmath171 be the number of edges in @xmath170 which are incident to @xmath172 , counted with multiplicity .",
    "in other words , @xmath173 set @xmath174 .",
    "we construct an @xmath53-cover @xmath175 and the desired @xmath163 explicitly .",
    "the vertex set of @xmath55 is @xmath176 and the map @xmath175 is given by @xmath177 , @xmath178 .",
    "we now need to describe the edges of @xmath55 and the disjoint paths @xmath160 .",
    "we will first describe the edges of @xmath55 which are involved in the @xmath160 s , and then we will describe the remaining edges of @xmath55 .",
    "the bit nodes of @xmath55 involved in the @xmath160 s are @xmath179 and the check nodes of @xmath55 involved in the @xmath160 s are @xmath180 .",
    "start by writing out , for each @xmath149 , @xmath150 copies of the list @xmath181 of neighbors of @xmath153 ; label these lists using the bit nodes @xmath182 of @xmath55 lying above @xmath153 so that @xmath183 are the @xmath150 copies of @xmath181 .",
    "notice that there is a 1 - 1 correspondence between the edges in @xmath170 ( with multiplicity ) and pairs @xmath184 where @xmath172 occurs in @xmath185 .",
    "similarly , write out , for each @xmath154 , one copy of the list @xmath186 of neighbors of @xmath172 , but then replace each @xmath153 appearing in the list with the bit nodes @xmath187 of @xmath55 so that the list has length @xmath171 ; call this list @xmath188 .",
    "again , we have a 1 - 1 correspondence between the edges in @xmath170 ( with multiplicity ) and the pairs @xmath189 , where @xmath190 occurs in @xmath188 .",
    "we will construct the @xmath160 s one vertex at a time .",
    "each time we add a vertex ( except for the initial vertex of each @xmath160 ) , we are choosing an edge from @xmath170 and lifting it to @xmath55 , and so we will cross one check node off a list labeled by a bit node and one bit node off a list labeled by a check node . thus the lists @xmath185 and @xmath188 change as the algorithm proceeds .",
    "we will need some terminology and notation in the construction :    * at any given point in the algorithm and for any vertex @xmath18 , let the _ current weight _ of @xmath18 be the number of elements in @xmath191 .",
    "* at any given point in the algorithm and for @xmath149 and @xmath192 , set @xmath193 .",
    "notice that since , as mentioned above , the lists @xmath191 change as the algorithm proceeds , the current weight of a vertex and the value @xmath194 for @xmath149 and @xmath154 do as well . at the beginning ,",
    "the current weight of @xmath190 ( @xmath149 and @xmath195 ) is @xmath196 , the current weight of @xmath154 is @xmath171 , and @xmath197 if @xmath198 and @xmath44 otherwise . to construct the @xmath160 s which form @xmath163 ,",
    "we proceed as follows :    1 .",
    "[ firstbit ] choose a bit node of @xmath55 whose current weight is at least that of every other bit node of @xmath55 and take it to be the first vertex in a path @xmath199 .",
    "[ nextcheck ] suppose we have just added the bit node @xmath190 to @xmath199 , where @xmath149 and @xmath200 , and that @xmath201 .",
    "choose a check node @xmath202 such that the current weight of @xmath172 is at least that of any other check node in @xmath185 .",
    "write down @xmath203 as the next vertex of @xmath199 , where @xmath144 is the number of times ( including this one ) that @xmath172 has been used so far in all of @xmath163 .",
    "cross @xmath172 off @xmath185 and cross @xmath190 off @xmath188 .",
    "[ nextbit ] suppose we have just added the bit node @xmath190 and then the check node @xmath203 to @xmath199 , where @xmath149 , @xmath154 , @xmath195 , and @xmath204 .",
    "let @xmath205 denote the set of vertices in @xmath188 which are not of the form @xmath40 for any @xmath130 ; claim  [ claim : f : minus : x : nonempty ] below shows that @xmath206 is nonempty .",
    "let @xmath207 be such that @xmath208 for all @xmath19 such that @xmath209 for some @xmath210 and the current weight of @xmath211 is at least that of any other @xmath212 .",
    "append the vertex @xmath211 to @xmath199 .",
    "cross @xmath211 off @xmath188 and @xmath172 off @xmath213 .",
    "if @xmath213 is now empty , then @xmath199 is complete and will be one of the @xmath160 s in the disjoint union @xmath163 .",
    "otherwise , return to step  ( [ nextcheck ] ) .",
    "4 .   [ done ] if there are nonempty lists remaining , start over with step  ( [ firstbit ] ) on the remaining set of vertices . otherwise , @xmath163 is the union of the @xmath160 s and the algorithm is complete .",
    "it is now clear from the construction and hypothesis  ( h.[hypoth : m_x ] ) that @xmath214 is a union of paths satisfying conditions  ( c.[concl : tf : at : most : once ] ) , ( c.[concl : edge : at : most : once ] ) and ( c.[concl : pi(delta)=gamma ] ) .",
    "claim  [ claim : f : minus : x : nonempty ] below shows that each @xmath160 is backtrackless , and hypothesis  ( h.[hypoth : sum : m_x : even ] ) implies that the ending vertices must be bit nodes since the starting vertices are . to see that condition  ( c.[concl : empty : or : full ] ) holds , let @xmath149 and consider two cases . if @xmath215 , then @xmath190 is not involved in @xmath163 and so no edge incident to @xmath190 occurs in @xmath163 .",
    "if @xmath216 , we have @xmath217 edges incident to @xmath190 involved in @xmath163 . since the degree of @xmath190 in @xmath55 is to be the same as the degree of @xmath153 in @xmath41 , we have that all edges which are to be incident to @xmath190 in @xmath55 occur already in @xmath163 .",
    "all that remains is to add additional edges to @xmath55 so that @xmath175 is an @xmath53-cover . in order for @xmath175 to be an @xmath53-cover of @xmath41",
    ", we must have , for each bit node @xmath153 of @xmath41 and each @xmath218 with @xmath80 , @xmath219 and @xmath220    let @xmath149 . as mentioned above",
    ", these properties hold already for @xmath190 with @xmath195 , and we have constructed no edges involving the @xmath221 other bit nodes @xmath190 of @xmath55 .",
    "similarly , for each check node @xmath172 with @xmath198 , we know that exactly @xmath150 of the vertices @xmath222 are connected by an edge to some @xmath223 , which means that there are @xmath221 vertices @xmath224 which are not connected by an edge to any @xmath223 .",
    "we can pair up these @xmath221 bit nodes @xmath190 and these @xmath221 check nodes @xmath224 any way we please . in particular , this will not change any bit nodes already involved in our @xmath163 , and when we are done doing this for each @xmath153 , we will have the @xmath53-cover @xmath175 and the @xmath163 we seek .",
    "the proof of theorem  [ theorem : general : path : lifting ] will be complete once we have proven claim  [ claim : f : minus : x : nonempty ] .",
    "[ claim : f : minus : x : nonempty ] steps  ( [ nextcheck ] ) and ( [ nextbit ] ) can always be performed without introducing a backtrack .",
    "in particular , the set @xmath206 in step  ( [ nextbit ] ) of the algorithm is nonempty .    for each bit",
    "node @xmath225 , let @xmath226 be the value of @xmath227 at the _ start _ of step  ( [ nextcheck ] ) and let @xmath228 be the value of @xmath227 at the _ end _ of step  ( [ nextbit ] ) . for each @xmath229 and each @xmath154",
    ", let @xmath230 denote the inequality @xmath231 and let @xmath232 denote the inequality @xmath233 notice that at the start of the algorithm , @xmath230 is true for every @xmath19 and @xmath172 by hypothesis  ( h.[hypoth : ineq ] ) .",
    "suppose @xmath230 holds for every @xmath19 and @xmath172 and that we are at the start of step  ( [ nextcheck ] ) , having just appended @xmath190 to @xmath199 .",
    "we will show that we can perform steps  ( [ nextcheck ] ) and ( [ nextbit ] ) without introducing a backtrack , and that the inequalities @xmath232 will hold when we are done with these two steps .",
    "this will mean that we can continue to perform these steps until we are forced to move on to step  ( [ done ] ) .    since each check node occurs in @xmath185 at most once , we know that @xmath185 no longer contains the check node we appended to @xmath163 just before we appended @xmath190 .",
    "so , since @xmath185 is , by assumption , nonempty , step  ( [ nextcheck ] ) can be performed and it does not introduce a backtrack ; let @xmath172 be the check node appended to @xmath163 in that step , so that @xmath234 . since @xmath235 held before step  ( [ nextcheck ] ) , we know that there is at least one @xmath236 such that @xmath212 for some @xmath130 , i.e. , @xmath206 is nonempty .",
    "so step  ( [ nextbit ] ) can be performed , and we have @xmath237 for the @xmath238 chosen in that step . for all other bit nodes @xmath19 , we have @xmath239 .",
    "we now need to show that the inequality @xmath232 holds for every @xmath225 .",
    "first note that @xmath240 is obtained from @xmath235 by subtracting 1 from each side .",
    "since @xmath235 held , @xmath240 must also .",
    "the same argument shows that @xmath241 holds .",
    "further , @xmath232 holds whenever @xmath242 since what appears on the left - hand side of @xmath232 is certainly nonnegative .",
    "hence we need only show that @xmath232 holds for @xmath243 with @xmath244 .",
    "so suppose @xmath244 .",
    "consider first the case where @xmath245 for all @xmath246 .",
    "then the inequality @xmath232 says @xmath247 if @xmath248 , then , since @xmath249 is even , we know that @xmath250 and so @xmath232 holds . otherwise , we have @xmath251 and so , since @xmath252 , we again see that @xmath232 holds .",
    "now consider the case that there is at least one bit node @xmath253 with @xmath254 .",
    "then it is enough to show that @xmath255 but this is the same as @xmath256 since @xmath257 and each of @xmath258 and @xmath259 is at least 1 , this latter inequality holds and so @xmath232 does as well .",
    "this completes the proof of theorem  [ theorem : general : path : lifting ] .",
    "the pseudo - codewords are described for general ldpc codes by the fundamental cone .",
    "[ def : fundamental : cone ] let @xmath127 be an @xmath26 matrix with @xmath260 for each @xmath131 and @xmath130 .",
    "the _ fundamental cone _",
    "@xmath261 of @xmath3 is the set of vectors @xmath262 such that , for all @xmath79 and @xmath263 , we have @xmath264 and @xmath265    the matrices @xmath3 we consider will be parity - check matrices of binary linear codes . as such , we will sometimes be doing computations over @xmath266 ( e.g. , when deciding if a vector is a codeword ) and sometimes over @xmath267 ( e.g. , when deciding if a vector is in the fundamental cone ) . although the field over which we are working should usually be clear from context , we will typically specify it explicitly to help avoid confusion .",
    "[ example : dumbbell : code : fundamental : cone ] the fundamental cone @xmath261 for the parity - check matrix @xmath3 of the code @xmath2 from example  [ example : dumbbell : code ] is @xmath268 notice that the unscaled pseudocodeword @xmath103 and the normalized pseudocodeword @xmath269 from example  [ example : dumbbell : code : pseudocodewords ] lie in @xmath261 . @xmath43    the importance of the fundamental cone is illustrated below by theorem  [ theorem : pseudo - codewords : fundamental : cone ] , corollary  [ cor : normalized : in : cone ] and theorem  [ theorem : rays : dense : in : cone ] .",
    "[ theorem : pseudo - codewords : fundamental : cone ] let @xmath270 be an @xmath26 matrix with @xmath271 for each @xmath131 and @xmath130 , @xmath272 the fundamental cone of @xmath3 , and @xmath2 the binary code with parity - check matrix @xmath3 .",
    "let @xmath273 be a vector of integers",
    ". then the following are equivalent :    1 .",
    "@xmath274 is an unscaled pseudo - codeword .",
    "2 .   @xmath275 and @xmath276 .    in other words ,",
    "the unscaled pseudo - codewords are precisely those integer vectors in the fundamental cone which reduce modulo 2 to codewords .",
    "suppose that @xmath274 is an unscaled pseudo - codeword .",
    "then there is an @xmath53-cover @xmath55 of the tanner graph @xmath41 associated to @xmath3 and a codeword @xmath277 in @xmath56 , the code associated to @xmath55 , such that , for each @xmath130 , exactly @xmath94 of the coordinates @xmath278 , @xmath80 , are 1 .",
    "let @xmath279 , where @xmath263 , @xmath280 , @xmath281 , and @xmath129 , be the parity - check matrix of the code @xmath56 associated to @xmath55 .",
    "for each @xmath130 and @xmath131 , let @xmath132 be as in lemma  [ lemma : permutation ] , so that @xmath282 if and only if @xmath32 and @xmath283 . then the equation @xmath284 implies that , in @xmath266 , we have for each @xmath131 and @xmath285 , @xmath286 we shall use this observation to prove that @xmath275 and that @xmath276 .",
    "we first show that @xmath275 .",
    "clearly inequalities  ( [ def : fc : nonneg ] ) hold for @xmath287 , and we must show that inequalities  ( [ def : fc : allij ] ) do as well .",
    "thus , we must show that we have @xmath288 for each @xmath130 and @xmath131 .",
    "certainly ( [ temp : ineq ] ) holds if @xmath289 or if @xmath290 for all @xmath218 .",
    "so assume @xmath291 and not all @xmath278 are zero .",
    "for each @xmath218 with @xmath292 , set @xmath293",
    ". then we have by ( [ temp : observation ] ) that the integer sum @xmath294 is even .",
    "hence , for each @xmath218 with @xmath295 , there is at least one value of @xmath296 such that @xmath297 . note that as @xmath218 varies , the indices @xmath298 are all distinct . thus ( [ temp : ineq ] ) holds and so @xmath275 .    to see that @xmath299 , sum ( [ temp : observation ] ) over @xmath285 to get that for each @xmath131 , we have @xmath300 in @xmath266 . after interchanging the summations over @xmath285 and @xmath130",
    ", we may use the fact that @xmath132 is a permutation and substitute the summation variable @xmath285 by @xmath283 to get @xmath301 in @xmath266 , i.e. , @xmath276 .",
    "conversely , suppose @xmath302 and @xmath303 .",
    "let @xmath41 be the tanner graph associated to @xmath3 , and label the bit nodes of @xmath41 as @xmath304 to correspond to the @xmath6 columns of @xmath3 .",
    "for @xmath79 , set @xmath305 . for each edge @xmath152 of @xmath41 , there is a unique @xmath130 , @xmath79 , such that @xmath152 is incident to @xmath40 ; set @xmath306 for this value of @xmath130",
    ". then hypothesis  ( h.[hypoth : m_x ] ) of theorem  [ theorem : general : path : lifting ] is satisfied .",
    "that hypothesis  ( h.[hypoth : sum : m_x : even ] ) is satisfied follows directly from the fact that @xmath276 .",
    "the fact that @xmath275 says that hypothesis  ( h.[hypoth : ineq ] ) holds .",
    "thus theorem  [ theorem : general : path : lifting ] applies and we have a finite @xmath53-cover @xmath55 of @xmath41 for some @xmath71 and a union @xmath159 of backtrackless paths on @xmath55 starting and ending at bit nodes of @xmath55 and satisfying conditions  ( c.[concl : tf : at : most : once])(c.[concl : pi(delta)=gamma ] ) of that theorem . label the bit nodes of @xmath55 as @xmath307 for @xmath308 and @xmath80 , and let @xmath309 be the vector given by the rule @xmath292 if and only if @xmath307 occurs in @xmath163 , i.e. , if and only if @xmath310 .",
    "then conditions  ( c.[concl : tf : at : most : once])(c.[concl : pi(delta)=gamma ] ) ensure that @xmath311 is a codeword in the code corresponding to @xmath55 . finally , we see that the unscaled pseudo - codeword associated to @xmath311 is precisely @xmath274 .",
    "[ cor : normalized : in : cone ] every normalized pseudo - codeword lies in the fundamental cone .",
    "let @xmath312 be a normalized pseudo - codeword , where @xmath274 is an unscaled pseudo - codeword coming from a codeword in the code corresponding to some @xmath53-cover .",
    "then @xmath275 by theorem  [ theorem : pseudo - codewords : fundamental : cone ] and so @xmath313 since @xmath314 is a cone .",
    "[ theorem : rays : dense : in : cone ] the rays through the pseudo - codewords are dense in the fundamental cone .",
    "more precisely , let @xmath2 be a binary linear code with parity - check matrix @xmath3 , tanner graph @xmath34 and fundamental cone @xmath272 , and let @xmath315 .",
    "then for any @xmath316 , there is a pseudo - codeword @xmath274 such that @xmath317 for some @xmath318 .",
    "let @xmath6 be the length of @xmath2 , so that @xmath262 .",
    "choose @xmath319 sufficiently large so that the vector @xmath320 , where @xmath321 , satisfies @xmath322 for some @xmath323 .",
    "for example , if @xmath324 we may take @xmath325 and @xmath326 .",
    "we claim @xmath275 .",
    "certainly @xmath327 for @xmath328 , and we must show that inequalities  ( [ def : fc : allij ] ) hold for @xmath274 . since @xmath315 by assumption , we know that inequalities  ( [ def : fc : allij ] ) hold for @xmath329 . multiplying both sides by @xmath330 and taking ceilings yields , for all @xmath130 and @xmath131 , @xmath331    since each @xmath94 is even , we have @xmath276 , and so @xmath274 is an unscaled pseudo - codeword by theorem  [ theorem : pseudo - codewords : fundamental : cone ] .",
    "a binary linear code @xmath2 defined by a parity - check matrix @xmath3 is called a _ cycle code _ if all bit nodes in the associated tanner graph @xmath28 have degree @xmath102 .",
    "the pseudo - codewords of cycle codes were studied by the authors in @xcite . in this section , we review the results of that paper . in section  [ section : bit - even ] , we will show that every ldpc code can be realized as a punctured subcode of a cycle code , and use that relationship to give a nice characterization of the pseudo - codewords in the general case .",
    "the pseudo - codewords of cycle codes can be described in terms of the monomials appearing in the _ edge zeta function _",
    "@xcite , @xcite of the _ normal graph _ @xcite of the code .",
    "we begin with some definitions .",
    "[ def : normal : graph ] let @xmath2 be a cycle code with parity check matrix @xmath3 and associated tanner graph @xmath41 .",
    "let @xmath168 be the set of bit nodes of @xmath41 and let @xmath169 be the set of check nodes of @xmath41 .",
    "the _ normal graph _ of @xmath41 ( or of @xmath3 , or of @xmath2 ) is the graph @xmath332 with vertex set @xmath169 and edge set @xmath333 .",
    "[ example : dumbbell : code : normal : graph ] since all the bit nodes of the tanner graph of the code @xmath2 from example  [ example : dumbbell : code ] have degree 2 , @xmath2 is a cycle code",
    ". the normal graph @xmath2 is formed by simply dropping the bit nodes from the tanner graph .",
    "it is shown in figure  [ fig : dumbbell : code : normal : graph ] .",
    "the edge @xmath334 is labeled by @xmath335 .",
    "from example  [ example : dumbbell : code ] , as described in example  [ example : dumbbell : code : normal : graph].,width=288 ]    let @xmath12 be a graph .",
    "fix an ordering of the edges , so that we have @xmath138 .",
    "a sequence of edges @xmath336 of @xmath15 is called a _ cycle _ if the edges @xmath140 can be directed so that @xmath141 terminates where @xmath142 begins for @xmath143 and @xmath337 terminates where @xmath338 begins , i.e. , a cycle is a path which starts and ends at the same vertex .",
    "we say the cycle is _ edge - simple _ if @xmath339 for @xmath340 .",
    "we say the cycle is _ simple _ if each vertex of @xmath15 is involved in at most two of the edges @xmath338 , ",
    ", @xmath337 ; note that every simple cycle is necessarily edge - simple .",
    "characteristic vector _ of the edge - simple cycle @xmath341 on @xmath15 is the binary vector of length @xmath6 whose @xmath342 coordinate is 1 if and only if @xmath343 appears as some @xmath140 .",
    "the significance of the term _ cycle code _ is illustrated by the following lemma , which follows from euler s theorem ( * ? ? ?",
    "1.2.26 ) .",
    "[ lemma : cycle : code : def ]     1 .",
    "let @xmath2 be a cycle code with tanner graph @xmath41 and normal graph @xmath344 .",
    "then @xmath2 is precisely the code spanned by the characteristic vectors of the simple cycles in @xmath345 .",
    "2 .   let @xmath12 be any graph and let @xmath2 be the code spanned by the characteristic vectors of the simple cycles in @xmath15 .",
    "let @xmath346 be the bipartite graph described as follows : the vertex set of @xmath41 is @xmath347 . if @xmath147 and @xmath20 , then the pair @xmath348 is an edge of @xmath41 if and only if @xmath152 is incident to @xmath18 in @xmath41 .",
    "then the degree in @xmath41 of every vertex @xmath349 is 2 , and @xmath2 is precisely the cycle code with tanner graph @xmath41 .    in light of lemma",
    "[ lemma : cycle : code : def ] , if @xmath15 is any graph , we call the code spanned by the characteristic vectors of the simple cycles in @xmath15 the _ cycle code on @xmath15_. in order to define the edge zeta function of @xmath345 , we need some more definitions .    [ def : primitive : tailless : equivalence ] let @xmath350 be a cycle in a graph @xmath168 .",
    "we say @xmath170 is _ tailless _ if @xmath351 .",
    "we say @xmath170 is _ primitive _ if there is no cycle @xmath352 on @xmath168 such that @xmath353 with @xmath354 , i.e. , such that @xmath170 is obtained by following @xmath352 a total of @xmath355 times .",
    "we say that the cycle @xmath356 is _ equivalent _ to @xmath170 if there is some integer @xmath210 such that @xmath357 for all @xmath144 , where indices are taken modulo @xmath218 .",
    "it is easy to check that any simple cycle is primitive , backtrackless and tailless , and that the notion of equivalence given in definition  [ def : primitive : tailless : equivalence ] defines an equivalence relation on primitive , backtrackless , tailless cycles .",
    "also , it is clear that , up to equivalence , a cycle is backtrackless if and only if it is tailless",
    ". the edge zeta function of a graph is a way to enumerate all equivalence classes of primitive , backtrackless cycles and combinations thereof .",
    "[ def : edge : zeta : function:1 ] @xcite let @xmath170 be a path in a graph @xmath168 with edge set @xmath358 ; write @xmath350 to indicate that @xmath170 begins with the edge @xmath338 and ends with the edge @xmath337 .",
    "the _ monomial of @xmath170 _ is given by @xmath359 , where the @xmath360 s are indeterminants .",
    "the _ edge zeta function _ of @xmath168 is defined to be the power series @xmath361 $ ] given by @xmath362 \\in a(x ) }             \\big (               1 - g(\\gamma )             \\big)^{-1 } ,    \\end{aligned}\\ ] ] where @xmath363 is the collection of equivalence classes of backtrackless , tailless , primitive cycles in @xmath168 .",
    "although the product in the definition of the edge zeta function is , in general , infinite , the edge zeta function is a rational function @xcite . to make this precise",
    ", we must define the _ directed edge matrix _ of a graph .",
    "[ def : directed : edge : matrix]@xcite let @xmath364 be a graph with edge set @xmath138 . a _ directed graph _",
    "@xmath365 derived from @xmath168 is any pair @xmath366 where @xmath367 is a collection of ordered pairs of elements of @xmath13 such that , for @xmath308 , if @xmath368 then @xmath369 .",
    "( thus we may think of @xmath365 as having two directed edges , with opposite directions , for every edge of @xmath168 . )",
    "the _ directed edge matrix _ of @xmath365 is the @xmath370 matrix @xmath371 with @xmath372 the directed edge matrix of any directed graph @xmath365 of @xmath168 is called a _ directed edge matrix _ of @xmath168 .    @xcite the edge zeta function @xmath373 is a rational function .",
    "more precisely , for any directed edge matrix @xmath53 of @xmath168 , we have @xmath374 where @xmath375 is the identity matrix of size @xmath376 and @xmath377 is a diagonal matrix of indeterminants .",
    "the next theorem gives the connection between the pseudo - codewords of a cycle code and the edge zeta function of the normal graph of the code .",
    "its proof was sketched in @xcite , and it is generalized in theorem  [ theorem : bit - even : pseudo - codewords ] below to the case in which all bit nodes of the tanner graph have ( arbitrary ) even degree .",
    "[ theorem : pseudo - codewords : cycle : zeta ] let @xmath2 be a cycle code defined by a parity - check matrix @xmath3 having normal graph @xmath378 , let @xmath379 be the number of edges of @xmath345 , and let @xmath380 be the edge zeta function of @xmath345 .",
    "let @xmath381 be nonnegative integers",
    ". then the following are equivalent :    1 .",
    "@xmath382 has nonzero coefficient in @xmath383 .",
    "@xmath384 is an unscaled pseudo - codeword for @xmath2 with respect to the tanner graph @xmath34 .",
    "3 .   there is a backtrackless tailless cycle in @xmath345 which uses the @xmath385 edge exactly @xmath94 times for @xmath386 .",
    "[ def : exponent : vector ] the _ exponent vector _ of the monomial @xmath387 is the vector @xmath388 of the exponents of the monomial .",
    "[ example : dumbbell : code : zeta : function ] it is shown in @xcite that the edge zeta function of @xmath345 , where @xmath345 is the normal graph of the code @xmath2 given in example  [ example : dumbbell : code : normal : graph ] , satisfies @xmath389 expanding out the taylor series , we get the first several terms of @xmath383 : @xmath390 the exponent vectors of the first several monomials appearing in @xmath383 are    [ cols= \" < \" , ]     note that most of these lie within the integer span of the codewords in @xmath2 ; for example , @xmath391 the exceptions thus far are @xmath392 the first of these exceptions is exactly the unscaled pseudo - codeword of the codeword @xmath393 on the double - cover @xmath55 of the tanner graph @xmath41 in example  [ example : dumbbell : code : cover ] , and the rest lie within the integer span of this pseudo - codeword along with the codewords .",
    "@xmath43    the following corollary gives an algebraic description of the fundamental cone in the cycle code case .",
    "[ cor : newton : polyhedron : cycle ] the newton polyhedron of @xmath383 , i.e. , the polyhedron spanned by the exponent vectors of the monomials appearing with nonzero coefficient in the taylor series expansion of @xmath383 , is exactly the fundamental cone @xmath261 of the code @xmath2 .",
    "in section  [ section : cycle : codes ] , we saw that if @xmath2 is a cycle code on a graph @xmath345 , then the edge zeta function @xmath383 of the graph @xmath345 has the property that the monomials appearing with nonzero coefficient in the power series expansion of @xmath383 correspond exactly to the pseudo - codewords of @xmath2 .",
    "it is a natural goal to find such a function for more general ldpc codes . in this section ,",
    "we make some progress toward this goal .    a tanner graph is called _ bit - even _ if all the bit nodes in it have even degree .",
    "let @xmath394 be a binary matrix and let @xmath395 be the associated tanner graph .",
    "if @xmath396 is not bit - even , let @xmath3 be the matrix obtained from @xmath394 by duplicating each row of @xmath394 .",
    "then the tanner graph @xmath41 corresponding to @xmath3 is obtained from @xmath396 by duplicating all the check nodes and drawing an edge between a bit node and a copy of a check node if and only if there was an edge between the bit node and the original check node , so that @xmath41 is bit - even . certainly , @xmath394 and @xmath3 ( i.e. , @xmath396 and @xmath41 ) describe the same code . moreover , it is clear from definition  [ def : fundamental : cone ] that they have the same fundamental cone , and hence , by theorem  [ theorem : pseudo - codewords : fundamental : cone ] , the same pseudo - codewords .",
    "thus , to describe the pseudo - codewords which arise when we use @xmath396 to decode , we may equivalently describe the pseudo - codewords which would arise from the ( redundant ) parity check matrix giving rise to the tanner graph @xmath41 .",
    "our next task , therefore , is to describe the pseudo - codewords associated to bit - even tanner graphs .    given a tanner graph @xmath396 , the procedure described above of duplicating all check nodes will always produce a bit - even tanner graph with the same fundamental cone ( and hence the same pseudo - codewords ) as our original tanner graph . in some cases , it may be possible to produce a tanner graph with these properties by duplicating only some of the check nodes",
    ". this `` smaller '' tanner graph may be desirable in practice .",
    "[ proposition : bit - even : codewords ] let @xmath2 be a binary linear code and let @xmath41 be a tanner graph associated to @xmath2",
    ". assume that @xmath41 is bit - even .",
    "then the codewords in @xmath2 correspond to disjoint unions of edge - simple cycles on @xmath41 such that at each bit node @xmath153 of @xmath41 , either all or none of the edges incident to @xmath153 occur .",
    "let @xmath168 be the set of bit nodes of @xmath41 and let @xmath169 be the set of check nodes of @xmath41 .",
    "fix a binary vector @xmath397 .",
    "we know that @xmath105 is a codeword in @xmath2 if and only if , when we assign the value @xmath398 to every edge incident to the bit node @xmath153 , the binary sum of the values of the edges incident to each check node is 0 .",
    "in other words , associate to @xmath105 the subgraph @xmath399 which has as left vertices those @xmath149 such that @xmath400 , as right vertices those @xmath401 which are joined by an edge in @xmath41 to at least one of these @xmath153 , and as edges all the edges in @xmath41 between these @xmath153 and these @xmath172 .",
    "then @xmath105 is a codeword if and only if the degree in @xmath399 of each @xmath172 is even . since the degree of each @xmath153 is even by assumption , we see that @xmath105 is a codeword if and only if the degree of every vertex in @xmath399 is even .",
    "the result now follows immediately from euler s theorem ( * ? ? ?",
    "1.2.26 ) .    using proposition  [ proposition : bit - even : codewords ]",
    ", we may view a binary linear code with bit - even tanner graph as a punctured subcode of a cycle code as follows : let @xmath25 be a binary linear code with associated tanner graph @xmath41 , and assume that @xmath41 is bit - even .",
    "let @xmath402 be the cycle code on @xmath41 .",
    "let @xmath403 ,  , @xmath404 be the bit nodes of @xmath41 , and label the edges of @xmath41 ( which correspond to the coordinates of @xmath402 ) so that the edges incident to the bit node @xmath40 are labeled @xmath405 ,  , @xmath406 , where @xmath407 is the ( even ) degree of @xmath40 .",
    "let @xmath408 be the number of edges in @xmath41 and define @xmath409 by",
    "@xmath410 i.e. , @xmath411 picks off the first coordinate in each of the @xmath6 blocks corresponding to the @xmath6 bit nodes @xmath40 .",
    "let @xmath412 be the subcode of @xmath402 consisting of codewords @xmath413 where @xmath414 for @xmath79 and @xmath415 .",
    "then the restriction of @xmath411 to @xmath412 is an isomorphism to @xmath2 by proposition  [ proposition : bit - even : codewords ] . in other words ,",
    "@xmath2 may be regarded as the code obtained by puncturing the subcode @xmath412 of @xmath402 on the positions @xmath416 with @xmath417 , for @xmath79 .",
    "[ theorem : bit - even : pseudo - codewords ] let @xmath2 be a binary linear code with associated tanner graph @xmath41 . assume that @xmath41 is bit - even .",
    "then the unscaled pseudo - codewords of @xmath2 with respect to @xmath41 correspond to disjoint unions of backtrackless tailless cycles on @xmath41 in which all edges incident to any given bit node occur the same number of times .",
    "we first set up some notation .",
    "let @xmath3 be the parity - check matrix for @xmath2 associated to @xmath41 and let @xmath272 be the fundamental cone .",
    "let @xmath6 be the length of @xmath2 , let @xmath418 be the bit nodes of @xmath41 , and assume @xmath41 has @xmath355 check nodes so that @xmath3 is an @xmath26 matrix .",
    "assume that @xmath419 is an unscaled pseudo - codeword of @xmath2 with respect to the tanner graph @xmath41 .",
    "then there is a codeword @xmath311 in the code corresponding to some finite cover @xmath175 of @xmath41 such that the unscaled pseudo - codeword associated to @xmath311 is @xmath274 . since @xmath55 is bit - even , we have by proposition  [ proposition : bit - even : codewords ] that @xmath311 corresponds to a union @xmath163 of edge - simple cycles on @xmath41 such that at each bit node @xmath153 of @xmath41 , either all or none of the edges incident to @xmath153 occur .",
    "taking @xmath420 , we get a union of backtrackless tailless cycles on @xmath41 in which all edges incident to any given bit node occur the same number of times , as desired .",
    "conversely , suppose we are given a union @xmath163 of backtrackless tailless cycles on @xmath41 in which all edges incident to any given bit node @xmath40 occur the same number , say @xmath94 , of times .",
    "let @xmath421 .",
    "we know that @xmath276 since @xmath163 is a union of cycles , and we need to show that @xmath275 . certainly equations  ( [ def : fc : nonneg ] ) hold for @xmath287 .",
    "the expression @xmath422 counts how many edges in @xmath163 go between the bit node @xmath40 and the check node @xmath42 .",
    "since each @xmath160 is backtrackless and tailless , every time @xmath160 goes from @xmath40 to @xmath42 , it must continue to some @xmath423 .",
    "this means that the number of edges in each @xmath160 which go between @xmath40 and @xmath42 is at most the number of edges which go between @xmath42 and all @xmath424 with @xmath296 .",
    "thus @xmath425 for each @xmath130 and @xmath131 , i.e. , equations  ( [ def : fc : allij ] ) hold .",
    "hence @xmath275 and so , by theorem  [ theorem : pseudo - codewords : fundamental : cone ] , @xmath274 is a pseudo - codeword .",
    "using theorem  [ theorem : bit - even : pseudo - codewords ] , we can describe the pseudo - codewords of a binary linear code @xmath2 with respect to a bit - even tanner graph @xmath41 in terms of the exponent vectors of the monomials appearing with nonzero coefficient in a certain power series .",
    "we saw above that @xmath2 is equal to @xmath426 , where @xmath412 is a subcode of the cycle code @xmath402 on @xmath2 , and @xmath411 is the map which punctures on all positions @xmath416 with @xmath427 for @xmath79 .",
    "we also have a map on the power series rings , which we will again write as @xmath411 : @xmath428 \\to { \\mathbb{z}}[[u_1 , \\dots , u_n]].\\ ] ] this map @xmath411 is induced by @xmath429    let @xmath430 be the edge zeta function of @xmath41 , so that unscaled pseudo - codewords of @xmath402 with respect to @xmath41 are precisely the exponent vectors of the monomials appearing with nonzero coefficient in the power series expansion of @xmath431 by theorem  [ theorem : pseudo - codewords : cycle : zeta ] . by theorem  [ theorem :",
    "bit - even : pseudo - codewords ] , the unscaled pseudo - codewords of @xmath2 with respect to @xmath41 are the unscaled pseudo - codewords of @xmath402 with respect to @xmath41 in which all edges incident to any given bit node of @xmath41 occur the same number of times . if we let @xmath432 be the power series obtained from @xmath431 by picking off those terms with monomials of the form @xmath433 with @xmath434 for @xmath435 , then the unscaled pseudo - codewords of @xmath2 with respect to @xmath41 are precisely the exponent vectors of the monomials appearing with nonzero coefficient in the power series @xmath436 .",
    "let @xmath2 be a binary linear code with tanner graph @xmath41 , let @xmath437 be a bit - even tanner graph obtained by duplicating some or all of the check nodes of @xmath41 , and let @xmath402 be the cycle code on @xmath437 .",
    "then @xmath2 is a punctured subcode of @xmath402 .",
    "moreover , after choosing a suitable labeling of the @xmath438 edges of @xmath437 , where @xmath407 is the ( even ) degree of the @xmath439 bit node of @xmath437 , the unscaled pseudo - codewords of @xmath2 with respect to @xmath41 are precisely those vectors @xmath440 of nonnegative integers",
    "such that @xmath441 appears with nonzero coefficient in the power series expansion of the edge zeta function @xmath442 of @xmath437 .",
    "when @xmath2 is a cycle code on a graph @xmath345 , we saw in section 5 that the associated zeta function @xmath383 is a rational function whose taylor series expansion records all pseudo - codewords of @xmath2 . for a general ldpc code @xmath2 with associated tanner graph @xmath41 , it would be very interesting to find a rational function , arising combinatorially , such that the monomials occurring in its taylor series expansion are precisely those in @xmath443 constructed above .",
    "k.  hashimoto , _ zeta functions of finite graphs and representations of @xmath444-adic groups _ , automorphic forms and geometry of arithmetic varieties , adv . stud .",
    "pure math .",
    "15 , academic press , boston , ma , 1989 , pp ."
  ],
  "abstract_text": [
    "<S> an important property of high - performance , low complexity codes is the existence of highly efficient algorithms for their decoding . </S>",
    "<S> many of the most efficient , recent graph - based algorithms , e.g.  message passing algorithms and decoding based on linear programming , crucially depend on the efficient representation of a code in a graphical model . in order to understand the performance of these algorithms , we argue for the characterization of codes in terms of a so called _ fundamental cone _ in euclidean space which is a function of a given parity check matrix of a code , rather than of the code itself . </S>",
    "<S> we give a number of properties of this fundamental cone derived from its connection to unramified covers of the graphical models on which the decoding algorithms operate . </S>",
    "<S> for the class of cycle codes , these developments naturally lead to a characterization of the fundamental polytope as the newton polytope of the hashimoto edge zeta function of the underlying graph . </S>"
  ]
}