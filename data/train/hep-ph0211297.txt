{
  "article_text": [
    "traditionally form  @xcite is called a program for particle theory .",
    "this is however a misconception that follows from a desire of putting labels on things .",
    "form is a program for many fields of science in which large formulae occur , like in deep perturbative expansions .",
    "its dealing with non - commutative objects makes it also very suitable for mathematics calculations  @xcite . and",
    "it has also been used successfully in the field of euler - zagier sums  @xcite in which the results of certain categories of sums can only be obtained by solving large sets of equations .",
    "of course form has been mostly tested in perturbative quantum field theory .",
    "however its speed and the potential size of its expressions should make form very attractive for many scientists .",
    "new features are always looked at from a more generic viewpoint .",
    "this makes them useful for as many people as possible .",
    "some of these new features are :    * $ -variables which allow a high level of control over the organisation of a program .",
    "version 1 and 2 of form never had this flexibility . *",
    "write to file facilities .",
    "this allows even dynamical addition to running programs . * large file support .",
    "now also 32-bits processors can deal with intermediate expressions and files of more than 2 gbytes , provided the operating system supports this ( as in the ext-3 file - system versions of linux ) .",
    "* better support for large tables .",
    "* the tablebase .",
    "this is a database - like facility for extremely large tables .",
    "it was inspired by a calculation  @xcite in which there were more than 20000 table elements , each of which occupied on average more than 20 kbytes .",
    "to compile all these table elements in each program that might need some of the elements would be wasteful and slow , even in form .",
    "now there are facilities by which the program can determine what is needed and when , and only those elements will be compiled at the proper moment .",
    "the first example concerns a run which is much like a benchmark used originally by d. fliegner  @xcite to test the parallel version of form .",
    "later this test was taken over by r. kreckel  @xcite to compare the ginac system with other symbolic systems .",
    "here we have modified it somewhat to allow the intermediate expression to surpass 4 gbytes .    .... form by j.vermaseren,version 3.1(jul 22 2002 )                    run at : mon jul 22 15:06:39 2002      # : smallsize 10000000      # : largesize 100000000      # : termsinsmall 1000000      # define max \" 700 \"      s    a0, ... ,a`max ' ;      l    f = ( a0+ ... +a`max')^3 ;      i d   a1 = -a2- ... -a`max ' ;      print + f ;      .end    time =     1.73 sec     generated terms =      417057               f       1 terms left       =      133668                        bytes used       =     1882524                            .                            .                            .",
    "time = 2611.92 sec     generated terms =   457333100               f       1 terms left       =   390169111                        bytes used       = 5494312698    time = 2613.52 sec               f         terms active     =   390169111                        bytes used       = 5496905398    time = 2959.48 sec     generated terms =   457333100               f         terms in output =           1                        bytes used       =          18     f =        a0 ^ 3 ; ....    the run was on a notebook computer with a 850 mhz pentium , 500 mbytes memory and redhat 7.3 linux .",
    "the next example shows the dynamic extension of tables during a run .",
    "it uses the $ -variables and the resulting table elements are also appended to a file . this way each new run can start by reading all results of the previous jobs .",
    "this mechanism was used to run and tabulate more than 20000 integrals in the computation of basic building blocks for the three loop structure functions in deep inelastic scattering .",
    "sometimes more than 1000 integrals were done in a single ( rather lengthy ) run .",
    ".... # include be88fill.h # do num = 1,500      l ffk = *    get an integral from a list    # call intlist(be88,`num ' )          ; *    for example this one : *      + be(0,1,1,1,1,2,1,3+n,0,1,0,0,0,0,0,n,0 ) * *   here we compute the integral . next we do *    l ffl = *    get the integral again    # call intlist(be88,`num ' )          ;    i d   be(n1?, ... ,n7?,n8?!number_,k1?,k2 ?                       , 0,0,0,0,0,n?!number_,k9 ? ) =        be88fil(n1, ... ,n7,n8-n , k1,k2,k9,n)*f(be88 ) ; * load arguments into $ args and type into $ ltype    i d   fx?{ ... ,be88fil, ... }(?a$args , n)*f(x?$ltype )                                               = 0 ;    .sort *    put the result in $ expr    # $ expr = ffk ; *    ' construct ' a fill statement to add to table    fill ` $ ltype'fill(`$args ' ) = ` $ expr ' ;    .global *    make sure file is ready for appending    # append < ` $ ltype'fill.h > *    and append to file    # write < ` $ ltype'fill.h > \\            \" fill ` $ ltype'fill(`$args ' ) = % e;\",ffk    .store # enddo .end ....",
    "faced with hundreds of megabytes of table elements of which we may typically need only a few in each job ( but we can not say in advance which ) we need a special database structure .",
    "we want a database for form with the features :    * form reads at first only an index of the database .",
    "* at a specified time form can determine which elements are actually needed .",
    "* at a specified time form will load and compile these elements .",
    "* when the user speciefies it , the elements will be used . *",
    "the elements can be stored in gzipped  @xcite form ( saves a factor 4 ) .    of course such ` tablebases ' need a number of control commands amoung which should be commands for    * creating a new tablebase . * adding tables and table elements to the tablebase . * investigating what is in the tablebase . * removing elements from the tablebase . * cleaning up a tablebase . * loading the index and compiling ` stubbs ' . *",
    "loading and compiling individual elements . * loading and compiling complete tables . * loading and compiling indicated elements . * @xmath0 and probably more @xmath0 .",
    "the stubbs are intermediate expressions .",
    "they replace an object by an indicator that this table element exists in the tablebase .",
    "the advantage of this is that the object does not need to be manipulated by other routines that would deal with cases that are not in the tablebase , but yet we do not replace it by potentially lots of terms until we are ready for manipulating those terms .",
    "let us see how this works out .    ....",
    "# -   # define expandep \" 6 \"   # include ensum.h   # if ` expandep ' > 0   s   ep(:`expandep ' ) ;   # endif   .global   l   f = x1+x2 ;   .sort : start ;   # include be11fill.h   # include be22fill.h   # include be55fill.h   # include be66fill.h   # include be88fil1.h   # include be88fil2.h   # include be88fil3.h   # include be88fil4.h   # include la11fill.h   # include la22fill.h   # include la77fill.h   # include no11fill.h   # include no22fill.h   .sort : after 4 ;   .sort : complete reading ;   tablebase \" three.tbl \" create ;   .sort : create ;   tablebase \" three.tbl \" addto be11fill , be22fill                     , be55fill , be66fill , be88fill                     , la11fill , la22fill , la77fill                     , no11fill , no22fill ;   .sort : addto ;   .end ....    this program gives the output    .... time =     0.04 sec     generated terms =           2               f         terms in output =           2                  start bytes used       =          32    time =   148.75 sec     generated terms =           2               f         terms in output =           2                after 4 bytes used       =          32    time =   148.76 sec     generated terms =           2               f         terms in output =           2       complete reading bytes used       =          32    time =   148.76 sec     generated terms =           2               f         terms in output =           2                 create bytes used       =          32 we add the name be11fill we add the name be22fill we add the name be55fill we add the name be66fill we add the name be88fill we add the name la11fill we add the name la22fill we add the name la77fill we add the name no11fill we add the name no22fill    time =   241.65 sec     generated terms =           2               f         terms in output =           2                  addto bytes used       =          32    time =   241.65 sec     generated terms =           2               f         terms in output =           2                        bytes used       =          32 ....    the running times refer to a pentium 850 .",
    "the first part shows the reading and compilation of the entire tables .",
    "the second part is the compression and the writing into the tablebase .",
    "how big are these files ?    ....         lines      bytes               21527    1665848 be11fill.h         13123    1030971 be22fill.h         12420     968211 be55fill.h         19035    1486649 be66fill.h        679908   53221903 be88fil1.h        490372   38477216 be88fil2.h        410549   32158987 be88fil3.h        165495   12920526 be88fil4.h        798355   61843593 la11fill.h         37895    2896918 la22fill.h        120615    9421657 la77fill.h         48035    3647629 no11fill.h         14177    1090916 no22fill.h       2831506 220831024 total              --- >",
    "51875476 three.tbl              254795   20008483 ta0fill.h         66790    5270950 ta1fill.h        317318",
    "24834908 ta2fill.h        553843   43037497 ta3fill.h        252002   19610471 ta5fill.h        568589   44627190 tb0fill.h        277903   21738353 tb1fill.h         21553    1689338 tb5fill.h       2312793 180817190 total              --- >",
    "38599445 two.tbl               35338    2348216 gtab00.prc         49784    3313386 gtab01.prc         48620    3065428 gtab10.prc         68647    4383913 gtab11.prc         51825    3283619 gtab20.prc         51077    3401328 gtab02.prc        305291   19795890 total              --- >",
    "5005177 one.tbl ....    these are the three loop , two loop and one loop tabulated integrals respectively .",
    "there is already one pleasant spinoff .",
    "when we just load this one file three.tbl and enter and compile all elements we have    .... time =     0.07 sec     generated terms =           2               f         terms in output =           2                  start bytes used       =          32    time =     0.20 sec     generated terms =           2               f         terms in output =           2                   open bytes used       =          32    time =     0.59 sec     generated terms =           2               f         terms in output =           2                   load bytes used       =          32    time =   124.80 sec     generated terms =           2               f         terms in output =           2                  enter bytes used       =          32    time =   124.80 sec     generated terms =           2               f         terms in output =           2                        bytes used       =          32 ....    and we see that the fact that the file is compressed saves much time on the reading .",
    "loading alone , the process of reading the index and compiling a complete list of ` stubbs ' takes about 0.4 sec . which indicates that we have eliminated the whole problem of slow startup .",
    "let us now try to use this .    ....",
    "# -      .global",
    "l f = la(1,n+1,1,1,1,1,1,1,0,n,0,0,0,0,0,0,3 )           + la(1,n+1,1,8,1,1,1,1,0,n,0,0,0,0,0,0,3 ) ;      print + f + s ;      .sort    time =     0.03 sec     generated terms =           2               f         terms in output =           2                        bytes used       =         172       f=        + la(1,1+n,1,1,1,1,1,1,0,n,0,0,0,0,0,0,3 )        + la(1,1+n,1,8,1,1,1,1,0,n,0,0,0,0,0,0,3 )        ;      tablebase \" three.tbl \" open ;      tablebase \" three.tbl \" load ;      .sort    time =     0.40 sec     generated terms =           2               f         terms in output =           2                        bytes used       =         172     i d   la(n1?pos_,n2?!number_,<n3?pos _ > , ... ,",
    "< n8?pos_>,k1?,k2?!number_,k3?,0,0,0,0 ,               0,k9 ? ) = la22(n1, ... ,n8,k1,k2,k3,k9 ) ;     print + f + s ;     .sort      f=       + la22(1,1+n,1,1,1,1,1,1,0,n,0,3 )       + la22(1,1+n,1,8,1,1,1,1,0,n,0,3 )       ;     *     * shift to table notation and back     * whatever is in the table will be intercepted     *     i d   la22(n1?, ... ,n8?,k1?,k2?,k3?,k9 ? ) =           la22fill(n1,n2-k2,n3, ... ,n8,k1,k3,k9,k2 ) ;     i d   la22fill(n1?, ... ,n8?,k1?,k3?,k9?,k2 ? ) =             la22(n1,n2+k2,n3, ... ,n8,k1,k2,k3,k9 ) ;     print + f + s ;     .sort      f=       + tbl_(la22fill,1,1,1,1,1,1,1,1,0,0,3,n )       + la22(1,1+n,1,8,1,1,1,1,0,n,0,3 )       ;     testuse la22fill ;     print + f + s ;     .sort      f=       + tbl_(la22fill,1,1,1,1,1,1,1,1,0,0,3,n )       + la22(1,1+n,1,8,1,1,1,1,0,n,0,3 )       ;     tablebase \" three.tbl \" use ;     print + f + s ;     .sort    time =     0.45 sec     generated terms =           2               f         terms in output =           2                        bytes used       =         152      f=       + tbl_(la22fill,1,1,1,1,1,1,1,1,0,0,3,n )       + la22(1,1+n,1,8,1,1,1,1,0,n,0,3 )       ;     polyfun acc ;     apply ;     i d nval(n?)*r(n?,x ? ) = den(x+n)^n ;     i d nval(n?)*r(n?,x?,?a ) =                            den(x+n)^n*s(r(?a),x+n ) ;     i d s(r , x ? ) = 1 ;     i d nval(n ? ) = 1 ;     i d   z3?{z3,z4,z5,z6 } = acc(z3 ) ;     i d   ep^n ?",
    "= acc(ep^n ) ;     print + f + s ;     b    theta , delta ;     .end    time =     0.45 sec     generated terms =          50               f         terms in output =          32                        bytes used       =        2550      f=      + theta(-2+n ) * (        + den(-1+n)*acc(23/8+ep^-2 + 1/3*ep^-1 + 4/3*z3 )        + den(-1+n)^2*acc(-7/2-ep^-1 )        + den(-1+n)^3*acc(3 )        + den(-1+n)^3*s(r(1),-1+n)*acc(2/3 )        + den(-1+n)^2*s(r(1),-1+n)*acc(-31/18 )        + den(-1+n)*s(r(1),-1+n)*acc(37/36+ep^-1 )        + den(-1+n)*s(r(1,1),-1+n)*acc(1 )        + den(-1+n)*s(r(2),-1+n)*acc(-29/18 )        + den(-1+n)*s(r(3),-1+n)*acc(-2/3 ) )      + theta(-1+n ) * (        + den(n)*acc(-17/18-ep^-2 - 1/3*ep^-1 + 16/3*z3 )        + den(n)^2*acc(-73/18+ep^-1 )        + den(n)^3*acc(11/3 )        + den(n)^3*s(r(1),n)*acc(8/3 )        + den(n)^2*s(r(1),n)*acc(-29/9 )        + den(n)*s(r(1),n)*acc(23/9-ep^-1 )        + den(n)*s(r(1,1),n)*acc(-1 )        + den(n)*s(r(2),n)*acc(5/9 )        + den(n)*s(r(3),n)*acc(-8/3 ) )      + theta(n ) * (        + den(1+n)*acc(4*z3 )        + den(1+n)^2*acc(8*z3 )        + den(1+n)^4*s(r(1),1+n)*acc(4 )        + den(1+n)^3*s(r(1),1+n)*acc(2/3 )        + den(1+n)^2*s(r(2),1+n)*acc(-2/3 )        + den(1+n)^2*s(r(3),1+n)*acc(-4 )        + den(1+n)*s(r(1),1+n)*acc(-8*z3 )        + den(1+n)*s(r(1,2),1+n)*acc(2/3 )        + den(1+n)*s(r(1,3),1+n)*acc(4 )        + den(1+n)*s(r(2,1),1+n)*acc(-2/3 )        + den(1+n)*s(r(3,1),1+n)*acc(-4 ) )      + delta(-1+n ) * (        + acc(1001/648 + 4/3*ep^-3 - 2/9*ep^-2                           -13/108*ep^-1 - 1/3*z3 )        )      + delta(n ) * (        + acc(-1087/81 - 1/3*ep^-3 - 1/9*ep^-2                           -97/54*ep^-1 + 20/3*z3 )        )      + la22(1,1+n,1,8,1,1,1,1,0,n,0,3)*acc(1 ) ; ....",
    "the above features are released in version 3.1 of form at its regular address http://www.nikhef.nl/@xmath1form .",
    "of course there are still features that form does not have and would be much appreciated .",
    "one would be proper gcd and factorization algorithms .",
    "this would make it much easier to solve sets of equations .",
    "these are anticipated , but lack of manpower is the main problem .",
    "it seems that the inherent speed of form comes from its internal data representation .",
    "the locality of its operations seems to be less important in this matter than was previously believed .",
    "this plays mainly a role when expressions are so big that they reside on disk .",
    "but even in that case a good use of the .sort instructions helps .",
    "currently a study is under way to see whether form can be made into an open source project .",
    "this would need a considerable amount of manpower , because the sources may have to be reprogrammed , several levels of documentation will have to be made and a number of additions will have to made .          j.  a.  m. vermaseren , int .",
    "* a14 * ( 1999 ) 2037 s.  moch , j.  a.  m. vermaseren and a.  vogt hep - ph/0209100 j.  a.  m. vermaseren , s.  moch and a.  vogt , hep - ph/0211296 d. fliegner , a. retey , and j.  a.  m. vermaseren hep - ph/9906426 , r. kreckel , phd thesis `` algorithmische methoden zur berechnung von vierbeinfunktionen '' , mainz 2002"
  ],
  "abstract_text": [
    "<S> some recent additions to form are discussed . in particular large file support and </S>",
    "<S> the tablebases are presented .    </S>",
    "<S> # 1_#1  ( # 1)s_#1 ( # 1,#2)s_#1,#2 ( # 1,#2,#3)s_#1,#2,#3 ( # 1,#2,#3,#4)s_#1,#2,#3,#4 ( # 1,#2,#3,#4,#5)s_#1,#2,#3,#4,#5    ( # 1)p_qq(#1 ) ( # 1,#2)li_#1(#2 ) ( # 1,#2,#3,#4)h_#1,#2,#3(#4 ) </S>"
  ]
}