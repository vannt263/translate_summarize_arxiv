{
  "article_text": [
    "the gist of many ( np-)hard combinatorial problems is to _ decide _ whether a universe of @xmath0 elements contains a _ witness _ consisting of @xmath1 elements that match some prescribed pattern . in the positive case",
    "this is naturally followed by the task of _ extracting _ the elements of one such witness .    as a result of advances in fixed - parameter tractability ,",
    "many such hard problems are now known to admit algorithms that run in linear ( or low - order polynomial ) time in the size of the universe @xmath0 , and where the complexity of the problem can be isolated to the size of the witness @xmath1 .",
    "that is , the running times obtained are of the form @xmath3 for some rapidly growing function @xmath4 of @xmath1 .",
    "this makes such algorithms ideal candidates for practical applications that must consider large inputs , that is , large values of @xmath0 .",
    "for example , a recent randomized algorithm for the @xmath1-sized graph motif problem runs in time @xmath5 , where @xmath6 is the number of edges in the input graph @xcite .    despite scalability to large inputs , some such advanced parameterized algorithms ( like the ones for graph motif  @xcite or for @xmath1-path  @xcite ) have an inherent handicap from a concrete algorithm engineering perspective .",
    "_ they only solve the decision problem .",
    "_ in applications , however , one needs access to the witnesses , which puts forth the question whether one can efficiently extract a witness or list all witnesses , using the algorithm for the decision problem as an _ oracle _ ( black - box subroutine ) , and without losing the scalability to large inputs .    this paper studies the question of efficiently turning a decision oracle into an algorithm for witness extraction over the universe @xmath7 .",
    "let @xmath8 be the ( unknown ) family of witnesses .",
    "we focus on the following oracle :    inclusion oracle : :    given a query set @xmath9 , the oracle answers    ( either yes or no ) whether there exists at least one witness    @xmath10 such that @xmath11 .",
    "we    can motivate this type of oracle by observing that most problems have    natural self - reducibility that we can use to narrow down the universe    from @xmath12 to @xmath13 ( e.g. take the subgraph    induced by the set @xmath13 of vertices ) and then run the    decision algorithm .    in the oracle setting there are at least two natural ways to measure the efficiency of witness extraction .",
    "number of oracle queries : :    this measure has been extensively studied in the domain of    _ combinatorial group testing _",
    "@xcite , where the canonical task is to    identify @xmath1 _ defective _ items from a population of    @xmath0 items , with the objective of minimizing the number of    tests ( oracle queries ) required to identify all the    defectives .",
    "while this measure does not reflect accurately the amount    of computing resources invested in our context  indeed , different    oracle queries in general do not use the same amount of resources ",
    "the    group testing perspective enables information - theoretic lower bounds    and supplies useful algorithmic techniques for extraction .",
    "total running time : :    assuming we have bounds on the running time of the oracle as a    function of @xmath0 and @xmath1 , we can bound the    running time of extraction of witnesses by taking the sum of the    running times of the oracle queries .",
    "it turns out that we get fair    control over the total running time already if we know that the    running time of the oracle scales at least linearly in    @xmath0 .",
    "the objectives of this paper are threefold .",
    "( a ) first , we draw from techniques in classical group testing to arrive at efficient witness extraction algorithms for inclusion oracles both in deterministic and in randomized settings with one - sided error .",
    "( b ) second , we show examples of parameterized problems which can be solved efficiently _ in practice _ by a combination of an fpt decision oracle and a group - testing algorithm ; in particular , for the @xmath1-path problem our experimental results show that one can find a @xmath14-vertex witness in a 2000-vertex graph within a minute on a typical laptop .",
    "( c ) third , we discuss some non - obvious choices we made during the implementation : namely the choice of the @xmath15 arithmetic implementation ; we believe our findings might be useful for implementations of other algorithms applying @xmath15 arithmetic .    to set up a trivial baseline for performance comparisons , it is not difficult to see that @xmath16 queries to an inclusion oracle suffice to extract a witness  simply delete points from the universe one by one , with each deletion followed by an oracle query on the remaining points .",
    "if the oracle answers no , we know the deleted point was essential and insert it back . when the process finishes the points that remain form a witness .",
    "this , however , is not particularly efficient since each oracle query costs at least @xmath3 time , raising the total running time to @xmath17 and making the approach impractical for large @xmath0 .    * * our results on extraction .",
    "* * we begin by transporting techniques from group testing @xcite to arrive at more efficient witness extraction .",
    "our first contribution merely amounts to observing that the so - called _ bisecting algorithm _ @xcite can be translated to work with an inclusion oracle and in the presence of one or more witnesses .",
    "we also observe that taking into account the total running time of the algorithm , the baseline cost of a factor @xmath18 in running time can be lowered to @xmath19 if the running time of the oracle is at least linear in @xmath0 , which is the case in most applications .",
    "these observations are summarized in theorem  [ thm : main - deterministic ] .",
    "let @xmath20 be a nonempty family witnesses , each of size at most @xmath1 , over an @xmath0-element universe , @xmath21 .",
    "we say that a function @xmath22 is _ at least linear _ if for all @xmath23 it holds that @xmath24 .",
    "[ thm : main - deterministic ] there exists an algorithm that extracts a witness in @xmath20 without knowledge of @xmath1 using at most @xmath25 queries to a deterministic inclusion oracle .",
    "moreover , suppose the oracle runs in time @xmath26 for a function @xmath27 that is at least linear .",
    "then , there exists an algorithm that extracts a witness in @xmath20 in time @xmath28 .",
    "currently the fastest known parameterized algorithms in many cases use randomization .",
    "thus in practice one must be able to cope with decision oracles that may give erroneous answers , for example it is typically the case that the decision algorithm produces false negatives with at most some small probability , but false positives do not occur  @xcite .",
    "let us assume that the probability of a false negative is @xmath29 . beyond the absence of false positives , a further observation to our advantage",
    "is that typically _ witnesses may be checked _ ,",
    "deterministically , and essentially at no computational cost compared with the execution of even one oracle query .",
    "that is , we have available a subroutine that takes a candidate witness @xmath30 as input and returns whether @xmath10 .",
    "we make this assumption in what follows .",
    "thus having access to a randomized inclusion oracle enables deterministic extraction , but with randomized running time .",
    "these observations are summarized in theorem  [ thm : main - randomized ] .",
    "[ thm : main - randomized ] there exists an algorithm that extracts a witness in @xmath20 without knowledge of @xmath1 using in expectation at most @xmath2 queries to a randomized inclusion oracle that has no false positives but may output a false negative with probability at most @xmath29",
    ". moreover , suppose the oracle runs in time @xmath26 for a function @xmath27 that is at least linear .",
    "then , there exists an algorithm that extracts a witness in @xmath20 in time @xmath31 .    *",
    "an application : @xmath1-path .  *",
    "the @xmath1-path problem is one of the basic np - complete problems , a natural parameterized version of the hamiltonian path problem . in this problem",
    "we are given an undirected connected graph @xmath32 , and a natural number @xmath1 .",
    "the goal is to find a simple path on @xmath1 vertices in @xmath33 .",
    "denote by @xmath34 and @xmath35 . in terms of dependence on @xmath1 ,",
    "the currently fastest algorithm is due to bjrklund , husfeldt , kaski , and koivisto  @xcite and can be tuned to run in @xmath36 time .",
    "it uses algebraic tools and only solves the corresponding decision problem .",
    "we applied a simplified version of this algorithm , slightly easier to implement , which runs in @xmath37 time , assuming that finite field arithmetic operations take constant time ( cf .",
    "the algorithm evaluates a certain polynomial of degree @xmath38 over the finite field @xmath15 , which turns out to be a generating function of all witnesses .",
    "the algorithm is randomized , and it may return a false negative .",
    "the failure probability is bounded by @xmath39 , hence by choosing @xmath40 large enough we can assume it is at most @xmath41 , as required by theorem  [ thm : main - randomized ] .",
    "our universe @xmath12 is the set of edges of the input graph and we are extracting witnesses with exactly @xmath42 edges . by theorem  [ thm : main - randomized ]",
    "we obtain an algorithm with expected running time @xmath43 for witness extraction .    however , when we consider actual _ implementation _ the above approach should be refined as follows .",
    "first set the universe @xmath12 to be the set of _ vertices _ and find the set of @xmath1 vertices @xmath44 which contains a @xmath1-vertex path .",
    "next , set the universe @xmath12 to be the set of _ edges _ in the induced graph @xmath45 $ ] , and find the witness . by theorem  [ thm : main - randomized ] , for dense graphs this can give a factor two speed - up .    * a computational biology application : graph motif .",
    "* in the graph motif problem we are given an undirected connected graph @xmath32 , a vertex coloring @xmath46 , and a multiset @xmath47 of cardinality @xmath1 consisting of colors in the set @xmath48 .",
    "the goal is to find a subset @xmath49 such that the induced subgraph @xmath45 $ ] is connected , and the _ multiset _ @xmath50 of colors of the vertices of @xmath44 is equal to @xmath47 .",
    "note that @xmath51 .",
    "this problem has important applications in querying patterns in protein - protein interaction ( ppi ) networks , see e.g.  @xcite .",
    "although problem is np - hard , in the data instances coming from this application the graph size is of order of thousands and the pattern is very small ( according to  @xcite the number of edges is 21275 for fly and 28972 for human , and @xmath52 ) , i.e.  they are perfectly suited for fpt algorithms .",
    "a recent randomized decision algorithm @xcite solves the corresponding decision problem by evaluating a certain polynomial of degree @xmath53 over the finite field @xmath15 , which turns out to be a generation function of all witnesses .",
    "its running time is dominated by performing @xmath43 arithmetic operations in @xmath15 , where @xmath54 is the number of edges in the input graph . the algorithm returns false negatives with probability bounded by @xmath55 , hence by choosing @xmath40 large enough we can assume it is at most @xmath41 .",
    "it follows that we can use it as a randomized oracle in the algorithm described in theorem  [ thm : main - randomized ] .",
    "our universe @xmath12 is be the set of vertices of the input graph . by theorem",
    "[ thm : main - randomized ] we obtain an algorithm with expected running time @xmath56 for witness extraction , assuming that finite field arithmetic operations take constant time .    * further applications .  *",
    "the list of problems which a ) fall into our witness extraction framework and b ) have the property that asymptotically fastest decision algorithms do not return a witness includes steiner tree  @xcite , @xmath40-set packing  @xcite , @xmath40-dimensional matching  @xcite , steiner cycle ( aka @xmath57-cycle )  @xcite , directed rural postman problem  @xcite .",
    "* related and previous work .  *",
    "the relations between the time complexity of decision problems and their search versions were studied by fellows and langston  @xcite .",
    "independently of our work , hassidim , keller , lewenstein , and roditty  @xcite presented a _",
    "randomized _ algorithm that extracts a witness for the ( weighted ) @xmath1-path problem using @xmath2 calls to a decision oracle , _ in expectation_. their approach is to discard random subsets ( of size @xmath58 ) of the vertex set as long as the resulting instance still contains the solution . the bisecting algorithm  @xcite that we extend in this paper can be seen as a cleaner version of this idea .",
    "first , in the bisecting algorithm larger sets get discarded .",
    "second , the bisecting algorithm is deterministic .",
    "hassidim et al .",
    "do not analyze how the time of their algorithm is influenced by the fact that the oracle is randomized . from an asymptotic perspective this is not needed because one can repeat each oracle call multiple times to reduce the error probability below an arbitrary threshold .",
    "however , in practice this is an unnecessary ( though only constant - factor ) slow - down , which we seek to avoid in what follows .    *",
    "implementation and experiments .",
    "* we implemented in c the @xmath37-time decision algorithm for the @xmath1-path problem and the algorithm from theorem  [ thm : main - randomized ] , which we call ` fifo ' on the charts .",
    "the crucial part of implementation of the decision oracle is the finite field arithmetic .",
    "somewhat unexpectedly , we found that to optimize the running time , a _ different",
    "_ method should be chosen depending on whether we use the oracle just once ( e.g.  check whether there is a witness ) or whether it is used in combination with the algorithm from theorem  [ thm : main - randomized ] to find a witness .",
    "details can be found in section  [ sec : gf - impl ] .     running times of various algorithms for a graph with exactly one witness ( upper charts ) and @xmath59 witnesses ( lower charts ) .",
    "each running time on the graph is the median of 5 runs for the same input instance .",
    "the left charts : a 1000-vertex graph and @xmath60 .",
    "the right charts : @xmath61 ( upper ) or @xmath62 ( lower ) and the number of vertices varies . running times on a 2.53-ghz intel xeon cpu . ]     running times of various algorithms for a graph with exactly one witness ( upper charts ) and @xmath59 witnesses ( lower charts ) .",
    "each running time on the graph is the median of 5 runs for the same input instance .",
    "the left charts : a 1000-vertex graph and @xmath60 .",
    "the right charts : @xmath61 ( upper ) or @xmath62 ( lower ) and the number of vertices varies .",
    "running times on a 2.53-ghz intel xeon cpu . ]     running times of various algorithms for a graph with exactly one witness ( upper charts ) and @xmath59 witnesses ( lower charts ) .",
    "each running time on the graph is the median of 5 runs for the same input instance . the left charts : a 1000-vertex graph and @xmath60 .",
    "the right charts : @xmath61 ( upper ) or @xmath62 ( lower ) and the number of vertices varies . running times on a 2.53-ghz intel xeon cpu . ]     running times of various algorithms for a graph with exactly one witness ( upper charts ) and @xmath59 witnesses ( lower charts ) .",
    "each running time on the graph is the median of 5 runs for the same input instance .",
    "the left charts : a 1000-vertex graph and @xmath60 .",
    "the right charts : @xmath61 ( upper ) or @xmath62 ( lower ) and the number of vertices varies . running times on a 2.53-ghz intel xeon cpu . ]",
    "we run a series of experiments on a single 2.53-ghz intel xeon cpu .",
    "we compare the fifo algorithm with two other natural candidates .",
    "the first is the witness extraction algorithm of hassidim et al .  @xcite",
    "combined with the @xmath37-time inclusion oracle , called ` hklr ' on the charts .",
    "the second is the @xmath63-time algorithm of chen et al .",
    "@xcite called ` divide - and - color ' .",
    "it is not based on algebraic tools and finds the witness while solving the decision problem .",
    "note that there are many more algorithms / heuristics for @xmath1-path problem which would be much faster on particular instances .",
    "a natural heuristic is computing the dfs tree . if the tree has depth at least @xmath1 the witness is found and otherwise the graph has pathwidth at most @xmath1 . on the other hand , when the pathwidth @xmath64 is very small ( say , @xmath65 ) , the @xmath66 algorithm of cygan et al .",
    "@xcite should be fast .",
    "however , in this work we want to focus on algorithms with best guarantees _ in the worst case_. disregarding the detailed memory layout of the input graph , all the three algorithms we compare are oblivious to the topology of the graph apart from the parameters @xmath54 and @xmath1 . in our experiments we use two types of trees with @xmath67 as the input graphs .",
    "the first type ( with a unique witness ) consists of @xmath68-vertex paths joined at a common endvertex ; when @xmath1 is odd two of the paths are extended by an edge , when @xmath1 is even one path is extended by two edges and one path by one edge .",
    "the second type ( with @xmath59 witnesses ) has @xmath1 odd and all paths are extended by an edge .",
    "the results can be seen on fig .",
    "[ fig : alg_charts ] .",
    "we see that both fifo and hklr are much faster than divide - and - color even for very small values of @xmath1 . for 1000-vertex graphs our algorithm fifo finds @xmath69-vertex patterns below 1 second and @xmath70-vertex patterns below 1 hour .",
    "hklr is considerably slower and the difference is more visible when there are many witnesses .",
    "( the size of the graph is roughly the same as the ppi network of human ) .",
    "the right chart : @xmath61 and the number of vertices varies from 100 to 10000 ( @xmath71 ) . ( note that both axes use logarithmic scale . ) ]     ( the size of the graph is roughly the same as the ppi network of human ) .",
    "the right chart : @xmath61 and the number of vertices varies from 100 to 10000 ( @xmath71 ) . ( note that both axes use logarithmic scale . ) ]    we have also implemented the @xmath43-time decision algorithm @xcite for the graph motif problem , plugged into the fifo extraction algorithm from the present paper . in fig .",
    "[ fig : motif_charts ] one can see running times of our implementation . the size of the input instance is typical for the applications in protein - protein interaction networks .",
    "similarly as in the case of @xmath1-path , the running time of the decision algorithm is essentially the same regardless of the structure of the graph and the motif , so we just used a random input graph and a random motif .",
    "the objective of this section is to prove theorem  [ thm : main - deterministic ] .",
    "accordingly , we assume we have available a deterministic inclusion oracle . our strategy is to translate an existing algorithm developed for group testing into the setting of witness extraction ( algorithm  [ alg : extract - inclusion ] and lemma  [ lem : deterministic - extraction ] ) , and then analyze its performance with respect to the total running time , including the oracle queries ( lemma  [ lem : deterministic - extract - runtime ] ) .",
    "let us first review the setting of classical group testing , and then indicate how to translate classical algorithms to the setting of witness extraction . in group testing , we do not have a family of witnesses , but rather a _",
    "unknown set @xmath72 consisting of _ defective _ items .",
    "furthermore , instead of an inclusion oracle ( that would test whether @xmath73 for a query @xmath13 ) we have an _ intersection oracle _ that answers whether @xmath74 for a query @xmath13 . that is , a query tells us whether the query set @xmath13 has at least one defective item .",
    "characteristic to classical group testing algorithms is that they proceed to shrink down the size of the universe @xmath12 while maintaining the invariant @xmath72 until @xmath75 has been identified ( that is , @xmath76 ) .",
    "indeed , whenever the ( intersection ) oracle answers no , we know that the query @xmath13 is disjoint from @xmath75 , and thus can safely delete all points in @xmath13 from @xmath12 without violating the invariant .    in our setting",
    "we have to work with an inclusion oracle and cope with the possibility of the family @xmath20 containing more than one witness .",
    "fortunately , it turns out that the setting is not substantially different from group testing . indeed , in analogy with group testing , we will also proceed to narrow down the universe @xmath12 but seek to maintain a slightly different invariant , namely `` there exists a @xmath77 such that @xmath30 '' . in this setting",
    "we can narrow down the universe by the following basic procedure : for a subset @xmath78 we query the inclusion oracle with @xmath79 .",
    "if the answer is yes , we know that we can safely remove @xmath80 from @xmath12 while maintaining the invariant .",
    "this basic analogy enables one to transport group testing algorithms into the setting of witness extraction .    in what follows we focus on a translation of one such algorithm , the _ bisecting algorithm",
    "_  @xcite .",
    "one of its advantages is that it does not need to know the number of defective items in advance , and hence in particular it is suitable for our applications where we want to allow the witnesses to potentially differ in size .",
    "moreover , this particular algorithm is convenient in our further modifications for the randomized oracle model ( sect .  [ sect : randomized ] ) .",
    "we give the pseudocode of a `` witness extraction '' version of the bisecting algorithm in pseudocode as algorithm  [ alg : extract - inclusion ] .",
    "initialize an empty fifo queue @xmath81 let @xmath82 insert @xmath12 into @xmath81    the correctness of algorithm  [ alg : extract - inclusion ] follows from the fact that our invariant `` there exists a @xmath77 such that @xmath30 '' is always satisfied .",
    "we remark that algorithm  [ alg : extract - inclusion ] has a further minor difference with the original bisection algorithm in that whenever it partitions a set @xmath80 into @xmath83 and @xmath84 then @xmath83 and @xmath84 are almost of the same size ( @xmath85 ) , whereas the original algorithm @xmath86 and @xmath87 .",
    "du and hwang  @xcite showed that the bisection algorithm performs @xmath88 queries .",
    "below we present a self - contained analysis .",
    "[ lem : deterministic - extraction ] algorithm  [ alg : extract - inclusion ] makes at most @xmath89 oracle queries .",
    "we can model the execution of algorithm  [ alg : extract - inclusion ] with a tree @xmath90 whose nodes are the subsets @xmath80 that have appeared in the queue @xmath81 during execution .",
    "a node @xmath80 is a child of node @xmath91 if and only if @xmath80 was obtained by bisecting @xmath91 . in particular",
    "@xmath90 is a binary tree with at most @xmath1 leaves and two types of internal nodes : the _ partition nodes _ with two children correspond to splitting a set into two halves , and the _ cut nodes _ with one child correspond to cutting - off a half of a set .",
    "each internal node in @xmath90 is associated with 1 or 2 queries .",
    "let us order @xmath90 arbitrarily so that every partition node has a left child and a right child ; let us furthermore call the only child of a cut node the left child . for every leaf @xmath92 form a path @xmath93 up in the tree by first including @xmath92 into the path and including each subsequent node into @xmath93 as long as we arrived into the node from the left child of the node .",
    "such paths @xmath93 clearly form a partition of nodes in @xmath90 .    for every cut node @xmath94 ,",
    "let @xmath95 denote the subset of vertices that was discarded .",
    "for a leaf @xmath92 let @xmath96 denote the union of all the sets @xmath95 on path @xmath93 . for any cut nodes @xmath94 and @xmath97 on @xmath93 , if @xmath94 is an ancestor of @xmath97 then @xmath98 .",
    "it follows that there are at most @xmath99 cut nodes on @xmath93 .",
    "hence the total number of cut nodes is at most @xmath100 where the sum is over the at most @xmath1 leaves @xmath92 in @xmath90 and the inequality follows from jensen s inequality ( and the fact that the sets @xmath96 form a partition of @xmath101 , where @xmath102 is the returned witness ) . since @xmath90 is a binary tree , the number of partition nodes is at most @xmath42 .",
    "thus there are at most @xmath103 nodes and at most @xmath89 queries .",
    "a routine information - theoretic argument shows that lemma  [ lem : deterministic - extraction ] is optimal up to constants , that is , at least @xmath104 queries ( bits of information ) are needed to identify a unique witness of size @xmath1 in a universe of size @xmath0 .",
    "this observation can be strengthened to the randomized setting via the yao principle  in expectation at least @xmath105 queries are required .",
    "we now proceed to analyze algorithm  [ alg : extract - inclusion ] with a more natural complexity measure , namely the total time of the extraction procedure , taking into account the time used by the oracle queries .",
    "recall that a function @xmath22 is at least linear if for all @xmath23 we have @xmath24 .",
    "[ lem : deterministic - extract - runtime ] suppose the time complexity of the inclusion oracle on a query set of size @xmath0 is @xmath26 , where @xmath27 is at least linear .",
    "then , the running time of algorithm  [ alg : extract - inclusion ] is @xmath106 .",
    "we follow the notation introduced in the proof of lemma  [ lem : deterministic - extraction ] . because there are at most @xmath42 partition nodes , the total time spent at these nodes is @xmath107 .",
    "hence it remains to analyze the time spent at the cut nodes .",
    "it suffices to show that for every leaf @xmath92 of the tree @xmath90 the total time spent at the cut nodes in path @xmath93 is @xmath108 .",
    "observe that at every cut node the size of the universe decreases by a factor of 2 .",
    "hence this time is at most @xmath109 where the last inequality uses the assumption that @xmath27 is at least linear .",
    "lemma  [ lem : deterministic - extraction ] and lemma  [ lem : deterministic - extract - runtime ] now establish theorem  [ thm : main - deterministic ] .",
    "the objective of this section is to prove theorem  [ thm : main - randomized ] .",
    "accordingly , we assume we have available a randomized inclusion oracle that has no false positives but may output a false negative with probability at most @xmath29",
    ". the outcomes of queries are assumed to be mutually independent as random events .",
    "we start with two simple observations regarding algorithm  [ alg : extract - inclusion ] in the context of a randomized oracle .",
    "first , since the oracle does not have false positives , the set @xmath102 output by algorithm  [ alg : extract - inclusion ] is always a superset of a witness .",
    "second , by theorem  [ thm : main - deterministic ] we know that the algorithm makes at most @xmath110 queries to extract a witness _ in the event no false negatives occur in the first @xmath110 queries_. by the union bound , the probability of this event is at least @xmath111 .",
    "this gives us a monte carlo algorithm that fails with probability at most @xmath112 .",
    "recalling that we assume we have access to a subroutine that checks whether a given set @xmath30 satisfies @xmath10 , we would clearly like to transform the monte carlo algorithm into a las vegas algorithm that always extracts a witness , and the cost of randomization is only paid in terms of the running time .",
    "the las vegas algorithm now operates in two stages .",
    "let us call this algorithm algorithm  [ alg : second ] .",
    "in the first stage , we simply run algorithm  [ alg : extract - inclusion ] and obtain a set @xmath102 as output . in the second stage ,",
    "we insert each element of @xmath102 into an empty queue @xmath81 .",
    "next , as long as @xmath102 is not a witness , we ( 1 ) remove an element @xmath6 from the head of @xmath81 , ( 2 ) if includes(@xmath113 returns no then we insert @xmath6 at the tail of @xmath81 and otherwise we remove @xmath6 from @xmath102 . finally , we return @xmath102 .    given that only false negatives may occur , algorithm  [ alg : second ] is obviously correct and always returns a witness .",
    "it remains to analyze the expected number of queries and the expected running time of algorithm  [ alg : second ] .",
    "[ thm:1se - upper - bound - query - model ] algorithm  [ alg : second ] makes in expectation @xmath2 queries to the randomized inclusion oracle .",
    "first we bound the expected number of queries in the first stage .",
    "recall the tree model of the execution of algorithm  [ alg : extract - inclusion ] in the proof of lemma  [ lem : deterministic - extraction ] .",
    "let us study the model in the presence of false negatives .",
    "a false negative at line  [ line : oracle1 ] of algorithm  [ alg : extract - inclusion ] causes the algorithm to view the set @xmath83 as necessary and continue processing it even if it could in be dropped in reality .",
    "similarly , a false negative at line  [ line : oracle2 ] causes the algorithm to view @xmath84 as necessary .",
    "in particular , each false negative gets inserted into the queue @xmath81 and hence into the tree @xmath90 .    now let us study an arbitrary subtree of @xmath90 rooted at a false negative node .",
    "we observe that all such nodes either remain false negative nodes , or become exhausted as yes nodes or singleton nodes .",
    "( that is , no node in the subtree is a true negative . )",
    "let us study the process that creates such a subtree and for convenience ignore the possibility of singleton nodes exhausting the process .",
    "let @xmath114 be the random variable that tracks the size of the subtree .",
    "because the left and right child nodes of each node are independently false negatives with probability @xmath64 , we observe that the expectation of @xmath114 satisfies @xmath115=1 + 2p\\mathrm{e}[x]$ ] .",
    "that is , @xmath115=1/(1 - 2p)$ ] . because @xmath29 , we have @xmath115\\leq 2 $ ] .",
    "since each false negative has to interact with true negative and positive nodes , the expected number of queries in the first stage is , by linearity of expectation , at most @xmath116 by lemma  [ lem : deterministic - extraction ] .",
    "let @xmath117 denote @xmath102 at the beginning of the second stage . for purposes of analysis we divide the second stage into two sub - stages .",
    "the first sub - stage finishes when @xmath118 .",
    "assume that there was at least one query in the first sub - stage , that is , @xmath119 .",
    "let @xmath120 be the total number of queries in the first sub - stage .",
    "then @xmath121 where @xmath122 is the number of false negative queries , @xmath123 is the number of positive queries and @xmath124 is the number of true negative queries .",
    "first observe that @xmath122 has the negative binomial distribution , that is , @xmath125 , and hence @xmath126=(|w_0|-2k)\\tfrac{p}{1-p}\\le |w_0|-2k$ ] .",
    "it follows that @xmath127 \\le \\mathrm{e}[|w_0|]-2k \\leq 3q(n , k)$ ] .",
    "now note that that @xmath123 is bounded by @xmath128 , which is bounded by the number of queries in the first stage , so @xmath129\\leq 3q(n , k)$ ] .",
    "call an element @xmath6 of @xmath102 _ false _ if @xmath130 contains a witness and _ true _ otherwise .",
    "since there are at most @xmath1 true elements , as long as @xmath131 the number of true elements is bounded by the number of false elements ( if @xmath102 contains more than one witness then all elements of @xmath102 may be false ) .",
    "if @xmath132 is a true element then the query @xmath130 always returns no ( a true negative ) ; if @xmath6 is false then the query @xmath130 may return either yes ( a true positive ) or no ( a false negative ) . since elements of @xmath102 are tested in queue order , @xmath133 and hence @xmath134\\leq 6q(n , k)$ ]",
    "finally consider the second sub - stage , when @xmath118 .",
    "let @xmath135 be the number of false elements in @xmath102 , @xmath136 .",
    "the algorithm iterates through the queue until there is no false element in @xmath102 .",
    "the number of times we iterate over the whole queue is the maximum of @xmath135 independent random variables , each of geometric distribution with success probability @xmath137 , which by @xmath29 is in expectation at most @xmath138 ( cf .",
    "@xcite ) . since in each iteration",
    "the algorithm performs at most @xmath139 queries , the expected number of queries in the second sub - stage is then at most @xmath140 .",
    "the expected number of queries is thus at most @xmath141 .",
    "theorem  [ thm : main - randomized ] is now established by lemma  [ thm:1se - upper - bound - query - model ] and the following lemma .    [",
    "lem : randomized - extract - runtime ] suppose the time complexity of the randomized inclusion oracle on a query set of size @xmath0 is @xmath26 , where @xmath27 is at least linear .",
    "then , the running time of algorithm  [ alg : second ] is @xmath142 .    by lemma  [ lem : deterministic - extract - runtime ] the total time of the queries in the first stage that returned a correct answer",
    "is bounded by @xmath106 .    as argued in the proof of lemma  [ thm:1se - upper - bound - query - model ] , all nodes corresponding to false negative queries in _ both stages _ form @xmath143-sized subtrees of tree @xmath90 .",
    "for every such subtree the parent @xmath64 of the root of the subtree corresponds to a query with a correct answer .",
    "moreover the size of the instance passed to the oracle in every call in the subtree is bounded by the size of the instance passed to the oracle in the query corresponding to @xmath64 .",
    "hence the expected total time spent at the subtree is asymptotically the same as the time spent at @xmath64 .",
    "it follows that all the false negative queries take @xmath106 time in expectation .",
    "in particular we showed that the first phase takes @xmath106 expected time .",
    "for every positive query includes(@xmath113 in the second stage there is the corresponding ( false negative ) leaf corresponding to the singleton @xmath144 in tree @xmath90 .",
    "hence the total time of positive queries in the second stage is bounded by the time of the first phase .",
    "now we focus on true negative queries in the first sub - stage of the second stage .",
    "consider a single pass of the algorithm through all the elements in the queue . within this pass",
    "there are at most @xmath1 true negatives ( since witnesses are of size at most @xmath1 ) . moreover , since in the second phase there are at least @xmath139 elements in the queue , we can injectively assign to each of the true negative queries a false negative or a positive query for an instance of the same or larger size .",
    "hence , the total time of true negative queries in the first sub - stage of the second stage is bounded by the total time of false negative and positive queries which we already bounded by @xmath106 .",
    "we are left with bounding the time of true negatives in the second sub - stage of the second stage .",
    "however , since then @xmath118 , each query takes just @xmath145 time .",
    "in the proof of lemma  [ thm:1se - upper - bound - query - model ] we showed that the total number of queries in the second sub - stage is @xmath146 , so the desired bound follows .",
    "the most critical subroutines of the @xmath1-path inclusion oracle we implemented are operations of addition and multiplication in a finite field @xmath15 .",
    "the choice of @xmath40 is important : the oracle returns a false negative with probability at most @xmath39 .",
    "we can assume that @xmath147 , for otherwise the oracle runs too long .",
    "it follows that to guarantee low error probability , say , at most @xmath148 , it suffices to pick @xmath149 .",
    "comparison of three implementations of @xmath15 arithmetic . left : ( single run of ) @xmath1-path decision oracle for instances with _ no _ solution .",
    "the pattern size is fixed as @xmath150 and the number of vertices @xmath0 varies .",
    "right : fifo algorithm using @xmath1-path decision oracle for instances with exactly one solution ( each running time on the graph is the median of 5 runs for the same input instance ) .",
    "the pattern size is fixed as @xmath151 and the number of vertices @xmath0 varies . running times on a 2.53-ghz intel xeon cpu . ]",
    "comparison of three implementations of @xmath15 arithmetic . left : ( single run of ) @xmath1-path decision oracle for instances with _ no _ solution .",
    "the pattern size is fixed as @xmath150 and the number of vertices @xmath0 varies .",
    "right : fifo algorithm using @xmath1-path decision oracle for instances with exactly one solution ( each running time on the graph is the median of 5 runs for the same input instance ) .",
    "the pattern size is fixed as @xmath151 and the number of vertices @xmath0 varies . running times on a 2.53-ghz intel xeon cpu . ]",
    "let us recall that elements of @xmath15 correspond to polynomials of degree at most @xmath152 with coefficients from @xmath153 .",
    "such a polynomial is conveniently represented as a @xmath40-bit binary number .",
    "the addition in @xmath15 corresponds to addition of two polynomials , that is , the symmetric difference ( xor ) of the binary representations .",
    "multiplication is performed by ( a ) multiplying the polynomials and ( b ) returning the remainder of the division of the result by a primitive degree-@xmath40 polynomial ; this is easily implemented in @xmath154 word operations .",
    "we refer to this implementation as ` naive ' .",
    "one can observe that step ( a ) above corresponds to carry - less multiplication of two binary numbers , that is , the usual multiplication without generating carries ( @xmath155 ) .",
    "such multiplication of two 64-bit numbers is available as a single instruction ( pclmulqdq ) on a number of modern intel and amd architectures .",
    "using the fact that there is an only 5-term primitive polynomial of degree 64 , step ( b ) can be implemented using bit shifts and xors  @xcite .",
    "we refer to this implementation as ` clmul ' .",
    "the third natural option is to _ precompute _ the whole multiplication table ( using the naive algorithm ) before running the oracle .",
    "this takes @xmath156 bytes of memory , so can be considered only for small values of @xmath40 , say @xmath157 ( even for @xmath158 the precomputation time is negligible at substantially less than a second ) .",
    "we refer to this implementation as ` lookup ' .    the left chart of fig .",
    "[ fig : gf - impl ] shows the comparison of the three implementations of @xmath15 arithmetic used in a _",
    "single run _ of the decision oracle .",
    "for ` naive ' we use @xmath149 and for ` clmul ' @xmath159 .",
    "for ` lookup ' we use @xmath160 because for smaller values of @xmath40 the running time is roughly the same ; nevertheless since in the tests we look for a pattern of size 16 , it gives just a bound of @xmath41 for error probability . to squeeze the probability down to",
    "@xmath148 one can run the oracle 10 times and return the conjunction of the results .",
    "we see that although ` lookup ' is faster than ` clmul ' when the oracle is called once , it is much slower when we repeat the oracle call 10 times ( note also that clmul provides error probability @xmath161 ) .",
    "the ` naive ' method is worse than the other two .",
    ", @xmath151 ) using lookup implementation for @xmath162 and clmul implementation ( @xmath159 ) . running time of each execution",
    "is visualized as a green circle .",
    "all experiments for a given field size @xmath163 are summarized using a boxplot showing a first and third quantile and the mean ( thick vertical line).,title=\"fig : \" ] [ fig : boxplots ]    note however that , if we aim at _ finding _ a witness , by theorem  [ thm : main - randomized ] it suffices to guarantee that error probability is at most @xmath41 , hence for @xmath164 we can pick @xmath160 .",
    "the advantage of our witness extraction algorithm fifo is that even if it gets a false answer from the oracle , it will discover the mistake in the future .",
    "indeed , the right chart of fig .",
    "[ fig : gf - impl ] shows that using @xmath165 with ` lookup ' outperforms using @xmath166 with ` clmul ' , roughly by a factor of four .",
    "the value @xmath160 here is carefully chosen .",
    "one one hand , we want @xmath40 to be large to get small error probability for a single query and thus small variance of the whole extraction running time . on the other hand , at our machine the multiplication table for @xmath167 does not fit into l1 cache ( of size 32k ) what results in increase in the median running time . in the table",
    "below ( see also fig .  [",
    "fig : boxplots ] ) we show statistics for 200 runs of the extraction algorithm ( @xmath168 , @xmath151 ) using ` lookup ' for @xmath169 and ` clmul ' ( @xmath159 ) ."
  ],
  "abstract_text": [
    "<S> the gist of many ( np-)hard combinatorial problems is to decide whether a universe of @xmath0 elements contains a _ witness _ consisting of @xmath1 elements that match some prescribed pattern . </S>",
    "<S> for some of these problems there are known advanced algebra - based fpt algorithms which solve the decision problem but do not return the witness . </S>",
    "<S> we investigate techniques for turning such a yes / no - decision oracle into an algorithm for extracting a single witness , with an objective to obtain practical scalability for large values of @xmath0 . by relying on techniques from combinatorial group testing , </S>",
    "<S> we demonstrate that a witness may be extracted with @xmath2 queries to either a deterministic or a randomized set inclusion oracle with one - sided probability of error . </S>",
    "<S> furthermore , we demonstrate through implementation and experiments that the algebra - based fpt algorithms are practical , in particular in the setting of the @xmath1-path problem . also discussed are engineering issues such as optimizing finite field arithmetic . </S>"
  ]
}