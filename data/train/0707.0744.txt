{
  "article_text": [
    "the mechanism of an autonomous agent announcing a promise towards another agent is a powerful organizational principle in the setting of computer networks .",
    "several approaches have been used in the past to formalize such interactions of computing devices as a representation of policies and a resolve of conflicts : burgess and fagernes @xcite represent them as graphs , prakken and sergot @xcite use temporal deontic logic , lupu and sloman @xcite propose role theory , glasgow et al . @xcite modal logic , bandera et al .",
    "@xcite event calculus and lafuente and montanari @xcite model checking .",
    "in this paper we use process algebra @xcite for the formalization of a restricted set of aspects of promises paying attention to the sequential ordering of promises between a number of parties . as an example",
    "we specify how promises may be used in coming to an agreement regarding a simple though practical transportation problem .    in the world of process algebra we can label certain communications as promises if that makes sense intuitively .",
    "process algebra formalisms will not provide very sharp distinctions that set apart _ promise acts _ from all other conceivable actions , however .",
    "modal logics are in principle better suited for the task to capture what is specific about promises , but process algebras may be more helpful to formalize the role that promises can play in specific multi - agent systems .",
    "the justification of the process algebra framework for promises is therefore as follows :    1 .   to provide clear and formalized cases of the use of promises in some protocols that occur within multi - agent systems , 2 .   to support the design and analysis of distributed protocols that make use of promises made by autonomous agents .",
    "the process algebra framework can not , by nature , characterize the concept of a promise in its logical essence .",
    "that is a much harder task and requires the design of specific versions of deontic logic .",
    "the data type for task bodies is depicted in figure [ tb ] .",
    "@xmath0 is assumed to be a finite set of primitives which fall into two basic complementary categories , namely into tasks for giving or taking , or _",
    "services _ and _ usage_. we distinguish the atom @xmath1|the special task of compliance .",
    "atomic tasks are assumed services rather than uses and positive , i.e.  , not negated .",
    "two operations @xmath2 on tasks are then considered :    1 .",
    "( _ usage _ ) if @xmath3 is a task then @xmath4 is denoted by @xmath5 or @xmath6 instead of @xmath4 . ]",
    "is the task of making use of @xmath3 as performed by another agent , and 2 .",
    "( _ negation _ ) if @xmath3 is a task then @xmath7 is the task of not doing @xmath3 .    moreover ,",
    "@xmath8 specify the properties _ service _ and _ positive_. the interaction of these operations satisfies the laws in figure [ usage_negation ] .",
    "@xmath9 & \\neg \\neg x & = & x&&&s(\\neg x ) & = & s(x ) & & & p(\\neg x)&= & \\neg p(x)&\\\\[2 mm ] & { { \\sim}}\\neg x & = & \\neg { { \\sim}}x&&&s({{\\sim}}x)&= & \\neg s(x)&&&p({{\\sim}}x)&= & p(x)&\\\\[2 mm ] \\hspace{.5cm}&&&&&&&&&&&&&&\\hspace{.5cm}\\\\ \\hline \\end{array}\\ ] ]    note that @xmath10 is overloaded in the sense that it acts as negation on tasks and on booleans . the actual meaning , however , will always be clear from the context .",
    "in general , promises can be viewed as declarations to keep certain tuples of data within a given range of values .",
    "promises are thus typed .",
    "we therefore assume a collection of types , @xmath11 , and a typing function @xmath12 providing types for task bodies . given a service @xmath3",
    ", we assume that types do not differ under usage or negation , i.e. , @xmath13 furthermore , since promises can be incompatible with each other we assume a symmetric incompatibility relation @xmath14 .",
    "we write @xmath15|instead of @xmath16|if @xmath3 and @xmath17 _ can not _ both be realized at the same time by the same agent .",
    "only tasks of similar type can exclude one another .",
    "moreover , tasks are incompatible with their negations .",
    "for incompatible tasks @xmath3 and @xmath17 , however , @xmath3 will be compatible with @xmath18 .",
    "observe that @xmath19 is derivable from the axiom and the third rule in figure [ incom ] using the law of double negation shift .",
    "let @xmath20 be a partially ordered set containing so - called agents . for agents @xmath21 ,",
    "we write @xmath22 if @xmath23 is subordinated to @xmath24 .",
    "we denote a promise @xmath3 between arbitrary autonomous agents @xmath23 and @xmath24|while being unspecific about how and when they are made|by @xmath25 for @xmath26 with @xmath27 we distinguish the 4 kinds of promises given in figure [ 4prom ]    @xmath28 & ( 2)&{a \\overset{\\pi:{{\\sim}}x}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } b}\\\\[4 mm ] & ( 3)&{a \\overset{\\pi:\\neg x}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } b}\\\\[4 mm ] & ( 4)&{a \\overset{\\pi:\\neg { { \\sim}}x}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } b}\\\\[4 mm ] \\hline \\end{array}\\ ] ]    where    1 .",
    "@xmath23 promises @xmath24 to provide its service @xmath3 , 2 .",
    "@xmath23 promises @xmath24 to make use of its service @xmath3 , 3 .",
    "@xmath23 promises @xmath24 not to provide its service @xmath3 , and 4 .",
    "@xmath23 promises @xmath24 not to make use of its service @xmath3 .",
    "we tacitly assume that promises are equal under equal tasks , i.e. , that @xmath29    one can generalize this basic notation of promise exchange to a more expressive system where agents can make promises about what other agents might do|provide a service or make use of . a generalized notation of the form @xmath30 \\overset{\\pi : x}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } b[d]}\\ ] ] denotes that ` @xmath23 promises @xmath24 that @xmath31 will do @xmath3 for @xmath32 ' .",
    "the autonomously made promises in figure [ 4prom ] are then equivalent to their more general notations @xmath33 \\overset{\\pi : x}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } b[b]}.\\ ] ]    if @xmath34 and @xmath35 \\overset{\\pi : x}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } b[d]}$ ] , then the promise by @xmath23 implies an obligation for @xmath31 .",
    "autonomous agents , however , ought not to be obliged to anything .",
    "another interaction between autonomous promises and the more general kind of promises is given by the so - called _ compliance promise _ between agent @xmath31 and @xmath23 , @xmath36 where @xmath31 promises to comply with @xmath23 .",
    "we then have @xmath30 \\overset{\\pi : x}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } b[d]},{c \\overset{\\pi:\\gamma}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } a } \\longrightarrow { c \\overset{\\pi : x}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } d}.\\ ] ]    one can consider the even more general notation@xmath37 \\overset{\\pi : x}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } b[d_1,\\ldots , d_m]}\\ ] ] denoting that    1 .   ` @xmath23 promises @xmath24 that one of @xmath38 wil do @xmath3 for some one amongst @xmath39 ' if @xmath3 is a service , or 2 .   `",
    "@xmath23 promises @xmath24 that one of @xmath38 will make use of @xmath3 as done by one amongst @xmath39 ' if @xmath3 is a usage    provided @xmath3 is positive . in the negative case none of @xmath38 wil",
    "do @xmath3 for any of @xmath39 etc .    in distributed systems design",
    "it is unhelpful to use either @xmath35 \\overset{\\pi : x}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } b}$ ] or @xmath35 \\overset{\\pi : x}{- \\!\\!\\!-",
    "\\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } b[d]}$ ] .",
    "if these occur in a design they should and usually can be translated into small protocols using _ voluntary _ promises only . in the sequel",
    "we will therefore focus on promises of the basic form made by autonomous agents forgetting about the general notion of promises .",
    "we will model states as sets of basic promises that do not conflict together with transition rules that describe the development of such states .",
    "the presence of a single promise @xmath40 is written as @xmath41 and promises are combined by the promise set composition operator @xmath42 .",
    "a _ transition rule _ for a basic promise has one of the two forms @xmath43 or @xmath44 where    1 .",
    "@xmath45 is a state , i.e. , a set of non - conflicting basic promises , 2 .",
    "the promise introduction @xmath46 labels the transition rule with the announcement that introduces the promise @xmath47 , 3 .",
    "the promise withdrawal @xmath48 labels the transition rule with the speech act that withdraws the promise @xmath47 , 4 .",
    "@xmath42 combines the state @xmath45 with the promise @xmath47 yielding a new state , and 5 .",
    "@xmath49 removes the promise @xmath47 from the state @xmath45 yielding a new state .",
    "since states are sets of non - conflicting promises , a promise introduction event ( that is an application of the promise introduction rule ) is applicable only if the conclusion of the rule is a set of non - conflicting promises , i.e. , if for all @xmath50 , @xmath51 ) .",
    "here we assume that an autonomous agent is itself responsible for making no promises that would require performing incompatible tasks ( ` breaking its own promises ' is burgess nomenclature in @xcite ) .",
    "this system can be generalized to generalized promises .",
    "a typical rule in this format is of the form @xmath52\\rightarrow b[d]}(x)\\ \\frac{s\\oplus { c \\overset{\\pi:\\gamma}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } a}}{s\\oplus { c \\overset{\\pi:\\gamma}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } a}\\oplus { c \\overset{\\pi : x}{- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!- \\!\\!\\!\\!\\!\\!\\!\\!\\longrightarrow } d}}\\ ] ]    in addition to incompatibility we now introduce _",
    "@xmath53 marking tasks that can not be served to or consumed from two different agents at the same time .",
    "this will mean that @xmath47 and @xmath54 with @xmath55 can never be kept if @xmath56|and should not both be made either .",
    "in the presence of exclusiveness , the promise event rule takes the conditional format @xmath57 note that exclusiveness is not related to incompatibility : ` taking a train ' and ` taking a car ' are conflicting tasks ; ` being driven by ' @xmath24 , however , excludes ` being driven by ' @xmath31 .",
    "we now consider an acp - style process algebra with the standard operators @xmath58 for choice , sequential and parallel composition ( cf .",
    "@xcite ) , and conditional guards ( cf .",
    "e.g. @xcite ) based on atomic actions like @xmath59 and @xmath60 .",
    "in such a setting a protocol , @xmath61 , that describes a plausible course of actions for introducing a promise @xmath47 can be given by @xmath62 here is an example from our recent experience .",
    "the autonomous agents jan , jrgen , and mark consider the task of transport by car to the jacobs university bremen ( jub ) , i.e. ,    1 .",
    "@xmath63 , and 2 .",
    "@xmath64 .",
    "since one can not be transported in 2 different cars at the same time and by 2 different people , @xmath65 is exclusive , i.e. , @xmath66 a possible execution of @xmath67 is given by the trace @xmath68 on an intuitive level , the trace can be described as follows : initially jan promises mark a lift to jub which mark accepts .",
    "then jrgen makes this promise too which mark|because of the exclusiveness of this task|declines .",
    "thereupon jrgen withdraws his offer and mark his declination .",
    "this kind of example can typically be found in data centre management : renaming the agents and tasks to    1 .",
    "@xmath69 , and 2 .",
    "@xmath70    we derive an example of choosing a supplier for e.g.  packet transport , power / electricity etc .",
    "promises are then exclusive if ispa and ispb are competitors , for instance .",
    "we have provided the outline of a process algebra based framework for promise theory . using this algebra in combination with conditional guards one can formalize|as other approaches",
    "do|how promises might be used in coming to an agreement . however , in contrast to the static approaches to promise theory mentioned in the introduction , in the here chosen framework|the algebra of communicating processes acp| the interaction of promises and the resolution of conflicts can be modelled in a dynamic way .",
    "this formalization is treating promises at a meta - level .",
    "there are also underlying events or processes that the promises suppress|we do not talk about how the promises are kept , or comment on their reliability ; that is a different matter .",
    "thus our description is at a _ promise management level_. at that level we could say it describes an autonomous process .",
    "jan bergstra and mark burgess acknowledge helpful discussions with jrgen schnwlder , school of engineering and science , during a working visit of one week to the jacobs university bremen in october 2006 .",
    "bandara , e.c .",
    "lupu , j. moffet , and a. russo . using event calculus to formalise policy specification and analysis .",
    "_ proceedings of the 5th international workshop on policies for distributed systems and networks ( policy 2004 ) _ , ieee computer society , 229239 ( 2004 ) ."
  ],
  "abstract_text": [
    "<S> we present a process algebra based approach to formalize the interactions of computing devices such as the representation of policies and the resolution of conflicts . as an example </S>",
    "<S> we specify how promises may be used in coming to an agreement regarding a simple though practical transportation problem .    software / program verification , formal methods d.2.4 </S>"
  ]
}