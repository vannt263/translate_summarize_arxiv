{
  "article_text": [
    "information - theoretic research on capacity and coding for write - limited memory originates in @xcite , @xcite , @xcite and @xcite . in @xcite ,",
    "the authors consider a model of write - once memory ( wom ) .",
    "in particular , each memory cell can be in state either 0 or 1 .",
    "the state of a cell can go from 0 to 1 , but not from 1 back to 0 later .",
    "these write - once bits are called _ wits_. it is shown that , the efficiency of storing information in a wom can be improved if one allows multiple rewrites and designs the storage / rewrite scheme carefully .",
    "multilevel flash memory is a storage technology where the charge level of any cell can be easily increased , but is difficult to decrease .",
    "recent multilevel cell technology allows many charge levels to be stored in a cell .",
    "cells are organized into blocks that contain roughly @xmath2 cells .",
    "the only way to decrease the charge level of a cell is to erase the whole block ( i.e. , set the charge on all cells to zero ) and reprogram each cell .",
    "this takes time , consumes energy , and reduces the lifetime of the memory .",
    "therefore , it is important to design efficient rewriting schemes that maximize the number of rewrites between two erasures @xcite , @xcite , @xcite , @xcite .",
    "the rewriting schemes increase some cell charge levels based on the current cell state and message to be stored . in this paper",
    ", we call a rewriting scheme a _ modulation code_.    two different objective functions for modulation codes are primarily considered in previous work : ( i ) maximizing the number of rewrites for the worst case @xcite and ( ii ) maximizing for the average case @xcite . as",
    "finucane et al .",
    "@xcite mentioned , the reason for considering average performance is the averaging effect caused by the large number of erasures during the lifetime of a flash memory device .",
    "our analysis shows that the worst - case objective and the average case objective are two extreme cases of our optimization objective .",
    "we also discuss under what conditions each optimality measure makes sense .    in previous work ( e.g. , @xcite ) ,",
    "many modulation codes are shown to be asymptotically optimal as the number of cell - levels @xmath0 goes to infinity .",
    "but the condition that @xmath1 can not be satisfied in practical systems . therefore , we also analyze asymptotically optimal modulation codes when @xmath0 is only moderately large using the results from load - balancing theory @xcite .",
    "this suggests an enhanced algorithm that improves the performance of practical system significantly .",
    "theoretical analysis and simulation results show that this algorithm performs better than other asymptotically optimal algorithms when @xmath0 is moderately large .",
    "the structure of the paper is as follows .",
    "the system model and performance evaluation metrics are discussed in section [ sec : optimality - measure ] .",
    "an asymptotically optimal modulation code , which is universal over arbitrary i.i.d .",
    "input distributions , is proposed in section [ sub : another - rewriting - algorithm ] .",
    "the storage efficiency of this asymptotically optimal modulation code is analyzed in section [ sec : an - enhanced - algorithm ] .",
    "an enhanced modulation code is also presented in section [ sec : an - enhanced - algorithm ] .",
    "the storage efficiency of the enhanced algorithm is also analyzed in section [ sec : an - enhanced - algorithm ] .",
    "simulation results and comparisons are presented in section [ sec : simulation - results ] .",
    "the paper is concluded in section [ sec : conclusion ] .",
    "flash memory devices usually rely on error detecting / correcting codes to ensure a low error rate . so far",
    ", practical systems tend to use bose - chaudhuri - hocquenghem ( bch ) and reed - solomon ( rs ) codes .",
    "the error - correcting codes ( ecc s ) are used as the outer codes while the modulation codes are the inner codes . in this paper , we focus on the modulation codes and ignore the noise and the design of ecc for now .",
    "let us assume that a block contains @xmath3 @xmath0-level cells and that @xmath4 cells ( called an @xmath4-cell ) are used together to store @xmath5 @xmath6-ary variables ( called a @xmath5-variable ) .",
    "a block contains @xmath7 @xmath4-cells and the @xmath7 @xmath5-variables are assumed to be i.i.d . random variables .",
    "we assume that all the @xmath5-variables are updated together randomly at the same time and the new values are stored in the corresponding @xmath4-cells .",
    "this is a reasonable assumption in a system with an outer ecc .",
    "we use the subscript @xmath8 to denote the time index and each rewrite increases @xmath8 by 1 .",
    "when we discuss a modulation code , we focus on a single @xmath4-cell .",
    "( the encoder of the modulation code increases some of the cell - levels based on the current cell - levels and the new value of the @xmath5-variable . )",
    "remember that cell - levels can only be increased during a rewrite .",
    "so , when any cell - level must be increased beyond the maximum value @xmath9 , the whole block is erased and all the cell levels are reset to zero .",
    "we let the maximal allowable number of block - erasures be @xmath10 and assume that after @xmath10 block erasures , the device becomes unreliable .",
    "assume the @xmath5-variable written at time @xmath8 is a random variable @xmath11 sampled from the set @xmath12 with distribution @xmath13 .",
    "for convenience , we also represent the @xmath5-variable at time @xmath8 in the vector form as @xmath14 where @xmath15 denotes the set of integers modulo @xmath6 .",
    "the cell - state vector at time @xmath8 is denoted as @xmath16 and @xmath17 denotes the charge level of the @xmath18-th cell at time @xmath19 when we say @xmath20 we mean @xmath21 for @xmath22 since the charge level of a cell can only be increased , continuous use of the memory implies that an erasure of the whole block will be required at some point .",
    "although writes , reads and erasures can all introduce noise into the memory , we neglect this and assume that the writes , reads and erasures are noise - free .",
    "consider writing information to a flash memory when encoder knows the previous cell state @xmath23 the current @xmath5-variable @xmath24 , and an encoding function @xmath25 that maps @xmath24 and @xmath26 to a new cell - state vector @xmath27 .",
    "the decoder only knows the current cell state @xmath27 and the decoding function @xmath28 that maps the cell state @xmath27 back to the variable vector @xmath29 .",
    "of course , the encoding and decoding functions could change over time to improve performance , but we only consider time - invariant encoding / decoding functions for simplicity .",
    "the idea of designing efficient modulation codes jointly to store multiple variables in multiple cells was introduced by jiang @xcite . in previous work on modulation codes",
    "design for flash memory ( e.g. @xcite , @xcite , @xcite , @xcite ) , the lifetime of the memory ( either worst - case or average ) is maximized given fixed amount of information per rewrite .",
    "improving storage density and extending the lifetime of the device are two conflicting objectives .",
    "one can either fix one and optimize the other or optimize over these two jointly .",
    "most previous work ( e.g. , @xcite ) takes the first approach by fixing the amount of information for each rewrite and maximizing the number of rewrites between two erasures . in this paper",
    ", we consider the latter approach and our objective is to maximize the total amount of information stored in the device until the device dies .",
    "this is equivalent to maximizing the average ( over the @xmath5-variable distribution @xmath13 ) amount of information stored per cell - level , @xmath30 where @xmath31 is the amount of information stored at the @xmath18-th rewrite , @xmath32 is the number of rewrites between two erasures , and the expectation is over the @xmath5-variable distribution .",
    "we also call @xmath33 as _ storage efficiency_.      in previous work on modulation codes for flash memory , the number of rewrites of an @xmath4-cell has been maximized in two different ways . the authors in @xcite consider the worst case number of rewrites and the authors in @xcite consider the average number of rewrites . as mentioned in @xcite , the reason for considering the average case is due to the large number of erasures in the lifetime of a flash memory device .",
    "interestingly , these two considerations can be seen as two extreme cases of the optimization objective in ( [ eq : opt ] ) .",
    "let the @xmath5-variables be a sequence of i.i.d .",
    "random variables over time and all the @xmath4-cells .",
    "the objective of optimization is to maximize the amount of information stored until the device dies .",
    "the total amount of information stored in the device - cell changes to the same value , should it count as stored information ? should this count as a rewrite ?",
    "this formula assumes that it counts as a rewrite , so that @xmath34 values ( rather than @xmath35 ) can be stored during each rewrite .",
    "] can be upper - bounded by @xmath36 where @xmath37 is the number of rewrites between the @xmath38-th and the @xmath18-th erasures .",
    "note that the upper bound in ( [ eq : total_info_ub ] ) is achievable by uniform input distribution , i.e. , when the input @xmath5-variable is uniformly distributed over @xmath39 , each rewrite stores @xmath40 bits of information .",
    "due to the i.i.d .",
    "property of the input variables over time , @xmath37 s are i.i.d .",
    "random variables over time . since @xmath37 s are i.i.d . over time",
    ", we can drop the subscript @xmath18 .",
    "since @xmath10 , which is the maximum number of erasures allowed , is approximately on the order of @xmath41 , by the law of large numbers ( lln ) , we have @xmath42k\\log_{2}(l).\\ ] ] let the set of all valid encoder / decoder pairs be @xmath43 where @xmath44 implies the charge levels are element - wise non - decreasing .",
    "this allows us to treat the problem @xmath45 as the following equivalent problem @xmath46k\\log_{2}(l).\\label{eq : opt2 - 1}\\ ] ]    denote the maximal charge level of the @xmath18-th @xmath4-cell at time @xmath8 as @xmath47 .",
    "note that time index @xmath8 is reset to zero when a block erasure occurs and increased by one at each rewrite otherwise .",
    "denote the maximal charge level in a block at time @xmath8 as @xmath48 which can be calculated as @xmath49 define @xmath50 as the time when the @xmath18-th @xmath4-cell reaches its maximal allowed value , i.e. , @xmath51 .",
    "we assume , perhaps naively , that a block - erasure is required when any cell within a block reaches its maximum allowed value .",
    "the time when a block erasure is required is defined as @xmath52 it is easy to see that @xmath53=ne\\left[t\\right],$ ] where the expectations are over the @xmath5-variable distribution . so maximizing @xmath54 $ ] is equivalent to maximizing @xmath55 .",
    "so the optimization problem ( [ eq : opt2 - 1 ] ) can be written as the following optimization problem @xmath56.\\label{eq : opt3}\\ ] ] under the assumption that the input is i.i.d .",
    "over all the @xmath4-cells and time indices , one finds that the @xmath50 s are i.i.d . random variables .",
    "let their common probability density function ( pdf ) be @xmath57 it is easy to see that @xmath58 is the minimum of @xmath7 i.i.d .",
    "random variables with pdf @xmath57 therefore , we have @xmath59 where @xmath60 is the cumulative distribution function ( cdf ) of @xmath61",
    "so , the optimization problem ( [ eq : opt3 ] ) becomes @xmath62=\\max_{f , g\\in\\mathcal{q}}\\int nf_{t}(x)\\left(1-f_{t}(x)\\right)^{n-1}x\\mbox{d}x.\\label{eq : opt}\\ ] ] note that when @xmath63 the optimization problem in ( [ eq : opt ] ) simplifies to @xmath64.\\label{eq : opt2}\\ ] ] this is essentially the case that the authors in @xcite consider .",
    "when the whole block is used as one @xmath4-cell and the number of erasures allowed is large , optimizing the average ( over all input sequences ) number of rewrites of an @xmath4-cell is equivalent to maximizing the total amount of information stored @xmath65 the analysis also shows that the reason we consider average performance is not only due to the averaging effect caused by the large number of erasures .",
    "one other important assumption is that there is only one @xmath4-cell per block .",
    "the other extreme is when @xmath66 in this case , the pdf @xmath67 tends to a point mass at the minimum of @xmath8 and the integral @xmath68 approaches the minimum of @xmath8 .",
    "this gives the worst case stopping time for the programming process of an @xmath4-cell .",
    "this case is considered by @xcite .",
    "our analysis shows that we should consider the worst case when @xmath69 even though the device experiences a large number of erasures .",
    "so the optimality measure is not determined only by @xmath10 , but also by @xmath70 when @xmath7 and @xmath10 are large , it makes more sense to consider the worst case performance . when @xmath71 , it is better to consider the average performance . when @xmath7 is moderately large",
    ", we should maximize the number of rewrites using ( [ eq : opt ] ) which balances the worst case and the average case .",
    "when @xmath7 is moderately large , one should probably focus on optimizing the function in ( [ eq : opt ] ) , but it is not clear how to do this directly .",
    "so , this remains an open problem for future research .",
    "instead , we will consider a load - balancing approach to improve practical systems where @xmath0 is moderately large .",
    "if we assume that there is only one variable changed each time , the average amount of information per cell - level can be bounded by @xmath72 because there are @xmath73 possible new values .",
    "since the number of rewrites can be bounded by @xmath74 we have @xmath75 if we allow arbitrary change on the @xmath5-variables , there are totally @xmath76 possible new values .",
    "it can be shown that @xmath77 for fixed @xmath6 and @xmath0 , the bound in ( [ eq : storage_efficiency_bound ] ) suggests using a large @xmath5 can improve the storage efficiency .",
    "this is also the reason jointly coding over multiple cells can improve the storage efficiency @xcite . since optimal rewriting schemes only allow a single cell - level to increase by one during each rewrite , decodability implies that @xmath78 for the first case and @xmath79 for the second case .",
    "therefore , the bounds in ( [ eq : storage_efficiency_bound2 ] ) and ( [ eq : storage_efficiency_bound ] ) also require large @xmath4 to improve storage efficiency .",
    "the upper bound in ( [ eq : storage_efficiency_bound ] ) grows linearly with @xmath5 while the upper bound in ( [ eq : storage_efficiency_bound2 ] ) grows logarithmically with @xmath5 .",
    "therefore , in the remainder of this paper , we assume an arbitrary change in the @xmath5-variable per rewrite and @xmath71 , i.e. , the whole block is used as an @xmath4-cell , to improve the storage efficiency .",
    "this approach implicitly trades instantaneous capacity for future storage capacity because more cells are used to store the same number of bits , but the cells can also be reused many more times .",
    "note that the assumption of @xmath71 might be difficult for real implementation , but its analysis gives an upper bound on the storage efficiency . from the analysis above with @xmath71",
    ", we also know that maximizing @xmath33 is equivalent to maximize the average number of rewrites .",
    "in @xcite , modulation codes are proposed that are asymptotically optimal ( as @xmath0 goes to infinity ) in the average sense when @xmath80 . in this section ,",
    "we introduce a modulation code that is asymptotically optimal for arbitrary input distributions and arbitrary @xmath5 and @xmath6 . this rewriting algorithm can be seen as an extension of the one in @xcite .",
    "the goal is , to increase the cell - levels uniformly on average for an arbitrary input distribution .",
    "of course , decodability must be maintained .",
    "the solution is to use common information , known to both the encoder ( to encode the input value ) and the decoder ( to ensure the decodability ) , to randomize the cell index over time for each particular input value .",
    "let us assume the @xmath5-variable is an i.i.d .",
    "random variable over time with arbitrary distribution @xmath13 and the @xmath5-variable at time @xmath8 is denoted as @xmath81 the output of the decoder is denoted as @xmath82 we choose @xmath83 and let the cell state vector at time @xmath8 be @xmath84 , where @xmath17 is the charge level of the @xmath18-th cell at time @xmath19 at @xmath85 , the variables are initialized to @xmath86 , @xmath87 and @xmath88 .    the decoding algorithm @xmath89 is described as follows .",
    "* step 1 : read cell state vector @xmath27 and calculate the @xmath90 norm @xmath91 .",
    "* step 2 : calculate @xmath92 and @xmath93    the encoding algorithm @xmath94 is described as follows .",
    "* step 1 : read cell state @xmath26 and calculate @xmath95 and @xmath96 as above . if @xmath97 then do nothing . *",
    "step 2 : calculate @xmath98 and @xmath99 * step 3 : increase the charge level of the @xmath100-th cell by 1 .    for convenience , in the rest of the paper , we refer the above rewriting algorithm as `` self - randomized modulation code '' .",
    "the self - randomized modulation code achieves at least @xmath101 rewrites with high probability , as @xmath102 for arbitrary @xmath103 @xmath104 and i.i.d",
    ". input distribution @xmath13 .",
    "therefore , it is asymptotically optimal for random inputs as @xmath1 .",
    "[ sketch of proof ] the proof is similar to the proof in @xcite .",
    "since exactly one cell has its level increased by 1 during each rewrite , @xmath105 is an integer sequence that increases by 1 at each rewrite .",
    "the cell index to be written @xmath100 is randomized by adding the value @xmath106 .",
    "this causes each consecutive sequence of @xmath76 rewrites to have a uniform affect on all cell levels . as @xmath1 ,",
    "an unbounded number of rewrites is possible and we can assume @xmath107 .",
    "consider the first @xmath108 steps , the value @xmath109 is as even as possible over @xmath110 for convenience , we say there are",
    "@xmath111 @xmath112 s at each value , as the rounding difference by 1 is absorbed in the @xmath113 term .",
    "assuming the input distribution is @xmath114 .",
    "for the case that @xmath115 , the probability that @xmath116 is @xmath117 for @xmath118 .",
    "therefore , @xmath119 has a uniform distribution over @xmath12 .",
    "since inputs are independent over time , by applying the same chernoff bound argument as @xcite , it follows that the number of times @xmath116 is at most @xmath120 with high probability ( larger than @xmath121 ) for all @xmath122 . summing over @xmath122",
    ", we finish the proof .",
    "notice that the randomizing term @xmath105 a deterministic term which makes @xmath100 look _ random _ over time in the sense that there are equally many terms for each value .",
    "moreover , @xmath105 is known to both the encoder and the decoder such that the encoder can generate `` uniform '' cell indices over time and the decoder knows the accumulated value of @xmath105 , it can subtract it out and recover the data correctly .",
    "although this algorithm is asymptotically optimal as @xmath1 , the maximum number of rewrites @xmath123 can not be achieved for moderate @xmath0 .",
    "this motivates the analysis and the design of an enhanced version of this algorithm for practical systems in next section .",
    "a self - randomized modulation code uses @xmath83 cells to store a @xmath5-variable .",
    "this is much larger than the @xmath124 used by previous asymptotically optimal algorithms because we allow the @xmath5-variable to change arbitrarily .",
    "although this seems to be a waste of cells , the average amount of information stored per cell - level is actually maximized ( see ( [ eq : storage_efficiency_bound2 ] ) and ( [ eq : storage_efficiency_bound ] ) ) .",
    "in fact , the definition of asymptotic optimality requires @xmath79 if we allow arbitrary changes to the @xmath5-variable .",
    "we note that the optimality of the self - randomized modulation codes is similar to the weak robust codes presented in @xcite .",
    "we use @xmath83 cells to store one of @xmath125 possible messages .",
    "this is slightly worse than the simple method of using @xmath126 .",
    "is it possible to have self - randomization using only @xmath126 cells ?",
    "a preliminary analysis of this question based on group theory indicates that it is not .",
    "thus , the extra cell provides the possibility to randomize the mappings between message values and the cell indices over time .",
    "while asymptotically optimal modulation codes ( e.g. , codes in @xcite , @xcite , @xcite , @xcite and the self - randomized modulation codes described in section [ sec : another - rewriting - algorithm ] ) require @xmath1 , practical systems use @xmath0 values between @xmath127 and @xmath128 . compared to the number of cells @xmath4 ,",
    "the size of @xmath0 is not quite large enough for asymptotic optimality to suffice . in other words , codes that are asymptotically optimal",
    "may have significantly suboptimal performance when the system parameters are not large enough .",
    "moreover , different asymptotically optimal codes may perform differently when @xmath0 is not large enough . therefore , asymptotic optimality can be misleading in this case . in this section ,",
    "we first analyze the storage efficiency of self - randomized modulation codes when @xmath0 is not large enough and then propose an enhanced algorithm which improves the storage efficiency significantly .",
    "before we analyze the storage efficiency of asymptotically optimal modulation codes for moderately large @xmath0 , we first show the connection between rewriting process and the load - balancing problem ( aka the balls - into - bins or balls - and - bins problem ) which is well studied in mathematics and computer science @xcite .",
    "basically , the load - balancing problem considers how to distribute objects among a set of locations as evenly as possible .",
    "specifically , the balls - and - bins model considers the following problem .",
    "if @xmath129 balls are thrown into @xmath4 bins , with each ball being placed into a bin chosen independently and uniformly at random , define the _ load _ as the number of balls in a bin , what is the maximal load over all the bins ? based on the results in theorem 1 in @xcite , we take a simpler and less accurate approach to the balls - into - bins problem and arrive at the following theorem .    [ thm : random_loading]suppose that @xmath129 balls are sequentially placed into @xmath4 bins . each time",
    "a bin is chosen independently and uniformly at random .",
    "the maximal load over all the bins is @xmath130 and :    ( @xmath18 ) if @xmath131 the maximally loaded bin has @xmath132 balls , @xmath133 and @xmath134 , with high probability ( @xmath135 ) as @xmath136    ( @xmath137 ) if @xmath138 , the maximally loaded bin has @xmath139 balls , @xmath140 , with high probability ( @xmath135 ) as @xmath136    ( @xmath141 ) if @xmath142 the maximally loaded bin has @xmath143 , @xmath144 , @xmath145 and @xmath146 , with high probability ( @xmath135 ) as @xmath136    denote the event that there are at least @xmath5 balls in a particular bin as @xmath147 . using the union bound over all subsets of size",
    "@xmath103 it is easy to show that the probability that @xmath147 occurs is upper bounded by @xmath148 using stirling s formula , we have @xmath149 . then @xmath150 can be further bounded by @xmath151 if @xmath152 , substitute @xmath153 to the rhs of ( [ eq : maxload_ub ] ) , we have @xmath154 denote the event that all bins have at most @xmath5 balls as @xmath155 . by applying the union bound , it is shown that @xmath156 since @xmath157 we finish the proof for the case of @xmath158    if @xmath138 , substitute @xmath159 to the rhs of ( [ eq : maxload_ub ] ) , we have @xmath160 by applying the union bound , we finish the proof for the case of @xmath161    if @xmath142 substitute @xmath162 to the rhs of ( [ eq : maxload_ub ] ) , we have @xmath163 where @xmath164 by applying the union bound , it is shown that @xmath165 since @xmath166 we finish the proof for the case of @xmath167    note that theorem [ thm : random_loading ] only shows an upper bound on the maximum load @xmath130 with a simple proof .",
    "more precise results can be found in theorem 1 of @xcite , where the exact order of @xmath130 is given for different cases .",
    "it is worth mentioning that the results in theorem 1 of @xcite are different from theorem [ thm : random_loading ] because theorem 1 of @xcite holds with probability @xmath168 while theorem [ thm : random_loading ] holds with probability ( @xmath135 ) .",
    "the asymptotic optimality in the rewriting process implies that each rewrite only increases the cell - level of a cell by 1 and all the cell - levels are fully used when an erasure occurs .",
    "this actually implies @xmath169 .",
    "since @xmath4 is usually a large number and @xmath0 is not large enough in practice , the theorem shows that , when @xmath0 is not large enough , asymptotic optimality is not achievable .",
    "for example , in practical systems , the number of cell - levels @xmath0 does not depend on the number of cells in a block .",
    "therefore , rather than @xmath74 only roughly @xmath170 charge levels can be used as @xmath171 if @xmath0 is a small constant which is independent of @xmath4 . in practice",
    ", this loss could be mitigated by using writes that increase the charge level in multiple cells simultaneously ( instead of erasing the block ) .",
    "[ thm : gamma1]the self - randomized modulation code has storage efficiency @xmath172 when @xmath173 and @xmath174 when @xmath175 as @xmath4 goes to infinity with high probability ( i.e. , @xmath168 ) .    consider the problem of throwing @xmath129 balls into @xmath4 bins and let the r.v .",
    "@xmath10 be the number of balls thrown into @xmath4 bins until some bin has more than @xmath9 balls in it . while we would like to calculate @xmath176 $ ] exactly",
    ", we still settle for an approximation based on the following result . if @xmath177 , then there is a constant @xmath178 such that maximum number of balls @xmath130 in any bin satisfies@xmath179 with probability @xmath168 as @xmath171 @xcite .",
    "the constant @xmath178 is given by the largest @xmath180-root of@xmath181 and solving this equation for @xmath182 gives the implicit expression @xmath183 .",
    "since the lower bound matches the expected maximum value better , we define @xmath184 and apply it to our problem using the equation @xmath185 or @xmath186 .",
    "therefore , the storage efficiency is @xmath187    if @xmath188 , the maximum load is approximately @xmath189 with probability @xmath168 for large @xmath4 @xcite . by definition ,",
    "therefore , the storage efficiency is @xmath191    the results in theorem [ thm : gamma1 ] show that when @xmath0 is on the order of @xmath192 , the storage efficiency is on the order of @xmath193 . taking the limit as @xmath194 with @xmath195 , we have @xmath196 when @xmath0 is a constant independent of @xmath4 , the storage efficiency is on the order of @xmath197 taking the limit as @xmath171 with @xmath173 , we have @xmath198 . in this regime , the self - randomized modulation codes actually perform very poorly even though they are asymptotically optimal as @xmath1 .",
    "considering the bins - and - balls problem , can we distribute balls more evenly when @xmath199 is on the order of @xmath200 fortunately , when @xmath201 , the maximal load can be reduced by a factor of roughly @xmath202 by using _",
    "the power of two random choices _ @xcite . in detail ,",
    "the strategy is , every time we pick two bins independently and uniformly at random and throw a ball into the less loaded bin . by doing this ,",
    "the maximally loaded bin has roughly @xmath203 balls with high probability .",
    "theorem 1 in @xcite gives the answer in a general form when we consider @xmath204 random choices .",
    "the theorem shows there is a large gain when the number of random choice is increased from 1 to 2 . beyond that , the gain is on the same order and only the constant can be improved .",
    "based on the idea of 2 random choices , we define the following load - balanced modulation code .    again , we let the cell state vector at time @xmath8 be @xmath84 , where @xmath17 is the charge level of the @xmath18-th cell at time @xmath19 this time , we use @xmath205 cells to store a @xmath5-variable @xmath206 ( i.e. , we write @xmath207 bits to store @xmath208 bits of information ) .",
    "the information loss provides @xmath6 ways to write the same value .",
    "this flexibility allows us to avoid sequences of writes that increase one cell level too much .",
    "we are primarily interested in binary variables with 2 random choices or @xmath209 . for the power of @xmath6 choices to be effective , we must try to randomize ( over time ) , the @xmath6 possible choices over the set of all @xmath210 possibilities . the value @xmath91 is used to do this .",
    "let @xmath211 be the galois field with @xmath212 elements and @xmath213 be a bijection that satisfies @xmath214 ( i.e. , the galois field element 0 is associated with the integer 0 ) .",
    "the decoding algorithm calculates @xmath215 from @xmath27 and operates as follows :    * step 1 : read cell state vector @xmath27 and calculate the @xmath90 norm @xmath91 .",
    "* step 2 : calculate @xmath216 and @xmath217 * step 3 : calculate @xmath218 and @xmath219 * step 4 : calculate @xmath220 .",
    "the encoding algorithm stores @xmath11 and operates as follows .",
    "* step 1 : read cell state @xmath26 and decode to @xmath221 and @xmath96 . if @xmath222 then do nothing .",
    "* step 2 : calculate @xmath223 , @xmath218 , and @xmath219 * step 3 : calculate @xmath224 and @xmath225 for @xmath226 .",
    "* step 4 : calculate @xmath227 .",
    "increase the charge level by 1 of cell @xmath228 .",
    "note that the state vector at @xmath85 is initialized to @xmath229 and therefore @xmath87 .",
    "the first arbitrary value that can be stored is @xmath230 .",
    "the following conjecture suggests that the ball - loading performance of the above algorithm is identical to the random loading algorithm with @xmath209 random choices .",
    "[ thm : gamma2]if @xmath209 and @xmath175 , then the load - balancing modulation code has storage efficiency @xmath231 with probability 1-@xmath232 as @xmath171 . if @xmath233 the storage efficiency @xmath234 with probability 1-@xmath232 .    [ sketch of proof ]",
    "consider the affine permutation @xmath235 for @xmath236 and @xmath237 .",
    "as @xmath238 vary , this permutation maps the two elements @xmath11 and @xmath239 uniformly over all pairs of cell indices .",
    "after @xmath240 steps , we see that all pairs of @xmath238 occur equally often .",
    "therefore , by picking the less charged cell , the modulation code is almost identical to the random loading algorithm with two random choices .",
    "unfortunately , we are interested in the case where @xmath241 so the analysis is somewhat more delicate . if @xmath177 , the highest charge level is @xmath242 with probability @xmath168 @xcite . since @xmath175 in this case , the storage efficiency is @xmath243 .",
    "if @xmath188 , then @xmath173 and the maximum load is @xmath244 . by definition ,",
    "we have @xmath245 therefore , we have @xmath246    if @xmath209 and @xmath0 is on the order of @xmath247 conjecture [ thm : gamma2 ] shows that the bound ( [ eq : storage_efficiency_bound ] ) is achievable by load - balancing modulation codes as @xmath4 goes to infinity . in this regime ,",
    "the load - balancing modulation codes provide a better constant than self - randomized modulation codes by using twice many cells .",
    "[ rem : if ",
    "@xmath209 and @xmath0 is a constant independent of @xmath4 , the storage efficiency is @xmath248 for the self - randomized modulation code and @xmath249 for the load - balancing modulation code .",
    "but , the self - randomized modulation code uses @xmath250 cells and the load - balancing modulation code uses @xmath251 cells . to make fair comparison on the storage efficiency between them , we let @xmath251 for both codes .",
    "then we have @xmath252 and @xmath249 .",
    "so , as @xmath171 , we see that @xmath253 .",
    "therefore , the load - balancing modulation code outperforms the self - randomized code when @xmath4 is sufficiently large .",
    "in this section , we present the simulation results for the modulation codes described in sections [ sub : another - rewriting - algorithm ] and [ sub : an - enhanced - algorithm ] . in the figures ,",
    "the first modulation code is called the `` self - randomized modulation code '' while the second is called the `` load - balancing modulation code '' .",
    "let the `` loss factor '' @xmath254 be the fraction of cell - levels which are not used when a block erasure is required : @xmath255}{n(q-1)}.$ ] we show the loss factor for random loading with 1 and 2 random choices as comparison .",
    "note that @xmath254 does not take the amount of information per cell - level into account .",
    "results in fig .",
    "[ flo : fig2 ] show that the self - randomized modulation code has the same @xmath254 with random loading with 1 random choice and the load - balancing modulation code has the same @xmath254 with random loading with 2 random choices .",
    "this shows the optimality of these two modulation codes in terms of ball loading .    , @xmath209 and 1000 erasures.[flo : fig2 ] ]     with @xmath80 , @xmath256 @xmath257 and 1000 erasures.[flo : fig4 ] ]    .[fig : fig5 ] ]    .[fig : fig6 ] ]",
    "we also provide the simulation results for random loading with 1 random choice and the codes designed in @xcite , which we denote as flm-(@xmath258 ) algorithm , in fig .",
    "[ flo : fig4 ] . from results shown in fig .",
    "[ flo : fig4 ] , we see that the flm-(@xmath258 ) algorithm has the same loss factor as random loading with 1 random choice .",
    "this can be actually seen from the proof of asymptotic optimality in @xcite as the algorithm transforms an arbitrary input distribution into an uniform distribution on the cell - level increment .",
    "note that flm algorithm is only proved to be optimal when 1 bit of information is stored .",
    "so we just compare the flm algorithm with random loading algorithm in this case .",
    "[ fig : fig5 ] and fig .",
    "[ fig : fig6 ] show the storage efficiency @xmath33 for these two modulation codes .",
    "[ fig : fig5 ] and fig .",
    "[ fig : fig6 ] show that the load - balancing modulation code performs better than self - randomized modulation code when @xmath4 is large .",
    "this is also shown by the theoretical analysis in remark [ rem : if  is ] .",
    "in this paper , we consider modulation code design problem for practical flash memory storage systems . the storage efficiency , or average ( over the distribution of input variables ) amount of information per cell - level is maximized . under this framework",
    ", we show the maximization of the number of rewrites for the the worst - case criterion @xcite and the average - case criterion @xcite are two extreme cases of our optimization objective .",
    "the self - randomized modulation code is proposed which is asymptotically optimal for arbitrary input distribution and arbitrary @xmath5 and @xmath6 , as the number of cell - levels @xmath1 .",
    "we further consider performance of practical systems where @xmath0 is not large enough for asymptotic results to dominate .",
    "then we analyze the storage efficiency of the self - randomized modulation code when @xmath0 is only moderately large .",
    "then the load - balancing modulation codes are proposed based on the power of two random choices @xcite @xcite .",
    "analysis and numerical simulations show that the load - balancing scheme outperforms previously proposed algorithms ."
  ],
  "abstract_text": [
    "<S> in this paper , we consider modulation codes for practical multilevel flash memory storage systems with @xmath0 cell levels . instead of maximizing the lifetime of the device @xcite , </S>",
    "<S> we maximize the average amount of information stored per cell - level , which is defined as storage efficiency . using this framework </S>",
    "<S> , we show that the worst - case criterion @xcite and the average - case criterion @xcite are two extreme cases of our objective function . </S>",
    "<S> a self - randomized modulation code is proposed which is asymptotically optimal , as @xmath1 , for an arbitrary input alphabet and i.i.d . </S>",
    "<S> input distribution .    in practical flash memory systems , </S>",
    "<S> the number of cell - levels @xmath0 is only moderately large . </S>",
    "<S> so the asymptotic performance as @xmath1 may not tell the whole story . using the tools from load - balancing theory , we analyze the storage efficiency of the self - randomized modulation code . </S>",
    "<S> the result shows that only a fraction of the cells are utilized when the number of cell - levels @xmath0 is only moderately large . </S>",
    "<S> we also propose a load - balancing modulation code , based on a phenomenon known as `` the power of two random choices '' @xcite , to improve the storage efficiency of practical systems . </S>",
    "<S> theoretical analysis and simulation results show that our load - balancing modulation codes can provide significant gain to practical flash memory storage systems . </S>",
    "<S> though pseudo - random , our approach achieves the same load - balancing performance , for i.i.d . inputs , as a purely random approach based on the power of two random choices . </S>"
  ]
}