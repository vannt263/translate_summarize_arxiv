{
  "article_text": [
    "the _ guarding game _ @xmath0 , introduced by fomin et al .",
    "@xcite , is played on a graph @xmath1 ( or directed graph @xmath2 ) by two players , the _ cop - player _ and the _ robber - player _ , each having his pawns ( @xmath3 cops and one robber , respectively ) on  @xmath4 .",
    "there is a protected region ( also called cop - region ) @xmath5 .",
    "the remaining region @xmath6 is called robber - region and denoted @xmath7 .",
    "robber aims to enter @xmath8 by a move to a vertex of @xmath8 with no cop on it .",
    "the cops try to prevent this .",
    "the game is played in alternating turns . in the first turn the robber - player places robber on some vertex of @xmath7 . in the second turn",
    "the cop - player places his @xmath3 cops on vertices of @xmath8 ( more cops can share one vertex ) . in each subsequent",
    "turn the respective player can move each of his pawns to a neighbouring vertex of the pawn s position ( or leave it where it is ) .",
    "however , the cops can move only inside @xmath8 and robber can move only on vertices with no cops . at any time of the game",
    "both players know the positions of all pawns .",
    "the robber - player wins if he is able to move robber to some vertex of @xmath8 in a finite number of steps .",
    "the cop - player wins if the cop - player can prevent the robber - player from placing robber on a vertex in @xmath8 indefinitely .",
    "note that @xmath9 is the upper bound on the number of all possible positions of robber and all cops , so after that many turns the position has to repeat .",
    "thus , if robber can win , he can win in less than @xmath9 turns .",
    "consequently , we may define robber to lose if he does not win in @xmath9 turns . without loss of generality",
    ", we may assume that robber never passes his move .",
    "for a given graph @xmath10 and guarded region @xmath8 , the task is to find the minimum number @xmath3 such that cop - player wins .",
    "note that this problem is polynomially equivalent with the problem of determining the outcome of the game for a fixed number @xmath3 of cops .",
    "the guarding game is a member of a big class called pursuit - evasion games , see , e.g. , alspach  @xcite or bonato and nowakowski  @xcite for introduction and survey .",
    "pursuit - evasion games is a family of problems in which one group attempts to track down members of another group in some environment .",
    "probably the best known variant of these games is called the cops - and - robber game . in this game",
    "a graph @xmath10 is given , together with the number @xmath3 of cops and one robber .",
    "the cops are placed at the vertices in the first turn , then the robber is placed in the second turn . in alternating turns , the cops may move to a neighbouring vertex , and the robber may move to a neighbouring vertex .",
    "the question is whether the cops have a strategy to capture the robber , which means at some point enter a vertex with the robber .",
    "the cops - and - robber game was first defined for one cop by winkler and nowakowski  @xcite and by quilliot  @xcite .",
    "aigner and fromme  @xcite initiated the study of the problem with several cops .",
    "the minimum number of cops required to capture the robber in a given graph is called the cop number of the graph .",
    "the guarding game is thus a natural variant of the cops - and - robber game .",
    "the complexity of the decision problem related to the cops - and - robber game was studied by goldstein and reingold  @xcite .",
    "they have shown that if the number of cops is not fixed and if either the graph is directed or initial positions are given , then the problem is -complete .",
    "also , recently mamino  @xcite has shown that the cops - and - robber decision problem without any further restriction is -hard . very recently , kinnersley  @xcite published a proof that the computational complexity of cops - and - robber decision problem without further restrictions is -complete .",
    "unfortunately , the previous papers @xcite use a misleading notion , using  instead of .",
    "another interesting variant is the `` fast robber '' game , which is studied in fomin et al .  @xcite . in this version",
    ", the robber may move @xmath11-times faster than the cops .",
    "the authors prove that the problem of computing the minimum number of cops such that the fast cops - and - robber game is cop - win , is -complete and the parameterised version ( where the parameter is the number of cops ) is -complete . see the annotated bibliography  @xcite for reference on further topics .    a different well - studied problem , the _ eternal domination _ problem ( also known as _ eternal security _ ) is strongly related to the guarding game .",
    "the objective in the eternal domination , introduced by burger et al .",
    "@xcite , is to place the minimum number of guards on the vertices of a graph @xmath10 such that the guards can protect the vertices of @xmath10 from an infinite sequence of attacks . in response to an attack of an unguarded vertex @xmath12 ,",
    "at least one guard must move to @xmath12 and the other guards can either stay put , or move to adjacent vertices . the minimum number of guards needed to protect the vertices of @xmath10 is denoted by @xmath13 .",
    "the eternal domination problem is in fact a special case of the guarding game .",
    "this can be seen as follows .",
    "let @xmath10 be a graph on @xmath14 vertices and we construct a graph @xmath15 from @xmath10 by adding a clique @xmath16 on @xmath14 vertices and connecting the clique and @xmath10 by @xmath14 edges which form a perfect matching .",
    "the cop - region is @xmath17 and the robber - region is @xmath18 .",
    "now @xmath10 has an eternal dominating set of size @xmath19 if and only if @xmath19 cops can guard @xmath17 .",
    "several variants of the eternal domination are studied and various results are known .",
    "for example in @xcite , the variant when only one guard may move in a turn is studied , and it is shown that all graphs not having @xmath20 as a minor satisfy @xmath21 where @xmath22 denotes the clique covering number of @xmath10 and @xmath23 denotes the minimum number of guards needed to protect @xmath10 when only one guard may move in a turn ( so called _ eternal @xmath24-security _ ) .",
    "also , for the eternal 1-security , @xmath25 holds for every graph @xmath10 where @xmath26 is the independence number , and if @xmath27 then @xmath28 @xcite .",
    "klostermeyer and macgillivray  @xcite proved that @xmath29 .",
    "in @xcite it is shown that there are graphs @xmath10 for which @xmath30 . in @xcite",
    "the following conjecture is posed : if @xmath31 for a graph @xmath10 , then the @xmath26 is equal to the chromatic number of the complement of the graph .",
    "this conjecture was proved in @xcite for graphs with @xmath27 .",
    "various complexity - related question were also studied .",
    "for example , in @xcite it is shown that the decision problem of the eternal 1-security is -@xmath32-hard ( in fact , there is a completeness proof in @xcite but later an error in the proof was found ) .",
    "further graph - theory and algorithmic issues are discussed in @xcite : for the eternal 1-security , the relationship between the number of guards and the independence and clique covering numbers of the graph is studied , results concerning which triples of these parameters can be attained by some graph are given , and the exact value of the number of guards for graphs in certain classes is determined . for the eternal domination , a linear algorithm to determine the minimum number of guards necessary to defend a tree",
    "is given in @xcite .",
    "in our paper we focus on the complexity issues of the following decision problem : given the guarding game @xmath33 , who has the winning strategy ?",
    "let us define the computational problem precisely . in measuring the computational complexity ,",
    "our model is the deterministic one - tape turing machine .    the _ guarding decision problem _ ( ) is , given a guarding game @xmath34 where @xmath35 is a directed graph , to decide whether it is a cop - win game or a robber - win game .",
    "more precisely , we specify a ( binary ) encoding of the graph @xmath35 , subset @xmath8 and starting positions ; the language  then consists of all words that encode a configuration winning for the robber - player .",
    "we may also define the _ guarding problem _",
    ", which is , given a directed or undirected graph @xmath10 and a cop - region @xmath36 , to compute the minimum number @xmath3 such that the @xmath0 is a cop - win .",
    "it is easy to see , that the guarding problem can be in polynomial time reduced to  by trying all possible values of @xmath3 .",
    "was introduced and studied by fomin et al .",
    "the computational complexity of  depends heavily on the chosen restrictions on the graph @xmath10 .",
    "in particular , in  @xcite the authors show that if robber s region is only a path , then the problem can be solved in polynomial time , and when robber moves in a tree ( or even in a star ) , then the problem is -complete . furthermore",
    ", if robber is moving in a directed acyclic graph , the problem becomes -complete .",
    "later fomin , golovach and lokshtanov  @xcite studied the _ reverse guarding game _ with the same rules as in the guarding game , except that the cop - player plays first .",
    "they proved in @xcite that the related decision problem is -hard on undirected graphs .",
    "nagamochi @xcite has also shown that that the problem is -complete even if @xmath7 induces a 3-star and that the problem is polynomially solvable if @xmath7 induces a cycle . also , thirumala reddy , sai krishna and pandu rangan proved @xcite that if the robber - region is an arbitrary undirected graph , then the decision problem is -hard .",
    "fomin et al .",
    "@xcite asked the following question .",
    "[ q : fomin ] is  -complete ?",
    "let us consider the class @xmath37 of languages recognisable by a deterministic turing machine in time @xmath38 , where @xmath14 is the input size . in pursuit of question",
    "[ q : fomin ] we prove the following result .",
    "[ t : main ]  is -complete under log - space reductions . furthermore , @xmath39 via length order @xmath40 .",
    "we defer the precise technical definitions of log - space reductions and length order to the end of section  [ s : mainproof ] .",
    "note that the log - space reduction via certain length order is a more subtle definition of reduction than the general log - space reduction .",
    "the motivation is as follows .",
    "the reduction @xmath41 via length order @xmath42 means that given some instance @xmath43 , we obtain an instance @xmath44 equivalent to @xmath45 , which size has increased to @xmath46 ( where @xmath47 is measured in bits ) .",
    "therefore , informally , given a solver @xmath48 for @xmath49 working in time @xmath38 , this proves that the time needed to solve @xmath44 is at least @xmath50 where @xmath51 is the inverse function to @xmath52 .",
    "immediately , we get the following corollary .",
    "[ c : main ] the guarding problem is -complete under log - space reductions .    using the time - hierarchy theorem",
    ", we get the following consequence ( for the proof see section  [ s : mainproof ] ) .",
    "[ c : maintime ] there is a constant @xmath53 so that if a deterministic one - tape turing machine decides  within time @xmath54 , then @xmath55 for infinitely many  @xmath14 .",
    "let us explain here the relevance of theorem  [ t : main ] to question  [ q : fomin ] .",
    "very little is known about how the class  is related to .",
    "it is only known @xcite that @xmath56 .",
    "the following corollary shows that positive answer to question  [ q : fomin ] would give a relation between these two complexity classes .",
    "this gives unexpected and strong incentive to find positive answer to question  [ q : fomin ] .",
    "( on the other hand , to the skeptics among us , it may also indicate that negative answer is more likely . )",
    "if the answer to question  [ q : fomin ] is yes , then @xmath57 .",
    "suppose the guarding problem is -complete .",
    "let @xmath58 .",
    "then ( by theorem  [ t : main ] ) an instance of @xmath49 can be reduced by a log - space reduction to an instance of the guarding game , which we suppose to be in .",
    "consequently , @xmath59 .",
    "let us mention here , that the distance between  and  is rather small in the realm of guarding games : the game , that we will construct to show -hardness , has the property that after removing a single edge , the robber - region becomes a directed acyclic graph , and for such , the decision problem is in  by a result of fomin et al .",
    "@xcite .    in a sense",
    ", we show analogous result for the guarding game as goldstein and reingold  @xcite have shown for the original cops - and - robber game .",
    "in order to prove -completeness of , we first note that the problem is in .",
    "we define the _ guarding game with prescribed starting positions _",
    "@xmath60 , where @xmath61 is the initial placement of cops and @xmath62 is the initial placement robber , and we consider the guarding game @xmath0 after the two initial turns where the cops were placed as described by @xmath48 and robber was placed to @xmath63 . the _ guarding decision problem with prescribed starting positions _ ( ) is , given a guarding game with prescribed starting positions @xmath64 where @xmath35 is a directed graph , to decide whether it is a cop - win game or a robber - win game .",
    "[ l : etime ] the guarding decision problem is in .",
    "we need to show that there is an algorithm deciding the outcome of a given guarding game @xmath33 in @xmath38 time , where @xmath14 is the size of the input  @xmath65 in some encoding .",
    "let us first consider the normal ( i.e. , not reverse ) version of the problem .",
    "consider the directed graph @xmath15 of all configurations of the game  @xmath65 where edges mark the legal moves of @xmath65 .",
    "we use the standard backwards - labelling algorithm : first we label all final states of the game , then all states that can be finished by a single move , etc . in this way we can decide the outcome of every configuration in time polynomial in the size of the graph @xmath15 .",
    "it remains to show that the size of @xmath15 is @xmath38 .",
    "as mentioned in the introduction , the simplest upper bound on @xmath66 is @xmath67 , which is unfortunately super - exponential in @xmath14 if @xmath3 is close to @xmath14 . to find a better upper bound , we use the fact that the cops are mutually indistinguishable",
    ". there are at most @xmath68 positions of robber .",
    "counting the number of all positions of the cops is the classical problem of putting @xmath3 indistinguishable balls into @xmath69 bins .",
    "then , taking into account also whose turn it is and the number of vertices @xmath70 , we get that @xmath66 is bounded by @xmath71 thus the total size of @xmath15 is @xmath38 as well .",
    "the proof for the reverse version of the game is analogous .",
    "let us first study the problem after the second move , where both players have already placed their pawns .",
    "we reduce  from the following formula - satisfying game which was described by stockmeyer and chandra  @xcite ( game @xmath72 in section  3 of @xcite ) .    a position in the formula - satisfying game configuration",
    "is a @xmath73-tuple @xmath74 where @xmath75 , @xmath76 and @xmath77 are formulas in 12-dnf both defined on set of variables @xmath78 , where @xmath79 and @xmath80 are disjoint and @xmath81 is the current @xmath82-assignment .",
    "the symbol @xmath83 serves only to differentiate the positions where the first or the second player is to move .",
    "( ii ) moves by changing the values assigned to at most one variable in @xmath80 ( @xmath79 ) ; either player may pass since changing no variable amounts to a `` pass '' .",
    "( ii ) wins if the formula @xmath76 ( @xmath77 ) is true after some move of player i ( ii ) .",
    "more precisely , player i can move from @xmath84 to @xmath85 in one move if and only if @xmath86 differs from @xmath81 in the assignment given to at most one variable in @xmath80 and @xmath77 is false under the assignment @xmath81 ; the moves of player ii are defined symmetrically .",
    "let  denote the language of all binary encodings of formula - satisfying game configurations which are winning for player i.    note , that if the game continues infinitely , then the starting position is not in , as player  i did not win .",
    "we may as well consider the game won by player  ii , which is consistent with the rules of the cop - game .    the following result is known .",
    "[ t : stocha ]  is an -complete language under log - space reduction .",
    "moreover , @xmath87 via length order @xmath88 .",
    "let us first informally sketch the reduction from @xmath89 to @xmath65 , i.e. , simulating @xmath89 by an equivalent guarding game @xmath65 .",
    "the setting of variables is represented by positions of certain cops so that only one of these cops may move at a time ( otherwise the cop - player loses the game ) , we call this device a variable cell .",
    "the variables in  @xmath79 are under the control of the cop - player .",
    "the variables in  @xmath80 are under the control of the robber - player ( even though they are also represented by cops ) .    in the following text",
    ", we construct a lot of gadgets .",
    "first , we precisely define them and then we informally describe how particular gadgets work , together with prerequisites needed for the gadget to work properly , and with the desired outcome of each gadget . then we describe in detail the whole construction and how all gadgets are connected together . finally , we precisely prove that the gadgets ( and the whole game ) behave as we described earlier .",
    "when describing the features of various gadgets , we will often use the term _ binding scenario_. by binding scenario of a certain gadget ( or even the whole game )",
    "we mean a flow of the game that both players must follow : if a player deviates from it , he will lose the game . the graph will be constructed in such a way , that if the players follow the binding scenario , they will simulate the formula game @xmath89 .",
    "let us define the binding scenario more precisely .",
    "let @xmath60 be an instance of the guarding game with prescribed positions .",
    "let @xmath90 be a nonempty sequence such that @xmath91 is a valid move of robber and @xmath92 is a valid move of cops for every @xmath93 .",
    "we call such @xmath94 a _ move sequence_. a set @xmath89 of move sequences is called a _ scenario_. we say that players _ follow the scenario @xmath89 _ if they make a move sequence @xmath95 .",
    "we say that the player @xmath96 _ deviates from the scenario @xmath89 _ if @xmath96 makes a move not permitted by @xmath89 , but until his move the players did follow  @xmath89 .",
    "we call a scenario @xmath89 a _ binding scenario _ when @xmath89 satisfies the following condition : if the cop - player deviates from @xmath89 , he will lose in at most ten turns .",
    "if the robber - player deviates from @xmath89 , he ends in a losing state of the game .",
    "when describing a particular gadget , we also describe its scenario and prerequisites which must be satisfied in order for the gadget to work properly .",
    "later , after we complete the whole construction , we prove that the presented scenarios are in fact binding , if the prerequisites are satisfied .",
    "there are four cyclically repeating phases of the game , determined by the current position of robber .",
    "the binding scenario is as follows : robber cyclically goes through the following phases marked by four special vertices and in different phases he can enter certain gadgets .",
    "( robber is allowed to pass . however , as we will show , it is never to his advantage . )    1 .",
    "`` robber move '' ( @xmath97 ) : in this step robber can enter a _ robber switch _",
    "gadget , allowing him to change setting of at most one variable in @xmath80 .",
    "the values of formula variables are represented by positions of special cops in gadgets called variable cells .",
    "`` robber test '' ( @xmath98 ) : in this step robber may pass through the _ robber gate _ into the protected region @xmath8 , provided that the formula @xmath76 is satisfied under the current setting of variables .",
    "`` cop move '' ( @xmath99 ) : in this step the cop player can change one variable in @xmath79 .",
    "this is realized by a gadget called _",
    "cop switch_. at the end of this phase robber ` waits ' on vertex @xmath100 for the cop to finish setting the variable .",
    "`` cop test '' ( @xmath101 ) : in this step , if the formula @xmath77 is satisfied under the current setting of variables , the cops are able to block the entrance to the protected region forever ( by temporarily leaving the _ cop gate _",
    "gadget unguarded and sending a cop to block the entrance to @xmath8 that is provided by the robber gate gadgets ) .    to begin with the construction ,",
    "we start with the basic five vertices organised to a directed cycle @xmath102 , we call it the _ basic cycle_.      to maintain the current setting of a variable @xmath103 , we use the variable cell gadget , there will be a separate variable cell for every variable .    for a variable @xmath104",
    "we introduce a _ variable cell _ @xmath105 , which is a directed cycle @xmath106 ( see fig .  [",
    "f : varcell ] ) .",
    "the informal description of the function of @xmath105 is as follows .",
    "there is one cop ( _ variable cop _ ) located in every @xmath105 and the position of the cop on vertices @xmath107 , @xmath108 represents the boolean values true and false , respectively .",
    "the prescribed starting position of the variable cop is @xmath107 if @xmath109 is true , and @xmath108 otherwise .",
    "all the vertices of @xmath105 belong to @xmath8 .      to make the variable cops truly represent the boolean values and allow only the changes of these values that follow the rules of the formula game , we introduce two gadgets that will be used repeatedly .",
    "we say that we _",
    "block _ a set @xmath110 by a vertex @xmath111 , when we add to our graph the _ blocker _ gadget @xmath112 .",
    "the blocker @xmath112 consists of a directed path @xmath113 together with edges @xmath114 for @xmath115 .",
    "the vertex @xmath116 is in @xmath7 , while @xmath117 is in @xmath8 .",
    "we will call @xmath117 the _ entry vertex _ of the blocker .",
    "see fig .",
    "[ f : blocking ] for illustration .",
    "suppose we blocked @xmath48 by @xmath111 and the only edges coming to @xmath117 start in  @xmath48 .",
    "if robber is at @xmath111 , then we must have at least one cop in the set @xmath48 or on @xmath117 .",
    "we prove the properties of the blocker in lemma  [ l : blocking ] .    a way to prevent cops from moving",
    "arbitrarily is called _ forcing _ and we will now describe it .",
    "consider @xmath118 ( we will apply this for @xmath48 consisting of all the `` normal '' positions of robber ) and @xmath119 .",
    "we say that we _",
    "force @xmath4 by @xmath48 _",
    ", when we add the gadget @xmath120 in fig",
    ".  [ f : forcing ] : it consists of a vertex @xmath121 , together with edges from each vertex in @xmath48 to it .",
    "further , for any @xmath122 we add a directed path @xmath123 .",
    "all of the new vertices @xmath121 and @xmath124 are added to the robber - region @xmath7 .",
    "we describe here shortly the desired behaviour .",
    "we say a vertex @xmath125 is _ guarded _ if there is a cop that can reach @xmath111 in at most two moves .",
    "the forcing gadget ensures that before each robber s move , every vertex of  @xmath4 is guarded .",
    "later , we will apply the gadget @xmath120 for @xmath126 and @xmath127 ( and for one more similar pair ) .",
    "the desired outcome is that the variable cop is forced to stay on @xmath107 or @xmath108 , unless another cop helps to guard these two vertices .",
    "( we could ensure the same behaviour using blocker gadgets , but it would lead to a larger graph  one with quadratically many edges  thus we would obtain weaker result for the running time of algorithms that solve . )    the properties of forcing are precisely described and proved in lemma  [ l : forcing ] .      for every clause @xmath128 of @xmath76",
    ", we construct robber gate gadget @xmath129 .",
    "the goal of this gadget is that it allows robber to enter @xmath8 if and only if @xmath128 is satisfied by the current setting of variables .",
    "consider a clause @xmath130 where each @xmath131 is a literal .",
    "the robber gate @xmath129 is the blocker @xmath132 with @xmath133    for easier notation , we shall use shorter notation @xmath134 and @xmath135 . see fig .",
    "[ f : robgate ] for illustration .",
    "the vertices @xmath136 and @xmath98 belong to @xmath7 , @xmath137 belongs to @xmath8 .    robber stands on @xmath98 and there is exactly one cop in each @xmath105 , @xmath138 , standing either on @xmath107 or @xmath108 .",
    "no other cop can access @xmath137 in one move .",
    "it is the robber s turn .",
    "robber can reach @xmath137 ( thus winning the game ) if and only if @xmath128 is satisfied under the current setting of variables ( given by the positions of cops on variable cells ) _ and _ the cop - player did not win before .",
    "otherwise , robber moves to @xmath99 .",
    "we remark that if cop - player has won before ( by satisfying his formulas in the formula - game  this corresponds to moving one of his pawns to vertex @xmath139 described in the next section ) then there will be a cop that can reach every @xmath137 in a single move .",
    "this renders the robber gate unfunctional .",
    "the properties of the robber gate are proved in lemma  [ l : robbergate ] .      for every clause @xmath140 of @xmath77",
    ", we will use the _ cop gate _",
    "gadget @xmath141 ( see fig .  [",
    "f : copgate ] ) .",
    "if ( and only if ) @xmath140 is satisfied , @xmath141 allows cops to win the game . according to the rules , the game will still continue infinitely long , but robber will never be able to enter @xmath8 .",
    "this is achieved by placing a cop to a vertex , from which he controls all vertices @xmath137 in the robber gates .",
    "the cop gate @xmath141 contains a directed cycle @xmath142 .",
    "further , @xmath141 contains edges @xmath143 for every clause  @xmath128 of the robber s formula  @xmath76 .",
    "( these edges are common for all clauses  @xmath140 . )",
    "note , that the vertex @xmath139 does not have the subscript  @xmath140  this vertex is shared among all clauses  @xmath140 .",
    "the reason for this is to keep the size of the constructed graph  @xmath35 small enough .",
    "let @xmath144 where each @xmath131 is a literal .",
    "we add 12 blockers to our gadget , one for every literal : + if @xmath145 then we add the blocker @xmath146 to @xmath141 .",
    "+ if @xmath147 then we add the blocker @xmath148 instead .",
    "the directed 4-cycle belongs to @xmath8 , the blocker is as described above .",
    "there is one cop at the vertex @xmath149 ( we call him arnold ) and there is exactly one cop in each @xmath105 , @xmath150 , standing on either @xmath107 or @xmath108 .",
    "robber is at the vertex @xmath101 and no other cop can access @xmath141 in less than three moves .",
    "it is the cop s turn .",
    "arnold is able to move to @xmath139 ( and therefore block all the entrances @xmath137 forever ) without permitting robber to enter @xmath8 if and only if @xmath140 is satisfied under the current setting of variables ( given by the position of cops in the variable cells ) .",
    "note that while arnold will never move voluntarily back from  @xmath139 to @xmath149 , robber may force him using the forcing gadget that we will add in section  [ s : bigpicture ] in step  [ item : force ] of the construction .",
    "therefore , the vertex @xmath151 is needed .",
    "the properties of the cop gate are proved in lemma  [ l : copgate ] .      when changing variables of @xmath152 , we have to make sure that at most one variable is changed at a time .",
    "we already prevented all variable cops from moving at all by means of forcing , see section  [ s : forceblock ] and lemma  [ l : forcing ] .",
    "next we describe a gadget that allows one of them to move : the gadget commander ( see fig .  [",
    "f : commander ] ) .",
    "it consists of vertices @xmath153 . for each @xmath154",
    "there is directed 2-cycle @xmath155 and directed paths @xmath156 and @xmath157 .",
    "all of the vertices belong to @xmath8 .",
    "there is one cop , commander , whose prescribed starting position is the vertex @xmath158 . in section  [ s : bigpicture ]",
    "we will add some extra edges that will force commander to stay at @xmath158 most of the time .",
    "the desired function of @xmath159 is as follows : in order to move a variable cop from @xmath107 to @xmath108 or vice versa , commander moves to @xmath160 to temporarily guard vertices @xmath107 and @xmath108 .",
    "this will happen in two stages of the game : when robber sets variables , he will pick a particular @xmath161 and make commander move to  @xmath160 . when the cop - player moves , robber will only ensure that commander moves to a @xmath160 with @xmath162 .",
    "let @xmath163 .",
    "we describe a gadget that allows robber to change the value of the variable @xmath164 , i.e. , to force the variable cop in @xmath165 to move from @xmath166 to @xmath167 or vice versa .",
    "the switch of robber s variable @xmath164 ( @xmath168 ) consists of a directed path @xmath169 , edges @xmath170 , @xmath171 , @xmath172 , @xmath173 and a blocker @xmath174 ( see fig .  [",
    "f : switch ] ) .",
    "the new vertices @xmath175 belong to @xmath7 , the blocker is described earlier .",
    "robber is at @xmath97 , the cop in @xmath165 is either on @xmath166 or @xmath167 , commander is at @xmath158 and no other cop can access any vertex of @xmath165 .",
    "it is the robber s turn .    by entering the vertex @xmath175 robber forces commander to move to @xmath176 , and the variable cop to enter @xmath177 or @xmath178 .",
    "robber then enters the vertex @xmath98 , the variable cop finishes his move to @xmath166 ( or @xmath167 ) and at the same time commander returns to @xmath158 . if robber decides not to change any variable , he may go directly to @xmath98 ; in such case the cops do not move in their next turn .",
    "the properties of the robber switch are proved in lemma  [ l : robs ] .",
    "the @xmath179 gadget consists of a blocker @xmath180 .",
    "robber is on @xmath99 , all variable cops are at @xmath107 or @xmath108 and commander at @xmath158 .",
    "it is the cop s turn .",
    "the cop - player decides which variable @xmath162 to change .",
    "the commander moves to @xmath160 , and the variable cop in @xmath105 moves to @xmath181 or @xmath182 .",
    "next , robber moves to @xmath100 .",
    "commander moves back to @xmath158 and the cop in @xmath105 finishes his move to @xmath108 or @xmath107 . finally , robber moves to @xmath101",
    "alternatively , if the cop - player does not want to change any variable , all variable - cops stay put , and just commander moves to some @xmath160 and back to @xmath158 .      let us consider an instance of the formula game @xmath74 .",
    "we now proceed by putting all gadgets together in order to construct the instance @xmath183 of .",
    "when different gadgets contain a vertex with the same name , this means that this vertex is shared by these gadgets ( this happens often for vertices @xmath97 , @xmath98 , @xmath99 , @xmath101 , @xmath158 , @xmath139 but also for others ) . to make the construction clearer , we define the following sets : @xmath184    the order of construction steps is as follows",
    ".    1 .   [ item : basiccycle ] construct the basic cycle .",
    "[ item : varcell ] for every variable @xmath104 construct the variable cell gadget @xmath105 .",
    "[ item : robbergate ] for every clause @xmath128 of @xmath76 construct the robber gate gadget @xmath129 .",
    "[ item : copgate ] for every clause @xmath140 of @xmath77 construct the cop gate gadget @xmath141 . 5 .",
    "[ item : commander ] construct the commander gadget @xmath159 .",
    "[ item : robs ] for every variable @xmath163 construct the robber switch @xmath168 . 7 .   [ item : cops ] construct the cop switch @xmath179 .",
    "[ item : force ] let @xmath185 and @xmath186 .",
    "add to the graph gadgets @xmath187 , @xmath188 , @xmath189 , and @xmath190 .",
    "we call the vertices @xmath191 , @xmath192 , @xmath193 , and @xmath194 of these gadgets the _ forcing vertices_. 9 .",
    "[ item : edges ] add directed edges to @xmath158 from @xmath97 , @xmath98 , @xmath100 , @xmath101 .",
    "the prescribed starting position @xmath63 of robber is the vertex @xmath97 .",
    "we define the starting positions @xmath48 of the cops as follows :    * for each variable @xmath104 , the corresponding variable cop starts at the vertex @xmath107 if @xmath109 is true and at the vertex @xmath108 if @xmath109 is false . *",
    "each @xmath140-arnold starts at the corresponding vertex @xmath149 . *",
    "the cop commander starts at the vertex @xmath158 .",
    "the number @xmath3 of cops is thus set as @xmath195 , where @xmath196 denotes the number of clauses in  @xmath77 .",
    "we also briefly show that the construction of @xmath65 based on @xmath89 can be done in log - space .",
    "a log - space reduction is a reduction computable by a deterministic turing machine ( with read - only input tape , a working tape , and output tape ) using logarithmic space .",
    "conceptually , this means that while producing encoding of the instance @xmath65 to the output tape the reducing turing machine can keep ( stored on the work tape ) a constant number of pointers into the input tape along with a constant number of integers holding at most polynomially large values , and a logarithmic number of fixed size integers .",
    "[ l : logspace ] let @xmath89 be an instance of the formula game and let @xmath65 be an instance of  constructed via the above construction from @xmath89 . then the reducing turing machine is log - space bounded and @xmath197 where the instance sizes are measured in bits .    in order to show the log - space reducibility of our construction of @xmath65 , we need to observe that the whole construction can be performed by an algorithm reading the encoding of the formula game @xmath89 and using only constant number of work variables holding polynomially large values .",
    "we go through the construction and briefly discuss the space needed for construction .",
    "* step [ item : basiccycle ] of the construction produces a fixed - size gadget . * steps [ item : varcell ] , [ item : commander ] , and [ item : robs ] can be realised by an iteration over the set of variables , each iteration producing a fixed - size gadget",
    ". clearly , a constant number of log - space integers suffices .",
    "* steps [ item : robbergate ] and [ item : copgate ] can be realised by two nested iterations over the set of clauses and the set of variables . again",
    ", a constant number of log - space integers suffices .",
    "* step [ item : force ] can be done by several iterations ( over the set of variables and over the set of clauses ) .",
    "important thing to note is that the gadget @xmath120 has size ( the number of vertices and edges ) @xmath198 .",
    "the output of the cops and robber starting positions can be done by an iteration over the set of clauses and variables .",
    "therefore , only a constant number of log - space integers is needed during the reduction .",
    "let @xmath199 be the number of clauses of @xmath89 and let @xmath200 be the number of variables of  @xmath89 .",
    "then the number of bits of @xmath89 is @xmath201 as we need @xmath202 bits to encode the variable identifiers , each clause contains at most 12 literals and the initial assignment of variables takes @xmath200 bits .",
    "next , we estimate the size of the instance @xmath203 , based on our construction , starting with the number of vertices and edges of @xmath35 .",
    "each @xmath165 has a constant size , all variable cells thus have total size @xmath204 .",
    "each @xmath129 has a constant size , all robber gates thus have total size @xmath205 .",
    "the cop gate gadgets contain a shared part of size @xmath206 and the non - shared part of each @xmath141 has a constant size .",
    "therefore , all cop gate gadgets have total size @xmath206 .",
    "the size of the commander gadget is clearly @xmath204 .",
    "each @xmath168 has a constant size , so the total size of all robber switches is @xmath204 .",
    "the size of @xmath179 is clearly @xmath204 . in the last nontrivial step ,",
    "step  [ item : force ] , @xmath207 vertices and edges are added to @xmath35 .    as @xmath208 , we need @xmath209 bits to encode @xmath35 .",
    "note that we may get a linear bound on the size of @xmath65 , if we assume fairly reasonable condition on the formula game : all variables are used and no clause repeats within a formula .",
    "let us start by a simple observation . while the rules allow robber to pass (",
    "skip a move ) , we may assume that he never uses it .",
    "for if robber does not move , the cops may do the same and repeating this indefinitely means a win for cops . from now on",
    ", we shall assume robber never passes .",
    "another assumption , that will be somewhat harder to prove :    1cm1 cm assumption a : the cop - player restricts to strategy where either every @xmath140-arnold is at his starting vertex  @xmath149 , or exactly one of them moves to  @xmath210 ,  @xmath139 ( when robber entered vertex  @xmath101 ) , and possibly back to @xmath151 and @xmath149 .    in theorem  [ t : prescribedgame ]",
    "we will show that this restriction does not change the outcome of the game , it will make it easier to analyze , though .    before getting to the individual lemmas",
    ", we describe the main idea : if the robber - player succeeds in satisfying formula  @xmath76 , robber will be able to enter the cop - region by means of robber gate .",
    "if the cop - player will be faster with satisfying his formula  @xmath77 , he will be able to send one arnold to  @xmath139 .",
    "the resulting state of game will be cop - win  there is an easy strategy ( described in lemma  [ l : arnoldwin ] ) that will make sure robber will never enter the cop - region .",
    "recall that we call a vertex @xmath211 _ guarded _ if there is a cop that can reach @xmath12 in at most two moves .",
    "further , a _ set _",
    "@xmath212 is _ guarded _ if every vertex of  @xmath4 is guarded and each one is guarded by a different cop .",
    "formally , we require that there is a set @xmath213 , @xmath214 , of cops and a 1 - 1 mapping @xmath215 between @xmath213 and @xmath4 such that for each @xmath216 the vertex @xmath217 is guarded by the cop  @xmath3    [ l : forcing ] let @xmath48 , @xmath4 be sets such that the gadget @xmath120 is part of @xmath35 .",
    "let us consider the game state where robber is in @xmath48 and it is robber s turn .    1 .",
    "let there be an unguarded vertex of  @xmath4 .",
    "then this is a robber - win state .",
    "2 .   if the set @xmath4 is guarded and robber enters the vertex @xmath121 , the game state will be a cop - win .",
    "if the set  @xmath4 is not guarded and there is no vertex @xmath218 that has more than one outneighbor in  @xmath4 then this is a robber - win state .",
    "suppose @xmath12 is unguarded .",
    "then robber moves along the path @xmath123 and no cop can stop him .    on the other hand , suppose the set  @xmath4 is guarded and mapping  @xmath215 is defined as above .",
    "if robber decides to move to @xmath121 , than each cop  @xmath3 guarding vertex @xmath219 moves towards it ( or stays in place , if they already are at it ) .",
    "thus , the cops can reach all vertices of  @xmath4 before robber , and robber is stuck in  @xmath121 or some @xmath124 for the rest of the game .",
    "for the third part , suppose that robber moves to @xmath121 and the cops can somehow prevent him from winning .",
    "then for every @xmath122 the cops have a response to robber s move to @xmath124 , namely , there is a cop that can move to  @xmath12 in one step , denote him by @xmath220 . due to the extra condition in the third part , mapping @xmath221 is injective , its inverse is the required mapping  @xmath215 .    we now define the notion of _ normal positions _ of certain pawns .",
    "[ def : normal ] we say that    * robber is in normal position if he is on @xmath222 ( which was previously defined as @xmath223 ) , * commander is in normal position if he is on @xmath158 or on some @xmath160 , * variable cops are in normal position if they are in some @xmath105 , * @xmath140-arnold is in normal position if he is at @xmath149 or @xmath139 .",
    "if one of the players leaves these positions , the game will be decided quickly .",
    "this is obvious for robber , for if he is not in the normal position , he is no longer in the strongly connected part of the graph .",
    "so , he either reaches @xmath8 within two moves , or he will be unable to move for the rest of the game . in the following lemmas we deal with the rest of the pawns .",
    "[ l : hq ] consider a game state where robber is in @xmath222 ( see definition  [ def : normal ] ) and it is the robber s turn . if commander is not on @xmath158 or on some  @xmath160 , then this is a robber - win state .",
    "if commander is elsewhere , he will not be able to reach @xmath158 again ( by the construction ) .",
    "if robber is in  @xmath222 , he will be able to get to @xmath97 and from there to enter @xmath158 .",
    "[ l : normalposvarcops ] consider a game state where robber is in @xmath222 ( see definition  [ def : normal ] ) and it is the robber s turn .",
    "if there is an @xmath154 so that there is no cop on @xmath108 , @xmath107 , or @xmath160 , then this is a robber - win state .",
    "otherwise , if robber enters vertex @xmath224 or @xmath225 , he loses .    by lemma  [ l : hq ]",
    ", commander must stay on  @xmath158 or some  @xmath160 .",
    "consequently , there is at most one cop in each @xmath105 and no cop is at vertices @xmath226 , @xmath227 .",
    "thus , to guard both @xmath107 and @xmath108 , we need a cop at either @xmath160 , @xmath107 , or @xmath108 ( lemma  [ l : forcing ] ) .",
    "the second statement follows again from lemma  [ l : forcing ] , as no cop will be guarding two of the vertices @xmath107 , neither two of the vertices @xmath108 .",
    "[ l : normalposarnolds ]    1 .",
    "consider a game state where robber is in  @xmath222 ( see definition  [ def : normal ] ) and it is the robber s turn",
    ". then all arnolds are in @xmath228 , or it is a robber - win state .",
    "2 .   if every @xmath140-arnold is on @xmath149 , with possible exception of one , who is at @xmath139 , then robber may not enter vertices @xmath229 , @xmath230 .",
    "3 .   if robber is in  @xmath231 , some arnold in  @xmath210 and it is the robber s turn , then it is a robber - win state .",
    "again , a simple consequence of lemma  [ l : forcing ] : there is no edge leading towards  @xmath232 , thus if some arnold leaves  @xmath232 , there will be always less than  @xmath233 cops in  @xmath232 . when ( now or in the next move ) robber is in  @xmath231 , he can use the gadget @xmath189 according to the third part of lemma  [ l : forcing ] .",
    "this proves the first part and the third part . by the second part of lemma  [ l :",
    "forcing ] follows the second part .",
    "[ l : blocking ] let a set @xmath48 be blocked by a vertex @xmath111 .",
    "( that is , the blocker gadget @xmath112 is a part of the constructed graph @xmath35 . )",
    "suppose that no other edges leading to @xmath117 are part of  @xmath35 .",
    "suppose robber is on @xmath234 and it is his turn to move .",
    "then there must be at least one cop in the set @xmath48 , otherwise the cop - player loses the game . if there is at least one cop in @xmath48 , robber may not enter @xmath116 , otherwise he loses the game .    by lemma  [ l : hq ] ,",
    "[ l : normalposvarcops ] and [ l : normalposarnolds ] , there is no cop in  @xmath117  all cops must be at vertices distinct from all vertices of form  @xmath117 .",
    "this means that robber can reach this vertex in two moves , and the cops can not stop him . on the other hand ,",
    "if robber moves to @xmath116 while there is a cop on @xmath48 , then this cop moves to @xmath117 , blocking robber forever .",
    "[ l : beginning ] at the beginning of the game @xmath65 , the prerequisites of the robber switches @xmath168 , @xmath163 are satisfied .    by the construction ,",
    "robber is on  @xmath97 and the variable cops for each variable gadget @xmath105 are either on @xmath107 or @xmath108 .",
    "commander is on  @xmath158 .",
    "no other cop can ever reach @xmath105 .",
    "[ l : robs ] consider a game state satisfying the prerequisites of all robber switches @xmath168 , @xmath163 .",
    "then the scenarios of all @xmath168 , @xmath163 are binding scenarios .",
    "moreover , after execution of these binding scenarios , the prerequisites of all robber gates @xmath129 , @xmath235 are satisfied , unless there is an arnold at  @xmath139 .",
    "if robber moves to @xmath175 , commander must move to @xmath176 , or robber enters @xmath8 there .",
    "( by the construction , no other cop than commander can be at @xmath176 . )    also , by lemma  [ l : blocking ] , the variable cop in @xmath165 must move to @xmath178 or @xmath177 . by lemma  [ l :",
    "forcing ] and  [ l : blocking ] , robber may not enter the forcing vertices , and thus continues to  @xmath98 .",
    "after this , commander must move back to @xmath158 , thus the variable cop in @xmath165 to @xmath166 or @xmath167 ( lemma  [ l : normalposvarcops ] ) .",
    "if robber moves directly to  @xmath98 , no cop may move ( by lemma  [ l : forcing ] and  [ l : blocking ] ) .",
    "[ l : robbergate ] consider a game state satisfying the prerequisites of all robber gates @xmath129 , @xmath235 .",
    "then the scenarios of all robber gates @xmath129 , @xmath235 are binding scenarios . moreover , after execution of these binding scenarios , the prerequisites of the cop switch are satisfied .",
    "if no other cop may access @xmath137 , lemma  [ l : blocking ] applies : robber may enter @xmath137 if and only if there is no cop in the set  @xmath4 ( see the definition of robber gates ) . by the construction , this happens precisely if @xmath128 is satisfied by the current setting of the variables .",
    "if he may not enter @xmath137 , the only non - losing move for him is to move to @xmath99 .",
    "if the vertex @xmath139 is occupied ( the cop - player has `` won '' already ) , robber may not enter @xmath137 either and moves to @xmath99 .",
    "after the robber s move to @xmath99 , the prerequisites of the cops switch are satisfied , as the cops did not move yet .",
    "[ l : cops ] let us consider a game state satisfying the prerequisites of the cop switch .",
    "then the scenario of the cop switch is a binding scenario .",
    "moreover , after execution of it , the prerequisites of all cop gates @xmath141 , @xmath236 , are satisfied .    when robber stands on @xmath99 , commander may leave @xmath158 , as the edge @xmath237 is not part of  @xmath35 .",
    "in fact , commander has to move to a vertex @xmath160 where @xmath162 is a cop - player s variable because of the cop switch gadget . if the cop - player decided to switch @xmath103 , the variable cop in @xmath105 moves also in the first move to @xmath182 or @xmath181 .",
    "next , robber moves to @xmath100 , after which commander must return to @xmath158 and thus the cop in @xmath105 finishes his move to @xmath107 or @xmath108 ( or keeps staying in place ) . finally , robber moves to @xmath101 , which leads to a game state satisfying all prerequisites of all cop gates .",
    "[ l : arnoldwin ] consider a game state where @xmath140-arnold is on the vertex @xmath139 for some clause @xmath140 , other cops are in normal positions , and robber is in @xmath222 ( see definition  [ def : normal ] ) .",
    "then this is a cop - win state .    as long as robber is in normal position",
    ", the cop - player does not move with any of his cops until he is forced to : one arnold stays at @xmath139 , the others at their initial positions  even if another clause in @xmath77 becomes satisfied .",
    "the variable - cops and commander follow the scenarios of the cop - switch and robber - switch .",
    "robber may force the arnold at  @xmath139 to move back to his original position by using the enforcer gadget  @xmath238 ; however , he will be trapped afterwards .",
    "it is easy to check that robber may not enter the cop - region , as in binding scenarios he may do this only in some robber gate .",
    "but if he moves to some vertex @xmath136 , the arnold at @xmath139 moves to @xmath137 , thus blocking robber forever .",
    "[ l : copgate ] consider a game state satisfying the prerequisites of all cop gates @xmath141 , @xmath236 .",
    "then the scenarios of all @xmath141 , @xmath236 , are binding scenarios . moreover , after execution of these binding scenarios , the prerequisites of all robber switches @xmath168 , @xmath163 , are satisfied .",
    "if @xmath140 is satisfied by the current setting of variables in the variable cells , then we do not need the @xmath140-arnold to protect the entry vertex of any of the blockers , thus he may move to @xmath210 .",
    "if robber enters some of the blockers , then he loses by lemma  [ l : blocking ] . on the other hand ,",
    "if @xmath140 is not satisfied , and @xmath140-arnold leaves @xmath149 , then the cop - player loses : again by lemma  [ l : blocking ] .",
    "next , robber moves to @xmath97 , which forces all vertices @xmath149 , thus the @xmath140-arnold either stays at @xmath149 or , if he left it already , finishes his move to @xmath139 .",
    "therefore , the scenarios of the cop gates are binding .",
    "it is easy to see that the prerequisites of all robber switches are satisfied at the end of the binding scenario . using lemma  [ l : arnoldwin ]",
    "we justify that if some arnold moves to @xmath139 , it is a win for the cop - player .    we have described the complete reduction from the formula game @xmath89 to the guarding game @xmath65 with prescribed starting positions , and characterised the properties of various stages of @xmath65 .",
    "it remains to show that both games have the identical outcome ; we also list some properties of the constructed graph that will be useful later .",
    "[ t : prescribedgame ] for every instance of formula satisfying game @xmath239 there exists a guarding game @xmath183 , @xmath35 directed , with a prescribed starting positions such that player i wins @xmath89 if and only if the robber - player wins the game @xmath65 .",
    "moreover , the following properties are satisfied :    1 .   the size of the instance @xmath65 is @xmath240 .",
    "2 .   there is no oriented edge @xmath241 with the endpoint in @xmath63 .",
    "3 .   there is at most one cop standing at each vertex @xmath242 .",
    "4 .   consider the set @xmath243 of the `` border '' vertices .",
    "the out - degree of each @xmath244 is exactly 1 .    for every formula game @xmath89 we",
    "have described in section  [ s : bigpicture ] a construction of guarding game @xmath183 with prescribed starting positions .",
    "first , we justify assumption  a. enforcer gadget  @xmath238 does not allow any arnold to move from his starting position unless robber is on  @xmath101 .",
    "when robber is on  @xmath101 , lemma  [ l : copgate ] describes the condition under which @xmath140-arnold may move from  @xmath149 to  @xmath210 and further to  @xmath139 : it is precisely when clause  @xmath140 is satisfied .",
    "the cop - player may refrain from moving more then one arnold to  @xmath139 even if more then one clause in  @xmath77 is satisfied , and he may also avoid moving another arnold to  @xmath139 , if one is already there . this will not change the outcome of the game as ( because of lemma  [",
    "l : arnoldwin ] ) , one arnold on  @xmath139 already means the game is won by the cop - player .",
    "the above proves that using assumption  a does not change the outcome of the game .",
    "if there is an arnold at  @xmath139 , the cop - player has won .",
    "otherwise , all arnolds are at their starting positions ; this will be important in lemma  [ l : robbergate ] and  [ l : copgate ] .    by lemma  [ l : beginning ] ,",
    "the assumptions of lemma  [ l : robs ] , are satisfied at the beginning of the game . by lemma  [ l :",
    "robs ] , the assumptions of lemma  [ l : robbergate ] are satisfied when robber moves to  @xmath245 .",
    "lemma  [ l : robbergate ] in turn that ensures we can apply lemma  [ l : cops ] in the next step , and similarly we continue with lemma  [ l : copgate ] which closes the cycle by guaranteeing the assumptions of lemma  [ l : robs ] .",
    "this altogether means that @xmath65 precisely simulates the game @xmath89 : in the robber move phase ( lemma  [ l : robs ] ) @xmath65 imitates setting of the variables @xmath80 , which is due to lemma  [ l : robbergate ] followed in the robber test phase by test if the robber - player wins . by lemma  [ l : cops ] in the following cop move phase the game @xmath65 imitates setting of the variables @xmath79 , which is then due to lemma  [ l : copgate ] followed in the cop test phase by a test if the cop - player wins .",
    "the process then repeats .",
    "we have thus found the desired game @xmath65 and proved its equivalence with @xmath89 . the first property is proved in lemma  [ l : logspace ] .",
    "the second property is in fact not true , but it is very easy to modify the construction , so that it is . we create a vertex @xmath246 and connect it by an edge to all out - neighbours of  @xmath63 .",
    "we redefine the starting position of robber as  @xmath246 .",
    "it is immediate , that this modification does not change the outcome , and @xmath246 has no incoming edge .",
    "the third and the fourth items are true by the construction .",
    "next we prove that we can modify our current construction so that it fully conforms to the definition of the guarding game on a directed graph , i.e. , without prescribing the starting positions .",
    "[ l : force ] let @xmath183 be a guarding game with a prescribed starting positions , such that it satisfies the following initial conditions :    1 .",
    "there is no oriented edge @xmath241 with the endpoint in @xmath63 .",
    "2 .   there is at most one cop standing at each vertex @xmath242 .",
    "3 .   consider the set @xmath247 of the `` border '' vertices .",
    "the out - degree of each @xmath244 is exactly 1 .",
    "then there exists a guarding game @xmath248 , @xmath249 , @xmath250 such that the following holds :    1 .",
    "the robber - player wins @xmath251 if and only if the robber - player wins the game @xmath65 .",
    "2 .   if the robber - player does not place robber on @xmath63 in his first move , the cops win . 3 .   if the cop - player does not place the cops to completely cover @xmath48 in his first move , he will lose .",
    "4 .   the construction of @xmath251 can be made in log - space .",
    "@xmath252    let @xmath253 be the number of vertices from @xmath8 directly threatened ( i.e. , in distance 1 ) from robber - region .",
    "let us define the graph @xmath254 such that @xmath255 where @xmath256 is the set of new vertices and @xmath257 .",
    "consider the game @xmath248 where @xmath258 and @xmath259 .",
    "see fig .",
    "[ f : startforce ] for illustration .",
    "suppose that the robber - player places robber in the first move to some vertex @xmath260 .",
    "then there are @xmath215 vertices in @xmath8 directly threatened by edges going from @xmath7 and because we have at least @xmath215 cops available , the cops in the second move can occupy all these vertices and prevent robber from entering @xmath8 forever .",
    "so robber must start at the vertex @xmath63 .",
    "then observe , that @xmath3 cops must occupy the positions @xmath48 and @xmath215 cops must occupy the vertices @xmath261 . if any cop does not start either on @xmath261 or @xmath48 , robber wins in the next move .",
    "the cops on @xmath261 remain there harmless to the end of the game .",
    "the cops can not move until robber decides to leave the vertex @xmath63 .",
    "after that , the vertices in @xmath262 no longer affect the game , thus @xmath251 exactly imitates @xmath65 .",
    "the construction of @xmath263 from @xmath35 can be realised by an iteration over the set of vertices and edges of @xmath35 , which means that the construction can be done in log - space .",
    "it is easy to see , that the number of vertices and edges we add is linear in the number of vertices of @xmath35 , proving the last statement .",
    "here we give the precise definition of log - space reductions via length order .",
    "let @xmath264 denote the alphabet and let @xmath265 denote all nonempty and finite words over the alphabet @xmath266 .",
    "the function @xmath267 is _ logspace - computable _ if there is a deterministic turing machine with a separate two - way read - only input tape , a read / write work tape , and a one - way output tape such that , when started with any word @xmath268 on the input tape , the machine eventually halts with @xmath269 on the output tape while having visited at most @xmath270 cells on the work tape . let @xmath271 .",
    "the function @xmath199 is _ length @xmath42 bounded _ if @xmath272 for all @xmath268 .",
    "let @xmath273 . _",
    "@xmath45 transforms to @xmath44 within logspace via @xmath199 _ ( denoted by @xmath274 via @xmath199 ) if @xmath267 is logspace - computable function such that @xmath275 for all @xmath268 .",
    "let @xmath44 be a language and let @xmath276 be a class of languages .",
    "then @xmath41 if @xmath274 for all @xmath277 .",
    "furthermore , @xmath41 _ via length order @xmath42 , @xmath271 _ , provided that for each @xmath277 there is a function @xmath199 and constant @xmath278 such that @xmath274 via @xmath199 and @xmath199 is length @xmath279 bounded . the language @xmath44 is _",
    "@xmath276-complete under log - space reductions _ if both @xmath280 and @xmath41 .    by lemma  [ l : etime ] ,",
    "consider a problem @xmath282 . by theorem  [ t : stocha ] ,",
    "@xmath49 can be reduced to the formula satisfying game @xmath89 in log - space via length - order @xmath283 . by theorem  [ t : prescribedgame ]",
    "there exists an equivalent ( in the terms of the game outcome ) guarding game @xmath284 with prescribed starting positions , together with other properties as stated by theorem  [ t : prescribedgame ] . by lemma  [ l : force ] applied on the game @xmath65 there is an equivalent guarding game @xmath251 , @xmath285 , without prescribed starting positions .",
    "thus , we reduced @xmath49 to . by lemma",
    "[ l : logspace ] and lemma  [ l : force ] , the whole reduction can be done in log - space , via length order @xmath286 .",
    "therefore , theorem  [ t : main ] is proved .    by the time hierarchy theorem ,",
    "if @xmath287 , there is a problem @xmath232 in @xmath288 .",
    "thus , @xmath232 is in @xmath289 and we can use the reduction from theorem  [ t : main ] . for an instance @xmath290 of @xmath232 of size @xmath14 , we can construct in polynomial time an instance @xmath291 of  of size @xmath292 so that deciding @xmath291 solves the instance  @xmath290 . by choice of @xmath14 ,",
    "this can not be done in time @xmath293 for all @xmath14 .",
    "it remains to check that @xmath294 .",
    "as we have already mentioned , the relation of the classes  and  is unclear as we only know that @xmath295 and the current state of the art is missing some deeper understanding of the relation .",
    "therefore , the conjecture of fomin et al .",
    "whether  is -complete still remains open .",
    "however , we believe that the conjecture is not true .    for a guarding game",
    "@xmath33 , what happens if we restrict the size of strongly connected components of @xmath10 ? if the sizes are restricted by 1 , we get dag , for which the decision problem is -complete . for unrestricted sizes",
    "we have shown that @xmath65 is -complete .",
    "is there some threshold for @xmath65 to become -complete from being -complete ?",
    "this may give us some insight into the original conjecture .",
    "another interesting question is what happens if we bound the degrees of  @xmath10 by a constant .",
    "we are also working on forcing the starting position in the guarding game on undirected graphs in a way similar to theorem  [ t : main ] .",
    "we would like to thank ruda stola for drawing initial versions of some pictures and for useful discussion .",
    "we thank peter golovach for giving a nice talk about the problem , which inspired us to work on it .",
    "we would also like to thank jarik neetil for suggesting some of the previous open questions and to honza kratochvl for fruitful discussion of the paper structure .",
    "fomin , f.v . ,",
    "golovach , p.a . , kratochvl , j. : on tractability of cops and robbers game .",
    "proceedings of the 5th ifip international conference on theoretical computer science ( tcs 2008 ) , springer - verlag ifip international federation for information processing 237 , 171185 ( 2008 )"
  ],
  "abstract_text": [
    "<S> the guarding game is a game in which several cops try to guard a region in a ( directed or undirected ) graph against robber . </S>",
    "<S> robber and the cops are placed on the vertices of the graph ; they take turns in moving to adjacent vertices ( or staying ) , cops inside the guarded region , robber on the remaining vertices ( the robber - region ) . </S>",
    "<S> the goal of robber is to enter the guarded region at a vertex with no cop on it . </S>",
    "<S> the problem is to determine whether for a given graph and given number of cops the cops are able to prevent robber from entering the guarded region . </S>",
    "<S> fomin et al .  </S>",
    "<S> [ fomin , golovach , hall , mihalk , vicari , widmayer : how to guard a graph ? </S>",
    "<S> algorithmica 61(4 ) , 839856 ( 2011 ) ] proved that the problem is -complete when the robber - region is restricted to a tree . </S>",
    "<S> further they prove that is it -complete when the robber - region is restricted to a directed acyclic graph , and they ask about the problem complexity for arbitrary graphs . in this paper </S>",
    "<S> we prove that the problem is -complete for arbitrary directed graphs .    </S>",
    "<S> game , cops and robber game , graph guarding game , computational complexity , e - completeness , games on propositional formulas </S>"
  ]
}