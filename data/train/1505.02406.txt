{
  "article_text": [
    "community detection in large graphs is getting attention as an important application of social network analysis ( sna ) , the ability to detect closely knit communities opens several applications from targeting ads to recommender systems . in this work",
    "we try to derive a very simple and efficient algorithm for community detection based on a size parameter .",
    "being able to specify the minimum and maximum size of communities to detect can be a critical factor in the sna area , some networks tend to form very small and dense communities while other networks form larger groups .",
    "the first section of this report discusses some existing algorithms for community detection in social graphs , then we introduce the idea behind the entropy walker and present our algorithm .",
    "the final sections show some examples of the algorithm being used in some toy examples and analyzes the scaling of the method for large graphs .",
    "several algorithms have been developed for community detection in large graphs .",
    "clutsering methods based in k - means need to know in advance the number of communities to find in the network . in practice",
    "this is not possible as the number of communities is usually unknown and furthermore due to social interactions the number of communities in a network might change over time making it very hard to set up as a parameter .",
    "the modularity optimization algorithm [ b08 ] automatically detects the number of communities but it does nt allow for overlapping communities .",
    "this is also inpractical for social networks as most nodes will be members of several different social circles .",
    "bigclam [ lesk13 ] is a fast algorithm to detect overlaping communities , it s based in non - negative matrix factorization but it needs to know the number of communities to detect , as mentioned before this is an important limitation .",
    "[ mca13 ] presents an algorithm to find social circles in networks but is based on node parameters `` features '' , we would like to perform the extraction of communities based in network structure only .",
    "the idea of random walks being used to detect communities is also used in the mcl algorithm [ vdon99 ] however mcl ca nt control the size of the communities being detected and it needs to perform operations on the complete matrix of the graph limiting its use to small and medium sized networks .",
    "we define a `` tour '' as a random walk of length `` s '' .",
    "the basic idea of the algorithm is to perform several tours starting from random nodes and to detect communities based on the result of those tours .",
    "`` s '' should be longer than the minimum number of members that we want for a community and it serves as an upper bound for the maximum number of members in a community .",
    "it is likely for a random walker to get `` trapped '' inside nodes of a community , going back and forth between them because there are more inter - community edges than edges that will take the walker outside of the community . even if the random walker goes outside the community chances are it might come back .    the algorithm will filter the random walks that are nt likely to have found a community calculating the entropy of the tour [ sha48 ] . tours with high entropy are unlikely to contain a community because they visit mostly different nodes .",
    "they are probably paths or bridges between communities and might be of interest for some other applications .",
    "the entropy is computed using the very popular shannon formula :    @xmath0    where @xmath1 is just the probability of the node in the tour , in other words its frequency in the tour over the sum of all node frequencies .",
    "a threshold parameter establishes the maximum entropy for a tour to be accepted as a fraction of the maximum possible entropy that can be computed assuming a random walk that never visits the same node more than once .",
    "we call this parameter @xmath2 for entropy threshold .    when @xmath2 is 1 all the tours are accepted , lowering @xmath2 increases the amount of rejected tours .",
    "the graph in figure 1 shows the percentage of accepted tours for different values of @xmath2 using the food network as an example .        the @xmath2 parameter can be tuned based on two different goals .",
    "one possibility is to use it to limit the total number of tours to store in memory for very large graphs , a second use , more logical , is to set how dense a community has to be to be considered .",
    "this second use that is data dependant is probably the recommended one .",
    "this is an example of a very low entropy tour from the food network : @xmath3 $ ]    and this is an example of a high entropy tour from the same network : @xmath4 $ ]    we can see how the first tour can be converted in a community with the top ingredients being used for the same kind of dishes , the second tour has a wide array of ingredients and ca nt be considered a community .",
    "maybe a bridge between different communities . as we have mentioned extracting the high entropy tours from a network",
    "might also be an interesting application .    after accepting or rejecting a tour based on its entropy",
    "the algorithm will try to see if this tour is new or if it is similar to an already seen tour .",
    "locality sensitive hashing ( lsh ) can be used to make similar tours hash to the same bucket avoiding the need to compare new tours with the existing ones .",
    "if lsh maps the tour to a bucket where a tour is already stored then both tours are merged adding the frequencies of the nodes present in both tours .",
    "this greatly reduces the number of tours that need to be stored in memory and avoids the problem of two very similar tours being detected as different communities .    in some applications",
    "the @xmath5 most frequent nodes in a tour can be used as the key to a hash function to determine the bucket number for the node .",
    "this is a simplification of lsh using only one minhash computed from the most frequent nodes in a tour .",
    "when this is not possible or does nt work standard lsh can be used .",
    "now we describe the parameters used in the algorithm :    the algorithm uses several parameters to fine - tune its behaviour :    0.25 cm    the algorithm will perform @xmath6 random tours and check the entropy of each tour . if the tour entropy is below the @xmath2 threshold then the tour will be stored in a hash table along with a counter merging the tour with the already existing one if the bucket is not empty .",
    "it s easy to notice that this process can be parallelized and that several million tours can be performed efficiently .",
    "the memory cost to store the tours depends on the algorithm parameters .    when the @xmath2 ( entropy threshold ) parameter is low the algorithm with detect only a few very dense communities and tours with frequency 1 can be considered a community .",
    "when the @xmath2 parameter is higher the algorithm will check many tours and it might make sense to discard the tours with lower frequencies keeping the ones that have been repetedly matched .",
    "it is known that montecarlo random walks can be used to compute pagerank and/or eigenvector centrality , the procedure used to detect communities can be used to compute at the same time a centrality score for the network nodes .",
    "so the first conclusion is that node centrality can be computed at the same time as the community detection algorithm runs , just adding 1 to a counter every time a node is visited by a tour and then normalizing the cummulative score .",
    "the effect of entropy filter is show in fig2 .",
    "we can see that some nodes produce peaks for entropy thresholds below 1.00 , this means that the centrality of those nodes is higher in the entropy filtered sets compared to the plain random walks without filtering .",
    "these peaks can be detected computing the delta between the eigenvector centrality and the tour computed centrality . from these peaks",
    "we can detect nodes that are both central to the network and to the small communities where they belong , this gives an index of in - community centrality .",
    "testing the procedure on the facebook ego network the peaks matched nodes that had a high degree of connections with the members in their communities .",
    "something interesting to notice is that the algorithm can be run starting always from the same node , in the style of a personalized pagerank , when that happens we get as a result the social circles of a given user .",
    "this is in some way similar to the algorithm used by twitter to recommend users to follow[gup12 ] the difference is that instead of computing a score for each node we compute scores for each random walk ( tour ) performed by the simulation .    for example we can run the algorithm from the tomato ingredient to see what goes well with tomato :    instantaneous delicious recipes !",
    "this section presents some analysis and graphs about the behaviour of the algorithm .",
    "it is interesting to analyze the number of tours that the algorithm will keep in memory as the network grows larger for a constant fixed entropy threshold .",
    "we found that the number of tours analyzed does not grow as the size of the network and is strongly dependant on network structure .        with only a few nodes small communities",
    "are common in a graph with high clustering , as the network grows larger the number of small communities quickly goes down .",
    "this can be explained because a random walker has now more options and is less likely to get trapped inside a community .",
    "then after more nodes are added a threshold is passed and small communities emerge again .",
    "this curious behaviour in the formation of small communities as the network grows larger resulted an interesting find and can be useful to refine generic models for network growth .",
    "the emergence of small communities in large networks is strongly related to the clustering coefficient of the network . when the clustering coefficient is very los there are not enough edges to form dense communities so small communities will not form in random networks . in the same way",
    "if the clustering coefficient is too high then the random walker can visit almost any node from any node and thus will not get trapped inside a small community , the whole network is the only existing community .",
    "the following graph shows the number of tours detected for a fixed entropy threshold depending on the clustering coefficient of networks synthetically generated using the barabasi - albert model[bar99 ] .",
    "as the clustering coefficient gets larger the number of nodes in a tour has to be increased to detect communities .",
    "in our example we run the algorithm against the eastern food network composed by different ingredients using in the eastern cuisine .",
    "the idea is that the algorithm should be able to find groups of ingredients that are frequently used together .",
    "using @xmath2 at 0.75 and simulating 150.000 tours of 30 hops the algorithm processed a total of 8308 tours to find clusters with 5 to 10 nodes in less than 5 seconds and these were the top results .",
    "the number between parentheses reflects the number of times the same community was detected , so the higher the number the stronger the community .",
    "we can see that the algorithm quickly detects the ingredients for most deserts or breakfast - type preparations .",
    "in total the algorithm detected 141 overlapping communities .",
    "the following result looks like a good recipe to try :    as a point of comparision we run the modularity optimization algorithm [ blon08 ] as implemented in gephi and got the following communities :    [ lemon , egg , orange , almond , orangejuice , cream , raisin , cinnamon , honey , butter , milk , vanilla , walnut ] [ coriander , pepper , blackpepper , chicken , thyme , cayenne , cilantro , dill , cumin , bellpepper , chickenbroth , ginger , turmeric , carrot ] [ garlic , parsley , onion , lemonjuice , beef , lamb , tomato , cucumber , bread , oliveoil , mint , vinegar , yogurt , potato ]    as we can see the modularity algorithm does a very good job but it lists all the ingredients that are similar together and is not very helpful to detect smaller groups that go very well together , for example communities of 3 or 4 ingredients . the algorithm presented here would create the following top 10 communities of 3 ingredients :    the graph of the communities found by gephi looks like this [ figure2 ]        as we can see the results help to create new recipes starting with ingredients that go well together frequently .",
    "something interesting is that by allowing overlapping communities we can see that some ingredients are partially in different groups .",
    "for example ginger is used for both savory and deserts .",
    "the modularity algorithm is forced to choose only one cluster for ginger but in our algorithm we can find it in different communities .",
    "we also run the algorithm in a very large dump of a social network with a total of about 5 million nodes .",
    "the algorithm runs in constant time regardless of the size of the graph as it always simulates a constant number of random walks , the only difference in runtime is due to the time needed to access the adjacency list of each node and that is independant of the clustering algorithm .",
    "besides the runtime analysis we weree curious to investigate what kind of small communities the algorithm would find in a large social network .",
    "we run a modularity clustering phase first and then the entropy walker algorithm .        after running the entropy walker algorithm we found that 100        we see that the entropy walker algorithm finds small dense communities inside the big communities created by the modularity algorithm .",
    "figure 4 shows an accepted random walk inside a modularity class .",
    "figure 5 shows the shape of one of the accepted random walk , we can see the community is actually a clique so the algorithm is finding cliques or structures similar to cliques for the parametrized size of components that depend on the length of the random walks .",
    "in a streaming model the graph is constantly updated via the addition and deletion of nodes and edges . in this model",
    "the algorithm can be kept running continuously producing `` infinite '' tours .",
    "as the graph is updated communities that were previously detected might disappear and new communities can emerge .",
    "an algorithm like the count - min sketch [ mutu05 ] can be used to keep in memory a list of only the top @xmath5 communities discovered so far . if a new very tight community forms it will be eventually found by the algorithm several times entering the top @xmath5 ranking . besides keeping the top @xmath5 communities",
    "the streaming model can be used to detect communities that pass the entropy filter and the count - min sketch can be used to only list those communities that have repeated a number of times .",
    "several strategies to prune old communities from memory can be used .",
    "the entropy walker is a very simple algorithm , the core is just a montecarlo simulation of random walks in a graph .",
    "the algorithm uses two very simple tricks to be able to compute communities from these random walks , first it is able to keep or discard a tour by calculating its entropy reasoning that a tour that gets trapped inside a community will visit several times the same nodes resulting in a low - entropy tour .",
    "the second trick is the use of lsh and the ability to merge similar tours into a single one to reduce memory consumption and be able to detect the same community even if the nodes have been visited in different order and with different frequencies .",
    "the algorithm can run very quickly consuming very little memory even for massive graphs , it can be kept running continusly in a streamming model where the graph is constantly updated , this setup is perfect for the anlysis of large social networks ."
  ],
  "abstract_text": [
    "<S> this report presents a very simple algorithm for overlaping community - detection in large graphs under constraints such as the minimum and maximum number of members allowed . </S>",
    "<S> the algorithm is based on the simulation of random walks and measures the entropy of each random walk to detect the discovery of a community . </S>"
  ]
}