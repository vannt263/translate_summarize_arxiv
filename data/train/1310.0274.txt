{
  "article_text": [
    "the mathematica package formcalc @xcite simplifies feynman diagrams generated with feynarts @xcite up to one - loop order .",
    "it provides the analytical results and can generate fortran code for the numerical evaluation of the squared matrix element .",
    "cuba is a library for multidimensional numerical integration which is included in formcalc but can also be used independently .",
    "this note presents the following features new in formcalc 8 and cuba 3.2 :    * significant improvement of the algebraic simplification with form 4 features . *",
    "vectorization of the helicity loop . * automated c - code generation .",
    "* optimizations for unitarity methods . *",
    "checkpointing for all cuba algorithms .",
    "the algebraic simplification of feynman amplitudes is split between mathematica and form . in a preprocessing stage",
    ", mathematica translates the elements of a feynarts amplitude into form syntax and writes them to an input file for form .",
    "( note that none of the feynarts symbols are directly redefined , such that processing does not start automatically . )",
    "form then does the major part of the symbolic simplification . in a postprocessing step ,",
    "the form output is read and returned to mathematica by formcalc s readform mathlink utility .",
    "many new and useful features were introduced in form 4 @xcite , most notably abbreviationing and factorization .",
    "the form part of formcalc 8 has been rewritten to take advantage of these facilities , resulting in significantly improved algebraic simplification .",
    "once a partial expression is considered final at a particular point in the form program it is abbreviated , i.e.  substituted by a symbol .",
    "this not only shortens the active expressions but makes the abbreviated parts inert , such that subsequent id - statements do not spend time on matching these , thus making the form code run faster .    a similar technique has been used since version 6 @xcite , where the form expressions were sent on a round - trip to mathematica halfway through the evaluation for introducing abbreviations .",
    "since this involved quite some transmission overhead , it was performed only once during each form run .",
    "with abbreviationing built into form now , abbreviations are introduced whenever possible , thereby obviating the extra pass to mathematica .",
    "abbreviationing also serves to prevent form s automatic expansion of expressions , i.e.  it preserves a ( pre)factorized structure , which is particularly useful in combination with the new factorization available in form ( see sect .",
    "[ sect : fact ] below ) .",
    "what is more , since mathematica receives an expression in many small pieces rather than one large chunk , more aggressive simplification functions can be applied upon return to mathematica at reasonable efficiency . to this end",
    ", formcalc wraps a zoo of simplification functions around various parts of the amplitude .",
    "all of these are ` transparent ' in the sense that they can be replaced by ` identity ` without affecting the numerical result .",
    "the three most important ones are listed below , a complete inventory is given in the formcalc manual .",
    "* ` formsub ` is applied to subexpressions of an amplitude . * ` formdot ` is applied to combinations of dot products in an amplitude . * ` formmat ` is applied to the coefficients of matrix elements ( `` mat ` ' ) in an amplitude .    on the technical side ,",
    "since the abbreviations are also transmitted to mathematica as such ( i.e.  not back - substituted into the expressions ) , the volume of data transferred is significantly reduced and the final expression is stored efficiently as multiple instances of a subexpression are taken care of by reference count ( same as with ` share [ ] ` ) .    at the moment , formcalc does not use form 4 s `` ` format  on ` '' output optimization , as it is not yet clear how to combine it with the postprocessing in readform and mathematica .",
    "form s new ` full ' factorization ( over the rationals ) makes it possible to simplify expressions much better already inside of form .",
    "the old ` simple ' factorization ( pulling out common symbols from an expression ) is still used in instances where full factorization is too expensive .",
    "potentially time - consuming instances of the ` factarg ` command in the form code can be suppressed by setting the ` calcfeynamp ` option ` nocostly\\totrue ` .",
    "this is occasionally necessary in models with more complex couplings such as the mssm .",
    "plain factorization is not a cure - all for arbitrary expressions , however .",
    "for example , while the following expression is not factorizable as a whole ,    .... -2*e2.k5*s35 + 2*e2.k5*t24 + 2*e2.k5*t14 - 2*e2.k5*mt2 + 2*e2.k5*s - 3*e2.k6*s35 - e2.k6*s45 - e2.k6*t25 - e2.k6*t15 +   4*e2.k6*t24 + 4*e2.k6*t14 - 4*e2.k6*mt2 + 4*e2.k6*s ....    it easily admits further compactification by collecting with respect to the dot products first :    .... -2*(mt2 - s + s35 - t14 - t24)*e2.k5 -   ( 4*mt2 - 4*s + 3*s35 + s45 - 4*t14 + t15 - 4*t24 + t25)*e2.k6 ....    formcalc takes typical objects such as dot products into account , of course .",
    "still , for a general expression it is not straightforward to find a suitable simplification procedure , which is why it is useful to have functions like ` formdot ` through which one can apply more sophisticated functions such as mathematica s ` simplify ` .",
    "the assembly of the squared matrix element in formcalc can be sketched as in the following figure , where the helicity loop sits at the center of the calculation :    ( 205,120 ) ( 0,0)(205,120)bluepastelblue ( 5,115)[tl]loop(s ) over @xmath0 & model parameters ( 15,5)(200,100)olivegreenpastelgreen ( 20,95)[tl]loop(s ) over angular variables ( 30,10)(195,80)redpastelred ( 35,75)[tl]loop over helicities @xmath1 ( 40,50)[tl]@xmath2 ( 103,33)[tl]@xmath3    the helicity loop is not only strategically the most desirable but also the most obvious candidate for concurrent execution , as formcalc does not insert explicit helicity states during the algebraic simplification @xcite .",
    "that is , the amplitude is a numerical function of the helicities @xmath4 and not a bunch of ( different ) functions for each helicity combination , @xmath5 such a design is known as single instruction multiple data ( simd ) in computer science since a single code ( @xmath6 ) is independently run for multiple data ( @xmath4 ) , and is conceptually easy to parallelize or vectorize .",
    "parallelization on the cpu s cores using ` fork`/`wait ` has been available from version 7.5 on @xcite .",
    "the drawback of this method is that it competes for compute cores in particular with cuba . for better efficiency the cores",
    "should be assigned to cuba since it computes entire phase - space points in parallel , not just the helicity loop .",
    "gpu parallelization was attempted using opencl but we found that it was not too efficient . since the transfer of data between the cpu and the gpu is relatively time - consuming , we believe that the distribution of the helicity - independent variables from the cpu to the gpu outweighed the parallelization gains .",
    "eventually the best speedup we could achieve was with vectorization . with intel s x86 vector instructions ,",
    "there is essentially no overhead .",
    "our implementation in c is based on the vector data type extensions offered by gcc and intel s icc .",
    "unfortunately , these are restricted to real algebra , even in c99 .",
    "complex addition is obviously no problem and complex multiplication might have been solved through c++ s operator overloading .",
    "since we wanted to stick to c to avoid linking hassles with fortran object files , we adjusted the c - code generation in mathematica to insert explicit macros for the multiplication of complex vectors : ` sxh ` stands for `` scalar times helicity vector '' and ` hxh ` for `` helicity vector times helicity vector . ''",
    "helicity vectors are declared with ` heltype ` .",
    "( to avoid confusion with minkowski four - vectors , we use prefixes `` hel ` ' or `` h ` ' to denote helicity vectors in the simd sense . )    depending on the hardware features indicated by preprocessor flags these macros emit explicit sse3 or avx instructions .",
    "for sse3 the maximum vector length is 1 ( 2 doubles per operation ) which may at first not seem very useful , but besides performing addition twice as fast there exists an efficient complex multiplication routine with 2.5 instructions instead of 6 . for avx ( requires i7",
    "` sandy bridge ' or higher ) the maximum vector length is 2 ( 4 doubles per operation ) . again",
    "the complex multiplication can be formulated fairly efficiently using intel s vector instructions .",
    "overall we found a speedup of 3.7 out of theoretical 4 with avx for the helicity loop .",
    "currently the configure script does not automatically add flags to switch on sse3 or avx instructions , e.g.  gcc needs the extra flag ` -march = corei7-avx ` to enable the latter .",
    "this may change in the future .",
    "a related question is which default to choose for executables that could potentially be run on a cluster of computers with differing simd capabilities .",
    "vector data types are standard fare in fortran 90 and so not only complex vectors are allowed but one can , in principle , choose arbitrary vector lengths . on the downside ,",
    "the actual deployment of vector instructions is at the discretion of the compiler and may not be chosen for vector lengths incommensurable with the hardware .",
    "even though fortran 90 is an effective requirement for vectorized computation , the code is still generated in fixed format and can be made compatible with fortran 77 through preprocessor definitions , e.g.  for inclusion in legacy packages .",
    "c - code generation has been available from formcalc 7 on @xcite but now its use is mostly automatic , i.e.  also drivers and utility files are available in c. in fact , only the declarations needed to be translated as the initialization still takes place in fortran and the c object files are simply linked in . for this to work ,",
    "the layout of c s structs must match fortran s common blocks , of course .",
    "private declarations , e.g.  for new models , are not automatically translated , but this is fairly straightforward as can be seen by comparing the c and fortran versions of e.g.  the standard model declarations .    to switch from fortran to c output , the following statement needs to precede the output commands ( e.g.  ` writesquaredme ` , ` writerenconst ` ) :    ....    setlanguage[\"c \" ] ....    the output is by default in c99 , because of complex numbers , but can easily be made to work with c++ by redefining the abstract data type ` complextype ` .    even without simd vectorization , and",
    "perhaps remarkably so for fortran aficionados , c and fortran versions of the same amplitude show very similar performance figures , i.e.  there is no penalty for using c.",
    "formcalc can generate amplitudes for evaluation with the opp ( ossola , papadopoulos , pittau @xcite ) unitarity method as implemented in the two libraries cuttools @xcite and samurai @xcite . instead of introducing tensor coefficients @xcite ,",
    "the whole numerator is placed in a subroutine , as in : @xmath7 \\text{where}\\quad n(q_\\mu ) & = ( \\varepsilon_1\\cdot q ) \\ : ( \\varepsilon_2\\cdot q)\\,.\\end{aligned}\\ ] ] the numerator subroutine @xmath8 will be sampled by the opp function ( @xmath9 in this example ) . the first argument of @xmath9 , 2 , refers to the maximum power of the integration momentum @xmath10 in @xmath8 .",
    "the opp procedure indeed generates significantly fewer terms than the traditional passarino ",
    "veltman decomposition , nevertheless a naive implementation runs quite a bit slower than its counterpart with tensor coefficients .",
    "this section describes our attempts to optimize the opp performance .",
    "we were able to bring the slowdown from originally a factor 10 to about a factor 3 for multiplicities such as @xmath11 and hope to improve matters further . to be fair , opp was in the first place designed to increase the reach of one - loop calculations to higher - leg multiplicities and not so much to speed up the ones with not so many legs .",
    "* the major part of the slowdown ( at least half of that factor 10 ) comes from the fact that the opp master integrals ( the scalar integrals @xmath12 , @xmath13 , @xmath14 , @xmath15 ) are naively computed over and over again .",
    "this is because the opp functions must be evaluated inside the helicity loop since the numerator subroutine depends on the helicities .",
    "the scalar integrals contain only the denominators , however , and thus could simply be moved outside the helicity loop .",
    "+ in formcalc , we generate code that foresees a split between the computation of the masters and their use in assembling the tensor integrals , for example : + ....    complextype mas145(mcc )    ...    call cmas(mas145 , ( c0 args ) )    ...    call ccut(mas145 , num , ( c0 args ) ) .... + the complex array ` mas145 ` stores the master integrals computed by ` cmas ` ( outside the helicity loop ) and used by ` ccut ` ( inside the helicity loop ) .",
    "unfortunately , so far none of the available opp libraries allows this decomposition even though the two tasks `` cmas ` ' and `` ccut ` ' must be completed internally in some way or another already now .",
    "looptools alleviates the situation by retrieving recurring masters from its cache , though even here the lookup time could be eliminated with the above construction . *",
    "some packages address this problem by moving the helicity sum into the numerator .",
    "this works if only the interference term is sought since then the amplitude contains at most one loop integration in each term : @xmath16 in formcalc we do nt pursue this strategy , firstly because it is not applicable if the tree - level contribution is zero ( or so small that including the loop - squared part becomes necessary ) and secondly because it is not obvious how this evaluation fits into the present abbreviation concept .",
    "* subexpressions of the numerator function ( coefficients , summands , etc . )",
    "independent of @xmath10 are pulled out and computed once , ahead of invoking the opp function , using formcalc s abbreviationing machinery @xcite . in particular in bsm theories",
    ", these coefficients can be lengthy such that pulling them out significantly increases performance .",
    "* our implementation admits mixing passarino  veltman decomposition with opp in the sense that one chooses an integer @xmath17 starting from which an @xmath17-point function is treated with opp methods .",
    "for example , ` opp \\to 4 ` means that @xmath18 , @xmath19 , @xmath20 functions are treated with passarino  veltman and @xmath21 and up with opp .",
    "* we optimize opp calls to reduce sampling effort , e.g.  by collecting denominators , as in : @xmath22 depending on @xmath8 and rank , joining integrals is not universally better .",
    "rather , we tabulated the sampling behavior of samurai and cuttools such that the algorithm can determine the optimal splitting . *",
    "the ninja library implements the @xmath21-dimensional integrand reduction via laurent expansion @xcite , which constructs the tensor integral from fewer samples in a numerically more stable way .",
    "ninja requires a slightly modified numerator subroutine which is currently being implemented in formcalc . *",
    "the profiler pointed us to a bottleneck in fermion chains : before , we were using elementary operations to build up the fermion chain , which we have now merged into a single inlined function call : @xmath23 the elementary operations could not be inlined in fortran because they returned a 2-component spinor , not a scalar value . *",
    "the helicity information of an opp integral s prefactor is taken into account in an extra argument .",
    "that is , if a term in the amplitude is known to become zero for a particular helicity combination due to its prefactor ( because of massless external particles , say ) , the evaluation of the loop integral therein is cut short .",
    "for example , the following ` dcut ` is actually computed only if @xmath24 : @xmath25",
    "cuba s current version 3.2 allows checkpointing for all routines .",
    "checkpointing means writing out the integrator s complete state to disk to be able to recover from the last state after a crash . in a long - running calculation",
    "this may mean losing one hour instead of one day .",
    "checkpointing is enabled by specifying a name for the state file .",
    "note that , since only vegas had this functionality in version 3.0 , the invocation of the other routines has changed to incorporate the extra state file argument .",
    "we always write the state to a new file and remove the former state file only when the new one is successfully stored .",
    "this makes checkpointing failsafe since even a crash during saving is recoverable .",
    "if the integration finishes successfully , the state file is removed .",
    "the checkpoints have been implemented in the serial regions of the code which ensures reliable behavior regardless of parallelization .",
    "version 3.2 furthermore relaxes several restrictions on the compiler , it is now fully c99-compliant and uses no gcc extensions .",
    "formcalc 8 ( ` http://feynarts.de/formcalc ` ) has many new and improved features , most notably better algebra , a vectorized helicity loop , and opp improvements .",
    "the cuba library ( ` http://feynarts.de/cuba ` ) , also included in formcalc , adds checkpointing for all four integration algorithms , which is useful for resuming interrupted long - running integrations .",
    "hahn t , prez - victoria m , 1999 , _ comput .",
    "commun . _ * 118 * 153 [ hep - ph/9807565 ] .",
    "hahn t , 2001 , _ comput .",
    "commun . _ * 140 * 418 [ hep - ph/0012260 ] .",
    "kuipers j , ueda t , vermaseren jam , vollinga j , 2013 , _ comput .",
    "commun . _ * 184 * 1453 [ arxiv:1203.6543 ] .",
    "hahn t , 2003 , _ nucl .",
    "suppl . _ * 116 * 363 [ hep - ph/0210220 ] hahn t , 2008 , _ pos _ * acat 2008 * 121 [ arxiv:0901.1528 ] .",
    "agrawal s , hahn t , mirabella e , 2012 , _ j.  phys",
    ".  conf .",
    "* 368 * 012054 [ arxiv:1112.0124 ] .",
    "agrawal s , hahn t , mirabella e , 2012 , _ pos _ * ll 2012 * 046 [ arxiv:1210.2628 ] .",
    "hahn t , 2005 , _ comput .",
    "commun . _ * 168 * 78 [ hep - ph/0404043 ] .",
    "passarino g , veltman m , 1979 , _ nucl .",
    "b _ * 160 * 151 .",
    "ossola g , papadopoulos c , pittau r , 2007 , _ nucl .",
    "b _ * 763 * 147 [ hep - ph/0609007 ] .",
    "ossola g , papadopoulos c , pittau r , 2008 , _ jhep _ * 0803 * 042 [ arxiv:0711.3596 ] .",
    "mastrolia p , ossola g , reiter t , tramontano f , 2010 , _ jhep _ * 1008 * 080 [ arxiv:1006.0710 ] .",
    "hahn t , 2010 , _ pos _ * acat 2010 * 078 [ arxiv:1006.2231 ] mastrolia p , mirabella e , peraro t , 2012 , _ jhep _ * 1206 * 095 , erratum : 2012 , ibid .  * 1211 * , 128 [ arxiv:1203.0291 ] ."
  ],
  "abstract_text": [
    "<S> we present version 8 of the feynman - diagram calculator formcalc . </S>",
    "<S> new features include in particular significantly improved algebraic simplification as well as vectorization of the generated code . </S>",
    "<S> the cuba library , used in formcalc , features checkpointing to disk for all integration algorithms . </S>",
    "<S> report mpp-2013 - 273 </S>"
  ]
}