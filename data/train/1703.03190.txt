{
  "article_text": [
    "highly dynamic networks are made of dynamic ( often mobile ) entities such as vehicles , drones , or robots .",
    "it is generally assumed , in these networks , that the set of entities ( nodes ) is constant , while the set of communication links varies over time .",
    "many classical assumptions do not hold in these networks .",
    "for example , the topology may be disconnected at any instant .",
    "it may also happen that an edge present at some time never appears again in the future .",
    "in fact , of all the edges that appear at least once , one can distinguish between two essential sets : the set of _ recurrent _ edges , which always reappear in the future ( or remain present ) , and the set of _ non recurrent _ edges which eventually disappear in the future .",
    "the static graph containing the union of both edge sets is called the _ footprint _ of the network  @xcite , and its restriction to the recurrent edges is the _ eventual footprint _ of the network  @xcite .",
    "it is not clear , at first , what assumptions seem reasonable in a highly dynamic network .",
    "special cases have been considered recently , such as always - connected dynamic networks  @xcite , @xmath3-interval connected networks  @xcite , or networks the edges of which correspond to pairwise interactions obeying a uniform random scheduler ( see e.g.  @xcite ) . arguably , one of the weakest possible assumption is that any pair of nodes be able to communicate infinitely often through _ temporal paths _ ( or journeys ) .",
    "interestingly enough , this property was identified more than three decades ago by awerbuch and even  @xcite and remained essentially ignored afterwards .",
    "the corresponding class of dynamic networks ( class  5 in  @xcite  here referred to as @xmath4for consistency with various notations  @xcite ) is however one of the most general and it actually includes the three aforementioned cases .",
    "dubois _ et al . _",
    "@xcite observe that class @xmath5 is actually the set of dynamic networks whose _ eventual footprint _ is connected . in other words , it is more than reasonable to assume that some of the edges are recurrent and their union does form a _ connected _ spanning subgraph . solving classical problems such as symmetry - breaking tasks relative to this particular set thus makes sense , as the nodes can rely forever on the corresponding solution , even though intermittently  @xcite .",
    "unfortunately , it is impossible for a node to distinguish between the set of recurrent edges and the set of non recurrent edges .",
    "so , the best the nodes can do is to compute a solution relative to the footprint , hoping that this solution still makes sense in the eventual footprint , whatever it is .",
    "( whether , and how the nodes can learn the footprint itself is discussed later on . )",
    "this context suggests a particular form of heredity which we call _ robustness_. in classical terms , robustness can be formulated as the fact that a given property must be inherited by all the connected spanning subgraphs of the original graph .",
    "significantly , this concept admits several possible interpretations , including the dynamic interpretation developed here .",
    "a more conventional , almost direct interpretation is that some edges in a classical ( static ) network are subject to permanent failure at some point , and the network is to be operated so long as it remains connected .",
    "while this interpretation is more intuitive and familiar , we insist on the fact that the dynamic interpretation of robustness is what makes its study compelling , for this notion arises naturally in class @xmath4 , which is one of the most general class of dynamic networks imaginable . the reader may adopt either interpretation while going through the paper , keeping in mind that our results apply to both contexts and are therefore quite general .",
    "* contributions .",
    "* we investigate the concept of _ robustness _ of a property , with a focus on the _ maximal independent set _",
    "( mis ) problem , which consists of selecting a subset of nodes none of which are neighbors ( independence ) and such that no further node can be added to it ( maximality ) . as it turns out , a robust mis may or may not exist , and if it exists , it may or may not be computable locally depending on the considered graph ( _ resp . _",
    "footprint ) .",
    "for example , if the graph is a triangle ( see figure  [ fig : mis - a ] ) , then only one mis exists up to isomorphism , consisting of a single node .",
    "however , this set is no longer maximal in one of the possible connected spanning subgraphs ( e.g.after removing an adjacent edge to the selected node ) .",
    "therefore , the triangle graph admits no robust mis .",
    "some graphs do admit a robust mis , but not all of the miss are robust",
    ". figures  [ fig : mis - b ] and  [ fig : mis - c ] show two miss in the bull graph , only one of which is robust . finally , some graphs like the square graph ( figure  [ fig : mis - d ] ) are such that _ all _ miss are robust .",
    "although the last two examples seem to suggest that robust miss are related to _ maximum _ miss , being maximum is actually neither a necessary nor a sufficient condition .    in this paper , we characterize the class of graphs such that all miss are robust , denoted @xmath6 .",
    "we prove that @xmath6consists _ exactly _ of the union of complete bipartite graphs and a new class of graphs called _",
    "sputniks _ , which contains among others all the trees ( for which any property is trivially robust ) .",
    "while the sufficient side is easy to establish , proving that these graphs are the only ones is more difficult . interestingly , while the best known algorithms for deterministic distributed mis in general graphs are superlogarithmic in the number of nodes @xmath0 , namely they take @xmath7 rounds  @xcite ( better randomized algorithms are known  @xcite ) , graphs in @xmath6turn out to be specific enough to find an mis ( robust by definition ) by using only information available within a sublogarithmic distance .",
    "we present an algorithm that first settles specific subsets of the networks using information available within _ constant _ distance , the residual instance being a disjoint union of trees .",
    "the residual instance can then be given to state - of - the - art algorithms like barenboim and elkin s for graphs of bounded arboricity  @xcite , which is known to use only information within distance @xmath8 .",
    "an added benefit of this reduction is that any further progress on the mis problem on trees will automatically transpose to robust miss in @xmath6 .",
    "( note that we deliberately do not use the terms `` rounds '' or `` time '' , due to the non equivalence of locality and time in the context of a footprint . )",
    "next , we turn our attention to general graphs and ask whether a robust mis can be found ( if one exists ) using only local information .",
    "we answer negatively , proving an @xmath2 lower bound on the locality of the problem .",
    "this result implies a separation between the mis problem and the robust mis problem in general graphs , since the former is feasible within @xmath7 hops  @xcite .",
    "it also implies that no strategy is essentially better than collecting the network at a single node and subsequently solving the problem in an offline manner .",
    "motivated by this observation , we consider the offline problem of finding a robust mis in a given graph if one exists ( and rejecting otherwise ) .",
    "the trivial strategy amounts to enumerating all miss until a robust one is found , however there may be exponentially many miss in general graphs ( moon and moser  @xcite , see also  @xcite for an extension to the case of connected graphs ) .",
    "we present a polynomial time algorithm for computing a robust mis in any given graph ( if one exists ) .",
    "our algorithm relies on a particular decomposition of the graph into a tree of biconnected components ( @xmath9-tree ) , along which constraints are propagated about the mis status of special nodes in between the components .",
    "the inner constraints of non trivial components are solved by reduction to the 2-sat problem ( which _ is _ tractable ) . as a by - product",
    ", the set of instances for which a robust mis is found characterizes the existential analogue of @xmath6 , that is the class @xmath10of all graphs that",
    "_ admit _ a robust mis .",
    "( whether a closer characterization exists is left as an open question . )    * further discussion on the dynamic interpretation . * as pointed out , in a dynamic network there is no way to distinguish between recurrent and non recurrent edges , therefore the nodes can not learn the _ eventual _ footprint @xcite ( this observation is the very basis of the notion of robustness ) .",
    "now , what about the union of both types of edges , that is , the footprint itself ?",
    "clearly , the footprint can never be _ decided _ in a definitive sense by the nodes , since some edges may appear arbitrary late for the first time .",
    "however , it is also clear that every edge of the footprint _",
    "will _ eventually appear ; thus , over time the nodes can learn the footprint in a stabilized way , by updating their representation as new edges are detected .",
    "it is therefore possible to update some structure or property that eventually relates to the correct footprint .",
    "( alternatively , one may assume simply that prior information about the footprint is given to the nodes , or that an oracle informs the nodes once every edge of the footprint has appeared . ) again , the reader is free to ignore the dynamic interpretation if the static one makes for a sufficient motivation .",
    "* outline .",
    "* section  [ sec : definitions ] presents the main definitions and concepts .",
    "then , we characterize in section  [ sec : forallmis ] the class @xmath6and present a dedicated mis algorithm that requires only information up to a sublogarithmic number of hops .",
    "section  [ sec : existsmis ] establishes the non - locality of the problem in general and describes a tractable algorithm that computes a robust mis in a given graph if one exists .",
    "section  [ sec : conclusion ] concludes with some remarks .",
    "many of the concepts presented in the introduction , including that of temporal paths , footprint , or classes of dynamic networks are not defined here .",
    "the authors believe that the informal descriptions given in introduction are sufficient to understand the dynamic interpretation of the results .",
    "( if that is not the case , the reader is referred to  @xcite for thorough definitions using the time - varying graph formalism . )",
    "our results themselves are formulated using standard concepts of graph theory , making them independent from both interpretations .",
    "let @xmath11 be an undirected graph , with @xmath12 the set of nodes ( vertices ) and @xmath13 the set of bidirectional communication links ( edges ) .",
    "we denote by @xmath14 the number of nodes in the graph , and by @xmath15 the _ diameter _ of the graph , that is , the length of the longest shortest path in @xmath16 over all possible pairs of nodes .",
    "we denote by @xmath17 the neighborhood of a vertex @xmath18 , which is the set of vertices @xmath19 .",
    "the degree of a vertex @xmath18 is @xmath20 .",
    "a vertex is _ pendant _ if it has degree  @xmath21 .",
    "a _ cut vertex _ ( or _ articulation point _ ) is a vertex whose removal disconnects the graph .",
    "a _ cut edge _ ( or _ bridge _ ) is an edge whose removal disconnects the graph .",
    "we say that an edge is _ removable _ if it is not a cut edge .",
    "a _ spanning connected subgraph _ of a graph @xmath22 is a graph @xmath23 such that @xmath24 , @xmath25 , and @xmath26 is connected . in the most general variant ,",
    "we define _ robustness _ as follows .",
    "[ def : robustness ] a property @xmath27 is said to be _ robust _ in @xmath16 if and only if it is satisfied in every connected spanning subgraph of @xmath16 ( including @xmath16 itself ) .    in other words ,",
    "a robust property holds even after an arbitrary number of edges are removed without disconnecting the graph .",
    "robustness is a special case of hereditary property , and more precisely a special case of decreasing monotone property ( see for instance  @xcite ) . in this paper , we focus on the _ maximal independent set _ ( mis ) problem .",
    "an mis is a set of nodes such that no two nodes in the set are neighbors and the set is maximal for the inclusion relation . following definition  [ def : robustness ] ,",
    "a robust mis in a graph @xmath16 ( rmis , for short ) is an mis that remains _ maximal _ and _ independent _ in every connected spanning subgraph of @xmath16 .",
    "observe that independence is stable under the removal of edges ; therefore , it is sufficient that the mis be maximal in all these subgraphs in order to be an rmis .",
    "we define two classes of graphs related to the robustness of miss .",
    "this class is the set of all graphs in which all miss are robust .",
    "this class is the set of all graphs that admit at least one robust mis .",
    "we define the distributed problem of computing an rmis in a given graph as follows .",
    "[ def : rmis - problem ] given a graph @xmath16 and an algorithm @xmath28 executed at every node of @xmath16 , @xmath28 solves robustmison @xmath16 iff every node eventually terminates by outputting in or out , and the set of nodes outputting in forms an rmis on @xmath16 .",
    "algorithm @xmath28 solves robustmisin a class of graphs @xmath29 iff for all @xmath30 , @xmath28 solves robustmison @xmath16 .",
    "finally , let us define two classes of graphs that turn out to be closely related to rmiss , namely _ complete bipartite graphs _ and _ sputnik graphs_. the latter is introduced here for the first time .",
    "a complete bipartite graph is a graph @xmath31 such that @xmath32 and @xmath33 . in words ,",
    "the vertices can be partitioned into two sets @xmath34 and @xmath35 such that every vertex in @xmath34 shares an edge with every vertex in @xmath35 ( completeness ) , and these are the only edges ( bipartiteness ) .",
    "a graph is a _ sputnik _",
    "iff every vertex belonging to a cycle also has a pendant neighbor .",
    "( an example of sputnik is shown in figure  [ fig : lnf ] . )",
    "based on the chosen interpretation of our results , the base graph in the above definitions refers either to the footprint of a dynamic network , or to the network itself . in the dynamic case ,",
    "the actual timing of the edges is arbitrary , so the classical equivalence between time and locality in synchronous network does not hold .",
    "nonetheless , we rely on the @xmath1 model  @xcite to describe the algorithms . to avoid confusion between locality and time in the dynamic case",
    ", we always state the complexities in terms of locality , saying that an algorithm ( or problem ) is @xmath36-local if it can be solved in @xmath36 rounds in the @xmath1 model .",
    "( other terminologies include saying that such problems are in @xmath37@xcite . ) for completeness , let us recall the main features of the @xmath38 model",
    ". in this model , the nodes operate in synchronous discrete rounds and they wake up simultaneously . in each round ,",
    "a node can exchange messages of arbitrary size with its neighbors and perform some local ( typically unrestricted ) computation .",
    "the complexity of an algorithm over a class of graphs is the maximum number of rounds , taken over all graphs of this class , performed until all nodes have terminated . in the dynamic interpretation of our results ,",
    "the algorithms are seen as being _ restarted _ every time the local knowledge of the footprint changes .",
    "in this section , we show that @xmath6 , the class of graphs in which all miss are robust , corresponds exactly to the union of complete bipartite graphs and sputnik graphs",
    ". then we present an algorithm that solves robustmisin @xmath6using information available only within a sublogarithmic number of hops in @xmath0 .",
    "we first show that all miss are robust in complete bipartite graphs and in sputnik graphs . due to space limitation",
    ", the proofs of the two following lemmas are postponed to appendix [ sec : missing ] .",
    "they follow easily from the very definition of rmis and of these classes of graphs .",
    "[ lem : bk ] all miss are robust in complete bipartite graphs .",
    "[ lem : sputniks ] all miss are robust in sputnik graphs .",
    "we now prove the stronger result that if a graph is such that all possible miss are robust , then it _ must _ be either a bipartite complete graph or a sputnik .",
    "[ lem : necessary ] if @xmath16 is not a sputnik , and yet every mis in @xmath16 is robust , then @xmath16 is bipartite complete .    if @xmath16 is not a sputnik , then some node @xmath39 in a cycle @xmath40 has no pendant neighbor . in general",
    ", @xmath39 may be an articulation point , and so the graph @xmath41 may result in several components .",
    "let @xmath42 be the resulting components with vertex @xmath39 back in each of them .",
    "in particular , let @xmath43 be the one that contains @xmath44 and observe that @xmath43 contains at least @xmath45 vertices ( cycle ) .",
    "the other components , if they exist , all contain at least two vertices other than @xmath39 ( otherwise @xmath39 would have a pendant neighbor ) .",
    "* claim 1 : * if all miss in @xmath16 are robust , then all neighbors of @xmath39 in @xmath43 have the same neighborhood .",
    "we prove this claim by contradiction .",
    "let two neighbors @xmath46 of @xmath39 be such that @xmath47 .",
    "we will show that at least one mis is not robust .",
    "without loss of generality , assume that some vertex @xmath48 belongs to @xmath49 . then we can build an mis that contains both @xmath50 and @xmath48 ( as a special case , @xmath48 may be the same vertex as @xmath50 , but this is not a problem ) .",
    "for each of the components @xmath51 , choose an edge @xmath52 and add another neighbor of @xmath53 to the mis ( such a neighbor exists , as we have already seen ) .",
    "one can see that @xmath39 , @xmath54 and all @xmath53 can no longer enter the mis because they all have neighbors in it .",
    "now , choose the remaining elements of the mis arbitrarily .",
    "we will show that the resulting mis is not robust , by consider the removal of edges as follows . in all components",
    "@xmath51 , remove _ all _ edges incident to @xmath39 except @xmath55 ; and in @xmath43 , remove all edges incident to @xmath39 except @xmath56 .",
    "the resulting graph remains connected , by definition , since each of the @xmath57 is connected . and",
    "yet , @xmath39 no longer has a neighbor in the mis , which contradicts robustness.@xmath58    now , claim 1 implies that none of @xmath39 s neighbors in @xmath43 has a pendant neighbor ( since their neighborhoods are the same ) . as a result ,",
    "the arguments that applied to @xmath39 because of its absence of pendant neighbors , apply in turn to @xmath39 s neighbors in @xmath43 .",
    "in particular , it means that if some node @xmath18 is neighbor to @xmath39 in @xmath43 , then all neighbors of @xmath18 ( including @xmath39 ) must have the same neighborhood .",
    "therefore , @xmath39 can not be an articulation point and we are left with the single component @xmath43 , in which all neighbors of @xmath39 have the same neighbors and these neighbors in turn have the same neighbors , which implies that the graph is complete bipartite .    based on lemmas  [ lem : bk ] , [ lem : sputniks ] , and [ lem : necessary ] , we conclude with the following theorem .    [",
    "th : forallmis ] all miss are robust in a graph @xmath16 if and only if @xmath16 is complete bipartite or sputnik .",
    "= [ defnode ] ( 1.5,10.3 ) node [ ] ( v0 ) ; ( 3.08,10.48 ) node [ ] ( v3 ) ; ( 1.9,8.36 ) node [ ] ( v5 ) ; ( 3.78,7.8 ) node [ ] ( v9 ) ; ( 6.48,7.38 ) node [ ] ( v16 ) ; ( 8.02,7.36 ) node [ ] ( v17 ) ; ( 7.32,10.8 ) node [ ] ( v18 ) ; ( 5.4,7.52 ) node [ ] ( v19 ) ; ( 8.88,7.4 ) node [ ] ( v20 ) ; ( 9.64,7.42 ) node [ ] ( v24 ) ; ( 10.38,7.44 ) node [ ] ( v25 ) ;    ( 2.18,9.66 ) node [ ] ( v1 ) ; ( 3.26,9.68 ) node [ ] ( v2 ) ; ( 2.88,8.76 ) node [ ] ( v4 ) ; ( 6.56,8.86 ) node [ ] ( v11 ) ; ( 7.32,9.64 ) node [ ] ( v12 ) ; ( 8.02,8.86 ) node [ ] ( v13 ) ; ( 6.9,8.12 ) node [ ] ( v14 ) ; ( 7.66,8.1 ) node [ ] ( v15 ) ; ( 4.5,8.32 ) node [ ] ( v8 ) ; ( 9.98,8.24 ) node [ ] ( v23 ) ; ( 4.44,9.66 ) node [ ] ( v6 ) ; ( 9.02,9.82 ) node [ ] ( v21 ) ; ( 5.06,9.02 ) node [ ] ( v7 ) ; ( 5.52,9.92 ) node [ ] ( v10 ) ; ( 9.92,9.08 ) node [ ] ( v22 ) ; = [ ] ; ( v0)(v1 ) ; ( v1)(v2 ) ; ( v2)(v4 ) ; ( v4)(v1 ) ; ( v5)(v4 ) ; ( v2)(v3 ) ; ( v2)(v6 ) ; ( v7)(v6 ) ; ( v9)(v8 ) ; ( v8)(v7 ) ; ( v6)(v10 ) ; ( v10)(v11 ) ; ( v11)(v12 ) ; ( v12)(v13 ) ; ( v13)(v11 ) ; ( v11)(v14 ) ; ( v14)(v15 ) ; ( v15)(v13 ) ; ( v16)(v14 ) ; ( v17)(v15 ) ; ( v18)(v12 ) ; ( v19)(v11 ) ; ( v20)(v13 ) ; ( v21)(v13 ) ; ( v22)(v21 ) ; ( v23)(v22 ) ; ( v23)(v24 ) ; ( v23)(v25 ) ;    = [ mis ] ( v18 ) node [ ] ; ( v3 ) node [ ] ; ( v0 ) node [ ] ; ( v5 ) node [ ] ; ( v9 ) node [ ] ; ( v16 ) node [ ] ; ( v17 ) node [ ] ; ( v19 ) node [ ] ; ( v20 ) node [ ] ; ( v24 ) node [ ] ; ( v25 ) node [ ] ; ( v6 ) node [ ] ; ( v21 ) node [ ] ; ( v18 ) coordinate[xshift=5pt , yshift=5pt ] ( v18ne ) ; ( v3 ) coordinate[yshift=5pt ] ( v3n ) ; ( v0 ) coordinate[xshift=-7pt , yshift=6pt ] ( v0nw ) ; ( v5 ) coordinate[xshift=-5pt , yshift=-4pt ] ( v5sw ) ; ( v9 ) coordinate[yshift=-5pt ] ( v9s ) ; ( v19 ) coordinate[yshift=-5pt ] ( v19s ) ; ( v16 ) coordinate[yshift=-5pt ] ( v16s ) ; ( v17 ) coordinate[yshift=-5pt ] ( v17s ) ; ( v20 ) coordinate[yshift=-5pt ] ( v20s ) ; ( v24 ) coordinate[yshift=-5pt ] ( v24s ) ; ( v25 ) coordinate[xshift=5pt , yshift=-5pt ] ( v25se ) ; ( v25 ) coordinate[xshift=5pt , yshift=5pt ] ( v25ne ) ; ( v24 ) coordinate[yshift=5pt ] ( v24n ) ; ( v20 ) coordinate[yshift=5pt ] ( v20n ) ; ( v17 ) coordinate[yshift=5pt ] ( v17n ) ; ( v16 ) coordinate[yshift=5pt ] ( v16n ) ; ( v19 ) coordinate[yshift=5pt ] ( v19n ) ; ( v9 ) coordinate[yshift=5pt ] ( v9n ) ; ( v5 ) coordinate[xshift=4pt , yshift=4pt ] ( v5ne ) ; ( v0 ) coordinate[xshift=4pt , yshift=-3pt ] ( v0se ) ; ( v3 ) coordinate[yshift=-5pt ] ( v3s ) ; ( v18 ) coordinate[xshift=5pt , yshift=-5pt ] ( v18se ) ;    ( v18ne)(v3n)(v0nw)(v5sw)(v9s)(v19s)(v16s)(v17s)(v20s)(v24s)(v25se)(v25ne)(v24n)(v20n)(v17n)(v16n)(v19n)(v9n)(v5ne)(v0se)(v3s)(v18se)cycle ;    ( v1 ) coordinate[xshift=-5pt , yshift=-3pt ] ( v1sw ) ; ( v4 ) coordinate[xshift=-3pt , yshift=-5pt ] ( v4sw ) ; ( v8 ) coordinate[yshift=-4pt ] ( v8s ) ; ( v14 ) coordinate[yshift=-5pt ] ( v14s ) ; ( v15 ) coordinate[yshift=-5pt ] ( v15s ) ; ( v23 ) coordinate[xshift=5pt , yshift=-5pt ] ( v23se ) ; ( v23 ) coordinate[xshift=5pt , yshift=4pt ] ( v23ne ) ; ( v13 ) coordinate[xshift=4pt , yshift=4pt ] ( v13ne ) ; ( v12 ) coordinate[yshift=7pt ] ( v12n ) ; ( v11 ) coordinate[xshift=-4pt , yshift=4pt ] ( v11nw ) ; ( v8 ) coordinate[yshift=4pt ] ( v8n ) ; ( v2 ) coordinate[xshift=2pt , yshift=5pt ] ( v2n ) ; ( v1 ) coordinate[xshift=-5pt , yshift=5pt ] ( v1nw ) ;    ( v1sw)(v4sw)(v8s)(v14s)(v15s)(v23se)(v23ne)(v13ne)(v12n)(v11nw)(v8n)(v2n)(v1nw)cycle ;    ( v6)+(.57,-.05 ) circle ( .7 ) ;    ( v21)+(.48,-.3 ) circle ( .7 ) ;    = [ ] ( v12n ) node[right=5pt , green ] n ; ( v5 ) node[below=10pt , blue ] p ; ( v10 ) node[right=5pt , red ] f ;    we now prove that computing deterministically an rmis in class @xmath6can be done locally , by presenting a distributed algorithm that computes a ( regular ) mis using only information available within @xmath59-hops a sublogarithmic number of hops in @xmath0 . by definition of the class ,",
    "this mis is robust .",
    "informally , the algorithm proceeds as follows ( due to space limitations , the pseudo - code and the formal proof of the algorithm are moved to appendix [ sec : missing ] ) .",
    "class @xmath6consists of exactly the union of bipartite complete graphs and sputniks ( theorem  [ th : forallmis ] ) .",
    "first , the nodes decide if the graph is complete bipartite by looking within a constant number of hops ( three ) .",
    "if so , membership to the mis is decided according to some convention ( e.g.all nodes in the same part as the smallest identifier are in the mis ) . otherwise , the graph _ must _ be a sputnik and every node decides ( without more information ) which of the following three cases it falls into : 1 ) it is a pendant node ( set @xmath27 in figure  [ fig : lnf ] ) , 2 ) it is not a pendant node but has at least one pendant neighbor ( set @xmath60 ) , or 3 ) none of the two cases apply ( set @xmath61 ) . in the first case",
    ", it enters the mis , while in the second it decides not to .",
    "we prove that the set of nodes falling into the third case does form a disjoint union of trees , each of which can consequently be solved by state - of - the - art algorithms .",
    "in particular , barenboim and elkin  @xcite present a @xmath8-local algorithm that solves mis in graphs of bounded arboricity ( and a fortiori trees ) . on the negative side ,",
    "we show ( using standard arguments ) that linial s @xmath62 lower bound for @xmath45-coloring  @xcite in cycles extends to robustmisin class @xmath6 , leading to the following theorem .",
    "[ th : localityforall ] robustmisis @xmath63-local in class @xmath6 .",
    "in this section , we prove that the problem of computing deterministically an rmis in general graphs , if one exists , is _ not _ local . precisely , we first observe that _ deciding _ whether an rmis exists is not a local problem ; then , we prove a @xmath2 lower bound on the distance at which it might be necessary to look to solve the problem if an rmis exists , where @xmath0 is the diameter of the network .",
    "motivated by this result , we present an offline algorithm that compute an rmis , in polynomial time , if one exists . it can be used in a strategy where all the information about the network is collected at one node ( or several , the algorithm being deterministic ) .",
    "= [ defnode ] ( -1,1 ) node [ ] ( ma ) ; ( 0,0 ) node [ ] ( ba ) ; ( 0,2 ) node [ ] ( ha ) ; ( 1,1 ) node [ ] ( mb ) ; ( 3,1 ) node [ ] ( m0 ) ; ( 4,0 ) node [ ] ( b0 ) ; ( 4,2 ) node [ ] ( h0 ) ; ( 5,1 ) node [ ] ( m1 ) ; ( 6,0 ) node [ ] ( b3 ) ; ( 6,2 ) node [ ] ( h3 ) ; ( 7,0 ) node [ ] ( b3b ) ; ( 7,2 ) node [ ] ( h3b ) ; ( 8,1 ) node [ ] ( m4 ) ; ( 9,0 ) node [ ] ( b4 ) ; ( 9,2 ) node [ ] ( h4 ) ; ( 10,1 ) node [ ] ( m5 ) ; ( 12,1 ) node [ ] ( m7 ) ; ( 13,0 ) node [ ] ( b7 ) ; ( 13,2 ) node [ ] ( h7 ) ; ( 14,1 ) node [ ] ( m8 ) ;    = [ ] ( ma ) node[left ] @xmath64 ; ( ba ) node[below ] @xmath65 ; ( ha ) node[above ] @xmath66 ; ( mb ) node [ ] ; ( m0 ) node[above , xshift=-5pt ] @xmath67 ; ( b0 ) node[below ] @xmath68 ; ( h0 ) node[above , xshift=-2pt ] @xmath69 ; ( m1 ) node[right , xshift=2pt ] @xmath70 ; ( b3 ) node[below ] @xmath71 ; ( h3 ) node[above , xshift=2pt ] @xmath72 ; ( b3b ) node[below ] @xmath73 ; ( h3b ) node[above ] @xmath74 ; ( m4 ) node[left ] @xmath75 ; ( b4 ) node[below ] @xmath76 ; ( h4 ) node[above ] @xmath77 ; ( m5 ) node[above , xshift=5pt ] @xmath78 ; ( m7 ) node [ ] ; ( b7 ) node[below ] @xmath79 ; ( h7 ) node[above ] @xmath80 ; ( m8 ) node[right ] @xmath81 ; ( mb ) node[right=9pt ] @xmath82 ; ( m5 ) node[right=9pt ] @xmath82 ;    ( ma)(ba)(mb)(ha)(ma ) ; ( m0)(b0)(m1)(h0)(m0 ) ; ( m1)(b3)(b3b)(m4)(h3b)(h3)(m1 ) ; ( m4)(b4)(m5)(h4)(m4 ) ; ( m7)(b7)(m8)(h7)(m7 ) ;    = [ mis ] ( ha ) node ; ( ba ) node ; ( h0 ) node ; ( b0 ) node ; ( h3 ) node ; ( b3 ) node ; ( m4 ) node ; ( m5 ) node ; ( m7 ) node ; ( m8 ) node ;      let us first observe that the problem of deciding whether an rmis exists is not local .",
    "consider two graphs @xmath83 and @xmath84 which respectively consist of a @xmath85-long path and to a lollipop graph ( i.e.a graph joining a @xmath85-long path to a clique of size @xmath85 ) .",
    "then , clearly , a node at one extremity of @xmath83 and the ( unique ) pendant node of @xmath84 can not distinguish their @xmath86 neighborhood ( even with identifiers , which could be exactly the same in this neighborhood ) whereas @xmath83 admits an rmis and @xmath84 does not .",
    "we go further and prove that , even if some rmiss do exist , then finding one is non local . to prove this result , we exhibit an infinite family of graphs @xmath87 , each of which has diameter linear in @xmath88 ( and @xmath0 ) .",
    "we first show through lemmas  [ lem : gk - robust ] and  [ lem : gk - only ] that every @xmath89 admits only _ two _ rmiss @xmath90 and @xmath91 which are _ complements _ of each other ; that is @xmath92 . intuitively , these miss are such that two nodes at distance @xmath85 must take opposite decisions , although they have the same view up to distance @xmath85 .",
    "( the real proof is more complex and involves showing that identifiers do not help either . ) as a result , the nodes may have to collect information up to distance @xmath2 in order to decide consistently .",
    "let @xmath87 be an infinite famility of graphs defined as follows .",
    "graph @xmath93 is such that @xmath94 and @xmath95 induces a cycle @xmath74-@xmath75-@xmath73-@xmath71-@xmath70-@xmath72-@xmath74 as shown in figure  [ fig : gk ] .",
    "then @xmath96 is obtained from @xmath97 as follows : @xmath98 and @xmath99 @xmath100 .    for any @xmath88 ,",
    "define @xmath90 as the set of nodes @xmath101 and @xmath102 .",
    "observe that @xmath103 ( written @xmath104 ) .",
    "set @xmath90 is illustrated in figure  [ fig : gk ] .",
    "[ lem : gk - robust ] for any @xmath105 , @xmath90 and @xmath91 are rmiss in @xmath89 .",
    "we prove this for @xmath90 .",
    "the same holds symmetrically for @xmath91 .",
    "first , observe that @xmath90 is a valid mis : no two of its nodes are neighbors by construction ( independence ) and all nodes in @xmath106 have neighbors in @xmath90 ( maximality ) .",
    "now , to obtain a connected spanning subgraph of @xmath89 , one can remove from @xmath107 at most one edge from each simple cycle of @xmath89 .",
    "since any node of @xmath106 has a number of neighbors in @xmath90 strictly greater than the number of simple cycles it belongs to , @xmath90 is robust .    [",
    "lem : gk - only ] for any @xmath105 , @xmath90 and @xmath91 are the only two rmiss in @xmath89 , implying that nodes @xmath81 and @xmath64 must take opposite decisions in all rmiss .",
    "we say that an edge @xmath108 is _ critical _ with respect to some mis @xmath109 in @xmath89 if @xmath110 is removable ( i.e.not a cut edge ) and @xmath109 is no longer maximal in @xmath111 .",
    "the existence of a critical edge implies that the considered mis is not robust .",
    "let us now consider an rmis @xmath109 in @xmath89 .",
    "we prove several claims on @xmath109 .",
    "* claim 1 : * if @xmath112 , then @xmath113 and @xmath114 .    if @xmath112 , then @xmath115 ( independence ) .",
    "it also holds that @xmath116 , otherwise the edge @xmath117 is critical ( robustness ) .",
    "it follows that @xmath118 ( independence ) and @xmath119 ( maximality ) .    * claim 2 : * if @xmath120 , then @xmath121 and @xmath122 .    * claim 3 : * if @xmath112 , then @xmath123 and @xmath124 for all @xmath125 .    by contradiction ,",
    "if @xmath126 for some @xmath127 , then @xmath128 ( independence ) .",
    "let @xmath127 be smallest possible , then edges @xmath129 and @xmath130 are critical _",
    "w.r.t._@xmath109 ( recall that , if @xmath131 , @xmath132 by construction and @xmath133 by claim 1 ) , which contradicts robustness .",
    "therefore , @xmath124 .",
    "the maximality of @xmath109 allows us to conclude .",
    "* claim 4 : * if @xmath120 , then @xmath134 and @xmath126 for all @xmath125 .",
    "* claim 5 : * if @xmath112 , then @xmath135 and @xmath136 for all @xmath125 .    by contradiction , if @xmath137 for some @xmath127 , then @xmath135 ( independence ) .",
    "let @xmath127 be smallest possible ( recall that , if @xmath131 , @xmath138 by construction and @xmath116 by claim 1 ) .",
    "let @xmath139 be @xmath75 if @xmath140 and be @xmath141 otherwise .",
    "the edges @xmath142 and @xmath143 are then critical , which contradicts robustness .",
    "therefore , @xmath136 .",
    "the independence of @xmath109 allows us to conclude .    * claim 6 : * if @xmath120 , then @xmath144 and @xmath137 for all @xmath125 .    claims 1 to 6 imply that @xmath145 if @xmath112 and @xmath146 otherwise .    finally , we relate these results to the locality of the robustmisproblem .",
    "[ th : localityexists ] robustmisrequires the nodes to use information up to distance @xmath2 in @xmath89",
    ".    the proof would be straightforward in an anonymous network , due to the fact that @xmath81 and @xmath64 have indistinguishable structural neighborhoods ( _ a.k.a._views  @xcite ) up to distance @xmath85 , and yet , they must take different decisions ( lemma  [ lem : gk - only ] ) .",
    "unique identifiers make the argument more complicated , since @xmath81 and @xmath64 do have unique _ labeled _ views ( i.e.views taking into account identifiers ) even at distance @xmath147 .",
    "let us call @xmath81 and @xmath64 the _ extremities _ of the network . observe that the distance between both extremities is larger than @xmath148 .",
    "let @xmath149 , @xmath150 , and @xmath151 be three possible labeling functions that assign unique identifiers to the neighborhood of an extremity up to distance @xmath88 ( say ) and such that the three labelings have no identifier in common .",
    "let @xmath152 be the labeled graph whose structure is isomorphic to @xmath89 , in which the neighborhood of @xmath81 is labeled according to @xmath149 and the neighborhood of @xmath64 is labeled according to @xmath150 ; the rest of the nodes are labeled arbitrarily .",
    "let @xmath153 be defined similarly , but using @xmath151 instead of @xmath150 in the neighborhood of @xmath64 .",
    "finally , let @xmath154 be defined similarly , but using @xmath150 in the neighborhood of @xmath81 and @xmath151 in the neighborhood of @xmath64 .",
    "now , if @xmath81 and @xmath64 use only information up to distance @xmath88 , then they must take identical decisions in at least one of the three labeled graphs , contradicting lemma  [ lem : gk - only ] .",
    "we now describe an algorithm that tests constructively whether an rmis exists in a graph @xmath16 .",
    "our algorithm relies on the construction of an auxiliary tree called _",
    "@xmath155-tree _ , which represents a particular decomposition of the graph based on biconnected components ( it is neither a block - cut tree , nor a bridge tree , but a mix of these two types of decomposition ) .",
    "roughly speaking , our algorithm works by propagating constraints about the mis along the @xmath155-tree .",
    "each non - trivial component is solved on the way up by means of a reduction of its constraints to 2-sat ( which _ is _ polynomial - time solvable ) . in the following ,",
    "we describe how the @xmath155-treeis built over @xmath16 .",
    "it is followed by an informal presentation of the algorithm ",
    "due to the lack of space , the formal algorithm has been moved to appendix  [ sec : pseudo ] and its proof is presented in appendix  [ sec : bigproof ] .",
    "* decomposition of @xmath16 .",
    "* in the context of this section , we call _ biconnected component _ ( or simply _ component _ ) in @xmath16 a maximal subgraph @xmath156 such that the removal of any node in @xmath26 does not disconnect @xmath26 ( i.e.@xmath26 is @xmath157-_vertex_-connected ) . by abuse of notation , we write @xmath158 if @xmath39 is a vertex of the subgraph @xmath26 .",
    "we consider here a mix of the so - called block - cut tree and bridge tree and refer to it as the _ @xmath155-tree_. let @xmath159be the set of biconnected components of @xmath16 ( see figure  [ fig : ex_compo ] for an illustration )",
    ".     decomposition of a graph into biconnected components ( left ) and the corresponding @xmath155-tree(right ) .",
    "nodes with shapes  @xmath160 and  @xmath161 correspond respectively to pendant vertices ( @xmath162 ) and articulation points ( @xmath163 ) .",
    "nodes with shape  @xmath164 correspond to bridge edges ( @xmath165 ) , and nodes with shape  @xmath166 show components that contain at least @xmath45 vertices ( @xmath167 ) .",
    ", title=\"fig : \" ]   decomposition of a graph into biconnected components ( left ) and the corresponding @xmath155-tree(right ) .",
    "nodes with shapes  @xmath160 and  @xmath161 correspond respectively to pendant vertices ( @xmath162 ) and articulation points ( @xmath163 ) . nodes with shape  @xmath164 correspond to bridge edges ( @xmath165 ) , and nodes with shape  @xmath166 show components that contain at least @xmath45 vertices ( @xmath167 ) .",
    ", title=\"fig : \" ]    two adjacent components either share a common articulation point or they are linked by a bridge . for instance , node @xmath168 in figure  [ fig : ex_compo ] is common to components @xmath169 and @xmath109 , and edges @xmath170 and @xmath171 are bridges between @xmath15 and @xmath169 , and @xmath169 and @xmath172 respectively .",
    "let @xmath173be the set of all articulation points ( whether or not they are shared ) and @xmath174the set of bridges .",
    "let @xmath175be the set of all pendant vertices , which form singleton components  in figure  [ fig : ex_compo ] , @xmath176 .",
    "finally , let @xmath177be the set of components that contain three or more vertices@xmath178 .",
    "remark that if @xmath177is empty , then @xmath16 is acyclic .",
    "the @xmath9 decomposition ( or @xmath155-tree ) of @xmath16 , is the graph @xmath179 such that @xmath180 and @xmath181 is defined by the two following rules : @xmath182 @xmath183 , @xmath184 , @xmath185 if and only if @xmath186 ; and @xmath187 @xmath188 , @xmath189 and @xmath190 .",
    "figure  [ fig : ex_compo ] ( right side ) shows the @xmath155-treecorresponding to the graph of the left side",
    ".    * algorithm . *",
    "the algorithm works on @xmath191 , the @xmath155-treemade over the four sets @xmath173 , @xmath174 , @xmath177 , and @xmath175with respect to @xmath16 .",
    "if the set @xmath177is empty , it means that @xmath16 is acyclic . in that case",
    ", @xmath16 trivially admits an rmis , which is returned by the algorithm . otherwise ( @xmath192 ) , a component vertex @xmath193 is arbitrarily selected to be the root of @xmath191 , denoted by @xmath194 .",
    "then , the classical concepts in oriented trees , such as _ children _ , _ parent _ , _ descendant _ , _ subtree _ , or _ leaf _ apply to the vertices of @xmath191 . for ease of reading , we abuse the term `` _ admit _ '' by saying that a subtree @xmath195 of @xmath191``_admits an rmis _ ''",
    "if the subgraph of @xmath16 corresponding to @xmath195 admits an rmis .    at the higher level , the algorithm proceeds within two phases . based on @xmath191 , the first one is called the _ labeling _ phase . initiated from the leaves of the tree , it evaluates whether the subgraph of @xmath16 corresponding to the current subtree admits a robust mis or not and labels each subtree according to that . if it does admit an rmis , it may impose some constraints about the membership of the higher nodes . for instance , a robust mis of the subtree may exist only if the articulation point leading up to the parent belongs to it",
    ". then , the goal of the labeling phase consists of propagating ( and memorizing within labels ) such constraints up through subtle interactions among the various types of vertices ( namely , pendant nodes , articulation point , bridge , or component ) leading up to the root . besides",
    ", the inner topological configuration of a single component may also impose non - trivial constraints for the existence of a robust mis .",
    "intuitively , it must have properties that relate to ( but are slightly more complex than ) bipartiteness .",
    "the second ( short ) phase of the algorithm is called the _ deciding _ phase .",
    "it simply consists of deciding whether the graph admits a robust mis or not considering the label of the root of the @xmath155-tree .    *",
    "labeling phase .",
    "* as already mentioned , a given subtree @xmath195 of @xmath191may or may not admit an rmis .",
    "intuitively , the global decision depends on topological contraints , established over @xmath195 .",
    "obviously , those constraints influence the possible topological organization of a global rmis toward the parent of @xmath195 .",
    "so , this mecanism involves in a crucial way the unique @xmath196 such that @xmath197 through which @xmath195 is connected to the remainder of @xmath191 . in the following @xmath48 is called the _ attachment point _ of @xmath195 . in other words and more conveniently , the attachment point of the root @xmath198 of @xmath195 is either @xmath198 itself if @xmath199 or the parent of @xmath198 if @xmath200 .",
    "for instance , in figure  [ fig : ex_compo ] , assuming that @xmath194is the component vertex m , then , @xmath201 is the attachment point of itself ( @xmath202 ) , @xmath203 is the one of both @xmath204 and @xmath171 , while @xmath168 is the attachment point of @xmath205 ( @xmath165 ) , @xmath109 ( @xmath167 ) , and itself ( @xmath206 .",
    "constraint transmission takes place from the leaves to the root by tagging each vertices with the following labels : for possibly in(meaning that @xmath195 admits an rmis that includes @xmath48 , the attachment point of @xmath195 ) ; for possibly out(meaning that @xmath195 admits an rmis that does not include @xmath48 ) ; for possibly external(meaning that @xmath195 is not tagged , and it admits an rmis that does not include @xmath48 assuming that another node @xmath207 , external to @xmath195 belongs to the rmis ) ; and for negative(meaning that none of the three other tags is applicable to @xmath195 ) .",
    "an extra label , is used at the root ( see below ) . note that the algorithm associates to each label a set of vertices that is used to store a robust mis of @xmath195 satisfying the constraint of the label . also , remark",
    "that and are mutually exclusive .",
    "furthermore , a vertex can be tagged with more than a single tag , namely either and ( together ) , or and ( together ) .",
    "the analysis consists of recursively tagging each vertex @xmath208 from the leaves to the root .",
    "let us first consider @xmath18 as a leaf .",
    "there are two cases : either @xmath209 or @xmath210 . in the former case , @xmath18 is tagged with both and .",
    "( indeed , @xmath18 being a pendant node , @xmath18 can or can not be in the rmis depending or its unique neighbor . ) for instance , in figure  [ fig : ex_compo ] , assuming that @xmath211 , the vertices @xmath201 , @xmath212 , and @xmath213 are tagged and .",
    "if @xmath210 , then the algorithm checks whether @xmath18 must be tagged , , , or .",
    "for instance , in the same example , @xmath60 is tagged and .",
    "indeed , @xmath60 is a square ( sub)graph ( refer to figure  [ fig : ex_compo ] ) and its attachment point is @xmath214 .",
    "clearly , it admits two possible rmiss : either @xmath215 or @xmath216 . in former case , @xmath214 does not belong to the rmis ( implying the label of type ) ; in the latter , @xmath214 belongs to the rmis ( implying the label of type ) .",
    "the actual finding is solved through reduction to the 2-sat problem described below .    from now on , consider that @xmath18 is an internal vertex ( i.e.@xmath217 ) .",
    "provided that none of its descendants is tagged , an internal vertex @xmath208 is analyzed according of its type ( whenever a vertex has two tags , each corresponding rule is applied ) as follows .",
    "consider first the case where @xmath218 .",
    "if its ( unique ) descendant @xmath39 is tagged , then @xmath18 is tagged ; if @xmath39 is tagged , then @xmath18 is tagged ; if @xmath39 is tagged , then @xmath18 is tagged , and if possible ( @xmath18 is not already tagged ) , also . in the example ( figure  [ fig : ex_compo ] ) , the vertices @xmath219 , @xmath220 , and @xmath221 are all tagged and .",
    "when @xmath222 , let @xmath223 be the set of descendant vertices of @xmath18 .",
    "if every vertex @xmath224 is tagged , then @xmath18 is also tagged ; if every vertex @xmath224 is tagged , then @xmath18 is also tagged ; if every vertex @xmath224 is tagged either or and there exists @xmath225 tagged , then @xmath18 is tagged .",
    "for instance , vertices @xmath45 , @xmath226 , and @xmath227 are all tagged and .    if @xmath228 , then , as for the leaves , @xmath18 is analysed using the 2-sat reduction described below .",
    "however , by contrast with a leaf vertex , the analysis introduces extra clauses to the 2-sat expression , according to the labels of its descendants .    if @xmath229 ( @xmath167 ) , then the algorithm operates the last 2-sat reduction that checks the existence of an rmis , again accoring to the labels of its descendants .",
    "@xmath194is then tagged either with ( @xmath16 admits no rmis ) or with ( @xmath16 admits at least one rmis ) .    *",
    "testing a component vertex . *",
    "the finding process is mainly based on the resolution of a 2-sat expression .",
    "let us first consider an internal @xmath44 component  leaf and root components are special cases that are addressed later .",
    "the procedure first consider @xmath230 that is equal to @xmath44 to which edges linking vertices both tagged are removed .",
    "doing so , @xmath230 may be split into several components .",
    "if @xmath230 is not bipartite , then the component is tagged with .",
    "otherwise , for each maximal connected component @xmath231 , one part of the bipartition is arbitrarily chosen in which each vertex @xmath18 ( @xmath232 ) is labelled with a label @xmath233 equal to @xmath234 .",
    "the vertices of the other part are labelled @xmath235 .",
    "all those labels form a 2-sat expression to which the tags coming up from the subtrees are included .",
    "for instance , a node @xmath222 that is tagged forces the label @xmath233 of the corresponding vertex @xmath236 to true . also , the edge @xmath237 that was removed from @xmath44 to @xmath230 also forces the labels corresponding to @xmath39 and @xmath18 to be mutually exclusive ( @xmath238 ) , meaning that at most one of the two can be included into the rmis , but not both .",
    "since a vertex of @xmath191can be tagged with one or two tags , the satisfiability of the 2-sat expression is evaluated assuming first that the attachment point @xmath48 of @xmath44 belongs to the rmis ( tag  , @xmath239 ) .",
    "next , it is evaluated assuming that the attachment point @xmath48 of @xmath44 does not belong to the rmis ( tag  , @xmath240 ) .",
    "if @xmath44 could not be tagged ( i.e.the expression could not be satisfied assuming @xmath240 ) , then it can still be tagged .",
    "this is done by temporarily adding an aerial @xmath241 at the attachment point @xmath48 of @xmath44 ( i.e.a virtual extra vertex @xmath242 with the corresponding edge @xmath243 ) and repeating the whole above process with @xmath244 .",
    "note this process is also performed at the leaves and at the root ( @xmath245 )",
    ". however , in both cases , the process is simpler . indeed ,",
    "since the leaves have no descendant , it is sufficient to check whether @xmath44 is bipartite or not . for the root ( that has no attachment point )",
    ", it is sufficient to check whether the 2-sat expression is satisfied or not .    * deciding phase .",
    "* this phase simply consists in testing the label of @xmath194(attributed in the labeling phase ) .",
    "if @xmath194is labeled with , the algorithm rejects .",
    "otherwise ( @xmath194is labeled with ) , the algorithm returns the set associated to the label of @xmath194that is a robust mis of @xmath16 thanks to the work done in the labeling phase .",
    "this paper is dedicated to showing the actual impact of robustness in highly dynamic distributed systems .",
    "a property is robust if and only if it is satisfied in every connected spanning subgraphs of a given graph .",
    "focusing on the minimal independent set ( mis ) problem , we proved the existence of a significant complexity gap between graphs where _ all _ mis are robust ( building a robust mis is then a _ local _ problem ) and graphs where _ some _ mis are robust ( building a robust mis is then a _ global _ problem ) .",
    "we are convinced that robustness is a key property of highly dynamic systems to achieving stable structures in such unstable environments .",
    "the complete characterization of the class @xmath10is left open , as well as the study of similar symmetry breaking tasks .",
    "[ [ proof - of - lemmalembk ] ] * proof of lemma  [ lem : bk ] * + + + + + + + + + + + + + + + + + + + + + + + + +    ( _ all miss are robust in complete bipartite graphs . _ )    there are two ways of chosing an mis in a complete bipartite graph @xmath246 , namely @xmath34 or @xmath35 . without loss of generality ,",
    "assume @xmath34 is chosen .",
    "then , in any connected spanning subgraph of @xmath16 , every node in @xmath35 has at least one neighbor in @xmath34 ( the graph is bipartiteness ) .",
    "so the mis remains maximal .",
    "( independence is not affected , as discussed in section  [ sec : definitions ] . )",
    "[ [ proof - of - lemmalemsputniks ] ] * proof of lemma  [ lem : sputniks ] * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    ( _ all miss are robust in sputnik graphs .",
    "_ )    by definition , any removable edge in a sputnik graph belongs to a cycle , thus both of its endpoints have a pendant neighbor . on the other hand",
    ", it holds that a pendant node either is in the mis , or its neighbor must be ( thanks to maximality ) . as a result , after an edge is removed , both of its endpoints remain covered by the mis , i.e.either they are in the mis or their pendant neighbor is , which preserves maximality .    [ [ proof - of - theoremthlocalityforall ] ] * proof of theorem  [ th : localityforall ] * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    ( _ robustmisis @xmath63-local in class @xmath6 .",
    "_ )    ( lower bound ) : if one can solve robustmisin @xmath6looking at distance @xmath247 , then as a special case , one solves regular mis in paths ( indeed , rmiss are miss , and paths are trees , which are sputniks , which all belong to @xmath6 ) .",
    "then , one can convert the resulting mis into a @xmath45-coloring as follows : each node in the mis takes color @xmath21 , then at most two nodes lie between these nodes .",
    "the one with smallest identifier takes color @xmath157 and the other takes color @xmath45 . finally , it is well known that linial s @xmath62 lower bound for @xmath45-coloring  @xcite in cycles extends to paths ( within an additive constant ) , which gives the desired contradiction .",
    "xx : = xx = 01 : collect the information available within distance @xmath45 from @xmath18 in @xmath248 + 02 : * if * @xmath248 is a complete bipartite graph with no outgoing edges towards nodes not in @xmath248 * then * + 03 : set @xmath249 as the node with the lowest identifier of @xmath248 + 04 : terminate outputting @xmath250 if @xmath18 is in the same part as @xmath249 , @xmath251 otherwise + 05 : * if * @xmath18 is a pendant node * then * + 06 : terminate outputting @xmath250 + 07 : * if * @xmath18 has a pendant neighbor * then * + 08 : terminate outputting @xmath251 + 09 : set @xmath252 as the set of outgoing edges of @xmath18 towards nodes that have a pendant neighbor + 10 : execute the mis algorithm from  @xcite ignoring edges of @xmath252    ( upper bound ) : let @xmath11 be a graph in @xmath6 . we will prove that algorithm [ algo : rmis ] computes a regular mis ( which by definition is robust ) in @xmath16 .",
    "all nodes first gather information within distance three ( line 1 ) and decides if the graph is complete bipartite ( line 2 ) .",
    "three hops are sufficient because all the nodes in a complete bipartite graph are at most at distance 2",
    ". both parts of the test ( bipartiteness and completeness ) are trivial . if the test is positive , then all nodes which are in the same part as the smallest identifier output in , the others out ( lines 3 and 4 ) . since @xmath16 is bipartite , the set of nodes outputting @xmath250 is independent , and since @xmath16 is complete , it is maximal . now , if the graph is not complete bipartite , then it is a sputnik ( theorem [ th : forallmis ] ) .",
    "let us partition the set of nodes of @xmath16 into three parts ( refer to figure [ fig : lnf ] for an illustration ) : the set @xmath27 of pendant nodes in @xmath16 ( i.e. nodes of degree one ) , the set @xmath60 of nodes with at least one neighbor in @xmath27 , and the set @xmath253 of the nodes which are neither in @xmath27 or in @xmath60 .",
    "observe that it is easy for a node to determine which of the sets it belongs to , based on the ( @xmath45-hop ) information it already has .",
    "furthermore , two neighbors can not be in @xmath27 , since this would imply a single - edge graph that would then be classified as complete bipartite in the previous step .",
    "then , nodes in @xmath27 terminate outputting @xmath250 ( line 6 ) and nodes in @xmath60 terminate outputting @xmath251 ( line 8) .",
    "the crucial step is that the subgraph of @xmath16 induced by the nodes of @xmath61 ( denoted @xmath254 in the following ) is a forest due to the definition of a sputnik .",
    "indeed , by definition , any node involved in a cycle has at least a pendant neighbor and thus belong to @xmath60 .",
    "furthermore , these nodes impose no constraint onto the remaining nodes in @xmath61 since they are _ not _ in the mis , and yet , they do not need additional neighbors to be . as a result ,",
    "the edges between @xmath61 and @xmath60 can be ignored ( line 9 ) and a generic mis algorithm be executed on the induced forest @xmath254 .",
    "one such algorithm  @xcite , dedicated to graphs of bounded arboricity ( which the case of @xmath254 ) requires looking only within @xmath8 hops .",
    "note that variable @xmath0 in this formula corresponds to the number of nodes in @xmath254 , which is dominated by @xmath255 .",
    "finally , we will prove that the produced mis is valid in @xmath16 .",
    "let us call @xmath109 this mis , and @xmath256 the mis produced by algorithm  @xcite on @xmath254 .",
    "then clearly @xmath257 ( all nodes in @xmath60 output @xmath251 ) .",
    "@xmath109 is independent since @xmath182 @xmath258 is independent in @xmath254 ( and thus in @xmath16 ) ; @xmath187 no node in @xmath61 is neighbor to a node in @xmath27 ( by construction ) ; and @xmath259 no two nodes of @xmath27 are neighbors ( as already discussed ) . as to the maximality ,",
    "if there exists an independent set @xmath260 for some @xmath39 in @xmath261 , then @xmath39 must belong to either @xmath262 or @xmath61 .",
    "being in @xmath27 is not possible since all nodes in @xmath27 are already in @xmath109 .",
    "being in @xmath60 contradicts independence of @xmath263 since any node in @xmath60 is neighbor to at least one node in @xmath27 ( that belongs to @xmath109 ) .",
    "finally , being in @xmath61 contradicts the fact that @xmath258 is maximal , which concludes the proof .",
    "* input : * a graph @xmath11 + * output : * a robust mis of @xmath16 if @xmath16 admits one , @xmath264 otherwise    xx : =",
    "xx = xx = xx = xx = xx = xx = xx = 01 : build @xmath265 be the @xmath155-treeof @xmath16 + 02 : * if * @xmath266 * then * + 03 : build a 2-coloring of @xmath16 + 04 : return one non empty maximal set of nodes of",
    "@xmath12 sharing the same color + 05 : let @xmath267 ( arbitrarily choosen ) + 06 : root @xmath191towards @xmath198 + 07 : let @xmath268 be the set of children in @xmath191of each @xmath269 + 08 : let @xmath270 be the parent in @xmath191of each @xmath271 + 09 : associate an empty set of labels @xmath272 to each @xmath269 + ( a label is a couple @xmath273 with type @xmath274 and @xmath275 ) + 10 : * foreach * @xmath276 * do * + 11 : * * labelsubtree**@xmath277 + 12 : * if * @xmath278 for a @xmath276 * then * + 13 : @xmath279 + 14 : * else * + 15 : @xmath280**testrmis**@xmath281 + 16 : * if * @xmath282 * then * + 17 : @xmath279 + 18 : * else * + 19 : @xmath283 + 20 : * if * @xmath284 * then * + 21 : return @xmath264 + 22 : * else * + 23 : return the set of the label of type of @xmath285    * parameters : * an @xmath155-tree@xmath191and a node @xmath48 of @xmath191 + * return : * none    xx : = xx = xx = xx = xx = xx = xx = xx = 01 : * foreach * @xmath286 * do * + 02 : * * labelsubtree**@xmath277 + 03 : * if * @xmath278 for a @xmath286 * then * + 04 : @xmath287 + 05 : * else * + 06 : * if * @xmath288 * then * + 07 : * * labelnodea**@xmath289 + 08 : * if * @xmath290 * then * + 09 : * * labelnodeb**@xmath289 + 10 : * if * @xmath291 * then * + 11 : * * labelnodec**@xmath289 + 12 : * if * @xmath292 * then * + 13 : @xmath293    * parameters : * an @xmath155-tree@xmath191and a node @xmath294 of @xmath191 + * return : * none    xx : = xx = xx = xx = xx = xx = xx = xx = 01 : * if * @xmath295 contains a label @xmath296 for each @xmath286 * then * + 02 : @xmath297 + 03 : * if * @xmath295 contains a label @xmath298 for each @xmath286 * then * + 04 : @xmath299 + 05 : * if * @xmath295 contains a label @xmath300 or @xmath298 for each @xmath286 + * and * @xmath295 contains a label @xmath300 for a @xmath286 * then * + 06 : @xmath301    * parameters : * an @xmath155-tree@xmath191and a node @xmath302 of @xmath191 + * return : * none    xx : = xx = xx = xx = xx = xx = xx = xx = 01 : * if * @xmath295 contains a label @xmath296 * then * + 02 : @xmath303 + 03 : * if * @xmath295 contains a label @xmath300 * then * + 04 : @xmath304 + 05 : * if * @xmath295 contains a label @xmath298 * then * + 06 : @xmath305    * parameters : * an @xmath155-tree@xmath191and a node @xmath291 of @xmath191 + * return : * none    xx : = xx = xx = xx = xx = xx = xx = xx = 01 : @xmath280**testrmis**@xmath306 + 02 : * if * @xmath307 * then * + 03 : @xmath308 + 04 : @xmath280**testrmis**@xmath309 + 05 : * if * @xmath307 * then * + 06 : @xmath310 + 07 : * else",
    "* + 08 : @xmath311 + 09 : @xmath280**testrmis**@xmath312 + 10 : * if * @xmath307 * then * + 11 : @xmath313 + 12 : @xmath314 + 13 : * if * @xmath315 * then * + 14 : @xmath287    * parameters : * an @xmath155-tree@xmath191 , a node @xmath291 of @xmath191and two subsets @xmath250 and @xmath251 of @xmath177 + * return : * @xmath316 or a subset of the set of nodes of the subgraph of @xmath16 induced by @xmath48    xx : = xx = xx = xx = xx = xx = xx = xx = 01 : let @xmath44 be the subgraph of @xmath16 induced by @xmath48 + 02 : let @xmath317 be the set of edges @xmath237 of @xmath44 such that @xmath318 and @xmath319 contain both + a label of type + 03 : * if * @xmath320 is not bipartite * then * + 04 : return @xmath316 + 05 : let @xmath321 be the maximal connected components of @xmath320 + 06 : let @xmath61 be an empty @xmath157-sat expression on the set of boolean variables @xmath322 + 07 : * foreach * @xmath323 * do * + 08 : label each node @xmath324 with @xmath325 or @xmath326 such that two neighbors in @xmath231 + do not have the same label + 09 : * foreach * @xmath327 such that @xmath328 * do * + 10 : * if * @xmath329 is reduced to one label of type * then * + 11 : @xmath330 + 12 : * if * @xmath329 is reduced to one label of type or * then * + 13 : @xmath331 + 14 : * foreach * @xmath332 * do * + 15 : @xmath333 + 16 : * foreach * @xmath334 * do * + 17 : @xmath335 + 18 : * foreach * @xmath336 * do * + 19 : @xmath337 + 20 : * if * @xmath61 does not have an satisfying assignment * then * + 21 : return @xmath316 + 22 : * else * + 23 : let @xmath338 be an satisfying assignment of @xmath61 + 24 : @xmath339 + 25 : return @xmath340 where + @xmath341 is the set of the label of type of @xmath295 if @xmath342 , + the set of the label of type or of @xmath295 if @xmath343",
    "we consider that we apply * findrmis * to a graph @xmath11 whose @xmath155-treeis @xmath265 .",
    "the objective of this section is to prove that * findrmis * terminates in a polynomial time and returns a robust mis of @xmath16 if this latter admits one , @xmath264 otherwise .",
    "our proof contains mainly three steps .",
    "first ( section [ sub : prooftree ] ) , we prove that * findrmis * returns a robust mis of @xmath16 whenever @xmath16 is a tree .",
    "once this trivial case eliminated , we define a set of notations and definitions in section [ sub : proofnotations ] .",
    "these notations are used in the sequel of the proof .",
    "then , we prove central properties provided by function * testrmis * ( section [ sub : testrmis ] ) and by functions * labelnode * ( section [ sub : labelnode ] ) .",
    "we use these properties to prove that the execution of * findrmis * up to line 19 produces a well - labeling of @xmath191(in a sense defined below ) in section [ sub : prooflabelling ] .",
    "finally , we prove that * findrmis * uses this well - labelling of @xmath191to return a robust mis if @xmath16 admits one , @xmath264 otherwise ( section [ sub : proofbuilding ] ) .",
    "[ lem : findrmistree ] if @xmath16 is a tree , * findrmis * terminates in polynomial time and returns a robust mis of @xmath16 .",
    "assume that @xmath16 is a tree .",
    "line 01 of * findrmis * build the @xmath155-treeof @xmath16 ( that take a polynomial time in the size of @xmath16 ) .",
    "then , the test on line 02 is true ( since any biconnected component of a tree has a size of 1 ) and * findrmis * returns a non empty set of nodes that share the same color in a 2-coloring of @xmath16 ( computed in a polynomial time ) on line 04 .",
    "note that this set is trivially a mis of the tree @xmath16 and hence a robust mis of @xmath16 since any tree belongs to @xmath6(see theorem [ th : forallmis ] ) .      in the following of the proof , according to lemma [ lem : findrmistree ] , we restrict our attention to the case where the graph analysed by * findrmis * is not a tree .",
    "we define in the following a set of notations used in the proof .    the @xmath155-treeof @xmath16 is now rooted towards a node @xmath267 .",
    "first , we denote by @xmath344 the @xmath155-subtreeof @xmath191rooted to a node @xmath269 . for any node @xmath269",
    ", we denote its set of children in @xmath191by @xmath268 . for any node @xmath271",
    ", we denote its parent in @xmath191by @xmath270 and its attachment point ( @xmath48 if @xmath345 , @xmath270 otherwise ) by @xmath346 .    for any node @xmath269",
    ", we say that @xmath48 induces the subgraph @xmath347 of @xmath16 defined as follows . if @xmath345 , then @xmath348 and @xmath349 . if @xmath350 , then @xmath351 and @xmath352 .",
    "if @xmath353 , then @xmath354 and @xmath355 . then , we define the subgraph of @xmath16 induced by @xmath356 as @xmath357 and the aerial subgraph of @xmath16 induced by @xmath356 as @xmath358 @xmath359 with @xmath360 .",
    "the algorithm * findrmis * associates a set of labels @xmath272 to each node @xmath269 .",
    "a label is a couple @xmath273 with type @xmath274 and @xmath275 .",
    "we are now in measure to introduce the main definitions on which relies our proof .",
    "[ def : welllabeledabcst ] given a node @xmath361 , the @xmath155-subtree@xmath362 is well - labeled if the following properties hold for any node @xmath363 :    1 .",
    "@xmath364 if and only if @xmath365 does not admit a robust mis and @xmath366 does not admit a robust mis including @xmath367 2 .",
    "@xmath272 contains @xmath368 with @xmath109 a robust mis of @xmath365 including @xmath346 if and only if @xmath365 admits such a mis .",
    "3 .   @xmath272 contains @xmath369 with @xmath109 a robust mis of @xmath365 not including @xmath346 if and only if @xmath365 admits such a mis .",
    "4 .   @xmath272 contains @xmath370 with @xmath109 a robust mis of @xmath366 including @xmath367 if and only if @xmath366 admits such a mis and @xmath365 does not admit a robust mis not including @xmath346 .",
    "[ def : welllabeledabct ] the @xmath155-tree@xmath371 is well - labeled if the following properties hold :    1 .",
    "@xmath372 with @xmath109 a robust mis of @xmath16 if and only if @xmath16 admits such a mis .",
    "2 .   @xmath284 if and only if @xmath16 does not admit a robust mis .      in this section",
    ", we prove the main technical part of the algorithm .",
    "roughly speaking , we prove that the function * testrmis * applied to any node of @xmath373 is able to determine if the @xmath155-subtreerooted to this node admits a robust mis or not and to compute one such mis .",
    "we need four lemmas depending on the parameters of the function .",
    "[ lem : testrmis1 ] for any node @xmath374 such that , for each @xmath18 of @xmath268 , @xmath362 is well - labeled , @xmath319 does not contain a label of type , and @xmath375 , * * testrmis**@xmath306 returns ( in polynomial time ) :    * @xmath316 if @xmath365 does not admit a robust mis including @xmath270 ; * @xmath109 otherwise ( with @xmath109 such a mis ) .",
    "let @xmath48 be a node of @xmath376 such that , for each @xmath18 of @xmath268 , @xmath362 is well - labeled , @xmath319 does not contain a label of type , and @xmath375 .",
    "first , assume that * * testrmis**@xmath306 is executed when @xmath365 does not admit a robust mis including @xmath270 .",
    "then , we are going to prove that , if the test of line 03 of * testrmis * is false , the one of line 20 of * testrmis * is true ( and hence that * testrmis * returns necessarily @xmath316 in this case ) . by contradiction , assume that @xmath61 ( build up to line 19 of * testrmis * ) admits a satisfying assignment @xmath338 .",
    "as , for each @xmath18 of @xmath268 , @xmath362 is well - labeled and @xmath319 does not contain a label of type , each @xmath377 admits a robust mis or @xmath378 admits a robust mis including @xmath367 by definition .",
    "that allows us to define the following sets :    * @xmath379 ; * for any @xmath286 such that @xmath380 in @xmath338 , @xmath381 is a robust mis of @xmath382 such that @xmath383 ; * for any @xmath286 such that @xmath384 in @xmath338 , @xmath381 is a robust mis of @xmath382 such that @xmath385 if such a mis exists , @xmath386 is a robust mis of @xmath387 otherwise .",
    "then , we are going to prove that the set @xmath388 is a robust mis of @xmath365 .",
    "note that @xmath389 ( by construction ) and @xmath390 ( thanks to the clause introduced in @xmath61 on line 17 of * testrmis * ) .",
    "independence of @xmath109 : : :    as each @xmath381 is independent and covers the articulation    point that connects    @xmath382 to    @xmath44 for each @xmath286 by construction , it    remains to prove that @xmath317 is independent .",
    "let    @xmath391 be an edge of @xmath44 .",
    "if    @xmath392 , then the clause introduced in @xmath61 on    line 15 of * testrmis * ensures that labels of @xmath39 and    @xmath18 can not be simultaneously true in @xmath338 .",
    "otherwise , @xmath110 belongs to @xmath320 ( that    is bipartite ) and hence , the labeling done on line 08 of * testrmis *    ensures us that labels of @xmath39 and @xmath18 can not    be simultaneously true in @xmath338 .",
    "then , the construction of    @xmath317 guarantees its independence .",
    "maximality of @xmath109 : : :    as each @xmath381 is maximal ( in    @xmath382 or    @xmath387 depending on    the case ) for each @xmath286 by construction , it remains    to prove that @xmath317 is maximal in @xmath44 .",
    "let    @xmath393 be a node that does not belong to    @xmath109 .",
    "that implies that @xmath394 is false in    @xmath338 and then that @xmath395 is a robust mis of    @xmath396 such that    @xmath397 if such a mis exists , a robust mis of    @xmath398 such that    @xmath399 otherwise .",
    "+    in the first case , @xmath39 has a neighbor in @xmath395    by maximality of @xmath395 . in the second case ,",
    "as    @xmath400 is well - labeled by    assumption , we know that @xmath318 contains a label of type    and hence does not contains a label of type .",
    "then , no adjacent edge    to @xmath39 in @xmath44 belongs to @xmath317 . as a    consequence",
    ", @xmath39 and its neighbors belongs to the same    connected component of @xmath320 and receive opposite    labels on line 08 of * testrmis*. in both cases , @xmath39 has a    neighbor in @xmath109 , that proves its maximality .",
    "robustness of @xmath109 : : :    the robustness of @xmath109 is proved by using the following    equivalence ( proved by @xcite in the case of minimal dominating set    but easily translatable to mis ) : a mis @xmath109 of a graph    @xmath16 is robust if and only if , for any node @xmath39    not in @xmath109 , removing all edges between @xmath39 and    a node of @xmath109 disconnects @xmath16 .",
    "let    @xmath39 be a node of    @xmath365 that does not    belong to @xmath109 .",
    "+    assume first that @xmath393 .",
    "if @xmath39 has no    adjacent edge in the set @xmath317 defined in line 02 of    * testrmis * , then all its neighbors in @xmath44 belongs to    @xmath109 by the labeling done on line 08 of * testrmis*. by    definition of a biconnected component , the removing of all edges    between @xmath39 and its neighbors in @xmath44    deconnects @xmath16 .",
    "otherwise ( i.e.@xmath39 has at    least one adjacent edge in the set @xmath317 ) , that means that    @xmath318 contains a label of type .",
    "as    @xmath400 is well - labeled by    assumption , we know that @xmath395 is a robust mis of    @xmath396 such that    @xmath397 . by robustness of @xmath395 on    @xmath396 , we know that the    removing of all edges between @xmath39 and its neighbors of    @xmath396 in    @xmath395 deconnects    @xmath396 ( hence    @xmath16 ) .",
    "+    assume now that @xmath401 .",
    "the result is easily proved    by the robustness of @xmath381 where @xmath402 is the    child @xmath48 such that    @xmath403 .",
    "the set @xmath109 is hence a robust mis of @xmath365 such that @xmath390 , that contradicts the assumption that @xmath365 does not admit such a mis . in conclusion ,",
    "* * testrmis**@xmath306 returns @xmath316 if @xmath365 that does not admit a robust mis @xmath109 such that @xmath390 .",
    "second , assume that @xmath365 admits a robust mis @xmath109 such that @xmath390 .",
    "if two neighbors @xmath39 and @xmath18 of @xmath44 do not belongs to @xmath109 , then the edge @xmath237 belongs to the set @xmath317 defined in line 02 of * testrmis * ( otherwise , we obtain a contradiction with the maximality of @xmath109 ) .",
    "then , the subgraph @xmath320 is bipartite ( one partition is @xmath404 , the other is @xmath405 ) and hence * testrmis * does not return @xmath316 on line 04 . as we can deduce a satisfying assignment to the 2-sat formula",
    "( build up to line 19 ) from @xmath109 ( it is sufficient to assign all @xmath234 @xmath323 to have @xmath406 ) , we can deduce that * testrmis * does not return @xmath316 on line 21 . in conclusion ,",
    "* testrmis * returns a set @xmath109 on line 25 . we know , by the construction of this set and by the proof of the first case , that @xmath109 is a robust mis of @xmath365 such that @xmath390 .    to conclude the proof ,",
    "note that all instructions of * testrmis * are polynomial in the size of @xmath44 and are repeated at most @xmath407 times , that implies that the running time of * testrmis * is polynomial in the size of @xmath16 .",
    "the three following lemmas shows similar results depending on the parameters of the function *",
    "testrmis*. their proofs are similar to the previous one .",
    "[ lem : testrmis2 ] for any node @xmath374 such that , for each @xmath18 of @xmath268 , @xmath362 is well - labeled , @xmath319 does not contain a label of type , and @xmath375 , * * testrmis**@xmath309 returns ( in polynomial time ) :    * @xmath316 if @xmath365 does not admit a robust mis not including @xmath270 ; * @xmath109 otherwise ( with @xmath109 such a mis ) .",
    "[ lem : testrmis3 ] for any node @xmath374 such that , for each @xmath18 of @xmath268 , @xmath362 is well - labeled , @xmath319 does not contain a label of type , and @xmath408 , * * testrmis**@xmath312 returns ( in polynomial time ) :    * @xmath316 if @xmath366 does not admit a robust mis including @xmath367 ; * @xmath409 otherwise ( with @xmath109 such a mis ) .",
    "[ lem : testrmis4 ] if , for each @xmath18 of @xmath410 , @xmath362 is well - labeled , @xmath319 does not contain a label of type , * * testrmis**@xmath281 returns ( in polynomial time ) :    * @xmath316 if @xmath16 does not admit a robust mis ; * @xmath109 otherwise ( with @xmath109 such a mis ) .      in this section , we prove that each of the three functions * labelnode * produces a well - labeled @xmath155-subtreerooted on a node @xmath48 provided that all @xmath155-subtreerooted on children of @xmath48 are well - labeled .",
    "[ lem : articulation ] for any node @xmath294 such that , for each @xmath18 of @xmath268 , @xmath362 is well - labeled and @xmath319 does not contain a label of type , @xmath356 is well - labeled after the execution ( in polynomial time ) of * * labelnodea**@xmath289 .",
    "observe that , for any node @xmath294 , we have the following properties by definition of an articulation point :    * @xmath365 does not admit a robust mis and @xmath366 does not admit a robust mis including @xmath367 if and only if there exists at least one child @xmath286 such that @xmath382 does not admit a robust mis and @xmath387 does not admit a robust mis including @xmath367 .",
    "* @xmath365 admits a robust mis including @xmath346 if and only if , for every child @xmath286 , @xmath382 admits a robust mis @xmath381 including @xmath411 .",
    "moreover , @xmath412 is such a mis of @xmath365 .",
    "* @xmath365 does not admit a robust mis not including @xmath413 and @xmath366 admits a robust mis including @xmath414 if and only if , for every child @xmath286 , @xmath382 does not admit a robust mis not including @xmath411 and @xmath387 admits a robust mis @xmath381 including @xmath367 .",
    "moreover , @xmath412 is such a mis of @xmath366 .",
    "* @xmath365 admits a robust mis not including @xmath413 if and only , for every child @xmath286 , @xmath382 admits a robust mis @xmath381 not including @xmath411 or @xmath387 admits a robust mis including @xmath367 and there exists at least one child @xmath286 such that @xmath382 admits a robust mis @xmath381 including @xmath411 .",
    "moreover , @xmath412 is such a mis of @xmath365 .",
    "let @xmath48 be a node of @xmath415 such that , for each @xmath18 of @xmath268 , @xmath362 is well - labeled and @xmath319 does not contain a label of type .",
    "then , note that the construction of * labelnodea * is strictly based on the previous set of properties , implying that @xmath356 is well - labeled after the execution of * * labelnodea**@xmath289 .    to conclude the proof ,",
    "note that all tests of * labelnodea * are performed in polynomial time ( since the size of the set of children is bounded by the size of @xmath16 ) , hence * labelnodea * terminates in a polynomial time .",
    "[ lem : bridge ] for any node @xmath416 with @xmath417 such that @xmath362 is well - labeled and @xmath319 does not contain a label of type , @xmath356 is well - labeled after the execution ( in constant time ) of * * labelnodeb**@xmath289 .    observe that , for any node @xmath416 with @xmath417 , we have the following properties by definition of a bridge :    * @xmath365 does not admit a robust mis and @xmath366 does not admit a robust mis including @xmath367 if and only if @xmath377 does not admit a robust mis and @xmath378 does not admit a robust mis including @xmath367 .",
    "* @xmath365 admits a robust mis including @xmath346 if and only @xmath377 does not admit a robust mis including @xmath418 and @xmath378 admits a robust mis @xmath419 including @xmath367 or @xmath377 admits a robust mis @xmath420 not including @xmath418 .",
    "moreover , @xmath421 and @xmath422 are respectively such a mis of @xmath365 .",
    "* @xmath365 admits a robust mis not including @xmath346 if and only @xmath377 admits a robust mis @xmath420 including @xmath418 .",
    "moreover , @xmath420 is such a mis of @xmath365 .",
    "* @xmath365 does not admit a robust mis not including @xmath346 and @xmath366 admits a robust mis including @xmath367 if and only if @xmath377 admits a robust mis @xmath420 not including @xmath423 .",
    "moreover , @xmath420 is such a mis of @xmath365 .",
    "let @xmath48 be a node of @xmath424 with @xmath417 such that @xmath362 is well - labeled and @xmath319 does not contain a label of type .",
    "then , note that the construction of * labelnodeb * is strictly based on the previous set of properties , implying that @xmath356 is well - labeled after the execution of * * labelnodeb**@xmath289 .    to conclude the proof ,",
    "note that all tests of * labelnodeb * are performed in constant time , hence * labelnodeb * terminates in a constant time .",
    "[ lem : component ] for any node @xmath374 such that , for each @xmath18 of @xmath268 , @xmath362 is well - labeled and @xmath319 does not contain a label of type , @xmath356 is well - labeled after the execution ( in polynomial time ) of * * labelnodec**@xmath289 .",
    "this result directly follows from the definition of a well - labeled @xmath155-subtree , the construction of the function * labelnodec * , and lemmas [ lem : testrmis1 ] to [ lem : testrmis4 ] .",
    "we are now in measure to characterize the labeling made by functions * labelsubtree * and * findrmis * ( up to line 19 ) .",
    "[ lem : subtree ] for any node @xmath271 , @xmath356 is well - labeled after the execution ( in polynomial time ) of * * labelsubtree**@xmath289 .",
    "we prove this result by induction on @xmath425 , the height of the @xmath155-subtree@xmath356 .",
    "consider first a node @xmath271 such that @xmath426 .",
    "that implies that @xmath427 and that @xmath428 . if @xmath374 , the result holds by lemma [ lem : component ] . if @xmath429 , line 13 of * labelsubtree * is executed and produces a well - labeling of @xmath48 by definition of a pendant node .",
    "note that * labelsubtree * terminates in polynomial time in both cases .",
    "consider now a node @xmath430 such that @xmath431 .",
    "the execution of * labelsubtree * starts by a recursive call on each child of @xmath48 . by induction assumption ,",
    "each @xmath155-subtree@xmath432 is well - labeled in polynomial time with @xmath286 .    as @xmath365 does not admit a robust mis and @xmath366",
    "does not admit a robust mis @xmath109 such that @xmath414 if there exists one child @xmath286 such that @xmath382 does not admit a robust mis and @xmath387 does not admit a robust mis @xmath381 such that @xmath433 , the well - labeling of @xmath432 and the test on lines 03 - 04 of * labelsubtree * imply that @xmath48 is labeled @xmath434 ( in polynomial time ) in this case .",
    "then , lemmas [ lem : articulation ] , [ lem : bridge ] , and [ lem : component ] allow us to conclude that the end of the execution of * labelsubtree * ( lines 06 to 13 ) well - labels @xmath356 in polynomial time .",
    "[ lem : labeling ] if @xmath16 is not a tree , the execution of * findrmis * up to line 19 produces a well - labeled @xmath155-treeof @xmath16 in polynomial time .    by lemmas [ lem : findrmistree ] and [ lem : subtree ] ,",
    "the execution of * findrmis * on a graph @xmath16 ( that is not a tree ) up to line 11 leads in polynomial time to a well - labeling of each @xmath155-subtree@xmath432 with @xmath286 .",
    "as @xmath16 does not admit a robust mis if there exists one child @xmath286 such that @xmath382 does not admit a robust mis and @xmath387 does not admit a robust mis @xmath381 such that @xmath433 , the well - labeling of @xmath432 and the test on lines 12 - 13 of * findrmis * imply that @xmath198 is labeled @xmath434 ( in polynomial time ) in this case .",
    "then , lemma [ lem : testrmis4 ] allows us to conclude that the execution of * findrmis * up to line 19 well - labels @xmath371 in polynomial time .",
    "the execution of of * findrmis * on a graph @xmath16 returns in polynomial time a robust mis of @xmath16 if @xmath16 admits one , @xmath264 otherwise .",
    "if @xmath16 is a tree , the result directly follows from lemma [ lem : findrmistree ] .",
    "otherwise , lemma [ lem : labeling ] imply that the execution of * findrmis * up to line 19 produces a well - labeled @xmath155-treeof @xmath16 in polynomial time .",
    "then , by definition of a well - labeled @xmath155-tree , @xmath284 if and only if @xmath16 does not admit a robust mis",
    ". then , * findrmis * returns @xmath264 ( in polynomial time ) on line 21 if and only if @xmath16 does not admit a robust mis .",
    "hence , in the case where @xmath16 admits at least one robust mis , * findrmis * terminates ( in polynomial time ) on line 23 . by definition of a well - labeled @xmath155-tree ,",
    "the returned set is a robust mis of @xmath16 , that ends the proof .",
    "figure  [ fig : tagged ] shows how the @xmath155-treein figure  [ fig : ex_compo ] is tagged after completion of the labelling phase of algorithm  * findrmis*see algorithm  [ algo : findrmis ] in annexe  [ sec : pseudo ] ."
  ],
  "abstract_text": [
    "<S> we investigate a special case of hereditary property that we refer to as _ robustness_. a property is _ robust _ in a given graph if it is inherited by all connected spanning subgraphs of this graph . </S>",
    "<S> we motivate this definition in different contexts , showing that it plays a central role in highly dynamic networks , although the problem is defined in terms of classical ( static ) graph theory . in this paper </S>",
    "<S> , we focus on the robustness of _ maximal independent sets _ ( mis ) . following the above definition </S>",
    "<S> , a mis is said to be _ robust _ ( rmis ) if it remains a valid mis in all connected spanning subgraphs of the original graph . </S>",
    "<S> we characterize the class of graphs in which _ all _ possible miss are robust . </S>",
    "<S> we show that , in these particular graphs , the problem of finding a robust mis is _ local _ ; that is , we present an rmis algorithm using only a sublogarithmic number of rounds ( in the number of nodes @xmath0 ) in the @xmath1 model . on the negative side , we show that , in general graphs , the problem is not local . precisely , we prove a @xmath2 lower bound on the number of rounds required for the nodes to decide consistently in some graphs . </S>",
    "<S> this result implies a separation between the rmis problem and the mis problem in general graphs . </S>",
    "<S> it also implies that any strategy in this case is asymptotically ( in order ) as bad as collecting all the network information at one node and solving the problem in a centralized manner . motivated by this observation </S>",
    "<S> , we present a centralized algorithm that computes a robust mis in a given graph , if one exists , and rejects otherwise . </S>",
    "<S> significantly , this algorithm requires only a polynomial amount of local computation time , despite the fact that exponentially many miss and exponentially many connected spanning subgraphs may exist . </S>"
  ]
}