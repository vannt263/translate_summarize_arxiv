{
  "article_text": [
    "the handling of aggregates in logic programming ( lp ) has been the subject of intense studies in the late 80 s and early 90 s  @xcite . most of these proposals focused on the theoretical foundations and computational properties of aggregate functions in lp .",
    "the recent development of the _ answer set programming _ paradigm , whose underlying theoretical foundation is the answer set semantics @xcite , has renewed the interest in the treatment of aggregates in lp , and led to a number of new proposals @xcite . unlike many of the earlier proposals , these new efforts provide a sensible semantics for programs that makes a general use of aggregates , including the presence of _ recursion _ through the aggregates and the ability to use non - monotone aggregate functions .",
    "most of these new efforts build on the spirit of answer set semantics for lp , and some have found their way in concrete implementations .",
    "for example , the current release ( built ben / jan 13 2006 ) of dlv@xmath1 handles aggregate - stratified programs @xcite , and the system described in @xcite supports recursive aggregates according to the semantics described in  @xcite .",
    "a prototype of the aset - prolog system , capable of supporting recursive aggregates , has also been developed  @xcite .",
    "answer set semantics for lp @xcite has been one of the most widely adopted semantics for _ normal _ logic programs  i.e . ,",
    "logic programs that allow negation as failure in the body of the rules .",
    "it is a natural extension of the minimal model semantics of positive logic programs to the case of normal logic programs .",
    "answer set semantics provides the theoretical foundation for the recently emerging programming paradigm called _ answer set programming",
    "_ @xcite which has proved to be useful in several applications @xcite .    a set of atoms @xmath2 is an _ answer set _ of the program @xmath3 if @xmath2 is the minimal model of the positive program @xmath4 ( the _ reduct of @xmath3 with respect to @xmath2 _ ) , obtained by    * removing from @xmath3 all the rules whose body contains a negation as failure literal @xmath5 which is false in @xmath2 ( i.e. , @xmath6 ) ; and * removing all the negation as failure literals from the remaining rules .",
    "the above transformation is often referred to as the _ gelfond - lifschitz transformation_.    this definition of answer sets satisfies several important properties .",
    "in particular , answer sets are    * @xmath7 _ closed _ , i.e. , if an answer set satisfies the body of a rule @xmath8 then it also satisfies its head ; * @xmath9 _ supported_i.e . , for each member @xmath10 of an answer set @xmath2 there exists a rule @xmath11 such that @xmath10 is the head of the rule and the body of @xmath8 is true in @xmath2 ; * @xmath12 _ minimal_i.e .",
    ", no proper subset of an answer set is also an answer set .",
    "it should be emphasized that the properties @xmath7-@xmath12 are necessary but not sufficient conditions for a set @xmath2 to be an answer set of a program @xmath3 .",
    "for example , the set @xmath13 is not an answer set of the program @xmath14 , even though it satisfies the three properties .",
    "nevertheless , these properties constitute the main principles that guided several extensions of the answer set semantics to different classes of logic programs , such as _ extended _ and _ disjunctive _ logic programs @xcite , programs with _ weight constraint _",
    "rules @xcite , and programs with _ aggregates _ ( e.g. , @xcite ) .",
    "it should also be mentioned that , for certain classes of logic programs ( e.g. , programs with weight constraints and choice rules @xcite or with nested expressions @xcite ) , @xmath12 is not satisfied .",
    "it is , however , generally accepted that @xmath7 and @xmath9 must be satisfied by any answer set definition for any extension of logic programs .    as evident from the literature , a straightforward extension of the gelfond - lifschitz transformation to programs with aggregates leads to the loss of some of the properties @xmath7-@xmath12 ( e.g. , presence of non - minimal answer sets @xcite ) .",
    "sufficient conditions , that characterize classes of programs with aggregates for which the properties @xmath7-@xmath12 of answer sets hold , have been investigated , such as aggregate - stratification and monotonicity ( e.g. , @xcite ) .",
    "alternatively , researchers have either accepted the loss of some of the properties @xmath7-@xmath12 ( e.g. , acceptance of non - minimal answer sets @xcite ) or have _ explicitly _ introduced minimality or analogous properties as requirements in the definition of answer sets for programs with aggregates ( e.g. , @xcite ) .",
    "the various approaches for defining answer set semantics for logic programs with arbitrary aggregates differ from each other in both the languages that are considered and in the treatment of aggregates .",
    "some proposals accept languages in which aggregates , or atoms representing aggregates ( e.g. , the weight constraints in smodels - notation ) , are allowed to occur in the head of programs rules or as facts in @xcite , while this has been disallowed in other proposals @xcite .",
    "the advantage of allowing aggregates in the head can be seen in the use of choice rules and weight constraints in generate and test programs .",
    "allowing aggregates in the head can make the encoding of a problem significantly more declarative and compact .",
    "similarly , some proposals do not consider negation - as - failure literals with aggregates @xcite .",
    "the recent approaches for defining answer sets for logic programs with arbitrary aggregates can be roughly divided into three different groups .",
    "the first group can be viewed as a straightforward generalization of the work in @xcite , by treating aggregates in the same way as negation - as - failure literals .",
    "belonging to this group are the proposals in @xcite .",
    "a limitation of this approach is that it leads to the acceptance of unintuitive answer sets , in presence of recursion through aggregates .",
    "another line of work is to replace aggregates with equivalent formulae , according to some notion of equivalence , and to reduce programs with aggregates to programs for which the semantics has already been defined @xcite .",
    "a third direction is to make use of novel semantic constructions @xcite .",
    "the objective of this paper is to investigate an alternative characterization of the semantics of logic programs with unrestricted use of aggregates . in this context",
    ", aggregates are simply viewed as a syntactic sugar , representing a collection of constraints on the admissible interpretations .",
    "the proposed characterization is designed to maintain the positive properties of the most recent proposals developed to address this problem ( e.g. , @xcite ) , and to meet the following requirements :    * it should apply to programs with _",
    "arbitrary _ aggregates ( e.g. , no syntactic restrictions in the use of aggregates as well as no restrictions on the types of aggregates that can be used ) .",
    "in particular , we wish the approach to naturally support aggregates as facts and as heads of rules .",
    "* it should be as intuitive as the traditional answer set semantics , and it should extend traditional answer set semantics  i.e . , it should behave as traditional answer set semantics for programs without aggregates .",
    "it should also naturally satisfy the basic properties @xmath7-@xmath12 of answer sets .",
    "* it should offer ways to implement the semantic characterization by integrating , with minimal modifications , the definition in state - of - the - art answer set solvers , such as smodels @xcite , dlv @xcite , cmodels @xcite , assat @xcite , etc . in particular , it should require little more than the addition of a module to determine the _ `` solutions '' _ of an aggregate , without substantial modifications of the mechanisms to compute answer sets .",
    "we achieve these objectives by defining a transformation , called _ unfolding _ , from logic programs with aggregates to normal logic programs . the key idea that makes",
    "this possible is the generalization of the supportedness property of answer sets to the case of aggregates .",
    "more precisely , our transformation ensures that , if an aggregate atom is satisfied by a model @xmath15 , then @xmath15 supports at least one of its solutions .",
    "solutions of aggregates can be precomputed , and an answer set solver for lp with aggregates can be implemented using standard answer set solvers .",
    "the notion of unfolding has been widely used in various areas of logic programming ( e.g. ,  @xcite ) . the inspiration for",
    "the approach used in handling aggregates in this paper comes from the methodology proposed in various works on _ constructive negation _",
    "( e.g. , @xcite)in particular , from the idea of unfolding _ intensional sets _ into sets of solutions , employed to handle intensional sets in  @xcite .",
    "the approach developed in this paper is the continuation and improvement of the approach in @xcite .",
    "it offers an alternative view of the semantics for lp with aggregates developed in  @xcite .",
    "in particular , the two characterizations provide the same meaning to program with aggregates , although our approach does not require the use of approximation theory .",
    "we provide two ways of using unfolding .",
    "the first is similar to the notion of transformation explored in @xcite .",
    "the second is closer to the spirit of the original definition of answer sets @xcite , and it allows us to naturally handle more general use of aggregates ( e.g. , aggregates in the heads ) .",
    "the characterization proposed in this paper also captures the same meaning as the proposals in  @xcite for large classes of programs ( e.g. , stratified programs and programs with monotone aggregates ) .",
    "observe that , in this work , we do not directly address the problem of negated aggregates .",
    "this problem can be tackled in different ways ( e.g. @xcite ) .",
    "our approach to aggregates can be easily extended to accommodate any of these approaches @xcite .",
    "the rest of this paper is organized as follows .",
    "section  [ sec2 ] presents the syntax of our logic programming language with aggregates .",
    "section  [ semantics ] describes the first definition of answer sets for programs with aggregates that do not allow for aggregates to occur in the head of rules .",
    "the definition is based on an unfolding transformation of programs with aggregates into normal logic programs .",
    "it also contains a discussion of properties of answer sets and describes an implementation .",
    "section  [ sec - alternative ] introduces an alternative unfolding , which is useful for extending the use of aggregates to the head of program rules .",
    "section  [ related - work ] compares our approach with the relevant literature .",
    "section  [ sec - diss ] discusses some issues related to our approach to providing semantics of aggregates .",
    "finally , section  [ concl ] presents the conclusions and the future work .",
    "[ syntax ]    let us consider a signature @xmath16 , where    * @xmath17 is a collection of constants ( _ program constants _ ) , * @xmath18 is a collection of unary function symbols ( _ aggregate functions _ ) , * @xmath19 and @xmath20 are denumerable collections of variables , such that @xmath21 , * @xmath22 is a collection of arbitrary predicate symbols ( _ program predicates _ ) , and * @xmath23 is a collection of unary predicate symbols ( _ aggregate predicates _ ) .    in the rest of this paper",
    ", we will assume that @xmath24 is a subset of @xmath17i.e .",
    ", there are distinct constants representing the integer numbers .",
    "we will refer to @xmath25 as the _ asp signature_.    we will also refer to @xmath26 as the _ program signature _ , where    * @xmath27 , * @xmath28 , and * @xmath29 is finite .",
    "we will denote with @xmath30 the @xmath31-herbrand universe , containing the ground terms built using symbols of @xmath29 , and with @xmath32 the corresponding @xmath31-herbrand base .",
    "we will refer to an atom of the form @xmath33 , where @xmath34 and @xmath35 , as an asp - atom .",
    "an asp - literal is either an asp - atom or the negation as failure ( @xmath36 ) of an asp - atom .",
    "[ groundset ] an _ extensional set _ has the form @xmath37 , where @xmath38 are terms of @xmath31 .",
    "extensional multiset _ has the form @xmath39 where @xmath38 are ( possibly repeated ) terms of @xmath31 .",
    "[ intensionalset ] an _ intensional set _ is of the form @xmath40 where @xmath41 is a variable , @xmath42 s are variables or constants , @xmath43 , and @xmath10 is a k - ary predicate in @xmath44 .",
    "an _ intensional multiset _ is of the form @xmath45 where @xmath46 , @xmath47 are variables or constants ( of @xmath29 ) , @xmath48 , and @xmath49 .",
    "we call @xmath50 and @xmath10 the _ collected variable _ and the _ predicate _ of the set / multiset , respectively .    intuitively , we are collecting the values of @xmath50 that satisfy the atom @xmath51 , under the assumption that the variables @xmath52 are locally and existentially quantified .",
    "for example , if @xmath53 is true for @xmath54 and @xmath55 , then the multiset @xmath56 corresponds to @xmath57 .",
    "definition [ intensionalset ] can be extended to allow more complex types of sets , e.g. , sets collecting tuples as elements , sets with conjunctions of literals as property of the intensional construction , and intensional sets with existentially quantified variables .",
    "observe also that the variables from @xmath20 are used exclusively as collected or local variables in defining intensional sets or multisets , and they can not occur anywhere else .",
    "an _ aggregate term _ is of the form @xmath58 , where @xmath59 is an intensional set or multiset , and @xmath60 .",
    "an _ aggregate atom _ has the form @xmath61 where @xmath62 and @xmath63 is an aggregate term .",
    "this notation for aggregate atoms is more general than the one used in some previous works , and resembles the _ abstract constraint atom _ notation presented in  @xcite .    in our examples",
    ", we will focus on the `` standard '' aggregate functions and predicates , e.g. , count , sum , min , max , avg applied to sets / multisets and predicates such as @xmath64 , @xmath65 , @xmath66 , etc .",
    "also , for the sake of readability , we will often use a more traditional notation when dealing with the standard aggregates ; e.g. , instead of writing @xmath67 we will use the more common format @xmath68 .    given an aggregate atom @xmath69 , with k - ary collected predicate @xmath10 , we denote with @xmath70 the following set of asp - atoms : @xmath71    an @xmath0  rule is an expression of the form @xmath72 where @xmath73 are asp - atoms , and @xmath74 are aggregate atoms ( @xmath75 , @xmath76 , @xmath77 ) .    an @xmath0  program is a collection of @xmath0  rules .    for an @xmath0  rule @xmath8 of the form ( [ agg - rule ] )",
    ", we use the following notations :    @xmath78    @xmath79 denotes the asp - atom @xmath80 ,    @xmath81 denotes the set @xmath82 ,    @xmath83 denotes the set @xmath84 ,    @xmath85 denotes the set @xmath86 ,    @xmath87 denotes the right hand side of the rule @xmath8 .    for a program @xmath3 , @xmath88 denotes the set of all asp - atoms present in @xmath3 .",
    "the syntax has been defined in such a way that collected and local variables of an aggregate atom @xmath69 have a scope that is limited to @xmath69 .",
    "thus , given an @xmath0  rule , it is possible to rename these variables apart , so that each aggregate atom @xmath89 in the body of a rule makes use of different collected and local variables .",
    "observe also that the collected and the local variables are the only occurrences of variables from @xmath20 , and these variables will not appear in any of @xmath79 , @xmath83 , and @xmath85 .    given a term ( atom , literal , rule ) @xmath90 , we denote with @xmath91 the set of variables from @xmath92 present in @xmath90 .",
    "we will refer to these as the _ free variables _ of @xmath90 .",
    "the entity @xmath90 is _ ground _ if @xmath93 .    in defining the semantics of the language",
    ", we will need to consider all possible ground instances of programs . a _ ground substitution _",
    "@xmath94 is a set @xmath95 , where the @xmath42 are distinct elements of @xmath92 and the elements @xmath96 are constants from @xmath29 .",
    "given a substitution @xmath94 and an asp - atom ( or an aggregate atom ) @xmath10 , the notation @xmath97 describes the atom obtained by simultaneously replacing each occurrence of @xmath42 ( @xmath98 ) with @xmath99 .",
    "the resulting element @xmath97 is the _ instance _ of @xmath10 w.r.t .",
    "@xmath94 .    given a rule @xmath8 of the form ( [ agg - rule ] ) with @xmath100 , and given a ground substitution @xmath101 , the ground instance of @xmath8 w.r.t .",
    "@xmath94 is the rule obtained from @xmath8 by simultaneously replacing every occurrence of @xmath42 ( @xmath102 ) in @xmath8 with @xmath99",
    ".    we will denote with @xmath103 the set of all the possible ground instances of a rule @xmath8 that can be constructed in @xmath31 . for a program @xmath3",
    ", we will denote with @xmath104 the set of all ground instances of all rules in @xmath3 , i.e. , @xmath105 .",
    "observe that a ground logic program with aggregates differs from a ground logic program , in that it might still contain some local variables , which are members of @xmath20 , and they occur only in aggregate atoms .",
    "let @xmath106 , @xmath107 , @xmath108 , and @xmath109 .",
    "let @xmath8 be the rule @xmath110 @xmath103 will contain the following rules : @xmath111 furthermore , for the aggregate atom @xmath112 , we have that @xmath113",
    "in this section , we develop our first characterization of the semantics of program with aggregates , based on answer sets , study some of its properties , and investigate an implementation based on the smodels system .",
    "let us start by developing the notion of interpretation , following the traditional structure  @xcite .",
    "the _ domain _ @xmath114 of an interpretation is the set @xmath115 , where @xmath116 is the set of all ( finite ) subsets of @xmath30 , while @xmath117 denotes the set of all finite multisets built using elements from @xmath30 .",
    "an _ interpretation _",
    "@xmath118 is a pair @xmath119 , where @xmath120 is a function that maps ground terms to elements of @xmath114 and ground atoms to truth values .",
    "the interpretation function @xmath120 is defined as follows :    * if @xmath121 is a constant , then @xmath122 * if @xmath59 is a ground intensional set @xmath123 , then @xmath124 is the set @xmath125 , where @xmath126 is true if and only if @xmath127 . *",
    "if @xmath59 is a ground intensional multiset @xmath128 , then @xmath124 is the multiset @xmath129 , where , for each @xmath130 , there exists a ground substitution @xmath131 for @xmath132 such that @xmath133 is true , and no other element has such property . * given an aggregate term @xmath58 , then @xmath134 is equal to @xmath135 , where @xmath136 * if @xmath137 is a ground asp - atom or a ground aggregate atom , then @xmath138 is @xmath139 , where @xmath140 .    in the characterization of the aggregate functions , in this work",
    "we will mostly focus on functions that maps sets / multisets to integer numbers in @xmath24 .",
    "we will also assume that the traditional aggregate functions and predicates are interpreted in the usual manner .",
    "e.g. , @xmath141 is the function that sums the elements of a set / multiset , and @xmath142 is the predicate that is true if its argument is an element of @xmath24 no greater than @xmath143 .    given a literal @xmath144 , its interpretation @xmath145 is true ( false ) iff @xmath146 is false ( true ) .",
    "for the sake of simplicity , given an atom ( literal , aggregate atom ) @xmath10 , we will denote with @xmath147 the fact that @xmath146 is true .",
    "let @xmath118 be an interpretation and @xmath8 an @xmath0  rule .",
    "@xmath118 satisfies the body of the rule ( @xmath148 ) if @xmath149 for each @xmath150 .",
    "we say that @xmath118 satisfies @xmath8 if @xmath151 whenever @xmath148 .",
    "finally , we can define the concept of model of a program .",
    "an interpretation @xmath118 is a _ model _ of a program @xmath3 if @xmath15 satisfies each rule @xmath152 .    in the rest of this work",
    ", we will assume that the interpretation of the aggregate functions and predicates is _ fixed_i.e .",
    ", it is the same in all the interpretations .",
    "this allows us to keep the `` traditional '' view of interpretations as subsets of @xmath32 @xcite .",
    "[ minimal model ] an interpretation @xmath118 is a _ minimal model _ of @xmath3",
    "if @xmath118 is a model of @xmath3 and there is no proper subset of @xmath118 which is also a model of @xmath3 .",
    "we will now present the notion of _ solution of an aggregate_. one of the guiding principles behind this concept is the following observation . the satisfaction of an asp - atom @xmath10 is _ monotonic _ , in the sense that if @xmath153 and @xmath154 , then we have that @xmath155 .",
    "this property does not hold any longer when we consider aggregate atoms .",
    "furthermore , the truth value of an aggregate atom @xmath69 depends on the truth value of certain atoms belonging to @xmath70 .",
    "for example , if we consider the aggregate atom @xmath156 in the program with @xmath157 , we can observe that @xmath158 and @xmath69 is true if @xmath159 is false or @xmath160 is true .",
    "these two observations lead to the following definition .",
    "let @xmath69 be a ground aggregate atom .",
    "solution _ of @xmath69 is a pair @xmath161 of disjoint subsets of @xmath70 such that , for every interpretation @xmath118 , if @xmath162 and @xmath163 then @xmath164",
    ".    we will denote with @xmath165 the set of all the solutions of the aggregate atom @xmath69 .",
    "let @xmath166 be the solution of an aggregate @xmath69 ; we denote with @xmath167 and @xmath168 the two components @xmath169 and @xmath170 of the solution .    [ ex - sol ]",
    "let @xmath121 be the aggregate atom @xmath171 in a language where @xmath172 .",
    "this aggregate atom has a total of @xmath173 solutions of the form @xmath161 such that @xmath174 , @xmath175 , and ( i ) either @xmath176 ; or ( ii ) @xmath177 .",
    "these solutions are listed below .",
    "@xmath178 @xmath179",
    "let @xmath69 be an aggregate atom .",
    "the following properties hold :    [ obs0 ]    if there is at least one interpretation @xmath118 such that @xmath164 , then @xmath180 .",
    "if @xmath181 is a solution of @xmath69 then , for every set @xmath182 with @xmath183 , we have that @xmath184 and @xmath185 are also solutions of @xmath69 .    the first property holds since the pair @xmath186 is a solution of @xmath69 .",
    "the second property is trivial from the definition of a solution .",
    "we will now define the _ unfolding _ of an aggregate atom , of a ground rule , and of a program . for simplicity",
    ", we use @xmath2 ( resp .",
    "@xmath187 ) to denote the conjunction @xmath188 ( resp .",
    "@xmath189 ) when @xmath190 ; @xmath191 ( @xmath192 ) stands for @xmath193 ( @xmath194 ) . with @xmath193 and @xmath195 with @xmath194 . ]    given a ground aggregate atom @xmath69 and a solution @xmath196 , the unfolding of @xmath69 w.r.t .",
    "@xmath2 , denoted by @xmath197 , is @xmath198 .",
    "[ unfolding ] let @xmath8 be a ground rule @xmath199 where @xmath200 are aggregate atoms .",
    "a ground rule @xmath201 is an _ unfolding _ of @xmath8 if there exists a sequence of aggregate solutions @xmath202 such that    1 .",
    "@xmath203 is a solution of the aggregate atoms @xmath89 ( @xmath204 ) , 2 .",
    "@xmath205 , 3 .",
    "@xmath206 , 4 .",
    "@xmath207 , and 5 .",
    "@xmath208 .",
    "we say that @xmath201 is _ an unfolding of @xmath8 with respect to _ @xmath209 .",
    "the set of all possible unfoldings of a rule @xmath8 is denoted by @xmath210 .    for an @xmath0  program @xmath3",
    ", @xmath211 denotes the set of the unfoldings of the rules in @xmath104 .",
    "it is easy to see that @xmath211 is a normal logic program .",
    "the answer sets of @xmath0  programs are defined as follows .",
    "[ answerset ] a set of atoms @xmath15 is an @xmath0-answer set of @xmath3 iff @xmath15 is an answer set of @xmath211 .",
    "[ exp1 ] let @xmath212 be the program : @xmath213 the aggregate atom @xmath214 has five aggregate solutions : @xmath215 the unfolding of @xmath212 is the program @xmath216 @xmath217 and @xmath218 are the two answer sets of @xmath219 , thus @xmath0-answer sets of @xmath212 .",
    "@xmath179    [ exp2 ] let @xmath220 be the program @xmath221 the only aggregate solution of @xmath222 is @xmath223 and @xmath224 contains : @xmath225 which has @xmath226 as its only answer set .",
    "thus , @xmath227 is the only @xmath0-answer set of @xmath220 .",
    "@xmath179    the next program with aggregates does not have answer sets , even though it does not contain any negation as failure literals .",
    "consider the program @xmath228 : @xmath229 the unique aggregate solution of the aggregate atom @xmath230 with respect to @xmath231 is @xmath232 .",
    "the unfolding of @xmath228 consists of the two rules : @xmath233 and it does not have any answer sets . as such , @xmath228",
    "does not have any @xmath0-answer sets .",
    "@xmath179    observe that , in creating @xmath211 , we use _ every _ solution of @xmath121 in @xmath234 . since the number of solutions of an aggregate atom can be exponential in the size of the herbrand base ,",
    "the size of @xmath211 can be exponential in the size of @xmath3 .",
    "fortunately , as we will show later ( theorem [ theorem10 ] ) , this process can be simplified by considering only minimal solutions of each aggregate atom ( definition [ def9 ] ) . in practice , for most common uses of aggregates , we have observed a small number of elements in the minimal solution set ( typically linear or quadratic in the extension of the predicate used in the intensional set ) .",
    "it is easy to see that the notion of @xmath0-answer sets extends the notion of answer sets of normal logic programs . indeed , if @xmath3 does not contain aggregate atoms , then @xmath235 .",
    "thus , for a program without aggregates @xmath3 , @xmath15 is an @xmath0-answer set of @xmath3 if and only if @xmath15 is an answer set of @xmath3 with respect to the gelfond - lifschitz definition of answer sets .",
    "we will now show that @xmath0-answer sets satisfies the same properties of minimality , closedness , and supportedness as answer sets for normal logic programs .",
    "[ lem1 ] every model of @xmath211 is a model of @xmath3 .",
    "* let @xmath15 be a model of @xmath211 , and let us consider a rule @xmath236 such that @xmath15 satisfies the body of @xmath8 .",
    "this implies that there exists a sequence of solutions @xmath237 for the aggregate atoms occurring in @xmath8 , such that @xmath238 , @xmath239 , and @xmath240 .",
    "let @xmath201 be the unfolding of @xmath8 with respect to @xmath237 .",
    "we have that @xmath241 and @xmath242 .",
    "in other words , @xmath15 satisfies the body of @xmath243 .",
    "this implies that @xmath244 , i.e. , @xmath245 .",
    "@xmath179    [ lem2 ] every model of @xmath3 is a model of @xmath211 .    * proof .",
    "* let @xmath15 be a model of @xmath3 , and let us consider a rule @xmath243 such that @xmath15 satisfies the body of @xmath201 .",
    "since @xmath243 , there exists @xmath236 and a sequence of aggregate solutions @xmath237 for the aggregate atoms in @xmath8 such that @xmath15 satisfies @xmath246 ( for @xmath247 ) and @xmath201 is the unfolding of @xmath8 with respect to @xmath237 .",
    "this means that @xmath248 , @xmath249 , and @xmath250 for @xmath247 . in other words",
    ", @xmath15 satisfies @xmath87 .",
    "since @xmath15 is a model of @xmath104 , we have that @xmath245 , which means that @xmath244 . @xmath179    [ th1 ] let @xmath3 be a program with aggregates and @xmath15 be an @xmath0-answer set of @xmath3 .",
    "then , @xmath15 is closed , supported , and a minimal model of @xmath104 .    * proof . *",
    "since @xmath15 is an @xmath0-answer set of @xmath3 , lemma [ lem1 ] implies that @xmath15 is a model of @xmath104 .",
    "minimality of @xmath15 follows from lemma [ lem2 ] and from the fact that @xmath15 is a minimal model of @xmath211 .",
    "closedness is immediate from lemma  [ lem1 ] .",
    "supportedness can be derived from the fact that each atom @xmath10 in @xmath15 is supported by @xmath15 ( w.r.t .",
    "@xmath211 ) since @xmath15 is an answer set of @xmath211 .",
    "thus , if @xmath10 were not supported by @xmath15 w.r.t .",
    "@xmath104 , then this would mean that no rule in @xmath211 supports @xmath10 , which would contradict the fact that @xmath15 is an answer set of @xmath211 .",
    "observe that the converse of the above theorem does not hold , as illustrated by the following example .",
    "let @xmath251 be the program @xmath252 it is easy to see that @xmath253 is a minimal model of this ground program ",
    ", @xmath15 is a minimal set of atoms , closed under the rules of @xmath254 and each atom of @xmath15 is supported by a rule of @xmath254 . on the other hand ,",
    "@xmath255 consists of the following rules @xmath256 @xmath15 is not an answer set of @xmath255 .",
    "we can easily check that this program does not have an answer set .",
    "thus , @xmath251 does not have an answer set according to definition [ answerset ] .",
    "@xmath179    the above result might seem counterintuitive , and it deserves some discussion .",
    "one might argue that , in any interpretation of the program @xmath251 , either @xmath257 will be true .",
    "as such , @xmath258 would appear to be true , and hence @xmath15 should be an answer set of the program .    while this is a possible way to deal with aggregates , in this example , this line of reasoning might lead to circular justifications of atoms in @xmath15 . in fact , observe that the rules that support @xmath159 and @xmath258 in @xmath15 are @xmath259 and @xmath260 , respectively . in the context of the program , @xmath261 can be true only if @xmath159 is true .",
    "this is equivalent to say that @xmath159 is true because @xmath258 is true , and @xmath258 is true because @xmath159 is true . in other words ,",
    "the answer set contains two elements whose truth values depend on each other .",
    "the traditional answer set definition in @xcite does not allow such type of justifications  in that it does not consider @xmath262 as an answer set of the program @xmath263 .",
    "example [ p4-ex ] shows that our approach to defining the semantics of logic programs with aggregates is closer to the spirit of the traditional answer set definition .",
    "we should also observe that most of the recent approaches to handling aggregates ( e.g. , @xcite ) yield the same result on this example .",
    "moreover , if we encode @xmath251 in smodels ( using weight constraints ) as    ....         p(1 ) .",
    "p(2 ) .",
    "q:- 2[p(1)=1 , p(2)=2 ] .",
    "q:-[p(1)=1 , p(2)=2]1 .",
    "....    we obtain an smodels program that does not have any answer sets .      in spite of the number of proposals dealing with aggregates in logic programming , only few implementations have been described .",
    "dellarmi et al . @xcite describe an implementation of aggregates in the dlv engine , based on the semantics described in section [ old - semantics ] ( the current distribution is limited to aggregate - stratified programs . ] ) .",
    "elkabani et al .",
    "@xcite describe an integration of a constraint logic programming engine ( the eclipse engine ) and the smodels answer set solver ; the integration is employed to implement aggregates , with respect to the semantics of section [ old - semantics ] .",
    "some more restricted forms of aggregation , characterized according to the semantics of section [ old - semantics ] have also been introduced in the aset - prolog system @xcite .",
    "efficient algorithms for bottom - up computation of the perfect model of aggregate - stratified programs have been described in @xcite .    in this section",
    ", we will describe an implementation of a system for computing @xmath0-answer sets based on the computation of the solutions of aggregate atoms , unfolding of the program , and computation of the answer sets using an off - the - shelf answer set solver .",
    "we begin with a discussion of computing solutions of aggregate atoms .      as we have mentioned before , the size of the program @xmath211 can become unmanageable in some situations .",
    "one way to reduce the size of @xmath211 is to find a set of `` representative '' solutions for the aggregate atoms occurring in @xmath3 , whose size is  hopefully  smaller than the size of the @xmath165 .",
    "interestingly , in several situations , the number of representative solutions of an aggregate atom is small @xcite .",
    "we say that a set of solutions is complete if it can be used to check the satisfiability of the aggregate atom in every interpretation of the program .",
    "first , we define when a solution _ covers _ another solution .",
    "a solution @xmath2 of an aggregate atom @xmath69 _ covers _ a solution @xmath264 of @xmath69 , denoted by @xmath265 , if , for all interpretations @xmath118 , @xmath266    this can be used to define a _",
    "complete _ and _ minimal _ sets of solutions of an aggregate atom .",
    "[ def9 ] a set @xmath267 of solutions of an aggregate atom @xmath69 is _ complete _ if for every solution @xmath268 of @xmath69 , there exists @xmath269 such that @xmath270 .",
    "a solution set @xmath267 is _ reducible _ if there are two distinct solutions @xmath2 and @xmath264 in @xmath267 such that @xmath271 .",
    "the set of solutions @xmath272 is then called a _ reduction _ of @xmath267 .",
    "a solution set @xmath267 is _ minimal _ if it is complete and not reducible .    by definition",
    ", we have that @xmath165 is complete . because of the transitivity of the covering relationship , we can conclude that any minimal solution set of @xmath69 is a reduction of @xmath165 .",
    "given a ground program @xmath3 , let @xmath273 be the aggregate atoms present in @xmath3 , and let us denote with @xmath274)$ ] the unfolding of @xmath3 where @xmath275 has been unfolded using only the solution set @xmath276 .    [ theorem10 ] given a ground program @xmath3 containing the aggregate atoms @xmath273 , and given a complete solution set @xmath276 for each aggregate atom @xmath275 , we have that @xmath15 is an @xmath0-answer set of @xmath3 iff @xmath15 is an answer set of @xmath277)$ ] .",
    "* for an interpretation @xmath15 , let @xmath278))^m$ ] and @xmath279))^m = ( unfolding(p))^m$ ] .",
    "we have that @xmath15 is an @xmath0-answer set of @xmath3 iff @xmath15 is an answer set of @xmath280 .",
    "furthermore , @xmath281 , and for each rule @xmath282 there is a rule @xmath283 with @xmath284 and @xmath285 . using this information",
    ", we can show that @xmath15 is an answer set of @xmath286 iff @xmath15 is an answer set of @xmath280 , which proves the theorem . @xmath179",
    "the above theorem shows that we can use any complete solution set ( e.g. , a minimal one ) to unfold an aggregate atom .",
    "we make use of the following observation to compute a complete solution set :    let @xmath69 be an aggregate atom and let @xmath287 , @xmath288 be solutions of @xmath69",
    ". then @xmath289 .",
    "the abstract algorithm in figure [ al1 ] computes a complete solution set @xmath290 for a given aggregate atom  when called with find_solution@xmath291 and with initially @xmath292 .",
    "this algorithm is generic  i.e .",
    ", can be used with arbitrary aggregate predicates , as long as a mechanism to perform the test in line 3 is provided .",
    "the test is used to check whether the current @xmath293 represents a solution of @xmath69 .",
    "observe also that more effective algorithms can be provided for specific classes of aggregates , by using properties of the aggregate predicates used in the aggregate atoms @xcite .",
    "iiiiiiiiiiiiiiiiiiiiiiiiiiiii1 : ( @xmath69 , @xmath294 ) + 2:\\ { assume @xmath295 and @xmath296 } + 3 : @xmath297 * then * + 4 : add @xmath293 to @xmath290 ; + 5 : + 6 : + 7 : @xmath298 * then return * ; + 8 : + 9 : ( @xmath299 ) + 10:(@xmath69 , @xmath300 ) ; + 11:(@xmath69 , @xmath301 ) ; + 12 :    given a program @xmath3 containing the aggregate atoms @xmath273 , we can replace @xmath3 with @xmath302)$ ] .",
    "the program @xmath303 is a normal logic program without aggregates , whose answer sets can be computed using a standard answer set solver .",
    "the algorithm has been implemented in an extended version of lparse  using an external constraint solver to compute line 3 .",
    "note that the * forall * in line 9 is a _ non - deterministic _ choice of @xmath10 .",
    "we will now describe the prototype we have constructed , called @xmath0 , for computing answer sets of programs with aggregates .",
    "the computation is performed following the semantics given in definition [ answerset ] , simplified by theorem [ theorem10 ] . in other words , to compute the answer set of a program @xmath3 , we    1 .",
    "compute a complete ( and possibly minimal ) solution set for each aggregate atom occurring in @xmath3 ; 2 .",
    "unfold @xmath3 using the computed solution sets ; 3 .",
    "compute the answer sets of the unfolded program @xmath211 using a standard answer set solver ( in our case , both smodels and cmodels ) .",
    "the overall structure of the system is shown in figure  [ big ] .",
    "the computation of answer sets is performed in five steps . in the first step ,",
    "a preprocessor performs a number of simple syntactic transformations on the input program , which are aimed at rewriting the aggregate atoms in a format acceptable by lparse .",
    "for example , the aggregate atom @xmath304 is rewritten to @xmath305 and an additional rule @xmath306 is added to the program .",
    "the rewritten program is then grounded and simplified using lparse , in which aggregate atoms are treated like standard ( non - aggregate ) literals .",
    "the ground program is processed by the _ transformer module _ , detailed in figure  [ transformer ] , in which the unfolded program is computed .",
    "this module performs the following operations :    1 .",
    "creation of the _ atom table _ , the _ aggregate table _ , and the _ rule table _ , used to store the ground atoms , aggregate atoms , and rules of the program , respectively .",
    "this is performed by the _ reader _",
    "component in figure [ transformer ] .",
    "identification of the dependencies between aggregate atoms and the atoms contributing to such atoms ( done by the _ dependencies analyzer _ ) ; 3 .",
    "computation of a complete solution set for each aggregate atom ( done by the _",
    "aggregate solver_as described in the previous subsection ) ; 4 .",
    "creation of the unfolded program ( done by the _ rule expander _ ) .",
    "note that the unfolded program is passed one more time through lparse , to avail of the simplifications and optimizations that lparse can perform on a normal logic program ( e.g. , expansion of domain predicates and removal of unnecessary rules ) .",
    "the resulting program is a ground normal logic program , whose answer sets can be computed by a system like smodels or cmodels .",
    "we have performed a number of tests using the @xmath0   system . in particular , we selected benchmarks with aggregates presented in the literature .",
    "the benchmarks , drawn from various papers on aggregation , are :    * _ company control : _ let @xmath307 denotes the fact that company @xmath50 owns a fraction @xmath308 of the shares of the company @xmath309 .",
    "we say that a company @xmath50 _ controls _ a company @xmath309 if the sum of the shares it owns in @xmath309 together with the sum of the shares owned in @xmath309 by companies controlled by @xmath50 is greater than half of the total shares of @xmath309 : @xmath310 we explored different instances , with varying numbers of companies . * _ shortest path : _ suppose a weight - graph is given by relation @xmath311 , where @xmath312 means that there is an arc in the graph from node @xmath50 to node @xmath309 of weight @xmath313 .",
    "we represent the shortest path ( minimal weight ) relation @xmath314 using the following rules @xmath315 the instances explored make use of graphs with varying number of nodes . * _ party invitations : _ the main idea of this problem is to send out party invitations considering that some people will not accept the invitation unless they know that at least @xmath316 other people from their friends accept it too .",
    "@xmath317 the instances explored in our experiments have different numbers of people invited to the party . *",
    "_ group seating : _ in this problem , we want to arrange the sitting of a group of @xmath318 people in a restaurant , knowing that the number of tables times the number of seats on each table equals to @xmath318 .",
    "the number of people that can sit at a table can not exceed the number of chairs at this table , and each person can sit exactly at one table .",
    "in addition , people who like each other must sit together at the same table and those who dislike each other must sit at different tables . @xmath319",
    "the benchmark makes use of 16 guests , 4 tables , each having 4 chairs . *",
    "_ employee raise : _ assume that a manager decides to select at most @xmath308 employees to give them a raise .",
    "an employee is a good candidate for the raise if he has worked for at least @xmath320 hours per week .",
    "a relation @xmath321 denotes that an employee @xmath50 worked @xmath322 hours during the day @xmath323 .",
    "@xmath324 the different experiments conducted are described by the two parameters @xmath325 , where @xmath15 is the number of employees and @xmath308 the maximum number of individuals getting a raise . * _ nm1 _ and _ nm2 _ : these are two synthetic benchmarks that compute large aggregates that are recursive and non - monotonic .",
    "_ nm1 _ has its core in the following rules : @xmath326 the program _ nm2",
    "_ relies on the following set of rules : @xmath327    the code for the benchmarks can be found at : www.cs.nmsu.edu/~ielkaban/asp-aggr.html .",
    "table  [ tab1 ] presents the results obtained .",
    "the columns of the table have the following meaning :    * program is the name of the benchmark .",
    "* instance describes the specific instance of the benchmark used in the test . *",
    "smodels time is the time ( in seconds ) employed by smodels to compute the answer sets of the unfolded program . *",
    "cmodels time is the time ( in seconds ) employed by cmodels to compute the answer sets of the unfolded program . *",
    "transformer time is the time ( in seconds ) to preprocess and ground the program ( i.e. , compute the solutions of aggregates and perform the unfolding  this includes the complete pipeline discussed in figure  [ big ] ) . *",
    "dlv@xmath1 is the time employed by the dlv@xmath1 system to execute the same benchmark ( where applicable , otherwise marked n / a)observe that the current distribution of this system does not support recursion through aggregates . *",
    "a - prolog is the time employed by the a - prolog system ; this system supports only sum and count aggregates on sets , but it allows recursively defined aggregates ( according to the semantics of section  [ old - semantics ] ) .",
    "the entries marked failed denote one of the following facts : 1 .",
    "the system stopped with a segmentation fault 2 .",
    "the system did not produce a solution after 30 minutes of computation 3 .",
    "the system produced a non - minimal answer set ( this occurred only in the party invitation benchmark )    all computations have been performed on a pentium 4 , 3.06 ghz machine with 512 mb of memory under linux 2.4.28 using gcc 3.2.1 .",
    "the system is available for download at www.cs.nmsu.edu/~ielkaban/asp-aggr.html .    as we can see from the table",
    ", even this relatively simple implementation of aggregates can efficiently solve all benchmarks we tried , offering a coverage significantly larger than other existing implementations .",
    "observe also that the overhead introduced by the computation of aggregate solutions is significant in very few cases .",
    ".computing answer sets of benchmarks with aggregates[tab1 ] [ cols=\"<,^,^,^,^,^ \" , ]",
    "the main advantage of the previously introduced definition of @xmath0-answer sets is its simplicity , which allows an easy computation of answer sets of programs with aggregates using currently available answer set solvers . following this approach ,",
    "all we need to do to compute answer sets of a program @xmath3 is to compute its unfolded program @xmath211 and then use an answer set solver to compute the answer sets of @xmath211 .",
    "one disadvantage of this method lies in the fact that the size of the program @xmath211 can be exponential in the size of @xmath3which could potentially become unmanageable . theoretically , this is not a surprise , as the problem of determining the existence of answer sets for propositional programs with aggregates can be very complex , depending on the types of aggregates ( i.e. , aggregate functions and comparison predicates ) present in the program ( see @xcite and chapter 6 in @xcite for a thorough discussion of these issues ) .",
    "in what follows , we present an alternative characterization of the semantics for programs with aggregates , whose underlying principle is still the unfolding mechanism .",
    "this new characterization allows us to compute the answer sets of a program by using a generate - and - test procedure .",
    "the key difference is that the unfolding is now performed with respect to a _ given interpretation_.      let us start by specializing the notion of solution of an aggregate to the case of a fixed interpretation .    for a ground aggregate atom @xmath69 and an interpretation @xmath15",
    ", its @xmath15-solution set is @xmath328    intuitively , @xmath329 is the set of solutions of @xmath69 which are true in @xmath15 . for a solution @xmath330 , the unfolding of @xmath69 w.r.t .",
    "@xmath268 is the conjunction @xmath331 .",
    "we say that @xmath332 is an unfolding of @xmath69 with respect to @xmath15 if @xmath332 is an unfolding of @xmath69 with respect to some @xmath333 .",
    "when @xmath334 , we say that @xmath194 is the only unfolding of @xmath69 in @xmath15 .",
    "we next define the unfolding of a program with respect to an interpretation @xmath15 .",
    "[ dunfolding2 ] let @xmath15 be an interpretation of the program @xmath3 .",
    "the unfolding of a rule @xmath236 w.r.t .",
    "@xmath15 is a set of rules , denoted by @xmath335 , defined as follows :    1 .",
    "if @xmath336 , or if there is a @xmath247 such that @xmath194 is the unfolding of @xmath121 in @xmath15 , then @xmath337 ; 2 .   if @xmath249 and , for every @xmath247 @xmath194 is not the unfolding of @xmath121 , then @xmath338 if 1 .",
    "@xmath205 2 .",
    "there exists a sequence of aggregate solutions @xmath237 of aggregate atoms in @xmath81 such that @xmath339 for every @xmath247 and @xmath340 .",
    "the unfolding of @xmath3 w.r.t .",
    "@xmath15 , denoted by @xmath341 , is defined as follows : @xmath342    observe that @xmath341 is a definite program .",
    "similar to the definition of an answer set in @xcite , we define answer sets as follows .",
    "[ alternatedef ] @xmath15 is an @xmath0-answer set of @xmath3 iff @xmath15 is an answer set of @xmath343 .    in the next example , we illustrate the above definitions .",
    "consider the program @xmath212 ( example [ exp1 ] ) and consider the interpretation @xmath344 .",
    "let @xmath69 be the aggregate atom @xmath214 .",
    "we have that @xmath345 the @xmath346 is : @xmath347 observe that @xmath15 is indeed an answer set of @xmath346 .",
    "@xmath179    consider the program @xmath220 from example [ exp2 ] , and let us consider @xmath348 .",
    "observe that , if we consider the aggregate atom @xmath69 of the form @xmath349 then @xmath350 then , @xmath351 is : @xmath352 this program has the unique answer set @xmath353 which is different from @xmath15 ; thus @xmath15 is not an answer set of @xmath220 according to definition [ alternatedef ] . @xmath179",
    "the next theorem proves that this new definition is equivalent to the one in section [ semantics ] .    for any @xmath0  program @xmath3 ,",
    "an interpretation @xmath15 of @xmath3 is an answer set of @xmath211 iff @xmath15 is an answer set of @xmath341 .",
    "* let @xmath354 and @xmath355 .",
    "we have that @xmath356 and @xmath357 are definite programs .",
    "we will prove by induction on @xmath316 that if @xmath15 is an answer set of @xmath357 then @xmath358 for every @xmath359 . denotes the traditional immediate consequence operator and @xmath360 is the @xmath361 upward iteration of @xmath362 . ]",
    "the equation holds trivially for @xmath363 .",
    "let us consider the case for @xmath364 , assuming that @xmath365 for @xmath366 .",
    "* consider @xmath367 .",
    "this means that there exists some rule @xmath368 such that @xmath369 and @xmath370 . from the definition of the gelfond - lifschitz reduction and the definition of the unfolded program",
    ", we can conclude that there exists some rule @xmath236 and a sequence of aggregate solutions @xmath237 for the aggregate atoms in @xmath87 such that @xmath340 , and @xmath371 .",
    "in other words , @xmath201 is the gelfond - lifschitz reduction with respect to @xmath15 of the unfolding of @xmath8 with respect to @xmath237 .",
    "these conditions imply that @xmath372 . together with the inductive hypothesis",
    ", we can conclude that @xmath373 .",
    "* consider @xmath373 .",
    "thus , there exists some rule @xmath372 such that @xmath369 and @xmath374 . from the definition of @xmath356",
    ", we can conclude that there exists some rule @xmath236 and a sequence of aggregate solutions @xmath237 for the aggregate atoms in @xmath87 such that @xmath340 , and @xmath371 .",
    "thus , @xmath368 .",
    "together with the inductive hypothesis , we can conclude that @xmath367 .",
    "this shows that , if @xmath15 is an answer set of @xmath357 , then @xmath15 is an answer set of @xmath356 .",
    "similar arguments can be used to show that if @xmath15 is an answer set of @xmath356 , @xmath358 for every @xmath359 , which means that @xmath15 is an answer set of @xmath357 .",
    "@xmath179    the above theorem shows that we can compute answer sets of aggregate programs in the same generate  and  test order as in normal logic programs .",
    "given a program @xmath3 and an interpretation @xmath15 , instead of computing the gelfond - lifschitz s reduct @xmath375 we compute the @xmath341 .",
    "this method of computation might yield better performance but requires modifications of the answer set solver .",
    "another advantage of this alternative characterization is its suitability to handle aggregate atoms as heads of program rules , as discussed next .      as in most earlier proposals , with the exception of the weight constraints of smodels @xcite ,",
    "logic programs with abstract constraint atoms @xcite , and answer sets for propositional theories @xcite , the language discussed in section [ sec2 ] does not allow aggregate atoms as facts ( or as head of a rule ) . to motivate the need for aggregate atoms as rule heads ,",
    "let us consider the following example .",
    "let us have a set of three students who have taken an exam , and let us assume that at least two got a. this can be encoded as the smodels program with the set of facts about students and the weight constraint @xmath376 if aggregate atoms were allowed in the head , we could encode this problem as the following @xmath0  program @xmath377 along with a constraint stating that if @xmath378 is true then @xmath379 must be true as well  which can be encoded using the constraint @xmath380 this program should have four answer sets , each representing a possible grade distribution , in which either one of the students does not receive the a grade or all the three students receive a. @xmath179    the above example suggests that aggregate atoms in the head of a rule are convenient for certain knowledge representation tasks .",
    "we will now consider logic programs with aggregate atoms in which each rule is an expression of the form @xmath381 where @xmath382 are asp - atoms , @xmath74 are aggregate atoms ( @xmath75 , @xmath76 , @xmath77 ) , and @xmath323 can be either an asp - atom or an aggregate atom .",
    "an @xmath0  program is now a collection of rules of the above form .",
    "the notion of a model can be straightforwardly generalized to program with aggregates in the head .",
    "it is omitted here for brevity .",
    "as it turns out , the semantics presented in the previous subsection can be easily extended to allow for aggregate atoms in the head of rules .",
    "it only requires an additional step , in order to convert programs with aggregates in the head to programs without aggregates in the head . to achieve that",
    ", we introduce the following notation .",
    "let @xmath3 be a program with aggregates in the head , @xmath15 be an interpretation of @xmath3 , and @xmath8 be one of the rules in @xmath104 such that @xmath79 is an aggregate atom .",
    "we define @xmath383 and @xmath384 .",
    "[ aggheadfree ] let @xmath3 be a program with aggregates in the head and let @xmath15 be an interpretation of @xmath3 .",
    "the _ aggregate - free head reduct _ of @xmath3 with respect to @xmath15 , denoted by @xmath385 , is the program obtained from @xmath3 by replacing each rule @xmath236 whose head is an aggregate atom with    * @xmath386 if @xmath387 ; or * @xmath388 if @xmath389 .    for each rule @xmath8 ,",
    "whose head is an aggregate atom , we first check whether @xmath79 is satisfied by @xmath15 ( i.e. , @xmath387 by observation [ obs0 ] ) .",
    "if it is not satisfied , then this means that we intend the rule s body to not be satisfied  and we encode this with a rule of the type @xmath390 .",
    "otherwise , @xmath15 provides us with a solution of the aggregate atom @xmath79i.e .",
    ", @xmath391and we intend to use this rule to `` support '' such solution ; in particular , the rules in @xmath388 provides support for all the elements in @xmath392 .",
    "we are now ready to define the notion of answer sets for program with aggregates in the head .",
    "[ def - general ] a set of atoms @xmath15 is an @xmath0-answer set of @xmath3 iff @xmath15 is an answer set of @xmath393 .",
    "observe that , because of aggregates in the head , an @xmath0-answer set might be non minimal .",
    "nevertheless , the following holds .",
    "[ asmodel ] every @xmath0-answer set of a program @xmath3 is a model of @xmath3 .",
    "consider the program @xmath394 : @xmath395    let us compute some answer sets of @xmath394 .",
    "let @xmath69 denote the aggregate atom @xmath396 .",
    "* let @xmath397 .",
    "we can check that @xmath69 is not satisfied by @xmath227 , and hence , the unfolding of the fourth rule of @xmath394 is the set of rules @xmath398 , i.e. , @xmath399 is the following program : @xmath400 this program does not have any answer set .",
    "thus , @xmath227 is not an @xmath0-answer set of @xmath394 ( according to definition [ def - general ] ) . *",
    "consider @xmath401 we have that @xmath69 is satisfied by @xmath402 .",
    "hence , @xmath403 is obtained from @xmath394 by replacing its fourth rule with the two rules @xmath404 @xmath403 has @xmath402 as an answer set .",
    "therefore , @xmath402 is an @xmath0-answer set of @xmath394 .",
    "similar to the second item , we can show that @xmath405 are answer sets of @xmath394.@xmath179",
    "in this section , we relate our definition of @xmath0-answer sets to several formulations of aggregates proposed in the literature .",
    "we begin with a comparison of our unfolding approach with the two most recently proposed semantics for lp with aggregates , i.e. , the _ ultimate stable model semantics _",
    "@xcite , the _ minimal answer set semantics _",
    "@xcite , and the semantics for abstract constraint atoms @xcite .",
    "we then relate our work to earlier proposals , such as perfect models of aggregate - stratified programs ( e.g. , @xcite ) , the fixpoint answer set semantics of aggregate - monotonic programs @xcite , and the semantics of programs with weight constraints @xcite .",
    "finally , we briefly discuss the relation of @xmath0-answer sets to other proposals .      the doctoral thesis of pelov @xcite contains a nice generalization of several semantics of logic programs to the case of logic programs with aggregates .",
    "the key idea in his work is the use of approximation theory in defining several semantics for logic programs with aggregates ( e.g. , two - valued semantics , ultimate three - valued stable semantics , three - valued stable model semantics ) . in particular , in @xcite , the author describes a fixpoint operator , called @xmath406 , operating on 3-valued interpretations and parameterized by the choice of approximating aggregates .",
    "the results presented in @xcite allow us to conclude the following result .",
    "given a program with aggregates @xmath3 , @xmath15 is a @xmath0  answer set of @xmath3 if and only if @xmath15 is the least fixpoint of @xmath407 , where @xmath408 denotes the first component of @xmath409 .",
    "the work of pelov includes also a translation of logic programs with aggregates to normal logic programs , denoted by @xmath410 , which was first given in @xcite and then in @xcite .",
    "the translation in @xcite ( independently developed ) and the unfolding proposed in section [ sec2 ] have strong similarities .",
    "for the completeness of the paper , we will review the basics of the translation of @xcite , expressed using our notation . given a logic program with aggregates @xmath3",
    ", @xmath411 denotes the normal logic program obtained after the translation .",
    "the translation begins with the translation of each aggregate atom @xmath412 into a disjunction @xmath413 where @xmath414 is the set of atoms of @xmath10the predicate of @xmath59in @xmath32 , @xmath415 belongs to an index set , @xmath416 , and each @xmath417 is a conjunction of the form @xmath418 the construction of @xmath419 considers only pairs @xmath415 satisfying the following condition : every interpretation @xmath118 such that @xmath420 and @xmath421 also satisfies @xmath69 .",
    "@xmath411 is then created by rewriting rules with disjunction in the body by a set of rules in a straightforward way .",
    "for example , the rule @xmath422 is replaced by the two rules @xmath423 we can prove a lemma that connects @xmath211 and @xmath411 .",
    "[ tr1 ] for every aggregate atom @xmath412 , @xmath2 is a solution of @xmath69 if and only if @xmath424 is a disjunct in @xmath419 .",
    "* the result is a trivial consequence of the definition of a solution and the definition of @xmath419 .",
    "@xmath179    this lemma allows us to prove the following relationship between @xmath211 and @xmath411 .    for every program @xmath3",
    ", @xmath80 is an @xmath0-answer set of @xmath3 if and only if @xmath80 is an exact stable model of @xmath3 with respect to @xcite .",
    "* proof . *",
    "the result is a trivial consequence of the fact that @xmath425 and @xmath411 has the same set of partial stable models as @xmath3 @xcite .",
    "@xmath179      in this subsection , we investigate the relationship between @xmath0-answer sets and the notion of answer set defined by _",
    "faber et al .",
    "_ in @xcite .",
    "the notion of answer set proposed in @xcite is based on a new notion of reduct , defined as follows . given a program @xmath3 and a set of atoms @xmath2 , the _ reduct of p with respect to s _ , denoted by @xmath426 , is obtained by removing from @xmath104 those rules whose body is not satisfied by @xmath2 . in other words , @xmath427 the novelty of this reduct is that it _ does not _",
    "remove aggregate atoms and negation - as - failure literals satisfied by @xmath2 .",
    "[ flp - answer set , @xcite ] [ d - faberlp04 ] for a program @xmath3 , @xmath2 is a _ flp - answer set _ of @xmath3 iff it is a minimal model of @xmath428 .",
    "observe that the definition of an answer set in this approach _ explicitly _ requires answer sets to be minimal , thus requiring the ability to determine minimal models of a program with aggregates . in the following propositions",
    ", we will show that @xmath0-answer sets of a program @xmath3 are flp - answer sets and that flp - answer sets of @xmath3 are minimal models of @xmath211 , but not necessary @xmath0-answer sets .",
    "[ th2 ] let @xmath3 be a program with aggregates .",
    "if @xmath15 is an @xmath0-answer set , then @xmath15 is a flp - answer set of @xmath3 .",
    "if @xmath15 is a flp - answer set of @xmath3 then @xmath15 is a minimal model of @xmath211 .",
    "*    * let @xmath429 .",
    "since @xmath15 is an @xmath0-answer set , we have that @xmath15 is an answer set of @xmath357 .",
    "lemma [ lem2 ] shows that @xmath15 is a model of @xmath104 and hence is a model of @xmath430 .",
    "+ let us assume that @xmath15 is not a minimal model of @xmath356 .",
    "this means that there exists @xmath431 such that @xmath432 is a model of @xmath433 .",
    "+ we will show that @xmath432 is a model of @xmath434 where @xmath435 is the result of the gelfond - lifschitz transformation of the program @xmath357 with respect to @xmath15 .",
    "+ consider a rule @xmath436 such that @xmath437 , i.e. , @xmath438 . from the definition of the gelfond - lifschitz transformation , we conclude that there exists some @xmath368 such that @xmath439 and @xmath242 .",
    "this implies that there is a rule @xmath236 and a sequence of solutions @xmath237 of aggregates in @xmath8 such that @xmath201 is the unfolding of @xmath8 with respect to @xmath237 and for every @xmath247 , @xmath440 and @xmath240 . since @xmath441",
    ", we can conclude that @xmath442 , i.e. , @xmath443 .",
    "furthermore , @xmath444 because @xmath445 , @xmath446 and @xmath242 , and for every @xmath247 , @xmath440 and @xmath447 .",
    "since @xmath432 is a model of @xmath356 , we have that @xmath448 .",
    "since @xmath449 , we have that @xmath432 satisfies @xmath450 .",
    "this holds for every rule of @xmath451 .",
    "thus , @xmath432 is a model of @xmath357 .",
    "this contradicts the fact that @xmath15 is an answer set of @xmath357 .",
    "* let @xmath15 be a flp - answer set of @xmath3 . clearly , @xmath15 is a model of @xmath104 and hence of @xmath211 .",
    "if @xmath15 is not a minimal model of @xmath211 , there exists some @xmath431 which is a model of @xmath211 .",
    "lemma [ lem1 ] implies that @xmath432 is a model of @xmath104 and hence is a model of @xmath452 .",
    "this is a contradiction with the assumption that @xmath15 is a flp - answer set of @xmath3 .",
    "thus , we can conclude that @xmath15 is a minimal model of @xmath211 .",
    "the next example shows that flp - answer sets might not be @xmath0-answer sets .",
    "[ p5 ] consider the program @xmath453 where @xmath454 the interpretation @xmath455 is a flp - answer set of @xmath453 .",
    "we will show next that @xmath453 does not have an answer set according to our definition .",
    "it is possible to show . ]",
    "that the aggregate atom @xmath456 has the following solutions with respect to @xmath457 : @xmath458 , @xmath459 , @xmath460 , @xmath461 , and @xmath462 .",
    "the unfolding of @xmath453 , @xmath463 , consists of the following rules : @xmath464 it is easy to see that @xmath463 does not have answer sets .",
    "thus , @xmath453 does not have @xmath0-answer sets.@xmath179    [ rem1 ] if we replace in @xmath453 the rule @xmath465 with the intuitively equivalent smodels weight constraint rule @xmath466.\\ ] ] we obtain a program that does not have answer sets in smodels .",
    "the above example shows that our characterization of programs with aggregates differs from the proposal in @xcite .",
    "apart from the lack of support for aggregates in the heads of rules , the semantics of  @xcite might accept answer sets that are not @xmath0-answer sets .",
    "observe that the two semantical characterizations coincide for large classes of programs ( e.g. , for programs that have only monotone aggregates ) .",
    "a very general semantic characterization of programs with aggregates has been proposed by marek and truszczyski in  @xcite .",
    "the framework offers a model where general aggregates can be employed both in the body and in the head of rules .",
    "the authors introduce the notion of abstract constraint atom , @xmath467 , where @xmath50 is a set of atoms ( the domain of the aggregate ) and @xmath468 is a subset of @xmath469 ( the solutions of the aggregate ) .",
    "for an abstract constraint atom @xmath470 , we will denote @xmath50 with @xmath471 and @xmath468 with @xmath472 . in @xcite ,",
    "the focus is only on _ monotone constraints _ ,",
    "i.e. , constraints @xmath467 , where if @xmath473 then all supersets of @xmath309 are also in @xmath468 .",
    "a program with monotone constraints is a set of rules of the form @xmath474 where each @xmath475 ( @xmath476 ) is an abstract constraint atom . abusing the notation , for a rule @xmath8 of the above form , we use @xmath79 , @xmath83 , @xmath85 , and @xmath87 to denote @xmath477 , @xmath478 , @xmath479 , and @xmath480 , respectively .",
    "the semantics of this language is developed as a generalization of answer set semantics for normal logic programs . to make the paper",
    "self - contained , we briefly review the notion of a stable model for a program with monotone constraints .",
    "an interpretation @xmath15 satisfies @xmath481 , denoted by @xmath482 , if @xmath483 ( or @xmath484 ) . @xmath485 if @xmath486 . for a set of literals",
    "@xmath2 , @xmath487 if @xmath488 for each @xmath489 . for a program with monotone constraints @xmath3",
    ", @xmath490 denotes the set @xmath491 .",
    "given a set of atoms @xmath2 , a rule @xmath8 is _ applicable _ in @xmath2 if @xmath492 .",
    "the set of applicable rules in @xmath2 is denoted by @xmath493 .",
    "a set @xmath494 is _ nondeterministically one - step provable _ from @xmath2 by means of @xmath3 if @xmath495 and @xmath496 for every @xmath497 .",
    "nondeterministic one - step provability operator _",
    "@xmath498 is a function from @xmath499 to @xmath500 , where @xmath501 denotes the herbrand base of @xmath3 , such that for every @xmath502 , @xmath503 consists of all sets @xmath494 that are nondeterministically one - step provable from @xmath2 by means of @xmath3 .",
    "a sequence @xmath504 is called a _",
    "p - computation _",
    "if @xmath505 and for every non - negative integer @xmath318 ,    * @xmath506 , and * @xmath507 .",
    "@xmath508 is called the _ result _ of the computation @xmath509 .",
    "a set of atoms @xmath2 is a _",
    "derivable model _ of @xmath3 if there exists a @xmath3-_computation _ @xmath509 such that @xmath510 .",
    "for a monotone program @xmath3 and a set of atoms @xmath15 , the _ reduct _ of @xmath3 with respect to @xmath15 , denoted by @xmath375 , is obtained from @xmath3 by ( _ i _ ) removing from @xmath3 every rule containing in the body a literal @xmath511 such that @xmath482 ; and ( _ ii _ ) removing all literals of the form @xmath511 from the remaining rules .",
    "a set of atoms @xmath512 is an _ stable model _ of a monotone program @xmath3 if @xmath15 is a derivable model of the reduct @xmath375 .    observe that each aggregate atom @xmath69 in our notation can be represented by an abstract constraint atom @xmath513 , where @xmath514 .",
    "furthermore , an atom @xmath515 can be represented as an abstract constraint atom @xmath516 .",
    "thus , each program @xmath3 , as a set of rules of the form ( [ agg - rule-2 ] ) , could be viewed as a program with abstract constraint atoms @xmath517 , where @xmath517 is obtained from @xmath3 by replacing every occurrence of an aggregate atom @xmath69 or an atom @xmath515 in @xmath3 with @xmath518 or @xmath516 respectively .",
    "the monotonicity of an abstract constraint atom implies the following :    [ obs2 ] let @xmath69 be an aggregate atom and @xmath15 be a set of atoms such that @xmath519 is a monotone constraint and @xmath520 .",
    "then , @xmath521 is a solution of @xmath69 .    using this observation , we can related the notions of @xmath0-answer set and of stable models for programs with monotone atoms as follows .",
    "let @xmath3 be a program with monotone aggregates .",
    "@xmath15 is an @xmath0  answer set of @xmath3 iff @xmath15 is a stable model of @xmath517 according to @xcite .",
    "* for each rule @xmath11 , let @xmath522 be the rule in @xmath517 which is obtained from @xmath8 by the translation from @xmath3 to @xmath517 .    1 .",
    "let us assume @xmath15 is a stable model of @xmath517 according to  @xcite .",
    "a result in @xcite shows that @xmath523 where @xmath524 we will show that @xmath15 is a @xmath0  answer set of @xmath3 by proving that @xmath525 where @xmath526 and @xmath303 the aggregate - free head reduct of @xmath3 with respect to @xmath15 ( definition [ aggheadfree ] ) .",
    "+ let us start by showing that @xmath527 for @xmath476 , using induction on @xmath528 .",
    "the result is obvious for @xmath529 .",
    "let us assume the result to hold for @xmath530 and let us consider the case of @xmath531 . by the definition of @xmath42 s , @xmath532 implies that @xmath533 .",
    "this means that there is a rule @xmath534 such that @xmath535 for @xmath536 , @xmath537 , and @xmath538 . from @xmath539 , @xmath540 , and the monotonicity of @xmath475",
    ", we have that @xmath541 . from observation  [ obs2 ] and the monotonicity of the aggregates",
    ", we can infer that there is a rule in @xmath357 with @xmath542 and @xmath543 .",
    "thus , @xmath544 . the inductive step is proved .",
    "this allows us to conclude that @xmath545 .",
    "+ on the other hand , we can easily show that @xmath15 is a model of @xmath357 , thus @xmath546 .",
    "this allows us to conclude that @xmath547 . together with @xmath545 , we have that @xmath15 is an @xmath0  answer set of @xmath3 .",
    "2 .   let @xmath15 be an @xmath0  answer set of @xmath3 and @xmath526 where @xmath303 is the aggregate - free head reduct of @xmath3 with respect to @xmath15 .",
    "thus , @xmath548 . + we will prove that @xmath15 is a stable model of @xmath3 by showing that the sequence @xmath549 , for @xmath476 , is a p - computation .",
    "obviously , we have that ( _ i. _ ) @xmath550 and ( _ ii _ ) @xmath551 for @xmath552 .",
    "it remains to be shown that ( _ iii _ ) @xmath553 for @xmath476 .",
    "+ in order to prove the property ( _ iii _ ) we need to show that ( _ iv _ ) @xmath554 and ( _ v _ ) @xmath555 for each @xmath522 in @xmath556",
    ". + let us consider @xmath557 .",
    "this means that there exists some rule @xmath201 in @xmath357 such that @xmath558 and @xmath369 .",
    "let @xmath8 be the rule in @xmath3 such that @xmath201 is obtained from @xmath8 ( as specified in definitions [ aggheadfree]-[dunfolding2 ] ) .",
    "this implies @xmath559 , @xmath560 , and @xmath561 for every @xmath247 . from the monotonicity of aggregates in @xmath3",
    ", we can conclude that @xmath562 and @xmath563 .",
    "this holds for every @xmath564 .",
    "hence , we have that @xmath554 , i.e. , ( _ iv _ ) is proved . +",
    "now let us consider a rule @xmath562 .",
    "this implies that the rule @xmath8 , from which @xmath522 is obtained , satisfies that @xmath559 , @xmath560 , and @xmath561 for every @xmath247 .",
    "again , the monotonicity of aggregates in @xmath3 implies that @xmath250 for every @xmath247 . by the definition of @xmath357",
    ", we have that for each @xmath565 , there exists a rule @xmath566 such that @xmath567 and @xmath568 . as such , @xmath569 .",
    "this means that @xmath570 , i.e. , ( _ v _ ) is proved .",
    "the proposal of ferraris @xcite applies a novel notion of reduct and answer sets , developed for propositional theories , to the case of aggregates containing arbitrary formulae . the intuition behind the notion of satisfaction of an aggregate relies on translating aggregates to propositional formulae that guarantee that all cases where the aggregate is false are ruled out .",
    "in particular , for an aggregate of the form @xmath571 , where @xmath572 are propositional formulae , @xmath573 and @xmath356 are real numbers , @xmath574 is a function from multisets of real numbers to @xmath575 , and @xmath576 is a relational operator ( e.g. , @xmath66 , @xmath65 ) , the transformation leads to the propositional formula : @xmath577 the results in  @xcite show that the new notion of reduct , along with this translation for aggregates , applied to the class of logic programs with aggregates of @xcite , captures exactly the class of flp - answer sets .",
    "let us consider the weight constraints employed by smodels and let us describe a translation method to convert them into our language with aggregates .",
    "we will focus on weight constraint that are used in the body of rules ( see sect .",
    "[ heads ] for aggregates in the heads of rules ) . for simplicity , we will also focus on weight constraints with non - negative weights ( the generalization can be obtained through algebraic manipulations , as described in @xcite ) .",
    "a _ ground _",
    "weight constraint @xmath121 has the form : @xmath578 where @xmath579 are ground atoms , and @xmath580 are numeric constants .",
    "@xmath581 s and @xmath582 s are called literals of @xmath121 . @xmath583 denotes the set of literals of @xmath121 .",
    "the local weight function of a constraint @xmath121 , @xmath584 , returns the weight of its literals .",
    "for example , @xmath585 and @xmath586 .",
    "the weight of a weight constraint @xmath121 in a model @xmath2 , denoted by @xmath587 , is given by @xmath588    we will now show how weight constraints in smodels can be translated into aggregates in our language . for each weight constraint @xmath121 , let @xmath589 and @xmath590 be two new predicates which do not belong to the language of @xmath3 .",
    "let @xmath591 be the set of following rules : @xmath592 intuitively , @xmath593 assign a specific weight to each literal originally present in the weight constraint .",
    "the weight constraint itself is replaced by a conjunction @xmath594 : @xmath595 where sum is an aggregate function with its usual meaning .    given an smodels program @xmath3 , let @xmath596 be the program obtained from @xmath3 by replacing every weight constraint @xmath121 in @xmath3 with @xmath594 and adding the set of rules @xmath597 to @xmath3 where @xmath598 .",
    "for each set of atoms @xmath2 , let us denote with @xmath599 .",
    "is the immediate consequence operator of program @xmath597 .",
    "] we have that @xmath600 this implies the following lemma .",
    "let @xmath2 be a set of atoms and @xmath121 be a weight constraint . for @xmath599 , @xmath601    * proof .",
    "* follows directly from equation [ hats ] and the definition of @xmath587 . @xmath179    [ weightc ] given a set of atoms @xmath2 and a weight constraint @xmath121 , @xmath602 iff @xmath603 .",
    "the next theorem relates @xmath3 and @xmath596 .",
    "let @xmath3 be a ground smodels program with weight constraints only in the body and with no negative literals in the weight constraints .",
    "let @xmath596 be its translation to aggregates .",
    "it holds that    1 .",
    "if @xmath2 is an smodels answer set of @xmath3 then @xmath604 is an @xmath0-answer set of @xmath596 ; 2 .",
    "if @xmath605 is an @xmath0-answer set of @xmath596 then @xmath606 is a _ minimal _",
    "smodels answer set of @xmath3",
    ".    * proof .",
    "* since negation - as - failure literals can be replaced by weight constraints , without loss of generality , we can assume that @xmath3 is a positive program with weight constraints .",
    "let @xmath2 be a set of atoms and @xmath356 be the smodels reduct of @xmath3 with respect to @xmath2 .",
    "furthermore , let @xmath607 .",
    "using corollary [ weightc ] , we can prove by induction on @xmath316 that if @xmath2 is an smodels answer set of @xmath3 ( resp .",
    "@xmath604 is an answer set of @xmath596 ) then    1 .",
    "@xmath608 for @xmath359 2 .",
    "@xmath609 for @xmath359    this proves the two items of the theorem .",
    "the idea of the proof is as follows .",
    "the base case follows from the fact that facts in @xmath356 are either facts of @xmath3 or heads of rules whose body can be reduced by smodels - reduction , i.e. , all the weight constraints are satisfied by @xmath2 . on the other hand , facts in @xmath357",
    "are either facts of @xmath3 or heads of rules whose aggregate atoms has a solution @xmath610 which corresponds to the second type of fact in @xmath356 .",
    "the inductive step is proved using corollary [ weightc ] and the construction of @xmath611 . @xmath179    the following example , used in @xcite to show that smodels - semantics for weight constraints is counter - intuitive in some cases , indicates that the equivalence does not hold when negative literals are allowed in the weight constraint .",
    "let us consider the smodels program @xmath612 @xmath613 according to the semantics described in @xcite , we can observe that , for @xmath614 , the reduct @xmath615 is @xmath191 making it an answer set of @xmath612 .",
    "for @xmath616 , the reduct @xmath615 is @xmath617 thus making @xmath618 an answer set of @xmath612 .    on the other hand , the intuitively equivalent program using aggregates ( we make use of the obvious extension that allows negations in the aggregate ) is : @xmath619 the unfolding of this program is @xmath620 which has the single answer set @xmath191 .",
    "@xmath179    instead of the set of rules @xmath591 , we use the following set of rules @xmath621 and @xmath622    the program @xmath623 will become @xmath624 the aggregate atom has a unique solution @xmath625 .",
    "this leads to the unfolding @xmath626 which do have two answer sets @xmath13 and @xmath627 which correspond to the two smodels answer sets @xmath13 and @xmath191 .",
    "various forms of stratification ( e.g. , lack of recursion through aggregates ) have been proposed to syntactically identify classes of programs that admit a unique minimal model , e.g. , local stratification @xcite , modular stratification @xcite , and xy - stratification @xcite .",
    "efficient evaluation strategies for some of these classes have been investigated ( e.g. , @xcite ) .",
    "let us show that the simpler notion of aggregate stratification leads to a unique @xmath0  answer set .",
    "the program with aggregates @xmath3 is aggregate - stratified if there is a function @xmath628 such that , for each rule @xmath629 in @xmath3 ,    * @xmath630 if @xmath631 is an asp - atom ; * @xmath632 if @xmath631 is the asp - literal @xmath633 ; and * @xmath634 if @xmath635 is an aggregate atom with @xmath10 as the predicate of @xmath59 .    the notion of _ perfect model _ is defined as follows .",
    "[ perfect model , @xcite ] the _ perfect model _ of an aggregate - stratified program @xmath3 is the minimal model @xmath15 such that    @xmath636=-2pt    if @xmath432 is another model of @xmath3 , then the extension of each predicate @xmath10 of level @xmath637 in @xmath15 is a subset of the extension of @xmath10 in @xmath432    if @xmath432 is another model of @xmath3 such that @xmath15 and @xmath432 agree on the predicates of all levels up to @xmath528 , then the extension of each predicate at level @xmath638 in @xmath15 is a subset of the extension of the same predicate in @xmath432    from @xcite we learn that each aggregate - stratified program has a unique perfect model .",
    "we will show next that @xmath0-answer sets for aggregate - stratified programs are perfect models .",
    "let @xmath3 be an aggregate - stratified program @xmath3 .",
    "the following holds :    1 .",
    "if @xmath15 is an @xmath0-answer set of @xmath3 then @xmath15 is the perfect model of @xmath3 .",
    "the perfect model of @xmath3 is an @xmath0-answer set of @xmath3 .",
    "* let @xmath639 be the set of rules in @xmath3 whose head has the level @xmath528 and @xmath640 be the set of atoms in @xmath15 whose level is @xmath528 .    1 .",
    "let @xmath15 be an @xmath0-answer set of @xmath3 .",
    "let @xmath355 . by the definition of answer sets ,",
    "we know that @xmath641 where @xmath642 is the immediate consequence operator for @xmath357 . since @xmath15 is an @xmath0-answer set of @xmath3 , we know that @xmath15 is also a model of @xmath3 ( theorem [ th1 ] ) .",
    "assume that @xmath15 is not the perfect model of @xmath3 , i.e. , the perfect model of @xmath3 is @xmath432 and @xmath643 .",
    "we have that * @xmath644 is a definite program .",
    "thus , @xmath645 .",
    "this means that @xmath646 is the least model of @xmath644 , which implies that @xmath647 .",
    "* let us assume that @xmath15 and @xmath432 agree on the levels up to @xmath316 and let us assume @xmath648 . in particular ,",
    "let us consider the first atom @xmath10 with such property introduced in @xmath15 by the iterations of @xmath642 .",
    "this means that there exists a rule @xmath649 such that @xmath650 and @xmath651 . because @xmath649 we can conclude that there exists some @xmath243 such that @xmath439 and @xmath242",
    "this implies that there exists a rule @xmath11 and a sequence of aggregate solutions @xmath237 such that @xmath239 and @xmath240 for @xmath247 and @xmath201 is the unfolding of @xmath8 with respect to @xmath237 .",
    "since @xmath15 and @xmath432 agree on the levels up to @xmath316 , this implies that @xmath652 for every @xmath247 , @xmath653 , and @xmath654 .",
    "thus , @xmath444 . because @xmath432 is a model of @xmath3 , we have that @xmath655 .",
    "this contradicts the fact that @xmath656 , i.e. , @xmath15 is the perfect model of @xmath3 .",
    "2 .   let @xmath15 be the perfect model of @xmath3 .",
    "we will show that @xmath15 is an @xmath0-answer set of @xmath3 .",
    "lemma [ lem1 ] implies that @xmath15 is a model of @xmath211 , and in particular @xmath15 is a model of @xmath355 .",
    "assume that @xmath15 is not an @xmath0-answer set .",
    "this means that it is not the minimal model of @xmath357 , i.e. , there exists @xmath431 which is the minimal model of @xmath357 .",
    "we will show that the existence of @xmath432 violates the minimality nature of the perfect model .",
    "we have that * @xmath644 is a collection of definite clauses .",
    "thus , @xmath646 is the least model of @xmath644 .",
    "since @xmath657 is a model of @xmath644 then we must have @xmath647 .",
    "* let @xmath15 and @xmath432 agree on the levels up to @xmath316 ; if we consider the program @xmath658 with the interpretation of all predicates of levels @xmath659 fixed , we are left with a definite program , whose least model is @xmath660 from definition . as @xmath661 is also a model ,",
    "we have that it must coincide with @xmath660 . +",
    "this proves the second part of the theorem . @xmath179",
    "the following corollary follows directly from the fact that an aggregate - stratified program has a unique perfect model and the above theorem .",
    "every aggregate - stratified program admits a unique @xmath0-answer set .",
    "we believe that this equivalence can be easily proved for other forms of aggregate - stratification .",
    "the notion of _ monotone programs _ has been introduced in @xcite , and later elaborated by other researchers ( e.g. , @xcite ) , as another class of programs for which the existence of a unique intended model is guaranteed , even in presence of recursion through aggregation . the notion of monotone programs , defined only for programs with aggregates and without negation , is as follows .",
    "[ monotonic ] let @xmath574 be a collection of base predicates and @xmath662 be an interpretation of @xmath574 .",
    "a program @xmath3 is _ monotone _ with respect to @xmath662 if , for each rule @xmath8 in @xmath104 where @xmath663 , and for all interpretations @xmath118 and @xmath664 , where @xmath665 , we have that @xmath148 implies @xmath666",
    ".    we will follow the convention used in @xcite of fixing the set of base predicates @xmath574 to be equal to the set of edb predicates , i.e. , it contains only predicates which do not occur in the head of rules of @xmath3 .",
    "this will also mean that @xmath662 is fixed and @xmath662 is true in every interpretation of the program @xmath3 .",
    "as such , instead of saying that @xmath3 is monotone with respect to @xmath662 , we will often say that @xmath3 is monotone whenever there is no confusion .    for a monotone program @xmath3 with respect to the interpretation @xmath662 of a set of base",
    "predicates @xmath574 , the fixpoint operator , denoted by @xmath667 , is extended to include @xmath662 as follows : @xmath668 it can be shown that @xmath667 is monotone and hence has a unique least fixpoint , denoted by @xmath669 .",
    "we will next prove that monotonicity also implies uniqueness of @xmath0-answer sets .",
    "first , we prove a simple observation characterizing aggregate solutions in monotone programs .",
    "[ obs1 ] let @xmath3 be a monotone program with respect to @xmath662 and @xmath8 be a rule in @xmath104 .",
    "assume that @xmath247 and @xmath670 is a solution of @xmath121 .",
    "then , @xmath671 is also a solution of @xmath121 .",
    "* proof . * due to the monotonicity of @xmath3 we have that @xmath250 for every interpretation @xmath15 satisfying the condition @xmath239 .",
    "this implies that @xmath671 is a solution of @xmath121 .",
    "let @xmath303 be a monotone program w.r.t .",
    "@xmath662 and let @xmath672 .",
    "then @xmath673 is an @xmath0-answer set of @xmath3 .",
    "* let @xmath674 , @xmath675 , and @xmath676 .",
    "we will prove that @xmath677 .",
    "first of all , observe that @xmath678 , since the elements of @xmath662 are present as facts in @xmath3 . since the predicates used in @xmath662 do not appear as head of any other rule in @xmath303 , in the rest we can focus on the elements of @xmath679 which are distinct from @xmath662 .",
    "* @xmath441 : we prove by induction on @xmath316 that @xmath680 .",
    "the result is obvious for @xmath363 .",
    "assume that @xmath681 and consider @xmath682 .",
    "this implies that there is a rule @xmath368 such that @xmath683 and @xmath684 .",
    "this means that there exists a rule @xmath236 and a sequence of aggregate solutions @xmath237 such that @xmath201 is obtained from @xmath685 , which is the unfolding of @xmath8 with respect to @xmath237 , by removing @xmath686 from its body , i.e. , @xmath687 .",
    "this implies that * * @xmath688 * * @xmath689 and @xmath684 * * @xmath690 and @xmath687 . +",
    "this implies that @xmath250 for every @xmath691 , @xmath248 , and @xmath249 .",
    "this allows us to conclude that @xmath442 . by the definition of @xmath692",
    ", we have that @xmath693 . *",
    "@xmath694 : we will show that @xmath695 for @xmath359 .",
    "we prove this by induction on @xmath316 .",
    "the result is obvious for @xmath363 .",
    "assume that @xmath696 .",
    "consider @xmath697 .",
    "this implies the existence of a rule @xmath236 such that @xmath542 and @xmath698 .",
    "this means that @xmath699 and @xmath700 for every @xmath247 . from proposition  [ obs1 ] , we know that there exists a sequence of aggregate solutions @xmath237 such that @xmath701 and @xmath702 .",
    "this implies that @xmath201 , the unfolding of @xmath8 with respect to @xmath237 , is a rule in @xmath357 and @xmath703 .",
    "hence , @xmath704 .",
    "the above results allow us to conclude that @xmath677 . @xmath179    since @xmath669 is unique , we have the following .",
    "every monotone program admits exactly one @xmath0-answer set .",
    "another semantic characterization of aggregates that has been adopted by several researchers @xcite can be simply described as follows .",
    "given a program @xmath3 and an interpretation @xmath15 , let @xmath705 be the program obtained by :    * removing all the rules with an aggregate atom or a negation - as - failure literal which is false in @xmath15 ; and * removing all the remaining aggregate atoms and negation - as - failure literals .",
    "@xmath15 is a",
    "_ stable set _ of @xmath3 if @xmath15 is the least model of @xmath705 .",
    "we can prove the following result .",
    "let @xmath3 be a program with aggregates .",
    "if @xmath15 is an @xmath0-answer set of @xmath3 , then @xmath15 is a stable set of @xmath3 .",
    "* proof : * let @xmath706 and let us denote with @xmath707 .",
    "let us show that @xmath708 .",
    "first , let us show that @xmath709 ; we will accomplish this by showing @xmath710 by induction on @xmath316 . for @xmath363 ,",
    "the result is obvious .",
    "let us assume that @xmath710 and let us consider @xmath711 .",
    "this means that there is a rule @xmath712 in @xmath357 such that @xmath713 and @xmath714 .",
    "this means that there is a rule @xmath715 in @xmath211 , @xmath716 and @xmath717 . in turn",
    ", there is a rule @xmath718 in @xmath3 such that @xmath719 is an unfolding of @xmath81 . since @xmath720 and @xmath721 , then @xmath722",
    "this implies that @xmath723 is in @xmath356 ; since @xmath724 then @xmath725 .",
    "second , let us show that @xmath726 ; we will accomplish this by showing that @xmath727 by induction on @xmath316 .",
    "the result is obvious for @xmath363 .",
    "let us consider @xmath728 and let us now consider @xmath729 .",
    "this means that there is a rule @xmath730 in @xmath356 such that @xmath731 .",
    "this means that there is a rule @xmath732 in @xmath3 such that @xmath733 and @xmath734 .",
    "this means that there is an unfolding of this rule of the form @xmath715 and @xmath735 and @xmath736 .",
    "this implies that @xmath737 is in @xmath357 , @xmath738 and @xmath739 , and finally @xmath740 .",
    "@xmath179    the converse is not true in general , since stable sets could be not minimal with respect to set inclusion .",
    "for example , the program @xmath220 in example [ exp2 ] has @xmath741 as a stable set .",
    "a somewhat different direction has been explored in @xcite .",
    "the semantics proposed in @xcite relies on approximation theory , and does not in general coincide with answer set semantics on normal programs .",
    "the work in @xcite addresses this problem and provides a new semantics for aggregate programs which guarantees minimality of total answer sets , as in our case .",
    "we discussed the relationship between the work in @xcite and ours in subsection [ pelov ] .",
    "in this section , we present a program with aggregates in which the unfolding transformation ( as well as the translation discussed in @xcite ) is not applicable .",
    "we also briefly discuss the computational complexity issues related to the class of logic programs with aggregates .",
    "the key idea of our approach lies in that , if an aggregate atom is satisfied in an interpretation , one of its solutions must be satisfied .",
    "since our main interest is in the class of programs whose answer sets can be computed by currently available answer set solvers , we are mainly concerned with finite programs and aggregate atoms with finite solutions . here , by a finite solution we mean a solution @xmath2 whose components @xmath167 and @xmath168 are finite sets of atoms . certain modifications to our approach might be needed to deal with programs with infinite domains which can give raise to infinite solutions .",
    "for example , consider the program @xmath742 which consists of the rules : @xmath743 it is easy to see that the aggregate atom @xmath744 has two aggregate solutions , @xmath745 and @xmath746 , where @xmath747 both solutions are infinite .",
    "as such , the unfolded version of program @xmath742 is no longer a normal logic program  in the sense that it contains some rules whose body is not a _",
    "finite _ set of asp - literals .",
    "presently , it is not clear how the unfolding approach can be employed in this type of situations .    in @xcite , we provide an alternative definition of @xmath0   answer sets which utilizes the notion of solutions but does not employ the unfolding transformation .",
    "this semantics yields the intuitive answer for @xmath742 .      our main goal in this paper is to develop a framework for dealing with aggregates in answer set programming .",
    "as we have demonstrated in section [ impl ] , the proposed semantics can be easily integrated to existing answer set solvers . in @xcite",
    ", we proved that the complexity of checking the existence of an answer set of a program with aggregates depends on the complexity of evaluating aggregate atoms and on the complexity of checking aggregate solutions .",
    "in particular , we proved that there are large classes of programs , making use of the standard aggregate functions ( e.g. , sum , min ) , for which the answer set checking problem is tractable and the problem of determining the existence of an answer set is in * np*. these results are in line with similar results presented in @xcite .",
    "in this paper , we presented two equivalent definitions of answer sets for logic programs with arbitrary aggregates , and discussed an implementation of an answer set solver for programs with aggregates .",
    "our definitions are based on a translation process , called _ unfolding _ , which reduces programs with aggregates to normal logic programs .",
    "the translation builds on the general idea of _ unfolding of intensional sets _",
    "@xcite , explored in our previous work to handle intensional sets in constraint logic programming .",
    "key to our definitions is the notion of a _ solution _ of an aggregate atom .",
    "our first definition can be viewed as an alternative characterization of the semantics of logic programs with arbitrary aggregates developed in @xcite .",
    "in fact , the first form of unfolding used in characterizing the semantics of lp with aggregates corresponds to an independently developed translation approach proposed in  @xcite , which captures the same meaning as the semantics  based on approximation theory  described in @xcite .    to allow aggregate atoms in the head",
    ", we developed a second translation scheme , which unfolds a program with aggregates w.r.t .",
    "a provisional answer set .",
    "the result of this process is a _ positive program _ which can be used to verify whether or not the provisional answer set is indeed an answer set of the original program .",
    "we discussed how the second unfolding can be extended to deal with programs with aggregate atoms as heads of rules .",
    "we related the semantics for logic programs with aggregates defined in this paper to other proposals in the literature .",
    "we showed that it coincides with various existing proposals on large classes of programs ( e.g. , stratified programs and programs with monotone aggregates ) .",
    "we also noticed that there are some subtle differences between distinct semantic characterizations recently proposed for logic programming with aggregates .",
    "as future work , we propose to investigate formalizations of semantics of aggregates that can be parameterized in such a way to cover the most relevant existing proposals .",
    "our future work includes also an investigation of whether our alternative characterization for answer sets , based on unfolding w.r.t .",
    "a given interpretation , can be used to improve the performance of our implementation .",
    "we would like to thank vladimir lifschitz and michael gelfond for the numerous discussions , related to the topics of this paper .",
    "we also wish to thank the anonymous referees of a preliminary version of this work , for their helpful comments .",
    "the authors have been supported by the nsf grants cns-0220590 , cns-0454066 , and hrd-0420407 .",
    "the description of the system @xmath0  has been presented in @xcite .",
    "m. denecker , n. pelov , and m. bruynooghe .",
    "ultimate well - founded and stable semantics for logic programs with aggregates . in _ international conference logic programming _ , pages 212226 .",
    "springer verlag , 2001 .",
    "i. elkabani , e. pontelli , and t. c. son .",
    "smodels with clp and its applications : a simple and effective approach to aggregates in asp . in _ international conference on logic programming _ , pages 7389 .",
    "springer verlag , 2004 .",
    "i. elkabani , e. pontelli , and t. c. son .",
    "smodels@xmath748  a system for computing answer sets of logic programs with aggregates . in _ logic programming and non - monotonic reasoning _ , pages 427431 .",
    "springer verlag , 2005 .",
    "i.  niemel and p.  simons .",
    "smodels - an implementation of the stable model and well - founded semantics for normal logic programs . in _ logic programming and non - monotonic reasoning _ , springer verlag , pages 420429 , 1997 .",
    "n. pelov , m. denecker , and m. bruynooghe .",
    "partial stable models for logic programs with aggregates . in _ international conference on logic programming and non - monotonic reasoning _ , pages 207219 .",
    "springer verlag , 2004 ."
  ],
  "abstract_text": [
    "<S> the paper presents two equivalent definitions of answer sets for logic programs with aggregates . </S>",
    "<S> these definitions build on the notion of _ unfolding of aggregates _ , and they are aimed at creating methodologies to translate logic programs with aggregates to normal logic programs or positive programs , whose answer set semantics can be used to defined the semantics of the original programs .    </S>",
    "<S> the first definition provides an alternative view of the semantics for logic programming with aggregates described in  @xcite . </S>",
    "<S> in particular , the unfolding employed by the first definition in this paper coincides with the translation of programs with aggregates into normal logic programs described in @xcite . </S>",
    "<S> this indicates that the approach proposed in this paper captures the same meaning as the semantics discussed in @xcite .    </S>",
    "<S> the second definition is similar to the traditional answer set definition for normal logic programs , in that , given a logic program with aggregates and an interpretation , the unfolding process produces a positive program . </S>",
    "<S> the paper shows how this definition can be extended to consider aggregates in the head of the rules .    </S>",
    "<S> these two approaches are very intuitive , general , and do not impose any syntactic restrictions on the use of aggregates , including support for use of aggregates as heads of program rules . </S>",
    "<S> the proposed views of logic programming with aggregates are simple and coincide with the ultimate stable model semantics @xcite , and with other semantic characterizations for large classes of program ( e.g. , programs with monotone aggregates and programs that are aggregate - stratified ) . </S>",
    "<S> moreover , it can be directly employed to support an implementation using available answer set solvers . </S>",
    "<S> the paper describes a system , called @xmath0 , that is capable of computing answer sets of programs with arbitrary ( e.g. , recursively defined ) aggregates . </S>",
    "<S> the paper also presents an experimental comparison of @xmath0   with another system for computing answer sets of programs with aggregates , dlv@xmath1 . </S>"
  ]
}