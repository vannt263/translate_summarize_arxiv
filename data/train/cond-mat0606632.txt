{
  "article_text": [
    "_ cellular automata _ ( ca ) @xcite were originally conceived by ulam and von neumann @xcite in the 1940s to provide a formal framework for investigating the behavior of complex , extended systems .",
    "cas are dynamical systems in which space and time are discrete .",
    "a cellular automaton usually consists of a @xmath0-dimensional regular lattice of @xmath1 lattice sites , commonly called _",
    "cells_. each cell can be in one of a finite number of @xmath2 possible states and further consists of a transition function @xmath3 ( also called _ rule _ ) , which maps the neighboring states to the set of cell states .",
    "cas are called _ uniform _ if all cells contain the same rule , otherwise they are _ non - uniform_. each cell takes as input the states of the cells within some finite local neighborhood . by convention , a cell is considered to be a member of its own neighborhood . in the standard one - dimensional ca model , for example , each cell",
    "is connected to the @xmath4 ( @xmath4 stands for radius ) immediate local neighbors on either side as to itself , thus each cell is connected to @xmath5 neighbors .    _ random boolean networks _ ( rbns ) , on the other hand , form a more general class of discrete dynamical systems , in which two - state cellular automata are a special subclass . random networks and rbns",
    "were investigated in the past forty years by many a researcher ( see for example @xcite ) , but became popular mainly due to the contributions of stuart kauffman @xcite and others .    in its simplest form ,",
    "a rbn is composed of @xmath1 nodes ( sometimes also called _",
    "elements _ or _ cells _ ) where each node can be in one of two possible states ( @xmath6 or @xmath7 ) and receives inputs from @xmath8 randomly chosen other nodes ( self - connections are allowed ) .",
    "note that @xmath8 can refer to the _ exact _ or to the _ average _ number of connections between the nodes . in the geneticist s term , for example",
    ", @xmath8 measures the richness of epistatic interactions among the components of a system @xcite .",
    "the deterministic behavior of each node is specified by one out of the @xmath9 boolean functions , specifying its next value for each of the @xmath10 combinations with @xmath8 inputs . like cas",
    ", rbns can be _ non - uniform _",
    "( i.e. , each node can potentially have a different rule ) or _ uniform _ , although they are non - uniform in the majority of the cases .",
    "the network s nodes are usually updated synchronously , although multiple asynchronous updating schemes exist ( see @xcite for an overview ) .",
    "synchronous random boolean networks as introduced by kauffman are commonly called _ nk _ networks or models . figure [ fig : rbn ] shows a possible _ nk _ random boolean network representation ( @xmath11 ) . the model is very similar to the well - studied class of models which arises in statistical physics , called _ spin - glasses _",
    "spin - glasses are disordered magnetic materials in which the orientation of nearby magnetic dipoles may be either parallel or antiparallel in space .",
    "nodes and @xmath12 inputs per node ( self - connections are allowed ) .",
    "the node rules are commonly represented by _ lookup - tables _ ( luts ) , which associate a @xmath7-bit output ( the node s future state ) to each possible @xmath8-bit input configuration .",
    "the table s out - column is commonly called the _ rule _ of the node . ]",
    "more formally speaking , let @xmath13 be the state - vector of the network s nodes at time @xmath14 .",
    "the neighborhood @xmath15 of a node @xmath16 is defined as @xmath17 where @xmath18 denotes the set of all subsets of size @xmath8 from @xmath19 ( self - connections are allowed ) .",
    "the neighborhood size is given by @xmath20 .",
    "the most common ways to choose the neighborhood are the following :    * _ random neighborhood _ : choose the @xmath8 neighbors randomly from the set + @xmath21 ( without self - connections ) or from the set @xmath22 ( self - connections allowed ) * _ adjacent neighborhood _ : @xmath8 neighbors are randomly chosen in the `` immediate '' neighborhood .    @xmath23 is sometimes used to denote a _",
    "_ model with adjacent neighborhood , @xmath24 for the random neighborhood .",
    "we shall not go into more details of the adjacent neighborhood here , as we will only consider purely random networks with a uniform probability to connect two nodes together in this article .",
    "figure [ fig : rbn ] shows the interaction graph @xmath25 where @xmath26 corresponds to the set of nodes , and @xmath27 if and only if @xmath16 is connected to @xmath28 .",
    "the node rules are commonly represented by _ lookup - tables _ ( luts ) , which associate a @xmath7-bit output ( the node s future state ) to each possible @xmath8-bit input configuration .",
    "the table s out - column is commonly called the _ rule _ of the node .    whereas the homogeneous connectivity and the usually uniform rules of a ca restrict the automaton s parameter space , rbns have a vastly greater space , which adds an additional challenge for both evolutionary and analytical methods , either to analyze the networks behavior or to find networks able to perform a given task .",
    "the main contribution of this paper consists in a novel analytical method which allows to determine the local rules of a random boolean network for two global and well - known problems for cellular automata , ( 1 ) the synchronization and ( 2 ) the density classification task . whereas previous work was purely quantitative and focused on the co - evolution of cellular automata to find suitable rules and architectures @xcite",
    ", our qualitative approach goes a step further and also provides convergence and quality estimates .",
    "we systematically compare the results with previous work on standard and non - standard cellular automata architectures , including small - world networks , and show that randomly interconnected automata perform better than a standard cellular automata with a regular interconnection architecture .",
    "our method also allows the networks to be randomly rewired during operation without affecting the global performance . the approach and",
    "results may have applications in designing robust complex networks and locally interacting distributed computing systems for solving global tasks .    in section [ sec :",
    "tasks ] we describe the two global tasks used in this paper , the density classification task and the synchronization task .",
    "the main challenge in solving such global tasks with cas and rbns consists in finding the node s local rules that will result in the desired global automata behavior .",
    "note that no generally applicable method for this exists . in section [ sec : comp_and_inf ] we derive the recursive equation which gives the probability of a node to be in state @xmath7 at the next time step .",
    "this equation is then used in section [ sec : rules ] to determine the node s rules for both tasks .",
    "section [ sec : experiments ] examines the network s performance as a function of @xmath1 and @xmath8 whereas section [ sec : rbns_vs_cas ] compares the results with previously published performance results of cellular automata for the same tasks . in order to measure the rule s capacity to solve the tasks",
    ", we introduce an entropy - based performance measure in section [ sec : entropy_measure ] .",
    "the same measure also allows us to predict how quickly the two tasks can be solved . in section [ sec : non - standard ] we briefly discuss non - uniform random boolean networks and perform experiments with small - world network topologies .",
    "our findings , their possible future applications , and future work are discussed in section [ sec : conclusions ] .",
    "two commonly used applications for cas are the _ density _ and the _ synchronization _ task . both of these `` global '' tasks are mostly trivial to solve if one has a global view on the system ( i.e. , if one has access to the state of all nodes at the same time ) , but are non - trivial to solve for ca and rbns , mainly because of the locality and the limited number of their interconnections , the simplicity of the basic cells ( i.e. , the basic components ) , and because there is no generally valid way to determine the cells s",
    "rules for such a massive parallel system . unlike in the standard approach to parallel computation , in which a given problem is split into independent sub - problems , cas and rbns have to solve problems by the bottom - up approach , where the global and usually complex behavior arises from nonlinear , spatially extended , and local interactions @xcite .",
    "this difficulty has naturally also limited cas applications .    in the following",
    ", the density classification and the synchronization task shall be briefly described .",
    "the density classification task for cas must decide whether or not the initial configuration of the automaton contains more than @xmath29 of @xmath7s . in this context , the term `` configuration '' refers to an assignment of the states @xmath6 or @xmath7 to each cell of the ca ( i.e. , there are @xmath30 possible initial configurations ) .",
    "the desired behavior of the automaton is to have all of its cells set to 1 if the initial density of @xmath7s exceeded @xmath31 , and all @xmath6 otherwise .",
    "the density task for cas can straightforwardly be applied to rbns .",
    "the special case of having an equal number of @xmath7s and @xmath6s in the network is commonly avoided by using an odd number of nodes .",
    "the density task was studied among others by mitchell et al .",
    "@xcite , das et al .",
    "@xcite , sipper @xcite , sipper et al .",
    "@xcite , capcarrre @xcite , capcarrre et al .",
    "@xcite and tomassini et al .",
    "@xcite in various forms , including non - uniform cas , asynchronous cas , and non - standard architectures .",
    "it should also be mentioned that no uniform two - state ca exists , which perfectly solves the density classification task for all initial configurations @xcite .",
    "let @xmath32 be the number of nodes being in state @xmath7 at time @xmath14 .",
    "the density classification task can then be formally described by the following equation : t_limt t _",
    "limn_1^t = \\ {    cl 0 & +",
    "n & + &    .. [ eq : density ] let us define @xmath33 as the fraction of nodes that are in state @xmath7 at time @xmath14 .",
    "we will sometimes use @xmath34 instead of @xmath32 when the networks are sufficiently large ( i.e. , @xmath35 ) , since @xmath34 may then be interpreted as the probability of the node to be in state @xmath7 at time @xmath14 .",
    "moreover , since we only consider a synchronous updating scheme , @xmath36 will solely depend on @xmath34 .",
    "the network s behavior can thus simply be described by a map of the form @xmath37 , where @xmath38 .",
    "each of the three solutions of the density classification task will then be represented by a fixed point in this map .",
    "figure [ fig : density_poly ] shows three possible functions @xmath39 that satisfy equation [ eq : density ] . note that the fixed point in @xmath40 is unstable , which means that a small perturbation of the network s state , such as for example one state change among the @xmath1 nodes , will drive the system towards the wrong fixed point , i.e. , towards the wrong solution .",
    "this unstable fixed point can fortunately be avoided by using an odd number of nodes .",
    "the one - dimensional _ synchronization task _ ( also called _ firefly task _ ) for synchronous ca was introduced by das et al . @xcite and studied among others by hordijk @xcite and sipper @xcite . in this task ,",
    "the two - state one - dimensional or two - dimensional ca , given any initial configuration , must reach a final configuration within @xmath41 time steps , that oscillates between all @xmath6s and all @xmath7s on successive time steps .",
    "the whole automaton is then globally synchronized .    as with the density classification task",
    ", synchronization is a non - trivial global computation task for a small - radius ca where all cells must coordinate their behavior with all the other cells while having only a very local view of their neighborhood .",
    "the two - state machine of each cell obviously also prevents any counting , which would make the task much less difficult .",
    "furthermore , in the non - uniform case , where each cell can have a different rule , there is an immediate solution consisting of a unique `` master '' rule that alternates between 0 and 1 without looking at his neighbors , and all other cells being its `` slave '' , i.e. , alternating according to their right ( or upper , in the two - dimensional case ) neighbor state only . however , sipper @xcite used non - uniform cas to find perfect synchronizing cas by means of evolution only .",
    "it appeared that this very particular solution was never found by evolution and , in fact , the `` master '' or `` blind '' rule 10101010 ( rule 170 ) in one dimension , was never part of the evolved solutions .",
    "this is simply due to the fact that this rule has to be unique for the solution to be perfect , which is contradictory to the natural tendency of the evolutionary algorithm used , as was demonstrated by capcarrre @xcite .",
    "the two - dimensional version of the task is identical to the one - dimensional version , except that the necessary number of time steps granted to synchronize is not anymore in the order of @xmath1 , the number of cells in the automaton , but in the order of @xmath42 , where @xmath43 and @xmath44 are the size of each side of the standard ca .",
    "therefore , the speed of synchronization is much faster compared to the one - dimensional version .",
    "extending the two - dimensional synchronization task for cas to rbns is again straightforward and solutions found be means of co - evolutionary algorithms were presented by teuscher and capcarrre in @xcite .",
    "the firefly synchronization task was also successfully implemented in actual evolutionary hardware , for both the one @xcite and the two - dimensional @xcite version .",
    "similarly to the density classification task , the synchronization task may also be formally described by a condition on the number of @xmath7s in the network s state : t_limt t _",
    "limn_1^t = \\",
    "{    cl n & + 0 & +    .",
    "[ eq : sync ] figure [ fig : firefly_poly ] shows three possible maps which satisfy equation [ eq : sync ] .",
    "contrary to the density classification task , fixed points must be avoided since oscillations are required .",
    "the challenge in solving the density classification and synchronization task with cas and rbns consists in finding the node s local rules that will result in a global automaton behavior which satisfies equations [ eq : density ] or [ eq : sync ] for all possible initial configurations .",
    "the difficulty comes from the fact that each node has only access to @xmath8 randomly chosen bits of the entire rbn s state vector @xmath13 at time @xmath14 .",
    "it is therefore crucial to know how the global network state is seen by the local nodes in order to understand the network s dynamics .",
    "let @xmath45 be a random variable representing the number of @xmath7s in a node s neighborhood at time @xmath14 and let @xmath46 and @xmath47 be two random variables which represent the number of @xmath7s and the percentage of @xmath7s in the network s state @xmath13 at time @xmath14 respectively .",
    "@xmath45 obviously depends on @xmath48 , thus , if we suppose that the nodes neighbors are randomly chosen from a uniform distribution , then the probability of having @xmath49 neighbors in state @xmath7 at time @xmath14 , knowing the percentage of @xmath7s ( i.e. , @xmath34 ) in the global network state @xmath13 of a rbn , is therefore given by : p(w_1^t = d | p_1^t = p_1^t ) = k d ( p_1^t)^d ( 1-p_1^t)^k - d .",
    "[ eq : bin ] the distribution of @xmath45 knowing @xmath50 thus follows a binomial law @xmath51 and the expected number of @xmath7s in a node s neighborhood is therefore @xmath52 , which implies that the average number of @xmath7s in the input of a node is the same as the average number of @xmath7s in the global network state .",
    "this property is actually the key that will allow us to reduce the complex behavior of @xmath1 nodes to the stochastic behavior of a single node which behaves on the average like the entire network .",
    "let @xmath13 be the state of a rbn at time @xmath14 , composed of @xmath1 nodes , each being randomly connected to @xmath8 other nodes ( self - connections are allowed ) .",
    "furthermore , let us assume that @xmath1 is sufficiently large to consider @xmath33 as the probability of a node to be in state 1 at time @xmath14 .",
    "we will later see in our experiments that this approximation only affects performance .",
    "knowing @xmath13 , the probability that the future state of node @xmath53 is @xmath7 is then given by : p(s_i^t+1 = 1    where @xmath54 and @xmath55 are two random variables that represent the state of node @xmath53 at time @xmath56 and its input at time @xmath14 respectively .",
    "this is a probabilistic description of the node s boolean transfer function ( i.e. , its rule ) , where @xmath57 and @xmath58 are the input and output distributions respectively .",
    "if @xmath59 is the output of node @xmath53 for an input value @xmath60 , then the previous equation becomes : p(s_i^t+1 = 1 | ^t = ^t ) = _",
    "j=0 ^ 2^k-1 f_i(j ) p(_i^t = j | ^t = ^t ) , since the probability of a node to be in state @xmath7 at time @xmath56 is @xmath7 if @xmath61 , and @xmath6 otherwise . by using the variables @xmath45 and @xmath48 as introduced above , this latter equation can further be reduced to : p(s_i^t+1 = 1 | p_1^t = p_1^t ) =",
    "_ j=0^k c_j p(w_1^t = j |",
    "p_1^t = p_1^t ) , [ eq : input ] where @xmath60 is the number of @xmath7s in the input of node @xmath53 and @xmath62 is the probability that the future state ( the output ) of node @xmath53 is @xmath7 , provided that the input contains @xmath60 times a 1 .    putting equation [ eq : bin ] into equation [ eq : input ] gives us : p(s_i^t+1 = 1 | p_1^t = p_1^t ) = _",
    "j=0^k c_j k j ( p_1^t)^j ( 1-p_1^t)^k - j , which holds for any node @xmath53 . since @xmath63 is equivalent to @xmath36 , the probability for a node to be in state @xmath7 at time @xmath56 , we can now express @xmath36 as a function of @xmath34 by means of the following recursive equation : p_1^t+1 = _",
    "j=0^k a_j ( p_1^t)^j ( 1-p_1^t)^k - ja_j = k j c_j , [ eq : poly ] where the parameters @xmath64 represent the number of the rule s inputs that contain @xmath60 times a @xmath7 and that produce a @xmath7 as output . note that , if we represent a node s rule by a lookup - table , then @xmath64 corresponds to the number of entries that contain @xmath60 times a @xmath7 and that have a @xmath7 as output",
    "for example , the two - bit _ xor _ rule ( i.e. , the output is @xmath7 if and only if the two inputs are different ) corresponds to @xmath65 , @xmath66 and @xmath67 since the output is @xmath7 if there is only one @xmath7 in the input . on the other hand , the two - bit _ nand _ rule corresponds to : @xmath68 , @xmath66 and @xmath69 .",
    "recently , matache and heidel @xcite used a formula to describe the probability of finding a node in state @xmath7 at time @xmath14 to analyze deterministic chaos in random boolean networks .",
    "the basic idea is similar to our approach , but their work , which extends the model studied by andrecut and ali @xcite , is limited to rule @xmath70 only , whereas our approach is valid for any rules .",
    "as seen in section [ sec : density_task ] , solving the density task can be reduced to finding maps @xmath71 which satisfy the constraints that were informally represented in figure [ fig : density_poly ] .",
    "more formally speaking , these constraints may be defined by the following set of equations : @xmath72 @xmath731/2,1].\\ ] ] however , according to equation [ eq : poly ] , we have : q_k(x ) = _",
    "j=0^k a_jx^j(1-x)^k - ja_j .",
    "[ eq : poly2 ] applying constraints c1 and c2 to equation [ eq : poly2 ] and solving it as a function of @xmath64 provides us now with an elegant means to directly determine the node s rules for the density task . in the following sections , different possible solutions for small connectivity parameters @xmath8 shall be presented .",
    "we will see that the simple _ majority rule _ presents a common solution for all networks with a connectivity @xmath74 .      for @xmath75 , equation [ eq : poly2 ] becomes : @xmath76 after applying constraints c1 we obtain the following set of values : @xmath77 this implies @xmath78 and therefore @xmath79 for all @xmath80 , which does not satisfy constraints c2 .",
    "hence , for @xmath75 no set of rules is able to perfectly solve the density classification task for all initial configurations .      for @xmath12 , equation [ eq : poly2 ]",
    "becomes : @xmath81 in order to satisfy constraints c1 , we must impose @xmath65 , @xmath82 and @xmath83 . @xmath84 and @xmath85 then become : @xmath86 after applying constraints c2 , we obtain : @xmath87 one can easily verify that @xmath88 is the sole solution .",
    "the corresponding polynomial is therefore : q_3(x ) = 3 x^2 ( 1-x ) + x^3 .",
    "[ eq : density_k3 ] this solution simply corresponds to the well - known _ majority _ rule : its output is @xmath7 if and only if there are more @xmath7s than @xmath6s in the inputs , and @xmath6 otherwise . as one can verify , since @xmath89 , the only input with all bits set to @xmath6 and the @xmath90 inputs with one bit set to @xmath7 result in a @xmath6 as output .",
    "conversely , for all inputs containing more than one bit set to @xmath7 , the output becomes @xmath7 , since @xmath91 and @xmath82 .",
    "for @xmath92 only one polynomial satisfies both sets of constraints .",
    "it corresponds to : @xmath93 , @xmath94 , @xmath95 , @xmath96 and @xmath97 . since @xmath95 and according to equation",
    "[ eq : poly2 ] , of the @xmath98 inputs with two bits set to @xmath7 , only half of them will set the output to @xmath7 .",
    "since there are @xmath99 possibilities of setting @xmath100 out of @xmath101 outputs to @xmath7 , there are @xmath99 ( out of @xmath102 ) equivalent rules which will successfully solve the density classification task .",
    "these rules are represented in table [ tab : k4rules ] .",
    "as one can see , all rules are in a certain sense _ majority _ rules , but applied to an even number of connections , reason why many possibilities exist .",
    "@xmath99 ( out of @xmath102 ) rules for @xmath92 random boolean networks that successfully solve the density classification task for all initial configurations . [ cols=\"<,<,<,<\",options=\"header \" , ]      in order to measure a rule s capability to solve the density classification or the synchronization task , we will introduce the following measure derived from wuensche s _ input entropy _",
    "@xcite : h(w_1^t|p_1^t ) = _",
    "i=0^n h(w_1^t|p_1^t = i / n )",
    "p(p_1^t = i / n ) , [ eq : measure ] where @xmath103 is the shannon entropy @xcite .",
    "this measure simply computes the conditional entropy of the number of @xmath7s in a node s input , knowing the state of the network at time @xmath14 , i.e. , the percentage of @xmath7s , @xmath50 .",
    "contrary to the measure used by wuensche , which considers each possible node input , our measure only takes into account the distribution of @xmath45 , i.e. , the number of @xmath7s in an input .",
    "this means that two node input configurations that contain the same number of @xmath7s are considered to be equivalent .",
    "our measure not only allows to qualitatively compare the ca and rbn behavior , but it also gives indications on how difficult it is for a rule to solve a given task and what the average number of required times steps is .",
    "for example , if we obtain @xmath104 after a certain amount of time , we know that the network has converged to an all @xmath7s or all @xmath6s state .",
    "this will therefore provide us with an estimation of how fast a rbn may solve a task .    we have seen in section [ sec : comp_and_inf ] that @xmath45 follows a binomial law @xmath51 , where @xmath34 is implicitly defined by means of the map @xmath105 and by an initial distribution function for @xmath106 .",
    "for example , figure [ fig : bin_th ] shows the variation of the input entropy if we use the map defined by equation [ eq : density_k3 ] ( section [ sec : density_task ] ) under the assumption that the initial configurations are randomly chosen according to a biased distribution , i.e. , @xmath107 is the uniform distribution on the interval @xmath108 $ ] . ] .",
    "as can be seen , the input entropy quickly decreases towards zero .",
    "this means that  at least theoretically ",
    "it takes on average less than @xmath109 time steps to settle down in a fixed point when @xmath12 and the majority rule is used .",
    "however , as shown in figure [ fig : density_len ] , the actual number of steps required is much lower ( the average lies around @xmath110 steps ) .",
    "figures [ fig : entropy_bias ] and [ fig : entropy_unbias ] show the variation of the conditional input entropy for the rbn rule @xmath111 as well as for the ca rules @xmath112 , @xmath113 , @xmath114 , and @xmath115 ( @xmath116 , initial configurations selected using a biased or unbiased distribution respectively , see section [ sec : rbns_vs_cas ] ) .",
    "the results suggest the following comments :    * @xmath111 exactly follows the curve as predicted by our theory . *",
    "all plots start slightly below a value of @xmath117 .",
    "this value is exactly the same as for a binomial law , which means that at time @xmath118 , no difference exists between rbns and cas .",
    "* when @xmath119 , the behaviors of the @xmath120-rules are fairly different from the @xmath121-rules . as seen in section [ sec : entropy_measure ] , rbns follow a simple curve that corresponds to a binomial law .",
    "cas , on the other hand , need more complex behaviors to achieve the same result .",
    "* rbns with @xmath111-rule have a very simple , straightforward behavior compared to cas . after a very small number of iterations ,",
    "the input entropy is already less than one bit , which means that most of the nodes basically see the same input . *",
    "the @xmath112-rule is very similar to the @xmath111-rule for unbiased distributions .",
    "however , because of the ca s connection topology , frozen blocks show up and prevent the automata from converging to a zero input entropy . *",
    "the behavior of the best evolved @xmath114-rule and of the hand - designed @xmath115-rule are very similar .",
    "note that @xmath115 has intentionally been designed to break the inherent symmetry of cas and thus requires more time to converge .",
    "* the behavior of the @xmath122-rule is very similar to that of the @xmath111-rule .",
    "however , figure [ fig : entropy_unbias ] shows that an increase in complexity is required around @xmath123 to overcome the emergence of frozen blocks .",
    "@xmath114 and @xmath115 , on the other hand , increase the complexity of their behavior from the very beginning in order to somehow compensate for the regularity of the interconnection topology .",
    "similarly , figures [ fig : ff_h_bias ] and [ fig : ff_h_unbias ] show the variation of the conditional input entropy for the synchronization task .",
    "the @xmath124-rule as well as the three ca rules @xmath125 , @xmath126 and @xmath127 were used , @xmath116 , and initial configurations were selected using a biased and unbiased distribution respectively ( see section [ sec : rbns_vs_cas ] ) .",
    "the results suggest the following comments :    * @xmath124 follows almost exactly the curve as predicted by our theory",
    ". a small difference , however , exists when the unbiased distribution is used ( figure [ fig : ff_h_unbias ] ) . * in the unbiased case , the system converges after less than three iterations , which is very rapid , given that the synchronization is always perfect in that case ( see table [ tab : sync ] ) . *",
    "the input entropy is not fully monotonous ( figure [ fig : ff_h_unbias ] ) .",
    "this can be explained by looking at the evolution of the network s state during the first three iterations : after the first iteration , most of the nodes are in state @xmath6 since @xmath124 produces a @xmath7 only if the input contains @xmath6s only .",
    "the input entropy is thus very low , however , at the second iteration , all nodes which are connected to a @xmath7 will be in state @xmath6 and all others in state @xmath7 since they are connected to @xmath6s only .",
    "thus , a single @xmath7 in the network after the first iteration can generate more than one @xmath6 at the next step and therefore increases the input entropy . *",
    "the non - convergence of @xmath125 and @xmath126 after @xmath128 iterations indicates the existence of frozen - blocks , which makes the problem much harder to solve for these rules .",
    "in order to improve the computational power of cas , various people proposed to introduce non - uniformity among the rules .",
    "although this approach sacrifices one of the main advantages of cas , namely , to have simple and identical processing elements , it allows to find better solutions @xcite .",
    "these solutions often rely on a particular structure where the nodes rules must be carefully chosen . with rbns , however , this is not the case : as we have seen in section [ sec : rules ] , when @xmath129 for example , a single map can represent @xmath130 rules , which are strictly equivalent .",
    "we can thus easily build non - uniform rbns by randomly choosing one rule for each node instead of using the same rule in all nodes .",
    "cas and rbns can be considered as two extreme classes of networks that are not really observed in nature . from the point of view of the interconnection topology , cas are simply too regular , whereas random networks require an equal probability for each connection to be established among all nodes , which is in most cases subjected to physical limitations since long - distance connections are more costly than short - distance connections .",
    "many recent studies have instead confirmed that an important number of networks observed in nature belong to a class called _ small - world _ networks ( see for example @xcite ) .",
    "these networks may be considered as an intermediate class between cas and rbns , since , if we gradually transform a ca into a rbn in a certain manner , we can obtain small - world networks .",
    "different types of small - world networks exist @xcite , here we shall however only consider the networks of watts and strogatz as described in @xcite . in their paper they state for the density classification task that `` [  ] a simple _ majority - rule _ running on a small - world graph can outperform all known human and genetic algorithm - generated rules running on a ring lattice . ''",
    "however , they do not give the amount of randomness a network should contain in order to outperform cas on the density task .",
    "moreover , since we also studied the synchronization task , it would be interesting to see if small - world networks using the @xmath131-rule perform better than cas on this task as well .",
    "we performed several experiments with networks built in the following way :    1 .",
    "start with a ring lattice , which might be considered as a special one - dimensional ca with a @xmath132 neighborhood , but without self - connections .",
    "2 .   rewire the connections with probability @xmath133 as described in @xcite .",
    "therefore , if @xmath134 , the initial automaton is left unchanged , if @xmath135 , it is transformed into an automaton with a random topology . note that , although the connectivity @xmath8 was @xmath117 for each node at the beginning , each node can potentially have a different connectivity at the end .",
    "the average of @xmath75 connections per node is , however , not affected by this random rewiring algorithm .",
    "figures [ fig : sw - perf ] and [ fig : sw - len ] show the percentage of success and the number of iterations required for solving the density classification and the synchronization task as a function of @xmath133 , i.e. , the amount of randomness in the network .",
    "the simulations were performed for a network size of @xmath116 nodes , the rules used were the majority rule for the density classification and the @xmath131-rule for the synchronization task .",
    "the results can be summarized as following : for both tasks , the percentage of success reaches its maximal value around @xmath136 ( see figure [ fig : sw - perf ] ) .",
    "whereas the number of iterations for the synchronization task reaches its maximum around @xmath137 ( figure [ fig : sw - len ] ) already , the density classification task requires significantly less iterations on a random topology .",
    "the reason for this can be found in the corresponding maps ( figures [ fig : density_poly ] and [ fig : firefly_poly ] ) : the synchronization map does not possess stable fixed points , which makes it less sensitive to additional connections between the already existing clusters .",
    "we can conclude that a relatively small amount of randomness already greatly helps to improve performance for solving our two tasks .",
    "however , especially for the density classification task , a randomly interconnected network helps to significantly improve convergence . despite the extreme simplicity of our random boolean networks used ,",
    "the results fit into the global picture of recent work on complex network synchronization using coupled oscillators ( see for example @xcite ) , although more works is certainly needed in that area .",
    "in this paper we have first derived a recursive equation which gives the probability of a node to be in state @xmath7 at time @xmath56 for random boolean networks . based on that equation , we were then able to analytically find the local node rules from the global network behavior for our two comparative tasks .",
    "our main findings are the following :    1 .",
    "no @xmath75 random boolean network can perfectly , i.e. , for all initial configurations , solve the density classification task .",
    "the majority rule is the only perfect rule for @xmath12 networks , whereas many rules exist for @xmath138 networks . 2 .",
    "the two symmetrical @xmath139-rules are the best rules for solving the synchronization task .",
    "random boolean networks outperform cellular automata on both the density classification and on the synchronization task .",
    "random boolean networks also outperform networks with a small - world topology on the density classification task , but their performance is equivalent for the synchronization task .",
    "the rules obtained for both our tasks are highly scalable , i.e. , the larger the network , the better they perform .",
    "this is not the case for cellular automata .",
    "the reason why random boolean networks perform better on both the synchronization and on the density classification tasks is the following : due to the random wiring , each node of a random boolean network has  from a statistical point of view ",
    "an unbiased view on the automata s global state since the distribution of @xmath7s in the node inputs of each node is the same as in the global network state . on the other hand , cellular automata have a biased view because of their local neighborhood , which makes it more difficult for them to solve global tasks .",
    "another advantage of random boolean networks over cas is that they allow the network to be rewired at any time , without affecting the global performance .",
    "this property is especially interesting if interconnections are likely to fail .",
    "one would then only have to re - establish a new connection to a randomly chosen alternative node .",
    "this property could be very interesting for large scale distributed systems . although not explicitly tested in this work , the existence of many equivalent rules for certain values of @xmath8 tend to show that rbns may exhibit great robustness to node and interconnection failures .",
    "one might of course ask whether the current approach might be applied to similar global tasks and whether it might be generalized to non - uniform random boolean networks , alternative topologies , or asynchronously updating nodes .",
    "our current work concentrates exactly on these questions .",
    "the goal is to extend the theory to asynchronously updating and non - uniform random boolean networks and to other , more useful tasks .",
    "asynchrony not only allows to remove the sole global clock signal necessary to synchronously update the cells , which often represents a constraint for hardware realizations , but also yields in further potentially interesting properties .",
    "asynchronous automata attracted much interest in the past few years , although it has been proved independently by capcarrre @xcite and nehaniv @xcite that any @xmath43-state synchronous automata can be emulated by a particular @xmath140-state asynchronous automata . in their 1984 experimental study , ingerson and",
    "buvel @xcite already explored the question of how much of the interesting behavior of cellular automata comes from the synchronous modeling .",
    "they concluded  based on the visual appearance of the evolution patterns over time  that the synchronous assumption is not essential to the study of cellular automata and that certain irrelevant structures may appear from the synchronous update of the cells .",
    "however , one of the main arguments against purely synchronous automata as a tool for modeling has always been the lack of biological plausibility @xcite , although a purely asynchronous behavior is certainly not biologically plausible either .",
    "but there are several other issues of interest in asynchronous models : bersini and detours @xcite suggested that asynchrony might induce stability , but also forces evolution to find more robust solutions , as rohlfshagen and di paolo have shown for the case of rhythmic asynchronous random boolean networks @xcite .",
    "a further topic of interest is also the extension of the theory to @xmath2-state random networks , which are likely to have interesting properties and would represent a generalization of @xmath2-state cas",
    ". the formalization of asynchronously updating and non - uniform random boolean or @xmath2-state networks and the ability to derive their local rules for a larger class of global tasks would certainly represent a major step in that field of research , where the local node rules are commonly either hand - designed or evolved so far .",
    "d.  andre , f.  b.  bennett iii , and j.  r. koza .",
    "evolution of intricate long - distance communication signals in cellular automata using genetic programming . in c.  g. langton and k.  shimohara , editors , _ artificial life v : proceedings of the fifth international workshop on the synthesis and simulation of living systems _ , volume  1 , pages 1618 , cambridge , ma , 1996 .",
    "mit press .",
    "h.  bersini and v.  detours .",
    "asynchrony induces stability in cellular automata based models . in r.",
    "a. brooks and p.  maes , editors , _ proceedings of the artificial life iv conference _ , pages 382387 , cambridge , ma , 1994 . mit press",
    ".            m.  s. capcarrre .",
    "evolution of asynchronous cellular automata . in j.  j.  merelo guervs , a.  panagiotis , and h .-",
    "beyer , editors , _ parallel problem solving from nature _ ,",
    "volume 2439 of _ lecture notes in computer science _ ,",
    "pages 903912 , berlin , heidelberg , 2002 .",
    "springer - verlag .",
    "r.  das , j.  p. crutchfield , m.  mitchell , and j.  e. hanson . evolving globally synchronized cellular automata . in l.",
    "j. eshelman , editor , _ proceedings of the sixth international conference on genetic algorithms _ , pages 336343 , san francisco , ca , 1995 .",
    "morgan kaufmann .",
    "r.  das , m.  mitchell , and j.  p. crutchfield .",
    "a genetic algorithm discovers particle - based computation in cellular automata . in y.",
    "davidor , h .-",
    "schwefel , and r.  manner , editors , _ proceedings of the third parallel problem - solving from nature conference ( ppsn iii ) _ , volume 866 of _ lecture notes in computer science _ ,",
    "pages 344353 , berlin , heidelberg , 1994 .",
    "springer - verlag .",
    "h.  juill and j.  b. pollack .",
    "coevolving the `` ideal '' trainer : application to the discovery of cellular automata rules . in j.",
    "r. koza , w.  banzhaf , k.  chellapilla , m.  dorigo , d.  b. fogel , m.  h. garzon , d.  e. goldberg , h.  iba , and r.  l. riolo , editors , _ genetic programming 1998 : proceedings of the third annual conference _ , pages 519527 , san francisco , ca , 1998 .",
    "morgan kaufmann .",
    "m.  mitchell , j.  p. crutchfield , and r.  das .",
    "evolving cellular automata with genetic algorithms : a review of recent work . in _ proceedings of the first international conference on evolutionary computation and its applications ( evca96)_. russian academy of sciences , 1996 .",
    "m.  sipper .",
    "non - uniform cellular automata : evolution in rule space and formation of complex structures . in r.",
    "a. brooks and p.  maes , editors , _ artificial life iv _ , pages 394399 , cambridge , ma , 1994 . mit press .",
    "m.  sipper .",
    "quasi - uniform computation - universal cellular automata . in f.",
    "morn , a.  moreno , j.  j. merelo , and p.  chacn , editors , _",
    "@xmath141 european conference on artificial life _ , lecture notes in computer science , pages 544554 , berlin , heidelberg , 1995 .",
    "springer - verlag .",
    "m.  sipper , m.  goeke , d.  mange , a.  stauffer , e.  sanchez , and m.  tomassini .",
    "the firefly machine : online evolware . in _ proceedings of the 1997 ieee international conference on evolutionary computation ( icec97 ) _ , pages 181186 , piscataway , nj , usa , 1997 .",
    "ieee press .              c.  teuscher and m.  s. capcarrre . on fireflies , cellular systems , and evolware . in a.",
    "m. tyrrell , p.  c. haddow , and j.  torresen , editors , _ evolvable systems : from biology to hardware .",
    "proceedings of the @xmath142 international conference ( ices2003 ) _ , volume 2606 of _ lecture notes in computer science _ , pages 112 , berlin , heidelberg , 2003 .",
    "springer - verlag ."
  ],
  "abstract_text": [
    "<S> it has been shown that uniform as well as non - uniform cellular automata ( ca ) can be evolved to perform certain computational tasks . </S>",
    "<S> random boolean networks are a generalization of two - state cellular automata , where the interconnection topology and the cell s rules are specified at random .    here </S>",
    "<S> we present a novel analytical approach to find the local rules of random boolean networks ( rbns ) to solve the global density classification and the synchronization task from any initial configuration . </S>",
    "<S> we quantitatively and qualitatively compare our results with previously published work on cellular automata and show that randomly interconnected automata are computationally more efficient in solving these two global tasks . </S>",
    "<S> our approach also provides convergence and quality estimates and allows the networks to be randomly rewired during operation , without affecting the global performance . </S>",
    "<S> finally , we show that rbns outperform small - world topologies on the density classification task and that they perform equally well on the synchronization task .    our novel approach and the results may have applications in designing robust complex networks and locally interacting distributed computing systems for solving global tasks .    random boolean network , cellular automata , density classification task , synchronization task , small - world topologies </S>"
  ]
}