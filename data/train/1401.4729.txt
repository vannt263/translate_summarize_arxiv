{
  "article_text": [
    "knowledge of nuclear level densities is important in nuclear reactions and decays , particularly for heavy nuclei .",
    "the starting point in the theory of level densities is the independent nucleon model , either from a shell model or a mean - field approximation .",
    "a quantitative theory requires a careful treatment of the interactions beyond mean field , but it is useful to have the independent particle level densities to build from . in principle",
    "that theory is very simple , needed only the single - particle energies to calculate the excitations .",
    "even so , the computational problem remains nontrivial .",
    "the two well - known methods for treating it are the statistical approach using the partition function , and the combinatorial approach which individual particle - hole excitations are counted . the statistical approach via the partition function has two drawbacks .",
    "one is that the calculated partition function must be transformed to an actual level density by using the saddle - point approximation .",
    "this is accurate when the level density is high but is unsatisfactory as a complete solution .",
    "the other drawback is that partial level densities ( mostly associated with conserved quantum numbers ) may be awkward to extract .",
    "the combinatorial approach does not require that the level density be high , but it can also be awkward for writing codes when it depends on many quantum numbers that are to be exhibited explicitly in partial level densities . here",
    "we shall show that the coding becomes quite simple using a real - time formulation of the problem and the fast fourier transform ( fft ) .",
    "the one - dimensional fft was first used to calculate level densities by berger and martinot @xcite . however , for calculating partial level densities the formulation using the trace of the real - time green s function is more transparent and can be easily implemented by the multidimensional fft .",
    "the codes to perform the calculations under different conditions are described in the appendix and are available for download .",
    "to derive the equations of the real - time method , let us consider a fock space of @xmath1 orbitals with the hamiltonian h = _ i^n_p _ i a^_i a_i where @xmath2 are the single - particle energies of the orbitals .",
    "the total level density @xmath3 is defined as ( e ) = tr ( ( h - e ) ) here the trace runs over all states of the many - particle fock space , i.e. with any number of particles in the space .",
    "next , the @xmath4-function is represented by the fourier transform ( h - e ) = 12 _ -^d t e^i e t e^-ih t. the trace of the operator in this equation is easy to evaluate due to the independent - particle character of the hamiltonian .",
    "it is g(t ) ( e^-ih t ) = _ i^n_p ( 1 + e^-i _ i t ) . in practice ,",
    "the computation is carried out by building a table of @xmath5 as a function of @xmath6 and then applying the fourier transform by the fft algorithm . specifically , we apply the discrete fft with time points @xmath7 as g(e_i ) = fft(g(2 t_i ) ) with @xmath7 forming a mesh with @xmath8 points separated by a fixed interval @xmath9 .",
    "the result is @xmath10 , an array with the elements giving the number of levels in an energy interval @xmath11 around the point @xmath12 , g(e_i ) = _ e_i^e_i+e de ( e ) to make the results completely transparent , it is helpful to discretize the single - particle energy spectrum with the same @xmath13",
    ". provided the discretization in @xmath6 is sufficiently fine , the output of the fft will be an integer in each energy bin .",
    "we have coded eq .",
    "( 5 ) and eq . ( 8,9 ) below for the total level density partial level densities in rt_levels3.py .",
    "the program is described in the appendix and available for download . to illustrate its use",
    ", we calculate the neutron level density of the heavy deformed nucleus @xmath0dy , taking the single - energies from the hartree - fock spectrum calculated with the gogny d1s interaction .",
    "the single - particle space has been truncated to @xmath14 orbitals , taking the orbitals of the @xmath0dy ground state closest to the fermi level .",
    "the excitation energies in that space range from zero to @xmath15 mev , and the total number of states is @xmath16 .",
    "the energy binning is taken as @xmath17 mev .",
    "this implies that the fft must be carried out with at least @xmath18 time points .",
    "the resulting total level density is shown in fig . 1 as the open circles .    in practical applications we often would like level densities projected onto conserved quantum numbers .",
    "if the quantum numbers are additive , the projections can also be conveniently carried out by fourier transform .",
    "for example , number projection is performed by introducing a second @xmath4-function in the trace formula , ( n -n ) = 12 _ ^d_n e^i n _ ne^-in_n where @xmath19 is a gauge angle .",
    "as before , the integral is evaluated as a discrete fourier transform .",
    "this method for number projection is in common use , eg . in the shell - model monte carlo treatment of level densities@xcite and in the extended hartree - fock - bogoliubov theory of ground state energies@xcite .",
    "the program rt_levels3.py also includes the coding for the needed two - dimensional fft , which we write as g(e_i , n ) = fft2(g(2 t_i , 2_k ) ) the discretization in gauge angle @xmath20 require at least as many angles as there are in the range of @xmath21 values in the output .",
    "this calculation is illustrated by the black squares in fig .",
    "1 . the single - particle spectrum is the same as in the previous example ; one sees that the projected level density is as much as an order of magnitude smaller .",
    "the same technique can be used for any other additive quantum number . besides particle number",
    ", we would like to project on @xmath22 , the @xmath23-component of angular momentum .",
    "if the nuclear field is axially symmetric , the orbitals have a well - defined @xmath22 quantum number and an additional variable can be added to @xmath5 corresponding to rotation angles @xmath24 about the @xmath23-axis .",
    "the required three - dimensional fourier transform is also coded in rt_levels3.py .",
    "we write it as g(e_i , n , j_z ) = fft3(g(2 t_i , 2_k , 2_z ) ) .",
    "the result for the combined @xmath21- and @xmath22-projection of the neutron level density in @xmath0dy is shown in fig . 1 as the black circles",
    ".    one can apply the same method to the parity operator .",
    "since there are only two possible parities , it is sufficient to take only two angles @xmath25 and @xmath26 in constructing the @xmath5 array .",
    "the code rt_levels3.py has the flexibility to project on a fixed parity as well as carrying out the @xmath27 projections at the same time .",
    "one should be aware of two computational issues associated with the real - time method .",
    "first , roundoff error will be come severe if the size of the many - body space @xmath28 exceeds the number of bits in the floating point arithmetic .",
    "the examples in the fig . 1 and fig .",
    "2 below have @xmath29 , well below the 56 mantissa bits of the double precision arithmetic in the fft program library calls .",
    "second , the method is only fast if the number of simultaneous projections is limited .",
    "the running time on a laptop is of the order of seconds or minutes for the one- and the two - dimensional fourier transforms .",
    "the three - dimensional transformation is on the scale of an hour , but higher order transforms would be quite time - consuming .",
    "we describe in the next section an approximate treatment of projections that might be preferable in those cases .",
    "the most complete decomposition we can envisage here is to project on proton number @xmath30 , neutron number @xmath21 , azimuthal quantum number @xmath22 , and parity @xmath31 . as discussed earlier , parity is easy to include .",
    "but the 4-dimensional array and fourier transformed needed to do the @xmath32 projection is beyond the scope of laptop computation .",
    "fortunately , the central limit theorem allows one to estimate the projections at a factor of 2 in cost for each projection .",
    "we illustrate first with a single projection , for example , neutron number @xmath21 .",
    "the one - dimensional fft is carried out in the time - energy domain with two values of the neutron gauge angle , @xmath33 .",
    "the angle @xmath34 is chosen to be small enough so that a power series expansion of @xmath10 in that variable is permitted . then we can extract the first and second moments of @xmath35 for each bin in @xmath36 . call the total number of states in the bin @xmath37 , m_e= g(e,=0 ) .",
    "the average number of particles and holes in those @xmath37 states is calculated as n_1 = n _ e . the mean square number of particles and holes is calculated as n_2 = n",
    "n _ e ( 1-re g(e , ) m_e ) .",
    "now treat @xmath21 as a continuous variable and assume that the distribution in @xmath21 is gaussian , with the same moments @xmath38 and @xmath39 .",
    "this gives p(n ) = m_e ( - ( n - n_1)^2 2 ^ 2 ) , where ^2 = n_2-n_1 ^ 2 .",
    "the program rt_levelsnp.py estimates the @xmath40 and @xmath41 projections using eqs .",
    "( 7 - 10 ) assuming there are no correlations between the three variances except for one .",
    "namely , the number parities of @xmath42 and @xmath43 are always equal , eg .",
    "@xmath42 is even if @xmath43 is even .",
    "so half the of entries in a table of level densities are zero , and the nonzero ones are on the average twice as large .",
    "2 shows the calculated levels densities of @xmath0dy using rt_levelsnp.py .",
    "one sees that the three - fold projection has a very strong effect on the level density , reducing it by more than two orders of magnitude in the 5 - 10 mev range of excitation energies .    also in fig .",
    "2 we show the exact three - fold projected densities calculated by folding the neutron and proton level densities obtained from three - dimensional fourier transforms .",
    "the results are indistinguishable for energies over 6 mev .",
    "the program foldnp.py to carry out the folding is also included in the package of codes provided with this article .",
    "we are grateful for discussions with a. bulgac , w. nazarewicz , and p.g .",
    "reinhard on the level density problem , in the framework of the 2013 int program on large amplitude shape dynamics .",
    "we would also like to thank y. alhassid for a careful reading of the manuscript .",
    "support for this work was provided by the us department of energy under grant no .",
    "de - fg02 - 00er41132 and by mineco grants nos .",
    "fpa2012 - 34694 , fis2012 - 34479 and by the consolider - ingenio 2010 program multidark csd2009 - 00064 .",
    "the examples in the text were computed with the programs rt_levels3.py , rt_levelsnp.py , and foldnp.py . a tar file of the three programs together with input data going with figs .",
    "1 and 2 is available on the website of one of the authors , www.phys.washington.edu/users/bertsch/computer.html under  level densities \" .",
    "they are written in the python programming language and require the numpy library to run .",
    "the programs have been tested with version 2.7.3 of python and 1.6.1 of numpy .",
    ".... #   rt_levelsnp.py calculates level densities by 1d fourier transform   # with neutrons and protons together ; n , z , and k projections are # calculating assuming that the distributions are gaussian .",
    "import sys import math as m import numpy as np import numpy.fft as fft    lines = open(sys.argv[1]).readlines ( ) datafile = lines[0].split()[0 ] ss = lines[1].split ( ) nt = int(ss[0 ] ) nphi , zphi , kphi = map(float , ss[1:4 ] ) deltae = float(lines[2].split()[0 ] ) lines = open(datafile).readlines ( ) nnp = len(lines ) -2 lines= lines[1 : ] print ' nt , nnp , deltae',nt , nnp , deltae print ' phin , phiz , phik ' , nphi , zphi , kphi qvals = [ ] evals = np.array([0.0]*nnp ) etot = 0.0 tau_z = 1 i = 0 for line in lines :     ss = line.split ( )     if len(ss ) !",
    "= 4 :        tau_z = -1     else :       k , p , b = map(int , ss[:3 ] )       if p = = 1 :   pex = 0.0 ;       if p = = -1 :   pex = 1.0       qvals.append((k,pex,b,tau_z ) )      # k , p , b , tau_z       e = round(float(ss[3])/deltae+1.0e-4 )       evals[i]= e       etot + = e       i + = 1 print ' deltae , etot ' , deltae , etot      nphase = np.array([0.0]*nnp ) zphase = np.array([0.0]*nnp ) kphase = np.array([0.0]*nnp ) nophase = np.array([0.0]*nnp ) for ip in range(nnp ) :     k , pex , b , tau_z = qvals[ip ]     if tau_z = = 1 :       nphase[ip ] = nphi*b     else :       zphase[ip ] = zphi*b     kphase[ip ] = kphi*k   print        g = np.array([0.0j]*nt ) def make_g(gauge ) :    for it   in range(nt ) :      green = 1.0 + 0.0j      for ip in range(nnp ) :         e = evals[ip ]           exponent   = m.pi*2*e*it/float(nt)+gauge[ip ]         expgauge = m.e**(1.0j*exponent )         green = green * ( 1.0 + expgauge )      g[it ] = green    return g    ggauged[0 , : ] = make_g(nophase ) ggauged[1 , : ] = make_g(nphase ) ggauged[2 , : ] = make_g(zphase ) ggauged[3 , : ] = make_g(kphase )            nstates = 0.0 for i in range(nt ) :    e = i*deltae    f0 = gg_fft[0,i ]    ne = f0.real    np0 = 1.0 ; zp0 = 1.0 ; kp0 = 1.0    if ne > 0.01 :      n0[i ] = gg_fft[1,i].imag / ne / nphi      z0[i ] = gg_fft[2,i].imag / ne / zphi      k0[i ] = gg_fft[3,i].imag / ne / kphi      nsigsq = 2*(1 - gg_fft[1,i].real / ne)/nphi**2 - n0[i]**2          zsigsq = 2*(1 - gg_fft[2,i].real / ne)/zphi**2 - z0[i]**2          ksigsq = 2*(1 - gg_fft[3,i].real / ne)/kphi**2 - k0[i]**2          if nsigsq > 0.5 :        nsig = m.sqrt(nsigsq )        np0 = m.e**(-n0[i]**2/(2*nsigsq))/(2*m.pi)**0.5/nsig      if zsigsq > 0.5 :        zsig = m.sqrt(zsigsq )        zp0 = m.e**(-z0[i]**2/(2*zsigsq))/(2*m.pi)**0.5/zsig      if ksigsq > 0.5 :        ksig = m.sqrt(ksigsq ) # note factor of 2 on line below        kp0 = 2*m.e**(-k0[i]**2/(2*ksigsq))/(2*m.pi)**0.5/ksig      nprojected = np0*zp0*kp0*ne      print ' % 6.2f % 10.1f % 6.4f % 6.4f % 6.4f % 10.1f ' % ( e , ne , np0,zp0,kp0,nprojected )    else :      print ' % 6.2f     0.0 ' % e       nstates + = ne print ' nstates ' , ggauged[0,0].real , nstates ....    99 r.a .",
    "senkov , m. horoi , and v.g .",
    "zelevinsky , comp .",
    "phys . comm . * 184 * 215 ( 2013 ) .",
    "y. alhassid , s. liu , and h. nakada , phys .",
    "lett . * 83 * 4265 ( 1999 ) .",
    "berger and m.  martinot , nucl .",
    "phys . a*226 * 391 ( 1974 ) .",
    "m.  anguiano , j.l .",
    "egido , and l.m  robledo , nucl .",
    "a*696 * 467 ( 2001 ) .",
    "ormand , et al .",
    ", phys . rev .",
    "c 49 , 1422 ( 1994 ) ."
  ],
  "abstract_text": [
    "<S> levels densities of independent - particle hamiltonians can be calculated easily by using the real - time representation of the evolution operator together with the fast fourier transform . </S>",
    "<S> we describe the method and implement it with a set of python programs . </S>",
    "<S> examples are provided for the total and partial levels densities of a heavy deformed nucleus ( @xmath0dy ) . </S>",
    "<S> the partial level densities that may be calculated are the projected ones on neutron number , proton number , azimuthal angular momentum , and parity . </S>"
  ]
}