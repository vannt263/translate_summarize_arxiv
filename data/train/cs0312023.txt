{
  "article_text": [
    "this paper focuses on the inference of modes for which a logic program is guaranteed to terminate .",
    "this generalises traditional termination analysis where an analyser tries to verify termination for a specified mode .",
    "for example , for the classic @xmath0 relation , a standard analyser will determine that a query of the form @xmath1 with @xmath2 bound to a closed list terminates and likewise for the query in which @xmath3 is bound to a closed list .",
    "in contrast , termination inference provides the result @xmath4 with the interpretation that the query @xmath1 terminates if @xmath2 or @xmath3 are bound to closed lists .",
    "we refer to the first type of analysis as performing _ termination checking _ and to the second as _",
    "termination inference_. we consider universal termination using prolog s leftmost selection rule and we assume that unifications do not violate the occurs check .    several analysers for termination checking are described in the literature .",
    "we note the termilog system described in @xcite and the system based on the binary clause semantics described in @xcite .",
    "termination inference is considered previously by mesnard and coauthors in @xcite . here",
    ", we make the observation that the missing link which relates termination checking and termination inference is _",
    "backwards analysis_. backwards analysis is concerned with the following type of question : given a program and an assertion at a given program point , what are the weakest requirements on the inputs to the program which guarantee that the assertion will hold whenever execution reaches that point .    in a recent paper , king and lu @xcite",
    "describe a framework for backwards analysis for logic programs in the context of abstract interpretation . in their approach ,",
    "the underlying abstract domain is required to be condensing or equivalently , a complete heyting algebra .",
    "this property ensures the existence of a weakest requirement on calls to the program which guarantees that the assertions will hold .    to demonstrate this link between termination checking and termination inference",
    ", we apply the framework for backwards analysis described by king and lu @xcite to enhance the termination ( checking ) analyser described in @xcite to perform also termination inference .",
    "we use the condensing domain @xmath5 , of positive boolean formula , to express the conditions on the instantiation of arguments which guarantee the termination of the program .",
    "the use of a standard framework for backwards analysis provides a formal justification for termination inference and leads to a simple and efficient implementation similar in power to that described in @xcite .",
    "it also facilitates a formal comparison of termination checking and inference .",
    "in particular , we provide a condition on the components of the analyser which guarantee that termination inference will infer all modes which termination checking can prove to be terminating .",
    "in the rest of the paper , section [ prelim ] provides some background and a motivating example .",
    "section [ sec : b - analysis ] reviews the idea of backwards analysis . section [ sec : from - chk - to - inf ] illustrates how to combine termination analysis with backwards analysis in order to obtain termination inference and investigates their relative precision .",
    "section [ sec : exper ] presents an experimental evaluation .",
    "finally , section [ sec : rw ] reviews related work and section [ sec : conc ] concludes . a preliminary version of this paper appeared as ref .",
    "our implementation @xcite can be accessed on the web .",
    "it supports termination checking as described in @xcite and termination inference as described in this paper .",
    "we assume a familiarity with the standard definitions for logic programs @xcite as well as with the basics of abstract interpretation @xcite .",
    "this section describes the standard program analyses upon which we build in the rest of the paper . for notation , in brief : variables in logic programs are denoted as in prolog ( using the upper case ) while in relations , boolean formula , and other mathematical context we use the lower case .",
    "we let @xmath6 denote a tuple of distinct variables @xmath7 .",
    "to highlight a specific point in a program we use labels of the form @xmath8 .",
    "size relations and instantiation dependencies rest at the heart of termination analysis : size information to infer that some measure on program states decreases as computation progresses ; and instantiation information , to infer that the underlying domain is well founded .",
    "consider the recursive clause of the @xmath0 relation : @xmath9,ys,[x|zs ] ) \\leftarrow append(xs , ys , zs).$ ] it does not suffice to observe that the size of the first and third arguments decrease in the recursive call . to guarantee termination one must also ensure that at least one of these arguments is sufficiently instantiated in order to argue that this recursion can be activated only a finite number of times .",
    "instantiation information is traditionally obtained through abstract interpretation over the domain  which consists of the positive boolean functions augmented with a bottom element ( representing the formula @xmath10 ) .",
    "the elements of the domain are ordered by implication and represent equivalence classes of propositional formula .",
    "this domain is usually associated with its application to infer groundness dependencies where a formula of the form @xmath11 is interpreted to describe a program state in which @xmath2 is definitely bound to a ground term and there exists an instantiation dependency such that whenever @xmath12 becomes bound to a ground term then so does @xmath3 .",
    "similar analyses can be applied to infer dependencies with respect to other notions of instantiation .",
    "boolean functions are used to describe the groundness dependencies in the success set of a program @xmath13 as well as in the set of calls which arise in the computations for an initial call pattern @xmath14 .",
    "we denote these approximations by @xmath15 and @xmath16 respectively .",
    "the elements are of the form @xmath17 where @xmath18 is a predicate defined in @xmath13 and @xmath19 is a positive boolean function on @xmath6 . for details on",
    "see @xcite .",
    "size relations express linear information about the sizes of terms ( with respect to a given norm function ) @xcite .",
    "for example , the relation @xmath20 describes a program state in which the sizes of the terms associated with @xmath2 and @xmath12 are less or equal to the size of the term associated with @xmath3 .",
    "similarly , a relation of the form @xmath21 describes a state in which the sum of the sizes of the terms associated with @xmath2 and @xmath12 is equal to the size of the term associated with @xmath3 . here",
    "the variables represent sizes and hence are implicitly constrained to be non - negative .",
    "several methods for inferring size relations are described in the literature @xcite .",
    "they differ primarily in their approach to obtaining a finite analysis as the abstract domain of size relations contains infinite chains . for a survey on termination analysis of logic programs",
    "see @xcite .",
    "throughout this paper we will use the so - called term - size norm for size relations for which the corresponding notion of instantiation is groundness .",
    "we base our presentation on the termination ( checking ) analyser described in @xcite although we could use as well almost any of the alternatives described in the literature .",
    "this analyser is based on a bottom - up @xmath22 like semantics which makes loops observable in the form of binary clauses .",
    "this provides a convenient starting point for termination inference as derived in this paper .",
    "we denote the abstraction of this semantics for a program @xmath13 over the domain of size relations as @xmath23 .",
    "each element of @xmath23 represents a loop and is of the form @xmath24 where @xmath25 is a conjunction of linear constraints . in the examples these",
    "are represented as lists of constraints .",
    "we proceed to demonstrate our approach by example in four steps :     + consider the @xmath0 relation .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ xxxx = xxx = xxxxxxxxxxxxxxxxx = append([x|xs],ys,[x|zs ] ) : - append(xs ,",
    "ys , zs ) . + append([],ys , ys ) . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    termination checking reports a single abstract binary clause :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ xxxx = xxx = xxxxxxxxxxxxxxxxx = append(a , b , c ) : - [ d < a , f < c , b = e ] , append(d , e , f ) .",
    "_ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    indicating that subsequent calls @xmath26 and @xmath27 in a computation , involve a decrease in size for the first and third arguments ( @xmath28 and @xmath29 ) and maintain the size of the second argument ( @xmath30 ) . to guarantee that this loop may be traversed only a finite number of times , it is sufficient to require that either @xmath31 or @xmath32 be sufficiently instantiated .",
    "this can be expressed as a boolean condition : @xmath33 .",
    "backwards analysis is now applied to infer the weakest conditions on the program s predicates which guarantee this condition . for this example",
    "the inference is complete and we have derived the result : @xmath34 interpreted as specifying that @xmath1 terminates if @xmath2 or @xmath3 are bound to ground terms .",
    "+ consider the use of @xmath0 to define list membership . adding the following clause to the program introduces no additional loops :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ xxxx = xxx = xxxxxxxxxxxxxxxxx = member(x , xs ) : - append(a,[x|b],xs ) .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    backwards analysis should specify the weakest condition on @xmath35 which guarantees the termination condition @xmath36 for @xmath37,xs)$ ] .",
    "this is obtained through projection which for backwards analysis is defined in terms of universal quantification as @xmath38 .",
    "the resulting boolean precondition is : @xmath39 indicating that @xmath40 terminates if @xmath12 is ground .",
    "+ we now add to the program a definition for the subset/2 relation :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ xxxx = xxx = xxxxxxxxxxxxxxxxx = subset([x|xs],ys ) : - member(x , ys ) , subset(xs , ys ) .",
    "+ subset([],ys ) . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    termination checking reports an additional loop :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ xxxx = xxx = xxxxxxxxxxxxxxxxx = subset(a , b ) : - [ b = d , c < a ] , subset(c , d ) . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    which will be traversed a finite number of times if @xmath31 is sufficiently instantiated .",
    "for the first clause to terminate both loops must terminate : for @xmath0 in the call to @xmath41 and for @xmath42 in the call to @xmath43 .",
    "so both @xmath44 and @xmath45 must be instantiated which implies that both arguments of @xmath42 should be ground inputs .",
    "namely , @xmath46 .   +",
    "this step demonstrates that the precondition on a call in a clause body may be ( partially ) satisfied by answers to calls which precede it .",
    "consider adding to the program a clause :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ xxxx = xxx = xxxxxxxxxxxxxxxxx = s(x , y , z ) : - append(x , y , t ) , subset(t , z ) .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    which defines a relation @xmath47 such that the set @xmath3 contains the union of sets @xmath2 and @xmath12 .",
    "the preconditions for termination derived in the previous steps specify the conditions @xmath48 and @xmath49 at points and respectively .",
    "in addition , from a standard groundness analysis we know that on success @xmath50 satisfies @xmath51 .",
    "so , instead of imposing on the clause head both conditions from the calls in its body , as we did in the previous step , we may weaken the second condition in view of the results from the first call .",
    "namely @xmath52 .",
    "now the termination condition inferred for @xmath47 is   @xmath53    in general , the steps illustrated above , though sufficient for these simple examples , do need to be applied in iteration . in the next section",
    "we describe more formally the steps required for backwards analysis .",
    "this section presents an abstract interpretation for backwards analysis using the domain  distilled from the general presentation given in @xcite .",
    "clauses are assumed to be normalised and contain assertions so that they are of the form @xmath54 where @xmath55 is a  formula , interpreted as an instantiation condition that must hold when the clause is invoked , and @xmath56 is either an atom , or a unification operation .",
    "the analysis associates preconditions , specified in , with the predicates of the program . initialised to @xmath57 ( the top element in @xmath58 ) these preconditions become more restrictive ( move down in ) through iteration until they stabilise . at each iteration",
    ", clauses are processed from right to left using the current approximations for preconditions on the calls together with the results of a standard groundness analysis to infer new approximations for these preconditions .    for the basic step , consider a clause of the form : @xmath59 and assume that the current approximation for the precondition for a predicate @xmath60 is @xmath61 , the success of @xmath60 is approximated by @xmath62 , and that processing the clause from right to left has already propagated a condition @xmath63 at the point .",
    "then , to insure that @xmath63 will hold after the success of @xmath60 , it suffices to require at the conjunction of @xmath64 with the weakest condition @xmath65 such that @xmath66 .",
    "this @xmath65 is precisely the pseudo - complement @xcite of @xmath62 with respect to @xmath63 , obtained as @xmath67 .",
    "so propagating one step to the left gives the condition @xmath68 .",
    "now consider a clause @xmath69 with an assertion @xmath70 .",
    "assume that the current approximation for the precondition of @xmath71 is @xmath19 and let @xmath72 and @xmath73 denote respectively the approximation of the success set of @xmath56 ( obtained through standard groundness analysis ) and the current precondition for @xmath56 ( @xmath74 ) .",
    "backwards analysis infers a new approximation @xmath75 of the precondition for @xmath71 by consecutive application of the basic step described above .",
    "we start with @xmath76 and through @xmath77 steps ( with @xmath78 going from @xmath77 to @xmath79 ) compute a condition @xmath80 which should hold just before the call to @xmath56 . after computing @xmath81 we take @xmath82 and project @xmath83 on the variables @xmath6 of the head by means of universal quantification . the new condition is finally obtained through conjunction with the previous condition @xmath19 .",
    "namely , @xmath84 .",
    "there is one subtlety in that @xmath85 is not closed under universal quantification . to be precise ,",
    "elimination of @xmath2 from @xmath86 is defined as the largest element in  which implies @xmath87 .",
    "when @xmath87 is not positive then the projection gives @xmath10 which is the bottom element in .",
    "consider the clause    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ xxxx = xxx = xxxxxxxxxxxxxxxxx = subset(a , b ) : - a @xmath88 a=[x|xs ] , b = ys , + member(x , ys ) , subset(xs , ys ) . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    where the assertion @xmath31 states that the first argument must be ground and the success patterns ( derived by a standard groundness analysis ) and the current approximation of the preconditions are ( respectively ) : +    @xmath89    @xmath90     + starting from @xmath91 , the conditions @xmath92 are obtained by substituting in @xmath93 as illustrated in the following table :    @xmath94 we now obtain @xmath83 as @xmath95 and projecting @xmath83 to the variables in the head gives @xmath96 . which leads to the new precondition @xmath97 .    in @xcite , the authors formalise backwards analysis as the greatest fixed point of an operator over . in our implementation @xcite backwards analysis",
    "is realised as a simple prolog interpreter which manipulates boolean formula using a package for binary decision diagrams written by armstrong and schachte ( used in @xcite and described in @xcite ) .",
    "termination checking aims to determine if a program is guaranteed to terminate for a specified mode .",
    "termination inference aims to infer a set of modes for which the program is guaranteed to terminate . to be precise ,",
    "we introduce the following definition and terminology .",
    "a mode is a tuple of the form @xmath98 where @xmath99 @xmath100 is either * b * ( `` bound '' ) or * f * ( `` free '' ) .",
    "we can view a mode as a call pattern @xmath17 where @xmath101 .",
    "given a norm function , we say that a program terminates for a mode @xmath102 if it terminates for all initial queries @xmath103 such that for @xmath74 , @xmath104 implies that @xmath105 is rigid with respect to the given norm .",
    "this section describes how an analyser for termination inference can be derived from an analyser for termination checking together with a component for backwards analysis .",
    "we first describe in section [ sec : chk ] the activities performed by an analyser for termination checking . then",
    ", in section [ sec : inf ] we explain how some of these activities are combined with a backwards analysis component to obtain an analyser for termination inference .",
    "finally , in section [ cvsi ] , we compare the precision of termination checking and inference .",
    "termination checking involves two activities : first , the loops in the program are identified and characterised with respect to size information ; and second , given the mode of an initial query , it is determined if for each call pattern in a computation and for each loop , some measure on the sizes of some of the sufficiently instantiated arguments in the call decrease as the loop progresses .    in the analyser described in @xcite these activities",
    "are performed in two phases . the first ( goal independent ) phase computes a set of abstract binary clauses @xmath23 which describe , in terms of size information , the loops in the program @xmath13 .",
    "the second ( goal dependent ) phase determines a set of call patterns @xmath16 for a initial mode @xmath14 and checks that for each call in @xmath16 and each corresponding loop in @xmath23 there exists a suitable well - founded decreasing measure .",
    "the next definitions provide the notions required to state the theorem which follows ( reformulating proposition 6.5 in @xcite ) to provide a sufficient termination ( checking ) condition .",
    "[ d.a.s . ] a set of arguments @xmath106 is for an abstract binary clause @xmath107 if there exist coefficients @xmath108 such that @xmath109 .",
    "the set of all decreasing sets of arguments for @xmath110 is denoted by @xmath111 .    note that by definition @xmath111 is closed under extension .",
    "namely , if @xmath112 and @xmath113 then @xmath114 ( simply map coefficients for the arguments in @xmath115 to 0 ) .    [ def : ie ] we say that a set of arguments @xmath116 is instantiated in a call pattern @xmath117 if @xmath118 .",
    "we denote by @xmath119 the set of all arguments instantiated in @xmath120 .",
    "[ tc ] let @xmath13 be a logic program and @xmath14 an initial call pattern .",
    "if for each call pattern @xmath121 and corresponding binary clause @xmath122 there exists a set of arguments @xmath123 which is in @xmath120 and for @xmath110 then @xmath13 terminates for @xmath14 .",
    "the analysis of the @xmath0 relation ( detailed in section [ prelim ] ) for the initial mode @xmath124 gives : @xmath125 , ~append(d , e , f ) }      \\end{array }    \\right\\}}\\\\[1ex ]        \\posgd = { \\left\\ {      \\begin{array}{l}\\mathtt{append(a , b , c ) \\leftarrow a\\wedge b }      \\end{array }    \\right\\ } }    \\end{array}\\ ] ] the termination condition holds for this single binary clause and call pattern with @xmath126 as well as with @xmath127 .",
    "we now focus in on that component of the termination checker that checks if the termination condition is satisfied for a call pattern @xmath128 and a corresponding binary clause @xmath110 .",
    "we denote by @xmath129 the decision procedure which is at the heart of this component and determines if some subset of @xmath130 is decreasing for @xmath110 .",
    "since any decreasing and instantiated enough set of arguments is a subset of @xmath119 , the analyser will typically invoke @xmath131 .",
    "for the correctness of termination checking , @xmath129 must be sound but need not be complete . namely if @xmath129 reports then @xmath130 must be a decreasing set of arguments for @xmath110 .",
    "the termination analyser described in @xcite applies a simple ( and fast ) decision procedure which is not complete but works well in practise . for a call @xmath17 with instantiated variables @xmath132 and a matching binary clause @xmath133 the system checks if @xmath134 ( recall that all of the variables are non - negative ) .",
    "if not , then it reports `` yes '' because it must be the case that for some @xmath135 , @xmath136 and hence the singleton @xmath137 is a decreasing argument set .    a complete procedure for @xmath138 ( denoted )",
    "is described in @xcite and discussed also in @xcite . there",
    "the authors observe that checking the satisfiability of the _ non - linear _ constraint system @xmath139 , for coefficients @xmath108 , is equivalent to checking that of the dual constraint system which is linear .",
    "see the references above for details .",
    "the terminweb analyser @xcite offers the optional use of this procedure .",
    "our approach to termination inference proceeds as follows : ( 1 ) the first phase of the termination checker is applied to approximate the loops in the program as binary clauses with size information ( @xmath23 ) ; ( 2 ) each loop in @xmath23 is examined to extract an initial ( boolean ) termination assertion on the instantiation of arguments of the corresponding predicate which guarantee that the loop can be executed only a finite number of times ; and ( 3 ) backwards analysis is applied to infer the weakest constraints on the instantiation of the initial queries to guarantee that these assertions will be satisfied by all calls .    intuitively , an initial termination assertion for a predicate @xmath140 is a boolean formula constructed so as to guarantee that each binary clause has at least one set of arguments which is instantiated enough and decreasing . to this end ,",
    "the best we can do for a given binary clause @xmath110 is to require the instantiation of the variables in ( at least ) one of of the decreasing sets of arguments in @xmath111 ( a disjunction ) .",
    "this gives the most general initial termination assertion for @xmath110 .",
    "for a predicate in the program , the assertions for all of its binary clauses must hold ( a conjunction ) . in practise , an analyser for termination inference involves a component @xmath141 which approximates @xmath111 ( from below ) for an abstract binary clause @xmath110 .",
    "for the correctness of termination inference , @xmath141 must be sound but need not be complete . namely it may return a subset of @xmath111 .",
    "of course if it is complete ( i.e. computes @xmath111 ) then the inference will be more precise .",
    "given such a procedure @xmath141 , the initial termination assertions are specified as follows :    [ def : assertion ] let @xmath13 be a logic program . the initial termination assertions for a binary clause @xmath142 , and a predicate @xmath143 are given as : @xmath144 where @xmath145 is the set of binary clauses for @xmath140 in @xmath23 .",
    "note that we can assume without loss of generality that @xmath146 is closed under extension as the assertions @xmath147 are invariant to the addition of extending sets of arguments .",
    "[ ex : merge ] consider as @xmath13 the @xmath148 relation ( from merge sort ) :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ xxxx = xxx = xxxxxxxxxxxxxxxxx = split ( [ ] , [ ] , [ ] ) .",
    "+ split([x|xs],[x|ys],zs ) : - split(xs , zs , ys ) .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the binary clauses obtained by the analyser of @xcite are :    * @xmath149 , ~split(y_1,y_2,y_3).$ ] * @xmath150 , ~split(y_1,y_2,y_3).$ ] * @xmath151 , ~split(y_1,y_2,y_3).$ ]    here , @xmath152 represents the size information corresponding to passing one time through the loop defined by the second clause ; @xmath153 the information corresponding to any even number of times through the loop ; and @xmath154 any odd number of times ( greater than 1 ) .",
    "let @xmath155 denote the closure of a set @xmath156 under extension with respect to the variables of interest . assuming that @xmath157 ( note that @xmath158 and @xmath159 ) and @xmath160 ( note that @xmath161 )",
    ", we have @xmath162 ; and @xmath163 . the assertion for @xmath148",
    "is : @xmath164 backwards analysis starting from this assertion infers the termination condition @xmath165 for @xmath166 .",
    "the result of backwards analysis is a positive boolean formula for each predicate describing the conditions under which a corresponding initial query terminates .",
    "the following definition specifies how the initial modes for terminating queries are derived from this formula .",
    "let @xmath13 be a logic program .",
    "we say that @xmath98 is terminating for @xmath167 defined in @xmath13 if the conjunction @xmath168 implies the condition inferred by termination inference for @xmath140 .",
    "consider again the @xmath148 relation given in example [ ex : merge ] for which we inferred @xmath169 .",
    "both @xmath170 and @xmath171 are terminating modes because @xmath172 and @xmath173 imply @xmath165 .",
    "the correctness of the method described follows from the results of @xcite and @xcite .",
    "[ th:2 ] let @xmath146 be a sound procedure , @xmath13 a logic program and @xmath174 a terminating mode for @xmath140 inferred by termination inference .",
    "then @xmath13 terminates for @xmath174 .",
    "let @xmath175 be an initial query described by the inferred terminating mode @xmath174 .",
    "the correctness of backwards analysis garantees that when executing @xmath14 , any call to a predicate @xmath176 satisfies the assertions inferred for @xmath176 . from the specification of the initial termination assertion ( definition  [ def : assertion ] ) we know that @xmath177 for each @xmath178 .",
    "hence , at least one set of arguments for @xmath110 is decreasing and sufficiently instantiated .",
    "this means that the termination condition of theorem [ tc ] holds .    in the analyzer for termination inference implemented in the context of this work",
    "@xcite we adopt for @xmath146 a fast though incomplete procedure . given a binary clause",
    "@xmath179 the procedure works as follows where we denote the arguments of @xmath140 as @xmath180 : first , it computes the set @xmath181 which includes all argument positions that are decreasing .",
    "each singleton subset of @xmath182 is reported by the procedure to be a decreasing set of arguments ; second , it checks if the sum of the non - decreasing arguments is decreasing .",
    "namely , if @xmath183 if so , then it reports that @xmath184 is a decreasing set of arguments .    performing step 2 does appear to make a difference .",
    "this simplistic approach works well in practice for the standard benchmarks and guarantees scalability of the analysis .",
    "for example consider the binary clause @xmath152 from example [ ex : merge ] .",
    "the only decreasing singleton is @xmath185 and the set of all non - decreasing arguments @xmath186 is also decreasing , this enables the detection of the terminating mode @xmath187 . in @xcite ,",
    "the authors adopt a complete algorithm for @xmath146 which they call .",
    "similar to the authors consider the dual ( linear ) constraint system of the form @xmath188 .",
    "but instead of checking for satisfiability , they look for the smallest subsets @xmath189 for which the constraint system is satisfiable .",
    "this is done by projecting the system @xmath190 on the variables @xmath191 and systematically trying to bind some of the @xmath192 s to zero . in general",
    "this can require an exponential number of steps .",
    "however , the author s experimentation indicates that the algorithm works well in practise .",
    "see the reference above for details .      to compare the precision of an analyser for termination checking with one for termination inference",
    "the relevant question is : is there some mode which can be checked to be terminating which is not inferred to be terminating ( or vice versa ) ?",
    "in particular we would like to compare the precision of our own two analysers for checking and inferring termination as well as with the cti analyser for termination inference .",
    "in the next section we provide an experimental comparison for both efficiency and precision .",
    "here we are concerned with a theoretical comparison .    to keep all else the same",
    ", we will assume that the analysers being compared obtain the same approximations of a program s loops ( @xmath23 in our terminology ) and use the @xmath58 domain to approximate instantiation information .",
    "for our two analysers these assumptions are of course true as we use the same component to compute @xmath23 . given that all other parameters in the analysers are the same , it is the relation between the precision of the specific choices for the procedures @xmath138 and @xmath146 which determine the relevant precision of termination checking and termination inference .",
    "the comparison for a given choice of @xmath138 and @xmath146 is done by considering for each abstract binary clause @xmath110 the sets @xmath141 and @xmath193 .",
    "if these sets are equal for all @xmath110 then we say that @xmath138 and @xmath146 are of the same accuracy .",
    "in particular if both @xmath138 and @xmath146 are complete then they are of the same accuracy , as we have already noted , cti employs an @xmath146 procedure which is complete and terminweb applies @xmath138 and @xmath146 procedures which are sound but not complete .",
    "the following theorem states that if @xmath138 and @xmath146 are of the same accuracy then termination checking and inference report equivalent results .",
    "let @xmath194 and @xmath195 be analysers for checking and inferring termination based on procedures @xmath138 and @xmath146 of the same accuracy and assume that these analysers approximate loops and instantiation information in the same way .",
    "assume also that @xmath195 is based on backwards analysis .",
    "then , @xmath194 reports that @xmath13 terminates for a mode @xmath174 if and only if @xmath174 is inferred by @xmath195 .",
    "let us first make two simple observations concerning backwards analysis :    * * ( ba@xmath196 ) * : let @xmath13 be a logic program , @xmath197 an initial call pattern , @xmath198 and @xmath199 a logic program with assertions defined by introducing to the clauses in @xmath13 the call patterns from @xmath16 as initial assertions : @xmath200 then , if @xmath201 is the result of backwards analysis of @xmath199 for @xmath202 , then @xmath203 . + * * ( ba@xmath204 ) * : let @xmath205 be a logic program with assertions and let @xmath206 be the result of backwards analysis of @xmath205 for @xmath176 .",
    "let @xmath207 be a program obtained by replacing an assertion @xmath208 in @xmath205 by an assertion @xmath209 such that @xmath210 and let @xmath211 be the result of backwards analysis of @xmath207 for @xmath176",
    ". then @xmath212 .",
    "+    * @xmath213",
    "*   let @xmath197 be a mode for which @xmath194 proves termination , we show that @xmath14 is inferred by @xmath195 .",
    "denote @xmath198 and let @xmath214 and @xmath215 .",
    "consider the set @xmath216 of variables instantiated in @xmath19 .",
    "@xmath217 answers `` yes '' because @xmath194 proves termination and by the assumption that @xmath138 and @xmath146 are of the same accuracy , @xmath218 .",
    "hence , by definition  [ def : assertion ] , @xmath219 . by definition [ def : ie",
    "] @xmath220 , so we have @xmath221 * ( * ) * .",
    "let @xmath222 be the result of backwards analysis for @xmath13 with call patterns from @xmath16 as initial assertions .",
    "by observation * ( ba@xmath196 ) * @xmath222 is the call pattern from @xmath176 and hence @xmath223 ( because @xmath14 is one of the call patterns for @xmath176 ) .",
    "now by * ( * ) * , the termination assertions ( @xmath224 ) are more general than the call patterns ( @xmath19 ) and hence by observation * ( ba@xmath204 ) * @xmath62 implies the result of backwards analysis with termination assertions replacing call patterns . in particular",
    "this is the case for @xmath202 and so @xmath14 is inferred by @xmath195 to be a terminating mode for @xmath13 .    *",
    "@xmath225 *   let @xmath14 be a terminating mode inferred by @xmath195 , we show that @xmath194 proves termination of @xmath14 .",
    "for this we show that for any @xmath226 and @xmath227 there exists a decreasing set of arguments which is also instantiated enough : from the correctness of backwards analysis we know that @xmath228 , and since @xmath147 was constructed in order to guarantee that at least one decreasing arguments set for @xmath110 is instantiated enough , so there exists @xmath229 such that @xmath230 . since @xmath141 can be assumed without loss of generality to be extensive @xmath218 and according to the accuracy requirements @xmath217 answers `` yes '' .",
    "so the termination condition holds and @xmath194 proves termination for @xmath14 .    in the case of our analysers , using the fast versions of @xmath138 and @xmath146 , checking is always as precise as inference .",
    "this follows as a simple result from the definitions of @xmath138 and @xmath146 .",
    "however , inference may be weaker than checking . the benchmark program ` rev_interleave ` in table [ table : t1 ] demonstrates this case . enhancing our analysers with and for @xmath138 and @xmath146 respectively , would result in analysers which infer and check the same sets of modes .",
    "this because both and are complete and hence of the same accuracy .",
    "note that we can not make such a comparison for termination inference as implemented in cti because it is based on a different technique for inferring termination conditions . while this technique seems equivalent to backwards analysis , to make a formal comparison we would need to prove that it supports the two claims * ( ba@xmath196 ) * and * ( ba@xmath204)*.",
    "this section describes an evaluation comparing our termination inference and termination checking analysers .",
    "we also compare our analyser for termination inference with the cti @xcite analyzer . for the experiments described , our analyser runs sicstus 3.7.1 on a pentium iii 500mhz machine with 128 mb ram under linux redhat 7.1 ( kernel 2.4.2 - 2 ) .",
    "the cti analyser runs sicstus 3.8.4 on an athlon 750mhz machine with 256 mb ram .",
    "the timings for cti are taken from @xcite .",
    "table [ table : t1 ] indicates analysis times in seconds for three blocks of programs .",
    "the first two blocks correspond respectively to the programs from tables 2 and 5 in @xcite .",
    "the third block contains two programs included to make a point detailed below .",
    "the analysis parameters are the same as those reported in @xcite  term - size norm with widening applied every third iteration , except for the programs marked by a @xmath231 for which the list - length norm is applied and widening is performed every fourth iteration .",
    "the columns in the table indicate the cost for :    * * joint : * the activities common to termination checking and inference : preprocessing ( reading , abstraction , computing sccs , printing results ) , size analysis ( to approximate binary clauses ) and groundness analysis ( to approximate answers ) .",
    "note that in terminweb , the checking component uses groundness analysis as described in @xcite while the inference component uses a faster bdd based analyser .",
    "for the sake of comparison we consider the timing of the bdd based analyser for both checking and inference . * * inf : * the activities specific to termination inference : computing initial instantiation assertions as specified in definition  [ def : assertion ] ( about 90% ) and performing backwards analysis ( about 10% ) . *",
    "* check : * the additional activities specific to termination checking for a single one of the top - level modes inferred to terminate . * * total inf : * the total analysis time for inference using our analyser ( @xmath232 ) . *",
    "* cti : * the total analysis time for inference using cti ( timings as reported in @xcite ) .",
    ".experimental results [ cols=\"<,<,<,<,<,<\",options=\"header \" , ]     [ [ regarding - precision ] ] * regarding precision * + + + + + + + + + + + + + + + + + + + + +    for the first block of programs we infer exactly the same termination conditions as cti . for the second block ( of larger programs ) , we infer the same number of terminating predicates as does cti , except for the last three programs where a `` @xmath233 '' indicates that we infer termination for more predicates than does cti and a `` @xmath234 '' vice - versa .",
    "these differences stem from the fact that the two analysers are based on slightly different components for approximating loops . for all programs , in the first two blocks , our termination checker verifies termination for the same set of modes as our termination inference infers .",
    "note that for the second block of programs we count only the number of terminating predicates in order to be consistent with the experiments reported for cti in @xcite .",
    "the two programs in the third block demonstrate how the precision of the @xmath138 and @xmath146 affect the precision of the analysis .",
    "here @xmath235 indicates that inference with is more precise than inference with our simplified @xmath146 procedure , and @xmath236 indicates that our termination checking gives a more precise result than our termination inference  this is due to the fact that our choice of @xmath138 and @xmath146 are not complete ( as described in section [ cvsi ] ) .",
    "[ [ regarding - timings ] ] * regarding timings * + + + + + + + + + + + + + + + + + + +    the comparison of the columns * total inf * and * cti * indicate that terminweb and cti are comparable for termination inference .",
    "we note that the published results for cti are obtained on a different machine , the two analyzers are implemented using different versions of sicstus prolog and they use different libraries for manipulating constraints . for arithmetic constraints",
    ", terminweb uses the library while cti uses the library .",
    "the prior is more efficient but may loose precision . for boolean constraints , terminweb uses the library described in @xcite , while cti uses the sicstus library .",
    "the prior is considerably faster .",
    "more interesting is to notice the comparison of columns * inf * and * check * which indicates that the cost of inferring all terminating modes at once ( computing assertions and apply backards analysis ) is typically faster than performing a termination check for a single mode .",
    "this paper draws on results from two areas : termination ( checking ) analysis and backwards analysis .",
    "it shows how to combine components implementing these so as to obtain an analyser for termination inference .",
    "termination checking for logic programs has been studied extensively ( see for example the survey @xcite ) . backwards reasoning for imperative programs dates back to the early days of static analysis and has been applied extensively in functional programming .",
    "applications of backwards analysis in the context of logic programming are few . for details concerning other applications of backwards analysis ,",
    "see @xcite . the only other work on termination inference that we are aware of",
    "is that of mesnard and coauthors .",
    "the implementation of mesnard s cti analyser is described in @xcite and its formal justification is given in @xcite .",
    "the two techniques ( cti and ours ) appear to be equivalent .",
    "the real difference is in the approach .",
    "our analyser combines termination checking and backwards analysis to perform termination inference .",
    "this is a `` black - box '' approach which simplifies design , implementation and formal justification .",
    "the implementation reuses the terminweb code and an implementation of the backwards analysis algorithm described and formally justified in @xcite .",
    "both systems compute the greatest fixed point of a system of recursive equations . in our case",
    "the implementation is based on a simple meta - interpreter written in prolog . in cti",
    ", the implementation is based on a @xmath55-calculus interpreter . in our case",
    "this system of equations is set up as an instance of backwards analysis hence providing a clear motivation and justification @xcite .",
    "we have demonstrated that backwards analysis provides a useful link relating termination checking and termination inference .",
    "this leads to a better understanding of termination inference and simplifies the formal justification and the implementation of termination inference .",
    "we demonstrate this by enhancing the analyser for termination checking described in @xcite to perform also termination inference .",
    "we also identify a simple condition which guarantees that termination inference can infer all provably terminating modes when the corresponding analysers make use of the same underlying analyses for size relations and instantiation dependencies .",
    "introduction to logic programming . in _ handbook of theoretical computer science _ , j.  van leeuwen , ed .",
    "b : formal models and semantics .",
    "elsevier , amsterdam and the mit press , cambridge , 495574 .",
    "abstract interpretation : a unified lattice model for static analysis of programs by construction or approximation of fixpoints . in _ proc .",
    "4th acm symp .",
    "principles of programming languages_. acm press , new york , 238252 .",
    "\\2001 . inferring termination conditions for logic programs using backwards analysis . in _ proceedings of the eighth international conference on logic for programming , artificial intelligence and reasoning _ ,",
    "r.  nieuwenhuis and a.  voronkov , eds .",
    "lecture notes in artificial intelligence , vol . 2250 .",
    "springer - verlag , 681690 .",
    "\\2001 . applying static analysis techniques for inferring termination conditions of logic programs . in _",
    "static program analysis symposium _ , p.  cousot , ed .",
    "lecture notes in computer science , vol .",
    "springer , 93110 ."
  ],
  "abstract_text": [
    "<S> this paper focuses on the inference of modes for which a logic program is guaranteed to terminate . </S>",
    "<S> this generalises traditional termination analysis where an analyser tries to verify termination for a specified mode . </S>",
    "<S> our contribution is a methodology in which components of traditional termination analysis are combined with backwards analysis to obtain an analyser for termination inference . </S>",
    "<S> we identify a condition on the components of the analyser which guarantees that termination inference will infer all modes which can be checked to terminate . </S>",
    "<S> the application of this methodology to enhance a traditional termination analyser to perform also termination inference is demonstrated . </S>"
  ]
}