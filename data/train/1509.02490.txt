{
  "article_text": [
    "recently , it has become more and more common for technology to handle various tasks in everyday life , each one with an associated complexity . ensuring that systems work properly imply in cost reduction and even , in some areas , that lives are safe .",
    "this is what makes program debugging so worthy of attention in computer - based systems .",
    "program debugging is a very important but time - consuming task , in software development processes , which can be divided into three steps : fault detection , fault localization , and fault correction .",
    "however , the associated debugging time can be largely reduced , if automatic methods are used for localizing faults , especially in multi - threaded programs , which are widely used in embedded system products .",
    "a number of different approaches have been introduced , in order to provide automated methods for localizing faults in applications , based on the generation of a program model that is extracted from its source code  @xcite .",
    "those include slicing  @xcite , mutation testing  @xcite , trace - based analysis  @xcite , delta - debugging  @xcite , model - based debugging  @xcite , and model checking  @xcite . in this paper , a fault localization method",
    "is proposed , which relies entirely on model - checking techniques . in particular , bounded model checking ( bmc ) based on satisfiability modulo theories ( smt ) is used to automatically refute a safety property and consequently produce a counterexample , if the ( multi - threaded ) program does not satisfy a given specification .",
    "it is worth noticing that the generated counterexamples may be regarded as error traces , which contain useful information about faults , so that one can localize and correct them .",
    "the c bounded model checker ( cbmc )  @xcite and also the efficient smt - based context - bounded model checker ( esbmc )  @xcite are both well known bmc tools , which are suitable for verifying multi - threaded c programs .",
    "since the majority of the initiatives , in multi - threaded software verification , have focused on java , as shown by park , harrold , and vuduc  @xcite , this study suggests an automated fault localization method for multi - threaded c programs , using smt - based bmc techniques . in particular , in this present work",
    ", esbmc  @xcite is adopted , since it is one of the most efficient verifiers , as reported by beyer  @xcite , and it also supports both single- and multi - threaded programs , using different smt solvers to check for the generated verification conditions ( vcs )  @xcite .",
    "two main goals are achieved here : the evaluation of the method proposed by griesmeyer , staber , and bloem  @xcite and the improvement / extension of this same method , in order to support multi - threaded applications .",
    "the basic concept of extending the mentioned work  @xcite consists in transforming a multi - threaded program into a corresponding sequential one , by carrying out evaluation and transformation steps , and then using that work for localizing faults . as a consequence , the found violations , in the sequential code",
    ", can show the location of the initial faults , in the original multi - threaded program .",
    "this paper is organized as follows .",
    "section [ sec : relatedwork ] describes the related work .",
    "fault localization based on model checking is introduced in section [ sec : background ] . the method proposed by griesmeyer , staber , and bloem @xcite",
    "is also tackled , in detail , in section [ sec : background ] .",
    "section [ sec : methodmultithreaded ] is the main section of the present paper and demonstrates the proposed method for fault localization , in multi - threaded programs .",
    "section [ sec : experiment ] provides experimental results , analysis , and discussion .",
    "finally , section [ sec : conclusion ] summarizes the main results and highlights future work .",
    "cleve _ et al . _",
    "@xcite show how _ cause transitions _",
    ", which are moments where a variable replaces another as failure cause , can locate defects in programs .",
    "such an achievement is possible due to a comparison regarding program states of failing and passing runs ; however , given that such state differences can occur all over the program run , the focus is _ in space _ , with a subset of variables that is relevant to the failure occurrence , and also _ in time _ , where _ cause transitions _ occur .",
    "griesmeyer _ et al . _",
    "@xcite proposed a method for localizing faults , in ansi - c programs , by instrumenting the original code and running that new version on a model checker .",
    "such an approach is very helpful , given that model checkers are able to identify the exact fault line ; however , this work only presented a method for sequential programs  @xcite",
    ".    birch _ et al . _",
    "@xcite describe a method for fast model - based fault localization , which , given a test suite , automatically identifies a small subset of program locations , where faults exist , by using symbolic execution methods . in summary",
    ", the mentioned algorithm tries to find counterexamples that are capable of localizing faults , based on failing test cases from a test suite .",
    "the key factor to its speed is that if an execution takes longer than expected , it is pushed into a queue , for later handling , and then another execution is chosen to be run .",
    "jones _ et al . _",
    "@xcite showed how test information visualization can assist in fault localization . by coloring program statements that participate in the outcome of a program execution , with a test suite , it is possible to assist users to inspect code , evaluate statements involved in failures , and identify possible faults .",
    "jose _ et al . _",
    "@xcite reported a method to localize faults in programs , using a reduction to the maximal satisfiability problem , which informs the maximum number of clauses , of a boolean formula , that can simultaneously be satisfied by an assignment .",
    "the potential error is given by finding the maximal set of clauses that can be satisfied , in a formula generated by combining a failing program execution and a boolean trace formula , and outputting the complement set .",
    "tomasco _ et al . _",
    "@xcite presented an approach for symbolically verifying multi - threaded programs , with shared memory and dynamic thread creation , by using a technique called memory unwinding ( mu ) , which is the process of writing operations into shared memory . a code - to - code transformation from multi - threaded to sequential programs",
    "was used , following mu rules , and then checked by a sequential verification tool .",
    "the closest related work is that of park _ et al . _",
    "@xcite , which describe a dynamic fault localization method to localize the root causes of concurrency bugs in java programs , based on dynamic pattern detection and statistical fault localization . to the best of our knowledge",
    ", this present paper marks the first application of a fault - localization method , based on bmc techniques , to a broader range of multi - threaded c programs .",
    "the basic idea of bmc applied to multi - threaded software is to check for the negation of a given property , at a given depth  @xcite . given a reachability tree @xmath0 , which represents the program unfolding for a context bound @xmath1 and a bound @xmath2 , and a property @xmath3 , bmc derives a vc @xmath4 for a given interleaving ( or computation path ) @xmath5 , such that @xmath4 is satisfiable if and only if @xmath3 has a counterexample of depth _ k _ , which is exhibited by @xmath6 .",
    "the vc @xmath4 is a quantifier - free formula in a decidable subset of first - order logic , which is checked for satisfiability by an smt solver  @xcite .",
    "the model checking problem associated with smt - based bmc , of a given @xmath6 , is formulated by constructing the logical formula  @xcite @xmath7 here , @xmath8 represents a safety property @xmath3 , in step @xmath2 , @xmath9 is the set of initial states , and @xmath10 is the transition relation at time steps @xmath11 and @xmath12 , as described by the states in @xmath6 nodes .   in order to check",
    "if ( [ bounded - model - checking ] ) is satisfiable or unsatisfiable , the smt solver constrains some symbols , by a given background theory ( _ e.g. _ , arithmetic restricts the interpretation of symbols such as @xmath13 , @xmath14 , @xmath15 , and @xmath16 )  @xcite .  if ( [ bounded - model - checking ] ) is satisfiable , then @xmath3 is violated and the smt solver provides a satisfying assignment , from which one can extract values of program variables to construct a counterexample , _",
    "i.e. _ , a sequence of states @xmath17 , with @xmath18 , and transition relations @xmath19 , for @xmath20 .   if ( [ bounded - model - checking ] ) is unsatisfiable , one can conclude that no error state is reachable , in length @xmath2 along @xmath6 .",
    "the most basic task regarding fault localization , in model checking , is to generate a counterexample , which is provided when a program does not satisfy a given specification . according to clarke _",
    "et al . _",
    "@xcite , a counterexample does not solely provide information about the cause - effect relation of a given violation , but also about fault localization .",
    "however , since an enormous amount of information is presented in a counterexample , actual fault lines may not be easily identified .",
    "several methods have been proposed , in order to localize possible fault causes , through counterexamples .",
    "an approach proposed by ball , naik , and rajamani  @xcite tries isolating possible causes of counterexamples , which are generated by the slam model checker  @xcite . in summary",
    ", potential fault lines can be isolated by comparing transitions among obtained counterexamples and successful traces , since transitions not included in correct traces are possible causes of errors .",
    "groce and visser  @xcite state that if a counterexample exists , a similar but successful trace can also be found , using bmc techniques .",
    "program elements related to a given violation are implicated by the minimal differences between that counterexample and a successful trace , which is known as the java pathfinder approach  @xcite and can also provide execution paths that lead to error states , regarding for multi - threaded programs ( _ e.g. _ , data race ) .",
    "the essence of the approach described by groce _",
    "et al . _",
    "@xcite is similar to the latter and uses alignment constraints to associate states , in a counterexample , with corresponding states in a successful trace , which was generated by a constraint solver .",
    "the mentioned states are abstract states over predicates , which represent concrete states in a trace . by using distance metric properties ,",
    "constraints can be employed for representing program executions , and non - matching constraints that represent concrete states might lead to faults .",
    "additionally , if a distance metric property is not satisfied , a counterexample is generated by the bmc tool  @xcite .",
    "in contrast to the transition - based and difference - based methods mentioned above , a method can directly identify possible faults by combining instrumented programs and bmc , as shown by griesmeyer _ et al . _",
    "@xcite , which will be further demonstrated .",
    "the approach proposed in the present paper is based on that method and consists in an extension to multi - threaded programs , that is , it tries to identify fault lines in multi - threaded programs , using bmc techniques .      the method proposed by griesmeyer _",
    "et al . _",
    "@xcite is based on the bmc technique , which can directly identify possible faults in programs . in particular",
    ", this method adds additional numerical variables ( _ e.g. _ , ` diag1 , ... , diagn ` ) ) to identify a fault in a given program .",
    "each line of a program , representing a statement ` s ` , is changed to a logic version of that statement . as a consequence , the value held by ` s ` will be either non - deterministically chosen by the bmc tool , if the value of ` diag ` is the same as the one representing the line related to statement ` s ` , or the one originally specified .    if the bmc tool identifies a ` diag ` value , by correcting this line in the original program , the fault can be avoided . in the case of multiple ` diag ` values , correcting those lines lead to a successful code execution . in order to find the full set of lines that cause a faulty behavior in a program , a new line can be added to its source code , which is then rerun in the bmc tool .",
    "this process is repeatedly executed , until no more values of ` diag ` are obtained ( _ i.e. _ , the run succeeds )  @xcite .    as an example , a simple program slightly modified from griesmeyer _ et al . _",
    "@xcite , is presented in fig .",
    "[ figure : simpleprogram ] .",
    "its modified version , using the mentioned method  @xcite and ready to be run by a bmc tool , is shown in fig .",
    "[ figure : modifiedversion ] . the diagnosis informed by a bmc tool is ` diag = = 4 ` and ` diag = = 7 ` , which means that changing line @xmath21 ( to `` ` a = 6 ` '' ) or line @xmath22 ( to ` if(0 ) ` ) , in the original program , can result in source code that is able to successfully execute , therefore",
    ", one can note that the example below contains a single fault .",
    ".... void main ( ) {    int a , b , c , d ;      if ( a ) {        a = 5 ;        b = 2 ;        c = a + b ;        if ( a % 2 = = 0 ) {        int d ;        a = d ;        }        assert ( c = = 8) ;      } } ....    .... int nondet ( ) ; void main ( ) {    int a , b , c , d ;      int diag ;      diag = nondet ( ) ;      a = 5 ; b = 2 ; c = 7 ;      if ( diag = = 4 ? nondet ( ) : a ) {        a = ( diag = = 6 ?",
    "nondet ( ) : 5 ) ;        b = ( diag = = 7 ?",
    "nondet ( ) : 2 ) ;        c = ( diag = = 8 ?",
    "nondet ( ) : ( a + b ) ) ;        if ( diag = = 9 ? nondet ( ) : ( a%2==0 ) ) {          int d ;          a = ( diag = = 12 ?",
    "nondet ( ) : d ) ;        }        assume(c = = 8) ;      }      assert(false ) ; } ....",
    "the proposed method , which has the goal of localizing faults in multi - threaded c programs , is based on griesmeyer s method  @xcite and counterexamples generated by bmc tools , such as esbmc .",
    "its key concept is to transform a multi - threaded program into a corresponding sequential one and then apply instrumentation for identifying faults  @xcite .",
    "the transformation from multi - threaded programs into sequential ones can be split into four distinct steps .",
    "first , counterexamples are obtained from a bmc tool , which contain useful pieces of information related to faults .",
    "then , the framework described below is applied , which consists in code used as fixed structure for a new sequential version , together with the use of some rules ( defined later in section  [ sec : rules ] ) . following that , an original ( multi - threaded ) program is converted into its sequential version and ,",
    "finally , order control is included into the latter , specifying the order in which threads are executed .",
    "these steps are summarized in fig .",
    "[ figure : methodology ] .",
    "a framework provides the same execution sequence as in the original program .",
    "it consists basically in writing each thread code inside a @xmath23 statement , and their execution sequence is specified in the @xmath24 array .",
    "such a framework is used as the basic structure for new sequential versions of multi - threaded programs , and fig .",
    "[ figure : framework ] shows how it is encoded .",
    ".... int order[1 ] = { 1 } ; int main(int argc , char * argv [ ] ) {      int order_index ;      for(order_index= 0 ; order_index < 1 ;           order_index++ ) {        switch(order[order_index ] ) {          case 1 :              case 11 : { ... }              ...              case 20 : { ... }          break ;          case 2 :              case 21 : { ... }              ...              case 30 : { ... }          break ;          case 3 :              case 31 : { ... }              ...              case 40 : { ... }          break ;          ...          default :          break ;        }      }      return 1 ; } ....    as one can note , the mentioned framework provides new fixed positions , for each part of the original code , and table  [ table : relation ] shows the relation between new positions and code - fragment types , that is , it summarizes how the new sequential code is structured . in particular , global elements , global variables , header file declarations , and other types of global declarations",
    "are placed before the sequential code @xmath25 function .",
    "the body of its @xmath25 function , in the original code , is placed between the @xmath23 @xmath16 statement and its respective @xmath26 command , the body of the first thread is placed between @xmath23 @xmath27 and its respective @xmath26 command , and so on .",
    "this process is repeated until there are no more threads to be inserted into the sequential code version .",
    "additionally , arguments passed to the original program @xmath25 function are all passed to the sequential version @xmath25 one . in cases where threads are partially executed , a context switch occurs , another thread is executed , or a previous thread continues to execute from where it stopped , the respective pieces of code are inserted into each @xmath23 inside the @xmath28 @xmath23 ( the @xmath28 case represents the @xmath28 thread ) , in such a way that the execution order remains the same .",
    ".relation between positions and codes [ cols=\"^,^ \" , ]     the verification of _ account_bad.c _ presented @xmath29 different ` diag ` values , which are in different parts of the code ; however , they ultimately identified the actual fault in the original code , which was a bad assertion .",
    "the @xmath22 diagnosed values regarding _",
    "circular_buffer_bad.c _ led to a bad assertion in the program , which is related to a loop .",
    "this way , the ` diag ` values indicate this loop .    when checking _",
    "arithmetic_prog_bad.c _ , the proposed methodology informed @xmath27 different ` diag ` values , which address a loop in thread @xmath27 of this program , meaning that the fault is in that specific loop .    the analysis of both _ lazy01_bad.c _ and _ queue_bad.c _ presented @xmath21 errors . in the former ,",
    "esbmc indicated that the faults lie on the code part where its shared variable is used , which led to a bad assertion . in the latter ,",
    "the identified faults are related to flags providing access control to a shared variable and a loop , where they are changed , that is , the problem lies again on bad handling .    _",
    "sync02_bad.c _ presented @xmath27 different values , related to a consumer thread in the original program , whose lines are related to a deadlock present in this benchmark .",
    "although _ sync01_bad.c _ and _ token_ring_bad.c _ presented no errors , both were diagnosed with one fault .",
    "indeed , esbmc found a ` diag ` with value @xmath15 , which is particularly odd , since there is no line @xmath15 .",
    "besides , even after adding an assert , esbmc still diagnoses @xmath15 .",
    "indeed , both have synchronization problems and the proposed method was unable to provide useful information .",
    "the proposed methodology was not able to verify benchmarks _",
    "carter_bad.c _ , _",
    "twostage_bad.c _ , and _ wronglock_bad.c _ , since there was not enough memory while esbmc checked for deadlocks .",
    "this probably occurred due to the great number of threads ( in case of _",
    "twostage_bad.c _ , and _",
    "wronglock_bad.c _ ) or due to a very large set of data variables ( _ carter01_bad.c _ ) .    according to the results shown in table  [ table : results ]",
    ", one can note that the proposed methodology was able to find faults ( useful information ) in @xmath30 out of @xmath31 benchmarks , which amounts to @xmath32.@xmath33% .",
    "note that benchmarks whose verification failed and , consequently , from which no counterexample was extracted , are also included into this evaluation .",
    "the methodology itself showed to be useful in diagnosing data race violations , since most of the used benchmarks presented a fault related to that problem .",
    "however , the proposed method needs to be improved , in order to verify deadlocks in a more efficient way , and loop transformations also need a significant work , so that threads interleaving inside loops can be better represented .",
    "regarding benchmarks in which no useful information was obtained , that leads to the conclusion that improved grammar and rules are needed , in order to localize faults .",
    "apart from that , the experimental results showed the feasibility of the proposed methodology for localizing violations , in multi - threaded c programs , since esbmc is able to provide helpful diagnosis information regarding potential faults .",
    "a novel method for localizing faults in multi - threaded c programs , using code transformation and bmc techniques , was proposed .",
    "it is based on the approach introduced by griesmeyer _",
    "et al . _",
    "@xcite and an extension specific to handle multi - threaded programs , which is useful for embedded systems .",
    "the experimental results revealed the performance of the proposed methodology , when localizing faults in standard multi - threaded c benchmarks .",
    "in particular , it was able to identify potential faults in multi - threaded software , in @xmath32.@xmath33% of the chosen benchmarks .",
    "besides , this number may change to @xmath34% , if only the ones able to be verified are considered , _",
    "i.e. _ , those where counterexamples are provided by the bmc tool ( see column * vt * in table [ table : results ] ) .    as future work ,",
    "new rules for code transformation and also an improved grammar will be developed , in order to increase the methodology accuracy .",
    "additionally , an _ eclipse _ plug - in will be developed for automating the fault diagnosis process , during development .",
    "e.  clarke and h.  veith , _ counterexamples revisited : principles , algorithms , applications_. in verification : theory and practice , essays dedicated to zohar manna on the occasion of his 64th birthday , pp . 208224 , 2003 ."
  ],
  "abstract_text": [
    "<S> software debugging is a very time - consuming process , which is even worse for multi - threaded programs , due to the non - deterministic behavior of thread - scheduling algorithms . </S>",
    "<S> however , the debugging time may be greatly reduced , if automatic methods are used for localizing faults . in this study </S>",
    "<S> , a new method for fault localization , in multi - threaded c programs , is proposed . </S>",
    "<S> it transforms a multi - threaded program into a corresponding sequential one and then uses a fault - diagnosis method suitable for this type of program , in order to localize faults . </S>",
    "<S> the code transformation is implemented with rules and context switch information from counterexamples , which are typically generated by bounded model checkers . </S>",
    "<S> experimental results show that the proposed method is effective , in such a way that sequential fault - localization methods can be extended to multi - threaded programs .    </S>",
    "<S> _ multi - threaded software , bounded model checking , fault localization_. </S>"
  ]
}