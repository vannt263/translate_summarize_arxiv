{
  "article_text": [
    "in  @xcite , dijkstra presents the following mutual exclusion protocol for a ring of nodes @xmath0 where each node can read the state @xmath1 \\in \\set{0}{k-1}$ ] of its anti - clockwise neighbour , and where node @xmath2 runs a different program than the other nodes .",
    "node @xmath2 , privileged when @xmath3=x[n]$ ] @xmath3=x[n]$ ] @xmath3 \\assign ( x[0 ] + 1 ) \\bmod k$ ] node @xmath4 , @xmath5 , privileged when @xmath6 \\neq x[i-1]$ ]",
    "@xmath6 \\neq x[i-1]$ ] @xmath6 \\assign x[i-1]$ ]    dijkstra proves self - stabilization of this protocol to a configuration where only one node is privileged at a time , for @xmath7 under a central daemon and says  @xcite : `` for smaller values of @xmath8 , counter examples kill the assumption of self - stabilization '' .",
    "failing to find a counter example for @xmath9 , we instead found the following proof that the system also stabilizes when @xmath9 , provided that @xmath10 .",
    "we first define the legitimate configurations as those configurations that satisfy @xmath6=a$ ] for all @xmath4 with @xmath11 and @xmath6=(a-1 ) \\bmod k$ ] for all @xmath4 with @xmath12 for some choice of @xmath13 and @xmath14 .",
    "hence the configuration where all nodes have the same state is legitimate .",
    "dijkstra already showed ( independent of any restriction on @xmath8 ) closure of the legitimate states , that no run of the protocol ever terminates , and that in each of these runs the exceptional node will change state ( aka `` fire '' ) infinitely often .",
    "let @xmath10 .",
    "consider the case where node @xmath2 fires for the first time .",
    "then just before that , @xmath3=x[n]=b$ ] for some @xmath15 and the new value of @xmath3 $ ] becomes @xmath16 .",
    "now consider the case when node @xmath2 fires again .",
    "then just before that , @xmath3=x[n]=b+1 $ ] . in order for node @xmath17 to change value from @xmath15 to @xmath16 ,",
    "it must have copied @xmath16 from its anti - clockwise neighbour @xmath18 $ ] ( which exists if @xmath10 ) .",
    "this moment must have occurred after node @xmath2 changed state to @xmath3=b+1 $ ] .",
    "but then , just after node @xmath17 copies @xmath16 from node @xmath19 we actually have @xmath18=x[n]=x[0]=b+1 $ ] .    in other words , if @xmath10 , three different nodes hold the same value @xmath16 .",
    "then the remaining @xmath20 nodes can each take a different value from the remaining @xmath21 values ( unequal to @xmath16 ) , which means that if @xmath22 ( so in particular when @xmath9 ) at this point in time there is a value @xmath13 ( among these @xmath21 values ) not occurring as the state of any node on the ring .    because node @xmath2 fires infinitely often , eventually @xmath3 $ ] becomes @xmath13 . because the other nodes merely copy values from their anti - clockwise neighbours , at this point no other node holds @xmath13 .",
    "the next time node @xmath2 fires , @xmath23=x[0]=a$ ] .",
    "the only way that node @xmath17 gets the value @xmath13 is if all intermediate nodes have copied @xmath13 from node @xmath2 .",
    "we conclude that for nodes , @xmath6=a$ ] , which is a legitimate state ."
  ],
  "abstract_text": [
    "<S> we show that , contrary to common belief , dijkstra s self - stabilizing mutual exclusion algorithm on a ring  @xcite also stabilizes when the number of states per node is one less than the number of nodes on the ring .    </S>",
    "<S> * keywords * : distributed computing , fault tolerance , self - stabilization . </S>"
  ]
}