{
  "article_text": [
    "there are two types of semantics for a logic program : a declarative semantics and a procedural semantics .",
    "the declarative semantics formally defines the meaning of a logic program by specifying an _ intended model _ among all models of the logic program , whereas the procedural semantics implements / computes the declarative semantics by providing an algorithm for evaluating queries against the logic program .",
    "most existing procedural semantics are built upon the well - known _ resolution rule _ created by robinson @xcite .",
    "prolog is the first yet the most popular logic programming language @xcite .",
    "it adopts _ sldnf - resolution _ as its procedural semantics @xcite .",
    "one of the best - known properties of sldnf - resolution is its _ linearity _ of derivations , i.e. , its query evaluation ( i.e. , sldnf - derivations ) constitutes a search tree , called an _ sldnf - tree _ , which can be implemented easily and efficiently using a simple stack - based memory structure @xcite .",
    "however , sldnf - resolution suffers from two serious problems .",
    "first , its corresponding declarative semantics , i.e. the _ predicate completion semantics _ @xcite , is based on two truth values ( either _ true _ or _ false _ ) and thus incurs inconsistency for some logic programs like @xmath0 @xcite .",
    "second , it may generate infinite loops and a large amount of redundant sub - derivations @xcite .    to overcome the first problem with sldnf - resolution , the _ well - founded semantics _",
    "@xcite is introduced as an alternative to the predicate completion semantics .",
    "a well - founded model accommodates three truth values : _ true , false _ and _ undefined _ , so that inconsistency is avoided by letting atoms that are recursively connected through negation undefined .",
    "several procedural semantics have been developed as an alternative to sldnf - resolution to compute the well - founded semantics , among the most representative of which are _ global sls - resolution _",
    "@xcite and _ slg - resolution _ @xcite",
    ".    global sls - resolution is a direct extension of sldnf - resolution .",
    "it evaluates queries under the well - founded semantics by generating a search tree , called an _ sls - tree _",
    ", in the same way as sldnf - resolution does except that infinite derivations are treated as _ failed _ and infinite recursions through negation as _",
    "undefined_. global sls - resolution retains the linearity property of sldnf - resolution , but it also inherits the problem of infinite loops and redundant computations . moreover , global sls - resolution handles negation as follows : a ground atom @xmath1 is false when all branches of the sls - tree for @xmath1 are either infinite or end at a failure leaf .",
    "infinite branches make global sls - resolution not effective in general @xcite .    to resolve infinite loops and redundant computations , the _ tabling _ technique is introduced @xcite .",
    "the main idea of tabling is to store intermediate answers of subgoals and then apply them to solve variants of the subgoals .",
    "with tabling no variant subgoals will be recomputed by applying the same set of clauses , so infinite loops can be avoided and redundant computations be substantially reduced .",
    "there are two typical ways to make use of tabling to compute the well - founded semantics .",
    "one is to directly enhance sldnf - resolution or global sls - resolution with tabling while the other is to create a new tabling mechanism with a different derivation structure .",
    "slg - resolution results from the second way @xcite . due to the use of tabling",
    ", slg - resolution gets rid of infinite loops and reduces redundant computations .",
    "however , it does not have the linearity property since its query evaluation constitutes a search forest instead of a search tree . as a result",
    ", it can not be implemented in the same way as sldnf - resolution using a simple stack - based memory structure @xcite .    in @xcite",
    "an attempt is made to directly enhance sldnf - resolution with tabling to compute the well - founded semantics , which leads to a tabling mechanism , called _ slt - resolution_. slt - resolution retains the linearity property , thus is referred to as a _ linear tabling _ mechanism . due to the use of tabling , it is free of infinite loops and has fewer redundant computations than sldnf - resolution .",
    "however , slt - resolution has the following two major drawbacks : ( 1 ) it defines positive loops and negative loops based on the same ancestor - descendant relation , which makes loop detection and handling quite costly since a loop may go across several ( subsidiary ) slt - trees .",
    "( 2 ) it makes use of answer iteration to derive all answers of looping subgoals , but provides no answer completion criteria for pruning redundant derivations . note that answer completion is the key to an efficient tabling mechanism .    in this paper",
    ", we develop a new procedural semantics , called _ sltnf - resolution _ , for the well - founded semantics by enhancing global sls - resolution with tabling and loop cutting mechanisms .",
    "sltnf - resolution retains the linearity property and makes use of tabling to get rid of all loops and reduce redundant computations .",
    "it defines positive and negative loops in terms of two different ancestor - descendant relations , one on subgoals within an sls - tree and the other on sls - trees , so that positive and negative loops can be efficiently detected and handled .",
    "it employs two effective criteria for answer completion of tabled subgoals so that redundant derivations can be pruned as early as possible .",
    "all these mechanisms are integrated into an algorithm quite like that for generating sls - trees .",
    "the paper is organized as follows .",
    "section 2 reviews global sls - resolution .",
    "section 3 defines ancestor - descendant relations for identifying positive and negative loops , develops an algorithm for generating sltnf - trees , establishes criteria for determining answer completion of tabled subgoals , and proves the correctness of sltnf - resolution .",
    "section 4 mentions some related work , and section 5 concludes .",
    "in this section , we review some standard terminology of logic programs @xcite and recall the definition of global sls - resolution .",
    "we do not repeat the definition of the well - founded model here ; it can be found in @xcite and many other papers .",
    "variables begin with a capital letter , and predicate , function and constant symbols with a lower case letter . by a _",
    "variant _ of a literal @xmath2 we mean a literal @xmath3 that is identical to @xmath2 up to variable renaming .",
    "_ a _ general logic program _ ( logic program for short ) is a finite set of clauses of the form _",
    "@xmath4    where @xmath1 is an atom and @xmath5s are literals .",
    "@xmath1 is called the _ head _ and @xmath6",
    "is called the _ body _ of the clause . when @xmath7 , the `` @xmath8 '' symbol is omitted .",
    "if a logic program has no clause with negative literals in its body , it is called a _ positive logic program_.    _ a _ goal _ @xmath9 is a headless clause @xmath10 where each @xmath5 is called a _ subgoal_. a goal is also written as @xmath11 where @xmath12 is called a _",
    "query_. a _ computation rule _ ( or _ selection rule _ ) is a rule for selecting one subgoal from a goal . _",
    "let @xmath13 be a goal with @xmath14 a positive subgoal .",
    "let @xmath15 be a clause such that @xmath2 and @xmath14 are unifiable , i.e. @xmath16 where @xmath17 is an mgu ( most general unifier ) .",
    "the _ resolvent _ of @xmath18 and @xmath19 on @xmath14 is a goal @xmath20 . in this case",
    ", we say that the proof of @xmath18 is reduced to the proof of @xmath21 .",
    "the initial goal , @xmath22 , is called a _ top",
    "_ goal . without loss of generality",
    ", we shall assume throughout the paper that a top goal consists only of one atom ( i.e. @xmath23 and @xmath24 is a positive literal ) .",
    "trees are used to depict the search space of a top - down query evaluation procedure . for convenience , a node in such a tree",
    "is represented by @xmath25 where @xmath26 is the node name and @xmath18 is a goal labeling the node .",
    "assume no two nodes have the same name , so we can refer to nodes by their names .",
    "let @xmath27 be a logic program and @xmath28 a top goal .",
    "global sls - resolution is the process of constructing sls - derivations from @xmath29 via a computation rule @xmath30 .",
    "sls - derivation _ is a partial branch beginning at the root @xmath31 of an sls - tree .",
    "every leaf of an sls - tree is either a _ success _ leaf or a _ failure _ leaf or a _ flounder _ leaf or an _ undefined _ leaf .",
    "@xmath32 is a _ non - floundering query _ if no sls - tree for evaluating @xmath32 under @xmath30 contains a flounder leaf .",
    "an sls - tree is _ successful _ if it has a success leaf .",
    "it is _ failed _ if all of its branches are either infinite or end at a failure leaf .",
    "it is _ floundered _ if it contains a floundered leaf and is not successful .",
    "an sls - tree is _ undefined _ if it is neither successful nor failed nor floundered .",
    "there are two slightly different definitions of an sls - tree : przymusinski s definition @xcite and ross definition @xcite .",
    "przymusinski s definition requires a level mapping ( called _ strata _ ) to be associated with literals and goals , while ross definition requires the computation rule to be _ preferential _ ,",
    "i.e. positive subgoals are selected ahead of negative ones and negative subgoals are selected in parallel .",
    "both of the two definitions allow infinite branches and infinite recursion through negation .",
    "the following definition of an sls - tree is obtained by combining the two definitions .",
    "[ sls - tree ]    _ let @xmath27 be a logic program , @xmath33 a top goal , and @xmath30 a computation rule .",
    "sls - tree _",
    "@xmath34 for @xmath35 via @xmath30 is a tree rooted at @xmath31 such that for any node @xmath25 in the tree with @xmath36 : _    1 .",
    "if @xmath7 then @xmath26 is a _ success _ leaf , marked by @xmath37 .",
    "[ l1 ] if @xmath14 is a positive literal selected by @xmath30 , then for each clause @xmath19 in @xmath27 whose head is unifiable with @xmath14 , @xmath26 has a child @xmath38 where @xmath21 is the resolvent of @xmath19 and @xmath18 on @xmath14 .",
    "if no such a clause exists in @xmath27 , then @xmath26 is a _ failure _ leaf , marked by @xmath39 .",
    "[ l2 ] let @xmath40 be a negative literal selected by @xmath30 .",
    "if @xmath1 is not ground then @xmath26 is a _ flounder _ leaf , marked by @xmath41 , else let @xmath42 be an ( subsidiary ) sls - tree for @xmath43 via @xmath30 .",
    "we consider four cases : 1 .",
    "[ la ] if @xmath42 is failed then @xmath26 has only one child that is labeled by the goal @xmath44 .",
    "[ lb ] if @xmath42 is successful then @xmath26 is a _ failure _ leaf , marked by @xmath39 .",
    "[ lc ] if @xmath42 is floundered then @xmath26 is a _ flounder _ leaf , marked by @xmath41 .",
    "[ ld ] otherwise ( i.e. @xmath42 is undefined ) , we mark @xmath14 in @xmath18 as _ skipped _ and use the computation rule @xmath30 to select a new literal @xmath45 from @xmath18 and apply the resolution steps [ l1 ] and [ l2 ] to the goal @xmath18 .",
    "if all literals in @xmath18 were already marked as skipped then @xmath26 is an _ undefined _ leaf , marked by @xmath46 .",
    "we make two remarks .",
    "first , the level mapping / strata used in przymusinski s definition is implicit in definition [ sls - tree ] .",
    "that is , in case [ l2 ] the level / stratum of @xmath1 is less than the level / stratum of @xmath18 if and only if either case [ la ] or case [ lb ] or case [ lc ] holds .",
    "second , the preferential restriction of ross definition to the computation rule is relaxed by marking undefined subgoals as skipped and then continuing to select new subgoals from the remaining subgoals in @xmath18 for evaluation ( see case [ ld ] ) . a leaf is undefined if and only if all its subgoals are marked as skipped .",
    "_ a _ successful _",
    "_ failed _ or _ undefined _ ) derivation for a goal @xmath9 is a branch beginning at the root of the sls - tree for @xmath9 and ending at a success ( resp .",
    "failure or undefined ) leaf .",
    "correct answer substitution _ for @xmath9 is the substitution @xmath47 , where @xmath48s are the most general unifiers used at each step along the derivation , restricted to the variables in @xmath9 .",
    "_    it has been shown that global sls - resolution is sound and complete with respect to the well - founded semantics for non - floundering queries .",
    "[ sound - comp ] let @xmath27 be a logic program , @xmath30 a computation rule , and @xmath49 be a top goal with @xmath32 a non - floundering query under @xmath30 . let @xmath50 be the well - founded model of @xmath27 .    1 .",
    "@xmath51 if and only if the sls - tree for @xmath35 via @xmath30 is successful .",
    "2 .   @xmath52 if and only if there exists a correct answer substitution for @xmath33 more general than the substitution @xmath17 .",
    "3 .   @xmath53 if and only if the sls - tree for @xmath35 is failed .",
    "_ let @xmath25 be a node in an sls - tree @xmath54 where @xmath1 is the selected positive subgoal in @xmath18 .",
    "the partial branches of @xmath54 beginning at @xmath26 that are used to evaluate @xmath1 constitute _ sub - derivations _ for @xmath1 .",
    "all such sub - derivations form a _ sub - sls - tree _ for @xmath1 at @xmath26 . _    by theorem [ sound - comp ] , for any correct answer substitution @xmath17 built from a successful sub - derivation for @xmath1 , @xmath55 .",
    "since global sls - resolution allows infinite derivations as well as infinite recursion through negation , we may need infinite time to generate an sls - tree .",
    "this is not feasible in practice . in the next section ,",
    "we resolve this problem by enhancing global sls - resolution with both loop cutting and tabling mechanisms .",
    "we first define an ancestor - descendant relation on selected subgoals in an sls - tree .",
    "informally , @xmath1 is an _ ancestor subgoal _ of @xmath56 if the proof of @xmath1 depends on ( or in other words goes via ) the proof of @xmath56 .",
    "for example , let @xmath57 be a node in an sls - tree , and @xmath58 be a child node of @xmath59 that is generated by resolving @xmath59 on the subgoal @xmath1 with a clause @xmath60 where @xmath61 .",
    "then @xmath1 at @xmath59 is an ancestor subgoal of all @xmath62s at @xmath63 .",
    "however , such relationship does not exist between @xmath1 at @xmath59 and any @xmath64 at @xmath63 .",
    "it is easily seen that all @xmath62s at @xmath63 inherit the ancestor subgoals of @xmath1 at @xmath59 , and that each @xmath64 at @xmath63 inherits the ancestor subgoals of @xmath65 at @xmath59 .",
    "note that subgoals at the root of an sls - tree have no ancestor subgoals .",
    "let @xmath25 and @xmath38 be two nodes and @xmath1 and @xmath56 be the selected subgoals in @xmath18 and @xmath21 , respectively .",
    "when @xmath1 is an ancestor subgoal of @xmath56 , we refer to @xmath56 as a _ descendant subgoal _ of @xmath1 , @xmath26 as an _ ancestor node _ of @xmath66 , and @xmath66 as a _ descendant node _ of @xmath26 .",
    "particularly , if @xmath1 is both an ancestor subgoal and a variant , i.e. an _ ancestor variant subgoal _ , of @xmath56 , we say the derivation goes into a _ loop _",
    ", where @xmath26 and @xmath66 are respectively called an _ ancestor loop node _ and a _ descendant loop node _ , and @xmath1 ( at @xmath26 ) and @xmath56 ( at @xmath66 ) are respectively called an _ ancestor loop subgoal _ and a _ descendant loop subgoal_.    the above ancestor - descendant relation is defined over subgoals and will be applied to detect positive loops , i.e. loops within an sls - tree . in order to handle negative loops ( i.e. loops through negation like @xmath67 and @xmath68 ) which occur across sls - trees , we define an ancestor - descendant relation on sls - trees .",
    "let @xmath69 be a node in @xmath54 , with @xmath70 the selected subgoal , and let @xmath42 be an ( subsidiary ) sls - tree for @xmath43 via @xmath30 .",
    "@xmath54 is called an _",
    "ancestor sls - tree _ of @xmath42 , while @xmath42 is called a _",
    "descendant sls - tree _ of @xmath54 .",
    "of course , the ancestor - descendant relation is transitive .",
    "a negative loop occurs if an sls - tree has a descendant sls - tree , with the same goal at their roots .",
    "for convenience , we use dotted edges to connect parent and child sls - trees , so that negative loops can be clearly identified .",
    "let @xmath33 be a top goal .",
    "we call @xmath34 together with all of its descendant sls - trees a _ generalized sls - tree _ , denoted @xmath71 ( or simply @xmath72 when no confusion would arise ) . therefore , a branch of a generalized sls - tree may come across several sls - trees through dotted edges .",
    "generalized sls - derivation _ is a partial branch beginning at the root of a generalized sls - tree .",
    "assume that all loops are detected and cut based on the ancestor - descendant relations .",
    "this helps global sls - resolution get rid of infinite derivations and infinite recursion through negation .",
    "however , applying such loop cutting mechanism alone is not effective since some answers would be lost . in order to guarantee the completeness of global sls - resolution with the loop cutting mechanism",
    ", we introduce a tabling mechanism into sls - derivations , leading to a tabulated sls - resolution .    in tabulated resolutions ,",
    "the set of predicate symbols in a logic program is partitioned into two groups : _ tabled predicate symbols _ and _ non - tabled predicate symbols_. subgoals with tabled predicate symbols are then called _ tabled subgoals_. a _ dependency graph _",
    "@xcite is used to make such classification .",
    "informally , for any predicate symbols @xmath73 and @xmath74 , there is an edge @xmath75 in the dependency graph @xmath76 of a logic program @xmath27 if and only if @xmath27 contains a clause whose head contains @xmath73 and whose body contains @xmath74 .",
    "@xmath73 is a tabled predicate symbol if @xmath76 contains a cycle involving @xmath73 .",
    "it is trivial to show that subgoals involved in any loops in sls - trees must be tabled subgoals .",
    "intermediate answers of tabled subgoals will be stored in tables once they are produced at some derivation stages .",
    "such answers are called _",
    "tabled answers_. for convenience of presentation , we organize a table into a compound structure like @xmath77 in pseudo @xmath78 language .",
    "that is , the table of an atom @xmath1 , denoted @xmath79 , is internally an instance of the data type table defined as follows :    @xmath80 = typ= edef struct \\ { + @xmath81= @xmath82 ; //for @xmath79 , @xmath83 .",
    "+ @xmath84 ; //status of @xmath82 indicating if all answers have been tabled .",
    "+ @xmath85 ; //tabled answers of @xmath82 .",
    "+ } table ;    answers of a tabled subgoal @xmath1 are stored in @xmath86 .",
    "we say @xmath79 is _ complete _ if @xmath86 contains all answers of @xmath1 .",
    "we use @xmath87 to mark the completeness of tabled answers . clearly , the case @xmath87 and @xmath88 indicates that @xmath1 is false .",
    "we introduce a special subgoal , @xmath89 , which is assumed to occur neither in logic programs nor in top goals .",
    "@xmath89 will be used to substitute for some ground negative subgoals whose truth values are temporarily undefined ( i.e. , whether they are true or false can not be determined at the current stage of derivation ) .",
    "we assume such a special subgoal will not be selected by a computation rule .",
    "we also use a special subgoal , @xmath90 , to mark occurrence of a loop .",
    "augmenting sls - trees with the loop cutting and tabling mechanisms leads to the following definition of sltnf - trees .",
    "here `` sltnf '' stands for `` _ l_inear _ t_abulated resolution using a _",
    "s_election / computation rule with _ n_egation as finite _ f_ailure . ''",
    "[ sltnf - tree ]    _ let @xmath27 be a logic program , @xmath33 a top goal , and @xmath30 a computation rule .",
    "let @xmath91 be a set of tables each of which contains a finite set of tabled answers .",
    "the _ sltnf - tree _",
    "@xmath34 for @xmath92 via @xmath30 is a tree rooted at @xmath31 such that for any node @xmath25 in the tree with @xmath36 : _    1 .",
    "[ l20 ] if @xmath7 then @xmath26 is a _",
    "success _ leaf , marked by @xmath37 , else if @xmath93 then @xmath26 is a _ temporarily undefined _ leaf , marked by @xmath94 , else if @xmath95 then @xmath26 is a _ loop _ leaf , marked by @xmath96 .",
    "2 .   if @xmath97 is a positive literal selected by @xmath30 , we consider two cases : 1 .",
    "if @xmath98 with @xmath99 , then for each tabled answer @xmath1 in @xmath100 , @xmath26 has a child node @xmath38 where @xmath21 is the resolvent of @xmath1 and @xmath18 on @xmath14 . in case that @xmath101 , @xmath26 is a _ failure _ leaf , marked by @xmath39 .",
    "[ l4d ] otherwise , for each tabled answer @xmath1 in @xmath100 @xmath26 has a child node @xmath38 where @xmath21 is the resolvent of @xmath1 and @xmath18 on @xmath14 , and 1 .",
    "if @xmath26 is a descendant loop node then it has a child node @xmath102 .",
    "2 .   otherwise , for each clause @xmath19 in @xmath27 whose head is unifiable with @xmath14 @xmath26 has a child node @xmath103 where @xmath104 is the resolvent of @xmath19 and @xmath18 on @xmath14 .",
    "if there are neither tabled answers nor clauses applicable to @xmath26 then @xmath26 is a _ failure _ leaf , marked by @xmath39 .",
    "3 .   let @xmath40 be a negative literal selected by @xmath30 .",
    "if @xmath1 is not ground then @xmath26 is a _ flounder _ leaf , marked by @xmath41 , else we consider the following cases : 1 .",
    "if @xmath105 with @xmath106 and @xmath107 , then @xmath26 has only one child node @xmath38 with @xmath108 .",
    "2 .   if @xmath105 with @xmath106 and @xmath109",
    ", then @xmath26 is a _ failure _ leaf , marked by @xmath39 .",
    "[ l5c ] otherwise , if the current sltnf - tree or one of its ancestor sltnf - trees is with a goal @xmath110 at the root , @xmath26 has only one child node @xmath38 where if @xmath111 then @xmath112 @xmath113 else @xmath114 .",
    "[ l5d ] otherwise , let @xmath115 be an ( subsidiary ) sltnf - tree for @xmath116 via @xmath30 .",
    "we have the following cases : 1 .   [ l5d1 ]",
    "if @xmath115 has a success leaf then @xmath26 is a _ failure _ leaf , marked by @xmath39 .",
    "if @xmath115 has no success leaf but a flounder leaf then @xmath26 is a _ flounder _ leaf , marked by @xmath41 .",
    "[ l5d3 - 1 ] ( _ negation as finite failure _ ) if all branches of @xmath115 end at either a failure or a loop leaf where for each loop leaf generated from a descendant loop subgoal @xmath117 , no successful sub - derivation for its ancestor loop subgoal has a correct answer substitution @xmath17 such that @xmath118 is not in @xmath91 , then @xmath26 has only one child node @xmath38 with @xmath108 .",
    "[ l5d4 ] otherwise , @xmath26 has only one child node @xmath38 where if @xmath111 @xmath112 @xmath113 else @xmath114 .",
    "note that some commonly used concepts , such as derivations ( for goals ) , sub - derivations ( for subgoals ) , sub - trees ( for subgoals ) , generalized trees , and correct answer substitutions , have the same meanings as in sls - trees ( see section [ sec2 ] ) .",
    "positive loops are broken simply by disallowing descendant loop nodes to apply clauses in @xmath27 for expansion ( see case [ l4d ] ) , while negative loops are broken by substituting @xmath89 for looping negative subgoals ( see case [ l5c ] ) .",
    "this guarantees that sltnf - trees are finite for logic programs with the bounded - term - size property ( see definition [ bounded - term - size ] and theorem [ tree - finite ] ) .",
    "note that @xmath89 is only introduced to signify existence of subgoals whose truth values are temporarily non - determined because of occurrence of positive or negative loops .",
    "so keeping only one @xmath89 in a goal is enough for such a purpose . from case [ l20 ] of definition [ sltnf - tree ]",
    "we see that goals with @xmath89 can not lead to a success leaf .",
    "however , @xmath89 may well appear in a failure leaf since one of the other subgoals may fail regardless of what truth values the temporarily undefined subgoals would take .",
    "this achieves the effect of what a preferential computation rule @xcite is supposed to achieve , although our computation rule is not necessarily preferential .",
    "observe that sltnf - trees implement an _ negation as finite failure _ ( naf ) rule ( see case [ l5d3 - 1 ] ) : a ground subgoal @xmath70 fails if @xmath1 succeeds , and succeeds if @xmath1 finitely fails after exhausting all answers of the loop subgoals involved in evaluating @xmath1 .",
    "this naf rule is the same as that used in sldnf - resolution @xcite except that loop leaves are considered .",
    "the following example illustrates the process of constructing sltnf - trees .",
    "[ eg3 - 2 ]    _ consider the following program and let @xmath119 be the top goal .",
    "_    @xmath120 : = @xmath121 ` @xmath122 + @xmath123 ` @xmath124 + @xmath125 ` @xmath126 + @xmath127 ` @xmath128 + @xmath129 ` @xmath130 + @xmath131 ` @xmath132    let @xmath133 , and for convenience , let us choose the widely - used left - most computation rule ( i.e. we always select the left - most subgoal from a goal ) .",
    "the generalized sltnf - tree @xmath134 for @xmath135 is shown in figure [ fig2 ] , '' symbol in goals . ] which consists of three finite sltnf - trees that are rooted at @xmath136 , @xmath137 and @xmath138 , respectively .",
    "note that two positive loops are cut at @xmath139 and @xmath140 , respectively , and one negative loop is cut at @xmath141 .",
    "@xmath142 has only one branch , which ends at a loop leaf @xmath143 .",
    "there is no successful sub - derivation for the ancestor loop subgoal @xmath144 at @xmath137 , so the naf rule is applicable .",
    "thus , @xmath145 at @xmath146 succeeds , leading to a successful sub - derivation for @xmath147 at @xmath136 with a correct answer substitution @xmath148 .",
    "[ bounded - term - size ] _ a logic program has the _ bounded - term - size _ property if there is a function @xmath149 such that whenever a top goal @xmath33 has no argument whose term size exceeds @xmath150 , then no subgoals and tabled answers in any generalized sltnf - tree @xmath72 have an argument whose term size exceeds @xmath149 .",
    "_    the following result shows that the construction of sltnf - trees is always terminating for logic programs with the bounded - term - size property .",
    "[ tree - finite ] let @xmath27 be a logic program with the bounded - term - size property , @xmath33 a top goal and @xmath30 a computation rule .",
    "the generalized sltnf - tree @xmath72 for @xmath92 via @xmath30 is finite .",
    "* proof : * first note that @xmath72 contains no negative loops ( see case [ l5c ] ) .",
    "the bounded - term - size property guarantees that no term occurring on any path of @xmath72 can have size greater than @xmath149 , where @xmath150 is a bound on the size of terms in the top goal @xmath33 .",
    "assume , on the contrary , that @xmath72 is infinite .",
    "since the branching factor of @xmath72 ( i.e. the average number of children of all nodes in the tree ) is bounded by the finite number of clauses in @xmath27 , @xmath72 either contains an infinite number of sltnf - trees or has an infinite derivation within some sltnf - tree .",
    "note that @xmath27 has only a finite number of predicate , function and constant symbols .",
    "if @xmath72 contains an infinite number of sltnf - trees , there must exist negative loops in @xmath72 , a contradiction .",
    "if @xmath72 has an infinite derivation within some sltnf - tree , some positive subgoal @xmath151 selected by @xmath30 must have infinitely many variant descendants @xmath152 on the path such that the proof of @xmath151 needs the proof of @xmath153 that needs the proof of @xmath154 , and so on .",
    "that is , @xmath155 is an ancestor loop subgoal of @xmath65 for any @xmath156 .",
    "this contradicts the fact that any descendant loop subgoal in @xmath72 has only one ancestor loop subgoal because a descendant loop subgoal can not generate descendant loop subgoals since no clauses will be applied to it for expansion ( see case [ l4d ] of definition [ sltnf - tree ] ) .",
    "@xmath157    consider figure [ fig2 ] again .",
    "observe that if we continued expanding @xmath139 ( like global sls - resolution ) by applying @xmath122 and @xmath124 , we would generate another correct answer substitution @xmath158 for @xmath33 .",
    "this indicates that applying loop cutting alone would result in incompleteness .",
    "we use _ answer iteration _ @xcite to derive all answers of loop subgoals .",
    "here is the basic idea : we first build a generalized sltnf - tree for @xmath159 with @xmath160 while collecting all new tabled answers ( for all tabled subgoals ) into @xmath161 .",
    "then we build a new generalized sltnf - tree for @xmath162 with @xmath163 while collecting all new tabled answers into @xmath164 .",
    "such an iterative process continues until no new tabled answers are available .",
    "the key issue with answer iteration is _ answer completion _ , i.e , how to determine if the table of a subgoal is complete at some derivation stages .",
    "careful reader may have noticed that we have already used a completion criterion for ground subgoals in defining the naf rule ( see case [ l5d ] of definition [ sltnf - tree ] ) .",
    "we now generalize this criterion to all subgoals .",
    "[ comp - thm ] let @xmath72 be the generalized sltnf - tree for @xmath165 and @xmath166 contain all new tabled answers in @xmath72 .",
    "the following completion criteria hold .    1 .   for a ground tabled positive subgoal @xmath1 , @xmath167 is complete for @xmath1 if @xmath168 .",
    "2 .   for any tabled positive subgoal @xmath1 , @xmath167 is complete for @xmath1 if there is a node @xmath25 in @xmath72 , where @xmath1 is the selected subgoal in @xmath18 and let @xmath169 be the sub - sltnf - tree for @xmath1 at @xmath26 , such that ( 1 ) @xmath169 has no temporarily undefined leaf , and ( 2 ) for each loop leaf in @xmath169 , the sub - sltnf - tree for its ancestor loop subgoal @xmath117 has neither temporarily undefined leaf nor success leaf with a correct answer substitution @xmath17 such that @xmath118 is not in @xmath91 .",
    "* proof : * the first criterion is straightforward since @xmath1 is ground .",
    "we now prove the second .",
    "note that there are only two cases in which a tabled subgoal @xmath1 may get new answers via iteration .",
    "the first is due to that some temporarily undefined subgoals in the current round would become successful or failed in the future rounds of iteration .",
    "this case is excluded by conditions ( 1 ) and ( 2 ) .",
    "the second case is due to that some loop subgoals in @xmath169 in the current round would produce new answers in the future rounds of iteration .",
    "such new answers are generated in an iterative way , i.e. , in the current round descendant loop subgoals in @xmath169 consume only existing tabled answers in @xmath91 and help generate new answers ( which are not in @xmath91 ) for their ancestor loop subgoals .",
    "these new answers are then tabled ( in @xmath166 ) for the descendant loop subgoals to consume in the next round . in this case",
    ", @xmath169 must contain at least one descendant loop subgoal @xmath170 such that the sub - sltnf - tree for its ancestor loop subgoal @xmath117 has a success leaf with a new correct answer substitution not included in @xmath91 ( this new answer is not consumed by @xmath170 in the current round but will be consumed in the next round ) .",
    "obviously , this case is excluded by condition ( 2 ) . as a result ,",
    "conditions ( 1 ) and ( 2 ) together imply that further iteration would generate no new answers for @xmath1 . therefore , @xmath79 is complete for @xmath1 after merging @xmath91 with the new tabled answers @xmath166 in @xmath72 .",
    "@xmath157    [ eg3 ] _ consider figure [ fig2 ]",
    ". we can not apply theorem [ comp - thm ] to determine the completeness of @xmath171 since the ancestor loop subgoal @xmath147 at @xmath136 has a successful sub - derivation with an answer @xmath172 not in @xmath173 . as we can see , applying this new answer to the descendant loop subgoal at @xmath139 would generate another new answer @xmath174 .",
    "the completeness of @xmath175 is not determinable either , since both the two sub - sltnf - trees for @xmath176 ( rooted at @xmath177 and @xmath138 , respectively ) contain a temporarily undefined leaf .",
    "however , by theorem [ comp - thm ] , @xmath178 is complete . _    [ sltnf ]",
    "_ let @xmath27 be a logic program , @xmath179 a top goal with @xmath1 an atom , and @xmath30 a computation rule .",
    "let @xmath160 .",
    "_ sltnf - resolution _ evaluates @xmath33 by calling the function @xmath180 , defined as follows . _",
    "* function * @xmath181 * returns * a table @xmath79 + @xmath182 + @xmath80 = build = a generalized sltnf - tree @xmath183 for @xmath184 while collecting + all new tabled answers into @xmath185 ; + @xmath186 ; + check completeness of all tables in @xmath187 and update their status ; + @xmath188 or @xmath189 * then return * @xmath79 ; + @xmath190 ; + @xmath191    _ first execute @xmath192 where @xmath193 , @xmath194 and @xmath30 is the left - most computation rule .",
    "the procedure builds a generalized sltnf - tree for @xmath135 as shown in figure [ fig2 ] .",
    "it also collects the following new tabled answer into @xmath161 : @xmath195 for @xmath171 .",
    "moreover , it has @xmath178 completed by setting @xmath196 to 1 ( note that @xmath197 ) . _",
    "next execute @xmath198 where @xmath199 .",
    "it builds a generalized sltnf - tree @xmath200 for @xmath201 as shown in figure [ fig3 ] , and collects the following new tabled answer into @xmath164 : @xmath174 for @xmath171 .",
    "finally execute @xmath202 where @xmath203 .",
    "the procedure builds a generalized sltnf - tree @xmath204 for @xmath205 in which no new tabled answer is produced .",
    "therefore , it returns with two tabled answers , @xmath172 and @xmath206 , to the top goal @xmath33 .    [",
    "sltnf - term ] let @xmath27 be a logic program with the bounded - term - size property , @xmath33 a top goal and @xmath30 a computation rule .",
    "@xmath207 terminates in finite time .",
    "* proof : * let @xmath150 be the maximum size of arguments in any top goal . since @xmath27 has the bounded - term - size property , neither subgoals nor tabled answers have arguments whose size exceeds @xmath149 for some function @xmath208 .",
    "let @xmath209 . since @xmath27 has a finite number of predicate symbols , the number of distinct subgoals ( up to variable renaming ) occurring in all @xmath183s is bounded by a finite number @xmath210 .",
    "therefore , sltnf - resolution performs at most @xmath210 iterations ( i.e. generates at most @xmath210 generalized sltnf - trees ) . by theorem [ tree - finite ] , each iteration terminates in finite time , hence sltnf - resolution terminates in finite time .",
    "@xmath157    [ sls - sltnf ]",
    "let @xmath27 be a logic program with the bounded - term - size property , @xmath1 an atom , and @xmath211 a top goal with @xmath1 a non - floundering query .",
    "let @xmath79 be the tabled answers returned from @xmath207 , and let @xmath34 be the sls - tree for @xmath29 via @xmath30 .    1 .",
    "@xmath212 is in @xmath79 if and only if there is a correct answer substitution @xmath17 for @xmath33 in @xmath34 .",
    "2 .   @xmath87 and @xmath88 if and only if @xmath34 is failed .",
    "* proof : * we first prove that sls - trees with negative loops can be transformed into equivalent sls - trees without negative loops .",
    "let @xmath213 be an sls - tree with a descendant sls - tree @xmath214 .",
    "obviously , this is a negative loop .",
    "observe that @xmath56 at @xmath26 being successful or failed must be independent of the loop sls - tree @xmath214 , for otherwise the truth value of @xmath56 would depend on @xmath215 so that @xmath56 is undefined .",
    "this strongly suggests that using a temporarily undefined value @xmath89 as the truth value of @xmath214 does not change the answer of @xmath56 at @xmath26 . in other words ,",
    "any sls - trees with negative loops can be transformed into equivalent sls - trees where all descendant loop sls - trees are assumed to return a temporarily undefined value @xmath89 .",
    "let @xmath216 and @xmath183 be respectively the sltnf - tree and the generalized sltnf - tree for @xmath217 , where @xmath160 and for each @xmath218 , @xmath219 where @xmath185 contains all new tabled answers collected from @xmath183 .",
    "we prove this theorem by showing that answers over sls - derivations can be extracted in an iterative way and such iterations are the same as those of sltnf - resolution .",
    "therefore , both resolutions extract the same set of answers to @xmath33 .",
    "we distinguish between three cases :    1 .   for any answer @xmath212 that is generated without going through any loops",
    ", we must have the same successful derivations for @xmath1 in @xmath220 as in @xmath34 .",
    "[ pr-2 ] let us consider answers to @xmath33 that are generated without going through any negative loops . without loss of generality , assume the sls - derivations for the answers involve positive loops as shown in figure [ fig4 ] , where for any @xmath221 , @xmath222 is an ancestor loop subgoal of @xmath223 and each @xmath224 together with the branch leading to @xmath225 is a sub - sls - tree for @xmath222 at @xmath226 .",
    "obviously , all @xmath224s are identical up to variable renaming and thus they have the same set @xmath227 of correct answer substitutions for @xmath222 ( up to variable renaming ) .",
    "+ observe that besides @xmath227 , the other possible correct answer substitutions for @xmath222 must be generated via the infinite loops in an iterative way : for any @xmath228 , the correct answer substitutions for @xmath229 at @xmath230 combined with @xmath231 , when restricted to the variables in @xmath232 , are also correct answer substitutions for @xmath232 at @xmath233 .",
    "these substitutions are obtained by applying each correct answer substitution @xmath234 for @xmath235 to @xmath236 and then evaluating @xmath237 .",
    "since @xmath27 has the bounded - term - size property , no correct answer substitution requires performing an infinite number of such iterations .",
    "that is , there must exist a depth bound @xmath238 such that any correct answer substitution @xmath17 for @xmath239 is in the following closure ( fixpoint ) : * the initial set of correct answer substitutions is @xmath240 .",
    "* for each @xmath241 , the set of correct answer substitutions for @xmath232 at @xmath233 is @xmath242 and @xmath243 where @xmath244 is a correct answer substitution for @xmath245 .",
    "+ apparently , sltnf - resolution performs the same iterations by making use of the loop cutting and tabling mechanisms : in the beginning , @xmath246 is empty .",
    "the loop is cut at @xmath247 , so @xmath248 after @xmath220 is generated ( note @xmath239 and @xmath222 ( resp . ,",
    "@xmath249 and @xmath224 ) are variants ) .",
    "then for the @xmath250-th iteration @xmath251 @xmath246 obtains new answers by applying the already tabled answers to @xmath252 at @xmath247 in @xmath253 ; i.e. , @xmath254 . as a result ,",
    "sls - resolution and sltnf - resolution derive the same set of correct answer substitutions for all subgoals involving no negative loops .",
    "let us now consider answers to @xmath33 that are generated involving negative loops .",
    "as we discussed earlier , loop descendant sls - trees @xmath213 can be removed by assuming they return a temporarily undefined value @xmath89 .",
    "then we get equivalent sls - trees without any negative loops . by point [ pr-2 ]",
    "above , we can exhaust all answers to @xmath33 from these ( negative loop free ) sls - trees in an iterative way , as sltnf - resolution does .",
    "if no single answer to @xmath1 in @xmath33 is generated after the iteration , we have two cases .",
    "the first is that no sls - derivation for @xmath1 at @xmath136 ends at a leaf with @xmath89 .",
    "this means that the truth value of @xmath1 does not depend on any negative loop subgoal , so @xmath34 is failed and thus @xmath87 and @xmath88 .",
    "the second case is that some sls - derivation for @xmath1 at @xmath136 ends at a leaf with @xmath89 .",
    "this means that the truth value of @xmath1 recursively depends on some negative loop subgoal , so @xmath1 is undefined . in this case ,",
    "sltnf - resolution stops with @xmath255 and @xmath88 .",
    "@xmath157    since global sls - resolution is sound and complete w.r.t . the well - founded semantics ( see theorem [ sound - comp ] ) , we have the following immediate corollary .",
    "let @xmath27 be a logic program , @xmath30 a computation rule , and @xmath49 be a top goal with @xmath32 a non - floundering query under @xmath30 .",
    "sltnf - resolution is sound and complete w.r.t .",
    "the well - founded semantics .",
    "existing procedural semantics for the well - founded model can be divided into two groups in terms of the way they make derivations : ( 1 ) _ bottom - up _ approaches , such as the alternating fixpoint approach @xcite , the magic sets approach @xcite and the transformation - based bottom - up approach @xcite , and ( 2 ) _ top - down _ approaches . our method belongs to the second group .",
    "existing top - down methods can be further divided into two groups : ( 1 ) non - tabling methods , such as global sls - resolution , and ( 2 ) tabling methods .",
    "our method is one with tabling .",
    "several tabling methods for positive logic programs have been proposed , such as oldt - resolution @xcite , tp - resolution @xcite and the dra tabling mechanism @xcite . however , to the best of our knowledge , only slg - resolution and slt - resolution use tabling to compute the well - founded semantics for general logic programs .",
    "slg - resolution is the state - of - the - art tabling mechanism .",
    "it is based on program transformations , instead of on standard tree - based formulations like sldnf- or global sls - resolution .",
    "starting from the predicates of the top goal , it transforms ( instantiates ) a set of clauses , called a _ system _ , into another system based on six basic transformation rules .",
    "such a system corresponds to a forest of trees with each tree rooted at a tabled subgoal . a special class of literals , called _ delaying literals _",
    ", is used to represent and handle temporarily undefined negative literals .",
    "negative loops are identified by maintaining an additional _ dependency graph _ of subgoals @xcite .",
    "in contrast , sltnf - resolution generates an sltnf - tree for the top goal in which the flow of the query evaluation is naturally depicted by the ordered expansions of tree nodes .",
    "such a tree - style formulation is quite easy for users to understand and keep track of the computation .",
    "it can also be implemented efficiently using a simple stack - based memory structure .",
    "the disadvantage of sltnf - resolution is that it is a little more costly in time than slg - resolution due to the use of answer iteration in exchange for the linearity of derivations .",
    "slt - resolution is a tabling mechanism with the linearity property . like sltnf - resolution",
    ", it expands tree nodes by first applying tabled answers and then applying clauses .",
    "it also uses answer iteration to derive missing answers caused by loop cuttings .",
    "however , it is different from sltnf - resolution both in loop handling and in answer completion ( note that loop handling and answer completion are two key components of a tabling system ) .",
    "recall that slt - resolution defines positive and negative loops based on the same ancestor - descendant relation : let @xmath1 be a selected positive subgoal and @xmath56 be a subgoal produced by applying a clause to @xmath1 , then @xmath56 is a descendant subgoal of @xmath1 and inherits all ancester subgoals of @xmath1 ; let @xmath70 be a selected ground subgoal with @xmath115 being its subsidiary slt - tree , then the subgoal @xmath1 at @xmath256 inherits all ancester subgoals of @xmath70 .",
    "a ( positive or negative ) loop occurs when a selected subgoal has an ancestor loop subgoal .",
    "observe that the ancestor and descendant subgoals may be in different slt - trees .",
    "when a positive loop occurs , sltnf - resolution will apply no clauses to the descendant loop subgoal for node expansion , which guarantees that any ancestor loop subgoal has just one descendant loop subgoal .",
    "however , slt - resolution will continue expanding the descendant loop subgoal by applying those clauses that have not yet been applied by any of its ancestor loop subgoals . as an illustration , in figure [ fig2 ]",
    ", slt - resolution will apply @xmath124 to expand @xmath139 , leading to a child node @xmath257 with a goal @xmath258 .",
    "observe that if the subgoal @xmath259 at @xmath257 were @xmath260 , another loop would occur between @xmath136 and @xmath257 .",
    "this suggests that in slt - resolution , an ancestor loop subgoal may have several descendant loop subgoals . due to this , slt - resolution is more complicated and costly than sltnf - resolution in handling positive loops .",
    "slt - resolution is also more costly than sltnf - resolution in handling negative loops .",
    "it checks negative loops in the same way as positive loops by comparing a selected subgoal with all of its ancester subgoals across all of its ancestor slt - trees .",
    "however , in sltnf - resolution a negative loop is checked simply by comparing a selected ground negative subgoal with the root goals of its ancestor sltnf - trees .",
    "recall that a negative loop occurs if a negative ground subgoal @xmath70 is selected such that the root of the current sltnf - tree or one of its ancestor sltnf - trees is with a goal @xmath110 .",
    "slt - resolution provides no mechanism for answer completion except that when a generalized slt - tree @xmath183 is generated which contains no new tabled answers , it evaluates each negative ground subgoal @xmath70 in @xmath183 in a way such that ( 1 ) @xmath70 fails if @xmath1 is a tabled answer , and ( 2 ) @xmath70 succeeds if ( i ) all branches of its subsidiary slt - tree @xmath115 end with a failure leaf and ( ii ) for each loop subgoal in @xmath115 , all branches of the sub - slt - trees for its ancestor loop subgoals end with a failure leaf . not only",
    "is this process complicated , it is also quite inefficient since the evaluation of @xmath70 may involve several ancestor slt - trees .",
    "in contrast , sltnf - resolution provides two criteria for completing answers of both negative and positive subgoals . on the one hand ,",
    "the criteria are applied during the construction of generalized slt - trees so that redundant derivations can be pruned as early as possible . on the other hand ,",
    "checking the completion of a subgoal involves only one sltnf - tree .",
    "global sls - resolution and slg - resolution represent two typical styles in top - down computing the well - founded semantics ; the former emphasizes the linearity of derivations as sldnf - resolution does while the latter focuses on making full use of tabling to resolve loops and redundant computations .",
    "sltnf - resolution obtains the advantages of the two methods by enhancing global sls - resolution with loop cutting and tabling mechanisms .",
    "it seems that the existing linear tabling mechanism slt - resolution has similar advantages , but sltnf - resolution is simpler and more efficient due to its distinct mechanisms for loop handling and answer completion .    due to its sldnf - tree like structure , sltnf - resolution",
    "can be implemented over a prolog abstract machine such as wam @xcite or atoam @xcite .",
    "in particular , it can be implemented over existing linear tabling systems for positive logic programs such as @xcite , simply by adding two more mechanisms , one for identifying negative loops and the other for checking answer completion of tabled subgoals .",
    "we are currently working on the implementation .",
    "experimental analysis of sltnf - resolution will then be reported in the near future .",
    "we thank the anonymous referees for their helpful comments .",
    "yi - dong shen is supported in part by chinese national natural science foundation and trans - century training programme foundation for the talents by the chinese ministry of education .",
    "s. brass , j. dix , i. niemelae and t. przymusinski , on the equivalence of the static and disjunctive well - founded semantics and their computation , _ theoretical computer science _",
    "258(1 - 2):523 - 553 ( 2001 ) .",
    "h. f. guo and g. gupta , a simple scheme for implementing tabled logic programming systems based on dynamic reordering of alternatives , in : ( p. codognet , ed . ) _ lecture notes in computer science _ 2237 , 2001 , pp . 181 - 196 .",
    "n. f. zhou , y. d. shen and t. sato , semi - naive evaluation in linear tabling , in : _ the sixth acm - sigplan international conference on principles and practice of declarative programming _ ,",
    "verona , italy , 2004 ."
  ],
  "abstract_text": [
    "<S> global sls - resolution is a well - known procedural semantics for top - down computation of queries under the well - founded model . </S>",
    "<S> it inherits from sldnf - resolution the _ linearity _ property of derivations , which makes it easy and efficient to implement using a simple stack - based memory structure . </S>",
    "<S> however , like sldnf - resolution it suffers from the problem of infinite loops and redundant computations . to resolve this problem , </S>",
    "<S> in this paper we develop a new procedural semantics , called _ sltnf - resolution _ , by enhancing global sls - resolution with loop cutting and tabling mechanisms . </S>",
    "<S> sltnf - resolution is sound and complete w.r.t . </S>",
    "<S> the well - founded semantics for logic programs with the bounded - term - size property , and is superior to existing linear tabling procedural semantics such as slt - resolution . </S>",
    "<S> + _ keywords : _ logic programming , the well - founded semantics , global sls - resolution , loop cutting , tabling . </S>"
  ]
}