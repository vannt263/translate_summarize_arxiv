{
  "article_text": [
    "this work was inspired mainly by the recent papers on the computational complexity of video games by foriek  @xcite and cormode  @xcite , along with the excellent surveys on related topics by kendall et al .",
    "@xcite and demaine et al .",
    "@xcite , and may be regarded as their continuation on the same line of research .",
    "our purpose is to single out certain recurring features or mechanics in a video game that enable general reduction schemes from known hard problems to the games we are considering . to this end , in section  [ s2 ]",
    "we produce several _ metatheorems _ that will be applied in section  [ s3 ] to a wealth of famous commercial video games , in order to automatically establish their hardness with respect to certain computational complexity classes ( with a couple of exceptions ) .",
    "because most recent commercial games incorporate turing - equivalent scripting languages that easily allow the design of undecidable puzzles as part of the gameplay , we will focus primarily on older , `` scriptless '' games .",
    "our selection includes games published between 1980 and 1998 , presented in alphabetical order for better reference .",
    "not every game will be rigorously explained in all its aspects and details , but at least the game elements that are relevant to our proofs will be introduced , so that any casual player will promptly recognize them and readily understand our constructions .    it is clear that , in order to meaningfully apply the standard computational complexity tools , a suitable _ generalization _ of each game must be considered .",
    "since classic video games typically include only a finite set of levels , whose complexity is merely a constant , a way must be devised to automatically generate a class of infinitely many new levels of increasing size .",
    "deciding which game elements are `` scalable '' and which are not is ultimately a matter of taste and common sense : when designing a generalization of a well - known game , one should remain as faithful as possible to the feeling and mechanics of the original version .",
    "for example , in a typical platform game , the number of platforms and the number of hazards in a level may increase as the level size grows . in contrast , the maximum height of a jump and the enemy ai should remain unchanged , as they are more inherent aspects of the game .",
    "it is generally acknowledged that single - player games that are humanly `` interesting '' to play are complete either for * np*or for * pspace*(for an introduction to general computational complexity theoretic concepts and classes , refer to  @xcite ) .",
    "* np*-complete games feature levels whose solution demands some degree of ingenuity , but such levels are usually solved within a polynomial number of `` manipulations '' , and the challenge is merely to find them .",
    "in contrast , the additional complexity of a * pspace*-complete game seems to reside in the presence of levels whose solution requires an exponential number of manipulations , and this may be perceived as a nuisance by the player , as it makes for tediously long playing sessions .",
    "several open problems remain for further research : whenever only the hardness of a game is proved with respect to some complexity class , the obviously implied question is whether the game is also complete for that class .",
    "moreover , different variations of each game may be studied , obtained for instance by further restricting the set of game elements used in our hardness proofs .",
    "indeed , the computational complexity of a game is expected to dramatically drop if some `` critical '' elements are removed from its levels .",
    "it is interesting to study the `` complexity spectrum '' of a game , as a function of the game parameters that we set .",
    "this has been done to some extent for the game of lemmings , by different authors , as partly documented in section  [ s3 ] .",
    "a conference version of this paper has appeared at fun 2012  @xcite .",
    "more often than not , games allow the player to control an _ avatar _ , either directly or indirectly . in some circumstances",
    ", an avatar may be identified within the game only through some sort of artifice or abstraction on the game mechanics . throughout section  [ s2 ]",
    ", we will stipulate that the player s actions involve controlling an avatar , and that the elements of the game may be freely arranged in a plane lattice , or a higher dimensional space . at the very least ,",
    "the set of game elements includes _ walls _ that can not be traversed by the avatar , and can be arranged to form rooms , paths , etc .    in general",
    ", a problem instance will be a `` level '' of a given game .",
    "the description of a level includes the position of every relevant game element , such as walls , items , the avatar s starting location , etc .",
    "the question is always whether or not a given level can be `` solved '' under certain conditions , such as losing no lives , etc .",
    "the exact definition of `` solvability '' is highly game - dependent , and can range from reaching an exit location , to collecting some items , to killing some enemies , to surviving for a certain time , etc .",
    "all the _ metatheorems _ that follow yield hardness results under the assumption that certain game elements are present in a given game .",
    "these are not to be intended as `` black boxes '' , as regular _ theorems _ would be , but rather as `` frameworks '' .",
    "indeed , we will not always be able to apply the statement of a metatheorem to a particular game without keeping in mind the actual proof of the metatheorem , and the underlying construction enabling the reduction .",
    "as it turns out , in order to apply a metatheorem in a non - trivial way , we may need to use certain game elements having very complex behaviors , which serve our purposes only when arranged in some special ways . in order to make sure that our constructions work",
    "as intended , we may have to access the full proof of the metatheorem , and exploit some of its features at a `` lower level '' . to avoid all this",
    ", we would have to strengthen the metatheorems statements by adding so many details about the actual reduction constructions that most of their appeal would be lost . here",
    "we opt for shorter metatheorem statements , but as a drawback we will have to refer to their proofs from time to time , when invoking them .",
    "a game is said to exhibit the _ location traversal _",
    "feature if the level designer can somehow force the player s avatar to visit several specific game locations , arbitrarily connected together , in order to beat the level .",
    "although every location must be visited at least once , the avatar may visit them multiple times and in any order .",
    "however , the first location is usually fixed ( starting location ) , and sometimes also the last one is ( exit location ) .",
    "an example of location traversal is the _ collecting items _ feature discussed in  @xcite : a certain number of items are scattered across different locations , and the avatar s task is to collect them all .",
    "the _ single - use paths _ feature is the existence of configurations of game elements that act as paths connecting two locations , which can be traversed by the avatar at most once .",
    "a typical example are _ breakable tiles _ , which disappear as soon as the avatar walks on them .",
    "[ m1 ] any game exhibiting both location traversal ( with or without a starting location or an exit location ) and single - use paths is * np*-hard .",
    "we give a straightforward reduction from hamiltonian cycle , which is * np*-complete even for undirected 3-regular planar graphs  @xcite .",
    "construct a plane embedding of a given 3-regular graph @xmath0 ( perhaps an orthogonal embedding , if needed ) with an additional vertex @xmath1 dangling from a distinguished vertex @xmath2 .",
    "then we convert such embedding into a valid level , by implementing each vertex as a location that must be visited by the avatar , and each edge as a single - use path .",
    "the starting location is placed in @xmath2 and , if an exit location is required , it is placed in @xmath1 .    clearly , the last vertex the avatar must visit is @xmath1 , because it has only one incident edge .",
    "moreover , each vertex except @xmath2 can be visited at most once : recall that @xmath0 is 3-regular , hence reaching a given vertex @xmath3 for the first time implies the consumption of one of its incident edges .",
    "then , leaving @xmath4 consumes another incident edge , and reaching it a second time consumes the third incident edge . at this point",
    ", there is no way for the avatar to leave @xmath4 , and therefore no way to reach the last vertex @xmath1 . as for the starting",
    "vertex @xmath2 , the incident edges are initially four , and one is immediately consumed . the second time the avatar reaches @xmath2 , it must necessarily proceed to @xmath1 , for otherwise @xmath1 would become forever unreachable .",
    "it follows that the level is solvable if and only if the player can find a walk starting from @xmath2 , touching every vertex ( except @xmath1 ) exactly once , reaching @xmath2 again , and then terminating in @xmath1 .",
    "this is possible if and only if @xmath0 contains a hamiltonian cycle .",
    "it is easy to see that * np*-hardness is the best we can achieve given the hypotheses of metatheorem  [ m1 ] .",
    "there exists an * np*-complete game exhibiting location traversal and single - use paths .",
    "consider the game @xmath5 played on an undirected graph , in which some distinguished edges implement single - use paths , and some distinguished vertices must be visited by the avatar in order to win .",
    "then , by metatheorem  [ m1 ] @xmath5 is * np*-hard , while a certificate for @xmath5 is an injective sequence of distinguished vertices and distinguished edges .",
    "also notice that both assumptions of metatheorem  [ m1 ] are required : removing either of them from the above game @xmath5 reduces it to determining if two vertices in a graph are connected , which is solvable in logarithmic time ( see  @xcite ) .    as section",
    "[ s3 ] testifies , metatheorem  [ m1 ] has a wide range of applications , and it tends to yield game levels that are more `` playable '' than those resulting from the somewhat analogous  ( * ? ? ?",
    "* metatheorem  2 ) , which rely on a tight time limit to traverse a grid graph .",
    "additionally ,  ( * ? ? ?",
    "* metatheorem  2 ) is prone to design complications in `` anisotropic '' games , in which the avatar moves at different speeds in different directions , for instance due to gravity effects .",
    "we consider now another type of game mechanics : _ tokens _ and _ toll roads_. tokens are items that can be carried by the avatar , and _ toll roads _",
    "are special paths connecting two locations .",
    "whenever the avatar traverses a toll road , it must `` spend '' a token that it is carrying .",
    "if the avatar is carrying no token , then it can not traverse a toll road .",
    "we distinguish between two types of tokens : _ collectible _ tokens , which may be placed by the game designer at specific locations and can be picked up by the avatar , and _ cumulative _ tokens , any number of which can be carried around by the avatar at the same time .",
    "section  [ s3 ] will offer some examples of different types of tokens : for instance , pac - man features _ power pills _ , which may be regarded as collectible tokens that are not cumulative .",
    "[ m1b ] a game is * np*-hard if either of the following holds :",
    "1 .   the game features _",
    "collectible _ tokens , toll roads , and location traversal .",
    "the game features _ cumulative _ tokens , toll roads , and location traversal .",
    "3 .   the game features _",
    "collectible cumulative _",
    "tokens , toll roads , and the avatar has to reach an exit location .",
    "once again , we give a reduction from hamiltonian cyclefor all three parts of the metatheorem , varying it slightly depending on our hypotheses . for part  ( a ) ,",
    "given an undirected 3-regular planar graph @xmath0 , we construct an embedding as described in the proof of metatheorem  [ m1 ] , and we implement each vertex as a location that has to be traversed by the avatar . each edge",
    "is then implemented as a toll road , and one collectible token is placed in each vertex , except for the final vertex @xmath1 , where we place no token , and the starting vertex @xmath2 , where we place two tokens .",
    "notice that , if @xmath0 has @xmath6 vertices , there are exactly @xmath7 locations that the avatar must visit , and @xmath7 tokens in the level .",
    "therefore , any feasible traversal of the level starts from @xmath2 and has length at most @xmath7 .",
    "if the traversal must reach all locations , then at most one location may be visited twice . moreover ,",
    "@xmath2 must be visited at least a second time , because it is the only neighbor of @xmath1 . as a consequence , a valid traversal of the level must start from @xmath2 ,",
    "visit every other location except @xmath1 exactly once , return in @xmath2 , and end in @xmath1 .",
    "it follows that , if @xmath0 has no hamiltonian cycle , then the level is unsolvable .",
    "conversely , let us assume that @xmath0 has a hamiltonian cycle , and let us show that the level is solvable .",
    "the avatar can traverse @xmath0 , starting from @xmath2 and ending in @xmath2 again , along a hamiltonian cycle , and finally it can reach @xmath1 and solve the level .",
    "this traversal is valid even if tokens are not cumulative : upon reaching a new location , the avatar collects one new token and immediately spends it in a toll road . likewise ,",
    "when @xmath2 is reached for the second time , the second token is collected , and it is immediately spent to reach @xmath1 .",
    "the construction for part  ( b ) is the same , but instead of scattering @xmath7 tokens throughout the level ( where @xmath6 is the number of vertices of @xmath0 ) , we assume that the avatar already carries @xmath7 tokens as the game starts",
    ". then a similar reasoning applies : exactly one location may be visited twice , which must be @xmath2 because it is the starting location and the only neighbor of @xmath1 .",
    "therefore , @xmath1 must be the last location to be visited , and the level is solvable if and only if @xmath0 has a hamiltonian cycle .",
    "for part  ( c ) , we further modify the previous proof as follows : we construct the same embedding of @xmath0 , and we place two tokens in every location , except in @xmath1 , where we place no token",
    ". then we implement each edge as a toll road , except the edge between @xmath2 and @xmath1 , which is implemented as a sequence of @xmath6 toll roads .",
    "the starting location is @xmath2 again , and the exit location is @xmath1 . the avatar carries no token as the game starts .",
    "there are @xmath8 tokens in the level , and @xmath6 of them must be used to travel from @xmath2 to @xmath1 , so at most @xmath6 more tokens may be spent in other toll roads . every time a toll road is traversed ,",
    "one token is gained if a new location is reached ( one token is spent and two are found ) , and one token is lost if an already visited location is reached .",
    "it follows that the player must find a walk in @xmath0 that starts and ends in @xmath2 , traverses at most @xmath6 edges and visits @xmath6 different vertices .",
    "this is equivalent to finding a hamiltonian cycle in @xmath0 .",
    "( observe that the location traversal feature has been obtained here as a by - product of our construction , without being an explicit requirement . )    * np*-hardness is the best complexity achievable under the hypotheses of metatheorem  [ m1b ] , in each of the three cases .",
    "there exists an * np*-complete game featuring collectible cumulative tokens and toll roads , in which the avatar has to reach an exit location .",
    "consider the game played on a graph in which some distinguished edges implement toll roads , each vertex may contain some collectible cumulative tokens , and one distinguished vertex is the exit location . indeed , a certificate for this game is simply an injective sequence of toll roads , because we may assume that the avatar always collects all the tokens it can reach without traversing toll roads , and therefore no toll read ever has to be traversed twice .      a _ door _",
    "is a game element that can be open or closed , and may be traversed by the avatar if and only if it is open .",
    "key _ is a type of token that can be used by the avatar to open a closed door , upon contact .",
    "any key can open any door , but a key is `` consumed '' as soon as it is used .",
    "hence , the key - door paradigm is somewhat similar to the token - toll road one , with the difference that a door opened by a key remains open and can be traversed several times afterwards without consuming new keys .",
    "we distinguish again between _",
    "collectible _ keys , which can be found by the avatar and picked up , and _ cumulative _ keys , any number of which can be carried at the same time .",
    "many examples of keys are found in platform games and adventure games . in section  [ s3 ]",
    ", we will show how the lemmings game features cumulative keys that are not collectible , although this will be established through non - trivial abstractions on the game mechanics .    to state the next result , which is an analogous of metatheorem  [ m1b ] for the key - door paradigm , we further need to introduce the concept of _ one - way path _ , which is a path that can be traversed by the avatar in one specific direction only .",
    "[ m1c ] a game is * np*-hard if it contains doors and one - way paths , and either of the following holds :    1 .",
    "the game features _",
    "collectible _ keys and location traversal .",
    "the game features _ cumulative _ keys and location traversal .",
    "3 .   the game features _",
    "collectible cumulative _ keys and the avatar has to reach an exit location .",
    "we reduce from hamiltonian cycle , which is * np*-complete even for directed planar graphs whose vertices have one incoming edge and two outgoing edges , or two incoming edges and one outgoing edge  @xcite .",
    "all three parts of our proof are based on the same construction : given one such directed graph @xmath0 on @xmath6 vertices , we pick a vertex @xmath2 with indegree two and outdegree one ( which exists ) , and we attach to it a new outgoing edge , ending in a new vertex @xmath1 . then we construct a plane embedding of this graph ( maybe an orthogonal embedding ) , substituting each vertex with a game location , and each directed edge with a one - way path .",
    "@xmath2 will be the avatar s starting location and , if an exit location is required , it is placed in @xmath1 ( @xmath1 must be the final location anyway , because it has no outgoing edges ) .",
    "moreover , we place a closed door in each one - way path , except in the path between @xmath2 and @xmath1 .    to prove part  ( a ) , place one key in each location , except @xmath1 , and assume that the avatar must traverse every location (",
    "the last of which would be @xmath1 ) .",
    "after collecting the first key in @xmath2 , every time a new location ( except @xmath1 ) is reached , one key is used to open a door , and one new key is found . on the other hand ,",
    "as soon as an already visited location @xmath4 is reached , the only key in the avatar s possession is lost and no key is found , so afterwards the avatar is bound to traverse only paths with no door ( hence @xmath9 ) or with an already opened door . as a consequence , the level is solved if and only if @xmath10 and every location except @xmath1 has been visited , which is possible if and only if @xmath0 has a hamiltonian cycle .    for part",
    "( b ) , we put no keys in the level , but we assume that the avatar already carries @xmath6 keys as the game starts .",
    "we assumed that each location must be visited , and therefore at least two of its incident paths doors must be opened ( unless the location is @xmath1 ) . hence , @xmath6 doors must be opened in total , and all the keys must be used . on the other hand ,",
    "if all the three incident paths doors of a location are opened , and all the locations are visited , a straightforward double counting argument shows that at least @xmath7 keys have been used , which is unfeasible .",
    "therefore , the avatar must follow a hamiltonian cycle of @xmath0 starting and ending in @xmath2 , and then visit @xmath1 .    finally , for part  ( c ) , we place two keys in each location , except in @xmath1 , and we place @xmath6 doors in the path between @xmath2 and @xmath1 .",
    "no key is carried by the avatar as the game starts .",
    "hence , the avatar must visit some locations to collect keys , return to @xmath2 with at least @xmath6 keys , and reach the exit in @xmath1 .",
    "the same double counting argument used for part  ( b ) reveals that , if @xmath11 distinct locations are visited before reaching @xmath1 , then at at least @xmath12 doors must be opened .",
    "in particular , exactly @xmath12 doors are opened if and only if a cycle of @xmath0 is followed . because visiting @xmath12 distinct locations allows to collect exactly @xmath13 keys , the only way to return in @xmath2 with @xmath6 keys is to follow a cycle of length @xmath14 , i.e. , a hamiltonian cycle .",
    "there exists an * np*-complete game featuring doors , collectible cumulative keys , one - way paths , location traversal , in which the avatar has to reach an exit location .",
    "consider the game played on a graph in which some edges may implement doors or one - way paths , some distinguished vertices must be traversed by the avatar , some vertices contain collectible cumulative keys , and one vertex is the exit location .",
    "a certificate for this game is an injective sequence of distinguished vertices , vertices containing keys , and edges containg doors .",
    "indeed , all the keys contained in a vertex can be taken as soon as the vertex is reached , and any open door becomes a regular path and does not have to be opened a second time .",
    "hence the game is in * np * , and by metatheorem  [ m1c ] it is * np*-complete .",
    "there are other ways to modify a door s status , such as pushing a _ pressure plate_. a pressure plate is a floor button that is operated whenever the avatar steps on it , and its effect may be either the opening or the closure of a specific door .",
    "each pressure plate is connected to just one door , and each door may be controlled by at most two pressure plates ( one opens it , one closes it ) .",
    "of course , all our hardness results will hold in the more general scenario in which any number of doors is controlled by the same pressure plate , or any number of pressure plates control the same door .    in  ( * ? ? ?",
    "* metatheorem  3 ) , foriek shows ( with a different terminology ) that a game is * np*-hard if the avatar has to reach an exit location , and the game elements include one - way paths , doors and pressure plates ( or 1-buttons , see the next subsection ) that can open doors . in the following metatheorm",
    ", we further explore the capabilities of pressure plates .",
    "we say that a game allows _ crossovers _ if there is a way to prevent the avatar from switching between two crossing paths . some 2-dimensional games natively implement crossovers through bridges or tunnels .",
    "in some other games , crossovers can be simulated through more complicated gadgets .",
    "[ m2 ] if a game features doors and pressure plates , and the avatar has to reach an exit location in order to win , then :    1 .   even if no door can be closed by a pressure plate , and if crossovers are allowed , then the game is -hard .",
    "even if no two pressure plates control the same door , the game is * np*-hard .",
    "if each door may be controlled by two pressure plates , then the game is * pspace*-hard .    to prove part  ( a )",
    ", we give a  - reduction from monotone circuit value@xcite . or and and",
    "gates are implemented as in figures  [ f1a ] and  [ f1b ] , the starting location is connected to all true input literals , and the exit is located on the output .",
    "it is easy to check that the output of an or gate can be reached by the avatar if and only if at least one of its two input branches is .",
    "similarly , both input branches of an and gate must be reached by the avatar in order for doors @xmath15 and @xmath16 to be opened and allow access to the output .",
    "the doors @xmath17 and @xmath18 in the and gate prevent the avatar from walking from one input branch to the other through the center of the gate , in case only one input branch is reachable . clearly , the exit is eventually reachable if and only if the output of the circuit is true .    for part",
    "( b ) , observe that we can implement single - use paths as shown in figure  [ f1c ] : in order to traverse the gadget , the avatar must walk on both pressure plates , thus permanently closing both doors .",
    "since we can also enforce location traversal by blocking the exit with several closed doors , which may be opened via as many pressure plates positioned in every location , we may indeed invoke metatheorem  [ m1 ] .    finally , to prove  ( c ) , we implement a reduction framework from true quantified boolean formula , sketched in figure  [ f2 ] .",
    "a given fully quantified boolean formula @xmath19 , where @xmath20 is in 3-cnf , is translated into a row of _ quantifier gadgets _ , followed by a row of _ clause gadgets _ , connected by several paths .        traversing a quantifier gadget at any time sets the truth value of the corresponding boolean variable . on the other hand",
    ", each clause gadget can be traversed if and only if the corresponding clause of @xmath20 is satisfied by the current variable assignments .",
    "whenever traversing an existential quantifier gadget , the player can choose the truth value of the corresponding variable .",
    "on the other hand , the first time a universal quantifier gadget is traversed , the corresponding variable is set to true .    when all variables are set , the player attempts to traverse the clause gadgets .",
    "if the player succeeds , he proceeds to the `` lower parts '' of the quantifier gadgets , where he is rerouted to the last universal quantifier gadget in the sequence .",
    "the corresponding variable is then set to false , and @xmath20 is `` evaluated '' again by making the player walk through all the clause gadgets .",
    "the process continues , forcing the player to `` backtrack '' several times , setting all possible combinations of truth values for the universally quantified variables , and choosing appropriate values for the existentially quantified variables in the attempt to satisfy @xmath20 .",
    "finally , when all the necessary variable assignments have been tested and @xmath20 keeps being satisfied , i.e. , if the overall quantified boolean formula is true , the exit becomes accessible , and the player may finish the level .",
    "conversely , if the quantified boolean formula is false , there is no way for the player to operate doors in order to reach the exit .",
    "next we show how to implement all the components of our framework using just doors and pressure plates .",
    "clause gadgets are straightforwardly implemented , as shown in figure  [ f3 ] .",
    "there is a door for each literal in the clause , and the avatar may traverse the clause if and only if at least one of the doors is open .",
    "the existential quantifier gadget for variable @xmath17 is illustrated in figure  [ f4 ] .",
    "@xmath21 , @xmath22 , etc .",
    "( respectively , @xmath23 , @xmath24 , etc . )",
    "denote the positive ( respectively , negative ) occurrences of @xmath17 in the clauses of @xmath20 .",
    "( respectively , @xmath25 ) denotes the @xmath26-th occurrence of literal @xmath17 ( respectively , @xmath27 ) in @xmath20 . ]",
    "when traversing the upper part of the gadget from left to right , the player must choose one of the two paths , thus setting the truth value of @xmath17 to either true or false .",
    "this is done by appropriately opening or closing all the doors corresponding to occurrences of @xmath17 in @xmath20 .",
    "the doors labeled @xmath15 and @xmath16 prevent leakage between the two different paths of the existential quantifier gadget , enforcing mutual exclusion .    finally , the lower part of the gadget is traversed from right to left when the player backtracks , and it is simply a straight path .    a universal quantifier gadget for variable @xmath17 is shown in figure  [ f5 ] .",
    "when the avatar enters the gadget from the top left , door @xmath28 gets closed and variable @xmath17 is set to true .",
    "then the avatar must exit to the top right , because door @xmath29 can not be traversed from right to left .",
    "when backtracking the first time , the avatar enters from the bottom right and , because door @xmath28 is still closed , it must take the upper path , thus setting variable @xmath17 to false .",
    "incidentally , door @xmath28 gets opened and door @xmath15 gets closed , thus preventing leakage to the top left entrance , and forcing the avatar to exit to the top right again .    when backtracking the second time ( i.e. , when both truth values of @xmath17 have been tested ) , door @xmath28 is open and the avatar may finally exit to the bottom left . when done backtracking , the avatar will eventually enter this gadget again from the top left , setting @xmath17 to true again , etc .",
    "we note that , as a result of our constructions , each door is operated by exactly two pressure plates .",
    "for instance , the door labeled @xmath21 , located in some clause gadget , is opened and closed by exactly two pressure plates , both located in the quantifier gadget corresponding to variable @xmath17 .",
    "observe that our metatheorem  [ m2].c is an improvement on  ( * ? ? ?",
    "* metatheorem  4 ) , in that the _ long fall _ feature ( and thus the concept of gravity ) is not used , and it works with a more restrictive model of doors : in  @xcite , arbitrarily many pressure plates can act on the same door , while we allow just two .    as with previous metatheorems",
    ", we can prove that metatheorem  [ m2 ] s statement is the best possible given its hypotheses .",
    "[ cor2 ] there exist games @xmath30 , @xmath31 , @xmath32 , featuring doors and pressure plates , in which the avatar has to reach an exit location , such that :    1 .   in @xmath30 ,",
    "pressure plates can only open doors , crossovers are allowed , and @xmath30 is -complete .",
    "2 .   in @xmath31 ,",
    "no two pressure plates control the same door , and @xmath31 is * np*-complete .",
    "3 .   in @xmath32 , each door may be controlled by two pressure plates , and @xmath32 is * pspace*-complete .",
    "we consider games played on graphs whose vertices may contain pressure plates , and whose edges may contain doors",
    ". then , @xmath30 belongs to because the set of vertices accessible to the avatar can only increase whenever a pressure plate is activated .",
    "as new pressure plates become accessible , the avatar immediately activates them , opening new doors , until either the exit becomes accessible , or no new pressure plates are discovered .",
    "@xmath31 is in * np*because no pressure plate can undo the effects of another pressure plate .",
    "therefore , we may pretend that a pressure plate disappears as soon as it is activated .",
    "it follows that a certificate for this game is simply an injective sequence of pressure plates .    finally , to see that @xmath32 is in * pspace*@xmath33 * npspace*(cf .",
    "savitch s theorem  @xcite ) , it is sufficient to observe that the a level s _ state _ can be stored in linear space , allocating one bit for each door and storing the position of the avatar in the graph",
    ". then , a certificate is just a walk in the graph .",
    "metatheorem  [ m2].c has a wide range of straightforward applications : most first - person shooters ( with the notable exception of wolfenstein  3d ) , adventure games , and dungeon crawls are all * pspace*-hard .",
    "this includes rpgs such as dungeon master , the eye of the beholder , and lands of lore , which natively implement doors operated by pressure plates .",
    "similar mechanisms can be implemented also in the first - person shooter doom and its sequels , via walkover lines and sector tags . in simple terms ,",
    "whenever the player - controlled avatar crosses a certain line on the ground , a `` block '' somewhere in the level is moved to a predefined location , thus simulating the opening or closure of a door .",
    "all the point - and - click adventure games based on lucasarts scumm engine , such as maniac mansion and the secret of monkey island , as well as most sierra s adventure games , easily fall in this category , too .      a _ button _",
    "is similar to a pressure plate , except that the player may choose whether to push it or not , whenever his avatar encounters one .",
    "games with buttons are in general not harder than games with pressure plates , because a pressure plate can trivially simulate a button , as figure  [ f6a ] shows . however , since the converse statement is not as clear , we will allow a single button to act on several doors , in contrast with pressure plates . a button acting on @xmath12 doors",
    "simultaneously is called a _",
    "@xmath12-button_.    we obtain an analogous of metatheorem  [ m2 ] for buttons .    [ m3 ] if a game features doors and @xmath12-buttons , and the avatar has to reach an exit location in order to win , then :    1 .   if @xmath34 and crossovers are allowed , then the game is -hard .",
    "if @xmath35 , then the game is * np*-hard .",
    "if @xmath36 , then the game is * pspace*-hard .    for part  ( a ) , we mirror the proof of metatheorem  [ m2].a , by using @xmath37-buttons as opposed to pressure plates .",
    "indeed , pressing a button to open a door is never a `` wrong '' move , if the goal is to reach the exit location .",
    "for part  ( b ) , we implement single - use paths as in figure  [ f6b ] : in order to open door @xmath16 , one of the two buttons has to be pressed , thus permanently closing door @xmath15 or door @xmath29",
    ". then we proceed as in the proof of metatheorem  [ m2].b .",
    "finally , for part  ( c ) , we use the gadget in figure  [ f7a ] to simulate a generic pressure plate for @xmath38 : the only way to traverse the gadget from left to right ( the other direction is symmetric ) is to press the buttons as indicated in figures  [ f7b ] ,  [ f7c ] , and  [ f7d ] , incidentally activating also door @xmath17 .",
    "moreover , observe that , no matter how the six buttons are operated , there is no way to `` break '' the gadget by leaving its four doors in an open / closed state that is not the original one . now , by simulating general pressure plates , we can apply the * pspace*-hardness framework used for metatheorem  [ m2].c , concluding the proof .",
    "( observe that our gadget can be further simplified : by inspecting the proof of metatheorem  [ m2].c , it is apparent that each pressure plate is traversed by the avatar in only in one direction .",
    "hence , only three buttons are sufficient in our gadget , e.g. , those that are used to traverse it from left to right . )",
    "+    we can show that metatheorem  [ m3].a and metatheorem  [ m3].c are tight .",
    "there exist games @xmath30 and @xmath31 , featuring doors , in which the avatar has to reach an exit location , such that :    1 .",
    "@xmath30 features @xmath37-buttons and is -complete .",
    "@xmath31 features @xmath12-buttons , with @xmath36 , and is * pspace*-complete .",
    "once again , we consider games played on a graph , in which some vertices contain buttons , and some edges implement doors . to prove that @xmath30 belongs to  , observe that each 1-button either opens or closes a door .",
    "1-buttons opening doors can be presses as soon as they become accessible , and 1-buttons closing doors may be ignored .",
    "therefore the game is equivalent to that of corollary  [ cor2].a .",
    "similarly to the game of corollary  [ cor2].c , @xmath31 belongs to * pspace*@xmath33 * npspace*because the level s state can be stored in linear space , and a certificate is the sequence of the avatar s positions and the @xmath12-switches pressed .",
    "it remains an open problem to establish if also metatheorem  [ m3].b is tight .",
    "there exists an * np*-complete game featuring doors and 2-buttons in which the avatar has to reach an exit location .",
    "it is easy to construct levels in which some 2-buttons have to be pressed more than once in order to reach the exit , therefore it is not trivially true that the sequence of buttons pressed is a polynomial certificate .",
    "in this section we apply the previous metatheorems to some well - known games . in some cases we will merely have to `` simulate '' all the required elements and mechanics with appropriate gadgets , and the reductions",
    "will immediately follow from metatheorems statements .",
    "in other cases , the desired effects will be obtained by taking into account specific features of a metatheorem s proof , and noticing that the patterns we wish to construct have particular properties that , for the sake of brevity , are not mentioned in the actual statement of the metatheorem ( cf .  section  [ s2 ] s introduction ) .    most of the results we prove are new .",
    "for the results that were already known , we either provide simplified reductions , or reductions that use a different set of game elements .",
    "the following table relates all the games that we consider in this section with their complexities , indicating whether or not each result is new .",
    "some of our reductions produce quite contrived levels or configurations , which are very unlikely to occur in the real games : for instance , a draw in starcraft is somewhat rare , and a tron configuration such as the one presented is definitely unnatural . for these games , designing reductions that preserve most of the relevant aspects of the gameplay remains a challenging open problem .",
    "the game is similar to sokoban , but with added gravity .",
    "the player - controlled avatar may push ( but not pull ) single boulders horizontally , excavate some special tiles , and must collect diamonds while avoiding monsters .",
    "when a certain amount of diamonds has been collected , an exit door appears , and the avatar has to reach it to beat the level .",
    "gravity affects boulders and diamonds , but not the avatar or the monsters .      a proof that `` pushing blocks in gravity '' is * np*-hard has been given by friedman in 2002  @xcite , based on a rather involved reduction scheme and several gadgets that may be adapted to work with the slightly different `` physics '' of boulder dash ( namely , if a boulder is on the `` edge '' of a pit , it falls down even if it is not pushed ) .",
    "we give a much simpler proof that relies on metatheorem  [ m1 ] .",
    "location traversal is trivially implemented , due to the presence of diamonds that have to be collected : we place one diamond in each relevant location , forcing the player to visit them all .",
    "a single - use path gadget is illustrated in figure  [ fbd ] : when traversing the gadget in either direction for the first time , three boulders are pushed in the pits .",
    "on the second traversal attempt , the fourth boulder blocks the path .",
    "this is a psychedelic puzzle game in which a laser ray has to be reflected around in the level by rotating several mirrors .",
    "the laser ray is emanated by a laser beam and must be reflected to a predefined location , after hitting several items that must be collected , while avoiding static mines , and without reflecting the laser back to the source for too long ( which overheats the beam ) .",
    "all the relevant game elements are static , or can rotate in place .",
    "there are 16 possible orientations for the laser ray , and making it reach some location basically boils down to finding the correct way to orient the player - controlled mirrors .",
    "some tiles act as reflecting walls , some are opaque and absorb the ray , some special tiles act as teleporters , others as self - rotating mirrors , or self - rotating _ polarizators _ that may be traversed by the ray only in one direction at a time .",
    "all polarizators have eight possible orientations , and rotate at the same speed ( or they are static ) .",
    "there are also some prisms that randomly refract the ray , and some gremlins that attach to player - controlled mirrors and randomly reorient them .",
    "this is a remarkable example of an `` easy '' commercial game : deflektor is solvable in logarithmic space , which is a quite uncommon feature for a puzzle game , and possibly contributed to its modest success .",
    "the key observation is that the ray never needs to be reflected twice by the same mirror in order to reach some location , because it can be re - oriented to any direction already on its first reflection .    for our purposes , prisms count as a special type of player - orientable mirror , as they effectively refract the ray in any desired direction and at the right moment , after waiting a long - enough time .",
    "similarly , self - rotating mirrors count as regular mirrors , as the player can indeed slow them down or accelerate them . on the other hand ,",
    "gremlins may be disregarded in our analysis , as their presence is merely a nuisance and never really prevents a level from being solved .",
    "next we show how to reduce deflektor to the problem undirected connectivity  @xcite .",
    "recall that there are eight possible combined orientations of the polarizators , as they are either static or keep rotating at the same speed .",
    "each combined orientation yields a _ reachability graph",
    "_ @xmath39 on the game elements , which tells if a ray can be redirected by an object onto another .",
    "a reachability graph may be computed in by shooting the 16 possible rays from each mirror ( or prism ) and extending them until each ray is absorbed or reaches a relevant game element , such as a mirror or a collectible item .",
    "this necessarily happens after a finite number of reflections , because the possible ray slopes are rational , and a ray that is never absorbed must have a periodic trajectory .",
    "let @xmath40 be the disjoint union of all the @xmath39 s , in which the eight copies of the laser beam are connected to a common _",
    "beam vertex_. finding a path in @xmath40 from the beam vertex to one of the eight copies of an object means that the laser ray can be redirected to that object after suitably rotating the mirrors , and after waiting for the polarizers to be properly oriented .",
    "the final graph is obtained as the disjoint union of several copies of @xmath40 , one for each item to collect .",
    "let us arbitrarily order the items , and let @xmath41 be the copy of @xmath40 associated to the @xmath42-th item ( here , the exit location counts as the last item in the list ) .",
    "then , the eight copies of the @xmath42-th item in @xmath41 are linked to the beam vertex of @xmath43 .",
    "the beam vertex of @xmath44 will be called the _ starting vertex _ , and the eight copies of the last item in the last copy of @xmath40 are connected to a common vertex , which will be the _",
    "ending vertex_.    thus , the final graph has a path from the starting vertex to the ending vertex if and only if the mirrors can be oriented in such a way that the first item in the list can be collected , then reoriented to collect the second item , etc . , and finally the exit location can be reached . because items can be collected in any order , this is equivalent to solving the level .",
    "the player has to guide a tribe of lemming creatures to safety through a hazardous landscape , by assigning them specific skills that modify their behavior in different ways .",
    "there is a limit to the number of times each skill can be assigned to a lemming , and skills range from building a short stair , to excavating a tunnel , to climbing vertical walls , etc . if no skill is assigned to a lemming , it keeps walking forward , turning around at walls , and falling into pits .",
    "hazards include deadly pools of water or lava , several kinds of traps , and long falls . to beat a level",
    ", at least a given percentage of lemmings has to reach one of several exit portals within a time limit .",
    "the complete set of rules , especially the ways lemmings behave in different landscapes , is quite complex , and has been described by the author in  @xcite .",
    "the * np*-hardness of lemmings was already proved by cormode in  @xcite using only digger skills .",
    "more recently , in  @xcite , the author showed that lemmings is * pspace*-complete , even if there is only one lemming in the level , and only basher and builder skills are available ( the technique used is based on a variant of metatheorem  [ m2].c ) . here",
    "we propose a simple alternative proof of * np*-hardness , which uses only basher skills ( that allow lemmings to dig horizontally ) and relies on metatheorem  [ m1c].b .",
    "our construction can be easily modified to work with miner skills , too ( used to dig diagonally ) .",
    "we model each location as in figure  [ flm1 ] .",
    "as the game starts , exactly one lemming joins the level from the trapdoor , and is bound to stay in the enclosed area , walking back and forth .",
    "if either the indegree or the outdegree of the location is less than two , we suitably remove some of the passages marked by arrows . in the starting location , we fit a second trapdoor that releases another lemming in the upper corridor : this lemming is not a prisoner , and will be the avatar . in the final location , we replace the outgoing passages with an exit portal , which is intended for the avatar .",
    "we appropriately connect locations together as the arrows suggest , and we make sure that the right outgoing passage of the starting location leads to the exit location ( rather than the left passage ) .",
    "it is quite simple to implement paths that go in any direction and can be effectively traversed by lemmings : simple ways to build them have been described in  @xcite and  @xcite .",
    "all the lemmings in the level must reach an exit portal , and the initially available skills are @xmath45 bashers , where @xmath7 is the amount of locations in the level .",
    "the tiles with the steel texture in figure  [ flm ] can not be excavated , hence any lemming that is not the avatar is trapped inside a cage , waiting for the avatar to rescue it by bashing the ground below , as figure  [ flm2 ] illustrates . as a by - product of the lemmings moving rules , when a prisoner hits the leftmost wall of its cage , it turns around and climbs on the upper platform .",
    "then it falls down to the right , turns around at the wall , and walks on the lower ground from right to left .",
    "hence , the prisoner is bound to come out of its cage facing left as soon as the avatar bashes its ground , and it will inevitably reach the nearby exit portal .",
    "this implies that the avatar must visit every location in the level ( location traversal ) and that at least @xmath7 basher skills have to be used to rescue all the prisoners . at any time",
    ", the number of available basher skills minus the number of trapped lemmings will be understood as the number of keys carried by the avatar .",
    "note that a small amount of ground ( i.e. , a door ) must be bashed in order to exit a location from an unvisited outgoing edge , and the initial amount of keys is @xmath7 .",
    "this agrees with the key - door paradigm and the requirements of metatheorem  [ m1c].b , except for the presence of a door in the path between @xmath2 and @xmath1 , which is matched by the extra available key ( this must be the last door to be opened anyway , hence the discrepancy can be safely ignored ) .",
    "the passages connecting locations are indeed one - way paths by construction , since lemmings can not change direction unless they encounter a wall .",
    "observe that the avatar may choose which outgoing path to take on its first traversal of a location .",
    "however , after the right path has been taken , there is no way to take the left path on the second traversal ( but not vice versa ) .",
    "fortunately , by inspecting the proof of metatheorem  [ m1c].b , this does not appear to be an issue , because it is not restrictive to assume that each location will be visited only once , except for the starting location , in which both outgoing paths must be taken .",
    "but we made sure that the right path leads to the exit location , and therefore it must be the last path to be traversed , which is indeed feasible .",
    "the player - controlled avatar must collect gold pieces while avoiding monsters , and is able to dig holes into certain floor tiles ( those that look like bricks ) , which regenerate after a few seconds .",
    "both the avatar and the monsters may fall into such holes , and the avatar can not jump .",
    "the avatar is killed when it is caught by a monster , but it can safely stand in the tile directly above a monster s head .",
    "monsters behave deterministically , according to the player s moves , although their behavior is often quite counterintuitive , as they do not always take the shortest path toward the player s avatar .",
    "when every gold piece has been collected , a ladder appears , leading to the exit .",
    "we apply metatheorem  [ m1 ] : location traversal is implied by the collecting items feature , and a single - use path is illustrated in figure  [ flr ] .",
    "on the first traversal , the avatar can safely land on top of the monster and dig a hole to the left .",
    "the ai will make the monster fall in the hole , so the avatar may follow it , land on its top again , and proceed through a ladder , while the brick tile regenerates and the monster remains trapped in the hole below .",
    "the avatar can not attempt to traverse the gadget a second time without getting stuck in the hole where the monster previously was ( recall that the avatar can neither jump , nor dig holes horizontally ) .",
    "this is the fantasy - themed sequel of deflektor ( see above ) , with a wizard shooting a ray of light in some direction , static gnomes holding orientable mirrors , kettles that must be collected by hitting them with the ray of light , and several new game elements .",
    "these include collectible keys that open locks , wandering monsters that eat kettles , movable blocks , etc .",
    "all the elements of deflektor are recreated in mindbender , with substantially identical mechanics , with one crucial exception : polarizators in mindbender are manually orientable by the player , whereas in deflektor they rotate on their own .",
    "the full game is easily * np*-hard and arguably * pspace*-complete , but the interesting fact is that even the subgame that is supposed to be `` isomorphic '' to deflektor is in fact * nl*-complete , thus harder than deflektor .",
    "we give a straightforward reduction from the * nl*-complete problem directed connectivity  @xcite : first of all , we may assume that each vertex of the given graph has indegree and outdegree at most two .",
    "then , each such vertex is modeled with the gadget in figure  [ fmb ] .",
    "the left and bottom teleporters correspond to incoming edges , while the upper and right teleporters correspond to outgoing edges .",
    "teleporters in different gadgets are connected together according to the topology of the given graph ( which may be non - planar ) .",
    "the central object is a polarizator , which can be oriented by the player and lets light rays pass in one direction only .",
    "the two gnomes can reflect the light either upward or rightward , as figure  [ fmb2 ] exemplifies .",
    "no light ray can be redirected from the left teleporter to the bottom one , or vice versa , due to the polarizator .",
    "the starting vertex contains the wizard instead of the left ( or bottom ) teleporter , and the ending vertex contains the exit door instead of the top ( or right ) teleporter .",
    "the level is solvable if and only if a path exists from the starting vertex to the ending vertex .",
    "remarkably , no kettle has been used in the reduction .",
    "the player controls a yellow ball whose task is to collect all the _ pills _ in a maze , while avoiding _",
    "ghosts_. collecting some special _ power pills _ makes the avatar invulnerable for a short time , giving it the ability to temporarily disable ghosts upon contact . despite this seeming simplicity , the full set of rules is quite complicated  @xcite , although just a few are relevant to our purposes .",
    "ghosts come in four different colors , and a ghost s color determines its behavior . however , all ghosts alternate between chase mode and scatter mode . in chase mode",
    ", they follow the avatar with different heuristics , and in scatter mode they head toward a preset location .",
    "there is also a frightened mode , which is entered when the avatar collects a power pill , and makes all ghosts move randomly .",
    "after a few seconds , the effects of the power pill expire and all ghosts are back to chase and scatter modes . if a ghost in frightened mode is touched by the avatar , it goes back to its starting location , a _ ghost house _ , and comes out again shortly .    as a general rule ,",
    "every time there is a mode switch , all ghosts immediately reverse their direction .",
    "other than that , ghosts may never reverse direction , not even upon reaching a maze intersection , and not even when in frightened mode .",
    "( this is also a practical way for the player to tell when a mode switch occurs . )",
    "depending on the game level , all timings and speeds are subject to variations : ghosts may be faster or slower in different modes , and the durations of the three modes may vary . usually , during frightened mode , the avatar speeds up and the ghosts slow down .",
    "the decision problem is whether a level can be completed without losing lives .",
    "we assume full configurability of the amount of ghosts and ghost houses , speeds , and the durations of chase , scatter , and frightened modes .",
    "we do not alter the basic game mechanics or the ai , though .",
    "we prove * np*-hardness by applying metatheorem  [ m1b].a .",
    "a location with an adjacent toll road is sketched in figure  [ fpa ] .",
    "power pills are used to model tokens , so the starting location contains two power pills , and the final location contains none .",
    "hence , to properly enforce location traversal , we further place a normal pill in the final location .",
    "each toll road is implemented as a pair of parallel maze corridors , each of which contains a ghost house somewhere , spawning one red ghost .",
    "the two corridors are intended to be traversed in opposite directions by the avatar ( i.e. , they are one - way paths ) .",
    "chase and scatter modes have the same duration , and all ghosts have the same speed in both modes .",
    "let @xmath46 be the number of tiles each ghost covers between two mode switches .",
    "frightened mode lasts longer , but ghosts slow down , covering exactly @xmath47 tiles while in that mode .",
    "we make sure that each ghost house is found exactly @xmath48 tiles away from its corridor s entrance , and that each corridor is more than @xmath49 tiles long .",
    "as the game starts , the ghosts spawn in front of their respective ghost houses , and start in chase mode , following the corridor in some direction . whenever a mode switch occurs , all ghosts reverse direction , and they can not change it again until the next mode switch , because they never reach a maze intersection . as a result ,",
    "each ghost `` patrols '' a portion of length @xmath46 of its own corridor . by construction ,",
    "since frightened mode can be entered at most @xmath7 times , no ghost may ever leave its corridor .    upon collecting a power pill , the avatar s",
    "speed increases in such a way that it can cover @xmath49 tiles ( or slightly more ) into any adjacent corridor . by doing so",
    ", the avatar consumes a token and , if the corridor is traversed in the proper direction , the ghost is necessarily encountered and sent back to the ghost house . by the time the avatar has reached the end of the corridor ,",
    "the power pill s effects expire and the ghost comes out of the ghost house , making the toll road functional again .",
    "not to be confused with kplumber , with a similar theme but much different mechanics  @xcite , in this puzzle game a long - enough pipe has to be constructed out of several pieces , randomly presented in a queue , starting from a given _ source location_. after a timer expires , a stream of water starts flowing from the source into the pipes , and the game is won if and only if the stream traverses a given number of tiles before spilling out .    since the player can keep constructing pipes on the same tile , `` overwriting '' the previous pieces until he gets the piece that he wants , he may indeed shape the pipe as he pleases , if the initial timer lasts long enough .",
    "some obstacles are also present in each level , such as fire hydrants , on which pipes can not be built .",
    "membership in * np*is obvious . for * np*-hardness , we apply metatheorem  [ m1 ] .",
    "we use obstacles to model the boundaries of locations and paths , as figures  [ fpm1 ] and  [ fpm3 ] illustrate .",
    "the resulting paths are necessarily single - use , as only one pipe can fit in them .",
    "we still need to establish location traversal .",
    "suppose we implemented our planar graph with orthogonal lines as edges and squares as vertices .",
    "let @xmath50 be the total length of the paths plus the area of the starting vertex , and @xmath15 be the side length of a generic vertex .",
    "if the number of vertices is @xmath7 , the number of paths is @xmath51 , because the graph is 3-regular ( refer to the proof of metatheorem  [ m1 ] ) .",
    "imagine scaling our construction by an integer factor @xmath12 , in such a way that all paths preserve their unit width , but just increase their length .",
    "all the vertices are also scaled in size , except the starting vertex , which remains constant .",
    "then , the total length of all paths plus the starting vertex area becomes @xmath52 , and the area of a non - starting vertex becomes @xmath53 .",
    "when the pipe reaches a generic vertex , it can cover most of its tiles twice before taking the path toward another vertex ( cross - shaped pieces must be used , see figure  [ fpm2 ] ) .",
    "the length of such a pipe is at least @xmath54 .",
    "let us set @xmath12 to a suitable @xmath51 , so that @xmath55 becomes negligible compared to @xmath56 .",
    "now , it is sufficient to set the required length of the pipe to @xmath57 to ensure that all the vertices will be covered by it .",
    "the player has to guide an avatar through several dungeon levels , opening gates , fighting guards , and avoiding traps .",
    "most gates are operated by pressure plates .",
    "the avatar can walk , run , jump , climb , duck , fight , etc .",
    "the game s * pspace*-hardness was first proved in  @xcite , but the rather involved construction may be replaced by a somewhat simpler one based on metatheorem  [ m2].c , which in addition does not rely on gravity , long falls , or on doors that can be opened by more than one pressure plate . to prevent the avatar from avoiding a pressure plate by jumping past it , we simply put it on an elevated tile , which has to be climbed in order to be traversed , as figure  [ fpp ] shows .",
    "we can even do without vertical walls ( as in  @xcite ) , because they can be substituted with unopenable gates .",
    "membership in * pspace*@xmath33 * npspace*(cf .",
    "savitch s theorem  @xcite ) is quite obvious , as the whole level s configuration can be stored in linear space , and enemy guards have a very simple pseudo - random fighting pattern .        in this tetris - like puzzle game ,",
    "levels are made of several colored bubbles , stacked in a hexagonal distribution .",
    "the player controls a cannon at the bottom of the screen , which can shoot new bubbles of random colors in any direction .",
    "bubbles attach to each other and , whenever at least three monochromatic bubbles form a connected set as a result of a shot , they pop .",
    "monochromatic triplets may indeed be present in the initial level configuration , and they pop only when hit by a new bubble of the same color .",
    "apart from colored bubbles , there are _ stone blocks _ that can not be popped ( but may fall if not held up by an anchor ) , and _ rainbow bubbles _ that turn the same color of any bubble that pops next to them , and can later be popped like normal bubbles .",
    "notably , if a set of at least three adjacent monochromatic bubbles is formed as a result of some rainbow bubbles turning that color , they immediately pop .",
    "this may even induce a `` chain reaction '' of exploding rainbow bubbles , during which the player is not allowed to shoot a new bubble , and must wait for the explosions to finish .",
    "we prove * np*-hardness by a reduction from planar 3-sat .",
    "several variable gadgets ( figure  [ fpba ] ) are stacked on top of each other , slightly staggered , on the far left of the construction .",
    "the clause gadgets ( figure  [ fpbb ] ) are on the right , far above the variable gadgets . to separate _",
    "variable layers _ from each other and from the clause gadgets , we put long _ shields _ of stone blocks , extending from each variable gadget to the far right of the construction . the last shield (",
    "i.e. , the one in the top layer ) also extends all around the whole construction , on the right , top and left sides , preventing bubbles shot by the player from bouncing on the sides of the screen .",
    "variables and clauses are connected via carefully shaped _",
    "fuses _ made of rainbow bubbles , forking and bending as in figure  [ fpb1 ] .      initially , only the bottom variable gadget is exposed , and the player may choose whether to pop the black or the white bubbles , which correspond to opposite truth values . popping one of the two sets say ,",
    "the black one causes three rainbow bubbles to turn black and pop immediately after .",
    "this triggers a chain reaction , in which at least three new rainbow bubbles turn black and pop at each step , consuming the fuse and eventually reaching the clause gadgets . at this point",
    ", a thin colored _ wire _ is reached in every clause gadget ( see figure  [ fpbb ] ) , which pops if and only if it is black ( its color tells whether the corresponding literal in the clause is positive or negative ) .",
    "if it pops , the explosion propagates inside the clause gadget , eliminating the anchor .",
    "notice that the explosion can never `` backfire '' from the clause gadget and consume fuses corresponding to different variables , because each wire is connected to only two rainbow bubbles of its attached fuse .      when the fuse of the first variable has been consumed , the remaining part of the variable layer falls , including the shield ( see figure  [ fpba ] ) .",
    "the second variable layer is then exposed , and the process continues until all fuses have been consumed , and all shields have fallen .",
    "what eventually remains are the `` unsatisfied '' clause gadgets , whose wires are now impossible to reach , due to the surrounding _ sheaths _ made of stone blocks .",
    "notice that each variable layer has its own anchor , so its shield does not fall until the variable has been set by the player , even if all the clauses connected to that variable have already been satisfied .",
    "this proves * np*-hardness .",
    "completeness holds under the assumption that the player can always choose the color of his next bubble , which is not far from true in most cases , since bubbles can be either discarded by making them bounce back to the bottom of the screen , or can be stacked somewhere ( if done properly , not more than two bubbles per color need to be stacked at once ) .",
    "the player controls a furry ball that has to walk on blue tiles in order to paint them pink , while avoiding monsters .",
    "some tiles are made of ice and do not have to be painted , the avatar slides on them and is unable to change direction until it reaches a different type of tile , or its slide is blocked by a wall .",
    "some blue tiles fall apart when the avatar steps on them , opening a hole in the ground that becomes a deadly area .",
    "all the blue tiles have to be painted pink within a time limit in order to finish the level .",
    "several power - ups randomly appear , including an exit door and teddy bears of several colors , which let the player immediately skip the level when collected .",
    "the decision problem is whether a given level can be completed without losing lives , regardless of the power - ups that may randomly appear .",
    "the presence of breakable tiles yields an immediate application of metatheorem  [ m1 ] .",
    "figure  [ fsk ] shows how a location is constructed : location traversal is implied by the blue tiles , all of which have to be covered by the avatar . on the other hand , after traversing a path connecting two locations , the cracked tiles break and can not be accessed again , making it a single - use path .",
    "the reason why we use ice tiles is merely that they need not be painted , so the player s purpose is in fact to visit all locations , rather than all paths .",
    "for this reason , even though there exists a power - up that prevents the avatar from sliding on ice , our construction still works as intended .",
    "proving membership in * np*would be almost straightforward , were it not for a certain type of monster that turns tiles from pink to blue .",
    "on top of this , monster behavior is pseudo - random and partly depends on the player s moves . for these reasons , beating a level may conceivably take an exponentially long time , and any proof that the game lies in * np*would have to be carefully crafted .",
    "starcraft is a real - time strategy game in which two or more players have to train an army in order to destroy each other s bases .",
    "two types of resources can be gathered from the environment by special units called _",
    "workers_. resources allow to make new buildings in order to train more units , thus forming an army that can be sent to war .",
    "there are three possible _ races _ to choose , each of which has its unique unit types , each one with different parameters , such as hit points , range , damage , speed , etc .",
    "some units have special abilities , such as becoming invisible , casting offensive or defensive `` spells '' , etc .",
    "a player loses if and only if all his buildings are destroyed , regardless of the amount of units that he still has , or the amount of resources he gathered .",
    "most rts games are expected to be * exp*-hard , since they involve at least two players , and a match may last an arbitrarily long time .",
    "however , a simple * np*-hardness proof can be given via metatheorem  [ m1b].a . the same reasoning applies , with minor changes , to several rts games other than starcraft , such as warcraft and age of empires .      in our setting , the avatar will be a protoss probe ( i.e. , the protoss race s worker unit ) .",
    "when several probes will be found in the same area , we will identify one as the avatar , and all the other probes will represent tokens carried by the avatar .        consistently with our avatar - token abstraction , we present a toll road in figure  [ fsc1 ] . if a lone probe attempts to walk in the canyon , it is destroyed by a single shot of the enemy siege tank .",
    "but if two probes walk together , only one can be targeted and destroyed , whereas the second probe can make it past the siege tank while it reloads ( the two probes should stay a couple of tiles away from each other , to avoid splash damage ) . paraphrasing",
    ", the avatar can traverse the toll road if and only if it is carrying a token .",
    "it does not matter which probe is destroyed , because they are all equivalent . in general , if several probes attempt to traverse the canyon together , at least one is destroyed , and at least one survives .",
    "figure  [ fsc2 ] shows how to implement a token lying in some location .",
    "the building is a protoss nexus , and there is a probe trapped behind a mineral field , worth exactly @xmath58 minerals . the probe can gather up to eight minerals at once , but then it must bring them to a nexus before it can gather more minerals .",
    "it follows that the trapped probe can not free itself , but it must wait for another probe to set it free by bringing all the minerals to the nexus .        in our analogy , gathering all the minerals in a location to set a probe free corresponds to picking up a token .",
    "if now we add a free probe to the designated starting location , we are effectively placing an avatar there , which must set a new probe free every time it needs to traverse a toll road .",
    "we still have to enforce location traversal and ensure that no new probes are trained .",
    "recall from the proof of metatheorem  [ m1b].a that there are @xmath59 locations with one token , plus a starting location with two tokens , and a final location with no tokens .",
    "therefore , in our generated map , the starting location has two mineral fields , and the final location has none .",
    "we place a nexus and a mineral field in the final location as well ( but no probe , i.e. , no token ) , so that there are @xmath60 minerals in total , and at least @xmath58 minerals in each location .    in a different part of the map , we place @xmath61 copies of the `` crater '' shown in figure  [ fsc3 ] . in each crater",
    ", there is a protoss gateway supported by a protoss pylon , and a terran supply depot .",
    "this completes our construction .",
    "it is clear that the terran player has no way to gather resources or train new units , in that he has no workers , and his only buildings are @xmath61 supply depots .",
    "moreover , each siege tank is bound to stay on a small platform , and switching from siege mode to tank mode has no use , because the shortened attack range would not allow it to hit any probe .",
    "on the other hand , let us assume that the protoss player starts with no resources , either .",
    "because there are no vespene geysers on the map , and only minerals are available , there are only two kinds of units that the protoss player may ever train : probes from nexuses and zealots from gateways .",
    "because none of them can fly and both are melee units , it follows that a zealot must be trained from each gateway in order to destroy the nearby supply depot . since training a zealot costs 100 minerals , all the minerals in every location",
    "must be gathered and spent just for training zealots .",
    "therefore , no additional buildings may be built , and no additional probes may be trained at the nexuses . in other terms , just the initial avatar can be used , and all the locations must be reached , which implies the location traversal feature .",
    "there are four subgames , one of which is a `` light cycle '' race between the player and several opponents .",
    "the race takes place in a rectangular grid whose external boundary is a deadly obstacle .",
    "the trail of each light cycle becomes a deadly obstacle as well , hence the safe areas become narrower and narrower as the race progresses .",
    "as soon as a light cycle hits an obstacle , it is eliminated , and also its trail is removed from the grid .",
    "the goal is to remain the sole survivor in the arena .",
    "we start from a grid - aligned embedding in which each vertex is a square , and paths have unit width .",
    "then we scale the construction up by some large - enough factor , while preserving the size of the vertices , and keeping all the paths of unit width .",
    "we do so to make the total area of all vertices negligible compared to the area of a face of the underlying plane graph .",
    "next we perform the same operation that we did for pipe mania ( see above ) : with the same notation , we scale the construction by a factor @xmath62 , so that the resulting combined path length @xmath55 is negligible with respect to the area of a single vertex @xmath63 .",
    "( in contrast with pipe mania , though , the starting vertex counts as a regular vertex and its area does not contribute to @xmath64 or @xmath55 . )",
    "then we proceed by implementing paths and locations , as sketched in figure  [ ftr ] .",
    "each opponent light cycle is responsible for drawing the border of a face of the plane graph underlying our construction ( including the outer face ) , which is a grid - aligned polygon .",
    "when a light cycle is done drawing and meets its own trail again , it turns around and `` traps '' itself in a rectangle of area @xmath65 ( or slightly smaller ) inside the polygon it just outlined .",
    "this rectangle necessarily fits somewhere in the polygonal face , by the first step of the above construction . in figure  [ ftr ]",
    "we see a path , traversed by the player s light cycle , which is bordered by two faces , the upper face arguably having a smaller perimeter than the lower one ( because the upper rectangle is bigger , and a larger part of it has been covered ) .    while paths and vertices are constructed , we assume that the player `` waits '' by covering a small square in the starting vertex .",
    "this is feasible , because the perimeter of any face is much smaller than the area of a vertex , by construction .",
    "then the actual race starts , and the player has to cover enough locations to survive longer than his opponents .",
    "paths are obviously single - use , because they have unit width , and the player s trail is an obstacle even for the player himself .",
    "location traversal is implied by the fact that the player s light cycle must cover at least a length of slightly less than @xmath65 , so it must visit all vertices .",
    "e.  d. demaine and r.  a. hearn .",
    "playing games with algorithms : algorithmic combinatorial game theory . in _ games of no chance 3 _ , edited by m.  h. albert and r.  j. nowakowski , msri publications , 56:356 , 2009 ."
  ],
  "abstract_text": [
    "<S> we establish some general schemes relating the computational complexity of a video game to the presence of certain common elements or mechanics , such as destroyable paths , collectible items , doors opened by keys or activated by buttons or pressure plates , etc . </S>",
    "<S> then we apply such `` metatheorems '' to several video games published between 1980 and 1998 , including pac - man , tron , lode runner , boulder dash , deflektor , mindbender , pipe mania , skweek , prince of persia , lemmings , doom , puzzle bobble  3 , and starcraft . </S>",
    "<S> we obtain both new results , and improvements or alternative proofs of previously known results . </S>"
  ]
}