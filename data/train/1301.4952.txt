{
  "article_text": [
    "two sequences are _ order - isomorphic _ if the permutations required to sort them are the same .",
    "a sequence @xmath2 is said to be a _ pattern _ ( or _ occurs _ ) within a sequence @xmath0 if @xmath0 has a _ subsequence _ that is order - isomorphic to @xmath2 .",
    "pattern involvement _ permutations _ and sequences has now become a very active area of research @xcite .",
    "however , only few results on the complexity of finding patterns in permutations and sequences are known .",
    "it appears to be a difficult problem to decide of two given permutations @xmath15 and @xmath16 whether @xmath16 occurs in @xmath15 , and in this generality the problem is np - complete @xcite . for @xmath17 and @xmath18 ,",
    "the @xmath19 time brute - force algorithm was improved to @xmath20 time in @xcite .",
    "there are several ways in which this notion of permutation patterns may be generalized , and we focus here on _ consecutive patterns _ ( _ i.e. _ the match is required to consist of contiguous elements ) @xcite .",
    "a sequence @xmath2 is said to be a _ consecutive pattern _ or _ consecutively occurs _ within a sequence @xmath0 if @xmath0 has a _ substring _ that is order - isomorphic to @xmath2 .",
    "searching for a pattern @xmath2 in a text @xmath0 consists in identifying all occurrences of @xmath2 in @xmath0 . recently , using a modification of the classical knuth - morris - pratt string matching algorithm , a @xmath21 time algorithm has been proposed for checking if a given sequence @xmath0 of length @xmath22 contains a substring which is order - isomorphic to a given pattern @xmath2 of length @xmath3 @xcite .",
    "the time complexity reduces to @xmath23 time under the assumption that the symbols of the pattern can be sorted in @xmath13 time .",
    "the set of all integers from @xmath24 to @xmath22 is written @xmath1 $ ] .",
    "let @xmath0 be a permutation of length @xmath22 and @xmath2 be a sequence of @xmath25 distinct integers in @xmath1 $ ] .",
    "first we present a forward automaton which allows us to search for @xmath2 in @xmath0 in @xmath11 time .",
    "next , we introduce a morris - pratt automaton representation  @xcite of the forward automaton which allows us to reduce this complexity to @xmath12 at the price of an additional amortized constant term by integer of the text .",
    "both automata occupy @xmath13 space .",
    "we then extend the problem to search for a set of patterns and exhibit a specific aho - corasick like algorithm .",
    "finally we present a sub - linear average case search algorithm running in @xmath26 time that we eventually prove to be optimal on average .",
    "let us define some notations .",
    "the set of all permutations on @xmath1 $ ] is denoted by @xmath27 .",
    "let @xmath28 $ ] .",
    "abusing notations , we consider in this paper permutations of @xmath27 as strings without symbol repetition , and we denote by @xmath29 the set of all strings without symbol repetition ( including the empty string ) , where each symbol is an integer in @xmath1 $ ] .",
    "a _ prefix _ ( resp . _",
    "suffix _ , _ factor _ ) @xmath30 of @xmath2 is a string such that @xmath31 .",
    "@xmath32 , @xmath33 .",
    "we also denote @xmath34 the number of integer(s ) in a string @xmath35 .",
    "we eventually denote @xmath36 the reverse of @xmath2 , that is , the string formed by the symbols of @xmath2 read in the reverse order .",
    "we denote by @xmath37 the set of words of @xmath29 which are order - isomorphic to @xmath2 .",
    "the following property is useful for designing automaton transitions .",
    "[ trans ] let @xmath38 and @xmath39 , @xmath40 , such that @xmath41 is order - isomorphic to @xmath42 , and let @xmath43 .",
    "testing if @xmath44 is order - isomorphic to @xmath45 can be performed in constant time storing only a pair of integers",
    ".    * proof . *",
    "the pair of integers @xmath46 is determined as follows : @xmath47 is the greatest number such that @xmath48 is the position of one of the largest integer in @xmath49 which is smaller than @xmath50 , if any . otherwise , we fix @xmath51 arbitrarily to @xmath52 .",
    "let @xmath53 be the greatest position of one of the smallest integer in @xmath49 which is larger than @xmath50 , if any .",
    "otherwise , we fix @xmath54 to @xmath55 .",
    "now , it suffices to test if @xmath56 to verify if @xmath44 is order - isomorphic to @xmath57    we define a function @xmath58 which returns a pair of integers @xmath46 that represents the pair defined in property [ trans ] for the prefix of length @xmath59 of a motif @xmath2 .",
    "before proceeding , we first describe some useful data structures we shall use as basic subroutines of our algorithms . the problem called _ predecessor search problem _ is defined as follows : given a set @xmath60 $ ] ( @xmath30 is called the size of the universe ) , we support the following query : given an integer @xmath61 return its predecessor in the set @xmath62 , namely the only element @xmath63 such that @xmath64   are smaller than @xmath61 , then return @xmath52 and if they are larger than @xmath61 then return @xmath65 . in addition , in the dynamic case , we also support updates : add or remove an element from the set @xmath62 . the standard data structures to solve the predecessor search are the balanced binary search trees  @xcite .",
    "they use linear space and support queries and updates in worst - case @xmath66 time .",
    "however , there exists better data structures that take advantage of the structure of the integers to get better query and update time .",
    "specifically , the van - emde - boas tree  @xcite supports queries and updates in ( worst - case ) time @xmath67 using @xmath68 space . using randomization",
    ", the y - fast trie achieves linear space with queries supported in time @xmath67 and updates supported in randomized @xmath67 time .",
    "the problem has received series of improvements which culminated with andersson and thorup s result  @xcite .",
    "they achieve linear space with queries and updates supported in @xmath69 ( the update time is still randomized ) .",
    "a special case occurs when space @xmath22 is available and the set of keys @xmath62 is known to be smaller than @xmath70 for some constant @xmath71 . in this case",
    "all operations are supported in worst - case constant time using the atomic - heap  @xcite .",
    "the problem we consider is to search for a motif @xmath2 in a permutation @xmath0 without preprocessing the text itself . by analogy to the simpler case of the direct search of a word @xmath2 in text @xmath0 , we build an automaton that recognizes @xmath72 . we then prove its size to be linear in the length of the pattern .",
    "we formally define our forward search automaton @xmath73 built on @xmath74 as follows :    * @xmath75 states corresponding to each prefix ( including the empty prefix ) of @xmath2 , state @xmath76 is initial , state @xmath3 is terminal ; * @xmath3 forward transitions from state @xmath59 to @xmath77 labelled by @xmath78 ; * @xmath79 backward transitions @xmath80)$ ] , where @xmath81 numbers a state , @xmath82 , @xmath83 , @xmath84 , defined the following way : @xmath80 ) = q$ ] if and only if for all @xmath85 ( resp .",
    "@xmath86 if @xmath87 , @xmath88 if @xmath89 ) , the longest prefix of @xmath2 that is order - isomorphic to a suffix of @xmath90 is @xmath91 .",
    "we also impose some constraints on outgoing transitions .",
    "let @xmath81 be a given state corresponding to the prefix @xmath92 .",
    "let us sort all @xmath93 and consider the resulting order @xmath94 .",
    "we build one outgoing transition for each interval @xmath95 $ ] , excepted if @xmath96 also we merge transitions from the same state to the same state that are labeled by consecutive intervals .",
    "it is obvious that the resulting automaton recognizes a given pattern in a permutation by reading one by one each integer and choose the appropriate transition .",
    "figure [ aut1 ] shows such an automaton .    .",
    "state @xmath76 is initial and state @xmath97 is terminal.,width=340 ]    the main result on the structure of the forward automaton is the following .",
    "[ lemmasize ] the number of transitions of the forward automaton built on @xmath98 is linear in @xmath3 .",
    "lemma  [ lemmasize ] combined with the fact that the outgoing transitions from each state @xmath99 are sorted accordingly to the closest proximity to @xmath99 of their arrival state leads to the following lemma .",
    "[ searchphase ] searching for a consecutive motif @xmath74 in a permutation @xmath100 using a forward automaton built on @xmath2 takes @xmath101 time .",
    "we can build the forward automation in @xmath102 time .",
    "however , we defer the proof of this construction for the following reason",
    ". this @xmath103 complexity might be too large for long patterns .",
    "nevertheless , we show below that we can compute in a first step a type of morris - pratt coding of this automaton which can either ( a ) be directly used for the search for the pattern in the text and will preserve the linear time complexity at the cost of an amortized constant term by text symbol , or ( b ) be developed to build the whole forward automaton structure",
    ".    therefore we present and build a new automaton @xmath104 that is a morris - pratt representation of the forward automaton .",
    "the idea is to avoid building all backward transitions by only considering a special backward single transition from each state @xmath105 named _ failure _ transition .",
    "we formally define our automaton @xmath106 built on @xmath74 the following way :    * @xmath75 states corresponding to each prefix ( including the empty prefix ) of @xmath2 , state @xmath76 is initial , state @xmath3 is terminal ; * @xmath3 forward transitions from state @xmath59 to @xmath77 labelled by @xmath78 ; * @xmath3 failure transitions ( non labelled ) defined by : a failure transition connects a state @xmath107 to a state @xmath108 if and only if @xmath109 is the largest order - isomorphic border of @xmath110 .",
    "automaton built on @xmath111 .",
    "state @xmath76 is initial and state @xmath97 is terminal .",
    "backward transitions are failure transitions.,width=302 ]    reading a text @xmath0 through the mp representation of the forward automaton is performed the following way .",
    "let us assume we reached state @xmath112 and we read a symbol @xmath113 at position @xmath5 of the text .",
    "let @xmath114 = \\mbox{rep}(p , x+1).$ ] if @xmath115 $ ] we follow the forward transition and the new current state is @xmath116 .",
    "otherwise , we _ fail _ reading @xmath113 from @xmath81 and we retry from state @xmath117 and so - on until ( a ) either @xmath99 is undefined , in which case we start again from state @xmath76 , either ( b ) a forward transition from @xmath99 to @xmath118 works , in which case the next current state is @xmath118 .",
    "[ kmp ] searching for a pattern @xmath2 in a text @xmath119 using the morris - pratt representation of the forward automaton built on @xmath2 is @xmath101 time .",
    "in order to prove lemma [ kmp ] we need to focus on the classical notion of border that we extend to our framework .",
    "let @xmath120 .",
    "a _ border _ of @xmath2 is a word @xmath121 that is order - isomorphic to a suffix of @xmath2 but also order - isomorphic to a prefix of @xmath2 .",
    "the construction of the forward automation relies of the maximal border of each prefix that is followed by an appropriate integer in the pattern .",
    "the morris - pratt approach is based on the following property :    a border of a border is a border .",
    "this property allows us to replace the direct transition of the forward algorithm by a search along the borders , from the longest to the smallest , to identify the longest one that is followed by the appropriate integer .",
    "we prove now that we can build the morris - pratt representation of the forward automaton efficiently .",
    "[ kmpbuild ] building an morris - pratt representation of the forward automaton on a consecutive motif @xmath74 can be performed in ( worst - case ) @xmath122 time .",
    "lemma [ kmp ] and [ kmpbuild ] allow us to state the main theorem of this section .",
    "[ theoall ] searching for a consecutive motif @xmath74 in a permutation @xmath100 can be done in @xmath123 time .",
    "the morris - pratt representation of the forward automaton permits to search directly in the text at the price of larger amortized complexity ( considering the constant hidden by the @xmath124 notation ) than that required by searching with the forward automaton directly .",
    "if the real time cost of the search phase is an issue , the forward automaton can be built form its morris - pratt representation as follows .",
    "[ forward ] building the forward automaton of a consecutive motif @xmath125 can be performed in @xmath126 time .",
    "an interesting point is that the construction of the forward automaton from its morris - pratt representation can also be performed in a lazy way , that is , when reading the text .",
    "the missing transitions are then built _ on the fly _ when needed .",
    "we can extend the previous problem defined for a single pattern to a set of patterns @xmath62 .",
    "we note by @xmath127 the number of patterns , by @xmath3 the total length of the patterns and by @xmath128 the length of the longest pattern . for this problem",
    "we adapt the aho - corasick automaton  @xcite ( or @xmath129 automaton for short ) .",
    "the @xmath129 automaton is a generalization of the @xmath104 automaton to a set of multiple patterns .",
    "we note by @xmath130 the set of prefixes of strings in @xmath62 . in order to simplify the description",
    "we will assume that the set of patterns @xmath62 is prefix - free .",
    "that is , we will assume that no pattern is prefix of another .",
    "extending the algorithm to the case where @xmath62 is non - prefix free , should not pose any particular issue .",
    "the states of the @xmath129 automaton are defined in the same way as in the @xmath131 automaton .",
    "each state @xmath0 in the @xmath129 automaton corresponds uniquely to a string @xmath132 .",
    "the forward transitions are defined as follows : there exists a forward transition connecting state @xmath133 to each state corresponding to an element @xmath134 ( where @xmath71 is a single symbol ) .",
    "thus this definition of the forward transitions matches essentially the definition of the forward transitions in the @xmath104 automaton .",
    "the failure transitions are defined as follows : a failure transition a state @xmath133 corresponding a string @xmath2 to the state @xmath135 corresponding to the longest string @xmath99 such that @xmath136 and @xmath137 . the matching using the @xmath129 automaton is done in the same way as in the @xmath131 automaton using the forward and failure transitions .",
    "we could use exactly the same algorithm as the one used previously for our variant of the @xmath131 automaton with few differences .",
    "we describe our modification to @xmath129 automaton to adapt it to the case of consecutive permutation matching .",
    "an important observation is that we could have two or more elements of @xmath130 that are both of the same length and order - isomorphic .",
    "those two elements should have a single corresponding state in the @xmath129 automaton .",
    "thus , if two or more elements of @xmath130 are order - isomorphic then we keep only one of them . for the forward transitions , we can a associate a pair of positions @xmath46 to each forward transition",
    ". then we can check which transition is the right one by checking the condition @xmath138 for every pair @xmath46 and take the corresponding transition .",
    "the main problem with this approach is that the time taken would grow to @xmath139 time to determine which transition to take which can lead to a large complexity if @xmath127 is very large .",
    "our approach will instead be based on using a binary search tree ( or more sophisticated predecessor data structure ) . with the use of a binary search tree",
    ", we can achieve @xmath140 time to decide which transition to take .",
    "more precisely , each time we read @xmath141 $ ] we insert the pair @xmath142 into the binary search tree .",
    "the insertion uses the number @xmath113 as a key .",
    "now suppose that we only pass through forward transitions .",
    "then a transition at step @xmath5 is uniquely determined by : ( 1 ) the current state @xmath133 corresponding to an element @xmath132 ; ( 2 ) the position of the predecessor of @xmath113 among @xmath143 .    to determine the predecessor of @xmath113 among @xmath144 , the binary search tree should contain precisely the @xmath145 pairs corresponding to @xmath146}\\ldots t_{i-1}$ ] .",
    "if the predecessor of @xmath113 in the binary search tree is a pair @xmath147 , we then conclude that the element @xmath148 $ ] is the predecessor of @xmath149 in @xmath2 .    in order to maintain the binary search tree we must do the following actions during passing through a failure or a forward transition : ( 1 ) whenever we pass through a forward transition at a step @xmath5 we insert the pair @xmath142 ; ( 2 )",
    "whenever we pass through a failure transition from a state corresponding to a prefix @xmath150 to a state corresponding to a prefix @xmath151 , then we should remove from the binary tree all the pairs corresponding to the symbols @xmath152 .",
    "it should be noted that each removal or insertion of a pair into the binary search tree takes @xmath153 time .",
    "the upper bound @xmath153 comes from the fact that we never insert more than @xmath128 elements in the binary search tree . since in overall we are doing @xmath101 insertions or removals",
    ", the amortized time should simplify to @xmath154 .",
    "finally if we replace binary search tree with a more efficient predecessor data structure , we will be able to achieve randomized time @xmath155 where @xmath156 is the time needed to do an operation on the predecessor data structure ( see section  [ sec : tools ] for details ) .",
    "we use the linear space version of the predecessor data structure which guarantees only randomized performance but uses @xmath157 additional space only .",
    "we thus have the following theorem :    [ theoacsearch ] searching for set of @xmath127 consecutive motifs of maximal length @xmath128 and whose @xmath129 automaton has been built and where the longest pattern is of length @xmath128 can be done in randomized @xmath158 time , where @xmath156 .",
    "* preprocessing . *",
    "we now show that the preprocessing phase can be done in worst - case @xmath159 time . as before our starting point will be to sort all the patterns and reduce the range of symbols of each pattern of length @xmath160 from range @xmath1 $ ] to the range @xmath161 $ ] .",
    "this takes worst - case time @xmath159 .",
    "recall that two or more elements of @xmath130 of the same length and order - isomorphic should be associated with the same state in the @xmath129 automaton . in order to identify the order - isomorphic elements of @xmath130",
    ", we will carry a first step called normalization .",
    "it consists in normalizing each pattern .",
    "a pattern @xmath2 is normalized by replacing each symbol @xmath162 by the pair @xmath163 ( consisting in the positions of the predecessor and successor among symbols @xmath164 ) .",
    "this can be done for all patterns in total @xmath159 time . in the next step ,",
    "we build a trie on the set of normalized patterns .",
    "this takes linear time .",
    "the trie naturally determines the forward transitions .",
    "more precisely any node in the trie will represent a state of the automaton and the the labeled trie transitions will represent follow transitions .",
    "note that unlike the forward automaton ( or the @xmath104 automaton ) there could be more than one outgoing forward transition from each node . in order to encode the outgoing transition from each node",
    ", we will make use of a hash table that stores all the transitions outgoing from that node .",
    "more precisely for each transition labeled by the pair @xmath165 and directed to a state @xmath99 , the hash table will associate the key @xmath150 associated with the value @xmath99 . now that the next transitions have been successfully built",
    ", the final step will be to build the failure transitions and this takes more effort . in order to build the failure transitions we decompose the trie into @xmath128 layers .",
    "the first layer consists in the nodes of the trie that represent prefixes of length @xmath24 .",
    "the second layer consist in all the nodes that represent prefixes of length @xmath166 , etc .",
    "next , we will reuse the same algorithm that was used in  [ kmpbuild ] to build the @xmath104 automaton but adapted to work on the @xmath129 automaton .",
    "instead of using a single predecessor data structure we will use multiple predecessor data structures and attach a pointer to a predecessor data structure at each trie node .",
    "a node of the original non compacted trie will share the same predecessor with its parent , iff it is the only child of its parent .",
    "the following building phases will no longer reuse the normalized patterns , but instead reuse the original patterns . to each node",
    ", we attach a pointer to one of the original pattern .",
    "more precisely if a node has a single child , then his pattern pointer will be the same as its ( only ) child pattern pointer .",
    "if a node has more than one child ( in which case it is called a _ branching node _ ) , then it will point to the shortest pattern in its subtree .",
    "if a node is a leaf then it will directly point to the corresponding pattern .",
    "a predecessor data structure of a node whose pattern pointer points to a pattern of length @xmath30 will have capacity to hold @xmath30 keys from universe @xmath30 and thus will use @xmath68 space .",
    "this is justified by the fact that the predecessor data structure will only hold at most @xmath30 elements of the patterns and each element value is at most @xmath30 ( recall that the pattern is a permutation of length @xmath30 ) .    in order to bound the total number of predecessor data structures and their total size",
    ", we consider a compacted version of the trie ( patricia trie ) , where each node with a single child is merged with that single child .",
    "a node in the original ( non - compacted ) trie with two of more children is called _ branching node_. it is clear that the set of nodes of a patricia ( compacted ) trie are precisely the branching nodes and the leaves of the original trie .",
    "it is a well known fact that a patricia trie with @xmath128 leaves has at most @xmath167 nodes in total .",
    "thus the total number of predecessor data structures will be upper bounded by @xmath167 . during the building",
    "if a node at layer @xmath0 has a single child , then that single child at level @xmath168 will inherit the predecessor data structure of its parent . otherwise if the node @xmath169 at level @xmath0 has two or more children at level @xmath168 , then a predecessor data structure is created for each child @xmath30 . then if the predecessor data structure of @xmath169 contains exactly @xmath170 elements , those elements are precisely @xmath171 , where @xmath81 is string pointed by @xmath169 .",
    "we will insert the k elements @xmath172 into the predecessor data structure of @xmath30 , where @xmath61 the string pointed by @xmath30 .    in order to bound the total space used by the predecessor data structures",
    ", we notice that the total capacities of all predecessor data structures is @xmath13 .",
    "this can easily be proved . because we know that the total length of all patterns is bounded by @xmath3",
    ", we will also know that the total cumulative length of all strings pointed by branching node is also upper bounded by @xmath3 .",
    "this is because precisely the pointed strings are precisely the shortest strings in the subtrees rooted by the branching node .",
    "the same holds for the leaves as the capacities of their respective predecessor data structures will be no more than the total length of the patterns that correspond to the leaves which is @xmath13 .    we finally need to bound the total construction time which is dominated by the operations on the predecessor data structures . the time is clearly bounded by @xmath159 .",
    "this is by a straightforward argument : as the total sum of the pointed strings is @xmath13 , and we know that each element of a pointed string can only be inserted or deleted once , and furthermore each insert / delete cost precisely @xmath173 worst - case time , we conclude that the total time spent in the predecessor data structure is worst case @xmath159 .",
    "we thus have the following theorem :    [ theacbuild ] building the @xmath129 automaton for a set of @xmath127 consecutive motifs of total length @xmath3 and where the longest motif is of length @xmath128 can be done in worst - case @xmath159 time .",
    "algorithm forward takes @xmath174 time in the worst case time but also on average .",
    "we present now a very simple and efficient average case - algorithm which takes @xmath175 time . in order to search for a pattern @xmath2 in @xmath0 ,",
    "we first build a tree @xmath176 of all isomorphic - order factors of @xmath36 of length @xmath177 .",
    "@xmath176 is built by inserting each such factor one after the other in a tree and building the corresponding path if it does not already exist .",
    "the construction of this tree requires @xmath178 time ( details are given below ) .",
    "the search phase is performed through a window of size @xmath3 that is shifted along the text .",
    "for each position of this window , @xmath179 symbols are read backward from the end of the window in the tree @xmath176 .",
    "two cases may occurs : _ (",
    "i ) _ either the factor is not recognized as a factor of @xmath36 .",
    "this means that no occurrence of @xmath2 might overlap this factor and we can surely shift the search window after the last symbol of this factor ; _ ( ii ) _ either the factor is recognized , in which case we simply check if the motif is present using a naive @xmath13 algorithm , and we repeat this test for the next @xmath180 symbols .",
    "this might require @xmath181 steps in the worst case .",
    "figure [ fail ] illustrates the first case .",
    "is not recognized in the tree @xmath176 , which implies that no occurrence of @xmath2 can overlap @xmath41 and the search window can surely be shifted after the first symbol of @xmath182,width=340 ]    let us analyze the average complexity of our algorithm , in a bernoulli model with equiprobability of letters , that is , every position in the text and the paper is independent of the others and the probability of a symbol to appear is @xmath183 we also consider that @xmath184 since we are interested in analyzing the average complexity for pattern long enough .",
    "we count the average number of symbol comparisons required to shift the search window of @xmath185 symbols to the right .",
    "as there are @xmath186 such segments of length @xmath185 symbols in @xmath22 , we will simply multiply the resulting complexity by @xmath186 to gain the whole average complexity of our algorithm",
    ".    there might be @xmath187 distinct motifs that could appear in the text while this number is bounded by @xmath188 in the pattern ( one by position ) .",
    "thus , with a probability bounded by @xmath189 we will recognize the segment of the text as a factor of @xmath2 and enter case 2 . in which case , moving the search window of @xmath185 symbols to the right using the naive algorithm will require @xmath181 worst case time .",
    "in the other case which occurs with probability at least @xmath190 , shifting the search window by @xmath185 symbols to the right only requires reading @xmath191 numbers .",
    "the average complexity ( in terms of number of symbol reading and comparisons ) for shifting by @xmath185 symbols is thus ( upper ) bounded by @xmath192 and the whole complexity by @xmath193 . by expanding and simplifying @xmath194",
    "we get that @xmath195 now using the famous stirling approximation @xmath196 , it is not difficult to prove that @xmath197 and thus @xmath198 and the whole average time complexity ( in terms of number of symbol reading and comparisons ) turns out to be @xmath199 .      the tree @xmath176 can actually be built in @xmath178 time by using appropriate data structures . recall that the tree @xmath176 recognizes all the factors of @xmath36 of length @xmath177 . to implement @xmath176",
    ", we use the same @xmath129 automaton presented in previous section to build the tree @xmath176 , but with two differences : we only need forward transitions and the length of any pattern is bounded by @xmath200 .",
    "thus the cost is upper bounded by @xmath201 , where @xmath0 is the time needed to do an operation on the predecessor data structure ( maximum of the times needed for inserts / deletes and searches ) we now turn our attention to the cost of the matching phase . from the previous section , we know that the total complexity in terms of number of symbol reading and comparisons is @xmath202 .",
    "the total cost of the matching phase is dominated by the multiplication of the total number of text symbols read multiplied by the cost of a transition in the @xmath129 automaton which itself is dominated by the time to do an operation on a predecessor data structure . the total cost of the matching phase is thus @xmath203 , where @xmath0 is the time needed to do an operation on the predecessor data structure .    now",
    "the performance of both matching and building phases crucially depend on the used predecessor data structure .",
    "if a binary search tree is used then @xmath204 and the total matching time becomes @xmath205 , and the total building time becomes @xmath206 .",
    "however , we can do better if we work in the word - ram model .",
    "namely , we can use the atomic - heap ( see section  [ sec : tools ] ) which would add additional @xmath207 words of space and support all operations ( queries , inserts and deletes ) in constant time on sets of size @xmath208 . in our case",
    ", we have a set of size @xmath209 and thus the operations can be supported in constant time .",
    "we thus have the following theorem :    [ theoall2 ] searching for a consecutive motif @xmath74 in a permutation @xmath100 can be done in average @xmath210 time .",
    "we prove in this section a lower bound on the average complexity of any consecutive motif matching algorithm .",
    "the proof of this bound is inspired by that of yao @xcite which proved on average lower bound of @xmath211 for matching a pattern of length @xmath3 in a text of length @xmath22 , both taken on a alphabet @xmath212 .",
    "we prove in our case of interest an average lower bound of @xmath213 considering all permutations over @xmath214 $ ] to be equiprobable . as this average complexity",
    "is reached by the algorithm we designed in the previous section , this bound is tight .",
    "we begin to circumscribe our problem on small segments of length @xmath215 of the text into which we search for .",
    "precisely , following @xcite , we divide our text in @xmath216 contiguous and no - overlapping segments @xmath217 , such that @xmath218 when searching for a pattern in @xmath0 , there might be occurrences overlapping two blocks .",
    "but as we are interested on a lower bound , the following lemma allows us to focus on all segments .",
    "[ pre - counting lemma-1 ] a lower bound for finding a pattern @xmath2 inside all segments @xmath219 is also a lower bound to the problem of searching for all occurrences of @xmath2 in @xmath0 .",
    "we now prove that instead of focusing on all segments @xmath219 , we can focus on obtaining a lower bound to search @xmath2 in any single segment and then extend the lover bound on searching for @xmath2 inside this segment to searching for @xmath2 inside all segments , and thus , using the previous lemma , to the whole text .",
    "[ pre - counting lemma-2 ] the average time for searching for @xmath2 inside all segments @xmath219 is @xmath220 times the average time for searching for @xmath2 inside any such segment .",
    "let @xmath221 be the average complexity for searching @xmath2 in any segments .",
    "using the previous lemma , the whole average complexity is @xmath222    we now prove a lower bound for @xmath221 , which , using the two previous lemma , gives us a lower bound for the whole problem .",
    "let @xmath223 the number of permutations of size @xmath3 that can be discarded using a sliding window of size @xmath3 over a text of size @xmath215 and checking only @xmath224 positions in this window .",
    "[ counting lemma ] let @xmath225 .",
    "then @xmath226    let us consider now the whole set @xmath227 of permutations of length @xmath3 which contains @xmath228 such permutations .",
    "given @xmath229 , this set is the union of two distinct set @xmath223 and @xmath230 that is the set of motifs discarded by a certificate of length l ( or by @xmath231 accesses ) and the others .",
    "for all pattern in @xmath232 the average complexity to be discarded is counted @xmath24 . for any other motif in @xmath233",
    "the average complexity is at least @xmath234 .",
    "the average complexity for discarding all patterns in @xmath227 is thus @xmath235 we aim to find @xmath236 that maximizes this expression when @xmath3 grows , which will provide us a lower bound for the whole average complexity .",
    "now let us consider a fixed @xmath236 .",
    "we need to lower bound @xmath237 .",
    "as @xmath237 decreases when @xmath223 increases , this lower bound is minimal when @xmath223 is as large as possible . then , as the counting lemma states that @xmath238 @xmath237 is minimal when @xmath239 we now arbitrarily impose @xmath240 . with the left constraint , @xmath241 .",
    "we want to compute @xmath236 such that @xmath242 let us impose @xmath243 .",
    "this allows us to approximate our equation using the classical formula @xmath244 where @xmath245 , @xmath246 and @xmath247 .",
    "it is easy to see that inequality ( 1 ) implies that @xmath248 converges and is dominated by its first term which is bounded @xmath249 .",
    "we thus deduce that @xmath250 $ ] which implies that @xmath251 . from @xmath252",
    "$ ] , we obtain @xmath253 . by replacing @xmath254 and @xmath81 in @xmath255",
    "we get : @xmath256 we prove in appendix that @xmath257 with @xmath258 verify these two inequalities and inequality ( 1 ) .",
    "thus @xmath259 is a lower bound of the whole average complexity for searching for a consecutive motif in a permutation .",
    "we would like to thanks carine pivoteau , cyril nicaud and elie de panafieu for checking parts of our calculus .",
    "10    m.  adelsonvelskii and e.m .",
    "defense technical information center , 1963 .",
    "s.  ahal and y.  rabinovich . .",
    ", 22(2):629649 , 2008 .",
    "a.  v. aho and m.  j. corasick .",
    "efficient string matching : an aid to bibliographic search .",
    ", 18(6):333340 , 1975 .",
    "a.  andersson and m.  thorup .",
    "dynamic ordered sets with exponential search trees .",
    ", 54(3):13 , 2007 .",
    "r.  bayer .",
    "symmetric binary b - trees : data structure and maintenance algorithms .",
    ", 1(4):290306 , 1972 .",
    "p.  bose , j.f.buss , and a.  lubiw .",
    "pattern matching for permutations .",
    ", 65(5):277283 , 1998 .",
    "deterministic sorting in o(nlog log n ) time and linear space . in _ stoc _",
    ", pages 602608 , 2002 .",
    "morris and vaughan  r. pratt . a linear pattern - matching algorithm .",
    "technical report , univ . of california , berkeley , 1970 .",
    "s.  kitaev . .",
    "springer , 2011 .",
    "m.  kubica , kulczyski , j.  radoszewski , w.  rytter , and t.  wale . a linear time algorithm for consecutive permutation pattern matching . , 2013 .",
    "to appear .",
    "g.  navarro and k.  fredriksson .",
    "average complexity of exact and approximate multiple string matching .",
    ", 321(2 - 3):283290 , 2004 .",
    "i.  simon .",
    "string matching algorithms and automata . in j.  karhumki , h.  maurer , and rozenberg g , editors , _",
    "results and trends in theoretical computer science _ , number 814 in lncs , pages 386395 , 1994 .",
    "p.  van emde  boas .",
    "preserving order in a forest in less than logarithmic time and linear space .",
    ", 6(3):8082 , 1977 .",
    "d.  e. willard . examining computational geometry , van emde boas trees , and hashing from the perspective of the fusion tree .",
    ", 29(3):10301049 , december 1999 .",
    "a.  c. yao .",
    "the complexity of pattern matching for a random string .",
    ", 8(3):368387 , 1979 .",
    "' '' ''      * point 1 . *",
    "we adapt the technique of @xcite to our framework .",
    "let @xmath260)$ ] a backward transition from @xmath81 to @xmath99 such that @xmath261 .",
    "then @xmath262 is order - isomorphic to the suffix of @xmath92 of length @xmath263 .",
    "but either ( a ) @xmath264 is not order - isomorphic with @xmath92 , or ( b ) @xmath265 ( @xmath81 is the last state of the automaton .",
    "let @xmath266 we prove now _ a contrario _ that no other backward transition @xmath267)$ ] such that @xmath268 can accept the same difference @xmath269 .",
    "let @xmath270)$ ] be such a transition and consider without lost of generality that @xmath271 then @xmath272 would be order - isomorphic to the suffix of @xmath273 of length @xmath274 , and @xmath275 must not be order - isomorphic to @xmath276 however , as @xmath277 @xmath275 is a prefix of @xmath278 and as @xmath279 @xmath262 is order - isomorphic to the prefix of @xmath92 of length @xmath280 , which is exactly @xmath281 this leads to a contradiction and for a given @xmath282 there exists at most one backward transition @xmath283 ) , q\\geq 2 $ ] such that @xmath284 .",
    "this bounds the number of such backward transition to @xmath285 .",
    "let @xmath286 be the number of backward transitions @xmath260)$ ] from @xmath81 such that @xmath287 .",
    "* point 2 .",
    "* we consider now all backward transitions @xmath288)$ ] reaching state @xmath24 .",
    "we denote such a transition a 1-transition .",
    "note that state @xmath76 is never reached by any transition because any two integers are always order - isomorphic .",
    "the key observation is that from each state @xmath81 source of the transition , the number of such 1-transitions from @xmath81 is bounded by @xmath289 this is true since 1-transitions and other transitions must be interleaved to cover @xmath290.$ ] therefore , as the total number of @xmath286 is bounded by @xmath285 , the number of 1-transitions is bounded by @xmath291          searching for @xmath2 in @xmath0 using the forward automaton of @xmath2 can be easily done reading all symbols of the text one after the other .",
    "but at each state one must identify the right outgoing transition , which normally requires to search in a list or an avl tree .",
    "this would add a polylog factor to all integer reading and thus the complexity would be of the form @xmath293 however , the structure of the forward automaton combined with the fact that we imposed all outgoing transitions of each node to be sorted increasingly to the length of the transition allow us to amortize the search complexity of the searching phase along the permutation .",
    "the resulting search phase complexity is @xmath101 time .",
    "indeed , let us search @xmath0 through the automaton , reading one symbol at a time reaching a current state @xmath81 .",
    "let us assume we read the text until position @xmath5 and we want to match @xmath294 .",
    "we test if @xmath294 belongs to the interval @xmath295 $ ] labeling @xmath296)$ ] if @xmath112 .",
    "if yes , we follow this forward transition .",
    "if not , we test each backward transition from @xmath81 in increasing length order .      the important point to notice",
    "is that after having identified the right backward transition from @xmath81 for @xmath294 reaching state @xmath99 ( there must be one ) , the search for @xmath299 starts from @xmath300 moreover , we associate all @xmath231 transitions @xmath301)$ ] touched before finding the right one to its ending state which verifies @xmath302 .",
    "thus @xmath303 .",
    "this point is illustrated in figure [ forwardcomp ] . as the search starts again from @xmath99 and that at most one forward transition is passed through by text symbol , the total number of forward and backward transitions touched or passed through when reading the whole text @xmath304 is thus bounded by @xmath305 .        .",
    "exactly as in the case of a classical text , we amortize the complexity of the search over the number of transitions we pass through and the number of reinitialisations of the search we do if no more failure transition is available . each time we pass through a failure transition",
    ", we decrease the state from where we will go on the search if the state is validated .",
    "thus , there can be at most as many failure transitions passed through during the whole reading of the text as the number of forward transitions that has been passed through .",
    "since this number is at most the size of the text , the total number of transitions touched is at most @xmath305 .",
    "then , if after a descent from failure transition to failure transition no more outgoing transition exists , we reinitialise the search to state 1 .",
    "thus there are at most @xmath22 such reinitialisations and the total complexity of transitions and states touched is bounded by @xmath306 .        before processing ,",
    "the pattern we first reduce the range of the keys from @xmath1 $ ] to @xmath307 $ ] .",
    "this is done in deterministic @xmath308 times by first sorting the keys using the fastest integer sorting algorithm due to han  @xcite , and then replacing each key by its rank obtained from the sorting .",
    "we then process the pattern in left - to - right in @xmath3 steps and at each step @xmath59 determine the failure and forward transitions outgoing of state @xmath59 .",
    "we use two predecessor data structures that require @xmath13 words of space and support insert , delete and query operations ( a query operation returns both the predecessor and the successor ) in ( worst - case ) time @xmath309 .",
    "as we move forward in the pattern , we insert each symbol in both predecessor data structures ( except for the first symbol which is only inserted in the first predecessor data structure ) .",
    "the difference between the two predecessor data structures is that the first one will only get insertions while the second one can also get deletions .",
    "the first is used to determine forward transitions while the second one is used to determine failure transitions .",
    "we now show how we determine the transitions at each step @xmath59 .",
    "the forward transitions connecting state @xmath59 to state @xmath77 is labeled by @xmath78 .",
    "the latter is determined by doing a predecessor search for @xmath310 on the first predecessor data structure .",
    "this gives us both the predecessor and successor of @xmath310 among @xmath311 which is exactly @xmath78 .",
    "the failure transition is determined in the following way . if the target state of the failure transitions of state @xmath312 is state @xmath5 .",
    "then we do a predecessor query on the the second predecessor data structure .",
    "if the pair of returned prefixes is precisely @xmath313 , then we can make @xmath314 as a target for state @xmath59 .",
    "otherwise we take the failure transition of state @xmath312 .",
    "if that transitions leads to a state @xmath170 , then we remove the symbols @xmath315 from the second predecessor data structure .",
    "we first build the morris - pratt representation in @xmath308 time .",
    "we then consider each state @xmath316 corresponding to the @xmath317 from left to right and for each such state we expand its backward transitions .",
    "let us sort all @xmath93 and consider the resulting order @xmath318 .",
    "we build one outgoing transition for each interval @xmath95 $ ] , excepted if @xmath96 this transition is computed as follows .",
    "let @xmath99 be the image state of the failure transition from @xmath81 .",
    "we pick a value @xmath319 in @xmath95 $ ] an search for @xmath319 from @xmath99 .",
    "let @xmath280 be the new state reached .",
    "we create a backward transition form @xmath81 to @xmath280 labeled @xmath95 $ ] . after this process we created at most @xmath320 edges in at most @xmath126 time .",
    "we now merge backward transitions from the same state to the same state that are labeled by consecutive intervals .",
    "this required at most @xmath321 time .",
    "the whole algorithm thus requires @xmath322 time .",
    "let a be an algorithm to search for @xmath2 in @xmath0 running in @xmath323 time .",
    "it can be converted in an algorithm to search for @xmath2 inside all @xmath219 also running in @xmath324 since : ( a ) it suffices to remove all occurrences overlapping two segments and occurrences in the last few remaining symbols of @xmath0 out of a segment ; and ( b ) in @xmath323 time , only at most @xmath323 such occurrences can be reported , so only @xmath323 occurrences might have to be discarded ; and ( c ) testing if an occurrence is overlapping two segments can be done in constant @xmath323 time .",
    "the extra work required to remove all overlapping occurrences is therefore also @xmath323 , and thus @xmath194 can be converted in an @xmath323 algorithm to search for @xmath2 inside all segments @xmath219 .",
    "this implies that a lower bound for this last problem is also a lower bound for a.        all segments @xmath219 are identically distributed , independently of each other .",
    "thus the average time for searching for @xmath2 in any segment is the same .",
    "as the expected time is the sum of the expected time to search for @xmath2 in all segments , the sum commutes and the expected time becomes @xmath220 times the average expected time to search for @xmath2 in any segment .",
    "let @xmath325 be the position of the accesses .",
    "for @xmath326 we define @xmath327 note that @xmath328 for @xmath329 .",
    "also , for any @xmath330 , since it is canceled by the @xmath160 accesses considering isomorphic orders , for all shift @xmath59 there is a mismatch , _",
    "i.e. _ there exists two positions @xmath331 such that @xmath332>p[\\ell]$ ] and @xmath333 < t[j+\\ell]$ ] .",
    "we then show that we can find @xmath334 @xmath335 , such that @xmath336 for @xmath337 in @xmath338 .",
    "we use a greedy procedure to find @xmath338 .",
    "let @xmath339 .",
    "inductively , suppose that we have found @xmath340 .",
    "then @xmath341 is obtained by finding the smallest @xmath59 such that @xmath342 is disjoint from the unions of the previous positions we have already chosen , namely @xmath343 we claim that this procedure allows us to find at least @xmath344 such sets .",
    "we prove in fact that @xmath345 as long as @xmath346 .",
    "observe that @xmath347 contains at most @xmath348 positions .",
    "we thus claim that at least one of the sets in @xmath349 is disjoint from @xmath347 .",
    "if not , for each @xmath128 , @xmath350 there exists a pair @xmath351 such that @xmath352 and @xmath353 for some @xmath354 .",
    "so there must exists at least @xmath355 such pairs , one for each set @xmath356 .",
    "but the total number of such pair is no more than @xmath357 , a contradiction .",
    "now take @xmath358 @xmath359 , such that @xmath336 for @xmath360 in @xmath338 . to prove the lemma , consider a random pattern @xmath2 from @xmath361 ( the set of permutations of size @xmath3 ) .",
    "then for all shift @xmath362 , there is a mismatch .",
    "so @xmath363 notice that for each @xmath364 , the probability that there is no mismatch with @xmath2 at shift @xmath59 is @xmath365 which is the probability that the permutation formed by the non-@xmath366 symbol is the good one . since all the sets @xmath342 for @xmath367 are disjoints , we have @xmath368 concluding the proof since @xmath369 ."
  ],
  "abstract_text": [
    "<S> let @xmath0 be a permutation ( that shall play the role of the _ text _ ) on @xmath1 $ ] and a pattern @xmath2 be a sequence of @xmath3 distinct integer(s ) of @xmath1 $ ] , @xmath4 . </S>",
    "<S> the pattern @xmath2 occurs in @xmath0 in position @xmath5 if and only if @xmath6 is order - isomorphic to @xmath7 , that is , for all @xmath8 , @xmath9 if and only if @xmath10 . searching for a pattern @xmath2 in a text @xmath0 consists in identifying all occurrences of @xmath2 in @xmath0 . </S>",
    "<S> we first present a forward automaton which allows us to search for @xmath2 in @xmath0 in @xmath11 time . </S>",
    "<S> we then introduce a morris - pratt automaton representation of the forward automaton which allows us to reduce this complexity to @xmath12 at the price of an additional amortized constant term by integer of the text . </S>",
    "<S> both automata occupy @xmath13 space . </S>",
    "<S> we then extend the problem to search for a set of patterns and exhibit a specific aho - corasick like algorithm . </S>",
    "<S> next we present a sub - linear average case search algorithm running in @xmath14 time , that we eventually prove to be optimal on average . </S>"
  ]
}