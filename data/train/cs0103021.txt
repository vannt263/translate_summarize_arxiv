{
  "article_text": [
    "clock synchronization is a well studied problem with many practical and scientific applications . in the special theory of relativity",
    "there are two standard methods for synchronizing a pair of spatially separated clocks , einstein synchronization @xcite and eddington s slow clock transport @xcite .",
    "recently , two new quantum protocols have been proposed for synchronizing remote clocks .",
    "the first one uses prior quantum bit entanglement between the two parties and was proposed by _",
    "jozsa et al _ @xcite .",
    "this protocol is based on the assumption that the entanglement can be achieved without any relative phase error .",
    "however , the validity of this assumption has been discussed and questioned in a number of papers @xcite . once and if this entanglement can be obtained , their algorithm determines the time difference @xmath0 between the clocks by essentially monitoring the oscillation of a function @xmath4 , and thus requires @xmath5 shared singlets .",
    "the second protocol was proposed by _",
    "i. chuang _",
    "@xcite , and obtains @xmath0 to @xmath1 bits of accuracy by communicating only @xmath6 qubits and using an @xmath2 range of frequencies . after communicating the bits according to his protocol , they are in the state corresponding to the fourier transform ( over @xmath7 ) of the state @xmath8 , for some fixed and known @xmath9 . as a result , one can apply an inverse fourier transform and subsequently measure the value of @xmath10 and hence @xmath0 .    in this paper",
    ", we improve significantly on chuang s result by presenting an algorithm that is able to calculate @xmath0 to @xmath1 bits of accuracy while communicating only one qubit in one direction and using an @xmath2 range of frequencies .",
    "further , we prove that , under our computational model , the product of the frequency range and the number of transmitted qubits must be @xmath3 , and conclude that our algorithm is optimal in this model .",
    "in our protocol alice sends a photon @xmath11 to bob with some tick rate @xmath9 .",
    "the state of the received photon is @xmath12 , where @xmath13 is the time the photon spent in transit and @xmath14 is the pauli matrix @xmath15}.\\ ] ] even though we only use one - way communication from alice to bob , for the purposes of proving computational lower bounds we assume an even stronger model , where the two parties can exchange photons back and forth .",
    "the information they get about the time difference @xmath0 between the two clocks comes from a phase change in the state of the qubit , which depends on @xmath0 and the tick rate @xmath9 .",
    "let s now define this procedure and see how we can actually implement it .",
    "the input to this procedure will be a quantum register which holds the tick rate @xmath16 and a qubit @xmath11 .",
    "the output is a state that has a phase which depends on @xmath0 and @xmath16 .",
    "let tqh be a black box quantum procedure defined by the equation @xmath17 where @xmath0 is the time difference between the two parties and @xmath18 is a known base tick rate .",
    "this is a very reasonable and powerful model , since we know that all the information one can get about the time difference via such photon communications is in the form of a relative phase change . here",
    "the first register handles the tick rate of the photon to be transmitted and the second register is the photon that alice communicates to bob ( or bob to alice ) .",
    "the implementation of this black box is based on the ticking qubit handshake protocol ( tqh ) described in i. chuang s paper @xcite .",
    "suppose alice wants to create the state @xmath19 .",
    "she first sends the qubit @xmath11 to bob with ticking rate @xmath20 . along a classical channel",
    "she also tells him her time @xmath21 at the moment of the quantum communication .",
    "bob receives at time @xmath22 ( according to bob s clock ) a quantum state @xmath23 , where @xmath24 is the time the qubit spent in transit .",
    "finally , bob applies a phase change @xmath25 and thus the final state of the qubit is @xmath26 .",
    "we are going to describe a protocol for synchronizing two remote clocks by communicating one photon . in this algorithm , alice starts by preparing a register @xmath27 of @xmath1 qubits in a certain superposition . then she sends a photon to bob with the superposition of tick rates specified in @xmath27 .",
    "bob measures the received photon and alice obtains @xmath0 to @xmath1 bits of accuracy by processing a phase estimation on @xmath27 .    in more detail ,    1 .",
    "alice starts with a register of @xmath1 qubits initialized to @xmath28 , and after applying a fourier transform to them she obtains @xmath29 she also prepares a photon with polarization state @xmath30 .",
    "alice now transmits the prepared photon with the tick rate described by her first register .",
    "if the photon had a definite tick rate @xmath16 and polarization state @xmath11 the final state would be @xmath31 . since the register described in step 1 is in a superposition of tick rates , the outcome will be in a superposition of states @xmath32 3 .",
    "bob measures the received photon .",
    "assuming without loss of generality that the outcome is @xmath28 , alice s register @xmath27 becomes @xmath33 4 .",
    "alice then applies an inverse fourier transform , obtaining the state @xmath34 in @xmath27 .",
    "it is easy to see that this algorithm is an application of the general procedure known as _ phase estimation_. in this procedure , we assume a unitary operator @xmath35 with an eigenvector @xmath36 and eigenvalue @xmath37 .",
    "the goal is to estimate @xmath38 to @xmath1 bits of accuracy . to perform the estimation we start with two registers , the first one in a uniform superposition over all states in @xmath7 and the second one in the state @xmath36 .",
    "then we apply the unitary operation @xmath35 to the second register @xmath39 times , where @xmath40 is the content of the first register . by analyzing the performance of this procedure",
    "it can be seen that our algorithm obtains @xmath0 to @xmath1 bits of accuracy with constant probability @xmath41 .",
    "we can boost the probability of success to @xmath42 by increasing the size of the first register to @xmath43 .",
    "further analysis can be found in @xcite , page 221 .",
    "in this section we will prove a lower bound on the product of the range of tick rates ( frequencies ) we use and the number of qubits we communicate .",
    "if a quantum algorithm in the tqh model makes only queries to the black box with a single tick rate @xmath9 , then it must make a total number of @xmath3 queries in order to obtain @xmath0 to @xmath1 digits of accuracy .    by making a query to the black box ,",
    "the input @xmath48 will become @xmath49 ; after applying a hadamard transform we obtain the quantum state @xmath50 from this we see that the problem of determining @xmath0 is equivalent to estimating the amplitude of @xmath28 ( or @xmath51 ) . the problem of estimating the amplitude of a quantum state , which is equivalent to the problem of counting the number of solutions to a quantum problem , is well - studied @xcite . in @xcite",
    "they prove that @xmath52 queries are required for a @xmath53-approximate count , where @xmath13 is the number of solutions , @xmath54 is the set of possible inputs and @xmath53 defines the closeness of the approximation .",
    "if we use this lower bound for the case of amplitude estimation , we get a lower bound of @xmath55 , since the amplitude is @xmath56 . in our case , @xmath57 can take any value in @xmath58 , @xmath53 must be less than @xmath59 and @xmath60 , so we obtain the lower bound of @xmath3 qubits .",
    "+      suppose we are able to query the black box with frequencies in the range @xmath61 $ ] .",
    "we claim that this black box can be simulated by a black box with only one tick rate @xmath9 at the cost of replacing each query with at most @xmath45 queries .",
    "this can be done since one query to the @xmath61 $ ] black box with tick rate @xmath62 is equivalent to @xmath16 consecutive queries with tick rate @xmath9 , using the output of one query as the input to the next .",
    "notice that a superposition of queries to the @xmath61 $ ] black box does not pose any challenge to the simulation , since we can also query the one - tick rate black box in a superposition of times .",
    "for such an input , the number of queries is defined to be the maximum over all states of the superpositions .    since in all cases",
    "we query the black box at most @xmath45 times , this means that the one - tick rate version will run with at most @xmath63 queries . now , in lemma 1 we have already proved that when we use only one tick rate , we need to communicate at least @xmath3 qubits , and therefore @xmath64 ."
  ],
  "abstract_text": [
    "<S> the clock synchronization problem is to determine the time difference @xmath0 between two spatially separated parties . </S>",
    "<S> we improve on i. chuang s quantum clock synchronization algorithm and show that it is possible to obtain @xmath0 to @xmath1 bits of accuracy while communicating only one qubit in one direction and using an @xmath2 frequency range . </S>",
    "<S> we also prove a quantum lower bound of @xmath3 for the product of the transmitted qubits and the range of frequencies , thus showing that our algorithm is optimal . </S>"
  ]
}