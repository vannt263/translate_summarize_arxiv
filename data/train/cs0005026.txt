{
  "article_text": [
    "mobile agents are a promising technology that could improve performance over the classical client / server model in distributed application scenarios @xcite and world - wide communications .",
    "it is well known that agents offer important benefits in distributed environments . amongst other things ,",
    "mobile agents reduce network load , overcome network latency , encapsulate protocols , are executed asynchronously and autonomously , adapt dynamically , are heterogeneous and are fault - tolerant @xcite .",
    "mobile agents are also used to search for distributed information @xcite , in electronic commerce @xcite , network management ( service reconfiguration , mobility ) @xcite , control @xcite , monitorization , information streams automation , active networks @xcite and active documents .",
    "looking at security , mobile agents have a flaw .",
    "they are vulnerable to attacks from malicious nodes and other agents in the network .",
    "a data protection scheme developed to reduce security risks in distributed environments will be presented in this work .",
    "mobile code based computing requires data management models that allow information to be protected against both potential malicious _ peer hosts _",
    "( remote hosts in the network ) and hostile agents that could falsify and destroy data collected by other agents or stored in nodes in the _ information network_. furthermore , peer hosts and mobile code requires code area , execution thread and data part all to be protected against both unauthorized disclosure and modification of information and _ denial of service _ ( dos ) attacks @xcite . in fact , comparable protection requirements should be implemented on hosts and mobile code @xcite .",
    "protection of hosts could be easily solved using classical protection strategies like firewalls and unpermissive access control policies ; some examples are the use of _ access control lists _",
    "( acls ) and independent address spaces . however security of agents require the development of new protection algorithms because information will be managed in untrusted environments .",
    "it is known that when mobile code arrives to a remote host it can be completely examined by the host before running . at this moment , the remote host could counterfeit or erase retrieved data to hide important information to the server that has sent the mobile code . a classical approximation to solve this problem",
    "is the use of _ cryptography_. in conventional cryptographic algorithms a single key is used for both encryption and decryption .",
    "such systems , also known as _ symmetric _",
    ", require the key to be stored on a safe place . obviously , symmetric cryptosystems are not suitable to protect information collected by mobile code if the encryption key needs to be conveyed with mobile code",
    ". _ asymmetric ciphers _ ( public - key cryptosystems ) are a better choice to protect information against malicious hosts , but are too slow and sometimes allow detectable patterns in a message to survive the encryption process making the technology vulnerable to cryptanalysis . to prevent this weakness , public - key ciphers should hide these patterns by standard compression of the message before encryption @xcite .",
    ".operators used in this paper [ cols=\"<,<\",options=\"header \" , ]     now , we are going to explain the propagation of keys .",
    "each host in the network that wants to provide some information must create a random one - time key that will be used to digitally sign or encrypt just one message using the function ` genkey`@xmath0 . in figure [ genkey ] appears the random one - time keys generator proposed to create valid keys to protect new registers for a mobile agent .",
    "the one - time key created by the host will be applied to the message using the function ` protectmsg`@xmath0 .",
    "figure [ protectmsg ] provides a description of the algorithm used to protect data provided by peer hosts to the agent .",
    "the function ` genkey`@xmath0 will assure that this key could not be applied to other messages in the mobile code data area before accepting it .",
    "this restriction ensures that messages signed or encrypted by remote hosts will be easily identified .",
    "these keys will be shared with the agent server through a secure channel when data encryption is required .",
    "when the agent is traveling in the network , keys must not be provided to other hosts , in particular to the server that has sent it , because information is vulnerable to attack or damage in untrusted nodes .",
    "the protocol described in this article allows to establish a link between the agent server and remote hosts in the network using the function ` reqkeys`@xmath0 to get copies of the applied keys when the agent returns to the server that has dropped it . whenever an agent server requests the used keys to a remote host , after sending them to the server , they must be removed by the generating host by using the function ` removekeys`@xmath0 .",
    "if we forecast that mobile agents may travel through more than one information network in the same trip , we must assure that keys will be used only one time .",
    "it is highly unlikely , but possible , to sign or encrypt two messages using the same key .",
    "we could think that mobile code could verify this fact , but only if it does not imply to carry a copy of the used keys in the mobile code data area .",
    "it is possible to check keys generated by each peer host by trying to match it with every register carried by the mobile code . that a random one - time key matchs a register does not mean that we have obtained a key used by other host as it will be shown below , but to assure security this key",
    "must be discarded .",
    "figure [ checkmsg ] shows an algorithm that could be used to authenticate and decrypt the registers stored in the mobile agent data area using the keys created by the remote hosts . upon the return of the agent",
    ", these keys will be delivered to the server that owns it using the function ` sendkeys`@xmath0 .    to prevent attacks trying to discover",
    "the keys at use , previously used cryptographic keys will not be applied again . instead of using the old key a new one",
    "will be generated to sign or encrypt a message .",
    "as commented above , each peer host should check that its own generated cryptographic keys could not be applied to other registers .",
    "the check will be performed by trying to apply these keys on the registers stored in the mobile agent internal table .",
    "this condition assures that the host that signed the data will be identified without problems by the server that generated the agent .",
    "at this moment we have a way to share encryption keys between remote hosts in the information network and the agent server .",
    "as shown above , each register provided by a peer host will be digitally signed or encrypted using a different one - time key .",
    "these keys will be sent to the agent server after the return of the agent . on this section",
    "we will show how to digitally sign and encrypt information provided by remote hosts and how to authenticate information retrieved using these shared keys .      in the following subsection , we are going to describe a detailed information management in peer hosts , showing how to digitally sign and encrypt data provided by remote hosts .",
    "a scheme to protect data against `` a mobile code brainwash '' based on logging the agent route in external servers and use one - time keys will be examined too .",
    "figure [ process-1 ] is an overview of the process of digital signature and encryption of data .",
    "remote hosts should protect data provided by encrypting or , at least , digitally signing its own information fields before releasing the mobile agent . as shown above , they could digitally sign its own data with a 128-bit key or encrypt it using a cryptographic 128-bits key greater than the data field size ( as shown in table [ keys ] ) .",
    "the length field ( len ) will store the data field length .",
    "this field is needed to provide a most flexible communication protocol supporting messages of arbitrary size .",
    "it is also needed because we have no way to define an end - of - message code for our communication protocol if encryption is a requeriment .    *",
    "_ digital signature .",
    "_ digital signature of information will protect data against handling by other hosts in a safe way but allowing reading .",
    "digital signature of information does not permit counterfeited information to be carried by mobile code and , as will be shown below , to remove information provided by peer hosts .",
    "this is because digitally signed fields can only be validated with the encryption keys requested to the peer hosts by the agent server .",
    "it is possible because the algorithm shown in this article uses a random 64-bit block that must be generated for each message digitally signed by a remote host .",
    "this random block is never sent as plain - text .",
    "this random field will be called _ codeword _ ( cw ) along this work . only a host",
    "that have a copy of the used key intended to cover the codeword and the message field digest could easily authenticate information provided by remote hosts and identify simultaneously the host that digitally signed it .",
    "a host that does not have a copy of either the encryption key or the codeword ( therefore it could not obtain the message field digest that depends on the data field and the codeword itself ) will have @xmath1 possible combinations that could be valid to digitally sign the message .",
    "we have no way to know which key has been used to protect a message . *",
    "_ data encryption .",
    "_ information could be easily changed in a way that does not permit to recover blocks of the message and/or the encryption key applied . if a server provides predictable data this fact could not be used by a malicious host to change the message contents .",
    "the message field digest will be obtained in the same manner as in the process of digital signature but now the key used to protect the register covers the data , codeword and message digest fields .",
    "this key is nothing but the _ encryption key _ in this article and obviously will need to be sent to the agent server by means of a secure channel .",
    "the agent server could apply these encryption keys provided by peer hosts to the encrypted registers to recover the original message that will be checked in the same way as the digital signature .",
    "let us suppose a mobile agent returns to a peer host and needs to change some information previously posed in the agent data area .",
    "trying to decrypt the messages , this host can look for its own registers using the encryption keys generated to protect the messages .",
    "this condition should be checked with the message field digest . to prevent data erasing",
    ", remote hosts must generate a new random key to sign the message discarding the key currently used .",
    "in other case , a brute force attack against both the old and the new messages would be possible making the protection algorithm vulnerable . in the case a peer host needed to remove a register it could look for it in the same way , remove it from the mobile agent data area and erase the key used to protect the register itself so that it will not be sent to the agent server in the future .",
    "a message field digest will protect each register .",
    "the algorithm proposed to generate and hide the message field digest is easy to implement in any programming language and is fast , allowing a peer host to process big volumes of information quickly .",
    "let us take a look to figure [ process-1 ] .",
    "the data field must be splitted in 64-bit blocks .",
    "the number of blocks that are needed to split a message is stored in the message length field and will be used to determine the message length even if encryption is requested .",
    "the field digest is set to zero and then the next algorithm must be applied to each 64-bit block :    1 .   as shown in figure [ process-2 ]",
    "the @xmath2-th 64-bit block must be rotated @xmath3 bits to the left in , where @xmath3 is obtained from the six least significant bits of the codeword field .",
    "the rotated field will be stored in the message field digest using an exclusive - or bitwise operator .",
    "the codeword field itself is rotated @xmath4 bits to the right , where @xmath4 is provided by the six most significant bits of the codeword .",
    "this operation over the codeword field will assure that the rotation of the next 64-bit field , the @xmath5-th 64-bit block , could not be found .",
    "after obtaining the field digest , the codeword field must be overwritten with the unrotated codeword , as shown in making easier to check register integrity using the same routine for both encryption ( or digital signature ) and decryption ( or authentication of information ) . at last",
    ", the codeword and the field digest will be protected with the random one - time key ( a 128-bit key for digital signature or a key 128-bit greater than data field length for encryption ) using an exclusive - or bitwise operator hiding its contents as shown in .",
    "figure [ process-2 ] shows how fields will be rotated to generate the message digest and how this field is protected against reading by unauthorized hosts .",
    "the digital signature and encryption algorithm presented in this article is really quick and effective with respect to computational requirements .",
    "information provided by peer hosts must be protected against both counterfeit and erasing .",
    "the former could be avoided using digital signature or data encryption techniques as described above .",
    "the latter requires a way to log agent activities in the network .",
    "obviously , this information could not be conveyed with the mobile agent because we can not protect it against unauthorized modification .",
    "should a mobile agent return to a malicious host , both data and log areas could be overwritten with a bitcopy of old data and log areas carried by the agent covering information provided since it was released for the first time by the hostile host . to workaround this problem",
    ", we propose to store this information in one or more remote _ route servers _",
    "figure [ route ] shows how rss could be used to log the routes followed by agents .",
    "this information could be sent to these servers over untrusted communication channels without risk .",
    "these servers will provide the route followed by each agent to the agent servers upon requested .    in our propousal",
    ", a host could delete its own information .",
    "as described above , in the case a peer host needed to remove some information previously provided to a mobile agent it would be able to erase the message field that must be eliminated and the one - time key used to protect the message itself simultaneously .",
    "this procedure will assure that the old one - time key will not be sent to the agent server in the future .",
    "if the agent server receives a key that could not be applied to a message stored in the mobile agent data area , the information provided by that agent could not be authenticated and then the ported data should be discarded .",
    "when a mobile agent returns to the server that has sent it , information coming from remote hosts must be authenticated and , if it was protected against reading by other hosts , decrypted .",
    "this server will request to the rss the agent route information and , after that , the keys used by the peer hosts .",
    "the agent server must try to apply all the cryptographic keys provided by the peer hosts to the registers collected by the mobile agent in order to try to identify the hosts that have signed the registers .",
    "as we have shown above , these cryptographic keys were generated in peer hosts and were not provided to other hosts in the network . as a consequence",
    ", they are supposed not to be compromised ( we are not talking about malicious people administrating these hosts ) . when the agent arrives to the server that has dropped it , keys could be requested over untrusted communication channels since the server that has sent the mobile agent already have a copy of the data provided by peer hosts and these keys will not be re - used .",
    "only the right key will match the message field digest and will decrypt the information if needed .",
    "this event can be easily checked using the algorithm depicted in figure [ checkmsg ] .",
    "this analysis must be applied to all the registers found on the data area .",
    "the scheme described in this article allows a mobile agent to return to a remote host an unlimited number of times even if it is a malicious one .",
    "a security related restriction imposed by the algorithm described is that a host can only change its own registers .",
    "it is easy to see that in any other case it is not possible to assure data integrity .",
    "mobile agents and peer hosts require to be protected against attacks from other agents and hosts in the network . in this section",
    "we will study the security of the communication protocol against brute force attacks and spoofing techniques intending to supplant a host identity .",
    "all strong password mechanisms proposed in the literature employ public - key techniques .",
    "the possibility of develop a symmetric cipher safe to brute force attacks has been posed in @xcite .",
    "our protection strategy is immune to off - line guessing . if encryption is requested , security of the protocol depends on the security of the communication channel used to share the symmetric one - time encryption keys and the security of the remote hosts that store the keys .",
    "a cryptosystem whose encryption key has the same length as the message to protect is invulnerable against off - line guessing attacks if we have a way to generate a perfect random one - time encryption key .",
    "suppose we have an @xmath6-bit length message and a perfect ( non predictable ) random encryption key with the same length .",
    "it is easy to see that we can establish a bijective relation between the bits of the message and the bits of the key .",
    "let us suppose that the @xmath2-th bit of the encryption key could change the state of the @xmath2-th bit of the message ; as a result , there are no statistical methods that any potential attacker could hope to use to infer detectable patterns in the message and that could allow the prediction of the final state of the bits in the message from the ciphertext , what is a simple consequence of information theory .",
    "it is worth to remark that unpredictable encryption keys are needed .",
    "a predictable ( or at least partially predictable ) encryption key will allow statistical attacks against the ciphertext trying to discover parts of the information provided .",
    "good random generators have been proposed in the bibliography @xcite .",
    "next proposition assures that registers are off - line guessing resistant .    for any given ciphertext @xmath7:i=1,2,\\ldots , n$ ] we can found an encryption key @xmath8:j=1,2,\\ldots , n$ ] that allows to hide an arbitrary message of the same length @xmath9:k=1,2,\\ldots , n$ ] using the cipher described in this work .",
    "we have an @xmath6-bit length ciphertext @xmath7:i=1,2,\\ldots , n$ ] obtained using an exclusive - or bitwise operator as described in subsection 3.1.1 ( here @xmath7 = a[i]\\,{\\rm xor}\\,b[i]:i=1,2,\\ldots , n$ ] where @xmath10 $ ] denotes the @xmath2-th bit of the message and @xmath11 $ ] labels the @xmath2-th bit of the encryption key ) .",
    "it is possible to hide an arbitrary message @xmath10:i = 1 , 2,\\ldots , n$ ] if we define the key as : @xmath12 = \\left\\ { \\begin{array}{ll }          0 & \\mbox{if $ a[i ] = c[i]$ } \\\\          1 & \\mbox{otherwise }         \\end{array }         \\right.\\ ] ] where @xmath13 .",
    "it is easy to see that off - line guessing could not be applied against digital signatures and encrypted data fields because we can not determine , using brute force attacks , what key has been applied to digitally sign the message .    for any given message we can obtain @xmath1 possible digital signatures . by using brute force attacks based techniques",
    ", we have no way to know what key has been applied .",
    "suppose we have a ciphertext @xmath7:i=1 , 2 , \\ldots , 128 $ ] provided with the message as digital signature .",
    "these ciphertext hides a codeword ( a random bitmap ) @xmath14:i = 1 , 2 , \\ldots , 64 $ ] and a message field digest @xmath15:i = 1 , 2 , \\ldots , 64 $ ] that depends on the codeword itself .",
    "it is easy to see that we have @xmath1 possible codewords and a message field digest for each codeword field .",
    "applying proposition 2 we can find a key for each pair @xmath16 that allows us to obtain the ciphertext @xmath17 .    as a consequence ,",
    "we conclude that off - line guessing based attacks against data protected using the algorithm described are not possible when digital signature of data is applied .",
    "if encryption of data is required , security depends on both classes of hosts ( peer hosts and the agent server ) and the communication channel used to provide copies of the encryption keys managed by the agent server .",
    "the current ip protocol technology ( ipv4 ) does not allow to eliminate ip - spoofed packets in the network .",
    "we are currently working in an ipv6-based protection scheme that will offer a better solution to this problem and will be presented elsewhere . to install filtering",
    "routers has been proposed as the best protection practice in @xcite but there is not a generally accepted solution to this threat yet .",
    "however for the seek of completeness a strategy based on filtering routers could be implemented as follows :    * _ input filters . _",
    "an input filter is a filtering router that will restrict the input to the external interface of the route server .",
    "this filter must block each package that has a source address belonging to the internal network but comming from outside eliminating in this way the possibility of superseding the identity of a internal host in the network . * _ output filters . _",
    "an output filter is a filtering router that will refuse all packages coming from inside and with an external source address avoiding then ip - spoofing attacks that could be originated from any host of the subnet .",
    "obviously filtering routers will work only when the network where hosts that provide information are placed is physically isolated from the external network .",
    "we should not assume that the peer hosts where agents will collect information are all in the same physical subnet .",
    "neither can we assume that all remote hosts are trusted .",
    "in fact , we can not protect hosts against spoofing techniques using filtering routers because the hosts receiving the mobile agent could be spreaded over the whole network .",
    "it is the mobility of the agent what breaks down the difference between internal and external .",
    "internet protocol version 6 includes aditional security features useful to protect mobile agents .",
    "it is then natural to implement in this context good anti - spoofing techniques based on authenticating the ip headers .",
    "security risks must be considered on the design of information networks based on mobile code . as noted by , mobile agents are extremely vulnerable to all kinds of attacks from potentially malicious peer hosts and agents once it leaves the agent server .",
    "weaknesses related with remote hosts and code protection ( for example , host protection against unauthorized accesses and dos attacks , host authentication and code protection against modification ) will not be treated here because are out of the scope of this work and have been extensively considered in the bibliography @xcite . in this section well known security risks related with data protection in mobile agents will be studied .",
    "security weaknesses related with mobile computing has been extensively considered in the bibliography . as mentioned above , one of the main problems here is that of agents which will be executed in untrusted nodes .",
    "these hosts will have full access to code and data areas of the agent ( and to the execution thread in mobile code too ) .",
    "security risks related with classical computing environments like off - line guessing attacks against the ciphertext are also present .",
    "some of these weaknesses can be itemized as :    _ attacks by hosts in the route of an agent .",
    "_ some protection schemes proposed in the bibliography @xcite rely on carrying keys that will be used to obtain _ partial result authentication codes _ ( pracs ) . after using them ,",
    "these keys will be destroyed ( simple mac - based pracs ) or changed by means of _ one - way functions _",
    "( mac - based pracs with one - way functions ) . in his work",
    ", bennet s. yee explains that the former could be easily attacked copying un - removed keys making vulnerable any host @xmath18 , where @xmath19 is the malicious host and @xmath20 is the last peer host in the mobile code route .",
    "the latter is based on calculating , when mobile code is going from host @xmath19 to host @xmath21 , the key @xmath22 where @xmath23 is a one - way function . a malicious host",
    "@xmath19 could get the key @xmath24 and obtain @xmath25 turning vulnerable the hosts @xmath26 .",
    "publicly verifiable pracs allow an agent itself to check the partial results obtained allowing computations that depend on previous partial results trying to detect any integrity violation of those results .",
    "this can be achieved without arriving at the server that has sent it .    _",
    "off - line guessing .",
    "_ as described above , symmetric ciphers require the keys to be stored in a safe place . in this case",
    ", keys must not be safely sent over untrusted channels .",
    "asymmetric ciphers allow public - keys to be sent over untrusted communication channels but exposing detectable patterns in a message that survive the encryption process making these public - key based ciphers vulnerable to cryptanalysis whenever the message is not compressed before encryption .",
    "both symmetric and asymmetric ciphers are vulnerable to off - line guessing ( brute force attacks against the ciphertext ) .    _ data erasing .",
    "_ all protection schemes applied to mobile agents allow information to be protected against counterfeit . these algorithms could be used to avoid data handling by non - authorized hosts in the network in the sense that information could not be modified , but sometimes they allow information to be partially or fully removed from the data area of the agent .",
    "our goal is to protect the registers in the data area for both agents and mobile code against counterfeit and erasing in a way that will be transparent to final users .",
    "the protection of the code area and the execution thread , if present , is beyond the scope of this article .",
    "exhaustive works dwelling on security concepts in mobile agents have been developed during the last years @xcite .",
    "these works are mainly devoted to protect the code area of mobile agents but not the data area that , as we mentioned above , will evolve dinamically when mobile agents travel over the network .    _",
    "attacks by hosts in the route of an agent . _",
    "the protection scheme proposed in this work does not require the keys to be sent with the mobile code . instead of this",
    ", each host will generate a random one - time key for digital signature or encryption of data .",
    "these keys will not be carried in the mobile code data area and will not be provided to other hosts .",
    "consequently , an agent can return to a previously visited peer host , including malicious hosts , safely .",
    "a remote host can not change data provided by any other host without invalidate the register carried by the mobile code .",
    "as we have extensively described , a mobile agent data area `` brainwash '' is not possible because the routes followed by agents will be registered by the rss .",
    "_ off - line guessing . _ some problems related with off - line guessing could not be avoided .",
    "if encryption is required , one - time keys used to protect data must be transmitted over secure channels ; as a result , data security depends on channel security . digital signature does not require keys to be transmitted using secure channels .",
    "as we already noted , keys will not be stored as a part of the agent data state and will then not be delivered to the agent server before the agent returns .",
    "we have already shown that keys could not be guessed using brute force attacks .    _ data erasing .",
    "_ a possible workaround could be to store information about the hosts visited in remote rss instead of in the mobile agent data area .",
    "each host that wants to provide information to the agent could protect itself sending its own network address to the rss proposed by the agent server .",
    "each host in the network could extract this information from the agent code area .",
    "redundant information could eventually be sent to the agent server when keys are requested and could also be used to rebuild the route followed by the agent .",
    "the protection algorithms applied to agents must satisfy the restrictions imposed by mobile agent based systems .",
    "a minimal interaction between the agent server and the agent itself is one of this restrictions .",
    "each host that provides information must be able to modify or remove its own registers without invalidate the agents .",
    "_ non - interactive protocol .",
    "_ the proposed data protection algorithm is based on a non - interactive protocol between the agent server and the mobile code . as a consequence , the server that has sent an agent have the possibility of going off - line .",
    "this is one of the main goals of a mobile code based system .",
    "so , the use of a non - interactive protocol reduces bandwidth requirements .",
    "_ keys do not need to be carried together with the mobile agent .",
    "_ our algorithm does not require keys to be carried with agents , but allows peer hosts to generate its own random one - time keys in a way that assures that they are completely new keys .",
    "it is important to notice that this does not mean that a brute force attack against ciphertext trying to discover used keys is possible .",
    "one might think that the freedom of a host to generate lots of keys could be a way of guessing and checking actually used keys but anyone of these would be one over @xmath1 possible choices .",
    "the only possibility the host has is that of being very lucky picking with a single trial the correct one among such a big set .",
    "the root of this indeterminacy is the fact that underneath of the 128-bit signature there is a random field we have called codeword and that affects to the message digest .    _ information could be changed .",
    "_ this algorithm is such that information provided by peer hosts could be changed when needed by the host that has generated it .",
    "it is interesting to compare our proposal with that of tschudin s @xcite that consists in appropiately linking an information with any other one coming from other hosts to accomplish that a malicious host will not be able to remove the signed data .",
    "this is because it can not forge the signatures of the other hosts .",
    "there is here an advantage in the sense that , in principle , rss are not needed .",
    "but there is a clear inconvenience because in the best case we can finally find ourselves with a message containing a lot of obsolete information that could not be removed by its owner .",
    "strong foundation is a requirement for future work in the topic of mobile agents @xcite . to design semantics and type - safety languages for agents in untrusted networks @xcite and supporting permissions languages for specifying distributed processes in dynamically evolving networks , as the languages derived from the @xmath27-calculus @xcite are important to protect hosts against malicious code .",
    "have shown that agents could be used for collaborative applications reducing network bandwidth requeriments .",
    "have proposed a way to obtain code privacy using non - interactive evaluation of encrypted functions ( eef ) .",
    "has proposed the possibility of use algorithms to `` mess up '' code .",
    "we are currently developing a public - key based cipher that will solve this problem using standard cryptographic tools but at a higher computational cost",
    ". the main advantage of this algorithm will be that it would avoid the need to wait for a network link to share a cryptographic key because all hosts in the information network and the server that has sent the mobile code would get copies of public - keys from a key server .",
    "these keys could be certified by a ca .",
    "we are working on a key propagation algorithm that will make easier to share public - keys in distributed environments .",
    "mobile and distributed computing requires new security schemes that do not depend on carrying cryptographic keys . during the past",
    ", information security was based on symmetric ciphers because cryptographic keys were stored in servers accessible only through firewalls and control access procedures .",
    "however , data management models are changing quickly .",
    "agent based computing is fundamental in networking environments and , as shown before , can not be based on classical protection schemes .",
    "our encryption method , as other cryptographic algorithms , obeys the following requeriments :    * _ it is not needed to hide the algorithm _ nor the digital signature keys , only the encryption keys must be protected against reading by unauthorized hosts ; * _ the encryption process must destroy statistical parameters _ and the structure and predictable patterns in the language ; * _ an error in the transmission should not destroy the rest of the information provided _ but , obviously , will invalidate the message digest .    the data management model shown in this article allows data signature and encryption in a way that only authorized hosts ( the server that has sent mobile code and the host that provides information ) could modify and certificate information retrieved then , at the same time , protecting data against `` mobile code brainwash '' by malicious hosts .",
    "the cryptographic algorithm described is faster and easier to implement on mobile code environments than public - key based ciphers that have a higher computational cost .",
    "other important property of this algorithm is that it does not allow brute force attacks against the ciphertext .",
    "the author would like to thank daro lvarez and jess arturo prez for introduce him in the distributed computing world .",
    "thanks go to m. a. r. osorio , diego rodrguez and jos luis ruz for many helpful comments and reviewing the draft of the article .",
    "the author greatly appreciate the department of mathematics of the university of oviedo for donating him forever a sparc workstation from sun microsystems that has been used in the current research ."
  ],
  "abstract_text": [
    "<S> a _ one - time pad _ ( otp ) based cipher to insure both data protection and integrity when mobile code arrives to a remote host is presented . </S>",
    "<S> data protection is required when a mobile agent could retrieve confidential information that would be encrypted in untrusted nodes of the network ; in this case , information management could not rely on carrying an encryption key . </S>",
    "<S> data integrity is a prerequisite because mobile code must be protected against malicious hosts that , by counterfeiting or removing collected data , could cover information to the server that has sent the agent . </S>",
    "<S> the algorithm described in this article seems to be simple enough , so as to be easily implemented . </S>",
    "<S> this scheme is based on a non - interactive protocol and allows a remote host to change its own data on - the - fly and , at the same time , protecting information against handling by other hosts .    </S>",
    "<S> [ distributed networks , network communications ] [ distributed applications ] [ distributed systems , information networks ] </S>"
  ]
}