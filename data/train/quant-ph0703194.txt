{
  "article_text": [
    "consider a probabilistic bit that equals 0 with probability @xmath0 .",
    "define the _ bias _ of the bit to be @xmath1 which is the difference between the probability that the bit equals 0 and the probability that the bit equals 1 .",
    "( the symbol `` @xmath2 '' is usually used to denote the bias in the literature on algorithmic cooling ; i prefer to reserve this symbol for error rates . )",
    "the problem addressed by algorithmic cooling is the following . given some number of bits initially having a common bias @xmath3 , distill out some smaller number of bits having greater bias .",
    "this should be accomplished without the need for any pure ancillary bits initialized to 0 , since preparing such initialized bits is the problem to be solved .",
    "also , we should assume that we can not perform measurements .",
    "algorithmic cooling has significant relevance to quantum computing , because for physical systems like nuclear spins controlled using nuclear magnetic resonance ( nmr ) , obtaining a pure initial state can be very challenging .",
    "it is this fact that has motivated recent research on the implementation of algorithmic cooling in nmr quantum computers , as well as theoretical investigations of the efficiency and performance of cooling algorithms .",
    "algorithmic cooling in the context of nmr quantum computation first appeared in @xcite .",
    "the authors presented a method for implementing _ reversible polarization compression _ ( rpc ) .",
    "the idea of rpc is to use reversible logic to implement a permutation on the ( classical ) states of @xmath4 bits , so that the bias of some of the bits is increased , while the bias of others is decreased ( this is closely connected to data compression ) .",
    "unfortunately rpc is theoretically limited by shannon s bound , which says that the entropy of a closed system can not decrease .",
    "an alternative algorithm was proposed in @xcite to enable cooling below the shannon bound .",
    "the idea is to use a second register of bits that quickly _ relax _ to the initial bias @xmath5 .",
    "call these the _ relaxation bits _ , and refer to the bits on which we perform the rpc operation as the _ compression bits_. the idea is to first use rpc to increase the bias of some of the compression bits , while decreasing the bias of the other compression bits .",
    "then the hotter compression bits ( i.e. those having decreased bias ) are swapped with the relaxation bits , where they will quickly relax back to the initial bias @xmath5 . repeating this procedure effectively pumps heat out of the some of the compression bits , cooling them to bias much higher than @xmath5 .",
    "this system is analogous to a kitchen refrigerator , where the relaxation bits behave like the radiator on the back of the refrigerator , dumping the heat taken from the refrigerator compartment out into the surrounding environment .",
    "this approach is often referred to as `` heat - bath algorithmic cooling '' , and the relaxation bits are often referred to as the `` heat bath '' .",
    "another approach to heat - bath algorithmic cooling was introduced in @xcite .",
    "their algorithm has a simpler analysis than the algorithm in @xcite , and gives a better bound on the size of molecule required to cool a single bit .",
    "in @xcite the physical limits of heat - bath cooling are explored . in their analysis ,",
    "the assumption is that the basic operations can be implemented perfectly , without errors .",
    "even given this assumption , the authors show that if the heat bath temperature is above a certain temperature threshold , no cooling procedure can initialize the system sufficiently for quantum computation .",
    "a heat - bath cooling algorithm called the `` partner pairing algorithm '' ( ppa ) is introduced to derive bounds on the best possible performance of algorithmic cooling with a heat bath .",
    "the ppa performs better than the previous algorithms , but it is unclear whether implementing the required permutations will be realistic in practice . in this paper",
    "i will focus on cooling algorithms based on repeated application of simple 2 or 3-bit rpc steps .",
    "to be useful for nmr quantum computing , we should implement cooling algorithms on a register of quantum bits all having some initial bias @xmath5 , without access to any `` clean '' ancillary bits .",
    "further , we should be careful about how much `` local control '' we assume is directly provided by the system . in @xcite ,",
    "four primitive computational operations are proposed as being supported by nmr quantum computers . for implementing the cooling algorithm ,",
    "the first two of these suffice :    1 .",
    "cyclically shift the @xmath4 bits clockwise or counterclockwise one position .",
    "2 .   apply an arbitrary two - bit operation to the first two bits ( i.e. to the bits under a fixed `` tape - head '' ) .    to implement the two operations",
    ", @xcite suggested to use a repeating polymer like the @xmath6-chains used for global control schemes ( e.g. @xcite ) .",
    "the chain could be configured as a closed loop . to mark the position of the `` first two bits '' of the chain ( for operation @xmath7 ) , an atom of a fourth type , @xmath8 ,",
    "is positioned adjacent to the chain , in the desired location .",
    "notice that a system supporting operations @xmath9 and @xmath7 above can be re - phrased in terms of a fixed `` tape '' containing the bit - string , and a moving `` head '' that can be positioned over any adjacent pair of tape cells . for convenience",
    ", the tape can be viewed as a closed loop . in @xcite an architecture",
    "is proposed that uses a repeating polymer with 8 species to implement a system having four such tapes .",
    "a rather complicated scheme for implementing the cooling algorithm is described for this four - tape machine .    some versions of the cooling algorithm ( @xcite , @xcite ) use ( classical reversible ) 3-bit operations : generalized toffoli gates ( from which controlled - operations can be implemented ) .",
    "operation to one of the bits conditioned on a specific pattern of the basis states of the other two bits . ] without access to ancillary bits , the toffoli can not be implemented by classical 2-bit gates ( and gates ) .",
    "it can be implemented without ancilla _ if _ we also have access to arbitrary single - qubit quantum gates @xcite .",
    "so to implement the algorithms of @xcite , and @xcite using operations @xmath9 and @xmath7 would require inherently quantum operations .",
    "an error analysis of the cooling algorithms is greatly simplified if we assume it has a `` classical '' implementation , however .",
    "fortunately , @xmath6-chains naturally support generalized toffoli operations directly , since the transition frequency of one species will be affected by the states of the neighbouring bits of two other species .",
    "it is worth revisiting the idea put forth in @xcite , to use an @xmath6-chain .",
    "i propose an alternative set of operations that should be supported ( these are sufficient for cooling , although obviously not for quantum computing ) :    1 .",
    "move any three bits into adjacent positions under a fixed `` tape head '' ( which covers three bits ) .",
    "2 .   apply any generalized toffoli or operation to the bits under the tape head .    using the scheme described in appendix",
    "[ append_abc_ring_scheme ] , @xmath10 and @xmath11 can be implemented on an @xmath6-chain which is configured as a closed loop .",
    "an atom of a fourth type , @xmath8 is positioned adjacent to some @xmath6-triple selected ( arbitrarily ) to be the position of the tape head .    the cooling algorithms work by moving some bits under the tape head and applying a basic ( 2-bit or 3-bit ) rpc step .",
    "the resulting cooler bits are then moved to one side of the array ( tape ) , while the hotter bits are moved to the other side .",
    "the rpc step is repeated to cool several bits , and then recursively applied to these cooled bits .",
    "we will assume that our initial configuration is some string of bits , each of which is ( independently ) in state 0 with some probability @xmath12 .",
    "equivalently , we assume the bits all have an identical bias @xmath13 before applying the polarization compression step .",
    "the assumption of independence ( i.e. a binomial distribution on the strings ) is required for the analysis .",
    "algorithmic cooling only amplifies an existing bias and hence the initial bias @xmath14 must be positive .",
    "the basic idea behind rpc is to implement a permutation that maps strings with low hamming weight ( i.e. having many 0 s ) to strings having a long prefix of 0 s . because it will be useful to implement cooling algorithms on systems for which we do nt have arbitrary local control",
    ", we will construct rpc permutations based on basic `` rpc steps '' .",
    "an rpc step will be a permutation on the states of a small number of bits ( 2 or 3 in the examples i consider ) .",
    "the overall system will be cooled by recursively applying the basic rpc step to all the bits .",
    "if we apply the rpc steps to disjoint pairs or triples of bits at each stage , the assumption of independence will hold throughout .    in the following sections we will examine candidates for the rpc step , and discuss how they may be implemented .",
    "the algorithms described in @xcite and @xcite both use a very simple 2-bit operation for the basic rpc step .",
    "the operation begins with a gate .",
    "suppose the is applied to two bits initially having some positive bias @xmath14 .",
    "after the , the target bit is 0 if both bits were originally equal , and is 1 if both bits were originally different . in the case that they were both the same , the control bit has an amplified bias after the .",
    "so , conditioned on the outcome of the target bit , the control bit is either accepted as a new bit with higher bias and is subsequently moved to the `` colder '' side of the array with a sequence of controlled - operations , or it is rejected and subsequently moved to the `` warmer '' side of the array . for specificity , i will refer to this 2-bit rpc step as `` 2bc '' .",
    "suppose the values of the control and target bits before the are @xmath15 and @xmath16 respectively . then after the the value of the target bits is @xmath17 .",
    "the control bit is accepted iff this value equals 0 .",
    "the probability that @xmath18 given that @xmath19 is @xmath20 and so in this case the bias of the control bit is @xmath21 the probability that the control bit is accepted equals the probability that @xmath19 , which is @xmath22    if the control bit is rejected , it has bias 0 . to achieve the polarization compression ,",
    "the must be followed by an operation that selects the accepted bits to be retained .",
    "this is accomplished in the 2bc operation by controlled - operations that move the bit to the left or right according to whether it was accepted or rejected .",
    "we will show that the followed by a controlled - actually computes the majority of three bits , and thus the 2bc operation is equivalent to the 3bc operation defined in section [ sec_3bit_step ] . ]",
    "a cooling algorithm can work by recursive application of the 2bc step across many bits having an initial bias @xmath5 .",
    "first some of the bits will be cooled by one application of 2bc , while others are warmed .",
    "the cooled bits will be moved away from the warmed bits , and then cooled further by another application of 2bc , and so on .",
    "the total number of starting bits required is determined by the depth of recursion required to obtain a single bit cooled to the desired target bias .",
    "the algorithm described in @xcite uses a 3-bit reversible polarization compression step ( 3bc ) .",
    "this rpc step is implemented by a permutation on the basis states of a 3-bit register that has the effect of increasing the bias of the one of the bits , while decreasing the bias of the other two .",
    "experimental demonstration of the 3-bit rpc step has been conducted using nmr @xcite .",
    "the implementation of the 3bc operation given in @xcite uses a gate followed by a controlled - gate .",
    "recall from our discussion in section [ sec_architecture ] that we are assuming that the bits have already been moved onto an @xmath6-triple under the `` tape - head '' , and that we can implement any reversible 3-bit ( classical ) operation on them .",
    "the quantum circuit model is a convenient paradigm for describing the operations .",
    "note that the controlled - can be implemented by generalized toffoli operations , as shown in figure [ fig_cswap_cooling ] .",
    "( approaches for implementing such generalized toffoli gates on @xmath6-chains are described for example in @xcite and @xcite . )",
    "the permutation implemented by the circuit in figure [ fig_cswap_cooling ] results in the majority value of the three bits ( before the operation ) being encoded into bit @xmath23 .",
    "since we are only interested in the final bias of bit @xmath23 , we can use any permutation that has this effect .",
    "in fact , the following claim says that such a permutation is the best choice for a 3-bit rpc step .",
    "suppose we have a register of @xmath4 bits independently having identical bias @xmath13 , where @xmath4 is odd .",
    "suppose we want to implement a permutation that has the effect of increasing the bias of the first bit as much as possible .",
    "then the best choice is a permutation that computes the majority value of the @xmath4 bits into the first bit .    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ * proof * since each bit has bias @xmath13 , each bit is independently 0 with probability @xmath24 .",
    "an optimal permutation for increasing the bias of the first bit will be one which maps the @xmath25 most - likely strings to strings having a 0 in the first bit .",
    "the @xmath25 most - likely strings are precisely those having at least @xmath26 bits in the state 0.@xmath27 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the circuit is shown in figure [ fig_3bitmaj ] is an alternative implementation of the 3-bit majority , which is simpler in terms of toffoli and operations .",
    "i will henceforth refer to the operation implemented by this circuit as 3bc .",
    "note that the circuit of figure [ fig_3bitmaj ] implements a different permutation that that implemented by the circuit of figure [ fig_cswap_cooling ] , but the effect on bit @xmath23 ( i.e. after tracing - out bits @xmath28 and @xmath29 ) is the same for both circuits ( assuming the input bits are independently distributed ) .",
    "since toffoli and operations are `` classical '' in the sense that they do not generate nontrivial superpositions given basis states as inputs , we can analyze the behaviour of the 3bc circuit entirely in the computational basis .",
    "in the following , i will restrict the analysis in terms of classical bits .",
    "consider the effect on the bias of bit @xmath23 after applying the circuit of figure [ fig_3bitmaj ] .",
    "the majority value is computed into bit @xmath23 .",
    "suppose initially the bias of each of the three bits is @xmath14 .",
    "so the probability for each bit equaling 0 is initially @xmath30 .",
    "after the 3bc operation , the probability that bit @xmath23 ( which now equals the majority of the initial values of @xmath31 ) equals zero is @xmath32 so the bias of bit @xmath23 after the 3bc operation is @xmath33      recall that 2bc is followed by controlled - operations which moves the control bit ( of the ) to the left or right conditioned on the state of the target bit .",
    "the itself has no effect on the bias of the control bit .",
    "it is the value of the target bit after the that provides some information about the state of the control bit . in the case that the target bit equals zero ,",
    "the control bit is more likely to be 0 , and hence has a greater bias .",
    "so the 2bc step is really a method for gaining some information about which bits are more likely to be zero , and moving these off to one side .",
    "after a single application of 2bc on two bits having equal bias , we may or may not be left with a bit having increased bias .",
    "the 3bc step , on the other hand , deterministically increases the bias of the third bit at the expense of decreasing the bias of the other two . every time we apply the 3bc step to three bits having equal bias we are certain to be left with a bit",
    "whose bias has been increased .",
    "this property makes it somewhat simpler to analyze the efficiency of algorithms based 3bc .",
    "the analysis of the 2bc - based heat - bath algorithm in @xcite relies on the law of large numbers , and gives a worse bound than does the analysis of the 3bc - based    algorithm of @xcite .    in the algorithms of @xcite and",
    "@xcite the of the 2bc step is always followed by a controlled - operation .",
    "an important observation is that the followed by a controlled - actually computes the three - bit majority ( indeed this is the way the 3bc step was implemented in @xcite ) .",
    "specifically , suppose we first apply a between bits in states @xmath34 and @xmath35 ( with @xmath34 as the control bit ) , and then apply a controlled - between @xmath34 and a third bit in state @xmath36 , controlled on the target bit of the being 0 .",
    "the final state of @xmath36 is @xmath37 which is the majority of @xmath38 .",
    "so if we explicitly include the extra target bit of the controlled - operation , the 2bc step is is equivalent to the 3bc step .",
    "this suggests an equivalence between the early algorithms described in terms of a 2bc operation and algorithms phrased in terms of a 3-bit majority vote ( 3bc ) .",
    "for this reason , in the following i will restrict attention to algorithms based on the 3bc operation .",
    "we will analyze the efficiency of a simple algorithm that recursively partitions the string of bits into triplets and applies 3bc to these triplets .",
    "after each 3bc step ( say on bits @xmath31 ) , the @xmath28 and @xmath29 bits which become heated are discarded .",
    "thus at each level of recursion the total number of bits is reduced by a factor of 3 , and the remaining bits bias is increased from @xmath14 to a new value @xmath39 to simplify the analysis we will approximate @xmath40 by @xmath41    after @xmath42 levels of recursion the bias is increased to @xmath43 this gives us an estimate on the number of levels of recursion @xmath42 required to achieve some target bias @xmath44 on a single bit .",
    "@xmath45 therefore the total number of bits starting at bias @xmath14 required to obtain one bit with a target bias of @xmath46 is @xmath47 which is polynomial in @xmath46 .",
    "for example , suppose we start with a bias of @xmath48 ( see @xcite ) .",
    "then the number of bits required to yield a single bit with bias @xmath49 is about @xmath50 , and the number required to yield a bit with bias @xmath51 is about @xmath52 .    note that this analysis has only given the number of bits required . to obtain a good estimate of the time complexity",
    ", we would have to specify the computational model more precisely , and account for the time required to shuttle the states around as required by the architecture and the algorithm .",
    "there are many ways in which the recursive algorithm might be modified to take advantage of a heat bath .",
    "the heat bath is a mechanism by which a heated bit can be exchanged for a fresh bit having initial bias @xmath5 ( taken from the environment ) . for a rough analysis",
    ", we ignore the details of how the heat - bath contact will be implemented , and assume we can apply an operation which resets a bit s bias to @xmath5 on - demand ( this may be an unrealistically optimistic assumption ) .",
    "one approach to using the heat bath in a 3bc algorithm is as follows .",
    "first apply the 3bc step as in the simple recursive algorithm . at this point",
    "we have @xmath53 bits cooled to @xmath40 .",
    "now , instead of discarding the @xmath54 bits that were heated in this process , send them to the heat bath to return them to bias @xmath5 . then partition these @xmath54 bits into triples , and apply the 3bc step to them .",
    "this yields another @xmath55 bits of bias @xmath40 .",
    "repeat this process until there are fewer than @xmath56 bits left having bias less than @xmath40 ( there will always be exactly 2 bits left over ) .",
    "now we have @xmath57 bits cooled to bias @xmath40 and we can proceed to the next level of recursion . as before ,",
    "the number of levels of recursion @xmath42 required to achieve a bit having some target bias @xmath44 is @xmath58 this time , however , a logarithmic amount additional work is done for each level of recursion . by taking this extra time , we save on the total number of bits required .",
    "after each level of recursion an additional 2 bits are discarded .",
    "so the total number of bits required to obtain one bit cooled to @xmath46 by this method is @xmath59 which is polylogarithmic in @xmath46 .",
    "as before , supposing we start with a bias of @xmath60 , then the number of bits required to yield a single bit with bias @xmath49 is about @xmath61 , and the number required to yield a bit with bias @xmath51 is about @xmath62 .",
    "another approach to using the heat bath is described in @xcite .",
    "their algorithm repeatedly applies the 3bc step to three bits having bias values @xmath63 and @xmath64 .",
    "this requires more careful analysis .",
    "consider applying 3bc to three bits @xmath65 having initial bias values @xmath63 and @xmath64 respectively , where the majority is computed into the third bit @xmath66 .",
    "the resulting bias of the third bit is @xmath67 now suppose the first two bits are sent to the heat bath , and then run back through the cooling procedure to regain bias values of @xmath68 and @xmath69",
    ". then 3bc is applied again ( on the same three bits , except this time the third bit starts with bias @xmath70 ) .",
    "if this process is repeated several times , the bias of the third bit reaches a steady state value of @xmath71    the algorithm described by @xcite is based on this process .",
    "suppose the algorithm has built - up an array of @xmath72 cooled bits @xmath73 having bias values @xmath74 in that order , where @xmath75 for each @xmath76 .",
    "then in the next stage of the algorithm a new bit @xmath77 is introduced having the heat - bath bias @xmath78 .",
    "the 3bc procedure is applied to the three bits @xmath79 repeatedly , where between each application the algorithm is recursively repeated to re - establish the bias values @xmath80 on bits @xmath81 . repeating this process",
    "several times the bias of bit @xmath77 will reach the steady state value @xmath82 .    starting with @xmath4 bits of bias @xmath5 ,",
    "the algorithm of @xcite achieves one bit of bias approximately @xmath83 , where @xmath84 is the @xmath85 fibonacci number .",
    "this is even better than the simple recursive heat - bath method described previously . starting with a bias of @xmath60 ,",
    "the number of bits required for this method to yield a single bit with bias @xmath49 is about @xmath86 , and the number required to yield a bit with bias @xmath51 is about @xmath87 .",
    "there is a polynomial cost in time incurred by the repeated re - cooling of bits from the point of heat - bath contact at the left end of the chain up to @xmath68 and @xmath69 .",
    "notice that in the heat bath algorithms we have described , after a 3bc operation the two bits that have become heated by this operation are both sent to the heat bath . in the early stages of an algorithm , this would be sensible , because the 3bc operation will have warmed those two bits to bias values less than the initial bias @xmath5 . towards the end of the algorithm , however , 3bc will be applied to triples of bits that are all very cold bits , and the bits that become heated may still have bias considerably higher than @xmath5 . in this case , sending these bits to the heat bath does not seem like the right thing to do . to analyze the performance of algorithms",
    ", however , it is extremely convenient to assume we always do so .",
    "if we do not send the two heated bits back to the heat bath after a 3bc application , the bits values are no longer described by independent probability distributions , and bias values are no longer well - defined .",
    "it is convenient to model the process of a 3bc application followed by sending the two heated bits to the heat bath as a single operation , as follows .",
    "consider three bits @xmath88 having bias values @xmath89 respectively .",
    "define @xmath90 as the three - bit majority on @xmath88 ( where the majority is computed into @xmath91 ) followed by sending @xmath34 and @xmath35 to the heat bath .",
    "the bias values of the three bits after this operation are @xmath92 respectively .",
    "the heat - bath algorithms described above can all be described as a sequence of operations @xmath93 where each @xmath90 is applied to three bits in some specific positions ( e.g. under a `` tape head '' ) , and each @xmath94 is some permutations of the positions of the bits in the string .",
    "the following claim shows that the algorithm of @xcite is the best such algorithm ( this is not claimed in @xcite ) .",
    "consider a string of bits each having initial bias value @xmath5 .",
    "let @xmath95 be any cooling algorithm described by a sequence of operations @xmath96 where each @xmath90 is applied to three bits in some specific positions ( e.g. under a `` tape head '' ) , and each @xmath94 is some permutation of the positions of the bits in the string . at any stage of the algorithm , suppose we arrange the bits in a nondecreasing order of their bias values @xmath97 .",
    "then we have @xmath98 for all @xmath99 , where @xmath100 is the @xmath101 fibonacci number .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ the proof is by induction .",
    "the claim is initially true ( before starting the algorithm ) by assumption . since the only operation allowed in @xmath95 that changes the bias values is the @xmath90 operation , it suffices to show that",
    "after an arbitrary @xmath90 operation the claim is still true .",
    "suppose the ordered bias values before the 3bc operation are @xmath102 then suppose the @xmath90 operation is applied to any three bits , suppose those having bias values @xmath103 and @xmath104 , where @xmath105 .",
    "we assume that after the 3bc operation the value of @xmath104 is not decreased .",
    "this is a safe assumption , because otherwise algorithm @xmath95 would have done just as well not to apply that 3bc operation .",
    "after the @xmath90 operation , the new bias of the bit originally indexed by @xmath106 is @xmath107 by assumption we have @xmath108 , @xmath109 and @xmath110 . since @xmath111 by definition , we have @xmath112 now",
    ", suppose the re - ordered bias values are @xmath113 since two of the bits were subjected to heat bath contact , we have @xmath114 and @xmath115 for @xmath116 .",
    "so the claim is true for the first @xmath117 bias values . by the ordering we have @xmath118 , and by ( [ eqn_bound_br ] ) we know these are all at most @xmath119 , so the claim is true for these bias values . for the remaining bits we have @xmath120 for @xmath121 , and",
    "so the claim is true for them as well .",
    "this completes the proof.@xmath122 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _      the heat bath is typically modeled by a process whereby a hot bit is magically replaced by a fresh bit having the initial bias @xmath5 . usually we would make some assumption about where the heat - bath contact occurs , for example requiring that only the bit on the end of a chain can be replaced with a fresh bit .    from a complexity theory point of view , the heat bath is a resource that should be account for . for modeling the physics of the situation it might be very convenient to draw a conceptual boundary between the system we are trying to cool and the heat bath , which for all practical purposes might be extremely large . continuing our previous analogy between heat - bath cooling and a kitchen refrigerator ,",
    "if we put the refrigerator in a large enough room we wo nt have to account for the fact that the room itself is gradually heated by the radiator on the back of the fridge . while heat - bath techniques appear to drastically reduce the number of bits required to achieve a target bias",
    ", it should be recognized that this hasnt come for free .",
    "the extra bits ultimately come from the heat bath . in practice",
    ", it may be very reasonable to assume we get these bits `` for free '' , since we do nt have to exercise control over the heat bath the way we do with the bits directly involved in the algorithm .",
    "in the following sections i investigate the performance of cooling algorithms when errors can occur in the rpc step . the bounds i will derive will apply to cooling algorithms that are based on recursive application of the 3bc step , where the step is always applied to 3 bits that have been previously cooled to equal bias values . in section [ sec_general_3bc_algs ]",
    "i discuss how the same approach can be applied to analyze more general algorithms based on the 3bc step .",
    "i do not account for errors that might occur between applications of the rpc steps , such as when bits are being shuttled around , or placed in an external heat bath .",
    "for this reason the bounds apply quite generally , independent of implementation details and low - level algorithmic details .",
    "the most general way to analyze the effect of errors on a quantum circuit is to examine the effect of the errors on the density matrix of the state as it evolves through the circuit .",
    "as we observed above , the 3bc step can be implemented by classical operations , and can be analyzed entirely in the computational basis .",
    "i therefore perform the error analysis in a classical setting .",
    "suppose we implement the rpc operation in a system subject to errors described by a set of error patterns @xmath123 .",
    "the error pattern is a record of what errors actually occurred . for each error pattern",
    "@xmath124 we can analyze the effect by considering a new circuit containing the original rpc circuit as well as the error operations that occurred .",
    "we can then find the probability @xmath125 that the cooled bit would be in state 0 after applying this new circuit .",
    "thus the probability that the cooled bit equals 0 for the overall process is @xmath126 where @xmath127 is the probability that error pattern @xmath124 occurs .",
    "the new bias of the cooled bit after the process is then @xmath128 equivalently , we could compute the new bias @xmath70 of the cooled bit resulting from application of the rpc step for each error pattern @xmath124 , and take a weighted sum of these bias values ( weighted by the probabilities @xmath127 ) .",
    "@xmath129 after obtaining the new bias @xmath40 of the cooled bit after the overall process , we can obtain theoretical limits on the performance of the cooling algorithm by analyzing the condition @xmath130 where @xmath14 is the bias before the rpc and error channel were applied ( this simply says that the bias should be greater after application of the 3bc step ) . in practice , to analyze the inequality @xmath131 we study the expression @xmath132 , which for the error models we consider will be a quadratic or cubic polynomial in @xmath14 ( and also a function of the error rates ) . by studying the roots of this polynomial we can find ranges of values for the error rates for which inequality ( [ general_bias_boost_inequal ] ) has solutions @xmath13 , and",
    "also obtain the maximum value of @xmath14 which is a solution ( this maximum value will be the maximum bias achievable by the rpc step for the given error rates ) .",
    "the first error model we will consider is the symmetric bit - flip model , in which a bit s value is flipped with probability @xmath133 ( `` symmetric '' in this context means that the probability of a bit flip is independent of the initial state of the bit ) .",
    "if the bit - flip channel is applied to a bit initially having bias @xmath14 , the result is a bit with bias @xmath134 .",
    "we will now consider the case in which a bit - flip error can occur after the 3bc step has been performed ( and errors do not occur between application of the gates in figure [ fig_3bitmaj ] ) .",
    "there are two error patterns .",
    "pattern @xmath135 represents the case where a bit flip does not occur . in this case",
    ", the final bias of bit @xmath23 is @xmath136 as we found in section [ sec_3bit_step ] ( equation ( [ 3bc_newb ] ) ) .",
    "the error pattern @xmath137 represents the case where the bit flip occurs on the newly biased bit . in this case , the bias is negated , and so the new bias is @xmath138 so the new bias of @xmath23 for the overall process is @xmath139    then the condition that @xmath140 gives @xmath141 which leads to @xmath142 so for this simple error model @xmath143 is an error threshold beyond which the 3bc procedure can have no positive effect on the bias ( regardless of how low the initial bias is ) . for a fixed error rate @xmath144",
    "a bound on the maximum bias that will be achievable is obtained by solving for @xmath14 in ( [ sym_after_3bc_thresh_inequal ] ) ) : @xmath145 approximating the expression to second - order gives @xmath146    once the bias exceeds @xmath147 , the 3bc procedure will no longer be effective in increasing the bias , and the algorithm will yield no further improvement .",
    "so @xmath147 represents the limit of the bias that can be achieved by any cooling algorithm that is based on the 3bc step , under this error model .    for error rates @xmath2 below 1% ,",
    "the approximate value in ( [ sym_after_3bc_blim_approx ] ) is within 0.01% of the value in ( [ sym_after_3bc_blim ] ) .",
    "we will now do a more careful analysis accounting for the possibility of errors occurring during the application of the 3bc step . specifically",
    ", we consider independent bit - flip errors on each bit with probability @xmath2 , where the errors can occur at each time step ; that is , immediately after the application of any gate in the circuit of figure [ fig_3bitmaj ] ( equivalently after the application of each @xmath148 operation ) .",
    "this is only one possible decomposition of the majority - vote operation into a sequence of basic operations , but it serves to illustrate the technique for analysis .",
    "a similar analysis can easily be conducted given an alternative decomposition of the majority vote into a sequence of basic operations .",
    "there are 9 possible sites for bit - flip errors in figure [ fig_3bitmaj ] , but two of these can be ignored ( errors on the @xmath28 or @xmath29 bits after the final toffoli have no effect on the final bias of the @xmath23 bit ) .",
    "figure [ fig_3bitmaj_err1 ] illustrates the circuit including the possible error operations .",
    "the binary variables @xmath149 shown on the circuit are taken to be `` 1 '' if a bit - flip error occurs in that location , and `` 0 '' otherwise .",
    "suppose the value of the @xmath150 register is initially @xmath151 , where @xmath152 , @xmath153 , and @xmath36 are the binary values of the three bits .",
    "analyzing the circuit in figure [ fig_3bitmaj_err1 ] , the final value of the @xmath23 bit is found to be @xmath154 since the errors occur independently with probability @xmath2 at each position , the probability associated with each error pattern @xmath155 ( where @xmath156 indexes the possible patterns ) can be evaluated as @xmath157 where @xmath158 .",
    "initially , the probability that each bit @xmath159 or @xmath36 equals 0 is @xmath160 .",
    "so the tuple @xmath161 describes the situation where the register was initially in the state @xmath151 and the error described by @xmath162 occurred , and this happens with probability @xmath163 let @xmath164 be the probability that the final value of @xmath23 for the overall process equals 0 .",
    "the value of @xmath164 is obtained by adding the probabilities @xmath165 over all those tuples @xmath161 for which the value of ( [ 3bitmaj_err1_newa ] ) equals 0 .",
    "the new bias of @xmath23 is then determined as @xmath166 this value is @xmath167\\ ] ] which can be expressed in terms of the original bias by substituting @xmath168 : @xmath169    now the condition @xmath170 leads to @xmath171    the expression on the left side of ( [ sym_during_3bc_inequal ] ) represents the improvement in the bias .",
    "it decreases monotonically as @xmath14 increases from 0 , and so an upper bound can be obtained by setting @xmath172 .",
    "then , by studying the real roots of the resulting polynomial in @xmath2 we can determine the range of values for which the improvement is positive . by numerical computation , the threshold is found to be    @xmath173    for a fixed @xmath174 , inequality ( [ sym_during_3bc_inequal ] ) also gives a bound on the maximum bias achievable by the 3bc step under the given error model .",
    "@xmath175    for small values of @xmath2 , we can approximate ( [ sym_during_3bc_blim ] ) to second order .",
    "@xmath176    for error rates @xmath2 below 1% ,",
    "the approximate value in ( [ sym_during_3bc_blim_approx ] ) is within 0.1% of the value in ( [ sym_during_3bc_blim ] ) .",
    "we will now consider a more general error model for a classical bit . under this error model ,",
    "called the _",
    "asymmetric bit - flip channel _",
    ", a bit transforms from 0 to 1 with some probability @xmath177 , and transforms from 1 to 0 with some probability @xmath178 .",
    "a fixed - point probability distribution for the asymmetric bit - flip channel is @xmath179&=\\frac{{\\varepsilon}_1}{{\\varepsilon}_0+{\\varepsilon}_1}\\\\ p[1]&=\\frac{{\\varepsilon}_0}{{\\varepsilon}_0+{\\varepsilon}_1}.\\end{aligned}\\ ] ]    if left to evolve for under the symmetric channel , a bit will eventually settle to a bias value of @xmath180 the rate at which the bias approaches this fixed point is related to @xmath181",
    ".    it will be convenient to make a couple of assumptions about the error rates .",
    "first , we will assume that errors cause the system to tend back to the initial bias @xmath5 ( which would be the same as , or close to , the bias of the `` heat bath '' for cooling algorithms that use this device ) .",
    "that is , @xmath182    in other words , errors cause a partial debiasing of the cooled bits ( ideally , this will happen very slowly , and so a the value for the sum of the error rates , @xmath181 , will be small ) . in the following",
    ", i will refer to this type of asymmetric bit - flip error as a _",
    "debiasing error_.    since @xmath183 , we have @xmath184    we will also assume that the error rates @xmath177 and @xmath178 are both less than @xmath185 .",
    "in this case we have @xmath186 since we assumed that the bias of the bit being cooled starts at @xmath5 and is thereafter nondecreasing , we can say that at any stage of the algorithm we have @xmath187 where @xmath14 is the current bias of the bits that the rpc step is being applied to .    consider what happens to a bit initially having some bias @xmath14 when we apply the asymmetric bit - flip channel once .",
    "a simple calculation shows the resulting bias to be @xmath188 in the following analysis , it will be convenient to make a change of variables , letting @xmath189 then our assumptions are @xmath190 , and @xmath191 , and equation ( [ 1_asym_step_newb_e0e1 ] ) becomes @xmath192 notice that @xmath193 is also an obvious condition .",
    "consider the special case of the symmetric bit - flip channel . in this case @xmath194 , and so @xmath195 .",
    "this is why we obtained positive threshold error rates for the rpc step to increase the bias .",
    "now , under our assumption @xmath196 , we will not obtain such a threshold . even with high error rates ( fast debiasing ) the rpc step will increase the bias above @xmath5 by some positive amount .",
    "it is still important to analyze the effect of these errors on the rpc step , because they will imply a limiting value on the highest bias achievable .",
    "the rpc step tends to increase the bias away from the value @xmath197 , while the errors tend to force the bias back towards @xmath198 .",
    "the maximum achievable value of @xmath14 will be determined by @xmath199 and @xmath200 , or equivalently , by @xmath5 and @xmath200 .",
    "recall that @xmath200 can be seen as a measure of the rate at which the errors force the bias towards the initial value @xmath5 .",
    "thus the maximum achievable bias is limited by the initial bias , and by the rate at which errors cause the system to tend back to the initial bias .",
    "consider the scenario in which a debiasing error may occur immediately after the 3bc operation .",
    "the bound obtained here will apply regardless of how the 3bc step is implemented . assuming all three bits initially start with bias @xmath14 , the bias of bit @xmath23 after the process ( the 3bc circuit followed by a debiasing error ) is @xmath201 the condition that @xmath202 leads to @xmath203 for values of @xmath204 ( recall the threshold condition @xmath205 we obtained in section [ sec_sym_after_3bc ] ) and for @xmath193 , the cubic polynomial on the left - hand side of ( [ asym_after_3bc_inequal_newb ] ) has one positive real root ( and the value of this root will be less than 1 ) .",
    "a positive value of @xmath14 will satisfy inequality ( [ asym_after_3bc_inequal_newb ] ) only if it is less than than the value of this root .",
    "that is ,    @xmath206    the appearance of nonreal numbers in ( [ asym_after_3bc_blim ] ) is unavoidable .",
    "to second order in @xmath199 and @xmath200 , ( [ asym_after_3bc_blim ] ) gives @xmath207 in the symmetric case , the bound ( [ asym_after_3bc_blim_approx_sd ] ) agrees with the bound ( [ sym_after_3bc_blim_approx ] ) which we found in section [ sec_sym_after_3bc ] .    in terms of @xmath200 and @xmath5 , ( [ asym_after_3bc_blim_approx_sd ] )",
    "is @xmath208    for error rates less than 1% , the approximate value ( [ asym_after_3bc_blim_approx ] ) agrees with the actual value to within @xmath209 .",
    "we will now consider the error model in which debiasing errors can occur at each time step ( i.e. immediately after the application of any gate in the circuit of figure [ fig_3bitmaj ] , or equivalently after each @xmath148 operation ) .",
    "the analysis is performed similarly to what we did in section [ sec_sym_during_3bc ] , by considering the probability associated with each binary tuple @xmath161 for which the resulting value of bit @xmath23 equals 0 . for the asymmetric model , by tracing through the circuit of figure [ fig_3bitmaj ]",
    ", we find that equation ( [ 3bitmaj_sym_err_prob_scen ] ) generalizes to    @xmath210    where @xmath211 and @xmath212 again we can sum the probabilities @xmath213 over those tuples for which the final value of bit @xmath23 ( given by equation ( [ 3bitmaj_asym_err_prob_scen ] ) equals 0 , and compute then new bias .",
    "the new bias , approximated to second - order in @xmath200 and @xmath199 , is @xmath214 then the condition @xmath170 gives @xmath215 for values of @xmath216 ( recall the threshold condition we obtained in section [ sec_sym_during_3bc ] ) and for @xmath193 , the cubic polynomial on the left - hand side of ( [ asym_during_3bc_inequal_newb ] ) has one positive real root ( whose value will be less than 1 , modulo the error in the second - order approximation ) .",
    "a positive value of @xmath14 will satisfy inequality ( [ asym_during_3bc_inequal_newb ] ) only if it is not greater than the value of this root , which is ( to second order in @xmath200 and @xmath199 ) @xmath217 in the symmetric case , the bound ( [ asym_during_3bc_blim_approx_sd ] ) agrees with the bound ( [ sym_during_3bc_blim_approx ] ) that we obtained in section [ sec_sym_during_3bc ] . in terms of @xmath200 and @xmath5",
    "we have ,    @xmath218    for error rates less than 1% , the approximate value ( [ asym_after_3bc_blim_approx ] ) agrees with the actual value ( [ asym_after_3bc_blim ] ) to within @xmath219 .",
    "in all of the above error analysis , we have assumed that the 3bc step is applied to three bits having identical bias at each stage of the algorithm .",
    "recall in section [ sec_efficiency ] it was mentioned that an algorithm proposed in @xcite is structured somewhat differently , and applies the 3bc step to three bits having different bias values @xmath68 , @xmath69 and @xmath64 .",
    "we can still learn something by performing the previous analysis assuming all three bits have bias @xmath220 , but it is worth briefly considering how we could analyze this more general scenario directly .",
    "consider applying the debiasing error channel with error parameters @xmath177 and @xmath178 immediately after the 3bc step is applied . in this case , the bias of the third bit after the process is @xmath221 ( recall @xmath222 and @xmath223 ) .",
    "as in section [ sec_debiasing_errors ] , we assume that the error parameters satisfy @xmath190 , @xmath224 and @xmath199 is less than each of @xmath68 , @xmath69 and @xmath64 .",
    "we also assume that @xmath225 is less than each of @xmath68 , @xmath69 and @xmath64 so that the errors are indeed tending the system towards a lower bias .",
    "now suppose we proceed as in @xcite and send the first two bits back to the heat bath , re - cool them up to bias values @xmath68 and @xmath69 , and again apply 3bc . without errors , we mentioned previously that by repeating this process several times the third bit reaches a steady - state bias value of @xmath71 with the debiasing error channel being applied after every application of 3bc , this steady - state bias value is reduced to @xmath226 equations ( [ equation_general_3bc_alg_err1 ] ) and ( [ equation_general_3bc_alg_err1 ] ) can be used to analyze can be used to analyze more general algorithms based on repeated application of 3bc , including the fibonacci sequence algorithm proposed in @xcite , under the effect of debiasing errors that may occur after each application",
    ". we could similarly decompose the 3bc step into a suitable sequence of discrete operations , and proceed as we have done above to analyze the effect of errors that may occur after each discrete step .",
    "i have studied the performance of cooling algorithms that use the 3-bit majority as the compression step ( e.g. @xcite , @xcite ) and argued that previously discovered algorithms ( e.g. @xcite , @xcite ) can be re - cast in this way .",
    "i have proven the optimality of the best such algorithm for obtaining one cold bit with the fewest possible number of initially mixed bits .",
    "an error analysis of these algorithms has been conducted , first under a simple error model ( symmetric bit - flip ) , and then under a more realistic model of debiasing .",
    "since the implementations of the rpc steps are inherently `` classical '' ( states do not leave the computational basis ) , it is reasonable to restrict attention to these classical error models . in each case , i first derived some bounds assuming that errors may occur immediately after the rpc step .",
    "since this may be taken as a best - case scenario , then these bounds apply regardless of the implementation .",
    "i also derived bounds assuming that the 3bc cooling step is implemented by a sequence of physical operations that simulate a sequence of and toffoli gates ( i.e. a sequence of @xmath227 operations ) .",
    "specifically we considered the simplest such arrangement for implementing the 3bc step , shown in figure [ fig_3bitmaj ] .",
    "the results are summarized below ( approximated to second - order ) .    given a specific low - level implementation of a cooling algorithm , specified as a sequence of pulses applied to an @xmath6-chain or some other suitable hardware , a detailed error analysis could be conducted in a manner similar to the approach i have taken here . for specific cooling algorithms",
    "it will also be interesting to analyze the effects of errors occurring between applications of the rpc step ( for example , while the bits are being permuted to move the required bits into position for the next application of the cooling step ) . by studying the time - complexity of a specific algorithm implemented on a specific architecture",
    ", we can determine the balance between the rate at which the algorithm increases the bias , and the rate at which debiasing errors are causing the bias to decrease .",
    "cooling algorithms can be built from basic steps other than the 3-bit majority .",
    "for those that have `` classical '' implementations ( that is , can be built from some sequence of generalized toffoli gates ) the approach we have taken here could be employed to conduct a similar error analysis . for basic rpc steps operating on more than 3 bits ,",
    "the kind of analysis we have performed here would require examining higher - order polynomials , and this may have to be done numerically .    for rpc steps that are implemented `` quantumly '' ( i.e. using gates that force states to leave the the computational basis ) , more general quantum error models will have to be considered , and a different approach to the error analysis will be required .",
    "this research was supported by mitacs ( mathematics of information technology and complex systems ) , nserc ( national science and engineering research council ) , cse ( communications security establishment ) , cfi ( canadian foundation for innovation ) , ordcf ( ontario research and development challenge fund ) , and prea ( premier s research excellence awards ) .",
    "i would like to particularly thank mark saaltink for the many interesting conversations that made this work possible .",
    "recall the following two operations we proposed that should be supported by an nmr computer for implementing algorithmic cooling .      here",
    "we sketch an method for implementing @xmath228 and @xmath148 on an @xmath6-chain which is configured as a closed loop .",
    "note that we could alternatively use a linear configuration , but would then have to be careful about the behaviour at the ends of the chain ( one approach would be to have the chain be long enough so that the bits of interest are sufficiently far into the interior of the chain that the effects the ends are irrelevant ) .",
    "we will also assume that the loop consists of an odd number of @xmath6-triples .",
    "we assume that the physical system directly supports the implementation of a generalized toffoli or operation on all the @xmath6-triples in parallel ( or alternatively an all @xmath229-triples , or on all @xmath230-triples ) .",
    "we also assume that we can implement any such operation on _ only _ the @xmath6-triple under the tape head , by making use of the effect of the proximity of the @xmath8 atom .",
    "so operation @xmath7 is directly supported by the hardware .",
    "given these primitives , we focus on the problem of implementing operation @xmath9 .    for clarity of exposition , we will refer to the physical bits of species @xmath31 as `` cells '' of `` types '' @xmath31 .",
    "when we talk about `` moving a bit to a cell '' , we are referring to a sequence of logical operations ( usually nearest - neighbour operations ) that permute the logical states of the physical bits on the chain .",
    "we will use the following lemma .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "* proof sketch * let @xmath231 be the operation that swaps the states of the bits on the @xmath23-cells with the bits in the neighbouring-@xmath28 cells .",
    "the sequence @xmath232 has the effect of moving every bit initially in an @xmath23-cell to the @xmath23-cell of the next @xmath6-triple to the left ( counterclockwise ) .",
    "it also moves every bit initially in a @xmath29-cell to the @xmath29-cell of the next @xmath6-triple to the right ( clockwise ) .",
    "it leaves the bits on the @xmath28-cells fixed . by permuting the labels of the species we have similar sequences for moving the bits in the @xmath23- and @xmath28-cells , while keeping the bits in the @xmath29-cells fixed .",
    "suppose we have a pair of bits @xmath233 in adjacent @xmath28- and @xmath29-cells , that we wish to move into adjacent positions under the tape head .",
    "first we apply the sequence that moves the bits in the @xmath23- and @xmath28-cells ( keeping the bits in the @xmath29-cells fixed ) until @xmath234 is in the @xmath28-cell under the tape - head .",
    "then we apply the sequence that moves the bits in the @xmath23- and @xmath29-cells ( keeping the bits in the @xmath28-cells fixed ) , until @xmath235 is in the @xmath29-cell under the tape head ( beside @xmath234 ) .",
    "similar procedures will bring any pairs of adjacent bits into adjacent positions under the tape head.@xmath27 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    from the lemma , it follows that we can implement a nearest - neighbour operation between any adjacent pair of bits on the tape .",
    "first we move the pair under the tape - head , and then use an @xmath148 operation to the states of these bits .",
    "finally use the sequence operation of @xmath148 to move all the bits back to their corresponding original positions ( modulo the swapped pair ) .",
    "now it follows that we can implement an arbitrary permutation of the bits on the tape ( by a suitable sequence of nearest - neighbour transpositions ) , of which operation @xmath228 is a special case .",
    "notice that this also allows us to perform the permutations of the bits required to move cooled bits to one side of the tape and move warmer bits to the other side , as would be required between applications of the basic cooling step .",
    "99 adriano barenco , charles h. bennett , richard cleve , david p. divincenzo , norman margolus , peter shor , tycho sleator , john smolin , harald weinfurter .",
    "`` elementary gates for quantum computation '' . _ physical review a _ , 52(5):3457 - 3467 , 1995 . _",
    "also arxiv e - print quant - ph/9503016_.              j. baugh , o. moussa , c.a .",
    "ryan , a. nayak , r. laflamme .",
    "`` experimental implementation of heat - bath algorithmic cooling using solid - state nuclear magnetic resonance '' .",
    "_ nature _ vol .",
    "7076 , 470 - 473 ."
  ],
  "abstract_text": [
    "<S> algorithmic cooling is a potentially important technique for making scalable nmr quantum computation feasible in practice . </S>",
    "<S> given the constraints imposed by this approach to quantum computing , the most likely cooling algorithms to be practicable are those based on simple reversible polarization compression ( rpc ) operations acting locally on small numbers of bits . </S>",
    "<S> several different algorithms using 2- and 3-bit rpc operations have appeared in the literature , and these are the algorithms i consider in this note . specifically , i show that the rpc operation used in all these algorithms is essentially a majority vote of 3 bits , and prove the optimality of the best such algorithm . </S>",
    "<S> i go on to derive some theoretical bounds on the performance of these algorithms under some specific assumptions about errors . </S>"
  ]
}