{
  "article_text": [
    "nowadays mobile equipment have often more than one single network interface . for instance , laptops have usually at least both a wired ( ethernet ) and a wireless ( wifi ) network adapters . similarly smartphones and tablet pcs can reach the internet either through wifi or through a cellular network ( umts or 3g+ ) .",
    "another fact is that network operators usually duplicate links and equipments in order to protect their networks against failures , especially in the access and the backhaul networks .",
    "moreover the backbone networks are generally meshed . in this context",
    "many paths may exist between any two endpoints .",
    "the idea to use concurrently many paths has then emerged , to improve the robustness and performance of end - to - end connections .",
    "such multipath connections can indeed balance the load between the different paths , switching dynamically and automatically the traffic from congested , disrupted or broken links to the best paths .",
    "a lot of studies have considered the implementation of multipath capabilities at different layers : at the application layer @xcite , at the transport layer @xcite , @xcite , @xcite , @xcite , @xcite , @xcite , @xcite , etc . following these last references , and @xcite",
    ", we think that the transport layer is a good place to implement multipath capabilities .    at this layer , end - systems",
    "can gather information about each used path : capacity , latency , congestion state .",
    "these information can then be used to react to congestion events in the network by moving the traffic away from congested paths .",
    "an ietf s working group has recently been created to specify a multipath protocol at the transport layer multipath tcp @xcite ( mptcp ) . more precisely , this working group develop protocol extensions to transmission control protocol ( tcp ) , the most used transport protocol on internet , to handle multiple sub - connections following different paths between two endpoints .    previous works in simulating mptcp @xcite focused on congestion control mechanisms without implementing other parts of mptcp . this restriction was inherited from the used simulator , which does not allow the creation of an accurate model of the simulated protocol .",
    "our contribution consists of the proposal of a model of mpctp with a better fidelity , and also the proposal of enhancing the current version of mptcp with packet reordering mechanisms to cope with the variety of path characteristics .    in this paper",
    "we first describe mptcp in section [ sec : drafts ] , as it is specified in the current versions of the ietf drafts @xcite .",
    "we describe in section [ sec : reordering ] the implementation of two packet reordering algorithms , and how to adapt them to mptcp .",
    "then we present in section [ sec : implementation ] our implementation of mptcp under ns-3 , conform to these ietf drafts , and with some of the congestion control algorithms proposed for mptcp , for example in @xcite . in section [ sec : simulation ]",
    "we describe the simulation scenario , and comment the behaviour of the congestion window according to the used packet reordering algorithm .",
    "finally , in section [ sec : conclusion ] we conclude the paper .",
    "an ietf working group has recently been created to specify a multipath protocol for the transport layer .",
    "they propose mptcp @xcite ( multipath tcp ) , an extension of tcp to handle multiple paths between two endpoints .",
    "mptcp is designed with three major goals :    1 .",
    "* improve throughput * : the performance of a multi - path flow should be at least as good as this of a single - path flow on the best route .",
    "2 .   * do no harm * : a multi - path flow should not take up any more capacity on any one of its paths than a single - path flow using that route .",
    "* balance congestion * : a multi - path flow should move as much traffic as possible away from the most congested paths .      with mptcp , the transport layer is splitted into two sublayers . the upper one gathers the functionalities for connection management ( establishing connection , reordering packets , etc . ) .",
    "the lower sublayer manages a set of subflows that can be seen each as one single tcp flow .",
    "mptcp distinguishes two spaces of sequence numbers , one for each sublayer .",
    "each subfow has its own sequence space which is similar to the standard tcp sequence number , identifying bytes within a subflow . at the connection level ,",
    "another sequence space is used to reorder the tcp segments before sending them to the application layer .",
    "the mptcp protocol uses new tcp options to exchange signalling information between peers : especially :    * mpc * : :    ( multipath capable ) is used during the three - way handshake to    establish a multipath tcp connection . * data * : :    * fin * is used to inform the remote peer of the end of data and to    close the multipath tcp connection . *",
    "add * : :    and * remove * address ( ipv4 ) are used to inform the remote peer of the    availability of a new address or to ask it to ignore an existing one . *",
    "join * : :    is used to initiate a new sub - flow ( packet flow on a route ) between a    not already used couple of addresses .",
    "* dsn * : :    ( data sequence number ) is used as a map between the subflow level and    the data sequence space number .",
    "figure [ conestab ] illustrates the process of establishment of a mptcp connection .",
    "after that the source application sends a connect ( ) call , the transport layer establishes a connection with the destination peer which was waiting for receiving connection requests .",
    "the establishment is tcp - like ( three way handshake ) with the use of mpc option to inform the callee that the initiator is able to exchange data using multipath tcp . to initiate a new subflow",
    ", the peers must first exchange their additional ip addresses .",
    "the current mptcp draft do not specify how the exchange may happen .",
    "we have chosen to send additional tcp segments .",
    "these segments handle the addr ( add address ) option and they are sent just after the successful establishment of the mptcp connection .",
    "figure [ subflowinit ] shows the initiation of a new subflow and the presence of a join in a syn segment . to maximize the chance that the subflow under initiation takes a path which is disjoined with previously established paths , each ip address",
    "is only used by one subflow .",
    "mptcp redefines some tcp mechanisms so that they fit the multipath context .",
    "congestion control allows the sender to regulate its throughput according to the available network resources . with mptcp ,",
    "the congestion control is performed at the subflow level .",
    "each subflow has its own congestion window .",
    "however the congestion windows of the different subflows of a given tcp connection may be coupled to improve its performance .",
    "besides , at the upper sublayer , the mptcp receiver has a single global receiving window shared between the set of the established subflows . the objective is to do not limit the speed of some subflows .",
    "four different algorithms have been proposed by raiciu et al . in @xcite , coupling in various ways the congestion windows of active subflows : uncoupled , fully coupled , linked increase , and rtt compensator .",
    "they consider a simple extension of the standard congestion control mechanism tcp reno in case the round - trip time is the same for all the available paths @xmath0 .",
    "with the algorithm uncoupled , the congestion window of each subflow behaves like for a single standard tcp connection .",
    "let @xmath1 be the congestion window on path @xmath2 , and @xmath3    algorithm * fully coupled *    * @xmath4 per ack on path @xmath2 * @xmath5 per loss event on path @xmath2    most of the time either one path or another is used with this algorithm , and rarely both .",
    "this phenomenon is called `` flappiness '' . to reduce this flappiness ,",
    "the authors proposed the following algorithm :    algorithm * linked increases * @xcite    * @xmath6 per ack on path @xmath2 * @xmath7 per loss event on path @xmath2    in more general case when the round - trip times are not equal for the all paths , the authors adjust the precedent algorithm :    algorithm * rtt compensator *    * @xmath8 per ack on path @xmath2 * @xmath7 per loss event on path @xmath2",
    "with standard tcp , in networks with large packet jitter , i.e. when the end - to - end delay may vary a lot , packets may arrive out - of - sequence .",
    "this may for example be the case on wireless networks where mobile devices may change the used hotspot for accessing the internet .",
    "the reordering of a packet makes the receiver responding with duplicated acknowledgements , and this may induce the sender to infer wrongly a packet loss . to avoid this problem and to distinguish clearly between packet losses due to congestion in the network and reordering due to transmission jitter , many mechanisms have been proposed for tcp .",
    "leung et al .",
    "cite some of such mechanisms in @xcite .",
    "some of these mechanisms have been specified by the ietf @xcite",
    "@xcite @xcite , and some of them are implemented in the operating systems @xcite ( especially in the most frequent like windows , linux ... ) where they may be active by default , or not .    in multipath context , packets may also arrive out - of - sequence as the different paths may have different characteristics ( especially the end - to - end delay ) , or congestion state ( and then different queuing delays ) .",
    "the out - of - sequence arrival will create a problem for mptcp while re - assembling packets at the connection level , and not at the subflow level because subflows are independent .",
    "so we suggest to consider for mptcp similar reordering mechanisms than those proposed for standard tcp on wireless networks .",
    "some of the algorithms , like eifel @xcite @xcite and dsack @xcite , need to store the connection state ( the congestion window cwnd , the slow - start threshold ssthresh , etc . ) before retransmitting .",
    "when a spurious retransmission is detected , the saved state is restored .",
    "other algorithms , like the blanton - allman algorithm @xcite and the rr - tcp ( reordering - robust tcp ) @xcite , adjust the threshold dupthresh which is the number of received duplicated acknowledgement after which the sender considers a packet as lost and retransmits it .",
    "others proposed mechanisms make the receiver delaying the transmission of duplicated ack , like paxson algorithm @xcite , or make the sender delaying its response to congestion ( reception of three duplicated ack ) , like tcp - dcr ( delayed congestion response tcp ) @xcite .",
    "we introduce in the following subsections some standardized algorithms @xcite used by tcp to avoid packet reordering problems .",
    "figure [ eiffelalgo ] illustrates how eifel algorithm @xcite @xcite works .",
    "the sender inserts a tcp timestamp option in each transmitted segment , and the receiver inserts the timestamp value of the received segment in the corresponding acknowledgement . in case of loss ,",
    "the sender saves the values of the current congestion window ( cwnd ) and of the slow start threshold ( ssthresh ) .",
    "then the sender retransmits the missing segment and stores its timestamp value .",
    "when the sender receives an acknowledgement for a retransmitted segment , it compares the saved timestamp value with the one inserted in the acknowledgement .",
    "if the first one is greater then the retransmission is considered spurious and the values of cwnd and ssthresh are restored .",
    "figure [ dsackalgo ] illustrates how the dsack algorithm @xcite works .",
    "this algorithm is based on the sack ( selective acknowledgement ) option . at the reception of a segment that creates a hole in the sequence numbers",
    ", the receiver sends back a duplicated acknowledgement containing a sack option .",
    "the first block in the sack option refers to the segment which triggers this duplicated acknowledgements .",
    "after three duplicated acknowledgements , the sender retransmits the missing segment , saves the congestion window value , and then enters a congestion avoidance phase . after that , when the sender detects that the retransmitted segment was acknowledged twice , it infers a spurious retransmission and begin a dsack slow start to the stored congestion window s value .",
    "we have implemented mptcp under the network simulator ns-3 @xcite to evaluate mptcp s performance and to compare the different congestion control mechanisms proposed in @xcite , and also to analyze the efficiency of our own mechanisms , such as those presented in the next section .",
    "the project is hosted at google code @xcite .",
    "we opted for this simulator for its many interesting features .",
    "ns-3 is an open source network simulator , it is available for free under the gnu gplv2 @xcite license . ns-3 has a large community of developers and users , and it is the main network simulator used in the academic area .    in the following subsections ,",
    "we illustrate the different states a mptcp connection can take , the structure of our mptcp implementation , the segment flow through the different used classes and the implemented algorithms for packet reordering .",
    "the mptcp draft does not define for the moment any diagram to describe the different possible states of an mptcp connection and their transitions .",
    "however , subflows may have the same states as a standard tcp connection . for simplification",
    ", we have implemented a subset of the tcp states as described in figure [ constate ] .",
    "this figure illustrates the state diagram for a mptcp subflow to exchange data , establish and close a connection .",
    "the starting and ending states are the state closed .",
    "the established state allows data transfer between endpoints .",
    "transitions to this state correspond to a connection opening , while transitions from it correspond to a connection closing on the corresponding subflow .    to send data , the application on the source host asks the transition from close state to syn - sent state  where the host has sent a syn request ans is waiting for a syn - ack answer .",
    "when the source host receives a syn - ack segment , the connection moves to established state and an ack segment is sent .",
    "the connection on the destination host moves from close state to listen state , after a passive opening by the application .",
    "when the destination receives a syn segment , the connection moves from listen to syn - rcvd state and a syn ack segment is sent back to the source .    the application can request to close the connection .",
    "the connection is closed by moving from any state to closing state and sending a fin segment .",
    "after the receipt of a fin ack segment , the connection is totally closed and moved to closed state .",
    "the multipath transport layer is divided into two sublayers .",
    "the upper sublayer is responsible for the connection management : establishing connection , initiating subflows , etc .",
    "it is called the mptcp sub - layer .",
    "the lower sub - layer is responsible for the management of each sub - flow .",
    "the following classes ( figure [ classdia ] ) are the main ones composing the mptcp transport layer :    * ` mptcpsocketimpl ` is a subclass of the ns-3 class ` tcpsocketimpl ` .",
    "it provides to the application layer a mptcp api ( connect , bind , etc . ) to manage multipath tcp connections .",
    "it also implements the packet reordering algorithms described previously . * ` mptcpl4protocol ` is a subclass of the ns-3 class ` tcpl4protocol ` .",
    "it is an interface between the multipath transport layer and the network layer . * ` mptcpsubflow ` represents a subflow of a mptcp connection . * ` mptcpheader ` is a subclass of ` tcpheader ` .",
    "an instance of this class is a tcp header that can handle options like timestamp , mpc , etc .",
    "figure [ mptcplayer ] shows the structure of the multipath transport layer and its interfaces with the application and the network layers . the application and the multipath transport layers use the port number as an interface to communicate with each other .",
    "similarly , the network and the multipath transport layers use the protocol number .",
    "when the application has data to send , it chooses the appropriate transport layer instance using the peer source and destination port number .",
    "the ` mptcpsocketimpl ` receives the data , splits it into tcp segments of a maximum size mss and then forwards it to the appropriate subflow which is represented by a ` mptcpsubflow ` instance . at this level ,",
    "a tcp segment header is created and will contain one of the mptcp options ( dsn option if the segment contains data ) .",
    "after that , the segment is ready to be sent , it is forwarded to the ` mptcpl4protocol ` which will forward it to the network layer .    at the receiver side ,",
    "when the network layer receives a packet , it figures out the corresponding protocol number and sends the segment to the appropriate transport instance .",
    "when the ` mptcpl4protocol ` instance receives the segment , it uses the network layer addresses to find the corresponding subflow and then forward the segment to a ` mptcpsubflow ` instance .",
    "the ` mptcpsubflow ` updates the information related to its subflow ( ex : sequence number ) , then it sends the segment to the ` mptcpsocketimpl ` .",
    "the later adds the data to the previously received ones , notifies the application about the reception of new data and optionally generates a response ( ex : sends back an acknowledgement to the source ) .          in ns-3",
    ", the transport layer is implemented via the ` tcpsocketimpl ` class .",
    "this class holds many variables like m_endpoint which is an instance of ` ipv4endpoint ` .",
    "this variable maintains information about a data flow ( source - destination ports and addresses ) , and a callback for notification to higher layers that a packet from a lower layer was received .",
    "when a packet is received by an instance of tcpl4protocol , this one uses a callback ( method forwardup of m_endpoint ) to notify the upper layer ( which is represented by tcpsocketimpl ) of the reception .",
    "in fact , tcpl4protocol holds a list of pointers to ipv4endpoint variables each one attached to a tcpsocketimpl instance .    in our mptcp implementation ,",
    "the classes composing the transport layer are derived from the ones of ns-3 ( tcpsocketimpl , tcpl4protocol ) .",
    "the mptcpsocketimpl class maintains a set of subflows , a received packet may below to one of them and the m_endpoint variable is used to determine which one .",
    "when mptcpl4protocol receives a packet , it updates the m_endpoint and notify the mptcpsocketimpl about the reception of the packet .",
    "the mptcpl4protocol may receive at the same time a lot of packets belonging to different subflows . in this case",
    ", we expected that the packets will be forwarded up one by one which make easy the use of the m_endpoint variable  it will contain the information of the right subflow . instead of this , packets are forwarded up ( after removing the ipv4 header ) at once and not in the reception order .",
    "thus , the m_endpoint variable will not contain a consistent information .",
    "such a behaviour is not a problem for standard tcp . for multipath tcp",
    "it is because we can not decide to which subflow a packet belongs .    to overcome this",
    ", we used the sequence number in the segment header and for each subflow we gave a different sequence space .",
    "we used the implementation previously described to run a set of simulations in order to evaluate mptcp connection performance by varying network parameters : bandwidth , latency and loss rate .",
    "default values for these parameters are respectively : 0.5 mb / s , 10 ms , 0 .",
    "we also varied the used congestion control algorithm ( uncoupled tcps , linked increases , etc . ) and the packet reordering algorithm ( none , eifel , dsack ) .        the simulated system ( fig . [ simulation ] )",
    "is composed of a ftp application , to transfer a 10 go file , running on client / server architecture where the two hosts are linked by two point to point links .",
    "figure [ cwndeifel ] shows the behaviour of the congestion window in case the eifel algorithm is used .",
    "the graph of the congestion window of the subflow 1 oscillates between two curves of evolution : the congestion window takes its values according to the lower one in case of segment retransmission , and returns to the upper one when the eifel algorithm detects that the retransmission was spurious .",
    "figure [ cwnddsack ] illustrates the evolution of the congestion window of two subflows of a mptcp connection in case the dsack algorithm is used . in the graph of the congestion window of subflow 1 , we can see three periods of time during which the corresponding window grows unusually in an exponential way .",
    "these periods reflect the dsack slow start which is triggered by the dsack algorithm after detecting a spurious retransmission .",
    "we have implemented the mptcp protocol under the network simulator ns-3 .",
    "the implementation is conform to the ietf drafts , at least according to their release in their july 2010 .",
    "we also have added for this implementation of mptcp two packet reordering mechanisms standardized for tcp .",
    "we use now this implementation to test on simulations nonetheless under different realistic environments various congestion control and packet reordering mechanisms that could be used with the mptcp protocol . our objective to evaluate and compare the robustness and the performance of these different congestion control and packet reordering mechanisms .    based on the conducted simulations",
    ", we deduced that neither eifel nor dsack will help to face effectively performance problems due to persistent out - of - sequence packets arrival .",
    "we plan to test other packet reordering mechanisms and assess their impact on avoiding or at least alleviating this problem .              t. hacker and b. athey ,  the end - to - end performance effects of parallel tcp sockets on a lossy wide - area network , \" in ieee parallel and distributed processing symposium .",
    ", proceedings international ( ipdps ) , florida , april 2002 .",
    "ka - cheong leung , victor o.k .",
    "li and d. yang .",
    " an overview of packet reordering in transmission control protocol ( tcp ) : problems , solutions , and challenges \" .",
    "ieee transactions on parallel and distributed systems , vol .",
    "4 , april 2007 .",
    "m. zhang , j. lai , a. krishnamurthy , l. peterson and r. wang .  a transport layer approach for improving end - to - end performance and robustness using redundant paths , \" annual conference on usenix ( atec04 ) , berkeley ( ca , usa ) , june 2004 ."
  ],
  "abstract_text": [
    "<S> we present an implementation of multipath tcp ( mptcp ) under the ns-3 open source network simulator . </S>",
    "<S> mptcp is a promising extension of tcp currently considered by the recent eponymous ietf working group , with the objective of improving the performance of tcp , especially its robustness to variable network conditions . </S>",
    "<S> we describe this new protocol , its main functions and our implementation in ns-3 . besides this implementation compliant to the current versions of the ietf drafts , </S>",
    "<S> we have also added and compared various packet reordering mechanisms . </S>",
    "<S> we indeed notice that such mechanisms highly improve the performance of mptcp . </S>",
    "<S> we believe that our implementation could be useful for future works in mptcp performance evaluation , especially to compare packet reordering algorithms or coupling congestion control mechanisms between subflows .    </S>",
    "<S> [ multipath protocols ] </S>"
  ]
}