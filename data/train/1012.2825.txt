{
  "article_text": [
    "there are several known data structures that answer distance queries in planar graphs .",
    "we survey them below .",
    "all of these data structures use the following basic idea .",
    "they split the graph into _ pieces _ , where each piece is connected to the rest of the graph only through its _",
    "boundary vertices_. then , every path can go from one piece to another only through these boundary vertices .",
    "the different data structures find different efficient ways to store or compute the distance between two boundary vertices or between a boundary vertex and a non - boundary vertex .",
    "frederickson @xcite gave the first data structures that can answer distance queries in planar graphs fast .",
    "he gave a data structure of linear size with @xmath1 preprocessing time that can find the shortest path tree rooted at any vertex in @xmath2 time , where @xmath3 is the number of vertices in the graph .",
    "this leads also to an @xmath4 solution to the all - pairs shortest - paths problem , and implies a distance query data structure of size @xmath4 with @xmath5 query time .",
    "feuerstein and marchetti - spaccamela @xcite modified the data structure of @xcite and showed how to decrease the time of a distance query by increasing the preprocessing time .",
    "they do not provide an analysis of their data structure in terms of preprocessing time , storage space , and query time , but they show the total running time of @xmath6 queries , which is @xmath7 , @xmath8 , @xmath9 , @xmath10 for @xmath11 , @xmath12 , @xmath13 , @xmath14 , respectively .",
    "this solution actually consists of three different data structures for the three cases @xmath11 , @xmath15 and @xmath16 , where the data structure for the first case is the one of  @xcite .",
    "henzinger , klein , rao and subramanian @xcite gave an @xmath2 algorithm for the single - source shortest path problem .",
    "this implies a trivial distance query data structure , which uses the algorithm , and takes @xmath2 space and query time .",
    "djidjev @xcite gave three data structures .",
    "we will use the specific section number in @xcite   3 , ",
    "4 , or  5 , to refer to each one of them .",
    "the first one ( * ? ? ?",
    "* (  3 ) ) works for @xmath17 $ ] and has size @xmath18 , @xmath18 preprocessing time , and @xmath19 query time .",
    "the same data structure was also presented by arikati et al .",
    "this data structure is similar to the two data structures of @xcite , but takes advantage of the algorithm of @xcite to get a better preprocessing time .",
    "the second ( * ? ? ?",
    "* (  4 ) ) works for @xmath20 $ ] and has size @xmath18 , @xmath21 preprocessing time , and @xmath19 query time .",
    "the third data structure ( * ? ? ? * (  5 ) ) works for @xmath22 $ ] , has size @xmath18 , @xmath21 preprocessing time , and @xmath23 query time.$ ] with @xmath24 query time , however the same data structure works for a larger range of @xmath25 , and the running time is actually @xmath23.[ftnt : d96 ] ] chen and xu @xcite presented a data structure with the same time and space bounds .",
    ", the bounds here are derived by setting @xmath26 in the bounds that appear below lemma 28 ( page 477 ) of @xcite ; the bounds stated in @xcite depend on the minimum number @xmath27 of faces required to cover all vertices of the graph ( @xmath27 is called _ face - on - vertex covering _ ) , these bounds are obtained using hammock decomposition @xcite , which can be applied to any planar distance data structure.[ftnt : cx00 ] ]    fakcharoenphol and rao @xcite gave a data structure with @xmath1 space and @xmath28 preprocessing time and @xmath29 query time .",
    "klein @xcite improved the preprocessing time of the data structure to @xmath30 .",
    "cabello @xcite presented a data structure that uses @xmath18 space and can be constructed in @xmath18 time for @xmath31 $ ] , and answers a query in @xmath32 time .",
    "this data structure can answer @xmath6 queries in a total of @xmath33 time .",
    "if the queries are known in advance , the algorithm of @xcite avoids storing the entire structure , and uses only @xmath34 space .",
    "other data structures exist for outerplanar graphs ( some use the fact that these graphs have treewidth @xmath35 ) and planar graphs with small face - on - vertex covering @xcite , for planar graphs with bounded edge lengths @xcite , and for approximate distance queries in planar graphs @xcite .",
    "in this paper we present three new data structures for the problem :    * section [ sec : a ] : a data structure with @xmath2 space , @xmath1 preprocessing time , and @xmath36 query time , for a constant @xmath37 .",
    "this data structure has the best known query time achievable with linear space .",
    "this also improves the total running time for answering @xmath6 distance queries when @xmath6 is @xmath38 and @xmath39 , and if we limit ourselves to data structures with @xmath34 space then the upper bound on the range of @xmath6 grows to @xmath40 .",
    "the data structure is based on the data structure of @xcite , by replacing the _ recursive decomposition _ of @xcite with recursive _ @xmath41-decomposition _ as in @xcite .",
    "as the data structure of @xcite , our data structure also generalizes to graphs embedded in a surface of bounded genus .",
    "* section [ sec : b ] : for @xmath42 $ ] , a data structure with @xmath18 space , @xmath43 preprocessing time , and @xmath23 query time .",
    "this data structure matches the storage space and query time of ( * ? ? ?",
    "* ; * ? ? ?",
    "* (  5 ) ) , which is the best query time for this range of storage space , with a better preprocessing time for @xmath44 . the data structure is obtained by combining a preprocessing algorithm similar to @xcite with a data structure similar to ( * ? ? ?",
    "* (  5 ) )",
    ". * section [ sec : c ] : for @xmath42 $ ] , a data structure with @xmath18 space , requiring @xmath45 preprocessing time , and @xmath46 query time .",
    "this data structure has the fastest query time for the same range of storage space as the previous data structure , but with a longer preprocessing time .",
    "the fast query time is obtained using an efficient minimum search in a monge matrix .",
    "the different data structures are summarized in table [ table : sum ] .",
    ".comparison of distance query data structures for planar graphs .",
    "time bounds are expressed as a function of the storage space .",
    "the data structures are ordered by decreasing storage space and then by decreasing query time . [ cols=\"^,^,^,^\",options=\"header \" , ]",
    "we consider a directed simple planar graph @xmath47 .",
    "we let @xmath48 , and by euler s formula @xmath49 .",
    "we assume that @xmath50 is given with a fixed planar embedding , in other words it is a _",
    "plane graph_. without loss of generality we assume that @xmath50 is a triangulated , bounded degree graph ; this assumption is required by algorithms that we use and are described in sect .",
    "[ sec : decomp ] and [ sec : dense ] .",
    "we assume that @xmath50 is connected , since we can handle each connected component separately .",
    "every edge in @xmath51 has a non - negative _",
    "length_. the length of a _ path _ is the sum of lengths of all of its edges .",
    "the _ distance _ from a vertex @xmath52 to a vertex @xmath53 is the minimum length of a path from @xmath52 to @xmath53 . with additional @xmath54 preprocessing time we can allow negative edge lengths as well ,",
    "see @xcite for details .",
    "let @xmath55 be subgraphs of @xmath50 .",
    "we write @xmath56 to denote the distance from @xmath52 to @xmath53 in @xmath57 .",
    "the graph @xmath58 is the subgraph induced by @xmath59 . for short we denote @xmath60 .",
    "a _ decomposition _ of a planar graph @xmath50 is a set of subgraphs of @xmath50 , such that each edge is in exactly one subgraph and each vertex of @xmath50 is in at least one subgraph .",
    "each of the subgraphs which define the decomposition is called a _ piece_.",
    "a vertex @xmath53 is a _ boundary vertex _ of a piece @xmath61 , if @xmath62 and @xmath53 is incident to some edge not in @xmath63 .",
    "the set of all boundary vertices of @xmath61 is the _ boundary _ of @xmath61 , denoted by @xmath64 .",
    "a _ hole _ is a face of @xmath61 ( including the external face ) that is not a face of @xmath50 . for a hole @xmath57",
    "we denote by @xmath57 also the subgraph of @xmath50 inside @xmath57 .",
    "boundary walk _ of @xmath61 is a facial walk of @xmath61 around a hole @xmath57 . for a piece @xmath61 with hole @xmath57",
    "we denote @xmath65 = \\partial b \\cap v(h)$ ] .",
    "a vertex of @xmath66 is an _ internal vertex _ of @xmath61 .",
    "all distance query data structures mentioned in the introduction decompose the planar graph .",
    "they take advantage of the fact that a path can go from one piece to another only through boundary vertices .    a _ recursive decomposition _",
    "@xcite is obtained by starting with @xmath50 itself being the only piece in level 0 of the decomposition . at each level",
    ", we split each piece @xmath61 with @xmath67 vertices and @xmath68 boundary vertices that has more than one edge into two pieces , each with at most @xmath69 vertices and at most @xmath70 boundary vertices .",
    "we require that the boundary vertices of a piece @xmath61 are also boundary vertices of the subpieces of @xmath61 .",
    "each piece @xmath61 in the decomposition has @xmath71 boundary vertices .",
    "an _ @xmath41-decomposition _",
    "@xcite is a decomposition of the graph into @xmath72 pieces , each of size at most @xmath41 with @xmath73 boundary vertices .",
    "fakcharoenphol and rao @xcite showed how to find a recursive decomposition of @xmath50 , such that each piece is connected and has at most a constant number of holes .",
    "they use these two properties for their distance algorithm .",
    "the construction of the decomposition takes @xmath1 time using @xmath1 space , and is done by recursively applying the separator algorithm of miller @xcite .",
    "frederickson @xcite showed how to find an @xmath41-decomposition in @xmath1 time and @xmath2 space by recursively applying the separator algorithm of lipton and tarjan @xcite .",
    "thus , an @xmath41-decomposition is a limited type of recursive decomposition where we stop the recursion earlier ( when we get to pieces of size @xmath41 ) , and do not store all the levels of the recursion ( we store only the leaves ) .",
    "cabello @xcite combined the two constructions of @xcite ( using @xcite instead of @xcite ) and constructed an @xmath41-decomposition with the properties that the number of holes per piece is bounded by a constant , and that each piece is connected .    in sect .",
    "[ sec : a ] we use a combination of recursive decomposition and @xmath41-decomposition  we decompose the graph recursively , but we decompose each piece into @xmath72 pieces instead of 2 . in sect .",
    "[ sec : b ] we use @xmath41-decomposition . in sect .",
    "[ sec : c ] we use @xmath41-decomposition as well , there we take advantage of the fact that the construction of an @xmath41-decomposition is the same as of a recursive decomposition , which was stopped earlier .      fakcharoenphol and rao @xcite define the _ dense distance graph _ of a recursive decomposition . for each piece",
    "@xmath61 in the recursive decomposition they add a piece to the dense distance graph that contains the vertices of @xmath64 and for every @xmath74 an edge from @xmath52 to @xmath53 whose length is @xmath75 .",
    "the multiple - source shortest paths algorithm of klein @xcite finds @xmath6 distances where the sources of all of them are on the same face in @xmath76 time .",
    "therefore , using @xcite it takes @xmath77 time to find the part of the dense distance graph that corresponds to a piece @xmath61 ( recall that @xmath78 and @xmath61 has a constant number of holes ) .",
    "it thus takes @xmath30 time to construct the dense distance graph over all pieces of the recursive decomposition .",
    "every single edge defines a piece in the base of the recursion , so it is clear that the distance from @xmath52 to @xmath53 in the dense distance graph is the same as the distance between these two vertices in the original graph .",
    "fakcharoenphol and rao noticed that in order to find the distance from @xmath52 to @xmath53 we do not have to search the entire dense distance graph , but that it suffices to consider only edges that correspond to shortest paths between boundary vertices in a limited number of pieces .",
    "the pieces are these containing either @xmath52 or @xmath53 , and their siblings in the recursive decomposition .",
    "there are @xmath79 such pieces with a total of @xmath80 boundary vertices .",
    "fakcharoenphol and rao gave an implementation of dijkstra s algorithm that runs over a subgraph of the dense distance graph with @xmath81 vertices , defined by a partial set of the pieces in the recursive decomposition , in @xmath82 time .",
    "this gives the @xmath83 query time of their data structure .",
    "we use dense distance graphs in two of our data structures ( sect .",
    "[ sec : a ] and [ sec : c ] ) . in both cases",
    "it is on a variant of recursive decomposition , as discussed above .",
    "a @xmath84 matrix @xmath85 satisfies the _ monge property _ if for every two rows @xmath86 and two columns @xmath87 , @xmath85 satisfies @xmath88",
    ". we can find the minimum element of @xmath85 by transposing , negating and reversing @xmath85 , and using the smawk algorithm @xcite for row - maxima on the resulting totally monotone matrix . if we do not store @xmath85 explicitly , but are able to retrieve each entry in @xmath5 time this takes @xmath89 time . note that if we add a constant to an entire row or to an entire column of a matrix with the monge property , then the property remains .",
    "consider two disjoint sets @xmath90 and @xmath91 of consecutive boundary vertices on a boundary walk of some piece @xmath61 .",
    "rank the vertices of @xmath90 from @xmath92 to @xmath93 according to their order around the boundary walk , and rank the vertices of @xmath91 from @xmath94 to @xmath95 according to their order in the opposite direction around the boundary walk . for",
    "@xmath86 and @xmath87 , the shortest path from @xmath96 to @xmath97 inside @xmath61 and the shortest path from @xmath98 to @xmath99 inside @xmath61 must cross each other .",
    "let @xmath100 be a vertex common to both paths .",
    "then , @xmath101 ( see fig .  [",
    "fig : monge ] ) .",
    "therefore , the matrix @xmath85 such that @xmath102 has the monge property . the monge property was first used explicitly for distance queries in planar graphs by @xcite .",
    "@xmath103    a _ partial matrix _ is a matrix that may have some blank entries . in a _ falling staircase matrix _",
    "the non - blank entries are consecutive in each row starting not before the first non - blank entry of the previous row and ending at the end of the row ( see fig .",
    "[ fig : stair ] ) , _ inverse falling staircase matrix _ is defined similarly by exchanging the positions of the non - blanks and the blanks .",
    "aggarwal and klawe @xcite find the minimum of an ( inverse ) falling staircase matrix whose non - blank entries satisfy the monge property in @xmath104 time by filling the blanks with large enough values to create a monge matrix .    in sect .",
    ": c ] we use this tool for finding the minimum of two staircase matrices whose non - blank entries satisfy the monge property .",
    "in this section we present a data structure with linear space , almost linear preprocessing time , and query time faster than any previous data structure of linear space .",
    "we generalize the data structure of fakcharoenphol and rao @xcite by combining recursive decomposition of the graph with @xmath41-decomposition .",
    "this is similar to the way that mozes and wulff - nilsen @xcite improved the shortest path algorithm of klein , mozes and weimann @xcite .",
    "mozes and sommer @xcite have independently obtained a similar result .",
    "we find an @xmath41-decomposition of @xmath50 into @xmath105 pieces , and then we recursively decompose each piece into @xmath27 subpieces , until we get to pieces with a single edge .",
    "the depth of the decomposition is @xmath106 where at level @xmath107 we have @xmath108 pieces , each of size @xmath109 and with @xmath110 boundary vertices .",
    "constructing this recursive decomposition takes @xmath111 time .",
    "an alternative way to describe this decomposition is to perform a recursive decomposition on @xmath50 while storing only levels @xmath112 for @xmath113 of the recursion tree and the leaves of the recursion ( the pieces containing single edges ) .",
    "we compute the dense distance graph for the recursive decomposition , in the same way as in the data structure of @xcite .",
    "that is , we compute the distance between every pair of boundary vertices in each piece . using the algorithm of klein @xcite this takes @xmath1 time for each level , and a total of @xmath111 time .",
    "the size of dense distance graph over our recursive decomposition is @xmath114 .",
    "when a distance query from @xmath52 to @xmath53 arrives , we use the dijkstra implementation of @xcite to answer it .",
    "we run the algorithm on the subgraph of the dense distance graph that includes all the pieces that contain either @xmath52 or @xmath53 , and the @xmath115 siblings in the recursive decomposition of each such piece .",
    "we require the sibling pieces because the shortest path can get out of a piece @xmath61 into a sibling of @xmath61 without getting out of any piece that contains @xmath61 .",
    "therefore , the number of boundary vertices involved in each distance query is @xmath116 .",
    "hence the query time using the algorithm of @xcite is @xmath117 .",
    "we conclude that for a planar graph with @xmath3 vertices and any @xmath118 $ ] , we can construct in @xmath119 time a data structure of size @xmath120 that computes the distance between any two vertices in @xmath117 time .",
    "if we set @xmath121 we get exactly the data structure of @xcite .",
    "if we set @xmath122 for a constant @xmath123 we get :    [ col : a ] for a planar graph with @xmath3 vertices and any constant @xmath37 , we can construct in @xmath1 time a data structure of size @xmath2 that computes the distance between any two vertices in @xmath36 time .",
    "the total time for @xmath6 distance queries is @xmath124 and the required space is @xmath34 .",
    "this improves the fastest time for @xmath6 distance queries for @xmath125 and @xmath126 simultaneously . among data structures that require only @xmath34 space ,",
    "the upper bound on the range of @xmath6 is @xmath40 .",
    "fakcharoenphol and rao @xcite noted that smith suggested that their algorithm can be generalized to graphs of bounded genus . if a graph @xmath50 with bounded vertex degree",
    "is embedded in an orientable surface of genus @xmath127 , then @xcite showed how to find a _ planarizing set _ of @xmath128 edges whose removal from the graph makes the graph planar , in @xmath129 time .",
    "we use the planarizing set for the first decomposition of the graph , and combine the dijkstra implementation of @xcite with standard implementation using a heap for the topmost pieces in the recursion .",
    "we get that the bounds of theorem [ col : a ] apply also to graphs embedded in an orientable surface of a fixed genus .",
    "in this section we present a data structure that matches the space - query time tradeoff of the data structures of djidjev ( * ? ? ? * (  5 ) ) and chen and xu @xcite with the preprocessing time of the data structure of cabello @xcite .",
    "our data structure combines parts of the data structures of ( * ? ? ?",
    "* (  5 ) ) and of @xcite .",
    "first , we construct an @xmath41-decomposition of @xmath50 in @xmath1 time , for some parameter @xmath130 . for each piece",
    "@xmath61 our data structure has three parts :    a.   the distances @xmath131 and @xmath132 for every @xmath133 and @xmath62 .",
    "b.   a data structure that reports @xmath75 in @xmath73 time for @xmath134 . c.   for each hole @xmath57 of @xmath61 we store @xmath135 for every",
    "@xmath136 $ ] and @xmath137 such that @xmath53 is a boundary vertex of some piece contained in @xmath57 .",
    "part ( i ) is from the data structure of cabello @xcite .",
    "the construction of this part requires @xmath138 time and @xmath139 space per piece @xcite . part ( ii ) was used both by djidjev ( * ? ? ? * (  5 ) ) and by cabello @xcite .",
    "this is the data structure of ( * ? ? ?",
    "* ; * ? ? ?",
    "* (  3 ) ) with @xmath140 , its construction takes @xmath141 time and space per piece . part ( iii ) is from the data structure of ( * ? ? ? * (  5 ) ) , but we construct it more efficiently .",
    "we find the distances for this part using the multiple - source shortest paths algorithm of klein @xcite for every boundary walk .",
    "the required space per piece for part ( iii ) is @xmath2 and the preprocessing time is @xmath1 .",
    "since there are @xmath72 pieces , each with a constant number of holes and @xmath73 boundary vertices , constructing the three parts takes @xmath142 time and @xmath143 space .",
    "let @xmath144 be a query pair .",
    "we use the data structure of this section to find @xmath131 in @xmath145 time .",
    "if @xmath52 and @xmath53 are in the same piece then we find the distance from @xmath52 to @xmath53 using parts ( i ) and ( ii ) of the data structure with the query algorithm of @xcite in @xmath73 time ( see details in sect .",
    "[ sec : cq ] below ) .",
    "if @xmath52 and @xmath53 are in different pieces then we find the distance using parts ( i ) and ( iii ) with the query algorithm of ( * ? ? ?",
    "* (  5 ) ) in @xmath145 time ( see details in appendix [ apx : b ] ) .",
    "we conclude that for a planar graph with @xmath3 vertices and any @xmath146 , we can construct in @xmath147 time a data structure of size @xmath148 that computes the distance between any two vertices in @xmath149 time .",
    "the sum @xmath150 minimizes at @xmath151 , and for @xmath152 we get :    for a planar graph with @xmath3 vertices and @xmath42 $ ] , we can construct in @xmath43 time a data structure of size @xmath18 that computes the distance between any two vertices in @xmath23 time .",
    "in this section we present a data structure with an improved query time , for the same range of space bounds as in the previous section . in return",
    ", the preprocessing time is higher . for this purpose",
    "we use minimum search in monge matrices .",
    "while previous planar distance data structures have taken advantage of the monge property before , this is the first to use fast minimum search in a monge matrix with the smawk algorithm @xcite .",
    "again , we construct an @xmath41-decomposition of @xmath50 .",
    "assume that we want to find the distance from a vertex @xmath52 to a vertex @xmath53 that are in two different pieces .",
    "let @xmath61 and @xmath153 be the different pieces that contain @xmath52 and @xmath53 respectively , let @xmath57 and @xmath154 be the holes of @xmath61 and @xmath153 that contain @xmath53 and @xmath52 respectively , and let @xmath155 $ ] and @xmath156 $ ] .",
    "let @xmath157 be the subgraph of @xmath50 contained both in @xmath57 and in @xmath154 .",
    "we assume without lost of generality that @xmath158 contains the infinite face .",
    "see fig .",
    "[ fig : subgraphj ] .    .",
    "the vertex @xmath52 is in the piece @xmath61 , and @xmath53 is in @xmath153 .",
    "the subgraph @xmath158 is between @xmath61 and @xmath153 .",
    "every path from @xmath52 to @xmath53 must contain a vertex from the boundary walks @xmath90 of @xmath61 and a vertex from the boundary walk @xmath91 of @xmath153 . ]    the shortest path from @xmath52 to @xmath53 must contain a vertex @xmath159 and a vertex @xmath160 ( it is possible that @xmath161 ) .",
    "we assume that there is no internal vertex of @xmath61 or @xmath153 between @xmath162 and @xmath163 in this path , since otherwise we can replace @xmath162 with a later vertex .",
    "therefore , @xmath164 .",
    "our goal then is to find @xmath165 that minimize @xmath166 . for a particular order of @xmath90 and of @xmath91 , which we specify below",
    ", let @xmath85 be the matrix such that @xmath167 , and @xmath168 be the matrix such that @xmath169 .",
    "we show how to order the members of @xmath90 and @xmath91 such that @xmath85 decomposes into two staircase matrices , each with the monge property .",
    "since @xmath170 is fixed for a fixed @xmath96 , and @xmath171 is fixed for a fixed @xmath99 , then @xmath168 also consists of two staircase matrices with the monge property .",
    "thus we can use the algorithm of aggarwal and klawe @xcite to find the minimum entry of @xmath168 , which is the desired distance .    for every @xmath159 we define the _ leftmost shortest path from @xmath162 to @xmath91 _ , denoted by @xmath172 as follows .",
    "we add to the embedding of @xmath158 a vertex @xmath173 inside @xmath61 and connect it with an edge to @xmath162 , and a vertex @xmath174 inside @xmath153 and connect it with edges from every vertex of @xmath91 ( recall the internal vertices of @xmath61 and @xmath153 are not in @xmath158 ) .",
    "we set the length of all new edges to be @xmath175 .",
    "an edge @xmath176 is called _ tight _ if the length of @xmath177 is equal to @xmath178 , that is if @xmath177 is on some shortest path from @xmath173 to @xmath179 .",
    "we remove all non - tight edges from the graph , and perform a _ left - first search _ from @xmath173 until we find @xmath174 ( i.e. we perform a depth - first search from @xmath173 , and visit the edges outgoing from a specific vertex according to their left - to - right order , see also @xcite ) .",
    "let @xmath172 be the path we obtain by removing the first and the last edges of the leftmost path we found from @xmath173 to @xmath174 , and let @xmath180 be the last vertex of @xmath172 .",
    "note that @xmath172 is a shortest path from @xmath162 to @xmath181 .",
    "the reason we added @xmath173 is to decide between two paths that diverge at @xmath162 itself , the reason we added @xmath174 is to decide between two paths such that one is a prefix of the other . note that @xmath172 may contain more than one vertex of @xmath91 .",
    "moreover , even if @xmath182 it is not necessarily true that @xmath183 . see fig .",
    "[ fig : leftfs ] .    .",
    "only tight edges of @xmath158 are shown , @xmath61 and @xmath153 are _ shaded_. the leftmost path from @xmath173 to @xmath174 is _ bold _ , @xmath184 , @xmath172 is its subpath between @xmath162 and @xmath163 . directions of the edges are not shown . ]    fix some arbitrary vertex of @xmath90 to be @xmath92 and rank the other vertices of @xmath90 in a clockwise order .",
    "let @xmath185 , and rank the vertices of @xmath91 in a counterclockwise order .",
    "let @xmath186 .",
    "[ lem : c ] let @xmath187 and @xmath188 .",
    "there is a shortest path @xmath189 in @xmath158 from @xmath96 to @xmath99 such that either @xmath189 does not cross @xmath190 , or every prefix of @xmath189 crosses @xmath190 from the left side of @xmath190 to its right side at most once more than it crosses @xmath190 from its right side to its left side .",
    "assume that every shortest path from @xmath96 to @xmath99 in @xmath158 crosses @xmath190 , and let @xmath189 be such a path .",
    "first , we can assume that at the first time that @xmath189 emanates from @xmath190 it emanates from its right side ",
    "if @xmath189 emanates from the left side of @xmath190 at a vertex @xmath100 , we can replace the suffix of @xmath190 that starts at @xmath100 with the suffix of @xmath189 and get a path from @xmath92 to @xmath99 which is to the left of @xmath190 , contradicting its definition as @xmath172 ( see fig .  [",
    "fig : qxp](a ) ) .",
    "second , we may assume that if @xmath189 meets @xmath190 at a vertex @xmath100 , and then again at a vertex @xmath191 such that @xmath191 is after @xmath100 also in @xmath190 , then the subpath of @xmath189 between @xmath100 and @xmath191 is the same subpath as in @xmath190 , since otherwise we can replace the subpath of @xmath189 between @xmath100 and @xmath191 with the subpath of @xmath190 ( see fig .",
    "[ fig : qxp](b ) ) .",
    "last we may assume that in two consecutive times that @xmath189 crosses @xmath190 it does so from different directions , since if the same direction is repeated twice , and by the previous observation the second crossing precedes the first crossing in their order in @xmath190 , then @xmath189 must cross itself ( see fig .",
    "[ fig : qxp](c ) ) . from these three observations",
    "the lemma follows .",
    "+    let @xmath192 be the partial matrix of @xmath85 where @xmath193 is non - blank if there is a shortest path in @xmath158 from @xmath96 to @xmath99 that does not cross @xmath190 , and let @xmath194 be the partial matrix of @xmath85 where @xmath195 is non - blank if every shortest path from @xmath96 to @xmath99 crosses @xmath190 .",
    "the partial matrix @xmath192 has the monge property , we get this by cutting open @xmath158 along @xmath190 and using the claim from sect .",
    "[ sec : monge ] ( see @xmath196 in fig .  [",
    "fig : qxp](d ) ) .",
    "a similar argument ( by taking two copies of @xmath158 open at @xmath190 and `` gluing '' the right side of one of them to the left side of the other ) shows that @xmath194 also has the monge property ( see @xmath197 in fig .",
    "[ fig : qxp](d ) ) .",
    "the non - blank entries of row @xmath107 in @xmath192 are from @xmath198 to @xmath185 , and the rest of the row is in @xmath194 .",
    "the partial matrix @xmath192 is a falling staircase matrix and @xmath194 is an inverse falling staircase matrix , since @xmath199 , the leftmost path from @xmath200 to @xmath91 , can not cross the path @xmath201 from its right side to its left ( this is similar to the illustration in fig .",
    "[ fig : qxp](a ) ) .",
    "let @xmath202 and @xmath203 be the corresponding staircase matrices partial to @xmath168 ( with same blank entries as @xmath192 and @xmath194 respectively ) , both of them have the monge property .",
    "in order use the insights above , we take parts ( i ) and ( ii ) of the data structure of the previous section together with the following two new parts , where @xmath204 and @xmath158 are as defined above ( part ( iii ) is not necessary ) :    a.   for each two pieces @xmath61 and @xmath153 we store @xmath205 for every @xmath159 , @xmath160 .",
    "b.   for each two pieces @xmath61 and @xmath153 , and every @xmath159 , we store @xmath181 .",
    "notice that @xmath205 and @xmath181 depend on the specific pieces @xmath61 and @xmath153 .",
    "since there are @xmath206 pieces , each piece has @xmath207 boundary vertices , and each vertex is on the boundary of a constant number of pieces , the total space required for part ( iv ) is @xmath208 and for part ( v ) is @xmath209 .",
    "this does not increase the total space complexity of the data structure which remains @xmath148 .",
    "we have an @xmath41-decomposition of @xmath50 obtained by a recursive decomposition , where we decomposed each piece into two pieces using a separator and stopped the recursion at pieces of size @xmath210 , from which we took only the pieces that correspond to leaves of the recursion tree .",
    "now we will take all the pieces of the entire recursive decomposition which defined the @xmath41-decomposition .",
    "we build a dense distance graph for @xmath50 based on this recursive decomposition using the algorithm of fakcharoenphol and rao @xcite with the improvement of klein @xcite in @xmath30 time and @xmath1 space .    for two fixed pieces @xmath61 and",
    "@xmath153 we use a subgraph of the dense distance graph to compute the distances from vertices of @xmath90 to vertices of @xmath91 in @xmath158 .",
    "we should choose carefully a set @xmath25 of pieces of the recursive decomposition to use , we must obey three rules  we can not take any piece of the @xmath79 pieces that contain either @xmath61 or @xmath153 , we should cover all the paths from @xmath90 to @xmath91 , and the total number of boundary vertices of pieces in @xmath25 should not be too large .",
    "we start with the entire graph @xmath50 , which is the root of the recursive decomposition , as the single piece in @xmath25 .",
    "as long as there is a piece @xmath211 in @xmath25 containing either @xmath61 or @xmath153 in it ( @xmath211 is an ancestor of @xmath61 or @xmath153 in the recursive decomposition ) , we replace @xmath211 with both of its two children in the recursion tree . when we get to @xmath61 or @xmath153",
    ", we remove them from @xmath25 . at the end of this process",
    ", @xmath25 contains @xmath79 pieces with @xmath80 boundary vertices .",
    "all the vertices of @xmath90 and @xmath91 are boundary vertices of pieces of @xmath25 ( because otherwise such a vertex will be internal vertex of some member of @xmath25 , which is an ancestor of @xmath61 or @xmath153 ) , and the paths between them in @xmath158 are covered by @xmath25 ( since @xmath25 only misses internal vertices of @xmath61 and @xmath153 ) , as required .",
    "denote the subgraph of the dense distance graph that include exactly the pieces of @xmath25 by @xmath212 .    for @xmath159 , we compute part ( iv ) , by computing @xmath205 for every @xmath160 using the dijkstra implementation of @xcite on @xmath212 in @xmath83 time .",
    "we use the distances of vertices of @xmath212 from @xmath162 to find @xmath181 for part ( v ) as well .",
    "we add to @xmath212 a vertex @xmath173 inside @xmath61 and connect it to @xmath162 , and a vertex @xmath174 inside @xmath153 and connect every vertex of @xmath91 to it , as described before . since we added an edge with length @xmath175 from @xmath173 to @xmath162 , for every vertex @xmath179 in @xmath212 , @xmath213 , so we can determine for each edge of @xmath212 whether it is tight in a constant time . even though @xmath212 is not planar",
    ", we can define a cyclic order on the edges incident to each vertex using the embedding of @xmath50 .",
    "the order of edges incident to a specific vertex of @xmath212 is defined by the order of the shortest paths in @xmath50 that they represent . due to space constraint",
    "we give the complete details of this process which takes total time of @xmath28 in appendix [ apx : c ] .",
    "then , we ignore all non - tight edges in @xmath212 and find @xmath181 by finding the leftmost path from @xmath173 to @xmath174 .",
    "this takes time proportional to the number of vertices in @xmath212 , which is @xmath80 .",
    "we perform the computation of parts ( iv ) and ( v ) for every @xmath61 and @xmath153 , and @xmath159 . for every @xmath162 this computation takes @xmath83 time , and we repeat it @xmath209 times .",
    "the total time required for constructing the data structure is @xmath214 ( note that the term @xmath215 is dominated by this bound ) .",
    "we note that it is also possible to perform the computation in @xmath216 time using the algorithm of klein @xcite for every pair of pieces , however this does not improve the time bound for our range of @xmath41 .",
    "let @xmath144 be a query pair .",
    "we use the data structure of this section to find @xmath131 in @xmath73 time . again , let @xmath61 , @xmath153 be the pieces that contain @xmath52 , @xmath53 respectively .",
    "if @xmath217 then we can answer the query in @xmath73 time in same way as in the previous data structure , which uses the query algorithm of @xcite .",
    "either the shortest path from @xmath52 to @xmath53 is inside @xmath61 or the shortest path contains some vertex @xmath218 . in other words , @xmath219 .",
    "we retrieve the distance @xmath75 from part ( ii ) of the data structure in @xmath73 time . for each @xmath218",
    "we retrieve @xmath220 from part ( i ) in @xmath5 time .",
    "since @xmath221 , it takes @xmath73 time to go over all vertices of @xmath64 and find @xmath218 that minimizes @xmath220 . then , @xmath131 is the minimum between @xmath75 and @xmath220 .    for the case where @xmath52 and @xmath53 are in different pieces , let @xmath90 and @xmath91 be as before .",
    "fix @xmath92 to be an arbitrary vertex of @xmath90 and let @xmath185 .",
    "let the matrices @xmath168 , @xmath202 , @xmath203 be as before .",
    "we compute an entry @xmath222 in @xmath5 time using parts ( i ) and ( iv ) of the data structure .",
    "we determine whether an entry of @xmath168 is in @xmath202 or in @xmath203 in @xmath5 time using part ( v ) .",
    "therefore , we can use the smawk algorithm @xcite as in @xcite to find the minimum value in @xmath168 in @xmath73 time .",
    "this value is the requested distance .",
    "we conclude that for a planar graph with @xmath3 vertices and any @xmath146 , we can construct in @xmath223 time a data structure of size @xmath148 that computes the distance between any two vertices in @xmath73 time . as in sect .",
    "[ sec : b ] , we set @xmath152 and get :    for a planar graph with @xmath3 vertices and @xmath42 $ ] , we can construct in @xmath45 time a data structure of size @xmath18 that computes the distance between any two vertices in @xmath46 time .    10    aggarwal , a. , klawe , m.  m. , moran , s. , shor , p. , wilber , r. : geometric applications of a matrix - searching algorithm .",
    "algorithmica 2 , 195 - 208 ( 1987 ) .",
    "aggarwal , a. , klawe , m. : applications of generalized matrix searching to geometric algorithms .",
    "discrete appl .",
    "27 , 3 - 23 ( 1990 ) .",
    "arikati , s.  r. , chen , d.  z. , chew , l.  p. , das , g. , smid , m.  h. , zaroliagis , c.  d. : planar spanners and approximate shortest path queries among obstacles in the plane . in : proceedings of the fourth annual european symposium on algorithms .",
    "lecture notes in computer science , vol .  1136 , pp .  514 - 528",
    "springer - verlag ( 1996 ) .",
    "bodlaender , h.  l. : dynamic algorithms for graphs with treewidth 2 . in : proceedings of the 19th international workshop on graph - theoretic concepts in computer science .",
    "lecture notes in computer science , vol .",
    "790 , pp .",
    "112 - 124 .",
    "springer - verlag ( 1994 ) .",
    "cabello , s. : many distances in planar graphs .",
    "algorithmica ( to appear ) .",
    "doi : 10.1007/s00453 - 010 - 9459 - 0 .",
    "chaudhuri , s. , zaroliagis , c.  d. : shortest paths in digraphs of small treewidth .",
    "part i : sequential algorithms .",
    "algorithmica 27 , 212 - 226 ( 2000 ) .",
    "chen , d.  z. : on the all - pairs euclidean short path problem . in : proceedings of the sixth annual acm - siam symposium on discrete algorithms , pp .  292 - 301 .",
    "siam , philadelphia ( 1995 ) .",
    "chen , d.  z. , xu , j. : shortest path queries in planar graphs . in : proceedings of the thirty - second annual acm symposium on theory of computing , pp .",
    "469 - 478 .",
    "acm , new york ( 2000 ) .",
    "djidjev , h.  n. : efficient algorithms for shortest path queries in planar digraphs . in : graph - theoretic concepts in computer science .",
    "lecture notes in computer science , vol .  1197 , pp",
    ".  151 - 165 .",
    "springer - verlag ( 1997 ) .",
    "djidjev , h.  n. , pantziou , g.  e. , zaroliagis , c.  d. : computing shortest paths and distances in planar graphs . in : proceedings of the 18th international colloquium on automata , languages and programming .",
    "lecture notes in computer science , vol .",
    "510 , pp .",
    "327 - 338 .",
    "springer - verlag ( 1991 ) .",
    "djidjev , h.  n. , pantziou , g.  e. , zaroliagis , c.  d. : on - line and dynamic algorithms for shortest path problems , in : proceedings of 12th stacs .",
    "lecture notes in computer science , vol .",
    "900 , pp .",
    "193 - 204 .",
    "springer - verlag ( 1995 ) .",
    "dijdjev , h.  n. , venkatesan , s.  m. : planarization of graphs embedded on surfaces . in : proceedings of the 21st international workshop on graph - theoretic concepts in computer science .",
    "lecture notes in computer science , vol .  1017 , pp .",
    "springer - verlag ( 1995 ) .",
    "eppstein , d. : subgraph isomorphism in planar graphs and related problems . j. graph algorithms appl .  3 , 1 - 27 ( 1999 ) .",
    "fakcharoenphol , j. , rao , s. : planar graphs , negative weight edges , shortest paths , and near linear time .",
    "j.  comput .",
    "72 , 868 - 889 ( 2006 ) .",
    "feuerstein , e. , marchetti - spaccamela , a. : dynamic algorithms for shortest paths in planar graphs .",
    "116 , 359 - 371 ( 1993 ) .",
    "frederickson , g.  n. : fast algorithms for shortest paths in planar graphs , with applications .",
    "siam j.  comput .",
    "16 , 1004 - 1022 ( 1987 ) .",
    "frederickson , g.  n. : using cellular graph embeddings in solving all pairs shortest paths problems .",
    "j.  algorithms 19 , 45 - 85 ( 1995 ) .",
    "frederickson , g.  n. : searching among intervals and compact routing tables .",
    "algorithmica 15 , 448 - 466 ( 1996 ) .",
    "henzinger , m.  r. , klein , p. , rao , s. , subramanian , s. : faster shortest - path algorithms for planar graphs .",
    "j.  comput .",
    "55 , 3 - 23 ( 1997 ) .",
    "hutchinson , j.  p. , miller , g.  l. : deleting vertices to make graphs of positive genus planar . in",
    ": discrete algorithms and complexity theory , pp .",
    "81 - 98 . academic press , boston ( 1986 ) .",
    "klein , p. : preprocessing an undirected planar network to enable fast approximate distance queries . in : proceedings of the thirteenth annual acm - siam symposium on discrete algorithms , pp .",
    "820 - 827 .",
    "siam , philadelphia ( 2002 ) .",
    "klein , p.  n. : multiple - source shortest paths in planar graphs . in : proceedings of the sixteenth annual acm - siam symposium on discrete algorithms , pp .",
    "145 - 155 .",
    "siam , philadelphia ( 2005 ) .",
    "klein , p.  n. , mozes , s. , weimann , o. : shortest paths in directed planar graphs with negative lengths : a linear - space @xmath30-time algorithm .",
    "acm trans .",
    "algorithms 6 , 1 - 18 ( 2010 ) .",
    "kowalik ,  . ,",
    "kurowski , m. : oracles for bounded - length shortest paths in planar graphs .",
    "acm trans .",
    "algorithms 2 , 335 - 363 ( 2006 ) .",
    "lipton , r.  j. , tarjan , r.  e. : a separator theorem for planar graphs .",
    "siam j.  on appl .",
    "36 , 177 - 189 ( 1979 ) .",
    "miller , g.  l. : finding small simple cycle separators for 2-connected planar graphs .",
    "j.  comput .",
    "32 , 265 - 279 ( 1986 ) .",
    "mozes , s. , sommer , c. : exact distance oracles for planar graphs .",
    "arxiv:1011.5549 ( 2010 ) .",
    "mozes , s. , wulff - nilsen , c. : shortest paths in planar graphs with real lengths in @xmath54 time . in : algorithms - esa 2010 ,",
    "18th annual european symposium .",
    "lecture notes in computer science , vol .  6347 , pp .  206 - 217",
    "springer ( 2010 ) .",
    "sleator , d.  d. , tarjan , r.  e. : a data structure for dynamic trees . j.  comput .",
    "26 , 362 - 391 ( 1983 ) .",
    "thorup , m. : compact oracles for reachability and approximate distances in planar digraphs . j.  acm 51 , 993 - 1024 ( 2004 ) .",
    "consider the data structure of sect .",
    "[ sec : b ] .",
    "let @xmath144 be a query pair , such that @xmath52 is in a piece @xmath61 and @xmath53 is in another piece @xmath153 .",
    "the query algorithm that we describe here is similar to the one of ( * ? ? ? * (  5 ) ) , and the complete details are given there .",
    "let @xmath57 be the hole of @xmath61 that contains @xmath53 and let @xmath154 the hole of @xmath153 that contains @xmath52 .",
    "denote @xmath155 $ ] and @xmath156 $ ] .",
    "we assume without loss of generality that @xmath224 contains the infinite face .",
    "a shortest path from @xmath52 to @xmath53 contains some vertex @xmath159 and some vertex @xmath160 ( it is possible that @xmath161 ) .",
    "we may assume that there is no internal vertex of @xmath61 between @xmath162 and @xmath163 in the shortest path ( since otherwise we can replace @xmath162 with another vertex of @xmath90 ) .",
    "therefore , @xmath225 .",
    "next we show how to find @xmath226 for every @xmath159 in @xmath145 time .    for a fixed vertex @xmath187 it is easy to find @xmath227 that minimizes @xmath228 in @xmath73 time ( the same member of @xmath91 may be @xmath229 for different members of @xmath90 ) , by going over all vertices of @xmath91 and using parts ( iii ) and ( i ) of the data structure",
    ". let @xmath94 and @xmath230 be the vertices that minimizes @xmath228 for @xmath92 and @xmath231 .",
    "there is a shortest path from @xmath92 to @xmath53 that contains @xmath94 , and similarly a shortest path from @xmath231 to @xmath53 that contains @xmath230 .",
    "let @xmath232 be a vertex between @xmath92 and @xmath231 in the clockwise order of @xmath90 starting at @xmath92 .",
    "there is a vertex @xmath233 that minimizes @xmath234 located between @xmath94 and @xmath230 in the counterclockwise order of vertices of @xmath91 starting at @xmath94 . since otherwise",
    ", every shortest path from @xmath232 to @xmath53 must cross the shortest path from @xmath92 or from @xmath231 to @xmath53 that contains @xmath94 or @xmath230 , respectively .",
    "assume without loss of generality that the shortest path from @xmath232 to @xmath53 crosses the shortest path from @xmath92 to @xmath53 , and let @xmath100 be the vertex in which the two shortest paths meet .",
    "then , if we replace the suffix of the shortest path from @xmath92 that begins at @xmath100 with the suffix of the shortest path from @xmath232 we get a shorter path , this is a contradiction ( see fig .  [",
    "fig : x3y3 ] ) .",
    "this gives the following algorithm for finding @xmath227 for every @xmath187 .    .",
    "for @xmath232 between @xmath92 and @xmath231 , the vertex @xmath235 is between @xmath94 and @xmath230 , since otherwise we get that every path from @xmath232 to @xmath53 ( _ dashed _ ) crosses either the shortest path from @xmath92 to @xmath53 or from @xmath231 to @xmath53 at a vertex @xmath100 . ]",
    "let @xmath236 be two arbitrary vertices of @xmath90 .",
    "find @xmath94 and @xmath230 for @xmath92 and @xmath231 by going over all vertices of @xmath91 .",
    "let @xmath232 be the middle vertex between @xmath92 and @xmath231 in the clockwise order of @xmath90 starting at @xmath92 .",
    "find @xmath235 by going over all vertices of @xmath91 between @xmath94 and @xmath230 in the counterclockwise order of vertices of @xmath91 starting at @xmath94 .",
    "continue recursively for the vertices of @xmath90 between @xmath92 and @xmath232 and the vertices of @xmath91 between @xmath94 and @xmath235 , and also for the vertices of @xmath90 between @xmath232 and @xmath231 and the vertices of @xmath91 between @xmath235 and @xmath230 .",
    "similarly , find @xmath229 for every @xmath96 between @xmath92 and @xmath231 in the counterclockwise order of @xmath90 starting at @xmath92 .",
    "we conclude that we can find @xmath226 for every @xmath159 in @xmath145 time . now , we go over all vertices of @xmath90 , and using part ( i ) of the data structure we find @xmath237 in @xmath73 time .",
    "the total query time is @xmath145 .",
    "in this appendix we define a cyclic order on the edges incident to a specific vertex in the graph @xmath212 , which is a subgraph of the dense distance graph .",
    "we use this order in the preprocessing algorithm of sect .",
    "[ sec : cp ] , in order to find @xmath181 for a boundary vertex @xmath162 .",
    "we define the order of the edges such that the leftmost shortest paths from @xmath162 to @xmath91 in @xmath50 , and in @xmath212 , both end at the same vertex of @xmath91 ( @xmath238 and @xmath212 are defined in sect .  [",
    "sec : c ] ) .",
    "a vertex @xmath100 of @xmath212 is a boundary vertex of more than one piece , however the order between two edges in two different pieces is clear from the embedding of @xmath50 ( the pieces of @xmath212 are pairwise edge disjoint ) .",
    "therefore , here we define the left - to - right order of the edges inside each piece . the left - to - right order of the edges , is in fact a left - to - right order of the boundary vertices , because the edges of a piece in the dense distance graph connect a vertex on the boundary of the piece to all other vertices on the boundary .",
    "we define the left - to - right order from @xmath100 to the other boundary vertices of the piece according to the left - to - right order of the leftmost shortest paths from @xmath100 to the other vertices .",
    "this order allows us to find @xmath181 as required .",
    "the order that we define does not depend on the specific graph @xmath212 , so we perform the procedure described here only once for every boundary vertex of every piece .",
    "let @xmath100 be a boundary vertex of a piece @xmath211 .",
    "when we compute the distances from @xmath100 to the other vertices of @xmath239 for the dense distance graph , we use the algorithm of klein @xcite , which maintains a _ dynamic tree _ @xcite that contains the rightmost shortest path from @xmath100 to every vertex of @xmath211 . since we are interested in leftmost shortest paths we use a symmetric version of @xcite , by replacing the roles of left and right .",
    "denote this leftmost shortest path tree rooted at @xmath100 by @xmath240 .",
    "let @xmath179 and @xmath241 be two vertices of @xmath239 different from @xmath100 .",
    "we show how to decide in @xmath242 time which of the two vertices is to the left of the other , with respect to @xmath100 .",
    "let @xmath243 be the nearest common ancestor of @xmath179 and @xmath241 in @xmath240 .",
    "we can find @xmath243 and the two edges that lead from it to @xmath179 and to @xmath241 in @xmath242 time from the dynamic tree @xcite .",
    "first assume that @xmath244 .",
    "consider the following three edges incident to @xmath243 in @xmath240  the edge that connects @xmath243 to its parent ( if @xmath243 = @xmath100 then we add a dummy edge inside the hole that @xmath100 lies on its boundary for this purpose ) , the edge that leads from @xmath243 to @xmath179 , and the edge that leads from @xmath243 to @xmath241 .",
    "the order of these edges around @xmath243 determine the order between @xmath179 and @xmath241 ( see fig .  [",
    "fig : compare](a ) ) . now assume without loss of generality that @xmath245 .",
    "the vertex @xmath179 lies on the boundary of some hole of @xmath211 , denote this hole by @xmath57 .",
    "there are two edges incident to @xmath179 on the boundary of @xmath57 .",
    "we can find the two edges when we find the piece @xmath211 .",
    "consider the edge that connects @xmath179 to its parent in @xmath240 , the edge that leads from @xmath179 to @xmath241 , and the place of @xmath57 among the edges incident to @xmath179 .",
    "if in the clockwise order of edges around @xmath179 starting at the edge that connects @xmath179 to it parent , the edge that leads to @xmath241 is before @xmath57 , then @xmath241 is to the left of @xmath179 , otherwise @xmath179 is to the left of @xmath241 ( see fig .  [",
    "fig : compare](b ) ) .",
    "since we compare two vertices in @xmath242 time , we can use comparison sort to sort the @xmath246 vertices of @xmath239 around the vertex @xmath100 from left to right in @xmath247 time .",
    "we repeat the process for each vertex of @xmath239 in a total of @xmath248 time . for the pieces of a single layer of the recursive decomposition ,",
    "the total time is @xmath249 . and",
    "for all the pieces of the dense distance graph the process takes @xmath28 time ."
  ],
  "abstract_text": [
    "<S> there are several known data structures that answer distance queries between two arbitrary vertices in a planar graph . </S>",
    "<S> the tradeoff is among preprocessing time , storage space and query time . in this paper </S>",
    "<S> we present three data structures that answer such queries , each with its own advantage over previous data structures . </S>",
    "<S> the first one improves the query time of data structures of linear space . </S>",
    "<S> the second improves the preprocessing time of data structures with a space bound of @xmath0 or higher while matching the best known query time . </S>",
    "<S> the third data structure improves the query time for a similar range of space bounds , at the expense of a longer preprocessing time . </S>",
    "<S> the techniques that we use include modifying the parameters of planar graph decompositions , combining the different advantages of existing data structures , and using the monge property for finding minimum elements of matrices . </S>"
  ]
}