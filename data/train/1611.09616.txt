{
  "article_text": [
    "coding in data communication networks has been shown to offer many advantages in terms of data rate , error correction and security .",
    "many coding models have been considered for a variety of networks .",
    "error - correction for coherent networks has been considered in @xcite .",
    "for so called non - coherent networks , where the network topology is unknown , subspace codes have been shown to offer good solutions for error correction and have been widely studied .",
    "we consider the set - up for coherent network coding introduced in @xcite .",
    "the network @xmath17 is a directed acyclic graph with nodes / vertices @xmath18 and edge set @xmath19 of order @xmath1 .",
    "we assume that @xmath20 has a single source node @xmath21 incident with some @xmath22 outgoing edges and has several sinks labelled by elements of a set @xmath0 .",
    "a message of @xmath22 packets is transmitted from the source node to be received at each sink in @xmath0 . for each sink @xmath7 , let @xmath23 denote the set of edges incident with @xmath4 and let @xmath24 .",
    "we furthermore assume that @xmath25 for each @xmath4 and indeed that there are at least @xmath22 edge disjoint paths connecting @xmath21 to @xmath4 .",
    "we will adopt a linear coding scheme , which means , as usual , that at each node in the network , linear combinations of packets on its incoming edges are transmitted along its outgoing edges . in our context , the underlying alphabet is a finite bimodule and the codes are equipped with a distance function induced by the _ homogeneous weight_. this very general model includes the case where the alphabet is a finite fields and the induced metric comes from the hamming weight and so extends the coding model described in @xcite .",
    "furthermore , we develop upper bounds on codes associated with fixed network based on the plotkin and elias bounds . these results are new both for the classical case of a finite fields and in the more general case of a finite frobenius bimodule .    in section 2",
    "we give a formal description of a code for a fixed network digraph . in section 3",
    "we outline preliminaries on the homogeneous weight for code modules defined over finite frobenius bimodule .",
    "in section 4 we present an upper bound on the size of a network code based on plotkin s bound and in section 5 we give an elias - like bound . in section 6",
    "we give asymptotic versions of these bounds .",
    "let @xmath6 be a finite ring with unity and let @xmath5 be a finite @xmath6-@xmath6 bimodule .",
    "the set of messages for @xmath26 is a subset @xmath27 of @xmath28 .",
    "each message @xmath29 corresponds to a unique network word @xmath30 \\in { \\cal m } : = \\ { [ u,0 ] : u \\in { \\cal m}_0\\ } \\subset { \\cal a}^n$ ] , canonically embedding @xmath28 into @xmath14 .",
    "the network itself my be identified with @xmath14 , where each @xmath31-th coordinate projection from @xmath14 onto @xmath5 corresponds to the @xmath31-th edge of the network , under some ordering .",
    "a word @xmath32 is transmitted along the network by an invertible transfer map @xmath33 for some @xmath6-linearly independent maps @xmath34 if @xmath35 is transmitted from the source node @xmath21 and some edges of the network are corrupted by errors in the form of an error word @xmath36 then the network transmission is given by @xmath37 in other words , it is assumed that errors propagate through the network .    in the context of @xcite ( which is an error - free model )",
    "@xmath38 is represented by an invertible transfer matrix @xmath39 with respect to some fixed basis .",
    "the network coding model described in @xcite results from the case @xmath40 .",
    "the approach in @xcite corresponds to the case @xmath41 and @xmath42 .    for each @xmath7 ,",
    "let @xmath43 be the projection onto the coordinates indexed by the edges incident with @xmath4 and define a map @xmath44 in the multicast setting , for each @xmath7 , we require that @xmath45 be an injection , in order that each sink @xmath4 can decode the transmitted word to the same unique message in @xmath46 .    let @xmath20 be a network with transfer map @xmath47 .",
    "the network code for node @xmath4 of @xmath48 is the set @xmath49 the network code of @xmath48 is the collection @xmath50 .",
    "note that neither @xmath46 nor any @xmath9 need be @xmath6-linear ; the linearity of @xmath51 refers only to linearity of the transfer map @xmath52 .",
    "the received word at node @xmath4 is given by @xmath53 we denote by @xmath54 the kernel of the map @xmath11 in @xmath14 so that @xmath55 .",
    "observe that if @xmath56 then @xmath57 is received as if no errors have occurred . if @xmath58 , the kernel @xmath54 is trivial and the decoder will not detect any errors .    a weight function @xmath13 on @xmath59 induces a weight @xmath12 on @xmath8 as follows : @xmath60 for some @xmath61 in the preimage of @xmath62 under @xmath11 .",
    "if @xmath13 determines a distance function @xmath63 on @xmath59 by @xmath64 , then @xmath65 is also a distance function on @xmath8 .",
    "given the received word @xmath66 , the decoder at node @xmath4 decides that @xmath67 has been transmitted if @xmath68 for all @xmath69 .",
    "let @xmath70 and let @xmath13 denote the usual hamming weight on @xmath71 .",
    "let @xmath20 be a network and let @xmath9 be a network code for @xmath20 at one of its sink nodes @xmath4 .",
    "@xmath11 has a representation as an @xmath72 matrix @xmath73 with respect to a chosen basis .",
    "then @xmath74 counts the minimum number of linearly independent rows of @xmath73 required to obtain a representation of @xmath75 .",
    "if @xmath76 is transmitted and @xmath77 is received at @xmath4 , the decoder will decode to @xmath78 for some error @xmath79 of least hamming weight satisfying @xmath80 .",
    "in other words the decoder assumes that the least number of edges resulting in a non - trivial contribution to the computation of @xmath77 have been affected by noise during transmission .",
    "we denote by @xmath81 the minimum distance of @xmath9 with respect to @xmath82 .",
    "we write @xmath83 to denote the size of the support of @xmath54 . for each @xmath7 , we write @xmath84 to denote the preimage of @xmath9 in @xmath8 and we let @xmath85 . clearly @xmath86 and @xmath87 .",
    "we say that @xmath51 is an @xmath88 network code .",
    "we define @xmath89 , which we call the size of @xmath90 , and seek upper bounds on this number , which is the effective maximum possible size of the message space @xmath46 .",
    "we denote by @xmath91 the maximum size @xmath92 of any @xmath88 network code @xmath51 .",
    "the homogeneous weight was first introduced on the ring @xmath93 in @xcite .",
    "generalizations of this weight function have appeared in @xcite . for coding theoretic purposes ,",
    "these are often best defined on a _",
    "frobenius bimodule_.    we define a weight function , or weight on an @xmath6-module @xmath94 to be a map @xmath95 such that @xmath96 .",
    "the homogeneity conditions in @xcite are given by the following .",
    "a weight function @xmath13 on a left @xmath6-module @xmath94 is called ( left ) homogeneous if    1 .   if @xmath97 then @xmath98 for all @xmath99 .",
    "2 .   there exists a real number @xmath100 such that @xmath101    right homogeneous weights are defined similarly . in @xcite condition h2",
    "is given as :    1 .",
    "there exists a real number @xmath100 such that @xmath102    in fact , if @xmath103 is a left _ frobenius module _ , in particular",
    "if its socle is cyclic , then h2 implies h2 .",
    "moreover , a homogeneous weight function exists on any finite module @xmath103 and is unique up to choice of average weight @xmath100 @xcite .    for the case",
    "@xmath104 , the hamming weight is homogeneous with average weight @xmath105 . for the case",
    "@xmath106 , the lee weight is homogeneous with average weight @xmath107 .",
    "let @xmath108 .",
    "then it is straightforward to check that the weight function @xmath13 on @xmath94 defined by @xmath109 is homogeneous with average value @xmath110    for the case @xmath111 , only the hamming weight , for @xmath105 , is homogeneous .",
    "we extend @xmath13 to a weight function on @xmath14 in the obvious way : @xmath112    in @xcite , the authors show that every finite unital ring @xmath6 has a quasi - frobenius bimodule , which is unique up to right and left @xmath6-isomorphism if its socle is cyclic both as a left and right @xmath6-module .",
    "such a module is then called a frobenius bimodule .",
    "let @xmath113 hom@xmath114 , the group of characters of the additive group of @xmath5 .",
    "@xmath115 is an @xmath6-@xmath6 bimodule according to the relations @xmath116 for all @xmath117 and @xmath118 .",
    "a character @xmath119 is called ( left ) generating if given any @xmath120 there is some @xmath121 satisfying @xmath122 .",
    "this is equivalent to the property that @xmath123 contains no left @xmath6-submodule of @xmath5 .",
    "the bimodule @xmath124 is a frobenius bimodule if @xmath125    by duality , if @xmath124 is frobenius then @xmath126 in particular , if @xmath124 is a frobenius bimodule then @xmath127 is generated by a character @xmath128 both as a left and as a right @xmath6-module .",
    "the existence of such a generating character @xmath129 gives the following characterisation of the homogeneous weight on a frobenius bimodule ( cf @xcite ) .",
    "the proof is straightforward .",
    "[ lemcharfrob ] let @xmath124 be a frobenius bimodule with generating character @xmath128 .",
    "then the weight function @xmath130 is homogeneous .    for a positive integer @xmath131 , word @xmath132 and set @xmath133 we define @xmath134 . given an @xmath6-submodule @xmath135 , we write @xmath136 to denote the set @xmath137 , where @xmath138 for each @xmath31 .    using the character - theoretic description of the homogeneous weight given above",
    ", the following result can be shown , with the proof proceeding almost exactly as in ( * ? ? ?",
    "* lemma 1 ) .",
    "[ lemavwsp ] let @xmath124 be a frobenius bimodule with homogenous weight function @xmath139 .",
    "let @xmath94 be an @xmath6-submodule of @xmath14 and let @xmath35 .",
    "then @xmath140    unless stated otherwise , for the remainder we assume that @xmath5 is a frobenius bimodule and that for each linear map @xmath141 the weight function @xmath12 is induced by the homogeneous weight @xmath13 on @xmath5 , extended to a weight on @xmath14 .",
    "we seek an upper bound on @xmath142 for each @xmath143 code @xmath9 . following the usual argument for the classical plotkin bound ,",
    "we obtain lower and upper bounds on @xmath144 . proposition 2.1 of @xcite",
    "gives a plotkin bound for codes over finite frobenius rings with respect to the homogeneous weight , which has the trivial extension :    [ lemgsplotkin ] let @xmath145 have minimum homogeneous distance @xmath146 . then @xmath147    [ thplotkin ] let @xmath148 be the @xmath149 network code for node @xmath4 .",
    "if @xmath150 then @xmath151    we give an estimate of the sum of the distances between ordered pairs of distinct codewords of @xmath152 : @xmath153 @xmath154 from lemmas [ lemavwsp ] and [ lemgsplotkin ] .",
    "now rearrange to obtain @xmath155 as long as @xmath150 .",
    "we remark that if @xmath156 then the inequality @xmath157 implies that @xmath158 .",
    "if @xmath54 is trivial then @xmath159 and theorem [ thplotkin ] is the classical plotkin bound ( * ? ? ?",
    "* theorem 2.2 ) .",
    "[ corp1 ] let @xmath160 and let @xmath161 .",
    "then @xmath162    @xmath163    observe that the upper bound in corollary [ corp1 ] depends on @xmath164 and @xmath81 , but not on @xmath3 .",
    "[ corp2 ] let @xmath165 .",
    "then @xmath166    @xmath54 can be embedded in @xmath167 , so that @xmath168",
    ". then @xmath169 , so the result follows .",
    "the results of this section rely on @xcite , applied to @xmath9 , giving an upper bound on @xmath142 for the case @xmath170 .",
    "we recall the following well - known lemma ( see , for example ( * ? ? ?",
    "* lemma 5.2.9 ) ) .",
    "let @xmath171 .",
    "then there exists @xmath172 such that @xmath173    for each nonnegative real number @xmath174 we define @xmath175 it is easy to deduce from this lemma that latexmath:[\\[\\label{eqe2 }    to simplify notation , for each @xmath7 and vector @xmath177 , we write @xmath178 note that if @xmath179 for some @xmath180 then @xmath181",
    ". we will use this elementary fact throughout .",
    "[ coravball ] let @xmath182 .",
    "then @xmath183    let @xmath184 . applying lemma [ lemavwsp ] , @xmath185 if and only if @xmath186    let @xmath187 .",
    "then @xmath188    let @xmath189 . from corollary [ coravball ] , @xmath190 if and only if @xmath191 .",
    "let @xmath192 .",
    "clearly @xmath193 , so there are exactly @xmath194 distinct cosets of @xmath195 in @xmath167 . then for each @xmath196 , there are exactly @xmath194 distinct elements @xmath197 satisfying @xmath198 .",
    "the following is now immediate .",
    "let @xmath199 for each @xmath7 .",
    "then @xmath200    we now obtain an upper bound on the size of @xmath201 . clearly , @xmath202 has minimum distance @xmath203 . for each @xmath7 ,",
    "let @xmath204 be a set of distinct coset representatives of @xmath54 in @xmath205 .",
    "we denote by @xmath206 the multiset of words in @xmath207 constructed as @xmath208 where @xmath209 .",
    "let @xmath210 .",
    "then @xmath211    using lemma [ lemavwsp ] , we obtain @xmath212    let @xmath210",
    ". then @xmath213 .    as before ,",
    "let @xmath192 .",
    "let @xmath214 .",
    "let @xmath215 satisfy @xmath216 , and @xmath217 in particular @xmath218    we have the following result , given in the proof of ( * ? ? ?",
    "* corollary 3.3 ) .",
    "let @xmath219 and let @xmath220 . if @xmath221 for every @xmath222 then @xmath223    observing that the above result is valid for a multiset of words @xmath224 , and then substituting @xmath225 , @xmath226 , @xmath227 , and @xmath228 immediately gives :    let @xmath229 and let @xmath230 . then @xmath231 moreover , if @xmath232 then @xmath233    [ thelias ] let @xmath234 and let @xmath235",
    ". then @xmath236 in particular if the above hypothesis holds for each @xmath7 , then @xmath237",
    "asymptotic versions of these bounds are expressed by finding upper bounds on : @xmath238 as in the classical hamming case , we will require an asymptotic expression for the size of the homogeneous sphere @xmath239 .",
    "this was essentially answered first in @xcite and in a slightly different form ( which we use here ) in ( * ? ? ?",
    "* theorem 4.1 ) as follows :            if @xmath246 then from corollary [ corp1 ] it is clear that @xmath247 .",
    "now suppose that @xmath248 .",
    "let @xmath249 be an optimal @xmath88 network code and choose @xmath4 such that @xmath250 .",
    ". then @xmath252 choose @xmath253 to be the greatest integer satisfying @xmath254 .",
    "then @xmath255 and @xmath256 by our choice of @xmath253 .",
    "consider the words of @xmath257 . by a standard coding theory argument we can take @xmath258 successive shortenings of @xmath84 on its coordinates in @xmath259 to arrive at a code in @xmath260 of order at least @xmath261 .",
    "then puncture the code on these coordinates , as well as any coordinate not in @xmath262 , to obtain a code @xmath263 of the same order .",
    "the corresponding code @xmath264 obtained by puncturing @xmath54 on the same coordinates satisfies @xmath265 and so the set of words of @xmath266 is a union of at @xmath267 distinct cosets of @xmath264 in @xmath268 .",
    "this yields a code @xmath269 satisfying @xmath270 . again apply corollary [ corp1 ] to get @xmath271 then @xmath272      let @xmath0 be a non - empty set and let @xmath273 . for each @xmath7",
    "let @xmath274 satisfy @xmath275 , @xmath276 .",
    "for each positive integer @xmath1 define @xmath277 @xmath278 and @xmath279 .",
    "then @xmath280 in particular , @xmath281          e. byrne , `` on bounds for network codes , '' international workshop in coding and cryptography , bergen , april 15 - 19 , 2013 , preprint available at http://www.selmer.uib.no/wcc2013/preproceedings.pdf , pp",
    ". 476576 ."
  ],
  "abstract_text": [
    "<S> we give upper bounds on the size of a code whose fundamental parameters are determined by a a directed acyclic graph that has a single source node , a set of sink nodes @xmath0 and @xmath1 edges . </S>",
    "<S> a code associated with this digraph is a collection @xmath2 where @xmath3 is the number of edges incident with sink @xmath4 and @xmath5 is an @xmath6-@xmath6 bimodule for a finite ring @xmath6 . for each @xmath7 , </S>",
    "<S> the ambient space @xmath8 of @xmath9 is @xmath10 for a left @xmath6-epimorphism @xmath11 . </S>",
    "<S> then @xmath8 is equipped with a weight function @xmath12 induced by a weight function @xmath13 on @xmath14 via @xmath15 . </S>",
    "<S> we use the classical plotkin and elias bounds to derive upper bounds on the quantity @xmath16 as we range over all such codes @xmath2 .    example.eps ! </S>",
    "<S> ps - adobe-3.0 epsf-3.0 gsave newpath 20 20 moveto 20 220 lineto 220 220 lineto 220 20 lineto closepath 2 setlinewidth gsave .4 setgray fill grestore stroke grestore    network code , network error - correction , coherent networks , plotkin bound , elias bound , finite frobenius ring , homogeneous weight </S>"
  ]
}