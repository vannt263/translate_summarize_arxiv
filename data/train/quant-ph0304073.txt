{
  "article_text": [
    "query complexity theory is mainly concerned with the computational cost required to determine some specific property of functions .",
    "the cost is measured by the number of queries which can be addressed to a  black box \" device ( the oracle ) that outputs instantaneously an answer to a query .",
    "various results concerning query complexity of boolean functions , i.e. functions with a finite - size domain which have two possible output values only , exist in the literature  @xcite .",
    "the first of this sort of problems which has been addressed by the quantum computational theory , is represented by the deutsch - josza algorithm  @xcite .",
    "it involves the decision whether a given boolean function of @xmath0 binary digits is _ constant _ ( that is whether it outputs the same binary digit for every input value ) or _ balanced _ ( that is whether it outputs @xmath2 on exactly half inputs and @xmath3 on the other half ) and it can be solved with certainty by querying a quantum oracle just once .    this task is successfully achieved by exploiting two essential features of quantum mechanics : its linearity , which allows the simultaneous evaluation of a function on linear superpositions of its input values , and the interference between amplitudes , which raises the probability of obtaining the desired results .    the _ a - priori _ knowledge that the function computed by the quantum oracle is either constant or balanced , is crucial in solving the problem exactly , i.e. with zero probability of error . in this paper",
    ", we address the question of deciding the constancy of a generic function chosen at random among the set of @xmath4 @xmath0-bit boolean functions .",
    "in such a case , the iteration of the same algorithmic procedure permits one to decide about the constancy of such generic function with a probability of error which depends on @xmath0 and on the number @xmath1 of quantum oracle - queries .",
    "unfortunately , this probability tends to @xmath2 in the worst case scenario , namely when the given function outputs the same value for every input but one .",
    "nevertheless , it is our purpose to determine the efficiency of the quantum algorithm and the range of values of @xmath0 and @xmath1 for which it is more efficient compared to the unique classical procedure which involves querying the oracle successively until two different outputs are encountered .",
    "not too surprisingly , due to classical conditioning of each output on the previous ones , in some specific situations ( the worst cases ) , for large number of inputs and nearly as many oracle - queries , the efficiency of the classical algorithm turns out to overcome that of the quantum one .",
    "moreover , in the average case , i.e. when the @xmath0-bit boolean function is sorted at random , the quantum algorithm is always preferable to the classical one .",
    "the general problem we are going to tackle is as follows .",
    "suppose that we are given an oracle which instantaneously computes an arbitrary n - bit boolean function @xmath5 on inputs that , as usual , will be enumerated by the integers @xmath6 .",
    "our goal is to devise a quantum algorithm , involving oracle queries , in order to determine , with some probability of error , whether such a function is constant or not .",
    "since , by hypothesis , we have no _ a - priori _ information or knowledge about @xmath7 , we can only suppose that it has been sorted completely at random within the set @xmath8 of @xmath4 n - bit boolean functions .",
    "if we have at our disposal a classical oracle which outputs the value of @xmath7 , and which can be queried at most @xmath1 times , the only conceivable classical algorithm able to solve the problem is@xmath9 :  _ query the oracle @xmath1 times or until two output values are different : in the latter case stop querying and declare that the function is not constant , otherwise say that @xmath7 is constant _ \" .    of course , this simple algorithm fails to give the right answer only when the function is actually non - constant and when we have obtained @xmath1 consecutive equal digits in the querying procedure .",
    "in fact , the function @xmath7 might output a different digit on any of the untried inputs , so that one has to evaluate the probability of such an event .",
    "we start by considering the worst possible scenario , that is the unknown function @xmath7 , drawn from the set @xmath8 , actually outputs the same bit , say @xmath3 , for all of its inputs but one ( for simplicity of notation we will say that such a function is of @xmath10-type ) .",
    "the probability @xmath11 of declaring erroneously constant such a function , coincides with the probability of obtaining @xmath1 consecutive digits @xmath3 after querying the oracle @xmath1 times : @xmath12 = \\textrm{prob}[0 ] \\cdot \\big ( \\prod_{\\ell=1}^{k-1}\\textrm{prob}[\\,0 | \\underbrace{0\\dots 0\\,}_{\\ell } ] \\big),\\ ] ] where we have indicated with @xmath13 $ ] , @xmath14 , the conditional probability of getting @xmath3 after the @xmath15-th oracle query if a sequence of @xmath16 consecutive zeroes has already been obtained .",
    "since the function @xmath7 is of @xmath10-type , one easily calculates @xmath17=(2^{n}-1)/2^{n}$ ] and @xmath18=   ( 2^{n}-\\ell-1)/(2^{n}-\\ell)$ ] , whence @xmath19 this probability distribution is equal to zero for @xmath20 ; indeed , due to statistical correlations between subsequent outputs , in such a case we can determine with certainty if the function is constant or not .",
    "as we will see , this is not the case with the deutsch - josza quantum algorithm which , unless the function is either constant or balanced , is not able to give the correct answer with certainty .",
    "first , let us briefly recall the basics of that algorithm whose associated quantum circuit is the following :    ( 500,70 ) ( 120,40)(30,20 ) ( 220,40)(30,20 ) ( 120,0)(20,20 ) ( 170,0)(30,60 )    ( 110,10)(10,0)10 ( 140,10)(20,0)30 ( 200,10)(20,0)60    ( 110,50)(10,0)10 ( 150,50)(60,0)20 ( 200,50)(10,0)20 ( 250,50)(10,0)10    ( 225,47)@xmath21 ( 125,47)@xmath21 ( 178,27)@xmath22 ( 125,7)@xmath23    ( 90,7)@xmath24 ( 80,47)@xmath25 ( 270,47)@xmath26    we have indicated with @xmath27 the @xmath0-fold hadamard transformation on a @xmath0-qubit state and with @xmath28 the quantum oracle associated to @xmath7 .",
    "it is defined by @xmath29 , where @xmath30 denotes the sum modulus @xmath31 , @xmath32 is an @xmath0-qubit state such that @xmath33 , and @xmath34 is a one - qubit state . if the initial input states are those indicated in the figure , it is possible to prove  @xcite that the @xmath0-qubit output state @xmath35 in the figure above , turns out to be@xmath36 : @xmath37 where @xmath38 is the bitwise inner product of @xmath39 and @xmath40 , i.e. @xmath41 .",
    "therefore , according to eq .",
    "( [ worst3 ] ) , a measurement process performed onto the @xmath0-qubit computational basis @xmath42 yields the result @xmath43 with the following probability@xmath36 : @xmath44 = \\big\\vert \\frac{1}{2^{n } } \\sum_{x=0}^{2^{n}-1 } ( -1)^{f(x)}\\big\\vert^{2}\\:.\\ ] ] if the function @xmath7 is constant , the result @xmath43 is obtained with certainty ; this in turn implies that , if any other value @xmath45 is obtained , the function can not be constant . yet , if the function is of @xmath10-type , the result @xmath43 is obtained with a probability strictly smaller than @xmath2 , given by : @xmath46 = \\big\\vert \\frac{1}{2^{n } } \\sum_{x=0}^{2^{n}-1 } ( -1)^{f(x)}\\big\\vert^{2}=   \\big\\vert \\frac{1}{2^{n } } ( -2 + 2^{n})\\big\\vert^{2}= \\big ( 1-\\frac{1}{2^{n-1 } } \\big)^{2}\\:.\\ ] ] the simplest quantum procedure to determine whether the function @xmath7 is constant or not , consists of a simple iteration of the quantum circuit described above and it amounts to : ",
    "_ iterate the deutsch - jozsa algorithm @xmath1 times or until a measurement result @xmath45 appears : in the latter case stop querying and declare that the function is not constant , otherwise say that @xmath7 is constant _ \" .",
    "we denote by @xmath47 the probability that , after obtaining @xmath43 in @xmath1 consecutive measurements , we are wrong in asserting the constancy of the @xmath10-type function . according to eq .",
    "( [ worst4.5 ] ) , one gets : @xmath48 it is worth noting that , contrary to the classical case where the probability of obtaining the same output value changes , by conditioning , after each oracle query , the consecutive ( quantum ) oracle - queries are independent from each other .",
    "therefore , the probability of obtaining @xmath43 , @xmath1 times consecutively , is the product of the probabilities of the uncorrelated events ; quantum conditioning on past results would certainly improve the efficiency of the algorithm , however we do not know of any such technique .    in order to compare the quantum querying procedure with respect to the classical one in this worst case , we define the following efficiency function @xmath49 : @xmath50 given @xmath0 ( the number of bits ) and @xmath1 ( the number of oracle - queries ) , a positive value of @xmath49 indicates that the quantum algorithm is more efficient than the classical one . for @xmath51 and @xmath52",
    ", @xmath49 attains its absolute maximum at @xmath53 and @xmath54 : @xmath55 for fixed @xmath0 , the function @xmath49 has relative maxima at @xmath56 with @xmath57 , for @xmath58 .    in fig .",
    "[ fig1 ] , @xmath49 is plotted as a function of @xmath1 for different values of @xmath0 ; the curves displayed from left to right are associated with increasing values of @xmath0 , @xmath59 :    as it can be argued from the picture plotted above , @xmath49 is a concave function in the variable @xmath1 for every fixed value of @xmath60 .",
    "therefore , the worst case efficiency of the quantum algorithm increases , with respect to the classical one , for @xmath61 ( where @xmath62 for @xmath58 ) , until it reaches its ( relative ) maximum value .",
    "such a value exhibits a weak dependence on the variable @xmath0 and it is approximately equal to @xmath63 for @xmath58 . on the contrary , for @xmath64",
    ", @xmath49 decreases to zero , thus indicating a substantial equivalence of the two methods for large @xmath1 s .",
    "the above results show that , in the worst case , it is almost always better to resort to the quantum rather than to the classical algorithm .",
    "however , the improvement of quantum queries over the classical ones decreases with the number of queries .",
    "furthermore , @xmath49 becomes negative for @xmath65 , namely there is a ( small ) range of values of @xmath1 for which the classical querying procedure gives less probability of error than the quantum one .",
    "not surprisingly , this is due to the fact that the @xmath66-th classical query is able to determine with certainty if the function is constant or not , since @xmath67 .",
    "instead , the quantum algorithm , as it has been conceived , can never answer with certainty since @xmath47 never vanishes .",
    "until now we have restricted our analysis to the worst possible scenario , i.e. when the function @xmath7 outputs the same value for all possible inputs but one . in the general case , the function may be any of the @xmath4 possible @xmath0-bit boolean functions belonging to the set @xmath8 .",
    "this set contains @xmath31 constant functions ( one always outputs @xmath3 , while the other outputs @xmath2 ) , @xmath68 balanced functions ( they output the same value for exactly one - half of the possible inputs ) and @xmath69 @xmath70-type functions ( they output @xmath3 ( @xmath2 ) on @xmath71 inputs and @xmath2 ( @xmath3 ) on the remaining @xmath72 ones ) .",
    "we repeat the analysis of the previous section and suppose we are given one particular @xmath70-type function .",
    "the probability of obtaining always the same output bit by querying the classical oracle @xmath1 times , and thus of concluding , erroneously , that the function is constant , is equal to @xmath73 + \\textrm{prob } [ \\underbrace{1\\dots 1}_{k}]$ ] .",
    "the latter are the probabilities of obtaining @xmath1 consecutive digits @xmath3 and @xmath2 respectively , and they explicitly read @xmath74 =    \\prod_{j=0}^{k-1 } \\frac{2^{n}-m - j}{2^{n}-j}=    \\frac{(m-2^{n})_{k}}{(-2^{n})_{k}}\\:,\\ ] ] @xmath75 =    \\prod_{j=0}^{k-1 } \\frac{m - j}{2^{n}-j}=    \\frac{(-m)_{k}}{(-2^{n})_{k}}\\:.\\ ] ] in the above , for simplicity of notation , the pochhammer symbol @xmath76 has been used .",
    "therefore , the classical error probability @xmath77 in declaring constant an @xmath70-type function is : @xmath78 the corresponding probability @xmath79 for the quantum case is much easier to calculate .",
    "in fact , given an @xmath70-type function , the conditional probability of obtaining @xmath1 consecutive measurement results @xmath43 via the iterated deutsch - jozsa procedure is , according to eq .",
    "( [ worst4 ] ) : @xmath80   \\equiv q_{m}(k , n ) = \\big\\vert \\frac{1}{2^{n } } \\sum_{x=0}^{2^{n}-1 } ( -1)^{f(x)}\\big\\vert^{2k}= \\big ( 1-\\frac{m}{2^{n-1 } } \\big)^{2k}\\:.\\ ] ] as in the previous section , we can now define a function @xmath81 which quantifies the relative efficiency of the quantum algorithm with respect to the classical one : @xmath82 @xmath81 does not dramatically change with @xmath0 ; therefore , we fix @xmath83 and present typical behaviours for different values of @xmath72 .",
    "we notice that @xmath81 is symmetric around @xmath84 , and that , when @xmath72 gets close to @xmath85 , the function @xmath70 tends to be balanced and @xmath81 rapidly decreases .",
    "this behaviour indicates that the quantum algorithm can perform much better than the classical one , but only for small numbers of oracle - queries . on the contrary ,",
    "the two procedures become equally efficient for larger values of @xmath1 . for instance , in fig .",
    "[ fig2 ] , when @xmath86 and the function @xmath70 is almost balanced , the two procedures are nearly indistinguishable for @xmath87 . instead , in the general case of @xmath72 significantly different from @xmath85 , the dependence of @xmath81 on @xmath1 is much smoother and presents a maximum and a change of concavity .",
    "further , for @xmath65 , @xmath81 assumes negative values , invisible in the above pictures .",
    "this indicates a better performance of the classical algorithm over the quantum one , as already noticed when dealing with the @xmath10-type function in the previous section .",
    "however this phenomenon is much less pronounced than in the worst case situation .",
    "we now tackle the general case and suppose we are given a randomly chosen boolean function belonging to @xmath8 .",
    "then , the average classical error probability @xmath88 in declaring such a function constant , after @xmath1 consecutive queries with identical outputs , is : @xmath89 + \\frac{{2^{n}\\choose 2^{n-1}}}{2^{2^{n}}}\\ ,   \\frac{2(-2^{n-1})_{k}}{(-2^{n})_{k}}\\:.\\ ] ] in the previous expression , the factor @xmath90 , with @xmath91 , gives the probability of sorting , within the set @xmath8 , an unbalanced @xmath70-type function which outputs a number of zeroes less than @xmath85 ( the extra factor @xmath31 in front of the sum takes into account the contribution coming from functions which output a number of zeroes which is greater than @xmath85 ) .",
    "analogously , the factor @xmath92 gives the probability of sorting a balanced function .    on the contrary",
    ", the corresponding quantum error probability @xmath93 of choosing at random a boolean function within @xmath8 and declaring it constant , due to @xmath1 consecutive measurement results @xmath43 , is : @xmath94 as before , we introduce the average efficiency function @xmath95 : @xmath96 + \\ ] ] @xmath97 this function quantifies the ( average ) relative efficiency of the quantum algorithm with respect to the classical one : the larger @xmath95 , the more preferable the quantum procedure with respect to the classical one .",
    "the dependence of @xmath95 on @xmath1 and @xmath0 is shown in fig .",
    "[ fig3 ] below , where its different behaviour with respect to @xmath81 in fig .",
    "[ fig2 ] emerges .",
    "it is worth commenting on the behaviour of @xmath95 .",
    "first , we notice that this function is approximately zero for most of the values of @xmath0 and @xmath1 , indicating a substantial equivalence of the two algorithms ; indeed , in all but a few situations , they are able to solve the problem with negligible probability of error .",
    "second , for fixed @xmath0 , @xmath95 is monotonically decreasing in @xmath1 ; for @xmath54 , the quantum error probability @xmath98 falls rapidly to zero , while the classical one , @xmath99 , approaches unity .",
    "the decrease to zero of @xmath98 is due to the fact that the number of balanced ( or almost balanced ) functions increases considerably for @xmath0 large and the quantum algorithm is able , as we already know , to recognize them with certainty ( or almost certainty ) . on the contrary ,",
    "the number of _ worst _ case functions , i.e. those which output almost always the same value , gets rapidly to zero and the probability of sorting one of them becomes negligible .",
    "this argument does not apply to the classical probability @xmath99 , which instead tends to @xmath2 ; indeed , the classical algorithm fails to give the right answer for balanced ( or almost balanced ) functions which form the overwhelming majority in @xmath100 .    finally , unlike the previous cases , the numerical analysis indicates no negative values of @xmath95 ; thus , in the average case , the quantum algorithm is expected to be always better than the classical one .",
    "in this paper we have shown how a trivial iteration of the original deutsch - jozsa algorithm , can be applied to solve the general problem of deciding if a function @xmath7 , sorted at random among the set of @xmath0-bit boolean functions , is constant or not .",
    "we have compared the error probability of the quantum procedure with that of the classical one , the latter consisting of consecutive oracle - queries performed until two different outputs are encountered .",
    "we have analyzed the range of values of @xmath0 and @xmath1 for which the quantum procedure is more efficient than the classical one , both on average and in the worst possible situation . from a numerical analysis ,",
    "one concludes that , by iterating the quantum algorithm , one can always solve the problem , on average , _ better _ than with the classical method , and _ much better _ in those situations where the number of queries @xmath1 is small and @xmath66 large .",
    "moreover , we have seen that , when @xmath7 is a @xmath70-type function with @xmath72 not much greater than @xmath2 ( the worst cases ) , then the classical method is asymptotically ( that is , when @xmath66 is large and @xmath101 ) preferable to the quantum one .",
    "this peculiar effect is due to the fact that the deutsch - jozsa algorithm , unlike the classical querying , can never solve the general problem with certainty since it does not allow for conditioning on previous results .",
    "w. van dam ; _  quantum oracle interrogations : getting all information for almost half the price \" _ , in _ proceedings of the 39th annual symposium on foundations of computer science ( focs98 ) _ , ieee , ( 1998 ) ."
  ],
  "abstract_text": [
    "<S> we study the probability of making an error if , by querying an oracle a fixed number of times , we declare constant a randomly chosen @xmath0-bit boolean function . </S>",
    "<S> we compare the classical and the quantum case , and we determine for how many oracle - queries @xmath1 and for how many bits @xmath0 one querying procedure is more efficient than the other .    </S>",
    "<S> addtoresetequationsection    keywords : boolean functions ; oracles ; deutsch - josza algorithm . </S>"
  ]
}