{
  "article_text": [
    "when scott @xcite introduced his calculus @xmath0 and the model of partial continuous functionals for it , it was clear that this model is not fully abstract",
    ". there will be finite elements in this model , e.g. parallel or , that are not @xmath0-definable , and consequently there will be observationally equivalent terms in @xmath0 that will be interpreted as different objects in the scott model .",
    "milner @xcite constructed an alternative model for @xmath0 based on scott domains , a model that is fully abstract , and proved that up to isomorphism , there is only one such model . since milner s model has the cardinality of the continuum , there will be a lot of elements in this model that are not @xmath1-definable .",
    "however , if we let @xmath2 denote the calculus where we extend @xmath0 with one constant @xmath3 for each @xmath4 , together with the rewrite rules @xmath5 whenever @xmath6 , the question whether all objects in milner s model are @xmath2-definable remained open for many years .",
    "we let the _ sequential functionals _ be the hereditarily minimal extensional model for @xmath2 . in this paper",
    ", we will investigate the closure properties of the sequential functionals of types @xmath7 , where @xmath8 denotes the base type interpreted as the flat domain @xmath9 .",
    "we will , however , use one of the known characterizations , as the hereditarily extensional collapse of the sequential procedures , in this paper ( see section 2 ) .",
    "the main result is that the sequential functionals of these types will form a directed complete partial ordering . as a tool , an extended _ normal form theorem _",
    "will be obtained for these types .",
    "the first systematic analysis of the @xmath0-definable functionals , seen as a subclass of the scott model , was due to sazonov @xcite . to this end",
    ", he introduced the concept of a _ strategy _ , a concept that is close to sequential procedures as we define them .",
    "later characterisations are due to nickau @xcite , abramsky , jagadeesan and malacaria @xcite and hyland and ong @xcite .",
    "these characterisations appeared during the 1990 s .",
    "the question if they characterised milner s model as well was , however , left open through that decade .",
    "this question was answered in normann @xcite . there",
    "it is proved that the sequential functionals of pure type 3 do not form a _",
    "dcpo _ , a directed complete partial ordering , and thus do not coincide with milner s interpretation of this type .",
    "normann and sazonov @xcite studied some anomalies inspired by @xcite , and among other things , they proved that even the sequential functionals of type @xmath10 do not form a _",
    "dcpo_. however , in @xcite the authors were unable to offer a full characterisation of when the sequential functionals of a given type form a _",
    "dcpo _ , and it is this gap of knowledge that will be closed in this note .",
    "throughout this note , we will let @xmath11 be an integer .",
    "we let the set of monotone functions @xmath12 be our interpretation of the type @xmath13 , and we let @xmath14 be the standard pointwise ordering on this set .",
    "we will use @xmath15 , @xmath16 etc . for such functions .",
    "we will use @xmath17 for @xmath18-sequences @xmath19 of functions .",
    "we will interpret @xmath20 as the set of _ sequential functionals _ of the type .",
    "they can be given as the denotational , hereditarily extensional , interpretations of the _ sequential procedures _ as defined below .",
    "the sequential procedures will be infinite syntax trees , where we essentially follow the notation from @xcite .",
    "all of our procedures will be of type @xmath7 , so we do not specify the type in this note .",
    "since @xmath9 is a sequential retract of @xmath21 , we will indirectly also have covered the cases @xmath22 where each @xmath23 is either @xmath8 or @xmath13 .",
    "[ 2.1 ] the _ sequential procedures _ in the variables @xmath24 of type @xmath13 will be the largest class of infinitary syntactic objects @xmath25 such that either @xmath26 for some @xmath27 or @xmath25 is of the form    @xmath25 = case @xmath28 of @xmath29    where @xmath30 and each @xmath31 are sequential .",
    "we will drop the index @xmath32 in the notation in this paper .",
    "this definition is a special case of the more general definition of the sequential procedures of type @xmath33 for any type @xmath33 .",
    "these were used as the basis for investigating the sequential functionals both in @xcite and in @xcite . in both , there are proofs of the fact that the sequential procedures forms an applicative structure .",
    "the proofs differ in some essential ways , and in both cases they are non - trivial .",
    "the class of sequential procedures is given by a coinductive definition .",
    "we may of course view the clauses as clauses in an inductive definition",
    ". if we do so , and in addition restrict @xmath34 to finite sets @xmath35 instead of @xmath36 ( meaning that @xmath37 if @xmath38 ) , we get the _ finite sequential procedures_.    each procedure @xmath25 will define a _ sequential functional _ @xmath39 $ ] by the _",
    "inductive _ definition of @xmath40(\\vec f)$ ] :    [ 2.2 ]    1 .",
    "@xmath40(\\vec f ) = a$ ] when @xmath41 .",
    "2 .   if @xmath25 is defined from @xmath42 , @xmath30 and @xmath43 as above , we let @xmath40(\\vec f ) = b$ ] if for some @xmath34 , @xmath44(\\vec f ) = b$ ] and either @xmath45 or for some @xmath46 we have that @xmath47(\\vec f ) = c$ ] and @xmath48 .",
    "we write @xmath40(\\vec f)\\!\\!\\downarrow$ ] if there is some @xmath49 such that @xmath40(\\vec f ) = b$ ] , and we write @xmath40(\\vec f)\\!\\!\\uparrow$ ] or @xmath40(\\vec f ) = \\bot$ ] if there is no such @xmath50",
    ". there may be three reasons for why @xmath40(\\vec f ) = \\bot$ ] .",
    "one is that the syntax tree of @xmath25 is not well founded , and that we follow an infinite branch in this syntax tree when we evaluate @xmath40(\\vec f)$ ] .",
    "another is that we , during the evaluation , are led to some @xmath51 .",
    "the third reason is that we need to evaluate some @xmath52)$ ] where the value of @xmath52 ) = \\bot$ ] .",
    "there is a qualitative difference here , in the first case the process does not terminate , while in the other cases the process terminates with the value @xmath53 . in our interpretation",
    "@xmath40 $ ] we do not distinguish between these cases .",
    "[ 2.2a ] let @xmath54 , and let @xmath55 be the set of sequential functionals of our fixed type over the interpretation @xmath56 of @xmath8 .",
    "we let @xmath57 denote the full set of sequential functionals of the type in question . for each @xmath54 , let @xmath58 be the standard sequential embedding - projection pair between @xmath55 and @xmath57 induced by the inclusion map and the restriction map at base type .",
    "the crucial properties are :    @xmath59 and @xmath60    since we will consider @xmath55 to be a subset of @xmath57 we will also consider @xmath61 to be the inclusion map , and not mention it again .",
    "we will need @xmath62 in the sequel , viewing it as a restriction map .",
    "we will use the obvious fact that each @xmath55 is a finite set .",
    "we say that two procedures are _ equivalent _ if they define the same functional . in @xcite",
    "a procedure was defined to be _ normal _ if we will only use @xmath30s of the form @xmath63 with @xmath46 in the coinductive definition .",
    "it is not the case that all procedures will be equivalent to procedures on normal forms , so this term is slightly misleading . as usual , we will say that a function @xmath15 is _ strict _ if @xmath64 .",
    "it is the presence of non - strict functions , and the fact that sometimes @xmath65 may terminate _ because _",
    "some @xmath66 is not strict , that makes it impossible to prove a normalisation theorem .",
    "plotkin proved that the strict functions between _ concrete domains _ will form _ _",
    "dcpo__s , see kahn and plotkin @xcite , for definitions . from now on ,",
    "@xmath67 will always be a subset of @xmath68 .    [",
    "2.3 ] if @xmath69 is a sequential functional , we let @xmath70 be defined by    @xmath71 if there is a sequence @xmath72 such that    * @xmath73 is strict when @xmath74 . *",
    "@xmath75 .",
    "@xmath76 will be sequential when @xmath69 is , since @xmath70 is the composition of @xmath69 and sequential  strictification \"- functionals .",
    "this argument requires that we know that the sequential functionals form an applicative structure , see @xcite or @xcite .",
    "definition [ 2.4 ] will contain a direct construction of a procedure for @xmath70 from a procedure for @xmath69 in the finite case , and then it will follow that @xmath70 is sequential from our main theorem .",
    "a finite sequential procedure may be nested in two directions , in depth ( or to the left ) and in length ( or to the right )",
    ". we will prove that if @xmath69 is finite there is a special procedure for @xmath76 of uniformly bounded depth , and this will be our alternative to the normal form theorem for sequential procedures restricted to strict arguments .    [ 2.4 ] let @xmath25 be a finite , non - empty sequential procedure .",
    "we define the procedure @xmath77 $ ] by cases as follows :    1 .",
    "if @xmath26 , we let @xmath77 = p$ ] .",
    "2 .   let @xmath25 = case @xmath28 of @xmath78 : * if @xmath79 , let + @xmath77 $ ] = case @xmath80)$ ] of @xmath81\\}$ ] * if @xmath74 , and @xmath82 we write @xmath83 for @xmath30 and let + @xmath77 $ ] = case @xmath84 of @xmath85\\}$ ] . * if @xmath74 and @xmath30 = case @xmath86 of @xmath87 , we first let + @xmath88 case @xmath86 of @xmath89 case @xmath90 of @xmath91 + and then let @xmath77 = \\hat p[s]$ ] .    [ 2.5 ]    _ _    * @xmath77 $ ] is well defined , i.e. the rewriting terminates . *",
    "if @xmath39 $ ] , then @xmath92\\;]]$ ] .",
    "_ proof _ a ) is proved by finding a suitable complexity measure as follows : when @xmath25 is a finite sequential procedure , the evaluation of @xmath40(\\vec f)$ ] will have a bounded finite length , even if we insist on evaluating @xmath47(\\vec f)$ ] to a value in @xmath9 when @xmath66 is not strict and @xmath93(\\vec f))$ ] is asked for in the process . for input @xmath17",
    "we will let the length of the evaluation of @xmath40(\\vec f)$ ] be the number of evaluations @xmath47(\\vec f)$ ] we thus have to perform in the process .",
    "then we use induction on the maximal possible length of an evaluation . in case",
    "2.3 @xmath94 will have lower complexity than @xmath25 since we omit the need to evaluate @xmath95 , while both in the evaluation of @xmath40(\\vec f)$ ] and @xmath96(\\vec f)$ ] we have to evaluate @xmath97(\\vec f)$ ] , some @xmath44(\\vec f)$ ] and some @xmath98 ( with all their sub - evaluations ) , though in different orders in the two cases . for the rest of the cases , it is easy to see how the induction hypothesis is used .    in order to prove b ) we will use induction on the number of rewritings following the clauses of definition [ 2.4 ] we need in order to find @xmath77 $ ] , and prove that @xmath99\\;]](\\vec f ) = [ [ p]]_{s,}(\\vec f)$ ] for each input @xmath17 .",
    "we go through each of the steps :    * this case is trivial * there will be two sub - cases : : then @xmath47_{s}(\\vec f ) = [ [ q]]_{s \\cup \\{i\\}}(\\vec f)$ ] by construction , and the case follows from the induction hypothesis . :",
    "then it does not matter whatever we rewrite @xmath30 to , and by the induction hypothesis @xmath100\\;]](\\vec f ) = [ [ p_a]]_{s}(\\vec f)$ ] , so the conclusion holds . *",
    "this case is trivial . * in this case we use that when @xmath66 is strict , then @xmath40(\\vec f ) = [ [ \\hat p]](\\vec f)$ ] , and the rest follows by the induction hypothesis .",
    "this ends the proof .",
    "let @xmath25 be a sequential procedure .",
    "we say that @xmath25 is on _ @xmath67-normal form _",
    "if @xmath101 .",
    "a sequential procedure on @xmath67-normal form is left bounded with the cardinality of @xmath102 as its left bound .",
    "in tis section , we will make use of some basic facts about the finite sequential functionals proved in e.g. @xcite .",
    "one fact is that any sequential functional will be the least upper bound of a sequence of finite ones , in the sense that the graph is the union of the graphs of the approximations .",
    "another fact is that if two finite sequential functionals @xmath69 and @xmath103 are bounded by a sequential functional @xmath104 , then there is a sequential least upper bound @xmath105 of the two .",
    "this is not necessarily the set theoretical union of @xmath69 and @xmath103 .",
    "this section will be devoted to the proof of the following    [ main]_let @xmath106 be an increasing sequence of sequential functionals of type @xmath7 .",
    "then the least upper bound @xmath107 seen as a function , will be sequential . _",
    "if we do not allow for non - strict arguments at all , this theorem is part of the folklore , and is indeed covered by the more general result due to plotkin mentioned in the introduction .",
    "the theorem will be a special case of the key lemma , see below .",
    "this will be proved by induction , and the mentioned folklore result can be seen as the base case .    even in the simplest case , there will be an increasing sequence @xmath108 of finite sequential functionals of type @xmath109 that can be enumerated in a primitive recursive way such that the least upper bound has the complexity of the turing jump .",
    "thus it is impossible to give a constructive proof of our main result .",
    "arithmetical comprehension will suffice , but we will not stress on pointing out where non - constructive arguments are used .    throughout section [ sec3 ]",
    "we will let @xmath106 be a @xmath14-increasing sequence of finite sequential functionals and let @xmath110 be the pointwise least upper bound . by the first remark in section [ sec3 ] , this suffices .",
    "we will use the terminology of the previous section .",
    "[ lemma3.2]_without loss of generality , we may assume that @xmath111 for each @xmath54 and that @xmath112 when @xmath113 .",
    "_    _ proof_let @xmath114 since @xmath55 is finite , these least upper bounds exist as sequential functionals .",
    "clearly the sequences @xmath115 and @xmath106 will have the same least upper bounds .",
    "this ends the proof .",
    "from now on we will assume that the sequence we consider satisfies the conclusion of this lemma .",
    "we will prove the following stronger result by reversed induction on the size of @xmath67 :    [ kl ] _ @xmath116 is sequential .",
    "_      we have to develop some notation and prove some partial results before we are able to give the proof of lemma [ kl ] .",
    "the argument will be the same for all @xmath67 , except that for @xmath117 we will never be in a situation where we have to appeal to the induction hypothesis .    *",
    "a sequential functional @xmath69 is an",
    "_ @xmath67-functional _ if @xmath118 .",
    "* an _ @xmath67-query _ is a pair @xmath119 where @xmath120 and * * @xmath103 is a constant @xmath32 if @xmath74 * * @xmath103 is an @xmath121-functional if @xmath122 * an _ @xmath67-pre - path _ is a finite sequence @xmath123 where each @xmath124 is an @xmath67-query and each @xmath125 .",
    "* let @xmath126 be a sequence of functions in @xmath21 and let @xmath127 be an @xmath67-pre - path .",
    "we say that @xmath17 and @xmath128 _ match _ if @xmath129 for each @xmath130 .",
    "@xmath67-path _ is an @xmath67-pre - path that is matching at least one sequence @xmath17 .",
    "an @xmath67-path @xmath131 will satisfy the following consistency condition : if @xmath132 and @xmath133 and @xmath134 are consistent , then @xmath135 .",
    "this will not necessarily hold for pre - paths .",
    "if @xmath25 is a finite sequential procedure on @xmath67-normal form and @xmath127 is an @xmath67-path , we may _ evaluate _",
    "@xmath25 on @xmath128 as follows :    * if @xmath25 is a constant @xmath50 we output @xmath50 directly .",
    "* let @xmath136 case @xmath28 of @xmath137 .",
    "if there is a @xmath130 such that @xmath138 and @xmath139 $ ] we let @xmath140 be the first intermediate value of the evaluation , and continue with evaluating @xmath141 on @xmath128 .",
    "if there is no such @xmath130 , the evaluation stops with output @xmath53 .",
    "we write @xmath142 for the output of this process .    the paths will be forms of approximations to input sequences in the sense that they will carry the information about an input sequence we may have obtained after a partial evaluation of a sequential procedure .    in the definition of how to evaluate a finite procedure on a path , we implicitly assume that the functionals in the path are themselves finite .",
    "this is not a part of the definition , and we will make use of paths where the @xmath103 s are infinite sequential functionals obtained by the induction hypothesis",
    ". we will have to work carefully with approximations in order to make this work .",
    "it is clear that if @xmath17 matches @xmath143 and @xmath25 is a sequential procedure on @xmath67-normal form that evaluated on @xmath123 yields a value @xmath83 , then @xmath40(\\vec f ) = c$ ] . as a consequence",
    ", we see that if we evaluate two equivalent procedures on @xmath67-normal forms on the same @xmath67-path , the results will be consistent , meaning that if they both terminate , the output will be the same .",
    "we do not think that the outputs have to be equal , i.e. one may terminate and the other not , but have not produced an example .",
    "let @xmath69 be an @xmath67-functional , @xmath143 an @xmath67-path .",
    "an @xmath67-query @xmath119 is _ critical _ for @xmath69 at @xmath128 if for every sequence @xmath17 matching @xmath128 for which @xmath144 we have that @xmath145 .",
    "[ lemma3.6 ] _ let @xmath39 $ ] be a finite @xmath67-functional , where @xmath25 is a procedure on @xmath67-normal form .",
    "let @xmath128 be a path such that @xmath25 evaluated on @xmath128 does not yield a value in @xmath36 .",
    "assume that there is some @xmath17 matching @xmath128 such that @xmath146 .",
    "then there is an @xmath67-query @xmath119 that is critical for @xmath69 at @xmath128 , and moreover , such that there is no @xmath130 with @xmath138 and @xmath147 . _",
    "_ proof _ for any @xmath17 that matches @xmath128 , the evaluation of @xmath25 on @xmath17 will follow the same path through the procedure tree as the evaluation of @xmath25 on @xmath128 , until the latter comes to a halt .",
    "this must be because the evaluation reached a subprocedure    @xmath148 case @xmath28 of @xmath149    while there is no @xmath130 such that @xmath150 and @xmath139 $ ] .",
    "for the evaluation on @xmath17 to proceed , we must have that @xmath151(\\vec f ) ) \\in { { \\mathbb n}}$ ] .",
    "let @xmath152 $ ]",
    ". then @xmath119 will be critical for @xmath69 at @xmath128 and satisfy the extra requriement .",
    "this ends the proof .",
    "one problem with the concepts we have defined so far is that if @xmath25 is a procedure that we may evaluate on a path @xmath128 , and we extend the @xmath133 s in the path to some @xmath153 s , then the evaluation may not work anymore .",
    "this is not so strange as it may seem .",
    "if we extend the items of a path , the path will match more function sequences @xmath17 , also some for which the original procedure does not terminate .",
    "however , it is in order to handle the technical problem induced by this phenomenon that we assume that our increasing sequence @xmath106 has the properties of lemma [ lemma3.2 ] .",
    "we will take the liberty to extend the use of the term @xmath154 for the projection to @xmath55 to all types in question , in particular to @xmath155 and @xmath156 defined by :    * let @xmath157 be the functions of type @xmath13 , and let @xmath155 be the corresponding set of functions in @xmath158 . * if @xmath119 is an @xmath67-query , we let @xmath159 . *",
    "if @xmath143 is a path , we let @xmath160    notice that @xmath161 is not necessarily a path , since it does not have to match any @xmath17 if too much information is removed .",
    "[ lemma3.8 ]    _ _    * if @xmath162 and @xmath163 , then @xmath164 . * if @xmath165 and @xmath166 , then @xmath167 . *",
    "if @xmath163 and @xmath128 is a path matching @xmath17 , then @xmath161 is a path matching @xmath17 .",
    "_ proof _ a ) and b ) follows from the iterative construction of the projection @xmath154 over the types .",
    "the definition of matching requires that for any @xmath168 in @xmath128 we must have that @xmath169 . for this to hold",
    ", we must either have that @xmath66 is constant @xmath170 or that @xmath171 .",
    "in the first case , the claim is trivial , and in the second case we may use @xmath172 .",
    "this establishes c ) and ends the proof .",
    "we will extend the @xmath154 also to procedures :    if @xmath25 is a procedure , we let @xmath173 be the procedure we obtain by hereditarily cutting out all branchings to sub - procedures @xmath174 where @xmath175 in the top  down way .    it is easy to see that @xmath176 ) = [ [ \\pi_k(p)]]$ ] , because any evaluation of @xmath25 with an input from @xmath156 can only utilise values bounded by @xmath177 in the evaluation .",
    "[ lemma3.11]_let @xmath128 be a path , @xmath69 a functional and @xmath119 be critical for @xmath69 at @xmath128 .",
    "then @xmath178 is critical for @xmath179 at @xmath161 . _",
    "_ proof _ let @xmath163 be such that @xmath161 matches @xmath17 and such that @xmath180 .",
    "then @xmath128 matches @xmath17 and @xmath144 , so @xmath181 . by lemma [ lemma3.8 ]",
    "then , @xmath182 .",
    "this ends the proof",
    ".      we will now let the sequence @xmath106 be given , satisfying the assumption of lemma [ lemma3.2 ] , and we let @xmath166 be given .",
    "we have that @xmath183 , and we will device a sequential procedure for evaluating @xmath184 . to this end , we will construct a path matching @xmath17 step by step until we have enough information about @xmath17 to know the value of @xmath184 . we will prove that if @xmath185 , then our procedure applied to @xmath17 will come to a halt , and that whenever it halts , the conclusion will be the right one for the given input .    for each @xmath54 ,",
    "let @xmath186 be on @xmath67-normal form such that @xmath187 $ ] .",
    "we will describe one step in the construction :    let @xmath143 be the path matching @xmath17 constructed after step @xmath188 .    1 .",
    "if there is some @xmath177 such that @xmath189 we know that @xmath190 and we output this value .",
    "2 .   if there is no @xmath191 such that @xmath191 matches @xmath128 and @xmath192 , we know that @xmath193 , and our procedure applied to @xmath17 comes to a halt with output @xmath53 .",
    "3 .   otherwise , let @xmath177 be minimal such that for some @xmath194 matching @xmath128 we have that @xmath195 terminates .",
    "select one such @xmath191 .",
    "notice that we can split between the cases 1 .",
    ", 2 . and 3 . on the basis of @xmath128 , and that the values of @xmath177 and @xmath191 in this case only depends on @xmath128 , so we do not need to know @xmath17 in order to know what to do . + let @xmath196",
    ". then @xmath197 while @xmath198 . by lemma [ lemma3.6 ]",
    "there will be an @xmath67-query @xmath199 that is critical for @xmath200 at @xmath201 such that there is no @xmath130 with @xmath202 and @xmath203 .",
    "then , by lemma [ lemma3.11 ] , @xmath204 will be critical for @xmath205 at @xmath161 .",
    "since @xmath206 and @xmath194 , we have that @xmath207 . since @xmath208 we also have that @xmath209 is a procedure for @xmath210 , and the evaluation of @xmath211 will match the evaluation of @xmath212 for as long as the latter evaluation goes .",
    "it follows that @xmath204 will be the query unanswered by @xmath161 that we get when proving lemma [ lemma3.6 ] for @xmath209 , @xmath161 and @xmath191 .",
    "these considerations contain a proof of for each @xmath196 , let @xmath213 be the set consisting of pairs @xmath214 that are critical @xmath67-queries for @xmath200 at @xmath201 and such that for no @xmath215 we have that @xmath216 and @xmath217 .",
    "then @xmath213 is nonempty .",
    "if @xmath218 , then @xmath219 will project @xmath220 to @xmath221 , and each @xmath213 is finite .",
    "we use knig s lemma to see that there will be one @xmath222 and one increasing sequence @xmath223 of @xmath121-functionals , with each @xmath224 .",
    "we select one such sequence ( depending on @xmath128 , but not on @xmath17 . )",
    "if @xmath74 we actually have that all @xmath225 s are the same constant .",
    "if @xmath122 , we use the induction hypothesis , and let @xmath226 be sequential . if @xmath227 our procedure for @xmath184 will not terminate , which is as it should be since @xmath214 is critical at @xmath128 , so @xmath184 will not terminate either .",
    "if @xmath228 , we ad @xmath229 to our path and continue the process .",
    "this is the only place where we actually use @xmath17 , an clearly , the new path will also match @xmath17 .    clearly , if this process on @xmath17 leads to a conclusion after finitely many steps , the output in @xmath9 will coincide with @xmath184 .",
    "it remains to prove that if @xmath185 , then the process will terminate .",
    "* let @xmath185 and let @xmath230 be minimal such that @xmath231 . without loss of generality we may assume that @xmath232 , and then @xmath233 .",
    "when we apply our strategy to the input @xmath17 , we will build up a path matching @xmath17 , and as long as the @xmath67-normal procedure for @xmath234 does not terminate on the path built up , the @xmath177 of the construction will be bounded by @xmath230 . but as long as this is the case , we are properly extending the path even when projected to the @xmath230-level .",
    "this level is finite , so this can not go on forever .",
    "the conclusion is that our process , when applied to @xmath17 , must terminate .",
    "this ends the proof of the key lemma .",
    "in this note we have not just completed the characterisation of when the sequential functionals of a type @xmath33 form a _ dcpo_. as a bonus , we have proved that the sequential functionals of the types @xmath7 are what is called  left bounded \" in @xcite , and with a uniform bound on the left nesting needed .",
    "one key aspect of the examples in @xcite is that the sequence without a sequential upper bound in both cases will have increasing left depth , and in the limit there has to be an evaluation with an infinite left nesting of sub - procedure calls .",
    "it is then natural to ask if the substructure of the sequential functionals of any type with a fixed bound on the left nesting will form a _",
    "dcpo_. this seems likely , but since these classes in general does not seem to possess other interesting closure properties , a result along these lines will be of limited interest",
    ".    there were some other attempts to characterise properties in @xcite with some minor gaps ( unexplored territory ) in them .",
    "another natural question is if it is possible to close some or all of those gaps as well .",
    "it is still not known exactly when a finitary sequential functional is the least upper bound of some non - trivial increasing sequence of sequential functionals .",
    "these problems may be worthwhile to look into , not because the results will be of particular interest in themselves , but because solving the problems may lead to a better understanding of the sequential functionals .",
    "99 abramsky , s. , jagadeesan , r. : games and full completeness for multiplicative linear logic .",
    "journal of symbolic logic * 59(2 ) * , 543574 ( 1994 ) hyland , j.m.e . ,",
    "ong , c .- h.l . : on full abstraction for pcf : i , ii , and iii .",
    "information and computation * 163 * , 285408 ( 2000 ) kahn , g. , plotkin , g.d . : concrete domains .",
    "theoretical computer science * 121 * , 178277 ( 1993 ) , first appeared in french as inria technical report ( 1978 ) longley , j.r . , normann ,",
    "d. : higher - order computability , springer verlag , 2015 milner , r. : fully abstract models of typed @xmath235-calculi .",
    "theoretical computer science * 4(1 ) * , 122 ( 1977 )      normann , d. : sequential functionals of type 3 .",
    "mathematical structures in computer science * 16(2 ) * , 279289 ( 2006 ) normann , d. , sazonov , v.yu . : the extensional ordering of the sequential functionals .",
    "annals of pure and applied logic * 163(5 ) * 575603 ( 2012 )"
  ],
  "abstract_text": [
    "<S> we prove that the sequential functionals of some fixed types at type level 2 , taking finite sequences of unary functions as arguments , do form a directed complete partial ordering . </S>",
    "<S> this gives a full characterisation of for which types the partially ordered set of sequential functionals has this property .    as a tool , </S>",
    "<S> we prove a normal form theorem for the finite sequential functionals of the types in question . </S>"
  ]
}