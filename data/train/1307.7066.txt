{
  "article_text": [
    "turing proved in 1936 that undecidability exists by showing that the halting problem is undecidable  @xcite .",
    "rice extended the set of known undecidable problems to cover all questions of the form `` does the partial function computed by the given program have property @xmath0 '' , where @xmath0 is any property that at least one computable partial function has and at least one does not have  @xcite .",
    "for instance , @xmath0 could be `` returns @xmath1 for all syntactically correct c++ programs and @xmath2 for all remaining inputs . '' in other words , it may be impossible to find out whether a given weird - looking program is a correct c++ syntax checker .",
    "these results are basic material in such textbooks as  @xcite .",
    "on the other hand , imperfect halting testers are possible . for any instance of the halting problem , a _ three - way tester _ eventually answers `` yes '' , `` no '' , or `` i do nt know '' .",
    "if it answers `` yes '' or `` no '' , then it must be correct .",
    "we say that the `` i do nt know '' instances are _ hard instances _ for the tester .",
    "also other kinds of imperfect testers have been introduced , as will be discussed in section  [ s : variants ] .",
    "assume that @xmath3 is a tester . by turing s proof",
    ", it has a hard instance @xmath4 .",
    "if @xmath4 is a halting instance , then let @xmath5 be `` if the input is @xmath4 , then reply ` yes ' , otherwise run @xmath3 and return its reply '' .",
    "if @xmath4 is non - halting , then let @xmath5 be `` if the input is @xmath4 , then reply ` no ' , otherwise run @xmath3 and return its reply '' . by construction",
    ", @xmath5 is a tester with one fewer hard instances than @xmath3 has . by turing s proof",
    ", also @xmath5 has a hard instance .",
    "let us call it @xmath6 .",
    "it is hard also for @xmath3 .",
    "this reasoning can be repeated without limit , yielding an infinite sequence @xmath3 , @xmath5 ,   of testers and @xmath4 , @xmath6 ,   of instances such that @xmath7 is hard for @xmath3 ,  , @xmath8 but not for @xmath9 ,  .",
    "therefore , every tester has an infinite number of hard instances , but no instance is hard for all testers .    a program that answers `` i do nt know '' for every program and input is a three - way tester , although it is useless .",
    "a much more careful tester simulates the given program on the given input at most @xmath10 steps , where @xmath11 is the joint size of the program and its input .",
    "if the program stops by then , then the tester answers `` yes '' . if the program repeats a configuration ( that is , a complete description of the values of variables , the program counter , etc . ) by then , then the tester answers `` no '' .",
    "otherwise it answers `` i do nt know '' . with this theoretically possible but in practice unrealistic tester ,",
    "any hard halting instance has a finite but very long running time .    the proofs by turing and rice may leave the hope that only rare artificial contrived programs yield hard instances .",
    "one could dream of a three - way tester that answers very seldom `` i do nt know '' .",
    "this publication analyses this issue , by surveying and proving results that tell how the proportion of hard instances behaves when the size of the instances grows without limit .",
    "section  [ s : def ] presents the variants of the halting problem and imperfect testers surveyed , together with some basic results and notation .",
    "earlier research is discussed in section  [ s : related ] .",
    "the section contains some proofs to bring results into the framework of this publication .",
    "section  [ s : proglang ] presents some new results in the case that a program has many copies of all big sizes , or information can be packed densely inside the program .",
    "it is not always assumed that the program has access to the information .",
    "a natural example of such information is dead code , such as ` if(1==0)then {  } ` . in section  [ s : c++ ] , results are derived for c++ programs with inputs from files .",
    "section  [ s : conclusions ] briefly concludes this publication .",
    "this publication is a significantly extended version of  @xcite .",
    "the papers  @xcite are otherwise essentially the same , but three proofs were left out from  @xcite because of lack of space . in the present publication , theorems  [ t : ill - eof ] and  [ t : hard - sd ] and corollaries  [ c : nolimit1 ] and  [ c : nolimit2 ] are new results lacking from  @xcite . furthermore ,  @xcite incorrectly claimed the opposite of theorem  [ t : hard - sd ] .",
    "the present publication fixes this error and also a small error in proposition  [ p : syntax ] .",
    "the literature on hard instances of the halting problem considers at least three variants of the halting problem :    e : :    does the given program halt on the _ empty _ input  @xcite , s : :    does the given program halt when given _ itself _ as its input  ( * ? ? ?",
    "* ;    * ? ? ?",
    "* ) , and g : :    does the given program halt on the _ given _ input  ( * ? ? ?",
    "* ; * ? ? ?",
    "* ;    * ? ? ?",
    "each variant is undecidable .",
    "variant g has a different notion of instances from others : program  input pairs instead of just programs .",
    "a tester for g can be trivially converted to a tester for e or s , but the proportion of hard program ",
    "input pairs among all program  input pairs of some size is not necessarily the same as the similar proportion with the input fixed to the empty one or to the program itself .",
    "the literature also varies on what the tester does when it fails .",
    "three - way testers , that is , the `` i do nt know '' answer is used implicitly by  @xcite , as it discusses the union of two decidable sets , one being a subset of the halting and the other of the non - halting instances . in _",
    "generic - case decidability _",
    "@xcite , instead of the `` i do nt know '' answer , the tester itself fails to halt .",
    "yet another idea is to always give a `` yes '' or `` no '' answer , but let the answer be incorrect for some instances  @xcite .",
    "such a tester is called _",
    "approximating_. one - sided results , where the answer is either `` yes '' or `` i do nt know '' , were presented in  @xcite . for a tester of any of the three variants , we say that an instance is _ easy _ if the tester correctly answers `` yes '' or `` no '' on it , otherwise the instance is _",
    "these yield altogether nine different sets of testers , which we will denote with three - way(x),generic(x ) , and approx(x ) , where x is e , s , or g. some simple facts facilitate carrying some results from one variant of testers to another .",
    "[ p:3way- > ] for any three - way tester there is a generic - case tester that has precisely the same easy `` yes''-instances , easy `` no''-instances , hard halting instances , and hard non - halting instances .",
    "there also is an approximating tester that has precisely the same easy `` yes''-instances , at least the same easy `` no''-instances , precisely the same hard halting instances , and no hard non - halting instances ; and an approximating tester that has at least the same easy `` yes''-instances , precisely the same easy `` no''-instances , no hard halting instances , and precisely the same hard non - halting instances .",
    "a three - way tester can be trivially converted to the promised tester by replacing the `` i do nt know '' answer with an eternal loop , the reply `` no '' , or the reply `` yes '' .    [ p : gen->gen ] for any generic - case tester there is a generic - case tester that has at least the same `` yes''-instances , precisely the same `` no''-instances , no hard halting instances , and precisely the same hard non - halting instances .    in parallel with the original tester , the instance is simulated .",
    "( in turing machine terminology , parallel simulation is called `` dovetailing '' . )",
    "if the original tester replies something , the simulation is aborted .",
    "if the simulation halts , the original tester is aborted and the reply `` yes '' is returned .",
    "[ p : finite ] for any @xmath12 and tester @xmath13 , there is a tester @xmath8 that answers correctly `` yes '' or `` no '' for all instances of size at most @xmath14 , and similarly to @xmath13 for bigger instances .",
    "because there are only finitely many instances of size at most @xmath14 , there is a finite bit string that lists the correct answers for them . if @xmath15 , @xmath8 picks the answer from it and otherwise calls @xmath13 .",
    "( we do not necessarily know what bit string is the right one , but that does not rule out its existence . )",
    "we use @xmath16 to denote the set of characters that are used for writing programs and their inputs .",
    "it is finite and has at least two elements .",
    "there are @xmath17 character strings of size @xmath11 .",
    "if @xmath18 and @xmath19 are in @xmath20 , then @xmath21 denotes that @xmath18 is a prefix of @xmath19 , and @xmath22 denotes proper prefix .",
    "the size of @xmath18 is denoted with @xmath23 .",
    "a set @xmath24 of finite character strings is _ self - delimiting _ if and only if membership in @xmath24 is decidable and no member of @xmath24 is a proper prefix of a member of @xmath24 .",
    "the _ shortlex ordering _ of any set of finite character strings is obtained by sorting the strings in the set primarily according to their sizes and strings of the same size in the lexicographic order .    not necessarily all elements of @xmath20 are programs .",
    "the set of programs is denoted with @xmath25 , and the set of all ( not necessarily proper ) prefixes of programs with @xmath26 .",
    "so @xmath27 .",
    "for tester variants e and s , we use @xmath28 to denote the number of programs of size @xmath11 .",
    "then @xmath29 . for tester variant g",
    ", @xmath28 denotes the number of program ",
    "input pairs of joint size @xmath11 .",
    "we will later discuss how the program and its input are paired into a single string .",
    "the numbers of halting and non - halting ( a.k.a .",
    "diverging ) instances of size @xmath11 are denoted with @xmath30 and @xmath31 , respectively .",
    "we have @xmath32 .",
    "if @xmath13 is a tester , then @xmath33 , @xmath34 , @xmath35 , and @xmath36 denote the number of its easy halting , hard halting , easy non - halting , and hard non - halting instances of size @xmath11 , respectively . obviously @xmath37 and @xmath38 .",
    "the smaller @xmath34 and @xmath36 are , the better the tester is .",
    "the _ failure rate _ of @xmath13 is @xmath39 .",
    "when referring to all instances of size at most @xmath11 , we use capital letters .",
    "so , for example , @xmath40 and @xmath41 .",
    "nancy lynch  @xcite used _ gdel numberings _ for discussing programs .",
    "in essence , it means that each program has at least one index number ( which is a natural number ) from which the program can be constructed , and each natural number is the index of some program .",
    "although the index of an individual program may be smaller than the index of some shorter program , the overall trend is that indices grow as the size of the programs grows , because otherwise we would run out of small numbers . on the other hand ,",
    "if the mapping between the programs and indices is 11 , then the growth can not be faster than exponential .",
    "this is because @xmath42 . with real - life programming languages ,",
    "the growth is exponential , but ( as we will see in section  [ s : c++model ] ) the base of the exponent may be smaller than @xmath43 .    to avoid confusion ,",
    "we refrain from using the notation @xmath44 , etc . , when discussing results in  @xcite , because the results use indices instead of sizes of programs , and their relationship is not entirely straightforward .",
    "fortunately , some results of  @xcite can be immediately applied to programming languages by using the _ shortlex gdel numbering_. the shortlex gdel number of a program is its index in the shortlex ordering of all programs .",
    "the first group of results of  @xcite reveals that a wide variety of situations may be obtained by spreading the indices of all programs sparsely enough and then filling the gaps in a suitable way .",
    "for instance , with one gdel numbering , for each three - way tester , the proportion of hard instances among the first @xmath14 indices approaches @xmath1 as @xmath14 grows . with another gdel numbering",
    ", there is a three - way tester such that the proportion approaches @xmath2 as @xmath14 grows .",
    "there even is a gdel numbering such that as @xmath14 grows , the proportion oscillates in the following sense : for some three - way tester , it comes arbitrarily close to @xmath2 infinitely often and for each three - way tester , it comes arbitrarily close to @xmath1 infinitely often .    in its simplest form ,",
    "spreading the indices is analogous to defining a new language spaciousc++ whose syntax is identical to that of c++ but the semantics is different .",
    "if the first @xmath45 characters of a spaciousc++ program of size @xmath11 are space characters , then the program is executed like a c++ program , otherwise it halts immediately .",
    "this does not restrict the expressiveness of the language , because any c++ program can be converted to a similarly behaving spaciousc++ program by adding sufficiently many space characters to its front .",
    "however , it makes the proportion of easily recognizable trivially halting instances overwhelm . a program that replies `` yes '' if there are fewer than @xmath45 space characters at the front and `` i do nt know '' otherwise , is a three - way tester .",
    "its proportion of hard instances vanishes as the size of the program grows .    as a consequence of this and proposition  [ p : finite ]",
    ", one may choose any failure rate above zero and there is a three - way tester for spaciousc++ programs with at most that failure rate .",
    "of course , this result does not tell anything about how hard it is to test the halting of interesting programs .",
    "this is the first example in this publication of what we call _ an anomaly stealing the result_. that is , a proof of a theorem goes through for a reason that has little to do with the phenomenon we are interested in .    indeed ,",
    "the first results of  @xcite depend on using unnatural gdel numberings .",
    "they do not tell what happens with untampered programming languages .",
    "even so , they rule out the possibility of a simple and powerful general theorem that applies to all models of computation",
    ". they also make it necessary to be careful with the assumptions that are made about the programming language .    to get sharper results , _ optimal gdel numberings _",
    "were discussed in  @xcite .",
    "they do not allow distributing programs arbitrarily .",
    "a gdel numbering is optimal if and only if for any gdel numbering , there is a computable function that maps it to the former such that the index never grows more than by a constant factor .",
    "the most interesting sharper results are opposite to what was obtained without the optimality assumption . to apply them to programming languages , we first define a programming language version of optimal gdel numberings .",
    "[ d : eof - data ] a programming language is _ end - of - file data segment _ , if and only if each program consists of two parts in the following way . the first part , called the _ actual program _ ,",
    "is written in a self - delimiting language ( so its end can be detected ) .",
    "the second part , called the _ data segment _ , is an arbitrary character string that extends to the end of the file .",
    "the language has a construct via which the actual program can read the contents of the data segment .",
    "the data segment is thus a data literal in the program , packed with maximum density .",
    "it is not the same thing as the input to the program .",
    "[ c : lyn6 ] for each end - of - file data segment language ,",
    "@xmath46 @xmath47    let @xmath48 be the end - of - file data segment language , and let @xmath49 be any gdel numbering .",
    "consider the following program @xmath50 in @xmath48 .",
    "let @xmath51 and @xmath52 be the sizes of its actual program and data segment .",
    "the actual program reads the data segment , interpreting its content as a number @xmath14 in the range from @xmath53 to @xmath54 .",
    "then it simulates the @xmath14th program in @xmath49 .",
    "the shortlex index of @xmath50 is at most @xmath55 , yielding @xmath56 , so @xmath57 , thus @xmath58 .",
    "the shortlex numbering of @xmath48 is thus an optimal gdel numbering . from this",
    ", proposition  6 in  @xcite gives the claims .",
    "a remarkable feature of the latter result compared to many others in this publication is that @xmath59 is chosen before @xmath13 .",
    "that is , there is a positive constant that only depends on the programming language ( and not on the choice of the tester ) such that all testers have at least that proportion of hard instances , for any big enough @xmath11 . on the other hand ,",
    "the proof depends on the programming language allowing to pack raw data very densely .",
    "real - life programming languages do not satisfy this assumption .",
    "for instance , c++ string literals `  ` can not pack data densely enough , because the representation of ` \" ` inside the literal ( e.g. , `  \" ` or `  042 ` ) requires more than one character .",
    "because of proposition  [ p : finite ] , `` @xmath60 '' can not be moved to the front of `` @xmath61 '' .",
    "the result can not be generalized to @xmath62 , @xmath63 , and @xmath64 , because the following anomaly steals it .",
    "we can change the language by first adding ` 1 ` or ` 01 ` to the beginning of each program @xmath65 and then declaring that if the size of ` 1`@xmath65 or ` 01`@xmath65 is odd , then it halts immediately , otherwise it behaves like @xmath65 .",
    "this trick does not invalidate optimality but introduces infinitely many sizes for which the proportion of hard instances is @xmath2 .      in  @xcite ,",
    "the halting problem was analyzed in the context of programming languages that are _ frequent _ in the following sense :    [ d : frequent ] a programming language is ( a ) _ frequent _ ( b ) _ domain - frequent _ , if and only if for every program @xmath65 , there are @xmath66 and @xmath67 such that for every @xmath68 , at least @xmath69 programs of size @xmath11 ( a ) compute the same partial function as @xmath65 ( b ) halt on precisely the same inputs as @xmath65 .    instead of `` frequent ''",
    ", the word `` dense '' was used in  @xcite , but we renamed the concept because we felt `` dense '' a bit misleading .",
    "the definition says that programs that compute the same partial function are common .",
    "however , the more common they are , the less room there is for programs that compute other partial functions , implying that the smallest programs for each distinct partial function must be distributed more sparsely .",
    "`` dense '' was used for domain - frequent in  @xcite .",
    "any frequent programming language is obviously domain - frequent but not necessarily vice versa . on the other hand ,",
    "even if a theorem in this field mentions frequency as an assumption , the odds are that its proof goes through with domain - frequency . whether a real - life programming language such as c++ is domain - frequent , is surprisingly difficult to find out .",
    "we will discuss this question briefly in section  [ s : frequent ] .    as an example of a frequent programming language ,",
    "was mentioned in  @xcite .",
    "its full name starts with `` brain '' and then contains a word that is widely considered inappropriate language , so we follow the convention of  @xcite and call it .",
    "information on it can be found on wikipedia under its real name .",
    "it is an exceptionally simple programming language suitable for recreational and illustrational but not for real - life programming purposes .",
    "in essence ,  programs describe turing machines with a read - only input tape , write - only output tape , and one work tape .",
    "the alphabet of each tape is the set of 8-bit bytes .",
    "however ,  programs only use eight characters .    as a side issue , a non - trivial proof was given in  @xcite that only a vanishing proportion of character strings over the eight characters are programs .",
    "that is , @xmath70 exists and is @xmath2 .",
    "it trivially follows that if all character strings over the 8 characters are considered as instances and failure to compile is considered as non - halting , then the proportion of hard instances vanishes as @xmath11 grows .",
    "the only possible compile - time error in  is that the square brackets ` [ ` and ` ] ` do not match .",
    "most , if not all , real - life programming languages have parentheses or brackets that must match .",
    "so it seems likely that compile - time errors dominate also in the case of most , if not all , real - life programming languages .",
    "unfortunately , this is difficult to check rigorously , because the syntax and other compile - time rules of real - life programming languages are complicated . using another , simpler line of argument",
    ", we will prove the result for both c++ and  in section  [ s : syntax ] .    in any event",
    ", if the proportion of hard instances among all character strings vanishes because the proportion of programs vanishes , that is yet another example of an anomaly stealing the result .",
    "it is uninteresting in itself , but it rules out the possibility of interesting results about the proportion of hard instances of size @xmath11 among all character strings of size @xmath11",
    ". therefore , from now on , excluding section  [ s : syntax ] , we focus on the proportion of hard instances among all programs or program  input pairs .    in the case of program",
    " input pairs , the results may be sensitive to how the program and its input are combined into a single string that is used as the input of the tester . to avoid anomalous results ,",
    "it was assumed in  @xcite that this `` pairing function '' has a certain property called `` pair - fair '' .",
    "the commonly used function @xmath71 is pair - fair . to use this pairing function ,",
    "strings are mapped to numbers and back via their indices in the shortlex ordering of all finite character strings .",
    "a proof was sketched in  @xcite that , assuming domain - frequency and pair - fairness , @xmath72 that is , the proportion of wrong answers does not vanish .",
    "however , this leaves open the possibility that for any failure rate @xmath73 , there is a tester that fares better than that for all big enough @xmath11 .",
    "this possibility was ruled out in  @xcite , assuming frequency and pair - fairness .",
    "( it is probably not important that frequency instead of domain - frequency was assumed . )",
    "that is , there is a positive constant such that for any tester , the proportion of wrong answers exceeds the constant for infinitely many sizes of instances :    @xmath74    the third main result in  @xcite , adapted and generalized to the present setting , is the following .",
    "we present its proof to obtain the generalization and to add a detail that the proof in  @xcite lacks , that is , how @xmath75 is made to halt for `` wrong sizes '' .",
    "generic - case testers are not mentioned , because proposition  [ p : gen->gen ] gave a related result for them .",
    "[ t : ksz05 - 3 ] for each programming model and variant e , s , g of the halting problem ,",
    "@xmath76 @xmath77    let @xmath78 .",
    "consider the family @xmath75 of the programs of the following kind , where @xmath79 , @xmath80 , and @xmath81 . if @xmath82 , @xmath75 answers `` no '' in the case of approximating and `` i do nt know '' in the case of three - way testers .",
    "if @xmath83 , @xmath75 simulates all instances of size @xmath11 until @xmath84 of them have halted .",
    "if the simulation stage terminates , then if the given instance is among those that halted , @xmath75 answers `` yes '' , otherwise @xmath75 answers `` no '' or `` i do nt know '' .",
    "thus an approximating @xmath75 has @xmath85 .",
    "we prove next that some @xmath75 is the required tester .",
    "let @xmath86 . then @xmath87 .",
    "when @xmath83 , the simulation stage of @xmath88 terminates and the proportion of hard halting instances of @xmath88 is less than @xmath89 .",
    "some @xmath81 is the @xmath90 for infinitely many values of @xmath11 .",
    "furthermore , there is a smallest such @xmath14 .",
    "we denote it with @xmath91 .",
    "there also is a @xmath92 such that when @xmath83 , then @xmath93 . with these choices",
    ", @xmath94 always halts .    for a small enough @xmath59 and the approximating tester @xmath95 in theorem  [ t : ksz05 - 3 ] ,  ( [ e : ksz05 ] ) implies that the failure rate of @xmath95 oscillates , that is , does not approach any limit as @xmath96 .",
    "this observation is directly obtainable from lemma  23 in  @xcite .      for turing machines with one - way infinite tape and randomly chosen transition function , the probability of falling off the left end of the tape before halting or repeating a state approaches @xmath1 as the number of states grows  @xcite .",
    "the tester simulates the machine until it falls off the left end , halts , or repeats a state .",
    "if falling off the left end is considered as halting , then the proportion of hard instances vanishes as the size of the machine grows .",
    "this can be thought of as yet another example of an anomaly stealing the result .",
    "formally , @xmath97 , that is , @xmath98 here x may be e , s , or g. although e was considered in  @xcite , the proof also applies to s and g. comparing the result to theorem  [ t : itself ] in section  [ s : frequent ] reveals that the representation of programs as transition functions of turing machines is not domain - frequent .    on the other hand , independently of the tape model , the proportion does not vanish exponentially fast  @xcite .",
    "like in  @xcite , the proportion is computed on the transition functions , and not on some textual representations of the programs .",
    "the proof relies on the fact that any turing machine has many obviously similarly behaving copies of bigger and bigger sizes .",
    "they are obtained by adding new states and transitions while keeping the original states and transitions intact .",
    "so the new states and transitions are unreachable .",
    "they are analogous to dead code .",
    "these copies are not common enough to satisfy definition  [ d : frequent ] , but they are common enough to rule out exponentially fast vanishing .",
    "generic - case decidability was used in  @xcite , but the result applies also to three - way testers by proposition  [ p:3way- > ] .",
    "the results in  @xcite are based on using weighted running times . for every positive integer @xmath99 , the proportion of halting programs that do not halt within time",
    "@xmath100 is less than @xmath101 , simply because the proportion of times greater than @xmath100 is less than @xmath101 .",
    "the publication presents such a weighting that @xmath59 is a computable constant .",
    "assume that programs are represented as self - delimiting bit strings on the input tape of a universal turing machine .",
    "the smallest three - way tester of variant e that answers `` yes '' or `` no '' up to size @xmath11 and `` i do nt know '' for bigger programs , is of size @xmath102  @xcite .",
    "the assumption that the programming language is domain - frequent ( definition  [ d : frequent ] ) makes it possible to use a small variation of the standard proof of the non - existence of halting testers , to prove that each halting tester of variant s has a non - vanishing set of hard instances . for three - way and generic - case testers",
    ", one can also say something about whether the hard instances are halting or not . despite its simplicity ,",
    "as far as we know , the following result has not been presented in the literature .",
    "however ,  see the comment on  @xcite in section  [ s : ksz05 ] .",
    "[ t : itself ] if the programming language is domain - frequent , then @xmath103 @xmath104 @xmath105    let the execution of @xmath0 with an input @xmath106 be denoted with @xmath107 . for any @xmath13 , consider the program @xmath108 that first tries its input @xmath109 with @xmath13 .",
    "if @xmath110 replies `` yes '' , then @xmath111 enters an eternal loop .",
    "if @xmath110 replies `` no '' , then @xmath111 halts immediately .",
    "the case that @xmath110 replies `` i do nt know '' is discussed below .",
    "if @xmath110 fails to halt , then @xmath111 can not continue and thus also fails to halt .    by the definition of domain - frequent ,",
    "there are @xmath112 and @xmath113 such that when @xmath114 , at least @xmath115 programs halt on precisely the same inputs as @xmath108 .",
    "let @xmath116 be any such program .",
    "consider @xmath117 .",
    "if @xmath118 answers `` yes '' , then @xmath117 fails to halt",
    ". then also @xmath119 fails to halt .",
    "thus `` yes '' can not be the correct answer for @xmath118 .",
    "a similar reasoning reveals that also `` no '' can not be the correct answer for @xmath118 .",
    "so @xmath116 is a hard instance for @xmath13 .",
    "nothing more is needed to prove the claim for approximating testers . in the case of generic - case testers ,",
    "the hard instances make @xmath13 and thus @xmath108 fail to halt , so they are non - halting instances .    in the case of three - way testers , all hard instances can be made halting instances by making @xmath108 halt when @xmath13 replies `` i do nt know '' .",
    "this proves the claim @xmath120 .",
    "the claim @xmath121 is proven by making @xmath108 enter an eternal loop when @xmath13 replies `` i do nt know '' .",
    "these two proofs may yield different @xmath122 values , but the smaller one of them is suitable for both .",
    "similarly , the bigger of their @xmath123 values is suitable for both .",
    "the second claim of theorem  [ t : itself ] lacks a @xmath34 part .",
    "indeed , proposition  [ p : gen->gen ] says that with generic - case testers , @xmath34 can be made @xmath2 . with approximating testers ,",
    "@xmath34 can be made @xmath2 at the cost of @xmath36 becoming @xmath31 , by always replying `` yes '' .",
    "similarly , @xmath36 can be made @xmath2 by always replying `` no '' .",
    "the next theorem applies to testers of variant e and presents some results similar to theorem  [ t : itself ] . to our knowledge , it is the first theorem of its kind that applies to the halting problem on the empty input .",
    "it assumes not only that many enough equivalent copies exist but also that they can be constructed . on the other hand",
    ", its equivalence only pays attention to the empty input .",
    "[ d : cdf ] a programming language is _ computably empty - frequent _ if and only if there is a decidable equivalence relation `` @xmath124 '' between programs such that    * for each program @xmath65 , there are @xmath67 and @xmath66 such that for every @xmath68 , at least @xmath69 programs of size @xmath11 are equivalent to @xmath65 , and * for each programs @xmath65 and @xmath125 , if @xmath126 , then either both or none of @xmath65 and @xmath125 halt on the empty input .",
    "if @xmath126 , we say that @xmath125 is a _ cousin _ of @xmath65 .",
    "it can be easily seen from  @xcite that  is computably empty - frequent .",
    "[ t : ill - d - r1 ] if the programming language is computably empty - frequent , then @xmath127 the result also holds for generic - case testers but not for approximating testers .    given any three - way tester @xmath13 ,",
    "consider a program @xmath108 that behaves as follows .",
    "first it constructs its own code and stores it in a string variable .",
    "hard - wiring the code of a program inside the program is somewhat tricky , but it is well known that it can be done . with gdel numberings ,",
    "the same can be obtained with kleene s second recursion theorem",
    ".    then @xmath108 starts constructing its cousins of all sizes and tests each of them with @xmath13 . by the assumption ,",
    "there are @xmath112 and @xmath128 such that for every @xmath114 , @xmath108 has at least @xmath129 cousins of size @xmath11 .",
    "if @xmath13 ever replies `` yes '' , then @xmath108 enters an eternal loop and thus does not continue testing its cousins .",
    "if @xmath13 ever replies `` no '' , then @xmath108 halts immediately .",
    "if @xmath13 replies `` i do nt know '' , then @xmath108 tries the next cousin .",
    "if @xmath13 ever replies `` yes '' , then @xmath108 fails to halt on the empty input . by definition ,",
    "also the tested cousin fails to halt on the empty input .",
    "so the answer `` yes '' would be incorrect .",
    "similarly , if @xmath13 ever replies `` no '' , that would be incorrect .",
    "so @xmath13 must reply `` i do nt know '' for all cousins of @xmath108 .",
    "they are thus hard instances for @xmath13 . because there are infinitely many of them ,",
    "@xmath108 does not halt , so they are non - halting .",
    "to prove the result for generic - case testers , it suffices to run the tests of the cousins in parallel , that is , go around a loop where each test that has been started is executed one step and the next test is started .",
    "if any test ever replies `` yes '' or `` no '' , @xmath108 aborts all tests that it has started and then does the opposite of the reply .    a program that always replies `` no '' is an approximating tester with @xmath130 for every @xmath131 .",
    "the results in this section and section  [ s : ksz05 ] motivate the question : are real - life programming languages domain - frequent ?",
    "for instance , is c++ domain - frequent ?",
    "unfortunately , we have not been able to answer it .",
    "we try now to illustrate why it is difficult .    given any c++ program , it is easy to construct many longer programs that behave in precisely the same way , by adding space characters , line feeds ( denoted with @xmath132{->}(2,1.5)(2,.5)(0,.5 ) \\end{pspicture}}$ ] ) , comments , or dead code such as ` if(0!=0)`\\{  }. it is , however , hard to verify that many enough programs are obtained in this way .",
    "for instance , it might seem that many enough programs can be constructed with string literals .",
    "we now provide evidence that suggests ( but does not prove ) that it fails .",
    "any program of size @xmath11 can be converted to @xmath133 identically behaving programs of size @xmath134 by adding \\{`char*s=\\sigma ; ` } to the beginning of some function , where @xmath135{->}(2,1.5)(2,.5)(0,.5 ) \\end{pspicture}}\\})^k$ ] .",
    "( the purpose of \\ { and } is to hide the variable ` s ` , so that it does not collide with any other variable with the same name . )",
    "more programs are obtained by including escape codes such as `  \" ` to @xmath136 .",
    "however , it seems that this is a vanishing instead of at least a positive constant proportion when @xmath137 . in the absence of escape codes",
    ", it certainly is a vanishing proportion .",
    "this is because one can add \\{`char*s=\\sigma,*t=\\rho ; ` } instead , where @xmath138 .",
    "without escape codes , this yields @xmath139 programs . when @xmath137 , @xmath140 .    that is , although string literals can represent information rather densely",
    ", they do not constitute the densest possible way of packing information into a c++ program ( assuming the absence of escape codes ) .",
    "a pair of string literals yields an asymptotically strictly denser packing .",
    "similarly , a triple of string literals is denser still , and so on . counting the programs in the presence of escape codes",
    "is too difficult , but it seems likely that the phenomenon remains the same .",
    "so string literals do not yield many enough programs .",
    "it seems difficult to first find a construct that does yield many enough programs , and then prove that it works .      in this section",
    "we prove a theorem that resembles theorem  [ t : ill - d - r1 ] , but relies on different assumptions and has a different proof .",
    "we say that a three - way tester is _",
    "@xmath11-perfect _ if and only if it does not answer `` i do nt know '' when the size of the instance is at most @xmath11 .",
    "the following lemma is adapted from  @xcite .",
    "[ l : n - o(1 ) ] each programming language has a constant @xmath141 such that the size of each @xmath11-perfect three - way tester of variant e or s is at least @xmath142 .",
    "let @xmath143 be any @xmath11-perfect three - way tester of variant e or s. consider a program @xmath50 that constructs character strings @xmath109 in shortlex order and tests them with @xmath143 until @xmath144 replies `` i do nt know '' .",
    "if @xmath144 replies `` yes '' , @xmath50 simulates @xmath109 before trying the next character string .",
    "when simulating @xmath109 , @xmath50 gives it the empty input in the case of variant e and @xmath109 as the input in the case of s. the reply `` i do nt know '' eventually comes , because otherwise @xmath143 would be a true halting tester .",
    "as a consequence , @xmath50 eventually halts . before halting , @xmath50 simulates at least all halting programs of size at most @xmath11 .",
    "the time consumption of any simulated execution is at least the same as the time consumption of the corresponding genuine execution .",
    "so the execution of @xmath50 can not contain properly a simulated execution of @xmath50 .",
    "@xmath50 does not read any input , so it does not matter whether it is given itself or the empty string as its input .",
    "therefore , the size of @xmath50 is bigger than @xmath11 . because the only part of @xmath50 that depends on @xmath11 is @xmath143 ,",
    "there is a constant @xmath141 such that the size of @xmath143 is at least @xmath142 .    in any everyday programming language",
    ", space characters can be added freely between tokens .",
    "motivated by this , we define that a _ blank character _ is a character that , for any program , can be added to at least one place in the program without affecting the meaning of the program .",
    "[ t : ill - eof ] let x be e or s. if the programming language is end - of - file data segment and has a blank character , then @xmath145    assume first that tester @xmath13 is a counter - example to the @xmath62-claim .",
    "that is , for every @xmath73 , @xmath13 has infinitely many values of @xmath11 such that @xmath146 .",
    "if @xmath13 uses its data segment , let the use be replaced by the use of ordinary constants , liberating the data segment for the use described in the sequel .",
    "let @xmath147 be the following program . here",
    "@xmath99 is a constant inside @xmath147 represented by @xmath148 characters , and @xmath149 is the content of the data segment of @xmath147 interpreted as a natural number @xmath149 in base @xmath43 .",
    "let @xmath51 and @xmath52 be the sizes of the actual program and data segment of @xmath147 .",
    "we have @xmath150 .",
    "let @xmath109 be the input of @xmath147 .",
    "the program @xmath147 first computes @xmath11 : = @xmath151 . if @xmath152 , then @xmath147 adds blank characters to @xmath109 , to make its size @xmath11 .",
    "next , if @xmath153 , then @xmath147 replies `` i do nt know '' and halts",
    ". otherwise @xmath147 gives @xmath109 ( which is now of size precisely @xmath11 ) to @xmath13 .",
    "if @xmath110 replies `` yes ''",
    "or `` no '' , then @xmath147 gives the reply as its own reply and halts .",
    "otherwise @xmath147 constructs each character string @xmath106 of size @xmath11 and tests it with @xmath13 .",
    "@xmath147 simulates in parallel those @xmath106 for which @xmath154 returns `` i do nt know '' until @xmath149 of them have halted ( with @xmath106 or the empty string as the input , as appropriate ) .",
    "then it aborts those that have not halted .",
    "if @xmath109 is among those that halted , then @xmath147 replies `` yes '' , otherwise @xmath147 replies `` no '' .    for each @xmath155",
    ", there are infinitely many values of @xmath11 such that @xmath156 . for any such @xmath11 we have latexmath:[${\\overline h_t}(n ) < p(n)|\\sigma|^{-k } \\leq    representing @xmath34 .",
    "therefore , there is @xmath147 such that @xmath158 and @xmath159 .",
    "it is an @xmath11-perfect three - way tester of size @xmath160 .",
    "a big enough @xmath99 yields a contradiction with lemma  [ l : n - o(1 ) ] .",
    "the proof of the @xmath63-claim is otherwise similar , but @xmath147 counts the number @xmath161 of those @xmath106 for which @xmath154 returns `` i do nt know '' , and simulates the @xmath106 until @xmath162 of them have halted .",
    "the @xmath62-claim and @xmath63-claim are combined into a single claim by choosing the smaller @xmath122 and bigger @xmath123 provided by their proofs .      in this section",
    "we show that if dead information can be added extensively enough , a tester of variant e with an arbitrarily small positive failure rate exists , but the opposite holds for variant s. the reason for the result on variant e is that as the size of the programs grows , a bigger and bigger proportion of programs consists of copies of smaller programs .",
    "this phenomenon is so strong that to obtain the desired failure rate , it suffices to know the empty - input behaviour of all programs up to a sufficient size .",
    "an _ end - of - file dead segment language _ is defined otherwise like end - of - file data segment language ( definition  [ d : eof - data ] ) , but the actual program can not read the data segment .",
    "this is the situation with any self - delimiting real - life programming language , whose compiler stops reading its input when it has read a complete program .",
    "any end - of - file dead segment language is frequent and computationally domain - frequent .",
    "[ t : easy - sd ] for each end - of - file dead segment language , @xmath163 the result also holds with approximating and generic - case testers .",
    "let @xmath164 denote the number of programs whose dead segment is not empty .",
    "we have @xmath165 , so @xmath166 . for each @xmath131 ,",
    "so @xmath168 grows as @xmath11 grows .",
    "these imply that there is @xmath169 such that @xmath170 from below when @xmath96 .    because there are programs , @xmath171 . for every @xmath73 we have @xmath172 , so there is @xmath173 such that @xmath174 . on the other hand , @xmath175 .",
    "these imply @xmath176 . here",
    "@xmath177 is the number of those programs of size @xmath11 whose actual program is of size less than @xmath178 .",
    "the behaviour of a program on the empty input only depends on its actual program .",
    "let @xmath179 be the size of the actual program .",
    "consider a three - way tester that looks the answer from a look - up table if @xmath180 and replies `` i do nt know '' if @xmath181 ( cf.proposition  [ p : finite ] ) .",
    "it has @xmath182 , implying the claim .",
    "proposition  [ p:3way- > ] generalizes the result to approximating and generic - case testers .",
    "the above proof exploited the fact that the correct answer for a long program is the same as the correct answer for a similarly behaving short program .",
    "this does not work for testers of variant s , because the short and long program no longer get the same input , since each one gets itself as its input .",
    "although the program does not have direct access to its dead segment , it gets it via the input .",
    "this changes the situation to the opposite of the previous theorem .",
    "[ t : hard - sd ] for each end - of - file dead segment language , @xmath183 @xmath184[l]{{\\textnormal{generic(s ) } } } : \\forall n_0 \\in \\mathbb{n } : \\exists n \\geq n_0",
    ": \\frac{{\\overline d_t}(n)}{p(n ) } \\geq c\\textrm { , and}\\hspace{13mm}\\ ] ] @xmath184[l]{{\\textnormal{approx(s ) } } } : \\forall n_0 \\in \\mathbb{n } : \\exists n \\geq",
    "n_0 : \\frac{{\\overline h_t}(n)+{\\overline d_t}(n)}{p(n ) } \\geq c\\textrm { .}\\hspace{7mm}\\ ] ]    we prove first the claims on three - way and generic - case testers .",
    "let us recall the overall idea of the proof of theorem  [ t : itself ] .",
    "in that proof , for any tester @xmath13 , a program @xmath108 was constructed that gives its input @xmath109 to @xmath13 .",
    "if @xmath110 replies `` yes '' , then @xmath111 enters an eternal loop .",
    "if @xmath110 replies `` no '' , then @xmath111 halts immediately . to prove that a three - way tester has many hard ( a ) halting ( b ) non - halting instances , in the case of the",
    "`` i do nt know '' reply , @xmath111 was made to ( a ) halt immediately ( b ) enter an eternal loop .",
    "all programs that halt on the same inputs as @xmath108 were shown to be hard instances for @xmath13 . for each @xmath11 that is greater than a threshold that may depend on @xmath13 , the existence of at least @xmath129",
    "such programs was proven , where @xmath122 may depend on @xmath13 but not on @xmath11 .",
    "we now apply the same idea , but , to get a result where the same constant @xmath59 applies to all testers @xmath13 , we no longer construct a separate program @xmath108 for each @xmath13 . instead , we construct a single program @xmath50 , which obtains @xmath13 from the size of the input of @xmath50 .",
    "( a similar idea appears in  @xcite . ) to discuss this , for any @xmath185 , let @xmath186 be the program whose shortlex index is @xmath14 .",
    "let @xmath187 , where @xmath188 is the biggest square number that is at most @xmath14 .",
    "the essence of @xmath189 is that as @xmath14 gets the values @xmath1 , @xmath190 , @xmath191 ,  , @xmath189 gets each value @xmath1 , @xmath190 , @xmath191 ,",
    "  infinitely many times .",
    "one more idea needs to be explained before discussing the details of @xmath50 .",
    "let @xmath16 be partitioned to @xmath192 and @xmath193 of sizes @xmath194 and @xmath195 .",
    "let @xmath179 be the size of the actual program of @xmath50 .",
    "for each @xmath196 , by modifying the dead segment , @xmath197 programs are obtained that have the same actual program as @xmath50 . for @xmath198 ,",
    "let @xmath199 be the set of those of them whose dead segment ends with a character in @xmath200 .",
    "we have @xmath201 . because @xmath202 , by choosing @xmath203 we get @xmath204 .",
    "the program @xmath50 first checks that its input @xmath109 is a program with a non - empty dead segment .",
    "if it is not , then @xmath50 halts immediately .",
    "otherwise , @xmath50 constructs @xmath205 by going through all character strings in the shortlex order until @xmath206 programs have been found .",
    "then @xmath50 constructs every program @xmath106 that has the same size , has the same actual program , and belongs to the same @xmath199 as @xmath109 .",
    "then @xmath50 executes the @xmath207 in parallel until any of the following happens .",
    "if any @xmath207 replies `` yes '' , then @xmath50 enters an eternal loop . if any @xmath207 replies `` no '' , then @xmath50 aborts the remaining @xmath207 and halts .",
    "if every @xmath207 replies `` i do nt know '' , then @xmath50 halts if @xmath208 , and enters an eternal loop if @xmath209 .",
    "if none of the above ever happens , then @xmath50 fails to halt .",
    "recall that @xmath179 is the size of the actual program of @xmath50 . for any tester @xmath13",
    ", there are infinitely many @xmath11 such that @xmath196 and @xmath210 is @xmath13 . for any such @xmath11 , there are @xmath197 programs @xmath116 of size @xmath11 that have the same actual program as @xmath50 .",
    "let @xmath211 be any of them .",
    "the execution of @xmath212 starts @xmath213 for at least @xmath214 distinct @xmath116 .",
    "if @xmath213 replies `` yes '' , then @xmath13 claims that @xmath119 halts . then also @xmath215 halts , because @xmath50 halts on the same inputs as @xmath116 , since they have the same actual program .",
    "furthermore , @xmath212 halts , because @xmath50 only looks at the size , actual program , and @xmath199-class of its input , and @xmath211 and @xmath116 agree on them .",
    "but the halting of @xmath212 is in contradiction with the behaviour of @xmath50 described above .",
    "therefore , no @xmath213 can reply `` yes '' . for a similar reason",
    ", none of them replies `` no '' either .    in conclusion ,",
    "all at least @xmath214 distinct @xmath116 are hard instances for @xmath13 .",
    "if @xmath13 is a three - way tester , it replies `` i do nt know '' for all of them . depending on whether @xmath216 or @xmath217 , they are hard halting or hard non - halting instances",
    ". if @xmath13 is a generic - case tester , it halts on none of these hard instances .",
    "therefore , also @xmath212 and @xmath218 fail to halt .",
    "so they all are hard non - halting instances .    in the case of approximating testers ,",
    "@xmath50 is modified such that it lets all @xmath207 run into completion and counts the `` yes''- and `` no''-replies that they give .",
    "if the majority of the replies are `` no '' , then @xmath50 halts , otherwise @xmath50 enters an eternal loop . for the same reasons as above , @xmath212 halts if and only if @xmath215 halts if and only if @xmath119 halts",
    ". so at least half of the replies are wrong .",
    "finally , we prove a corollary of the above theorem that deals with _ the halting problem itself _ , not with imperfect testers .",
    "imperfect testers are used in the proof of the corollary , but not in the statement of the corollary .",
    "[ l : limit ] let x be any of e , s , and g , and let @xmath219 be any total computable function from natural numbers to integers . if @xmath220 then @xmath221 does not exist .",
    "assume that @xmath222 and @xmath73 .",
    "let @xmath223 .",
    "there is an @xmath224 of the form @xmath225 such that @xmath149 is an integer , @xmath226 when @xmath227 , and @xmath228 .",
    "there also is @xmath229 such that when @xmath230 , then @xmath231 .",
    "a tester @xmath13 that disobeys the formula is obtained as follows .",
    "if @xmath232 , @xmath13 replies `` i do nt know '' .",
    "if @xmath230 , @xmath13 simulates all instances of size @xmath11 until @xmath233 have halted .",
    "if the given instance is among those that halted , then @xmath13 replies `` yes '' and otherwise `` i do nt know '' .",
    "we have @xmath234 .",
    "[ c : nolimit1 ] consider variant s of the halting problem and any end - of - file dead segment language .",
    "then @xmath235 does not exist .",
    "the proof of lemma  [ l : limit ] can be modified to approximating testers with @xmath236 . by  ( [ e : ksz05 ] )",
    ", the limit fails to exist also in the framework of  @xcite .",
    "we first show that among all character strings of size @xmath11 , those that are not c++ programs  that is , those that yield a compile - time error  dominate overwhelmingly , as @xmath11 grows .",
    "in other words , a random character string is not a c++ program except with vanishing probability .",
    "the result may seem obvious until one realizes that a c++ program may contain comments and string literals which may contain almost anything .",
    "we prove the result in a form that also applies to .",
    "c++ is not self - delimiting . after a complete c++ program , there may be , for instance , definitions of new functions that are not used by the program .",
    "this is because a c++ program can be compiled in several units , and the compiler does not check whether the extra functions are needed by another compilation unit .",
    "even so , if @xmath65 is a c++ program , then @xmath237 is definitely not a c++ program and not even a prefix of a c++ program .",
    "similarly , if @xmath65 is a  program , then @xmath238}$ ] is not a prefix of a  program .",
    "[ p : syntax ] if for every @xmath239 there is @xmath240 such that @xmath241 , then @xmath242    let @xmath243 .",
    "obviously @xmath244 .",
    "assume first that for every @xmath245 , there is @xmath246 such that @xmath247 for every @xmath248 . because @xmath249 , we get @xmath250 as @xmath96 .",
    "in the opposite case there is @xmath245 such that @xmath251 for infinitely many values of @xmath11 .",
    "let they be @xmath252 . because @xmath253 is not a prefix of any program , @xmath254 .",
    "for the remaining values of @xmath11 , obviously @xmath255 @xmath256 .",
    "these imply that when @xmath257 , we have latexmath:[$0 \\leq p(n)/|\\sigma|^n \\leq q(n)/|\\sigma|^n \\leq q(n_i ) / |\\sigma|^{n_i } \\leq ( 1 - \\varepsilon /    @xmath96 .",
    "consider a tester @xmath13 that replies `` no '' if the compilation fails and `` i do nt know '' otherwise .",
    "if compile - time error is considered as non - halting , then proposition  [ p : syntax ] implies that @xmath259 , @xmath260 , @xmath261 , and @xmath262 when @xmath96 . as we pointed out in section  [ s : ksz05 ] , this is yet another instance of an anomaly stealing the result .",
    "the model of computation we study in this section is program ",
    "input pairs , where the programs are written in c++ , and the inputs obey the rules stated by the linux operating system .",
    "furthermore , @xmath16 is the set of all 8-bit bytes . to make firm claims about details ,",
    "it is necessary to fix some language and operating system .",
    "the validity of the details below has been checked with c++ and linux .",
    "most likely many other programming languages and operating systems could have been used instead .",
    "there are two deviations from the real everyday programming situation .",
    "first , of course , it must be assumed that unbounded memory is available .",
    "otherwise everything would be decidable .",
    "( however , at any instant of time , only a finite number of bits are in use . )",
    "second , it is assumed that the programs do not contain comments .",
    "this assumption needs a discussion .",
    "comments are information that is inside the program but ignored by the compiler .",
    "they have no effect to the behaviour of the compiled program .",
    "we show next that most long c++ programs consist of a shorter c++ program and one or more comments .",
    "[ l : clc++ ] there are at most @xmath263 comment - less c++ programs of size @xmath11 .    everywhere inside a c++ program excluding comments , it is either the case that ` @ ` or the case that the new line character @xmath132{->}(2,1.5)(2,.5)(0,.5 ) \\end{pspicture}}$ ] can not occur next .",
    "that is , for every character string @xmath18 , either @xmath264 or @xmath265{->}(2,1.5)(2,.5)(0,.5 ) \\end{pspicture}}$ ] is not a prefix of any comment - less c++ program .",
    "( perhaps surprisingly , there indeed are places that are outside comments and where any byte except @xmath132{->}(2,1.5)(2,.5)(0,.5 ) \\end{pspicture}}$ ] can occur . )",
    "[ l : allc++ ] if @xmath266 , then there are at least @xmath267 c++ programs of size @xmath11 .",
    "let @xmath268 , and let @xmath269 .",
    "consider the character strings of the form    ` int main()`\\{`/*\\alpha\\beta*/ ` }    where @xmath18 consists of @xmath270 space characters and @xmath19 is any string of the form @xmath271 , where @xmath272 for @xmath273 .",
    "each such string is a syntactically correct c++ program of size @xmath11 .",
    "their number is @xmath274 .",
    "the proportion of comment - less c++ programs among all c++ programs of size @xmath11 approaches @xmath2 , when @xmath96 .",
    "let @xmath275 . by lemmas  [ l : clc++ ] and  [ l : allc++ ] ,",
    "the proportion is at most + @xmath276 , when @xmath96 .    as a consequence , although comments are irrelevant for the behaviour of programs , they have a significant effect on the distribution of long c++ programs .",
    "to avoid the risk that they cause yet another anomaly stealing the result , we restrict ourselves to c++ programs without comments . this assumption does not restrict the expressive power of the programming language , but reduces the number of superficially different instances of the same program .",
    "the input may be any finite string of bytes .",
    "this is how it is in linux .",
    "although not all such inputs can be given directly via the keyboard , they can be given by directing the so - called standard input to come from a file .",
    "there is a separate test construct in c++ for detecting the end of the input , so the end of the input need not be distinguished by the contents of the input .",
    "there are @xmath277 different inputs of size @xmath11 .",
    "the sizes of a program and input are the number of bytes in the program and the number of bytes in the input file .",
    "this is what linux reports .",
    "the size of an instance is their sum .",
    "analogously to section  [ s : frequent ] , the size of a program is additional information to the concatenation of the program and the input .",
    "this is ignored by our notion of size .",
    "however , the notion is precisely what programmers mean with the word .",
    "furthermore , the convention is similar to the convention in ordinary ( as opposed to self - delimiting ) kolmogorov complexity theory  @xcite .",
    "[ l : pc++ ] with the c++ programming model in section  [ s : c++model ] , @xmath278 , the number of different program ",
    "input pairs of size @xmath11 is at most @xmath279 +      the next theorem says that with halting testers of variant g and comment - less c++ , the proportions of hard halting and hard non - halting instances do not vanish .",
    "[ t : ill - h - c ] with the c++ programming model in section  [ s : c++model ] , @xmath280    we prove first the @xmath281 part and then the @xmath282 part .",
    "the results are combined by picking the bigger @xmath123 and the smaller @xmath122 .",
    "there is a program @xmath108 that behaves as follows .",
    "first , it gets its own size @xmath283 from a constant in its program code . the constant uses some characters and thus affects the size of @xmath108 .",
    "however , the size of a natural number constant @xmath149 is @xmath284 and grows in steps of zero or one as @xmath149 grows .",
    "therefore , by starting with @xmath285 and incrementing it by steps of one , it eventually catches the size of the program , although also the latter may grow .",
    "then @xmath108 reads the input , counting the number of the characters that it gets with @xmath286 and interpreting the string of characters as a natural number @xmath109 in base @xmath43 .",
    "we have @xmath287 , and any natural number in this range is possible .",
    "let @xmath288 .",
    "next @xmath108 constructs every program  input pair of size @xmath11 and tests it with @xmath13 . in this way",
    "@xmath108 gets the number @xmath33 of easy halting pairs of size @xmath11 .",
    "then @xmath108 constructs again every pair of size @xmath11 .",
    "this time it simulates each of them in parallel until @xmath289 of them have halted .",
    "then it aborts the rest and halts .",
    "it halts if and only if @xmath290 .",
    "( it may be helpful to think of @xmath109 as a guess of the number of hard halting pairs . )    among the pairs of size @xmath11 is @xmath108 itself with the string that represents @xmath109 as the input .",
    "we denote it with @xmath291 .",
    "the time consumption of any simulated execution is at least the same as the time consumption of the corresponding genuine execution .",
    "so the execution of @xmath291 can not contain properly a simulated execution of @xmath291 .",
    "therefore , either @xmath291 does not halt , or the simulated execution of @xmath291 is still continuing when @xmath291 halts . in the former case , @xmath292 . in the latter case",
    "@xmath291 is a halting pair but not counted in @xmath293 , so @xmath294 . in both cases , @xmath295 .",
    "as a consequence , no natural number less than @xmath296 is @xmath34 .",
    "so @xmath297 . by lemma",
    "[ l : pc++ ] , @xmath298 .",
    "so for any @xmath299 , we have @xmath300 .",
    "the proof of the @xmath301 part is otherwise similar , except that @xmath108 continues simulation until @xmath302 pairs have halted .",
    "( now @xmath109 is a guess of @xmath36 , yielding a guess of @xmath30 by subtraction . )",
    "the program @xmath108 gets @xmath28 by counting the pairs of size @xmath11 whose program part is compilable .",
    "it turns out that @xmath303 , so @xmath109 can not be @xmath36 , yielding @xmath304 .",
    "next we adapt the second main result in  @xcite to our present setting , with a somewhat simplified proof and obtaining the result also for three - way and generic - case testers .",
    "[ t : indep ] with the c++ programming model in section  [ s : c++model ] , @xmath305 @xmath306[l]{{\\textnormal{generic(g ) } } } : \\forall n_0 \\in \\mathbb{n } : \\exists",
    ": \\frac{{\\overline d_t}(n)}{p(n ) } \\geq c\\textrm { , and}\\hspace{13mm}\\ ] ] @xmath306[l]{{\\textnormal{approx(g ) } } } : \\forall n_0 \\in \\mathbb{n } : \\exists n \\geq",
    "\\frac{{\\overline h_t}(n)+{\\overline d_t}(n)}{p(n ) } \\geq c\\textrm { .}\\hspace{7mm}\\ ] ]    the proof follows the same strategy as the proof of theorem  [ t : hard - sd ] , but differs in some technical details .    to prove the claim for three - way testers , for any character string @xmath18 , let",
    "@xmath307 if @xmath18 is the empty string , and otherwise @xmath308 is the value of the least significant bit of the last character of @xmath18 . for any character strings @xmath18 and @xmath19 , let @xmath309 if and only if @xmath310 and @xmath311 .",
    "for any size @xmath11 greater than @xmath2 , `` @xmath312 '' has two equivalence classes , each containing @xmath313 character strings . for any @xmath185 ,",
    "let @xmath186 be the program whose shortlex index is @xmath14 .",
    "there is a program @xmath50 that behaves as follows .",
    "we denote its execution on input @xmath18 with @xmath314 .",
    "please observe that if @xmath309 , then @xmath315 behaves in the same way as @xmath314 .",
    "first @xmath314 finds the program @xmath316 , where @xmath317 , where @xmath188 is the biggest square number that is at most @xmath14 .",
    "then @xmath314 goes through , in the shortlex order , all @xmath318 , until any of the termination conditions mentioned below occurs or @xmath314 has gone through all of them . for each @xmath19",
    ", it runs @xmath316 on @xmath19 .",
    "we denote this with @xmath319 .",
    "if @xmath319 fails to halt , then @xmath314 never returns from it and thus fails to halt .",
    "if @xmath319 halts replying `` yes '' , then @xmath314 enters an eternal loop , thus failing to halt .",
    "if @xmath319 halts replying `` no '' , then @xmath314 halts immediately .",
    "if @xmath319 halts replying `` i do nt know '' , then @xmath314 tries the next @xmath19 .",
    "it is not important what @xmath314 does if @xmath319 halts replying something else .    if @xmath319 halted replying `` i do nt know '' for every @xmath19 such that @xmath309 , then @xmath314 checks whether @xmath307 .",
    "if yes , then @xmath314 enters an eternal loop , otherwise @xmath314 halts .",
    "now let @xmath320 be any three - way tester that tests whether program @xmath321 halts on the input @xmath322 .",
    "how the two components @xmath321 and @xmath322 of the input of @xmath13 are encoded into one input string is not important .",
    "there is a program that has @xmath50 hard - coded into a string constant , inputs @xmath19 , calls @xmath323 , and gives its reply as its own reply . let @xmath14 be the shortlex index of this program , so the program is @xmath186 .",
    "there are infinitely many positive integers @xmath92 such that @xmath324 .",
    "let @xmath92 be such , and let @xmath18 be any character string of size @xmath92 .",
    "so @xmath316 is @xmath186 .",
    "if , during the execution of @xmath314 , @xmath325 ever replies `` yes '' or `` no '' , then the same happens during the execution of @xmath315 , because @xmath315 behaves in the same way as @xmath314 ( the fact that @xmath325 was called implies @xmath309 ) .",
    "but that would be incorrect by the construction of @xmath50",
    ". therefore , @xmath323 replies `` i do nt know '' for every @xmath19 of size @xmath92 .    as a consequence",
    ", @xmath13 has at least @xmath326 hard instances of size @xmath327 . if @xmath328 , then half of them are halting and the other half non - halting , thanks to the @xmath307 test near the end of @xmath50 . by lemma  [ l : pc++ ] ,",
    "so if @xmath329 , then @xmath330 the program @xmath50 does not depend on @xmath11 , so letting latexmath:[$c = 1/(2     the proof for generic - case testers is otherwise similar , but the @xmath19 are tried in parallel and @xmath323 fails to halt for every @xmath19 of size @xmath92 .",
    "all hard instances are non - halting .",
    "the @xmath50 for approximating testers lets each @xmath319 continue until completion , counts the numbers of the `` yes''- and `` no''-replies they yield , and then does the opposite of the majority of the replies .",
    "application of lemma  [ l : limit ] to this result yields the following .",
    "[ c : nolimit2 ] with the c++ programming model in section  [ s : c++model ] , @xmath332 does not exist .",
    "this study did not cover all combinations of a programming model , variant of the halting problem , and variant of the tester .",
    "so there is a lot of room for future work .",
    "the results highlight what was already known since  @xcite : the programming model has a significant role . with some programming models , a phenomenon of secondary interest dominates the distribution of programs , making hard instances rare .",
    "such phenomena include compile - time errors and falling off the left end of the tape of a turing machine .",
    "many results were derived using the assumption that information can be packed very densely in the program or the input file .",
    "sometimes it was not even necessary to assume that the program could use the information .",
    "it sufficed that the assumption allowed to make many enough similarly behaving longer copies of an original program .",
    "intuition suggests that if the program can access the information , testing halting is harder than in the opposite case .",
    "a comparison of theorem  [ t : easy - sd ] to theorem  [ t : hard - sd ] supports this intuition .",
    "corollaries  [ c : nolimit1 ] and  [ c : nolimit2 ] and the comment after corollary  [ c : nolimit1 ] tell that the proportion of _ all _ ( not just hard ) halting instances has no limit with end - of - file dead segment languages and variant s of the halting problem , with the c++ model and variant g , and in the framework of  @xcite .",
    "it must thus oscillate irregularly as the size of the program grows  irregularly because of lemma  [",
    "l : limit ] .",
    "this is not a property of various notions of imperfect halting testers , but a property of the halting problem itself .",
    "i thank professor keijo ruohonen for helpful discussions , and the anonymous reviewers of splst 13 and acta cybernetica for their helpful comments .",
    "the latter pointed out that proposition  [ p : syntax ] had been formulated incorrectly .",
    "khler , s. , schindelhauer , c. , and ziegler , m. on approximating real - world halting problems . in likiewicz ,",
    "m.  and reischuk , r. , editor , _ proc .",
    "15th fundamentals of computation theory _ , lecture notes in computer science 3623 , pages 454466 , 2005 .",
    "springer .",
    "schindelhauer , c.  and jakoby , a. the non - recursive power of erroneous computation . in pandu",
    "rangan , c. , raman , v. , and ramanujam , r. , editors , _ proc .",
    "19th foundations of software technology and theoretical computer science _ , lecture notes in computer science 1738 , pages 394406 , 1999 .",
    "springer .",
    "valmari , a. sizes of up - to-@xmath11 halting testers . in halava , v. , karhumki ,",
    "j. , and matiyasevich , y. , editors , _ proceedings of the second russian finnish symposium on discrete mathematics _ , tucs lecture notes 17 , pages 176183 , turku , finland , 2012 .      valmari , a. the asymptotic behaviour of the proportion of hard instances of the halting problem . in kiss ,  . ,",
    "editor , _ proceedings of splst 13 , 13th symposium on programming languages and software tools _ , pages 170184 , szeged , hungary , 2013 ."
  ],
  "abstract_text": [
    "<S> although the halting problem is undecidable , imperfect testers that fail on some instances are possible . </S>",
    "<S> such instances are called _ hard _ for the tester . </S>",
    "<S> one variant of imperfect testers replies `` i do nt know '' on hard instances , another variant fails to halt , and yet another replies incorrectly `` yes '' or `` no '' . </S>",
    "<S> also the halting problem has three variants : does a given program halt on the empty input , does a given program halt when given itself as its input , or does a given program halt on a given input . </S>",
    "<S> the failure rate of a tester for some size is the proportion of hard instances among all instances of that size . </S>",
    "<S> this publication investigates the behaviour of the failure rate as the size grows without limit . </S>",
    "<S> earlier results are surveyed and new results are proven . </S>",
    "<S> some of them use c++ on linux as the computational model . </S>",
    "<S> it turns out that the behaviour is sensitive to the details of the programming language or computational model , but in many cases it is possible to prove that the proportion of hard instances does not vanish .    </S>",
    "<S> * keywords : * halting problem , three - way tester , generic - case tester , approximating tester    * acm computing classification system 1998 : * f.1.1 models of computation  computability theory    * mathematics subject classification 2010 : * 68q17 computational difficulty of problems </S>"
  ]
}