{
  "article_text": [
    "the advent of high recording density enabling technologies , pioneered by galloping improvements in head and media design and manufacturing processes , has pushed for similar advances in read channel design and error correction coding , driving research efforts into developing channel - capacity - approaching coding schemes based on soft iterative decoding that are also implementation friendly  @xcite .",
    "soft decodable error correction codes ( ecc ) , mainly low density parity check ( ldpc ) codes , would eventually replace conventional reed - solomon ( rs ) outer ecc , which despite its large minimum distance , possesses a dense parity check matrix that does not lend itself easily to powerful belief propagation ( bp ) decoding .",
    "there exists vast literature on the various design aspects of ldpc coded systems for magnetic recording applications .",
    "this includes code construction  @xcite , efficient encoding  @xcite , decoder optimization  @xcite , and performance evaluation  @xcite . in this work ,",
    "we propose an ldpc coded system optimized for the magnetic recording channel that spans contributions in most of these areas .",
    "the error - pattern correcting code ( epcc ) is proposed in  @xcite motivated by the well - known observation that the error rate at the channel detector output of an isi channel is dominated by a few specific known error cluster patterns .",
    "this is due to the fact that the channel output energies associated with these error patterns are smaller than those of other patterns .",
    "a multiparity cyclic epcc was first described in@xcite , with an rs outer ecc , possessing distinct syndrome sets for all such dominant error patterns . to reduce the code rate penalty , which is a severe snr degradation in recording applications , a method to increase the code rate",
    "was introduced in  @xcite that also improved epcc s algebraic single and multiple error - pattern correction capability . in this method ,",
    "the generator polynomial of the short base epcc is multiplied by a primitive polynomial that is not already a factor of the generator polynomial .",
    "also , the primitive polynomial degree is chosen so as to achieve a certain desired codeword length . moreover",
    ",  @xcite describes a viterbi detection postprocessor that provides error - event - reliability information aiding syndrome - mapping of epcc to improve its correction accuracy .",
    "however , improving the epcc code rate by extending its codeword length increases the probability of multiple dominant error patterns within the codeword , and this requires increasing the size of the syndrome table considerably to maintain the same correction power , which eventually results in prohibitive decoding complexity . to maintain correction power with a manageable size syndrome decoding table",
    ",  @xcite discusses a more efficient method based on a list decoding strategy that delivers satisfactory sector error rate ( ser ) gain with an outer rs ecc .",
    "later , this list decoding scheme was formulated as a soft - input soft - output block in  @xcite and utilized to enhance the performance of turbo equalization based on convolutional codes ( cc ) .",
    "nevertheless , the serial concatenation scheme that proved successful with rs hard decoding and cc - based turbo equalization does not work as well in serial concatenation of long - epcc and ldpc .",
    "the reason is that when the ldpc decoder fails , especially in the water - fall region , the sector contains a large number of multiple error occurrences .",
    "when many such error events occur in a given epcc codeword , decoding by any reasonable size list decoder is formidable .",
    "thus , an inner epcc can not in any capacity reduce the ser of a serially concatenated outer ldpc .",
    "on the other hand , if the epcc codeword length is decreased substantially , then the number of errors per codeword is reasonable , as long as the overall code rate is somehow kept high . here",
    ", the concept of tensor product construction comes into play .    tensor product parity codes ( tppc ) were first proposed in @xcite as the null - space of the parity check matrix resulting from the tensor product of two other parity check matrices corresponding to a variety of code families . as a result , based on the choice of the concatenated codes , tppc would be classified as an error correction code if constructed from two eccs , an error detection code ( edc ) if constructed from two edcs , and an error location code ( elc ) if constructed from an edc and an ecc in a special order . as a matter of fact",
    ", elcs were introduced earlier in @xcite and their algebraic properties studied in detail , but later incorporated in the unified theme of tppcs in @xcite .",
    "furthermore , a generalized class of hard - decodable elcs was later suggested for application in the magnetic recording channel in @xcite .",
    "in addition , tppcs can be generalized by combining a number of codes on various extension fields with shorter binary codes . for this more general case ,",
    "a decoding algorithm was developed in  @xcite .",
    "an ecc - type tppc was applied to longitudinal magnetic recording in  @xcite , and to perpendicular magnetic recording in  @xcite . in  @xcite ,",
    "a hard decodable tensor product code based on a single parity code and a bch code is proposed as an inner code for rs .",
    "this code is suitable for low density longitudinal recording channels for which dominant errors have odd weights , such as @xmath4 and @xmath5 .",
    "also ,  @xcite proposes that the hard decoder passes the corrected parity bits to a viterbi detector reflecting channel states and parity code states in order to compute the decoder output .",
    "later ,  @xcite presented two methods for combining a tensor - product single parity code with a distance - enhancing constrained code .",
    "this code combination achieved more satisfactory performance with rs as an outer code in high density perpendicular recording channels .",
    "our goal in this work is to utilize the concept of tensor product concatenation to construct high rate soft - decodable epccs on the symbol - level of the outer ecc .",
    "the epcc target error list is matched to the dominant error events normally observed in high density perpendicular recording channels .",
    "since dominant error events in perpendicular recording are not only of odd weight  @xcite , this requires that our epcc be a multiparity code .",
    "however , in this case , a viterbi detector matching the channel and parity will have prohibitive complexity . in spite of this",
    ", the performance of the optimal decoder of the baseline parity - coded channel can be approached by the low complexity detection postprocessing technique in  @xcite .",
    "we also present in detail a low complexity highly parallel soft decoder for t - epcc and show that it achieves a better performance - complexity tradeoff compared to conventional iterative decoding schemes .",
    "* for a linear code @xmath6 , @xmath7 denotes the codeword length , @xmath8 denotes the user data length , and @xmath9 denotes the number of code parity bits . * for a certain parity check matrix @xmath10 corresponding to a linear code @xmath11 , a syndrome @xmath12 is the range of a perturbation of a codeword @xmath13 .",
    "a signature refers to the range under @xmath10 for any bit block , not necessarily a codeword formed of data and parity bits .",
    "* the multilevel log - likelihood ratio ( mlllr ) of a random variable @xmath14 corresponding to the p.m.f .",
    "( probability mass function ) @xmath15 , can be defined as : @xmath16 .",
    "* @xmath17_i^j$ ] denotes a local segment @xmath18 $ ] of the sequence @xmath19 . *",
    "the period of a generator polynomial on @xmath20 corresponding to a linear code is equal to the order of that polynomial , as defined in  @xcite . also , for a syndrome set @xmath21 that corresponds to all the @xmath22 possible starting positions of an error event , the period @xmath23 is defined as the smallest integer such that @xmath24  @xcite . *",
    "assume @xmath25 and @xmath26 , then @xmath27 .",
    "define @xmath28 .",
    "also , @xmath29 and @xmath30 are two different representations of the recursive implementation of @xmath31 acting on the elements of the set @xmath32 .",
    "* tppc : tensor product parity code .",
    "* @xmath0ldpc : @xmath0-ary low density parity check code .",
    "* rs : reed solomon code . *",
    "bcjr : bahl - cocke - jelinek - raviv . * t - epcc : tensor product error pattern correction code .",
    "* t - epcc-@xmath0ldpc and t - epcc - rs : tensor product of epcc and @xmath0ldpc or rs , respectively .",
    "* llr : log - likelihood ratio . *",
    "mlllr : multi - level log - likelihood ratio .",
    "* ml : maximum likelihood . *",
    "map : maximum _ a posteriori_. * qc : quasi - cyclic . * spa : sum - product algorithm .",
    "in this section we give a brief review on the concept of epcc , including the design of two example codes that will be utilized later in the simulation study . also , we review the tensor product coding paradigm and present an encoding method that allows for epcc - based linear - time - encodable tppcs .",
    "we review constructing a cyclic code targeting the set of @xmath33 dominant error events @xmath34 represented as polynomials on @xmath20 that can occur at any starting position @xmath8 in a codeword of length @xmath35 .",
    "a syndrome of error type @xmath36 at position @xmath8 is defined as @xmath37 , where @xmath38 is the generator polynomial of the code and @xmath39 is the polynomial modulus operation",
    ".    a syndrome set @xmath40 for error type @xmath36 contains elements corresponding to all cyclic shifts of polynomial @xmath36 ; elements of @xmath40 are thus related by @xmath41 .    for unambiguous decoding of @xmath36 and @xmath42 , @xmath43",
    ", we must have @xmath44 .",
    "this design requirement constrains @xmath38 to have distinct greatest common divisors with @xmath36 , for all targeted @xmath45  @xcite .",
    "however , even if this constraint is satisfied , an element in @xmath40 can still map to more than one error position , i.e. , the period of the syndrome set- and period of @xmath38- can be less than @xmath46 .",
    "moreover , this constraint is only sufficient but not necessary . as shown in  @xcite",
    ", there may exist a lower degree @xmath38 that can yield distinct syndrome sets for the targeted error polynomials , resulting in a higher rate epcc . a search method to find this @xmath38",
    "is already discussed in detail in  @xcite and  @xcite .",
    "we next give two example epcc constructions that will be used throughout the paper .",
    "we target the dominant error events of the  ideal \" equalized monic channel @xmath47 in awgn , which is suitable as a partial response target in perpendicular magnetic recording read channels . for this channel ,",
    "the dominant errors are given by : @xmath48 , @xmath49 , @xmath50 , etc .",
    ", i.e. they can be represented as polynomials on @xmath20 for which all powers of @xmath51 have nonzero coefficients .",
    "the two epccs are :    * _ example 1 _ : targeting error polynomials up to degree @xmath52 , we get the generator polynomial @xmath53 of period @xmath54 via the search procedure of  @xcite . choosing a codeword length of @xmath54 , @xmath55 distinct ,",
    "non - overlapping syndrome sets are utilized to distinguish the @xmath55 target errors . then , syndrome set @xmath56 will have period @xmath57 , while all other sets have period @xmath54 .",
    "a syndrome set of period @xmath57 means that each syndrome decodes to one of @xmath58 possible error positions within the @xmath54-bit codeword .",
    "nonetheless , @xmath59 can be decoded reliably via channel reliability information and the polarity of data support .",
    "the low code rate of @xmath60 makes this code unattractive as an inner code in a serial concatenation setup for recording channel applications .",
    "however , as we will see later , a tensor code setup makes it practical to use such powerful codes for recording applications . * _ example 2 _ : targeting error polynomials up to degree @xmath61 , we have to record more redundancy . to accomplish this feat ,",
    "a cyclic code with @xmath62 parity bits , code rate @xmath63 , and a generator polynomial @xmath64 of period @xmath65 is found by the search procedure in  @xcite .",
    "then , syndrome sets @xmath66 , @xmath56 , @xmath67 , and @xmath68 each have period @xmath65 and thus can be decoded without ambiguity .",
    "while syndrome sets @xmath69 , @xmath70 , @xmath71 , @xmath72 , and @xmath73 each have period @xmath61 , decoding to one of two positions .",
    "the worst is @xmath74 of period @xmath58 , which would decode to one of @xmath61 possible positions .",
    "still , the algebraic decoder can quickly shrink this number to few positions by checking the data support , and then would choose the one position with highest local reliability .",
    "consider a binary linear code @xmath75 derived from the null space of parity check matrix @xmath76 , and assume @xmath77 corrects any error event that belongs to class @xmath78 . also , consider a non - binary linear code @xmath79 derived from the null space of parity check matrix @xmath80 and defined over elements of @xmath81 .",
    "moreover , assume this code corrects any symbol error type that belongs to class @xmath82 . as a preliminary step ,",
    "convert the binary @xmath83 matrix @xmath76 , column by column , into a string of @xmath81 elements of dimension @xmath84 .",
    "then , construct the matrix @xmath85 as a @xmath86 array of @xmath81 elements .",
    "finally , convert the elements of @xmath87 into @xmath88-bit columns , based on the same primitive polynomial of degree @xmath88 used all over in the construction method .",
    "the null space of the @xmath89 binary @xmath87 corresponds to a linear binary code @xmath90 . as shown in fig .",
    "[ tppccodeword ] , a @xmath91 codeword is composed of @xmath92 blocks termed  tensor - symbols \" , each having @xmath93 bits . also , it can be shown that @xmath91 can correct any collection of tensor symbol errors belonging to class @xmath82 , provided that all errors within each tensor symbol belong to class @xmath78  @xcite .",
    "note that a tensor symbol is not an actual @xmath77 codeword , and as such , using the terms  inner \" and  outer \" codes would not be completely accurate .",
    "in addition , the tensor symbols are not codewords themselves , as can be seen in fig .",
    "[ tppccodeword ] , the first @xmath94 tensor symbols are all data bits to start with , and even the last @xmath95 tensor symbols , which are composed of data and parity bits , have non - zero syndromes under @xmath76 .",
    "thus , a tppc codeword does not correspond directly to either @xmath76 or @xmath80 , and as a result , the component codebooks they describe are not recorded directly on the channel .",
    "another interesting property of the resulting tppc is that the symbol - mapping of the sequence of tensor - symbol signatures under @xmath76 forms a codeword of @xmath96 , which we refer to as the  signature - correcting component code \" .",
    "the encoding of a tppc can be performed using its binary parity check matrix , but the corresponding binary generator matrix is not guaranteed to possess algebraic properties that enable linear time encodability .",
    "thus , an implementation - friendly approach would be to utilize the encoders of the constituent codes , which can be chosen to be linear time encodable .",
    "consider a binary code @xmath75 that is the null space of parity check matrix @xmath76 , and a non - binary code @xmath97 defined on @xmath81 , the tensor - product concatenation is a binary @xmath98 , where : @xmath99 assume that @xmath77 is a cyclic code , and @xmath96 is any of the linear time encodable codes , where we choose a quasi - cyclic ( qc ) component code for the purpose of this study .",
    "then , the encoders of @xmath77 and @xmath96 communicate via the following algorithm to generate a codeword of @xmath91 , see fig .",
    "[ tppcencoder ] :    1 .",
    "receive a block of @xmath100 bits from the data source , call it major block @xmath101 .",
    "2 .   divide major block @xmath101 into minor block @xmath102 of @xmath103 bits , and minor block @xmath104 of @xmath105 bits ( i.e. @xmath106 bits ) .",
    "3 .   divide block @xmath102 into @xmath94 columns each of @xmath93 bits .",
    "then , for each column , calculate the intermediate @xmath88-bit signature under the parity check matrix of @xmath77 . using a feedback shift register ( fsr ) to calculate the signatures ,",
    "the computational cost is @xmath107 operations per signature , and @xmath108 for this entire step .",
    "4 .   convert intermediate signatures from @xmath88-bit strings into @xmath81 symbols .",
    "5 .   encode the @xmath94 non - binary signatures into a @xmath96 codeword of length @xmath92 . using fsrs to encode the quasi - cyclic @xmath96",
    ", the computational complexity of this step is @xmath109 .",
    "[ step6 ] convert computed signatures back into @xmath88-bit strings . 7",
    "divide block @xmath104 into @xmath95 columns each of @xmath110 bits . add @xmath88 blanks in each column to be filled with the parity bits of @xmath91 . then",
    ", align each column with the @xmath95 signatures computed in the previous step , leaving @xmath88 blanks in each column .",
    "fill blanks in the previous step such that the signature of data plus parity blanks under @xmath77 equals the corresponding aligned signature from step ( vi ) .",
    "the parity can be calculated using the systematic @xmath76 and the method of back substitution which requires a computational complexity @xmath107 per column .",
    "the total computational complexity of this encoding algorithm is @xmath111 , i.e. it is @xmath112 , which is the tppc codeword length .",
    "thus , we have shown- with some constraints- that if @xmath77 and @xmath96 are linear time encodable , then @xmath113 is linear time encodable .",
    "to demonstrate the algebraic properties of tppc codes , we present an example code suitable for recording applications with @xmath1 kb sector size . consider two component codes :    * a binary cyclic @xmath114 epcc of example 2 above with rate @xmath115 , @xmath62 parity bits , and parity check matrix in @xmath116 : @xmath117_{1 \\times 18}.   \\\\",
    "\\end{array}}\\ ] ] * a @xmath118 rs over @xmath116 , of rate @xmath119 , @xmath120 , and @xmath121 parity symbols .",
    "the resulting tppc is a binary @xmath122 code , of rate @xmath123 , and redundancy of @xmath124 parity bits . for this code ,",
    "a codeword is made of @xmath125 @xmath65-bit tensor symbols , of which , any combination of @xmath126 or less tensor symbol errors are correctable , provided that each @xmath65-bit tensor symbol has a single or multiple occurrence of a dominant error that is correctable by epcc , those being combinations of error polynomials up to degree @xmath61 .",
    "furthermore , although the epcc constituent code has a very low rate of @xmath115 , the resulting t - epcc has a high rate of @xmath127 .",
    "notably , in the view of the @xmath65-bit epcc , this @xmath128 reduction in recorded redundancy corresponds to an snr improvement of @xmath58 db in a channel with rate penalty @xmath129 , and @xmath130 db in a channel with rate penalty @xmath131 .",
    "hard decoding of t - epcc - rs directly reflects the code s algebraic properties , and thus , serves to further clarify the concept of tensor product codes .",
    "hence , we discuss the hard decoding approach before going into the design of soft decoding of t - epcc codes .",
    "the decoding algorithm is summarized by the following procedure , see fig .",
    "[ harddecoder ] :    1 .",
    "after hard slicing the output of the viterbi channel detector , the signature of each tensor symbol is calculated under @xmath132 .",
    "each signature is then mapped into a galois field symbol , where the sequence of non - binary signatures constitute an rs codeword - that is if the channel detector did not suffer any errors",
    "any hard - input rs decoder , such as the berlekamp - massey decoder , acts to find a legitimate rs codeword based on the observed signature - sequence .",
    "if the number of signature - symbols in error is larger than the rs correction power , rs decoding fails and the tensor product decoder halts .",
    "4 .   otherwise ,",
    "if rs decoding is deemed successful , the corrected signature - symbol sequence is added to the original observed signature - symbol sequence to generate the  error syndrome - symbol \" sequence .",
    "each error syndrome - symbol is mapped into an epcc bit - syndrome of the corresponding tensor symbol .",
    "6 .   finally , epcc decodes each tensor symbol to satisfy the error - syndrome generated by the component rs , in which it faces two scenarios : * a zero  error - syndrome \" at the output of rs decoding indicates either no error occurred or a multiple error occurrence that has a zero epcc - syndrome , which goes undetected . in this case",
    ", the epcc decoder is turned off to save power . * a non zero  error - syndrome",
    "\" will turn epcc correction on .",
    "if the error - syndrome indicates a single error occurrence in the target set , then , the epcc single error algebraic decoder is turned on . on the other hand ,",
    "if the error - syndrome is not recognized , then epcc list decoding is turned on with a reasonable - size list of test words . + note",
    "that although the number of epcc codewords ( tensor symbols ) is huge , the decoder complexity is reasonable since epcc decoding is turned on only for nonzero error - syndromes .",
    "we learned from the design of t - epcc - rs that the component signature - correcting codeword length can be substantially shorter than the competing single level code .",
    "although the minimum distance is bound to be hurt if the increased redundancy does not compensate for the shorter codeword length , employing iterative soft decoding of the component signature - correcting code can recover performance if designed properly . while ldpc codes have",
    "strictly lower minimum distances compared to comparable rate and code length rs codes , the sparsity of its parity check matrix allows for effective belief propagation ( bp ) decoding .",
    "bp decoding of ldpc codes consistently performs better than the best known soft decoding algorithm for rs codes .",
    "since the tppc expansion enables the use of @xmath58 to @xmath52 times shorter component ldpc compared to a competing single level ldpc , a class of ldpc codes efficient at such short lengths are critical .",
    "ldpc codes on high order fields represent such good candidates . in that respect ,",
    "@xcite showed that the performance of binary ldpc codes in awgn can be significantly enhanced by a move to fields of higher orders ( extensions of @xmath20 being an example ) .",
    "moreover ,  @xcite established that for a monotonic improvement in waterfall performance with field order , the parity check matrix for very short blocks has to be very sparse .",
    "specifically , column weight @xmath133 codes over @xmath134 exhibit worse bit - error - rate ( ber ) as @xmath0 increases , whereas column weight @xmath58 codes over @xmath134 exhibit monotonically lower ber as @xmath0 increases . these results were later confirmed in  @xcite , where they also showed through a density evolution study of large @xmath0 codes that optimum degree sequences favor a regular graph of degree @xmath58 in all symbol nodes . on the other hand , for satisfactory error floor performance , we found that using a column weight higher than @xmath58 was necessary .",
    "this becomes more important as the minimum distance decreases for lower @xmath0 .",
    "for instance , we found that a column weight of @xmath133 improved the error floor behavior of @xmath135-ldpc at the expense of performance degradation in the waterfall region .      the low rate and relatively low column weight design of @xmath0ldpc in a tppc results in a very sparse parity check matrix , allowing the usage of high girth component @xmath0ldpc codes .",
    "to optimize the girth for a given rate , we employ the progressive edge growth ( peg ) algorithm  @xcite in @xmath0ldpc code design .",
    "peg optimizes the placement of a new edge connecting a particular symbol node to a check node on the tanner graph , such that the largest possible local girth is achieved .",
    "furthermore , peg construction is very flexible , allowing arbitrary code rates , galois field sizes , and column weights .",
    "in addition , modified peg - construction with linear - time encoding can be achieved without noticeable performance degradation , facilitating the design of linear time encodable tensor product codes .",
    "of the two approaches to achieve linear time encodability , namely , the upper triangular parity check matrix construction  @xcite and peg construction with a qc constraint  @xcite , we choose the latter approach , for which the designed codes have better error floor behavior .",
    "t - epcc-@xmath0ldpc lends itself to iterative soft decoding quite naturally .",
    "next , we present a low complexity soft decoder utilizing this important feature .          to fully utilize the power of the component codes in t - epcc-@xmath0ldpc , we need to develop a soft iterative version of the hard decoder of t - epcc - rs . to limit the complexity of the proposed soft decoder ,",
    "sub - optimal detection post - processing is adopted instead of the maximum _ a posteriori _ ( map ) detector to evaluate tensor symbol signature reliabilities .",
    "the complexity of the optimal map detector matched to both the channel of memory length @xmath22 and @xmath132 of row length @xmath136 is exponential in @xmath137 .",
    "we present a practical soft detection scheme that separates soft channel detection from tensor symbol signature detection , though , through a component signature - correcting ldpc in a tppc setup , approaches the joint map performance through channel iterations .",
    "the main stages of the decoder are , see fig .",
    "[ softdec ] :    1 .   * detection postprocessing * : * utilizing _ a priori _ information from the previous decoding iteration , binary viterbi generates the hard ml word based on channel observations , for which the error sequence is calculated and passed to the correlator bank . * a bank of local correlators estimates the probability of dominant error type / location pairs for all positions inside each tensor symbol .",
    "* signature p.m.f .",
    "calculation * : * for each tensor symbol , the list of most likely error patterns is constructed .",
    "this list includes single occurrences and a predetermined set of their combinations .",
    "the list is then divided into sublists , each under the signature value it satisfies .",
    "* for each tensor symbol , using each signature value s error likelihood list , we find the signature p.m.f .",
    "of that symbol .",
    "* @xmath0-ary ldpc decoding * : * using the observed sequence of signature p.m.f.s , we decode the component @xmath0-ary ldpc via fft - based spa . * for each tensor symbol , the ldpc - corrected signature p.m.f .",
    "is convolved with the observed signature p.m.f . at its input to generate the error - syndrome p.m.f .. 4 .   * epcc decoding * : * for each tensor symbol , we find the list of most probable error - syndromes and generate a list of test error words to satisfy each syndrome in the list .",
    "* a bank of parallel epcc single - error correcting decoders generates a list of most probable codewords along with their reliabilities .",
    "bit - llr feedback * : * using the codeword reliabilities we generate bit - level reliabilities that are fed back to the viterbi detector and the detection postprocessing stage .",
    "those bit - level reliabilities , serving as _ a priori _ information , favor paths which satisfy both the isi and parity constraints .",
    "we explain each of these steps in the following sections , but we replace any occurrence in the text of syndrome ( signature ) p.m.f . by syndrome ( signature ) multi - level log - likelihood ratios ( mlllr ) , as decoding will be entirely in the log domain for reasons explained below .          at this decoder stage",
    "we prepare a reliability matrix @xmath138 for error type / position pairs - captured in a tensor symbol of length @xmath35- that is usable by the next stage to calculate the tensor symbol s signature mlllr : @xmath139       \\\\ \\end{array }   & & \\end{aligned}\\ ] ] where @xmath140 is the error pattern ( type @xmath45/ position @xmath8 ) reliability measure computed by the maximum _ a posteriori _",
    "( map)-based error - pattern correlator shown in fig .",
    "[ fig : correlator ] .",
    "the bank of local correlators discussed here was also employed in  @xcite for awgn channels , and in  @xcite for data - dependent noise environments .",
    "we now discuss how to generate these local metrics .",
    "let @xmath141 be the channel detector input sequence @xmath142 , where @xmath143 is the bipolar representation of the recorded codeword sequence , @xmath144 is the partial response channel of length @xmath145 , and @xmath146 is zero - mean awgn noise with variance @xmath147 .",
    "also , let @xmath148 be the channel detector s output error sequence .",
    "if a target error pattern sequence @xmath149 occurs at positions from @xmath150 to @xmath151 , then @xmath152 can be written as @xmath153_j^{j+l_i-1}*h_k + w_k\\\\       & = [ \\textbf{e}^{(i)}]_j^{j+l_i-1}*h_k + w_k \\\\       & = [ \\textbf{s}^{(i)}]_j^{j+l_i^h } + w_k   \\end{split }   \\end{aligned}\\ ] ] where @xmath154 is the channel response of the error sequence , and is given by @xmath155 , and @xmath156 .",
    "note that we define the start of the tensor symbol at @xmath157 .",
    "so , if @xmath158 , then the error pattern starting position is in a preceding tensor symbol .    the reliability for each error pattern with starting position , @xmath159 , can be computed by the local _ a posteriori _ probabilities ( ignoring tensor symbol boundaries for now ) : @xmath160_j^{j+l_i-1 } } \\right|[\\textbf{r}]_j^{j + l_i^h } , [ { \\bf{\\hat c}}]_{j - l_h   + 1}^{j + l_i^h } } \\right ) & & \\\\   = \\pr \\left ( { \\left . {",
    "[ \\textbf{s}^{(i)}]_j^{j + l_i^h } } \\right|[\\textbf{q}]_j^{j + l_i^h } , [ { \\bf{\\hat c}}]_{j - l_h   + 1}^{j + l_i^h } } \\right ) . & & \\end{aligned}\\ ] ] the most likely assumed error type / position pair in a tensor symbol maximizes the _ a posteriori _ probability ratio of its reliability to the reliability of the most probable error event ( the competing event in this case would be the ml word itself , with no error occurrence assumed at the output of viterbi detection ) .",
    "hence , utilizing ( [ eq : postp ] ) and bayes rule , the ratio to maximize becomes @xmath161_j^{j + l_i^h } } \\right)}}{{\\pr \\left ( { \\left . { \\left [ { { \\rm{\\textbf{ml word } } } } \\right]_j^{j+l_i-1 } } \\right|{\\bf{\\hat c}},[\\textbf{q}]_j^{j + l_i^h } } \\right ) } } = \\\\ \\displaystyle \\frac{{\\pr \\left ( { \\left . { [ { \\bf{q}}]_j^{j + l_i^h } } \\right|[{\\bf{\\hat c}}]_{j - l_h   + 1}^{j + l_i^h } , [ { \\bf{s}}^{(i ) } ] _ j^{j + l_i^h } } \\right)\\pr \\left ( { [ { \\bf{s}}^{(i ) } ] _ j^{j + l_i^h } } \\right)}}{{\\pr \\left ( { \\left . { [ { \\bf{q}}]_j^{j + l_i^h } } \\right|[{\\bf{\\hat c}}]_{j - l_h   + 1}^{j + l_i^h } , [ { \\bf{\\tilde s}}^{(i ) } ] _ j^{j + l_i^h } } \\right)\\pr \\left ( { [ { \\bf{\\tilde s}}^{(i ) } ] _ j^{j + l_i^h } } \\right ) } }   \\end{array}\\end{aligned}\\ ] ] where @xmath162_j^{j + l_i^h}$ ] is the ml word s noiseless channel response . given the noise model , @xmath163_j^{j + l_i^h } $ ] is a sequence of independent gaussian random variables with variance @xmath147 .",
    "therefore , maximizing ( [ eq : ratio ] ) can be shown to be equivalent to maximizing the log - likelihood local measure  @xcite : @xmath164_j^{j + l_i^h } ) } } { { \\pr ( [ { \\bf{s}}^{(i ) } ] _",
    "j^{j + l_i^h } ) } } \\ ] ] where the _ a priori _ bias in ( [ eq : nobound ] ) is evaluated as : @xmath165_j^{j + l_i^h } ) } } { { \\pr([{\\bf{s}}^{(i ) } ] _",
    "j^{j + l_i^h } ) } } = \\sum\\limits_{k = j,\\hat c_k =   + 1}^{j + l_i^h } { \\lambda _ k }   - \\sum\\limits_{k = j,\\hat c_k =   - 1}^{j + l_i^h } { \\lambda _ k } \\ ] ] where @xmath166 is the _ a priori _ llr of the error - event bit at position @xmath8 as received from the outer soft decoder , and we are assuming here that error event sequences do not include @xmath167 bits , i.e. , the ml sequence and error sequence do not agree for the entire duration of the error event .",
    "equation ( [ eq : nobound ] ) represents the ",
    "local \" error - pattern correlator output in the sense that it essentially describes the correlator operation between @xmath152 and the channel output version of the dominant error pattern @xmath168 within the local region @xmath169 $ ] .",
    "however , equation ( [ eq : nobound ] ) ignores that errors can span tensor symbol boundaries when @xmath158 or @xmath170 .",
    "for instance , an error in the first bit of the tensor symbol can result from a single error event in that bit , a double error event in the last bit of the preceding tensor symbol , a triple error event occurring two bits into the previous symbol , and so on .",
    "hence , the probability of an error in the first bit is the sum of all these parent error event probabilities .",
    "moreover , this can be easily generalized to boundary errors extending beyond the first bit . in a similar manner",
    ", an error in the last bit of a tensor symbol can result from a single error event in that bit , a double error event starting in that bit and continuing into the next tensor symbol , a triple error starting at the last bit and continuing into the next tensor symbol , and so on .",
    "again , the probability of an error event in that bit is the sum of the probabilities of all these parent events .",
    "moreover , we have to nullify the probability of the parent error events in the modified reliability matrix since they are already accounted for in the last bit s reliability calculation .",
    "furthermore , this can also be generalized to error events starting earlier than the last bit and extending into the next tensor symbol . in summary , to calculate a modified metric relevant to the current tensor symbol , we utilize the following procedure :    * @xmath171 at @xmath157 , modify @xmath172 @xmath173 independently for each @xmath45 , where @xmath33 is the maximum length of a targeted error pattern . * starting at @xmath174 and @xmath175 , do : 1 .",
    "@xmath177 , set @xmath178 .",
    "3 .   set @xmath179 , @xmath180 .",
    "4 .   if @xmath181 go back to ( i ) .",
    "we assume here that dominant error events span only two tensor symbols at a time and that they do not include error free gaps , which is certainly true for the case study of this paper . following this procedure",
    "we obtain the modified reliability matrix @xmath182 .      for each tensor symbol @xmath45 ,",
    "utilizing @xmath183 , we need to find the p.m.f . or the log domain mlllr of its signature @xmath184 , for epcc with @xmath185 parity bits .",
    "to limit the computational complexity of this calculation , we construct a signature only from the dominant errors and a subset of their multiple occurrences .",
    "denote @xmath186 as the running estimate of the p.m.f . at @xmath187 , and @xmath188 as the running estimate of mlllr .",
    "denote a one dimensional index of @xmath182 as @xmath189 corresponding to the @xmath190__-th _ _ row and @xmath191__-th _ _ column of @xmath182 and error @xmath192 .",
    "we choose the dominant list as the @xmath22 patterns with the largest corresponding elements of @xmath193 having indexes @xmath194 .",
    "based on this list , we developed the following procedure to compute @xmath195 :    * step @xmath3 ( single occurrences ) : @xmath196^t ) =     \\alpha^{j-1 } & & \\\\\\end{aligned}\\ ] ] where @xmath197 , and @xmath198 is an operator that maps @xmath185-bit vectors into @xmath199 symbols .",
    "* step @xmath58 ( double occurrences ) : @xmath200^t ) = \\alpha^{j-1 } \\\\\\end{aligned}\\ ] ] where @xmath201 is the error free distance between the two errors , @xmath202 is the error free distance of the channel beyond which the errors are independent . * ... * step @xmath203 ( @xmath203 occurrences ) : @xmath204^t ) = \\alpha^{j-1 } \\\\\\end{aligned}\\ ] ] * step @xmath205 ( ml - signature reliability ; computed so that the resulting signature p.m.f . sums to @xmath3 ) : @xmath206 @xmath207 @xmath208 * step @xmath209 ( normalization ) : @xmath210    in steps @xmath3 through @xmath203 , to calculate the log - likelihood of signature @xmath45 assuming value @xmath187 , we sum the probabilities of all presumed single and multiple errors in the ml word whose signatures equal @xmath187 .",
    "this is equivalent to performing the @xmath31 operation in the log domain on error reliabilities dictated by @xmath182 .",
    "however , to limit the complexity of this stage , we only use a truncated set of possible error combinations , in all steps from @xmath3 to @xmath203 . also , for signature values that do not correspond to any of the combinations , we set their reliability to @xmath211 , or more precisely , a reasonably large negative value in practical decoder implementation .",
    "since there are many such signature values , the corresponding constructed p.m.f . will be sparse .    in step @xmath205 , the likelihood of the ml signature value is computed so that the p.m.f .",
    "of the tensor symbol signature sums to @xmath3 . in this step ,",
    "the @xmath31 operation in ( [ eq : sgml ] ) is a reflection of the fact that in previous steps , @xmath3 through @xmath203 , some multiple error occurrences have the same signature as the ml tensor symbol value .",
    "so , we have to account for such error instances in the running estimate of the ml signature reliability .",
    "these events correspond to cases where error events are not detectable by @xmath132 , i.e. , they belong to the null space of @xmath132 . in step @xmath209 ,",
    "the mlllr of the tensor symbol is centered around @xmath212 to prevent the @xmath0ldpc spa messages from saturating after a few bp iterations .",
    "now , the sequence of signature mlllrs is passed as multi - level channel observations to the @xmath0ldpc decoder .",
    "we choose to implement the log - domain @xmath0-ary fast fourier transform - based spa ( fft - spa ) decoder in  @xcite for this purpose .",
    "the choice of log - domain decoding is essential , since if we use the signature p.m.f . as input",
    ", the spa would run into numerical instability resulting from the sparse p.m.f .",
    "generated by the preceding stage .    the ldpc output _",
    "mlllrs correspond to the signatures of tensor symbols , rather than the syndromes of errors expected by epcc decoding . similar to the decoder of t - epcc - rs , error - syndrome @xmath213 is the finite field sum of the ldpc s input channel observation of signature @xmath45 , @xmath214 , and output _ posteriori _",
    "signature reliability , @xmath215 .",
    "moreover , the addition of hard signatures corresponds to the convolution of their p.m.f.s , and this convolution in probability domain corresponds to the following operation in log - domain : @xmath216 the error - syndrome mlllr is later normalized , similar to ldpc bp mlllr message normalization , according to : @xmath217      an error - syndrome will decode to many possible error events due to the low minimum distance of single - error correcting epcc . however , epcc relies on local channel side information to implement a list - decoding - like procedure that enhances its multiple error correction capability .",
    "moreover , the short codeword length of epcc reduces the probability of such multiple error occurrences considerably . to minimize power consumption ,",
    "epcc is turned on for a tensor symbol @xmath45 only if the most likely value of the error - syndrome mlllr is nonzero , i.e. , @xmath218 , indicating that a resolvable error has occurred .",
    "after this , a few syndrome values , @xmath133 in our case , most likely according to the mlllr , are decoded in parallel . for each of these syndromes ,",
    "the list decoding algorithm goes as  @xcite :    * a test error word list is generated by inserting the most probable combination of local error patterns into the ml tensor symbol . *",
    "an array of parallel epcc single - pattern correcting decoders decodes the test words to produce a list of valid codewords that satisfy the current error - syndrome . *",
    "the probability of a candidate codeword is computed as the sum of likelihoods of its parent test - word and the error pattern separating the two . * each candidate codeword probability is biased by the likelihood of the error - syndrome it is supposed to satisfy .",
    "in addition , when generating test words , we only combine independent error patterns that are separated by the error free distance of the isi channel .",
    "the list of candidate codewords and probabilities are used to generate bit level - probabilities in a similar manner to  @xcite .",
    "the conversion of word - level reliability into bit - level reliability for a given bit position can be done by grouping the candidate codewords into two groups , according to the binary value of the hard decision bit in that bit position , and then performing group - wise summing of the word - level probabilities .",
    "three scenarios are possible for this calculation :    1",
    ".   the candidate codewords do not all agree on the bit decision for location @xmath8 ; then , given the list of codewords and their accompanying _ a posteriori _ probabilities , the reliability @xmath166 of the coded bit @xmath219 is evaluated as @xmath220 where @xmath221 is the set of candidate codewords where @xmath222 , and @xmath223 is the set of candidate codewords where @xmath224 2 .",
    "although rare for such short codeword lengths , in the event that all codewords do agree on the decision for @xmath219 , a method inspired by  @xcite is adopted for generating soft information as follows @xmath225 where @xmath226 is the bipolar representation of the agreed - upon decision , @xmath227 is a preset value for the maximum reliability at convergence of turbo performance , and the multiplier @xmath228 is a scaling factor .",
    "@xmath229 in the first global iterations and is increased to @xmath3 as more global iterations are performed and the confidence in bit decisions improved .",
    "thus , this back - off control process reduces the risk of error propagation .",
    "3 .   the heuristic scaling in ( [ eq:4 ] ) is again useful when epcc is turned off for a tensor symbol , in case the most likely error - syndrome being @xmath167 .",
    "then , the base hard value of the tensor symbol corresponds to the most likely error event found as a side product in stage @xmath58 of the t - epcc-@xmath0ldpc decoder .      due to the ambiguity in mapping tensor symbols to signatures and syndromes to errors in stages @xmath58 and @xmath52 of the decoder , respectively , the possibility of non - targeted error patterns , or errors that have zero error - syndromes that are transparent to @xmath132 , a second line of defense is essential to take care of undetected errors .",
    "therefore , an outer rs code of small correction power @xmath230 is concatenated to t - epcc-@xmath0ldpc to take care of the imperfections of the component epcc .",
    "several concurrent functions are offered by this code , including :    * _ stopping flag _ : if the rs syndrome is zero , then , global iterations are halted and decisions are released . * _ outer ecc _ : attempt to correct residual errors at the output of epcc after each global iteration . * _ erasure decoding _ : if the rs syndrome is nonzero , then , for those tensor symbols that epcc was turned on , declare their bits as erasures .",
    "next , find the corresponding rs symbol erasures , and attempt rs erasure decoding which is capable of correcting up to @xmath231 such erasures . in this case ,",
    "t - epcc acts as an error locating code .",
    "we compare three coding systems based on ldpc : conventional binary ldpc , @xmath0-ary ldpc , and t - epcc-@xmath0ldpc , where all the component ldpc codes are regular and constructed by peg with a qc constraint .",
    "we study their sector error rate ( ser ) performance on the ideal equalized partial response target @xmath47 corrupted by awgn , and with coding rate penalty @xmath232 .",
    "the nominal systems run at a coding rate of @xmath233 .",
    "the minimum snr required to achieve reliable recording at this rate is @xmath234 db , estimated by following the same approach as in  @xcite .      in fig .",
    "[ fig : ldpcalone ] , we compare ser of the following ldpc codes , each constructed by peg with a qc constraint :    * a @xmath235 @xmath20-ldpc , of column weight @xmath55 , and circulant size @xmath236 bits .",
    "the channel detector is a @xmath58 state binary bcjr . * a @xmath237 @xmath116-ldpc , of codeword length @xmath238 bits , column weight @xmath58 , and circulant size of @xmath239 symbols .",
    "the channel detector is a symbol - bcjr with @xmath240 branches emanating from each of @xmath58 states . * a @xmath241 @xmath135-ldpc , of codeword length @xmath238 bits , column weight @xmath58 , and circulant size of @xmath242 symbols .",
    "the channel detector is a symbol - bcjr with @xmath243 branches emanating from each of @xmath58 states . * a @xmath244 @xmath135-ldpc , of codeword length @xmath245 bits , column weight @xmath133 , and circulant size of @xmath246 symbols .",
    "the channel detector is a symbol - bcjr with @xmath243 branches emanating from each of @xmath58 states .    for the binary ldpc turbo equalizer ,",
    "we run a maximum of @xmath247 iterations , @xmath248 global , and @xmath249 ldpc bp iterations .",
    "for the @xmath0-ary turbo equalizers , on the other hand , we run a maximum of @xmath250 iterations . a column weight of @xmath58",
    "gives the best waterfall performance of @xmath0-ary ldpc .",
    "however , @xmath135-ldpc exhibits an error floor as early as at ser @xmath251 , whereas a higher order field of @xmath116 does not show such a tendency down to @xmath252 . nevertheless , the prohibitive complexity of @xmath116 symbol - bcjr makes @xmath135-ldpc a more attractive choice .",
    "still , we need to sacrifice @xmath135-ldpc s waterfall performance gains to guarantee a lower error floor . for that purpose ,",
    "we move to a column weight @xmath133 @xmath135-ldpc that is @xmath253 db away at @xmath252 from the independent uniformly - distributed capacity @xmath254 of the channel  @xcite , and @xmath255 db away from @xmath116-ldpc a the same ser . in this simulation study , we have observed that while binary ldpc can gain up to @xmath256 db through @xmath248 channel iterations before gain saturates , @xmath116-ldpc and @xmath135-ldpc achieve very little iterative gain by going back to the channel , between @xmath257 to @xmath258 db through @xmath133 channel iterations .",
    "one way to explain this phenomenon , is that symbol - level ldpc decoding divides the bit stream into ldpc symbols that capture the error events introduced by the channel detector , rendering the binary inter - symbol interference limited channel into a memoryless multi - level awgn limited channel .",
    "nonetheless , error events spanning symbol boundaries reintroduce correlations between ldpc symbols that are broken only by going back to the channel .",
    "in other words , if it was not due to such boundary effects , a @xmath0-ary ldpc equalizer would not exhibit any iterative turbo gain whatsoever .",
    "nonetheless , full - blown symbol bcjr is still too complex to justify salvaging the small iterative gain by performing extra channel iterations  @xcite .",
    "this is where error event matched decoding comes into the picture , which leads us to the results of the next section .",
    "iterations of binary ldpc , @xmath259 iterations of @xmath116-ldpc of column weight @xmath58 , and @xmath259 iterations of @xmath135-ldpc of column weights @xmath58 and @xmath133 .",
    "minimum snr to achieve reliable recording at coding rate @xmath233 is @xmath234 db for @xmath47.,width=336 ]      we first construct two t - epcc-@xmath0ldpc codes of rate @xmath233 , the same rate as the competing single - level @xmath0ldpc .",
    "these tppc s are based on epcc @xmath260 of example 1 .",
    "the codes constructed are :    * tppc - a : a @xmath1 kb sector , binary @xmath261 tppc , of rate @xmath233 , and @xmath262 parity bits , based on a component @xmath263 peg - optimized qc @xmath135-ldpc , of rate @xmath264 , column weight @xmath133 , and circulant size @xmath265 . *",
    "tppc - b : a @xmath3 kb sector , binary @xmath266 tppc , of rate @xmath233 , and @xmath267 parity bits , based on a component @xmath268 peg - optimized qc @xmath135-ldpc , of rate @xmath264 , column weight @xmath133 , and circulant size @xmath269 .",
    "first , we study the ser of t - epcc-@xmath0ldpc just up to the component @xmath135 ldpc decoder , and only at the first channel pass . this ser is function of the viterbi symbol error rate , and the accuracy of generating signature mlllrs , in addition to the component ldpc employed .",
    "this ser represents the best that the tppc code can do , under the assumption of perfect component epcc , i.e. , as long as @xmath0ldpc generates a clean codeword of signature - symbols , then epcc generates a clean codeword of data - symbols .",
    "[ fig : idealtppc ] shows the ideal ser of these two tppc codes , assuming perfect epcc , compared to single - level @xmath135-ldpc and @xmath116-ldpc .",
    "ideal @xmath1 kb tppc has about the same ser as single level @xmath135-ldpc at @xmath270 ser . in @xmath1 kb tppc",
    ", the component @xmath135-ldpc has half the codeword length of the single level counterpart , saving @xmath2 of the decoder complexity , while delivering similar ser performance .",
    "the tppc component @xmath0ldpc faces a harsher channel than single - level @xmath0ldpc , because the symbol error probability of @xmath57-bit data symbols is strictly less than the symbol error probability of @xmath57-bit signature symbols , where signature symbols are compressed down from @xmath54-bit data symbols .",
    "also , the shorter codeword length of component @xmath0ldpc hurts its minimum distance .",
    "still , these impairments are effectively compensated for by an @xmath271 increase in the redundancy of the tppc component ldpc . on the other hand ,",
    "if we match the codeword length of tppc s component ldpc to single - level ldpc , as part of constructing @xmath3 kb tppc , then , @xmath3 kb tppc will have similar decoder complexity to @xmath1 kb single - level ldpc with about @xmath272 db snr advantage for @xmath3 kb ideal tppc at @xmath270 ser .    due to the imperfections of epcc design , including mis - correction due to one - to - many syndrome to error position mapping , and undetected errors due to epcc s small minimum distance , achieving the ideal performance in fig .",
    "[ fig : idealtppc ] is not possible in one channel pass .",
    "in addition , an outer code is necessary to protect against undetected errors and provide a stopping flag for the iterative decoder .",
    "hence , one can think of an implementation of the full t - epcc-@xmath135ldpc decoder that includes an outer @xmath273 @xmath274 rs for the @xmath1 kb case , and an outer @xmath275 @xmath276 rs for the @xmath3 kb case , so as to protect against epcc residual errors .",
    "these outer rs codes are defined on @xmath277 and have rate @xmath278 . however",
    ", this concatenation setup will run at a lower code rate of @xmath279 , which can incur an snr degradation larger than @xmath280 db for a noise environment characterized by the rate penalty @xmath281 . in a more thoughtful approach",
    ", one can preserve the nominal code rate of @xmath233 and redistribute the redundancy between the inner tppc and outer rs to achieve an improved tradeoff between miscorrection probability and the inner tppc s component ldpc code strength . in that spirit , we construct the following concatenated codes :    * tppc - c : a @xmath1 kb sector , binary @xmath282 tppc , of rate @xmath283 , and @xmath284 parity bits , based on a component @xmath285 peg - optimized qc @xmath135-ldpc , of rate @xmath286 , column weight @xmath133 , and circulant size @xmath242 . an outer @xmath273 @xmath287 rs code of rate @xmath278 is included , resulting in a total system rate of @xmath233 . * tppc - d : a @xmath3 kb sector , binary @xmath288 tppc , of rate @xmath283 , and @xmath289 parity bits , based on a component @xmath290 peg - optimized qc @xmath135-ldpc , of rate @xmath286 , column weight @xmath133 , and circulant size @xmath291 . an outer @xmath275 @xmath292 rs code of rate @xmath278",
    "is included , resulting in a total system rate of @xmath233 .",
    "the control mechanism of iterative decoding for these codes is as follows : if epcc results in less than @xmath57 rs symbol errors for the @xmath1 kb design or less than @xmath54 for the @xmath3 kb design , or if epcc generates more errors than this , but declares less than @xmath54 erasures for @xmath1 kb or @xmath293 erasures for @xmath3 kb , then , decoding halts and decisions are released .",
    "otherwise , one more channel iteration is done by passing epcc soft bit - level llr s to viterbi detection and the bank of error - matched correlators .",
    "simulation results in fig .",
    "[ fig : realtppc_r1 ] , for a noise environment of rate penalty @xmath294 , demonstrate that after @xmath133 channel iterations , the ideal and practical performances of the new tppc codes almost lock , while incurring minimal snr degradation .",
    "also , @xmath1 kb tppc saves @xmath2 of decoder complexity while achieving the same ser performance as single level ldpc for an additional snr cost of @xmath295 db at ser @xmath252 .",
    "hence , tppc - c represents a tradeoff between the lower complexity of @xmath20-ldpc and performance advantage of @xmath135-ldpc , whereas @xmath3 kb tppc has the same decoding complexity as single - level ldpc while furnishing @xmath296 db gain at @xmath297 ser . in terms of channel detector implementation complexity",
    ", the complexity and latency of @xmath135-bcjr in the single level code far exceeds the overall complexity of the non - ldpc parts of two level t - epcc-@xmath135ldpc including viterbi detection .",
    "at the same time , signature mlllr generation , epcc decoding , and bit - llr generation are all implemented tensor - symbol by tensor - symbol , achieving full parallelism on the tensor - symbol level . furthermore",
    ", it is only when @xmath0ldpc finds a syndrome error that epcc decoding is turned on for each tensor symbol . to eliminate redundant computations in the iterative decoder , branch metric computation in viterbi and ( [ eq : nobound ] ) is only required at the first pass . for all subsequent iterations , however ,",
    "only the _ a priori _ bias is updated in the second term of ( [ eq : nobound ] ) , and the branch update of viterbi  @xcite .",
    "iterations of binary ldpc , @xmath259 iterations of @xmath116-ldpc of column weight @xmath58 , @xmath259 iterations of @xmath135-ldpc of column weight @xmath133 , and @xmath298 iterations of ideal @xmath1 kb and @xmath3 kb t - epcc-@xmath135ldpc based on column weight @xmath133 ldpc.,width=336 ]    : @xmath299 iterations of binary ldpc , @xmath259 iterations of @xmath116-ldpc of column weight @xmath58 , @xmath259 iterations of @xmath135-ldpc of column weight @xmath133 , and @xmath300 iterations of practical @xmath1 kb t - epcc-@xmath135ldpc+rs(@xmath273 ) , and @xmath3 kb t - epcc-@xmath135ldpc+rs(@xmath275 ) , both based on column weight @xmath133 ldpc.,width=336 ]    one very important feature of the tppc setup , that single - level ldpc lacks , is its robustness to boundary error events .",
    "the presence of a syndrome - constraint means that errors spanning boundaries are broken by epcc when attempting to independently satisfy the adjacent tensor symbol syndromes , then , in the next turbo iteration , adjacent tensor - symbols are decorrelated .",
    "this mechanism enables tppc to recover from these errors by iterative decoding .",
    "however , for errors with a zero error - syndrome which go undetected by epcc , outer rs protection becomes handy .",
    "based on the fact that tppc enables an increase in the redundancy of its component ldpc , in addition to simulation results demonstrating the utility of such lowered rate in combating the harsher compressed channel , we conjecture that as the sector length of both tppc and single - level ldpc is driven to infinity , tppc will achieve strict error rate snr gains .",
    "this is mainly because of its surplus of redundancy compared to the single level code at the same rate penalty , whereas channel conditions and epcc correction power do not change with replication of tensor symbols , and the error rate performance of ldpc asymptotically approaches the noise threshold in the limit of infinite codeword length .",
    "therefore , within a channel - capacity achieving argument , in the limit of infinite codeword length , we take the view that tppc will bridge the gap to capacity further than any single level system could .",
    "moreover , the advantage of tppc for larger sector sizes is more timely than ever as the industry moves to the larger @xmath52 kb sector format  @xcite .",
    "in a tensor product setup , codes of short codeword length and low rate can be combined into high rate codes of nice algebraic properties .",
    "we showed that encoding of tensor product codes is linear time if the component codes are linear time encodable .",
    "we also demonstrated how the codeword length and rate of channel matched epcc can be substantially increased by combining with a strong rs or ldpc of short codeword length .",
    "we also incorporated an outer rs code of low correction power to clean out the residual errors of t - epcc - rs or t - epcc - ldpc tppcs . in conclusion , this work established t - epcc-@xmath0ldpc as a reasonable complexity approach to introducing non - binary ldpc to the perpendicular recording read channel architecture , paving the way to reliable higher recording densities .",
    "the authors would like to thank the anonymous reviewers for their constructive comments that helped enhance the technical quality and presentation of this paper .",
    "hao zhong , wei xu , ningde xie , and tong zhang ,  area - efficient min - sum decoder design for high - rate quasi - cyclic low - density parity - check codes in magnetic recording , \" _ ieee transactions on magnetics _",
    "12 , pp . 4117 - 4122 , dec . 2007 .",
    "hao zhong , tong zhong , and erich f. haratsch ,  quasi - cyclic ldpc codes for the magnetic recording channel : code design and vlsi implementation , \" _ ieee transactions on magnetics _ , vol .",
    "1118 - 1123 , mar .",
    "2007 .",
    "s. sankaranarayanan , b. vasic , and e. m.kurtas ,  irregular low - density parity - check codes : construction and performance on perpendicular magnetic recording channels , \" _ ieee transactions on magnetics _",
    "5 , pp . 2567 - 2569 , sept . 2003 .",
    "b. vasic , and o. milenkovic ,  combinatorial constructions of low - density parity - check codes for iterative decoding , \" _ ieee transactions on information theory _ , vol .",
    "50 , no . 6 , pp .",
    "1156 - 1176 , june 2004 .",
    "b. m. kurkoski , p. h. siegel , and j. k. wolf ,  joint message - passing decoding of ldpc codes and partial - response channels , \" _ ieee transactions on information theory _ , vol .",
    "49 , no . 8 , pp . 2076 - 2076 , aug . 2003 .",
    "r. d. cideciyan , e. eleftheriou , and t. mittelholzer ,  perpendicular and longitudinal recording : a signal - processing and coding perspective , \" _ ieee trans .",
    "1698 - 1704 , jul . 2002 .      hongxin song , r. m. todd , and j. r. cruz ,  applications of low - density parity - check codes to magnetic recording channels , \" _ ieee journal on selected areas in communications _ , vol .",
    "918 - 923 , may 2001 .",
    "p. chaichanavong , and p. h. siegel ,  tensor - product parity codes : combination with constrained codes and application to perpendicular recording , \" _ ieee transactions on magnetics _ , vol .",
    "214 - 219 , feb . 2006 .",
    "a. fahrner , h. grie@xmath301er , r. klarer , and v. v. zyablov ,  low - complexity gel codes for digital magnetic storage systems , \" _ ieee transactions on magnetics _ ,",
    "3093 - 3095 , jul . 2004 .",
    "l. zongwang , and b. v. k. v. kumar ,  a class of good quasi - cyclic low - density parity check codes based on progressive edge growth graph , \" _ conference record of the thirty - eighth asilomar conference on signals , systems and computers , 2004 _ , pp .",
    "1990 - 1994 vol . 2 , 7 - 10 nov .",
    "2004 .",
    "w. chang , and j. r. cruz , ",
    "comments on  performance and decoding complexity of nonbinary ldpc codes for magnetic recording `` [ jan .",
    "08 211 - 216 ] , '' _ magnetics , ieee transactions on _ , vol .",
    "2423 - 2424 , oct .",
    "2008 .",
    "hakim alhussien received the b.s . and",
    "degrees in electrical engineering with high honors from jordan university of science and technology ( just ) , irbid , in 2001 and 2003 , respectively , and the msee and ph.d .",
    "degrees in electrical engineering from the university of minnesota twin - cities , minneapolis , in 2008 and 2009 , respectively . from 2003",
    "to 2004 , he was an instructor with the department of electrical engineering at the university of yarmouk , jordan . from 2004 to 2008 , he held research and teaching assistant positions with the department of electrical and computer engineering , the university of minnesota . since september 2008",
    ", he has been a systems design engineer with link - a - media devices , santa clara .",
    "his main research interest are in the applications of coding , signal processing , and information theory to data storage systems .",
    "jaekyun moon is a professor of electrical engineering at kaist .",
    "moon received a bsee degree with high honor from suny stony brook and then m.s . and ph.d .",
    "degrees in electrical and computer engineering at carnegie mellon university . from 1990 through early 2009 , he was with the faculty of the department of electrical and computer engineering at the university of minnesota , twin cities .",
    "moon s research interests are in the area of channel characterization , signal processing and coding for data storage and digital communication .",
    "he received the 1994 - 1996 mcknight land - grant professorship from the university of minnesota .",
    "he also received the ibm faculty development awards as well as the ibm partnership awards .",
    "he was awarded the national storage industry consortium ( nsic ) technical achievement award for the invention of the maximum transition run ( mtr ) code , a widely - used error - control / modulation code in commercial storage systems .",
    "he served as program chair for the 1997 ieee magnetic recording conference .",
    "he is also past chair of the signal processing for storage technical committee of the ieee communications society . in 2001 ,",
    "he co - founded bermai , inc .",
    ", a fabless semiconductor start - up , and served as founding president and cto .",
    "he served as a guest editor for the 2001 ieee j - sac issue on signal processing for high density recording .",
    "he also served as an editor for ieee transactions on magnetics in the area of signal processing and coding for 2001 - 2006 .",
    "he worked as consulting chief scientist at dspg , inc . from 2004 to 2007 .",
    "he also worked as chief technology officer at link - a - media devices corp . in 2008 .",
    "he is an ieee fellow ."
  ],
  "abstract_text": [
    "<S> the error pattern correcting code ( epcc ) can be constructed to provide a syndrome decoding table targeting the dominant error events of an inter - symbol interference channel at the output of the viterbi detector . for the size of the syndrome table to be manageable and the list of possible error events to be reasonable in size </S>",
    "<S> , the codeword length of epcc needs to be short enough . </S>",
    "<S> however , the rate of such a short length code will be too low for hard drive applications . to accommodate the required large redundancy , </S>",
    "<S> it is possible to record only a highly compressed function of the parity bits of epcc s tensor product with a symbol correcting code . in this paper </S>",
    "<S> , we show that the proposed tensor error - pattern correcting code ( t - epcc ) is linear time encodable and also devise a low - complexity soft iterative decoding algorithm for epcc s tensor product with @xmath0-ary ldpc ( t - epcc-@xmath0ldpc ) . </S>",
    "<S> simulation results show that t - epcc-@xmath0ldpc achieves almost similar performance to single - level @xmath0ldpc with a @xmath1 kb sector at @xmath2 reduction in decoding complexity . </S>",
    "<S> moreover , @xmath3 kb t - epcc-@xmath0ldpc surpasses the performance of @xmath1 kb single - level @xmath0ldpc at the same decoder complexity .    </S>",
    "<S> alhussien moon : an iteratively decodable tensor product code with application to data storage    tensor product codes , inter - symbol interference , turbo equalization , error - pattern correction , @xmath0-ary ldpc , multi - level log likelihood ratio , tensor symbol signatures , signature - correcting code , detection postprocessing . </S>"
  ]
}