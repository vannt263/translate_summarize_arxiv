{
  "article_text": [
    "automated program analyses are useful for various purposes . for instance",
    ", compilers can benefit from their results to improve the translation of source into target programs .",
    "analysis information can be helpful to programmers to reason about the behavior and operational properties of their programs .",
    "moreover , this information can also be documented by program documentation tools or interactively shown to developers in dedicated programming environments . on the one hand , declarative programming languages provide interesting opportunities for analyzing programs . on the other hand , their complex or abstract execution model demands for good tool support to develop reliable programs .",
    "for example , the detection of type errors in languages with higher - order features or the detection of mode problems in the use of prolog predicates .",
    "this work is related to functional logic languages that combine the most important features of functional and logic programming in a single language ( see @xcite for recent surveys ) . in particular , these languages provide higher - order functions and demand - driven evaluation from functional programming together with logic programming features like non - deterministic search and computing with partial information ( logic variables ) .",
    "this combination has led to new design patterns @xcite and better abstractions for application programming .",
    "moreover , program implementation and analysis aspects for functional as well as logic languages can be considered in a unified framework .",
    "for instance , test cases for functional programs can be generated by executing functions with logic variables as arguments @xcite .",
    "automated program analyses have been already used for functional logic programming in various situations .",
    "for instance , currydoc @xcite is an automatic documentation tool for the functional logic language curry that analyzes curry programs to document various operational aspects , like the non - determinism behavior or completeness issues .",
    "currybrowser @xcite is an interactive analysis environment that unifies various program analyses in order to reason about curry applications .",
    "kics2 @xcite , a recent implementation of curry that compiles into haskell , includes an analyzer to classify higher - order and deterministic operations in order to support their efficient implementation which results in highly efficient target programs .",
    "similar ideas are applied in the implementation of mercury @xcite which uses mode and determinism information to reorder predicate calls .",
    "non - determinism information as well as information about definitely demanded arguments has been used to improve the efficiency of functional logic programs with flexible search strategies @xcite . a recent eclipse - based development environment for curry",
    "@xcite also supports the access to analysis information during interactive program development .",
    "these different uses of program analyses is the motivation for the current work .",
    "we present cass ( curry analysis server system ) which is intended to be a central component of current and future tools for functional logic programs .",
    "cass provides a generic interface to support the integration of various program analyses .",
    "although the current implementation is strongly related to curry , cass can also be used for similar declarative programming languages , like toy @xcite .",
    "the analyses are performed on an intermediate format into which source programs can be compiled .",
    "cass supports the analysis of larger applications by a modular and incremental analysis .",
    "the analysis results for each module are persistently stored and recomputed only if it is necessary .",
    "since cass is implemented in curry , it can be directly used in tools implemented in curry , like the documentation generator currydoc , the analysis environment currybrowser , or the curry compiler kics2 .",
    "cass can also be invoked as a server system providing a text - based communication protocol in order to interact with tools implemented in other languages , like the eclipse plug - in for curry .",
    "cass is implemented as a master / worker architecture , i.e. , it can distribute the analysis work to different processes in order to exploit parallel or distributed execution environments .",
    "in the next section , we review some features of curry .",
    "section  [ sec : anaimpl ] shows how various kinds of program analyses can be implemented and integrated into cass",
    ". some uses of cass are presented in section  [ sec : usage ] before its implementation is sketched in section  [ sec : impl ] and evaluated in section  [ sec : eval ] .",
    "in this section we review some aspects of curry that are necessary to understand the functionality and implementation of our analysis tool .",
    "more details about curry s computation model and a complete description of all language features can be found in @xcite .",
    "curry is a declarative multi - paradigm language combining in a seamless way features from functional , logic , and concurrent programming .",
    "curry has a haskell - like syntax to @xmath0 is denoted by juxtaposition ( `` @xmath1 '' ) . ]",
    "@xcite extended by the possible inclusion of free ( logic ) variables in conditions and right - hand sides of defining rules .",
    "curry also offers standard features of functional languages , like polymorphic types , modules , or monadic i / o which is identical to haskell s i / o concept @xcite .",
    "thus , `` '' denotes the type of an i / o action that returns values of type @xmath2 .    a _ curry program _ consists of the definition of functions and the data types on which the functions operate",
    "functions are defined by conditional equations with constraints in the conditions .",
    "they are evaluated lazily and can be called with partially instantiated arguments .",
    "for instance , the following program defines the types of boolean values and polymorphic lists and functions to concatenate lists ( infix operator `` '' ) and to compute the last element of a list :    data bool = true | false data list a = [ ] | a : list a@xmath3 ( + + ) : : [ a ] - > [ a ] - > [ a ] [ ] + + ys = ys ( x : xs ) + + ys = x : ( xs + + ys)@xmath3 last xs | _ + + [ x ] = : = xs = x where x free    the data type declarations define and as the boolean constants and ( empty list ) and ( non - empty list ) as the constructors for polymorphic lists ( is a type variable ranging over all types and the type `` '' is usually written as for conformity with haskell ) .",
    "the ( optional ) type declaration ( `` '' ) of the function specifies that takes two lists as input and produces an output list , where all list elements are of the same ( unspecified ) type . into elements of type @xmath4 . ]",
    "the operational semantics of curry @xcite is a conservative extension of lazy functional programming ( if free variables do not occur in the program or the initial goal ) and ( concurrent ) logic programming . to describe this semantics , compile programs , or implement analyzers and similar tools ,",
    "an intermediate representation of curry programs has been shown to be useful .",
    "programs of this intermediate language , called flatcurry , contain a single rule for each function where the pattern matching strategy is represented by case / or expressions .",
    "the basic structure of flatcurry is defined as follows : denotes a sequence of objects @xmath5 . ] +   @xmath6 + a program @xmath7 consists of a sequence of function definitions @xmath8 with pairwise different variables in the left - hand sides .",
    "the right - hand sides are expressions @xmath0 composed by variables , constructor and function calls , case expressions , disjunctions , and introduction of free ( unbound ) variables .",
    "a case expression has the form @xmath9 , where @xmath0 is an expression , @xmath10 are different constructors of the type of @xmath0 , and @xmath11 are expressions .",
    "the _ pattern variables _ @xmath12 are local variables which occur only in the corresponding subexpression @xmath13 .",
    "the difference between @xmath14 and @xmath15 shows up when the argument @xmath0 is a free variable : @xmath14 suspends ( which corresponds to residuation ) whereas @xmath15 nondeterministically binds this variable to the pattern in a branch of the case expression ( which corresponds to narrowing ) .",
    "note that it is possible to translate other functional logic languages , like toy @xcite , or even haskell into this intermediate format .",
    "since our analysis tool is solely based on flatcurry , it can also be used for other source languages provided that there is a translator from such languages into flatcurry .",
    "mature implementations of curry , like pakcs @xcite or kics2 @xcite , provide support for meta - programming by a library containing data types for representing flatcurry programs and an i / o action for reading a module and translating its contents into the corresponding data term .",
    "for instance , a module of a curry program is represented as an expression of type    data prog = prog string [ string ] [ typedecl ] [ funcdecl ] [ opdecl ]    where the arguments of the data constructor are the module name , the names of all imported modules , the list of all type , function , and infix operator declarations .",
    "furthermore , a function declaration is represented as    data funcdecl = func qname int visibility typeexpr rule    where the arguments are the qualified name ( of type , i.e. , a pair of module and function name ) , arity , visibility ( or ) , type , and rule ( of the form `` '' ) of the function . finally , the data type for expressions just reflects its formal definition :    data expr = var int | lit literal | comb combtype qname [ expr ] | case casetype expr [ ( pattern , expr ) ] | or expr expr | free [ int ] expr@xmath3 data combtype",
    "= funccall     thus , variables are numbered , literals ( like numbers or characters ) are distinguished from combinations ( ) which have a first argument to distinguish constructor applications and applications of defined functions .",
    "the remaining data type declarations for representing curry programs are similar but we omit them for brevity .",
    "basically , a program analysis can be considered as a mapping that associates a program element with information about some aspect of its semantics .",
    "since most interesting semantical aspects are not computable , they are approximated by some abstract domain where each abstract value describes some set of concrete values @xcite .",
    "for instance , an `` overlapping rules '' analysis determines whether a function is defined by a set of overlapping rules , which means that some ground call to this function can be reduced in more than one way .",
    "an example for an operation that is defined by overlapping rules is the `` choice '' operation    x ?",
    "y = y    for this analysis one can use as the abstract domain so that the abstract value is interpreted as `` defined by non - overlapping rules '' and is interpreted as `` defined by overlapping rules '' .",
    "hence , the `` overlapping rules '' analysis has the type    funcdecl - > bool    which means that we associate a value to each function definition . based on the data type definitions sketched in section  [ sec : flatcurry ] and some standard functions ,",
    "such an analysis can be defined by looking for occurrences of in the defining expression as follows :    isoverlapping : : funcdecl - > bool isoverlapping ( func _ _ _ _ ( rule _ e ) ) = orinexpr e@xmath3 orinexpr : : expr - > bool orinexpr ( var _ ) = false orinexpr ( lit _ ) = false orinexpr ( comb _ _ es ) = any orinexpr es orinexpr ( case _ e bs ) = orinexpr e || any ( orinexpr .",
    "snd ) bs orinexpr ( or _ _ ) = true orinexpr ( free _ e ) = orinexpr e    many interesting aspects require a more sophisticated analysis where dependencies are taken into account .",
    "for instance , consider a `` non - determinism '' analysis with the abstract domain    data detdom = det | nondet    here , is interpreted as `` the operation evaluates in a deterministic manner on ground arguments . ''",
    "however , is interpreted as `` the operation _ might _ evaluate in different ways for given ground arguments . ''",
    "the apparent imprecision is due to the approximation of the analysis .",
    "for instance , if the function is defined by overlapping rules and the function might call , then is judged as non - deterministic . in order to take into account such dependencies",
    ", the non - determinism analysis requires to examine the current function as well as all directly or indirectly called functions for overlapping rules . due to recursive function definitions",
    ", this analysis can not be done in one shot but requires a fixpoint computation . in order to make things simple for the analysis developer",
    ", cass supports such fixpoint computations and requires from the developer only the implementation of an operation of type    funcdecl - > [ ( qname , a ) ] - > a    where `` '' denotes the type of abstract values .",
    "the second argument of type represents the currently known analysis values for the functions _ directly _ used in this function declaration .",
    "hence , the non - determinism analysis can be implemented as follows :    nondetfunc : : funcdecl - > [ ( qname , detdom ) ] - > detdom nondetfunc ( func f _ _ _ ( rule _ e ) ) calledfuncs = if orinexpr e || freevarinexpr e || any ( = = nondet ) ( map snd calledfuncs ) then nondet else det    thus , it computes the abstract value if the function itself is defined by overlapping rules or contains free variables that might cause non - deterministic guessing ( we omit the definition of since it is quite similar to ) , or if it depends on some non - deterministic function .",
    "the actual analysis is performed by defining some start value for all functions ( the `` bottom '' value of the abstract domain , here : ) and performing a fixpoint computation for the abstract values of these functions .",
    "cass uses a working list approach as default but also supports other methods to compute fixpoints .",
    "the termination of the fixpoint computation can be ensured by standard assumptions in abstract interpretation @xcite , e.g. , by choosing a finite abstract domain and monotonic operations , or by widening operations .    to support the inclusion of different analyses in cass , there are an abstract type `` '' denoting a program analysis with abstract domain `` '' and several constructor operations for various kinds of analyses .",
    "each analysis has a name provided as a first argument to these constructors .",
    "the name is used to store the analysis information persistently and to pass specific analysis tasks to workers ( see below for more details ) .",
    "for instance , a simple function analysis which depends only on a given function definition can be created by    funcanalysis : : string - > ( funcdecl - > a ) - > analysis a    where the analysis name and analysis function are provided as arguments .",
    "thus , the overlapping analysis can be specified as    overlapanalysis : : analysis bool overlapanalysis = funcanalysis `` overlapping '' isoverlapping    a function analysis with dependencies can be constructed by    dependencyfuncanalysis : : string - > a - > ( funcdecl - > [ ( qname , a ) ] - > a ) - > analysis a    here , the second argument specifies the start value of the fixpoint analysis , i.e. , the bottom element of the abstract domain .",
    "thus , the complete non - determinism analysis can be specified as    nondetanalysis : : analysis detdom nondetanalysis = dependencyfuncanalysis `` deterministic '' det nondetfunc    it should be noted that this definition is sufficient to execute the analysis with cass since the analysis system takes care of computing fixpoints , calling the analysis functions with appropriate values , analyzing imported modules , etc . thus , the programmer can concentrate on implementing the logic of the analysis and is freed from many tedious implementation details .",
    "sometimes one is also interested in analyzing information about data types rather than functions .",
    "for instance , the curry implementation kics2 @xcite has an optimization for higher - order deterministic operations .",
    "this optimization requires some information about the higher - order status of data types , i.e. , whether a term of some type might contain functional values .",
    "cass supports such analyses by appropriate analysis constructors .",
    "a simple type analysis which depends only on a given type declaration can be specified by    typeanalysis : : string - > ( typedecl - > a ) - > analysis a    a more complex type analysis depending also on information about the types used in the type declaration can be specified by    dependencytypeanalysis : : string - > a - > ( typedecl - > [ ( qname , a ) ] - > a ) - > analysis a    similarly to a function analysis , the second argument is the start value of the fixpoint analysis and the third argument computes the abstract information about the type names used in the type declaration .    the remaining entities in a curry program that can be analyzed are data constructors . since their definition only contains the argument types , it may seem uninteresting to provide a useful analysis for them .",
    "however , sometimes it is interesting to analyze their context so that there is a analysis constructor of type    constructoranalysis : : string - > ( consdecl - > typedecl - > a ) - > analysis a    thus , the analysis operation of type gets for each constructor declaration the corresponding type declaration .",
    "this information could be used to compute the sibling constructors , e.g. , the sibling for the constructor is .",
    "the information about sibling constructors is useful to check whether a function is completely defined , i.e. , contains a case distinction for all possible patterns . for instance , the operation ( in flatcurry notation )    not x = case x of true - > false false - > true    is completely defined whereas    cond x y = case x of true - > y    is incompletely defined since it fails on as the first argument . to check this property , information about sibling constructors",
    "is obviously useful .",
    "but how can we provide this information in an analysis for functions ?    for this and similar purposes",
    ", cass supports the combination of different analyses .",
    "thus , an analysis developer can define an analysis that is based on information computed by another analysis . to make analysis combination possible",
    ", there is an abstract type `` '' to represent the analysis information of type `` '' for a given module and its imports . in order to look up analysis information about some entity",
    ", there is an operation    lookupproginfo : : qname - > proginfo a - > maybe a    one can use the analysis constructor    combinedfuncanalysis : : string - > analysis b - > ( proginfo b - > funcdecl - > a ) - > analysis a    to implement a function analysis depending on some other analysis .",
    "the second argument is some base analysis computing abstract values of type `` '' and the analysis function gets , in contrast to a simple function analysis , the analysis information computed by this base analysis .",
    "for instance , if the sibling constructor analysis is defined as    siblingcons : : analysis [ qname ] siblingcons = constructoranalysis @xmath16    then the pattern completeness analysis might be defined by    patcompanalysis : : analysis bool patcompanalysis = combinedfuncanalysis `` patcomplete '' siblingcons",
    "ispatcomplete@xmath3 ispatcomplete : : proginfo [ qname ] - > funcdecl - > bool ispatcomplete siblinginfo fundecl = @xmath16    similarly , other kinds of analyses can be also combined with some base analysis by using the following analysis constructors :    combinedtypeanalysis : : string - > analysis b - > ( proginfo b - > typedecl - > a ) - > analysis a combineddependencyfuncanalysis : : string - > analysis b - > a - > ( proginfo b - > funcdecl - > [ ( qname , a ) ] - > a ) - > analysis a combineddependencytypeanalysis : : string - > analysis b - > a - > ( proginfo b - > typedecl - > [ ( qname , a ) ] - > a ) - > analysis a    for instance , an analysis for checking whether a function is totally defined , i.e. , always reducible for all ground arguments , can be based on the pattern completeness analysis .",
    "it is a dependency analysis so that it can be defined as follows ( in this case , is the bottom element since the abstract value denotes `` might not be totally defined '' ) :    totalanalysis : : analysis bool totalanalysis = combineddependencyfuncanalysis `` total '' patcompanalysis true istotal@xmath3 istotal : : proginfo bool - > funcdecl - > [ ( qname , bool ) ] - > bool istotal pcinfo fdecl calledfuncs = ( maybe false i d ( lookupproginfo ( funcname fdecl ) pcinfo ) ) & & all snd calledfuncs    hence , a function is totally defined if it is pattern complete and depends only on totally defined functions .",
    "further examples of combined analyses are the higher - order function analysis used in kics2 ( see above ) where the higher - order status of a function depends on the higher - order status of its argument types , and the non - determinism analysis of @xcite where non - determinism effects are analyzed based on groundness information .    in order to integrate some implemented analysis in cass",
    ", one has to register it . in principle , this could be done dynamically , but currently only a static registration is supported . for the registration , the implementation of cass contains a constant    registeredanalysis : : [ registeredanalysis ]    keeping the information about all available analyses . to register a new analysis",
    ", it has to be added to this list of registered analyses and cass has to be recompiled .",
    "each registered analysis must provide a `` show '' function to map abstract values into strings to be shown to the user .",
    "this allows for some flexibility in the presentation of the analysis information .",
    "for instance , showing the results of the totally definedness analysis can be implemented as follows :    showtotal : : bool - > string showtotal true = `` totally defined '' showtotal false = `` possibly partially defined ''    an analysis can be registered with the auxiliary operation    cassanalysis : : analysis a - > ( a - > string ) - > registeredanalysis    for instance , we can register our analyses presented in this section by the definition    registeredanalysis = [ cassanalysis overlapanalysis showoverlap , cassanalysis nondetanalysis showdet , cassanalysis siblingcons showsibling , cassanalysis patcompanalysis showcomplete , cassanalysis totalanalysis showtotal ]    in the cass implementation . after compiling cass ,",
    "they are immediately available as shown in the next section .",
    "as mentioned above , a program analysis is useful for various purposes , e.g. , the implementation and transformation of programs , tool and documentation support for programmers , etc .",
    "therefore , the results computed by some analysis registered in cass can be accessed in various ways .",
    "currently , there are three methods for this purpose :    batch mode : : :    cass is started with a module and analysis name .",
    "then this analysis is    applied to the module and the results are printed ( using the    analysis - specific show function , see above ) . api mode : : :    if the analysis information should be used in an application    implemented in curry , the application program could use the cass    interface operations to start an analysis and use the computed results    for further processing .",
    "server mode : : :    if the analysis results should be used in an application implemented    in some language that does not have a direct interface to curry , one    can start cass in a server mode . in this case , one can connect to cass    via some socket using a communication protocol that is specified in    the documentation of cass .",
    "figure  [ fig : cass - usage ] shows some uses of cass which are discussed in the following .",
    "the use of cass in batch mode is obvious .",
    "this mode is useful to get a quick access to analysis information so that one can experiment with different abstractions , fixpoint computations , etc .",
    "if one wants to access cass inside an application implemented in curry , one can use some interface operation of cass .",
    "for instance , cass provides an operation    analyzegeneric : : analysis a - > string - > io ( either ( proginfo a ) string )    to apply an analysis ( first argument ) to some module ( whose name is given in the second argument ) .",
    "the result is either the analysis information computed for this module or an error message in case of some execution error .",
    "this access to cass is used in the documentation generator currydoc @xcite to describe some operational aspects of functions ( e.g. , pattern completeness , non - determinism , solution completeness ) , the curry compiler kics2 @xcite to get information about the determinism and higher - order status of functions , and the non - determinism optimizer described in @xcite to obtain information about demanded arguments and non - deterministic functions .",
    "furthermore , there is also a similar operation    analyzemodule : : string - > string - > io ( either ( proginfo string ) string )    which takes an analysis name and a module name as arguments and yields the textual representation of the computed analysis results .",
    "this is used in the currybrowser @xcite which allows the user to browse through the modules of a curry application and apply and visualize various analyses for each module or function . beyond some specific analyses like dependency graphs , all function analyses registered in cass are automatically available in the currybrowser .",
    "the server mode of cass is used in a recently developed eclipse plug - in for curry @xcite which also supports the visualization of analysis results inside eclipse . since this plug - in",
    "is implemented in a java - based framework , the access to cass is implemented via a textual protocol over a socket connection .",
    "this protocol has a command to query the names of all available analyses .",
    "this command is used to initialize the analysis selection menus in the eclipse plug - in . furthermore , there are commands to analyze a complete module or individual entities inside a module .",
    "the analysis results are returned as plain strings or in xml format .",
    "currently , we are working on more options to visualize analysis information in the eclipse plug - in rather than strings , e.g. , term or graph visualizations .",
    "as mentioned above , cass is implemented in curry using the features for meta - programming as sketched in section  [ sec : flatcurry ] .",
    "since the analysis programmer only provides operations to analyze a function , type , or data constructor , as shown in section  [ sec : anaimpl ] , the main task of cass is to supply these operations with the appropriate parameters in order to compute the analysis results .",
    "cass is intended to analyze larger applications consisting of many modules .",
    "thus , a simple implementation by concatenating all modules into one large program to be analyzed would not be efficient enough .",
    "hence , cass performs a separate analysis of each module by the following steps :    1 .",
    "the imported modules are analyzed .",
    "2 .   the analysis information of the interface of the imported modules are loaded .",
    "3 .   the module is analyzed .",
    "if the analysis is a dependency analysis , they are evaluated by a fixpoint computation where the specified start value is used as initial values for the locally defined ( i.e. , non - imported ) entities .",
    "obviously , this scheme can be simplified in case of a simple analysis without dependencies , since such an analysis does not require the imported entities . for a combined analysis ,",
    "the base analysis is performed before the main analysis is executed .",
    "it should be noted that the separate analysis of each module allows only a bottom - up but not a top - down analysis starting with the initial goal .",
    "a bottom - up analysis is sufficient for interactive systems where the initial goal is not known at analysis time .",
    "nevertheless , it is sometimes possible to express `` top - down oriented '' analyses , like a groundness analysis , in a bottom - up manner by choosing appropriate abstract domains , as shown in @xcite where a type and effect system is used to analyze groundness and non - determinism information .    in order to speed up the complete analysis process",
    ", cass implements a couple of improvements to this general analysis process sketched above .",
    "first , the analysis information for each module is persistently stored .",
    "hence , before a module is analyzed , it is checked whether there already exists a storage with the analysis information of this module and whether the time stamp of this information is newer than the source program with all its direct or indirect imports . if the storage is found and is still valid , the stored information is used .",
    "otherwise , the information is computed as described above and then persistently stored .",
    "this has the advantage that , if only the main module has changed and needs to be re - analyzed , the analysis time of a large application is still small .    to exploit multi - core or distributed execution environments ,",
    "the implementation of cass is designed as a master / worker architecture where a master process coordinates all analysis activities and each worker is responsible to analyze a single module .",
    "thus , when cass is requested to analyze some module , the master process computes all import dependencies together with a topological order of all dependencies .",
    "therefore , the standard prelude module ( without import dependencies ) is the first module to be analyzed and the main module is the last one .",
    "then the master process iterates on the following steps until all modules are analyzed :    * if there is a free worker and all imports of the first module are already analyzed , pass the first module to the free worker and delete it from the list of modules . *",
    "if the first module contains imports that are not yet analyzed , wait for the termination of an analysis task of a worker .",
    "* if a worker has finished the analysis of a module , mark all occurrences of this module as `` analyzed . ''    since contemporary curry implementations do not support thread creation , the workers are implemented as processes that are started at the beginning and terminated at the end of the entire execution .",
    "the number of workers can be defined by some system parameter .",
    "the current distribution of cass contains fourteen program analyses , including the analyses discussed in section  [ sec : anaimpl ] .",
    "further analyses include a `` solution completeness '' analysis ( which checks whether a function might suspend due to residuation ) , a `` right - linearity '' analysis ( used to improve the implementation of functional patterns @xcite ) , an analysis of demanded arguments ( used to optimize non - deterministic computations @xcite ) , or a combined groundness / non - determinism analysis based on a type and effect system @xcite .",
    "new kinds of analyses can easily be added , since , as shown in section  [ sec : anaimpl ] , the infrastructure provided by cass simplifies their definition and integration .",
    "we have already discussed some practical applications of cass in section  [ sec : usage ] .",
    "these applications demonstrate that the current implementation with a module - wise analysis , storing analysis information persistently , and incremental re - analysis is good enough to use cass in practice . in order to get some ideas about the efficiency of the current implementation",
    ", we made some benchmarks and report their results in this section .",
    "since all analyses contained in cass have been developed and described elsewhere ( see the references above ) , we do not evaluate their precision but only their execution efficiency .    cass is intended to analyze larger systems .",
    "thus , we omit the data for analyzing single modules but present the analysis times for four different curry applications : the interactive environment ( read / eval / print loop ) of kics2 , the analysis system presented in this paper , the interactive analysis environment currybrowser @xcite , and the module database , a web application generated from an entity / relationship model with the web framework spicey @xcite . in order to get an impression of the size of each application ,",
    "the number of modules ( including imported system modules ) is shown for each application .",
    "typically , most modules contain between 100 - 300 lines of code , where the largest one has more than 900 lines of code .",
    "table  [ table : benchmarks ] contains the elapsed time ( in seconds ) needed to analyze these applications for different numbers of workers .",
    "we ran two kinds of fixpoint analysis : an analysis of demanded arguments @xcite and a groundness analysis @xcite .",
    "each analysis has always been started from scratch , i.e. , all persistently stored information were deleted at the beginning , except for the last row which shows the times to re - analyze the application where only the main module has been changed . in this case , the actual analysis time is quite small but most of the total time is spent to check all module dependencies for possible updates .",
    "the benchmarks were executed on a linux machine running ubuntu 12.04 with an intel core i5 ( 2.53ghz ) processor where cass was compiled with kics2 ( version 0.2.4 ) .",
    "modules : & & & & + analysis : & demand & ground & demand & ground & demand & ground & demand & ground + 1 worker : & 8.09 & 8.25 & 10.25 & 10.30 & 19.53 & 19.36 & 27.97 & 28.15 + 2 workers : & 5.75 & 5.82 & 6.87 & 7.48 & 12.33 & 12.49 & 18.32 & 18.56 + 4 workers : & 5.41 & 5.47 & 6.17 & 6.47 & 10.20 & 10.38 & 16.98 & 17.15 + re - analyze : & 1.40 & 1.38 & 1.26 & 1.26 & 2.01 & 1.99 & 2.34 & 2.34 +    the speedup related to the number of workers is not optimal .",
    "this might be due to the fact that the dependencies between the modules are complex so that there are not many opportunities for an independent analysis of modules , i.e. , workers might have to wait for the termination of the analysis of modules which are imported by many other modules .",
    "nevertheless , the approach shows that there is a potential to exploit the computing power offered by modern computers .",
    "furthermore , the absolute run times are acceptable . it should also be noted that , during system development , the times are lower due to the persistent storing of analysis results .",
    "in this paper we presented cass , a tool to analyze functional logic programs .",
    "cass supports various kinds of program analyses by a general notion of analysis functions that map program entities into analysis information . in order to implement an analysis that also depends on information about other entities used in a definition",
    ", cass supports `` dependency analyses '' that require a fixpoint computation to yield the final analysis information .",
    "moreover , different analyses can be combined so that one can define an analysis that is based on the results of another analysis . using these different constructions ,",
    "the analysis developer can concentrate on defining the logic of the analysis and is freed from the details to invoke the analysis on modules and complete application systems . to analyze larger applications efficiently",
    ", cass performs a modular and incremental analysis where already computed analysis information is persistently stored .",
    "thus , cass does not support top - down or goal - oriented analyses but only bottom - up analyses which is acceptable for large applications or interactive systems with unknown initial goals .",
    "the implementation of cass supports different modes of use ( batch , api , server ) so that the registered analyses can be accessed by various systems , like compilers , program optimizers , documentation generators , or programming environments .",
    "currently , cass produces output in textual form .",
    "the support for other kinds of visualizations is a topic for future work .",
    "the analysis of programs is an important topic for all kinds of languages so that there is a vast body of literature .",
    "most of such works is related to the development and application of various analysis methods ( where some of them related to functional logic programs have already been discussed in this paper ) , but there are less works on the development or implementation of program analyzers .",
    "an example of such an approach , that is in some aspects similar to our work , is hoopl @xcite .",
    "hoopl is a framework for data flow analysis and transformation .",
    "as our framework does , hoopl eases the definition of analyses by offering high - level abstractions and releases the user from tasks like writing fixpoint computations .",
    "in contrast to our work , hoopl works on a generic representation of data flow graphs , whereas cass performs incremental , module - wise analyses on an already existing representation of functional logic programs .",
    "another related system is ciao @xcite , a logic programming system with advanced program analysis features to optimize and verify logic programs .",
    "cass has similar goals but supports strongly typed analysis constructors to make the analysis construction reliable .",
    "there are only a few approaches or tools directly related to the analysis of combined functional logic programs , as already discussed in this paper .",
    "the examples in this paper show that this combination is valuable since analysis aspects of pure functional and pure logic languages can be treated in this combined framework , like demand and higher - order aspects from functional programming and groundness and determinism aspects from logic programming . an early system in this direction is cider @xcite .",
    "cider supports the analysis of single curry modules together with some graphical tracing facilities .",
    "a successor of cider is currybrowser @xcite , already mentioned above , which supports the analysis and browsing of larger applications .",
    "cass can be considered as a more efficient and more general implementation of the analysis component of currybrowser .    for future work",
    ", we will add further analyses in cass with more advanced abstract domains . since this might lead to analyses with substantial run times",
    ", the use of parallel architectures might be more relevant .",
    "thus , it would be also interesting to develop advanced methods to analyze module dependencies in order to obtain a better distribution of analysis tasks between the workers .",
    "s.  antoy and m.  hanus .",
    "declarative programming with function patterns . in _ proceedings of the international symposium on logic - based program synthesis and transformation ( lopstr05 )",
    "_ , pp . 622 .",
    "springer lncs 3901 , 2005 .",
    "s.  antoy and m.  hanus . new functional logic design patterns . in _ proc .  of the 20th international workshop on functional and ( constraint )",
    "logic programming ( wflp 2011 ) _ , pp . 1934 .",
    "springer lncs 6816 , 2011 .",
    "b.  brael , m.  hanus , b.  peemller , and f.  reck . : a new compiler from curry to haskell . in _ proc . of the 20th international workshop on functional and ( constraint )",
    "logic programming ( wflp 2011 ) _ , pp .",
    "springer lncs 6816 , 2011 .",
    "p.  cousot and r.  cousot .",
    "abstract interpretation : a unified lattice model for static analysis of programs by construction of approximation of fixpoints . in _ proc . of the 4th acm symposium on principles of programming languages _ , pp . 238252 , 1977 .",
    "s.  fischer and h.  kuchen .",
    "systematic generation of glass - box test cases for functional logic programs . in _ proceedings of the 9th acm",
    "sigplan international conference on principles and practice of declarative programming ( ppdp07 ) _ , pp .",
    "acm press , 2007 .",
    "m.  hanus .",
    "currydoc : a documentation tool for declarative programs . in _ proc .",
    "11th international workshop on functional and ( constraint ) logic programming ( wflp 2002 ) _ , pp .",
    "research report udmi/18/2002/rr , university of udine , 2002 .",
    "m.  hanus . improving lazy non - deterministic computations by demand analysis . in",
    "technical communications of the 28th international conference on logic programming _ , volume  17 , pp .",
    "130143 . leibniz international proceedings in informatics ( lipics ) , 2012 .",
    "m.  hanus , s.  antoy , b.  brael , m.  engelke , k.  hppner , j.  koj , p.  niederau , r.  sadre , and f.  steiner . : the portland aachen kiel curry system .",
    "available at http://www.informatik.uni-kiel.de/~pakcs/ , 2013 .",
    "m.  hanus and j.  koj .",
    "cider : an integrated development environment for curry . in _ proc .  of the international workshop on functional and ( constraint )",
    "logic programming ( wflp 2001 ) _ , pp .",
    "369373 . report no .",
    "2017 , university of kiel , 2001 .",
    "m.  hanus and s.  koschnicke .",
    "an er - based framework for declarative web programming . in _ proc . of the 12th international symposium on practical aspects of declarative languages ( padl 2010 ) _ , pp .",
    "springer lncs 5937 , 2010 .",
    "n.  ramsey , j.  dias , and s.  peyton  jones .",
    "hoopl : a modular , reusable library for dataflow analysis and transformation . in _ proceedings of the 3rd acm sigplan symposium on haskell ( haskell 2010 )",
    "_ , pp . 121134 .",
    "acm press , 2010 ."
  ],
  "abstract_text": [
    "<S> we present a system , called cass , for the analysis of functional logic programs . </S>",
    "<S> the system is generic so that various kinds of analyses ( e.g. , groundness , non - determinism , demanded arguments ) can be easily integrated . in order to analyze larger applications consisting of dozens or hundreds of modules </S>",
    "<S> , cass supports a modular and incremental analysis of programs . </S>",
    "<S> moreover , it can be used by different programming tools , like documentation generators , analysis environments , program optimizers , as well as eclipse - based development environments . for this purpose </S>",
    "<S> , cass can also be invoked as a server system to get a language - independent access to its functionality . </S>",
    "<S> cass is completely implemented in the functional logic language curry as a master / worker architecture to exploit parallel or distributed execution environments . </S>"
  ]
}