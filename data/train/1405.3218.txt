{
  "article_text": [
    "over the last years , there has been increasing interest in models that combine first - order logic and probability , both for domain modeling under uncertainty , and for efficiently performing inference and learning  @xcite .",
    "probabilistic logic programming ( plp ) has recently received an increasing attention for its ability to incorporate probability in logic programming . among the various proposals ,",
    "the one based on the distribution semantics  @xcite has gained popularity as the basis of languages such as probabilistic horn abduction  @xcite , prism  @xcite , independent choice logic  @xcite , logic programs with annotated disjunctions  @xcite , and problog  @xcite .",
    "nonetheless , research in probabilistic logic languages has made it very clear that it is crucial to design models that can support efficient inference , while preserving intensional , and declarative modeling . lifted inference",
    "@xcite is one of the major advances in this respect .",
    "the idea is to take advantage of the regularities in structured models to decrease the number of operations .",
    "originally , the idea was proposed as an extension of variable elimination ( ve for short in the following ) .",
    "work on lifting ve started with @xcite .",
    "lifted ve exploits the symmetries present in first - order probabilistic models , so that it can apply the same principles behind ve to solve a probabilistic query without grounding the model .",
    "most work in probabilistic inference compute statistics from a sum of products representation , where each element is named a _ factor_. lifted inference generates templates , named _ parametric factors _ or _ parfactors _ , which stand for a set of similar factors found in the inference process , thus delaying as much as possible the use of fully instantiated factors .    in @xcite , the _ prolog factor language _",
    "( pfl , for short ) was proposed as a prolog extension to support probabilistic reasoning with parfactors .",
    "pfl exploits the state - of - art algorithm gc - fove  @xcite , which redefines the operations described in@xcite to be correct for whatever constraint representation is being used .",
    "this decoupling of the lifted inference algorithm from the constraint representation mechanism allows any constraint language that is closed under these operators to be plugged into the algorithm to obtain an inference system .",
    "in fact , the lifted ve algorithm of @xcite represents the adaptation of gc - fove to the pfl constraints .    in this work ,",
    "we move further towards exploiting efficient inference via lifted ve for plp languages under the distribution semantics . to support reasoning compliant with the distribution semantics ,",
    "we introduce two novel operators ( named _ heterogeneous _ lifted multiplication and sum ) in the pfl , and modify the gc - fove algorithm for computing them .",
    "we name lp@xmath0 ( for lifted probabilistic logic programming ) the resulting system .",
    "an experimental comparison between lp@xmath0 and problog2 @xcite and pita @xcite shows that inference time increases linearly with the number of individuals of the program domain for lp@xmath0 , rather than exponentially as with problog2 and pita .",
    "this is an exciting development towards the goal of preserving the declarativeness and conciseness of probabilistic logic languages , while extremely gaining in performances .",
    "the paper is organized as follows .",
    "section [ pre ] introduces preliminaries regarding problog , pfl , causal independence variable elimination , and gc - fove .",
    "section [ trans ] discusses the translation of problog into the extended pfl .",
    "section [ hetop ] presents the new operators introduced in gc - fove .",
    "section [ exp ] reports the experiments performed and section [ conc ] concludes the paper .",
    "problog @xcite is a probabilistic logic programming ( plp ) language .",
    "a problog program consists of a set of _ ground probabilistic facts _ plus a definite logic program , i.e.  a set of rules .",
    "a ground probabilistic fact , written @xmath1 , is a ground fact @xmath2 annotated with a number @xmath3 such that @xmath4 .",
    "an atom that unifies with a ground probabilistic fact is called a _ probabilistic atom _ , while an atom that unifies with the head of some rule in the logic program is called a _ derived atom_.",
    "if a set of probabilistic facts has the same probability @xmath3 , it can be defined intensionally through the syntax @xmath5 , where @xmath6 is the signature of the set , and @xmath7 is a conjunction of non - probabilistic goals , as shown in example [ ws_attr_problog ] .",
    "such rules are range - restricted : all variables in the head of a rule should also appear in a positive literal in the body .",
    "[ ws_attr_problog ] here we present an example inspired by the _ workshop attributes _ problem of @xcite .",
    "the problog program models the scenario in which a workshop is being organized and a number of people have been invited .",
    "` series ` indicates whether the workshop is successful enough to start a series of related meetings while ` attends(p ) ` indicates whether person ` p ` will attend the workshop .    ....",
    "series : - s. series : - attends(p ) .",
    "attends(p ) : - at(p , a ) . 0.1::s . 0.3::at(p ,",
    "a ) : - person(p ) , attribute(a ) .",
    "....    the first two rules define when the workshop becomes a series : either because of its own merits or because people attend . the third rule states that whether a person attends the workshop depends on its attributes ( location , date , fame of the organizers , etc ) .",
    "the probabilistic fact ` s ` represents the merit of the workshop .",
    "the probabilistic fact ` at(p , a ) ` represents whether person ` p ` attends because of attribute ` a ` .",
    "notice that the last statement corresponds to a set of ground probabilistic facts , one for each person ` p ` and attribute ` a ` .",
    "for brevity we do not show the ( non - probabilistic ) facts describing ` person/1 ` and ` attribute/1 ` predicates .",
    "a problog program specifies a probability distribution over normal logic programs . in this work , we consider the semantics in the case of no function symbols to be restricted to finite programs , and assume all worlds have a _ two - valued _ well - founded model .    for each ground",
    "probabilistic fact @xmath8 , an _ atomic choice _ specifies whether to include @xmath2 in a world ( with probability @xmath9 ) or not ( with probability @xmath10 ) .",
    "total choice c _ is a set of atomic choices , one for each ground probabilistic fact .",
    "these choices are assumed to be independent , hence the probability of a total choice is the product of the probabilities of the individual atomic choices , @xmath11 . a total choice @xmath12 also identifies a normal logic program @xmath13 called a _ world _ , where @xmath14 is the set of facts to be included according to @xmath12 and @xmath15 denotes the rules in the problog program .",
    "let @xmath16 be the set of all possible worlds .",
    "the probability of a world is equal to the probability of its total choice .",
    "the conditional probability of a query ( a ground atom ) @xmath17 given a world @xmath18 @xmath19 is 1 if the @xmath17 is true in the well - founded model of @xmath18 and @xmath20 otherwise .",
    "the probability of a query can therefore be obtained as @xmath21 .",
    "most graphical models provide a concise representation of a joint distribution by encoding it as a set of factors .",
    "the probability of a set of variables @xmath22 taking the value @xmath23 can be expressed as product of @xmath24 factors if : @xmath25 where @xmath26 is a sub - vector of @xmath23 that depends on the @xmath27-th factor and @xmath28 is a normalization constant ( i.e. @xmath29 ) .",
    "bayesian networks are an example where there is a factor for each variable that is a function of the variable @xmath30 and its parents @xmath31 , such that @xmath32 and @xmath33 .",
    "as progress has been made on managing large networks , it has become clear that often the same factor appears repeatedly in the network , thus suggesting the use of templates generalizing individual factors , or _",
    "parametric factors _",
    "@xcite .",
    "the prolog factor language ( pfl ) @xcite extends prolog to support probabilistic reasoning with parametric factors or _",
    "parfactors_. the pfl syntax for a factor is @xmath34 .",
    "@xmath35 refers to the type of the network over which the parfactor is defined ( @xmath36 for directed networks or @xmath37 for undirected ones ) ; @xmath14 is a sequence of prolog terms that define sets of random variables under the constraints in @xmath12 .",
    "the set of all logical variables in @xmath14 is named @xmath38 .",
    "@xmath12 is a list of prolog goals that impose bindings on the logical variables in @xmath38 ( the successful substitutions for the goals in @xmath12 are the valid values for the variables in @xmath38 ) .",
    "@xmath39 is the table defining the factor in the form of a list of real values . by default",
    "all random variables are boolean but a different domain may be defined .",
    "an example of a factor is ` series , attends(p);[0.51,0.49,0.49,0.51];[person(p ) ] ` : it has the boolean random variables ` series ` and ` attends(p ) ` as arguments , ` [ 0.51,0.49,0.49,0.51 ] ` as table and ` [ person(p ) ] ` as constraints .",
    "the semantics of a pfl program is given by the set of factors obtained by grounding parfactors : each parfactor stands for the set of its grounding obtained by replacing variables of @xmath38 with the values allowed by the constraints in @xmath12 .",
    "the set of ground factors define a factorization of the joint probability distribution over all random variables .",
    "[ ws_attr_pfl ] a version of the _ workshop attributes _ problem presented in example [ ws_attr_problog ] can be modeled by a pfl program such as    .... bayes attends(p ) , at(p , a ) ; [ 0.7 , 0.3 , 0.3 , 0.7 ] ; [ person(p),attribute(a ) ] .",
    "bayes series , attends(p ) ; [ 0.51 , 0.49 , 0.49 , 0.51 ] ; [ person(p ) ] . ....      quite often we want to find out the probability distribution of a set of random variables @xmath22 given that we know the values , or have evidence @xmath40 , on a set of variables @xmath41 , where @xmath22 is often a single variable @xmath42 .",
    "variable elimination ( ve )  @xcite is an algorithm for computing this _ posterior _ probability in factorized joint probability distributions .",
    "the key idea is to eliminate the random variables from a set of factors one by one until only the query variable @xmath42 remains .",
    "to do so ve eliminates a variable @xmath43 by first multiplying all the factors that include @xmath43 into a single factor ; @xmath43 can then be discarded through summing it out from the newly constructed factor . more formally ,",
    "suppose @xmath44 and @xmath45 are factors .",
    "the product @xmath46 is simply @xmath47 @xmath48 for every value of @xmath49 . to eliminate a variable @xmath50 from the factors @xmath51",
    "one observes that the cases for @xmath50 are mutually exclusive , thus @xmath52 ) is simply @xmath53 , where @xmath54 are the possible values of @xmath50 .",
    "the full ve algorithm takes as input a set of factors @xmath55 , an elimination order @xmath56 , a set of query variables @xmath22 and a list @xmath40 of observed values .",
    "first , it sets the observed variables in all factors to their corresponding observed values .",
    "then it repeatedly selects the first variable @xmath28 from the elimination order @xmath56 and it calls sum - out on @xmath55 and @xmath28 , until @xmath56 becomes empty .",
    "in the final step , it multiplies together the factors of @xmath55 obtaining a new factor @xmath57 that is normalized as @xmath58 to give the posterior probability .",
    "[ [ noisy - or - gates ] ] noisy or - gates + + + + + + + + + + + + + +    bayesian networks take advantage of conditional independence between variables to reduce the size of the representation . _ causal independence _",
    "@xcite goes one step further and looks at independence conditioned on _ values _ of the random variables .",
    "one important example is the _ noisy or - gate _",
    ", where we have a boolean variable @xmath42 with parents @xmath41 , and ideally @xmath42 should be true if any of the @xmath59 is true . in practice",
    ", each parent @xmath59 has a noisy inhibitor that independently blocks or activates @xmath59 , so @xmath42 is true if either * any * of the causes @xmath59 holds true _ and _ is not inhibited . a noisy or can be expressed as a factor @xmath39 . in fact ,",
    "it can be also expressed as a combination of factors by introducing intermediate variables that represent the effect of each cause _ given the inhibitor_. for example , if @xmath42 has two causes @xmath60 and @xmath61 , we can introduce a variable @xmath62 to account for the effect of @xmath60 and @xmath63 for @xmath61 , and the factor @xmath64 can be expressed as @xmath65 where the summation is over all values @xmath66 and @xmath67 of @xmath62 and @xmath63 whose disjunction is equal to @xmath68 .",
    "the @xmath42 variable is called _ convergent _ as it is where independent contributions from different sources are collected and combined .",
    "non - convergent variables will be called _",
    "regular variables_. the noisy or thus allows for a @xmath69 representation of a conditional probability table with @xmath24 parents .",
    "unfortunately , straightforward use of ve for inference would lead to construct @xmath70 tables .",
    "a modified algorithm , called ve1  @xcite , combines factors through a new operator @xmath71 , that generalizes formula ( [ comb ] ) as follows .",
    "let @xmath39 and @xmath72 be two factors that share convergent variables @xmath73 , let @xmath74 be the list of regular variables that appear in both @xmath39 and @xmath72 , let @xmath75 ( @xmath76 ) be the list of variables appearing only in @xmath39 ( @xmath72 ) .",
    "the combination @xmath77 is given by @xmath78 factors containing convergent variables are called _ heterogeneous _ while the remaining factors are called _",
    "homogeneous_. heterogeneous factors sharing convergent variables must be combined with @xmath71 that we call _ heterogeneous multiplication_.    algorithm ve1 exploits causal independence by keeping two lists of factors instead of one : a list of homogeneous factors @xmath79 and a list of heterogeneous factors @xmath80 .",
    "procedure sum - out is replaced by sum - out1 that takes as input @xmath79 and @xmath80 and a variable @xmath28 to be eliminated .",
    "first , all the factors containing @xmath28 are removed from @xmath79 and combined with multiplication to obtain factor @xmath39 . then all the factors containing @xmath28 are removed from @xmath80 and combined with heterogeneous multiplication obtaining @xmath72 .",
    "if there are no such factors set @xmath81 . in the latter case , sum - out1 adds the new ( homogeneous ) factor @xmath82 to @xmath79 otherwise it adds the new ( heterogeneous ) factor @xmath83 to @xmath80 .",
    "procedure ve1 is the same as ve with sum - out replaced by sum - out1 and with the difference that two sets of factors are maintained instead of one .",
    "the @xmath71 operator assumes that the convergent variables are independent given the regular variables .",
    "this can be ensured by _ deputising _ the convergent variables : every such variable @xmath84 is replaced by a new convergent variable @xmath85 ( called a _ deputy variable _ ) , @xmath85 that replaces @xmath85 in the heterogeneous factors containing @xmath84 , @xmath84 becomes a regular variable , and a new factor @xmath86 is introduced , called _ deputy factor _ , that represents the identity function between @xmath84 and @xmath85 , i.e. , it is defined by    deputising ensures that we do not have descendents of a convergent variable in an heterogeneous factor as long as the elimination order for ve1 is such that @xmath87 .",
    "work on lifting ve started with @xcite , and the current state of the art is the algorithm gc - fove @xcite , which redefines the operations of c - fove  @xcite .",
    "the lifted ve algorithm of @xcite represents the adaptation of gc - fove to the pfl language .",
    "_ first - order variable elimination _",
    "( fove ) @xcite computes the marginal probability distribution for query random variables ( randvars ) by repeatedly applying operators that are lifted counterparts of ve s operators .",
    "models are in the form of a set of parfactors that are essentially the same as in pfl . a parametrized random variable ( prv )",
    "@xmath88 is of the form @xmath89 , where @xmath90 is a non - ground atom and @xmath12 is a constraint on logical variables ( logvars ) @xmath91 .",
    "each prv represents the set of randvars @xmath92 , where @xmath23 is the tuple of constants @xmath93 .",
    "given a prv @xmath94 , we use @xmath95 to denote the set of randvars it represents .",
    "each ground atom is associated with one randvar , which can take any value in @xmath96 .",
    "gc - fove tries to eliminate all ( non - query ) prvs in a particular order . to do so",
    ", gc - fove supports several operators .",
    "it first tries _ lifted sum - out _ , that excludes a prv from a parfactor @xmath39 if the prv only occurs in @xmath39 .",
    "next , _ lifted multiplication _ , that multiplies two aligned parfactors . matching variables must be properly aligned and the new coefficients must be computed taking into account the number of groundings in @xmath12 .",
    "third , _ lifted absorption _",
    "eliminates @xmath24 prvs that have the same observed value .",
    "if the two operations can not be applied , a chosen parfactor must be _ split _ so that some of its prvs match another parfactor . in the worst case , when none of the lifted operators can be applied , gc - fove resorts to propositionalization : it completely grounds the parametrized randvars and parfactors and performs inference on the ground level .",
    "gc - fove further extends prvs with counting formulas , introduced in c - fove  @xcite .",
    "a counting formula takes advantage of symmetry existing in factors that are products of independent variables .",
    "it represents a factor of the form @xmath97 , where all variables have the same domain , as @xmath98)$ ] .",
    "the factor implements a multinomial distribution , such that its values depend on the number of variables @xmath24 and domain size .",
    "the lifted counted variable is named a pcrv .",
    "pcrvs may result from summing - out , when we obtain factors with a single prv , or through _ counting conversion _ that searches for factors of the form @xmath99 and counts on the occurrences of @xmath100 .",
    "definitions for counting formulas are reported in [ app_definition ] .",
    "gc - fove employs a constraint - tree to represent arbitrary constraints @xmath12 , whereas the pfl simply uses sets of tuples .",
    "arbitrary constraints can capture more symmetries in the data , which potentially offers the ability to perform more operations at a lifted level .",
    "in order to translate problog into pfl , let us start from the conversion of a problog program into a bayesian network with noisy or nodes . here",
    "we adapt the conversion for logic programs with annotated disjunctions presented in @xcite to the case of problog .",
    "the first step is to generate the grounding of the problog program . for each atom @xmath101 in the herbrand base of the program",
    ", the bayesian network contains a boolean random variable with the same name . each probabilistic fact @xmath102",
    "is represented by a parentless node with the conditional probability table ( cpt ) :    for each ground rule @xmath103 we add to the network a random variable called @xmath104 that has as parents @xmath105 and the following cpt :    in practice @xmath104 is the result of the conjunction of random variables representing the atoms in the body .",
    "then for each ground atom @xmath106 in the herbrand base not appearing in a probabilistic fact , we add @xmath106 to the network with parents all @xmath104 of ground rules with @xmath106 in the head and with the cpt    representing the result of the disjunction of random variables @xmath104 .",
    "translating problog into pfl allows us to stay in the lifted ( non - ground ) program .",
    "[ problog2pfl ] the translation of the problog program of example [ ws_attr_problog ] into pfl is    .... bayes series1 , s ; identity ; [ ] .",
    "bayes series2 , attends(p ) ; identity ; [ person(p ) ] .",
    "bayes series , series1 , series2 ; disjunction ; [ ] .",
    "attends1(p ) , at(p , a ) ; identity ; [ person(p),attribute(a ) ] .",
    "bayes attends(p ) , attends1(p ) ; identity ; [ person(p ) ] .",
    "bayes s ; [ 0.9 , 0.1 ] ; [ ] .",
    "bayes at(p , a ) ; [ 0.7 , 0.3 ] ; [ person(p),attribute(a ) ] .",
    "identity([1,0,0,1 ] ) .",
    "disjunction([1,0,0,0 ,               0,1,1,1 ] ) . ....    notice that ` series2 ` and ` attends1(p ) ` can be seen as or - nodes .",
    "thus , after grounding , factors derived from the second and the fourth parfactor should not be multiplied together but should be combined with heterogeneous multiplication , as variables ` series2 ` and ` attends1(p ) ` are in fact convergent variables .",
    "to do so , we need to identify heterogeneous factors and add deputy variables and factors .",
    "we thus introduce two new types of factors to pfl , ` het ` and ` deputy ` .",
    "the first factor is such that its ground instantiations are heterogeneous factors .",
    "the convergent variables are assumed to be represented by the first atom in the factor s list of atoms .",
    "lifting identity is straightforward , it corresponds to two atoms and imposes an identity factor between their ground instantiations .",
    "since the factor is fixed , it is not indicated .",
    "the pfl program of example [ problog2pfl ] , extended with the two new factors ` het ` and ` deputy ` , becomes :    .... het series1p , s ; identity ; [ ] .",
    "het series2p , attends(p ) ; identity ; [ person(p ) ] .",
    "deputy series2 , series2p ; [ ] .",
    "deputy series1 , series1p ; [ ] .",
    "bayes series , series1 , series2 ; disjunction ; [ ] .",
    "het attends1p(p ) , at(p.a ) ; identity ; [ person(p),attribute(a ) ] .",
    "deputy attends1(p ) , attends1p(p ) ; [ person(p ) ] .",
    "bayes attends(p ) , attends1(p ) ; identity ; [ person(p ) ] .",
    "bayes s ; [ 0.9 , 0.1 ] ; [ ] .",
    "bayes at(p , a ) ; [ 0.7 , 0.3 ] ; [ person(p),attribute(a ) ] . ....",
    "where ` series1p ` , ` series2p ` and ` attends1p(p ) ` are the convergent deputy random variables , and ` series1 ` , ` series2 ` and ` attends1(p ) ` are their corresponding new regular variables .",
    "the fifth bayesian factor represents the combination of the contribution to ` series ` of the two rules for it .",
    "causal independence could be applied here as well since the combination is really an or , but for simplicity we decided to concentrate only on exploiting causal independence for the convergent variables represented by the head of rules which is the hard part .",
    "gc - fove must be modified in order to take into account heterogeneous factors and convergent variables .",
    "the ve algorithm must be replaced by ve1 , i.e. , two lists of factors must be maintained , one with homogeneous and the other with heterogeneous factors .",
    "when summing out a variable , first the homogeneous factors must be combined together with homogeneous lifted multiplication",
    ". then the heterogeneous factors must be combined together with heterogeneous lifted multiplication and , finally , the two results must be combined to produce a final factor from which the random variable is eliminated .    lifted heterogeneous multiplication is defined as operator  [ het - mul ] , considering the case in which the two factors share convergent random variables .",
    "we assume familiarity with set and relational algebra ( e.g. ,  join @xmath107 ) while some useful definitions are reported in [ app_definition ] .",
    "prvs must be _ count - normalized _ , that is , the corresponding parameters must be scaled to take into account domain size and number of occurrences in the parfactor .",
    "prvs are then aligned and the joint domain is computed as the natural join between the set of constraints . following standard",
    "lifted multiplication , we assume the same prv will have a different instance in each grounded factor .",
    "we thus proceed very much as in the grounded case , and for each case @xmath108 we sum the potentials obtained by multiplying the @xmath109 and @xmath110 .",
    "note that although potentials need not be normalised to sum to @xmath111 until the end , the relative counts of @xmath112 and @xmath113 must be weighed by considering the number of instances @xmath113 for each @xmath112 .",
    "= = = = = = * * operator * * + * inputs * : + ( 1 ) @xmath114 : a parfactor in model @xmath115 with convergent variables @xmath116 + ( 2 ) @xmath117 : a parfactor in model @xmath115 with convergent variables @xmath118 + ( 3 ) @xmath119 : an alignment between @xmath120 and @xmath121 + * preconditions * : + ( 1 ) for @xmath122 : @xmath123 is count - normalized w.r.t .",
    "@xmath124 in @xmath125 + * output * : @xmath126 , such that + ( 1 ) @xmath127 + ( 2 ) @xmath128 + ( 3 ) let @xmath129 be @xmath130 with @xmath131 for @xmath132 , @xmath133 the set of regular variables + ( 4 ) for each assignment @xmath134 to @xmath129 with @xmath135 , @xmath136 + @xmath137 + @xmath138 + with @xmath139 + * postcondition * : @xmath140    consider the heterogeneous parfactors @xmath141 and @xmath142 and suppose that we want to multiply @xmath120 and @xmath121 ; @xmath143 is convergent in @xmath120 and @xmath121 ; @xmath144 is an alignment between @xmath120 and @xmath121 ; @xmath61 is count - normalized w.r.t .",
    "@xmath145 in @xmath146 ; @xmath147 and @xmath148 .",
    "then @xmath149 @xmath150 with @xmath39 given by :     _ ff _ & @xmath151 + _ ft _ & @xmath152 + _ tf _ & @xmath153 + _ tt _ & @xmath154 +    consider the heterogeneous parfactors @xmath155 and @xmath156 @xmath157 and suppose we want to multiply @xmath120 and @xmath121 ; all randvars are convergent ; @xmath158 is an alignment between @xmath120 and @xmath121 ( so @xmath159 )",
    ". then @xmath160 , with @xmath39 given by     _",
    "ff _ & @xmath161 + _ ft _ & @xmath162 + _ tf _ & @xmath163 + _ tt _ & @xmath164 + & @xmath165 + & @xmath166 +    the sum - out operator must be modified as well .",
    "in fact , consider the case in which a random variable must be summed out from a heterogeneous factor ( i.e. a factor that contains a convergent variable ) .",
    "consider for example the factor @xmath167 with @xmath168 and suppose we want to eliminate the prv @xmath169 .",
    "this factor stands for four ground factors of the form @xmath170 for @xmath171 where @xmath172 is convergent .",
    "given an individual @xmath173 , the two factors @xmath174 and @xmath175 share a convergent variable and can not be multiplied together with regular multiplication . in order to sum out",
    "@xmath169 however we must first combine the two factors with heterogeneous multiplication . to avoid generating first the ground factors , we have added to gc - fove het - sum - out ( operator [ het - sum - out ] ) that performs the combination and the elimination of a random variable at the same time .",
    "we provide a correctness proof for this operator in [ app_proof ] .",
    "= = = = = * * operator * * + * inputs * : + ( 1 ) @xmath176 : a parfactor in model @xmath115 + ( 2 ) let @xmath177 where @xmath178 are convergent atoms + ( 3 ) @xmath179 is the atom to be summed out + * preconditions * : + ( 1 ) for all prvs @xmath88 , other than @xmath180 , in @xmath115 : @xmath181 + ( 2 ) @xmath179 contains all the logvars @xmath182 for which @xmath183 is not singleton + ( 3 ) @xmath184 is count - normalized w.r.t .",
    "+ @xmath185 in @xmath12 + * output * : @xmath186 , such that + ( 1 ) @xmath187 + ( 2 ) @xmath188 + ( 3 ) for each assignment @xmath189 , to @xmath190 + @xmath191 + @xmath192 + @xmath193 with + @xmath194 + * postcondition * : @xmath195    consider the heterogeneous parfactor @xmath196 and suppose that we want to sum out @xmath169 , that @xmath197 and @xmath143 are convergent , that @xmath100 is count - normalized w.r.t .",
    "@xmath42 and that @xmath198 .",
    "then @xmath199 with @xmath200 given by     _",
    "ff _ & @xmath201 + _ ft _ & @xmath202 + _ tf _ & @xmath203 + _ tt _ & @xmath204- + & @xmath205 +",
    "in order to evaluate the performance of lp@xmath0 algorithm , we compare it with pita and problog2 in two problems : _ workshops attributes _ @xcite and example 7 in @xcite that we call _ plates_. code of all the problems can be found in [ app_programs ] . moreover , we did a scalability test on a third problem : _ competing workshops _ @xcite .",
    "all the tests were done on a machine with an intel dual core e6550 2.33ghz processor and 4 gb of main memory .",
    "the _ workshops attributes _ problem differs from example [ ws_attr_problog ] because the first clause for ` series ` is missing and the second clause contains a probabilistic atom in its body . the _ competing workshops _ problem differs from _ workshops attributes _ because it considers , instead of workshop attributes , a set of competing workshops @xmath18 each one associated with a binary random variable _",
    "hot(w ) _ , which indicates whether it is focusing on popular research areas .",
    "the _ plates _ problem is an artificial example which contains two sets of individuals , @xmath42 and @xmath100 .",
    "the distribution is defined by 7 probabilistic facts and 9 rules .",
    "figure [ watt - compare ] shows the runtime of lp@xmath0 , pita and problog2 on the _ workshops attributes _ problem for the query ` series ` where we fixed the number of people to 50 and we increased the number of attributes @xmath206 .",
    "as expected , lp@xmath0 is able to solve a much larger set of problems than pita and problog2 . figure [ watt - ns ] shows the time spent by lp@xmath0 with up to @xmath207 attributes .",
    "figure [ dpoole - pita - problog ] shows the runtime of lp@xmath0 , pita and problog2 on the _ plates _ problem , while figure [ dpoole - ns ] shows that of lp@xmath0 with up to @xmath208 @xmath100 individuals . for this test we executed the query ` f ` and we fixed the number of different @xmath42 individuals to 5 and we increased the number of @xmath100 individuals .    finally , we used the _ competing workshops _",
    "problem for testing the scalability of lp@xmath0 .",
    "the trend was calculated performing the query ` series ` with 10 competing workshops and an increasing number @xmath24 of people problems .",
    "figure [ wcomp - ns ] shows lp@xmath0 computation time .",
    "the trend is almost linear in the number of people contained in the problem .",
    "as the results show , lp@xmath0 can manage domains that are of several orders of magnitude larger than the ones managed by pita and problog2 in a shorter time .",
    "we have shown that the lifted variable elimination approach is very effective at resolving queries w.r.t .",
    "probabilistic logic programs containing large amount of facts .",
    "we have proved that with the introduction of the two new heterogeneous operators we can compute the probability of queries following the distribution semantics in a very efficient way .",
    "experimental evidence shows that lp@xmath0 can achieve several orders of magnitude improvements , both in runtime and in the number of facts that can be managed effectively . in the future",
    ", we plan to compare our approach with that of @xcite for dealing with noisy or factors , and to compare with weighted first order model counting  @xcite .",
    "* acknowledgments : * vsc was partially nanced by the north portugal regional operational programme ( on.2  o novo norte ) , under the nsrf , through the erdf and the fundao para a cincia e a tecnologia within project ade / ptdc / eia - eia/121686/2010 . this work was supported by `` national group of computing science ( gncs - indam ) '' .",
    "in this section we present the problog and pfl code of the testing problems .      to all programs of this section we added 50 workshops and an increasing number of attributes .    [ [ problog - program ] ] problog program",
    "+ + + + + + + + + + + + + + +    .... series:- person(p),attends(p),sa(p ) .",
    "0.501::sa(p):-person(p ) .",
    "attends(p):- person(p),attr(a),at(p , a ) .",
    "0.3::at(p , a):-person(p),attr(a ) .",
    "....    [ [ pfl - program ] ] pfl program + + + + + + + + + + +    .... het series1,ch1(p);[1.0 , 0.0 , 0.0 , 1.0];[person(p ) ] .",
    "deputy series , series1 ; [ ] .",
    "bayes ch1(p),attends(p),sa(p);[1.0,1.0,1.0,0.0 ,                                 0.0,0.0,0.0,1.0];[person(p ) ] .",
    "bayes sa(p);[0.499,0.501];[person(p ) ] .    het attends1(p),at(p , a);[1.0 , 0.0 , 0.0 , 1.0];[person(p),attr(a ) ] .    deputy attends(p),attends1(p);[person(p ) ] .",
    "bayes at(p , a);[0.7,0.3];[person(p),attr(a ) ] . ....      for the _ competing workshops _",
    "problem we report only the pfl version . for testing purpose we added to this code 10 workshops and an increasing number of people .    [ [ pfl - program-1 ] ] pfl program + + + + + + + + + + +    .... bayes ch1(p),attends(p),sa(p);[1.0,1.0,1.0,0.0 ,                                 0.0,0.0,0.0,1.0];[person(p ) ] .",
    "het series1,ch1(p);[1.0 , 0.0 , 0.0 , 1.0];[person(p ) ] .    deputy series , series1 ; [ ] .",
    "bayes sa(p);[0.499,0.501];[person(p ) ] .",
    "het attends1(p),ch2(p , w);[1.0 , 0.0 , 0.0 , 1.0];[person(p),workshop(w ) ] .",
    "deputy attends(p),attends1(p);[person(p ) ] .",
    "bayes ch2(p , w),hot(w),ah(p , w);[1.0,1.0,1.0,0.0 ,                                 0.0,0.0,0.0,1.0];[person(p),workshop(w ) ] .",
    "bayes ah(p , w);[0.2,0.8];[person(p),workshop(w ) ] . ....      for tha _ plates _ problem we added 5 individuals for @xmath42 and an increasing number of individuals for @xmath100 .    [",
    "[ problog - program-1 ] ] problog program + + + + + + + + + + + + + + +    .... f:- e(y ) .",
    "e(y ) : - d(y),n1(y ) .",
    "e(y ) : - y(y),\\+",
    "d(y),n2(y ) .",
    "d(y):- c(x , y ) .",
    "c(x , y):-b(x),n3(x , y ) .",
    "c(x , y):- x(x),\\+ b(x),n4(x , y ) .",
    "b(x):- a , n5(x ) .",
    "b(x):- \\+ a , n6(x ) .",
    "a:- n7 .",
    "0.1::n1(y ) : -y(y ) .",
    "0.2::n2(y ) : -y(y ) .",
    "0.3::n3(x , y ) : - x(x),y(y ) . 0.4::n4(x ,",
    "y ) : - x(x),y(y ) . 0.5::n5(x ) : -x(x ) . 0.6::n6(x ) : -x(x ) . 0.7::n7 . ....",
    "[ [ pfl - program-2 ] ] pfl program + + + + + + + + + + +    .... het f1,e(y);[1.0 , 0.0 , 0.0 , 1.0];[y(y ) ] .",
    "deputy f , f1 ; [ ] .",
    "bayes e1(y),d(y),n1(y);[1.0 , 1.0 , 1.0 , 0.0 ,                          0.0 , 0.0 , 0.0 , 1.0];[y(y ) ] .",
    "bayes e2(y),d(y),n2(y);[1.0 , 0.0 , 1.0 , 1.0 ,                          0.0 , 1.0 , 0.0 , 0.0];[y(y ) ] .",
    "bayes e(y),e1(y),e2(y);[1.0 , 0.0 , 0.0 , 0.0 ,                          0.0 , 1.0 , 1.0 , 1.0];[y(y ) ] .",
    "het d1(y),c(x , y);[1.0 , 0.0 , 0.0 , 1.0];[x(x),y(y ) ] .    deputy d(y),d1(y);[y(y ) ] .",
    "bayes c1(x , y),b(x),n3(x , y);[1.0 , 1.0 , 1.0 , 0.0 ,                              0.0 , 0.0 , 0.0 , 1.0];[x(x),y(y ) ] .",
    "bayes c2(x , y),b(x),n4(x , y);[1.0 , 0.0 , 1.0 , 1.0 ,                              0.0 , 1.0 , 0.0 , 0.0];[x(x),y(y ) ] .",
    "bayes c(x , y),c1(x , y),c2(x , y);[1.0 , 0.0 , 0.0 , 0.0 ,                                0.0 , 1.0 , 1.0 , 1.0];[x(x),y(y ) ] .",
    "bayes b1(x),a , n5(x);[1.0 , 1.0 , 1.0 , 0.0 ,                       0.0 , 0.0 , 0.0 , 1.0];[x(x ) ] .",
    "bayes b2(x),a , n6(x);[1.0 , 0.0 , 1.0 , 1.0 ,                       0.0 , 1.0 , 0.0 , 0.0];[x(x ) ] .",
    "bayes b(x),b1(x),b2(x);[1.0 , 0.0 , 0.0 , 0.0 ,                          0.0 , 1.0 , 1.0 , 1.0];[x(x ) ] .",
    "bayes a , n7;[1.0 , 0.0 , 0.0 , 1.0 ] ; [ ] .",
    "bayes n1(y);[0.9 , 0.1];[y(y ) ] .",
    "bayes n2(y);[0.8 , 0.2];[y(y ) ] .",
    "bayes n3(x ,",
    "y);[0.7 , 0.3];[x(x),y(y ) ] . bayes n4(x ,",
    "y);[0.6 , 0.4];[x(x),y(y ) ] . bayes n5(x);[0.5 , 0.5];[x(x ) ] . bayes n6(x);[0.4 ,",
    "0.6];[x(x ) ] .",
    "bayes n7;[0.3 , 0.7 ] ; [ ] . ....",
    "a counting formula is a syntactic construct of the form @xmath209 $ ] , where @xmath210 is called the counted logvar .",
    "a @xmath211 counting formula is a counting formula in which all arguments of the atom @xmath212 , except for the counted logvar , are constants .",
    "it defines a counting randvar ( crv ) as follows .",
    "a parametrized counting randvar ( pcrv ) is a pair ( @xmath213,c)$ ] . for each instantiation of @xmath214",
    ", it creates a separate counting randvar ( crv ) .",
    "the value of this crv is a histogram , and it depends deterministically on the values of @xmath212 . given a valuation for @xmath212 , it counts how many different values of @xmath30 occur for each @xmath215 .",
    "the result is a _ histogram _ of the form @xmath216 , with @xmath217 and @xmath218 the corresponding count .",
    "the multiplicity of a histogram @xmath219 is a multinomial coefficient , defined as @xmath220    as multiplicities should only be taken into account for ( p)crvs , never for regular prvs , we define for each prv @xmath101 and for each value @xmath221 if @xmath101 is a regular prv , and @xmath222 if @xmath101 is a pcrv .",
    "this mul function is identical to @xcite s num - assign .    given a constraint @xmath223 , for any @xmath224 and @xmath225 , the function @xmath226 is defined as follows : @xmath227 that is , for any tuple t , this function tells us how many values for @xmath41 co - occur with t s value for @xmath228 in the constraint .",
    "we define @xmath229 when @xmath230 .    for any constraint @xmath223 , @xmath224 and @xmath225",
    ", @xmath41 is count - normalized w.r.t .",
    "@xmath228 in @xmath223 if and only if @xmath231 when such an @xmath24 exists , we call it the conditional count of @xmath41 given @xmath228 in @xmath223 , and denote it @xmath232 .",
    "[ substitution ] a substitution @xmath233 maps each logvar @xmath30 to a term @xmath234 , which can be a constant or a logvar .",
    "when all @xmath234 are constants , @xmath235 is called a grounding substitution , and when all are different logvars , a renaming substitution . applying a substitution @xmath235 to an expression @xmath236 means replacing each occurrence of @xmath30 in @xmath236 with @xmath234 ; the result is denoted @xmath237 .",
    "an alignment @xmath235 between two parfactors @xmath238 and @xmath239 is a one - to - one substitution @xmath240 , with @xmath241 and @xmath242 , such that @xmath243 ( with @xmath56 the attribute renaming operator ) .",
    "an alignment tells the multiplication operator that two atoms in two different parfactors represent the same prv , so it suffices to include it in the resulting parfactor only once .",
    "given a model @xmath244 , two heterogeneous parfactors @xmath245 and an alignment @xmath235 between @xmath120 and @xmath121 , if the preconditions of the het - multiply operator are fulfilled then the postcondition @xmath246 holds .      given a model @xmath244 , a heterogeneous parfactor @xmath247 and an atom @xmath179 to be summed out , if the preconditions of the het - sum - out operator are fulfilled then the postcondition @xmath248 holds .",
    "we prove the formula giving @xmath249 in operator [ het - sum - out ] by double induction over @xmath194 and the number @xmath24 of values at @xmath250 in the tuple @xmath251 . for simplicity",
    "we assume that the variable to be summed out , @xmath179 , is not a counting variable , but the same reasoning can be applied for a counting variable . for @xmath252 , @xmath253 @xmath254 so the thesis is proved . for @xmath252 , @xmath255 ,",
    "let us call @xmath256 the the value of @xmath200 for @xmath197 .",
    "let us assume that the formula holds for @xmath257 . for @xmath255 , there is an extra valuation @xmath258 for @xmath259 given @xmath260 so there is an extra factor @xmath261 .",
    "eliminating @xmath179 from @xmath262 gives @xmath263 this must be multiplied by @xmath264 with heterogeneous multiplication as @xmath178 are shared obtaining @xmath265 @xmath266 @xmath267 @xmath268 so the thesis is proved .    for @xmath269 of values at @xmath250 in the tuple @xmath270",
    ", we assume that the formula holds for @xmath271 and @xmath272 .",
    "for the defintiion of heterogeneous multiplication @xmath273 by adding and removing"
  ],
  "abstract_text": [
    "<S> lifted inference has been proposed for various probabilistic logical frameworks in order to compute the probability of queries in a time that depends on the size of the domains of the random variables rather than the number of instances . even if various authors have underlined its importance for probabilistic logic programming ( plp ) , </S>",
    "<S> lifted inference has been applied up to now only to relational languages outside of logic programming . in this paper </S>",
    "<S> we adapt generalized counting first order variable elimination ( gc - fove ) to the problem of computing the probability of queries to probabilistic logic programs under the distribution semantics . </S>",
    "<S> in particular , we extend the prolog factor language ( pfl ) to include two new types of factors that are needed for representing problog programs . </S>",
    "<S> these factors take into account the existing causal independence relationships among random variables and are managed by the extension to variable elimination proposed by zhang and poole for dealing with convergent variables and heterogeneous factors . </S>",
    "<S> two new operators are added to gc - fove for treating heterogeneous factors . </S>",
    "<S> the resulting algorithm , called lp@xmath0 for lifted probabilistic logic programming , has been implemented by modifying the pfl implementation of gc - fove and tested on three benchmarks for lifted inference . </S>",
    "<S> a comparison with pita and problog2 shows the potential of the approach .    </S>",
    "<S> [ firstpage ]    probabilistic logic programming , lifted inference , variable elimination , distribution semantics , problog , statistical relational artificial intelligence </S>"
  ]
}