{
  "article_text": [
    "in standard `` big bang '' models of cosmology , the structures seen in the universe today formed due to self - gravity ; initially small perturbations in matter and radiation were gravitationally amplified into galaxies and clusters of galaxies . by following",
    "how these primordial fluctuations grow in time one can give testable predictions for the large - scale structure of the matter distribution .",
    "due to the same initial perturbations , there are slight deviations from a pure blackbody spectrum in the cosmic microwave background ( cmb ) blackbody radiation , a fossil relic of the big bang . the cobe satellite , which confirmed the isotropy and blackbody spectrum ( with temperature 2.726 k ) of the cmb , also measured these anisotropies .",
    "subsequent balloon - borne and ground - based experiments have measured the amplitude of cmb anisotropies on different angular scales ( see steinhardt 1995 and lubin 1994 for recent reviews ) . for a given cosmological model , one can compute the predicted amplitudes of the cmb anisotropies as another test of the theory .",
    "there are a variety of cosmological parameters which are not well constrained : the hubble constant , neutrino masses , a possible cosmological constant , the initial perturbation spectrum , etc .",
    "however , once the initial conditions are set , the input physics is well understood , and since the initial perturbations are small the subsequent evolution is linear system .",
    "the goal of cosmological spectral codes is to compute , for a given matter composition and initial spectrum of perturbations , the spectrum for mass perturbations and cmb anisotropies expected at the present time .",
    "these predictions can serve as a discriminant of the various models .    in the past varying degrees of approximation",
    "have been made in order to carry out the evolution ( for example peebles & yu 1970 , bond & efstathiou 1987 , holtzman 1989 , sugiyama and gouda 1992 , among others ) .",
    "the code we discuss here has a highly accurate treatment of both the physics and the numerical integration ; we believe it is the most accurate to date .",
    "the tradeoff for this accuracy is increased computational cost , making the use of supercomputers necessary .",
    "the serial and parallel versions of the code ( called linger and plinger , respectively ) will soon be made available through the gc3 software archive .",
    "a number of equations govern the growth of perturbations .",
    "the einstein equations give the effect of gravity , including the rate of universal expansion .",
    "also needed is the boltzmann equation , which governs the phase space evolution of photons and neutrinos .",
    "baryons , electrons , and cold dark matter follow the equations for a pressureless perfect fluid ( though the electrons and baryons are coupled to photons by thomson scattering ) .",
    "see bertschinger 1995 for a detailed introduction to the linearized einstein equations , and ma & bertschinger 1994 for a derivation of the equations used in the linger code .",
    "other physics which is modeled includes accurate treatments of hydrogen and helium recombination , decoupling of photons and baryons , and thomson scattering ( including two photon polarizations and the full angular dependences of the scattering cross section and distribution functions ) .",
    "the equations are most easily solved in @xmath0-space . in fourier space ,",
    "all the @xmath0 modes in the linearized einstein , boltzmann , and fluid equations evolve independently .",
    "in addition to the fourier transform , there is also an angular expansion of the phase space distributions in terms of legendre polynomials ; this turns the boltzmann equations into moment hierarchies determined at each time step . at a given time",
    "it is also necessary to integrate over the 3-momentum , @xmath1 , of the massive neutrinos .",
    "we carry out a full integration down to the final time without use of any free - streaming approximation .",
    "the time integration , ending at the present , is carried out using the standard runge - kutta integrator dverk , obtained from netlib@research.att.com .",
    "the serial code , called linger , is highly efficient on vector machines ; on a single cray c90 node it runs at 570 mflop , a significant fraction of the theoretical 1 gflop peak performance . while the message passing version discussed below will run on the c90 , it is more efficient to use cray s autotasking directives to parallelize the serial code .",
    "this has been done , so typical speeds in excess of 8 gflop should be possible on 16 nodes of the c90 , although the timing runs have not yet been carried out .    for runs determining the cmb anisotropy , we desire a high degree of accuracy , with errors @xmath2 for angular degree @xmath3 .",
    "this requires the inclusion of up to 10,000 moments @xmath4 , and the integration of up to 5000 points in @xmath0 .",
    "thus this problem is computationally intensive ; despite getting 570 mflop on the cray c90 , a full run still requires roughly 75 c90 cpu - hours .",
    "one important feature of the treatment in the previous section is that each mode characterized by a given @xmath0 evolves independently .",
    "this problem is thus perfect for coarse - grained parallelization , since each node can work on solving the equations for a particular value of @xmath0 without the need to communicate with other nodes .",
    "another important feature is that for any value of @xmath0 , the computation necessary to evolve a given mode to the present is much larger than that required for the initial and final message passing .",
    "for example , with the smallest values of @xmath0 required , the cpu time is a least two minutes on an ibm power2 chip , while the results are gathered as a single message of roughly 150 bytes .",
    "( the largest @xmath0-values , corresponding to smaller scales requiring a larger number of moments @xmath4 , can take up to half an hour of cpu time ; the message length increases roughly in proportion to the cpu time , to a maximum of 80 kbyte ) .",
    "thus the overhead from message passing is insignificant .",
    "the main loop of the serial code is in @xmath0 ; the obvious method of parallelization is to use a master / worker approach .",
    "the message passing required is quite straightforward . at the beginning of a run",
    ", the master process needs to broadcast a few quantities to all the workers , such as the time at which to end the evolution and the maximum number of angular moments @xmath4 to compute ; it then waits for a message from any worker process .",
    "when a worker receives this information it then requests a value of @xmath0 from the master , which replies with the appropriate value .",
    "when the worker completes the computation , it sends an array containing the values of interest back to the master , which prints out these values and sends the next @xmath0 value to the worker ( or , if no further work is to be done , a message to stop ) .",
    "thus only a few basic message passing routines are required : broadcasting to all other nodes , sending , receiving , and checking for an incoming message ( either from a particular process or from any process ) , as well as the ability to tag messages .",
    "see appendix a to see the algorithm in more detail .    in the parallel code",
    ", calls to wrapper routines are made ; these routines in turn invoke the actual message passing libraries .",
    "the wrapper routines are provided in a separate file , tailored to the particular library of choice . to date",
    ", we have used pvm ( see geist et al .",
    "1994 ) , mpi ( see gropp et al .",
    "1994 ) , mpl , and pvme ( available from ibm ) . given the computationally intensive nature of this code , the choice of which library to use has no effect on the efficiency of the code and is simply a matter of which is most convenient to the user .",
    "the parallel code , called plinger , has been run on the dec alpha cluster and the c90/t3d at the pittsburgh supercomputing center , and the ibm sp2 at the cornell theory center . on the sp2",
    ", mpl requires that messages be received in the order in which they arrive , but this does not create difficulties . on some machines , pvm allows the master process to cohabit a particular node along with a worker process ; this is desirable because the master process requires little cpu time compared to the workers .",
    "thus pvm has a slight edge on these machines .",
    "[ [ sp2 ] ] sp2 + + +    on a single ibm power 2 chip , about 15 times as much cpu is needed as for a single cray c90 node , so the serial code runs without special optimization at 40 mflop , or a seventh of the 266 mflop peak performance of the power 2 . thus on the ibm sp2 plinger achieves sustained speeds of 2.4 gflop using 64 nodes , and 9.6 gflop on 256 nodes .",
    "we have recently found that the use of the mass library , inlining of subroutines , and higher - order loop transformations can significantly improve the plinger performance on power 2 processors , up to 58 mflop on a single node ; further improvements may be possible .",
    "thus 15 gflop or more should be achievable on the sp2 .",
    "[ [ t3d ] ] t3d + + +    rather than just using the t3d , the message passing code is most suitable for psc s c90/t3d heterogeneous computing environment .",
    "the master process resides on the c90 , handling the input / output and controlling the t3d processes ; this master process uses a negligible amount of cpu time .",
    "plinger runs at 15 mflop on a single t3d node , or a tenth of the theoretical peak rate ( the flop rate was found by comparison with the c90 ) . for 256 nodes on the t3d",
    "the total rate is 3.7 gflop .",
    "figure 1 shows wallclock and cpu time as a function of the number of processors for a test run on the sp2 .",
    "the filled circles show the total cpu time ( as measured by calls to etime ) divided by 100 .",
    "the open squares show the wallclock time .",
    "the parallel efficiency , ( total cpu time)/(wallclock time x number of nodes ) ) , is 95dedicated mode .",
    "the x show the wallclock time for a 256-node t3d run .",
    "the line shows the curve expected if the wallclock time scaled exactly as the inverse of the number of processors .",
    "there is practically no overhead to adding more processors , so the cpu time does not change as the number of processors is increased .",
    "once the final value of @xmath0 has been given to a worker process , the other nodes will no longer have any work to do ( once they have completed the @xmath0-value they are currently working on ) .",
    "thus there will be a period of time at the end of each run when not all the processors are working , so doubling the processors does not quite halve the wallclock time .",
    "since larger wavenumbers require greater computation , one simple method by which we minimized this idle time was to compute the largest @xmath0 first . for productions",
    "runs , which are much longer than these test runs , this idle time will be less significant .",
    "the anisotropies in the cmb can be characterized in terms of multipole moments .",
    "the two - point temperature autocorrelation function , @xmath5 compares the temperatures at points in the sky separated by some angle . roughly speaking ,",
    "the y - axis of this plot shows the power in the spectrum on the angular scale of the multipole @xmath4 .",
    "the points in figure 2 are experimental measurements of the cmb anisotropy .",
    "the two leftmost points are the cobe first- and second - year data , probing an angular scale of ten degrees .",
    "the other points are from balloon flights or ground - based experiments ; these data are available as part of the cosapp software package made available by rahul dave and paul steinhardt at the university of pennsylvania .",
    "the curve shows the output of a plinger run using standard cold dark matter initial conditions and normalized to the cobe data .",
    "the plinger run took 20 hours on 64 nodes of the sp2 . increased accuracy in the measurement and theoretical prediction of the power spectrum",
    "will help to discriminate between cosmological models .",
    "figure 3 shows a simulated sky map , analogous to the cobe sky map , made using the output of plinger .",
    "there is much greater detail here because this map has not been smoothed like the cobe map ; the angular resolution is one - half degree , compared to ten degrees for cobe .",
    "the maximum temperature differences are + /-",
    "200 micro - k ( with the average temperature equal to 2.726 k ) .",
    "an mpeg movie in the html version of this paper shows the evolution of the potential psi of the conformal newtonian gauge ; psi plays the role of the gravitational potential in the newtonian limit .",
    "the square is a comoving 100 mpc across ( 1 pc = 3.3 light years ) .",
    "standard cold dark matter initial conditions are used .",
    "the movie ends shortly after recombination , at conformal time 250 mpc ( expansion factor 1/a = 1028 ) .",
    "the potential oscillates at early times due to the acoustic oscillations of the photon - baryon fluid .",
    "these same oscillations produce the small angular scale features in the cmb anisotropy map shown above .",
    "here we briefly outline the message passing algorithm used .    .... main routine         initialize message passing routines .         if master , call master subroutine ; else call worker subroutine         exit message passing routines    the master subroutine         do initialization .",
    "broadcast initial data to workers .",
    "while there are wavenumbers not yet complete :            receive message from worker            print out the data            send a wavenumber , or a message to stop    the worker subroutine         receive initial data from master .",
    "ask for wavenumber from master .",
    "receive from master :   next wavenumber or message to stop         while a message to stop has not been received :            integrate the equations            send the results to the master            receive from master : next wavenumber or message to stop    message passing wrapper routines     certain basic message passing elements are required by plinger .",
    "we have implemented   the following routines in pvm , mpl , mpi , and pvme .",
    "initpass       -initialize message passing           endpass        -exit from message passing           mybcastreal    -send a message to all other processes           mysendreal     -send a message to a given process           mycheckany     -check for message of any type from any process           mycheckone     -check for message of a given type from a given process           mychecktid     -check for message of any type from a given process           myrecvreal     -receive a message ....      [ [ tags ] ] tags + + + +    each message carries a tag which reveals its function .    ....       tag             type       ---     ----------------------------------           1      -first message from master to workers           2      -from worker ; asking for a wavenumber           3      -from master ; giving worker a wavenumber to work on           4      -from worker ; giving first set of data and lmax           5      -from worker ; giving data ( length = 2*lmax+8 )           6      -from master ; telling worker to stop ....",
    "[ [ message - passing - wrapper - routines ] ] message passing wrapper routines + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    here we show what the wrapper routines look like when using the mpi library .    .... initpass        -initialize message passing c    returns process i d in mytid and the i d of the master in mastid .",
    "subroutine initpass(mytid , mastid )          call mpi_init ( ierr )          call mpi_comm_rank ( mpi_comm_world , mytid , ierr )          call mpi_comm_size ( mpi_comm_world , nproc , ierr )          mastid = 0     endpass         -exit from message passing c    exits mpi            subroutine endpass ( )            call mpi_finalize(ierr )    mybcastreal     -send a message to all other processes c    the master process sends a message with tag = msgtype to all other processes .",
    "c    sends length double precision numbers starting at position buffer .",
    "subroutine mybcastreal ( buffer , length , msgtype )        do i=1 , nproc-1           call mpi_send(buffer , length , mpi_double_precision ,                                   i , msgtype , mpi_comm_world , ierr )        end do    mysendreal      -send a message to a given process c    sends a message with tag = msgtype to the process with id = target .",
    "c    sends length double precision numbers starting at position buffer .",
    "subroutine mysendreal ( buffer , length , msgtype , target )           call mpi_send(buffer , length , mpi_double_precision ,                              target , msgtype , mpi_comm_world , ierr )    mycheckany      -check for message of any type from any process c    waits for a message of any type from any process .",
    "subroutine mycheckany ( msgtype , target )              call mpi_probe ( mpi_any_source , mpi_any_tag ,                                        mpi_comm_world , status , ierr )              msgtype = status(mpi_tag )          target   = status(mpi_source )    mycheckone      -check for message of a given type from a given process c    waits for a message of type msgtype from process target .",
    "subroutine mycheckone ( msgtype , target )              call mpi_probe ( target , msgtype , mpi_comm_world , status , ierr )    mychecktid      -check for message of any type from a given process c    waits for a message of any type from process target .",
    "c    returns the message tag in msgtype .",
    "subroutine mychecktid ( msgtype , target )              call mpi_probe ( target , mpi_any_tag , mpi_comm_world , status , ierr )              msgtype = status(mpi_tag )    myrecvreal      -receive a message subroutine myrecvreal ( buffer , length , msgtype , target )     receives a message of type msgtype from process target .",
    "length double precision numbers are copied , starting at address of buffer .",
    "call mpi_recv(buffer , length , mpi_double_precision , target ,       &            msgtype , mpi_comm_world , status , ierr ) ....    [ [ the - main - routine ] ] the main routine + + + + + + + + + + + + + + + +    ....      program plinger c mytid = the process i d c mastid = the i d of the master process      integer mytid , mastid c initialize message passing routines          call initpass(mytid , mastid )      if ( mytid.eq.mastid ) then         call parentsub(mytid , mastid )      else         call kidsub(mytid , mastid )      endif c exit message passing routines          call endpass      stop      end ....    [ [ the - master - subroutine ] ] the master subroutine + + + + + + + + + + + + + + + + + + + + +    ....      subroutine parentsub(mytid , mastid )    { the master initializes various quantities : the number of k values , the maximum value of k , etc .",
    "the values needed by the workers are placed into the array y. }    c broadcast data to all node programs      msgtype   = 1      imsglen = 5      call mybcastreal ( y , imsglen , msgtype )    c ik is the next wavenumber to send          ik = 1 c keep track of how many ik have been received from workers      ikdone = 0    c start checking for messages from the workers   100     continue          call mycheckany ( msgtype , itid )            if ( msgtype.eq.2 ) then c msgtype=2 : the worker is ready for its first ik .",
    "c             dispose of the message since it contains no data .             call myrecvreal ( deltat , 1 , msgtype , itid )          endif            if ( msgtype.eq.4 ) then c msgtype=4 : receive first part of data from worker c             the length of the next message depends on lmax              call myrecvreal ( y , 21 , msgtype , itid )          ikold = int(y(1 ) )          lmax = int(y(21 ) ) c this data is written to an ascii file          write(unit_1 , * ) ( y(i),i=1,20 )    c msgtype=5 : receive second part of data from worker              msgtype = 5              call mycheckone ( msgtype , itid )              call myrecvreal ( y , 8+lmax+lmax , msgtype , itid ) c this data is written to a binary file          write(unit_2 ) ikold,(y(i),i=7,lmax )          write(unit_2 ) ( y(8+lmax+i),i=0,lmax ) c done with this wavenumber          ikdone = ikdone+1      endif            if ( ( msgtype.eq.2).or.(msgtype.eq.5 ) ) then          if ( ik.le.last_nk ) then c reply with ik to the worker that sent the last message                 y(1 ) =   dble(ik )             msgtype   = 3             imsglen   = 1             call mysendreal ( y , imsglen , msgtype , itid ) c find the next value of ik to be sent                 call ik_next(ik )              else c if no more wavenumbers to send , tell the worker to stop ( msgtype=6 )             msgtype   = 6             imsglen   = 1             call mysendreal ( y , imsglen , msgtype , itid )          endif          endif    c if there are still wavenumbers to receive , go back      if ( ikdone.le.last_nk ) go to 100        return      end ....    [ [ the - worker - subroutine ] ] the worker subroutine + + + + + + + + + + + + + + + + + + + + +    ....      subroutine kidsub(mytid , mastid )    c receive initial data from master          msgtype   = 1          call mycheckone ( msgtype , mastid )      call myrecvreal ( passbuffer , 5 , msgtype , mastid )    c ask for wavenumber from master          msgtype   = 2      imsglen = 1      call mysendreal ( passbuffer , imsglen , msgtype , mastid )    c receive from master :   next ik or message to stop          call mychecktid ( msgtype , mastid )      call myrecvreal ( passbuffer , 1 , msgtype , mastid )      ik = int ( passbuffer(1 ) )    c if the message is not a wavenumber , then exit          while ( msgtype.ne.3 )    c   begin timestep loop .",
    "time = t_start              while ( time.lt.end_time )    { here the worker integrates the coupled equations . }",
    "< br >            end while    c send first part of results to master              msgtype   = 4          imsglen = 21          call mysendreal ( passbuffer , imsglen , msgtype , mastid ) c send second part of results to master              msgtype   = 5              imsglen = 8+lmax+lmax              call mysendreal ( y , imsglen , msgtype , mastid )    c receive from master :   next ik or message to stop              call mychecktid ( msgtype , mastid )              call myrecvreal ( passbuffer , 1 , msgtype , mastid )              ik = int ( passbuffer(1 ) )        end while           return         end ....",
    ".75 in -0.5 in    lubin , p.m. 1994 , in _ examining the big bang and the diffuse background radiations : proceedings of iau symp . 168 _ ( astro - ph/9412021 )    ma , c. , and e. bertschinger 1994 , preprint ( astro - ph/9401007 )    bennett , c.l .",
    "1994 , ap .",
    "j. 436 423    bertschinger , e. 1995 , in _ 1993 les houches summer school lectures on cosmology _",
    "( elsevier science publishers b.v . )",
    "( astro - ph/9503125 )    bond , j.r . ,",
    "and g. efstathiou 1987 mnras 226 655    geist , a. , et al .",
    "1994 , _ pvm : parallel virtual machine _ ( mit press , cambridge ma ) ( html version available at    .... http://www.netlib.org/pvm3/book/pvm-book.html ) ....    gropp , w. , e. lusk , and a skjellum 1994 , _ using mpi _",
    "( mit press , cambridge ma )    holtzman , j. 1989 , ap .",
    "71 1    peebles , p.j.e . , and j.t .",
    "yu 1970 ap .",
    "j. 147 73    smoot , g.f .",
    "1992 , ap .",
    "396 l1    steinhardt , p.j .",
    "1995 , in _ snowmass workshop on particle astrophysics and cosmology _ , ed .",
    "e. kolb and r.peccei ( astro - ph/9502024 )    sugiyama , n. , and n. gouda 1992 , prog .",
    "88 803      * message passing libraries : *    .... http://www.epm.ornl.gov/pvm/pvm_home.html          pvm : parallel virtual machine    http://www.mcs.anl.gov/projects/mpi/index.html          mpi - message passing interface    http://www.mcs.anl.gov/projects/mpi/index.html          mpi - message passing interface    http://ibm.tc.cornell.edu/ibm/pps/doc/pvme.html          ibm powerparallel systems : pvme ....    _ see the cornell theory center hardware page for information on mpl _ + * supercomputing centers ( for information on the machines used ) : *    .... http://www.tc.cornell.edu/userdoc/hardware/          cornell theory center hardware page    http://pscinfo.psc.edu/          pittsburgh supercomputing center home page          ( cmb anisotropy experiment data , compiled by rahul dave ) ....    * astrophysics servers : *    .... http://dept.physics.upenn.edu/~www/astro-cosmo          cmb window and bandpower software package ( cosapp )    http://xxx.lanl.gov/astro-ph/          astro - ph astrophysics preprints ....    * the grand challenge cosmology consortium , gc3 : * _ look for linger ( as part of the cosmics cosmological initial conditions package ) and plinger to be made available from these sites . _",
    ".... http://zeus.ncsa.uiuc.edu:8080/gc3_home_page.html          the gc3 home page    http://zeus.ncsa.uiuc.edu:8080/gc3_software_archive.html          the gc3 software archive    http://arcturus.mit.edu/gc3/          the gc3 - mit branch home page    http://arcturus.mit.edu/~bode/          paul bode 's home page ....",
    "[ [ section ] ] 1 .",
    "+ + +        the points are experimental measurements of the cmb anisotropy , from the cosapp package .",
    "the curve shows the output of a plinger run using standard cold dark matter initial conditions and normalized to the cobe @xmath6 ."
  ],
  "abstract_text": [
    "<S> this is a latex version containing most of an html - format technical paper submitted for supercomputing 95 . </S>",
    "<S> the preferred method of viewing is to point your www client to    .... http://arcturus.mit.edu/sc95/ ....    we have developed a code which links the primeval fluctuations in the early universe with those observable at the present time by integrating the coupled , linearized , einstein , boltzmann , and fluid equations governing the evolution of metric perturbations and the density fluctuations ; this is the most accurate treatment to date of both the physics and the numerical integration . </S>",
    "<S> the results are useful both for calculations of the cosmic microwave background ( cmb ) anisotropy and the linear power spectrum of matter fluctuations .    </S>",
    "<S> the serial code ( linger ) is highly efficient on vector machines . </S>",
    "<S> furthermore , this application is perfectly suited for coarse - grained parallelism . a portable , parallel implementation ( plinger ) using common message - passing libraries ( </S>",
    "<S> pvm , mpi , mpl , and pvme ) has been completed ; it achieves gflop rates on current parallel supercomputers such as the t3d and sp2 . </S>",
    "<S> linger and plinger will soon to be released for general use .    </S>",
    "<S> _ supercomputing time was provided by the cornell theory center and the pittsburgh supercomputing center . </S>",
    "<S> this work was supported by nsf grant asc-9318185 and nasa grant nag5 - 2816 , as part of the grand challenge cosmology consortium , gc3 . _    </S>",
    "<S> .1 in </S>"
  ]
}