{
  "article_text": [
    "graph transformation  @xcite is becoming increasingly popular in order to describe system behavior due to its graphical , declarative and formal nature .",
    "for example , it has been used to describe the operational semantics of domain specific visual languages ( dsvls ,  @xcite ) , taking the advantage that it is possible to use the concrete syntax of the dsvl in the rules which then become more intuitive to the designer .",
    "the main formalization of graph transformation is the so - called algebraic approach  @xcite , which uses category theory in order to express the rewriting step .",
    "prominent examples of this approach are the double  @xcite and single  @xcite pushout ( dpo and spo ) which have developed interesting analysis techniques , for example to check sequential and parallel independence between pairs of rules  @xcite or the calculation of critical pairs  @xcite .    frequently , graph transformation rules are equipped with _ application conditions _ ( acs )  @xcite , stating extra ( in addition to the left hand side ) positive and negative conditions that the host graph should satisfy for the rule to be applicable .",
    "the algebraic approach has proposed a kind of acs with predefined diagrams ( i.e. graphs and morphisms making the condition ) and quantifiers regarding the existence or not of matchings of the different graphs of the constraint in the host graph  @xcite .",
    "most analysis techniques for plain rules ( without acs ) have to be adapted then for rules with acs ( see e.g.  @xcite for critical pairs with negative acs ) .",
    "moreover , different adaptations may be needed for different kinds of acs .",
    "thus , a uniform approach to analyze rules with arbitrary acs would be very useful .    in previous works",
    "@xcite we developed a framework ( matrix graph grammars , mggs ) for the transformation of simple digraphs .",
    "simple digraphs and their transformation rules can be represented using boolean matrices and vectors .",
    "thus , the rewriting can be expressed using boolean operators only .",
    "one important point is that , as a difference from other approaches , we explicitly represent the rule dynamics ( addition and deletion of elements ) instead of only the static parts ( rule pre and postconditions ) .",
    "this point of view enables new analysis techniques , such as for example checking independence of a sequence of arbitrary length and a permutation of it , or to obtain the smallest graph able to fire a sequence . on the theoretical side",
    ", our formalization of graph transformation introduces concepts from many branches of mathematics like boolean algebra , group theory , functional analysis , tensor algebra and logics  @xcite .",
    "this wealth of available mathematical results opens the door to new analysis methods not developed so far , like sequential independence and explicit parallelism not limited to pairs of sequences , applicability , graph congruence and reachability . on the practical side , the implementations of our analysis techniques ,",
    "being based on boolean algebra manipulations , are expected to have a good performance .",
    "in mggs we do not only consider the elements that must be present in order to apply a production ( left hand side , lhs , also known as _ certainty part _ ) but also those elements that potentially prevent its application ( also known as _",
    "nihil _ or _",
    "nihilation part _ ) .",
    "refer to  @xcite in which , besides this , application conditions and graph constraints are studied for the mgg approach .",
    "the present contribution is a continuation of  @xcite where a comparison with related work can also be found .",
    "we shall tackle pre and postconditions , their transformation , the sequential version of these results and multidigraph rewriting .",
    "* paper organization*. section  [ sec : mggs ] gives an overview of matrix graph grammars .",
    "section  [ sec : previous ] revises application conditions as studied in  @xcite . postconditions and their equivalence to certain sequences are addressed in sec .",
    "[ sec : postconditions ] .",
    "section  [ sec : movingconditions ] tackles the transformation of preconditions into postconditions .",
    "the converse , more natural from a practical point of view , is also addressed .",
    "the transformation of restrictions is generalized in sec .",
    "[ sec : delocalization ] in which _ delocalization _  how to move application conditions from one production to another inside the same sequence  is also studied together with _",
    "variable nodes_. as an application of restrictions to mggs , sec .",
    "[ sec : fromsimpledigraphstomultidigraphs ] shows how to make mgg deal with multidigraphs instead of just simple digraphs without major modifications to the theory .",
    "the paper ends in sec .",
    "[ sec : conclusions ] with some conclusions , further research remarks and acknowledgements .",
    "we work with * simple digraphs * which we represent as @xmath0 , where @xmath1 is a boolean matrix for edges ( the graph _ adjacency _ matrix ) and @xmath2 a boolean vector for vertices or nodes . in the corresponding position of the vector . ]",
    "the left of fig .",
    "[ fig : example_graph ] shows a graph representing a production system made up of a machine ( controlled by an operator ) which consumes and produces pieces through conveyors .",
    "self loops in operators and machines indicate that they are busy .",
    "well - formedness of graphs ( i.e. absence of dangling edges ) can be checked by verifying the identity @xmath3 , where @xmath4 is the boolean matrix product , @xmath5 is the transpose of the matrix @xmath1 , @xmath6 is the negation of the nodes vector @xmath2 , and @xmath7 is an operation ( a norm , actually ) that results in the * or * of all the components of the vector .",
    "we call this property * compatibility * ( refer to  @xcite ) . note that @xmath8 results in a vector that contains a 1 in position @xmath9 when there is an outgoing edge from node @xmath9 to a non - existing node",
    ". a similar expression with the transpose of @xmath1 is used to check for incoming edges .",
    "a * type * is assigned to each node in @xmath10 by a function from the set of nodes @xmath11 to a set of types @xmath12 , @xmath13 .",
    "sets will be represented by @xmath14 . in fig .",
    "[ fig : example_graph ] types are represented as an extra column in the matrices , where the numbers before the colon distinguish elements of the same type .",
    "it is just a visual aid . for edges we use the types of their source and target nodes .",
    "a * typed simple digraph * is @xmath15 . from now on we shall assume typed graphs and shall drop the @xmath12 subindex .",
    "a * production * or grammar rule @xmath16 is a morphism of typed simple digraphs , which is defined as a mapping that transforms @xmath17 in @xmath18 with the restriction that the type of the image must be equal to the type of the source element .. ] more explicitly , @xmath19 being @xmath20 and @xmath21 partial injective mappings @xmath22 , @xmath23 such that @xmath24 and @xmath25 , where @xmath26 stands for domain , @xmath27 for edges and @xmath2 for vertices .",
    "a production @xmath16 is * statically represented * as @xmath28 .",
    "the matrices and vectors of these graphs are arranged so that the elements identified by morphism @xmath29 match ( this is called completion , see below ) .",
    "alternatively , a production adds and deletes nodes and edges , therefore they can be * dynamically represented * by encoding the rule s lhs together with matrices and vectors representing the addition and deletion of edges and nodes : for `` erase '' and @xmath30 for `` restock '' . ] @xmath31 , where @xmath32 contains the types of the new nodes , @xmath33 and @xmath34 are the deletion boolean matrix and vector , @xmath35 and @xmath36 are the addition boolean matrix and vector .",
    "they have a 1 in the position where the element is to be deleted or added , respectively .",
    "the output of rule @xmath29 is calculated by the boolean formula @xmath37 , which applies both to nodes and edges .",
    "is usually omitted in formulae , so @xmath38 with precedence of @xmath39 over @xmath40 . ]    * example*.@xmath41figure  [ fig : example_rule ] shows a rule and its associated matrices . the rule models",
    "the consumption of a piece ( pack ) by a machine ( mach ) input via the conveyor ( conv ) .",
    "there is an operator ( oper ) managing the machine .",
    "compatibility of the resulting graph must be ensured , thus the rule can not be applied if the machine is already busy , as it would end up with two self loops which is not allowed in a simple digraph .",
    "this restriction of simple digraphs can be useful in this kind of situations and acts like a built - in negative application condition .",
    "later we will see that the _ nihilation matrix _ takes care of this restriction .",
    "@xmath42    in order to operate with the matrix representation of graphs of different sizes , an operation called *",
    "completion * adds extra rows and columns with zeros to matrices and vectors , and rearranges rows and columns so that the identified edges and nodes of the two graphs match .",
    "for example , in fig .",
    "[ fig : example_rule ] , if we need to operate @xmath43 and @xmath44 , completion adds a fourth @xmath45-row and fourth @xmath45-column to @xmath44 .",
    "no further modification is needed because the rest of the elements have the right types and are placed properly .    with the purpose of considering the elements in the host graph that disable a rule application",
    ", we extend the notation for rules with a new simple digraph @xmath46 , which specifies the two kinds of forbidden edges : those incident to nodes which are going to be erased and any edge added by the rule ( which can not be added twice , since we are dealing with simple digraphs ) .",
    "@xmath46 has non - zero elements in positions corresponding to newly added edges , and to non - deleted edges incident to deleted nodes .",
    "matrices are derived in the following order : @xmath47 .",
    "thus , a rule is _ statically _ determined by its lhs and rhs @xmath48 , from which it is possible to give a _ dynamic _",
    "definition @xmath49 , with @xmath50 and @xmath51 , to end up with a full specification including its _ environmental _ behavior @xmath52 .",
    "no extra effort is needed from the grammar designer because @xmath46 can be automatically calculated : @xmath53 , with @xmath54 .",
    "denotes the tensor or kronecker product , which sums up the covariant and contravariant parts and multiplies every element of the first vector by the whole second vector . ] the evolution of the nihilation matrix ( what elements can not appear in the rhs )  call it @xmath55  is given by the inverse of the production : @xmath56 .",
    "see  @xcite for more details .",
    "inspired by the dirac or bra - ket notation  @xcite we split the static part ( initial state , @xmath17 ) from the dynamics ( element addition and deletion , @xmath29 ) : @xmath57 .",
    "operators ( those to the right side of the bra - ket ) can be moved to the _ bra _ ( left hand side ) by using their adjoints .    *",
    "matching * is the operation of identifying the lhs of a rule inside a host graph . given a rule @xmath16 and a simple digraph @xmath58 ,",
    "any total injective morphism @xmath59 is a match for @xmath29 in @xmath58 , thus it is one of the ways of _ completing _ @xmath17 in @xmath58 . besides",
    ", we shall consider the elements that must not be present .",
    "given the grammar rule @xmath16 and the graph @xmath60 , @xmath61 is called a * direct derivation * with @xmath62 and result @xmath63 if the following conditions are satisfied :    1 .",
    "there exist total injective morphisms @xmath64 and @xmath65 with @xmath66 , @xmath67 .",
    "the match @xmath68 induces a completion of @xmath17 in @xmath58 .",
    "matrices @xmath69 and @xmath30 are then completed in the same way to yield @xmath70 and @xmath71 .",
    "the output graph is calculated as @xmath72 .",
    "the negation when applied to graphs alone ( not specifying the nodes ) ",
    "e.g. @xmath73 in the first condition above  will be carried out just on edges .",
    "notice that in particular the first condition above guarantees that @xmath17 and @xmath46 will be applied to the same nodes in the host graph @xmath58 .    in direct derivations _ dangling edges _ can occur because the nihilation matrix only considers edges incident to nodes appearing in the rule s lhs and not in the whole host graph . in mgg",
    "an operator @xmath74 takes care of dangling edges which are deleted by adding a preproduction ( known as @xmath75production ) before the original rule .",
    "refer to  @xcite .",
    "thus , rule @xmath29 is transformed into the sequence @xmath76 , where @xmath77 deletes the dangling edges and @xmath29 remains unaltered .",
    "there are occasions in which two or more productions should be matched to the same nodes .",
    "this is achieved with the * marking operator * @xmath78 introduced in chap .  6 in  @xcite . a grammar rule and its associated",
    "@xmath79-production is one example and we shall find more in future sections .    in  @xcite",
    "some analysis techniques for mggs have been developed which we shall skim through .",
    "one important feature of mgg is that sequences of rules can be analyzed independently to some extent of any host graph .",
    "a rule * sequence * is represented by @xmath80 where application is from right to left , i.e. @xmath81 is applied first . for its analysis , the sequence is completed by identifying the nodes across rules which are assumed to be mapped to the same node in the host graph .",
    "once the sequence is completed , sequence * coherence *  @xcite allows us to know if , for the given identification , the sequence is potentially applicable , i.e. if no rule disturbs the application of those following it . the formula for coherence results in a matrix and a vector ( which can be interpreted as a graph ) with the problematic elements .",
    "if the sequence is coherent , both should be zero ; if not , they contain the problematic elements .",
    "a coherent sequence is * compatible * if its application produces a simple digraph .",
    "that is , no dangling edges are produced in intermediate steps .    given a completed sequence ,",
    "the * minimal initial digraph * ( mid ) is the smallest graph that permits the application of such sequence .",
    "conversely , the * negative initial digraph * ( nid ) contains all elements that should not be present in the host graph for the sequence to be applicable . in this way , the nid is a graph that should be found in @xmath82 for the sequence to be applicable ( i.e. none of its edges can be found in @xmath58 ) . see sec .  6 in  @xcite or chaps .  5 and  6 in  @xcite",
    ".    other concepts we developed aim at checking * sequential independence * ( same result ) between a sequence and a permutation of it .",
    "* g - congruence * detects if two sequences , one permutation of the other , have the same mid and nid .",
    "it returns two matrices and two vectors , representing two graphs which are the differences between the mids and nids of each sequence , respectively .",
    "thus if zero , the sequences have the same mid and nid .",
    "two coherent and compatible completed sequences that are g - congruent are sequentially independent .",
    "see sec .  7 in  @xcite or chap .  7 in  @xcite",
    "in this section we shall brush up on application conditions ( acs ) as introduced for mgg in  @xcite with non - fixed diagrams and quantifiers . for the quantification , a full - fledged monadic second order logic formula is used .",
    "one of the contributions in  @xcite is that a rule with an ac can be transformed into ( sequences of ) plain rules by adding the positive information to the left hand side of the production and the negative to the nihilation matrix .",
    "a * diagram * @xmath83 is a set of simple digraphs @xmath84 and a set of partial injective morphisms @xmath85 with @xmath86 .",
    "the diagram @xmath83 is well defined if every cycle of morphisms commute .",
    "@xmath87 is a * graph constraint * where @xmath83 is a well defined diagram and @xmath88 a sentence with variables in @xmath89 and predicates @xmath90 and @xmath55 .",
    "see eqs .",
    "( [ eq : p ] ) and  ( [ eq : q ] ) .",
    "formulae are restricted to have no free variables except for the default second argument of predicates @xmath90 and @xmath55 , which is the host graph @xmath58 in which we evaluate the gc .",
    "gc formulae are made up of expressions about graph inclusions .",
    "the predicates @xmath90 and @xmath55 are given by : @xmath91 \\\\",
    "\\label{eq : q }    q(x^1 , x^2 ) & = \\exists e [ f(e , x^1 ) \\wedge f(e , x^2)],\\end{aligned}\\ ] ] where predicate @xmath92 states that element @xmath93 ( a node or an edge ) is in graph @xmath94 .",
    "predicate @xmath95 means that graph @xmath96 is included in @xmath97 .",
    "predicate @xmath98 asserts that there is a partial morphism between @xmath96 and @xmath97 , which is defined on at least one edge ( @xmath69 ranges over all edges ) .",
    "the notation ( syntax ) will be simplified by making the host graph @xmath58 the default second argument for predicates @xmath90 and @xmath55 . besides",
    ", it will be assumed that by default total morphisms are demanded : unless otherwise stated predicate @xmath90 is assumed .",
    "we take the convention that negations in abbreviations apply to the predicate ( e.g. @xmath99 \\equiv \\exists a [ \\overline{p}(a , g)]$ ] ) and not the negation of the graph s adjacency matrix .    * example*.@xmath41the gc in fig .",
    "[ fig : diagexample ] is satisfied if for every @xmath100 in @xmath58 it is possible to find a related @xmath101 in @xmath58 , i.e. its associated formula is @xmath102 $ ] , equivalent by definition to @xmath103 $ ] .",
    "nodes and edges in @xmath100 and @xmath101 are related through morphism @xmath104 in which the image of the machine in @xmath100 is the machine in @xmath101 . to enhance readability , each graph in the diagram",
    "has been marked with the quantifier given in the formula .",
    "the gc in fig .",
    "[ fig : diagexample ] expresses that each machine should have an output conveyor .",
    "@xmath42    given the rule @xmath16 with nihilation matrix @xmath46 , an * application condition * ac ( over the free variable @xmath58 ) is a gc satisfying :    1 .",
    "@xmath105 such that @xmath106 and @xmath107 .",
    "@xmath108 such that @xmath109 is the only free variable .",
    "3 .   @xmath88 must demand the existence of @xmath17 in @xmath58 and the existence of @xmath46 in @xmath73 .    for simplicity",
    ", we usually do not explicitly show the condition 3 in the formulae of acs , nor the nihilation matrix @xmath46 in the diagram which are existentially quantified before any other graph of the ac .",
    "notice that the rule s lhs and its nihilation matrix can be interpreted as the minimal ac a rule can have . for technical reasons addressed in sec .",
    "[ sec : movingconditions ] ( related to converting pre into postconditions ) we assume that morphisms @xmath110 in the diagram do not have codomain @xmath17 or @xmath46 .",
    "this is easily solved as we may always use their inverses due to @xmath110 s injectiveness .",
    "it is possible to embed arbitrary acs into rules by including the positive and negative conditions in @xmath17 and @xmath46 , respectively .",
    "intuitively : `` mgg + ac = mgg '' and `` mgg + gc = mgg '' . in  @xcite two basic operations are introduced :  * closure *  @xmath111  that transforms universal into existential quantifiers , and * decomposition *  @xmath112  that transforms partial morphisms into total morphisms .",
    "notice that a match is an existentially quantified total morphism .",
    "it is proved in  @xcite that any ac can be embedded into its corresponding direct derivation .",
    "this is achieved by transforming the ac into some sequences of productions .",
    "there are four basic types of acs / gcs .",
    "let @xmath113 be a graph constraint with diagram @xmath114 and consider the associated production @xmath115 .",
    "the case @xmath116 $ ] is just the matching of @xmath117 in the host graph @xmath58 .",
    "it is equivalent to the sequence @xmath118 , where @xmath119 has @xmath117 as lhs and rhs , so it simply demands its existence in @xmath58 .",
    "we introduce the operator @xmath120 that replaces @xmath29 by @xmath121 and leaves the diagram and the formula unaltered .",
    "if the formula @xmath122 $ ] is considered , we can reduce it to a sequence of matchings via the closure operator @xmath123 whose result is : @xmath124,\\end{aligned}\\ ] ] with @xmath125 , @xmath126 , is an isomorphism@xmath127 . ]",
    "@xmath128 and @xmath129 . is a maximal non - empty partial morphism with @xmath130 . ]",
    "this is equivalent to the sequence @xmath131 .",
    "if the application condition has formula @xmath132 $ ] , we can proceed by defining the composition operator @xmath133 with action : @xmath134,\\end{aligned}\\ ] ] where @xmath135 contains a single edge of @xmath117 and @xmath136 is the number of edges of @xmath117 .",
    "this is equivalent to the set of sequences @xmath137 .",
    "less evident are formulas of the form @xmath138 = \\forall a [ \\overline{a } ] $ ] .",
    "fortunately , operators @xmath111 and @xmath112 commute when composed so we can get along with the operator @xmath139 .",
    "the image of @xmath140 on such acs are given by : @xmath141.\\end{aligned}\\ ] ]    an ac is said to be * coherent * if it is not a contradiction ( false in all scenarios ) , * compatible * if , together with the rule s actions , produces a simple digraph , and * consistent * if @xmath142 host graph such that @xmath143 satisfies @xmath144 $ ] , written @xmath145 $ ] , if and only if @xmath146 $ ] , being @xmath147 is a total morphism@xmath148 .",
    "also , @xmath58 satisfies @xmath149 $ ] , written @xmath150 $ ] , if and only if @xmath151 $ ] .",
    "usually we shall abuse of the notation and write @xmath152 instead . for more details",
    ", please refer to  @xcite . ]",
    "to which the production is applicable .",
    "as acs can be transformed into equivalent ( sets of ) sequences , it is proved in  @xcite that coherence and compatibility of an ac is equivalent to coherence and compatibility of the associated ( set of ) sequence(s ) , respectively .",
    "also , an ac is consistent if and only if its equivalent ( set of ) sequence(s ) is applicable .",
    "besides , all results and analysis techniques developed for mgg can be applied to sequences with acs .",
    "some examples follow :    * as a sequence is applicable if and only if it is coherent and compatible ( see sec  6.4 in  @xcite ) then an ac is consistent if and only if it is coherent and compatible . *",
    "sequential independence allows us to delay or advance the constraints inside a sequence .",
    "as long as the productions do not modify the elements of the constraints , this is transformation of preconditions into postconditions .",
    "more on sec .",
    "[ sec : movingconditions ] . *",
    "initial digraph calculation solves the problem of finding a host graph that satisfies a given ac / gc .",
    "there are some limitations , though .",
    "for example it is necessary to limit the maximum number of nodes when dealing with universal quantifiers .",
    "this has no impact in some cases , for example when non - uniform mgg submodels are considered ( see _ nodeless mgg _ in  @xcite ) . *",
    "_ graph congruence _ characterizes sequences with the same initial digraph .",
    "therefore it can be used to study when two gcs / acs are equivalent for all morphisms or for some of them .",
    "summarizing , there are two basic results in  @xcite .",
    "first , it is always possible to embed an application condition into the lhs of the production or derivation .",
    "the left hand side @xmath17 of a production receives elements that must be found  @xmath153  and @xmath46 those whose presence is forbidden  @xmath154 .",
    "second , it is always possible to find a sequence or a set of sequences of plain productions whose behavior is equivalent to that of the production plus the application condition .",
    "in this section we shall introduce postconditions and state some basic facts about them analogous to those for preconditions .",
    "we shall enlarge the notation by appending a left arrow on top of the conditions to indicate that they are preconditions and an upper right arrow for postconditions .",
    "examples are @xmath155 for a precondition and @xmath156 for a postcondition .",
    "if it is clear from the context , arrows will be omitted .",
    "[ def : prepostcondition ] an application condition set on the lhs of a production is known as a _",
    "precondition_. if it is set on the rhs then it is known as a _",
    "postcondition_.    operators @xmath157 and @xmath158 are defined similarly for postconditions .",
    "the following proposition establishes an equivalence between the basic formulae ( match , decomposition , closure and negative application condition ) and certain sequences of productions .",
    "[ prop : postconds ] let @xmath159 be a postcondition . then we can obtain a set of equivalent sequences to given basic formulae as follows : @xmath160 \\quad      \\longmapsto \\quad t_a\\left(p\\right ) = id_a ; p \\\\",
    "\\label{eq : closure }      \\textrm{(closure ) } \\quad      \\mathfrak{f } & = \\nexists a [ \\overline{a } ] \\quad      \\longmapsto \\quad \\widecheck{t}_a\\left(p\\right ) = id_{a^1 } ;      \\ldots ; id_{a^m } ; p \\\\",
    "\\label{eq : decomp }      \\textrm{(decomposition ) } \\quad       \\mathfrak{f } & = \\exists a [ \\overline{a } ] \\quad \\longmapsto      \\quad \\widehat{t}_a\\left(p\\right ) = \\left\\ { \\overline{id}_{a_i } ;        p \\right\\}_{i = 1 , \\ldots , n } \\\\",
    "\\label{eq : postnac } \\textrm{(nac ) } \\quad \\mathfrak{f }      & = \\nexists a [ a ] \\quad \\longmapsto \\quad       \\widetilde{t}_a \\left ( p \\right ) = \\left\\ {        \\overline{id}_{a^1_{i_1 } } ; \\ldots ;        \\overline{id}_{a^m_{i_m } } ; p \\right\\}_{i_j \\in \\{1 , \\ldots , n\\ } ,      j \\in \\{1 , \\ldots , m\\ } }    \\end{aligned}\\ ] ] where @xmath93 is the number of potential matches of @xmath117 in the image of the host graph , @xmath136 is the number of edges in @xmath117 and @xmath161 asks for the existence of @xmath117 in the complement of the image of the host graph .    _",
    "+ @xmath41 for the first case ( match ) , the ac states that an additional graph @xmath117 has to be found in the image of the host graph .",
    "this is easily achieved by applying @xmath119 to the image of @xmath17 , i.e. by considering @xmath162 .",
    "the elements in @xmath117 are related to those in @xmath18 according to the identifications in a morphism @xmath163 that has to be given in the diagram of the postcondition . in the four cases considered in the proposition we can move from composition to concatenation by means of the marking operator @xmath78 .",
    "recall that @xmath78 guarantees that the identifications in @xmath163 are preserved .",
    "the second case ( closure ) is very similar .",
    "we have to verify all potential appearances of @xmath117 in the image of the host graph because @xmath164 = \\forall a [ a]$ ] .",
    "we proceed as in the first case but this time with a finite number of compositions : @xmath165 .    for decomposition , @xmath117",
    "is not found in the host graph if for some matching there is at least one missing edge .",
    "it is thus similar to matching but for a single edge .",
    "the way to proceed is to consider the set of sequences that appear in eq .",
    "( [ eq : decomp ] ) .",
    "negative application conditions ( nacs ) are the composition of eqs .",
    "( [ eq : closure ] ) and  ( [ eq : decomp ] ) .",
    "@xmath42    one of the main points of the techniques available for preconditions is to analyze rules with acs by translating them into sequences of flat rules , and then analyzing the sequences of flat rules instead .",
    "[ th : reductionpost ] any well - defined postcondition can be reduced to the study of the corresponding set of sequences .    _",
    "+ @xmath41the proof follows that of th .  4.1 in  @xcite and is included here for completeness sake",
    ". let the depth of a graph for a fixed node @xmath166 be the maximum over the shortest path ( to avoid cycles ) starting in any node different from @xmath166 and ending in @xmath166 .",
    "the depth of a graph is the maximum depth for all its nodes .",
    "notice that the depth is @xmath167 if and only if @xmath168 in the diagram are unrelated",
    ". we shall apply induction on the depth of the ac .",
    "a diagram @xmath83 is a graph where nodes are digraphs @xmath135 and edges are morphisms @xmath169 .",
    "there are @xmath170 possibilities for depth @xmath167 in a ac made up of a single element @xmath117 , summarized in table  [ tab : possibilitiessinglecase ] .",
    "( 1 * ) & @xmath171 $ ] & ( 5 * ) & @xmath172 $ ] & ( 9 * ) & @xmath173 $ ] & ( 13 * ) & @xmath174 $ ] +    ( 2 * ) & @xmath175 $ ] & ( 6 * ) & @xmath176 $ ] & ( 10 * ) & @xmath177 $ ] & ( 14 * ) & @xmath178 $ ] +    ( 3 * ) & @xmath179 $ ] & ( 7 * ) & @xmath180 $ ] & ( 11 * ) & @xmath181 $ ] & ( 15 * ) & @xmath182 $ ] +    ( 4 * ) & @xmath183 $ ] & ( 8 * ) & @xmath184 $ ] & ( 12 * ) & @xmath185 $ ] & ( 16 * ) & @xmath186 $ ] +    elements in the same row for each pair of columns are related using equalities @xmath187 = \\forall a[\\overline{a}]$ ] and @xmath188 = \\exists a[\\overline{a}]$ ] , so it is possible to reduce the study to cases ( 1 * )  ( 4 * ) and ( 9 * ) ",
    "identities @xmath189 and @xmath190 reduce ( 9 * ) ",
    "( 12 * ) to formulae ( 1 * )  ( 4 * ) : @xmath191 = \\exists",
    "a\\left[p(a ,      \\overline{g})\\right ] & , \\ ; \\exists a [ q(a ) ] = \\exists    a\\left[\\overline{p}(a , \\overline{g})\\right ] \\nonumber \\\\",
    "\\nexists a [ q(a ) ] = \\nexists a\\left[\\overline{p}(a ,      \\overline{g})\\right ] & , \\ ; \\nexists a [ \\overline{q}(a ) ] = \\nexists    a\\left[p(a , \\overline{g})\\right ] .",
    "\\nonumber\\end{aligned}\\ ] ]    proposition  [ prop : postconds ] considers the four basic cases which correspond to ( 1 * )  ( 4 * ) in table  [ tab : possibilitiessinglecase ] , showing that in fact they can all be reduced to matchings in the image of the host graph , i.e. to  ( 1 * ) in table  [ tab : possibilitiessinglecase ] , verifying the theorem .",
    "now we move on to the induction step which considers combinations of quantifiers .",
    "well - definedness guarantees independence with respect to the order in which elements @xmath135 in the postcondition are selected . when there is a universal quantifier @xmath192 , according to eq .",
    "( [ eq : closure ] ) , elements of @xmath117 are replicated as many times as potential instances of @xmath117 can be found in the host graph . in order to continue the procedure we have to clone the rest of the diagram for each replica of @xmath117 , except those graphs which are existentially quantified before @xmath117 in the formula .",
    "that is , if we have a formula @xmath193 when performing the closure of @xmath117 , we have to replicate @xmath194 as many times as @xmath117 , but not @xmath195 .",
    "moreover @xmath195 has to be connected to each replica of @xmath117 , preserving the identifications of the morphism @xmath196 .",
    "more in detail : when closure is applied to @xmath117 , we iterate on all graphs @xmath197 in the diagram .",
    "there are three possibilities :    * if @xmath197 is existentially quantified after @xmath117 ",
    "@xmath198  then it is replicated as many times as @xmath117 .",
    "appropriate morphisms are created between each @xmath135 and @xmath199 if a morphism @xmath200 existed .",
    "the new morphisms identify elements in @xmath135 and @xmath199 according to @xmath163 .",
    "this permits finding different matches of @xmath197 for each @xmath135 , some of which can be equal . in the image of the host graph but only one of @xmath197 ,",
    "then the three replicas of @xmath195 are matched to the same part of @xmath201 . ] * if @xmath197 is existentially quantified before @xmath117 ",
    "@xmath202  then it is not replicated , but just connected to each replica of @xmath117 if necessary .",
    "this ensures that a unique @xmath197 has to be found for each @xmath135 .",
    "moreover , the replication of @xmath117 has to preserve the shape of the original diagram .",
    "that is , if there is a morphism @xmath203 then each @xmath204 has to preserve the identifications of @xmath163 ( this means that we take only those @xmath135 which preserve the structure of the diagram ) . *",
    "if @xmath197 is universally quantified ( no matter if it is quantified before or after @xmath117 ) , again it is replicated as many times as @xmath117 .",
    "afterwards , @xmath197 will itself need to be replicated due to its universality .",
    "the order in which these replications are performed is not relevant as @xmath205 .",
    "@xmath42    previous theorem and the corollaries that follow heavily depend on the host graph and its image ( through matching ) so analysis techniques developed so far in mgg which are independent of the host graphs can not be applied .",
    "the `` problem '' is the universal quantifier .",
    "we can consider the initial digraph and dispose to some extent of the host graph and its image .",
    "this is related to the fact ( sec .",
    "[ sec : movingconditions ] ) that it is possible to transform postconditions into equivalent preconditions .",
    "two applications of th .",
    "[ th : reductionpost ] are the following corollaries that characterize coherence , compatibility and consistency of postconditions .",
    "[ cor : equivpostac_seqs ] a postcondition is coherent if and only if its associated ( set of ) sequence(s ) is coherent .",
    "also , it is compatible if and only if its associated ( set of ) sequence(s ) is compatible and it is consistent if and only if its associated ( set of ) sequence(s ) is applicable .",
    "[ cor : postcondconscohcomp ] a postcondition is consistent if and only if it is coherent and compatible .    * * example.**@xmath41let s consider the diagram in fig .",
    "[ fig : final_example_gc ] with formula @xmath206 $ ] .",
    "the postcondition states that if an operator is connected to a machine , such machine is busy .",
    "the formula has an implication so it is not possible to directly generate the set of sequences because the postcondition also holds when the left of the implication is false .",
    "the closure operator @xmath111 reduces the postcondition to existential quantifiers , which is represented to the right of the figure .",
    "the resulting modified formula would be @xmath207 $ ] .",
    "once the formula has existentials only , we manipulate it to get rid of implications .",
    "thus , we have @xmath208 = \\exists a^0_1 a^0_2 a^1_1 a^1_2 [ ( \\overline{a^0_1 } \\wedge \\overline{a^1_2 } ) \\vee ( \\overline{a^0_1 } \\wedge a^1_2 ) \\vee ( a^1_1 \\wedge \\overline{a^0_2 } ) \\vee ( a^1_1 \\wedge a^1_2)]$ ] .",
    "this leads to a set of four sequences : @xmath209 .",
    "thus , the graph @xmath201 and the production satisfy the postcondition if and only if some sequence in the set is applicable to @xmath201 .",
    "@xmath42    something left undefined is the order of productions @xmath210 and @xmath211 in the sequences .",
    "consistency does not depend on the ordering of productions  as long as the first to be applied is production @xmath29  because productions @xmath212 ( and their negation ) are sequentially independent ( they do not add nor delete any edge or node ) . if they are not sequentially independent then there exists at least one inconsistency .",
    "this inconsistency can be detected using previous corollaries independently of the order of the productions .",
    "in this section we give two different proofs that it is possible to transform preconditions into equivalent postconditions and back again . the first proof ( sketched )",
    "makes use of category theory while the second relies on the characterizations of coherence , g - congruence and compatibility . to ease exposition",
    "we shall focus on the certainty part only as the nihilation part would follow using the inverse of the production",
    ".    we shall start with a case that can be addressed using equations    , th .",
    "[ th : reductionpost ] and cor .",
    "[ cor : equivpostac_seqs ] : when the transformed postcondition for a given precondition does not change .",
    "the question of whether it is always possible to transform a precondition into a postcondition  and back again  in this restricted case would be equivalent to asking for sequential independence of the production @xmath29 and the identities @xmath212 or @xmath213 : @xmath214 where the sequence to the left of the equality corresponds to a precondition and the sequence to the right corresponds to its equivalent postcondition .",
    "in general the production may act on elements that appear in the diagram of the precondition , spoiling sequential independence .",
    "left and center of fig .",
    "[ fig : preposttrans ]  in which the first basic ac ( match ) is considered  suggest that the pre - to - post transformation is a categorical pushout is a pushout where @xmath29 , @xmath17 , @xmath215 , @xmath18 and @xmath155 are known and @xmath156 , @xmath216 and @xmath215 need to be calculated . ] in the category of simple digraphs and partial morphisms .",
    "theorem  [ th : reductionpost ] proves that any postcondition can be reduced to the match case . besides",
    ", we can trivially consider total morphisms ( instead of partial ones ) by restricting the domain and the codomain of @xmath29 to the nodes in @xmath155 .",
    "for the post - to - pre transformation we can either use pullbacks or pushouts plus the inverse of the production involved .    to see that precondition satisfaction is equivalent to postcondition satisfaction using category theory , we should check that the different pushouts can be constructed ( @xmath217 , etcetera ) and that @xmath218 and @xmath219 ( refer to fig .  [ fig : preposttrans ] ) .",
    "although some topics remain untouched such as dangling edges , we shall not carry on with category theory .",
    "* example*.@xmath41let be given the precondition @xmath155 to the left of fig .",
    "[ fig : pre2postsimpleex ] with formula @xmath220 $ ] . to calculate its associated postcondition",
    "we can apply the production to @xmath155 and obtain @xmath156 , represented also to the left of the same figure .",
    "notice however that it is not possible to fing a match of @xmath17 in @xmath155 because of node @xmath221 .",
    "one possible solution is to consider @xmath222 and restrict the production to those common elements .",
    "this is done to the right of fig .",
    "[ fig : pre2postsimpleex ] @xmath42    [ th : prepostpre ] any consistent precondition is equivalent to some consistent postcondition and vice versa .    _",
    "proof _ + @xmath41for the post - to - pre transformation roles of @xmath29 and @xmath223 are interchanged so we shall address only the pre - to - post case .",
    "it is enough to study a single @xmath117 in the diagram as the same procedure applies mechanically ( th .",
    "4.1 transforms any precondition into a sequence of productions ) .",
    "also , it suffices to state the result for @xmath119 because @xmath161 is similar but the evolution depends on @xmath223 .",
    "finally , we shall assume that @xmath29 and @xmath119 are not sequentially independent .",
    "recall that @xmath58-congruence guarantees sameness of the initial digraph , which is what the sequence demands on the host graph .",
    "therefore , all we have to do is to use @xmath58-congruence to check the differences in the two sequences : @xmath224 however , before that we need to guarantee coherence and compatibility of both sequences ( see the hypothesis of th .  4 in  @xcite ) .",
    "coherence gives rise to the following equation : @xmath225 where @xmath69 and @xmath30 correspond to @xmath29 , @xmath226 to @xmath227 and @xmath228 to @xmath229 .",
    "fortunately , @xmath212 is a production that does nothing , so from the dynamical point of view any conflict should come from @xmath29 , i.e. @xmath230 which has been used in the implication of eq .",
    "( [ eq:3 ] ) .    by consistency",
    "we have that @xmath231 so eq .  ( [ eq:3 ] ) will be fulfilled if the postcondition is the precondition but erasing the elements that the production deletes .",
    "a similar reasoning for the nihil part tells us that we should add to the postcondition all those elements added by the production .",
    "compatibility can only be ruined by dangling edges . in  sec .",
    "6.1 in  @xcite dangling edges are deleted transforming the production via the opeartor @xmath74 .",
    "this is proved to be equivalent to defining a sequence by appending a so - called @xmath79-production .",
    "in essence the @xmath79-production just deletes any dangling edge , thus keeping compatibility .",
    "this very same procedure can be applied now : @xmath232    according to prop .  5 and th .  4 in  @xcite ,",
    "two compatible and coherent sequences are @xmath58-congruent if the following equation ( adapted to our case ) is fulfilled : @xmath233 we have that @xmath234 . also , @xmath235 because @xmath227 acts on the certainty part and @xmath236 ( see e.g. prop .",
    "4.1.4 in  @xcite ) .",
    "we are left with @xmath237 which is guaranteed by compatibility : once @xmath227 is transformed into @xmath238 in eq .",
    "( [ eq:7 ] ) there can not be any potential dangling edge , except those to be deleted by @xmath29 in the last step . @xmath42    it is worth stressing the fact that the transformation between pre and postconditions preserve consistency of the application condition .",
    "we have seen in this section that @xmath29 not only acts on @xmath17 but on the whole precondition .",
    "we can therefore extend the notation : @xmath239    pre - to - post and post - to - pre transformations can affect the diagram and the formula . see the example below .",
    "there are two clear cases :    * the application condition requires the graph to appear and the production deletes all its elements . *",
    "the application condition requires the graph not to appear and the production adds all its elements .    for a given application condition ac it is not necessarily true that @xmath240 because some new elements may be added and some obsolete elements discarded .",
    "what we will get is an equivalent condition adapted to @xmath29 that holds whenever @xmath117 holds and fails to be true whenever @xmath117 is false .",
    "* example*.@xmath41 in fig .",
    "[ fig : pre2postex ] there is a very simple transformation of a precondition into a postcondition through morphism @xmath241 .",
    "the associated formula to the precondition @xmath155 that we shall consider is @xmath220 $ ] .",
    "the production deletes two arrows and adds a new one .",
    "the overall effect is reverting the direction of the edge between nodes @xmath167 and @xmath242 and deleting the self - loop in node @xmath167 .",
    "notice that @xmath68 can not match node @xmath242 to @xmath243 in @xmath58 because of the edge @xmath244 in the application condition .",
    "suppose we had a ( redundant ) graph @xmath195 made up of a single node @xmath167 with a self loop in the precondition and with formula @xmath245 $ ] .",
    "the formula in the postcondition would still be @xmath246 $ ] .    the opposite transformation , from postcondition into precondition ,",
    "can be obtained by reverting the arrow , i.e. through @xmath247 .",
    "more general schemes can be studied applying the same principles .",
    "let @xmath248 .",
    "if a pre - post - pre transformation is carried out , we will have @xmath249 because edge ( 2,1 ) would be added to @xmath155 .",
    "however , it is true that @xmath250 .",
    "note that in fact @xmath227 and @xmath29 are sequentially independent if we limit ourselves to edges , so it would be possible to simply move the precondition to a postcondition as it is .",
    "nonetheless , we have to consider nodes 1 and 2 as the common parts between @xmath17 and @xmath155 .",
    "this is the same kind of restriction as the one illustrated in fig .",
    "[ fig : pre2postsimpleex ] .",
    "@xmath42    if the pre - post - pre transformation is thought of as an operator @xmath251 acting on application conditions , then it fulfills @xmath252 where @xmath212 is the identity .",
    "the same would also be true for a post - pre - post transformation .    a possible interpretation of eq .",
    "is that the definition of the application condition can vary from the _ natural _ one , according to the production under consideration .",
    "pre - post - pre or post - pre - post transformations adjust application conditions to the corresponding production .    when defining diagrams some `` practical problems '' may turn up .",
    "for example , if the diagram @xmath253 is considered then there are two potential problems :    1 .",
    "the direction in the arrow @xmath254 is not the natural one .",
    "nevertheless , injectiveness allows us to safely revert the arrow , @xmath255 .",
    "even though we only formally state @xmath256 and @xmath257 , other morphisms naturally appear and need to be checked out , e.g. @xmath258 .",
    "new morphisms should be considered if they relate at least one element .",
    "graphs @xmath135 can be identified as the complete graph @xmath259 , in which nodes are graphs @xmath135 and morphisms are @xmath169 . whether this is a directed graph or not is a matter of taste ( morphisms are injective ) . ]",
    "in this section we touch on _ delocalization _ of graph constraints and application conditions as well as their equivalence . also , we shall pave the way to multidigraph rewriting to be studied in detail in sec .",
    "[ sec : fromsimpledigraphstomultidigraphs ] .",
    "let @xmath260 be a sequence of productions with their corresponding acs .",
    "we have seen in th .",
    "[ th : reductionpost ] that preconditions and postconditions are equivalent and in th .",
    "[ th : prepostpre ] that they can be transformed into sequences of productions . as a precondition in @xmath261 is the same as a postcondition in @xmath262 , we see that acs can be moved arbitrarily inside a sequence .",
    "similarly , constraints set on the intermediate states of a derivation can be moved among them .",
    "a graph constraint gc set in the initial state @xmath58 to which a production @xmath29 is going to be applied is equivalent to the precondition @xmath263.\\ ] ] if the gc is set on the final state @xmath264 to which the production @xmath29 has been applied , there is an equivalent postcondition : @xmath265.\\ ] ] in both cases the diagrams are given by the lhs or the rhs plus the diagram of the graph constraint .",
    "we call this property of application conditions and graph constraints _ delocalization_.    we shall now address variable nodes which will be used to enhance mgg functionality to deal with multidigraphs .",
    "graph transformation with variables is studied in  @xcite .",
    "we shall summarize the proposal in  @xcite and propound an alternative way to close the section .",
    "if instead of nodes of fixed type variable , types are allowed we get a so called _",
    "graph pattern_. a _ rule scheme _ is just a production in which graphs are graph patterns .",
    "a _ substitution function _",
    "@xmath266 specifies how variable names taking place in a production are substituted . a rule scheme @xmath29 is instantiated via substitution functions producing a particular production .",
    "for example , for substitution function @xmath266 we get @xmath267 .",
    "the set of production instances for @xmath29 is defined as the set @xmath268 @xmath266 is a substitution@xmath269 .",
    "the _ kernel _ of a graph @xmath58 , @xmath270 , is defined as the graph resulting when all variable nodes are removed .",
    "it might be the case that @xmath271 .",
    "the basic idea is to reduce any rule scheme to a set of rule instances .",
    "note that it is not possible in general to generate @xmath272 because this set can be infinite .",
    "the way to proceed is not difficult :    1 .   find a match for the kernel of @xmath17 .",
    "2 .   induce a substitution @xmath266 such that the match for the kernel becomes a full match @xmath273 .",
    "3 .   construct the instance @xmath274 and apply @xmath267 to get the direct derivation @xmath275 .    as an alternative",
    ", we may extend the concept of type assignment .",
    "recall from sec .",
    "[ sec : mggs ] that types are assigned by a function from the set of nodes @xmath11 of a simple digraph @xmath58 to some fixed set @xmath12 of types , @xmath276 .",
    "instead , we shall define @xmath277 where @xmath278 is the power set of @xmath12 except for the empty set because we do not permit nodes without types .",
    "when two matrices are operated , the types of a fixed node will be the intersection of the nodes operated .",
    "for example , suppose that we * and * two matrices @xmath279 and that the ( set of ) nodes associated to the elements @xmath280 and @xmath281 are @xmath282 and @xmath283 , respectively .",
    "then , @xmath284 .",
    "the operation would not be allowed in case @xmath285 .",
    "* example*.@xmath41 let a type of nodes be represented by squares ( call them _ multinodes _ ) and the rest ( call them _ simple nodes _ ) by colored circles .",
    "the set of types @xmath12 is split into two : multinodes and simple nodes .",
    "let s consider the graph constraint @xmath286 , with @xmath287 the diagram depicted in fig .",
    "[ fig : simplifieddiagram2 ] made up of the graphs @xmath100 and @xmath101 , along with the formula @xmath288 $ ] .",
    "this graph constraint is `` edges must connect nodes and multinodes alternatively but no edge is allowed to be incident to two multinodes or to two simple nodes , including self - loops '' .    in the graph @xmath100 of fig .",
    "[ fig : simplifieddiagram2 ] , @xmath289 and @xmath290 represent variable nodes while @xmath280 and @xmath281 in @xmath101 have a fixed type .",
    "we may think of @xmath280 and @xmath281 as variable nodes whose set of types has a single element .",
    "in this section we show how mgg can deal with multidigraphs ( directed graphs allowing multiple parallel edges ) just by considering variable nodes . at first sight",
    "this might seem a hard task as mgg heavily depends on adjacency matrices .",
    "adjacency matrices are well suited for simple digraphs but can not cope with parallel edges .",
    "this section can be thought of as a _ theoretical application _ of graph constraints and application conditions to matrix graph grammars .",
    "the idea is not difficult : a special kind of node ( call it _ multinode _ in contrast to _ simple node _ ) associated to every edge in the graph is introduced , i.e. edges in the multidigraph are substituted by multinodes in a simple digraph representation of the multidigraph . graphically , multinodes will be represented by a filled square while normal nodes will appear as colored circles .",
    "see the example by the end of sec .",
    "[ sec : delocalization ]    operations previously specified on edges now act on multinodes : adding an edge is transformed into a multinode addition and edge deletion becomes multinode deletion .",
    "there are edges that link multinodes to their source and target simple nodes .",
    "some restrictions ( application conditions ) to be imposed on the actions that can be performed on multinodes exist , as well as on the shape or topology of permitted graphs ( graph constraints ) .",
    "not every possible graph with multinodes represents a multidigraph .",
    "* example*.@xmath41consider the simple production in fig .",
    "[ fig : simplemultigraph ] with two parallel edges between nodes @xmath167 and @xmath221 . as commented above ,",
    "multinodes are represented by square nodes while normal nodes are left unchanged .",
    "when @xmath29 deletes an edge , @xmath291 deletes a multinode .",
    "adjacency matrices for @xmath291 are :    @xmath292 \\qquad    r & = \\left [      \\begin{array}{cccccc }        \\vspace{-10pt }        0 & 0 & 0 & 1 & 1 & \\vert\\;\\ ; 1_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }        0 & 0 & 0 & 0 & 0 & \\vert\\;\\ ; 2_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }        0 & 0 & 0 & 0 & 0 & \\vert\\;\\ ; 3_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }        0 & 0 & 1 & 0 & 0 & \\vert\\;\\ ; a_2 \\\\",
    "\\vspace{-10pt }        0 & 1 & 0 & 0 & 0 & \\vert\\;\\ ; d_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }      \\end{array } \\right ] \\\\",
    "k = \\left [      \\begin{array}{ccccccc }        \\vspace{-10pt }        0 & 0 & 0 & 0 & 0 & 0 & \\vert\\;\\ ; 1_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }        0 & 0 & 0 & 1 & 0 & 0 & \\vert\\;\\ ; 2_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }        0 & 0 & 0 & 1 & 0 & 0 & \\vert\\;\\ ; 3_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }        1 & 1 & 0 & 1 & 1 & 1 & \\vert\\;\\ ; a_1 \\\\",
    "\\vspace{-10pt }        0 & 0 & 0 & 1 & 0 & 0 & \\vert\\;\\ ; a_2 \\\\",
    "\\vspace{-10pt }        0 & 0 & 0 & 1 & 0 & 0 & \\vert\\;\\ ; d_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }      \\end{array } \\right ] \\qquad    \\;\\;e & = \\left [      \\begin{array}{ccccccc }        \\vspace{-10pt }        0 & 0 & 0 & 1 & 0 & 0 & \\vert\\;\\ ; 1_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }        0 & 0 & 0 & 0 & 0 & 0 & \\vert\\;\\ ; 2_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }        0 & 0 & 0 & 0 & 0 & 0 & \\vert\\;\\ ; 3_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }        0 & 0 & 1 & 0 & 0 & 0 & \\vert\\;\\ ; a_1 \\\\",
    "\\vspace{-10pt }        0 & 0 & 0 & 0 & 0 & 0 & \\vert\\;\\ ; a_2 \\\\",
    "\\vspace{-10pt }        0 & 0 & 0 & 0 & 0 & 0 & \\vert\\;\\ ; d_{\\phantom{2 } } \\\\",
    "\\vspace{-10pt }      \\end{array } \\right ]   \\nonumber\\end{aligned}\\ ] ]    in a real situation , a development tool such as atom@xmath293 or agg and http://www.gratra.org/ for agg and some other tools .",
    "] should take care of all these representation issues .",
    "a user would see what appears to the left of fig .",
    "[ fig : simplemultigraph ] and not what is depicted to the right of the same figure .",
    "@xmath42    some restrictions on what a production can do to a multidigraph are necessary in order to obtain a multidigraph again .",
    "think for example the case in which after applying some production we get a graph in which there is an isolated multinode ( which would stand for an edge with no source nor target nodes ) .",
    "all we have to do is to find the properties that define one edge and impose them on multinodes as graph constraints :    1 .   a simple node ( resp . ,",
    "multinode ) can not be directly connected to another simple node ( resp . ,",
    "multinode ) .",
    "2 .   edges ( encoded as multinodes ) always have a simple node as source and a simple node as target .",
    "first condition above is addressed in the example of sec .",
    "[ sec : delocalization ] with graph constraint @xmath294 .",
    "see fig .",
    "[ fig : simplifieddiagram2 ]",
    ". the second condition can be encoded as another graph constraint @xmath295 .",
    "the diagram can be found in fig .  [",
    "fig : multidigraphgc2 ] and the formula is @xmath296 $ ] .",
    "[ th : multidigraph ] any multidigraph is isomorphic to some simple digraph @xmath58 together with the graph constraint @xmath297 .",
    "_ proof ( sketch ) _",
    "+ @xmath41a graph with multiple edges @xmath298 consists of disjoint finite sets @xmath2 of nodes and @xmath27 of edges and source and target functions @xmath299 and @xmath300 , respectively .",
    "function @xmath301 , @xmath302 , @xmath303 returns the node source @xmath304 for edge @xmath69 .",
    "we are considering multidigraphs because the pair function @xmath305 need not be injective , i.e. several different edges may have the same source and target nodes .",
    "we have digraphs because there is a distinction between source and target nodes .",
    "this is the standard definition found in any textbook .",
    "it is clear that any @xmath1 can be represented as a multidigraph @xmath58 satisfying @xmath306 .",
    "the converse also holds . to see it , just consider all possible combinations of two nodes and two multinodes and check that any problematic situation is ruled out by @xmath306 .",
    "induction finishes the proof.@xmath42    the multidigraph constraint @xmath306 must be fulfilled by any host graph .",
    "if there is a production @xmath16 involved , @xmath306 has to be transformed into an application condition over @xmath29 .",
    "in fact , the multidigraph constraint should be demanded both as precondition and postcondition .",
    "this is easily achieved by means of eqs .",
    "( [ eq:8 ] ) and  ( [ eq:9 ] ) .",
    "this section is closed analyzing what behavior we have for multidigraphs with respect to dangling edges . with the theory",
    "as developed so far , if a production specifies the deletion of a simple node then an @xmath79-production would delete any edge incident to this simple node , connecting it to any surrounding multinode .",
    "but restrictions imposed by mc do not allow this so any production with potential dangling edges can not be applied .    in order to automatically delete any potential multiple dangling edge",
    ", @xmath79-productions need to be restated by defining them at a multidigraph level , i.e. @xmath79-productions have to delete any potential `` dangling multinode '' .",
    "a new type of productions ( @xmath307-productions ) are introduced to get rid of annoying edges that would dangle when multinodes are also deleted by @xmath79-productions .",
    "we will not develop the idea in detail and will limit to describe the concepts . the way to proceed",
    "is to define the appropriate operator @xmath308 and redefine the operator @xmath74 .",
    "a production @xmath16 between multidigraphs that deletes one simple node @xmath309 may give rise to one @xmath79-production that deletes one or more multinodes @xmath310 ( those `` incident '' to @xmath309 not deleted by the grammar rule ) .",
    "this @xmath79-production can in turn be applied only if any edge incident to the @xmath310 s has already been erased , hence possibly provoking the appearance of one @xmath307-production .",
    "this process is depicted in fig .",
    "[ fig : spomultidigraph ] where , in order to apply production @xmath29 , productions @xmath77 and @xmath311 need to be applied in advance @xmath312    eventually , one could simply compose the @xmath307-production with its @xmath79-production , renaming it to @xmath79-production and defining it as the way to deal with dangling edges in case of multiple edges , fully recovering the standard behavior in mgg . as commented above",
    ", a potential user of a development tool such as atom@xmath293 would still see things as in the simple digraph case , with no need to worry about @xmath307-productions .",
    "another theoretical use of application conditions and graph constraints is the encoding of turing machines and boolean circuits using matrix graph grammars ( see  @xcite ) .",
    "however , they are not necessary for petri nets ( see chap .  10 in  @xcite ) .",
    "in the present contribution we have introduced preconditions and postconditions for mggs , proving that there is an equivalent set of sequences of plain rules to any given postcondition . besides , coherence , compatibility and consistency of postconditions have been characterized in terms of already known concepts for sequences .",
    "we have also proved that it is always possible to transform any postcondition into an equivalent precondition and vice versa .",
    "moreover , we have seen that restrictions are delocalized if a sequence is under consideration . an alternative way to that in  @xcite to tackle",
    "variable nodes has also been proposed .",
    "this allows us to extend mgg to cope with multidigraphs without major modifications to the theory .    in  @xcite",
    "there is an exhaustive comparison of the application conditions in mgg and other proposals .",
    "the main papers to the best of our knowledge that tackle this topic are  @xcite ( with the definition of acs ) , @xcite where gcs and acs are extended with nesting and satisfiability , and also  @xcite in which acs are generalized to arbitrary levels of nesting ( though restricted to trees ) .    for future work , we shall generalize already studied concepts in mgg for multidigraphs such as coherence , compatibility , initial digraphs , graph congruence , reachability , etcetera .",
    "our main interest , however , will be focused on complexity theory and the application of mgg to the study of complexity classes , * p * and * np * in particular .",
    "@xcite follows this line of research .",
    "corradini , a. , montanari , u. , rossi , f. , ehrig , h. , heckel , r. , lwe , m. 1999 . _ algebraic approaches to graph transformation - part i : basic concepts and double pushout approach_. in  @xcite , pp . : 163 - 246      ehrig , h. , heckel , r. , korff , m. , lwe , m. , ribeiro , l. , wagner , a. , corradini , a. 1999 . _ algebraic approaches to graph transformation - part ii : single pushout approach and comparison with double pushout approach .",
    "_ in  @xcite , pp .",
    ": 247 - 312 .",
    "de lara , j. , vangheluwe , h. 2004 .",
    "_ defining visual notations and their manipulation through meta - modelling and graph transformation_. journal of visual languages and computing",
    ". special section on `` domain - specific modeling with visual languages '' , vol 15(3 - 4 ) , pp .",
    ": 309 - 330 .",
    "elsevier science .",
    "prez velasco , p. p. , de lara , j. 2006 .",
    "_ towards a new algebraic approach to graph transformation : long version .",
    "_ tech . rep . of the school of comp .",
    "autnoma madrid . ` http://www.ii.uam.es/\\simjlara/investigacion/techrep_03_06.pdf ` .",
    "prez velasco , p. p. , de lara , j. 2007 .",
    "_ using matrix graph grammars for the analysis of behavioural specifications : sequential and parallel independence _ proc .",
    "prole07 , pp . : 11 - 26 .",
    ". notes theor .",
    "elsevier .",
    "prez velasco , p.",
    "_ matrix graph grammars : an algebraic approach to graph dynamics_. isbn 978 - 3639212556 .",
    "vdm verlag . also available as e - book at : ` http://www.mat2gra.info/ ` and ` arxiv:0801.1245v1 ` .",
    "prez velasco , p. p. , de lara , j. 2009 .",
    "_ a reformulation of matrix graph grammars with boolean complexes_. the electronic journal of combinatorics .",
    "vol 16(1 ) .",
    "available at : ` http://www.combinatorics.org/ ` ."
  ],
  "abstract_text": [
    "<S> in the matrix approach to graph transformation we represent _ simple _ digraphs and rules with boolean matrices and vectors , and the rewriting is expressed using boolean operations only . in previous works , we developed analysis techniques enabling the study of the applicability of rule sequences , their independence , stated reachability and the minimal digraph able to fire a sequence . </S>",
    "<S> see  @xcite for a comprehensive introduction . in  @xcite , </S>",
    "<S> graph constraints and application conditions ( so - called _ restrictions _ ) have been studied in detail . in the present contribution </S>",
    "<S> we tackle the problem of translating post - conditions into pre - conditions and vice versa . </S>",
    "<S> moreover , we shall see that application conditions can be moved along productions inside a sequence ( _ restriction delocalization _ ) . as a practical - theoretical application </S>",
    "<S> we show how application conditions allow us to perform multidigraph rewriting ( as opposed to simple digraph rewriting ) using matrix graph grammars .    </S>",
    "<S> * keywords : * matrix graph grammars , graph dynamics , graph transformation , restrictions , application conditions , preconditions , postconditions , graph constraints . </S>"
  ]
}