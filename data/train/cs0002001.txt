{
  "article_text": [
    "the stable model semantics by gelfond and lifschitz @xcite is one of the two most widely studied semantics for normal logic programs , the other one being the well - founded semantics by van gelder , ross and schlipf @xcite . among 2-valued semantics , the stable model semantics is commonly regarded as the one providing the correct meaning to the negation operator in logic programming .",
    "it coincides with the least model semantics on the class of horn programs , and with the well - founded semantics and the perfect model semantics on the class of stratified programs @xcite .",
    "in addition , the stable model semantics is closely related to the notion of a default extension by reiter @xcite .",
    "logic programming with stable model semantics has applications in knowledge representation , planning and reasoning about action .",
    "it was also recently proposed as a computational paradigm well suited for solving combinatorial optimization and constraint satisfaction problems @xcite .",
    "before we proceed , we will recall the definition of a stable model of a logic program , and some related terminology and properties .",
    "the reader is referred to @xcite for a more detailed treatment of the subject . in the paper",
    "we deal only with the propositional case . a logic program _",
    "rule _ is an expression @xmath10 of the form @xmath11 where @xmath12 , @xmath13s and @xmath14s are propositional atoms .",
    "the atom @xmath12 is called the _ head _ of @xmath10 and is denoted by @xmath15 .",
    "atoms @xmath13 and @xmath14 form the _ body _ of @xmath10 .",
    "the set @xmath16 is called the _ positive _ body of @xmath10 ( denoted by @xmath17 ) and the set @xmath18 is called the _ negative _ body of @xmath10 ( denoted by @xmath19 ) . a _ logic program _ is a collection of rules . for a logic program @xmath2 , by @xmath20 we denote the set of atoms occurring in its rules and by @xmath21",
    " the set of atoms appearing as the heads of rules in @xmath2 . we will also denote the _ size _ of @xmath2 , that is , the total number of occurrences of atoms in @xmath2 , by @xmath22 . throughout the paper we use @xmath23 to denote the number of atoms in a logic program @xmath2 , and @xmath7 to denote the size of @xmath2 .",
    "a set of atoms @xmath24 _ satisfies _ a rule @xmath10 if @xmath25 , or if @xmath26 , or if @xmath27 . a set of atoms",
    "@xmath28 is a _ model _ of a program @xmath2 if @xmath29 satisfies all rules of @xmath2 .    a logic program rule @xmath10 is called _ horn _",
    "if @xmath30 . a _ horn program _ is a program whose every rule is a horn rule .",
    "the intersection of two models of a horn program @xmath2 is a model of @xmath2 .",
    "since the set of all atoms is a model of @xmath2 , it follows that every horn program @xmath2 has a unique least model .",
    "we will denote this model by @xmath31 .",
    "the least model of a horn program @xmath2 can be constructed by means of the van emden - kowalski operator @xmath32 @xcite . given a horn program @xmath2 and a set of atoms @xmath33 , we define @xmath34 we also define @xmath35 since the operator @xmath32 is monotone , the sequence @xmath36 is monotone and its union yields the least model of a horn program @xmath2 .",
    "that is , @xmath37 if @xmath2 is finite , the sequence stabilizes after finitely many steps .    for a logic program rule @xmath10 , by @xmath38",
    "we denote the rule obtained from @xmath10 by eliminating all negated atoms from the body of @xmath10 .",
    "if @xmath2 is a logic program , we define @xmath39 .",
    "let @xmath2 be a logic program ( possibly with rules containing negated atoms ) .",
    "for a set of atoms @xmath28 we define the _ reduct _ of @xmath2 with respect to @xmath29 to be the program obtained by eliminating from @xmath2 each rule @xmath10 such that @xmath40 ( we call such rules _ blocked _ by @xmath29 ) , and by removing negated atoms from all other rules in @xmath2 .",
    "the resulting program is a horn program",
    ". we will denote it by @xmath41 . as a horn program",
    ", @xmath41 has the least model @xmath42 .",
    "if @xmath43 , @xmath29 is a _",
    "stable _ model of @xmath2 . clearly , if @xmath29 is a stable model of @xmath2 , @xmath44 . both",
    "the notion of the reduct and of a stable model are due to gelfond and lifschitz @xcite .    in the paper",
    "we restrict our attention to programs whose rules do not contain multiple positive occurrences of the same atom nor multiple negative occurrences of the same atom in the body .",
    "it is clear that adopting this assumption does not limit the generality of our considerations .",
    "repetitive occurrences can be eliminated in linear time ( in the size of the program ) and doing so does not affect stable models of the program .    if @xmath29 is a stable model of @xmath2 , each rule @xmath10 such that @xmath45 and @xmath46 ( that is , such that @xmath29 satisfies its body ) , is called a _ generating _ rule for @xmath29 . clearly , if @xmath29 is a stable model of @xmath2 , it is also a stable model of the program consisting of all rules in @xmath2 that are generating for @xmath29 .",
    "there are several ways to look at the search space of possible stable models of a program @xmath2 .",
    "the most direct way is to look for stable models by considering all candidate subsets of @xmath21 . for each candidate subset @xmath44",
    ", one can compute the corresponding reduct @xmath41 , its least model @xmath42 , and check the equality @xmath43 to decide whether @xmath29 is stable . an alternative way",
    "is to observe that stable models are determined by subsets of the set of atoms appearing negated in @xmath2 .",
    "indeed , let us denote this set by @xmath47 and let us consider sets @xmath28 and @xmath48 .",
    "let @xmath49 .",
    "then , @xmath29 is a stable model of @xmath2 if and only if @xmath50 , @xmath51 and @xmath52 .",
    "thus , the existence of stable models can be decided by considering subsets of @xmath47 .",
    "finally , one can consider the search space of all subsets of @xmath2 itself , and regard each such subset as a candidate for the set of generating rules of a stable model . indeed , if @xmath28 and @xmath53 , then @xmath29 is a stable model of @xmath2 if and only if @xmath54 , @xmath55 is the set of all generating rules for @xmath29 in @xmath2 and @xmath56 .",
    "the problem with the stable model semantics is that , even in the propositional case , reasoning with logic programs under the stable model semantics is computationally hard .",
    "it is well - known that deciding whether a finite propositional logic program has a stable model is np - complete @xcite .",
    "consequently , it is not at all clear that logic programming with the stable model semantics can serve as a practical computational tool .",
    "this issue can be resolved by implementing systems computing stable models and by experimentally studying the performance of these systems .",
    "several such projects are now under way .",
    "niemel and simons @xcite developed a system , _ smodels _ , for computing stable models of finite function symbol - free logic programs and reported very promising performance results .",
    "for some classes of programs , _ smodels _ decides the existence of a stable model in a matter of seconds even if an input program consists of tens of thousands of clauses .",
    "encouraging results on using _",
    "smodels _ to solve planning problems are reported in @xcite .",
    "another well - advanced system is deres @xcite , designed to compute extensions of arbitrary propositional default theories but being especially effective for default theories encoding propositional logic programs .",
    "finally , systems capable of reasoning with disjunctive logic programs were described in @xcite and @xcite .    however , faster implementations will ultimately depend on better understanding of the algorithmic aspects of reasoning with logic programs under the stable model semantics . in this paper",
    ", we investigate the complexity of deciding whether a finite propositional logic program has stable models of some restricted sizes . specifically , we study the following two problems ( @xmath57 stands for the number of rules in a logic program @xmath2 ) :    @xmath1 : :    ( large stable models ) given a finite propositional logic program    @xmath2 and an integer @xmath0 , decide whether there    is a stable model of @xmath2 of size at least    @xmath3 . @xmath4 : :    ( small stable models ) given a finite propositional logic program    @xmath2 and an integer @xmath0 , decide whether there    is a stable model of @xmath2 of size no more than    @xmath0",
    ".    inputs to the problems @xmath1 and @xmath4 are pairs @xmath58 , where @xmath2 is a finite propositional logic program and @xmath0 is a non - negative integer .",
    "problems of this type are referred to as _",
    "parametrized _ decision problems . by fixing a parameter ,",
    "a parameterized decision problem gives rise to its _ fixed - parameter _ version . in the case of problems @xmath1 and @xmath4 , by fixing @xmath0 we obtain the following two fixed - parameter problems ( @xmath0 is now no longer a part of input ) :    @xmath59 : :    given a finite propositional logic program @xmath2 , decide    whether @xmath2 has a stable model of size at least    @xmath60 .",
    "@xmath61 : :    given a finite propositional logic program @xmath2 , decide    whether @xmath2 has a stable model of size at most    @xmath0 .",
    "the problems @xmath1 and @xmath4 are np - complete .",
    "it follows directly from the np - completeness of the problem of existence of stable models @xcite .",
    "but fixing @xmath0 makes a difference !",
    "clearly , the fixed - parameter problems @xmath61 and @xmath59 can be solved in polynomial time ( unlike the problems @xmath4 and @xmath1 which , most likely , can not ) .",
    "indeed , consider a finite propositional logic program @xmath2 .",
    "then , there are @xmath62 subsets of @xmath20 ( in fact , as pointed out earlier , it is enough to consider subsets of @xmath21 or @xmath47 ) of cardinality at most @xmath0 ( we recall that in the paper @xmath23 stands for the number of atoms in @xmath2 ) . for each such subset @xmath29 , it can be checked in time linear in @xmath7  the size of @xmath2  whether @xmath29 is a stable model of @xmath2 .",
    "thus , one can decide whether @xmath2 has a stable model of size at most @xmath0 in time @xmath63 .",
    "similarly , there are only @xmath64 subsets of @xmath2 of size at least @xmath3 .",
    "each such subset is a candidate for the set of generating rules of a stable model of size at least @xmath3 ( and smaller subsets , clearly , are not ) .",
    "given such a subset @xmath65 , one can check in time @xmath66 whether @xmath65 generates a stable model for @xmath2 .",
    "thus , it follows that there is an algorithm that decides in time @xmath67 whether a logic program @xmath2 has a stable model of size at least @xmath3 .    while both algorithms are polynomial in the size of the program , their asymptotic complexity is expressed by the product of the size of a program and a polynomial of order @xmath0 in the number of atoms of the program or in the number of rules of the program . even for small values of @xmath0 ,",
    "say for @xmath68 , the functions @xmath69 and @xmath70 grow very fast with @xmath71 , @xmath72 and @xmath57 , and render the corresponding algorithms infeasible .",
    "an important question is whether algorithms for problems @xmath61 and @xmath59 exist whose order is significantly lower than @xmath0 , preferably , a constant independent of @xmath0 .",
    "the study of this question is the main goal of our paper .",
    "a general framework for such investigations was proposed by downey and fellows @xcite .",
    "they introduced the concepts of _ fixed - parameter tractability _ and _ fixed - parameter intractability _ that are defined in terms of a certain hierarchy of complexity classes known as the @xmath73 _",
    "hierarchy_.    in the paper , we show that the problem @xmath1 is fixed - parameter tractable and demonstrate an algorithm that for every fixed @xmath0 decides the problem @xmath59 in linear time  a significant improvement over the straightforward algorithm presented earlier .",
    "on the other hand , we demonstrate that the problem @xmath4 is much harder .",
    "we present an algorithm to decide the problems @xmath61 , for @xmath74 , that is asymptotically faster than the simple algorithm described above but the improvement is rather insignificant .",
    "our algorithm runs in time @xmath75 , an improvement only by the factor of @xmath23 .",
    "the difficulty in finding a substantially better algorithm is not coincidental .",
    "we provide evidence that the problem @xmath4 is _ fixed - parameter intractable_. this result implies it is unlikely that there is an algorithm to decide the problems @xmath61 whose running time would be given by a polynomial of order independent of @xmath0 .",
    "the study of fixed - parameter tractability of problems occurring in the area of nonmonotonic reasoning is a relatively new research topic .",
    "another paper that pursues this direction is @xcite .",
    "the authors focus there on parameters describing structural properties of programs and show that in some cases , fixing these parameters leads to polynomial algorithms .",
    "our paper is organized as follows . in section [ ifp ]",
    ", we recall basic concepts of the theory of fixed - parameter intractability by downey and fellows @xcite .",
    "the following two sections present the algorithms to decide the problems @xmath1 and @xmath4 , respectively .",
    "the next section focuses on the issue of fixed - parameter intractability of the problem @xmath4 and contains the two main results of the paper .",
    "the last section contains conclusions and open problems .",
    "this section recalls basic ideas of the work of downey and fellows on fixed - parameter intractability .",
    "the reader is referred to @xcite for a detailed treatment of this subject .    informally , a _",
    "parametrized _ decision problem is a decision problem whose inputs are pairs of items , one of which is referred to as a _",
    "parameter_. the graph colorability problem is an example of a parametrized problem .",
    "the inputs are pairs @xmath76 , where @xmath77 is an undirected graph and @xmath0 is a non - negative integer .",
    "the problem is to decide whether @xmath77 can be colored with at most @xmath0 colors .",
    "another example is the vertex cover problem in a graph .",
    "again , the inputs are graph - integer pairs @xmath76 and the question is whether @xmath77 has a vertex cover of cardinality @xmath0 or less .",
    "the problems @xmath4 and @xmath1 are also examples of parametrized decision problems .",
    "formally , a _ parametrized",
    "_ decision problem is a set @xmath78 , where @xmath79 is a fixed alphabet .    by selecting a concrete value @xmath80 of the parameter ,",
    "a parametrized decision problem @xmath81 gives rise to an associated _ fixed - parameter _",
    "problem @xmath82 .",
    "for instance , by fixing the value of @xmath0 to 3 , we get a fixed - parameter version of the colorability problem , known as 3-colorability . inputs to the 3-colorability problem are graphs and the question is to decide whether an input graph can be colored with 3 colors . clearly , the problems @xmath61 ( @xmath59 , respectively ) are fixed - parameter versions of the problem @xmath4 ( @xmath1 , respectively ) .",
    "the interest in the fixed - parameter problems stems from the fact that they are often computationally easier than the corresponding parametrized problems .",
    "for instance , the problems @xmath4 and @xmath1 are np - complete yet , as we saw earlier , their parametrized versions @xmath61 and @xmath59 can be solved in polynomial time .",
    "similarly , the vertex cover problem is np - complete but its fixed - parameter versions are in the class p. to see this , observe that to decide whether a graph has a vertex cover of size at most @xmath0 , where @xmath0 is a fixed value and not a part of an input , it is enough to generate all subsets with at most @xmath0 elements of the vertex set of a graph , and then check if any of them is a vertex cover .",
    "a word of caution is in order here .",
    "it is not always the case that fixed - parameter problems are easier .",
    "for instance , the 3-colorability problem is still np - complete .    as we already pointed out , the fact that a problem admits a polynomial - time solution does not necessarily mean that practical algorithms to solve it exist .",
    "an algorithm that runs in time @xmath83 , where @xmath84 is the size of the input , is hardly more practical than an algorithm with an exponential running time ( and may even be a worse choice in practice ) .",
    "the algorithms we presented so far to argue that the problems @xmath61 , @xmath59 and the fixed - parameter versions of the vertex cover problem are in p rely on searching through the space of @xmath85 possible solutions ( where @xmath84 is the number of atoms of a program , the number of rules of a program , or the number of vertices in a graph , respectively ) .",
    "thus , these algorithms are not practical , except for the very smallest values of @xmath0 .",
    "the key question is how fast those polynomial - time solvable fixed - parameter problems can really be solved . or , in other words , can one significantly improve over the brute - force approach ?    a technique to deal with such questions is provided by the fixed - parameter intractability theory of downey and fellows @xcite",
    ". a parametrized problem @xmath78 is _ fixed - parameter tractable _ if there exist a constant @xmath86 , an integer function @xmath87 and an algorithm @xmath88 such that @xmath88 determines whether @xmath89 in time @xmath90 ( @xmath91 stands for the length of a string @xmath92 )",
    ". the class of fixed - parameter tractable problems will be denoted by fpt . clearly , if a parametrized problem @xmath81 is in fpt , each of the associated fixed - parameter problems @xmath93 is solvable in polynomial time by an algorithm whose exponent does not depend on the value of the parameter @xmath94 .",
    "it is known ( see @xcite ) that the vertex cover problem is in fpt .",
    "there is substantial evidence to support a conjecture that some parametrized problems whose fixed - parameter versions are in p are not fixed - parameter tractable . to study and compare complexity of parametrized problems downey and",
    "fellows proposed the following notion of reducibility . a parametrized problem",
    "@xmath81 can be _ reduced _ to a parametrized problem @xmath95 if there exist a constant @xmath86 , an integer function @xmath96 and an algorithm @xmath88 that to each instance @xmath97 of @xmath81 assigns an instance @xmath98 of @xmath95 such that    1 .",
    "@xmath99 depends upon @xmath100 and @xmath94 and @xmath101 depends upon @xmath94 only , 2 .",
    "@xmath88 runs in time @xmath102 , 3 .",
    "@xmath89 if and only if @xmath103 .",
    "downey and fellows also defined a hierarchy of complexity classes called the _ w hierarchy _ : @xmath104 } \\subseteq { \\rm w[2 ] } \\subseteq { \\rm w[3 ] } \\ldots\\ ] ]    the classes w[t ] can be described in terms of problems that are complete for them ( a problem @xmath105 is _ complete _ for a complexity class @xmath106 if @xmath107 and every problem in this class can be reduced to @xmath105 ) .",
    "let us call a boolean formula _",
    "@xmath108-normalized _ if it is of the form of product - of - sums - of - products ... of literals , with @xmath108 being the number of products - of , sums - of expressions in this definition .",
    "for example , 2-normalized formulas are products of sums of literals .",
    "thus , the class of 2-normalized formulas is precisely the class of cnf formulas .",
    "we define the _ weighted @xmath108-normalized satisfiability problem _ as :    @xmath109 : :    given a @xmath108-normalized formula @xmath110 ,    decide whether there is a model of @xmath110 with    exactly @xmath0 atoms ( or , alternatively , decide whether there    is a satisfying valuation for @xmath110 which assigns    the logical value * true * to exactly @xmath0 atoms )    downey and fellows show that for @xmath111 , the problems @xmath109 are complete for the class w[t ] .",
    "they also show that a restricted version of the problem @xmath112 :    @xmath113 : :    given a 3cnf formula @xmath110 and an integer    @xmath0 ( parameter ) , decide whether there is a model of    @xmath110 with exactly @xmath0 atoms    is complete for the class @xmath114 $ ] .",
    "downey and fellows conjecture that all the implications in ( [ eq1 ] ) are proper . in particular , they conjecture that problems in the classes w[t ] , with @xmath115 , are not fixed - parameter tractable .    in the paper",
    ", we relate the problem @xmath4 to the problems @xmath112 and @xmath116 to place the problem @xmath4 in the w hierarchy , to obtain estimates of its complexity and to argue for its fixed - parameter intractability .",
    "in this section we will show an algorithm for the parametrized problem @xmath1 that runs in time @xmath117 , where @xmath58 is an input instance and , as in all other places in the paper , @xmath71 .",
    "this result implies that the problem @xmath1 is fixed - parameter tractable and that there is an algorithm that for every fixed @xmath0 solves the problem @xmath59 in linear - time .",
    "given a logic program @xmath2 , denote by @xmath118 the logic program obtained from @xmath2 by eliminating from the bodies of the rules in @xmath2 all literals @xmath119 , where @xmath12 is not the head of any rule from @xmath2 .",
    "the following well - known result states the key property of the program @xmath118 .",
    "[ th-10 ] a set of atoms @xmath29 is a stable model of a logic program @xmath2 if and only if @xmath29 is a stable model of @xmath118 .",
    "lemma [ th-10 ] implies that the problem @xmath1 has a positive answer for @xmath58 if and only if it has a positive answer for @xmath120 .",
    "moreover , it is easy to see that @xmath118 can be constructed from @xmath2 in time linear in the size of @xmath2 .",
    "thus , when looking for algorithms to decide the problem @xmath1 we may restrict our attention to programs @xmath2 in which every atom appearing negated in the body of a rule appears also as the head of a rule ( that is , to such programs @xmath2 for which we have @xmath121 ) .    by @xmath122",
    "let us denote the program consisting of those rules @xmath10 in @xmath2 for which @xmath123 .",
    "we have the following lemma .    [ lem-42 ]",
    "let @xmath2 be a logic program such that @xmath121 .",
    "let @xmath28 be a set of atoms such that @xmath124 .",
    "then :    1 .",
    "@xmath29 is a stable model of @xmath2 if and only if @xmath29 is a stable model of @xmath122 2 .",
    "if @xmath29 is a stable model of @xmath122 , then @xmath122 has no more than @xmath125 different negated literals appearing in the bodies of its rules .",
    "proof : ( 1 ) consider a rule @xmath126 . then @xmath127 and , consequently , @xmath40 . indeed , if @xmath128 , then @xmath129 . since @xmath121 , @xmath130 .",
    "in addition , ( both if we assume that @xmath29 is a stable model of @xmath2 and if we assume that @xmath29 is a stable model of @xmath122 ) , we have @xmath44 .",
    "thus , @xmath131 . now observe that @xmath132 .",
    "thus , @xmath133 , a contradiction .    since for every rule @xmath126 we have @xmath27 , it follows that @xmath134 . hence , @xmath135 if and only if @xmath136",
    "consequently , @xmath29 is a stable model of @xmath2 if and only if @xmath29 is a stable model of @xmath122 .",
    "\\(2 ) let @xmath55 be the set of rules from @xmath122 such that @xmath137 if and only if @xmath46 ( the rules in @xmath55 contribute to the reduct @xmath138 ) and let @xmath139 be the set of the remaining rules in @xmath122 ( these are the rules that are eliminated when the reduct @xmath138 is computed ) . since @xmath121 , for every rule @xmath140 , @xmath130 .",
    "thus , @xmath141 .",
    "since @xmath44 ( as @xmath29 is a stable model of @xmath122 ) and @xmath132 , we have @xmath142 .",
    "further , since @xmath143 , it follows that @xmath144 .",
    "consequently , @xmath145 .",
    "hence , the second part of the assertion follows .",
    "@xmath146    let us now consider the following algorithm for the problem @xmath59 ( the input to this algorithm is a logic program @xmath2 ) .    1 .",
    "eliminate from the input logic program @xmath2 all literals @xmath119 , where @xmath12 is not the head of any rule from @xmath2 .",
    "denote the resulting program by @xmath147 .",
    "2 .   compute the set of rules @xmath148 consisting of those rules @xmath10 in @xmath147 for which @xmath123 .",
    "3 .   decide whether @xmath148 has a stable model @xmath29 such that @xmath149 .",
    "this algorithm reports yes if and only if the program @xmath148 has a stable model @xmath29 such that @xmath149 . by lemma [ lem-42 ] , that happens precisely if and only if @xmath147 has a stable model @xmath29 such that @xmath149 .",
    "this last statement , by lemma [ th-10 ] , is equivalent to the statement that @xmath2 has a stable model @xmath29 such that latexmath:[$|m|\\geq    @xmath59 .",
    "let us notice that steps 1 and 2 can be implemented in time @xmath66 , where the constant hidden by the `` big o '' notation does not depend on @xmath0 . to implement step 3 ,",
    "let us recall that every stable model of a logic program is determined by some subset of the set of atoms that appear negated in the program ( each such subset uniquely determines the reduct , as we stated in the introduction ; see also @xcite ) . by lemma [ lem-42 ] , the set of such atoms in the program @xmath148 has cardinality at most @xmath151",
    ". checking for each subset of this set whether it determines a stable model of @xmath148 can be implemented in time @xmath152 .",
    "consequently , our algorithm runs in time @xmath117 ( with the constant hidden by the `` big o '' notation independent of @xmath0 ) .",
    "the problem @xmath1 is fixed - parameter tractable .",
    "moreover , for each fixed @xmath0 there is a linear - time algorithm to decide whether a logic program @xmath2 has a stable model of size at least @xmath3 .",
    "in the introduction we pointed out that there is a straightforward algorithm to decide the problem @xmath61 that runs in time @xmath153 , where @xmath71 and @xmath72 . for @xmath74 ( the assumption we adopt in this section ) , this algorithm can be slightly improved .",
    "namely , we will now describe an algorithm for the problem @xmath61 that runs in time @xmath154 , where @xmath155 is some integer function .",
    "thus , if @xmath0 is fixed and not a part of the input , this improved algorithm runs in time @xmath75 .",
    "we present our algorithm under the assumption that input logic programs are _",
    "proper_. we say that a logic program rule @xmath10 is _ proper _ if :    ( p1 ) : :    @xmath156 , and ( p2 ) : :    @xmath157    we say that a logic program @xmath2 is _ proper _ if all its rules are proper .",
    "rules that violate at least one of the conditions ( p1 ) and ( p2 ) ( that is , rules that are not proper ) have no influence on the collection of stable models of a program as we have the following well - known result ( see , for instance , @xcite ) .",
    "[ l-11 ] a set of atoms @xmath29 is a stable model of a logic program @xmath2 if and only if @xmath29 is a stable model of the subprogram of @xmath2 consisting of all proper rules in @xmath2 .",
    "it is easy to see that rules that violate ( p1 ) or ( p2 ) can be eliminated from a logic program @xmath2 in time @xmath66 .",
    "thus , the restriction to proper programs does not affect the generality of our discussion .    for a proper logic program @xmath2 and for a set @xmath158 of atoms",
    ", we define @xmath159 to be the program consisting of all those rules @xmath10 of @xmath2 that are not blocked by @xmath88 ( in other words , those that satisfy @xmath160 ) and whose positive body is contained in @xmath88 ( in other words , such that @xmath161 ) .",
    "let @xmath2 be a logic program and let @xmath158 be a set of atoms .",
    "a stable model @xmath29 of @xmath2 is called _ @xmath88-based _ if    1 .",
    "@xmath29 is of the form @xmath162 , where @xmath163 , and 2 .",
    "@xmath164 ( in other words , when computing @xmath42 , the derivation of @xmath88 does not require that @xmath12 be derived first ) .",
    "we have the following simple lemma .    [ aa ]",
    "let @xmath0 be an integer such that @xmath74 .",
    "a proper logic program @xmath2 has a stable model of cardinality @xmath0 if and only if for some @xmath165 , with @xmath166 , @xmath2 has an @xmath88-based stable model .",
    "it follows from lemma [ aa ] that when deciding the existence of @xmath0-element stable models , @xmath74 , it is enough to focus on the existence of @xmath88-based stable models .",
    "this is the approach we take here . in most general terms",
    ", our algorithm for the problem @xmath61 consists of generating all subsets @xmath167 , with @xmath168 , and for each such subset @xmath88 , of checking whether @xmath2 has an @xmath88-based stable model .",
    "this latter task is the key .",
    "we will now describe an algorithm that , given a logic program @xmath2 and a set @xmath158 , decides whether @xmath2 has an @xmath88-based stable model . to this end",
    ", we define @xmath169 to be the program consisting of all those rules @xmath10 of @xmath2 such that :    1 .",
    "@xmath160 ( @xmath10 is not blocked by @xmath88 ) 2 .",
    "@xmath170 3 .",
    "@xmath171 consists of exactly one element ; _ we will denote it by @xmath172_.    our algorithm is based on the following result allowing us to restrict attention to the program @xmath159 ( the statement of the lemma and its proof rely on the terminology introduced above ) .",
    "[ l-12 ] let @xmath88 be a set of atoms .",
    "a proper logic program @xmath2 has an @xmath88-based stable model if and only if @xmath159 has an @xmath88-based stable model @xmath173 , such that @xmath174 .",
    "proof : ( @xmath175 ) let @xmath29 be an @xmath88-based stable model of @xmath2 .",
    "assume that @xmath173 , for some @xmath176 . since @xmath177 , @xmath178 . since @xmath29 is @xmath88-based , we have that @xmath164 .",
    "it follows that @xmath29 is an @xmath88-based stable model of @xmath159 .",
    "let us assume that there is a rule @xmath179 such that @xmath180 .",
    "the rule @xmath181 is not blocked by @xmath88 . since @xmath182",
    ", we have that @xmath183 ( we recall that all rules in @xmath2 are proper ) . hence , @xmath181 is not blocked by @xmath184 either . consequently , @xmath185 . since @xmath179 , the body of @xmath186 ( that is , @xmath187 ) is contained in @xmath29 .",
    "the set @xmath29 is a least model of @xmath41 . in particular",
    ", @xmath29 satisfies @xmath186 .",
    "thus , it follows that @xmath188 . in the same time , @xmath189 ( as @xmath181 is proper ) .",
    "thus , @xmath190 , a contradiction ( we recall that @xmath179 ) .",
    "it follows that @xmath174 .",
    "( @xmath191 ) we will now assume that @xmath173 is an @xmath88-based stable model of @xmath159 such that @xmath174 .",
    "similarly as before , we have @xmath192 .",
    "let us assume that @xmath193 .",
    "then there is a rule @xmath108 in @xmath41 such that the body of @xmath108 is contained in @xmath29 and @xmath194 .",
    "let @xmath181 be a rule in @xmath2 that gives rise to @xmath108 when constructing the reduct .",
    "assume first that the body of @xmath108 ( that is , @xmath187 ) is contained in @xmath88 .",
    "then @xmath195 , @xmath196 and , consequently , @xmath197 , a contradiction .",
    "thus , the body of @xmath108 is not contained in @xmath88 . since the body of @xmath108 is contained in @xmath29 , it consists of @xmath12 and , possibly , some other elements , all of which are in @xmath88 .",
    "it follows that @xmath179 .",
    "consequently , @xmath180 and @xmath198 , a contradiction .",
    "thus , @xmath199 , that is , @xmath29 is a stable model of @xmath2 . since @xmath200",
    ", it follows that @xmath29 is an @xmath88-based model of @xmath2 .",
    "@xmath146    let @xmath88 be a set of atoms .",
    "a logic program with negation , @xmath2 , is an _ @xmath88-program _ if @xmath201 , that is if for every rule @xmath140 we have @xmath202 and @xmath203 .",
    "clearly , the program @xmath159 , described above , is an @xmath88-program .",
    "we will now focus on @xmath88-programs and their @xmath88-based stable models .",
    "let @xmath88 be a set of atoms .",
    "we denote by @xmath204 the set of all proper horn rules over the set of atoms @xmath88 .",
    "clearly , the cardinality of @xmath204 depends on the cardinality of @xmath88 only .",
    "further , we define @xmath205 to be the set of all horn programs @xmath206 satisfying the condition @xmath207 . as in the case of @xmath204 ,",
    "the cardinality of @xmath205 also depends on the size of @xmath88 only .",
    "we will now describe conditions that determine whether an @xmath88-program @xmath2 has an @xmath88-based stable model . to this end , with every atom @xmath208 , we associate the following values :    * @xmath209 if there is a rule @xmath181 in @xmath2 with @xmath210 and @xmath183 ; @xmath211 , otherwise * @xmath212 the number of rules @xmath181 in @xmath2 with @xmath213 and @xmath214 .    further , with every proper horn rule @xmath215 and every atom @xmath208 , we associate the quantity :    * @xmath216 if there is a rule @xmath181 in @xmath2 with @xmath217 and @xmath183 ; @xmath218 , otherwise .",
    "the following lemma characterizes @xmath88-based stable models of an @xmath88-program .",
    "both the statement of the lemma and its proof rely on the terminology introduced above .",
    "[ l - main ] let @xmath88 be a set of atoms , let @xmath2 be an @xmath88-program and let @xmath12 be an atom such that @xmath163 .",
    "then @xmath162 is an @xmath88-based stable model of @xmath2 if and only if @xmath219 , @xmath220 , and for some program @xmath221 and for every rule @xmath222 , @xmath223 .",
    "proof : @xmath224 we denote @xmath225 and assume that @xmath29 is an @xmath88-based stable model for @xmath2 .",
    "it follows that @xmath135 .",
    "let @xmath226 be the subprogram of @xmath2 consisting of those rules of @xmath2 whose head belongs to @xmath88 .",
    "since @xmath29 is an @xmath88-based stable model of @xmath2 , we have @xmath227 .",
    "let @xmath147 be the program obtained from @xmath228 by removing multiple occurrences of rules .",
    "clearly , @xmath221 .",
    "it follows directly from the definition of the reduct that for every rule @xmath222 , @xmath229 .",
    "next , we observe that @xmath230 .",
    "thus , @xmath220 . let us assume that @xmath231 .",
    "let @xmath10 be a rule in @xmath2 such that @xmath232 and @xmath233 . since @xmath2 is an @xmath88-program , @xmath234 .",
    "thus , it follows that @xmath235 .",
    "we also have that @xmath236 . since @xmath29 is a model of @xmath41 , @xmath25 .",
    "however , in the same time we have that @xmath237 , a contradiction .",
    "it follows that @xmath238 .",
    "we now assume that for some @xmath163 , @xmath219 , @xmath220 and for some program @xmath221 and for every rule @xmath222 , @xmath229 .",
    "as before , we set @xmath173 . we will show that @xmath135 .",
    "first , since @xmath2 is an @xmath88-program and @xmath240 for every rule @xmath241 , it follows that @xmath242 .",
    "thus , @xmath243 .",
    "second , we have that @xmath244 .",
    "thus , there is a rule @xmath140 such that @xmath245 and @xmath233 .",
    "it follows that @xmath246 and @xmath235 .",
    "since @xmath242 , @xmath247 and @xmath161 , we obtain that @xmath248 .",
    "thus , @xmath164 . finally ,",
    "since @xmath238 , we have that for every rule @xmath249 such that @xmath183 , @xmath188 .",
    "thus , @xmath42 does not contain any atom not in @xmath29 .",
    "consequently , @xmath250 and @xmath29 is a stable model of @xmath2 .",
    "since @xmath164 , @xmath29 is an @xmath88-based stable model of @xmath2 .",
    "@xmath146    we will discuss now effective ways to compute values @xmath251 , @xmath252 and @xmath253 . clearly , computing the values @xmath252 can be accomplished in time linear in the size of the program , that is , in time @xmath66 .",
    "indeed , we start by initializing all values @xmath252 to 0 . then , for each rule @xmath249 , we set @xmath254 if @xmath255 , and leave @xmath256 unchanged , otherwise .",
    "to decide which is the case requires that we scan all negated lierals in the body of @xmath181 .",
    "that takes time @xmath257 .",
    "thus , the overall time is @xmath66 .",
    "computing values @xmath251 and @xmath253 is more complicated .",
    "first , we prove the following lemma .",
    "[ vn ] let @xmath2 be an @xmath88-program , let @xmath163 and let @xmath258",
    ". then    1 .",
    "@xmath259 if and only if @xmath260 .",
    "2 .   @xmath240 if and only if @xmath261 .",
    "proof : ( 1 ) let us assume first that @xmath259 .",
    "then there is a rule @xmath262 such that @xmath263 and @xmath183 .",
    "thus , @xmath264 .",
    "consequently , the identity @xmath265 follows .",
    "all the implications in this argument can be reversed .",
    "hence , we obtain the assertion ( 1 ) .",
    "\\(2 ) let us assume that @xmath240 .",
    "then , there is a rule @xmath249 such that @xmath217 and @xmath183 .",
    "consequently , @xmath266 . as in ( 1 )",
    ", all the implications are in fact equivalences and the assertion ( 2 ) follows .",
    "@xmath146    lemma [ vn ] shows that to compute all the values @xmath251 one has to compute the set @xmath267 to this end , for each atom @xmath12 we will compute the number of sets in @xmath268 that @xmath12 is a member of .",
    "we will denote this number by @xmath269 .",
    "we first initialize all values @xmath269 to 0 .",
    "then , we consider all sets in @xmath270 in turn . for each such set and for each atom @xmath12 in this",
    "set we set @xmath271 .",
    "the set @xmath272 is given by all those atoms @xmath12 for which @xmath269 is equal to the number of sets in @xmath273 .",
    "it is clear that the time needed for this computation is linear in the size of the program ( assuming appropriate linked - list representation of rules ) .",
    "thus , all the values @xmath251 can be computed in time linear in the size of the program , that is , in @xmath66 steps .    to compute values @xmath253",
    "we proceed similarly .",
    "first , we compute all the sets @xmath274 , where @xmath215 . to this end , we scan all rules in @xmath2 in order and for each of them we find the rule @xmath258 such that @xmath217",
    ". then we include @xmath181 in the set @xmath275 .",
    "given @xmath181 , it takes @xmath276 steps to identify rule @xmath10 ( where @xmath277 is some function ) .",
    "indeed , the size of @xmath187 is bound by @xmath278 as @xmath2 is an @xmath88-program .",
    "moreover , the number of rules in @xmath204 depends on @xmath278 only .",
    "thus , the task of computing all sets @xmath275 , for @xmath215 , can be accomplished in @xmath279 steps .",
    "next , for each these sets of rules , we proceed as in the case of values @xmath251 , to compute their intersections .",
    "each such computation takes time @xmath66 , where @xmath71 ) .",
    "thus , computing all the values @xmath253 can be accomplished in time @xmath280 , for some function @xmath87 .",
    "we can now put all the pieces together . as a result of our considerations ,",
    "we obtain the following algorithm for deciding the problem @xmath61 .",
    "= = = = = = = = = = + * algorithm to decide the problem @xmath61 , @xmath74 * + * input : * a logic program @xmath2 ( @xmath0 is _ not _ a part of input ) +   + ( 0)if @xmath281 is a stable model of @xmath2 * then * return yes and exit ; + ( 1)@xmath282 the set of proper rules in @xmath2 ; + ( 2 ) every @xmath158 with @xmath168 * do * + ( 3)compute the set of rules @xmath204 and the set of programs @xmath205 ; + ( 4)compute the program @xmath159 ; + ( 5)compute the program @xmath169 and the set @xmath283 ; + ( 6)given @xmath159 and @xmath204 , compute tables @xmath155 , @xmath77 and @xmath284 ( as described above ) ; + ( 7 ) every @xmath285 * do * + ( 8) + ( 9)@xmath219 , @xmath220 * and * + ( 10)there is a program @xmath221 s. t. for every rule @xmath222 , @xmath223 + ( 11 ) report yes and exit ; + ( 12)report no and exit .",
    "the correctness of this algorithm follows from lemmas [ aa ] - [ l - main ] .",
    "we will now analyze the running time of this algorithm .",
    "clearly , line ( 0 ) can be executed in @xmath66 steps .",
    "as we already observed , rules that are not proper can be eliminated from @xmath2 in time @xmath66 .",
    "next , there are @xmath286 iterations of loop ( 2 ) . in each of them , line",
    "( 3 ) takes time @xmath287 , for some function @xmath288 ( let us recall that @xmath289 and @xmath290 depend on @xmath278 only ) .",
    "further , lines ( 4 ) and ( 5 ) can be executed in time @xmath66 .",
    "line ( 6 ) , as we discussed earlier , can be implemented so that to run in @xmath291 steps .",
    "loop ( 7 ) is executed @xmath292 times and each iteration takes @xmath293 steps , for some function @xmath294 ( let us again recall that @xmath290 depends on @xmath0 only ) .",
    "thus , the running time of the whole algorithm is @xmath295 , for some integer function @xmath155 .",
    "consequently , we get the following result .",
    "there is an integer function @xmath155 and an algorithm @xmath296 such that @xmath296 decides the problem @xmath61 and runs in time @xmath295 ( the constant hidden in the `` big oh '' notation does not depend on @xmath0 ) .",
    "the algorithm outlined in the previous section is not quite satisfactory .",
    "its running time is still high .",
    "a natural question to ask is : are there significantly better algorithms for the problems @xmath61 ? in this section",
    "we address this question by studying the complexity of the problem @xmath4 .",
    "our goal is to show that the problem is difficult in the sense of the w hierarchy .",
    "we will show that the problem @xmath4 is @xmath5$]-hard and that it is in the class w[3 ] . to this end",
    ", we define the _",
    "@xmath297-weighted @xmath108-normalized satisfiability problem _ as :    @xmath298 : :    given a @xmath108-normalized formula @xmath110 ,    decide whether there is a model of @xmath110 with at    most @xmath0 atoms ( @xmath0 is a parameter ) .",
    "the problem @xmath298 is a slight variation of the problem @xmath109 .",
    "it is known to be complete for the class w[t ] , for @xmath111 ( see @xcite , page 468 ) . to show w[2]-hardness of @xmath4",
    ", we will reduce the problem @xmath299 to the problem @xmath4 .",
    "given the overwhelming evidence of fixed - parameter intractability of problems that are @xmath5$]-hard @xcite , it is unlikely that algorithms for problems @xmath61 exist whose asymptotic behavior would be given by a polynomial of order independent of @xmath0 .",
    "to better delineate the location of the problem @xmath4 in the w hierarchy we also provide an upper bound on its hardness by showing that it can be reduced to the problem @xmath300 , thus proving that the problem @xmath4 belongs to the class @xmath9 $ ] .",
    "we will start by showing that the problem @xmath61 is reducible ( in the sense of the definition from section [ ifp ] ) to the problem @xmath300 . to this end",
    ", we describe an encoding of a logic program @xmath2 by means of a collection of clauses @xmath301 so that @xmath2 has a stable model of size at most @xmath0 if and only if @xmath301 has a model with no more than @xmath302 atoms . in the general setting of the class np , an explicit encoding of the problem of existence of stable models in terms of propositional satisfiability",
    "was described in @xcite .",
    "our encoding , while different in key details , uses some ideas from that paper .",
    "let us consider an integer @xmath0 and a logic program @xmath2 . for each atom @xmath96 in @xmath2",
    "let us introduce new atoms @xmath303 ,",
    "@xmath304 , @xmath305 , and @xmath306 , @xmath307 . intuitively , atom @xmath303 represents the fact that in the process of computing the least model of the reduct of @xmath2 with respect to some set of atoms , atom @xmath96 is computed no later than during the iteration @xmath308 of the van emden - kowalski operator .",
    "similarly , atom @xmath304 represents the fact that in the same process atom @xmath96 is computed exactly in the iteration @xmath309 of the van emden - kowalski operator .",
    "finally , atom @xmath306 , expresses the fact that @xmath96 is computed _ before _ the iteration @xmath309 of the van emden - kowalski operator .",
    "the formulas @xmath310 , @xmath307 , and @xmath311 describe some basic relationships between atoms @xmath303 , @xmath304 and @xmath306 that we will require to hold : @xmath312 @xmath313    let @xmath10 be a rule in @xmath2 with @xmath314 , say @xmath315 we define a formula @xmath316 , @xmath307 , by @xmath317 we define @xmath318 ( * false * is a distinguished contradictory formula in our propositional language ) if @xmath319 . otherwise , we define @xmath320 speaking informally , formula @xmath316 asserts that @xmath96 is computed by means of rule @xmath10 in the iteration @xmath309 of the least model computation process and that it has not been computed earlier .",
    "let @xmath321 be all rules in @xmath2 with atom @xmath96 in the head .",
    "we define a formula @xmath322 , @xmath323 , by @xmath324 intuitively , the formula @xmath322 asserts that when computing the least model of the reduct of @xmath2 , atom @xmath96 is first computed in the iteration @xmath309 .",
    "we now define the theory @xmath325 that encodes the problem of existence of small stable models : @xmath326    next , we establish some useful properties of the theory @xmath325 .",
    "first , we consider a set @xmath327 of atoms that is a model of @xmath325 and define @xmath328    [ lem-11 ] let @xmath327 be a model of @xmath325 and let @xmath329 .",
    "then there is a unique integer @xmath309 , @xmath323 , such that @xmath330 .",
    "proof : since @xmath327 is a model of a formula @xmath311 , there is an integer @xmath309 , @xmath323 , such that @xmath330 . to prove uniqueness of such @xmath309 ,",
    "assume that there are two integers @xmath331 and @xmath332 , @xmath333 , such that @xmath334 and @xmath335 .",
    "since @xmath336 , it follows that there is a rule @xmath140 with @xmath314 and such that @xmath337 .",
    "in particular , @xmath338 . in the same time , since @xmath334 and @xmath339 , we have @xmath340 , a contradiction .",
    "@xmath146    for every atom @xmath329 define @xmath341 to be the integer whose existence and uniqueness is guaranteed by lemma [ lem-11 ] .",
    "define @xmath342 .",
    "next , for each @xmath309 , @xmath343 , define @xmath344_i=\\{q\\in m(u)\\colon i_q = i\\}.\\ ] ]    [ lem-12 ] let @xmath327 be a model of @xmath325 . under the terminology introduced above , for every @xmath309 , @xmath345 , @xmath346_i\\not=\\emptyset$ ] .",
    "proof : we will proceed by downward induction . by the definition of @xmath347 , @xmath346_{i_u}\\not=\\emptyset$ ] .",
    "consider @xmath309 , @xmath348 , and assume that @xmath346_i\\not = \\emptyset$ ] .",
    "we will show that @xmath346_{i-1}\\not   = \\emptyset$ ] .",
    "let @xmath349_i$ ] .",
    "clearly , @xmath330 and , since @xmath350 , there is a rule @xmath351 such that @xmath352 .",
    "consequently , for every @xmath353 , @xmath354 , @xmath355 .",
    "assume that for every @xmath353 , @xmath354 , @xmath356 .",
    "since @xmath357 and since @xmath358 , it follows that @xmath359 . consequently , @xmath327 satisfies the formula @xmath360 and , so , @xmath361 .",
    "it follows that @xmath362 , a contradiction ( we recall that @xmath363 ) .",
    "hence , there is @xmath353 , @xmath354 , such that @xmath364 .",
    "it follows that @xmath365_{i-1}$ ] and @xmath346_{i-1}\\not=\\emptyset$ ] .",
    "@xmath146    [ lem-13 ] let @xmath327 be a model of @xmath325 and let @xmath366",
    ". then    1 .",
    "@xmath367 , and 2 .",
    "@xmath368 is a stable model of @xmath2 .",
    "proof : ( 1 ) the assertion follows directly from the fact that @xmath369 and from lemma [ lem-12 ] .",
    "+ ( 2 ) we need to show that @xmath370 .",
    "we will first show that @xmath371 .",
    "since @xmath372_i$ ] , we will show that for every @xmath309 , @xmath345 , @xmath346_i\\subseteq lm(p^{m(u)})$ ] .",
    "we will proceed by induction .",
    "let @xmath349_1 $ ] .",
    "it follows that there is a rule @xmath10 such that @xmath373 .",
    "consequently , @xmath10 is of the form @xmath374 and @xmath375 .",
    "hence , for every @xmath353 , @xmath376 , @xmath377 .",
    "consequently , the rule @xmath378 is in @xmath379 and , so , @xmath380 .",
    "the inductive step is based on a similar argument .",
    "it relies on the inequality @xmath367 we proved in ( 1 ) .",
    "we leave the details of the inductive step to the reader .",
    "we will next show that @xmath381 .",
    "we will use the characterization of @xmath382 as the limit of the sequence of iterations of the van emden - kowalski operator @xmath383 : @xmath384 we will first show that for every integer @xmath309 , @xmath385 , we have : @xmath386 and for every @xmath387 , @xmath388 .    clearly , @xmath389 .",
    "hence , the basis for the induction is established .",
    "assume that for some @xmath309 , @xmath390 , @xmath391 and that for every @xmath387 , @xmath388 .",
    "consider @xmath392 .",
    "if @xmath393 , then @xmath394 for some @xmath395 , @xmath396 .",
    "since @xmath397 , @xmath398 and @xmath399 . by lemma [ lem-11 ]",
    ", it follows that @xmath400 .",
    "hence , @xmath401 .",
    "thus , assume that @xmath402 .",
    "since @xmath403 , there is a rule @xmath404 in @xmath2 such that @xmath405 , for every @xmath353 , @xmath376 , and @xmath406 , @xmath407 . by the induction hypothesis , for every @xmath353 , @xmath354 , we have @xmath408 and @xmath409 .",
    "it follows that @xmath410 and , consequently , that @xmath411 . since @xmath412 , @xmath398 and @xmath399",
    ". it also follows ( lemma [ lem-11 ] ) that @xmath413 .",
    "thus , we proved that @xmath414 .",
    "since @xmath415 , there is @xmath353 , @xmath416 such that @xmath417 .",
    "it follows that for every @xmath418 , @xmath419 , @xmath420 .",
    "consequently , @xmath421 for every non - negative integer @xmath309 .",
    "@xmath146    consider now a stable model @xmath29 of the program @xmath2 and assume that @xmath422 .",
    "clearly , @xmath423 . for each atom",
    "@xmath424 define @xmath425 to be the least integer @xmath181 such that @xmath426 . clearly , @xmath427 .",
    "moreover , since @xmath422 , it follows that for each @xmath424 , @xmath428 .",
    "now , define @xmath429    [ lem-14 ] let @xmath29 be a stable model of a logic program @xmath2 such that @xmath422 .",
    "under the terminology introduced above , the set of atoms @xmath430 is a model of @xmath325 .",
    "proof : clearly , @xmath431 for @xmath432 and @xmath307 , and @xmath433 for @xmath432 .",
    "we will now show that @xmath434 , for @xmath432 and @xmath435 .",
    "first , we will consider the case @xmath424 .",
    "there are three subcases here depending on the value of @xmath309 .",
    "we start with @xmath309 such that @xmath436 .",
    "then @xmath437 .",
    "it follows that @xmath438 for every rule @xmath140 such that @xmath314 . since @xmath439 , @xmath434",
    "next , we assume that @xmath440 . then , there is a rule @xmath441 @xmath442 in @xmath2 such that @xmath443 , for every @xmath353 , @xmath376 , and @xmath444 , @xmath354 .",
    "clearly , @xmath445 . since @xmath446 , it follows that @xmath434 , for @xmath440 .",
    "finally , let us consider the case @xmath447 .",
    "assume that there is rule @xmath140 such that @xmath314 and @xmath445 .",
    "let us assume that @xmath441 @xmath442 .",
    "it follows that for every @xmath353 , @xmath376 , @xmath448 .",
    "consequently , for every @xmath353 , @xmath376 , @xmath443 and the rule @xmath449 belongs to the reduct @xmath41 .",
    "in addition , for every @xmath353 , @xmath354 , @xmath450 . thus , @xmath451 and @xmath452 . this latter property is equivalent to @xmath453 .",
    "thus , it follows that @xmath454 and @xmath455  a contradiction with the assumption that @xmath456 .",
    "hence , for every rule @xmath10 with the head @xmath96 , @xmath438 . since for @xmath456 , @xmath457 , @xmath434 .    to complete the proof",
    ", we still need to consider the case @xmath458 . clearly , for every @xmath309 , @xmath459 , @xmath460 .",
    "assume that there is @xmath309 , @xmath459 , and a rule @xmath10 such that @xmath314 and @xmath445 .",
    "let us assume that @xmath10 is of the form @xmath461 .",
    "it follows that @xmath450 and , consequently , @xmath451 for every @xmath353 , @xmath354 .",
    "in addition , it follows that for every @xmath353 , @xmath376 , @xmath448 and , consequently , @xmath443 .",
    "thus , @xmath462 belongs to the reduct @xmath41 and , since @xmath29 is a model of the reduct , @xmath424 , a contradiction .",
    "it follows that for every @xmath309 , @xmath323 , @xmath434 .",
    "@xmath146    for each atom @xmath432 , let us introduce @xmath463 new atoms @xmath464 , @xmath465 , and define @xmath466 lemmas [ lem-11 ] - [ lem-14 ] add up to a proof of the following result .",
    "[ th-21 ] let @xmath0 be a non - negative integer and let @xmath2 be a logic program .",
    "the program @xmath2 has a stable model of size at most @xmath0 if and only if the theory @xmath301 has a model of size at most @xmath302 .",
    "proof : @xmath224 let @xmath29 be a stable model of @xmath2 such that @xmath422 . by lemma [ lem-14 ] ,",
    "the set @xmath430 is a model of @xmath325 consequently , the set @xmath467 is a model of @xmath301 .",
    "moreover , it is easy to see that @xmath468 .",
    "hence , @xmath469 .",
    "conversely , let us assume that some set @xmath470 , consisting of atoms appearing in @xmath301 and such that @xmath471 , is a model of @xmath301 .",
    "let us define @xmath327 to consist of all atoms of the form @xmath303 , @xmath304 and @xmath306 that appear in @xmath470 . clearly , @xmath327 is a model of @xmath325 .",
    "let us assume that @xmath472 ( we recall that the notation @xmath368 was introduced just before lemma [ lem-11 ] was stated ) .",
    "then , there are at least @xmath302 atoms of type @xmath464 in @xmath470 . consequently , @xmath473 as it contains also at least @xmath308 atoms @xmath303 , where @xmath329",
    "this is a contradiction .",
    "thus , it follows that @xmath366 .",
    "moreover , by lemma [ lem-13 ] , @xmath368 is a stable model of @xmath2 .",
    "@xmath146    let us now define the following sets of formulas .",
    "first , for each atom @xmath432 we define @xmath474 next , we define @xmath475 @xmath476 and @xmath477 where @xmath478 is the set of all rules in @xmath2 with @xmath96 in the head .    clearly , the theory @xmath479 is equivalent to the theory @xmath301 .",
    "moreover , it is a collection of sums of products of literals .",
    "therefore , it is a 3-normalized formula . by theorem [ th-21 ]",
    ", it follows that the problem @xmath4 can be reduced to the problem @xmath300 .",
    "thus , we get the following result .",
    "the problem @xmath480 $ ] .",
    "next , we will show that the problem @xmath299 can be reduced to the problem @xmath4 .",
    "let @xmath481 be a collection of clauses .",
    "let @xmath482 be the set of atoms appearing in clauses in @xmath483",
    ". for each atom @xmath484 , introduce @xmath0 new atoms @xmath485 , @xmath486 .",
    "by @xmath487 , @xmath486 , we denote the logic program consisting of the following @xmath23 clauses :    @xmath488 + @xmath489 + @xmath490    define @xmath491 . clearly , each stable model of @xmath492 is of the form @xmath493 , where @xmath494 for @xmath495 .",
    "sets of this form can be viewed as representations of nonempty subsets of the set @xmath88 that have no more than @xmath0 elements .",
    "this representation is not one - to - one , that is , some subsets have multiple representations .",
    "next , define @xmath496 to be the program consisting of the clauses @xmath497 stable models of the program @xmath498 are of the form @xmath499 , where @xmath29 is a nonempty subset of @xmath88 such that @xmath422 and @xmath500 enumerate ( possibly with repetitions ) all elements of @xmath29 .",
    "finally , for each clause @xmath501 from @xmath483 define a logic program clause @xmath502 : @xmath503 where @xmath87 is yet another new atom .",
    "define @xmath504 and @xmath505 .",
    "a set of clauses @xmath483 has a nonempty model with no more than @xmath0 elements if and only if the program @xmath506 has a stable model with no more than @xmath507 elements .",
    "proof : let @xmath29 be a nonempty model of @xmath483 such that @xmath422 .",
    "let @xmath500 be an enumeration of all elements of @xmath29 ( possibly with repetitions ) .",
    "then the set @xmath508 is a stable model of the program @xmath498 .",
    "since @xmath29 is a model of @xmath483 , it follows that @xmath509 , where @xmath155 consists of the clauses of the form @xmath510 such that @xmath115 and for some @xmath353 , @xmath376 , @xmath511 . since @xmath512",
    ", it follows that @xmath513 thus , @xmath514 is a stable model of @xmath506 .",
    "since @xmath515 , the `` only if '' part of the assertion follows .",
    "conversely , assume that @xmath514 is a stable model of @xmath506 . clearly , @xmath516 .",
    "consequently , @xmath517 that is , @xmath514 is a stable model of @xmath498 .",
    "as mentioned earlier , it follows that @xmath518 , where @xmath29 is a nonempty subset of @xmath20 such that @xmath422 and @xmath500 is an enumeration of all elements of @xmath29 .    consider a clause @xmath519 from @xmath483 .",
    "since @xmath514 is a stable model of @xmath506 , it is a model of @xmath506 . in particular",
    ", @xmath514 is a model of @xmath502 . since @xmath520",
    ", it follows that @xmath521 and , consequently , @xmath522 .",
    "hence , @xmath29 is a model of @xmath483 .",
    "@xmath146    now the reducibility of the problem @xmath299 to the problem @xmath4 is evident . given a collection of clauses @xmath483 , to check whether it has a model of size at most @xmath0 , we first check whether the empty set of atoms is a model of @xmath483 .",
    "if so , we return the answer yes and terminate the algorithm .",
    "otherwise , we construct the program @xmath506 and check whether it has a stable model of size at most @xmath507 .",
    "consequently , we obtain the following result .",
    "the problem @xmath4 is w[2]-hard .",
    "the paper established several results pertaining to the problem of computing small and large stable models .",
    "it also brings up interesting research questions .",
    "first , we proved that the problem @xmath1 is in the class fpt . for problems that are fixed - parameter tractable ,",
    "it is often possible to design an algorithm running in time @xmath523 , where @xmath84 is the size of the problem , @xmath0 is a parameter , @xmath86 is a polynomial and @xmath87 is a function @xcite .",
    "such algorithms are often practical for quite large ranges of @xmath84 and @xmath0 .",
    "the algorithm for the @xmath1 problem presented in this paper runs in time @xmath524 .",
    "it seems plausible it can be improved to run in time @xmath525 , for some function @xmath87",
    ". such an algorithm would most certainly be practical for wide range of values of @xmath7 and @xmath0 .",
    "we propose as an open problem the challenge of designing an algorithm for computing large stable models with this time complexity .",
    "there is a natural variation on the problem of computing large stable models : given a logic program @xmath2 and an integer @xmath0 ( parameter ) , decide whether @xmath2 has a stable model of size at least @xmath526 .",
    "this version of the problem @xmath1 was recently proved by zbigniew lonc and the author to be w[3]-hard ( and , hence , fixed - parameter intractable ) @xcite .",
    "the upper bound for the complexity of this problem remains unknown .    in the paper",
    ", we described an algorithm that for every fixed @xmath0 , decides the existence of stable models of size at most @xmath0 in time @xmath527 , where @xmath23 is the number of atoms in the program and @xmath7 is its size .",
    "this algorithm offers only a slight improvement over the straightforward `` guess - and - check '' algorithm .",
    "an interesting and , it seems , difficult problem is to significantly improve on this algorithm by lowering the exponent in the complexity estimate to @xmath528 , for some constant @xmath529 .",
    "we also studied the complexity of the problem @xmath4 and showed that it is fixed - parameter intractable .",
    "our results show that @xmath4 is @xmath5$]-hard .",
    "this result implies that the problem @xmath4 is at least as hard as the problem to determine whether a cnf theory has a model of cardinality at most @xmath0 , and strongly suggests that algorithms do not exist that would decide problems @xmath61 and run in time @xmath530 , where @xmath8 is a constant independent on @xmath0 . for the upper bound , we proved in this paper that the problem @xmath4 belongs to class @xmath9 $ ] .",
    "recently , zbigniew lonc and the author @xcite showed that the problem @xmath4 is , in fact , in the class @xmath5 $ ] .",
    "the author thanks victor marek and jennifer seitzer for useful discussions and comments .",
    "the author is grateful to anonymous referees for very careful reading of the manuscript .",
    "their comments helped eliminate some inaccuracies and improve the presentation of the results .",
    "this research was supported by the nsf grants cda-9502645 , iri-9619233 and eps-9874764 .",
    "apt , k. , blair , h.a . , & walker , a. ( 1988 ) . towards a theory of declarative knowledge .",
    "minker , j. ( ed ) , _ foundations of deductive databases and logic programming . papers from the workshop held in washington , d.c . ,",
    "august 1822 , 1986_. palo alto , ca : morgan kaufmann .",
    "bondarenko , a. , toni , f. , & kowalski , r.a .",
    "an assumption - based framework for non - monotonic reasoning .",
    "nerode , a. , & pereira , l. ( eds ) , _ logic programming and non - monotonic reasoning ( lisbon , 1993)_. cambridge , ma : mit press .",
    "gelfond , m. , & lifschitz , v. ( 1988 ) .",
    "the stable semantics for logic programs .",
    "kowalski , r. , & bowen , k. ( eds ) , _ proceedings of the 5th international symposium on logic programming_. cambridge , ma : mit press .",
    "gottlob , g. , scarcello , f. , & sideri , m. ( 1999 ) .",
    "fixed parameter complexity in ai and nonmonotonic reasoning .",
    "gelfond , m. , leone , n. , & pfeifer , g. ( eds ) , _ logic programming and nonmonotonic reasoning , proceedings of the 5th international conference , lpnmr99_. lecture notes in computer science , vol",
    "springer - verlag .",
    "marek , v.w .",
    ", & truszczyski , m. ( 1999 ) .",
    "stable models and an alternative logic programming paradigm .",
    "apt , k.r .",
    ", marek , w. , truszczyski , m. , & warren , d.s .",
    "( eds ) , _ the logic programming paradigm : a 25-year perspective_. springer verlag .",
    "marek , w. , & truszczyski , m. ( 1989 ) .",
    "stable semantics for logic programs and default theories .",
    "e.lusk , & overbeek , r. ( eds ) , _ proceedings of the north american conference on logic programming_. mit press ."
  ],
  "abstract_text": [
    "<S> in this paper , we focus on the problem of existence and computing of _ small _ and _ large _ stable models . </S>",
    "<S> we show that for every fixed integer @xmath0 , there is a linear - time algorithm to decide the problem @xmath1 ( large stable models problem ) : does a logic program @xmath2 have a stable model of size at least @xmath3 ? </S>",
    "<S> in contrast , we show that the problem @xmath4 ( small stable models problem ) to decide whether a logic program @xmath2 has a stable model of size at most @xmath0 is much harder . </S>",
    "<S> we present two algorithms for this problem but their running time is given by polynomials of order depending on @xmath0 . </S>",
    "<S> we show that the problem @xmath4 is _ fixed - parameter intractable _ by demonstrating that it is @xmath5$]-hard . </S>",
    "<S> this result implies that it is unlikely an algorithm exists to compute stable models of size at most @xmath0 that would run in time @xmath6 , where @xmath7 is the size of the program and @xmath8 is a constant independent of @xmath0 . </S>",
    "<S> we also provide an upper bound on the fixed - parameter complexity of the problem @xmath4 by showing that it belongs to the class @xmath9 $ ] .    </S>",
    "<S> [ firstpage ] </S>"
  ]
}