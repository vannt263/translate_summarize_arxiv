{
  "article_text": [
    "as the size and dimensionality of data sets in science and engineering grow larger and larger , it is necessary to develop efficient tools to analyze them @xcite .",
    "one of the best known and most frequently - used tools is the fast fourier transform ( fft ) .",
    "however , in the case that the bandwidth @xmath2 of frequencies is large , the sampling size becomes large , as dictated by the shannon - nyquist sampling theorem . specifically , the runtime complexity is @xmath5 and the number of samples is @xmath6 .",
    "this issue is only exacerbated in the @xmath7-dimensional setting , where the runtime complexity is @xmath8 and the number of samples is @xmath9 if we assume the dimension is @xmath7 and the bandwidth in each dimension is @xmath2 . due to this curse of dimensionality ",
    ", many higher dimensional problems of interest are beyond current computational capabilities of the traditional fft . moreover , in the sparse setting where the number of significant frequencies @xmath3 is small , it is computationally wasteful to compute all @xmath10 coefficients . in such a setting",
    "we refer to the problem as being sparse  . for sparse problems ,",
    "the idea of sublinear sparse fourier transforms was introduced @xcite .",
    "these methods greatly reduce the runtime and sampling complexity of the fft in the sparse setting .",
    "the methods were primarily designed for the one dimensional setting .",
    "the first sparse fourier algorithm was proposed in @xcite .",
    "it introduced a randomized algorithm with @xmath11 runtime and @xmath11 samples where @xmath12 is a positive number that varies depending on the trade - off between efficiency and accuracy .",
    "an algorithm with improved runtime @xmath13 and samples @xmath13 was given in @xcite .",
    "the algorithms given in @xcite and @xcite achieved @xmath14 runtime and gave empirical results .",
    "the algorithms in @xcite are all randomized .",
    "the first deterministic algorithm using a combinatorial approach was introduced in @xcite . in @xcite ,",
    "another deterministic algorithm was given whose procedure recognizes frequencies in a similar manner to @xcite .",
    "the two methods in @xcite were published at the same time and both use the idea of working with two sets of samples , one at @xmath1 points and the second at the same @xmath1 points plus a small shift .",
    "the ratio of the fft of the two sets of points , plus extra machinery , lead to fast deterministic algorithms .",
    "the first deterministic algorithm @xcite has @xmath15 runtime and sampling complexity , and the second one @xcite has @xmath16 runtime and @xmath1 sampling complexity .",
    "later , @xcite introduced modified methods for noisy data with @xmath17 runtime . our method , discussed throughout this paper builds on the method presented in @xcite .",
    "the methods introduced in the previous paragraph are for one - dimensional data . in @xcite , practical algorithms for data in two dimensions",
    "were given for the first time .",
    "in this paper , we develop algorithms designed for higher dimensional data , which is effective even for dimensions in the hundreds and thousands . to achieve our goal ,",
    "our approach must address the worst case scenario presented in @xcite .",
    "we can find a variety of data sets in multiple dimensions that we want to analyze .",
    "a relatively low - dimensional example is mri data , which is three dimensional .",
    "however , when we designed the method in this paper , we had much higher dimensional problems in mind , such as some astrophysical data , e.g. , the sloan digital sky survey and large synoptic survey telescope @xcite .",
    "they produce tera- or peta - bytes of imaging and spectroscopic data in very high dimensions . due to the computational effort of a multi - dimensional fft ,",
    "spectral analysis of this high dimensional data necessitates a multidimensional sparse fast fourier transform .",
    "further , given the massive size of data sets in some current and future problems in science and engineering , it is anticipated that the develop of such an efficient algorithm will play an important role in the analysis of these types of data .",
    "it is not straightforward to extend one dimensional sparse fourier transform algorithms to multiple dimensions .",
    "we face several obstacles .",
    "first , we do not have an efficient fft for multidimensional problems much higher than three .",
    "using projections onto lower - dimensional spaces solves this problem .",
    "however , like all projection methods for sparse fft , one needs to match frequencies from one projection with those from another projection . this _ registration _",
    "problem is one of the big challenges in the one dimensional sparse fft .",
    "an equally difficult challenge is that different frequencies may be projected into the same frequency ( _ the collision problem _ ) .",
    "all projection methods for sparse fft primarily aim to overcome these two challenges . in higher dimensional sparse fft , these problems become even more challenging as now we are dealing with frequency vectors , not just scalar frequencies .    as a first step to our goal of a high dimensional sparse fft",
    ", this paper addresses the case for continuous data without noise in a high dimensional setting . in a later paper",
    "we shall present an adaptation of the algorithm for noisy data .",
    "we introduce effective methods to address the registration and the collision problems .",
    "in particular , we introduce a novel _ partial unwrapping _ technique that is shown to be highly effective in reducing the registration and collision complexity while maintains the sublinear runtime efficiency .",
    "we shall show that empirically we can achieve @xmath18 computational complexity and @xmath19 sampling size for randomly generated test data . in section",
    "[ 5 ] , we present as examples computational results for sparse fft where the dimensions are 100 and 1000 respectively . for comparison ,",
    "the traditional @xmath7-dimensional fft requires @xmath20 time complexity and @xmath9 sampling complexity , which is impossible to implement on any computers today .",
    "the one - dimensional sublinear sparse fourier algorithm inspiring our method was developed in @xcite .",
    "we briefly introduce the idea and notation of the algorithm before developing the multidimensional ones throughout this paper .",
    "we assume a function @xmath21 with sparsity @xmath3 as the following , @xmath22 with bandwidth @xmath2 , i.e. , frequency @xmath23 belongs to @xmath24 and corresponding nonzero coefficient @xmath25 is in @xmath26 for all @xmath27",
    ". we can consider it as a periodic function over @xmath28 instead of @xmath29 .",
    "the goal of the algorithm is to recover all coefficients @xmath25 and frequencies @xmath23 so that we can reconstruct the function @xmath30 .",
    "this algorithm is called the phase - shift \" method since it uses equi - spaced samples from the function and those at positions shifted by a small positive number @xmath31 . to verify that the algorithm correctly finds the frequencies in the bandwidth @xmath2 ,",
    "@xmath31 should be strictly no bigger than @xmath32 .",
    "we denote a sequence of samples shifted by @xmath31 with sampling rate @xmath33 , where @xmath34 is a prime number , as @xmath35 we skip much of the details here . in a nutshell , by choosing @xmath34 slightly larger than @xmath3 is enough to make the algorithm work . in @xcite @xmath34",
    "is set to be roughly @xmath36 , which is much smaller than the nyquist rate @xmath2 .",
    "discrete fourier transform ( dft ) is then applied to the sample sequence @xmath37 , and the @xmath38-th element of its result is the following @xmath39 ~=~   p \\sum_{w_j = h ( \\bmod p ) } a_j e^{2 \\pi i \\epsilon w_j}\\ ] ] where @xmath40 . if there is only one frequency @xmath23 congruent to @xmath38 modulo @xmath34 , @xmath41",
    "~=~ pa_je^{2 \\pi i \\epsilon w_j}.\\ ] ] by putting @xmath42 instead of @xmath31 , we can get unshifted samples @xmath43 and applying the dft gives @xmath44 ~=~ pa_j.\\ ] ] this process so far is visualized in the figure [ 1d ] .",
    "as long as there is no collision of frequencies with modulo @xmath34 , we can find frequencies and their corresponding coefficients by the following computation @xmath45 }       { { \\mathcal f}({\\mathbf f}_{p,0})[h ] } \\big ) , \\nonumber\\\\      a_j & ~=~ \\frac{1}{p}{\\mathcal f}({\\mathbf f}_{p,0})[h],\\label{(7)}\\end{aligned}\\ ] ] where the function @xmath46 gives us the argument falling into @xmath47 note that @xmath23 should be the only frequency congruent to @xmath38 modulo @xmath34 , i.e. , @xmath23 has no collision with other frequencies modulo @xmath34 .",
    "the test to determine whether collision occurs or not is @xmath48\\vert}{\\vert{\\mathcal f}({\\mathbf f}_{p,0})[h]\\vert}~=~ 1.\\ ] ] the equality above holds when there is no collision . if there is a collision , the equality does not hold for almost all @xmath31 , i.e. , the test fails to predict a collision for finite number of @xmath31 @xcite .",
    "further , it is also shown in the same paper that for any @xmath49 with @xmath50 coprime and @xmath51 , equality ( [ ( 8) ] ) does not hold unless there is no collision . in practical implementations",
    ", we choose @xmath31 to be @xmath52 for some positive integer @xmath53 and allow some small difference @xmath54 between the left and right sides of ( [ ( 8) ] ) where @xmath54 is very small positive number .",
    "[ fig1 ]    the above process is one loop of the algorithm with a prime number @xmath34 . to explain it from a different view",
    ", we can imagine that there are @xmath34 bins .",
    "then we sort all frequencies into these bins according to their remainder modulo @xmath34 .",
    "if there are more than one frequencies in one bin , then a collision happened .",
    "if there is only one frequency , then there is no collision . to determine whether a collision occurs",
    ", we use the above test . in the case where the test fails , i.e. , the ratio is not @xmath55 , we need to use another prime number @xmath56 .",
    "thus we re - sort the frequencies into @xmath56 bins by their remainder modulo @xmath56 .",
    "even if two frequencies collide modulo @xmath34 , it is likely that they do not collide modulo @xmath56 .",
    "particularly , the chinese remainder theorem guarantees that with a finite set of prime numbers , @xmath57 , any frequency within the bandwidth @xmath2 can be uniquely identified , given @xmath58 .",
    "algorithmically , for each loop , we choose a different prime number @xmath56 and repeat equations ( [ ( 2)])-([(8 ) ] ) with @xmath34 replaced by @xmath56 . in this way we can recover all @xmath25 and @xmath23 in sublinear time @xmath59 using @xmath1 samples .",
    "the overall code is shown in algorithm [ algorithm1 ] referred from @xcite .     + *",
    "input:*@xmath60 + * output:*@xmath61 @xmath62",
    "@xmath63 @xmath64 @xmath65 prime number @xmath66 @xmath67    @xmath68 = f(\\frac{h}{p } ) - g(\\frac{h}{p } )   $ ] @xmath69 = f(\\frac{h}{p}+\\epsilon ) - g(\\frac{h}{p}+\\epsilon)$ ] @xmath70 @xmath71 @xmath72    @xmath73}{\\mathcal{f}^{sort}({f}_{p , 0})[h ] } \\big)$ ] @xmath74 $ ]",
    "@xmath75 @xmath76      in this section , the multidimensional problem is introduced .",
    "let us consider a function @xmath77 such that @xmath78 where @xmath79 and @xmath80 .",
    "that is , from ( [ ( 1 ) ] ) , @xmath81 is replaced by the @xmath7-dimensional phase or time vector @xmath82 , frequency @xmath23 is replaced by the frequency vector @xmath83 and thus the operator between @xmath83 and @xmath82 is a dot product instead of simple scalar multiplication .",
    "we can see that this is a natural extension of the one - dimensional sparse problem . as in the 1d setting , if we find @xmath25 and @xmath84 , we recover the function @xmath30 .",
    "however , since our time and frequency domain have changed , we can not apply the previous algorithm directly .",
    "if we project the frequencies onto a line , then we can apply the former algorithm so that we can retain sublinear time complexity .",
    "since the operator between frequency and time vectors is a dot product , we can convert projection of frequencies to that of time .",
    "for example , we consider the projection onto the first axis , that is , we put the last @xmath85 elements of time vectors as @xmath42 .",
    "if the projection is one - to - one , i.e. , there is no collision , then we can apply the algorithm in section [ 2.1 ] to this projected function to recover the first element of frequency vectors .",
    "if there is a collision on the first axis , then we can try another projection onto @xmath86th axis , @xmath87 , until there are no collisions .",
    "we introduce in latter sections how to recover the corresponding remaining @xmath85 elements by extending the test to determine the occurrence of a collision in section [ 2.1 ] .",
    "furthermore , to reduce the chance of a collision through projections , we use an unwrapping method  which unwraps frequencies onto a lower dimension guaranteeing a one - to - one projection .",
    "there is both a full unwrapping  and a partial unwrapping ",
    "method , which are explained in later sections .",
    "we shall call projections onto any one of the coordinate axes a _ parallel projection_.",
    "the worst case is where there is a collision for every parallel projection .",
    "this obviously happens when a subset of frequency vectors form the vertices of a @xmath7-dimensional hypercube , but it can happen also with other configurations that require fewer vertices . then our method can not recover any of these frequency vectors via parallel projections . to resolve this problem , we introduce _ tilted projections _ : instead of simple projection onto axes we project frequency vectors onto tilted lines or planes so that there is no collision after the projection .",
    "we shall call this the _ tilting method _ and provide the details in the next section . after introducing these projection methods , we explore",
    "which combination of these methods is likely to be optimal .",
    "as means of explanation , we introduce the two - dimensional case in this section and extend this to higher dimensions in section [ 4 ] . the basic two - dimensional algorithm using a parallel projection",
    "is introduced in section [ 3.1 ] , the full unwrapping method is introduced in section [ 3.2 ] and the tilting method for the worst case is discussed in section [ 3.3 ] .",
    "[ 2dbasic ]      our basic two - dimensional sublinear algorithm excludes certain worst case scenarios . in most cases ,",
    "we can recover frequencies in the 2-d plane by projecting them onto each horizontal axis or vertical axis .",
    "figure [ 2dbasic ] is a simple illustration .",
    "here we have three frequency vectors where @xmath88 and @xmath89 are colliding with each other when they are projected onto the horizontal axis and @xmath88 and @xmath90 are when they are projected onto the vertical axis .",
    "the first step is to project the frequency vectors onto the horizontal axis and recover @xmath90 and its corresponding coefficient @xmath91 only , since it is not colliding . after subtracting @xmath90 from the data , we project the remaining frequency vectors onto the vertical axis and then find both @xmath88 and @xmath89 .",
    "now let us consider the generalized two - dimensional basic algorithm .",
    "assume that we have a two - dimensional function @xmath30 with sparsity @xmath3 : @xmath92 for now , let us focus on one frequency vector with index @xmath93 which is not collided with any other pairs when they are projected onto the horizontal axis .",
    "to clarify put @xmath94 with @xmath95 into ( [ ( 10 ) ] ) , @xmath96 which gives the same effect of parallel projection of frequency vectors .",
    "now , we can consider this function as a one - dimensional function @xmath97 so that we can use the original one dimensional sparse fourier algorithm to find the first component of @xmath98 .",
    "we get the samples @xmath99 and @xmath100 with and without shift by @xmath31 .",
    "we can find these in the form of sequences in ( [ ( 2 ) ] ) , apply the dft to them , and then recover the first component of the frequency pair and its coefficient as follows , @xmath101 } { { \\mathcal f}({\\mathbf f}^1_{p,0})[h ] } \\big ) , \\nonumber\\\\      a_{j ' } & ~=~ \\frac{1}{p}{\\mathcal f}({\\mathbf f}^1_{p,0})[h].\\label{(12)}\\end{aligned}\\ ] ] at the same time , we need to find the second component . in ( [ ( 11 ) ] ) , we replace @xmath42 by @xmath31 . then @xmath102~ & = ~ pa_{j'}e^{2\\pi i w_{j'2}\\epsilon}\\nonumber,\\\\      w_{j'2}~ & = ~ \\frac{1}{2\\pi\\epsilon } { \\rm arg}\\big ( \\frac{{\\mathcal f}({\\mathbf f}^2_{p,\\epsilon})[h ] } { { \\mathcal f}({\\mathbf f}^1_{p,0})[h ] } \\big),\\label{(16)}\\end{aligned}\\ ] ] where @xmath103 are samples shifted by @xmath31 in the vertical sense with rate @xmath33 from the function @xmath104 . ( [ ( 12 ) ] ) holds only when @xmath105 is the only one congruent to @xmath38 modulo @xmath34 among every first component of @xmath3 frequency pairs and ( [ ( 16 ) ] ) holds only when the previous condition is satisfied and @xmath106 does not collide with other frequency pairs from the parallel projection .",
    "now we have two kinds of collisions .",
    "the first one is from taking modulo @xmath34 after the parallel projection and the second one is from the projection .",
    "thus we need two tests .",
    "to determine whether there are both kinds of collisions , we use similar tests as ( [ ( 8) ] ) . if there are at least two different @xmath107 congruent to @xmath38 modulo @xmath34 , then the second equality in the following is not satisfied for almost all @xmath31 , just as ( [ ( 8) ] ) , @xmath108\\vert}{\\vert{\\mathcal f}({\\mathbf f}^1_{p,0})[h]\\vert}~=~ \\frac{\\vert p \\sum_{w_{j1 } = h(\\bmod p ) } a_j",
    "e^{2 \\pi i \\epsilon w_{j1 } } \\vert}{\\vert p \\sum_{w_{j1 } = h(\\bmod p ) } a_j   \\vert } ~=~ 1.\\ ] ] likewise , if there is a collision from the projection , i.e. , the first components @xmath107 s of at least two frequency vectors are identical and the corresponding @xmath109 s are different , the following second equality does not hold for almost all @xmath31 , @xmath110\\vert}{\\vert{\\mathcal f}({\\mathbf f}^1_{p,0})[h]\\vert}~=~ \\frac{\\vert p \\sum_{w_{j1 } = h ( \\bmod p ) } a_j e^{2 \\pi i \\epsilon w_{j2 } } \\vert}{\\vert p \\sum_{w_{j1 } = h ( \\bmod p ) } a_j   \\vert } ~=~ 1.\\ ] ] the two tests above are both satisfied only when there is no collision both from taking modulo @xmath34 and the projection .",
    "we use these for the complete recovery of the objective frequencies .",
    "so far we project the frequencies onto the horizontal axis .",
    "after we find the non - collided frequencies from the first projection , we subtract a function consisting of found frequencies and their coefficients from the original function @xmath30 to get a new function .",
    "next we project this new function onto the vertical axis and do a similar process .",
    "the difference is to exchange @xmath55 and @xmath111 in the super - indices and sub - indices respectively in ( [ ( 11 ) ] ) through ( [ ( 18 ) ] ) .",
    "again , find the remaining non - collided frequencies , change the axis again and keep doing this until we recover all of the frequencies .",
    "we introduce another kind of projection which is one - to - one .",
    "the full unwrapping method uses one - to - one projections onto one - dimensional lines instead of the parallel projection onto axes from the previous method .",
    "we consider the @xmath3 pairs of frequencies @xmath112 , @xmath113 and transform them as follows @xmath114 this transformation in frequency space can be considered as the transformation in phase or time space .",
    "that is , from the function in ( [ ( 10 ) ] ) @xmath115 the function @xmath116 is a one - dimensional function with sparsity @xmath3 and bandwidth bounded by @xmath117 .",
    "we can apply the algorithm in section [ 2.1 ] on @xmath118 so that we recover @xmath3 frequencies of the form on the right side of the arrow in ( [ ( 19 ) ] ) . whether unwrapped or not , the coefficients are the same , so we can find them easily . in the end",
    "we need to wrap the unwrapped frequencies to get the original pairs .",
    "remember that unwrapping transformation is one - to - one .",
    "thus we can wrap them without any collisions .    since the pairs of the frequencies are projected onto the one - dimensional line directly",
    ", we call this method the  full unwrapping method \" .",
    "problem with this method occurs when the dimension @xmath7 gets large . from the above description",
    ", we see that after the one - to - one unwrapping the total bandwidth of the two dimensional signal increases from @xmath2 in each dimension to @xmath117 . if the full unwrapping method is applied to a function in @xmath7-dimensions , then to guarantee the one - to - one transformation the bandwidth will be @xmath119 .",
    "theoretically this does not matter .",
    "however , since @xmath31 is dependent on the bandwidth , in the case where @xmath7 is large , we need to consider the limit of machine precision for practical implementations . as a result",
    ", we need to introduce the partial unwrapping method to prevent the bandwidth from becoming too large .",
    "the partial unwrapping method is discussed in section [ 4 ] .     and solving it through tilting , scaledwidth=90.0% ]      up till now , we have assumed that we do not encounter the worst case , i.e. , that we do not encounter the case where any frequency pair has collisions from the parallel projection for all coordinate axes .",
    "this makes the algorithm break down .",
    "the following method is for finding those frequency pairs .",
    "basically , we rotate axes of the frequency plane and thus use a projection onto a one - dimension system which is a tilted line with the tilt chosen so that there are no collisions . if the horizontal and vertical axes are rotated with angle @xmath120 then the frequency pair @xmath121 can be relabeled with new coordinates as the right side of the following @xmath122 in phase - sense , this rotation can be written as @xmath123 we can apply the basic algorithm in section [ 3.1 ] to the function @xmath118 to get the frequency pairs in the form of the right side of the arrow in ( [ ( 21 ) ] ) .",
    "one problem we face is that the components of the projected frequency pairs should be integers to apply the method , since we assume integer frequencies in the first place . to guarantee injectivity for both projections",
    ", @xmath124 should be irrational , however , the projected frequencies become irrational .",
    "thus , we should try rational @xmath124 , and to make them integer it is inevitable to increase the bandwidth by multiplying the least common multiple of the denominators of @xmath125 and @xmath126 .",
    "we assume the following with integers @xmath127 , @xmath128 and @xmath12 @xmath129 multiplying @xmath12 to both inputs in the right - hand side of ( [ ( 22 ) ] ) we obtain @xmath130 as long as there is no collision for at least one projection , the frequency pairs , @xmath131 , can be found by applying the basic algorithm in section [ 3.2 ] on @xmath132 . due to machine precision",
    "the integer @xmath12 should not be too large , or the bandwidth gets too large resulting in failure of the algorithm .",
    "if four pairs of frequencies are at vertices of a rectangle aligned with coordinate axes before the rotation , then they are not aligned after the rotation with @xmath133 .",
    "thus we can assure finding whole frequencies whether they are in the worst case or not .     +",
    "* input:*@xmath134 , integers @xmath135 , @xmath136 , @xmath137 + * output:*@xmath61 @xmath62 @xmath63 @xmath138 , @xmath139 @xmath140 @xmath141 prime number @xmath66 @xmath142 mod 2)+1 @xmath143 @xmath144 mod @xmath111 , @xmath145 mod @xmath111 , @xmath146 mod @xmath111 , @xmath147 mod @xmath111 @xmath148 = $ ] @xmath149 @xmath150 @xmath151 = f(\\frac{h-1}{p}m ' \\cos + \\frac{h-1}{p}m '' \\sin , -\\frac{h-1}{p}m ' \\sin + \\frac{h-1}{p}m '' \\cos ) -",
    "g(\\frac{h-1}{p}{\\mathbf e}_m)$ ] @xmath152",
    "@xmath153 @xmath154 @xmath155 @xmath156 @xmath157}{\\mathcal{f}^{sort}({f}^{m , n}_{p , 0})[h ] } \\big)$ ] @xmath158 $ ] @xmath159 @xmath76 @xmath160 , @xmath161    the pseudo code of the 2d tilting method is shown in algorithm [ algorithm 3 ] .",
    "the lines 14 and 15 mean that each frequency pair @xmath162 is rotated by a matrix [ @xmath163 @xmath164 ; @xmath165 @xmath163 ] and scaled to make the rotated components integers .",
    "thus we first find the frequency pairs in the form of @xmath167 and after finding all of them , we rotate them back into the original pairs with the matrix [ @xmath163 @xmath165 ; @xmath164 @xmath163 ] in line 39 .",
    "this tilting method is a straight forward way to resolve the worst case problem .",
    "we only introduced the tilting method in the two - dimensional case , but the idea of rotating the axes can be extended to the general @xmath7-dimensional case with some effort . on the other hand , we may notice that the probability of this worst case is very low , especially when the number of dimensions @xmath7 is large .",
    "its details are shown in section [ 4 ] .",
    "thus , as we recover the frequencies as much as possible from the basic algorithm . if we can not get any frequency pairs for several projection switching among each axis then , assuming that the worst case happens , we apply the tilting method with several angles until all @xmath3 frequency pairs are found .",
    "in this section we present the _ partial unwrapping _ method for a sublinear sparse fourier algorithm for very high dimensional data . as we have already mentioned , while full unwrapping converts a multi - dimensional problem into a single dimensional problem , it is severely limited in its viability when the dimension is large or when the bandwidth is already high because of the increased bandwidth .",
    "partial unwrapping is introduced here to overcome this problem and other problems . in section",
    "[ 4.1 ] we give a four dimensional version of the algorithm using the partial unwrapping method as well as a generalize it to @xmath7 dimension . in section [ 4.2 ] , the probability of the worst case in @xmath7 dimension is analyzed .      to see the benefit of partial unwrapping we need to examine the main difficulties we may encounter in developing sublinear sparse fourier algorithms . for this",
    "let us consider a hypothetical case of sparse fft where we have @xmath168 frequencies in a 20-dimensional fourier series distributed in @xmath169 .",
    "when we perform the parallel projection method , because the bandwidth is small , there will be a lot of collisions after the projections .",
    "it is often impossible to separate any frequency after each projection , and the task could thus not be completed .",
    "this , ironically , is a _ curse of small bandwidth _ for sparse fourier algorithm . on the other hand ,",
    "if we do the full unwrapping we would have increased the bandwidth to @xmath170 , which is impossible to do within reasonable accuracy because @xmath2 is too large .",
    "however , a partial unwrapping would reap the benefit of both worlds .",
    "let us now break down the 20 dimensions into 5 lower 4-dimensional subspaces , namely we write @xmath171 in each subspace we perform the full unwrapping , which yields bandwidth @xmath172 in the subspace .",
    "this bandwidth @xmath2 is large enough compared with @xmath3 , so when projection method is used there is a very good probability that collision will occur only for a small percentage of the frequencies , allowing them to be reconstructed . on the other hand , @xmath2 is not so large that the phase - shift method will incur significant error .",
    "one of the greatest advantage of partial unwrapping is to turn the curse of dimensionality into the _ blessing _ of dimensionality .",
    "note that in the above example , the 4 dimensions that for any of the subspaces do not have to follow the natural order . by randomizing ( if necessary )",
    "the order of the dimensions it may achieve the same goal as the tilting method would . also note that the dimension for each subspace needs not be uniform .",
    "for example , we can break down the above 20-dimensional example into four @xmath173-dimensional subspaces and two @xmath174-dimensional subspaces , i.e. @xmath175 this will lead to further flexibility .      before introducing the generalized partial unwrapping algorithm for dimension @xmath7 ,",
    "let us think about the simple case of @xmath174 dimensions .",
    "we assume that @xmath3 frequency vectors are in @xmath174-dimensional space ( @xmath176 ) .",
    "then , a function @xmath30 constructed from these frequency vectors is as follows , @xmath177 since @xmath178 , the frequency pairs of the two - two dimensional spaces are both unwrapped onto one - dimensional spaces . here",
    ", @xmath174 dimensions is projected onto @xmath111 dimensions as follows @xmath179 where @xmath180 and @xmath181 .",
    "note that this projection is one - to - one so as to guarantee the inverse transformation .",
    "now we can apply the basic projection method in section [ 3.1 ] to this function @xmath118 re - defined as the @xmath111-dimensional one . to make this algorithm work ,",
    "@xmath182 should not collide with any other frequency pair after the projection onto either the horizontal or vertical axes .",
    "if not , we can consider using the tilting method . after finding all the frequencies in the form of @xmath183 , it can be transformed to @xmath184 .",
    "we introduce the final version of the multidimensional algorithm in this section .",
    "its pseudo code and detailed explanation are given in algorithm [ algorithm2 ] and section [ 5.0 ] , respectively .",
    "we start with a @xmath7-dimensional function @xmath30 , @xmath185 let us assume that @xmath7 can be divided into @xmath186 and @xmath187 - the case of @xmath7 being a prime number will be mentioned at the end of this section .",
    "the domain of frequencies can be considered as @xmath188 and @xmath189 will be reduced to one dimension , as @xmath186 is in the 4 dimensional case .",
    "each of the @xmath186 elements of a frequency vector , @xmath190 , is unwrapped as @xmath191 with @xmath192 , increasing the respective bandwidth from @xmath2 to @xmath193 and having injectivity .",
    "we rewrite this transformation in terms of the phase . with @xmath194 and put the following into @xmath195 @xmath196 for all @xmath197 , where @xmath198 and @xmath199 are the remainder from dividing @xmath200 by @xmath186 and quotient from dividing @xmath201 by @xmath186 respectively , and @xmath202 is a phase vector in @xmath187 dimensions after projection .",
    "define a function @xmath118 on @xmath187 dimension as @xmath203 where @xmath204 is the @xmath201th element of the input of @xmath30 .",
    "if we project frequency vectors of @xmath118 onto the @xmath205th axis then the @xmath206th element of a frequency vector @xmath207 can be found in the following computation , @xmath208 } { { \\mathcal f}({\\mathbf g}^{m , n}_{p,0})[h ] } \\big ) \\nonumber\\\\      a_j & ~=~ \\frac{1}{p}{\\mathcal f}({\\mathbf g}^{m , n}_{p,0})[h],\\label{(41)}\\end{aligned}\\ ] ] where @xmath209 is the @xmath205-th unit vector with length @xmath187 , i.e. , all elements are zero except the @xmath205-th one with entry @xmath55 .",
    "( [ ( 41 ) ] ) holds as long as @xmath210 is the only one congruent to @xmath38 modulo @xmath34 among all @xmath206-th elements of the frequency vectors and @xmath207 does not collide with any other frequency vector due to the projection onto the @xmath205-th axis .",
    "the test for checking whether these conditions are satisfied is @xmath211\\vert}{\\vert{\\mathcal f}({\\mathbf g}^{m , n}_{p,0})[h]\\vert } ~=~1\\ ] ] for all @xmath212 .",
    "the projections onto the @xmath205-th axis , where @xmath213 , take turns until we recover all frequency vectors and their coefficients . after that we wrap the unwrapped frequency vectors up from @xmath187 to @xmath7 dimension .",
    "since the unwrapping transformation is one - to - one , this inverse transformation is well - defined .",
    "so far , we assumed that dimension @xmath7 can be divided into two integers , @xmath186 and @xmath187 . for the case",
    "that @xmath7 is a prime number or both @xmath186 and @xmath187 are so large that the unwrapped data has a bandwidth such that @xmath31 is below the machine precision , a strategy of divide and conquer can be applied . in that case",
    "we can think about applying partial unwrapping method in a way that each unwrapped component has a different size of bandwidth .",
    "if @xmath7 is @xmath173 , for example , then we can unwrap the first two components of the frequency vector onto one dimension and the last one lies in the same dimension . in that case , the unwrapped data is in two dimensions , and the bandwidth of the first component is bounded by @xmath117 and that of second component is bounded by @xmath2 . in this case",
    "we can choose a shift @xmath214 where @xmath117 is the largest bandwidth .",
    "we can extend this to the general case , so the partial unwrapping method has a variety of choices balancing the bandwidth and machine precision .      in this section",
    ", we give an upper bound of the probability of the worst case assuming that we randomly choose a partial unwrapping method .",
    "as addressed in the section [ 4.1 ] , there is flexibility in choosing certain partial unwrapping method . assuming a certain partial unwrapping method and considering a stronger condition to avoid its failure",
    ", we can find the upper bound of the probability of the worst case where there is a collision for each parallel projection .    for simple explanation ,",
    "consider a two dimensional problem .",
    "choosing the first frequency vector @xmath215 on a two dimensional plane , if the second frequency vector , @xmath216 , is not on the vertical line crossing @xmath217 and the horizontal line crossing @xmath218 , then the projection method works",
    ". then if the third frequency vector is not on four lines , those two lines mentioned before , the vertical line crossing @xmath219 and the horizontal line crossing @xmath220 , then again the projection method works .",
    "we keep choosing next frequency vector in this way , excluding the lines containing previous frequencies .",
    "thus , letting such event @xmath221 , the probability that the projection method fails is bounded above by @xmath222 .    generally , let us assume that we randomly choose a partial unwrapping , without loss of generality , the total dimension is @xmath223 where @xmath224 is the number of subspaces and @xmath225 are the dimensions of each subspace .",
    "that is , partially unwrapped frequency vectors are in @xmath226 dimension and each bandwidth is @xmath227 , respectively , which is integer strictly larger than @xmath55 .",
    "then , the failure probability of projection method is bounded above by @xmath228 where @xmath229 is the event that we choose @xmath86th frequency not on the lines , crossing formerly chosen frequency vectors and parallel to each coordinate axis .",
    "noting @xmath230 , sparsity @xmath3 is relatively small compared to @xmath10 , and @xmath54 is large , we can see that the upper bound above gets closer to @xmath42 as @xmath7 or @xmath2 grows to infinity .",
    "+ * input:*@xmath231 + * output:*@xmath61 @xmath62 @xmath63 @xmath140 @xmath141 prime number @xmath66 @xmath142 mod @xmath232 @xmath143 @xmath148 = f(\\sum^{d_1}_{\\ell=1 } n^\\ell \\frac{h-1}{p}{\\mathbf e}_{d_1(m-1)+\\ell}+ \\epsilon \\sum^{d_1}_{\\ell=1 } n^\\ell { \\mathbf e}_{d_1(n-1)+\\ell } ) - g(\\frac{h-1}{p}{\\mathbf e}_m+\\epsilon{\\mathbf e}_n )   $ ] @xmath151 = f(\\sum^{d_1}_{\\ell=1 } n^\\ell \\frac{h-1}{p}{\\mathbf e}_{d_1(m-1)+\\ell } ) - g(\\frac{h-1}{p}{\\mathbf e}_m)$ ] @xmath152 @xmath153 @xmath154 @xmath155 @xmath156 @xmath157}{\\mathcal{f}^{sort}({f}^{m , n}_{p , 0})[h ] } \\big)$ ] @xmath158 $ ] @xmath233 @xmath76 and restore it in @xmath61",
    "the partial unwrapping method is implemented in the c language .",
    "the pseudo code of this algorithm is shown in algorithm [ algorithm2 ] .",
    "it is explained in detail in section [ 5.0 ] . in our experiment ,",
    "dimension @xmath7 is set to @xmath234 and @xmath235 , @xmath186 is @xmath236 and @xmath187 is @xmath237 and @xmath238 , accordingly .",
    "frequency bandwidth @xmath2 in each dimension is @xmath237 and sparsity @xmath3 varies as @xmath239 .",
    "the value of @xmath31 for shifting is set to @xmath240 and the constant number @xmath12 determining the prime number @xmath34 is set to @xmath236 .",
    "we randomly choose @xmath3 frequency vectors @xmath241 and corresponding coefficients @xmath242 from randomly chosen angles @xmath243 so that the magnitude of each @xmath25 is @xmath55 .",
    "for each @xmath7 and @xmath3 we have @xmath234 trials .",
    "we get the result by averaging @xmath244 errors , the number of samples used and cpu ticks out of @xmath234 trials .",
    "since it is difficult to implement high dimensional fft and there is no practical high dimensional sparse fourier transform it is hard to compare the result of ours with others , as so far no one else was able to do fft on this large data set . thus we can not help but show ours only . from figure [ fig4 ]",
    "we can see that the average @xmath244 errors are below @xmath245 .",
    "those errors are from all differences of frequency vectors and coefficients of the original and recovered values .",
    "since all frequency components are integers and thus the least difference is @xmath55 , we can conclude that our algorithm recover the frequency vectors perfectly .",
    "those errors are only from the coefficients . in figure [ fig5 ]",
    "the average sampling complexity is shown .",
    "we can see that the logarithm of the number of samples is almost proportional to that of sparsity .",
    "note that the traditional fft would show the same sampling complexity even though sparsity @xmath3 varies since it only depends on the bandwidth @xmath2 and dimension @xmath7 . in figure [ fig6 ]",
    "the average cpu ticks are shown .",
    "we can see the the logarithm of cpu ticks is also almost proportional to that of sparsity .",
    "note that the traditional fft might show the same cpu ticks even though sparsity @xmath3 varies since it also depends on the bandwidth @xmath2 and dimension @xmath7 only .      in this section",
    ", the explanation of algorithm [ algorithm2 ] is given .",
    "in @xcite several versions of 1d algorithms are shown . among them , non - adaptive and adaptive algorithms are introduced where the input function @xmath30 is not modified throughout the whole iteration , and is modified by subtracting the function constructed from the data in registry @xmath61 , respectively . in our multidimensional algorithm , however , the adaptive version is mandatory since excluding the contribution of the currently recovered data is the key of our algorithm to avoid the collision of frequencies through projections , whose simple pictorial description is given in figure [ 2dbasic ] . in algorithm",
    "[ algorithm2 ] , the function @xmath118 is the one constructed from the data in the registry @xmath61 .",
    "our algorithm begins with entering inputs , a function @xmath30 , a constant number @xmath12 determining @xmath34 , a sparsity @xmath3 , a bandwidth @xmath2 of each dimension , a dimension @xmath7 , factors @xmath186 and @xmath187 of @xmath7 and a shifting number @xmath246 .",
    "for each iteration of the algorithm , the number of frequencies to find is updated as @xmath247 .",
    "it stops when @xmath248 becomes equal to the sparsity @xmath3 .",
    "the prime number @xmath34 is determined depending on this new @xmath249 as @xmath250 and is chosen as the next larger prime number . the lines 13 and 14 of algorithm [ algorithm2 ] represent the partial unwrapping and sampling with and without shifting from the function where the contribution of former data is excluded . after applying the fft on each sequence , sorting them according to the magnitude of @xmath251",
    ", we check the ratio between the fft s of the unshifted and shifted sequences to determined whether there is a collision , either from modulo @xmath34 or a parallel projection .",
    "if all tests are passed , then we find each frequency component and corresponding coefficient for the data that passed and store them in @xmath61 .",
    "after several iterations , we find all the data and the final wrapping process gives the original frequency vectors in @xmath7 dimensions .",
    "error , scaledwidth=90.0% ]              we assume that there is no noise on the data that we want to recover . figure [ fig4 ] shows that we can find frequencies perfectly and the @xmath244 error from coefficients are significantly small .",
    "this error is what we average out over 100 trials for each @xmath252 and @xmath253 when @xmath2 is fixed to @xmath237 .",
    "the horizontal axis represents the logarithm with base @xmath111 of @xmath3 and the vertical axis represents the logarithm with base @xmath111 of the @xmath244 error .",
    "it is increasing as the sparsity @xmath3 is increasing since the number of nonzero coefficients increases . the red graph in the figure [ fig4 ] shows the error when the number of dimensions is @xmath234 and the blue one shows the error when the number of dimensions is @xmath235 .",
    "thus , we see that the errors are not substantially impacted by the dimensions .",
    "figure [ fig5 ] shows the sampling complexity of our algorithm averaged out from 100 tests for each dimension and sparsity .",
    "the horizontal axis means the logarithm with base @xmath111 of @xmath3 and the vertical axis represents the logarithm with base @xmath111 of the total number of samples from the randomly constructed function which are used to find all frequencies and coefficients .",
    "the red graph in the figure [ fig5 ] shows the sampling complexity when the number of dimensions is @xmath234 and the blue one shows the one when the number of dimensions is @xmath235 .",
    "both graphs increase as @xmath3 increases .",
    "when @xmath7 is large , we see that it requires more samples since there are more frequency components to find . from the graphs",
    ", we see that the scaling seems to be proportional to @xmath7 .      in figure",
    "[ fig6 ] , we plot the runtime complexity of the main part of our algorithm averaged over 100 tests for each dimension and sparsity .",
    " means that we have excluded the time for constructing a function consisting of frequencies and coefficients and the time associated with getting samples from it .",
    "the horizontal axis is the logarithm , base @xmath111 , of @xmath3 and the vertical axis is the logarithm , base @xmath111 , of cpu ticks .",
    "the red curve shows the runtime when we set the number of dimensions to 100 and the blue one shows the same thing when the number of dimensions to 1000 . both plots increase as @xmath3 increases .",
    "when @xmath7 is larger , the plots show that it takes more time to run the algorithm . from the graphs we see that the runtime looks proportional to @xmath7 .",
    "unfortunately , the sampling process of getting the samples from continuous functions dominates the runtime of the whole algorithm instead of the main algorithm . to show the runtime of our main algorithm , however , we showed cpu ticks without sampling process .",
    "reducing the time for sampling is still a problem . in @xcite",
    "the fully discrete fourier transform is introduced that we expect to use to reduce it .",
    "exploring how to use this will be one part of our future work .",
    "in this paper we show how to extend our deterministic @xmath254 sublinear sparse fourier algorithm to the general @xmath7 dimensional case . the method projects @xmath7 dimensional frequency vectors onto lower dimensions . in this process",
    "we encounter several obstacles .",
    "thus we introduced tilting method  for the worst case problems and the partial unwrapping method  to reduce the chance of collisions and to increase the frequency bandwidth within the limit of computation . in this way we can overcome the obstacles as well as maintain the advantage of the @xmath254 algorithm . in @xcite",
    "the sampling complexity is @xmath1 and the runtime complexity is @xmath16 .",
    "extended this estimation from our @xmath254 algorithm , we have @xmath19 sampling complexity and a runtime complexity of @xmath18 .",
    "multidimensional sparse fourier algorithms have not been discussed much so far , so there is a lot of room for future work .",
    "the algorithms in this paper are for recovering data from a noiseless environment only .",
    "however most of the actual data contains noise .",
    "thus , the next step will be developing an algorithm for noisy multidimensional data . as mentioned in the previous section , reducing sampling time is another problem to consider .",
    "furthermore , algorithms for fully discrete or nonuniform data will be explored . in the end",
    ", it is expected that we apply them to real problems like astrophysical data or mri data .",
    "* acknowledgements * we would like to thank mark iwen for his valuable advice .",
    "this research is supported in part by afosr grants fa9550 - 11 - 1 - 0281 , fa9550 - 12 - 1 - 0343 and fa9550 - 12 - 1 - 0455 , nsf grant dms-1115709 , and msu foundation grant spg - rg100059 , as well as hong kong research grant council grants 16306415 and 16317416 .",
    "casey  s greene , arjun krishnan , aaron  k wong , emanuela ricciotti , rene  a zelaya , daniel  s himmelstein , ran zhang , boris  m hartmann , elena zaslavsky , stuart  c sealfon , et  al . understanding multicellular function and disease with human tissue - specific networks .",
    ", 47(6):569576 , 2015 .      anna  c gilbert , sudipto guha , piotr indyk , s  muthukrishnan , and martin strauss .",
    "near - optimal sparse fourier representations via sampling . in _ proceedings of the thiry - fourth annual acm symposium on theory of computing _ , pages 152161 .",
    "acm , 2002 .",
    "anna  c gilbert , s  muthukrishnan , and martin strauss .",
    "improved time bounds for near - optimal sparse fourier representations . in _ optics & photonics 2005 _ , pages 59141a59141a",
    "international society for optics and photonics , 2005 .",
    "haitham hassanieh , piotr indyk , dina katabi , and eric price .",
    "nearly optimal sparse fourier transform . in _ proceedings of the forty - fourth annual acm symposium on theory of computing _ ,",
    "pages 563578 .",
    "acm , 2012 .",
    "haitham hassanieh , piotr indyk , dina katabi , and eric price .",
    "simple and practical algorithm for sparse fourier transform . in _ proceedings of the twenty - third annual acm - siam symposium on discrete algorithms _ ,",
    "pages 11831194 .",
    "siam , 2012 .",
    "badih ghazi , haitham hassanieh , piotr indyk , dina katabi , eric price , and lixin shi .",
    "sample - optimal average - case sparse fourier transform in two dimensions . in _",
    "communication , control , and computing ( allerton ) , 2013 51st annual allerton conference on _ , pages 12581265 .",
    "ieee , 2013 ."
  ],
  "abstract_text": [
    "<S> in this paper , we discuss the development of a sublinear sparse fourier algorithm for high - dimensional data . in adaptive sublinear time fourier algorithm \" by d. lawlor , y. wang and a. christlieb ( 2013 ) @xcite , an efficient algorithm with empirically @xmath0 runtime and @xmath1 sampling complexity for the one - dimensional sparse fft was developed for signals of bandwidth @xmath2 , where @xmath3 is the number of significant modes such that @xmath4 .    in this work </S>",
    "<S> we develop an efficient algorithm for sparse fft for higher dimensional signals , extending some of the ideas in @xcite . </S>",
    "<S> note a higher dimensional signal can always be unwrapped into a one dimensional signal , but when the dimension gets large , unwrapping a higher dimensional signal into a one dimensional array is far too expensive to be realistic . </S>",
    "<S> our approach here introduces two new concepts : partial unwrapping  and tilting  . </S>",
    "<S> these two ideas allow us to efficiently compute the sparse fft of higher dimensional signals . </S>"
  ]
}