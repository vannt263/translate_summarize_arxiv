{
  "article_text": [
    "an everlasting challenge of the verification of programs involving numerical computations is to efficiently find accurate invariants for values of variables .",
    "even though machine computations use finite precision arithmetic , it is important to rely on the properties of real numbers and estimate the real number values of the program variables first , before even trying to characterize the floating - point number invariants .",
    "we refer the reader to @xcite , which describes a way to go from this to floating - point analysis , or to the static linearization techniques of @xcite .    in @xcite",
    "as well , some first ideas about an abstract interpretation domain which would be expressive enough for deriving these invariants , were sketched .",
    "it relied on a more accurate alternative to interval arithmetic : affine arithmetic , the concretization of which is a center - symmetric polytope .",
    "but , contrarily to existing numerical relational abstract domains with polyhedral concretization ( polyhedra @xcite of course , but also zones , octagons @xcite etc . ) , dependencies in affine arithmetic are implicit , making the semantics very economical .",
    "also , affine arithmetic is close to taylor models , which can be exploited to give precise abstractions of non - linear computations .",
    "but these advantages are at a theoretical cost : the partial order and the correctness of the abstract computations are intricate to find and prove . in this article",
    ", we construct a `` quasi '' lattice abstract domain , and study the convergence of fixpoint computations .",
    "we show how the result of the join operators we define can be considered as a perturbation of the affine forms , and thus how the fixpoint iteration can be seen as a perturbation of the numerical schemes we analyze .",
    "a crucial point is that our abstract domain is both almost a bounded complete lattice , and an ordered banach space , where approximation theorems and convergence properties of numerical schemes naturally fit . as an application of the framework",
    ", we prove that our approach allows us to accurately bound the values of variables for stable linear recursive filters of any order .",
    "[ [ contributions ] ] contributions + + + + + + + + + + + + +    this article fully describes a general `` completeness '' result of the abstract domain , for a class of numerical programs ( linear recursive filters of any order ) , meaning that we prove that the abstract analysis results will end up with finite numerical bounds whenever the numerical scheme analyzed has this property .",
    "we also show good evidence that , on this class of programs , we can get as close an over - approximation of the real result as we want .",
    "the abstract domain on which we prove this result is a generalization of the one of @xcite ; better join and meet operators are described , and the full order - theoretic structure is described ( sketches of proofs are given ) .",
    "a new feature of this domain , with respect to the other numerical abstract domains , is that it does not only have an order - theoretic structure , but also a topological one , the interaction of which plays an important role in our results .",
    "the domain is an ordered banach space , `` almost '' a riesz space , which are structures of interest in functional analysis and optimization theory .",
    "this is not just a coincidence : correctness of the abstraction relies on the correctness of functional evaluations in the future , i.e. continuations .",
    "this opens up promises for useful generalizations and new techniques for solving the corresponding semantic equations .    [ [ contents ] ] contents + + + + + + + +    section [ sec_problem ] introduces the general problematic of finding precise invariants for numerical programs , and defines an interesting sub - class of problems , that is linear recursive filters of any order . we also introduce the classical affine forms @xcite introduced in numerical mathematics , on which our work elaborates .",
    "section [ pobanach ] extends these affine forms to deal with _",
    "static analysis invariants_. we show that the set of such generalized forms has the structure of an _ ordered banach space _ , which almost has least upper bounds and greatest lower bounds : it actually only has _ maximal lower bounds _ and _ minimal upper bounds _ , in general .",
    "an equivalent of _ bounded completeness _ is proved using the interplay between the partial order and the topology ( from the underlying banach space ) .",
    "we develop particular kleene iteration techniques in section [ convsection ] . with these",
    ", we prove that we can find finite bounds for the invariants of _ stable _ linear recursive filters .",
    "we also show evidence that these abstractions give good result in practice , using our current c implementation of the abstract semantics .",
    "finally , we give hints about current and future work in sections [ improv ] and [ conclusion ] .",
    "we are interested in _ numerical schemes _ in the large .",
    "this includes signal processing programs , control programs such as the ones used in aeronautics , automotive and space industry , libraries for computing transcendental functions , and as a long - term goal , simulation programs ( including the solutions of ordinary or partial differential equations ) .",
    "the context of our work is the determination of the accuracy reached by the finite precision ( generally ieee 754 ) implementation of these numerical schemes , see for instance @xcite .",
    "but it is already a difficult problem for these numerical programs , to determine run - time errors ( rtes ) statically , just because the bounds of the results of numerical computation are hard to find .",
    "these bounds are not only hard to find for floating - point arithmetic , but also for real arithmetic , which is the first critical step towards solving the complete problem .",
    "_ in the sequel , we are describing a precise abstract domain of affine forms for bounding real number calculations , in the sense of abstract interpretation @xcite . _",
    "we give in section [ numschemes ] a class of simple programs that are pervasive in the field of numerical computing : _ linear recursive filters of any order_. they are encountered generally in signal processing and control programs , but encompass also all linear recurrence schemes that can be found in simulation programs .",
    "we will study _ extensively _ the behavior of our abstract domain on such programs .    of course",
    ", we are also interested in non - linear schemes , and already studied some coming for example from the solution of a conjugate gradient algorithm , or algorithms for estimating transcendental functions . and ,",
    "as we will see in the description of our abstract semantics , one of the interesting points of affine forms is that they behave well also for non - linear computations , in a much more precise and natural way than with classical polyhedra , or zones / octagons .",
    "but we have not reached yet the point in the theory where we can state as precise statements as for the analysis of _ linear _ dynamical systems , although strong practical evidence show that our method gives very good results as well for some non - linear dynamical systems ( see for instance @xcite for some examples that were already solved with a much coarser abstract domain than the one of this article ) .",
    "let us consider the following class of program , that we will study in depth with our abstract domain in section [ linear ] :    .... filter(float x[n+1 ] ) {    real e[n+1 ] ;    e [ * ] = input(m , m ) ; [ 1 ]    while ( true ) { [ 2 ]      e[n+1 ] = input(m , m ) ;      x[n+1 ] = a[1]*x[1]+a[2]*x[2]+ ... +a[n]*x[n ]       + b[1]*e[1]+b[2]*e[2]+ ... +b[n+1]*e[n+1 ] ; [ 3 ]      x[n ] = x[n+1 ] ; ... x[1 ] = x[2 ] ; [ 4 ] } } ....    in the program above , ` a [ ] ` is an array of @xmath0 constants @xmath1 , @xmath2 ( indices of arrays start at 1 ) , ` b [ ] ` is an array of @xmath3 constants @xmath4 , @xmath5 . `",
    "m ` and ` m ` are parameters , giving the bounds @xmath6 and @xmath7 of the successive inputs over time . for purposes of simplicity ,",
    "as was discussed in the introduction , types of variables are _ real _ number types .",
    "we use the notation ` e[*]=input(m , m ) ; ` to denote the sequence of @xmath3 input assignments between @xmath7 and @xmath6 . at iterate @xmath8 of the filter , variable ` x[i ] ` represents the value @xmath9 of the output .",
    "our main interest here is in the _ invariant _ at control point [ 2 ] ( control points are indicated as numbers within square brackets ) .    the program ` filter `",
    "describes the infinite iteration of a filter of order @xmath0 with coefficients @xmath10 , @xmath11 and a new input @xmath12 between @xmath7 and @xmath6 at each iteration : @xmath13 starting with initial conditions @xmath14 .",
    "we rewrite ( [ lrf ] ) as : @xmath15 with @xmath16 @xmath17    now , of course , ( [ matrixeq ] ) has solution @xmath18 where @xmath19 is the vector of initial conditions of this linear dynamical system .",
    "if @xmath20 has eigenvalues ( roots of @xmath21 ) of module strictly less than 1 , then the term @xmath22 will tend to zero when @xmath8 tends toward infinity , whereas the partial sums @xmath23 will tend towards a finite value ( obtained as a convergent infinite series ) .",
    "[ transf2 ] consider the following filter of order 2 ( see @xcite ) : @xmath24 where @xmath25 are independent inputs between 0 and 1 . a typical run of this algorithm with @xmath26 ( for all @xmath27 ) and @xmath28 , @xmath29 converges towards 0.8333 ... stays positive , and reaches at most 1.1649 ( its dynamics is shown in figure [ dynamics1 ] ) .",
    "an _ affine form _ is a formal series over a set of _ noise symbols _ @xmath30 @xmath31 with @xmath32 .",
    "let @xmath33 denote the set of such affine forms .",
    "each noise symbol @xmath30 stands for an independent component of the total uncertainty on the quantity @xmath34 , its value is unknown but bounded in [ -1,1 ] ; the corresponding coefficient @xmath35 is a known real value , which gives the magnitude of that component .",
    "the idea is that the same noise symbol can be shared by several quantities , indicating correlations among them .",
    "these noise symbols can be used not only for modeling uncertainty in data or parameters , but also uncertainty coming from computation .    when the cardinal of the set @xmath36 is finite , such affine forms correspond to the affine forms introduced first in @xcite and defined for static analysis in @xcite by the authors .",
    "the concretization of a set of affine forms sharing noise symbols is a center - symmetric polytope , which center is given by the @xmath37 vector of the affine forms .",
    "for example , the concretization of @xmath38 is given in figure [ fig_concret ] .",
    "@xmath33 is a @xmath39-vector space with the operations @xmath40 and @xmath41 : @xmath42 @xmath43    a sub - vector space @xmath44 of @xmath33 can be classically endowed with a banach space structure , using the @xmath45 norm @xmath46 for the elements @xmath47 such that the above sum is finite .",
    "we define the projection @xmath48 and the associated semi - norm @xmath49 we also define @xmath50    .2 cm    let us come back now to the linear recursive filters of section [ numschemes ] . for simplicity",
    "s sake , suppose @xmath51 , so the @xmath52 are independent inputs between 0 and 1 . as we will see later on , but as should already be obvious because of the definitions of sum and product of affine forms by a scalar , the semantics , using affine forms , of the completely unfolded filter program exactly gives , at unfolding @xmath8 : @xmath53 where @xmath54 and @xmath55 are the obvious affine forms vector counterparts of @xmath56 .",
    "this means that in the case @xmath20 has complex roots of module strictly less than 1 , the affine forms ( with a finite number of @xmath30 ) giving the semantics of values at unfolding @xmath8 , converge in the @xmath57 sense to an affine form with infinitely many noise symbols .",
    "consider again the filter of order 2 of example [ transf2 ] .",
    "we supposed that the successive inputs @xmath25 are independent inputs between 0 and 1 , so that we can write @xmath58 ( with different noise symbols at each iterate ) , and @xmath59 .",
    "for instance , if we compute the affine form after 99 unfolds , we find : @xmath60 whose concretization gives an exact ( under the assumption that the coefficients of the affine form are computed with arbitrary precision ) enclosure of @xmath61  : @xmath62.\\ ] ] the limit affine form has a concretization converging towards ( see figure [ dynamics2 ] ) : @xmath63 $ ] .",
    "unfortunately , if asymptotically ( i.e. when @xmath8 is large enough ) , the concretization of the affine forms @xmath64 converges to a good estimate of the values that program variable @xmath65 can take ( meaning , after a large number of iteration @xmath8 ) , this form is in no way an invariant of the loop , and _ does not account _ for all values that this variable can take along the loops .",
    "[ transf22 ] this can be seen for the particular filter of order 2 of example [ transf2 ] . in figure",
    "[ dynamics2 ] , the reader with good eyes can spot that around iterations 8 - 10 , the concretization of @xmath65 can go above 2.75738551656 ... , which is the _",
    "asymptotic _ supremum .",
    "actually , the sup value is 2.82431841 ... , reached at iteration 8 , whereas the infimum is -1.12124069 ... , reached at iteration 13 .    * the aim of this paper is to describe a suitable extension of these affine forms that can account for such invariants . *",
    "we now extend our banach space of affine forms in order to _ represent _ unions of affine forms , as a _ perturbed _",
    "affine form .",
    "we consider @xmath66 and write these new affine forms as : @xmath67 norms @xmath57 are extended over this new domain in an obvious manner .",
    "we now have @xmath68    [ [ remark ] ] remark : + + + + + + + +    in the rest of this section , unless otherwise stated , we restrict the study to elements in the _ cone _ @xmath69 of @xmath70 whose elements @xmath47 have a positive @xmath71 .",
    "we will sketch some ways to extend the results obtained , and their meaning , for all of @xmath70 , in sections [ meetoperation ] and [ betaneg ] .",
    ".2 cm    we first give concrete semantics to these generalized affine forms in section [ concsem ] , then we give in section [ arithexpr ] the abstract transfer functions for arithmetic expressions .",
    "the counterpart of the inclusion ordering , the _ continuation _ ordering , is defined in section [ continuation ] . the main technical ingredient that will allow us to find effective",
    "join and meet operations in section [ quasilattice ] is the equivalence between this seemingly intractable ordering , and an ordering with a much simpler definition , the _ perturbation _ ordering , see theorem [ maintheo1 ] .",
    "finally we prove in section [ banach ] that these generalized affine forms also have the structure of _ an ordered _ banach space .",
    "this will be useful for proving convergence results with our iteration schemes in section [ linear ] .",
    "we define the concretization function @xmath72 in intervals as follows , for @xmath73 : @xmath74\\ ] ]    whose lower ( respectively upper ) bound corresponds to the infimum ( respectively supremum ) of the affine form @xmath47 seen as a function from @xmath75 $ ] to @xmath39 .",
    "let @xmath76 be the set of program variables .",
    "an _ abstract environment _ is a function @xmath77 .",
    "we write @xmath78 for the set of such abstract environments .",
    "the fact that the affine forms representing the variables share some common noise symbols can be expressed in the _ joint concretization _ , also denoted by @xmath79 , of @xmath80 ( we suppose here that @xmath76 is finite and equal to @xmath81 ) : @xmath82 , \\\\",
    "\\exists u_{x_1},\\ldots , u_{x_k } \\in [ -1,1 ] , \\\\",
    "\\left\\{\\begin{array}{rcl } \\hat x_1 & = & \\alpha^{x_1}_0 + \\sum_{i=1}^{\\infty } \\alpha^{x_1}_i t_i + \\beta^{x_1 } u_{x_1 } \\\\ \\ldots \\\\ \\hat x_k & = & \\alpha^{x_k}_0 + \\sum_{i=1}^{\\infty } \\alpha^{x_k}_i t_i + \\beta^{x_k } u_{x_k } \\\\",
    "\\end{array}\\right.\\end{array}\\right\\}\\ ] ]    [ firstjointaffine ] consider @xmath83 their joint concretization is the inner polyhedron of figure [ inclusionaffine ] .",
    "seeing affine forms @xmath47 as functions of @xmath30 and @xmath84 , we define the _ concrete _ semantics of arithmetic operations @xmath40 , @xmath85 and @xmath41 on affine forms , with values in the set of subsets of @xmath86 , as follows .",
    "we note @xmath87 , for @xmath88 $ ] , the application @xmath47 , seen as an affine function of @xmath89 , to @xmath90 .",
    "the concrete semantics of @xmath91 in @xmath39 is now    @xmath92\\right\\ } \\end{array}$ ]    for @xmath93 , it is    @xmath94\\right\\ }   \\end{array}$ ]    finally , the concrete semantics of @xmath95 is    @xmath96\\right\\ }   \\end{array}$ ]    we are going to give an abstract semantics for @xmath40 , @xmath85 and @xmath41 in next section",
    ".      let @xmath97 be the set of polynomial expressions , @xmath98 , @xmath99 etc . as affine forms are naturally taylor forms .",
    "this is not described in this article , for lack of space . ]",
    ", i.e. expressions built inductively from the set of program variables @xmath76 , real number constants , and operations + , - and @xmath41 .",
    "we now define the respective operators @xmath100 , @xmath101 and @xmath102 ( extending the ones of section [ affine ] )    @xmath103 ( note that the sign @xmath40 in @xmath104 is certainly not a typo ) . and we define for affine forms @xmath47 and @xmath105 having a finite number of non - zero @xmath106 coefficients ( we call them affine forms with finite support ) @xmath107 where @xmath108 is a symbol which is unused in @xmath47 nor in @xmath105 ( `` fresh noise symbol '' ) .",
    "[ base ] we have the following correctness result on the abstract semantics of expressions : @xmath109 where @xmath40 and @xmath85 on the right hand side of inequalities above are the corresponding operations on intervals , and the last inclusion holds only for affine forms with finite support .",
    "this is mostly the similar classical result in affine arithmetic @xcite , and easily extended to @xmath84 symbols and infinite series ( convergent in the @xmath57 sense ) .",
    "@xmath110      the correctness of the semantics of arithmetic expressions defined in section [ arithexpr ] , and more generally of the semantics of a real language ( section [ imp ] ) relies on an information ordering , which we call the _ continuation ordering _ , definition [ continuationorder ] .",
    "unfortunately , its definition makes it difficult to use , and we define an a priori weaker ordering , that we call _ perturbation ordering _ , definition and lemma [ perturborder ] , that will be easily decidable , and shown equivalent to the continuation ordering ( proposition [ equivinfoperturb ] ) .",
    "the _ perturbation ordering _ has minimal upper bounds , but not least upper bounds .",
    "a simple construction will allow us to define in section [ riesz ] a lattice with a slightly stronger _",
    "computational _ ordering , based on the _ perturbation ordering_.    [ continuation order ] [ continuationorder ] let @xmath111 and @xmath112 be two abstract environments .",
    "we say that @xmath113 if and only if for all @xmath114 @xmath115 \\ ! ] } \\sigma_1 \\subseteq   \\gamma { [ \\ ! [ } e { ] \\ ! ] } \\sigma_2\\ ] ]    we naturally say that @xmath116 if and only if @xmath115 \\ ! ]",
    "} \\sigma[u \\leftarrow \\hat{x } ] \\subseteq   \\gamma { [ \\ !",
    "[ } e { ] \\ ! ] } \\sigma[u \\leftarrow \\hat{y}]\\ ] ] for all @xmath114 and all @xmath117 ( and for some @xmath118 ) .",
    "[ perturbation order ] [ perturborder ] we define the following binary relation @xmath119 on elements of @xmath70 @xmath120 then @xmath119 is a partial order on @xmath70 .",
    "we extend this partial order _",
    "componentwise _ to abstract environments as follows : for all @xmath121 , @xmath122    reflexivity and transitivity of @xmath119 are trivial . for antisymmetry ,",
    "suppose @xmath123 and @xmath124 , then we have @xmath125 this implies that both @xmath126 and @xmath127 are positive , hence necessarily zero .",
    "hence also @xmath128 meaning @xmath129 .",
    "overall : @xmath130 .",
    "@xmath110    now , we prove intermediary results in order to prove equivalence between the two orders above .",
    "half of this equivalence is easy , see lemma [ predleq ] .",
    "the other half is a consequence of lemma [ conc ] and of lemma [ increasing ] . theorem [ maintheo1 ] is the same as proposition [ equivinfoperturb ] , not just for individual affine forms , but for all abstract environments .",
    "[ predleq ] @xmath131    given @xmath47 and @xmath105 in @xmath70 , consider the expression @xmath132 and the environment @xmath80 such that @xmath133 .",
    "we have @xmath134 \\ ! ] } [ u\\leftarrow \\hat{x } ]   \\subseteq \\gamma { [ \\ ! [ } e { ] \\ ! ] } \\sigma [ u \\leftarrow \\hat{y}]$ ] , which means : @xmath135\\ ] ] @xmath136\\ ] ] thus we have @xmath137 inequality ( [ last ] ) is equivalent to @xmath138 hence together with inequality ( [ first ] ) @xmath139 this exactly translates into @xmath140 .",
    "@xmath110    [ conc ] for all @xmath141 , @xmath142 implies @xmath143 .",
    "we compute : @xmath144 using the triangular inequality @xmath145 , and @xmath146 , we write : @xmath147 and similarly for the @xmath148 bound of the concretization .",
    "@xmath110    notice that the converse of lemma [ conc ] is certainly not true : just take @xmath149 and @xmath150 .",
    "it is easy to see that @xmath47 and @xmath151 are incomparable , but have same concretizations .",
    "[ increasing ] @xmath100 , @xmath101 and @xmath102 are increasing functions on @xmath152 .",
    "we have easily , for @xmath142 and @xmath153 : @xmath154 now : @xmath155 @xmath156 but @xmath123 so @xmath157 the last inequality being entailed by the triangular inequality .",
    "thus , @xmath158 which , by combining with inequality ( [ eq1 ] ) , completes the proof .",
    "@xmath110    [ equivinfoperturb ] @xmath142 if and only if @xmath116    we know from lemma [ predleq ] that @xmath116 implies @xmath142 . now , let @xmath114 , and suppose @xmath159 .",
    "we reason by induction on @xmath12 : the base case is constants and variables ( trivial ) .",
    "a consequence of lemma [ increasing ] is that for all @xmath153 , @xmath160 , @xmath161 and @xmath162 . by induction on the syntax of @xmath12",
    ", we then have @xmath163 \\ ! ] } \\sigma[u \\leftarrow \\hat{x } ]   \\leq { [ \\ ! [ } e { ] \\ ! ] } \\sigma[u \\leftarrow \\hat{y}]$ ] .",
    "this implies by lemma [ conc ] that @xmath134 \\ ! ] } \\sigma[u \\leftarrow \\hat{x } ] \\subseteq   \\gamma { [ \\ !",
    "[ } e { ] \\ ! ] } \\sigma[u \\leftarrow \\hat{y}]$ ] , hence @xmath116 .",
    "@xmath110    .2 cm    finally , we can prove the following more general equivalence , which is nothing but obvious at first .",
    "the example below shows the subtlety of this result .",
    "[ secondjointaffine ] to illustrate one of the aspects of next theorem , that is , @xmath164 implies that any _ joint concretization _ of @xmath151 with other affine forms , ( say just one , @xmath105 , here ) , contains the joint concretization of @xmath47 with @xmath105 , take again @xmath47 as in example [ firstjointaffine ] and @xmath165 of course , @xmath166 ; figure [ inclusionaffine ] shows the inclusion of the joint concretization of @xmath167 in the joint concretization of @xmath168 .",
    "note that several of the faces produced are fairly different .",
    "[ maintheo1 ] let @xmath111 , @xmath112 be two abstract environments , then @xmath169 if and only if @xmath113    it can be shown first ( classical result in affine arithmetic @xcite ) , that @xmath170 is a polyhedron ( a particular kind , called a _",
    "zonotope _ ) .",
    "it means that it can be equivalently described by a system of affine constraints ( @xmath171 ) : @xmath172    consider the expressions ( in @xmath97 ) : @xmath173 .",
    "we know that for all @xmath174 , @xmath175 , hence by proposition [ equivinfoperturb ] , @xmath176 .",
    "this entails , by induction on @xmath76 , that @xmath177 \\ ! ] } \\sigma_1 \\subseteq \\gamma { [ \\ ! [ } e^j { ] \\ ! ] } \\sigma_2 $ ] .",
    "thus the constraint @xmath178 is satisfied by elements of @xmath179 , by lemma [ base ] .",
    "so @xmath180 .",
    "let @xmath12 be any expression in @xmath97 .",
    "the result follows from proposition [ equivinfoperturb ] and the result above , by induction on @xmath12 .",
    "the aim of this section is to prove proposition [ orderedbanach ]",
    ". this will be central to the proofs in sections [ riesz ] and [ convsection ] .",
    "[ orderedbanach ] @xmath181 is an ordered banach space .",
    "first , we show that the partial order @xmath119 of definition and lemma [ perturborder ] makes @xmath70 into an ordered vector space .    for showing this",
    ", we have to show _ compatibility _ of @xmath119 with the linear structure , i.e. , for @xmath182 and @xmath142 , and for all @xmath183 : @xmath184 , @xmath185 , and @xmath186 , which is immediate verification .",
    "the only remaining property to prove is that @xmath119 is closed in @xmath187 , in the product topology , @xmath70 being given the banach topology of the @xmath57 norm .",
    "suppose @xmath188 converges towards @xmath65 as @xmath0 goes towards @xmath189 , in the sense of the @xmath57 norm , and suppose for all @xmath0 , @xmath190",
    ". then @xmath191 for all @xmath192 and @xmath193 .",
    "by continuity of @xmath194 , we thus know that there exists @xmath195 such that for all @xmath196 : @xmath197 this concludes the proof .",
    "@xmath110    a different way of stating that @xmath181 is an ordered vector space is to introduce the subset @xmath198 of @xmath70 such that @xmath199 and show it is indeed the _ cone _ of @xmath119 , see @xcite .",
    "we see that @xmath200 this is the analogue of the _ lorentz cone _ in special relativity theory , but with the @xmath57 norm instead of the @xmath201 norm .    to use the vocabulary from relativity theory , identifying the @xmath33 part with the space coordinates and the @xmath202 coefficient with the time coordinate , @xmath119 is the _ causal order _ and @xmath123 if the _ space - time interval _",
    "@xmath203 $ ] is _ time - like _ or _ light - like _ , whereas @xmath204 if @xmath205 $ ] is _ space - like _ or light - like .",
    "other considerations , using domain - theoretic methods , on the causal order in the case of the @xmath201 lorentz cone can be found for instance in @xcite .",
    "we will show in this section that @xmath181 is almost a bounded complete partial order ( bcpo ) .",
    "it is not a bcpo because there is not in general any least upper bound .",
    "this is a consequence of @xcite : as the cone @xmath206 of our partial order has @xmath207 generators ( the generators of the polyhedron which is the unit @xmath208 ball ) , it can not be simplicial , hence @xmath181 is not a lattice .",
    "instead , there are in general infinitely many _ minimal upper bounds _ , which will suffice for our semantics purposes .",
    "we prove furthermore that _ many _ bounded subset of @xmath70 ( `` enough '' again ) admit minimal upper bounds .",
    "we first recall the definition of a minimal upper bound or _ mub _",
    "( maximal lower bounds , or _ mlb _ , are defined similarly ) :    let @xmath209 be a partial order on a set @xmath210 .",
    "we say that @xmath211 is _ a mub _ of two elements @xmath212 of @xmath210 if and only if    * @xmath211 is an upper bound of @xmath65 and @xmath213 , i.e. @xmath214 and @xmath215 , * for all @xmath216 upper bound of @xmath65 and @xmath213 , @xmath217 implies @xmath218 .",
    "we note that for the order @xmath119 , we have a very simple characterization of mubs , if they exist ( proving existence , and deriving some formulas , when available , are the aims of the section to come ) .",
    "[ mubs ] [ necmin ] let @xmath47 and @xmath105 be two elements of @xmath70 .",
    "then @xmath183 is a mub of @xmath47 and @xmath105 if and only if    * @xmath219 and @xmath220 , * @xmath221 is minimal among the @xmath222 , for all @xmath223 upper bounds of @xmath47 and @xmath105 .",
    "suppose we have @xmath183 such as defined above .",
    "take any upper bound @xmath223 of @xmath47 and @xmath105 and suppose @xmath224 . then",
    ": @xmath225 . hence , @xmath226 .",
    "but by hypothesis , @xmath221 is minimal among all upper bounds , so @xmath227 .",
    "then this implies @xmath228 so @xmath229 as well , hence @xmath230 .",
    "@xmath110    in what follows , we will need an extra definition :    let @xmath65 and @xmath213 be two intervals .",
    "we say that @xmath65 and @xmath213 are in generic positions if , whenever @xmath231 , @xmath232 or @xmath233 .    by extension",
    ", we say that two affine forms @xmath47 and @xmath105 are in generic position when @xmath234 and @xmath235 are intervals in generic positions .      for any interval @xmath27 , we note @xmath236 its center .",
    "let @xmath237 denote the minimum of the two real numbers , and @xmath238 their maximum .",
    "we define @xmath239 ,   |\\alpha| \\mbox { minimal}\\}\\ ] ] @xmath240 , \\\\",
    "|\\alpha| \\mbox { maximal}\\}\\ ] ]    [ join1 ] let @xmath241 .",
    "there exist minimal upper bounds @xmath242 of @xmath34 and @xmath243 if and only if @xmath244 moreover , the minimal upper bounds , when they exist , all satisfy @xmath245 @xmath246 and they are such that @xmath247 and @xmath248 .",
    "we first characterize @xmath221 by expressing @xmath249 and @xmath250 : @xmath251 the smallest possible @xmath221 thus is @xmath252 let us now characterize solutions with such a @xmath221 , they satisfy : @xmath253 thus implying that @xmath254 , which is equivalent to ( [ minmax ] )",
    ". also , these solutions are such that @xmath255 and @xmath248 .",
    "thus , there exist solutions only is @xmath256 and @xmath257 , and the combination of these two equalities , with @xmath221 defined by ( [ beta_opt ] ) , is equivalent to ( [ exist_mub ] ) .",
    "let us now check that there exist minimal upper bounds under this assumption : we must prove that if ( [ exist_mub ] ) holds , there exists @xmath242 satisfying ( [ beta_opt ] ) and ( [ minmax ] ) such that @xmath258 first part of this equality is always satisfied when ( [ minmax ] ) holds .",
    "second part is about the existence of solutions to @xmath259 . using ( [ exist_mub ] ) , we have @xmath260 and @xmath261 , so there exists indeed such minimal upper bounds @xmath242 when ( [ exist_mub ] ) is satisfied .",
    "@xmath110    [ ex_u_0 ] take @xmath262 and @xmath263 , condition ( [ exist_mub ] ) is not satisfied , so there exists no minimal upper bounds . indeed , minimal upper bounds would be @xmath264 , with @xmath265 and @xmath266 . and",
    "expressing @xmath267 gives @xmath268 , which is not admissible ( not in [ 0,1 ] ) .",
    "we note that when @xmath34 and @xmath243 do not have @xmath84 symbols , there always exist minimal upper bounds . in the case",
    "when they do not exist , we will use a widening introduced in definition [ widen_1 ] .",
    "[ ex_u_1 ] take @xmath269 and @xmath270 .",
    "we have @xmath271 $ ] and @xmath272 $ ] , so @xmath34 and @xmath243 are in generic positions .",
    "minimal upper bounds @xmath242 of @xmath34 and @xmath242 are @xmath273 where @xmath274 .",
    "this implies @xmath275 , with @xmath276 , and @xmath277 . among these solutions ,",
    "we find a unique one that minimizes the width of the concretization , by taking @xmath278 and thus @xmath279 .",
    "this solution satisfies @xmath280 , @xmath281 and @xmath282 . in proposition",
    "[ join2 ] , we show that this is a general result when @xmath34 and @xmath243 are in generic positions .",
    "[ ex_u_2 ] now take @xmath269 and @xmath283 , this time @xmath284 and @xmath285 are not in generic positions .",
    "minimal upper bounds @xmath242 are : @xmath286 where @xmath287 , @xmath276 , and @xmath288 .",
    "now , let us minimize the width of the concretization as in the previous example .",
    "the problem is that we can not choose in this case @xmath289 because then the value of @xmath290 ( -1 ) deduced from @xmath287 is not admissible ( it is not beween 0 and 1 ) .",
    "the solution minimizing the width of the concretization is in fact @xmath291 , and it is such that @xmath281 and @xmath280 .",
    "we now give an intuition on the general case by taking examples with several noise symbols .",
    "[ ex_u_3 ] take @xmath292 and @xmath293 .",
    "we have @xmath294 $ ] and @xmath295 $ ] , @xmath284 and @xmath285 are in generic positions .",
    "minimal upper bounds are @xmath296 where @xmath297 , @xmath298 , @xmath299 , and @xmath300 . among these solutions",
    ", we can still find a unique one that minimizes the width of the concretization , taking @xmath301 , @xmath302 and @xmath303 : @xmath304 .",
    "[ ex_u_4 ] take @xmath305 and @xmath306 .",
    "we have @xmath307 $ ] and @xmath308 $ ] , so here @xmath284 and @xmath285 are not in generic positions .",
    "minimal upper bounds are @xmath309 where @xmath310 , @xmath311 , @xmath312 , @xmath300 and @xmath313 . again , as in example [ ex_u_2 ] , minimizing the concretization of @xmath314 by minimizing the absolute value of @xmath315 , @xmath316 and @xmath317 does not give an admissible solution ( when @xmath302 , @xmath303 , @xmath318 , relation @xmath310 gives @xmath319 which is not admissible ) .",
    "but , as the minimal concretization for @xmath242 is in any case @xmath320 , we can try to impose it .",
    "this gives @xmath321 , and an additional relation @xmath322 .",
    "+ all solutions @xmath323 with @xmath312 , @xmath300 , @xmath324 , @xmath325 and @xmath326 are minimal upper bounds with minimum concretization , and there are an infinite number of them , we can choose for example @xmath327 or @xmath328 , etc .",
    "[ join2 ] let @xmath241 , such that ( [ exist_mub ] ) holds",
    ". if @xmath284 and @xmath285 are in generic positions , then @xmath242 defined by ( [ beta_opt ] ) and @xmath329 is the unique minimal upper bound of @xmath34 and @xmath243 whose concretization is the union of the concretization of @xmath34 and @xmath243 .    if @xmath284 and @xmath285 are not in generic positions and @xmath330 ( we get symmetric properties when @xmath331 ) , then all @xmath242 satisfying ( [ beta_opt ] ) , ( [ minmax ] ) , and @xmath332 @xmath333 are minimal upper bounds with concretization the union of the concretization of @xmath34 and @xmath243 .    indeed , the solution with minimal concretization is particularly interesting when computing fixpoint in loops , by preserving the stability of the concretizations of variables values in iterates , as we will see in theorem [ thm ] .",
    "we want to find @xmath334 such that the concretization is the smallest possible , with the above conditions still holding . for that",
    ", we have to minimize @xmath335 with constraints ( [ minmax ] ) , we thus set @xmath336    for this choice of the @xmath334 , then for all @xmath337 , we can prove the two following properties :    @xmath338 : let us now , using @xmath255 and @xmath248 , write @xmath339 and express it using property ( [ prop1 ] ) .",
    "+ when @xmath340 , we can then show that it can be rewritten as @xmath341 and , using ( [ prop2 ] ) , that @xmath342 when @xmath343 , and @xmath284 and @xmath285 are in generic positions , then @xmath344 is the minimum of @xmath320 , and @xmath345 its maximum .",
    "so @xmath346 is indeed the center of @xmath320 , and the concretization of @xmath242 thus defined is the minimal possible , that is @xmath320 .",
    "the proof is of course symmetric when @xmath347 .",
    "now if @xmath284 and @xmath285 are not in generic positions , and for instance here @xmath330 , then we can use @xmath348 in ( [ alp0 ] ) to deduce @xmath349 and @xmath350 in ( [ alp0 ] ) to deduce @xmath351 , which is not admissible .",
    "so @xmath242 given by @xmath352 is not a minimal upper bound in the non generic case . in order to have minimal concretization , we must have @xmath353 , and @xmath354 which can be rewritten @xmath355 equivalent to ( [ min ] ) .",
    "the proof and conditions are of course symmetric when @xmath331 .",
    "@xmath110    note that , as we will show in section [ riesz ] , the join operator thus defined is not associative in the non generic case .",
    "what s more , as we will see , the affine form obtained by two successive join operations may not even be a minimal upper bound of the three joined affine forms . in section , [ riesz ] , we will thus introduce a first ( associative ) widening of this join operation , which we will use to define a partial order .",
    "if @xmath181 admitted binary least upper bounds , then we would have a riesz space , for which @xmath356 would be defined as @xmath357 . here",
    ", we have a different formula , linking @xmath358 with @xmath359 in some interesting cases .",
    "intersections will produce _ negative _ @xmath202 coefficients , where unions were producing _ positive _ @xmath202 coefficients .",
    "[ meetbeta ] for all @xmath47 , @xmath105 in @xmath70 , there exist _ maximal lower bounds _ ( or mlb ) @xmath183 of @xmath47 and @xmath105 if and only if @xmath360    they then all satisfy ( for all @xmath361 ) : @xmath362 @xmath363    being a lower bound of @xmath65 and @xmath213 means : @xmath364 summing the two inequalities , and using the triangular inequality : @xmath365 hence @xmath366 giving an upper bound .",
    "as we want a maximal @xmath211 , the natural question is whether we can reach this bound .",
    "this is the case when the triangular inequality for @xmath57 norm is an equality , which is the case when @xmath367 .",
    "a solution exists to these constraints only if ( [ exist_mlb ] ) is satisfied , as for the proof of proposition [ join1 ] .",
    "@xmath110    contrarily to the join operators , we can not in general impose ( even in generic position ) for a mlb @xmath183 to have a given concretization , such as @xmath368 , or even a smaller value , such as the interval that contains all values that @xmath369 and @xmath370 share for some @xmath371 $ ] .",
    "consider @xmath372 $ ] and @xmath373 $ ] .",
    "they are in generic position . then @xmath183 is a mlb with concretization @xmath374 $ ] if and only if @xmath375 , @xmath376 , @xmath377 , @xmath299 and @xmath378 .",
    "suppose @xmath315 is positive , then we want to have @xmath379 and @xmath380 , which is impossible .",
    "so @xmath315 is negative and we want to solve @xmath381 and @xmath380 , therefore , @xmath382 and @xmath383 , which is impossible because we precisely asked @xmath315 for being positive ( and @xmath290 to be less than 2 ) .    in some cases though , such mlb operators exist and we can give an explicit formula :    [ argmax ] in case @xmath47 and @xmath105 are in generic positions , ( [ exist_mlb ] ) is satisfied , and @xmath384 for all @xmath337 , there exists a maximal lower bound @xmath183 with @xmath385 , given by the formulas :    * @xmath386 * @xmath387 for all @xmath337 * @xmath388    in this case , we have : @xmath389    the formula for @xmath221 is given by lemma [ meetbeta ] .",
    "the fact that the concretization of @xmath183 is @xmath390 implies the formula for @xmath391 .    the formulas for @xmath392",
    ", @xmath337 can be checked easily as follows : as @xmath234 and @xmath235 are in generic positions , @xmath393 and @xmath234 ( similarly with @xmath235 ) are in generic positions .",
    "thus we can use the formula of proposition [ join2 ] for the join operator , to compute @xmath394 and @xmath395 .",
    "it is easily seen now that for @xmath396 , and @xmath397 , @xmath398 @xmath399 hence @xmath400 and @xmath401 for all @xmath361 .",
    "furthermore , @xmath402 and @xmath403 hence @xmath404 and @xmath405 .",
    "finally , again because of this equality and concretizations , and that all coefficients but @xmath406 ( respectively @xmath407 ) have been shown equal to the ones of @xmath47 ( respectively @xmath105 ) , we have necessarily that @xmath408 ( respectively @xmath409 ) .    therefore @xmath410 and @xmath411 so @xmath211 is a lower bound of @xmath65 and @xmath213 . because of the value of @xmath221 , by lemma [ meetbeta ] and [ necmin ] ( adapted to mlbs ) , @xmath211 is an mlb ( with the right concretization ) .",
    "@xmath110      we prove that we have almost bounded completeness of @xmath70 . unfortunately ,",
    "as shown in example [ nonassoc ] , this is barely usable in practice , and we resort to a useful sub - structure of @xmath70 in section [ widen ] ( in particular , with a view to section [ convsection ] ) .    @xmath181 is a quasi bounded - complete partial order ( or is quasi-``dedekind - complete '' ) , meaning that any bounded subset @xmath20 of @xmath70 such that for all @xmath47 , @xmath105 in @xmath20 @xmath412 has a minimal upper bound in @xmath70 .",
    "let @xmath211 be an upper bound of all @xmath413 .",
    "this means again , for all pairs @xmath414 that @xmath415 we can always suppose that @xmath416 . as @xmath315 dominates all @xmath413 , we have , using the triangular inequality : @xmath417 so @xmath418 .",
    "this means that we can write : @xmath419 which exists in @xmath39 .",
    "similarly to the proof of proposition [ join1 ] , condition [ quasibounded ] allows to prove existence of a solution to the mub equations .",
    "@xmath110    unfortunately , even if we pick one of the possible join operators , they are not in general associative operators , which means that even for countable subsets @xmath20 of @xmath70 , according to the iteration strategy we choose , we might end up with a non - minimal upper bound .    [ nonassoc ] take @xmath420 when computing with one of the possible join operators previously defines , we obtain @xmath421 with @xmath422 , @xmath423 , @xmath424 , @xmath425 , and @xmath426 .",
    "we see on this example that , in the case where all concretizations are not in generic positions , the join operator is not associative",
    ". moreover , the result of two successive join operations may not be a minimal upper bound of three affine forms because we do not always get the same @xmath202 coefficient ( 5 when computing @xmath427 , and 4.5 when computing @xmath428 .",
    "indeed , we have here @xmath429 when @xmath430 .",
    "we fix this difficulty in next section .      in practice",
    ", we obtain a stronger sub - structure by using a widening instead of the minimal upper bound :    [ widen_1 ] we define the widening operation @xmath431 by    * @xmath432 * @xmath433 for all @xmath337 , * @xmath434    in the case when @xmath34 and @xmath243 are in generic positions , @xmath435 is the union defined in section [ sec_join ] .",
    "otherwise , @xmath436 has as concretization the union of the concretizations of @xmath34 and @xmath243 , it is an upper bound of @xmath34 and @xmath242 ( but it is not a minimal upper bound with respect to @xmath119 , because @xmath221 is not minimal ) .",
    "this operator has the advantages of presenting a simple an explicit formulation , a stable concretization with respect to the operands , and of being associative .",
    "[ computational order ] let @xmath437 be the binary relation defined by : @xmath438 then , @xmath437 is a partial order .",
    "reflexivity comes from @xmath439 .",
    "antisymmetry is trivial .",
    "transitivity comes from the associativity of @xmath435 .",
    "@xmath110    @xmath440 if and only if :    * @xmath441 and * for all @xmath361 , @xmath442 or @xmath443    the first condition ensures that @xmath444 and @xmath445 .",
    "take @xmath337 .",
    "if @xmath446 then because @xmath447 , @xmath448 has to be zero .",
    "otherwise , this translates precisely to the second condition .",
    "we define operation @xmath449 by    * @xmath386 * @xmath387 for all @xmath337 , if @xmath384 , otherwise @xmath450 * @xmath451    [ completelattice ] @xmath452 is a bounded complete lattice , with :    * @xmath435 being the union , * @xmath453 being the intersection .    easy verification for the binary unions and intersections .",
    "take now @xmath454 and @xmath315 such that @xmath455 .",
    "then @xmath456 for all @xmath457 , so @xmath458 has finite bounds .",
    "this gives us @xmath459 .",
    "consider now any countable filtration of @xmath20 by an increasing sequence of finite subsets @xmath460 , @xmath461 , and consider @xmath462 any minimal upper bound of @xmath460 .",
    "we know that @xmath463 is a decreasing sequence of positive real numbers when @xmath8 increases , so it converges .",
    "we also know that the sign of @xmath464 remains constant , so @xmath464 converges , say to @xmath465 .",
    "last but not least , let @xmath466 , we argue that @xmath467 is a minimal upper bound of @xmath20 in @xmath70 .",
    "@xmath110    this allows to use @xmath435 ( and @xmath453 ) as effective widenings during the iteration sequence for solving the least fixed point problem .",
    "this is where all properties we studied fit together , to reach the important theorem [ thm ] , stating good behavior of the kleene - like iteration schemes defined in section [ iteration ] .",
    "first , we show that we must improve the computation of the abstract semantic functional , between two union points , this is explained in section [ shiftoperator ] .",
    "we also improve things a little bit , on the practical side , by defining new widening operators , in section [ realwiden ] .",
    "one problem we encounter if we are doing the blind kleene iteration in the lattice of proposition [ completelattice ] , is that we introduce @xmath84 coefficients , for which the semantics of arithmetic expressions is far less well behaved than for `` ordinary '' noise symbols @xmath30 .",
    "[ exxmoinsax ] let us give a first simple example of what can go wrong .",
    "consider the following program :    .... f(real a ) {    real x ;    x = input(-1,1 ) ; [ 1 ]    while ( true )      x = x - a*x ; [ 2 ] } ....    suppose that ` a ` can only be given values between ( strictly ) @xmath468 and @xmath469 , then it is easy to see that this scheme will converge towards zero , no matter what the initial value of @xmath65 is .",
    "as the scheme is essentially equivalent , in real numbers to @xmath470 , with @xmath471 , a simple kleene iteration scheme should converge .",
    "let us look at the successive iterates @xmath472 at control point [ 2 ] , of this scheme .",
    "first , note that @xmath473 ( or equivalently @xmath474 starting with @xmath475 ) , where @xmath476 stands for the noise symbol introduced by assignment at control point [ 1 ] ) .",
    "@xmath477 because the semantics of @xmath101 on @xmath84 symbols can not cancel out its coefficients _ a priori_. we will see a bit later that under some conditions , we can improve the semantics _",
    "locally_.    to carry on with this example , let us particularize the above scheme to the case @xmath478 : @xmath479 \\end{array}\\ ] ] we already see that the concretization of @xmath480 is bigger than @xmath481 $ ] showing loss of precision , even to simple interval computations .",
    "the next iterations make this interval grow to infinity .",
    "if we could have written @xmath482 instead of @xmath483 the iteration sequence would have been convergent .",
    "we are going to explain that we can make sense of this .",
    "we first introduce a _ shift _",
    "operator , that decreases the current abstract value .",
    "[ shift ] let @xmath484 .",
    "define , for @xmath47 with finitely many non - zero coefficients : @xmath485 where @xmath108 is a `` fresh '' symbol .",
    "then for all @xmath486 , @xmath487 .",
    "the idea is that , after some unions , during a kleene iteration sequence , such as right after the union in semantic equation [ badeq ] , of example [ exxmoinsax ] , we would like to apply the @xmath488 operator , allowing us to get an equation equivalent to ( [ goodeq ] ) .",
    "the full formalization of this refined iteration scheme is outside the scope of this paper .",
    "it basically relies on the following observation of our abstract semantics :    _ all concrete executions of a program correspond to a unique choice of values between -1 and 1 , of @xmath489 ( for all join control points ) .",
    "_ hence , locally , between two join control points , @xmath84 coefficients act as normal @xmath30 coefficients . hence one can use @xmath488 to carry on the evaluation of the abstract functionals after each control point where a union was computed , corresponding to a branching between several concrete executions .",
    "we carry on with the example [ exxmoinsax ] .",
    "we use now the new semantic equation : @xmath490 .",
    "therefore , the successive iterates , for @xmath478 are : @xmath491 where @xmath492 in the last iterate .",
    "therefore , @xmath493 .",
    "the successive iterates will converge very quickly to @xmath494 with concretization being @xmath481 $ ] and no surviving relation .",
    "[ iteration ]    as we have almost bounded completeness , and not unconditional completeness , our iteration schemes will be parametrized by a large interval @xmath495 : as soon as the current iterate leaves @xmath495 , we end iteration by @xmath496 ( that we can choose to represent by @xmath497 by an abuse of notation ) .",
    "the starting abstract value of the kleene like iteration of definition [ iter ] is as usual @xmath498 , that , in theory , we should formally introduce in the _ lifted _ domain of affine forms ( but that , by an abuse of notation , we can represent by @xmath499 ) .    in order to get good results , we need in particular _",
    "cyclic unfolds_. they are defined below :    [ iter ] let @xmath27 and @xmath316 be any positive integers , @xmath500 be any of the operators @xmath359 ( for some choice of a mub ) , or @xmath435 .",
    "the @xmath501-iteration scheme of some functional @xmath502 is as follows :    * first unroll @xmath27 times the kleene iteration sequence , starting from @xmath498 , i.e. compute @xmath503 .",
    "* then iterate : @xmath504 starting with @xmath505 .",
    "* end when a fixpoint is reached or with @xmath496 if @xmath506 .",
    "note that initial unfolding are important for better precision but will not be used in the sequel .",
    "we prove that our approach allow us to find good estimates for the real bounds of general affine recurrences ( i.e. _ linear recursive filters _ of any order ) , see section [ affine ] .",
    "the only abstract domains known to be able to give accurate results are the one of @xcite , which only deals with filters of order 2 , and the one of @xcite , which is specialized for digital filters ( which is not the case of our abstraction ) .",
    "we consider again the class of programs of section [ affine ] .",
    "[ thm ] suppose scheme ( [ lrf ] ) has bounded outputs , i.e. the ( complex ) roots of @xmath507 have module strictly less than 1 .",
    "then there exists @xmath508 such that the @xmath509-iteration scheme ( see section [ iteration ] ) converges towards a finite over - approximation of the output .    in other words , the perturbed numerical scheme solving the fixpoint problem",
    "is also bounded .",
    "being a fixed point of abstract functional @xmath510 ( giving the abstract semantics of the one iteration of the loop ) means @xmath511 define @xmath512 then the fixpoints of @xmath510 are determined by the fixed points @xmath211 : @xmath513    suppose first that @xmath514 .",
    "consider now the interval fixpoint equation resulting from ( [ fixpointeq ] ) .",
    "as @xmath79 commutes with @xmath435 , by definition , and because of lemma [ base ] , it transforms into @xmath515 this equation shows that @xmath516 is a pre - fixpoint of the interval abstraction of our linear scheme .",
    "it is well known that in the case @xmath514 , this interval abstraction admits a bounded least fixpoint @xmath517 .",
    "hence , @xmath211 in this case is bounded by @xmath517 ( for order @xmath119 , when @xmath517 is written as @xmath518 , with @xmath519)=\\frac{b - a}{2}$ ] ) , hence has finite concretization .",
    "in fact , not only @xmath211 but all the ascending sequence of the @xmath520-iteration scheme from @xmath498 is bounded by @xmath517 . note that any ascending sequence for any @xmath521-iteration scheme is also ascending for the partial order @xmath437 . by proposition [ completelattice ] , it has a least upper bound , which is the least fixed point of @xmath510 for partial order @xmath437 , because of the obvious continuity ( in the @xmath57 sense ) of @xmath510 . hence again",
    ", this fixed point is bounded by @xmath517 so has finite concretization .    secondly ,",
    "if the roots of @xmath507 have module strictly less than 1 , then there exists @xmath508 such that @xmath522 is a filter of order @xmath523 in the inputs @xmath12 , and @xmath0 in the outputs with coefficients @xmath524 , @xmath525 such that latexmath:[$\\sum_{i=1}^{n }    affine forms is exact on affine computations ( because of the use of the shift operator ) .",
    "we can then apply the result above to reach the conclusion .",
    "@xmath110    more generally , and this is beyond the scope of this article , we can show that there exist @xmath527-iteration schemes that will come _ as close as we want _ to the exact range of values that @xmath65 can take .",
    "we carry on with example [ transf2 ] .",
    "we see that matrix @xmath20 in our case is @xmath528 and of course , the @xmath57 norm of the rows of @xmath20 is bigger than 1 . iterating @xmath20 , we see that : @xmath529 is the first iterate of @xmath20 with @xmath57 norm of rows less than 1 . we know by theorem [ thm ] that a @xmath530-iteration scheme will eventually converge to an upper approximation of the invariant ( which we can estimate , see example [ transf22 ] , to [ -1.12124069 ... ,2.82431841 ... ] )",
    ". here is what @xmath531-iteration schemes give as last invariant and concretization , when @xmath27 is greater than 5 ( rounded , for purposes of readability ) :    [ cols=\"^,^,^\",options=\"header \" , ]     note that although the convergence to this invariant is _ asymptotic _ ( meaning that we would need in theory an infinite kleene iteration to reach the invariant ) , in _ finite precision _ , the limit is reached in a finite number of steps . in the case of the @xmath532-iteration scheme , the fixpoint is reached after 18 iterations . in some ways , we have replaced the numerical scheme ( a filter of order 2 here ) , by an _",
    "abstract numerical scheme _ which has similar convergence properties , and can be simulated in a finite time and in a _ guaranteed manner _",
    ", accurately .",
    "we can also use _ extrapolation _ or _",
    "widening _ techniques , for which we will show some results in example [ usewidening ] .    note also that none of the noise symbols survived in the final invariant : there is no dependency left with the successive inputs , when looking at the overall invariant .",
    "this is very easily shown on the first few kleene iterates already .",
    "we denote by @xmath472 the affine form at control point [ 2 ] , @xmath533 the affine form at control point [ 3 ] , at iteration @xmath27 , for the @xmath532-iteration scheme .",
    "we have ( as produced by our prototype implementation ) : @xmath534    finally , you should note that theorem [ thm ] is not limited by any means to finding invariants of such filter programs with independent inputs , or independent initial conditions .",
    "for instance , if all the inputs over time are equal , but unknown numbers between 0 and 1 , the final invariant has concretization [ -0.1008,2.3298 ] .",
    "we can define numerous widening operators , among which the following :    the operator @xmath535 defined by @xmath536 such that    * @xmath432 , * @xmath537 for all @xmath337 such that @xmath538 , * @xmath539 for all @xmath337 such that @xmath540 , * @xmath434    gives an upper bound of @xmath34 and @xmath243 that can be used as an efficient widening .",
    "[ usewidening ] now we are carrying on with example [ transf2 ] , but this time we apply the widening defined above after 1 normal iteration step . for @xmath27 equal to 5 , fixpoint is reached at iteration 9 , and for @xmath27 equal to 16 , it is reached at iteration 4 , with precision equivalent to the case without widening .",
    "this time , convergence is reached in finite time , by construction ( and not because of `` topological '' convergence ) .",
    "we discuss in this section very promising improvements of the above schemes , which we feel are important to mention here .",
    "but , as they are not fully formalized yet , we mostly demonstrate them on examples .",
    "[ betaneg ]      as we introduced ( definition [ shift ] ) the possibility to shift the union symbols to `` classical '' noise symbols in the iteration scheme , it becomes important to create as few union symbols as possible , in order not to lose relations .",
    "this can be partly solved by an adapted refined iteration strategy : when there is a cycle of explicit dependency between variables , make the union only on one variable and apply immediately the shift operator of definition [ shift ] , before this union is propagated to the other dependent variables .",
    "consider the following program , implementing a second - order filter ( where xnp1 stands for @xmath541 , xn stands for @xmath542 and xnm1 stands for @xmath543 ) :    ....    real xnp1,xn , xnm1 ;    xn = [ 0,1 ] ;    while ( true ) {      xnp1 = 1.2*xn - 0.8*xnm1 ;      xnm1 = xn ; xn = xnp1 ;     } ....    in this program , we have @xmath544 , where @xmath8 is the current iteration of the loop , so it is clearly a bad idea to make unions independently on @xmath188 and @xmath543 .    before the loop , @xmath545 , and after first iteration of the loop , @xmath546 , @xmath547 .    applying the classical join operations to @xmath548 and @xmath549 at the beginning of the loop after first iteration gives @xmath550 , @xmath551 .",
    "+ then , after applying the shift operator ( with a new symbol @xmath552 for @xmath553 , and a new symbol @xmath554 for @xmath555 ) , we get @xmath556 , and @xmath557 $ ]",
    ".    then @xmath558 , @xmath559 , and after applying a shift that creates new symbols @xmath560 and @xmath561 , we get @xmath562 and @xmath563 $ ] .",
    "of course , in practice , cyclically unrolling the loop allows to care with the bad behavior of the scheme , but it is better to refine as well the iteration as follows .    applying the join and shift operations on @xmath188",
    "only , we write @xmath564 , and @xmath565 , and @xmath566 $ ]",
    ".    then @xmath567 and @xmath568 , @xmath569 $ ] .",
    "we dealt here with an example where the dependencies between variables were explicit , but we can also generalize this and introduce symbols to explicit and preserve implicit dependency , as in example [ ex_improve_2 ] :    [ ex_improve_2 ] take the following program :    .... real x , y ; x = 1 ; y = 0 ; for ( x=1 ; x<=10000 ; x++ )    y = y + 2 ; ....    if we apply standard union , we get for example after first iteration , union and shift : @xmath570 and @xmath571 .",
    "we can not use the above strategy for using union on one variable only , because variables @xmath65 and @xmath213 are no explicitly linked .",
    "still , we can observe that , before or inside the loop , @xmath65 and @xmath213 are always such that @xmath572 .",
    "so , in order to construct a joint union on @xmath34 and @xmath243 that preserves this relation , we can just use union and shift on @xmath34 ( @xmath570 ) , and then simply deduce @xmath213 by @xmath573 , thus expressing relations that will be usable in further computation . and of course the same operation can be repeated again for the following iterations of the loop , as affine relations are preserved by affine arithmetic : here @xmath574 and @xmath575 , we still have @xmath576 .    and indeed , for practical realization , when making unions over a set of variables , it is easy for example to consider couple of variables , and first investigate whether or not they satisfy the same affine relation on the two states , and if it is the case propagate the union over one variable on the other .",
    "take the following program :    .... real x , y , z ; z = [ 0,1 ] ; if ( z < 0.5 ) {    x = 1 ; y = -1 ; } else { x = 0 ; y = 1 ; } if ( y > 0 )    x = x + y ;   ....    the result for @xmath65 of the execution of this toy example , is always @xmath577 , whatever @xmath578 $ ] .",
    "expliciting the dependency between @xmath65 and @xmath213 ( we can always do so with constants ) : in the two branches taken after the first test , we have @xmath579 , then we write @xmath580 , and @xmath581 after joining the results from the two branches . then , interpreting test @xmath582 leads to add constraint @xmath583 , but this is not enough to deduce @xmath577 .",
    "then , we can note that for example @xmath580 should denote a disjoint union of two values 1 and 0 , thus in this case symbol @xmath552 no longer takes all values in @xmath481 $ ] , but only the two values -1 and 1 .",
    "then , when test @xmath582 is true , then @xmath584 , @xmath585 , and when it is false , then @xmath34 is naturally equal to 1 .",
    "we have _ proved _ that our abstract domain behaves well for an interesting class of numerical programs .",
    "more work has yet to be done on the formalisation of the shift operator ( section [ shiftoperator ] ) and on more general schemes , such as some non - linear schemes of interest .",
    "many questions arise also from this work .",
    "for instance , can we replace affine forms ( but @xmath586 ) by higher - order taylor models ?    also ,",
    "most of our proofs only rely on the general properties of norms , and not specifically on @xmath57 .",
    "what do we get with the @xmath587 norms , and in particular with the standard lorentz cone , when considering @xmath201 ?",
    "many techniques are available here that could help , in particular the techniques of _ second - order cone programming_.    our main convergence result ( theorem [ thm ] ) can be recast as a fixpoint property of some general @xmath588 functions .",
    "can we use policy iteration techniques @xcite to help solve these ?",
    "last but not least , property [ spectral ] rings a bell and looks like phenomena appearing with spectral measures ( measures with value in a banach space ) .",
    "is this also generalizable to affine forms where @xmath30 are random variables of some sort ?"
  ],
  "abstract_text": [
    "<S> we completely describe a new domain for abstract interpretation of numerical programs . </S>",
    "<S> fixpoint iteration in this domain is _ proved _ to converge to finite precise invariants for ( at least ) the class of _ stable linear recursive filters of any order_. good evidence shows it behaves well also for some non - linear schemes . </S>",
    "<S> the result , and the structure of the domain , rely on an interesting interplay between order and topology .    </S>",
    "<S> [ validation ] [ mechanical verification ] [ program analysis ] theory , verification abstract interpretation , numerical programs </S>"
  ]
}