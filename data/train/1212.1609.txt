{
  "article_text": [
    "the problem we consider is a special case of makespan minimization , i.e. , the problem of scheduling a set of jobs @xmath0 on a set of machines @xmath1 with the objective of minimizing the maximum machine load . in the most general case of",
    "_ unrelated _ machines , each job @xmath2 has a processing time @xmath9 on machine @xmath10 an lp - rounding algorithm with an approximation factor of @xmath11 along with a proof of @xmath12-hardness , unless @xmath13 , are two classic results of @xcite . for more than 20 years , no progress has been made either on the approximation of the general case or on the lower bound .",
    "the @xmath12 lower bound holds also for the case with _ assignment constraints .",
    "_ in this setting , each job @xmath4 can be scheduled on any machine from a subset @xmath3 of @xmath1 .",
    "the processing time @xmath14 of @xmath4 is the same for any machine in @xmath5 for this case it was recently shown in @xcite that a strong lp - relaxation called the configuration lp has an integrality gap of at most @xmath15 .",
    "the proof of this exciting result is non - constructive , in the sense that it does not actually provide a polynomial - time algorithm that finds such a solution .",
    "the best known polynomial - time algorithm that computes a near - optimal schedule is still the @xmath11-approximation algorithm of @xcite .",
    "a slight improvement to @xmath16 was given by @xcite .",
    "the makespan minimization problem is one of the most important problems in scheduling .",
    "advancement on the approximation of the unrelated case appears as one of the top @xmath17 open problems in approximation algorithms in the listing of @xcite . due to the importance of the problem several special cases have been considered , where further restrictions are imposed either on the sets @xmath18 or on the domain of the processing times .    in the case of _",
    "graph balancing _",
    "each job can be scheduled on at most 2 machines .",
    "one can interpret this as the following problem : we are given an undirected graph with weighted edges and we are asked to direct the edges towards the nodes so as to minimize the maximum weighted in - degree over all nodes . an lp - rounding algorithm achieving an approximation factor of @xmath19",
    "was given in @xcite .",
    "the lp used is that of @xcite with the addition of a valid set of inequalities .",
    "the considered lp has an integrality gap of @xmath11 when we allow jobs that can be scheduled on @xmath20 machines @xcite .",
    "the case of graph balancing with no parallel edges and with integer edge weights had been previously considered in @xcite under the name _",
    "graph orientation_. among other results",
    "@xcite gave a combinatorial @xmath21-approximation algorithm when weights are from the set @xmath22    the natural case when jobs can be either `` big '' or `` small '' , i.e. , the processing times can only take one of two values gives rise to particularly difficult instances",
    ". the unrelated version of graph balancing with only @xmath11 distinct edge weights seems to capture a major portion of the difficulty of the general scheduling problem on unrelated machines .",
    "it was recently shown in @xcite that even when there are @xmath11 distinct edge weights and an edge may have different weights for each endpoint , the configuration lp has an integrality gap of @xmath11 .",
    "for scheduling with assignment constraints , @xmath12-hardness holds also for the case when there are only @xmath11 distinct processing time values @xcite and the integrality gap of the natural lp of @xcite is still @xmath11 @xcite .    motivated by the above",
    ", we study the _",
    "2-valued _ case of minimizing makespan with assignment constraints , where jobs are of two sizes , namely @xmath6 ( big ) and @xmath7 ( small ) .",
    "= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = as mentioned , the approximation hardness of the problem is still @xmath23 unless @xmath13 ( @xcite,@xcite ) and the integrality gap of the natural lp of @xcite is still @xmath11 @xcite .",
    "= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = we present a simple algorithm for the case when the job sizes are @xmath24 and @xmath25 which approximates the value of the optimal solution within a ratio of @xmath26 and then we show how to use this algorithm as a black - box subroutine to get an approximation when the job sizes are nonnegative real numbers . combining our algorithm with the non - constructive result of @xcite",
    "we get an improved non - constructive approximation guarantee of @xmath8 for the @xmath11-valued case of makespan with assignment constraints .",
    "the same algorithm can be used to obtain an efficient @xmath27 approximation for the @xmath11-valued graph balancing , where additionally for every @xmath4 we have @xmath28 , improving and generalizing the result of @xcite . note that even for the 2-valued graph balancing it remains np - hard to compute a better than @xmath12-approximate solution @xcite .",
    "this section describes a subroutine which will be used in our algorithms . apart from a few details , the network construction and the rounding argument follow from @xcite .",
    "similar to @xcite , our algorithm takes as a parameter an estimation @xmath30 of the makespan of the optimal solution . using binary search",
    ", we find the smallest @xmath30 for which our algorithm returns a ( possibly fractional ) solution . as we will show , that @xmath30 is a lower bound to the makespan of the optimal solution .    here and in the following sections we make the assumption that the optimal makespan is less than twice the size of the biggest job @xmath6",
    "this is w.l.o.g . since the algorithm of @xcite returns a solution with makespan at most @xmath31 where @xmath32 is the optimum of the natural lp relaxation for the problem",
    "this is formalized in the following lemma .",
    "@xcite [ lemma : add ] if the optimal makespan to an instance of the problem is @xmath33 , where @xmath6 is the biggest job size , then there is @xmath12-approximation algorithm .",
    "= = = = = = = = = = = = = = = = = = = = = = = = =    the rounding algorithm of @xcite returns a solution with makespan at most @xmath34 .",
    "this is clearly a @xmath12 approximate solution .",
    "= = = = = = = = = = = = = = = = = = = = = =    the algorithm we describe is used for instances where the sizes of the jobs are integers , either 1 or @xmath35 .",
    "given such an instance of the problem , we construct the following multi - level network . on the first level we have a single source @xmath7 .",
    "on the next level we have one node @xmath36 for each job @xmath4 . for each such node @xmath36",
    "we have a directed edge from @xmath7 to @xmath36 of capacity equal to the size of job @xmath4 . on the level after that",
    ", we have a node @xmath37 for each machine @xmath38 this type of nodes is not actually representing the set of machines .",
    "their purpose is to limit the amount of flow from big jobs that may enter the machine nodes of the next level , enforcing the valid inequality of @xcite in our solution .",
    "we have a a directed edge of capacity @xmath39 from a node @xmath40 to a node @xmath37 iff @xmath4 is a big job that can be scheduled to machine @xmath41 . on the next level",
    "we have one node @xmath42 for each machine @xmath41 .",
    "we have a directed edge of capacity @xmath24 from each node @xmath40 , where job @xmath4 is a small job , to a node @xmath42 iff job @xmath4 can be scheduled on @xmath41 .",
    "we also have one directed edge of capacity @xmath39 from @xmath37 to @xmath42 .",
    "we connect each machine node @xmath42 to the sink @xmath43 at the last level using edges of capacity @xmath30 , where @xmath30 is our estimation for the makespan .",
    "see fig .",
    "[ fig : graph ] for an example .",
    "observe that while the flow from small job nodes is routed directly to the machine nodes , the flow from the big job nodes is routed through the nodes @xmath37 and then to the machine nodes .",
    "thus at most @xmath39 units of flow from big job nodes enter each machine node .",
    "a feasible flow solution is one that sends a total amount of flow equal to the sum of the processing times of the jobs . using binary search we find the minimum value of @xmath30 for which such a feasible solution exists .",
    "this is a lower bound on the optimum . to see why this is true , consider a solution @xmath44 to the problem instance with makespan @xmath30 .",
    "we construct the following network flow solution for the network corresponding to the instance with estimation @xmath30 or higher : for each job @xmath4 , we send from @xmath7 to @xmath36 flow equal to the size of @xmath4 .",
    "if @xmath4 is a small job assigned to machine @xmath41 by @xmath44 , then we send @xmath24 unit of flow from @xmath36 to @xmath42 .",
    "if @xmath4 is a big job assigned to machine @xmath41 by @xmath44 , then we send @xmath39 units of flow from @xmath36 to @xmath37 and then @xmath39 units to @xmath42 from @xmath37 ( there is at most one such big job for each machine  recall that because of lemma  [ lemma : add ] we consider only instances with @xmath45 ) .",
    "we send from each node @xmath42 to the sink @xmath43 all amount of flow that @xmath42 has received , which is at most @xmath30 .",
    "we interpret the network solution naturally as a fractional assignment : if a fraction @xmath46 of the flow that source @xmath7 sends to node @xmath36 is routed through the machine node @xmath42 then we assign a fraction @xmath46 of job @xmath4 to machine @xmath41 .",
    "= = = = we are only interested in instances of the problem for which the network has a feasible solution for some value of the parameter @xmath30 .",
    "if an instance has no feasible solution for any value of @xmath30 , it it is necessary to have at least 2 big jobs scheduled on the same machine . obtaining a @xmath12 approximation for such",
    "an instance is trivial via the rounding technique of @xcite .",
    "= = = = = = = = = = = = = = = = = = = = = = = = = = = condensed = = = = = = = = = = = = = = after solving the network flow problem and obtaining a fractional assignment , we can easily produce the following integral assignment : the small jobs are already integrally assigned to machines because of flow integrality . observe that each machine has a total fraction of big jobs of at most @xmath24 assigned to it , due to the capacity @xmath39 of the edge that connects node @xmath37 to node @xmath42 .",
    "moreover the fraction of a big job that is assigned to a machine is a multiple of @xmath47 , again due to flow integrality .",
    "this guarantees that if a big job @xmath4 has a non zero fraction of it assigned to a machine @xmath41 , then @xmath41 has a fraction of @xmath4 of at least @xmath47 .",
    "the above gives us the following :    let @xmath44 be the fractional assignment that corresponds to the network flow solution of an instance of the problem . then for every big job @xmath4 that has a non zero fractional assignment @xmath48 to a machine @xmath41 , @xmath49 .",
    "= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =    after solving the network flow problem we obtain a fractional assignment @xmath44 in which small jobs are integrally assigned and for every big job @xmath4 that has a non - zero fraction @xmath50 assigned to machine @xmath51 @xmath52 .",
    "in particular by flow integrality , if @xmath53 then @xmath50 will be an integral multiple of @xmath54    the next lemma shows that we can assign each big job to a machine that has a fraction of at least @xmath47 of it , so that each machine gets at most one big job .",
    "the proof of the lemma is easy and is omitted .",
    "[ lemma : easy ] let @xmath55 be the set of big jobs and @xmath56 be the set of machines that have a non - zero fraction of a big job . we can find in polynomial time a feasible schedule of the jobs of @xmath55 to the machines of @xmath56 so that at most @xmath24 big job is assigned to each machine .",
    "= = = = = = = = = = = omit proof = = = = = = = = = = = = = = = = = =    we form the following bipartite graph @xmath57 : on one side @xmath58 of @xmath59 we have one node for each big job @xmath60 , and on the other side @xmath61 we have one node for each machine @xmath62 .",
    "the set of edges @xmath63 is defined as follows .",
    "we have an edge from each big job node to each machine node iff the corresponding machine has a non zero fraction of that job .",
    "now let us consider a set of nodes @xmath64 and let @xmath65 be the set of neighbor nodes of @xmath66 , that is @xmath67 is exactly the set of nodes that are connected to some node of @xmath66 . then @xmath68 . let assume otherwise that latexmath:[$|\\gamma   ( v'_1)| <    through any node that corresponds to a big job @xmath4 , the total fractions of @xmath4 that are assigned to machines in our fractional assignment @xmath44 sum up to @xmath24 .",
    "thus the total fraction of the big jobs in @xmath66 that is assigned to the machines of @xmath67 is @xmath70 . since @xmath71",
    "there is at least one machine that is assigned a total fraction of big jobs greater than @xmath24 , which violates the property of our fractional assignment discussed above .",
    "thus the conditions of hall s theorem for bipartite matching hold , so we can in polynomial time find such an assignment of big jobs to machines , with each machine getting at most one big job .",
    "= = = = = = = = = = = = = = = = = end omit proof = = = = = = = = = = = =    the value of the optimal solution is at least @xmath72 the size of a big job . by lemma  [ lemma : easy ] in our solution we increased the load of a machine by at most @xmath73 this results in a @xmath74 approximation .",
    "[ propos ] the solution we get for an instance of the @xmath11-valued makespan problem with job sizes from the set @xmath75 by rounding the fractional assignment @xmath44 resulting from the network flow solution , has an approximation ratio of @xmath74 .",
    "in this section we will use the algorithm of proposition  [ propos ] to design an approximation algorithm for the more general case where the two job sizes are arbitrary nonnegative real numbers . without loss of generality",
    "we assume that @xmath76 .",
    "we can easily normalize the job sizes by dividing them by @xmath6 .",
    "we also assume that the size of small jobs is @xmath77 for some @xmath78 .",
    "we can reduce this problem to the previous one by changing the size of small jobs to either @xmath79 or @xmath80 and use the previous algorithm , since in the modified instance the size of the big jobs is an integer multiple of the size of the small jobs .",
    "we will use the resulting assignment as a solution to our original instance .",
    "below we prove by doing so that the approximation ratio is bounded by certain expressions .",
    "later we will combine those expressions with the result of @xcite to get an improved non - constructive approximation guarantee .",
    "let @xmath81 be the original instance of our problem with job sizes in @xmath82 , @xmath83 let @xmath84 be the instance where we change the small job sizes to @xmath85 and @xmath86 be the instance resulting from changing the small job sizes to @xmath80 .",
    "additionally let @xmath87 be the factor by which the small jobs in @xmath81 are greater than the small jobs in @xmath84 , and @xmath88 be the factor by which the small jobs in @xmath81 are smaller than the small jobs in @xmath86 .",
    "we proceed by bounding the approximation ratio in the case we use the solution of instance @xmath84 as a solution to @xmath81 .",
    "we focus on the load of some machine @xmath41 .",
    "let @xmath89 be the cost of the optimal solution of instance @xmath84 and @xmath90 be the cost of the optimal solution for the original instance @xmath81 . in the fractional assignment resulting from the solution of the network flow for instance @xmath84 ,",
    "let @xmath91 be the total fraction of big jobs that are assigned to @xmath41 .",
    "if @xmath92 then @xmath93 by flow integrality .",
    "then the load of @xmath41 due to small jobs is at most @xmath94 . after the",
    "rounding the load of @xmath41 is at most @xmath95 where the load due to big jobs is @xmath24 and the load due to small jobs is @xmath96 .",
    "if @xmath97 , only small jobs are assigned to machine @xmath41 , then the load of @xmath41 does not increase during the rounding and thus the total load of @xmath41 is at most @xmath89 .",
    "if we use the forementioned solution of @xmath84 as a solution to @xmath81 , since the small jobs in @xmath81 are @xmath98 times greater , the load of a machine @xmath41 that is assigned a big job will be at most @xmath99 .",
    "also we have that @xmath100 .",
    "so , regarding the constructed solution for the original instance @xmath81 , the ratio of the load of @xmath41 to the optimum makespan is @xmath101 . since @xmath102 and @xmath103 we upper bound the former ratio once more ( setting @xmath104 and @xmath105 ) by @xmath106 . if @xmath41 is assigned only small jobs , then the corresponding load is at most @xmath107 in instance @xmath81 and the corresponding ratio is at most @xmath98 .",
    "clearly @xmath108 , since @xmath109 .",
    "thus we can bound the approximation ratio achieved using the solution of @xmath84 by the ratio of the first case : @xmath110 .",
    "now we will make a similar analysis for the case we use the solution of @xmath86 as a solution to @xmath81 .",
    "let @xmath111 be the value of the optimal solution of @xmath86 ( @xmath112 ) .",
    "we once again focus on the load of a single machine @xmath41 . using the same reasoning as above ,",
    "if @xmath41 was assigned a non - zero fraction @xmath113 of big jobs , we have @xmath114 by flow integrality .",
    "the load of @xmath41 after rounding the fractional assignment is at most @xmath115 .",
    "the small jobs of @xmath81 have size @xmath116 times the size they have in @xmath86 .",
    "so the load of @xmath41 for instance @xmath81 is at most @xmath117 . as for the value @xmath90 of the optimal solution of @xmath81 , we know that @xmath118 ( since the optimal solution to @xmath81 with cost @xmath90 induces a solution to @xmath86 which is at most @xmath119 )",
    ". thus the ratio of the contructed solution to the optimal cost is @xmath120 .",
    "like before , we upper bound the former expression by setting @xmath121 and @xmath122 and we get @xmath123 . if @xmath41 is assigned only small jobs , then the load does not increase during the rounding and is at most @xmath111 regarding instance @xmath86 .",
    "the corresponding load of @xmath41 in the solution for instance @xmath81 is at most @xmath124 .",
    "the ratio of this case is @xmath125 . since @xmath109 , @xmath126 .",
    "so , once again , the expression that bounds the approximation ratio achieved is @xmath123 .",
    "we use the solution of the instance that achieves the minimum approximation ratio .",
    "we have thus proved the following theorem :    for any instance of the 2-valued makespan with assignment constraints and with job sizes in @xmath127 , @xmath128 we can find in polynomial time a solution which has an approximation ratio @xmath129    the approximation we have achieved so far depends on @xmath130 .",
    "we can calculate the worst case approximation given by the above theorem for interval @xmath131 which contains @xmath130 , by setting the two expressions to be equal , since one is decreasing and the other is increasing in @xmath130 , for a given interval @xmath131 .    according to the above ,",
    "the worst approximation achieved for @xmath132 is for the value of @xmath130 for which :    @xmath133 + @xmath134 + @xmath135 +    the solution is @xmath136 .",
    "the above calculation gives an approximation guarantee of @xmath8 for values of @xmath137 up to @xmath138 .",
    "for values of @xmath139 the small job size is @xmath140 and therefore it is preferable to use the following :    @xcite if an instance of the scheduling problem only has job sizes @xmath141 and @xmath24 , then the configuration lp has integrality gap at most @xmath142 .",
    "the above theorem was actually proved in @xcite with the assumption that @xmath143 .",
    "the proof , however , can be easily generalized to the case where @xmath144 by making some minor changes .",
    "the main idea is changing @xmath24 to @xmath30 wherever the proof refers to the makespan ( i.e. , the integrality gap becomes @xmath145 ) .",
    "note that for @xmath146 the approximation of the above theorem is at most @xmath147 .",
    "so the following has been proved :    we can estimate the optimal makespan of a 2-valued instance with assignment constraints and with jobs of two sizes within a factor of @xmath8 in polynomial time .",
    "in this section we present a @xmath27-approximation for graph balancing instances , where the edge weights belong to the set @xmath148 .",
    "our proof relies on a modification of the proof for the more general case of 2-valued makespan with assignment constraints .",
    "we will first prove a tight @xmath12 approximation when @xmath149 .",
    "let us consider the multi - level network defined above for this case where the graph edges take the role of jobs and the nodes take the role of machines .",
    "the key difference here is that for each job node there are at most @xmath11 flow paths to the set of machine nodes .",
    "so in the fractional solution resulting from the flow solution , for each big job @xmath4 there are at most @xmath11 machines that have nonzero fraction of that job .",
    "moreover for each big job either there is one machine with a fraction greater than @xmath150 of @xmath4 , or there are @xmath11 machines with exactly a @xmath150 fraction of @xmath4 each .",
    "this is due to the constraint enforced by nodes @xmath37 that each machine may take a total fraction of big jobs of at most @xmath24 .",
    "the small jobs are assigned integrally due to integrality of flow .",
    "now we show how to round the fractional assignment : for each big job @xmath4 for which there is a machine @xmath41 with a fraction greater than @xmath150 of @xmath4 assigned to it , assign @xmath4 to @xmath41 . as for the big jobs that are assigned to @xmath11 machines with a fraction of exactly @xmath150",
    ", we consider the graph induced by the corresponding edges ( only for those big jobs ) and the nodes(machines ) covered by those edges .",
    "since each node has degree at most @xmath11 ( otherwise a machine is assigned at least 3/2 big jobs , which can not happen ) , the graph is a collection of disjoint paths and cycles .",
    "it is easy to find a @xmath151 assignment of the edges to the nodes ( i.e. , make a clockwise assignment on cycles , direct each path arbitrary and assign each edge to its head ) .    note that in the resulting assignment , each node - machine which had a fraction at least @xmath150 of some big edge - job may end up taking the whole edge - job .",
    "we have increased the cost of the fractional solution by @xmath150 at most and since the cost of the optimal solution is at least @xmath24 , we have achieved a @xmath12 approximation , matching the lower bound .      as in the previous section ,",
    "we use the above algorithm as a black box to solve the case with edge weights in @xmath153 or w.l.o.g . in @xmath154 following the exact same argumentation , we can reduce this case to the previous one , by rounding the small job size to either @xmath155 or to @xmath156 . for both cases ,",
    "the worst approximation ratio arise again from the case where machine @xmath41 has a non - zero fraction of big jobs and received a whole big job after the rounding .",
    "now we know that @xmath41 had at least @xmath150 fraction of some big job .",
    "the expressions giving the approximation in each case are @xmath157 and @xmath158 respectively and are obtained in the same manner as in section  [ sec : int ] .",
    "once again we balance the expressions in each interval @xmath131 getting the following :        when @xmath163 we use a different approach : in this case @xmath164 .",
    "if @xmath165 then it is obvious that we can find an optimal solution via bipartite maching .",
    "if @xmath166 , then we know that @xmath167 , since there must be a machine with at least 2 jobs assigned in each solution . consider the case @xmath168 . if @xmath169 then @xmath170 ( since we have either @xmath24 big job and @xmath24 small in some machine or we have more than 3 small jobs in some machine ) and the algorithm of @xcite gives a @xmath171 approximation .",
    "if @xmath172 using , e.g. , the lp and the cycle canceling of @xcite we get a fractional solution of cost at most @xmath173 for which the corresponding graph induced on the fractionally assigned nodes ( machines ) is a forest .",
    "consider a tree @xmath43 , and further consider a leaf node @xmath174 .",
    "the load of the integrally assigned jobs of @xmath174 can either be @xmath24 or @xmath7 ( @xmath174 can not have 2 integrally assigned jobs and one fractionally since @xmath172 ) .",
    "we assign the fractional job to @xmath174 , resulting to a total load of at most @xmath11 .",
    "we do the same in a bottom - up manner for each node of the tree .",
    "the resulting approximation is @xmath175 which is less than @xmath27 for @xmath176 .",
    "if @xmath177 then the reduction to @xmath84 done previously gives an approximation of at most @xmath178 .",
    "note that , for all the above , we do not need to know the value of @xmath90 , we just keep the best solution of the mentioned approaches ."
  ],
  "abstract_text": [
    "<S> we consider the following special case of minimizing makespan . a set of jobs @xmath0 and a set of machines </S>",
    "<S> @xmath1 are given . </S>",
    "<S> each job @xmath2 can be scheduled on a machine from a subset @xmath3 of @xmath1 . </S>",
    "<S> the processing time of @xmath4 is the same on all machines in @xmath5 the jobs are of two sizes , namely @xmath6 ( big ) and @xmath7 ( small ) . </S>",
    "<S> we present a polynomial - time algorithm that approximates the value of the optimal makespan within a factor of @xmath8 and some further improvements when every job can be scheduled on at most two machines .    </S>",
    "<S> * keywords : * approximation algorithms , scheduling , makespan minimization , graph balancing . </S>"
  ]
}