{
  "article_text": [
    "in networking or telecommunications the search for the minimum - delay path ( that is the shortest path between two points ) is always on .",
    "the cost on each edge , that is the time taken for a signal to travel between two adjacent nodes of the network , is often a function of real time .",
    "hence the shortest path between any two nodes changes with time . of course one can run a shortest path algorithm every time a signal has to be sent , but usually some prior knowledge of the network graph is given in advance , such as the structure of the network graph and the cost functions on each edge ( with time as a variable )",
    "how can one benefit from this extra information ?",
    "one plausible way is to preprocess the initial information and store the preprocessed information . every time the rest of the input is given , using the preprocessed information",
    ", one can solve the optimization problem faster than solving the problem from scratch .",
    "even if the preprocessing step is expensive one would benefit by saving precious time whenever the optimal solution has to be computed .",
    "also , if the same preprocessed information is used multiple times then the total amount of resources used will be less in the long run .",
    "similar phenomena can be observed in various other combinatorial optimization problems that arise in practice ; that is , a part of the input does not change with time and is known in advance . however , many times it is hard to make use of this extra information .    in this paper",
    "we consider only those problems where the whole input is a weighted graph .",
    "we assume that the graph structure and some knowledge of how the weights on the edges are generated are known in advance .",
    "we call this the _ function - weighted graph _",
    " it is a graph whose edges are labeled with continuous real functions . when all the functions are univariate ( and all have the same variable ) , the graph is called a _",
    "parametric weighted graph_. in other words , the graph is @xmath14 where @xmath15 and @xmath16 is the space of all real continuous functions with the variable @xmath17 .",
    "if @xmath18 is a parametric weighted graph , and @xmath19 is any real number , then @xmath20 is the standard weighted graph where the weight of an edge @xmath21 is defined to be @xmath22 .",
    "we say that @xmath20 is an _ instantiation _ of @xmath18 , since the variable @xmath17 in each function is instantiated by the value @xmath23 .",
    "parametric weighted graphs are therefore , a generic instance of infinitely many instances of weighted graphs .",
    "the idea is to use the generic instance @xmath18 to precompute some general generic information @xmath24 , such that for any given instantiation @xmath20 , we will be able to use the precomputed information @xmath24 in order to speed up the time to solve the given problem on @xmath20 , faster than just solving the problem on @xmath20 from scratch .",
    "let us make this notion more precise .",
    "a _ parametric weighted graph algorithm _ ( or , for brevity , a _ parametric algorithm _ ) consists of two phases .",
    "a _ preprocessing phase _ whose input is a parametric weighted graph @xmath18 , and whose output is a data structure ( the advice ) that is later used by the _ instantiation phase _ , where a specific value @xmath23 for the variable is given .",
    "the instantiation phase outputs the solution to the ( standard ) weighted graph problem on the weighted graph @xmath20 . naturally , the goal is to have the running time of the instantiation phase significantly smaller than the running time of any algorithm that solves the weighted graph problem from scratch , by taking advantage of the advice constructed in the preprocessing phase .",
    "parametric algorithms are therefore evaluated by a pair of running times , the _ preprocessing time _ and the _ instantiation time_.    in this paper we show that parametric algorithms are beneficial for one of the most natural combinatorial optimization problems : the _ shortest path _ problem in directed graphs .",
    "recall that given a directed real - weighted graph @xmath18 , and two vertices @xmath6 of @xmath18 , the distance from @xmath7 to @xmath8 , denoted by @xmath25 , is the length of a shortest path from @xmath7 to @xmath8 .",
    "the _ single pair _ shortest path problem seeks to compute @xmath25 and construct a shortest path from @xmath7 to @xmath8 .",
    "likewise , the _ single source _ shortest path problem seeks to compute the distances and shortest paths from a given vertex to all other vertices , and the _ all pairs _ version seeks to compute distances and shortest paths between all ordered pairs of vertices . in some of our algorithms",
    "we forgo the calculation of the path itself to achieve a shorter instantiation time . in all those cases the algorithms can be easily modified to also output a shortest path , in which case their instantiation time is the sum of the time it takes to calculate the distance and a time linear in the size of the path to be output .",
    "our first algorithm is a parametric algorithm for single source shortest path , in the case where the weights are _ linear _ functions .",
    "that is , each edge @xmath21 is labeled with a function @xmath26 where @xmath27 and @xmath28 are reals .",
    "such linear parametrization has practical importance .",
    "indeed , in many problems the cost of an edge is composed from some constant term plus a term which is a factor of some commodity , whose cost varies ( e.g. bank commissions , taxi fares , vehicle maintenance costs , and so on ) .",
    "our parametric algorithm has preprocessing time @xmath29 and instantiation time @xmath30 ( throughout this paper @xmath31 and @xmath32 denote the number of vertices and edges of a graph , respectively ) .",
    "we note that the fastest algorithm for the single source shortest path in real weighted directed graphs requires @xmath33 time ; the bellman - ford algorithm @xcite .",
    "the idea of our preprocessing stage is to precompute some other linear functions , on the _ vertices _ , so that for every instantiation @xmath23 , one can quickly determine whether @xmath20 has a negative cycle and otherwise use these functions to quickly produce a reweighing of the graph so as to obtain only nonnegative weights similar to the weights obtained by johnson s algorithm @xcite . in other words ,",
    "we _ avoid _ the need to run the bellman - ford algorithm in the instantiation phase .",
    "the @xmath29 time in the preprocessing phase comes from the use of megiddos@xcite technique that we need in order to compute the linear vertex functions .",
    "[ thm : neg ] there exists a parametric algorithm for single source shortest path in graphs weighted by linear functions , whose preprocessing time is @xmath29 and whose instantiation time is @xmath34 .",
    "our next algorithm applies to a more general setting where the weights are polynomials of degree at most @xmath3 .",
    "furthermore , in this case our goal is to have the instantiation phase answering distance queries between any two vertices in _ sublinear _ time .",
    "notice first that if we allow exponential preprocessing time , this goal can be easily achieved .",
    "this is not hard to see since the overall possible number of shortest paths ( when @xmath17 varies over the reals ) is @xmath35 , or from fredman s decision tree for shortest paths whose height is @xmath36 @xcite . but",
    "can we settle for _ sub - exponential _ preprocessing time and still be able to have sublinear instantiation time ?",
    "our next result achieves this goal .",
    "[ thm : gen ] there exists a parametric algorithm for the single pair shortest path problem in graphs weighted by degree @xmath3 polynomials , whose preprocessing time is @xmath37 and instantiation time @xmath38 , where @xmath39 is the time required to compute the intersection points of two degree @xmath3 polynomials .",
    "the size of the advice that the preprocessing algorithm produces is @xmath40 .",
    "the above result falls in the subject of sensitivity analysis where one is interested in studying the effect on the optimal solution as the value of the parameter changes .",
    "we give a linear - time ( linear in the output size ) algorithm that computes the breaking points .",
    "the practical and theoretical importance of shortest path problems lead several researchers to consider fast algorithms that settle for an approximate shortest path . for the general case ( of real weighted digraphs )",
    "most of the algorithms guarantee an _ @xmath41-stretch _ factor .",
    "namely , they compute a path whose length is at most @xmath42 .",
    "we mention here the @xmath43-stretch algorithm of zwick for the all - pairs shortest path problem , that runs in @xmath44 time when the weights are non - negative reals @xcite . here",
    "@xmath45 is the matrix multiplication exponent @xcite .",
    "here we consider probabilistic additive - approximation algorithms , or _ surplus _",
    "algorithms , that work for linear weights which may have positive and negative values ( as long as there is no negative weight cycle ) .",
    "we say that a shortest path algorithm has an @xmath12-surplus if it computes paths whose lengths are at most @xmath46 .",
    "we are unaware of any truly subcubic algorithm that guarantees an @xmath12-surplus approximation , and which outperforms the fastest general all - pairs shortest path algorithm @xcite .    in the linear - parametric setting , it is easy to obtain @xmath12-surplus parametric algorithms whose preprocessing time is @xmath47 time , and whose instantiation time , for any ordered pair of queried vertices @xmath6 is constant .",
    "it is assumed instantiations are taken from some interval @xmath48 whose length is independent of @xmath31 .",
    "indeed , we can partition @xmath48 into @xmath49 subintervals @xmath50 of size @xmath51 each , and solve , in cubic time ( say , using @xcite ) , the exact all - pairs solution for any instantiation @xmath23 that is an endpoint of two consecutive intervals . then , given any @xmath52 , we simply look at the solution for @xmath53 and notice that we are ( additively ) off from the right answer only by @xmath11 .",
    "standard scaling arguments can make the surplus smaller than @xmath12 .",
    "but do we really need to spend @xmath47 time for preprocessing ?",
    "in other words , can we invest ( significantly ) less than @xmath47 time and still be able to answer instantiated distance queries in @xmath11 time ?",
    "the following result gives a positive answer to this question .",
    "[ thm : approx ] let @xmath54 , let @xmath55 $ ] be any fixed interval and let @xmath56 be a fixed constant .",
    "suppose @xmath18 is a linear - parametric graph that has no negative weight cycles in the interval @xmath55 $ ] , and for which every edge weight @xmath57 satisfies @xmath58 .",
    "there is a parametric randomized algorithm for the @xmath12-surplus shortest path problem , whose preprocessing time is @xmath59 and whose instantiation time is @xmath11 for a single pair , and hence @xmath60 for all pairs .",
    "we note that this algorithm works in the restricted addition - comparison model .",
    "we also note that given an ordered pair @xmath6 and @xmath61 $ ] , the algorithm outputs , in @xmath11 time , a weight of an actual path from @xmath7 to @xmath8 in @xmath20 , and points to a linked list representing that path . naturally , if one wants to output the vertices of this path then the time for this is linear in the length of the path .",
    "the rest of this paper is organized as follows .",
    "the next subsection shortly surveys related research on parametric shortest path problems . in the three sections following it we prove theorems [ thm : neg ] , [ thm : gen ] and [ thm : approx ] .",
    "section  [ sec : conclusion ] contains some concluding remarks and open problems .",
    "several researchers have considered parametric versions of combinatorial optimization problems . in particular function - weighted graphs ( under different names )",
    "have been extensively studied in the subject of sensitivity analysis ( see @xcite ) where they study the effect on the optimal solution as the parameter value changes .",
    "murty  @xcite showed that for parametric linear programming problems the optimal solution can change exponentially many times ( exponential in the number of variables ) .",
    "subsequently , carstensen @xcite has shown that there are constructions for which the number of shortest path changes while @xmath17 varies over the reals is @xmath62 .",
    "in fact , in her example each linear function is of the form @xmath57 and both @xmath27 and @xmath28 are positive , and @xmath17 varies in @xmath63 $ ] .",
    "carstensen also proved that this is tight .",
    "in other words , for any linear - parametric graph the number of changes in the shortest paths is @xmath64 .",
    "a simpler proof was obtained by nikolova et al .",
    "@xcite , that also supply an @xmath64 time algorithm to compute the path breakpoints .",
    "their method , however , does not apply to the case where the functions are not linear , such as in the case of degree @xmath3 polynomials .",
    "gusfield  @xcite also gave a proof for the upper bound of the number of breakpoints in the linear function version of the parametric shortest path problem , in addition to studying a number of other parametric problems .",
    "karp and orlin @xcite , and , later , young , tarjan , and orlin  @xcite considered a special case of the linear - parametric shortest path problem . in their case , each edge weight @xmath21 is either some fixed constant @xmath28 or is of the form @xmath65 .",
    "it is not too difficult to prove that for any given vertex @xmath8 , when @xmath17 varies from @xmath66 to the largest @xmath67 for which @xmath68 has no negative weight cycle ( possibly @xmath69 ) , then there are at most @xmath60 distinct shortest path trees from @xmath8 to all other vertices .",
    "namely , for each @xmath70 $ ] one of the trees in this family is a solution for single - source shortest path in @xmath20 .",
    "the results in @xcite cleverly and compactly compute all these trees , and the latter does it in @xmath71 time .",
    "the proof of theorem  [ thm : neg ] follows from the following two lemmas .",
    "[ lem : negcyl ] given a linear - weighted graph @xmath14 , there exist @xmath72 such that @xmath20 has no negative cycles if and only if @xmath73 . moreover @xmath41 and",
    "@xmath74 can be found in @xmath29 time .",
    "[ lem : reweight ] let @xmath14 be a linear - weighted graph . also let @xmath75 be such that at least one of them is finite and for all @xmath76 the graph @xmath20 has no negative cycle .",
    "then for every vertex @xmath77 there exists a linear function @xmath78}_v$ ] such that if the new weight function @xmath79 is given by @xmath80}_u - g^{[\\alpha , \\beta]}_v\\ ] ] then the new linear - weighted graph @xmath81 has the property that for any real @xmath73 all the edges in @xmath82 are non - negative .",
    "moreover the functions @xmath83}_v$ ] for all @xmath77 can be found in @xmath84 time .",
    "so given a linear - weighted graph @xmath18 , we first use lemma [ lem : negcyl ] to compute @xmath41 and @xmath74 .",
    "if at least one of @xmath41 and @xmath74 is finite then using lemma  [ lem : reweight ] we compute the @xmath31 linear functions @xmath78}_v$ ] , one for each @xmath77 . if @xmath85 and @xmath86 , then using lemma  [ lem : reweight ] we compute the @xmath87 linear functions @xmath88}_v$ ] and @xmath89}_v$ ] .",
    "these linear functions will be the advice that the preprocessing algorithm produces .",
    "the above lemmas guarantee us that the advice can be computed in time @xmath29 , that is the preprocessing time is @xmath29 .",
    "now when computing the single source shortest path problem from vertex @xmath8 for the graph @xmath20 our algorithm proceeds as follows :    1 .",
    "if @xmath90 or @xmath91 output `` @xmath66 '' as there exists a negative cycle ( such instances are considered invalid ) .",
    "if @xmath92 and at least one of @xmath41 or @xmath74 is finite then compute @xmath93 for all @xmath94 . use these to re - weight the edges in the graph as in johnson s algorithm @xcite .",
    "if @xmath85 and @xmath86 then if @xmath95 compute @xmath96}_u(r)$ ] for all @xmath94 and if @xmath97 compute @xmath89}_u(r)$ ] for all @xmath94 .",
    "notice that after the reweighing we have an instance of @xmath82 .",
    "3 .   use dijkstra s algorithm @xcite to solve the single source shortest path problem in @xmath82 .",
    "dijkstra s algorithm applies since @xmath82 has no negative weight edges .",
    "the shortest paths tree returned by dijkstra s algorithms applied to @xmath82 is also the shortest paths tree in @xmath20 .",
    "as in johnson s algorithm , we use the results @xmath98 of @xmath82 to deduce @xmath99 in @xmath20 since , by lemma [ lem : reweight ] @xmath100 .",
    "the running time of the instantiation phase is dominated by the running time of dijkstra s algorithm which is @xmath101 @xcite .      since the weight on the edges of the graph @xmath18 are linear functions , we have that the weight of any directed cycle in the graph is also a linear function .",
    "let @xmath102 be the set of all directed cycles in the graph .",
    "the linear weight function of a cycle @xmath103 will be denoted by @xmath104 .",
    "if @xmath104 is not the constant function , then let @xmath105 be the real number for which the linear equation @xmath104 evaluates to @xmath106 .",
    "let @xmath41 and @xmath74 be defined as follows : @xmath107 @xmath108 note that if @xmath104 has a positive slope then @xmath109 thus for all @xmath110 the value of @xmath104 evaluated at @xmath17 is non - negative .",
    "so by definition for all @xmath111 the value of the @xmath104 is non - negative if the slope of @xmath104 is positive , and for any @xmath112 there exists a cycle @xmath103 such that @xmath104 has positive slope and @xmath113 is negative .",
    "similarly , for all @xmath114 the value of the @xmath104 is non - negative if the slope of @xmath104 is negative and for any @xmath115 there exists a cycle @xmath103 such that @xmath104 has negative slope and @xmath113 is negative .",
    "this proves the existence of @xmath41 and @xmath74 .",
    "there are , however , two bad cases that we wish to exclude .",
    "notice that if @xmath116 this means that for any evaluation at @xmath17 , the resulting graph has a negative weight cycle .",
    "the same holds if there is some cycle for which @xmath104 is constant and negative .",
    "let us now show how @xmath41 and @xmath74 can be efficiently computed whenever these bad cases do not hold . indeed , @xmath41 is the solution to the following linear program ( lp ) , which has a feasible solution if and only if the bad cases do not hold .",
    "this is an lp on one variable , but the number of constraints can be exponential . using megiddos@xcite technique for finding the minimum ratio cycles we can solve the linear - program in @xmath117 steps .",
    "let @xmath41 and @xmath74 be the two numbers such that for all @xmath118 the graph @xmath20 has no negative cycles and at least one of @xmath41 and @xmath74 is finite .",
    "first let us consider the case when both @xmath41 and @xmath74 are finite . recall that",
    ", given any number @xmath23 , johnson s algorithm associates a weight function @xmath119 such that , for any edge @xmath120 , @xmath121 ( johnson s algorithm computes this weight function by running the bellman - ford algorithm over @xmath20 ) . define the weight function @xmath78}_v$ ] as @xmath122}_v(x ) = \\left(\\frac{h^{\\beta}(v ) - h^{\\alpha}(v)}{\\beta - \\alpha}\\right)x + h^{\\alpha}(v ) - \\left(\\frac{h^{\\beta}(v ) - h^{\\alpha}(v)}{\\beta - \\alpha}\\right)\\alpha~.\\ ] ] this is actually the equation of the line joining @xmath123 and @xmath124 in @xmath125 .",
    "now we need to prove that for every @xmath126 and for every @xmath127 , @xmath128}_{u}(r ) - g^{[\\alpha,\\beta]}_{v}(r ) \\geq 0~.\\ ] ] since @xmath73 , one can write @xmath129 where @xmath130",
    ". then for all @xmath131 , @xmath122}_v(r ) = ( 1 - \\delta ) h^{\\alpha}(v ) + \\delta h^{\\beta}(v)~.\\ ] ] since @xmath132 is a linear function we can write @xmath133 so after re - weighting the weight of the edge @xmath134 is @xmath135 now this is non - negative as by the definition of @xmath136 and @xmath137 we know that both @xmath138 and @xmath139 are non - negative .",
    "we now consider the case when one of @xmath41 or @xmath74 is not finite . we will prove it for the case where @xmath86 .",
    "the case @xmath85 follows similarly .",
    "consider the simple weighted graph @xmath140 where the weight function @xmath141 is defined as : if the weight of the edge @xmath21 is @xmath142 then @xmath143 .",
    "we run the johnson s algorithm on the graph @xmath144 .",
    "let @xmath145 denote the weight that johnson s algorithm associates with the vertex @xmath8 . then define the weight function @xmath146}_v$ ] as @xmath147}_v(x )",
    "= h^{\\alpha}(v ) + ( x-\\alpha)h^{\\infty}(v)~.\\ ] ] we need to prove that for every @xmath148 and for every @xmath127 , @xmath149}_{u}(r ) - g^{[\\alpha , \\infty]}_{v}(r ) = w_{(u , v)}(r ) + h^{\\alpha}(u ) + ( r-\\alpha ) h^{\\infty}(u ) - h^{\\alpha}(v ) - ( r-\\alpha ) h^{\\infty}(v ) \\geq 0~.\\ ] ] let @xmath150 where @xmath151 . by the linearity of",
    "@xmath152 we can write @xmath153 , where @xmath154 . so the above inequality can be restated as @xmath155 this now follows from the fact that both @xmath156 and @xmath157 are non - negative .",
    "since the running time of the reweighing part of johnson s algorithm takes @xmath84 time , the overall running time of computing the functions @xmath78}_v$ ] is @xmath84 , as claimed .",
    "in this section we construct a parametric algorithm that computes the distance @xmath25 between a given pair of vertices .",
    "if one is interested in the actual path realizing this distance , then it can be found with some extra book - keeping that we omit in the proof .",
    "the processing algorithm will output the following advice : for any pair @xmath158 the advice consists of a set of @xmath159 increasing real numbers @xmath160 and an ordered set of degree-@xmath3 polynomials @xmath161 , such that for all @xmath162 the weight of a shortest path in @xmath20 from @xmath7 to @xmath8 is @xmath163 .",
    "note that each @xmath164 corresponds to the weight of a path from @xmath7 to @xmath8 .",
    "thus if we are interested in computing the exact path then we need to keep track of the path corresponding to each @xmath164 .    given @xmath23 ,",
    "the instantiation algorithm has to find the @xmath165 such that @xmath162 and then output @xmath163 .",
    "so the output algorithm runs in time @xmath166 . to prove our result we need to show that for any @xmath158 we can find the advice in time @xmath167 . in particular",
    "this will prove that @xmath168 and hence the result will follow .",
    "a _ minbase _ is a sequence of increasing real numbers @xmath169 and an ordered set of degree-@xmath3 polynomials @xmath161 , such that for all @xmath162 and all @xmath170 , @xmath171 .",
    "we call the sequence of real numbers the _ breaks_. we call each interval @xmath172 $ ] the @xmath165-th interval of the minbase and the polynomial @xmath164 the @xmath165-th polynomial",
    ". the _ size _ of the minbase is @xmath173 .",
    "the final advice that the preprocessing algorithm produces is a minbase for every pair @xmath174 where the @xmath165-th polynomial has the property that @xmath163 is the distance from @xmath7 to @xmath8 in @xmath20 for each @xmath175 .",
    "a @xmath176 is a minbase corresponding to the ordered pair @xmath6 , where the @xmath165-th polynomial @xmath164 has the property that for @xmath177 $ ] , @xmath163 is the length of a shortest path from @xmath7 to @xmath8 in @xmath20 , that is taken among all paths that use at most @xmath178 edges .",
    "a @xmath179 is a minbase corresponding to the ordered triple @xmath180 where the @xmath165-th polynomial @xmath164 has the property that for each @xmath177 $ ] , @xmath163 is the sum of the lengths of a shortest path from @xmath7 to @xmath181 in @xmath20 , among all paths that use at most @xmath178 edges , and a shortest path from @xmath181 to @xmath8 in @xmath20 , among all paths that use at most @xmath178 edges .",
    "note that in both of the above definitions some of the polynomials can be @xmath182 or @xmath66 .",
    "if @xmath183 and @xmath184 are two minbases ( not necessarily of the same size ) , with polynomials @xmath185 and @xmath186 , we say that another minbase with breaks @xmath187 and polynomials @xmath188 is @xmath189 if the following holds .    1",
    ".   for all @xmath190 there exist @xmath191 such that @xmath192 , and 2 .   for @xmath193 and for all @xmath191 we have @xmath194 .",
    "if @xmath195 are @xmath196 minbases ( not necessarily of the same size ) , with polynomials @xmath197 , another minbase with breaks @xmath187 and polynomials @xmath188 is @xmath198 if the following holds .    1",
    ".   for all @xmath190 there exist @xmath199 such that @xmath200 , and 2 .   for @xmath193 and for all @xmath201 and all @xmath202 , we have @xmath203 .",
    "note that using the above definition we can write the following two equations : @xmath204    @xmath205    the following claim will prove the result .",
    "the proof of the claim is omitted due to lack of space .",
    "[ cl : sizesminbase ] if @xmath183 and @xmath184 are two minbases of sizes @xmath206 and @xmath207 respectively , then    1 .",
    "@xmath208 can be computed from @xmath183 and @xmath184 in time @xmath209 .",
    "@xmath210 can be computed from @xmath183 and @xmath184 in time @xmath211 , where @xmath39 is the time required to compute the intersection points of two degree-@xmath3 polynomials .",
    "the size of @xmath210 is @xmath212 .    in order to compute @xmath213 one",
    "recursively computes @xmath214 and @xmath215 and then takes @xmath216 .    if there are no negative cycles , then the advice that the instantiation algorithm needs from the preprocessing algorithm consists of @xmath217 . to deal with negative cycles , both @xmath217 and @xmath218",
    "are produced , and the instantiation algorithm compares them . if they are not equal , then the correct output is @xmath66 .",
    "also note that @xmath219 is the trivial minbase where the breaks are @xmath66 and @xmath182 and the polynomial is weight @xmath220 associated to the edge @xmath134 if @xmath221 and @xmath182 otherwise .    if the size of @xmath176 is @xmath222 , then by ( [ eq : minuwv ] ) , ( [ eq : minuwwv ] ) , and by claim  [ cl : sizesminbase ] the time to compute @xmath223 is @xmath224 and the size of @xmath223 is @xmath225 . thus one can compute the advice for @xmath7 and @xmath8 in time @xmath226 and the length of the advice string is @xmath40 .",
    "given the linear - weighted graph @xmath14 , our preprocessing phase begins by verifying that for all @xmath61 $ ] , @xmath20 has no negative weight cycles . from the proof of lemma [ lem : reweight ] we know that this holds if and only if both @xmath227 and @xmath228 have no negative weight cycles .",
    "this , in turn , can be verified in @xmath84 time using the bellman - ford algorithm .",
    "we may now assume that @xmath20 has no negative cycles for any @xmath61 $ ] .",
    "moreover , since our preprocessing algorithm will solve a large set of shortest path problems , each of them on a specific instantiation of @xmath18 , we will first compute the reweighing functions @xmath78}_v$ ] of lemma [ lem : reweight ] which will enable us to apply , in some cases , algorithms that assume nonnegative edge weights . recall",
    "that by lemma [ lem : reweight ] , the functions @xmath78}_v$ ] for all @xmath77 are computed in @xmath84 time .",
    "the advice constructed by the preprocessing phase is composed of two distinct parts , which we respectively call the _ crude - short _ advice and the _ refined - long _ advice .",
    "we now describe each of them .    for each edge @xmath229 , the weight is a linear function @xmath230 .",
    "set @xmath231 .",
    "let @xmath232 and let @xmath233 .",
    "we define @xmath234 and @xmath235 points in @xmath55 $ ] and solve certain variants of shortest path problems instantiated in these points .",
    "consider first the case of splitting @xmath55 $ ] into @xmath236 intervals .",
    "let @xmath237 and consider the points @xmath238 for @xmath239 .",
    "the crude - short part of the preprocessing algorithm solves @xmath234 _ limited _ all - pairs shortest path problems in @xmath240 for @xmath239 .",
    "set @xmath241 , and let @xmath242 denote the length of a shortest path from @xmath7 to @xmath8 in @xmath240 that is chosen among all paths containing at most @xmath173 vertices ( possibly @xmath243 if no such path exists ) .",
    "notice that @xmath242 is not necessarily the distance from @xmath7 to @xmath8 in @xmath240 , since the latter may require more than @xmath173 vertices .",
    "it is straightforward to compute shortest paths limited to at most @xmath190 vertices ( for any @xmath244 ) in a real - weighted directed graph with @xmath31 vertices in time @xmath245 time , by the repeated squaring technique .",
    "in fact , they can be computed in @xmath246 time ( saving the @xmath247 factor ) using the method from @xcite , pp .",
    "this algorithm also constructs the predecessor data structure that represents the actual paths .",
    "it follows that for each ordered pair of vertices @xmath6 and for each @xmath239 , we can compute @xmath242 and a path @xmath248 yielding @xmath242 in @xmath240 in @xmath249 time which is @xmath250 we also maintain , at no additional cost , linear functions @xmath251 which sum the linear functions of the edges of @xmath248 .",
    "note also that if @xmath243 then @xmath248 and @xmath251 are undefined .",
    "consider next the case of splitting @xmath55 $ ] into @xmath252 intervals .",
    "let @xmath253 and consider the points @xmath254 for @xmath255 .",
    "however , unlike the crude - short part , the refined - long part of the preprocessing algorithm can not afford to solve an all - pairs shortest path algorithm for each @xmath256 , as the overall running time will be too large .",
    "instead , we randomly select a set @xmath257 of ( at most ) @xmath258 vertices .",
    "@xmath259 is constructed by performing @xmath258 independent trials , where in each trial , one vertex of @xmath260 is chosen to @xmath259 uniformly at random ( notice that since the same vertex can be selected to @xmath259 more than once @xmath261 ) . for each @xmath262 and for each @xmath255 , we solve the single source shortest path problem in @xmath256 from @xmath263 , and also ( by reversing the edges ) solve the single - destination shortest path _ toward _ @xmath263 .",
    "notice that by using the reweighing functions @xmath78}_v$ ] we can solve all of these single source problems using dijkstra s algorithm .",
    "so , for all @xmath264 and @xmath255 the overall running time is @xmath265 we therefore obtain , for each @xmath264 and for each @xmath255 , a shortest path tree @xmath266 , together with distances @xmath267 from @xmath263 to each other vertex @xmath77 , which is the distance from @xmath263 to @xmath8 in @xmath256",
    ". we also maintain the functions @xmath268 that sum the linear equations on the path in @xmath269 from @xmath263 to @xmath8 .",
    "likewise , we obtain a `` reversed '' shortest path tree @xmath270 , together with distances @xmath271 from each @xmath272 to @xmath263 , which is the distance from @xmath8 to @xmath263 in @xmath273 .",
    "similarly , we maintain the functions @xmath274 that sum the linear equations on the path in @xmath270 from @xmath8 to @xmath263 .",
    "finally , for each ordered pair of vertices @xmath6 and for each @xmath255 we compute a vertex @xmath275 which attains @xmath276 notice that the time to construct the @xmath277 for all ordered pairs @xmath6 and for all @xmath255 is @xmath278 .",
    "this concludes the description of the preprocessing algorithm .",
    "its overall runtime is thus @xmath279 .",
    "we now describe the instantiation phase . given @xmath280 and @xmath281 $ ] we proceed as follows .",
    "let @xmath165 be the index for which the number of the form @xmath282 is closest to @xmath23 .",
    "as we have the advice @xmath251 , we let @xmath283 ( recall that @xmath251 is a function ) . likewise , let @xmath284 be the index for which the number of the form @xmath285 is closest to @xmath23 . as we have the advice @xmath286 , we let @xmath287 .",
    "finally , our answer is @xmath288 .",
    "clearly , the instantiation time is @xmath11 .",
    "notice that if we also wish to output a path of weight @xmath289 in @xmath20 we can easily do so by using either @xmath248 , in the case where @xmath290 or using @xmath291 and @xmath292 ( we take the path from @xmath7 to @xmath263 in @xmath291 and concatenate it with the path from @xmath263 to @xmath8 in @xmath292 ) in the case where @xmath293 .",
    "it remains to show that , with very high probability , the result @xmath289 that we obtain from the instantiation phase is at most @xmath12 larger than the distance from @xmath7 to @xmath8 in @xmath20 .",
    "for this purpose , we first need to prove that the random set @xmath259 possesses some `` hitting set '' properties , with very high probability .    for every pair of vertices @xmath7 and @xmath8 and parameter @xmath23 , let @xmath294 be a shortest path in @xmath20 among all simple paths from @xmath7 to @xmath8 containing at least @xmath241 vertices ( if @xmath18 is strongly connected then such a path always exist , and otherwise we can just put @xmath182 for all @xmath6 pairs for which no such path exists ) .",
    "the following simple lemma is used in an argument similar to one used in @xcite .",
    "[ lem : prob ] for fixed @xmath7 , @xmath8 and @xmath23 , with probability at least @xmath295 the path @xmath294 contains a vertex from @xmath259 .",
    "indeed , the path from @xmath294 by its definition has at least @xmath296 vertices .",
    "the probability that all of the @xmath297 independent selections to @xmath259 failed to choose a vertex from this path is therefore at most @xmath298    let us return to the proof of theorem [ thm : approx ] .",
    "suppose that the distance from @xmath7 to @xmath8 in @xmath20 is @xmath299 .",
    "we will prove that with probability @xmath300 , @xmath259 is such that for every @xmath7 , @xmath8 and @xmath23 we have @xmath301 ( clearly @xmath302 as it is the precise length of some path in @xmath20 from @xmath7 to @xmath8 ) .",
    "assume first that there is a path @xmath303 of length @xmath299 in @xmath20 that uses less than @xmath296 edges .",
    "consider the length of @xmath303 in @xmath304 .",
    "when going from @xmath23 to @xmath282 , each edge @xmath21 with weight @xmath26 changed its length by at most @xmath305 . by the definition of @xmath306 , this is at most @xmath307 .",
    "thus , @xmath303 changed its weight by at most @xmath308 it follows that the length of @xmath303 in @xmath304 is less than @xmath309 . but",
    "@xmath248 is a shortest path from @xmath7 to @xmath8 in @xmath304 of all the paths that contain at most @xmath173 vertices . in particular ,",
    "consider the length of @xmath248 in @xmath20 .",
    "the same argument shows that the length of @xmath248 in @xmath20 changed by at most @xmath311 .",
    "but @xmath312 is that weight , and hence @xmath313 . in particular ,",
    "@xmath301 .",
    "assume next that every path of length @xmath299 in @xmath20 uses at least @xmath296 edges .",
    "let @xmath303 be one such path . when going from @xmath23 to @xmath314 , each edge @xmath21 with weight @xmath26 changed its length by at most @xmath315 . by the definition of @xmath306 ,",
    "this is at most @xmath316 .",
    "thus , @xmath303 changed its weight by at most @xmath317 in particular , the length of @xmath318 is not more than the length of @xmath303 in @xmath319 , which , in turn , is at most @xmath320 . by lemma [ lem : prob ] , with probability @xmath295 ,",
    "some vertex of @xmath263 appears on @xmath318 .",
    "moreover , by the union bound , with probability @xmath300 _ all _ paths of the type @xmath318 ( remember that @xmath321 can hold one of @xmath49 possible values ) are thus covered by the set @xmath259 .",
    "let @xmath322 be a vertex of @xmath259 appearing in @xmath318 .",
    "we therefore have @xmath323 .",
    "since @xmath286 is taken as the vertex which minimizes these sums , we have , in particular , @xmath324 .",
    "consider the path @xmath199 in @xmath325 realizing @xmath326 . the same argument shows that the length of @xmath199 in @xmath20 changed by at most @xmath327 .",
    "but @xmath328 is that weight , and hence @xmath329 . in particular , @xmath330 .",
    "we have constructed several parametric shortest path algorithms , whose common feature is that they preprocess the generic instance and produce an advice that enables particular instantiations to be solved faster than running the standard weighted distance algorithm from scratch .",
    "it would be of interest to improve upon any of these algorithms , either in their preprocessing time or in their instantiation time , or both .",
    "perhaps the most challenging open problem is to improve the preprocessing time of theorem [ thm : gen ] to a polynomial one , or , alternatively , prove an hardness result for this task . perhaps less ambitious is the preprocessing time in theorem [ thm : neg ] .    finally , parametric algorithms are of practical importance for other combinatorial optimization problems as well",
    ". it would be interesting to find applications where , indeed , a parametric algorithm can be truly beneficial , as it is in the case of shortest path problems .",
    "we thank oren weimann and shay mozes for useful comments .                          c.  p.  m.  van hoesel , a.  w.  j.  kolen , a.  h.  g.  rinooy and a.  p.  m.  wagelmans , _ sensitivity analysis in combinatorial optimization : a bibliography_. report 8944/a , econometric institute , erasmus university rotterdam , ( 1989 ) .",
    "e.  nikolova , j.  a. kelner , m.  brand and m.  mitzenmacher , _ stochastic shortest paths via quasi - convex maximization _ , proceedings of the @xmath332 annual european symposium on algorithms ( esa ) , lncs ( 2006 ) , 552563 ."
  ],
  "abstract_text": [
    "<S> a _ parametric weighted graph _ is a graph whose edges are labeled with continuous real functions of a single common variable . for any instantiation of the variable , </S>",
    "<S> one obtains a standard edge - weighted graph . </S>",
    "<S> parametric weighted graph problems are generalizations of weighted graph problems , and arise in various natural scenarios . </S>",
    "<S> parametric weighted graph algorithms consist of two phases . </S>",
    "<S> a _ preprocessing phase _ whose input is a parametric weighted graph , and whose output is a data structure , the advice , that is later used by the _ instantiation phase _ , where a specific value for the variable is given . </S>",
    "<S> the instantiation phase outputs the solution to the ( standard ) weighted graph problem that arises from the instantiation . the goal is to have the running time of the instantiation phase </S>",
    "<S> supersede the running time of any algorithm that solves the weighted graph problem from scratch , by taking advantage of the advice .    in this paper </S>",
    "<S> we construct several parametric algorithms for the shortest path problem . for the case of linear function weights we present an algorithm for the single source shortest path problem . </S>",
    "<S> its preprocessing phase runs in @xmath0 time , while its instantiation phase runs in only @xmath1 time . the fastest standard algorithm for single source shortest path runs in @xmath2 time . for the case of weight functions defined by degree @xmath3 polynomials , we present an algorithm with quasi - polynomial preprocessing time @xmath4 and instantiation time only @xmath5 . </S>",
    "<S> in fact , for any pair of vertices @xmath6 , the instantiation phase computes the distance from @xmath7 to @xmath8 in only @xmath9 time . </S>",
    "<S> finally , for linear function weights , we present a randomized algorithm whose preprocessing time is @xmath10 and so that for any pair of vertices @xmath6 and any instantiation variable , the instantiation phase computes , in @xmath11 time , a length of a path from @xmath7 to @xmath8 that is at most ( additively ) @xmath12 larger than the length of a shortest path . in particular , an all - pairs shortest path solution , up to an additive constant error , can be computed in @xmath13 time .    </S>",
    "<S> sourav chakraborty            eldar fischer    oded lachish        raphael yuster </S>"
  ]
}