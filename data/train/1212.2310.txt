{
  "article_text": [
    "of network topology is important for network management , diagnosis , operation , security , and performance optimization @xcite . in this paper",
    ", we consider a tomographic approach to topology inference , which assumes no cooperation from intermediate nodes and relies on end - to - end probes to infer internal network characteristics , including topology @xcite . typically , multicast or unicast probes are sent and received between sets of sources and receivers at the edge of the network , and the topology is inferred based on the number and order of received probes , or more generally , using some metric or correlation structure .",
    "an important performance metric is measurement bandwidth overhead : it is desirable to accurately infer the topology using a small number of probes .    in this paper , we focus on the problem of multiple - source multiple - destination topology inference : our goal is to infer the internal network ( @xmath0-by-@xmath1 ) topology by sending probes between @xmath0 sources and @xmath1 receivers at the edge of the network .",
    "prior work @xcite has shown that this problem can be decomposed into two parts : first , infer smaller subnetwork components ( _ e.g. , _ multiple @xmath2-by-@xmath1 s or @xmath3-by-@xmath3 s ) and then merge them to identify the entire @xmath0-by-@xmath1 topology .    significant progress has been made over the past years on the decomposition as well as the first part of the problem , _",
    "i.e. , _ inferring smaller components ( @xmath2-by-@xmath1 s or @xmath3-by-@xmath3 s ) using active probes .",
    "one body of work developed techniques for inferring @xmath2-by-@xmath1 ( _ i.e. , _ single - source tree ) topologies using end - to - end measurements @xcite .",
    "follow - up work @xcite showed that an @xmath0-by-@xmath1 topology can be decomposed into and reconstructed from a number of two - source , two - receiver ( @xmath3-by-@xmath3 ) subnetwork components or `` quartets '' . in @xcite ,",
    "a practical scheme was proposed to distinguish between some quartet topologies using back - to - back unicast probes . in our recent work @xcite",
    ", we proposed a method to exactly identify the topology of a quartet in networks with multicast and network coding capabilities .    in this paper , we focus on the second part of the problem , namely selecting and merging smaller subnetwork components to exactly identify the @xmath0-by-@xmath1 , which has received significantly less attention than the first part .",
    "existing approaches developed for merging the quartets @xcite have several limitations , including not being able to exactly identify the @xmath0-by-@xmath1 topology and/or being inefficient ( _ e.g. , _ requiring to send probes over all @xmath6 possible quartets ) . in this paper",
    ", we formulate the problem as active learning , characterize its complexity , and follow principled approaches to design efficient algorithms to solve it .",
    "this complexity is important from both theoretical ( a fundamental property of the topology inference problem ) and practical ( it determines the measurement bandwidth overhead , running time and memory usage ) points of view . these costs can become particularly important when we need to infer large or dynamic topologies using active measurements , and an efficient algorithm is required for that .",
    "more specifically , we start from the problem of @xmath3-by-@xmath1 topology inference , which is an important special case and can then be used as a building block for inferring an @xmath0-by-@xmath1 . consistently with @xcite , we assume that a ( static ) @xmath2-by-@xmath1 topology is known ( _ e.g. , _ using one of the methods in @xcite )",
    ". then we query the quartet component by sending end - to - end probes between the two sources and the two receivers , and we learn its topology using some of the methods in @xcite ) . ] .",
    "the problem then becomes one of active learning : `` _ which _ quartets to query and _ how _ to merge them with the given @xmath2-by-@xmath1 , so as to exactly identify the @xmath3-by-@xmath1 topology and optimize a number of performance metrics , including the number of queries ( thus the measurement bandwidth ) , time complexity , and memory usage . ''",
    "our contributions are as follows :    \\1 ) we provide a lower bound of @xmath4 on the number of quartets required by _ any _ active learning algorithm in order to identify the @xmath3-by-@xmath1 .",
    "this characterizes the inherent complexity of the problem and also serves as a rough baseline for assessing the performance of practical algorithms .",
    "\\2 ) we formulate the problem within the framework of multiple hypothesis testing and develop an active learning algorithm based on generalized binary search ( gbs ) .",
    "this is the natural framework to pose the problem ; however , we evaluate the performance of this algorithm via simulation and show that the computational complexity is high in practice .",
    "\\3 ) as an alternative , we design an efficient receiver elimination algorithm ( rea ) , which follows a greedy bottom - up approach and provably identifies the @xmath3-by-@xmath1 topology by querying exactly @xmath5 quartets . from the active probing perspective",
    ", this is attractive since only @xmath5 queries are required , which is much lower than all @xmath6 possible quartets one could query .",
    "this directly results in very low measurement bandwidth , which is the main performance metric in active monitoring .",
    "we compare the two algorithms to each other and to the lower bound via simulation over both synthetic and realistic topologies .",
    "the results show that both algorithms can exactly identify the topology and are near - optimal in terms of active measurement bandwidth . between the two ,",
    "the receiver elimination algorithm is found to be very efficient in terms of running time and memory usage , and is , therefore , recommended for practical implementation .",
    "the rest of the paper is organized as follows .",
    "section  [ sec - related ] summarizes related work .",
    "section  [ sec - statement ] provides the problem statement and terminology .",
    "section  [ sec - lowerbound ] provides a lower bound on the number of quartets required by any algorithm .",
    "section  [ sec - gbs ] proposes a greedy algorithm based on the gbs framework and evaluates its performance via simulation .",
    "section  [ sec - algorithm ] proposes the greedy rea , analyzes its correctness and performance , and compares it to gbs in simulation .",
    "section  [ sec - discussion ] discusses possible extensions .",
    "section  [ sec - conclusion ] concludes the paper .",
    "there is a large body of prior work on inference of network topology .",
    "the most closely related to this paper are the ones using active measurements and network tomography",
    ".    * tomographic approaches . * a survey of _ network tomography _ can be found in @xcite .",
    "tomographic approaches rely only on end - to - end measurements to infer internal network characteristics , which may include link - level parameters ( such as loss and delay metrics ) or the network topology @xcite . in this paper , we focus on inferring the network topology .",
    "most tomographic approaches rely on probes sent from a single source in a tree topology @xcite and feed the number , order , or a monotonic property of received probes as input to statistical signal - processing techniques .    in @xcite",
    ", the authors formulated the multiple source multiple destination ( @xmath0-by-@xmath1 ) tomography problem by sending probes between @xmath0 sources and @xmath1 receivers .",
    "it was shown that an @xmath0-by-@xmath1 network can be decomposed into a collection of @xmath3-by-@xmath3 components , also referred to as quartets @xcite .",
    "coordinated transmission of back - to - back unicast probes from the two sources and packet arrival order measurements at the two receivers were used to infer some information about the quartet topology . assuming knowledge of @xmath0 @xmath2-by-@xmath1 topologies and the quartets , it was also shown how to merge a second source s @xmath2-by-@xmath1 tree topology with the first one .",
    "the resulting @xmath0-by-@xmath1 topology is not exact , but bounds were provided on the locations of the points where the two @xmath2-by-@xmath1 trees merge with each other .",
    "this approach also requires a large number of probes for statistical significance , similar to many other methods @xcite . compared to @xcite",
    ", our work is different in that ( i ) we assume perfect knowledge of the quartets , thus we identify the topology accurately ; ( ii ) we focus on the efficiency of active learning , _",
    "i.e. , _ selecting and merging the quartets , which has not been studied before .",
    "to the best of our knowledge , the only other merging algorithm proposed in the literature is @xcite .",
    "however , the merging was not efficient since all possible quartets were queried exhaustively .    in our prior work @xcite , we revisited the problem of topology inference using end - to - end probes in networks where intermediate nodes are equipped with multicast and network coding capabilities .",
    "we built on @xcite and extended it , using network coding at intermediate nodes to deterministically distinguish among all possible quartet topologies , which was not possible before . while in @xcite , we focused on inferring the quartets fast and accurately , here we assume that any quartet can be queried and learned , and focus on efficiently selecting and merging the quartets to infer the larger topology .",
    "to the best of our knowledge , this work is the first to look at this aspect of the problem .",
    "there also exists a rich body of work on _ multiple hypothesis testing _ for active learning problems where",
    "queries are selected adaptively .",
    "one of the contributions of this paper is to formulate this problem in that framework and design an algorithm based on one such active learning scheme , gbs @xcite , which we describe in detail in section  [ sec - gbs ] .",
    "topology inference problems have also been studied in the context of _ phylogenetic _ trees @xcite .",
    "the work in @xcite built on @xcite and proposed robust algorithms for multiple source tree topology inference .",
    "the work in @xcite inferred the topology of sparse random graphs using end - to - end measurements between a small subset of nodes .",
    "however , the quartet structures and the way we measure them are different in our case due to the nature of active probing in network tomography ( see problem formulation in section  [ sec - statement ] ) .    * traceroute - based approaches .",
    "* an alternative to tomographic approaches is traceroute - based techniques , which rely on cooperation of nodes in the middle of the network , in order to connect the ids of nodes along paths and reconstruct the topology @xcite .",
    "these approaches face their own set of challenges : not all intermediate nodes cooperate by responding , many of them have multiple network interfaces ( ids ) , and traceroute is often turned off for security reasons . therefore , traceroute - based methods must deal with missing or incomplete data and alias problems .",
    "regardless , the point of this paper is not to compare the tomographic approaches against the traceroute - based approaches , but to provide active learning algorithms that can probe / query the network in an efficient way . querying the network",
    "can be achieved via end - to - end probes , traceroute , or even in a passive way .",
    "as long as we can query @xmath3-by-@xmath3 components , the active learning approach should be applicable and useful in minimizing the cost of all such approaches .",
    "* relation to the conference version .",
    "* this journal paper builds on our conference paper in @xcite .",
    "in addition to revisions and elaborating on parts of the writing , new materials / contributions in this paper include the following : the formulation of the problem in the gbs framework as well as the performance evaluation of the gbs algorithm via simulation , and its comparison against rea .",
    "* @xmath7-by-@xmath8 topology to be inferred . *",
    "consider an @xmath0-by-@xmath1 topology as a directed acyclic graph ( dag ) , between @xmath0 source nodes @xmath9 and @xmath1 receiver nodes @xmath10 .",
    "we denote this @xmath0-by-@xmath1 topology by @xmath11 .",
    "note that @xmath12 , @xmath13 , is a @xmath2-by-@xmath1 tree .",
    "similar to @xcite , we assume that a predetermined routing policy maps each source - destination pair to a unique route from the source to the destination .",
    "this implies the following three properties , first stated in @xcite :    * for every source @xmath14 and every receiver @xmath15 , there is a unique path @xmath16 .",
    "* two paths @xmath16 and @xmath17 , @xmath18 , branch at a _ branching point _ @xmath19 , and they never merge again . * two paths @xmath17 and @xmath20 , @xmath21 , merge at a _ joining point _",
    "@xmath22 , and they never split again .",
    "-by-@xmath23 topology .",
    "the solid lines and branching points @xmath24 s depict the @xmath25 tree topology , @xmath26 .",
    "@xmath27 is a joining point , where @xmath28 ( indicated by the dashed lines ) joins @xmath26 .",
    "an example quartet is the part of the network connecting @xmath29 to @xmath30 , which is type 1 since both @xmath31 and @xmath32 lie above the branching point of @xmath33 and @xmath34 in @xmath26 , _",
    "i.e. , _ @xmath35 . ]",
    "we are interested in inferring the logical topology , defined by the branching and joining points defined above .",
    "we present most of our discussion in terms of @xmath36 , _",
    "i.e. , _ inferring a @xmath3-by-@xmath1 topology @xmath11 , @xmath37 ; an @xmath0-by-@xmath1 topology , @xmath9 , can then be constructed by merging smaller structures , as we describe in section  [ sec - discussion ] .",
    "[ fig - problemstatement ] illustrates an example @xmath3-by-@xmath1 topology with @xmath38 .",
    "the logical tree topology of @xmath25 is shown by solid lines and branching points @xmath24 s .",
    "each @xmath27 depicts a joining point , where the path from @xmath39 to receiver @xmath40 ( indicated by the dashed lines ) joins the @xmath25 tree .",
    "for example , the path from @xmath39 to @xmath33 joins the @xmath25 tree at a point between @xmath41 and @xmath35 , whereas the path to @xmath42 joins at a point above @xmath43 .",
    "* quartet components . * in @xcite",
    ", it has been shown that an @xmath0-by-@xmath1 topology can be decomposed into a collection of @xmath3-by-@xmath3 subnetwork components , which , in this paper , we call _ quartets _ , following the terminology in @xcite .",
    "each quartet can be of four possible types , as shown in fig .",
    "[ fig-2by2 ] .",
    "we refer to fig .",
    "[ fig-2by2 ] ( a ) , ( b ) , ( c ) , and ( d ) as types 1 , 2 , 3 , and 4 , respectively . note that in type 1 , the joining points for both receivers coincide ( @xmath44 ) and the branching points for both sources coincide ( @xmath45 )",
    ". however , the other three types ( 2 , 3 , and 4 ) , have two distinct joining points and two distinct branching points .    in order to infer the type of a quartet between two sources @xmath46 and two receivers @xmath47 , a set of probes",
    "must be sent from @xmath46 to @xmath47 .",
    "the received probes can then be processed using techniques such as the ones developed in : @xcite ( which distinguish type 1 from types 2 , 3 , 4 by sending back - to - back unicast probes ) ; @xcite ( which distinguish among all four types exploiting multicast and network coding ) ; @xcite ( which can exactly infer the topology of a super - source to two receivers using network coding ) ; traceroute @xcite from the two sources to the two receivers ; or other techniques that may be developed in the future , since this is still an active research area .",
    "we consider the design of these techniques to be out of the scope of this paper and we focus on their use by active learning algorithms to perform a _ query _ , _ i.e. , _ to learn a quartet type by sending and processing a set of active probes .    being able to query",
    "the type of a quartet enables inference of an @xmath0-by-@xmath1 topology in two steps , as follows : first infer the type of each quartet , and then merge these quartets to identify the original topology .",
    "indeed , knowing the type of the quartet , we can use fig .",
    "[ fig-2by2 ] to infer the relative location of joining and branching points .",
    "for example , knowing that the quartet is of type 1 implies that ( i ) the two joining points coincide @xmath44 , ( ii ) the two branching points coincide @xmath45 , and ( iii ) the joining point is above the branching point .",
    "similar inferences can be made from the other types .",
    "* problem statement .",
    "* consistently with @xcite , we assume that @xmath26 ( _ i.e. , _ the @xmath2-by-@xmath1 tree topology rooted at @xmath25 , which contains only branching points ) is known ( _ e.g. , _ using one of the methods in @xcite ) .",
    "we also assume that the type of the quartet between @xmath25 , a new source @xmath39 , and any two receivers can be queried and learned , as explained above .    given ( i ) @xmath26 and ( ii ) the ability to query the quartet type between @xmath25 , @xmath39 , and any two receivers @xmath40 , @xmath15 , our goal is to _ identify _ all joining points , @xmath48 , where the paths from @xmath39 to each receiver join the tree describing paths from @xmath25 to the same set of receivers . because the tree topology of @xmath39 , like @xmath25 , is given .",
    "we are only interested in identifying where these two tree topologies join / merge with each other , _ i.e. , _ we only want to identify the joining points of @xmath25 and @xmath39 trees . ]",
    "identifying a joining point @xmath27 ( for receiver @xmath40 ) means locating @xmath27 on a single logical link , between two branching points on @xmath26 .",
    "_ e.g. , _ in fig .",
    "[ fig - problemstatement ] , the path from @xmath39 to @xmath33 joins the @xmath25 tree at a point between nodes @xmath41 and @xmath35 ; _ i.e. , _",
    "@xmath31 is located on the link @xmath49 .",
    "we achieve this goal via active learning : we start from the given , static , @xmath2-by-@xmath1 topology @xmath26 , and proceed by updating it in steps . in each step",
    ", we select which quartet to query ( _ i.e. , _ which two receivers to send probes to , from sources @xmath25 and @xmath39 ) , _",
    "i.e. , _ only two sources @xmath25 and @xmath39 , we represent the quartets @xmath50 only by the receivers @xmath51 for brevity . ] , and learn its type ( after sending and processing the received probes , we have essentially queried and learned the type of that quartet ) .",
    "we then merge this quartet with the known topology so far .",
    "we continue until identifying the entire @xmath3-by-@xmath1 .",
    "the goal is to exactly identify the @xmath3-by-@xmath1 topology while minimizing the number of queries ( _ i.e. , _ set of probes sent to measure the quartets ) .",
    "this metric is important because it directly translates into measurement bandwidth .",
    "additional performance metrics that it is desirable to keep low include : merging complexity and memory usage .",
    "first , we provide a lower bound on the number of quartets required by any active learning algorithm to identify the @xmath3-by-@xmath1 topology .",
    "this lower bound clearly depends on the topology we want to identify and serves as a baseline for assessing the performance of the proposed algorithms .",
    "[ theorem - minimum2by2s ] given @xmath26 , the number of quartets required to be queried by any algorithm in order to identify all the joining points in @xmath11 , @xmath37 , is at least @xmath4 .    before proving the theorem ,",
    "let us discuss some examples that illustrate the intuition and that this bound is not tight .",
    "[ fig - minimumexamples](a ) shows a @xmath3-by-@xmath1 topology with @xmath38 , which requires querying exactly @xmath52 quartets in order to uniquely identify all the joining points .",
    "this is because , in this particular topology , knowing the types of @xmath53 and @xmath54 is sufficient for identifying all four joining points .",
    "indeed , @xmath53 is of type 4 , which , according to fig .",
    "[ fig-2by2 ] , means that both @xmath31 and @xmath32 lie below @xmath35 ; also @xmath54 is type 4 , which means that both @xmath55 and @xmath56 are below @xmath57 .",
    "thus , each joining point is identified on a single logical link .",
    "[ fig - minimumexamples](b ) shows an example where @xmath52 quartets are not sufficient and 3 quartets are required to identify all the joining points .",
    "there exist @xmath58 possible quartets in this topology , from which @xmath59 pairs of quartets can be selected ; one can check that none of the 15 possible pairs can uniquely identify all the joining points .",
    "for example , let us consider @xmath53 . since it is of type 1 , fig .",
    "[ fig-2by2 ] indicates that @xmath44 and both of them lie above @xmath35 .",
    "however , there is more than a single link above @xmath35 ; therefore , we continue by considering @xmath60 .",
    "it is again of type 1 , which means that @xmath61 is located above @xmath41 .",
    "therefore , we go one step further and consider @xmath62 . since this is also of type 1 , @xmath63 lies above @xmath43 . at this step ,",
    "we only have a single link between @xmath25 and @xmath43 and thus , @xmath64 are all identified ( depicted as @xmath22 in fig .  [ fig - minimumexamples](b ) ) .",
    "although there are other choices of triplets of quartets , in this topology , at least 3 quartets are required .    from these examples",
    ", one can see that the lower bound of @xmath4 is not tight and it is not achievable in every topology .",
    "theorem  [ theorem - minimum2by2s ] follows from the following lemma .",
    "[ lem - minimum2by2s ] in order for an algorithm to identify all joining points for all the receivers , each receiver needs to appear in the set of quartets queried by the algorithm at least once .",
    "assume that there exists a receiver @xmath40 that has not been queried in any of the quartets .",
    "we show that even with complete knowledge of all other joining points , there exist at least two possible and feasible locations for @xmath27 , as follows .    _ location 1 : _",
    "@xmath27 lies on the last incoming link to @xmath40 , _",
    "i.e. , _ on the link between the parent of @xmath40 in the @xmath25 tree ( which from now on , we denote by @xmath65 ) , and @xmath40 .",
    "for example in fig .",
    "[ fig - minimumexamples](a ) and fig .",
    "[ fig - minimumexamples](b ) , assume that @xmath66 ; then location 1 would be the link ( @xmath67 . this is allowed by the routing assumptions in section  [ sec - statement ] because ( 1 ) there is a unique path @xmath28 ; ( 2 ) @xmath28 never merges with @xmath68 , @xmath69 ; and ( 3 ) @xmath28 merges with @xmath70 at @xmath27 , and they continue together until they reach @xmath40 .    _",
    "location 2 : _ define @xmath27 as follows",
    ". on path @xmath70 , start at @xmath65 and move up towards @xmath25 , until the first link that does not fully overlap with any @xmath68 , @xmath69 .",
    "place @xmath27 on that link .",
    "for example in fig .",
    "[ fig - minimumexamples](a ) , location 2 for @xmath32 would be the link ( @xmath71 ) ; whereas in fig .",
    "[ fig - minimumexamples](b ) , it would be the link ( @xmath72 . this location is also allowed by the assumptions in section  [ sec - statement ] :    * there is a unique path @xmath28 .",
    "* for every @xmath69 , the two paths @xmath28 and @xmath68 never join after they branch . indeed ,",
    "if @xmath73 is located above @xmath27 on @xmath70 , then this is guaranteed by the construction of @xmath27 .",
    "in contrast , @xmath73 can not be located below @xmath27 on @xmath70 since this would imply the violation of a2 even before adding @xmath27 . * @xmath28 merges with @xmath70 at @xmath27 and they never split .    thus , both location 1 and location 2 are valid for @xmath27 , according to the routing assumptions , and @xmath27 can not be uniquely identified .",
    "therefore , @xmath40 needs to be queried at least once .",
    "theorem  [ theorem - minimum2by2s ] follows from the following reasoning : each quartet involves two receivers , and thus , at least @xmath4 quartets are required for each receiver to appear in the set of quartets queried by the algorithm at least once .",
    "the gbs approach has been proposed for the problem of determining a binary - valued function through a sequence of strategically selected queries , as explained in the following @xcite .",
    "consider a finite ( potentially very large ) collection of binary - valued functions @xmath74 , called the `` hypothesis space '' , defined on a domain @xmath75 , called the `` query space '' .",
    "each @xmath76 is a mapping from @xmath75 to @xmath77 .",
    "let @xmath78 denote the cardinality of @xmath74 , _",
    "i.e. , _ the total number of hypotheses .",
    "the functions @xmath76 are assumed to be unique , and one function , @xmath79 , produces the correct binary labeling .",
    "@xmath80 is assumed to be fixed but unknown .",
    "the goal is to determine @xmath80 through as few queries from @xmath75 as possible .",
    "therefore , the queries need to be selected strategically in a sequential manner such that @xmath80 is identified as quickly as possible .    it has been shown that the learning problem described above is np - complete @xcite ; a practical heuristic has been proposed in the form of a greedy algorithm called generalized binary search ( gbs ) . at each step , gbs selects a query that results in the most even split of the hypotheses under consideration into two subsets , responding @xmath81 and @xmath82 , respectively , to the query .",
    "the correct response to the query eliminates one of these two subsets from further consideration .",
    "the work in @xcite characterizes the worst - case number of queries required by gbs in order to identify the correct hypothesis @xmath80 .",
    "the main result of @xcite indicates that under certain conditions on the query and hypothesis spaces , the query complexity of gbs ( _ i.e. , _ the minimum number of queries required by gbs to identify @xmath80 ) is near - optimal , _ i.e. , _ within a constant factor of @xmath83 .",
    "the constant depends on two parameters @xmath84 and @xmath85 , defined in @xcite , and it is desirable that they are both as small as possible .    in this section",
    ", we pose our problem in the gbs framework and use the gbs algorithm because ( i ) our problem is one of active learning and lends itself naturally to be posed in the gbs framework , and ( ii ) gbs is a principled ( although not optimal ) approach with provable correctness and performance guarantees @xcite .      in this section ,",
    "we formulate our problem within the gbs framework .",
    "consider a set of hypotheses @xmath74 , where each hypothesis @xmath76 is a configuration that results from placing each joining point @xmath27 on an arbitrary link in the path @xmath70 in the @xmath25 tree .",
    "the query space @xmath75 is the set of all queries for all the quartets , where each query @xmath86 asks about the type of a quartet @xmath51 . since in our problem",
    ", each such query @xmath87 has 4 possible answers ( corresponding to the 4 quartet types ) , we need to modify our queries to make them consistent with the binary functions in the standard gbs framework .",
    "we assume that each query @xmath87 consists of 4 subqueries , each of which asks whether @xmath51 is of a specific type ( 1 , 2 , 3 , or 4 ) or not ; _ i.e. _ : @xmath88 the answer to each such subquery is binary , which is consistent with the gbs formulation . of course",
    ", not all four subqueries are always required for a quartet ; one would stop as soon as she gets the first `` yes '' , which would reveal the type of the quartet . note , however , that we count the number of queries ( not subqueries ) as the performance metric of the gbs algorithm .",
    "let @xmath89 $ ] be a vector of length @xmath1 , which represents the locations of the joining points .",
    "let @xmath90 $ ] represent the worst case benefits for all the quartets .",
    "let @xmath24 be the lowest common ancestor of @xmath91 in @xmath26 let @xmath92 be the subset of @xmath70 located above @xmath24 let @xmath93 be the subset of @xmath94 located above @xmath24 let @xmath95 be the subset of @xmath70 located below @xmath24 let @xmath96 be the subset of @xmath94 located below @xmath24 _",
    "_ type1_b__@xmath97 _ _ type2_b__@xmath98 _ _ type3_b__@xmath99 _ _ type4_b__@xmath100 _ wcb.append(max([type1_b , type2_b , type3_b , type4_b ] ) ) _ _ selectedquartet = wcb.index(min(wcb ) ) _ let _ selectedquartettype _ be the type of _",
    "selectedquartet_. @xmath101 @xmath102 @xmath101 @xmath103 @xmath104 @xmath102 @xmath104 @xmath103 @xmath105 @xmath106 output @xmath22 .",
    "our goal is to find the target hypothesis @xmath80 , which is the configuration that results from the correct placement of the joining points in the @xmath25 topology , using as few queries ( _ i.e. , _ the knowledge of as few quartet types ) as possible . answers every query , for any pair of receivers , in accordance with the true @xmath3-by-@xmath1 topology .",
    "mathematically , @xmath80 is a mapping from queries to @xmath77 , not a topology itself .",
    "however , there is a bijection between all @xmath3-by-@xmath1 logical topologies and the corresponding mappings in @xmath74 , and therefore , knowing @xmath80 is equivalent to knowing the @xmath3-by-@xmath1 topology . ]",
    "algorithm  [ alg - gbs ] describes a greedy strategy based on gbs for determining @xmath80 . in the beginning",
    ", there are @xmath78 possible hypotheses . in each step",
    ", the algorithm selects the best ( _ i.e. , _ maximally discriminating @xcite ) quartet to query as follows . by querying a quartet and learning its type ,",
    "some information is obtained about the locations of two joining points .",
    "thus , the number of feasible hypotheses , which agree with the constraints imposed by the quartets queried and learned so far , is reduced by a number , which depends on the topology in general .",
    "we call this number the _ benefit _ of the quartet .",
    "the best quartet to select to query is the one with maximum benefit .",
    "however , the benefit of each quartet becomes known only _",
    "after _ it is queried .",
    "thus , the algorithm considers all four possible types for every possible quartet , and focuses on the worst case benefit of that quartet , _",
    "i.e. , _ the type that gives the minimum benefit .",
    "the best quartet to query is the one with maximum worst case benefit .",
    "we denote the benefit of each type for a quartet @xmath51 by _ type1_b _ ,",
    "@xmath107 , _ type4_b _ in alg .",
    "[ alg - gbs ] , and define it as follows .",
    "each quartet type limits the number of candidate edges where @xmath27 and @xmath73 can be located on , in the way depicted in fig .",
    "[ fig-2by2 ] .",
    "the benefit of a type for @xmath51 is the ratio of the number of edges where @xmath27 and @xmath73 can potentially be located on after learning this type , divided by the current number of candidate edges for the locations of @xmath27 and @xmath73 .",
    "the worst case ( minimum ) benefit of @xmath51 results from the type for which this ratio is maximized , and the maximum of these worst case benefits over all quartets is given by the quartet with minimum ratio .    in order to provide an analytical upper bound on the number of quartets required by alg .",
    "[ alg - gbs ] , one can try to use the main result of @xcite , which indicates that alg .",
    "[ alg - gbs ] requires @xmath83 quartets . and",
    "@xmath85 in @xcite are both as small as possible . in practice",
    ", there is an additional constant factor for @xmath83 .",
    "] however , we can not compute @xmath78 exactly in our problem ; we can only provide a loose upper bound on that , which is @xmath108 .",
    "tree and considering all possible placements of @xmath27 on @xmath70 , @xmath109 @xmath110 .",
    "[ fig - examples](c ) shows that there are @xmath111 possible such placements . in practice ,",
    "the routing assumptions in section  [ sec - statement ] impose some constraints on possible @xmath27 locations . also , the type of each quartet may rule out some types for the other quartets .",
    "therefore , the exact @xmath78 depends on the topology and we can not compute it . ] therefore , we obtain the upper bound of @xmath112 on the number of quartets required by algorithm  [ alg - gbs ] , which is loose , and much larger than the lower bound . in the next section ,",
    "we evaluate the performance of alg .",
    "[ alg - gbs ] via simulation to obtain a better estimate of the number of quartets it requires to query in order to infer different topologies .",
    "we evaluate alg .",
    "[ alg - gbs ] in simulations over both synthetic topologies ( as shown in fig .",
    "[ fig - examples ] ) and realistic topologies ( as shown in fig .",
    "[ fig - realistic ] ) , and we compare it to the lower bound .",
    "the main performance metric of interest is the number of quartets queried in order to exactly infer the topology , which directly translates into measurement overhead .",
    "additional metrics include the running time and the memory used by the algorithm , _",
    "i.e. , _ the computational complexity .    for the synthetic topologies ,",
    "we illustrate only the @xmath2-by-@xmath1 tree topology of @xmath25 in fig .",
    "[ fig - examples ] .",
    "we consider the star topology , `` perfect '' and `` tall '' binary trees ( referring to the topologies depicted in fig .",
    "[ fig - examples](b ) and [ fig - examples](c ) , respectively ) , and perfect ternary trees , for the @xmath26 tree topology .",
    "starting from this tree , we then create a @xmath3-by-@xmath1 topology , with sources @xmath25 and @xmath39 , by choosing the location of each joining point @xmath27 ( for receiver @xmath40 ) on a single logical link , selected uniformly at random , on @xmath70 in @xmath26 . for each @xmath26 in fig .",
    "[ fig - examples ] , we consider 100 realizations of such random placements ( resulting in different @xmath3-by-@xmath1 topologies ) and report the average number of quartets required for these topologies in the next section .    for the realistic topologies",
    ", we show the complete @xmath3-by-@xmath1 topology in fig .  [ fig - realistic ] .",
    "[ fig - realistic](a ) depicts a us university departmental lan with 16 receivers , first used in @xcite .",
    "[ fig - realistic](b ) is a @xmath3-by-@xmath113 directed acyclic graph ( dag ) , extracted from the exodus topology , which is a large commercial isp whose backbone map was inferred by the rocketfuel project @xcite . to generate this topology",
    ", we picked randomly two nodes of exodus ( nodes 5 , 36 ) to be the sources , and selected all sixteen nodes to which both sources had routes to be the receivers .",
    "we then found the shortest path trees from each source to the receivers , and considered the overlap between these two trees .",
    "our experiments are conducted using the python implementation of algorithm  [ alg - gbs ] , which we have made available online @xcite .",
    "it takes as input any topology and returns the number of quartets required by algorithm  [ alg - gbs ] to infer that topology .",
    "next , we summarize the simulation results .      when @xmath26 is a star topology as depicted in fig .",
    "[ fig - examples](a ) , alg .",
    "[ alg - gbs ] always identifies the @xmath3-by-@xmath1 topology by querying only @xmath4 quartets , which is the lower bound .",
    "therefore , it is optimal .    when @xmath26 is a perfect binary tree as shown in fig .",
    "[ fig - examples](b ) , alg .",
    "[ alg - gbs ] requires different numbers of quartets , between @xmath114 and @xmath1 , in different @xmath3-by-@xmath1 topologies .",
    "however , as shown in fig .",
    "[ fig - binaryresults ] , on average , alg .",
    "[ alg - gbs ] requires @xmath115 quartets .",
    "simulation results for the average number of quartets required by alg .",
    "[ alg - gbs ] ( gbs ) to infer the @xmath3-by-@xmath1 topology when @xmath26 is a perfect binary tree ( fig .  [ fig - examples](b ) ) of various sizes , @xmath116 .",
    "the results are averaged over 100 realizations of random placements of the joining points .",
    "the standard deviation error bars ( not shown ) are comparable with the marker size .",
    "the figure also shows the number of quartets required by alg .",
    "[ alg - merging ] ( rea ) and the lower bound in comparison to alg .",
    "[ alg - gbs ] ( gbs).,width=302 ]    similar results are obtained for tall binary trees ( fig .",
    "[ fig - examples](c ) ) and perfect ternary trees ( fig .",
    "[ fig - examples](d ) ) . here ,",
    "we omit the figures and only report the results . when @xmath26 is a tall binary tree , the number of quartets required by alg .",
    "[ alg - gbs ] varies depending on the quartet types in different @xmath3-by-@xmath1 topologies ; however , in our simulations on tall binary trees with @xmath117 receivers , we observe that in at least @xmath118 of the realizations , alg .",
    "[ alg - gbs ] requires @xmath5 quartets .",
    "this percentage increases up to @xmath119 in topologies with @xmath120 receivers .",
    "when @xmath26 is a perfect ternary tree , again on average , alg .",
    "[ alg - gbs ] requires @xmath5 quartets , while for some topologies , it requires even more than @xmath1 quartets .    for the realistic topologies in fig .",
    "[ fig - realistic](a ) and fig .  [ fig - realistic](b ) , alg .",
    "[ alg - gbs ] identifies both @xmath3-by-@xmath113 topologies by querying @xmath121 ( @xmath122 ) quartets .",
    "therefore , in our simulations , we find out that alg .",
    "[ alg - gbs ] only performs as well as one could hope for , _",
    "i.e. , _ it requires as few quartets as the lower bound , for flat @xmath26 topologies , such as the star topology in fig .",
    "[ fig - examples](a ) . in other topologies , such as binary / ternary trees or realistic topologies",
    ", it requires many more queries , and each round of querying is extremely complex : at each step , alg .",
    "[ alg - gbs ] needs to calculate the worst case benefits of all the quartets , in order to pick the best one among them .",
    "in fact , the time complexity of alg .",
    "[ alg - gbs ] is @xmath123 , and its memory requirement is also high because it requires to keep track of all the benefits and the worst case benefits for all the quartets , as well as all the path updates for the location of each joining point , and so forth .    since alg .",
    "[ alg - gbs ] is not very efficient in practice as described above , we propose an alternate algorithm in the next section , which is much simpler and more efficient than the gbs approach .",
    "in a graph . ]    in this section , we design another greedy algorithm as an alternative to the gbs approach , called the receiver elimination algorithm ( rea ) , which requires more queries than gbs for some topologies , but each iteration is extremely simple and fast , and it scales linearly in the number of receivers . in particular , given @xmath124 and the ability to query the type of any quartet , rea is able to identify all @xmath1 joining points where @xmath125 merges with @xmath124 , _ i.e. , _ the entire @xmath3-by-@xmath1 topology , in @xmath5 steps .",
    "let every edge @xmath126 in @xmath124 have a unique name : @xmath127 .",
    "in our algorithm , we use two operations `` edge deletion '' and `` edge contraction '' , depicted in fig .",
    "[ fig - contraction ] and defined as follows .    _ deleting _ edge @xmath128 , entails taking that edge out of the graph while the end - nodes @xmath129 and @xmath130 , and the labels of the remaining edges in the graph remain unchanged .    _ contracting _ edge @xmath128 into node @xmath131 , consists of deleting that edge and merging @xmath129 and @xmath130 into a single node @xmath131 .",
    "the labels of the remaining edges do not change ( although nodes may be renamed to @xmath131 ) .",
    "rea is described in alg .",
    "[ alg - merging ] .",
    "it starts from the @xmath25 tree ( @xmath124 ) and proceeds by selecting one quartet to query at each step ( _ i.e. , _ two receivers @xmath47 to send probes to , from sources @xmath46 ) .",
    "the two receivers ( @xmath47 ) in the selected quartet are sibling leaves . based on the type of the selected quartet , alg .",
    "[ alg - merging ] identifies exactly one joining point in one step .",
    "it then updates @xmath124 by deleting the receiver whose joining point has been identified and the last incoming edge to that receiver .",
    "that is why we call it the receiver elimination algorithm .",
    "furthermore , if a node of degree two appears in @xmath124 as a result of this edge deletion , the algorithm eliminates that node by contracting the corresponding edge .",
    "the algorithm continues iteratively until there is one edge left , _",
    "i.e. , _ all joining points are identified .",
    "this way , alg .",
    "[ alg - merging ] identifies all joining points ( where paths from @xmath39 to each receiver join the @xmath25 tree ) , one - by - one , proceeding from the bottom to the root of the tree .",
    "next , we describe an illustrative example .",
    "let @xmath22 be a vector of length @xmath1 of edge labels , which represents the locations of the joining points .",
    "pick any two receivers @xmath40 , @xmath15 in @xmath124 , such that @xmath40 and @xmath15 are siblings ; denote their parent by @xmath132 .",
    "query the type of @xmath51 .",
    "@xmath133 delete @xmath40 and edge @xmath134 .",
    "contract @xmath135 into @xmath15 .",
    "@xmath136 delete @xmath15 and edge @xmath135 .",
    "contract @xmath134 into @xmath40 .",
    "@xmath137 delete @xmath40 and edge @xmath134 .",
    "contract @xmath135 into @xmath15 .",
    "@xmath136 delete @xmath15 and edge @xmath135 .",
    "contract @xmath138 into @xmath132 .",
    "/*there is one remaining receiver , which we call @xmath139.*/ let @xmath140 .",
    "output @xmath22 .",
    "[ fig - algexecution](b)-(e ) demonstrate the steps performed by rea to identify the @xmath3-by-@xmath1 topology shown in fig .",
    "[ fig - algexecution](a ) .",
    "the algorithm starts from @xmath26 shown in fig .",
    "[ fig - algexecution](b ) ; @xmath141 are the edge labels on this tree .",
    "the algorithm first selects @xmath142 and queries its type .",
    "since the answer is type 1 , the algorithm assigns @xmath143 , and deletes @xmath34 and @xmath144 .",
    "since the degree of @xmath145 becomes 2 , the algorithm contracts @xmath146 into @xmath147 .    in the second step shown in fig .",
    "[ fig - algexecution](c ) , rea selects two sibling leaves @xmath60 , randomly out of three possible pairs of siblings , and queries its type . since it is type 4 , the algorithm identifies @xmath55 on @xmath148 ( which , together with the previous step , means that @xmath32 is also identified ) .",
    "it also deletes @xmath147 and @xmath148 .",
    "there is no contraction in this step as @xmath43 s degree is @xmath149 .    in the third step shown in fig .",
    "[ fig - algexecution](d ) , @xmath62 is selected and queried ; it is of type 3 .",
    "therefore , the algorithm identifies @xmath31 on @xmath150 , deletes @xmath33 and @xmath150 , and contracts @xmath151 into @xmath42 .",
    "since there is only one receiver left , there are no more quartets to query ; thus the algorithm exits the while loop and proceeds to the last step ( line 26 ) . for @xmath152 ,",
    "the algorithm identifies @xmath56 on @xmath153 , as shown in fig .",
    "[ fig - algexecution](e ) .",
    "the identified joining points agree with the real locations in @xmath11 topology in fig .",
    "[ fig - algexecution](a ) , which demonstrates the correctness of the algorithm .",
    "let @xmath154 denote the logical tree from @xmath25 to all @xmath1 receivers , which we assume to be known .",
    "in this section , we use the notation @xmath155 to emphasize that this initial tree @xmath26 contains @xmath1 receivers .",
    "after each iteration through the while loop in alg .",
    "[ alg - merging ] , one receiver is deleted .",
    "we write @xmath156 to denote the tree ( rooted at @xmath25 ) obtained at the end of iteration @xmath157 , at which point there are @xmath85 receivers remaining .",
    "let @xmath158 denote the set of joining points , which still remain to be identified after iteration @xmath157 , _",
    "i.e. , _ one for each remaining receiver .",
    "let @xmath156 and @xmath158 be given .",
    "the next iteration of alg .",
    "[ alg - merging ] ( lines @xmath159 ) produces @xmath160 and @xmath161 , which satisfy the following properties :    \\1 ) the @xmath25 topology is still a logical tree , and it has @xmath162 receivers ( _ i.e. , _ one receiver and its corresponding edge are deleted from @xmath156 ) .",
    "therefore , we denote it by @xmath160 .",
    "\\2 ) one joining point has been identified ; therefore , the algorithm has @xmath162 more joining points in @xmath161 to identify .",
    "\\3 ) all joining points in @xmath161 are located on edges in @xmath160 .",
    "these properties follow directly from the operations performed by one step of alg .",
    "[ alg - merging ] :    \\1 ) in each iteration , a single receiver is eliminated from the tree .",
    "consequently , the only node that can possibly have degree two ( or out - degree one ) after deleting the receiver is its parent , @xmath132 .",
    "however , after each deletion , alg .  [ alg - merging ] tests to see if @xmath132 has out - degree 1 , and if it does , then an additional contraction is performed so that the resulting tree , @xmath160 , is still logical .",
    "\\2 ) when @xmath51 is of type 2 , 3 , or 4 , we can see in lines 12 , 17 , and 22 of the algorithm , respectively , that one joining point is identified .",
    "when @xmath51 is of type 1 , line 7 assigns to @xmath40 , the same joining point as @xmath15 s . then , in line 8 , @xmath40 is deleted so that we do not create a loop by assigning @xmath27 again to @xmath73 later .",
    "also , @xmath73 eventually becomes identified , either in one of the other types ( 2 , 3 , or 4 ) in the while loop , or in the last line of the algorithm .",
    "thus , we have @xmath161 after one step .",
    "\\3 ) alg .",
    "[ alg - merging ] changes @xmath156 by 2 processes : edge deletion and edge contraction . we show that neither deletion nor contraction can eliminate an edge in @xmath156 that contains a joining point in @xmath161 .    _ deletion : _ alg .",
    "[ alg - merging ] is constructed such that any edge deleted from the @xmath25 tree contains either no joining point ( if @xmath51 is of type 1 ) or exactly one joining point , corresponding to the receiver being removed along with that edge ( if @xmath51 is of type 2 , 3 , or 4 ) .    _",
    "contraction : _ an edge is contracted only when it does not contain any joining point , neither for @xmath40 and @xmath15 ( see lines @xmath163 for type 1 , lines @xmath164 for type 2 , lines @xmath165 for type 3 , and lines @xmath166 for type 4 ) , nor for any other receivers ( since @xmath51 are sibling leaves , the contracted edge can not contain any joining point for any other receiver .",
    "selects _ sibling _",
    "receivers @xmath40 and @xmath15 at each step .",
    "therefore , there are only two potential candidates for the joining points that can be identified at this step : @xmath27 and @xmath73 . ] ) .",
    "the following theorem establishes the correctness and complexity of algorithm  [ alg - merging ] ( rea ) .",
    "[ thm - nsteps ] rea terminates in @xmath1 steps and correctly identifies all @xmath1 joining points after querying @xmath5 quartets .",
    "the proof is via induction . in the beginning",
    ", @xmath167 is a logical tree and according to corollary 1 in @xcite , the joining points are identifiable using sufficient quartets .",
    "our inductive step is one iteration of the while loop .",
    "first , note that there exist two sibling receivers at every step : it is enough to pick one of the lowest receivers ( _ i.e. , _ a receiver with the largest distance from the source ) ; it will always have a sibling because of the logical tree topology .",
    "the algorithm queries one quartet per step , identifies one joining point per step , and at the end of the step , it preserves properties 1 , 2 , and 3 .",
    "the while loop terminates in @xmath5 iterations and there is one additional step for @xmath139 after the loop ( which does not use any quartet ) .",
    "therefore , the algorithm terminates in @xmath1 steps , and correctly identifies all @xmath1 joining points by querying exactly @xmath5 quartets .",
    "_ discussion .",
    "_ an important observation is that the @xmath5 quartets are not known a priori , but are easily selected in a sequential way , as needed ; this makes rea easy to implement in practice using active probing .",
    "another observation is about the running time : exactly @xmath5 quartets need to be queried ( by sending sets of probes ) .",
    "this is much less than the @xmath6 possible quartets queried by a brute - force approach @xcite , but higher than the lower bound on the number of required quartets by any algorithm ( @xmath4 , theorem  [ theorem - minimum2by2s ] ) . therefore , rea is not optimal , but it is simple , efficient , and provably correct . the next section compares the performance of rea to gbs in different topologies .",
    "in section  [ sec - evaluation ] , we evaluated the performance of alg .",
    "[ alg - gbs ] ( gbs ) in simulations over both synthetic topologies of fig .",
    "[ fig - examples ] and realistic topologies of fig .",
    "[ fig - realistic ] . in this section ,",
    "we compare the performance of alg .",
    "[ alg - merging ] ( rea ) against alg .",
    "[ alg - gbs ] ( gbs ) and the lower bound , over the same topologies .",
    "the performance metrics of interest include the number of quartets queried in order to exactly infer the topology , _",
    "i.e. , _ the measurement overhead , as well as the running time and the memory used by each algorithm .      when @xmath26 is a star topology as in fig .",
    "[ fig - examples](a ) , we saw in section  [ sec - evaluation ] that gbs is optimal and requires only @xmath4 quartets . therefore , it performs better than rea , which requires @xmath5 quartets .    on the other hand , when @xmath26 is a perfect binary tree as in fig .",
    "[ fig - examples](b ) , we can see in fig .",
    "[ fig - binaryresults ] that on average , rea performs very close to gbs , while gbs is much more complex than rea .",
    "similar results are obtained for tall binary trees ( fig .",
    "[ fig - examples](c ) ) and perfect ternary trees ( fig .",
    "[ fig - examples](d ) ) .",
    "as described in section  [ sec - evaluation ] , for both @xmath26 topologies , on average , rea performs close to gbs , and for some topologies , gbs requires even more than @xmath1 quartets .    for the realistic @xmath3-by-@xmath113 topologies in fig .",
    "[ fig - realistic](a ) and fig .",
    "[ fig - realistic](b ) , we saw in section  [ sec - evaluation ] that gbs requires @xmath168 quartets , while rea requires @xmath169 quartets .    therefore , one can see that gbs only requires significantly fewer quartets than rea for flat @xmath26 topologies , such as the star topology in fig .",
    "[ fig - examples](a ) . in other topologies , such as binary / ternary trees or realistic topologies ,",
    "rea is preferred over gbs , because it is much simpler and it identifies the joining points using the same number of quartets ( or even fewer quartets in large topologies ) as gbs ( _ i.e. , _",
    "@xmath5 ) .      the time complexity of rea ( @xmath170 ) is significantly lower than that of gbs ( @xmath123 ) .",
    "the reason is that at each step , rea only needs to select a pair of sibling receivers ( any of them will do ) ; while gbs calculates the worst case benefits of all the quartets , in order to pick the best one among them , which takes much longer .",
    "as an example , for a single realization of our simulations when @xmath26 is a perfect binary tree with @xmath171 receivers , the running time of rea is only @xmath172 second , while that of gbs is @xmath173 seconds .",
    "this is a big difference when we consider a large number of realizations as described in section  [ sec - evaluation ] .",
    "the memory requirement of rea is also much lower than that of gbs .",
    "the reason is that rea only requires to store the ( modified version of the ) graph at each step ; while gbs requires to keep track of all the benefits and the worst case benefits for all the quartets , all the path updates for the location of each joining point , and so forth .",
    "in this section , we briefly outline the possible extensions to the active learning algorithms we have discussed so far .",
    "so far , we have focused on inferring a @xmath3-by-@xmath1 topology , which is a special but important case .",
    "@xmath0-by-@xmath1 topologies can be inferred by merging the tree topologies of the remaining @xmath174 sources to this @xmath3-by-@xmath1 topology , one source at a time .",
    "assume that we have inferred a @xmath85-by-@xmath1 topology , @xmath175 . to add the @xmath176 source , we need to identify each joining point of the new source , @xmath177 , and any one of the @xmath85 sources in the current topology , @xmath178 , @xmath179 , for each receiver , on a single logical link in the @xmath85-by-@xmath1 topology ( defined by all the branching points ) .",
    "therefore , we need to apply rea ( or gbs ) to @xmath177 and any one ( in the best case ) or all ( in the worst case ) of the current @xmath85 sources . therefore , for example using rea , the number of quartets required to identify the @xmath0-by-@xmath1 topology is between @xmath180 and @xmath181 .",
    "so far , we have considered the noiseless scenario , where the answer to each query is the correct quartet type .",
    "one can extend the algorithms to deal with noisy queries , using the two approaches proposed in @xcite .",
    "the first one is a simple solution that applies to both gbs and rea ; it repeats the query multiple times and considers the majority vote as the answer to that query .",
    "the second approach is more sophisticated and fits naturally in the gbs framework .",
    "it assigns weights to each hypothesis using a probability distribution .",
    "the initial weighting is uniform , but it gets updated after each query .",
    "the update naturally boosts the probability measure of the hypotheses that agree with the answer to the query . at the end",
    ", the hypothesis with the largest weight is selected .",
    "we can adopt this approach for the gbs algorithm by incorporating the probability measures in the path updates and in computing the benefits . using this approach , gbs can handle the noisy queries more naturally than rea . the query complexity and the probability of error for both approaches",
    "have been analyzed in @xcite .",
    "although active topology inference is a well - studied problem , to the best of our knowledge , this paper is the first to focus on efficient merging algorithms .",
    "we formulate the problem as multiple hypothesis testing and develop an active learning algorithm based on gbs .",
    "we also propose an efficient receiver elimination algorithm that queries only @xmath5 quartets , which is much less than the @xmath6 possible quartets .",
    "furthermore , comparing it to the gbs algorithm in simulations , we find out that the simple rea is near - optimal , and comparable to the gbs approach in terms of the number of queries ( thus measurement bandwidth ) , while having much lower time and space complexity .",
    "therefore , it is preferable for all practical purposes .",
    "m.  coates , r.  castro , m.  gadhiok , r.  king , y.  tsang , and r.  nowak , `` maximum likelihood network topology identification from edge - based unicast measurements , '' in _ proc . of acm sigmetrics _ , marina del rey , ca , june 2002 .",
    "p.  sattari , c.  fragouli , and a.  markopoulou , `` active topology inference using network coding , '' _ elsevier phycom , special issue on network coding and its applications to wireless communications _ ,",
    "vol .  6 , pp .",
    "142163 , march 2013 .",
    "e.  katz - bassett , h.  madhyastha , j.  p. john , a.  krishnamurthy , d.  wetherall , and t.  anderson , `` studying black holes in the internet with hubble , '' in _ proc .",
    "of usenix nsdi _",
    ", san francisco , ca , april 2008 .",
    "p.  sattari , m.  kurant , a.  anandkumar , a.  markopoulou , and m.  rabbat , `` active learning of multiple source multiple destination topologies , '' in _ proc . of ieee ciss _ , johns hopkins university , baltimore , md , march 2013 ."
  ],
  "abstract_text": [
    "<S> we consider the problem of inferring the topology of a network with @xmath0 sources and @xmath1 receivers ( hereafter referred to as an @xmath0-by-@xmath1 network ) , by sending probes between the sources and receivers . </S>",
    "<S> prior work has shown that this problem can be decomposed into two parts : first , infer smaller subnetwork components ( _ i.e. , _ </S>",
    "<S> @xmath2-by-@xmath1 s or @xmath3-by-@xmath3 s ) and then merge these components to identify the @xmath0-by-@xmath1 topology . in this paper , we focus on the second part , which had previously received less attention in the literature . </S>",
    "<S> in particular , we assume that a @xmath2-by-@xmath1 topology is given and that all @xmath3-by-@xmath3 components can be queried and learned using end - to - end probes . </S>",
    "<S> the problem is _ which _ </S>",
    "<S> @xmath3-by-@xmath3 s to query and _ how _ to merge them with the given @xmath2-by-@xmath1 , so as to exactly identify the @xmath3-by-@xmath1 topology , and optimize a number of performance metrics , including the number of queries ( which directly translates into measurement bandwidth ) , time complexity , and memory usage . </S>",
    "<S> we provide a lower bound , @xmath4 , on the number of @xmath3-by-@xmath3 s required by any active learning algorithm and propose two greedy algorithms . </S>",
    "<S> the first algorithm follows the framework of multiple hypothesis testing , in particular generalized binary search ( gbs ) , since our problem is one of active learning , from @xmath3-by-@xmath3 queries . </S>",
    "<S> the second algorithm is called the receiver elimination algorithm ( rea ) and follows a bottom - up approach : at every step , it selects two receivers , queries the corresponding @xmath3-by-@xmath3 , and merges it with the given @xmath2-by-@xmath1 ; it requires exactly @xmath5 steps , which is much less than all @xmath6 possible @xmath3-by-@xmath3 s . </S>",
    "<S> simulation results over synthetic and realistic topologies demonstrate that both algorithms correctly identify the @xmath3-by-@xmath1 topology and are near - optimal , but rea is more efficient in practice .    </S>",
    "<S> adaptive sensing algorithms , inference and estimation on graphs , applications of statistical signal processing techniques , sequential learning , active hypothesis testing , network monitoring , internet , tomography . </S>"
  ]
}