{
  "article_text": [
    "interactive theorem provers , also known as proof assistants , are computer programs for the development and verification of mathematical texts in a formal language .",
    "these systems make it _ _ certain _ _ that the verified mathematics contains no errors at all .",
    "the activity of coding mathematics in the formal language of an interactive theorem prover is called _ formalizing _ , and the set of resulting input files for such a system is called a _ formalization_. highly non - trivial proofs have been formalized , both in mathematics @xcite and in computer science @xcite .    in interactive theorem proving one can consider the proofs on two different levels .",
    "there is the _ user level proof _ , the proof in the formalization files on the level of which the user interacts with the system .",
    "and there is the _ proof object _ , the proof in the formal system underlying the system .",
    "generally the second is an order of a magnitude larger than the former . in systems like coq and hol @xcite , the user level proof consists of a list of tactics to be executed .",
    "the proof objects in coq are lambda terms , while in hol they consist of traces of function calls into the lcf style kernel of the system . in a system like mizar",
    "@xcite the user level proof consists of the proof steps in the input language of the system .",
    "the mizar implementation does not keep track of proof objects , but the proofs on the proof object level would be the formal deductions in first order predicate logic .",
    "interactive theorem provers can use three different proof styles ( the terminology originates in @xcite ) :    1 .   _ the procedural style .",
    "_ [ item : procedural ] in these systems the user inputs a proof as a sequence of _ tactic _ invocations , which are commands that transform proof obligations called _ goals_. a tactic reduces a goal to zero or more new subgoals .",
    "when all goals have been solved this way , the proof is finished .",
    "note that although most procedural systems support both forward and backward proof , the user interaction in those system primarily consists of reasoning backwards from a goal .",
    "systems that use the procedural style are the various hol systems like hol4 @xcite , hol light @xcite and proofpower @xcite , the original version of isabelle @xcite , coq @xcite , matita @xcite , pvs @xcite , the b method @xcite and metamath @xcite .",
    "+ some procedural systems offer the option to print their proof objects in the form of natural language text .",
    "an example of such a system is matita ( see the discussion in section  [ related ] below ) .",
    "2 .   _ the declarative style . _",
    "[ item : declarative ] in these systems the user inputs proofs in a stylized natural deduction language ( de bruijn called such a language a _ mathematical vernacular _",
    "the output of the system then consists of messages that point out where the proof text still has errors .",
    "there are two subclasses of this proof style : a.   [ item : declarative : natlang ] _ the natural language declarative style .",
    "_ here the proof language is a formal version of mathematical natural language , also called a _ controlled _ natural language .",
    "trivial reasoning between the steps in a proof is provided by the system through ( light weight ) automation .",
    "systems that use this proof style are mizar @xcite and isabelle with its ` structured ' proof language isar @xcite .",
    "+ actually , the mizar and isar languages , as well as the language described in this paper , are not very much like natural language .",
    "the forthel language for the sad system @xcite is much better in this respect .",
    "b.   _ the proof object declarative style . _",
    "[ item : declarative : object ] here the proof input language is a syntactic rendering of the proof object , with the structure of a natural deduction proof .",
    "systems that use this style are twelf @xcite , agda @xcite and epigram @xcite .",
    "+ in some of these systems , the user does not need to type the whole input text by themselves , but can also give _",
    "commands _ in the interface that generate part of the proof text .",
    "these commands will _ not _ be part of the proof files that are the final formalization .",
    "examples of such systems are agda and epigram .",
    "3 .   _ the guided automated style . _ [ item : guidedautomated ] in these systems the input is a sequence of lemma statements , which the system then tries to prove by itself .",
    "these systems generally produce long natural language texts for each lemma describing how it was proved .",
    "often for some of the lemmas parameters need to be given that direct the system how to perform the proof .",
    "also the lemma statements need to be chosen well for the system to be able to do the proof , as the gaps between the statements should not be too large . for this reason these systems still are _ interactive _ theorem provers .",
    "systems that use this style are acl2 @xcite and theorema @xcite .",
    "+ one can consider the guided automated style to be either an extreme version of the procedural or an extreme version of the declarative style . in a guided automated theorem prover ,",
    "one runs one supertactic per lemma . or",
    ", in a guided automated theorem prover one writes a theory as a series of lemma statements , where the system checks that each statement follows from the previous ones .",
    "it is interesting to compare where the ` proof commands to the system ' and where the ` natural language proofs ' are in these various proof styles :    lcc & _ commands _ & _ natural language _ + procedural & input & absent or output + declarative , natural language & absent & input + declarative , proof object & absent or interface & absent + guided automated & input & output + & interface _ and _ input & input _ and _ output +    there are some systems that are outside the simplicity of this table , like isabelle with its combination of natural language declarative and procedural proof styles , like matita with its declarative proof checker , and like the ` skeletonizer ' of mizar .",
    "these systems will be discussed in section  [ related ] below .",
    "the proof style that we propose in this paper is an integration of the procedural and natural language declarative styles .",
    "the advantage of the declarative style is that it is closer to normal mathematical practice ( one just writes proofs ) with more readable proof scripts , and that it gives full control over the exact statements in the proof .",
    "also declarative proofs tend to be easier to maintain and less dependent on the specific system than procedural ones .",
    "the advantage of the procedural style is that one does not need to write all intermediate statements : these are generated automatically . also , procedural systems tend to have much stronger automation , with often many different _ decision procedures _ that without human help can perform proofs in specific domains .",
    "the goal of this paper is to propose a proof style that combines the best of these two worlds",
    ".      looked at superficially , the procedural and declarative proof styles seem very different . certainly the proof scripts for those two styles _",
    "look _ completely different .",
    "however , when working with these systems , both styles turn out to have a very similar work flow .    when working on a declarative proof , most of the time when one is not finished the only errors left are that the system did not succeed in proving some of the steps in the proof from the earlier steps . in mizar",
    "these steps are called _ unjustified _ steps , and have error numbers ` * 1 ` and ` * 4 ` .",
    "now these unjustified steps correspond exactly to the subgoals that one looks at when a procedural proof is not finished ! in other words , an unfinished proof of a mizar lemma in which there still are  say  seven unjustified steps left , is very similar to a coq or hol proof in which there are still seven subgoals left .",
    "this is the first observation that is the basis of our approach .",
    "a proof in a declarative system consists of ` steps ' , most of which contain a statement .",
    "if one does the analogous proof in a procedural system , one goes through many subgoals that _ also _ consist of many statements .",
    "now it turns out that those two sets of statements in practice are very much the same ! in other words , if for a procedural proof we collect all the statements in the goals ( both the assumptions and the statements to be proved ) , then those statements can in a natural way be organized as a declarative proof .",
    "this is the second observation at the basis of our approach .",
    "note that in these two observations there is no reference to proof objects .",
    "this means that our integration of the procedural and declarative proof styles does not have anything to do with proofs on the proof object level .",
    "it also means that our proposed approach is independent of the foundations or architecture of the system .",
    "what we propose will apply to _ any _ system in which the user performs proofs by executing tactics on subgoals containing statements .",
    "our proposal then is to have a proof interface in which a user is working on a declarative proof . in this proof",
    "the unjustified statements _ are _ considered the subgoals of the prover . at any of these steps / subgoals one can execute any tactic of the system , and",
    "if this is successful the statements of the new subgoals that the tactic produces will be merged into the proof text , making the declarative proof ` grow ' @xcite . however , one also can freely manually edit and then recheck the declarative text .",
    "the text does not need to ` remember ' how it has been grown .",
    "for an example of how all this works out in a concrete session , see section  [ session ] below .      from the introduction in section  [ problem ] it will be clear that the proof style that we propose is a combination of aspects of many different proof systems . however , there are some systems that are quite close to what we propose . for each of them",
    "we will discuss now how they differ from our work :    -12 pt**isabelle / isar * * :  in isabelle one can encapsulate procedural proof fragments consisting of tactic applications in a declarative isar proof text @xcite",
    ". however , the user needs to manually type the declarative text ( it is not generated like in our approach ) , and the procedural proofs do not make sense without running them on the system ( unlike in our approach , where the tactics do not _ solve _ the goal but connect statements together ) .",
    "-12 pt**ssreflect * * :  the usage of georges gonthier s ssreflect language for coq @xcite is similar to a common way of using isar . it is used declaratively for the high level structure of the proof while at the ` leaves ' of the proof the user switches to the procedural proof style . however , the declarative part of ssreflect is much less developed than isar .",
    "also , although ssreflect is clearly intended to be also used declaratively , it barely fits category ( 2a ) in the classification above .",
    "-12 pt**helm / mowgli / matita * * :  the helm , mowgli and matita systems @xcite have as one of their goals to render type theoretical proof objects as natural language . in matita , these rendered proof objects also can be read back in , and checked for correctness like in a declarative proof system @xcite .",
    "an important difference with our approach is that one can not go back from declarative editing to procedural proving .",
    "once a declarative proof text has been modified , if the procedural proof from which it has been generated also gets modified , both modifications can not be integrated .",
    "in other words , once one has worked declaratively , working procedurally is no longer possible .",
    "another difference is that the declarative proof text is generated from the proof object , which is generally more fine grained than the user level proof on the level of the tactic invocations , and is therefore more verbose and less understandable .",
    "-12 pt**the proof rendering from the lemme project**:when proofs are being rendered as natural language , the source of the rendering is generally the proof object .",
    "an important exception is a system by frdrique guilhot , hanane naciri and loc pottier .",
    "unfortunately , this work seems not to have been published , all that exists is a set of slides for a talk about it @xcite .",
    "a difference with our approach is that the generated text can not be modified by the user anymore .",
    "the rendering in this system is just output , and is not parsed back again .",
    "-12 pt**nuprl**:the nuprl system @xcite has a way to display formal proofs in which groups of tactics are interleaved with fragments of goals . between the groups of tactics ,",
    "the parts of the goal that have changed are shown ( see for an example the nuprl chapter in @xcite ) .",
    "this is quite similar to what happens in our approach .",
    "but again , this rendering is just output , and is not parsed back again .    -12",
    "pt**mizar s skeletonizer**:in natural language declarative systems like isar and mizar , the proof text has to be written by the user .",
    "a slight exception to this is the ` skeletonizer ' of the emacs interface to mizar by josef urban @xcite . in this interface , a proof skeleton",
    "is automatically generated from the statement to be proved .",
    "this is similar to what happens when we ` grow ' a proof by executing a tactic .",
    "however , in our case the growing is _ generic _ :",
    "for each tactic there is a corresponding way to insert part of the proof . in mizar",
    "there is only one such way .",
    "there already are various declarative proof languages which have been grafted on top of a procedural system .",
    "currently isabelle / isar is the only one that knows widespread use .",
    "others are :    -12 pt**`mizar modes ' for hol light**:there are two by john harrison @xcite and two earlier ones by the author ( @xcite and an unpublished one included in the hol light distribution @xcite ) .",
    "the ` 3 ` in the system name ` miz3 ` refers to the fact that this is the third mizar mode for hol light that we developed .",
    "-12 pt**c - zar * * :   a declarative proof language for coq by pierre corbineau @xcite .",
    "-12 pt**phox**:there exists an experimental declarative version of the phox theorem prover by christophe raffalli @xcite .",
    "these systems are all quite similar .",
    "the main improvement of the work described in this paper over these other systems is that it adds a mizar - style interaction model , and that it integrates execution of tactics with generation of proof text .",
    "this paper is a continuation of the work in @xcite .",
    "it contains three contributions :    @xmath0    we describe a declarative proof interface for the hol light theorem prover that is much more developed and far more ergonomic than earlier attempts at this .",
    "this software can be downloaded at :    http://www.cs.ru.nl/~freek/miz3/miz3.tar.gz    we describe a new proof style for interactive theorem provers that is a synthesis between the procedural and declarative proof styles .",
    "we describe a method for automatically converting _ any _ existing procedural proof to a declarative equivalent .",
    "this gives an approach for conserving libraries of formal proofs and semi - automatically porting them between systems .",
    "for details see section  [ automatic ] below .",
    "the structure of the paper is as follows . in section  [ session ]",
    "we describe through an example how the proof interface that we developed works . in section  [ language ]",
    "we describe the declarative proof language of this interface . in section  [ implementation ]",
    "we give some details of the implementation of this interface . in section",
    "[ automatic ] we describe how our approach makes it possible to automatically convert existing proofs to our language . in section  [ lagrange ]",
    "we describe our experiences with using our interface on a non - trivial example . finally in section  [ discussion ]",
    "we conclude with some observations and planned future work .",
    "we developed a prototype of the interface style proposed in this paper as a layer called ` miz3 ` on top of the hol light system @xcite .",
    "it consists of about 2,000 lines of ocaml code ( in comparison , the basic hol light system is approximately 30,000 lines ) , and its development took three man months .",
    "we will explain the ` miz3 ` interface with a simple example .",
    "for this we will use the traditional inductive proof of @xmath1 in hol light this is written as :    ` !",
    "n .  nsum ( 1 .. n ) ( i.  i ) = ( n * ( n + 1 ) ) div 2 `    in this formula , the exclamation mark ` ! `",
    "is ascii for the universal quantifier @xmath2 , the backslash `` is ascii for the @xmath3 of function abstraction , and the function ` nsum ` is a higher order version of the summation operator @xmath4 .",
    "of course the example is very trivial .",
    "we do not want to give the impression that our approach only works well for simple examples like this . we just chose this example to be able to fit a reasonable representation of a proof session for it in the paper .",
    "we worked on much larger proofs with ` miz3 ` , and it performs well on those too . for a description of such a larger example see section  [ lagrange ] below .    to prove the equality of the example",
    ", we will need one lemma , which is the recursive characterization of ` nsum ` .",
    "the statement of this lemma , which we will use for rewriting expressions involving ` nsum ` , is :     + ` #  ` + ` val  it  :  thm  = ` + `  |-  ( ! m .",
    "nsum  ( m .. 0 )  f  =  ( if  m  =  0  then  f  0  else  0 ) )  / ` + `  ( ! m  n. ` + `  nsum  ( m .. suc  n )  f  = ` + `  ( if  m  < =  suc  n  then  nsum  ( m .. n )  f  +  f  ( suc  n )  else  nsum  ( m .. n )  f ) ) `    this is the first example of a command in a hol light session .",
    "we indicate user input by putting boxes around it , to differentiate it from the output from the system that is outside those boxes .",
    "we will now show how the proof of this statement is developed , both in the traditional procedural style of the hol light system , as well in the synthesis between the procedural and declarative proof styles that we propose in the paper .",
    "traditionally , one develops the proof of a lemma in hol light in an interactive session .",
    "however , the exact commands from that session are not what is put in the formalization file .",
    "we now first show the session , and then the proof as it is written in the file .",
    "the session for this lemma consists of six commands , with after each command output from the system :     + ` #  ` + ` val  it  :  goalstack  =  1  subgoal  ( 1  total ) ` +   + `  !",
    "n .  nsum  ( 1 .. n )  ( i.  i )  =  ( n  ( n  +  1 ) )  div  2  ` +   + ` #  [ tactic ] ` + ` val  it  :  goalstack  =  2  subgoals  ( 2  total ) ` +   + `  0  [  nsum  ( 1 .. n )  ( i.  i )  =  ( n  ( n  +  1 ) )  div  2  ] ` +   + `  nsum  ( 1 .. suc  n )  ( i.  i )  =  ( suc  n  ( suc  n  +  1 ) )  div  2  ` +   + `  nsum  ( 1 .. 0 )  ( i.  i )  =  ( 0  ( 0  +  1 ) )  div  2  ` +   + ` #  ` + ` val  it  :  goalstack  =  1  subgoal  ( 2  total ) ` +   + ` ",
    "( if  1  =  0  then  0  else  0 )  =  ( 0  ( 0  +  1 ) )  div  2  ` +   + ` #  ` + ` val  it  :  goalstack  =  1  subgoal  ( 1  total ) ` +   + `  0  [  nsum  ( 1 .. n )  ( i.  i )  =  ( n  ( n  +  1 ) )  div  2  ] ` +   + `  nsum  ( 1 .. suc  n )  ( i.  i )  =  ( suc  n  ( suc  n  +  1 ) )  div  2  ` +   + ` #  ` + ` val  it  :  goalstack  =  1  subgoal  ( 1  total ) ` +   + `  0  [  nsum  ( 1 .. n )  ( i.  i )  =  ( n  ( n  +  1 ) )  div  2  ] ` +   + `  ( if  1  < =  suc  n  then  ( n  ( n  +  1 ) )  div  2  +  suc  n  else  ( n  ( n  +  1 ) )  div  2 )  = ` + `  ( suc  n  ( suc  n  +  1 ) )  div  2  ` +   + ` #  ` + ` val  it  :  goalstack  =  no  subgoals `    the session starts with a ` g ` command that sets the goal to be proved , and then executes five tactics using the ` e ` command .",
    "each time after a tactic , the system presents the subgoals that the tactic produced , where the assumptions from which the subgoal has to be proved are numbered ( from 0 ) , and the statement to be proved is unnumbered .",
    "if there are multiple subgoals produced ( as is the case with ` induct_tac ` ) , the first goal to be worked on is printed last .",
    "the proof as it appears in the formalization file uses a more compact representation of these commands .",
    "it consists of just three lines , containing the name of the lemma , the statement , and the sequence of tactics separated by ` then`s :    this is the customary shape of lemmas in a hol light formalization .",
    "we will now show how the same proof is developed using the ` miz3 ` interface .",
    "this is a synthesis of the procedural and declarative proof styles , but more specifically it is a close synthesis of the hol light and mizar proof styles . for example , like in mizar the system will modify the file being worked on by putting error messages inside that file .",
    "also , the syntax of the ` miz3 ` proofs ( explained in detail in section  [ language ] below ) is a direct hybrid of the syntax of mizar and hol light : the proof steps are written using mizar syntax , but the formulas and types in those proof use hol light syntax .",
    "there are three ways to process a ` miz3 ` proof .",
    "first , one can just give the proof text as a command to the ocaml interpreter running hol light .",
    "the parser has been modified to recognize the following convention :    [ cols=\"^,^ \" , ]     the communication between the ` vi ` session and hol light is initiated by ` vi ` sending a unix signal to hol light , after which the signal handler of the hol light session does all the work .",
    "this means that the hol light session when not doing a ` miz3 ` check is not actively ` waiting ' for commands , and that if it is running some other code , then that code will be interrupted to do the ` miz3 ` check .",
    "the communication between ` vi ` and hol light is through files , of which some have hard coded special names in order for both sides to be able to find them .    specifically , when checking a proof from the ` vi ` interface by typing    the following steps happen :    ( 1 )    the relevant part of the buffer is selected using the ` vi ` commands `  { ` and `  } ` .",
    "this part of the buffer is filtered through the perl script ` miz3f ` .",
    "this script writes this to a temporary file in ` /tmp ` , and runs the shell script ` miz3 ` on that file .",
    "this then writes the name of its input file in the file with the special name ` /tmp/100miz3_100filename ` , looks up the process i d of the hol light session running the ` miz3 ` server in ` /tmp",
    "/ miz3_pid ` , and sends that process the ` usr2 ` signal .",
    "the signal handler of the hol light session now finds the file it needs to check , and parses it into a data structure of ocaml type ` step ` ` list ` . in this data structure",
    "the full input is stored in small pieces .",
    "next , the server calls the function ` check_proof ` on this , which returns another ` step ` ` list ` , this time with errors marked , and possibly grown by running tactics after the `  # ` symbol .",
    "this result now is printed back into the file in ` /tmp ` , after which the filter puts it back into the edit buffer .    in other words",
    "the _ full _ proof is processed _ every _ time a check is done . to make this acceptably fast , there are two caches .",
    "the first cache holds inferences that have already been checked , to prevent the checker from having to run all tactics every time .",
    "the second cache holds the ocaml objects associated with the elements in the ` by ` justifications .",
    "these are calculated using the ocaml functions ` toploop.100parse_toplevel_phrase ` and ` toploop.execute_phrase ` ( which together are the ocaml equivalent of lisp s ` eval ` function ) .",
    "we do not want to restrict users to ` special ' tactics that are designed to always terminate in a reasonable time .",
    "this means that while working on a proof sometimes tactics will ` hang ' .",
    "therefore , while developing a proof , after a specified time tactics will be killed using the ` unix.alarm ` function . this time is given by the variable ` timeout ` . of course",
    ", this makes it dependent on the specific computer used whether a proof will be accepted or flagged with a time - out error .",
    "( however , a similar thing holds for any interactive theorem prover , because the memory might run out during a check as well . )",
    "if one wants to check a finished proof on a slow system without having to worry about time - outs for tactics , one can set ` timeout ` ` : = ` ` -1 ; ; ` to disable time - outs .",
    "the system will never pretty - print user input by itself , even though it parses and reprints proofs all the time .",
    "even white space and comments will stay exactly the way they are .",
    "however , if the proof is modified by ` growing ' it through execution of tactics , the system tries hard to indent and line wrap the new parts nicely .",
    "there are a dozen parameters to direct this process , which are listed at the start of the source file ` miz3.ml ` .",
    "although the interface currently only runs in ` vi ` , we took great care to not have it be dependent on ` vi ` specific features .",
    "in fact , the whole `` miz3 ` mode ' for ` vi ` essentially consists of the single line in the ` .exrc ` file ( for ` vim ` users the ` .vimrc ` file ) , which is the file that configures mappings between ` vi ` keystrokes and commands .",
    "the simplicity of this interface means that porting it to other editors will be trivial .",
    "traditional hol light proofs can be mimicked in ` miz3 ` by using the system in the procedural style as shown in section  [ session ] .",
    "we wrote a small program that automates this process .",
    "using this , _ any _ proof from hol light library can be fully automatically converted to the ` miz3 ` language .",
    "for example , consider the following hol light lemma , that says that subtraction on natural and real numbers correspond to each other :     + ` let  real_of_num_sub  =  prove ` + `  (  !",
    "m  n.  m  < =  n  = = >  ( & n  -  & m  =  & ( n  -  m ) )  , ` + `  repeat  gen_tac  then  rewrite_tac[le_exists ]  then ` + `  strip_tac  then  asm_rewrite_tac[add_sub2 ]  then ` + `  rewrite_tac[gsym  real_of_num_add ]  then ` + `  once_rewrite_tac[real_add_sym ]  then ` + `  rewrite_tac[real_sub ;  gsym  real_add_assoc ]  then ` + `  meson_tac[real_add_linv ;  real_add_sym ;  real_add_lid ] ) ; ; `    to be able to use the converter , it is necessary to load it :     + ` #  ` +    then one converts the proof as follows :     + ` #  ` + ` 0 .. 0 .. 1 .. 2 .. 7 .. 14 .. 37 .. 72 .. 174 .. 325 .. solved  at  392 ` + ` val  it  :  step  = ` + `  ! m  n.",
    "m  < =  n  = = >  & n  -  & m  =  & ( n  -  m )  [ 1 ] ` + `  proof ` + `  !",
    "n  m.  m  < =  n  = = >  & n  -  & m  =  & ( n  -  m )  [ 2 ] ` + `  proof ` + `  let  n  m  be  num ; ` + `  !",
    "d.  n  =  m  +  d  = = >  & n  -  & m  =  & ( n  -  m )  [ 3 ] ` + `  proof ` + `  let  d  be  num ; ` + `  assume  n  =  m  +  d  [ 4 ] ; ` + `  & d  +  & m  +    & m  =  & d  [ 5 ] ` + `  by  meson_tac[real_add_linv ;  real_add_sym ;  real_add_lid],4 ; ` + `  ( & d  +  & m )  -  & m  =  & d  [ 6 ] ` + `  by  rewrite_tac[real_sub ;  gsym  real_add_assoc],4  from  5 ; ` + `  ( & m  +  & d )  -  & m  =  & d  [ 7 ]  by  once_rewrite_tac[real_add_sym],4  from  6 ; ` + `  & ( m  +  d )  -  & m  =  & d  [ 8 ] ` + `  by  rewrite_tac[gsym  real_of_num_add],4  from  7 ; ` + `  qed  by  asm_rewrite_tac[add_sub2],4  from  8 ; ` + `  ( ?",
    "n  =  m  +  d )  = = >  & n  -  & m  =  & ( n  -  m )  [ 9 ]  by  strip_tac  from  3 ; ` + `  qed  by  rewrite_tac[le_exists ]  from  9 ; ` + `  qed  by  repeat  gen_tac ; `    the possibility to convert proofs like this does not depend on hol light specifics . any procedural system that has goals and tactics can have a ` miz3 ` layer on top of it and proofs can then be converted to that in exactly the same way .",
    "we believe that this gives an approach to ` integrate ' mathematical libraries between systems :    ( 340,120)(0,22 ) ( 40,32 )    ( 0,0 )    _ system 1 _    ( 170,32 )    ( 0,0 )    _ system 2 _    ( 300,32 )    ( 0,0 )    _ system 3 _    ( 40,60 )    ( 0,0 )    declarative proofs    ( 170,60 )    ( 0,0 )    declarative proofs    ( 300,60 )    ( 0,0 )    declarative proofs    ( 40,130 )    ( 0,0 )    procedural proofs    ( 170,130 )    ( 0,0 )    procedural proofs    ( 300,130 )    ( 0,0 )    procedural proofs    ( 40,122)(0,-1)53 ( 170,122)(0,-1)53 ( 300,122)(0,-1)53 ( 87,60)(1,0)36 ( 123,60)(-1,0)36 ( 217,60)(1,0)36 ( 253,60)(-1,0)36    however , conversions between mizar style proofs for different systems can not be completely automatic .",
    "even although the ` miz3 ` language can be put on top of any system , the semantics of the _ statements _ ( when working on top of the native library of the systems ) will not exactly match , and the _ justification _ automation will not match either . when converting a ` miz3 ` proof to mizar , isar or c - zar , one can only do an approximate job with the statements , and there is no proper way to translate all tactics .",
    "however , one gets a very good ` starting point ' when converting a declarative proof between systems . there",
    "just will be some justification errors .",
    "this means that a declarative proof converted to a different system will be like a ` formal proof sketch ' @xcite .    for these reasons our system can also not directly make use of the mizar mathematical library mml . but",
    "again , it is not difficult to write a translator that translates a class of mizar proofs ( the ones that use statements that map reasonably well to hol light versions ) into ` miz3 ` formal proof sketches .",
    "we have tried ` miz3 ` on a somewhat larger proof : lagrange s theorem from group theory .",
    "this states that for any group the order of a subgroup always divides the order of that group .",
    "john harrison already had written a hol light proof of this theorem , which meant that we could see how the traditional proof style compared to what was possible in ` miz3 ` .",
    "we used two different approaches : we wrote a proof following the proof that is in van der waerden s book about algebra @xcite , and we wrote a ` miz3 ` proof trying to closely follow john harrison s proof .",
    "van der waerden s proof we formalized both in mizar and in ` miz3 ` , and in both cases we first wrote a formal proof sketch @xcite of the proof .",
    "the ` miz3 ` formal proof sketch was :     + ` now  let  a  be  a ;  assume  a  in  g ;  let  b  be  a ;  assume  b  in  g ; ` + `  assume  i(a)**b  in  h ; ` + `  b***h  =  a**i(a)**b***h ;  .=",
    "a***(i(a)**b***h ) ;  thus  .=  a***h ; ` + ` end ; ` + ` !",
    "a  b.  a  in  g  /  b  in  g  /  ( a***h  =  b***h )  = = >  a***h",
    "inter  b***h  =  { } ` + ` proof  let  a  be  a ;  assume  a  in  g ;  let  b  be  a ;  assume  b  in  g ; ` + `  now  assume  ( a***h  inter  b***h  =  { } ) ; ` + `  consider  g1  g2  such  that  g1  in  h  /  g2  in  h  /  a**g1  =  b**g2 ; ` + `  g1**i(g2 )  =  i(a)**b ; ` + `  i(a)**b  in  h ; ` + `  thus  a***h  =  b***h ; ` + `  end ; ` + ` qed ; ` + ` ! a .  a  in  g  = = >  a  in  a***h  proof  let  a  be  a ;  assume  a  in  g ;  a**e  =  a ;  qed ; ` + ` { a***h  |  a  in  g }  partitions  g ; ` + ` ! a  b.  a  in  g  /  b  in  g  = = >  card  ( a***h )  =  card  ( b***h ) ` + ` proof  let  a  be  a ;  assume  a  in  g ;  let  b  be  a ;  assume  b  in  g ; ` + `  consider  f  such  that",
    "! g.  g  in  h  = = >",
    "f(a**g )  =  b**g ; ` + `  bijection  f  ( a***h )  ( b***h ) ; ` + ` qed ; ` + ` set  index  =  card  { a***h  |  a  in  g } ; ` + ` set  n  =  card  g ;  set  n",
    "=  card  h ;  set  j  =  index ;  n  =  j*n ; ` + ` thus  card  h  divides  card  g ; `    ( the notations with the multiple stars is a bit ugly , but we wanted to use the statement from john harrison s proof , and there group multiplication is written as ` * * ` .",
    "we then used ` * * * ` for multiplication of an element and a coset . ) both the mizar and ` miz3 ` formalizations were completely straightforward .",
    "the part of the final formalization that corresponds to the first four lines of the formal proof sketch became :     + ` now  [ 22 ] ` + `  let  a  be  a ;  assume  a  in  g  [ 23 ] ; ` + `  let  b  be  a ;  assume  b  in  g  [ 24 ] ; ` + `  i(a)**b  in  g  [ 25 ]  by  2,23,24 ; ` + `  assume  i(a)**b  in  h  [ 26 ] ; ` + `  b***h  =  e**b***h  by  2,24 ; ` + `  .=  a**i(a)**b***h  by  -,2,23 ; ` + `  .=  a**(i(a)**b)***h  by  -,2,23,24 ; ` + `  .=",
    "a***(i(a)**b***h )  by  -,9,23,25 ; ` + `  thus  .=  a***h  by  -,17,26 ; ` + ` end ; `    we obtained ` miz3 ` versions of john harrison s proof in two different ways .",
    "we automatically generated this using the technology from section  [ automatic ] , but we also wrote one manually by just running the proof step by step , ` understanding ' what was going on , and then rendering that in ` miz3 ` syntax .",
    "the first , although a correct declarative proof , was disappointingly large , because there is a lot of equality reasoning in the proof and the converter does not optimize that proof pattern yet . writing the second",
    "again was completely straightforward .",
    "the line counts of the various formalizations that we got were :    lr traditional hol light by john harrison & * 214 * lines + mizar formal proof sketch & 25 lines + mizar & 153 lines + ` miz3 ` formal proof sketch & 23 lines + ` miz3 ` & * 183 * lines + ` miz3 ` ( converted from john harrison s proof ) & 1,317 lines + ` miz3 ` ( manually written following john harrison s proof ) & * 198 * lines +    [ proofcounts ]    it is clear that the two hand - written ` miz3 ` formalizations are of a similar size to the hol light and mizar formalizations , which shows that using ` miz3 ` did not lead to much larger proof texts .",
    "the synthesis between proof styles that we propose in this paper and its accompanying proof language is very general .",
    "therefore a natural question is why we did not make the ` miz3 ` framework _ generic _ , like for example the proof general interface @xcite . that way our work would be useful for users of systems like isabelle , coq and pvs .",
    "the reason we did not do this is that to get a usable framework we had to do various things that tie deep into the innards of the system .",
    "our current implementation really works on the level of the data structures inside the prover .",
    "and there we do things like timing out tactics , caching justifications , and interpreting strings as ocaml expressions .    to make a version of our system that is generic , we would need to work on a much more syntactic level .",
    "however , in that case it probably would not be so easy to do caching of justifications in a sound way .",
    "we still think this might be possible , but it would be very different from the architecture that we use now .      since we have not changed the hol light kernel , ` miz3 ` is as reliable as the standard version of hol light .",
    "if ` miz3 ` gives an error message , then _ that _ might be wrong , but if a proof is _ accepted _ , then we know that the kernel of the system has fully checked the proof object , and therefore that possible ` miz3 ` bugs did not matter ( this is called the de bruijn criterion @xcite ) .",
    "this holds even although ` miz3 ` consists of complicated code , and even although the system goes outside the basic ocaml programming model by using a system call to time out tactics and by invoking the ocaml interpreter on pieces of the proof text .",
    "when a lemma has a completed ` miz3 ` proof with no errors left , the proved ` thm ` will ` appear ' in the session for further use .",
    "for example , once we check a correct proof for the example lemma in section  [ example ] , we see magically appear in the hol light session :     + ` #  val  (  arithmetic_sum  )  :  thm  = ` + `  |-  ! n.  nsum  ( 1 .. n )  ( i.  i )  =  ( n  ( n  +  1 ) )  div  2 `    from then on we can refer to the variable ` arithmetic_sum ` .",
    "the interface generally suppresses all printing when it is doing a check ( we do not want a check from ` vi ` to disturb the output of our hol light session , where we might be doing other things ) , only when a proof is fully correct the theorem is printed .    to make it possible to get a ` thm ` out of a ` miz3 ` proof , the justification cache has not only have to hold the information that a justification was correct , but also a ` thm ` that can be used to redo that justification in a very fast way .",
    "the ` miz3 ` interface is working very well , and is competitive with the traditional way of using hol light .",
    "still , there are various ways in which it can be improved :    @xmath0    the default prover for ` by ` justifications is not completely satisfactory .",
    "this is orthogonal to the design of the system , but a better justifier will make the system easier to use .",
    "one would like the justifier to have the following properties :    @xmath5    any statement that can be proved in hol light should be provable in ` miz3 ` without explicit tactics .",
    "this does not mean that the ` by ` justifier should be able to prove it all by itself ( not even given infinite time and memory ) , but that it should be possible to break the proof in sufficiently small steps that ` by ` then can prove each _ step _ without further procedural help .",
    "basic hol light tactics like ` rewrite_tac ` , ` match_mp_tac ` , ` arith_100tac ` and ` meson_tac ` should not have to be given explicitly . if the tactic in a justification is one of these , and it runs in the justification in a reasonably short time , then the default tactic should be able to do the proof too .",
    "experimenting with goal states that correspond to steps in a ` miz3 ` proof could be more ergonomic .",
    "these goal states either can correspond to a ` thesis ` at a specific place in the proof , or to a ` by ` justification .",
    "one can experiment already using the ` goal_tac ` tactic ( a custom ` miz3 ` tactic that sets the current goal of the hol light session to the goalstate it is given as input ) but this is a bit cumbersome . at the moment",
    "isabelle / isar is in this respect much more ergonomic than our system .",
    "currently , when the system flags an error for a certain place in the proof this gives the user a bit of a helpless feeling ( the same holds for the mizar system ) .",
    "if the user understands the problem , then all is fine , but if the user does _ not _ understand the error then there should be something that can be done to investigate more easily than is possible now .    we might try going beyond the standard mizar proof idiom .",
    "for instance , it would be trivial ( although not terribly useful ) to follow the suggestion from various people to have an _ it now is sufficient to prove this _ proof step .",
    "such a step sets the ` thesis ` and its justification derives the old ` thesis ` from that statement .",
    "it is called `` suffices ` ` to ` ` show ` ' in @xcite and `` suffices ` ' in @xcite .",
    "more interestingly there could be a variant of the ` cases ` construct where the cases are the subgoals produced by a tactic .",
    "that way induction proofs could be more like traditional mathematical proofs , because then the ` induct_tac ` tactic would be _ before _ the inductive cases .",
    "it would be interesting to have a more intelligent folding editor on top of our interface .",
    "it could color the relevant parts of the proof to clearly show the goal that corresponds to an unjustified step , and it could intelligently fold and unfold subproofs",
    ".    it would be useful to make the communication architecture more flexible . that way we might have verification",
    "not be restricted to one contiguous block , the system could report errors more precisely , and several instances of the system could be run on one computer at the same time .      a good proof interface for formal mathematics should satisfy the requirement that _ easy things should be easy , and hard things should be possible _ @xcite .",
    "the synthesis proposed in this paper combines the ease of the declarative proof style with the power of the procedural proof style .",
    "we hope that our approach will turn out to be a piece in the puzzle of making interactive theorem provers useful for and attractive to the working mathematician .",
    "thanks to henk barendregt for his vision of a _ luxury mathmode _ for interactive theorem provers , which led directly to the approach from this paper . thanks to andrea asperti ,",
    "georges gonthier , john harrison , robbert krebbers , james mckinna , randy pollack , dan synek , laurent thry and makarius wenzel for many helpful discussions about this paper .",
    "thanks to anonymous referees for helpful feedback on various versions of this paper .",
    "andrea asperti , claudio  sacerdoti coen , enrico tassi , and stefano zacchiroli . .",
    "in _ proceedings of the 2006 international conference on types for proofs and programs _ , types06 , pages 1832 , berlin , heidelberg , 2007 .",
    "springer - verlag .",
    "andrea asperti and bernd wegner . .",
    "in _ proc . of the 9th intl .",
    "conference on electronic resources and the social role of libraries in the future _ , volume  1 , autonomous republic of crimea , ukraine , 2002 .",
    "b.  buchberger , t.  jebelean , f.  kriftner , m.  marin , and d.  vasaru . .",
    "in w.  kuechlin , editor , _ proceedings of issac97 ( international symposium on symbolic and algebraic computation ) _ , maui , hawaii , 1997 .",
    "acm press .",
    "robert  l. constable , stuart  f. allen , h.m .",
    "bromley , w.r .",
    "cleaveland , j.f .",
    "cremer , r.w .",
    "harper , douglas  j. howe , t.b .",
    "knoblock , n.p .",
    "mendler , p.  panangaden , james  t. sasaki , and scott  f. smith . .",
    "prentice - hall , nj , 1986 .",
    "john harrison . .",
    "in eduardo gimnez and christine paulin - mhring , editors , _",
    "types for proofs and programs : international workshop types96 _ , volume 1512 of _ lncs _ , pages 154172 , aussois , france , 1996 .",
    "springer - verlag .",
    "sam owre , john  m. rushby , and natarajan shankar . .",
    "in d.  kapur , editor , _ 11th international conference on automated deduction ( cade ) _ , volume 607 of _ lnai _ , pages 748752 , berlin , heidelberg , new york , 1992 ."
  ],
  "abstract_text": [
    "<S> we propose a synthesis of the two proof styles of interactive theorem proving : the procedural style ( where proofs are scripts of commands , like in coq ) and the declarative style ( where proofs are texts in a controlled natural language , like in isabelle / isar ) . our approach combines the advantages of the declarative style  the possibility to write formal proofs like normal mathematical text  and the procedural style  strong automation and help with shaping the proofs , including determining the statements of intermediate steps .    </S>",
    "<S> our approach is new , and differs significantly from the ways in which the procedural and declarative proof styles have been combined before in the isabelle , ssreflect and matita systems . </S>",
    "<S> our approach is generic and can be implemented on top of any procedural interactive theorem prover , regardless of its architecture and logical foundations .    to show the viability of our proposed approach , we fully implemented it as a proof interface called ` miz3 ` , on top of the hol light interactive theorem prover . </S>",
    "<S> the declarative language that this interface uses is a slight variant of the language of the mizar system , and can be used for any interactive theorem prover regardless of its logical foundations . </S>",
    "<S> the ` miz3 ` interface allows easy access to the full set of tactics and formal libraries of hol light , and as such has ` industrial strength ' .    </S>",
    "<S> our approach gives a way to automatically convert any procedural proof to a declarative counterpart , where the converted proof is similar in size to the original . </S>",
    "<S> as all declarative systems have essentially the same proof language , this gives a straightforward way to port proofs between interactive theorem provers . </S>"
  ]
}