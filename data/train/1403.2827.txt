{
  "article_text": [
    "any quantum computation ( qc ) is implemented either implicitly or explicitly through three fundamental steps : a quantum state is initially prepared ; then , the prepared state is manipulated by using a set of unitary transformations often referred to as a `` quantum algorithm . ''",
    "finally , a measurement is performed on the output state to extract the useful information of the solution .",
    "thus , the preparation @xmath0 , the operation @xmath1 , and the measurement @xmath2 are fundamental elements of the standard qc @xcite . with this fundamental @xmath0-@xmath1-@xmath2 building block ,",
    "one of the primary objectives in qc is to achieve the target state of the solution .",
    "however , sometimes it is very difficult or even impractical due to the lack of knowledge of the operation @xmath1 @xcite . in particular , finding the unitary transformations for any desired @xmath1 in qc is challenging when only limited information is available , e.g. , in designing a quantum algorithm @xcite .",
    "an operation @xmath1 can generally be described by the complete - positive trace - preserving map : @xmath3 , where @xmath4 is an initial state , and @xmath5 is known as the kraus operator , satisfying @xmath6 .",
    "such a general process of the quantum operation @xmath1 can also be described with an overall unitary @xmath7 , such as @xmath8 in a quantum system composed of a main and an extra ( @xmath9 ) system , followed by a partial measurement ( denoted as the partial trace ` @xmath10 ' ) projecting the coupled output state @xmath11 on a state @xmath12 @xcite . here , @xmath13 is a state of the extra system .",
    "thus , in a general sense , we can translate the problem into the task of finding the unitary transformation @xmath7 for any desired qc even in the case of the non - unitary process . here , the extra system @xmath9 and the partial measurement performed on the sub - system can arbitrarily be designed .    our basic idea to approach the problem , i.e. , finding the ( unknown ) unitary transformation @xmath7 , is to use the genetic algorithm ( ga ) .",
    "the ga is one of the global optimization methods inspired by the biological evolution , i.e. , breeding a population in which more _ fit _ individuals will have higher chances to produce their offsprings by crossing over the genetic information @xcite .",
    "ga methods have long been used in various fields of science and engineering @xcite due to their novel ability to find the optimal ( unknown ) solutions with limited a priori information .",
    "thus , ga methods ( or variant methods ) have attracted attention lately in various applications to the quantum information and computation @xcite , e.g. , in laser pulse shaping @xcite , optimizing the measure of entanglement @xcite , unitary decomposition @xcite , dynamic decoupling @xcite , etc . @xcite .    in the present paper",
    ", we propose a ga - based method to find the unitary transformations for any desired qc .",
    "we first assume that an overall qc process is decomposed into a finite series of internal unitary transformations .",
    "the only available information is a set @xmath14 of input - target pairs .",
    "then , our primary problem is to find the appropriate internal unitary transformations for the given @xmath14 .",
    "for the problem , we formulate a simple ga on a general design of qc . here , we introduce the notion of the `` genetic parameter vector , '' which is allowed to evolve during the ga process .",
    "an initial population of the genetic parameter vectors is supposed to evolve to the corresponding unitary transformations to the desired qc .",
    "we apply our method to find the optimal internal unitary transformations and to generalize the corresponding quantum algorithm for the one - bit oracle decision problem , or the often - called deutsch problem @xcite . by numerical simulations",
    ", we can faithfully find the appropriate unitary transformations to solve the problem .",
    "we analyze the quantum algorithms identified by the found unitary transformations and show that they are not exactly equal to the original deutsch s algorithm , but correspond to its variant models .",
    "we first need to specify the problem more precisely . as described in the previous section , the preparation @xmath0 , the operation @xmath1 , and the measurement @xmath2 are basic elements of the standard qc . the operation @xmath1 can generally be described by an overall unitary @xmath7 with an extra system and an arbitrarily chosen partial measurement . in practical qc , however , a finite number of internal unitary transformations are usually designed to implement @xmath7 of the desired qc , taking into account the proper minimum cost of the realization @xcite .",
    "thus , we assume that @xmath7 is decomposed into a finite @xmath15 series of internal unitary transformations @xmath16 ( @xmath17 ) whose exact forms are also _ yet to be known_. here , we assume further that the only available information is a set @xmath14 of input - target pairs . the input @xmath18 is _ classical information _ , because we  a _ classical _ supervisor or a _ classical _ algorithm designer  must perceive it .",
    "the information @xmath18 is often provided as a functional form and is usually encoded into @xmath0 or @xmath1 in qc whereas the target is a desired output _ quantum state _",
    "@xmath19 for the given @xmath18 . in the circumstance ,",
    "the main problem dealt with here is to find a set of appropriate internal unitary transformations @xmath20 for the given @xmath14 .    here",
    ", we briefly note that any essential part of using the information @xmath18 is always involved in qc . in a typical scheme of qc , the input @xmath18 is usually encoded in an ancillary system or a relative phase of the internally evolving quantum state .",
    "such an encoding for the reference of @xmath18 can successfully be performed by using a specific unitary operation , the so - called quantum oracle .",
    "we clarify that such a non - trivial operation would be involved in each separated unitary transformation @xmath16 ( @xmath17 ) or in one of them .",
    "-@xmath1-@xmath2 ) assisted by a feedback system ( @xmath21).,scaledwidth=50.0% ]    we then introduce another element , called the feedback controller @xmath21 , which contains an optimizing algorithm and a finite size of the classical memory .",
    "the basic architecture of our method is , thus , borrowed from a general model of qc assisted by a feedback system ( see fig .  [",
    "fig : scheme ] ) . here , we note that @xmath21 is _ classical _ in the sense that it mainly deals with classical information , e.g. , control parameters of @xmath1 and measurement outcomes from @xmath2 .",
    "this information is communicated through the classical channel .",
    "in such a basic design , the optimizing algorithm in @xmath21 is particularly important because it is directly connected with the efficiency , accuracy , and other performances of the method . in this work ,",
    "we employ the genetic algorithm ( ga ) , which is one of the widely - used global optimization methods @xcite .",
    "typically , the ga runs as follows : ( @xmath22 ) one prepares a population as the set of candidate solutions , ( @xmath23 ) selects several candidates to generate their offsprings , and then ( @xmath24 ) reconstructs a new population with newly - generated offsprings . using fitness criteria",
    ", the candidates can breed their offsprings .",
    "the above processes ( @xmath22)-(@xmath24 ) are continued to meet a certain ` termination condition . ' in formulating a ga , the most fundamental and important issue is to represent the genetic information of the candidate solutions @xcite .",
    "the question of how we define a certain condition to terminate the process is also one of the important issues and that problem remains open @xcite . with these issues , we now formulate a simple ga .    before starting , we briefly note here that our formulation refers to the standard ( or simple ) ga model initially introduced and studied by john holland @xcite because the main purpose of this work is to provide a basic framework rather than to develop it .",
    "most existing theories and applications were also build upon this standard ga model , although some remarkable theoretical advances were primarily built on its variant models @xcite .",
    "_ population preparation .",
    "_  first , we should prepare a population as the set of candidate solutions . from now on ,",
    "we call a single item of the candidate solution an `` individual '' ( just as in a standard ga model @xcite ) . in our case , @xmath7 corresponds to an individual . noting that @xmath7 consists of the internal unitary transformations @xmath16 ( @xmath17 ) , we represent a population as the number @xmath25 of unitary sets , @xmath26 which is initially prepared at random .",
    "we parametrize the internal unitary transformation @xmath16 in @xmath27-dimensional hilbert space as @xmath28 where @xmath29 is a real vector in @xmath30-dimensional real vector space @xmath31 , and @xmath32 is a vector whose components are su(@xmath27 ) group generators @xcite .",
    "note that , in our method , a component @xmath33 $ ] ( @xmath34 ) would be represented by a genetic form in order to evolve the internal unitary transformations ( as detailed below ) .",
    "our method is , in principle , applicable to a real experiment , as @xmath35 s can be directly matched to the control parameters , e.g. , beam - splitter and phase - shifter alignments in linear optical system @xcite or radio - frequency ( rf ) pulse sequences in nuclear magnetic resonance ( nmr ) system @xcite .",
    "is characterized as left or right branches ( genes ) on a binary tree .",
    "for example , `` @xmath36 '' corresponds to `` left(0)-left(0)-right(1)-left(0)-@xmath37 '' ( denoted by a red line ) .",
    "note that any flow finally arrives at a certain value of @xmath35 discretized to @xmath38 points with spacing @xmath39 in @xmath40 [ see the mapping eq .",
    "( [ eq : n_param])].,scaledwidth=50.0% ]    _ genetic representation . _  we give here the genetic representation of the real vector @xmath41 .",
    "the usual way is to take a finite , say @xmath42 , length of the binary strings ( @xmath43 s and @xmath44 s ) . following this ,",
    "we define @xmath45 ( `` chromosome '' ) as a binary @xmath42 sequence : @xmath46 , where @xmath47 ( `` gene '' ) , and @xmath42 is a _",
    "depth constant_. note that the accuracy of the found unitary transformations depends on the depth constant @xmath42 because the number of digits to represent a solution parameter increases with increasing @xmath42 .",
    "however , we also note that the run - time of the ga process becomes longer for larger @xmath42 , because the possible representation of the solutions , i.e. , the size of the search space , also increases .    for the sake of the convenience ,",
    "we visualize a chromosome @xmath45 in terms of the left(`@xmath43 ' ) or right(`@xmath44 ' ) branches on a binary tree , as depicted in fig .",
    "[ fig : g_path ] . here",
    ", any flow is seen to finally arrive at a certain value of @xmath35 discretized to @xmath38 points with spacing @xmath39 from @xmath48 to @xmath49 . by observing this",
    ", we can easily derive the mapping between @xmath45 and @xmath35 as @xmath50 where ` @xmath51 ' denotes the modulo-@xmath52 addition .",
    "we , thus , consider a real vector @xmath53 , whose components are given as the chromosomes @xmath45 .",
    "we call this vector @xmath54 the `` genetic parameter vector '' ( which is an approximation of the real vector @xmath55 ) . as we can make a one - to - one correspondence between the genetic parameter vectors @xmath56 and the internal unitary transformations @xmath16 for all @xmath57 , the population as in eq .",
    "( [ eq : pop_u ] ) can be represented in terms of the number @xmath25 of the genetic parameter vector sets as @xmath58    _ selection .",
    "_  selection is a step in which the particular individuals are chosen to breed .",
    "only the selected individuals have the opportunity to transfer their genetic information .",
    "the selection is done based on the `` fitness '' which quantifies how _ fit _ the individual is for the given circumstance . in our case ,",
    "the fitness @xmath59 of the @xmath60 individual is defined as the mean fidelity , @xmath61 where @xmath62 corresponds to the @xmath60 individual , @xmath63 is the initial state generated in @xmath0 , and @xmath19 is the state of the target for the given @xmath18 . here",
    ", the summation @xmath64 is done for a finite @xmath65 of the input - target pairs @xmath66 in @xmath14 ( i.e. , @xmath67 ) .",
    "the maximum value of the fitness , i.e. , @xmath68 , implies that @xmath62 is the perfect for the desired qc while it is incomplete when @xmath69 .",
    "therefore , the strategy for the selection in ga is that the individuals corresponding to better solutions are more likely to be selected ; the high - fitness individuals have higher probability to be selected . in our method , the probability @xmath70 that an @xmath60 individual is chosen is @xmath71 where we assume that the individuals are sorted by @xmath72 and that @xmath73 . here , @xmath74 .    .",
    "we first chose two ( old ) genes @xmath75 and @xmath76 by using the selection probability in eq .",
    "( [ eq : sel_p ] ) , where @xmath77 $ ] ( @xmath78 , and @xmath79 ) . any segments of the binary strings ( `` @xmath80 '' in @xmath75 and `` @xmath81 '' in @xmath76 ) are then exchanged to generate new ones @xmath82 and @xmath83 . by mutation ,",
    "a binary number ` @xmath44 ' was flipped to ` @xmath43 ' in the newly - generated @xmath83.,scaledwidth=60.0% ]    _ crossover and mutation . _",
    " crossover and mutation are known to be the main genetic operations to evolve the population . by crossover , new individuals can be generated . in most case , the segments of the parents genes are transferred to their offsprings .",
    "one typical method is to exchange some parts of the binary strings . in our case ,",
    "a genetic parameter vector is newly generated by merging the genes in the two selected vectors , as illustrated in fig .",
    "[ fig : crossover ] .",
    "thus , we can make progress in the population by renewing all @xmath25 sets of the genetic parameter vectors .    in mutation ,",
    "some genetic information is self - generated or transformed without the crossover .",
    "it can be applied by changing an arbitrary bit string from the original one .",
    "the purpose of mutation is usually to improve the diversity or to extend the solution space @xcite .",
    "we can realize such an operation by flipping a string in a gene @xmath84 ( see also fig .  [",
    "fig : crossover ] ) .    _ termination condition .",
    "_  the ga process would be terminated when a relevant condition is met .",
    "this condition is called the termination condition .",
    "the most easily and frequently used termination condition is to fix the maximum number of generations , taking into account the computational resources , e.g. , the memory size or the scale of the problem .",
    "another way involves the convergence of individuals ; namely , if the improvement in the fitnesses becomes smaller than a threshold value , say @xmath85 , then the process is terminated due to the lack of improvements .",
    "we consider the latter type here .    to construct the termination condition",
    ", we consider the `` fitness fluctuation '' as the standard deviation : @xmath86 where @xmath87 is the mean fitness over the population .",
    "then , we define the termination condition as follows : first , we set a constant @xmath85 to be very small .",
    "we evaluate @xmath88 and compare it with the predetermined value @xmath85 at every generation step of the ga process . in those cases where @xmath89 is larger than @xmath85 ,",
    "the process goes on ; however , if we meet @xmath90 , the process is terminated .",
    "we indicate here that we should take into account the rounding - off error due to the finite @xmath42",
    ". the rounding - off error would approximately be proportional to @xmath91 , where @xmath39 ( see fig .",
    "[ fig : g_path ] ) .",
    "note that , if the dimension @xmath27 of hilbert space is not too large and @xmath7 consists of a reasonable number @xmath15 of internal unitary transformations , the rounding - off error can be made vanishingly small by choosing a sufficiently large @xmath42 .",
    "we apply our method to a realistic problem known as the one - bit oracle decision problem , or often called the `` deutsch '' problem .",
    "this problem is to decide if an arbitrary one - bit boolean function @xmath92 is constant , i.e. , @xmath93 , or balanced , i.e. , @xmath94 .",
    "classically , the function @xmath18 should be evaluated twice for @xmath43 and @xmath44 to solve the problem . on the other hand ,",
    "qc enables us to identify the function @xmath18 by using only one evaluation @xcite .",
    "the quantum circuit for such an algorithm is presented in fig .",
    "@xmath95 . in the circuit",
    ", the unitary transformation @xmath96 corresponds to the oracle operation defined by @xmath97 where @xmath98 and @xmath99 are computational bases in a qubit system .",
    "such a form of the oracle is widely used in qc @xcite .",
    "the other two unitary transformations @xmath100 and @xmath101 change the incoming states to the superposed states so that we get the final output state as @xmath102 where @xmath103 and @xmath104 are arbitrary qubit states orthogonal to each other , i.e. , @xmath105 .",
    "we then identify the given function @xmath18 by performing the ( von - neumann ) measurement @xmath106 . here ,",
    "if @xmath103 is measured , then @xmath18 is a ` constant ' function ; otherwise , @xmath18 is a ` balanced ' function .     is the unitary of the oracle operation .",
    "the other two , @xmath100 and @xmath101 , allow us to generate the desired output @xmath107 as in eq .",
    "( [ eq : out_st ] ) by only one evaluation of @xmath18.,scaledwidth=50.0% ]    we can easily understand how this algorithm works .",
    "first , @xmath100 distributes the initially prepared state @xmath108 to an arbitrarily superposition of @xmath98 and @xmath99 ; then , @xmath96 acts _ only once _ on the distributed state .",
    "finally , @xmath101 leads the incoming state to the corresponding output @xmath107 for decision .",
    "the key feature of the algorithm is the `` quantum parallelism , '' by which all the values of @xmath43 and @xmath44 are _ simultaneously _ evaluated in the form of their superposition .",
    "therefore , finding appropriate unitary transformations @xmath100 and @xmath101 to maximize the quantum parallelism is important . in the original deutsch s algorithm , @xmath100 and @xmath101",
    "are given as the hadamard operation @xmath109 , which transforms @xmath98 and @xmath99 into an equally superposed state , such as @xmath110 and @xmath111 , and the final measurement is @xmath112 .",
    "here , we note that @xmath96 is also very important , as it is employed to encode the input @xmath18 in our method .    thus , we apply our method to find other explicit forms of @xmath100 and @xmath101 and to generalize the deutsch s algorithm .",
    "first , let us consider an input - target set @xmath113 where the input @xmath114 ( @xmath115 ) is one of the four possible boolean functions , and ` @xmath116 ' and ` @xmath117 ' stand for the constant and the balanced function , respectively .",
    "we then consider a decomposition of @xmath7 such that @xmath118 where @xmath96 is a part of encoding the given function @xmath119 , and the other two @xmath100 and @xmath101 are controllable single - qubit unitary transformations . by ` controllable , ' we mean here that @xmath120 can be controlled by adjusting @xmath121 ( @xmath122 ) .",
    "the preparation @xmath0 generates @xmath63 , and a measurement @xmath2 is chosen for the decision of @xmath18 .",
    "the feedback @xmath21 is responsible for the ga process . from eq .",
    "( [ eq : fidel ] ) , we represent the fitness @xmath59 of any @xmath60 individual @xmath62 as @xmath123 where @xmath124 ( @xmath125 ) .     and ( right ) the averaged mean error @xmath126 .",
    "we consider three population sizes : @xmath127 , @xmath128 , and @xmath129 .",
    "each point is obtained by averaging over @xmath130 simulations , and the error bar is the standard deviation .",
    "it is directly seen that @xmath131 is increased or @xmath132 is decreased , as the generation proceeds.,title=\"fig:\",scaledwidth=35.0% ]    and ( right ) the averaged mean error @xmath126 .",
    "we consider three population sizes : @xmath127 , @xmath128 , and @xmath129 .",
    "each point is obtained by averaging over @xmath130 simulations , and the error bar is the standard deviation . it is directly seen that @xmath131 is increased or @xmath132 is decreased , as the generation proceeds.,title=\"fig:\",scaledwidth=35.0% ]    based on the above settings , the numerical simulations are carried out . in the simulations ,",
    "we prepare @xmath25 individuals as a population .",
    "thus , we have @xmath25 sets of @xmath133-dimensional genetic parameter vectors as @xmath134 here , we consider three cases : @xmath127 , @xmath128 , and @xmath129 .",
    "we let @xmath135 to ignore the rounding - off error . for the sake of simplicity ,",
    "we take @xmath136 , and the mutation is not considered . in fig .",
    "@xmath137 , we give the mean fitnesses @xmath131 averaged over @xmath130 simulations .",
    "the error bars are the standard deviations . as directly seen in fig .",
    "[ grp : ga_p ] , @xmath131 is increased , or equivalently , @xmath138 is decreased . in particular , we can see that @xmath139 ( or @xmath140 ) fora large @xmath25 .",
    "we note here that , for a given problem size @xmath141 , a large number @xmath25 of populations is usually needed in evolutionary optimization .",
    "for example , choosing @xmath142 is appropriate ( see ref .",
    "@xcite ) . in our case ,",
    "the problem size @xmath141 is given as @xmath143 , which is the total number of control parameters in @xmath144 ( @xmath122 ) .",
    "however , we can still achieve a high accuracy even for a relatively small population size .",
    "actually , when @xmath127 , @xmath131 is as high as @xmath145 at the @xmath146 generation step .",
    "we here find that the identified @xmath7 will not be exactly equal to the original deutsch s algorithm , but will correspond to one variant model of it , with @xmath147 . to see this , it is convenient to rewrite the single - qubit unitary @xmath16 ( @xmath122 ) in the following ( geometric ) form : @xmath148 where @xmath149 is the vector of pauli operators , @xmath150 is given in terms of the euclidean norm of @xmath121 , i.e. @xmath151 , and @xmath152 is the normalized vector .",
    "any pure quantum state is characterized as a point on the surface of a unit sphere , called a `` bloch sphere , '' and @xmath16 rotates a pure state , a point on the bloch sphere , by the angle @xmath153 around the axis @xmath154 @xcite .",
    "for example , in the case of the original deutsch s algorithm , the hadamard operation @xmath109 ( corresponding to @xmath100 and @xmath101 ) is a @xmath49-rotation about the axis @xmath155 .    on the basis of the above description",
    ", we can generally describe how the identified algorithm @xmath156 works : first , @xmath100 rotates the initial state @xmath63 to @xmath157 where @xmath158 is the phase factor .",
    "then , the oracle @xmath96 flips the phase @xmath158 to @xmath159 if @xmath160 and leaves it unchanged if @xmath161 .",
    "the last unitary transformation @xmath101 rotates the state to the corresponding output ( e.g. , @xmath162 and @xmath163 in the case of the original deutsch s algorithm ) . here",
    ", we provide the necessary condition for the deutsch s algorithm : _ the state of eq .",
    "( [ eq : necessary_c ] ) should be on the equator of the bloch sphere _ , or equivalently , _",
    "@xmath164 should be equal to @xmath165 _",
    "( see appendix  [ appendix : variants ] ) .",
    "[ grp : variants ] , we plot @xmath130 data points ( @xmath164 , @xmath158 ) characterized by the found @xmath166 in polar coordinates . here",
    ", we have @xmath167 and @xmath168 , where @xmath169 and @xmath170 denote the average and the standard deviation , respectively .     and @xmath158 in eq .",
    "( [ eq : necessary_c ] ) in polar coordinates ( @xmath164 , @xmath158 ) .",
    "each data point is made by using the found @xmath171 and averaged over @xmath130 simulation results .",
    "as analyzed , the values of @xmath164 are located on @xmath172 ( green circular line ) whereas @xmath158 has an arbitrary value ; actually , we have @xmath167 and @xmath168 , where @xmath169 and @xmath170 are the average and the standard deviation , respectively.,scaledwidth=65.0% ]    we perform numerical simulations for further analysis . in particular",
    ", we investigate the relation between the required steps @xmath173 of the generations to complete the ga process and the accuracy of the identified algorithm @xmath174 after the completion .",
    "to do this , we evaluate the optimal mean errors @xmath175 of the identified @xmath174 and find @xmath173 in each simulation .",
    "the simulation is performed @xmath130 times for each case : @xmath176 , @xmath177 , @xmath178 , and @xmath179 .",
    "we let @xmath135 , as above . in fig .",
    "[ grp : err_nc ] , we give graphs of @xmath173 versus @xmath180 .",
    "note that the ga process is terminated within @xmath181 for all cases of @xmath25 .",
    "we assume here an _ exponential _ dependence of the overall run - time ( @xmath173 in our case ) on the required accuracy , which is typically found in evolutionary optimization ( see refs .  @xcite and @xcite , or references therein ) .",
    "with this assumption , we find that the data are well fitted to a function @xmath182 . the detailed fitting parameters , @xmath164 , @xmath183 , and @xmath184 , are given in table  [ tab : nc ] .",
    "note that the estimated parameters for each @xmath25 are all consistent ( within their error ranges ) .     versus @xmath185 graphs are given for ( a ) @xmath176 , ( b ) @xmath177 , ( c ) @xmath178 , and ( d ) @xmath179 .",
    "the data are well fitted to @xmath182 .",
    "fitting parameters @xmath164 , @xmath183 , and @xmath184 are listed in table  [ tab : nc].,title=\"fig:\",scaledwidth=35.0% ]   versus @xmath185 graphs are given for ( a ) @xmath176 , ( b ) @xmath177 , ( c ) @xmath178 , and ( d ) @xmath179 .",
    "the data are well fitted to @xmath182 .",
    "fitting parameters @xmath164 , @xmath183 , and @xmath184 are listed in table  [ tab : nc].,title=\"fig:\",scaledwidth=35.0% ] +   versus @xmath185 graphs are given for ( a ) @xmath176 , ( b ) @xmath177 , ( c ) @xmath178 , and ( d ) @xmath179 .",
    "the data are well fitted to @xmath182 .",
    "fitting parameters @xmath164 , @xmath183 , and @xmath184 are listed in table  [ tab : nc].,title=\"fig:\",scaledwidth=35.0% ]   versus @xmath185 graphs are given for ( a ) @xmath176 , ( b ) @xmath177 , ( c ) @xmath178 , and ( d ) @xmath179 .",
    "the data are well fitted to @xmath182 .",
    "fitting parameters @xmath164 , @xmath183 , and @xmath184 are listed in table  [ tab : nc].,title=\"fig:\",scaledwidth=35.0% ]    cccc @xmath25 & @xmath164 & @xmath183 & @xmath184 + @xmath129 & @xmath186 & @xmath187 & @xmath188 + @xmath177 & @xmath189 & @xmath190 & @xmath191 + @xmath178 & @xmath192 & @xmath193 & @xmath194 + @xmath179 & @xmath195 & @xmath196 & @xmath197 +",
    "we have proposed a naive method based on the genetic algorithm ( ga ) to find the unitary transformations for any desired quantum computation ( qc ) . to specify the problem",
    ", we assumed that an overall unitary for qc could be decomposed to a finite series of internal unitary transformations . here",
    ", we also assumed that the only available information would be a set of input - target pairs . with these assumptions ,",
    "the problem was to find the appropriate internal unitary transformations for the given input - target set .",
    "thus , we formulated the simple ga by introducing the notion of the genetic parameter vector .",
    "the genetic parameter vectors of the internal unitary transformations were allowed to evolve in the ga process .",
    "we argued that the presented method can , in principle , be applied to a real experiment with the current technology .",
    "we then applied our method to find the optimal unitary transformations and to generalize the corresponding quantum algorithm for a realistic qc problem , known as the one - bit oracle decision problem , or the often - called deutsch problem . by numerical simulations",
    ", we showed that the appropriate unitary transformations to solve the problem can faithfully be found in our method .",
    "we analyzed the quantum algorithms identified by the found unitary transformations and generalized the variant models of the original deutsch s algorithm .",
    "we also investigated the relation between the required steps @xmath173 of the generations to complete the ga process ( i.e. , the overall run - time ) and the mean error @xmath198 of the found unitaries ( i.e. , the accuracy ) . assuming the typical tendency of the evolutionary methods",
    ", we found that @xmath199 , with @xmath164 and @xmath183 having finite values .",
    "we expect that our method will be developed further for designing new quantum algorithms or for suppressing the various noises in quantum information processing .",
    "we also hope that our method will provide some intuitions or directions in hybridizing machine learning and quantum information science .",
    "we thank prof .",
    "jinhyoung lee and prof .",
    "hyunseok jeong .",
    "jb thanks changhyoup lee and chang - woo lee for helpful discussions .",
    "we acknowledge the financial support of the basic science research program through the national research foundation of korea ( nrf ) funded by the ministry of science , ict & future planning ( no .",
    "2010 - 0018295 and no .",
    "2010 - 0015059 ) .",
    "in this appendix , we investigate the necessary condition for the algorithm identified by the found @xmath100 and @xmath96 to be a variant model of the original deutsch s algorithm .",
    "we start with an arbitrary input @xmath63 .",
    "first , we let @xmath200 where @xmath98 and @xmath99 are defined as the qubit state at the north and the south poles of the bloch sphere , respectively . the coefficients @xmath164 and @xmath183 are the complex numbers , satisfying @xmath201 . applying the identified algorithm @xmath202 to the input @xmath63",
    ", we obtain the output states as @xmath203 with the dependence on the given boolean function @xmath114 ( @xmath115 ) .",
    "note that , in order to discriminate the given function @xmath114 by a fixed ( von neumann ) measurement , the above two output states should be orthogonal to each other , i.e. , @xmath204 from eq .",
    "( [ eq : condi_dis ] ) , we directly have @xmath205 or equivalently , @xmath206 where @xmath158 is an arbitrary ( relative ) phase factor . from this proof , we can infer that many generalized versions of the deutsch s algorithm with numerous sets of @xmath150 and @xmath154 ( @xmath122 ) can give the desired output @xmath11 , as in eq .",
    "( [ eq : out_st ] ) .",
    "r. biswas , l. blackburn , j. cao , r. essick , k. a. hodge , e. katsavounidis , k. kim , y - m .",
    "kim , e - o .",
    "le bigot , c - h .",
    "lee , j. j. oh , s. h. oh , e. j. son , y. tao , r. vaulin , and x. wang , phys .",
    "d * 88 * , 062003 ( 2013 ) ."
  ],
  "abstract_text": [
    "<S> we propose a genetic - algorithm - based method to find the unitary transformations for any desired quantum computation . </S>",
    "<S> we formulate a simple genetic algorithm by introducing the `` genetic parameter vector '' of the unitary transformations to be found . in the genetic algorithm process </S>",
    "<S> , all components of the genetic parameter vectors are supposed to evolve to the solution parameters of the unitary transformations . </S>",
    "<S> we apply our method to find the optimal unitary transformations and to generalize the corresponding quantum algorithms for a realistic problem , the one - bit oracle decision problem , or the often - called deutsch problem . by numerical simulations </S>",
    "<S> , we can faithfully find the appropriate unitary transformations to solve the problem by using our method . </S>",
    "<S> we analyze the quantum algorithms identified by the found unitary transformations and generalize the variant models of the original deutsch s algorithm . </S>"
  ]
}