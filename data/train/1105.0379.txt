{
  "article_text": [
    "storing digital data is a basic necessity of modern societies .",
    "the volume of data to be stored is tremendous , and is rapidly increasing .",
    "the kinds of data vary widely - from corporate and financial data repositories , archive of electronic communications to personal pictures , videos and work documents stored and shared in web 2.0 and cloud based services , and much more .",
    "distribution of such huge amount of data over multiple networked storage devices is thus the only practical and scalable solution .",
    "all across the wide gamut of networked distributed storage systems design space , eventual failure of any and all individual storage devices is a given .",
    "consequently , storing data redundantly is essential for fault tolerance .",
    "furthermore , over a period of time , due to failures or departure of storage devices from the system , the redundancy will gradually decrease - risking the loss of the stored data , unless the redundancy is recreated .",
    "the possible ways for recreating redundancy depends on , to start with , the kind of redundancy being used .",
    "data redundancy can be achieved using replication - however that entails a very large storage overhead .",
    "erasure coding based strategies in contrast can provide very good amount of redundancy for a very low storage overhead .",
    "however , when an encoded data block is lost and needs to be recreated , for traditional erasure codes , one would first need data equivalent in amount to recreate the whole object in one place ( either by storing a full copy of the data , or else by downloading adequate encoded blocks ) , even in order to recreate a single encoded block .",
    "such drawback of traditional erasure codes has in recent years given rise to a new flavor of coding research : designing erasure codes which need much less information to carry out the recreation of a lost encoded block .",
    "more precisely , consider a network of @xmath0 storage nodes , each with storage capacity @xmath1 , where an object @xmath2 of size @xmath3 has to be stored .",
    "a source possibly processes ( encodes ) the object @xmath2 , splits it into @xmath0 blocks , each of size at most @xmath1 , and stores such blocks at @xmath0 storage nodes . when a data collector wants to retrieve the object",
    ", he should be able to do so by contacting a subset of live nodes .",
    "we define @xmath4 as the minimum number of nodes that need to be contacted to retrieve the object , where the data collector may download upto @xmath5 amount of data , and possibly process ( decode ) the downloaded data . for maximal distance",
    "separable ( mds ) erasure codes , any arbitrary subset of @xmath4 nodes allow data retrievability .",
    "new nodes joining the network are assumed to perform the repair by contacting @xmath6 live nodes , from each of which they download @xmath7 amount of data .",
    "there are arguably two extreme points possible in the design - space of codes for distributed networked storage :    * ( i ) * minimize the absolute amount of data transfer @xmath8 needed to recreate the lost data from one node .",
    "network - coding inspired analysis determines the storage - bandwidth ( per repair ) trade - offs , and a new family of codes called _ regenerating codes _ ( rgc ) @xcite have been proposed , which can achieve ( some points on ) such a trade - off curve , under the assumption that @xmath9 .",
    "regenerating codes , like mds erasure codes , allow data retrievability from any arbitrary set of @xmath4 nodes .    *",
    "( ii ) * minimize the number of nodes to be contacted for repairing one node failure .",
    "recently proposed _ self - repairing codes _",
    "@xcite achieve this optimal , by allowing one repair while contacting only two nodes , i.e. @xmath10 . more specifically , self - repairing codes satisfy two cardinal properties , namely : ( a ) repairs can be performed directly through other subsets of nodes , without having to download data equivalent to that needed to reconstruct first the original object , ensuring that ( b ) a block is repaired from a fixed number of blocks , the number depending only on how many blocks are missing and independent of which specific blocks are missing . note that minimization of the number of contacted nodes for a repair is achieved when the fixed number in clause ( b ) is in fact two .",
    "homomorphic self - repairing codes ( hsrc ) were proposed in @xcite , which , besides satisfying the cardinal properties elaborated above , were shown to ( i ) have @xmath11 distinct pairs with which the data for a single missing node could be regenerated , and consequently , ( ii ) self - repair for up to @xmath11 node failures could be carried out simultaneously using two nodes for each self - repair , from the pool of the remaining @xmath12 live nodes .",
    "this paper proposes a new family of self - repairing codes ( psrc ) derived from a projective geometric construction .",
    "besides the fundamental difference in its construction , and apart from satisfying the cardinal properties of self - repairing codes , as well as , in fact the other properties satisfied by hsrc , psrc has several other salient features , as summarized next :    \\(i ) both the encoding and self - repair processes for psrc involve only xor operations , unlike hsrc encoding which involved the relatively more expensive task of evaluating a polynomial .",
    "\\(ii ) similar to regenerating codes @xcite , in psrc , each encoded block ( i.e. , data stored by a node ) comprise of several ( @xmath1 ) pieces . regeneration of the whole encoded block",
    "thus can likewise be done by regenerating the individual constituent pieces .",
    "this is in contrast to hsrc , where the encoded blocks were ` atomic ' , and hence repair of the whole encoded block had to be carried out atomically .",
    "this gives psrc some of the advantages of regenerating codes , while also naturally retaining the advantages of self - repairing codes , and provides several additional desirable properties , as elaborated next .",
    "\\(iii ) for self - repair of a specific node , if one live node is chosen arbitrarily , then there are several other nodes with which the first chosen node can be paired to regenerate the lost encoded block .",
    "this is in contrast to hsrc , where there is a unique pairing for one lost node , once one live node is chosen .",
    "\\(iv ) while the resulting code is strictly speaking not systematic in terms of what is stored at each node , if the constituent pieces stored over the nodes are considered , then systematic reconstruction of the object is possible , though this will need communication with @xmath13 specific nodes .",
    "the proposed construction as described in next section relies on the notion of spread coming from projective geometry .",
    "we thus start by providing the required background .",
    "consider the finite field @xmath14 , where @xmath15 is a power of a prime @xmath16 , and a vector space of dimension @xmath17 over @xmath14 , namely , a projective space denoted @xmath18 .",
    "note that we will adopt a row vector convention for the rest of the paper .",
    "[ def : spread ] let @xmath19 be a projective space .",
    "a @xmath20-_spread _ of @xmath19 is a set @xmath21 of @xmath20-dimensional subspaces of @xmath19 which partitions @xmath19 .",
    "that is , every point of @xmath19 is contained in exactly one @xmath20-space of @xmath21 .",
    "if @xmath19=pg(@xmath22 ) is a finite projective space , then a @xmath20-spread can only exist if the number of points of a @xmath20-space divides the number of points of the whole space , i.e. , if @xmath23 and hence @xmath24 , which holds if and only if @xmath25 .",
    "andr @xcite showed that this necessary condition is also sufficient .",
    "@xcite in pg(@xmath22 ) , a @xmath20-spread exists if and only if @xmath26 .",
    "a systematic construction of spreads can be obtained through field extensions as follows .",
    "suppose that @xmath27 .",
    "consider the finite fields @xmath28 , @xmath29 and @xmath30 .",
    "then @xmath31 .",
    "the field @xmath32 is an @xmath17-dimensional vector space @xmath33 over @xmath34 .",
    "the subspaces of @xmath33 form the projective space @xmath19=pg(@xmath35 ) .",
    "the field @xmath36 is a @xmath37-dimensional subspace of @xmath33 and hence a @xmath20-dimensional ( projective ) subspace of @xmath19 .",
    "the same holds for all cosets @xmath38 , @xmath39 .",
    "these cosets partition the multiplicative group of @xmath32 .",
    "hence they form a @xmath20-spread of @xmath19 .",
    "[ ex : part ] take as base field @xmath40 , i.e. , the alphabet is @xmath41 . in order to obtain planes , we consider @xmath42-spread , i.e. , @xmath43 and hence @xmath44 .",
    "finally , assume @xmath45 , that is @xmath46 : @xmath47 denote by @xmath48 the multiplicative group of @xmath49 .",
    "recall that @xmath48 is a cyclic group .",
    "let @xmath50 and @xmath51 be the respective generators of @xmath52 and @xmath53 .",
    "we have that @xmath51 is an element of order 3 contained in @xmath32 , so @xmath54 .",
    "thus @xmath53 can be written @xmath55 .",
    "as @xmath52 can be written @xmath56 we have a partition of @xmath57 into cosets of the form @xmath58 , @xmath59 .",
    "these five cosets define five disjoint planes .",
    "more precisely , @xmath57 can be decomposed into direct sums of @xmath60 : @xmath61 so that each element of @xmath57 can be written as a @xmath62-tuple .",
    "for example , the coset @xmath63 contains the elements @xmath64 .",
    "as @xmath65 , @xmath66 is the sum of the two other points . thus writing @xmath67 and @xmath68 , we finally get that the plane defined by the coset @xmath63 is @xmath69 .",
    "recall that our goal is to encode an object of size @xmath3 to be stored over @xmath0 nodes , each of storage capacity @xmath1 , such that each failure can be repaired by contacting any @xmath6 live nodes , @xmath70 .",
    "we denote by @xmath71 the self - repairing code with parameters @xmath0 and @xmath4 obtained from a spread construction .",
    "we will assume for simplicity that we work over the base field @xmath72 , though spreads can be constructed over larger alphabets .",
    "\\1 ) we first set @xmath73 , so that we are working with elements in @xmath74 , that is @xmath3-dimensional vectors over @xmath72 .",
    "\\2 ) consider a @xmath20-spread @xmath75 formed of @xmath20-dimensional subspaces of @xmath76 such that @xmath77 . in particular , take @xmath78 . since every subspace is a @xmath37-dimensional vector space over @xmath72 , it is described by a @xmath72-basis containing @xmath37 vectors .",
    "we thus set @xmath79 , and assign to each node an @xmath72-basis containing @xmath1 vectors .",
    "the number of nodes that will store the object is consequently ( at most ) @xmath80 since we must take @xmath81 , that is @xmath82 , we can further write @xmath83    \\3 ) let us denote by @xmath84 the collection of all @xmath85 vectors , ordered such that @xmath86 correspond to the first node , @xmath87 to the second node , etc . what the @xmath88th node will store is",
    "actually @xmath89 for a total storage of @xmath1 .",
    "[ ex : setting]consider the partition described in example [ ex : part ] , where we recall that @xmath90 , @xmath91 , @xmath92 @xmath93 , @xmath94 , @xmath95 , @xmath96 .",
    "the final partition of the space is thus : @xmath97    [ tab : b6 ]    .basis vectors for the scenario where we have @xmath98 , @xmath99 , @xmath100 nodes @xmath101 . [",
    "cols=\"^,^,^\",options=\"header \" , ]      we now need to make sure that the above coding strategy allows for object retrieval and repair .",
    "we start with repair of data stored in one storage node .",
    "it was shown in @xcite for hsrc that it is possible to repair data for one node by contacting @xmath10 nodes , and there are @xmath11 such choices of 2 nodes that allow repair .",
    "this holds also for psrc .",
    "suppose we have @xmath0 nodes , each storing @xmath1 pieces of data encoding an object using @xmath71 .",
    "then if one node @xmath102 fails , it is possible to repair it by contacting @xmath10 nodes .",
    "more precisely , for any choice of node @xmath103 among the remaining @xmath104 live nodes , there exists at least one node @xmath105 such that @xmath102 can be repaired by downloading the data stored at nodes @xmath103 and @xmath105 .    the @xmath106th node @xmath102 stores a subspace of the form @xmath107 , @xmath108 .",
    "let us assume this @xmath106th node fails , and a new comer joins .",
    "it contacts any node , say @xmath103 . since @xmath103 stores @xmath109 , we need to show that there exists a node @xmath105 such that @xmath110 repairs @xmath102 .",
    "now @xmath111 so we can take @xmath112 such that @xmath113 . by combining the data stored at node @xmath103 and @xmath105",
    ", we thus get @xmath114 which contains @xmath107 .",
    "let us continue with example [ ex : setting ] .",
    "if say @xmath115 fails , the data pieces @xmath116 ( corresponding to the basis vector @xmath117 ) and @xmath118 ( corresponding to the basis vector @xmath119 ) are lost . a new node joining the network can contact nodes @xmath120 and @xmath121 , from which it gets respectively @xmath122 , @xmath123 and @xmath124 , @xmath125 .",
    "now @xmath126 gives @xmath117 while @xmath127 gives @xmath119 .",
    "actually , in general , the redundancy for self - repair provided by @xmath128 is even stronger than that of @xmath129 , as we now illustrate .",
    "[ lem : b6 ] suppose we have @xmath130 nodes , each storing @xmath99 pieces of data , encoding an object of size @xmath98 using @xmath131 , as summarized in table [ tab : b6 ] .",
    "then if one node @xmath102 fails , for any choice of node @xmath103 among the remaining @xmath132 live nodes , there exists three nodes @xmath133 , @xmath134 , @xmath135 such that @xmath102 can be repaired by downloading the data stored at either nodes @xmath103 and @xmath133 , or @xmath103 and @xmath134 , or even @xmath103 and @xmath135 .    recall that @xmath50 is the generator of the cyclic group @xmath136 .",
    "we have that node @xmath102 stores @xmath137 , and @xmath103 similarly stores @xmath138 . now @xmath139 take @xmath140 such that @xmath141 we have",
    "then @xmath142    this proof actually gives an algorithm to find the different pairs that repair a given failed node .",
    "consider the code described in table [ tab : b6 ] , and suppose that the node @xmath115 fails , and a new comer contacts node @xmath121 which stores @xmath143 .",
    "we have @xmath144 thus the node @xmath115 can be repaired by contacting the following three pairs all involving @xmath121 : @xmath145      if a data collector connects to any choice of @xmath4 nodes , then he can access upto @xmath5 blocks , while trying to reconstruct an object of size @xmath3 .",
    "thus , @xmath146 .",
    "note that in the examples considered in this paper , @xmath147 .",
    "[ lem : k2 ] if @xmath148 , then the object can be retrieved from any choice of @xmath148 nodes , in which case , we may see @xmath71 as a mds code .    if @xmath148 , then each node stores @xmath149 linearly independent vectors .",
    "pick any two nodes say @xmath150 ( containing @xmath86 ) and @xmath151 ( similarly storing @xmath152 .",
    "suppose that there exists a vector @xmath153 in @xmath150 which is linearly dependent of some vectors in @xmath151 : @xmath154 since @xmath155 and @xmath156 , it must be that @xmath157 , a contradiction since @xmath150 and @xmath151 are non - intersecting by the definition of spread .",
    "to recover the object , the data collector just solves the system of linear equations in @xmath2 .    in general ,",
    "when @xmath158 , src codes are not maximum distance separable ( mds ) .",
    "a static resilience analysis provides an estimate of how much deterioration the system may suffer due to the lack of the maximum distance separability",
    ".    _ static resilience _ of a distributed storage system is defined as the probability that an object , once stored in the system , will continue to stay available without any further maintenance , even when a certain fraction of individual member nodes of the distributed system become unavailable .",
    "let @xmath159 be the probability that any specific node is available .",
    "then , under the assumptions that node availability is @xmath160 , and no two fragments of the same object are placed on any same node , we can consider that the availability of any fragment is also @xmath160 with probability @xmath159 .",
    "the probability @xmath161 of recovering the object is then @xmath162 where @xmath163 is the conditional probability that the stored object can be retrieved by contacting an arbitrary @xmath164 out of the @xmath0 storage nodes .    for @xmath165 mds erasure codes",
    ", @xmath163 is a deterministic and binary value equal to one for @xmath166 , and zero for smaller @xmath164 . for self - repairing codes ,",
    "the value is probabilistic . in fig .",
    "[ fig : oneminusrho ] we show for our toy example @xmath131 the probability that the object can not be retrieved , i.e. , @xmath167 , where the values of @xmath163 for @xmath166 were determined by exhaustive search .",
    "is zero for @xmath168 for psrc also . ]    in particular , one can list 17 unique groups of 5 nodes , whose all together 10 basis vectors generate a matrix with rank less than 6 , out of the @xmath169 unique groups of 5 .",
    "this means that if we choose any 5 arbitrary nodes , the object still can not be retrieved with a probability of 0.00083 , which is rather negligible .",
    "similarly , if we chose any arbitrary 3 nodes , the probability of unretrievability is 0.150375 .",
    "in contrast , for mds codes , the object will be retrievable from the data available at any arbitrary three nodes .",
    "of - course , this rather marginal sacrifice provides psrc an incredible amount of self - repairing capability . for any one node lost ,",
    "as shown earlier in lemma [ lem : b6 ] , one can choose any of the twenty remaining live nodes , and pair it with three other nodes , and regenerate the lost data .    in fig .",
    "[ fig : staticresilience ] we compare the static resilience @xmath161 for @xmath131 with respect to what could be achieved using a mds @xmath170 .",
    "the values were determined numerically , using the @xmath163 values evaluated as mentioned above .",
    "we note that in practice a mds erasure code may or not exist with the specific @xmath165 parameters .",
    "more importantly , we notice that the degradation of static resilience of @xmath131 to achieve the self - repairing property is marginal with respect to that of a mds erasure code , if such a code were to / does exist .",
    "we point out a few more properties of the proposed codes .    _",
    "systematic like code : _ it is usually appreciated from an implementation perspective to use a systematic code , since it makes the object retrieval immediate . we notice that though our code is not systematic , we can however contact @xmath3 specific nodes ( instead of @xmath4 ) , namely those storing as pieces each of the canonical basis vectors of @xmath171 to reconstruct the object in a systematic manner .",
    "_ bandwidth cost for regeneration : _ unlike hsrc , the psrc encoded blocks are not atomic , and instead comprise of @xmath1 pieces .",
    "thus , similar to regenerating codes , one could also expect to regenerate an encoded block piece - by - piece , by contacting more ( larger @xmath6 ) number of nodes .",
    "for example , when using @xmath131 , if the data for node @xmath115 needs to be regenerated , one could do so by contacting two nodes and downloading four pieces ( units ) of data , as we have already seen .",
    "one could instead also contact @xmath172 nodes , and regenerate the two lost pieces by downloading only three units of data .",
    "for instance , by downloading ( 010000 ) from @xmath173 , ( 110000 ) from @xmath174 and ( 000111 ) from @xmath175 .    as noted previously , for our examples , @xmath176 , corresponding to what is known as the minimum storage regeneration ( msr ) point for regenerating codes . at msr point , a node needs to contact @xmath177 nodes , and download @xmath178 data from each , resulting in a total download of @xmath179 data .",
    "thus , for the same choices of @xmath180 and with @xmath172 , one would need to download 6 units of data , and for @xmath181 , one would need to download 4 units of data , while @xmath10 is not allowed .",
    "thus , for the regeneration of one lost node , psrc can outperform regenerating codes both in terms of absolute bandwidth needed , as well as the number of nodes needed to carry out such regeneration , moreover , for upto @xmath11 failures , the regeneration overhead per node s data stays constant for psrc .",
    "it of - course needs to be noted that , in order to achieve these very interesting performance , we sacrificed the mds property . in practice , this sacrifice however has marginal impact , as can be observed from the resulting codes static resilience .",
    "in this work , we showed the existence of another instance of self - repairing codes , which are codes tailor made to meet the peculiarities of distributed networked storage .",
    "the proposed code family in this paper is based on constructions of spreads from projective geometry .",
    "we provided a preliminary study of the properties of this new family , demonstrating that they outperform existing code families both in several quantitative as well as qualitative metrics .",
    "further analysis to comprehend and harness these codes in practical settings are currently under investigation .",
    "f. oggier s research for this work has been supported by the singapore national research foundation grant nrf - crp2 - 2007 - 03 .",
    "a. datta s research for this work has been supported by acrf tier-1 grant number rg 29/09 .",
    "99 j. andr,uber nicht - desarguessche ebenen mit transitiver translationsgruppe , `` math .",
    "z. , p. 156 - 186 , 1954 .",
    "a. g. dimakis , p. b. godfrey , y. wu , m. wainwright and k. ramchandran , ' ' network coding for distributed storage systems \" _ ieee transactions on information theory _ ,",
    "56 , issue 9 , sept . 2010 .",
    "j. eisfeld and l. storme , `` partial @xmath20-spreads and minimal @xmath20-covers in finite projective spaces '' , unpublished . f. oggier and a. datta , `` self - repairing homomorphic codes for distributed storage systems '' , _ infocom 2011_. k. v. rashmi , n. b. shah , p. vijay kumar , k. ramchandran , `` explicit construction of optimal exact regenerating codes for distributed storage '' , _"
  ],
  "abstract_text": [
    "<S> self - repairing codes ( src ) are codes designed to suit the need of coding for distributed networked storage : they not only allow stored data to be recovered even in the presence of node failures , they also provide a repair mechanism where as little as two live nodes can be contacted to regenerate the data of a failed node . in this paper </S>",
    "<S> , we propose a new instance of self - repairing codes , based on constructions of spreads coming from projective geometry . </S>",
    "<S> we study some of their properties to demonstrate the suitability of these codes for distributed networked storage .    self - repair , projective geometry , coding , distributed storage </S>"
  ]
}