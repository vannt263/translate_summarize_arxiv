{
  "article_text": [
    "the author has long enjoyed solving mathematical and combinatorial puzzles , so the advent of fdr in the early 1990 s quickly led to him to try some of them out .",
    "the interested reader will find solutions to peg solitaire in  @xcite and to sudoku in  @xcite .",
    "the former has become perhaps the best known benchmark for different versions and implementations of fdr , for example in  @xcite .",
    "these examples proved very useful for demonstrating how much better model checking is than humans at finding counter - examples in many situations , and for teaching students how to use fdr effectively . at the same time",
    "they have been a useful source of student exercises .    at the same fdr",
    "has been used in a wide range of practical contexts , and the methods developed for efficiently coding these and puzzles frequently cross - fertilise .",
    "the author had never , until recently , coded a game of cards in csp .",
    "this was for a variety of reasons :    * the 52 !",
    "different orderings of a pack of cards seems prohibitive in contemplating potential possibilities .",
    "* csp s models and the way fdr works do not provide an efficient means for deciding the winner in games with multiple players trying to beat each other .",
    "* most games of patience ( i.e. card games for one , getting round the previous objection ) have dynamic structures , with the cards being moved around into structures that change size or shape as the game progresses .",
    "fdr has generally been considered as much more suitable for static structures .",
    "the first ( state - space ) objection can be addressed by observing that solving a _ particular _ deal of patience need not have anything like 52 ! states , though plainly the state space sizes of games with dynamic structure are potentially increased by this in a way not directly related to the number of deals .",
    "also , the ever improving capabilities of fdr  @xcite ( for example parallelising efficiently on multi - core and cluster architectures : the 187 m states of peg solitaire have been brought down to 23 seconds on our 32-core server and less than 2 seconds on a 1024 core cluster ) mean that the sizes of problems that can be addressed routinely using fdr has increased greatly in the last few years .",
    "in fact virtually none of the patience game checks that the author has run from the examples quoted here exceed @xmath1 states , a pretty routine level with the multi - core implementation of fdr at the time of writing , though the time taken for runs is a little more than implied by the solitaire figures above , because of the greater complexity of the csp models .",
    "few take more than 5 minutes exploring the state space on the server discussed here .",
    "the second objection is addressed by considering patience games .",
    "the third is alleviated by the observation that csp has been shown , for example in  @xcite and chapter 20 of  @xcite to be capable of handling mobile structures .    in this paper",
    "we consider the issues of coding patience games in csp , which includes building various dynamic structures and avoiding various ways in which symmetry can multiply state spaces .",
    "some of these structures are in effect linked lists and other pointer - based constructions .",
    "this work gives us insight into how to support the translation into csp of more general programming models requiring similar structures , particularly ones based on pointers .",
    "most readers will be familiar with the card games called _ patience _ or _ solitaire _",
    ", having played them via programs , apps , websites , or if they are ( like the author ) sufficiently old , with real cards .",
    "we use the name patience in this paper , to provide a clear distinction from peg solitaire .",
    "a game starts by shuffling one , or sometimes two packs of cards , then dealing some or all of them into a pre - set pattern .",
    "the player then manipulates the cards according to the rules of the particular game , usually aiming to arrange all the cards into ordered suits in some way .",
    "a given deal is winnable if this is a possible outcome . in some cases",
    "the question of winnability is complicated by hidden cards or further nondeterminism beyond the initial shuffle .",
    "we will discuss this later .    in the next section",
    "we give background information about csp , fdr and a few games of patience .",
    "section  [ coding ] discusses how to code them , together with our results .",
    "all the csp programs discussed in this paper can be downloaded from the author s publications web page , along with this paper .",
    "in this paper we will make extensive use of the extension of csp by functional programming constructs , known as , and described in detail in  @xcite .",
    "this allows to create data types , use inbuilt structures such as tuples , lists and sets , and to write concise programs which lay out large networks of component processes indexed by such structures .",
    "thus we can model the various components of a card game at the programming level , and then , for example , lay out the initial configuration of a game as a network of one process per card .",
    "for this reason the notation given below is that of  rather than the blackboard language seen in most books and papers .",
    "the main csp operators used in this paper are :    * stopthe process that does nothing . * a - > pthe process that communicates the event a and then behaves like p. the single event a can be replaced by various choice constructs such as ` c!e?x : d ` .",
    "this particular one assumes that c is a channel with two data components .",
    "this construct fixes the first to be the value of the expression e and allows the second to vary over d , assumed to be a subset of the type of the second component .",
    "if d is absent it varies over the whole of this type . in cases with such an input",
    ", the successor program p can include the input identifier x. * p [ ]  qis the external choice operator , giving the choice of the initial visible events of p and q , and then continuing to behave like the one chosen . like",
    "a number of other csp operators ,  has both the binary and an indexed form ` [ ] x : a @ p(x ) ` , meaning the external choice over all the processes ` p(x ) ` as ` x ` varies over the set ` d ` .",
    "the effect of the blackboard csp @xmath2 ( which has no literal translation in ) can be achieved via ` [ ] x : d @ x - > p ` .",
    "+ @xmath3 also has ` p |~| q ` as its internal , or nondeterministic choice operator , which allows the process to choose between the arguments .",
    "however this operator will not feature in this paper . * the final constructs we will use for building sequential processes allow us to put two processes in sequence : ` skip ` is a process that terminates successfully and ` p;q ` lets ` p ` run until it terminates successfully and then runs ` q ` .",
    "successful termination is represented by the process communicating the special event @xmath4 , and is distinct from ` stop ` .",
    "thus ` stop;p = stop ` and ` skip;p = p ` .",
    "* csp has a number of parallel operators .",
    "the ones we shall use here are",
    "_ alphabetised _",
    "parallel and _",
    "generalised parallel_. alphabetised parallel is written ` p [ a||b ] q ` , where ` p ` and ` q ` are respectively communicating in their alphabets ` a ` and ` b ` , with them forced to synchronise on actions in the intersection of their alphabets .",
    "most of our uses of this operator will be in its indexed form ` || i : i@[a(i)]p(i ) ` where ` a(i ) ` is the alphabet of ` p(i ) ` , and an action in the union of these alphabets occurs just when all the ` p(i ) ` with it in their alphabet perform it .",
    "generalised parallel ` p [ |a| ] q ` specifies just the interface ` a ` that ` p ` and ` q ` must synchronise on , with them being free to communicate anything else independently . *",
    "two important operators are commonly used to structure parallel networks : _ hiding _ ` p\\x ` allows internal or irrelevant communications ` x ` to be hidden , becoming invisible actions @xmath5 .",
    "the other is _ renaming _ ` p[[r ] ] ` where ` r ` specifies a collection of pairs of events written ` a < - b ` . for each such pair , every time `",
    "p ` offers ` a ` , ` p[[r ] ] ` offers ` b ` leading to the corresponding state of ` p ` , still renamed . the relational renaming implicitly maps any event of ` p ` not otherwise renamed to itself .",
    "it is permissible to map one event of ` p ` to several different ones ( which become alternatives ) or several events of ` p ` to the same target .",
    "* some of our uses of hiding and renaming will have the effect of creating a model which can easily be related to a natural specification .",
    "another operator we will use for this purpose is _ throw _ : ` p",
    "[ |a| > q ` , in which ` p ` progresses except that if it ever communicates an event in ` a ` it passes control to ` q ` .",
    "thus , like sequential composition , it represents a way in which ` p ` can hand control over to ` q ` .",
    "there are a number of books on patience , for example  @xcite , and many web - sites offering implementations of it .",
    "a number of standard terms are used . quoting in part from from wikipedia ,",
    "the following terms describe collections of cards which exist in some games :    * _ stock_typically squared and face - down . these cards can be turned over into the waste , usually one - by - one , but sometimes in groups of two or three ( depending on individual game rules ) , whenever the player wishes . *",
    "_ waste _ or _ discard _ or _",
    "heap_the area where the cards from the stock go when they are brought into play .",
    "the following are typically true : the pile is squared and face - up . in most games , only cards from the stock can be played to the waste .",
    "only the topmost card is available for play . *",
    "_ foundation_this usually consists of the cards build up in individual suits , face up and in order .",
    "the objective of most games is to move all cards here .",
    "* _ tableau_the tableau consists of a number of tableau piles of cards .",
    "cards can be moved from one pile or area to another , under varying rules .",
    "some allow stacks of cards that match the building requirements to be moved , others only allow the top card to be moved , yet others allow any stack to be moved . *",
    "_ reserve_a group or pile(s ) of cards where building is usually not permitted .",
    "these cards are dealt out at the beginning , and used , commonly one card at a time , during the play . *",
    "_ cell_common to `` freecell '' type games , cells allow only one card to be placed in them .",
    "any card can be put in a cell .",
    "these act as manoeuvring space .",
    "when one is writing a program to test to see if a given deal of a game is soluble , there are two important issues :    * in some games all the cards are laid face up on the table , whereas in others some are face up and some are face down or are hidden in the stock . in the former sort the player can take everything into consideration before deciding which move to play next , while in the latter there are things which would have affected the play , but the player does not have full information without cheating and taking a look . * in most games the cards are shuffled before the start but beyond that what happens to the cards is completely in the hands of the player . however in some",
    "there is re - shuffling or some other element of randomness introduced after the start .",
    "a good example of this is the game montana , in which the 52 cards are dealt out in four rows of 13 and the aces removed .",
    "the game is based on the spaces this removal creates .",
    "see figure  [ montanapic ] .",
    "+ ] + a move in montana is either to place a 2 in a space that appears in the first column or , in any other column , to place the card which follows ( in the same suit ) the card immediately to the left of the space .",
    "thus the space to the right of a king can not be filled and the game becomes stuck when all four spaces lie to the right of a king with no other card in between . in the position shown in figure  [ montanapic ]",
    "there are three moves possible , namely @xmath6 moved to after @xmath7 , @xmath8 after @xmath9 and @xmath10 after @xmath11 .",
    "+ the objective is to get the 2-to - king of the four suits in ( respectively ) the four rows , in order , leaving a single gap at the end of each row .",
    "since this is difficult , the game provides that when stuck you can pick up all the cards which are not already in place , plus the aces , shuffle them , and lay them out in the vacant positions .",
    "the aces are once more removed and the game re - starts . usually three of these re - deals are allowed .",
    "+ in real life it is unknowable how these re - deals will behave , and so impossible to condition one s strategy before one of them on how they will turn out .",
    "note that in this case a re - deal might put all the cards into exactly the right spots or place each of the aces to the immediate right of a king ( so solving or immediately blocking the game ) .",
    "+ we will not consider games of this type , and so in particular will only consider montana in the case where there are no re - deals .    in the case of games with hidden cards , in seeking a solution to a given deal we will be finding out if the player could have performed a series of moves to win the game , which in some cases , where cards are hidden , might be lucky guesses .",
    "so searching for a solution on a tool like fdr only models what an optimal player ought definitely to be able to achieve where there are no hidden cards and no randomisation after the initial shuffle . aside from no - redeal montana , two other such games are freecell and king albert , as described here :    * freecell is a very popular and well understood game thanks to microsoft including it in windows complete with a method of generating numbered pseudo - random deals from a seed .",
    "the cards are initially laid out in eight columns with seven or six cards as shown in figure  [ freecellpic ] .",
    "+   ( see text ) ] + the objective is to build them up in the foundation as four suits , starting with the aces . in the basic rules cards are moved around singly actions .",
    "] between the columns and the four cells , each of which can hold one card .",
    "a card can either be moved into the foundations ( preserving suit order ) , into a cell or onto the top of a column if the top card has one value higher and the opposite colour .",
    "there are no restrictions on what can be moved into an empty column",
    ". only the top card of each column can be moved .",
    "+ thanks to its popularity and the de facto standardisation of deal numbering , freecell has been well studied with solver programs , and a good deal is known about it including that only 8 of the first million deals are not solvable .",
    "the deal shown in figure  [ freecellpic ] was the result of the author trying to photograph the first of these , deal 11982 .",
    "however there is a mistake : the deal 11982 has @xmath9 and @xmath12 swapped from their true positions in that deal .",
    "it is interesting that this small change actually makes the deal solvable ( needing the full 4 cells ) , just as deal 11982 is soluble with 5 .",
    "the distributed file freecelldeal.csp illustrates these facts . *",
    "king albert ( named after a king of belgium ) is less well known , and indeed was unknown to the author until he was working on this paper . in this",
    "the cards are dealt out into nine columns as shown in figure  [ kapic ] , + ] + leaving seven cards as the `` belgian reserve '' .",
    "this game is played exactly like freecell except that there are no cells , and cards can only be moved from the reserve , never into it .",
    "the author has found no evidence of prior computer analysis of this game , merely a frequently repeated statement that about 10% of games are solvable ( we will see later that this is wrong ) .    nor has the author found any evidence for computer analysis of montana , though one does often find the statement that about 1 in 20 games or 1 in 10 games is soluble when using the three redeals .",
    "we will see later that this is also wrong .",
    "the final game we consider is perhaps the best - known one , klondike  : see figure  [ klondikepic ]    ]    unlike the ones above this does have hidden cards ( initially only eight are visible , the tops of the seven columns and the top card of the 24-card stock .",
    "it is played like king albert except that a card in one of the columns is only turned face - up when it is at the top , stacks of alternating descending cards can be moved freely between columns provided the alternating descending property in maintained , but only a stack with a king at the bottom can be moved into an empty stack . usually ( unlike freecell and most descriptions of king albert ) cards can be moved from the foundations to the columns , preserving the alternating descending property .",
    "there are many variants on this game , mainly based on how the stock cards are dealt ( typically singly or in threes , with various numbers of times through the stock ) .",
    "there are figures for the solubility of this game ( based on perfect knowledge ) of several variants . in this paper",
    "we will concentrate on the case where cards are dealt singly , with no limit on the number of times a card can be turned over .",
    "in csp , particularly when this is designed for input into fdr , we want models to have a fairly high degree of parallelism , since the tool is typically more efficient for these .",
    "we also want to avoid creating any inessential states , which in most games means states that do not relate directly to positions where real moves have been completed . for",
    "if we model a single move by several , especially if we allow these to interleave , the state space can grow alarmingly .",
    "all of the games we have described have symmetries which mean there can , depending on how they are coded , be large classes of states which are completely equivalent in behaviour . in the three examples based on columns of cards ,",
    "it is clear that two states with the same set of columns ( though in different positions ) are completely equivalent as regards solubility , as are two positions obtainable from each other by permuting the rows in montana .    aside from montana , which has an essentially fixed format throughout ( four rows of 13 cards or spaces ) ,",
    "all the others change in pattern dynamically through the game as various piles and stacks of cards grow , shrink and are moved around .",
    "there are two obvious approaches to modelling these games in csp .",
    "one is to make each card a process , which at any time knows enough about its position to allow it to determine its ability to move or to be moved to .",
    "these cards , together with one or two other processes to monitor things like empty cells or columns , can make up the csp model of a game .",
    "the other is to model each component of the game such as a column , an individual suit in the foundation , the stock or the waste cards . in the case of montana",
    "it makes sense to model each position in the @xmath13 grid as a separate process that is either a card or is a space ( this state changing as moves are played ) .",
    "each of these has its advantages and disadvantages , as revealed in the following discussion .    in the card - based solution , each card needs to know when it is at the top of a column or otherwise available for moving .",
    "it therefore has to know not only when it is moved , but also whether a card moves from or to being on top of it .",
    "this means that each card needs to know what card is above it and/or which is below it , noting that when a card is at the top of a column there will be none above , and none below when on the bottom .",
    "the author dealt with this by using the first of the following data types :    .... datatype links = crd.card | top | bottom    datatype suits = hearts | clubs | diamonds | spades    datatype card = card.suits.{1..13 } ....    making each column into a linked list of processes .",
    "there are arguments for making this doubly linked ( each card knowing the identities of the cards above and below it ) , though in many circumstances one can get away with a singly linked list .",
    "however in the latter case it is still for a card to know if it is at the top of a column , and probably necessary for it to know if it is at the bottom of one , so that moving it creates an empty column .",
    "he used actions such as ` stacktostack.c1.c2 ` meaning that ` c1 ` moves from the top of a column to the top of another , where the current top card is ` c2 ` .",
    "clearly the processes representing ` c1 ` and ` c2 ` respectively need to agree to this move , with ` c2 ` agreeing only if it is at the top of a column and ` c1 ` agreeing only when it is at the top or in the sorted portion in the case of klondike .",
    "such moves will only be possible when ` c1 ` is of the opposite colour and one point lower than ` c2 ` .",
    "the the cards now at the top of the two stacks will have to know this .",
    "it follows that whatever card was below ` c1 ` will need to synchronise on the event also or otherwise be told about its new status .    because a card keeps the same alphabet at all times , but the card on top of it changes , its alphabet ( in the case where it synchronises ) will have to contain all moves of the form ` stacktostack.c1.c2 ` where ` c1 ` is any card which might ever be on top of it . furthermore it will have to agree to such events : in the case where the card ` c ` we are defining is ` c2 ` , it will only agree to this event when it is on top of a stack .",
    "if it is not ` c2 ` but ` c1 ` is on top of it , ` c ` knows that after the event it is on top .",
    "however ( wherever it is in the game ) ` c ` should never block the event ` stacktostack.c1.c2 ` when it is neither ` c1 ` nor ` c2 ` .",
    "this is similar to the techniques used in chapter 20 of  @xcite to model mobility , where processes move around and change which ones they communicate with . there",
    "the author showed that this could be simulated in csp by putting every event that ever be available to a process into its simulation alphabet , and having the simulation of each process that does not for the time being have an event @xmath14 in its mobile alphabet agree to that event .",
    "the key way of explaining this is the csp identity    .... p [ a||b ] q   =   ( p|||run(b'))[|events|](q|||run(a ' ) ) ....    where ` a ' ` are the members of ` a ` not in ` b ` and vice - versa , provided ` p ` and ` q ` do not terminate with @xmath4 and only communicate within ` a ` and ` b ` respectively .",
    "thus the parallel composition on the left hand side , with its fixed alphabets , is equivalent to the one on the right where a pair of processes always synchronise on everything after being padded out by the two ` run(x ) ` processes , which are always willing to communicate anything in the parameter set of events . by building something like a dynamic version of `",
    "run(x ) ` which changes as its accompanying process s alphabet changes , we can create the effect of ` p [ a||b ] q ` where ` a ` and ` b ` can change as the execution progresses .",
    "that is precisely the approach set out in @xcite , whereas here we take the approach of building the process representing each card so that it allows the extra events required for mobility itself by allowing but ignoring events that would be relevant only if the moving card is in a different position .    so the state of a card when it is in one of the eight stacks of freecell , the first game we consider here , is    ....",
    "cstack(c , below , above ) = above==top & stacktosuit.c ?",
    "_ - >    ( newtop(c , below ) ; csuit(c ) ) [ ] above==top & stacktostack?c':skabove(c)!c - > cstack(c , below , crd.c ' ) [ ] above==top & stacktofc!c - > ( newtop(c , below);cfc(c ) ) [ ] above==top & fctostack?c':skabove(c)!c - > cstack(c , below , crd.c ' ) [ ] above==top & stacktostack!c?c':skbelow(c ) - >                      ( newtop(c , below);cstack(c , crd.c',above ) ) [ ] iscard(below ) and above==top & stacktoestack.c - >                     ( newtop(c , below);cstack(c , bottom , above ) ) [ ] above!=top & maketop.cardof(above)!c - > cstack(c , below , top )    newtop(c , c ' ) = if c'!=bottom then maketop.c.cardof(c ' ) - > skip                                else freestack.c - > skip    lsbelow(card.s.n ) = if n==ace then bottom else crd.card.s.n-1 ....    note that there are separate events for the possible places for moves to and from a stack such as a cell or suit .",
    "the separate event for moving to an _ empty _ stack is because this is governed by different rules to moves to a non - empty stack .",
    "there is a separate processes which monitor the numbers of empty stacks and only allows a card to move into one when one is available .",
    "it is important to realise that a card has no idea which of the eight stacks it is in .",
    "that is because it really does not matter : all that matters is that it is in a stack and which cards are above and below it .",
    "note that if we did have an index for which stack a card is in , this might increase the state space by a factor of nearly @xmath15 , because any permutation of the stacks would now produce a different state except for swapping two or more empty ones .",
    "this is perhaps the strongest reason why we code stacks as clusters of mobile card processes rather than a single process that represents a given stack , although another strong one is that such processes would have large state spaces .",
    "sorted ones.this does not take account of the unsorted cards that may be in the stack above these . ]",
    "similarly there is a very simple state for a card in a cell , with cards entering these when allowed by a separate process that monitors how many are currently filled . just as with stacks , there is good reason not to let each card know _ which _ cell it is in .    ....",
    "cfc(c ) = fctosuit.c ?",
    "_ - > csuit(c ) [ ] fctostack.c?c':skbelow(c ) - > cstack(c , crd.c',top ) [ ] fctoestack.c - >   cstack(c , bottom , top ) ....    there is similarly a process which monitors the progression of cards into the four suits , ensuring that each suit is built up in order and also raising a flag when all four are complete .",
    "it has a further , more subtle purpose .",
    "if a card is available to put in a suit then it is not always optimal to put it there , because it may be needed to hold a lower card of the opposite colour on top of it in a stack .",
    "however if both the cards of opposite colour with value one lower are in the suits _ or _ both cards of opposite colour with value two lower _ and _ the card with value three lower and the same colour ( but different suit ) as @xmath16 are already there then there can be no point in not moving @xmath16 to its suit . that @xmath16 might hold are already in the suits and can not move back .",
    "the second case follows because under these circumstances it is possible and safe to move any such @xmath17 to the suits : there is no need for @xmath16 to hold it . ]",
    "the boolean flag which is part of the event moving each card to its suit is calculated by the ` suits ` process : it is true is it is safe to force the move according to the above criteria .",
    "we force such actions to happen when they can . by itself",
    "this considerably reduces the state space , but we have another trick to play as well .",
    "we hide forced events and apply the fdr _ chase _ operator which forces _ tau _ events to happen without counting them as events in the breadth - first search .",
    "this has the effect of bringing forward states in which a lot of moves to suits have been forced , meaning that fdr typically looks at a lot less other states before finding one of these than it would without _ chase_. in fact if the forcing is made optimistic : forcing all enabled moves to suits , this usually results in finding solutions faster , though in theory it could fail to find any solution when there is in fact one .",
    "the events ` freestack.c ` indicating that a stack has become empty are also hidden and _ chased _ , because it is safe to do so and also reduces the state space by eliminating interleaving .",
    "there are several files implemented using these ideas available with this paper on the author s website .",
    "these include ones with a random deal generator that requires a seed , one that can not be solved with four cells , and one that uses suits rather than cards as the second argument of ` stacktostack ` as discussed above . at the time of writing all 52-card deals attempted",
    "were within the range of the author s dual - core laptop if not offered more cells than they need , most taking a few minutes    a feature common to all our card - game models is that fdr s preliminary compilation phase in which it reduces a cspm script to the supercombinator form the checking run in , takes significant time for each deal irrespective of how many states that deal has . in the case of these freecell models , it takes about 20s per script on the author s laptop , but this would have been considerably more if we had used processes representing multiple cards ( like whole stacks ) or had use a larger alphabet ( for example by parameterising ` stacktostack ` with three cards ( the card moving and the from and to ones ) , which is very tempting .",
    "the coding of king albert is very similar to that of freecell : the only differences are that there is now one more stack , that these have different sizes , and that the seven - card reserve ( to which cards can not move ) replaces the cells .",
    "this presents no challenge .",
    "the main point of interest in this game is the results obtained . despite the statements on the web to the effect that about 10% of games are soluble , the author found that 72 of the first 100 random deals were solved , mostly fairly quickly , by fdr .",
    "klondike is similar to king albert .",
    "the fact that some of the cards in columns are initially face down does not affect the coding , only the interpretation of what a discovered solution means   as discussed earlier this now depends on some luck as well as careful planning .",
    "the reserve of king albert has now become a 24-card stock that are initially face down and turned over in groups of 1 or 3 into the waste .",
    "there is a sense that a stock that is turned over in 1s as often as the player chooses is equivalent , in terms of solvability , to a reserve : each card remaining in the stock can always be reached . on the other hand",
    "this would move away from the spirit of the game and not be adaptable to more limited access to the stock .",
    "the author therefore implemented the combination of stock and waste as a doubly linked circular list : the links in one direction enable us to turn over the cards from the stock in the correct order , and those in the other enable us to treat the waste as a stack .",
    "a header process was included in the list to detect the top and bottom of the stock , handle the process of starting a new pass through the list , and handle the case where the stock as become empty .",
    "cards are never added to this circular list , but we have to allow for a card @xmath16 being removed , meaning that the two adjacent processes need to have the pointers which formerly pointed to @xmath16 being altered .",
    "thus the event(s ) constituting the move of @xmath16 to a column or suit need to tell the two adjacent cards what @xmath16 s former links were",
    ". it would be preferable to to do this in a single action , but that would mean that the events would need to contain at least three cards as data fields , meaning that the alphabet size and consequent compilation time would become problematic .",
    "therefore the author actually coded these interactions via a series of events , using a separate process ` linker ` to avoid having three - card events .",
    "the events are    1 .   the main move of a waste card ` c ` to a column or suit , that card then 2",
    ".   communicates its previous ` below ` link to ` linker ` , 3 .   followed by its previous ` above ` link .",
    "linker ` then tells ` above ` and ` below ` to link to each other in place of ` c ` .",
    "the last three events are hidden and the fdr function ` chase ` applied .",
    "this forces the three @xmath5s created from the ` linker ` events to happen immediately after the main move , thereby making the four events effectively into one .",
    "this cuts down on potential interleavings and eliminates any possibility of error arising from the series of events relating to different game moves overlapping",
    ".    it would be easy to adapt the resulting csp model to any of the usual variations in how the stock is used .",
    "the solvability of klondike has already been well studied ( see wikipedia article ) , so the author did not seek to repeat these experiments .",
    "unlike the three games we have discussed above , montana maintains a rather static structure throughout the game : four rows made up of 13 cards and spaces each , with four spaces and 48 cards overall .",
    "therefore we now have the option of maintaining a process for each of these 52 slots ( which is at all times a named card or an unnamed space ) as well as the option of having a mobile process for each card ( and perhaps space too ) .",
    "while the mobile cards approach has the potential benefit of eliminating any symmetries which arise from permuting the rows , provided one does not create more symmetries by giving the four spaces separate identities , the disadvantages mean it is not practical .",
    "in summary these are :    * a process for a slot in the array only needs 49 basic states ( one for each card that might be in the slot and one for a space .",
    "however to get the linked list approach to work the list needs to be doubly linked ( i.e. each card has a pointer to both left and right ) .",
    "it also needs to know how many spaces ( 04 ) are on its right , making @xmath18 basic states for a card process , and each of these states needs to participate in a large number of events .",
    "this is significantly more expensive than in the other examples we have seen of doubly linked lists , because for example the only cards that can be involved in the stock and waste in klondike are those initially in the stock .",
    "* to maintain the state of these pointers and counters at the sites both where the card is moved from and to needs multiple communications and large alphabets .",
    "multiple communications lead to a large number of intermediate states .",
    "these mean that the time taken to compile , run and debug the checks are substantially greater than with the array model .",
    "despite using tricks such as factoring the card process into three and using a lot of renaming to avoid symmetric compilations , the author did not succeed in getting the mobile card model to run for more than a 20 card pack ( once the aces had been removed ) , which is the smallest possible with four suits where one can not get a complete row of spaces .    on the other hand the array model was very successful and demonstrated that montana ( not allowing any redeals ) is far more frequently soluble than appears to have been believed before .",
    "63 of the first 100 random deals were soluble with no redeals , whereas several web sites quote the figure of about 10% being soluble by a skilled player with three redeals .",
    "we entered on this study to illustrate the expressive power of csp , in particular in describing mobile systems , and the power of fdr to decide things about them .",
    "it is clear that these 52-card games of patience are within the scope of what can be handled by these technologies , but are sufficiently close to the boundary that we have to be careful about how to describe each game , taking careful consideration of the nature of each system from the points of view of alphabet size , compilation time and running time .",
    "we have also illustrated a style of describing mobile systems in csp that is different from that described in chapter 20 of  @xcite , where it was shown how to achieve the effect of communicating channels along channels .",
    "the approach used here is more explicit : we simply tell each process ( i.e. card ) who it is next to , keeping this information up to date , and the processes duly communicate with their neighbours . thus processes are told the topology of their local network explicitly rather than implicitly .",
    "many of the models we created included linked structures of csp processes strongly suggestive of the pointer structures in heap used in programming .",
    "we will develop this idea by showing in a subsequent paper how such programming styles can be supported by csp and fdr , particularly when new _ symmetry reduction _ functionality of fdr is used to eliminate the differences in states created by different choices of heap cells for the same roles .",
    "that issue is essentially the same as the reason it was so much better to use the card - based linked model for games like freecell rather than to park cards in particular named columns or cells .",
    "the same symmetry reduction technology would successfully eliminate these symmetries in card models too , but the models presented here do not require it .",
    "one could well imagine producing a compiler from a suitable language for describing games of patience to csp , if one were wanted .",
    "however one might well need to input some human judgement about what style of model ( say array or mobile ) would work best .",
    "the csp files relevant to this paper can be found in an accompanying zip file on the author s web site .",
    "note that the one for klondike incorporates a trick not discussed in this paper : this uses the ability of fdr to compute multiple counter - examples to determine , in a single run , what the highest score attainable with a given deal it .",
    "the style of programming for this exactly parallels one discussed for metering timing problems in chapter 14 of  @xcite .",
    "t. gibson - robinson , p. armstrong , a.boulgakov and a.w .",
    "fdr3   a modern refinement checker for csp . in",
    "tools and algorithms for the construction and analysis of systems _",
    "187 - 201 ) .",
    "springer 2014 ."
  ],
  "abstract_text": [
    "<S> the author has long enjoyed using the csp refinement checker fdr to solve puzzles , as witnessed by examples in  @xcite . </S>",
    "<S> recent experiments have shown that a number of games of patience ( card games for one ) are now well within bounds . </S>",
    "<S> we discuss the modelling approaches used to tackle these and avoid symmetric states . for two such games </S>",
    "<S> we reveal much higher percentages of winnable games than was previously believed . </S>",
    "<S> the techniques developed for some of these card games   which employ various dynamic patterns of cards   suggest techniques for modelling pointer structures in csp and fdr analogous to those used with the @xmath0-calculus . </S>",
    "<S> most of these use csp s ability to express mobile systems . </S>"
  ]
}