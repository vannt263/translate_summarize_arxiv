{
  "article_text": [
    "quantum computers hold the promise of the efficient solution of problems , such as factoring @xcite and simulation of quantum systems @xcite that are generally believed to be intractable on a classical computer . furthermore ,",
    "as the processor size in state - of - the - art computers continues to scale down and performance begins to be limited by dissipative effects in logical processing , it has become increasingly clear that considering the quantum nature of the components of a classical computer will be essential in the not - too - distant - future . in both of these scenarios  constructing a working quantum computer , or simply continuing to improve the performance of classical computers ",
    "quantum error correcting codes and ideas from quantum fault - tolerance @xcite will be essential elements in the future computer engineer s toolbox .",
    "stabilizer codes are an important class of quantum codes developed in @xcite , and are the quantum analogues of classical additive codes .",
    "an @xmath2 $ ] stabilizer code encodes @xmath3 logical qubits into @xmath4 physical qubits , and is described by an abelian subgroup , @xmath5 , of the pauli group with size @xmath6 .",
    "the codespace is the set of simultaneous eigenvectors of @xmath5 with eigenvalue @xmath7 .",
    "there is a rich theory of stabilizer codes , and a thorough understanding of their properties .",
    "nevertheless , such codes are strictly suboptimal in some settings  there exist _ nonadditive codes _ which encode a larger logical space than possible with a stabilizer code of the same length and capable of tolerating the same number of errors .",
    "there are only a handful of such examples @xcite , and their constructions have proceeded in an ad hoc fashion , each code working for seemingly different reasons . in the following",
    "we present a framework for code design that includes as special cases stabilizer codes as well as all known nonadditive codes with good parameters .",
    "we note that the code of @xcite was presented explicitly in the form we describe below and , indeed , served as motivation for our studies of the generality of such a construction .",
    "our codes are fully described by two objects : a single stabilizer state @xmath8 , and a classical code that generates the basis vectors of our code from @xmath8 .",
    "the stabilizer is chosen such that it maps all pauli errors onto only @xmath9 errors , though this may increase their weight . in this way we map the problem of finding a quantum code to that of finding a classical code that corrects an unusual error model .",
    "we have thus unified stabilizer and nonadditive codes and rendered both in a form that gives insight into the classical nature of quantum error - correction .",
    "our approach is related to the description of nonadditive codes given in @xcite in terms of boolean functions our codeword operators , codeword stabilizer , and effective classical errors correspond , respectively , to a boolean function @xmath10 , a matrix @xmath11 , and the `` zset '' in the language of that work .",
    "their approach is essentially dual to ours  in the language we use here it amounts to first choosing a classical code and trying to design a stabilizer state whose induced error model is corrected by the chosen code . from this perspective , the approach of @xcite seems somewhat unnatural , which is perhaps the reason it has not proved useful for finding new codes . both approaches are closely related to the work of @xcite .",
    "we describe codes on @xmath4 qubits that encode @xmath12 dimensions with distance @xmath13 ( traditionally written @xmath14 . in this framework",
    "we find the original nonadditive @xmath15 code of @xcite and the family it generates , the simple family of distance @xmath16 codes found in @xcite , the @xmath17 code of @xcite , as well as new @xmath0 and @xmath1 codes .",
    "an @xmath18 code will be described by two objects@xmath5 , a @xmath19 element abelian subgroup of the pauli group not containing minus the identity , which we call the _ word stabilizer _ , together with a family of @xmath12 @xmath4-qubit pauli elements , @xmath20 , which we call the _ word operators_. there is a unique state @xmath8 stabilized by @xmath5 , _",
    "i.e. _ @xmath8 satisfies @xmath21 for all @xmath22 .",
    "our code will be spanned by basis vectors of the form @xmath23 since the code vectors should all be different , at most one @xmath24 can be in @xmath5 .",
    "typically we will choose @xmath25 and later we will prove this can be done without loss of generality . note",
    "that @xmath26 is an eigenvector of all @xmath22 with eigenvalue @xmath27 , but @xmath26 is not stabilized by @xmath5 unless @xmath28 .",
    "each @xmath26 is stabilized by a different stabilizer @xmath29 .",
    "we would now like to understand the error correction capabilities of such a _ codeword stabilized _ ( cws ) code .",
    "an @xmath30 code is an @xmath18 code capable of detecting pauli errors of weight up to @xmath31 , but not @xmath13 , and is said to have minimum distance @xmath13 .",
    "a distance @xmath13 code can also be used to correct errors up to weight @xmath32 .",
    "the conditions for error correction were found in @xcite .",
    "the error correction conditions for a general code with basis vectors @xmath26 are that , in order to detect errors from a set @xmath33 , it is necessary and sufficient to have @xmath34 for all @xmath35 . for a code of the form described above",
    ", this becomes @xmath36 to correct errors on a fixed number of qubits , it is sufficient to study errors of the form @xmath37 with bounded weight since these form a basis @xcite .",
    "this leads to the _ necessary and sufficient conditions _ for detecting errors in @xmath33 that for all @xmath38 @xmath39 and @xmath40 eq . ( [ detectcondition ] ) is the condition that two codewords should not be confused after an error , while the final three conditions express that each error must either be detected ( eq .",
    "( [ cond1 ] ) ) , or the code must be `` immune '' to it_i.e . _",
    "the code is _",
    "degenerate_.    [ theorem : graphstate ] an @xmath18 codeword stabilized code with word @xmath41 and codeword stabilizer @xmath5 is locally clifford - equivalent to a codeword stabilized code with word @xmath42 and codeword stabilizer @xmath43 generated by @xmath44 in other words , any cws code is locally equivalent to a cws code with a graph - state stabilizer and word consisting only of @xmath9s .",
    "the set of @xmath45s form the adjacency matrix of the graph .",
    "moreover , the word can always be chosen to include the identity .",
    "we call this * standard form*.    first note that @xmath5 is local - clifford equivalent to a graph state due to @xciteso there is some local - clifford unitary @xmath46 that maps @xmath5 to @xmath43 of the form ( [ graphstabilizer ] ) . in the new basis",
    "the word are @xmath47 , and we have @xmath48 so that , letting @xmath42 , we have @xmath49 since @xmath50 consists of local clifford elements , we see that the cws code defined by @xmath43 and @xmath51 is locally clifford equivalent to the original code .    finally , to ensure the codeword include the identity we can choose @xmath52=@xmath53 which always has @xmath54 .",
    "this can be seen by commuting the @xmath55 through the @xmath56 in the error - correction conditions which can at worst pick up a sign depending only on @xmath56 .",
    "the two conditions with @xmath57 on the right are insensitive to this and the other two conditions at most change places .",
    ", @xmath58 , @xmath59 , @xmath60 , @xmath61 , @xmath62 , and @xmath63 .",
    "an @xmath64 error applied to node 5 in the lower - left is translated by multiplying with the stabilizer element @xmath61 and turns into @xmath9 errors on the nodes indicated .",
    "[ pushedout ] ]    this structure theorem gives rise to the following lemma , which is at the heart of our construction :    a single qubit pauli error @xmath9 , @xmath64 or @xmath65 acting on a codeword @xmath66 of a cws code in standard form is equivalent up to a sign to another ( possibly multi - qubit ) error consisting only of @xmath9s . [ lemma ]    let the error @xmath67 act only on the @xmath68th qubit .",
    "if it is a @xmath9 error the result is immediate .",
    "otherwise use the fact that @xmath69 , and take @xmath70 to be the generator having @xmath64 on bit @xmath68 .",
    "then since @xmath71 the @xmath64 in @xmath67 cancels with the @xmath64 from @xmath70 and we are left with the @xmath9s from @xmath70 as well as a @xmath72 if @xmath67 was @xmath73 .",
    "lemma [ lemma ] allows us to construct cws codes with a satisfying interpretation : @xmath64 errors on any qubit are `` pushed '' outwards along the edges of the graph and transformed into @xmath9s .",
    "this is illustrated in figure [ pushedout ] .",
    "similarly @xmath74 errors are pushed along the edges , but also leave a @xmath9 behind at their original locations . since all errors become @xmath9s , we can think of the error model as classical , albeit consisting of strange multi - bit errors .",
    "we define this translation to classical errors by the function @xmath75 : @xmath76 where @xmath45 is the @xmath77th row of the stabilizer s adjacency matrix ( recall from eq .",
    "( [ graphstabilizer ] ) @xmath78 defines @xmath45 ) .",
    "the codeword @xmath79 will be chosen to so that the @xmath80s are a classical code for this error model .    a cws code in standard form with stabilizer @xmath5 and codeword @xmath81 detects errors from @xmath33 if and",
    "only if @xmath82 detects errors from @xmath83 and in addition we have for each @xmath56 , @xmath84 thus , any cws code is completely specified by a graph state stabilizer @xmath5 and a classical code @xmath85 .",
    "when @xmath86 , @xmath87 is satisfied exactly when @xmath88 , which is in turn equivalent to @xmath89 .",
    "in standard form , the only element of @xmath5 without any @xmath64 is the identity , so that this is satisfied exactly when @xmath90 .",
    "this is explicitly the classical error - detection condition .",
    "similarly , when @xmath91 , we must satisfy eqs .",
    "( [ cond1 ] ) , ( [ cond2 ] ) and ( [ cond3 ] ) , whose three possibilities translate directly to @xmath92 since @xmath93 for the @xmath94 codeword , eq .",
    "( [ notins ] ) is equivalent to @xmath95 and therefore to ( [ clseneq0 ] ) . if ( [ clseneq0 ] ) ( and therefore ( [ notins ] ) ) is not satisfied , @xmath96 .",
    "if any @xmath97 anticommutes with @xmath56 we have also @xmath98 . since no @xmath99 is also in @xmath100 this readily implies the equivalence of ( [ complus ] ) to ( [ ins ] ) and ( [ notins ] ) .    a classical code expressed in quantum terms would traditionally comprise computational basis vectors that are eigenstates of @xmath9 , and therefore the operators mapping one codeword to another",
    "would be of the form @xmath101 as these are the only errors that have any effect .",
    "it then might seem odd that standard form for cws codes , the intuition of which is to make everything classical , would employ word operators and effective errors consisting only of @xmath9s .",
    "this choice is arbitrary ( one could exchange @xmath9 and @xmath64 and nothing in the formalism would be affected ) and is made since the usual form of a graph state stabilizer is to have one @xmath64 and some number of @xmath9s rather than the reverse .",
    "we hope this historical accident does not cause too much confusion going forward .",
    "the cws framework includes stabilizer codes , and allows them to be understood in a new way .",
    "we now show that any stabilizer code is a cws code , and give a method for determining if a cws code is also a stabilizer code .",
    "an @xmath2 $ ] stabilizer code with stabilizer generators @xmath102 and logical operations @xmath103 and @xmath104 , is equivalent to the cws code defined by @xmath105 and word @xmath106 where @xmath107 is a @xmath3-bit string .    to see that this cws code describes the original code ,",
    "note that the stabilizer state associated with @xmath5 is @xmath108 , while the codeword generated by @xmath109 acting on @xmath108 is @xmath110 .",
    "if the word of an @xmath18 cws code are an abelian group @xmath111 ( not containing @xmath112 ) , then the code is an @xmath113 $ ] stabilizer code .",
    "the stabilizer @xmath5 of the cws code is a maximal abelian subgroup of the paulis ( not containing @xmath112 ) therefore it is isomorphic to the group @xmath114 and the mapping from @xmath5 to @xmath115 is a clifford operation @xmath50 ( not necessarily local ) .",
    "this follows from the definition of the clifford group as the automorphisms of the pauli group . because this automorphism group allows one to achieve any bijective mapping that preserves commutation relations ( see chapter 4 of @xcite ) , the map can further be chosen to map @xmath111 to @xmath116 here we have made use of the facts that all @xmath117 anticommute with at least one @xmath22 ( which implies @xmath118 ) and that @xmath115 is maximal , which allows us to choose for @xmath119 any order @xmath12 group made only of @xmath9s we like ( since _ all _ products of @xmath64 s are in @xmath115 )",
    "note this nonlocal clifford mapping is not the same as the conversion to @xmath9s used in theorem [ theorem : graphstate ] .",
    "we can now choose @xmath120 , @xmath121 and @xmath122 as follows : @xmath123 the inverse clifford operation @xmath124 maps these to our stabilizer code with stabilizer @xmath125 , and logical operations @xmath126 and @xmath127 .",
    "it remains to show this is the same as the cws code we started with .",
    "@xmath125 is by construction a subgroup of @xmath5 ( @xmath120 is explicitly generated by a subset of the generators of @xmath115 ) and therefore stabilizes @xmath8 .",
    "@xmath125 also stabilizes all @xmath128 , @xmath129 , since @xmath125 and @xmath130 commute . using @xmath126 we see these states are exactly the basis states of the cws code",
    "we now give some examples of our construction and including all known nonadditive codes with good parameters .",
    "the celebrated @xmath131 $ ] quantum code @xcite can be written as a cws code using eqs .",
    "( [ stabilizerstabilizer ] ) and ( [ stabilizerws ] ) but another way of writing it demonstrates the power of the cws framework . take generators corresponding to a ring graph : @xmath132 this induces effective errors as follows .",
    "letting @xmath133 be the graph state corresponding to the unique simultaneous @xmath134 eigenvector of these generators , we have @xmath135 where all additions and subtractions are taken modulo 5 .",
    "the corresponding 15 classical errors are : @xmath136 we then must choose @xmath137 where the @xmath138s form a classical code capable of detecting pairs of these errors .",
    "since no pair of these errors produces @xmath139 the codewords @xmath140 and @xmath141 will serve , and together with the stabilizer ( [ ring ] ) completely define the code .",
    "since the @xmath142 code is known to be unique we need not otherwise check that our construction is equivalent to the traditional presentation of this code .",
    "we note also that for @xmath143 a ring code with codeword operators @xmath144 and @xmath145 gives a @xmath146 $ ] code .",
    "the first nonadditive quantum code was found in @xcite , and encodes a six - dimensional space into five qubits with a minimum distance of two .",
    "this outperforms the best additive five qubit distance two code , which can have an encoded dimension of at most four .",
    "the code was originally found as follows : it was known that the linear programming upper bound was exactly @xmath147 for a blocklength @xmath148 distance @xmath16 code , and in fact it was possible to completely determine what the weight enumerator @xcite of a code meeting this bound must be .",
    "the authors of @xcite then performed a numerical search for such a code , and managed to find one .",
    "the structure of the resulting code was mysterious , and generating larger codes in a similar fashion seemed intractable ( though @xcite showed how to construct a @xmath149 code from this code ) .",
    "as a cws code the @xmath15 code of @xcite becomes simple .",
    "we again use the ring stabilizer ( [ ring ] ) and will have to detect the induced errors ( [ ringclassicalerrors ] ) , but since we are seeking a distance-2 code we need only consider single errors rather than pairs . the classical codewords @xmath80 , @xmath150 , are @xmath151 and the code generated by @xmath152 and @xmath153 is locally clifford equivalent to the @xmath15 code of @xcite .",
    "the @xmath154 codes of @xcite are also cws codes whose graph state is the union of the ring graph and @xmath77 bell pair graphs , and whose classical codewords can be derived straightforwardly from the @xmath15 classical codewords .      a family of distance two codes was found in @xcite , which outperforms the family of @xcite for odd blocklengths of eleven or larger .",
    "the codes were originally described in terms of their codewords as follows .",
    "if @xmath155 , a basis of our code consists of vectors of the form @xmath156 where @xmath157 ranges over all n - bit vectors of odd weight less than @xmath158 and @xmath159 is the complement of @xmath160 , while if @xmath161 , we let @xmath157 range over even weight vectors of weight less than @xmath158 , leading to an encoded dimension of @xmath162 .    we now show that these are actually cws codes .",
    "indeed , the codeword stabilizer of this code will be generated by @xmath163 with the corresponding stabilizer state being equivalent to a ghz state , @xmath164 .",
    "the codeword are simply @xmath165 for each allowed @xmath157 , which can immediately be seen to generate , up to local unitaries , the same codewords as eq .",
    "( [ eq : sswwords ] ) . putting the stabilizer into standard form , we find that the graph state it describes corresponds to a star graph .      like the @xmath15 code ,",
    "the codeword stabilizer is of the form @xmath166 the associated classical code correcting the induced errors is : @xmath167",
    "in light of the excellent performance of ring - stabilizers for cws codes ",
    "the @xmath15 and @xmath17 are both of this form  we have studied larger blocklength codes based on this stabilizer .",
    "this leads to a new code that outperforms stabilizer codes for blocklength @xmath168 .",
    "the blocklength ten code has a codeword stabilizer generated by @xmath169 and has @xmath170 word of the form @xmath171 , with @xmath80 taken from the list @xmath172    that this code satisfies the required error correction conditions can be shown by the straightforward ( if tedious ) technique of verifying that the associated classical code corrects the classical noise model induced by the ring stabilizer .",
    "we now consider a cws code with a codeword stabilizer that is not of the ring form .",
    "in particular , our stabilizer will correspond to the double ring , with generators @xmath173    this leads to a @xmath8 that is a @xmath174 $ ] stabilizer state .",
    "our classical code @xmath85 giving the codeword s operators is @xmath175",
    "thus far , we have focused on the existence and structure of cws codes .",
    "we now address a question of fundamental importance : _ what is the complexity of encoding a cws code ? _ the answer we find is perhaps the strongest one could hope for : a cws code will have an efficient encoding circuit as long as there is an efficient encoding circuit for the _ classical _ code @xmath82 .",
    "we will use the fact @xcite that a graph state @xmath8 whose graph has edges @xmath56 is equal to @xmath176 where @xmath177 is the two qubit controlled phase gate , acting on qubits @xmath178 and @xmath3 : @xmath179 .",
    "let @xmath5 and @xmath82 define cws code @xmath180 , @xmath50 be a unitary encoding circuit for the classical code @xmath82 , and @xmath181 be the unitary mapping @xmath182 to @xmath8 .",
    "then , @xmath183 is an encoder for @xmath180 . in particular",
    ", since @xmath181 has complexity no more than @xmath184 , if @xmath50 has complexity @xmath185 , the complexity of our encoder is @xmath186 .",
    "the @xmath68th quantum codeword @xmath187 is given by @xmath188 where @xmath189 is the @xmath68th codeword of @xmath82 .",
    "so , @xmath190",
    "we have presented a new framework for quantum codes and shown how it encompasses stabilizer codes , elucidates the structure of the known good nonadditive codes , as well as generates new nonadditive codes with excellent performance .",
    "it should be noted , however , that there do exist quantum codes outside of our framework , for example those of @xcite .",
    "our codeword stabilized codes are described by two objects : first , the codeword stabilizer that without loss of generality can be taken to describe a graph state , and which transforms the quantum errors to be corrected into effectively classical errors . and second , a classical code capable of correcting the induced classical error model . with a fixed stabilizer state , finding a quantum code is reduced to finding a classical code that corrects the ( perhaps rather exotic ) induced error model .",
    "we also show that cws codes include all stabilizer codes .",
    "this new way of thinking of stabilizer codes may help to find new codes with good properties .",
    "in fact , this method has since been used @xcite to systematically categorize all codes of @xmath191 and to find a @xmath192 code as well as slightly better distance-2 codes .    in a future work",
    "we hope to expand our work in several new areas . we will give algorithms for finding codes ( some of which were employed to find the new codes presented here ) as well as bounds on the computational complexity of the algorithms .",
    "we also hope to find more new codes , especially of distance higher than three ."
  ],
  "abstract_text": [
    "<S> we present a unifying approach to quantum error correcting code design that encompasses additive ( stabilizer ) codes , as well as all known examples of nonadditive codes with good parameters . </S>",
    "<S> we use this framework to generate new codes with superior parameters to any previously known . </S>",
    "<S> in particular , we find @xmath0 and @xmath1 codes . we also show how to construct encoding circuits for all codes within our framework .    </S>",
    "<S> quantum error correction , nonadditive codes , stabilizer codes </S>"
  ]
}