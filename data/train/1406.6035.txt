{
  "article_text": [
    "refinement calculus @xcite is a powerful and expressive tool for reasoning about sequential programs .",
    "refinement calculus is based on a _ monotonic predicate transformer _ semantics which allows to model total correctness ( functional correctness and termination ) , unbounded nondeterminism , demonic and angelic nondeterminism , among other program features .",
    "the framework also allows to express compatibility during program composition ( e.g. , whether the postcondition of a statement is strong enough to guarantee the precondition of another ) and also to reason about program evolution and substitution via refinement .    as an illustrative example , consider a simple assignment statement performing division : @xmath2 .",
    "semantically , this statement is modeled as a predicate transformer , denoted @xmath3 .",
    "@xmath3 is a function which takes as input a predicate @xmath4 characterizing a set of program states and returns a new predicate @xmath5 such that if the program is started in any state in @xmath5 it is guaranteed to terminate and reach a state in @xmath4 ( that is , @xmath5 is the _",
    "weakest precondition _ of @xmath4 ) . for our division example",
    ", we would also like to express the fact that division by zero is not allowed . to achieve this",
    ", we can define the predicate transformer as follows : @xmath6 .",
    "having defined the semantics of the division statement , we can now compose it with another statement , say , a statement that reads the values of @xmath7 and @xmath8 from the console : @xmath9 .",
    "making no assumptions on what _ read _ does , we model it as the so - called @xmath10 statement , which assigns arbitrary values to program variables .",
    "formally , _ read _ is modeled as the predicate transformer : @xmath11 where @xmath12 and @xmath13 denote the universal and empty sets , respectively .",
    "now , what happens if we compose the two statements in sequence ? that is , @xmath14 .",
    "refinement calculus tells us that sequential composition of statements corresponds to function composition of their predicate transformers , so the semantics of the composition is @xmath15 , which can be shown to be equivalent to the predicate transformer @xmath16 , defined as @xmath17 for any @xmath4 .",
    "this indicates incompatibility , i.e. , the fact that the composition of the two statements is invalid .",
    "indeed , without any assumptions on _ read _ , we can not guarantee absence of division by zero .",
    "we can go one step further and reason about program substitution via refinement .",
    "assume we have another division statement , but this time it calculates only some approximation of the result : @xmath18 such that @xmath19 .",
    "we model this new division statement as a new predicate transformer @xmath20 defined as follows : @xmath21 .",
    "refinement calculus allows us to state and prove that @xmath3 refines @xmath20 , and conclude that the @xmath3 statement can substitute the @xmath20 statement without affecting the properties of the overall program .",
    "refinement calculus has been developed so far primarily for sequential programs . in this paper",
    "we present an extension of refinement calculus for _ reactive systems _",
    "denotationally , a reactive system can be seen as a system which accepts as input infinite sequences of values , and produces as output infinite sequences of values .",
    "operationally , a reactive system can be seen as a machine with input , output , and state variables , which operates in steps , each step consisting of reading the inputs , writing the outputs , and updating the state .",
    "our framework allows us to specify a very large class of reactive systems , including nondeterministic and non - receptive systems , with both safety and liveness properties , both denotationally and operationally .",
    "it also allows to define system composition and to talk about incompatibility , refinement , and so on . to illustrate these features , we provide an example analogous to the division example above .    [ example_intro]consider the two components shown in figure [ fig : incomp-1 ] and specified using the syntax of linear temporal logic @xcite .",
    "component @xmath22 specifies that its output @xmath7 is never less than zero , while component @xmath23 requires that its input is infinitely often equal to one ( the fact that the output of @xmath24 has the same label @xmath7 as the input means that @xmath24 sets its output to be equal to the input  provided the input requirement holds ) .",
    "the output of @xmath25 is connected to the input of @xmath24 . using our framework",
    ", we can show that this composition is invalid , that is , that @xmath25 and @xmath24 are incompatible , because the output guarantee of @xmath25 is not strong enough to satisfy the input requirement of @xmath24 .",
    "two incompatible systems ]    two compatible systems ( top ) , their composition ( middle ) , and a refinement ( bottom ) ]    the above is akin to behavioral type checking .",
    "we can also use our framework to perform behavioral type inference .",
    "we can deduce , for instance , that component @xmath26 from figure [ fig : comp-1 ] , which models a request - response property ( always @xmath27 implies eventually @xmath28 ) is compatible with component @xmath24 above , and infer automatically a new input requirement @xmath29 for the composite system @xmath30 .",
    "finally , we can reason about refinement , akin to behavioral subtyping .",
    "in the example of figure [ fig : comp-1 ] , we can show that the executable component @xmath31 which sets output @xmath28 whenever input @xmath27 refines the component @xmath30 , and therefore conclude that @xmath31 can substitute @xmath30 in any context .",
    "the key technical contribution of our paper , which allows us to develop a refinement calculus of reactive systems , is the notion of _ monotonic property transformers_. a property transformer is a function which takes as input an _ output property _ @xmath4 and returns an _ input property _ @xmath5 .",
    "properties are sets of traces , so that @xmath4 is a set of output traces and @xmath5 is a set of input traces . in other words , similarly to predicate transformers , which transform postconditions to preconditions , property transformers transform _ out - conditions _ to _ in - conditions_.    monotonic property transformers ( mpts ) provide the semantical foundation for system specification and implementation in our framework .",
    "we generally use higher order logic to specify mpts , but we also show how to mpts can be defined using formalisms more amenable to automation , such as linear temporal logic and _ symbolic transition systems _",
    "( similar to the formalism used by the popular model - checker nusmv ) .",
    "we also provide the basic operations on mpts : composition , compatibility , refinement , variable hiding , and so on .",
    "we study subclasses of mpts specified by input - output relations , and derive a number of interesting closure and other properties on them .",
    "finally , as an application of our framework , we show how it can be used to extend the relational interfaces framework of @xcite from only safety ( finite , prefix - closed ) properties , to also infinite properties and liveness .    in the sequel we use higher order logic as implemented in isabelle / hol @xcite to express our concepts .",
    "all results presented in this paper were formalized in isabelle , and our presentation translates directly into isabelle s formal language .",
    "the isabelle formalization is available from the archive of formal proofs      a number of compositional frameworks for the specification and verification of input - output reactive systems have been proposed in the literature . in the focus framework",
    "@xcite specifications are relations on input - output streams .",
    "focus is able to express infinite streams and liveness properties , however , it focuses on _ input - receptive _ systems , that is , systems where all input values are always legal .",
    "other compositional frameworks that also assume input - receptiveness are dill s _ trace theory _",
    "@xcite , _ io automata _ @xcite , and _ reactive modules",
    "our framework allows to specify non - input - receptive systems , where some inputs are sometimes illegal .",
    "for example , in the case of the division statement @xmath32 $ ] , we can write @xmath33 instead of @xmath34 . the conjunction specifies a non - input - receptive system where @xmath35 is an illegal input , whereas the implication specifies an input - receptive system .",
    "as argued in @xcite , the ability to specify illegal inputs is essential in order to obtain a lightweight verification framework , akin to type - checking . in particular",
    ", it allows to define a behavioral notion of component _ compatibility _ , which goes beyond syntactic compatibility ( correct port matching ) as illustrated by the examples given above .",
    "there are also compositional frameworks which allow to specify non - input - receptive systems . among such frameworks ,",
    "our work is inspired from refinement calculus , on one hand , and _",
    "interface theories _ on the other , such as _ interface automata _ @xcite and _ relational interfaces _ @xcite .",
    "these interface theories , however , can not express liveness properties .",
    "the same is true with existing extensions of refinement calculus to infinite behaviors such as _ action systems _",
    "@xcite , which do not have acceptance conditions ( say , of type bchi ) and therefore can not express general liveness properties .",
    "_ fair _ action systems @xcite , augment action systems with fairness assumptions on the actions , but it is unclear whether they can handle general liveness properties , e.g. , full ltl .",
    "our approach is based on a natural generalization from predicate to property transformers , and as such can handle liveness ( and more ) as part of system specification .",
    "we use capital letters @xmath36 , @xmath37 , @xmath38 , @xmath39 to denote types , and small letters to denote elements of these types @xmath40 .... we denote by @xmath41 the type of the boolean values @xmath42 and @xmath43 , and by @xmath44 the type of natural numbers .",
    "we use in general the sans - serif font to denote constants ( types and elements ) .",
    "we use @xmath45 , @xmath46 , @xmath47 , @xmath48 for the boolean operations .",
    "if @xmath36 and @xmath37 are types , then @xmath49 denotes the type of functions from @xmath36 to @xmath37 .",
    "we use a _ dot notation _ for function application , so we write @xmath50 instead of @xmath51 from now on . if @xmath52 is a function which takes the first argument from @xmath36 and the second argument from @xmath37 and the result is from @xmath53 , and if @xmath54 and @xmath55 then @xmath56 denotes the function @xmath57 applied to @xmath7 and the result applied to @xmath8 . according to this interpretation function application associates to the left ( @xmath58 ) and correspondingly the function type constructor ( @xmath59 ) associates to the right ( @xmath60 ) .",
    "we use also lambda notation for constructing functions .",
    "for example if @xmath61 is a natural expression then @xmath62 is the function which maps @xmath7 and @xmath8 to @xmath63 .",
    "we use the notation @xmath64 for the cartesian product of @xmath36 and @xmath37 , and if @xmath54 and @xmath55 , then @xmath65 is a pair from @xmath64 .",
    "predicates are functions returning boolean values ( e.g. , @xmath66 ) , and relations are predicates with at least two arguments . for a relation @xmath67 we denote by @xmath68 the predicate given by @xmath69 if @xmath70 is a relation with more than two arguments then we define @xmath71 similarly by quantifying over the last argument of @xmath70 : @xmath72 we extend point - wise the operations on @xmath41 to operations on predicates .",
    "for example , if @xmath5 is a predicate only on @xmath7 , i.e. , @xmath73 and @xmath4 is a predicate on @xmath7 and @xmath8 , i.e. , @xmath74 , then : @xmath75 and we also have in this case : @xmath76    we use @xmath13 and @xmath12 as the smallest and greatest predicates @xmath77    the composition of relations @xmath78 is denoted @xmath79 and it is a relation given by : @xmath80 we treat subsets of a type , and predicates with one argument as being the same and we use both notations @xmath81 and @xmath82 to express the fact that @xmath5 is true in @xmath7 . for constructing predicates",
    "we use lambda abstraction ( e.g. , @xmath83 ) , and for predicates with single arguments we use also set comprehension @xmath84 .",
    "we assume that @xmath38 is a type of program states .",
    "for example for imperative programs over some variables @xmath7 , @xmath8 , @xmath85 , @xmath39 , a state @xmath86 gives values to the program variables @xmath87 .",
    "in general , the systems that we consider may have different input and output variables , and we can also have different state sets . for a system with a variable @xmath7 , @xmath88 denotes the type of states which gives values to @xmath7 . for a state @xmath86",
    ", @xmath89 is the value of @xmath7 in @xmath90 and @xmath91 $ ] is new state obtained from @xmath90 by changing the value of @xmath7 to @xmath92 .    for reactive systems we model states as _ infinite sequences _ or _",
    "traces _ from @xmath38 .",
    "formally such an infinite sequence is an element @xmath93 where @xmath94 . for @xmath93 , @xmath95 , and @xmath96",
    "is given by @xmath97 .",
    "we consider a pair of traces @xmath98 as being the same as a trace of pairs @xmath99 .    in the next subsection",
    "we introduce _ linear temporal logic _ ( ltl ) which is the main logic that we use to specify reactive systems .",
    "linear temporal logic ( ltl ) @xcite is a logic used for specifying properties of reactive systems .",
    "in addition to the connectives of classical logic it contains modal operators referring to time .",
    "ltl formulas can express temporal properties like something is always true , or something is eventually true , and their truth values are given for infinite sequences of states .",
    "for example the formula @xmath100 ( always @xmath7 is equal to 1 ) is true for the infinite sequence @xmath101 if for all @xmath102 @xmath103 .",
    "the semantics of an ltl formula is the set of all sequences for which the formula is true . in this paper",
    "we use a semantic ( algebraic ) version of ltl . for us",
    "an ltl formula is a predicate on traces and the temporal operators are functions mapping predicates to predicates .",
    "we call predicates over traces ( i.e. , sets of traces ) _ properties_.    if @xmath104 are properties , then _ always _",
    "@xmath5 , _ eventually _ @xmath5 , _ next _ @xmath5 , and @xmath5 _ until _ @xmath4 are also properties and they are denoted by @xmath105 , @xmath106 , @xmath107 , and @xmath108 respectively .",
    "the property @xmath105 is true in @xmath101 if @xmath5 is true at all time points in @xmath101 , @xmath106 is true in @xmath101 if @xmath5 is true at some time point in @xmath101 , @xmath107 is true in @xmath101 if @xmath5 is true at the next time point in @xmath101 , and @xmath108 is true in @xmath101 if there is some time in @xmath101 when @xmath4 is true , and until then @xmath5 is true .",
    "formally we have : @xmath109    quantification for properties is defined in the following way @xmath110))\\ ] ] where @xmath92 ranges over infinite traces of @xmath7 values , and @xmath111.i=\\sigma_{i}[x:=a_{i}]$ ] .",
    "when @xmath5 is a predicate on traces @xmath7 and @xmath8 , then quantification is defined as normally in predicate calculus , as in @xmath112 .",
    "we lift normal arithmetic and logical operations to traces ( @xmath7 and @xmath8 ) in the following way @xmath113    if @xmath5 and @xmath4 are properties , then we have : @xmath114 and @xmath115 .",
    "we define the operator @xmath116 .",
    "intuitively , @xmath117 holds if , whenever @xmath5 holds continuously up to step @xmath118 , then @xmath4 must hold at step @xmath119 .    if @xmath5 and @xmath4 are properties , then we have    1 .",
    "@xmath120 2 .",
    "@xmath121 and @xmath122    using ltl properties we can express _ safety _ properties , expressing that _ something bad never happens _",
    "( e.g. , @xmath123  the temperature stays always below @xmath124 ) , as well as _",
    "liveness _ properties , expressing that",
    "_ something good eventually happens _",
    "( e.g. , @xmath125  infinitely often @xmath7 becomes @xmath126 ) .",
    "_ monotonic predicate transformers _ are a powerful formalism for modeling programs . a program @xmath127 from state space @xmath128 to state space @xmath129",
    "is formally modeled as a monotonic predicate transformer , that is , a monotonic function from @xmath130 , with a weakest precondition interpretation .",
    "if @xmath127 is a program and @xmath131 is a predicate on @xmath129 ( set of final states ) , then @xmath132 is the set of all initial states from which the execution of @xmath127 always terminates and it terminates in a state from @xmath4 . _",
    "monotonic boolean transformers _ ( mbts ) @xcite is a generalization of monotonic predicate transformers , where instead of predicates @xmath133 arbitrary complete boolean algebras are used .",
    "mbts are monotonic functions from a complete boolean algebra @xmath134 to a complete boolean algebra @xmath135 .    in this section",
    "we introduce _",
    "monotonic property transformers _ ( mpts ) , and we use them to model input - output reactive systems .",
    "mpts are mbts from the complete boolean algebra of @xmath136 properties ( @xmath137 ) to the complete boolean algebra of @xmath88 properties ( @xmath138 ) , where @xmath7 and @xmath8 are the input and output variables , respectively .",
    "if @xmath127 is a reactive system with input variable @xmath7 and output variable @xmath8 , then a _ legal execution _ of @xmath127 takes as input a sequence of values for @xmath7 , @xmath139 , and produces a sequence of values for @xmath8 , @xmath140 .",
    "this execution may be nondeterministic , that is , for the same input sequence @xmath101 we can obtain different output sequences @xmath141",
    ". the execution of @xmath127 from @xmath101 may also _ fail _ if @xmath101 does not satisfy some requirements on the input variables . as a property transformer ,",
    "the system @xmath127 is applied to a property @xmath142 , i.e. , to a set of sequences over the output variable @xmath8 .",
    "then , @xmath127 returns the set of all sequences over the input variable @xmath7 from which all executions of @xmath127 do not fail and produce sequences in @xmath4 .",
    "@xmath127 must be monotonic in the following sense : interpreting properties as sets , @xmath127 is _ monotonic _ if for any two properties @xmath143 , if @xmath144 then @xmath145 .",
    "monotonic property transformers are appropriate primarily as semantic descriptions of systems . in practice",
    ", we also need some _ syntax _ for describing systems in general , and property transformers in particular . in this paper , we use two types of syntax : ltl , and _ symbolic transition systems_. property transformers based on symbolic transition systems will be discussed in detail in section [ sec_sts ] .",
    "property transformers based on ltl are a special case of _ relational property transformers _",
    ", discussed in detail in section [ sec_relational - property - transformers ] . here",
    "we provide an illustrative example .",
    "[ ex_first_property_transf]consider again component @xmath24 from example [ example_intro ] , figure [ fig : incomp-1 ] .",
    "suppose variable @xmath7 is a boolean , taking values in the set @xmath146 , i.e. , @xmath147 .",
    "then , @xmath24 can be modeled as a property transformer which from the set of properties @xmath148 to the same set ( because @xmath24 copies its input to its output , provided the requirements on the input are satisfied ) .",
    ". then @xmath150 must contain exactly those infinite input sequences @xmath151 such that : ( 1 ) @xmath101 satisfies the input requirement expressed by the ltl property @xmath152 , i.e. , @xmath101 must contain infinitely many 1 s ; and ( 2 ) @xmath101 is in @xmath4 , since @xmath24 copies its input to its output .",
    "written formally , @xmath153 . clearly , @xmath24 is a monotonic property transformer , as the larger the set @xmath4 is , the larger @xmath150 is .",
    "[ ex_property_transformers ] example [ ex_first_property_transf ] provided the explicit definition of the property transformer for a certain system , thereby also essentially completely defining that system . using property transformers",
    ", we can also specify systems _ implicitly _",
    ", by imposing constraints that the property transformers of these systems must satisfy .",
    "in this way , we can specify the fact that a certain system must exhibit various properties that we are interested in .",
    "for example , the specification of a system @xmath127 that guaranties the _ liveness _ property that the output boolean variable @xmath8 is true infinitely often regardless of the input , is given by @xmath154    note that the above equation does not define @xmath127 completely , it only specifies a constraint that @xmath127 ( interpreted as a property transformer ) must satisfy .",
    "below , in section [ sub : basic - operations - on ] we give a complete definition of a mpt which satisfies the requirement above .",
    "similarly , the specification of a system @xmath155 that guaranties the liveness property that the output boolean variable @xmath8 is true infinitely often when the integer input variable @xmath7 is equal to one infinitely often , is given by @xmath156      the point - wise extension of the boolean operations to properties , and then to monotonic property transformers gives us a _",
    "complete lattice _ with @xmath157 as the lattice _",
    "order _ , @xmath158 as the _ greatest lower bound _ , or _",
    ", @xmath159 as the _ least upper bound _ , or _ join _",
    ", @xmath16 as the _ bottom _ element , and @xmath160 as the _ top _ element .",
    "if @xmath127 and @xmath161 are monotonic property transformers , and @xmath4 is a property , then these elements are formally defined by    @xmath162 note that @xmath158 and @xmath159 preserve monotonicity .",
    "also note that , for any @xmath127 , @xmath163 and @xmath164 , so indeed @xmath16 and @xmath160 are the bottom and top elements , respectively .",
    "the transformer @xmath16 does not guarantee any property .",
    "for any property @xmath4 , we have @xmath165 , i.e. , there is no input sequence for which @xmath16 will produce an output sequence from @xmath4 . on the other hand @xmath160 can establish any property @xmath4 ( for any @xmath166 @xmath167 ) .",
    "the problem with @xmath160 is that it can not be implemented .",
    "all these lattice operations are also meaningful as operations on reactive systems .",
    "the order of this lattice ( @xmath168 ) gives the _ refinement relation _ of reactive systems .",
    "if @xmath168 , then we say that @xmath161 _ refines _",
    "@xmath127 , or @xmath127 is _ refined _ _ by _ @xmath161 .",
    "if @xmath161 refines @xmath127 then we can replace @xmath127 with @xmath161 in any context .",
    "note that in some works ( e.g. , @xcite ) the notation is inverted , with @xmath168 denoting @xmath127 refines @xmath161 , instead of @xmath161 refines @xmath127 as we employ here . in this paper",
    "we follow the same convention as in @xcite , which is also consistent with the definition of refinement for property transformers : @xmath168 iff @xmath132 is a subset of @xmath169 .    the interpretation of the lattice order as refinement follows from the modeling of reactive systems as monotonic property transformers . for example",
    "if we assume that @xmath127 and @xmath155 introduced in example [ ex_property_transformers ] are completely defined by @xmath170 and @xmath171 then @xmath127 and @xmath155 are monotonic and @xmath127 refines @xmath155 ( @xmath172 ) . in this example",
    "we see that if @xmath155 is used within some context where for certain inputs it guaranties outputs where @xmath8 is true infinitely often , then @xmath127 can replace @xmath155 because @xmath127 guaranties the same property of the output regardless of its input .    the operations @xmath158 and @xmath159 model ( _ unbounded _ ) _ demonic _ and _ angelic _ _ nondeterminism _ or _",
    "choice_. the interpretation of the demonic choice is that the system @xmath173 is correct ( i.e. , satisfies its specification ) if both @xmath127 and @xmath161 are correct . in this choice",
    "someone else ( the demon ) can choose to execute @xmath127 or @xmath161 , so they must both be correct . on the other hand the angelic choice @xmath174 is correct if one of the systems @xmath127 and @xmath161 are correct . in this choice",
    "we have the control over the choice , and we assume that we always choose the correct alternative .",
    "unbounded nondeterminism means that we could have unbounded choices as for example in @xmath175 where @xmath176 is infinite .",
    "for example , assume that we have two systems @xmath127 and @xmath155 which compute the factorial of @xmath119 , but @xmath127 computes the correct result only for @xmath177 and @xmath155 computes the correct result only for @xmath178 .",
    "formally we have @xmath179 the demonic choice of @xmath127 and @xmath155 is capable of computing the factorial only for numbers between @xmath180 and @xmath181 , while the angelic choice will compute the factorial for all natural numbers @xmath119 .",
    "_ sequential composition _ of two systems @xmath127 and @xmath161 is simply the functional composition of @xmath127 and @xmath161 viewed as property transformers ( @xmath182 ) .",
    "we denote this type of composition by @xmath183 ( @xmath184 ) . to be able to compose @xmath127 and @xmath161",
    ", the type of the output of @xmath127 must be the same as the type of the input of @xmath161 .",
    "the system @xmath185 defined by @xmath186 is the neutral element for sequential composition : @xmath187 it is easy to see that sequential composition preserves monotonicity , that is , if @xmath127 and @xmath161 are both monotonic property transformers , then so is @xmath183 .",
    "two systems @xmath127 and @xmath161 are _ incompatible _",
    "the sequential composition @xmath183 ) if @xmath188    intuitively , @xmath127 and @xmath161 are compatible if the outputs of @xmath127 can be controlled so that they are legal inputs for @xmath161 . controlling the outputs of @xmath127 might mean restricting its own legal inputs .",
    "[ ex_compatibility]if for example we have @xmath127 and @xmath161 given by @xmath189 then @xmath190 , for any @xmath4",
    ". therefore , @xmath127 and @xmath161 are in this case incompatible .",
    "this is because @xmath161 requires its input to be smaller than 10 , but @xmath127 can only guarantee that its output will be greater than 5 , and there is no way to restrict the input of @xmath127 to make this guarantee stronger .    on the other hand , assuming that the input and output of @xmath127 and @xmath161 have the same type , @xmath161 and @xmath127 are compatible w.r.t .",
    "the reverse composition , i.e. , @xmath191 is not @xmath16 . indeed , we have @xmath192 , for any @xmath4 .    for a property transformer @xmath127 ,",
    "the _ fail _ of @xmath127 , denoted @xmath193 , is the set of _ illegal _ input sequences , i.e. , the set of input sequences for which the system produces no output , or _ fails _ to establish any output property . formally : @xmath194    for example , the fail of @xmath160 is @xmath13 and the fail of @xmath16 is @xmath12 .    for a property transformer @xmath127 , the _ guard _ of @xmath127 , denoted @xmath195 ,",
    "is the set of input sequences for which the system does not behave _ miraculously_. formally : @xmath196    for example , the guard of @xmath160 is @xmath13 and the guard of @xmath16 is @xmath12 . to see the intuition behind the definition of guard , observe that @xmath197 is the set of input sequences for which @xmath127 is guaranteed to establish @xmath13 , that is , the empty property , and therefore by monotonicity of @xmath127 also any other output property . in other words , @xmath197 is the set of inputs for which @xmath127 behaves miraculously , since the empty property @xmath13 can not be established .",
    "for instance , taking @xmath127 and @xmath161 to be as defined in example [ ex_compatibility ] , we have : @xmath198 , @xmath199 , and @xmath200      we now define two special types of property transformers which will be used to form more general property transformers by composition . for @xmath104 and @xmath201",
    "we define the _ assert property transformer _",
    "@xmath202 , and the _ demonic update property transformer _ @xmath203 as follows : @xmath204 the assert transformer @xmath205 models a system which , given input sequence @xmath101 , produces @xmath101 as output when @xmath206 is true , and it fails otherwise . in other words , only inputs satisfying @xmath5 are legal for the assert system . the demonic update transformer @xmath207 models a system which establishes a post condition @xmath4 when given as input a sequence @xmath101 if all sequences @xmath141 with @xmath208 are in @xmath4 .",
    "note that the assert and demonic update property transformers are monotonic , for any @xmath5 and @xmath70 .",
    "the property transformer for component @xmath24 of figure [ fig : incomp-1 ] , discussed already in example [ ex_first_property_transf ] , is an example of an assert property transformer @xmath209 , where @xmath206 holds iff @xmath101 satisfies the ltl formula @xmath152 .",
    "component @xmath31 of figure [ fig : comp-1 ] is an example of a demonic update property transformer @xmath210 $ ] , where @xmath70 is the input - output trace relation corresponding to the ltl formula @xmath211 .",
    "let us now introduce some preliminary syntactic notations to describe the two kinds of property transformers introduced above .",
    "let @xmath212 be an expression in @xmath7 and @xmath8 , for example , the ltl formula @xmath213 . recall that @xmath214 denotes the function @xmath215 that takes two sequences @xmath7 and @xmath8 and returns true iff these two sequences satisfy the ltl formula .",
    "since @xmath70 is also an input - output relation on sequences , it defines the demonic property transformer @xmath210.$ ] however , a notation such as @xmath216 $ ] may be heavier than necessary . therefore",
    ", we introduce a lighter notation , namely , @xmath217 . in general , for any expression @xmath212 in @xmath7 and @xmath8 , we use notation @xmath218 as equivalent to @xmath219 .",
    "this notation also extends to systems with more than one inputs or outputs .",
    "for example , if @xmath212 is @xmath220 , and @xmath221 are the inputs while @xmath85 is the output , then @xmath222 .    for assert property transformers",
    "we introduce similar lighter notation . if @xmath223 is an expression in @xmath7 then @xmath224 .",
    "for example , if @xmath223 is @xmath225 , then @xmath226 . note that a notation such as @xmath227 is ambiguous , as it could mean the set of all , say , real numbers smaller than 1 , or the assert property transformer @xmath228 .",
    "we will still use such notation , however , and such ambiguity will be resolved from the context .",
    "note also that in notations such as @xmath229 and @xmath218 , the variables @xmath7 and @xmath8 are bound . however , when we compose some of these property transformers we will try whenever possible to use the same name for the output variables of a transformer which are input to another transformer .",
    "for example , we will use the notation : @xmath230 instead of the equivalent one : @xmath231 sometimes we also need demonic transformers that copy some of the input variables into some of the output variables , as in , for example @xmath232 in this case , we drop the condition @xmath233 from the relation of @xmath127 and we simply use the same name for @xmath7 and @xmath8 : @xmath234 if we want to rearrange the input variables into the output variables and if we want to drop some input variables and introduce some new arbitrary variables , then we use syntax like the following : @xmath235 this notation stands for @xmath236\\ ] ] which is equivalent to @xmath237\\ ] ] if @xmath127 starts on a tuple where the first component is the same as the last component ( @xmath238 ) , then @xmath127 returns @xmath239 such that @xmath240 . on the other hand",
    "if @xmath127 starts on a tuple where the first component is different from the last component , then @xmath127 behaves miraculously .      if @xmath241 , @xmath201 , and @xmath242 , then    1 .",
    "[ enu : assert - dem - a-1]@xmath243 ( @xmath185 is both a demonic update and an assert transformer ) 2 .",
    "@xmath244 , and @xmath245 ( @xmath160 is a demonic update , and @xmath16 is an assert transformer ) 3 .",
    "[ enu : assert - dem - b-1]@xmath246 and @xmath247 ( assert transformers are closed under sequential composition ) 4 .",
    "@xmath248 and @xmath249\\comp[y\\leadsto z\\mid r']=[x\\leadsto z\\mid\\exists y : r\\land r']$ ] ( demonic updates are closed under sequential composition ) 5 .",
    "[ enu : assert - dem - f-1]@xmath250 , and @xmath251 ( calculating the gard of assert and domonic update transformers ) 6 .",
    "@xmath252 and @xmath253=\\bot$ ] ( calculating the fail of assert and domonic update transformers )",
    "a _ relational property transformer _ ( rpt ) is a property transformer of the form @xmath254 .",
    "the assert transformer @xmath205 imposes the restriction @xmath5 on the input sequences , and the demonic update @xmath207 nondeterministically chooses output sequences according to the relation @xmath70 . for a rpt @xmath255",
    "we call @xmath5 the _ precondition _ of @xmath127 and @xmath70 the _ input - output relation _ of @xmath127 . for a rpt",
    "@xmath254 we use the notation @xmath256 .    for rpts",
    "we introduce also syntactic notation similar to the one introduced for assert and demonic transformers : @xmath257    note that every assert property transformer @xmath209 is a relational property transformer , because @xmath258 $ ] .",
    "also , every demonic update property transformer is a relational property transformer , because @xmath210=\\{x\\mid\\tru\\}\\comp[r]$ ] .",
    "also note that every relational property transformer is by definition monotonic .",
    "this is because every assert transformer is monotonic , every demonic update transformer is monotonic , and monotonicity is preserved by sequential composition .",
    "finally , note that , as a special case , property @xmath5 and relation @xmath70 can be described by ltl formulas .",
    "this allows us to describe rpts syntactically , by means of ltl formulas .",
    "this is illustrated in the example that follows .",
    "[ ex_division_transformers]consider again the division statement @xmath2 discussed in the introduction . using ltl and the syntax introduced above , we can define several variants of property transformers which perform division on sequences of input pairs @xmath7 and @xmath8 , as follows : @xmath259\\\\ s_{2 } & = & \\{x , y\\leadsto z\\mid\\always y\\ne0\\mid\\always(y\\ne0\\land z = x / y ) ] & = \\{x , y\\mid\\always y\\ne0\\}\\comp s_{1 } \\end{array}\\ ] ] @xmath260 and @xmath261 are different property transformers .",
    "both are relational , but they have different guards and fails .",
    "specifically , @xmath262 , whereas @xmath263 .",
    "this means that any input trace is legal for @xmath260 whereas only traces where @xmath8 is never zero are legal for @xmath261 . on the other hand , @xmath264 , whereas @xmath265 .",
    "this means that @xmath261 never behaves miraculously , whereas @xmath260 behaves miraculously when the input assumption @xmath266 is violated .",
    "the next theoremstates some important results , in particular regarding the compositionality ( i.e. , closure w.r.t .",
    "composition and other operations ) of relational property transformers .",
    "[ lem : assert - demonic]let @xmath267 be properties and @xmath268 be relations on sequences of appropriate types .",
    "then :    1 .",
    "@xmath269 ( relational property transformers are closed under sequential composition ) 2 .   [",
    "enu : assert - dem - d]@xmath270 ( relational property transformers are closed under demonic choice ) 3 .",
    "[ enu : assert - dem - c]@xmath271 ( precondition can be used in the input - output relation , e.g. , for simplification ) 4 .",
    "[ enu : assert - dem - e]@xmath272 ( necessary and sufficient condition for refinement ) 5 .",
    "[ enu : assert - dem - g]@xmath273 ( symbolic expression for the guard ) 6 .",
    "@xmath274 ( symbolic expression for the fail predicate )      relational property transformers are a strict subclass of monotonic property transformers , but they still allow to describe systems that may behave _",
    "an example of a transformer that may behave miraculously is transformer @xmath260 defined in example [ ex_division_transformers ] .",
    "often we are interested in systems that are guaranteed to never behave miraculously , i.e. , in systems defined by transformers @xmath127 such that @xmath199 . in these cases we use relational property transformers of the form @xmath275 .",
    "we call these rpts _ guarded _ :    the _ guarded system _ of a relation @xmath70 is the relational property transformer @xmath276 .    for guarded systems we also introduce a notation similar to the notation introduced for relational property transformers :",
    "@xmath277    it is worth pointing out that the property transformer @xmath275 is as general as @xmath278 because we have @xmath279 :    00.00.0000    @xmath278    \\{theorem [ lem : assert - demonic ] }    @xmath280    \\{theorem [ lem : assert - demonic ] }    @xmath281    the theorem that follows states several important closure properties for guarded systems .",
    "[ thm : grd - sysnew]if @xmath5 is a property and @xmath268 are relations of appropriate types , then    1 .",
    "@xmath282 ( guarded systems never behave miraculously ) 2 .",
    "@xmath283 and @xmath284 ( @xmath16 and @xmath185 are guarded ) 3 .",
    "@xmath285 and @xmath286 ( assert transformers are guarded and assert can be moved inside a guarded transformer ) 4 .",
    "@xmath287 ( guarded systems are closed under sequential composition ) 5 .",
    "@xmath288 ( guarded systems are closed under demonic choice )    note that part 3 of the above lemma implies that assert transformers are special cases of guarded systems .",
    "however , a demonic update is generally not a guarded system .",
    "for instance , we have @xmath289 .",
    "a less pathological example is the demonic update transformer @xmath260 from example [ ex_division_transformers ] , which is also not a guarded system , because it behaves miraculously when @xmath8 becomes 0 . as the following lemma states , demonic updates are guarded systems if and only if they impose no requirements on the inputs .",
    "[ lem : grd - sys - dem]the demonic update transformer @xmath207 is a guarded system if and only if @xmath290 and in this case we have @xmath291 .",
    "[ ex_guarded]here are some examples of guarded systems :    * @xmath292 : this demonic update transformer corresponds to a system which accepts any input sequence , and may generate an arbitrary output sequence .",
    "@xmath10 is a guarded system because it imposes no requirements on its input .",
    "* @xmath293 : this assert transformer corresponds to a system which requires its boolean input to be infinitely often true .",
    "* @xmath294 : this system corresponds to the sequential composition of the previous two ; it requires the input to be infinitely often true , and it makes no guarantees on the output ( i.e. , it can generate any output sequence ) .",
    "* @xmath295 : this demonic update transformer corresponds to a system which accepts any input sequence , and may generate an arbitrary output sequence , provided the request - response property _ for every input there is eventually an output _ is satisfied .",
    "the fact that all these systems are guarded follows from theorem [ thm : grd - sysnew ] and lemma [ lem : grd - sys - dem ] . note that @xmath296 illustrates the ability of our framework to express unbounded nondeterminism since , for a given input sequence @xmath7 , there is an infinite set of @xmath8 sequences that satisfy the request - response ltl formula .",
    "( we can also express unbounded nondeterminism for systems with infinite data types . )    for the above systems we have the following properties :    * @xmath297 : this means that @xmath10 and @xmath298 are incompatible .",
    "indeed , since @xmath10 guarantees nothing about its output , it can not meet the input requirements of @xmath298 .",
    "* @xmath299 : for the same reason as above , @xmath10 and @xmath300 are also incompatible . *",
    "@xmath301 : this says that @xmath296 and @xmath300 are compatible , and in fact that there sequential composition is equivalent to @xmath300 .",
    "this is indeed the case , because , in order to meet the input requirements of @xmath300 , the @xmath296 component must ensure that its output is infinitely often true .",
    "the only way for @xmath296 to achieve that is to impose a requirement on its own input , namely , that its own input is infinitely often true as well .",
    "since the names of input and output variables do not matter for the property transformer semantics , the result is identical to the property transformer @xmath300 .",
    "having introduced guarded systems , we can now give formal semantics to the components and diagrams introduced in figures [ fig : incomp-1 ] and [ fig : comp-1 ] , from example [ example_intro ] .",
    "the semantics of the components ( boxes ) in these figures are guarded monotonic property transformers , defined by ltl formulas .",
    "in particular , a component labeled with some formula @xmath302 corresponds to the guarded transformer @xmath303 .",
    "for instance , component _ c _ introduced in figure [ fig : comp-1 ] corresponds to the guarded transformer @xmath304 , which is equivalent to the transformer @xmath296 from example [ ex_guarded ] .",
    "( note that @xmath296 uses @xmath7 as the input and @xmath8 as the output , whereas in @xmath305 it is the other way around .",
    "this difference does not matter , as input and output variables are bound ; semantically , the two systems define identical property transformers . )    we can also use some of the established results to reason about such components formally .",
    "for example , let us apply the results of theorem [ lem : assert - demonic ] to see how checking refinement of systems specified in ltl can be reduced to checking satisfiability of quantified ltl formulas .",
    "consider again example [ example_intro ] , and in particular components @xmath30 and @xmath31 from figure [ fig : comp-1 ] .",
    "let @xmath306 be the ltl formula of @xmath30 and @xmath307 be the ltl formula of @xmath31 . then , checking that @xmath31 refines @xmath30 amounts to checking @xmath308 . by theorem [ lem : assert - demonic ] ,",
    "part [ enu : assert - dem - e ] , checking @xmath308 is equivalent to checking validity of the formula @xmath309 , where @xmath310 , for @xmath311 .",
    "the formulas @xmath312 and @xmath313 can be obtained from @xmath306 and @xmath307 by existential quantification of the output variables .",
    "for example , @xmath314 ) . in this specific example",
    ", quantifiers can be eliminated in both cases of @xmath312 and @xmath313 , and this results in two pure ltl formulas : @xmath315 and @xmath316 . in general , however , ltl is not closed under quantifier elimination @xcite .",
    "therefore , @xmath317 is generally an ltl formula with quantifiers . checking validity of @xmath317 amounts to checking ( un)satisfiability of @xmath318 .",
    "satisfiability of quantified ltl is decidable , and methods such as those presented in @xcite can be used for that purpose .",
    "we can also use some of the established results to reduce checking compatibility of components to checking satisfiability of formulas of the appropriate logic , as the following theorem states :    [ thm_compatibility]for property transformers @xmath127 and @xmath161 , and properties and relations @xmath5 , @xmath319 , @xmath70 , and @xmath320 , of appropiate types , we have :    1 .   if @xmath127 is monotonic , then @xmath321 iff @xmath322 .",
    "2 .   if @xmath127 and @xmath161 are monotonic , then @xmath127 and @xmath161 are incompatible with respect to @xmath183 iff @xmath323 .",
    "3 .   [ enu_thm_compatibility]@xmath256 and @xmath324 are incompatible with respect to @xmath325 iff @xmath326 .",
    "4 .   @xmath327 and @xmath328 are incompatible with respect to @xmath329 iff @xmath330 .    for instance ,",
    "part [ enu_thm_compatibility ] of theorem [ thm_compatibility ] states that the composition of two relational property transformers @xmath331 is valid ( i.e. , the two are compatible ) iff the formula @xmath332 is satisfiable .",
    "so far , we have introduced ( relational and guarded ) monotonic property transformers and showed how these can be defined using ltl . as a language ,",
    "ltl is often more appropriate for system specification , and less appropriate for system implementation . for the latter purpose ,",
    "it is often convenient to have a language which explicitly refers to state variables and allows to manipulate them , e.g. , by defining the next state based on the current state and input . in this section",
    "we introduce a _",
    "symbolic transition system _ notation which allows to do this , and show how this notation can be given semantics in terms of property transformers .    for example , suppose we want a counter which accepts as input infinite sequences of boolean values , and returns infinite sequences of natural numbers where every output is the number of true values seen so far in the input .",
    "moreover , we want this counter to accept inputs where the number of true values is bounded by a given natural number @xmath119 .",
    "if @xmath333 is the number of trues in @xmath334 , then this system can be defined in the following way : @xmath335 although this system is defined globally , when computing @xmath336 we only need to know @xmath337 , and we need to know how many true values we have seen so far in the input .",
    "we can store the number of true values seen so far in a _ state variable _ @xmath338 .",
    "then , it would be natural to define the counter _ locally _ , that is , define _ one step _ of the counter , as follows : @xmath339\\ ] ] where @xmath340 is the index of the step , and we can assume that initially @xmath341 . in the above definition , @xmath342 refers to the _ current _ state ( i.e. , the state at current step @xmath340 ) and @xmath343 refers to the _ next _ state ( i.e. , the state at next step @xmath344 ) , while @xmath337 refers to the current input and @xmath336 refers to the current output ( both at current step @xmath340 ) . at every step the assert statement @xmath345 tests if @xmath342 is less or equal to @xmath119 .",
    "if this is false then the system fails because the input requirement that the number of true values never exceeds @xmath119 is violated .",
    "if @xmath346 then we calculate the next state value @xmath343 and the output value @xmath336 .",
    "generalizing from this example , a _",
    "symbolic transition system _ is a tuple @xmath347 , formed by a predicate @xmath348 , a predicate @xmath349 , and a relation @xmath350 , where @xmath7 is the input , @xmath338 is the current state , @xmath351 is the next state , and @xmath8 is the output .",
    "the predicate @xmath352 is called the _ local initialization predicate _ of the system , the predicate @xmath5 is called the _ local precondition _ of the system , and @xmath70 is called the _ local input - output relation _ of the system . the intuitive interpretation of such a system is that we start with some initial state @xmath353 and we are given some input sequence @xmath354 , and",
    "if @xmath355 is true , then we compute the next state @xmath356 and the output @xmath357 such that @xmath358 is true .",
    "next , if @xmath359is true , then we compute @xmath360 and @xmath361 such that @xmath362 is true , and so on . if at any step @xmath363 is false , then the computation fails , and the input @xmath354 is not accepted .",
    "note that the computation defined by the relation @xmath70 can be nondeterministic in both next state @xmath351 and output @xmath8 .",
    "that is , for given values @xmath7 and @xmath338 for the input and current state , there could be multiple values for the next state @xmath351 and output @xmath8 such that @xmath350 is true .",
    "we must carefully account for this non - determinism when defining the property transformer based on such a symbolic transition system . to see the complications that may arise , consider another example :",
    "@xmath364 in this system , if the current state is true then we choose arbitrarily a new state @xmath351 and we copy the input @xmath7 into the output @xmath8 .",
    "if the system chooses @xmath365 then in the next step the system will fail , regardless of the input .",
    "this example shows that in a nondeterministic system , for the same input there could be different choices of internal states such that in one case the system succeeds while in another it fails . in the example above the choice of state sequence @xmath366 results in a successful computation , but",
    "all other choices of state sequences fail . in our definition of property transformers ,",
    "we accept an input only if _ all _ choices of internal states lead to no failures .",
    "formally , we say that an input sequence @xmath367 is _ illegal _ for a symbolic transition system if there is some @xmath368 and some choice @xmath369 of states and @xmath370 of outputs such that @xmath371 and @xmath372 and @xmath373 . for technical reasons ,",
    "we need to generalize @xmath5 to be a predicate not only on the current state and input , but also on the next state ( the need for this will become clear in the sequel , see theorem [ thm : localsys - repr ] and discussion that follows ) . with this generalization",
    ", we define the @xmath374 predicate on symbolic transition systems and input sequences , as follows : @xmath375    we can also formalize a _ run _ of a symbolic transition system , using the predicate @xmath376 . for sequences",
    "@xmath338 , and @xmath8 , the predicate @xmath377 is defined by : @xmath378 where , recall , @xmath379 denotes the sequence @xmath380 , i.e. , the sequence of states starting from the second state @xmath356 instead of the initial state @xmath381 .",
    "if the predicate @xmath377 is true we say that there is a _ run _ of the system with the inputs @xmath7 , the outputs @xmath8 and the states @xmath338 .",
    "we can now define monotonic property transformers based on symbolic transition systems as follows :    [ def_local_transformer]consider a symbolic transition system described by @xmath347 .",
    "such a system defines a monotonic property transformer called a _ local property transformer , _ and denoted @xmath382 , as follows : @xmath383 what the above definition states is that an input sequence @xmath7 is in the set of input sequences of @xmath382 that are guaranteed to establish @xmath4 iff : ( 1 ) @xmath7 is legal ; and ( 2 ) for all choices of state traces @xmath338 and output traces @xmath8 , if @xmath381 satisfies @xmath352 , and if there is a run of the system with the inputs @xmath7 , the outputs @xmath8 and the states @xmath338 , then @xmath8 must be in @xmath4 .    before proceeding ,",
    "let us make a remark on why we use similar , but different , notation for relational property transformers and for local property transformers .",
    "in the case of relational property transformers we use notation such as @xmath384 . here ,",
    "@xmath5 and @xmath70 are predicates over _ sequences _ ( traces ) . for instance",
    ", @xmath5 might be the ltl formula @xmath100 . in the case of local property transformers",
    "we use notation such as @xmath382 . here ,",
    "@xmath385 , and @xmath70 are local predicates over ( input , output , and state ) _",
    "variables_. for example , @xmath5 in this case might be the predicate @xmath386 .",
    "note that so far our definition of symbolic transition systems is essentially semantic , since @xmath387 are semantic objects . in practice",
    ", we may use a syntax such as boolean expressions for these elements .",
    "this is essentially the language used in symbolic model - checking tools like , say , nusmv .",
    "if @xmath388 @xmath223 , and @xmath212 are boolean expressions possibly containing free the variables @xmath338 and @xmath389 and @xmath390 , respectively then we define a syntax to describe local property transformers similar to the syntax we used for relational and guarded property transformers : @xmath391    for instance , we can define the property transformer for the counter system discussed in the beginning of this section as follows : @xmath392 we can also prove that the non - deterministic example discussed above is equivalent to the @xmath16 transformer : @xmath393 that is , for all input sequences this system fails .    for a symbolic transition system @xmath347 , the set of input sequences for which its local property transformer @xmath382 fails is equal to the set of its illegal input sequences :",
    "@xmath394      the definition of a local property transformer is close to our intuition of how a system with state should operate , step by step , however , it is difficult to see immediately from this definition whether local transformers belong to the class of relational property transformers .",
    "the following theorem shows that this is indeed the case :    [ thm : localsys - repr]for any symbolic transition system @xmath347 , we have : @xmath395    theorem [ thm : localsys - repr ] shows that a local property transformer @xmath382 can be expressed as a sequential composition of assert and update transformers . since the latter are special cases of relational transformers , and relational transformers are closed by sequential composition , this shows that local property transformers are relational .",
    "moreover , the assert and update transformers used in the right - hand side of theorem above are constructed by applying some temporal operators to the _ local _ precondition @xmath5 and the _ local _ input - output relation @xmath70 . here , @xmath5 and @xmath70 are _ local _ in the sense that they refer only to one step , i.e. , they are predicates on state , input and output variables , and not on infinite sequences .",
    "theorem [ thm : localsys - repr ] also justifies our earlier generalization of the local precondition to be a function not only on the current state and the input , but also on the next state .",
    "this is so because the precondition @xmath71 depends anyway on the next state @xmath396 .",
    "we call the precondition @xmath397 from the representation of the local system @xmath382 the _ global precondition _ of @xmath382 .",
    "similarly @xmath398 is the _ global input - output relation _ of @xmath382 .",
    "an additional benefit of theorem [ thm : localsys - repr ] is that it makes checking refinement of local systems against their specification ( or against another system ) easier .",
    "for example , suppose that we want to prove a refinement like @xmath399 if we use the original definition of local system ( definition [ def_local_transformer ] ) , then we need to expand the definition of @xmath400 and reason about individual values of traces ( @xmath337 , @xmath336 , @xmath342 ) .",
    "this reasoning is at a lower level than for example the reasoning about the refinement @xmath401 which , by theorem [ lem : assert - demonic ] , is equivalent to @xmath402 in this property @xmath7 , @xmath8 may also stand for traces , but this formula does not contain references to specific values ( @xmath337 or @xmath336 ) of these traces .",
    "therefore , checking validity of this formula can be often reduced to simpler problems , e.g. , satisfiability of ltl formulas , as explained in example [ ex_checking_refinement_ltl ]",
    ".    we can exploit theorem [ thm : localsys - repr ] to obtain an analogous result for local transformers :    for @xmath403 of appropriate types",
    "we have : @xmath404      theorems [ lem : assert - demonic ] and [ thm : localsys - repr ] allow us to calculate the sequential composition of two local systems , as follows :    [ thm : local - sys - comp ]   @xmath405 where @xmath406    ideally the composition of two local systems @xmath407 and @xmath408 would be a local system corresponding to the composition of the local transitions of @xmath127 and @xmath155 . unfortunately this is not the case . in the rest of this subsection",
    "we explain why this is the case .",
    "this will motivate the definition of a restricted class of local transformers , called _ guarded _ local transformers , which are analogous to guarded property transformers , and enjoy good closure properties .",
    "we begin by defining the _ local transition _ of a local system to be the predicate transformer : @xmath409 note that @xmath410 is a _ predicate _ transformer , not a property transformer . also note that here it suffices to consider @xmath5 as a predicate on the current state and input only .",
    "the execution of @xmath410 starts from the input value @xmath7 and the state @xmath338 and if @xmath349 is true , then it computes the output value @xmath8 and the new state @xmath351 such that @xmath350 is true .",
    "the local transitions of @xmath127 and @xmath155 have the local states @xmath338 and @xmath411 , respectively , and their compostion will have the local state pairs @xmath412 . in order to be able to compose the local transitions of @xmath127 and @xmath155 , we add the state @xmath411 to the local transition of @xmath127 and the state @xmath338 to local transition of @xmath155 :    @xmath413    we show what would be the local system for the composition of the local transitions of @xmath127 and @xmath155 .",
    "we have @xmath414 the sequential composition of the two systems has as state pairs @xmath412 and the initialization predicate , the local precondition , and the local relation of the composition should be given by @xmath415 the local system of the composition of the local transitions of @xmath127 and @xmath155 is @xmath416 now , one might expect the equality @xmath417 .",
    "unfortunately this does not generally hold for arbitrary local systems @xmath127 and @xmath155 .",
    "we do have , by definition @xmath418 but there exist @xmath419 and @xmath7 such that @xmath420 for example , if we take @xmath421 then ( [ eq : prec - local - comp ] ) becomes true .",
    "what happens in this case is that @xmath422 so @xmath423 , whereas @xmath424 , and therefore clearly @xmath425 .",
    "intuitively , when executing the system @xmath426 , the precondition @xmath319 of @xmath155 is tested after a complete execution of @xmath127 , however in our example above , the execution of @xmath127 proceeds normally with the first step when started in the state @xmath427 , but then next step is miraculous because @xmath428 is false .",
    "therefore the assertion of @xmath155 containing @xmath319 is not reached . on the other hand",
    "the execution of @xmath429 starting from the same initial state @xmath427 proceeds normally with the first step of @xmath127 ( @xmath430 ) , and then tests @xmath319 , and it fails because @xmath319 is false .      as we have seen from the previous section ,",
    "the composition of two local tranformers is not necessarily a local transformer .",
    "this is because of the possible miraculous behavior of such systems . in this section",
    "we restrict the local precondition of a local system such that we do not have miraculous behavior anymore .",
    "we achieve this by considering systems where the local precondition @xmath5 is @xmath71 .",
    "this is similar to what we have done in order to restrict general relational transformers to guarded systems , in section [ sub : guarded - systems ] .",
    "the _ guarded local system _ of @xmath352 and @xmath70 is denoted by @xmath431 and it is given by @xmath432 and the _ local precondition _ of a local guarded reactive systems with state is @xmath71 .",
    "[ thm : glocalsys - repr]for @xmath352 and @xmath70 as in the definition of a local guarded system we have : @xmath433    the next theorem shows that the sequential composition of two local guarded systems is also a local guarded system .    for @xmath352 , @xmath434 , @xmath70 , and @xmath320 we have @xmath435 where @xmath436 and @xmath437      we define _ stateless systems _ as a special case of local systems , where the state @xmath338 ranges over a singleton set @xmath438 and where @xmath439 . in this case",
    "we have    [ thm : less - localsys - repr]for @xmath5 , and @xmath70 as in the definition of a stateless system , we have : @xmath440    based on this theorem we use the notation @xmath441 for a stateless system .",
    "the next theorem gives a procedure to calculate the sequential composition of two stateless systems .",
    "[ thm : less - local - sys - comp ]   @xmath442    as in the case of general local systems , the composition of two stateless systems is not always a stateless system .",
    "this motivates us to introduce guarded stateless systems , similarly to guarded local systems .",
    "a _ guarded stateless system _ is a stateless system where @xmath443 .",
    "[ thm : glocalsys - repr-1]for any @xmath70 : @xmath444 .",
    "this is because we have @xmath445 we use the notation @xmath446 for a guarded stateless system .",
    "sequential composition of guarded stateless systems is also a guarded stateless system :    for @xmath70 , and @xmath320 we have @xmath447 where @xmath448 is as defined before , but without the state parameters @xmath449 and @xmath450 .",
    "next we introduce some special properties and we show that stateless guarded local systems behave consistently with respect to these properties",
    ".    for a property @xmath4 , the @xmath340-th _ projection _ of @xmath4 is a predicate on states given by @xmath451 and a property @xmath4 is a _ piecewise local property _ if it satisfies the condition @xmath452    equivalently , a property @xmath4 is piecewise local if there exist some predicates @xmath453 , @xmath454 , @xmath39 such that @xmath455 there are properties which are not local .",
    "for example the liveness property @xmath456 is not local because @xmath457 satisfies the condition @xmath458 , but @xmath459 .    if @xmath70 is a state relation , then    1 .",
    "@xmath460 2 .",
    "if @xmath4 is piecewise local then @xmath461 .",
    "this lemma asserts that for the piecewise local property @xmath4 and input sequence @xmath7 , all possible outputs of @xmath446 starting from @xmath7 are in @xmath4 if and only if for all steps @xmath340 all possible outputs of @xmath327 from @xmath337 are in @xmath462 .",
    "so the global execution of @xmath446 is equivalent to the execution of @xmath327 on all steps .",
    "if we have a local system it does not necessarily mean that we can not study its behavior with respect to non piecewise local properties . for example let us consider a stateless local guarded system that at each step computes @xmath463 or @xmath464 , assuming that @xmath465 : @xmath466 if we want to see under what conditions on the input @xmath7 the output of @xmath127 satisfies the property @xmath467 , then we should calculate @xmath132 : @xmath468 if we want to see under what conditions on the input the output of @xmath127 satisfies @xmath469 , then we should calculate @xmath470 . in this case",
    "we have @xmath471 .",
    "this is so because of the demonic choice @xmath463 or @xmath464 .",
    "for all values of @xmath7 it is always possible to choose @xmath472 .",
    "to illustrate the power of our framework , we show how it can handle as a special case the extension of the relational interface theory presented in @xcite to infinite behaviors and liveness .",
    "we note that the theory proposed in @xcite allows to describe only safety properties , in fact , finite and prefix - closed behaviors . extending to infinite behaviors and liveness properties",
    "is mentioned as an open problem in @xcite .",
    "a number of examples showcasing this extension have already been provided in the introduction . here",
    "we provide an additional example . consider the following symbolic transition system : @xmath473    this symbolic transition system has a boolean input @xmath7 and a boolean output @xmath8 .",
    "if the input is true then state counter @xmath338 is incremented .",
    "if the input is false then @xmath338 is decremented .",
    "regardless of the input , the system may also choose nondeterministically to reset the counter to zero .",
    "the output of the system is true whenever the counter reaches zero .",
    "the system also restricts the value of the state to be between @xmath474 and @xmath475 .",
    "if the state goes out of this range the system will fail .",
    "the system is supposed to start from state @xmath427 .",
    "the local system for this relation is @xmath476 however we are interested in a system which is also capable of ensuring the liveness property that @xmath8 is true infinitely often .",
    "we achieve this by adding the constraint @xmath477 to the input - output relation of ( [ eq : ex - no - live ] ) .",
    "so the full example is @xmath478 in this example the state condition @xmath479 is a safety property , and we designed the example such that this property is enforced on the input .",
    "that is , some input trace is accepted by this system only if this property is not violated .",
    "for example the input sequence @xmath480 , @xmath481 , @xmath39 maintains this property . on the other hand",
    "the property @xmath477 is a liveness property which is guaranteed by the system , regardless of the input .",
    "if we need we can move this property to the precondition ( adapted to the state variable ) and then the system will fail if the input is such that this property is false .",
    "we can prove that our example system establishes the liveness property @xmath477 for all inputs that do not fail , i.e. , for all input traces which satisfy @xmath482 we have @xmath483    we can now use @xmath484 as specification and we can , for instance , refine it to the system which always assigns @xmath42 to the output variable : @xmath485 we can also assume that the input satisfies some additional property .",
    "for instance , we can assume that @xmath7 is alternating between @xmath42 and @xmath43 : @xmath486 then we can show that this new system is refined by the original symbolic transition system : @xmath487 because the additional property used as precondition ensures the liveness property .",
    "using this formalism we can construct liveness specifications as the example system , and we can refine them in appropriate contexts to systems which do not have any liveness property , but they preserve the liveness property of the input .    from ( [ eq : liveness ] ) we also obtain @xmath488 we can use this property when constructing another system that uses the output from @xmath484 as input .",
    "then we know that this input satisfies the liveness property @xmath477 and we can design this second system accordingly .",
    "in this paper we introduced a monotonic property transformer semantics for reactive systems .",
    "the semantics supports refinement , compostion , compatibility , demonic choice , unbounded nondeterminism , and other interesting system properties .",
    "the semantics also supports angelic choice : we have not specifically exploited this feature here and we leave it for future work .",
    "the semantics can be used to specify and reason about both safety and liveness properties .",
    "our framework allows to describe systems using a variety of formalisms , from higher order logic , to temporal logic , to symbolic transition systems .",
    "the framework is compositional , in particular if we restrict ourselves to the most realistic case of guarded systems , which can not behave miraculously , and enjoy good closure properties .",
    "our work generalizes previous work on relational interfaces to systems with infinite behavior and liveness properties .",
    "future work includes studying more operators ( e.g. , angelic choice ) , and extending the framework to continuous - time and hybrid systems .",
    "ralph - johan back and joakim wright .",
    "trace refinement of action systems . in bengt jonsson and joachim parrow , editors , _",
    "concur 94 : concurrency theory _",
    ", volume 836 of _ lecture notes in computer science _ , pages 367384 .",
    "springer berlin heidelberg , 1994 ."
  ],
  "abstract_text": [
    "<S> refinement calculus is a powerful and expressive tool for reasoning about sequential programs in a compositional manner . in this paper </S>",
    "<S> we present an extension of refinement calculus for reactive systems . </S>",
    "<S> refinement calculus is based on monotonic predicate transformers , which transform sets of post - states into sets of pre - states . to model </S>",
    "<S> reactive systems , we introduce monotonic property transformers , which transform sets of output traces into sets of input traces . we show how to model in this semantics refinement , sequential composition , demonic choice , and other semantic operations on reactive systems . </S>",
    "<S> we use primarily higher order logic to express our results , but we also show how property transformers can be defined using other formalisms more amenable to automation , such as linear temporal logic ( suitable for specifications ) and symbolic transition systems ( suitable for implementations ) . finally , we show how this framework generalizes previous work on relational interfaces so as to be able to express systems with infinite behaviors and liveness properties .    @xmath0aalto university , finland . </S>",
    "<S> + @xmath1university of california , berkeley , usa .    # 1\\{#1 }    # 1[#1 ] # 1#2#3[#1#2 | # 3 ]    # 1#2#3\\{#1#2 |#3 }    # 1\\{#1 ]    # 1#2\\{#1  |  # 2 ]    # 1#1 ^ 1 # 1\\{|#1 ] ] # 1#2#3#1#2#3    ,    # 1#2#3#4#1 |#2 |#3 |#4    # 1#2#3#1 |#2 |#3    # 1#2#1 |#2    # 1#1    # 1#2#3#1#2#3 </S>"
  ]
}