{
  "article_text": [
    "consider a set @xmath13 of processors ( sites ) in which each site @xmath0 has a set @xmath14 of possible states ( also called `` local states '' ) .",
    "an arbitrary function @xmath15 is called a , or simply `` configuration '' , or `` global state '' .",
    "the value @xmath3 is the state of site @xmath0 in @xmath16 .",
    "a function @xmath17 will be called a assigning to each @xmath18 , a set @xmath1 called the of @xmath0 .",
    "a function @xmath19 is called a if @xmath20 depends only on @xmath21 , i.e. @xmath22 the transition function determines a possible `` next '' configuration from the `` current '' one .",
    "the 4-tuple @xmath23 will be called an ( not necessarily a finite one ) .",
    "if all sets @xmath1 are finite then the system is called . note",
    "that locality is actually a property of @xmath24 itself : it says that for each @xmath0 a finite @xmath1 can be chosen such that @xmath20 depends only on @xmath21 .",
    "let @xmath25 .",
    "[ x.ca ]    1 .   on the set of integers",
    ": let @xmath26 , @xmath27 .",
    "suppose that there is a transition function @xmath28 and each site @xmath0 has a value @xmath29 .",
    "now the result of transition at site @xmath0 is @xmath30 in this example , the transition function depends only on the sequence of values of @xmath21 , i.e.  it is homogenous .",
    "the present paper will not exploit any consequences of homogeneity .",
    "2 .   on the set of natural numbers , with `` free boundary condition '' : let @xmath31 , @xmath27 for @xmath32 and @xmath33 for @xmath34 .",
    "suppose that there are transition functions @xmath28 , @xmath35 .",
    "now the result of transition at site @xmath0 is @xmath36 for @xmath32 and @xmath37 for @xmath34 .",
    "let us fix an automaton @xmath38 as in  .",
    "an arbitrary function @xmath39 is called a .",
    "such a space - time configuration can also be viewed as a sequence @xmath40 of space - configurations .",
    "we will say that a space - time configuration @xmath41 is a if for all @xmath42 we have @xmath43 .",
    "in other words , @xmath44 i.e.  in @xmath41 , each site is `` updated '' every time by the function @xmath2 ( though the update may not change the state ) .",
    "we are interested in situations when at any one time , only the values of some of the sites are updated .",
    "we will say @xmath41 is an if   holds for all @xmath42 such that @xmath45 : i.e.  if each site in @xmath41 at each time is either updated or left unchanged . from now on , when we speak of a `` trajectory '' without qualification , this will mean an asynchronous trajectory . let the @xmath46 be the set of sites @xmath0 with @xmath45 . the initial configuration and the update sets @xmath47 determine @xmath41 .",
    "for any set @xmath48 , let @xmath49 for a space - time configuration @xmath5 we define the function @xmath50 as follows : @xmath51 we can call @xmath52 the of site @xmath0 in the space - time configuration @xmath41 at time @xmath4 : this is the number of effective updatings that @xmath0 underwent until time @xmath4 .",
    "given an initial configuration @xmath16 , we say that @xmath24 ( and thus @xmath38 ) has on @xmath16 if there is a function @xmath53 such that for all asynchronous trajectories @xmath5 with @xmath54 we have @xmath55 this means that after eliminating repetitions , the sequence @xmath6 , @xmath7 of values that a site @xmath0 will go through during some space - time configuration , does not depend on the update sets , only on the initial configuration ( except that the sequence may be finite if there is not an infinite number of successful updates ) .",
    "the update sets influence only the delays in going through this sequence .",
    "we say that an automaton has if it has such on all initial configurations .",
    "the sequence @xmath56 is a sequence of local states but @xmath57 is not a space - configuration ( global state ) that appears at any time in a typical asynchronous trajectory .",
    "[ t.undec ] if @xmath38 is a one - dimensional cellular automaton with state space @xmath58 for some natural number @xmath59 , then it is undecidable whether it has invariant histories .",
    "the theorem shows that some more condition is needed if we want the invariant history property to become decidable . for us",
    ", this condition will be monotonicity .",
    "the set of sites @xmath0 in a configuration @xmath16 is defined by @xmath60 for a space - time configuration @xmath41 , let @xmath61 for a configuration @xmath16 and a set @xmath62 of sites , let @xmath63 with this notation , we have @xmath64 .",
    "now we can express the condition that @xmath41 is an asynchronous trajectory by saying that for every @xmath4 there is a set @xmath65 with @xmath66 and the condition that @xmath41 is synchronous by requiring @xmath67 for each @xmath4 .",
    "we call a transition rule @xmath24 if @xmath68 , i.e.  updating a site can not take away the freedom of other sites .",
    "we call a transition rule @xmath24 ( and thus the automaton @xmath38 ) if for all configurations @xmath16 and all disjoint sets of sites @xmath69 we have @xmath70 we call @xmath24 when this property is required just for the special case where @xmath71 are one - element sets .",
    "the following fact is easy to see but we give the proof for completeness .",
    "[ l.commut.gener ] if @xmath24 is local then its local commutativity implies commutativity .",
    "let us first show @xmath72 local commutativity implies for each @xmath73 , @xmath74 therefore @xmath75 .",
    "now , let us show @xmath76 using  , we have @xmath77 , hence @xmath78 .",
    "using   again concludes the proof .",
    "let us return to the general case .",
    "obviously , it is sufficient to check   for sites @xmath79 .",
    "clearly , @xmath80 .",
    "the latter is @xmath81 according to  .    1 .   for the cellular automaton example above",
    ", local commutativity is equivalent to saying that if @xmath82 and @xmath83 then @xmath84 2 .",
    "if @xmath24 is not local then local commutativity does not always imply commutativity .",
    "for an example , let @xmath85 , @xmath26 , @xmath86 , and let @xmath87 now @xmath24 is obviously locally commutative . on the other hand , let @xmath88 for all @xmath0 , and let then @xmath89 and @xmath90 .    [ t.commut ] a transition function is commutative if and only if it is monotonic and has invariant histories .    in theorem   [ t.asynch-sim ]",
    "below , we will give a known simple example of a commutative transition function .",
    "for that example , the theorem can be proved much easier .",
    "theorem [ t.commut ] can be derived from results e.g. in  @xcite .",
    "however , i do not find it worth introducing all the concepts needed for the derivation : the simplicity of the condition in the present context probably justifies a self - contained proof .",
    "[ l.commut.necess ] suppose that @xmath24 has invariant histories and is monotonic : then it is commutative .",
    "let @xmath91 , @xmath92 , and @xmath93 .",
    "this defines @xmath94 and @xmath95 from initial configuration @xmath16 by @xmath96 as usual . by monotonicity , @xmath97 and @xmath98 , so @xmath99 s values satisfy @xmath100 which is 1 if @xmath101 and 0 otherwise .",
    "the same value is obtained for @xmath102 . by invariant histories ,",
    "there is a @xmath103 such that @xmath104 and @xmath105 thus , @xmath2 is commutative .",
    "what remains to prove after lemma  [ l.commut.necess ] is that commutativity implies monotonicity and invariant histories .",
    "[ l.commut.monot ] if @xmath24 is commutative then it is monotonic .    by lemma  [ l.commut.gener ] , @xmath106 .",
    "therefore @xmath107 implies that @xmath2 is monotonic .",
    "we say for two asynchronous trajectories @xmath108 with the same initial configuration that @xmath94 @xmath109 until time @xmath110 if the following conditions hold :    [ i.domin.ineq ] @xmath111 for all @xmath112    [ i.domin.eq ] for all @xmath113 , if @xmath114 then @xmath115 .",
    "when @xmath94 dominates @xmath109 up to time @xmath110 for all @xmath110 then we simply say that @xmath94 dominates @xmath109 .",
    "this domination is , of course , a transitive relation . if the rule has invariant histories then condition   implies  , but otherwise this may not be the case .",
    "let @xmath24 be a commutative transition rule .",
    "it remains to prove that it has invariant histories .",
    "commut.main-1 let @xmath41 be an asynchronous trajectory and @xmath116 .",
    "then there is an asynchronous trajectory @xmath117 dominating @xmath41 with initial configuration @xmath118 , such that @xmath119 .",
    "let @xmath120 .",
    "we show how to build , for each @xmath110 , a trajectory @xmath117 with the given properties that dominates @xmath41 up to time @xmath110 .",
    "when @xmath121 then @xmath117 will converge to a trajectory with the same properties that dominates @xmath41 .",
    "for @xmath122 we can choose @xmath123 .",
    "we assume that @xmath117 can be constructed for all @xmath124 and prove it for @xmath110 .",
    "let @xmath125 , and @xmath126 .",
    "let the trajectory @xmath94 be defined by @xmath127 .",
    "the inductive assumption gives a trajectory @xmath128 with initial configuration @xmath129 dominating @xmath94 , with @xmath130 using this trajectory , we define , for @xmath131 : @xmath132    commut.main-1.traj @xmath117 is an asynchronous trajectory .",
    "let us show that @xmath117 satisfies  .",
    "this holds by definition for @xmath133 and @xmath134 .",
    "let us show that it also holds for @xmath135 with @xmath136 .",
    "we have @xmath137    for domination , we must check two properties .",
    "commut.main-1.tau we have @xmath138 .    by the definition of @xmath99 , for @xmath131 , @xmath139 by the definition of @xmath140 , for @xmath131 , using",
    ", we have @xmath141 further , @xmath142 by the above definition , @xmath143 also , from here and  , @xmath144 by domination , @xmath145 and hence for all @xmath146 , we have , combining   with  , @xmath147    commut.main-1.equal if @xmath148 then @xmath149 .    if @xmath150 then clearly @xmath151 since this means that in both processes , no progress has been made in @xmath0 from the initial configuration . assume therefore that @xmath152 and hence @xmath153 .",
    "assume @xmath154 . then @xmath155 and hence @xmath156 .",
    "if @xmath157 then @xmath158 and hence the same transition that gives @xmath159 also gives @xmath160 .",
    "otherwise @xmath161 hence @xmath162 .",
    "also , @xmath163 , hence @xmath164 .",
    "the inductive assumption implies @xmath165 . on the other hand ,   and",
    "@xmath166 implies @xmath167 which concludes this case .",
    "assume now @xmath168 .",
    "since @xmath5 changes if and only if @xmath52 does we can assume that @xmath169 since otherwise we can decrease @xmath170 without changing @xmath171 . the same is true for @xmath172 . under these assumptions we have @xmath173 . by  , @xmath174 we assumed this to be equal to @xmath175 . hence @xmath176",
    "also @xmath177 , @xmath178 , and hence the inductive assumption implies the statement .",
    "commut.main-2 let @xmath41 be a trajectory .",
    "then the synchronous trajectory with initial configuration @xmath118 dominates @xmath41 .",
    "let @xmath179 . by  [ commut.main-1 ] above , there is a trajectory @xmath117 with initial configuration @xmath118 dominating @xmath41 such that @xmath180 .",
    "this just means that @xmath117 is a synchronous trajectory up to time 1 .",
    "continuing the application of  [ commut.main-1 ] , we can dominate @xmath41 by a synchronous trajectory @xmath181 up to time 2 , etc .",
    "now we can conclude the proof of the theorem as follows .",
    "let @xmath41 be a trajectory with initial configuration @xmath16 and let @xmath117 be the synchronous trajectory with the same initial configuration .",
    "let us define @xmath182 to prove  , note that due to domination , @xmath138 and hence for every @xmath183 there is a @xmath184 with @xmath185 .",
    "let @xmath186 be the first such : @xmath187 . by domination , @xmath188 .",
    "let us show the known result that every transition function can be embedded into a commutative one .",
    "we will use the following notation : @xmath189 is the integer @xmath0 with @xmath190 and @xmath191 .",
    "[ t.asynch-sim ] let @xmath192 be an arbitrary local ( not necessarily commutative ) automaton @xmath1 .",
    "then there is an automaton @xmath193 , where for @xmath194 we write @xmath195 , with the following property .",
    "let @xmath129 be an arbitrary configuration of @xmath196 and let @xmath197 be a configuration of @xmath198 such that for all @xmath0 we have @xmath199 . then for the synchronous trajectory @xmath95 of @xmath198 , with initial configuration @xmath197 , the space - time configuration @xmath200 is a synchronous trajectory of @xmath196 .",
    "moreover , in this trajectory , the state of each cell changes in each step .",
    "in other words , as long as we update synchronously the rule @xmath198 behaves in its field @xmath201 just like the arbitrary rule @xmath196 .",
    "but @xmath198 has invariant histories , so it is much more robust .    let @xmath202 .",
    "the three components of each state @xmath170 of @xmath203 will be written as @xmath204 the statement of the theorem will obtain by @xmath205 , @xmath206 .",
    "the field @xmath207 will be used to keep track of the time of the simulated cells mod 3 , while @xmath208 holds the value of @xmath209 for the previous value of @xmath210 .",
    "let us define @xmath211 . if there is a @xmath212 such that @xmath213 ( i.e.  some neighbor lags behind ) then @xmath214 i.e.  there is no effect",
    ". otherwise , let @xmath215 be @xmath216 if @xmath217 , and @xmath218 otherwise .",
    "@xmath219 thus , we use the @xmath209 and @xmath208 fields of the neighbors according to their meaning and update the three fields according to their meaning .",
    "it is easy to check that this transition rule simulates @xmath196 in the @xmath209 field if we start it by putting 0 into all other fields .",
    "let us check that @xmath198 is locally commutative .",
    "if two neighbors @xmath10 are both are allowed to update then neither of them is behind the other modulo 3 , hence they both have the same @xmath210 field .",
    "suppose that @xmath0 updates before @xmath12 . in this case , @xmath0 will use the the @xmath209 field of @xmath12 for updating and put its own @xmath209 field into @xmath208 .",
    "next , since now @xmath0 is `` ahead '' according to @xmath210 , cell @xmath12 will use the @xmath208 field of @xmath0 for updating : this was the @xmath209 field of before .",
    "therefore the effect of consecutive updating is the same as that of simultaneous updating .    the commutative medium of the above proof is also called the `` marching soldiers '' scheme since its handling of the @xmath210 field reminds one of a chain of soldiers marching ahead in which two neighbors do not want to be separated by more than one step .",
    "it is shown in  @xcite that if the update times obey a poisson process then the average computation time of this simulation within a constant factor of the computation time of the synchronous computation .    in typical cases of asynchronous computation , there are more efficient ways to build a commutative rule than to store the whole previous state in the @xmath208 field .",
    "indeed , the transition function typically does not use the complete state of cells in @xmath1 .",
    "rather , the cells only `` communicate '' in the sense that there is a message field and the next state of @xmath0 depends only on this field of the neighbor cells . in such cases , it is sufficient in the above construction to store the previous value of this message field",
    ". we can sometimes decrease the message field by taking several steps of @xmath198 to simulate a single step of @xmath196 .    in case of one - dimensional systems , the `` marching soldiers '' scheme has the following strengthening of the original property saying that @xmath220 is independent of the order of updating .",
    "as in example  [ x.ca ]    [ t.1dim - prop ] let @xmath192 be an arbitrary one - dimensional cellular automaton defined , as in example  [ x.ca ] , via a transition function @xmath221 .",
    "let the automaton @xmath193 be defined as in the proof of theorem  [ t.asynch-sim ] .",
    "let @xmath41 be an arbitrary asynchronous trajectory of @xmath222 .",
    "let us define the functions @xmath223 , @xmath224 by @xmath225 , and @xmath226 for all @xmath110 of the form @xmath227 .",
    "also , let @xmath228 .",
    "then @xmath229 implies with @xmath230 that @xmath231 and all terms in this equation are defined .",
    "the proof is straightforward verification .",
    "the theorem essentially says that from each asynchronous trajectory @xmath41 of @xmath222 , some synchronous trajectory @xmath232 of @xmath233 can be reconstructed as @xmath234 .",
    "the function @xmath223 shows how much `` ahead '' or `` behind '' we are in simulating this trajectory when we start in @xmath41 .",
    "this theorem fails in other neighborhood structures , namely in networks containing cycles : there , only certain initial configurations @xmath118 allow the construction of @xmath223 . in the ones that do not allow it",
    ", there is some inconsistency in the timing function @xmath235 ( a loop along which the sum of local increments of @xmath210 is not 0 ) . in a connected network , this loop will imply that each cell can have only finitely many state changes , even in an infinite trajectory .",
    "[ l.turing ] let us be given a one - dimensional commutative cellular automaton over the set of natural numbers , with `` free boundary condition '' , by a set of states @xmath58 , transition functions @xmath236 and @xmath237 as in example  [ x.ca ] , with @xmath238 , @xmath239 ( for all @xmath170 ) .",
    "the following problem is undecidable , as a function of @xmath240 : is there any synchronous trajectory of this cellular automaton , with @xmath241 for all @xmath0 and @xmath242 for some @xmath131 ?    there is a standard construction to simulate turing machines with such cellular automata , so the question reduces to the question whether an arbitrary turing machine will halt when started on an empty tape .",
    "[ l.undec ] let us be given a one - dimensional commutative cellular automaton over the set of natural numbers , with `` free boundary condition '' , by a set of states @xmath58 , transition functions @xmath236 and @xmath237 as in example  [ x.ca ] .",
    "the following problem is undecidable , as a function of @xmath240 : is there any trajectory of this cellular automaton , with @xmath243 and @xmath242 for some @xmath131 ?    of course , once the automaton is commutative it does not matter whether the trajectory asked for is synchronous or asynchronous .    from now on , without danger of confusion , let us write @xmath244 and forget about @xmath245 .",
    "let us be given a cellular automaton @xmath221 like in lemma  [ l.turing ] , with state set @xmath58 .",
    "we construct a new cellular automaton over the set of states @xmath246 , with the following transition function @xmath247 .",
    "over states @xmath248 , the functions @xmath247 behave as @xmath221 .",
    "further , we have the following rules for @xmath247 when at least one of the arguments is @xmath59 .",
    "@xmath249 and @xmath250 , @xmath251 in all remaining cases . by these rules ,",
    "the symbol @xmath59 `` sweeps '' right and in its wake the rule @xmath221 will operate as if it had started from the a configuration of all 0 s . thus , let @xmath41 be the synchronous trajectory of @xmath221 with @xmath241 for all @xmath0 .",
    "then clearly if @xmath117 is any synchronous trajectory of @xmath247 with @xmath252 then for all @xmath131 , for all @xmath253 we have @xmath254 .",
    "let us now apply the construction of the proof of theorem  [ t.asynch-sim ] to @xmath247 to obtain commutative rule @xmath255 over the set of states @xmath256 .",
    "we will prove that @xmath255 has an asynchronous trajectory @xmath181 with @xmath257 and @xmath258 for some @xmath110 , if and only if @xmath221 has a synchronous trajectory @xmath41 with @xmath259 for all @xmath0 and @xmath260 for some @xmath110 .",
    "since we know that the question whether this happens is undecidable from @xmath221 , we will have proved that the question whether some cellular automaton has an asynchronous trajectory @xmath41 with @xmath261 and @xmath262 for some @xmath263 is undecidable ; this will complete the proof .",
    "the `` if '' part : suppose first that @xmath221 has a synchrounous trajectory @xmath41 with @xmath259 for all @xmath0 , and and @xmath260 for some @xmath110 . as mentioned above",
    ", then the synchronous trajectory @xmath117 of @xmath247 has @xmath254 for all @xmath253 . consider the synchronous trajectory @xmath181 of @xmath255 started from @xmath264 for all @xmath0 .",
    "then for all @xmath131 and all @xmath253 we have @xmath265 let @xmath266 be the first number @xmath267 divisible by 3 .",
    "we have @xmath268 the `` only if '' part : assume that @xmath181 is an asynchronous trajectory of @xmath255 with @xmath257 and @xmath269 for some @xmath270",
    ". then @xmath271 and defining @xmath272 , theorem  [ t.1dim - prop ] implies @xmath273 applying theorem repeatedly , we obtain @xmath274 or , if @xmath34 , the same relation with the first argument of @xmath247 omitted , for @xmath275 and @xmath276 .",
    "now , if @xmath269 then @xmath277 while @xmath278 .",
    "we have just found that @xmath279 develops according to @xmath247 for @xmath275 and @xmath276 . as discussed above ,",
    "therefore @xmath277 if and only if @xmath221 computes 1 at @xmath280 from an all-0 initial configuration .",
    "let the local state space be the set of integers @xmath281 .",
    "let @xmath282 and @xmath283 be the rules for a commutative cellular automaton transition rule with state set @xmath284 .",
    "we define the transition function @xmath24",
    ". we will write @xmath285 as @xmath286 .",
    "we require @xmath287 and @xmath288 in all remaining cases .",
    "let us show that @xmath24 has invariant histories if and only if @xmath221 has no asynchronous trajectory @xmath109 over @xmath31 with @xmath289 and @xmath290 for some @xmath4 .",
    "assume first that @xmath221 has such a trajectory .",
    "let us define the initial configuration @xmath16 of @xmath24 as @xmath291 if @xmath292 and 0 otherwise .",
    "we may apply rule   first to get @xmath293 . or",
    ", we may apply rules  , , first to cells @xmath32 on the right repeatedly .",
    "sooner or later we have @xmath242 , which allows @xmath294 by rule   in the next step .",
    "thus , depending on the order of rule application , we obtained in cell @xmath295 the sequence @xmath296 or @xmath297 .",
    "suppose now that @xmath221 has no such trajectory and let @xmath16 be an arbitrary configuration of @xmath24 .",
    "each occurrence of a state @xmath298 remains such an occurrence . on segments between them , the commutative rule @xmath221 works .",
    "the only other transitions possible are @xmath299 and @xmath300 .",
    "assume @xmath301 and consider the sequence of different values in @xmath302 .",
    "let us show that 0 and 1 can not both occur in this sequence and hence only one of the transitions is possible .",
    "indeed , if 0 occurs before 1 then our assumption about @xmath221 excludes the occurrence of 1 in the sequence any later .",
    "if 1 occurs in the sequence before 0 then our rules ( in particular ,  ) do not allow any change of the state of @xmath303 after that .",
    "i thank robert solovay for pointing out several errors in the first version , wayne snyder for calling my attention to  @xcite and the anonymous referee for his careful reading and many corrections ."
  ],
  "abstract_text": [
    "<S> consider a network of processors ( sites ) in which each site @xmath0 has a finite set @xmath1 of neighbors . </S>",
    "<S> there is a transition function @xmath2 that for each site @xmath0 computes the next state @xmath3 from the states in @xmath1 . </S>",
    "<S> but these transitions ( updates ) are applied in arbitrary order , one or many at a time . </S>",
    "<S> if the state of site @xmath0 at time @xmath4 is @xmath5 then let us define the sequence @xmath6 , @xmath7 by taking the sequence @xmath8 , @xmath7 , and deleting each repetition , i.e.  each element equal to the preceding one . </S>",
    "<S> the function @xmath2 is said to have if the sequence @xmath9 , ( while it lasts , in case it is finite ) depends only on the initial configuration , not on the order of updates .    </S>",
    "<S> this paper shows that though the invariant history property is typically undecidable , there is a useful simple sufficient condition , called : for any configuration , for any pair @xmath10 of neighbors , if the updating would change both @xmath3 and @xmath11 then the result of updating first @xmath0 and then @xmath12 is the same as the result of doing this in the reverse order . </S>",
    "<S> this fact is derivable from known results on the confluence of term - rewriting systems but the self - contained proof given here may be justifiable . </S>"
  ]
}