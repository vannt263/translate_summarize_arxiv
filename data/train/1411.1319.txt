{
  "article_text": [
    "* background . * finding the node with the largest label in a labeled network is one of the fundamental problems in distributed computing .",
    "this is the way in which _ leader election _ is usually solved .",
    "( in leader election , one node of a network has to become a _ leader _ and all other nodes have to become _ non - leaders _ ) .",
    "in fact , to the best of our knowledge , all existing leader election algorithms performed in labeled networks choose , as leader , the node with the largest label or the node with the smallest label @xcite .",
    "the classic problem of leader election first appeared in the study of local area token ring networks @xcite , where , at all times , exactly one node ( the owner of a circulating token ) has the right to initiate communication .",
    "when the token is accidentally lost , a leader is elected as the initial owner of the token .",
    "* model and problem description . *",
    "the network is modeled as an undirected connected graph with @xmath0 labeled nodes and with diameter @xmath3 at most @xmath2 .",
    "we denote by @xmath10 the diameter of graph @xmath11 .",
    "labels are drawn from the set of integers @xmath12 , where @xmath13 is polynomial in @xmath0 .",
    "each node has a distinct label .",
    "initially each node knows its label and its degree .",
    "the node with the largest label in a graph will be called its _",
    "largest node_.    we use the extensively studied @xmath14 communication model @xcite . in this",
    "model , communication proceeds in synchronous rounds and all nodes start simultaneously . in each round",
    ", each node can exchange arbitrary messages with all of its neighbours and perform arbitrary local computations . for any @xmath15 and any node @xmath16",
    ", we use @xmath17 to denote the knowledge acquired by @xmath16 within @xmath18 rounds .",
    "thus , @xmath17 consists of the subgraph induced by all nodes at distance at most @xmath18 from @xmath16 , except for the edges joining nodes at distance exactly @xmath18 from @xmath16 , and of degrees ( in the entire graph ) of all nodes at distance exactly @xmath18 from @xmath16 .",
    "hence , if no additional knowledge is provided _ a priori _ to the nodes , the decisions of @xmath16 in round @xmath18 in any deterministic algorithm are a function of @xmath17 .",
    "we denote by @xmath19 the set of labels of nodes in the subgraph induced by all nodes at distance at most @xmath18 from @xmath16 .",
    "the _ time _ of a task is the minimum number of rounds sufficient to complete it by all nodes .",
    "it is well known that the synchronous process of the @xmath14 model can be simulated in an asynchronous network .",
    "this can be achieved by defining for each node separately its asynchronous round @xmath20 ; in this round , a node performs local computations , then sends messages stamped @xmath20 to all neighbours , and waits until it gets messages stamped @xmath20 from all neighbours . to make this work ,",
    "every node is required to send at least one ( possibly empty ) message with each stamp , until termination .",
    "all of our results can be translated for asynchronous networks by replacing `` time of completing a task '' by `` the maximum number of asynchronous rounds to complete it , taken over all nodes '' .",
    "we consider two distinct tasks in which the largest node is found deterministically . in _ selection _ , this node has to output 1 and all other nodes have to output 0 . in _ election _ , all nodes must output the largest label . note that in election all nodes perform selection and additionally learn the identity of the largest node .",
    "both variations are useful in different applications . in the aforementioned application of recovering a lost token ,",
    "selection is enough , as the chosen node will be the only one to get a single token and then the token will be passed from node to node . in this case , other nodes do not need to know the identity of the chosen leader .",
    "the situation is different if all nodes must agree on a label of one of the nodes , e.g. , to use it later as a common parameter for further computations .",
    "then the full strength of election is needed .",
    "likewise , learning the largest label by all nodes is important when labels carry some additional information apart from the identities of nodes , e.g. , some values obtained by sensors located in nodes .",
    "our results also remain valid in such situations , as long as the `` informative label '' can be represented as an integer polynomial in @xmath0 .",
    "our aim is to compare the difficulty of the two seemingly similar tasks of selection and election executed under stringent running time constraints .",
    "the measure of difficulty is the amount of information that nodes of the network must initially possess in order to solve the given task in an imposed amount of time . following the standard framework of _ algorithms with advice _ ,",
    "see , e.g. , @xcite , this information ( a single binary string ) is provided to all nodes at the start by an oracle knowing the entire graph .",
    "the length of this string is called the _ size of advice_.    the paradigm of algorithms with advice has a far - reaching importance in the realm of network algorithms . establishing a tight bound on the minimum size of advice sufficient to accomplish a given task permits to rule out entire classes of algorithms and thus focus only on possible candidates .",
    "for example , if we prove that @xmath4 bits of advice are needed to perform a certain task in @xmath0-node graphs , this rules out all potential algorithms that can work using only some linear upper bound on the size of the network , as such an upper bound could be given to the nodes using @xmath21 bits by providing them with @xmath22 .",
    "lower bounds on the size of advice give us impossibility results based strictly on the _ amount _ of initial knowledge outlined in a model s description .",
    "this more general approach should be contrasted with traditional results that focus on specific _ kinds _ of information available to nodes , such as the size , diameter , or maximum node degree .    * our results .",
    "* consider the class of @xmath0-node graphs with any diameter @xmath1 , for some integer @xmath2 .",
    "first observe that if time is larger than @xmath3 , then both tasks can be solved without advice , as nodes learn the entire network and _ learn that they have learned it_. thus they can just choose the maximum of all labels seen .",
    "for the task of _ election _ , we show that if time is smaller than @xmath3 , then the optimal size of advice is @xmath4 , and if time is exactly @xmath3 , then the optimal size of advice is @xmath5 . here",
    "our contribution consists in proving two lower bounds on the size of advice .",
    "we prove one lower bound by exhibiting , for any positive integers @xmath23 , networks of size @xmath24 and diameter @xmath25 , for which @xmath26 bits of advice are needed for election in time below @xmath3 .",
    "to prove the other lower bound , we present , for any positive integer @xmath2 , networks of diameter @xmath1 for which @xmath27 bits of advice are needed for election in time exactly @xmath3 .",
    "these lower bounds are clearly tight , as even for time 0 , @xmath28 bits of advice are enough to provide the largest label in the network , and , for time @xmath3  when nodes know the entire network , but they _ do not know that they know it _ ",
    "@xmath29 bits of advice are enough to give the diameter @xmath3 to all nodes and thus reassure them that they have seen everything . in this case",
    ", they can safely choose the maximum of all labels seen .",
    "hence , a high - level statement of our results for election is the following .",
    "if time is too small for all nodes to see everything , then no more efficient help in election is possible than just giving the largest label .",
    "if time is sufficient for all nodes to see everything , but too small for them to realize that they do , i.e. , the time is exactly @xmath3 , then no more efficient help in election is possible than providing @xmath3 , which supplies nodes with the missing certainty that they have seen everything .",
    "it should be noted that @xmath0 could be exponential in @xmath2 , as in hypercubes , or @xmath2 can even be constant with respect to arbitrarily large @xmath0 .",
    "thus , our results for election show that , for some networks , there is an exponential ( or even larger ) gap of difficulty of election ( measured by the size of advice ) between time smaller than @xmath3 and time exactly @xmath3 .",
    "another such huge gap is between time @xmath3 , when advice of size @xmath5 is optimal , and time larger than @xmath3 , when 0 advice is enough .",
    "these gaps could be called _ intra - task _ jumps in difficulty for election with respect to time .    for the task of _ selection",
    "_ , the situation changes dramatically , even within the class of rings . indeed , for the class of rings ,",
    "we show that , if time is @xmath6 , for any @xmath7 , then the optimal size of advice is @xmath5 , and , if time is @xmath8 ( and at most @xmath3 ) then this optimal size is @xmath9 . here",
    "our contribution is three - fold . for selection in time @xmath6 , for any @xmath7 ,",
    "we exhibit , for any positive integer @xmath2 , a class of rings with diameter at most @xmath2 which requires advice of size @xmath27 .",
    "as before , this lower bound is tight , even for time 0 .",
    "further , for selection in time at most @xmath30 , for @xmath31 , we construct a class of rings with diameter @xmath1 which requires advice of size @xmath32 . at first glance",
    ", it might seem that this lower bound is too weak .",
    "indeed , providing either the diameter or the largest label , which are both natural choices of advice , would not give a tight upper bound , as this may require @xmath33 bits .",
    "however , we use a more sophisticated idea that permits us to construct a very compact advice ( of matching size @xmath34 ) and we design a selection algorithm , working for all rings of diameter @xmath1 in time at most @xmath30 , for which this advice is enough .",
    "thus there is an _ exponential _ increase of difficulty ( measured by the size of advice ) between selection in time @xmath6 , for any @xmath7 , and selection in time @xmath8 .",
    "as in the case of election , another huge increase of difficulty occurs between time @xmath3 and time larger than @xmath3 .",
    "these gaps could be called _ intra - task _ jumps of difficulty for selection with respect to time .    as for the comparison between election and selection ,",
    "our results show that , perhaps surprisingly , while for small time , the difficulty of these two tasks on rings is similar , for time @xmath8 the difficulty of election ( measured by the size of advice ) is exponentially larger than that of selection , even for the class of rings . while both in selection and in election the unique leader having the maximum label is chosen , these tasks differ in how widely this label is known .",
    "it follows from our results that , if linear time ( not larger than the diameter ) is available , then the increase of difficulty ( in terms of advice ) of making this knowledge widely known is exponential .",
    "this could be called the _ inter - task _ jump of difficulty between election and selection .",
    "figure [ summarytable ] provides a summary of our results .    ]",
    "* related work . *",
    "the leader election problem was introduced in @xcite .",
    "this problem has been extensively studied in the scenario adopted in the present paper , i.e. , where all nodes have distinct labels . as far as we know ,",
    "this task was always solved by finding either the node with the largest or that with the smallest label .",
    "leader election was first studied for rings . a synchronous algorithm based on label comparisons and using",
    "@xmath35 messages was given in @xcite .",
    "it was proved in @xcite that this complexity is optimal for comparison - based algorithms .",
    "on the other hand , the authors showed an algorithm using a linear number of messages but requiring very large running time .",
    "an asynchronous algorithm using @xmath35 messages was given , e.g. , in @xcite , and the optimality of this message complexity was shown in @xcite .",
    "deterministic leader election in radio networks has been studied , e.g. , in @xcite , as well as randomized leader election , e.g. , in @xcite . in @xcite ,",
    "the leader election problem was approached in a model based on mobile agents for networks with labeled nodes .",
    "many authors @xcite studied leader election in anonymous networks . in particular , @xcite characterize message - passing networks in which leader election can be achieved when nodes are anonymous .",
    "characterizations of feasible instances for leader election were provided in  @xcite .",
    "memory needed for leader election in unlabeled networks was studied in @xcite .",
    "providing nodes or agents with arbitrary kinds of information that can be used to perform network tasks more efficiently has previously been proposed in @xcite .",
    "this approach was referred to as _ algorithms with advice_. the advice is given either to nodes of the network or to mobile agents performing some network task .",
    "in the first case , instead of advice , the term _ informative labeling schemes _ is sometimes used , if ( unlike in our scenario ) different nodes can get different information .",
    "several authors studied the minimum size of advice required to solve network problems in an efficient way . in @xcite ,",
    "given a distributed representation of a solution for a problem , the authors investigated the number of bits of communication needed to verify the legality of the represented solution .",
    "in @xcite , the authors compared the minimum size of advice required to solve two information dissemination problems using a linear number of messages . in @xcite , it was shown that advice of constant size given to the nodes enables the distributed construction of a minimum spanning tree in logarithmic time . in @xcite , the advice paradigm was used for online problems . in @xcite , the authors established lower bounds on the size of advice needed to beat time @xmath36 for 3-coloring cycles and to achieve time @xmath36 for 3-coloring unoriented trees . in the case of @xcite ,",
    "the issue was not efficiency but feasibility : it was shown that @xmath37 is the minimum size of advice required to perform monotone connected graph clearing . in @xcite ,",
    "the authors studied radio networks for which it is possible to perform centralized broadcasting in constant time .",
    "they proved that constant time is achievable with @xmath38 bits of advice in such networks , while @xmath39 bits are not enough . in @xcite",
    ", the authors studied the problem of topology recognition with advice given to nodes .",
    "to the best of our knowledge , the problems of leader election or maximum finding with advice have never been studied before .",
    "notice that in order to perform election in a graph @xmath11 in time larger than its diameter , no advice is needed . indeed , after time @xmath40 , all nodes know the labels of all other nodes , and they are aware that they have this knowledge .",
    "this is because , in round @xmath40 , no messages containing new labels are received by any node .",
    "so , it suffices for all nodes to output the largest of the labels that they have seen up until round @xmath40 .",
    "our first result shows that , if election time is no more than the diameter of the graph , then the size of advice must be at least logarithmic in the diameter .",
    "this demonstrates a dramatic difference between the difficulty of election in time @xmath10 and election in time @xmath40 , measured by the minimum size of advice .",
    "[ diam ] consider any algorithm @xmath41 such that , for every graph @xmath11 , algorithm @xmath41 solves election within @xmath42 rounds .",
    "for every integer @xmath43 , there exists a ring of diameter at most @xmath2 for which algorithm @xmath41 requires advice of size @xmath27 .",
    "fix any integer @xmath43 .",
    "we will show a stronger statement : at least @xmath2 different advice strings are needed in order to solve election within @xmath10 rounds for rings @xmath11 with diameter at most @xmath2 .",
    "the high - level idea of the proof is to first construct a particular sequence of @xmath2 rings of increasing sizes , each with a different largest label . with few advice strings , two such rings",
    "get the same advice .",
    "we show that there is a node in these two rings which acquires the same knowledge when executing algorithm @xmath44 , and hence has to elect the same node in both rings , which is a contradiction .    to obtain a contradiction ,",
    "assume that @xmath45 different advice strings suffice .",
    "consider a ring @xmath46 of diameter @xmath2 whose node labels form the sequence @xmath47 ( see figure [ rings ] ) .",
    "for each @xmath48 , define @xmath49 to be the ring obtained from @xmath46 by taking the subgraph induced by the nodes at distance at most @xmath50 from node @xmath51 and adding an edge between nodes @xmath52 and @xmath53 ( see figure [ rings ] ) .",
    "first , note that , for each @xmath48 , the diameter of @xmath54 is @xmath50 , and , the largest node in @xmath54 has label @xmath53 .",
    "the correctness of @xmath41 implies that , when @xmath41 is executed at a node in @xmath54 , it must halt within @xmath50 rounds and output @xmath53 .",
    "next , by the pigeonhole principle , there exist @xmath55 with @xmath56 such that the same advice string is provided to nodes of both @xmath57 and @xmath58 when they execute @xmath41 .",
    "when executed at node 1 in @xmath57 , algorithm @xmath41 halts in some round @xmath59 and outputs @xmath60 .",
    "we show that , when executed at node 1 in @xmath58 , algorithm @xmath41 also halts in round @xmath18 and outputs @xmath60 .",
    "indeed , the algorithm is provided with the same advice string for both @xmath57 and @xmath58 , and , @xmath61 in @xmath57 is equal to @xmath61 in @xmath58 .",
    "this contradicts the correctness of @xmath41 since , for the ring @xmath58 , there is a node with label @xmath62 . to conclude ,",
    "notice that , since at least @xmath2 different advice strings are needed for the class of rings of diameter at most @xmath2 , the size of advice must be @xmath27 for at least one of these rings .     and",
    "@xmath54 , as constructed in the proof of theorem [ diam ] ]    note that the lower bound established in theorem [ diam ] is tight .",
    "indeed , to achieve election in time @xmath10 for any graph @xmath11 , it is enough to provide the value of @xmath10 to the nodes of the graph and have each node elect the node with the largest label it has seen up until round @xmath10 . hence we have the following corollary for the class of graphs of diameter at most @xmath2 .",
    "[ cor1 ] the optimal size of advice to complete election in any graph in time at most equal to its diameter is @xmath5 .",
    "we next consider accomplishing election in time less than the diameter of the graph .",
    "one way to do it is to provide the maximum label to all nodes as advice .",
    "this yields election in time 0 and uses advice of size @xmath28 , where @xmath0 is the size of the graph , since the space of labels is of size @xmath13 polynomial in @xmath0 .",
    "the following result shows that this size of advice can not be improved for election in _ any _ time below the diameter .",
    "this result , when compared to corollary [ cor1 ] , again shows the dramatic difference in the difficulty of election ( measured by the minimum size of advice ) but now between times @xmath63 and @xmath10 .",
    "consider any positive integers @xmath64 .",
    "there exists @xmath65 such that , for any election algorithm @xmath66 in which every execution halts within @xmath45 rounds , there exists an @xmath0-node graph of diameter @xmath2 for which the size of advice needed by @xmath66 is @xmath67 .",
    "the high - level idea of the proof is the following .",
    "we first construct a family of `` ring - like '' graphs .",
    "for a given number of advice strings , we obtain a lower bound on the number of such graphs for which the same advice is given . on the other hand , an upper bound on this number",
    "is obtained by exploiting the fact that no node can see the entire graph within @xmath45 rounds .",
    "comparing these bounds gives the desired bound on the size of advice .",
    "let @xmath0 be the smallest integer greater than @xmath68 that is divisible by 2d ( and note that @xmath65 ) .",
    "consider a family @xmath69 of @xmath70 pairwise disjoint sets , each of size @xmath71 .",
    "in particular , let @xmath72 , where @xmath73 .",
    "we construct a family @xmath74 of @xmath0-node graphs .",
    "each graph in @xmath74 is obtained by first choosing an arbitrary sequence of @xmath75 sets from @xmath69 , say @xmath76 .",
    "the nodes of the graph are the elements of these sets ( which are integers ) , and this induces a natural labeling of the nodes .",
    "next , for each @xmath77 , add all edges between pairs of elements of the set @xmath78 , as well as all edges between every element in @xmath78 and every element in @xmath79 ( where the indices are taken modulo @xmath75 ) .",
    "in other words , each graph in @xmath74 is a `` fat ring '' , as illustrated in figure [ fatring ] .",
    "we uniquely identify each graph in @xmath74 by its sequence of sets @xmath76 , where the node @xmath80 with the smallest label belongs to the set @xmath81 , and @xmath82 contains the smallest neighbour of @xmath80 outside of @xmath81 .",
    "the size of @xmath83 is calculated in the following claim .     and @xmath84 .",
    "]    * claim 1 * @xmath85 .    to prove the claim , first note that the number of sequences @xmath76 consisting of @xmath75 distinct sets from @xmath69 is @xmath86 . to count the number of such sequences belonging to @xmath87",
    ", we first divide this integer by @xmath75 to eliminate those sequences in which @xmath81 does not contain the smallest label .",
    "then , we divide the result by 2 to eliminate those sequences in which the labels in @xmath88 are smaller than those in @xmath82 .",
    "this completes the proof of the claim .",
    "next , let @xmath89 be the maximum number of advice bits provided to @xmath41 , taken over all graphs in @xmath74 .",
    "by the pigeonhole principle , there exists a family @xmath90 of at least @xmath91 graphs in @xmath74 such that the algorithm receives the same advice string when executed on each graph in @xmath90 .",
    "the following claim will be used to find an upper bound on the size of @xmath90 .",
    "* claim 2 * _ consider two graphs from @xmath90 , say @xmath92 and @xmath93 .",
    "suppose that , for some @xmath94 , algorithm @xmath66 elects a node from set @xmath95 when executed on @xmath96 and elects a node from set @xmath97 when executed on @xmath98 .",
    "if @xmath99 for each @xmath100 , then @xmath101 .",
    "_    to prove the claim , let @xmath102 ) .",
    "since @xmath99 for all @xmath100 , it follows that each node @xmath103 is also an element of @xmath104 , and , moreover , for each such @xmath16 , knowledge @xmath105 in @xmath96 is equal to knowledge @xmath105 in @xmath98 . the nodes of @xmath106 output some label @xmath107 at the end of the execution of @xmath66 on @xmath96 .",
    "since we assumed that every execution of @xmath44 halts within @xmath45 rounds , and the same advice is given for @xmath96 and @xmath98 , the nodes of @xmath104 also output label @xmath107 at the end of execution of @xmath66 on @xmath98 .",
    "since @xmath66 elects a node from @xmath95 when executed on @xmath96 and elects a node from @xmath97 when executed on @xmath98 , it follows that @xmath107 is a label that appears in both @xmath95 and @xmath97 .",
    "as the sets in @xmath69 are pairwise disjoint , it follows that @xmath101 .",
    "this concludes the proof of the claim .",
    "using claim 2 , we now obtain an upper bound on the size of @xmath90 .",
    "in particular , for each @xmath94 , consider the subfamily of graphs @xmath76 in @xmath90 such that algorithm @xmath66 elects a node from @xmath108 .",
    "by the claim , for each choice of the @xmath109 sets @xmath110 , there is exactly one set @xmath108 such that @xmath76 belongs to @xmath90 .",
    "the number of such choices is bounded above by @xmath111 .",
    "since this is true for all @xmath75 possible values for @xmath20 , we get that @xmath112 . comparing this upper bound to our lower bound on @xmath113",
    ", it follows from claim 1 that @xmath114 .",
    "re - arranging this inequality , we get that @xmath115 , and hence @xmath116 .",
    "hence we have the following corollary .",
    "the optimal size of advice to complete election in any graph in time less than its diameter is @xmath117 .",
    "in this section , we study the selection problem for the class of rings .",
    "it turns out that significant differences between election and selection can be exhibited already for this class . as in the case of election , and for the same reasons , selection in time larger than the diameter can be accomplished without any advice .",
    "hence , in the rest of the section , we consider selection in time at most equal to the diameter . for",
    "any ring @xmath46 and any selection algorithm @xmath118 , denote by @xmath119 the advice string provided to all nodes in @xmath46 when they execute algorithm @xmath118 .",
    "denote by @xmath120 the node that outputs 1 in the execution of algorithm @xmath118 on ring @xmath46 .",
    "we first look at selection algorithms working in time at most @xmath121 , for any ring @xmath46 and any constant @xmath122 .",
    "we start with the lower bound on the size of advice needed by any selection algorithm working in time equal to the diameter of the ring .",
    "this lower bound shows that , for any positive integer @xmath2 , there exists a ring with diameter at most @xmath2 for which such an algorithm requires @xmath32 bits of advice .",
    "of course , this implies the same lower bound on the size of advice for selection in any smaller time .",
    "the following theorem provides our first lower bound on the size of advice for selection .",
    "[ lb1 ] consider any selection algorithm @xmath118 such that , for any ring @xmath46 , algorithm @xmath118 halts within @xmath123 rounds . for every positive integer @xmath2 , there exists a ring @xmath46 of diameter at most @xmath2 for which algorithm @xmath118 requires advice of size @xmath32 .    at a high level we consider a `` rings - into - bins '' problem , in which each bin represents a distinct advice string .",
    "we recursively construct sets of rings , such that the rings constructed at a given recursion level can not be put into the same bin as previously - constructed rings .",
    "we continue the construction long enough to run out of bins .",
    "with few bins , the number of levels of recursion is sufficiently small to keep the diameters of the constructed rings bounded by @xmath2 .",
    "the following claim will be used to show that a particular ring that we construct will cause algorithm @xmath118 to fail .",
    "we will use the following _ chopping _ operation in our constructions . for any selection algorithm @xmath118 and",
    "any ring @xmath46 of odd size , we define the _ chop _ of @xmath46 , denoted by @xmath124 , to be the path obtained from @xmath46 by removing the edge between the two nodes at distance @xmath123 from @xmath120 ( see figure [ chopandglue](a ) ) .",
    "* claim 1 * _ consider any selection algorithm @xmath118 such that , for any ring @xmath46 , algorithm @xmath118 halts within @xmath123 rounds .",
    "consider two disjoint rings @xmath125 of odd size such that @xmath126 .",
    "for any ring @xmath127 that contains @xmath128 and @xmath129 as subgraphs such that @xmath130 , two distinct nodes in @xmath127 output 1 when executing @xmath118 .",
    "_    in order to prove the claim , consider the execution of @xmath118 by the nodes of @xmath127 . using the definition of @xmath128 , it can be shown that knowledge @xmath131 in @xmath127 is equal to knowledge @xmath131 in @xmath132 .",
    "therefore , the execution of @xmath118 at node @xmath133 in @xmath127 halts in round @xmath134 , and @xmath133 outputs 1 . similarly , the execution of @xmath118 at node @xmath135 in @xmath127 halts in round @xmath136 , and @xmath135 outputs 1 .",
    "since @xmath132 and @xmath137 are disjoint , we have that @xmath138 .",
    "hence , two distinct nodes in @xmath127 output 1 when executing @xmath118 .",
    "this proves the claim .",
    "it is enough to prove the theorem for sufficiently large @xmath2 .",
    "fix any integer @xmath139 and set the label space to be @xmath140 . to obtain a contradiction ,",
    "assume that @xmath141 different advice strings suffice .",
    "form a family @xmath142 of @xmath143 disjoint sequences of integers , each of size 3 .",
    "more specifically , let @xmath144 .",
    "let @xmath145 .",
    "note that @xmath146 is a set of integer labels , each of which is larger than all labels that belong to sequences in @xmath142 . to verify that we have enough labels to define these sets , note that the largest label @xmath147!)$ ] . using the inequality @xmath148",
    ", we get that @xmath149 .",
    "when @xmath139 , one can verify that @xmath150{\\log d}$ ] , and @xmath151{(\\log d)^5 } + \\sqrt[3]{\\log d } < \\log d$ ] , so @xmath152 .",
    "it follows that @xmath153 .",
    "next , we construct a special family @xmath154 of rings of diameter at most @xmath2 .",
    "we will add rings to @xmath154 by following a procedure that we will describe shortly .",
    "each new ring that we add to @xmath154 will be the result of at most one ` gluing ' operation , denoted by @xmath155 , that takes two disjoint odd - sized rings @xmath156 and forms a new odd - sized ring @xmath127 . more specifically , the @xmath157 gluing operation takes two disjoint odd - sized rings @xmath132 and @xmath137 and forms the new ring defined as follows : construct paths @xmath128 and @xmath129 , add a new edge between the leaf of @xmath128 with smaller label and the leaf of @xmath129 with smaller label , add a new node with label @xmath158 , and add edges from this new node to the two remaining leaves .",
    "the gluing operation is illustrated in figure [ chopandglue](b ) .",
    "the additional node is introduced so that the resulting ring has an odd number of nodes .",
    "note that this additional node s label comes from @xmath146 , which ensures that the new ring formed by a gluing operation does not contain duplicate labels .",
    "further , note that , due to the dependence of the additional node s label on @xmath20 , no two gluing operations introduce additional nodes with the same label .     from node @xmath159 is removed .",
    "( b ) the glue operation on two rings of size 3 : concatenate paths @xmath128 , @xmath129 and add an additional node @xmath80 with a label from @xmath146 . ]    we now describe the procedure for adding rings to @xmath154 . in stage 1",
    ", we consider the set @xmath160 of 3-cliques obtained from each sequence in @xmath142 by identifying each integer with a node and adding all edges between them .",
    "we take a subset @xmath161 of size at least @xmath162 such that the same advice string is provided to the algorithm for each ring in @xmath82 .",
    "the rings in @xmath82 are added to @xmath154 , which concludes stage 1 . in each stage @xmath163",
    ", we consider the set @xmath164 of rings that were added to @xmath154 in stage @xmath165 .",
    "the elements of @xmath164 are partitioned into @xmath166 pairs of rings in an arbitrary way . for each such pair @xmath156",
    ", we perform @xmath155 . define @xmath167 to be the set of all of the resulting rings .",
    "we take a subset @xmath168 of size at least @xmath169 such that the same advice string is provided to the algorithm for each ring in @xmath78 .",
    "the rings in @xmath78 are added to @xmath154 , which concludes stage @xmath170 .",
    "this concludes the construction of @xmath154 .    it is not immediately clear that this construction can always be carried out .",
    "in particular , in order to define @xmath78 in each stage @xmath171 , there must exist @xmath169 rings in @xmath167 such that the same advice string is provided to the algorithm for each .",
    "to prove this fact , and to obtain the desired contradiction to prove the theorem , we will use the following two claims .",
    "* claim 2 * _ consider any @xmath172 and any ring @xmath173 .",
    "for every @xmath174 , there exists a ring @xmath175 such that @xmath124 contains @xmath176 as a subgraph .",
    "_    to prove the claim , we proceed by induction on @xmath50 .",
    "the case where @xmath177 is trivial .",
    "next , assume that , for some @xmath172 and any ring @xmath173 , for every @xmath174 , there exists a ring @xmath175 such that @xmath124 contains @xmath176 as a subgraph .",
    "we now prove that , for any @xmath178 , there exists a ring @xmath179 such that @xmath124 contains @xmath180 as a subgraph . by construction , @xmath181 for some disjoint rings @xmath182 . by the definition of the gluing operation",
    ", @xmath46 contains both @xmath128 and @xmath129 as disjoint subgraphs .",
    "since @xmath124 has one fewer edge than @xmath46 , at least one of @xmath128 and @xmath129 is a subgraph of @xmath124 . by induction , this proves claim 2 .",
    "* claim 3 * _ consider any @xmath183 with @xmath174 .",
    "for any ring @xmath184 , there exist disjoint @xmath185 such that @xmath186 contains @xmath187 and @xmath176 as subgraphs . _    to prove the claim , note that , by our construction , @xmath188 for some disjoint @xmath189 .",
    "it follows that @xmath128 and @xmath129 are disjoint subgraphs of @xmath186 . if @xmath190 , setting @xmath191 and @xmath192 satisfies the statement of the claim .",
    "if @xmath193 , then , by claim 2 , there exists a ring @xmath194 such that @xmath128 contains @xmath187 as a subgraph . similarly , there exists a ring @xmath175 such that @xmath129 contains @xmath176 as a subgraph .",
    "note that , since @xmath132 and @xmath137 are disjoint , it follows that @xmath187 and @xmath176 are disjoint , so @xmath195 and @xmath196 are disjoint .",
    "thus , @xmath195 and @xmath196 satisfy the statement of the claim , which concludes its proof .",
    "we now show that , in any fixed stage of the above construction of @xmath154 , the advice string that is provided for the rings added to @xmath154 in this stage is different than the advice strings provided for the rings added to @xmath154 in all previous stages .",
    "* claim 4 * _ consider any @xmath183 with @xmath174 . for any ring @xmath197 and any ring @xmath198",
    ", we have @xmath199 . _    to prove the claim , notice that",
    ", by claim 3 , there exist disjoint @xmath185 such that @xmath200 contains @xmath187 and @xmath176 as subgraphs . recall that the algorithm is provided the same advice string for all graphs in @xmath201 , so @xmath202 . by claim 1 and the correctness of @xmath44 , it follows that @xmath203 .",
    "hence , @xmath204 , which completes the proof of claim 4 .    we show that the construction of @xmath154 can always be carried out .",
    "* claim 5 * _ for all @xmath172 , in stage @xmath50 of the construction , there exist at least @xmath205 rings in @xmath206 such that the same advice string is provided to the algorithm for each of them .",
    "_    to prove the claim , first note that , for @xmath177 , there are @xmath207 different strings that could be used as advice for rings in @xmath160 .",
    "so , by the pigeonhole principle , there are at least @xmath208 rings in @xmath160 such that the same advice string is provided to the algorithm for each of them .",
    "next , for any @xmath209 , claim 4 implies that there are @xmath210 strings that are not provided to the algorithm as advice for rings in @xmath206 .",
    "namely , there are at most @xmath211 different strings used as advice for rings in @xmath206 . by the pigeonhole principle , there are at least @xmath205 rings in @xmath206 such that the same advice string is provided to the algorithm for each of them , which proves the claim .",
    "the following claim implies that @xmath212 , for all @xmath213 .",
    "later , we will use two rings from some @xmath78 to obtain the desired contradiction needed to complete the proof of the theorem .",
    "* claim 6 * _ for all @xmath171 , at the end of stage @xmath170 , @xmath214 .",
    "we prove the claim by induction on @xmath170 .",
    "when @xmath215 , we have @xmath216 . by claim 5 , there exist at least @xmath217 rings in @xmath160 such that the same advice string is provided to the algorithm for each of them .",
    "this implies that @xmath218 , as required . as induction hypothesis ,",
    "assume that , at the end of some stage @xmath219 , @xmath214 . in stage @xmath220",
    ", the set @xmath201 is partitioned into pairs and @xmath221 consists of one ( glued ) ring for each such pair .",
    "thus , @xmath222 . by claim 5 , there exist at least @xmath223 rings in @xmath221 such that the same advice string is provided to the algorithm for each of them .",
    "this implies that @xmath224 , as required .",
    "this concludes the proof of claim 6 .",
    "finally , we construct a ring @xmath225 on which algorithm @xmath118 fails .",
    "note that the rings in @xmath154 all have node labels from the sets @xmath142 and @xmath146 , and we proved that the largest integer in these sets is less than @xmath2 .",
    "thus , the rings in @xmath154 all have node labels from the range @xmath226 . to construct @xmath225",
    ", we take any two ( disjoint ) rings @xmath227 ( which exist by claim 6 ) and form a ring @xmath225 consisting of the concatenation of paths @xmath128 , @xmath129 , and the path of @xmath2 nodes with labels @xmath228 .",
    "recall that , in the construction , all rings in @xmath78 , for any fixed @xmath213 , get the same advice string . by claim 4 ,",
    "each of the @xmath207 distinct advice strings is used for rings in some @xmath78 .",
    "therefore , there exists a stage @xmath170 such that the advice provided for all graphs in @xmath78 is the string @xmath229 . by claim 2 ,",
    "there exists a ring @xmath194 such that @xmath128 contains @xmath187 as a subgraph , and , there exists a ring @xmath175 such that @xmath129 contains @xmath176 .",
    "it follows that @xmath225 contains @xmath187 and @xmath176 as subgraphs , and @xmath230 .",
    "by claim 1 , when algorithm @xmath118 is executed by the nodes of ring @xmath225 , two distinct nodes output 1 , which contradicts the correctness of @xmath118 . note that the size of @xmath225 is at least @xmath2 and at most @xmath75 , which implies that the size of the label space is linear in the size of @xmath225 .",
    "the obtained contradiction was due to the assumption that @xmath141 .",
    "hence the number @xmath207 of different advice strings is at least @xmath231 , which implies that the size of advice is @xmath232 for some ring of diameter at most @xmath2 .",
    "since imposing less time can not make the selection task easier , we have the following corollary .",
    "[ cor ] for any constant @xmath31 , consider any selection algorithm @xmath118 such that , for any ring @xmath46 , algorithm @xmath118 halts within @xmath121 rounds .",
    "for every positive integer @xmath2 , there exists a ring @xmath46 of diameter at most @xmath2 for which algorithm @xmath118 requires advice of size @xmath32 .",
    "we now establish an upper bound on the size of advice that matches the lower bound from theorem [ lb1 ] .",
    "let @xmath2 be any positive integer and let @xmath13 be a power of 2 .",
    "we consider algorithms that solve selection on the class of rings with diameter at most @xmath2 and labels from @xmath233 .",
    "recall that we assume that @xmath13 is polynomial in the size of the ring , and hence also in @xmath2 .    in order to prove the upper bound",
    ", we propose a family of selection algorithms such that , for each fixed @xmath234 $ ] , there is an algorithm in the family that takes @xmath34 bits of advice , and , for each ring @xmath46 , halts within @xmath121 rounds .",
    "we start with an informal description of the algorithm and the advice for any fixed @xmath234 $ ] .",
    "the algorithm consists of two stages , and the advice consists of two substrings @xmath235 and @xmath236 .    for any ring @xmath46 ,",
    "the substring @xmath235 of the advice is the binary representation of the integer @xmath237 .",
    "the size of this advice is @xmath34 .",
    "note that @xmath238 .    in stage 1 of the algorithm",
    "the nodes perform @xmath239 communication rounds , after which each node @xmath16 has acquired knowledge @xmath17 .",
    "next , each node @xmath16 checks if its own label is the largest of the labels it has seen within @xmath18 communication rounds , i.e. , the largest in the set @xmath19 .",
    "if not , then @xmath16 outputs 0 and halts immediately .",
    "let @xmath240 be the set of _ candidate nodes _ , i.e. , nodes @xmath16 whose label is the largest in @xmath19 . clearly , the largest node in @xmath46 is in @xmath241 , and every node knows if it belongs to @xmath240 .",
    "nodes in @xmath240 proceed to the next stage of the algorithm .    in stage 2 of the algorithm",
    ", each node in @xmath240 determines whether or not it is the largest node in @xmath46 , without using any further communication rounds .",
    "this is achieved using @xmath236 , the second substring of the advice , which we now describe .",
    "let @xmath242 be the family of sets of labels which contain all labels in @xmath241 and no larger labels .",
    "at a high level , we construct an integer colouring @xmath243 of the family @xmath242 such that , for any @xmath244 , when the colour @xmath245 is given as advice to candidate nodes , each of them can determine , without any communication , whether or not it is the candidate node with the largest label . call such a colouring _ discriminatory_.",
    "substring @xmath236 of the advice will be @xmath245 for some @xmath244 and some discriminatory colouring @xmath243 of @xmath242 .",
    "( we can not simply use @xmath246 because our colouring @xmath243 will be defined on sets of fixed size , and sets of candidate nodes for different rings do not have to be of equal size . ) using @xmath236 , the candidate nodes solve selection among themselves .",
    "this concludes the high - level description of the algorithm .",
    "the main difficulty of the algorithm is finding a discriminatory colouring @xmath243 .",
    "for example , bijections are trivially discriminatory , as nodes could deduce the set @xmath247 .",
    "however , we can not use such a colouring .",
    "indeed , the colouring must use few colours , otherwise the advice would be too large",
    ". we will be able to construct a discriminatory colouring with few colours using the fact that the number of candidate nodes is bounded by a constant that depends only on @xmath248 , as given in the following lemma .",
    "[ boundcandidates ] @xmath249 .",
    "first note that @xmath250 since the largest node @xmath16 in @xmath46 also has the largest label in @xmath19 .",
    "if @xmath251 , then @xmath252 is at most the number of nodes in @xmath46 , i.e. , at most @xmath253 , which is at most @xmath254 .",
    "hence we may assume that @xmath255 .",
    "next , note that there can not be two candidate nodes @xmath256 such that the distance between them is at most @xmath18 . indeed , if @xmath257 and @xmath258 , then the node in @xmath259 with smaller label will not be a candidate .",
    "since the number of nodes in @xmath46 is @xmath260 , it follows that the number of candidate nodes is less than @xmath261 . since @xmath262 and @xmath237",
    ", it can be shown that @xmath263 is at most @xmath264 .",
    "this completes the proof of the lemma .",
    "we define what it means for a colouring to be _ legal_. it will be shown that a legal colouring known by all nodes is discriminatory .",
    "let @xmath265 .",
    "let @xmath266 denote the set of all @xmath267-tuples of the form @xmath268 such that @xmath269 and @xmath270 .",
    "( we identify the tuple @xmath268 with the set @xmath271 . )",
    "a colouring @xmath243 of elements of @xmath266 by integers is _ legal _ if , for each colour @xmath272 and each integer @xmath273 , either    1 .",
    "every @xmath274 that contains @xmath275 and is coloured @xmath272 has @xmath276 , or , 2 .",
    "every @xmath274 that contains @xmath275 and is coloured @xmath272 has @xmath277 .    informally , a colouring of sets of labels is legal if , for all sets of a given colour in which a label @xmath275 appears , @xmath275 is either always the largest label or never the largest label .",
    "assume that we have a legal colouring @xmath243 of @xmath266 that uses @xmath278 colours , and that each node knows @xmath243 .",
    "using @xmath243 , we provide a complete description of our algorithm with advice of size @xmath34 and prove that it is correct .",
    "we will then describe such a legal colouring @xmath243 .    in order to complete the description",
    ", it remains to construct a legal colouring @xmath243 that uses @xmath279 colours .",
    "note that , since @xmath13 is polynomial in @xmath2 , that the number of colours is indeed @xmath280 .",
    "consider the following mapping @xmath281 that maps each @xmath282 to a @xmath283-tuple @xmath284",
    ". for each @xmath285 , set @xmath286 to be the largest integer @xmath170 such that there exists an integer in the range @xmath287 $ ] that is divisible by @xmath288 .",
    "next , take any bijection @xmath289 between @xmath290 and the set @xmath291 . define the colouring @xmath243 of @xmath266 as the composition of @xmath292 and @xmath289 .",
    "note that the colouring @xmath243 uses at most @xmath293 colours .",
    "[ islegal ] @xmath243 is a legal colouring of the elements of @xmath266 .",
    "consider an arbitrary colour @xmath294 and any integer @xmath273 . to obtain a contradiction ,",
    "assume that :    * there exists an element of @xmath266 , say @xmath295 , that contains @xmath275 , is coloured @xmath272 , and has @xmath296 , and , * there exists an element of @xmath266 , say @xmath297 , that contains @xmath275 , is coloured @xmath272 , and has @xmath298 .",
    "let @xmath299 .",
    "since @xmath295 contains @xmath275 and @xmath296 , it follows that @xmath300 for some @xmath285 . by the definition of @xmath292 , we know that the range @xmath301 $ ] contains an integer , say @xmath302 , that is divisible by @xmath303 , and we know that no integer in this range is divisible by @xmath304 . moreover , since @xmath298 , we know that the range @xmath305 $ ] contains an integer , say @xmath306 , that is divisible by @xmath303 , and we know that no integer in this range is divisible by @xmath307 .",
    "it follows that there are two distinct integers @xmath308 in the range @xmath309 $ ] that are divisible by @xmath310 and that no integer in the range @xmath309 $ ] is divisible by @xmath307 . since @xmath311 is the smallest integer greater than @xmath302 that is divisible by @xmath310 , it follows that @xmath312 \\in [ x_0 + 1,\\ldots , y_i]$ ] , so @xmath311 is not divisible by @xmath307 .",
    "note that , for some positive integer @xmath313 , we can write @xmath314 and @xmath315 . since neither @xmath302 nor @xmath316 is divisible by @xmath307 , it follows that both @xmath313 and @xmath317 must be odd , a contradiction .",
    "[ ub ] consider any fixed @xmath234 $ ] and any positive integer @xmath2 . for any ring @xmath46 with diameter at most @xmath2 , algorithm select solves selection in the ring @xmath46 in time @xmath318 and with advice of size @xmath34 .",
    "notice that algorithm select halts within @xmath318 communication rounds .",
    "indeed , by line 2 of the algorithm , every node uses exactly @xmath319 communication rounds , and @xmath320 .",
    "next , note that since @xmath235 is the binary representation of @xmath321 , the length of @xmath235 is @xmath34 .",
    "further , recall that @xmath236 is the binary representation of a colour assigned by @xmath243 , which uses @xmath278 colours where @xmath322 .",
    "thus , the length of @xmath236 is @xmath34 , and hence the size of advice is @xmath34 .",
    "finally , we prove the correctness of the algorithm for an arbitrary ring @xmath46 .",
    "first , note that the construction of the advice string can indeed be carried out .",
    "in particular , at line 6 in the advice construction , the tuple @xmath323 exists since , by lemma [ boundcandidates ] , the number of candidates ( and , hence , the value of @xmath324 ) is bounded above by @xmath267 .",
    "next , recall that @xmath242 is the family of sets of labels which contain all labels in @xmath241 and no larger labels .",
    "the following claim shows that the colouring @xmath243 is discriminatory .",
    "* claim 1 * _ for any @xmath325 , let @xmath326 . when lines 6  11 of algorithm select are executed , the largest node in @xmath240 outputs 1 , and all other nodes in @xmath240 output 0 .",
    "this proves that colouring @xmath243 is discriminatory . _",
    "to prove the claim , consider the largest node @xmath327 .",
    "we first show that @xmath328 is equal to @xmath329 s label . indeed ,",
    "since @xmath329 has the largest label in @xmath330 , it follows that @xmath331 . since @xmath247 does not contain labels larger than those in @xmath241 , @xmath328 is equal to @xmath329 s label .",
    "next , note that , by line 7 , @xmath332 . since @xmath333 is equal to @xmath329 s label , the condition of the * if * statement at line 8 evaluates to true , so @xmath329 outputs 1 .",
    "next , consider any node @xmath334 that is not the largest .",
    "since @xmath333 is not equal to @xmath16 s label and @xmath243 is a legal colouring , it follows that no tuple that is coloured @xmath335 has @xmath16 s label as its first entry . in other words ,",
    "no tuple in @xmath336 has @xmath16 s label as its first entry , so the * if * statement at line 8 evaluates to false , and @xmath16 outputs 0 .",
    "this completes the proof of the claim .",
    "we have shown that , if the nodes in @xmath240 are provided as advice the value of @xmath245 for any @xmath337 , then lines 6  11 of algorithm select solve selection among the nodes in @xmath240 .",
    "it remains to show that the advice substring @xmath236 created in the advice construction is indeed the binary representation of such an @xmath245 .",
    "* claim 2 * _ in advice construction , @xmath338 .",
    "_    to prove the claim , recall that , by line 4 of the advice construction , @xmath339 is the decreasing sequence of labels of nodes in @xmath240 .",
    "consider line 6 of the advice construction , and note that the largest element @xmath328 of the tuple @xmath340 is equal to @xmath341 , which proves that the labels @xmath342 are no larger than those of nodes in @xmath240 .",
    "further , since @xmath343 and @xmath344 , it follows that @xmath340 contains all of the labels of nodes in @xmath241 .",
    "therefore , @xmath338 , as claimed .",
    "we can now conclude that algorithm select solves selection in the entire ring .",
    "indeed , in lines 1  4 , each node that learns about the existence of a node with a larger label than itself outputs 0 and halts .",
    "the remaining nodes , namely those in @xmath240 ( which necessarily includes the largest node ) , proceed to lines 5  11 . from line 7 of the advice construction and by claim 2 ,",
    "line 5 of algorithm select assigns to @xmath335 the value of @xmath245 for some @xmath337 .",
    "finally , claim 1 shows that the largest node outputs 1 and all other nodes output 0 .",
    "corollary [ cor ] and theorem [ ub ] imply the following tight bound on the size of advice .",
    "the optimal size of advice to complete selection in any ring in time linear in its diameter ( and not exceeding it ) is @xmath9 .",
    "we now turn attention to very fast selection for rings of diameter @xmath2 . since every such ring has size @xmath0 linear in @xmath2 , and since @xmath13 is polynomial in @xmath0 , selection ( and even election ) can be accomplished using @xmath29 bits of advice without any communication by providing the largest label as advice .",
    "it turns out that , even when the available time is @xmath345 , for any constant @xmath346 , this size of advice is necessary .",
    "compared to theorem [ ub ] , this shows that selection in time @xmath345 where @xmath346 , requires exponentially more advice than selection in time @xmath25 .    for any constant @xmath347 , any selection algorithm @xmath44 for rings of diameter @xmath2 that works in time at",
    "most @xmath345 requires @xmath27 bits of advice .",
    "it is enough to consider sufficiently large values of @xmath2 .",
    "let @xmath348 , and let @xmath349 .",
    "we start by defining a special class of rings , and then proceed to show that algorithm @xmath44 requires @xmath27 bits of advice for this class . for the sake of clarity , we will use the notation @xmath350 and @xmath351 .",
    "first , we define a set of paths @xmath352 as follows .",
    "each path consists of @xmath353 nodes with labels from @xmath186 , with the middle node of the path having the largest label .",
    "more specifically , path @xmath354 is obtained by considering the path of nodes with labels @xmath355 , respectively , and reversing the order of the last @xmath356 labels .",
    "formally , for each @xmath357 , let @xmath354 be the path of nodes whose labels form the sequence @xmath358 .",
    "next , we define a set @xmath359 of rings @xmath360 .",
    "each ring @xmath361 will consist of the paths @xmath362 along with enough nodes with labels from @xmath363 to ensure that @xmath361 has size @xmath75 . in order to define the ring @xmath361",
    ", we first construct a path @xmath364 by taking the paths @xmath365 , and , for each @xmath366 , connecting the last node of path @xmath367 with the first node of path @xmath195 .",
    "more specifically , @xmath364 is obtained by taking the union of the paths @xmath365 , and , for each @xmath366 , adding an edge between the nodes with labels @xmath368 and @xmath369 .",
    "next , we construct a path @xmath370 whose labels form the sequence @xmath371 . since the number of nodes in @xmath364 is at most @xmath372 , which , for sufficiently large @xmath2 , is strictly less than @xmath75 , it follows that path @xmath370 has at least one node .",
    "finally , the ring @xmath361 is obtained by joining the paths @xmath364 and @xmath370 .",
    "more specifically , @xmath361 is obtained by taking the union of the paths @xmath364 and @xmath370 and adding the edges @xmath373 and @xmath374 .",
    "the paths and rings constructed above are illustrated in figure [ pathsrings ] .    ]",
    "the following claim asserts that , in any two rings in @xmath359 that contain path @xmath354 as a subgraph , the middle node of this path in both rings acquires the same knowledge when executing algorithm @xmath44 .",
    "* claim 1 * _ consider any @xmath357 and any @xmath375 .",
    "let @xmath376 be the node in @xmath361 with label @xmath377 and let @xmath378 be the node in @xmath379 with label @xmath377 .",
    "then , knowledge @xmath380 in @xmath361 is equal to knowledge @xmath381 in @xmath379 . _    to prove the claim , note that , in both @xmath361 and @xmath379 , the node with label @xmath377 is the middle node of path @xmath354 .",
    "since the path @xmath354 has length @xmath353 , it follows that , within @xmath80 communication rounds , node @xmath376 does not learn about any nodes in @xmath361 outside of @xmath354 . similarly , node @xmath378 does not learn about any nodes in @xmath379 outside of @xmath354 .",
    "this implies that knowledge @xmath380 in @xmath361 is equal to knowledge @xmath381 in @xmath379 , which completes the proof of the claim .",
    "we proceed to prove the theorem by way of contradiction .",
    "assume that the number of bits of advice needed by algorithm @xmath41 for the rings in @xmath154 is less than @xmath382 .",
    "it follows that the number of distinct advice strings that are provided to algorithm @xmath44 for the rings in @xmath359 is strictly less than @xmath383 .",
    "however , since the class @xmath359 consists of @xmath384 rings ( where @xmath385 for sufficiently large @xmath2 ) this means that there exist two rings in @xmath359 , say @xmath386 with @xmath387 , such that @xmath388 .",
    "first , consider the execution of @xmath44 by the nodes of ring @xmath389 .",
    "let @xmath390 be the node in @xmath389 with label @xmath391 , and note that @xmath390 is the largest node in @xmath389 .",
    "it follows that , in this execution , node @xmath390 outputs 1 .",
    "next , consider the execution of @xmath44 by the nodes of ring @xmath392 .",
    "let @xmath393 be the node in @xmath392 with the label @xmath391 .",
    "by claim 1 , @xmath394 in @xmath389 is equal to @xmath395 in @xmath392 .",
    "moreover , algorithm @xmath44 halts within @xmath80 rounds and @xmath388 .",
    "it follows that the execution of @xmath44 by @xmath390 in @xmath389 is identical to the execution of @xmath44 by @xmath393 in @xmath392 .",
    "hence , @xmath393 outputs 1 in the execution of @xmath44 in @xmath392 . however , node @xmath393 is not the largest in @xmath392 .",
    "indeed , @xmath393 s label is @xmath391 , whereas path @xmath396 ( and , hence , ring @xmath392 ) contains a node labeled @xmath397 .",
    "this contradicts the correctness of  @xmath44 .    for any constant @xmath346 , the optimal size of advice to complete selection in any ring of diameter at most @xmath2 in time",
    "@xmath345 is @xmath5 .",
    "we established tradeoffs between the time of choosing the largest node in a network and the amount of _ a priori _ information ( advice ) needed to accomplish two variations of this task : election and selection .",
    "for the election problem , the tradeoff is complete and tight up to multiplicative constants in the advice size .",
    "moreover , it holds for the class of arbitrary connected graphs . for selection ,",
    "our results are for the class of rings and a small gap remains in the picture .",
    "we proved that in rings with diameter @xmath3 at most @xmath2 , the optimal size of advice is @xmath5 if time is @xmath6 for any @xmath7 , and that it is @xmath9 if time is at most @xmath3 .",
    "hence , the first open problem is to establish the optimal size of advice to perform selection for rings when the time is in the small remaining gap , for example , in time @xmath398 .",
    "another problem is to extend the tradeoff obtained for selection in rings to the class of arbitrary connected graphs . in particular , it would be interesting to investigate whether the optimal advice needed to perform fast selection in graphs of size much larger than the diameter depends on their size ( like in the case of election ) or on their diameter .    as noted in the introduction ,",
    "all known leader election algorithms in labeled networks choose as leader either the node with the largest label or that with the smallest label .",
    "it is worth noting that the situation is not always symmetric here .",
    "for example , the time slice algorithm for leader election @xcite ( which elects the leader using exactly @xmath0 messages in @xmath0-node rings , at the expense of possibly huge time ) finds the node with the smallest label , and it does not seem to be possible to convert it directly to finding the node with the largest label .",
    "( of course it is possible to first find the node with the smallest label and then to use this leader to find the node with the largest label , but this takes additional time and communication . ) in our case , however , the situation is completely symmetric with respect to the order of labels : our results hold without change , if finding the largest node is replaced by finding the smallest .",
    "it is an open question whether they also remain valid if electing the largest node is replaced by general leader election ( i.e. , the task in which a single _ arbitrary _ node becomes the leader , and all other nodes become non - leaders and also learn the identity of the leader ) and if selecting the largest node is replaced by general leader selection ( i.e. , the task in which a single _ arbitrary _ node becomes the leader , and all other nodes become non - leaders ) .",
    "our lower bound for election in time at most the diameter and our algorithms for selection use the ordering in an essential way , and it is not clear if smaller advice would be sufficient to elect or select some arbitrary node in a given time .",
    "p. boldi , s. shammah , s. vigna , b. codenotti , p. gemmell , and j. simon , symmetry breaking in anonymous networks : characterizations .",
    "4th israel symposium on theory of computing and systems , ( istcs 1996 _ ) , 16 - 26 .",
    "j. chalopin , local computations on closed unlabelled edges : the election problem and the naming problem _ proc .",
    "31st conference on current trends in theory and practice of computer science ( sofsem 2005 ) _ , 82 - 91 .",
    "p. fraigniaud , d. ilcinkas , a. pelc , communication algorithms with advice , journal of computer and system sciences 76 ( 2010 ) , 222232 .",
    "p. fraigniaud , d. ilcinkas , a. pelc , tree exploration with advice , information and computation 206 ( 2008 ) , 12761287 .",
    "p. fraigniaud , a. korman , e. lebhar , local mst computation with short advice , theory of computing systems 47 ( 2010 ) , 920933 .",
    "haddar , a.h .",
    "kacem , y. mtivier , m. mosbah , and m. jmaiel , electing a leader in the local computation model using mobile agents .",
    "6th acs / ieee international conference on computer systems and applications ( aiccsa 2008 _ ) , 473 - 480 ."
  ],
  "abstract_text": [
    "<S> finding the node with the largest label in a labeled network , modeled as an undirected connected graph , is one of the fundamental problems in distributed computing . </S>",
    "<S> this is the way in which _ leader election _ is usually solved . </S>",
    "<S> we consider two distinct tasks in which the largest - labeled node is found deterministically . in _ selection _ , this node has to output 1 and all other nodes have to output 0 . in _ </S>",
    "<S> election _ , the other nodes must additionally learn the largest label ( everybody has to know who is the elected leader ) . </S>",
    "<S> our aim is to compare the difficulty of these two seemingly similar tasks executed under stringent running time constraints . </S>",
    "<S> the measure of difficulty is the amount of information that nodes of the network must initially possess , in order to solve the given task in an imposed amount of time . following the standard framework of _ algorithms with advice _ , this information ( a single binary string ) </S>",
    "<S> is provided to all nodes at the start by an oracle knowing the entire graph . </S>",
    "<S> the length of this string is called the _ size of advice_. the paradigm of algorithms with advice has a far - reaching importance in the realm of network algorithms . </S>",
    "<S> lower bounds on the size of advice give us impossibility results based strictly on the _ amount _ of initial knowledge outlined in a model s description . </S>",
    "<S> this more general approach should be contrasted with traditional results that focus on specific _ kinds _ of information available to nodes , such as the size , diameter , or maximum node degree .    </S>",
    "<S> consider the class of @xmath0-node graphs with any diameter @xmath1 , for some integer @xmath2 . </S>",
    "<S> if time is larger than @xmath3 , then both tasks can be solved without advice . </S>",
    "<S> for the task of _ election _ , we show that if time is smaller than @xmath3 , then the optimal size of advice is @xmath4 , and if time is exactly @xmath3 , then the optimal size of advice is @xmath5 . for the task of _ selection </S>",
    "<S> _ , the situation changes dramatically , even within the class of rings . indeed , for the class of rings , </S>",
    "<S> we show that , if time is @xmath6 , for any @xmath7 , then the optimal size of advice is @xmath5 , and , if time is @xmath8 ( and at most @xmath3 ) then this optimal size is @xmath9 . </S>",
    "<S> thus there is an _ exponential _ increase of difficulty ( measured by the size of advice ) between selection in time @xmath6 , for any @xmath7 , and selection in time @xmath8 . as for the comparison between election and selection , </S>",
    "<S> our results show that , perhaps surprisingly , while for small time , the difficulty of these two tasks on rings is similar , for time @xmath8 the difficulty of election ( measured by the size of advice ) is exponentially larger than that of selection .    * keywords : * election , selection , maximum finding , advice , deterministic distributed algorithm , time .    </S>",
    "<S> 0.18 in 0.0 in 0.2 in </S>"
  ]
}