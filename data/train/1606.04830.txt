{
  "article_text": [
    "at the moment high performance computing has a substantial problem , the cost of the software development cycle .",
    "it is expensive to develop an application that efficiently utilises available resources , whether it is a cluster with each node equipped with several gpus or a cloud / cluster mixed deployment . and things only get worse over time as for every change in the computing infrastructure , whether it is a transition to a new cpu family or the addition of new accelerators one has to invest time to tune , optimise and ensure the stability of an application .",
    "sometimes it is even easier to write whole applications from scratch for a particular technology stack .",
    "one of the reasons of such state of things is the abstraction level and complexity of the current hpc software stack . in order to produce an efficient scalable application one has to micro - manage several aspects of code execution .",
    "first , there is a need for a multi - process execution orchestration :    * each process has to be explicitly informed about what should it do and how . *",
    "a process has to know  when \" and  what \" information to send to and receive from other processes .",
    "* finally , one has to define how this communication is set up and optimize the computation / communication overlap .",
    "second , threaded execution has to be implemented for each process to efficiently utilise the node s cpu cores :    * the process local tasks and data parallel regions that could benefit from threading should be identified and instrumented . *",
    "synchronisation between computational and communication threads should be carefully engineered .",
    "finally , one might want to use accelerators , such as gpgpus to offload some parts of the computation :    * one additionally has to keep track not only of local and remote memory but also to transfer memory between cpu and gpu within the same node or between different nodes . *",
    "the synchronisation between cpu , accelerator and communication becomes even more challenging .",
    "everything mentioned above does not eliminate the necessity of optimised computational algorithms for the specific task at hands .    here",
    "we propose a solution to many of these challenges by introducing bind , a `` partitioned global workflow '' parallel programming model that deals with them in several ways :    * it is based on the classical sequential code design . * threading is performed automatically .",
    "* data transfer is implicit .",
    "* program execution is reproducible . *",
    "race conditions are avoided by design . *",
    "portable and easy to install by being a header - only library based upon mpi    the points above immediately translate into accelerated and simplified code development by keeping the user code agnostic of the low - level aspects of the parallel application execution .",
    "we start by defining what we mean by  global workflow \" is and why it is important .",
    "the foundation of bind s programming model is built on the notion of dataflow that is a set of parallel computational stages connected by data transfers .",
    "but unlike some dataflow programming languages @xcite , bind does not require users to reformulate the code in terms of pipelines and instead relies on the directed acyclic graph ( dag ) of operations that is extracted dynamically from the user s serial code execution flow ( workflow ) .",
    "once the code is decomposed into a set of computational stages one can easily execute them in parallel with respect to data constraints ( i.e. computational dependencies )",
    ". and more importantly , move some of the stages onto other nodes , hence enabling distributed memory parallelisation .    for a group of processes to be used this way , each of them has to have information about which actions each of them has to perform on what data . and in order for such a system to scale while remaining simple and robust one has to avoid centralisation of this information on any particular node .",
    "for this reason , bind s actual workflow is `` global '' that is produceable independently by any process in a group by means of parsing the sequential user code execution flow .",
    "this makes a sequential code base not just a benefit but a requirement since execution divergence would lead to inconsistency between processes local representations of the global operational dag .",
    "the construction of the dag used as a basis for the parallel execution is by no means a trivial task .",
    "bind uses function decorators and multi - version concurrency control @xcite . by employing function decorators bind",
    "is able to inspect a function s prototype at compile time . in particular",
    "it is able to detect which arguments are going to be modified and which arguments are going to remain constant .",
    "this information is then recorded in terms of argument object s  states \" .",
    "specifically , if a function takes in an object without a  const \" modifier bind assumes that the object will change and this is accounted for by creating a new  version \" of this object , marking the function call as a generator for this version .",
    "thus , for every operation in a program it is known which version of which object is needed and which operations are responsible for their input generation .",
    "this composes all operations into a transactional dag .",
    "the concept of object s versioning plays a key role here and in the overall programming model . besides serving to construct the operational dag it enables an additional degree of parallelism by allowing multiple versions of the same object to be used simultaneously .",
    "this means that operations depending on the newer state of the object need not wait until all of the older operations will finish .",
    "for example an mpi transfer will not block the next operations .",
    "additionally , by its nature the multi - version concurrency control guarantees that race conditions will never occur since a version of the object is immutable .",
    "this , coupled with the deterministic dag construction , makes a program execution reproducible and free of race conditions .     and",
    "@xmath0 ) depend on two different states of matrix a. keeping both states ( before and after scaling ) allows to perform @xmath1 operations in parallel.,width=307 ]      while the resulting dag contains all of the necessary information to be executed in a fully distributed way automatically , bind still leaves the declarative partitioning of the sequential code to the user . in other words ,",
    "the programmer has to declare on which node a set of operations has to be executed by means of scope guards .",
    "once it is done , bind takes care of the actual data transfers .",
    "the reason is that optimal scheduling of the dag across many nodes is a hard optimisation problem .",
    "while heuristical solutions @xcite might be good enough for shared - memory architectures the penalty for a suboptimal distribution is too high in case of the distributed systems due to high communication costs .",
    "it gets even more problematic if the whole dag is not known before execution , since an effective solution in one part of the dag might lead to inferior scheduling for the future parts of the dag .",
    "as was mentioned in the introduction , bind can substantially reduce development time and cost by providing safety ( which reduces debugging efforts ) and abstraction from the low level details of the parallelisation ( such as threading and communication ) .",
    "however , by virtue of its name , performance is crucial to hpc . and it turns out that the concept of the transactional dag also provides performance advantages :    * * zero - copy : * due to the multi - versioned nature of every object that is a part of the transactional dag , there is no need to perform any copies of data .",
    "instead it is sufficient just to point a pointer to the right revision of the object s data .",
    "this happens completely transparently for the user without a need to change classical pass - by - value semantics .",
    "* * memory differentiation : * as a side effect of having a transactional dag before its actual execution , bind can choose which type of memory the object should be allocated in depending on the object s lifetime and behaviour .",
    "e.g. it can get a pinned memory if it is going to be frequently transferred or bulk memory if the lifetime of the object is short .",
    "this can be crucial for applications sensitive to memory allocation strategies or memory - bound applications .",
    "* * memory locality and defragmentation : * since objects get frequently reallocated due to versioning , one automatically gains improved memory locality for the objects that are used jointly , thus improving tlb cache hit rate @xcite .",
    "this also helps avoid memory fragmentation issues in the long - running applications with persistent objects , thus improving allocations system time and memory capacity of the host . *",
    "* computation / communication overlap : * all of the implicit communication resulting from user - defined partitioning is performed completely asynchronously , thus allowing to efficiently overlap computations and communications .",
    "the intrinsic model s ability to retain multiple versions of the same data greatly facilitates this process since the computation becomes completely decoupled from the state of the memory transfers .",
    "* * implicit collectives : * inevitably there are cases when all of the processes would need to operate on the same dataset thus requiring a collective communication .",
    "bind s model infers such cases from the globally available dag of operations and their corresponding locations . by doing that it not only covers the functionality of global collectives but automatically infers `` partial '' collectives @xcite ( e.g. when only half of the nodes would need some dataset ) .",
    "it does so by dynamically constructing a binary tree from the queue of the communications involving the same object across multiple nodes . *",
    "* lockless execution : * finally , another performance advantage of the transactional nature is the absence of any internal locks or synchronisation primitives .",
    "this directly stems from the fact that the transaction can be either completed or not , thus keeping all of its dependencies in the waiting queue . thus avoiding mutex handling and related memory / cache coherence cpu cycles .",
    "the negative aspects of our model are a bigger memory requirement and an overhead of the run - time dag construction .",
    "the bigger memory requirement stems from multi - versioning meaning that an object may occupy more memory if it exists in multiple versions simultaneously , which is usually related to the degree of the parallelism the model exposes ( with smart memory reusage to mitigate the overhead when possible ) .    on the other hand , run - time construction of the dag ( despite being carefully optimised by means of template meta - programming )",
    "can still incur a critical disadvantage depending upon the computational cost of a single operation .",
    "in order to demonstrate the merits of our programming model , this section will cover two examples : matrix multiplication and sorting of integers using the mapreduce pattern .          for matrix multiplication",
    "we consider two algorithms : a shared - memory implementation of strassen s algorithm @xcite and distributed classical matrix multiplication algorithm with logarithmic reduction .",
    "the performance results were obtained on cscs monch cluster , which consists of two - socket 10 cores ivy bridge ( intel^^ xeon^^ ep e5 - 2660 v2 @2.2 ghz with 32 gb or ram ) nodes connected into a fat tree topology using infiniband fdr interconnect .",
    "figure [ fig : strassen_perf ] shows a performance comparison between intel^^ mkl s dgemm and bind s strassen matrix multiplication for a square matrix of 8192 by 8192 elements .",
    "the latter uses matrices stored as collections of tiles where each tile denotes a rectangular block of its original matrix and is stored contiguously in memory .",
    "the algorithm is executed recursively on the tiled matrices and their submatrices until the size of a submatrix hits a single tile ; then the operation would be dispatched to the sequential intel^^ mkl s dgemm call .",
    "the dag yielded by these series of recursive calls is then executed in parallel using bind s execution engine .",
    "as one can see , on average the mkl s parallel dgemm requires 25 percents more time than the strassen s algorithm ( with the downside of the strassen s algorithm requiring more memory ) .",
    "figure [ fig : pdgemm_perf ] , in turn , shows the performance of the distributed classical dgemm relative to the cumulative theoretical peak performance . since",
    "numerical stability is critical for the large scale matrix operations , this algorithm employs logarithmic reduction where any block of output matrix accumulates all of its updates by means of a binary tree reduction .    as one can see , for the given square matrix of 32768 by 32768 elements , 640 cores ( 64 nodes employing only one socket each ) yield about 70% of the cumulative theoretical peak performance with an algorithm that just uses 18 lines of code ( see listing [ lst : pdgemm_code ] ) .",
    ".... for(int ii = 0 ; ii < a.mt / np ; ii++ ) for(int kk = 0 ; kk < b.nt / nq ; kk++ ) {     for(int",
    "i = ii*np ; i < ( ii+1)*np ; i++ )     for(int k = kk*nq ; k < ( kk+1)*nq ; k++ ) {        std::vector < matrix > r(a.nt , c.tile(i,k ) ) ;        for(int j = 0 ; j < a.nt ; j++ ) {           bind::node p((i%np)*nq + j%nq ) ;           gemm(a.tile(i , j ) , b.tile(j,k ) ,                  r[(a.nt - k+j ) % a.nt ] ) ;        }        for(int s = 1 ; s < a.nt ; s * = 2 )        for(int w = s ; w < a.nt ; w + = s*2 ) {           bind::node p((i%np)*nq+((k+w - s)%a.nt)%nq ) ;           r[w - s ] + = r[w ] ;        }        c.tile(i,k ) = r[0 ] ;     }     bind::sync ( ) ; } ....      in `` big data '' applications and data analytics , sorting of large distributed datasets is a common task , which is often performed using hadoop^^ @xcite or spark @xcite employing the mapreduce parallel programming model for large scale cloud data processing .    here",
    ", we measure the performance of a trivial implementation of a mapreduce engine using bind , which can perform map , reduce , combine and implicit shuffle operations .",
    "see the integer sorting implementation as shown in listing [ lst : bind_sort_code ] .        similarly to the real world problems , the test - case was to sort one billion uniformly random integers which is roughly comparable to the amount of active facebook users .",
    "the test case was benchmarked using a single core per node on the monch cluster in order to stress the interconnect sensitivity of the resulting application and thus bring it closer to a cloud - like environment .",
    "as one can see from the fig .",
    "[ fig : bind_sort ] , the benchmark demonstrated perfect scalability on up to 64 nodes .",
    ".... kvpairs < int , doc_type>(local_map ) .map([](int k , std::vector < doc_type > & docs )    - > std::vector < std::pair < key_type , value_type > > {     std::vector < std::pair < int , value_type > > res ;     for(auto doc : docs ) for(auto v : doc ) {        key_type bucket = v > > ( 31 - log_bins ) ;        res.push_back ( { bucket , v } ) ;     }     return res ; } ) .reduce([](key_type k , std::vector < value_type > & vs )    - > std::vector < std::pair < key_type , value_type > > {     std::vector < std::pair",
    "< int , value_type > > res ;     std::sort(vs.begin ( ) , vs.end ( ) ) ;     for(auto v : vs ) res.push_back ( { k , v } ) ;     return res ; } ) ; ....    .... sortednumbers = sc.parallelize(range(1 , n+1 ) , np ) \\",
    ".map(lambda x : ( randint(1,2147483647 ) , 1 ) ) \\",
    ".sortbykey ( ) ....    in order to get a feeling on how the performance of this mapreduce would compare to the status quo in big data , the test case was then moved into the aws cloud with significantly smaller problem size ( 8 millions integers ) and compared to a similar test - case using apache spark ( see listing [ lst : spark_sort_code ] ) .",
    "the performance data was obtained in a slightly heterogeneous environment with nodes mainly using intel^^ xeon^^ e5 - 2670 v2 @2.50ghz and e5 - 2676 v3 @2.40ghz .        as one can see from the fig .",
    "[ fig : bind_spark ] while the scalability is quite similar , the absolute performance difference is close to 100 times .",
    "this paper has given an overview of the key concepts of the partitioned global workflow parallel programming model and its implementation in `` bind '' .",
    "the proposed approach based upon extraction of the transactional dag was shown not only to enable high - productivity software development cycles but also to deliver high performance as was illustrated with several synthetic benchmarks . in particular it was shown that the applications based upon this model are able to achieve close to native hand - crafted mpi based applications performance and scalability on many - core distributed systems both in cloud and cluster environments .",
    "more over , it was demonstrated that the performance of bind based applications can exceed those of the conventional widely used solutions , i.e. at linear algebra algorithms or big data analysis .",
    "such performance and an abstraction level that comes with this programming model might be as well a key to the whole range of future high performance computing applications that would be easily maintainable and adaptable to potentially disruptive conceptual shifts in computing .",
    "matrix - multiplication examples in this paper were composed by means of ambient , a parallel library based upon the bind model .",
    "the source codes of both frameworks can be obtained on the github under boost license .",
    "a.  gerasoulis and t.  yang , `` a comparison of clustering heuristics for scheduling directed acyclic graphs on multiprocessors , '' _ journal of parallel and distributed computing _ , vol .",
    "16 , no .  4 , pp .",
    "276291 , 1992 .",
    "template < class matrixa , class matrixb , class matrix , int ib >      void gemm_strassen(tiles < matrixa , ib > & & a , tiles < matrixb , ib > & & b , tiles < matrix , ib > & & c ) {          size_t n   = c.cols/2 ;          size_t nt = c.nt/2 ;          if(nt ) {              tiles < matrix < value_type > , ib > m1(n , n ) ;              tiles < matrix < value_type > , ib > m2(n , n ) ;              tiles <",
    "matrix < value_type > , ib > m3(n , n ) ;              tiles < matrix < value_type > , ib >",
    "m4(n , n ) ;              tiles < matrix < value_type > , ib > m5(n , n ) ;              tiles <",
    "matrix < value_type > , ib > d(n*2 , n*2 ) ;              tiles < matrix < value_type > , ib > e(n*2 , n*2 ) ;                  d.subset(0 ,   0 ,   nt , nt ) + = a.subset(0 ,   nt , nt , nt ) ;              d.subset(0 ,   nt , nt , nt ) -= a.subset(nt , nt , nt , nt ) ;              d.subset(nt , nt , nt , nt ) + = a.subset(nt , 0 ,   nt , nt ) ;              d.subset(nt , 0 ,   nt , nt ) -= a.subset(0 ,   0 ,   nt , nt ) ;                e.subset(0 ,   0 ,   nt , nt ) + = b.subset(0 ,   nt , nt , nt ) ;              e.subset(0 ,   nt , nt , nt ) -= b.subset(nt , nt , nt , nt ) ;              e.subset(nt , nt , nt , nt ) + = b.subset(nt , 0 ,   nt , nt ) ;              e.subset(nt , 0 ,   nt , nt ) -= b.subset(0 ,   0 ,   nt , nt ) ;                m4 + = a.subset(nt , nt , nt , nt ) ;              m5 + = b.subset(nt , nt , nt , nt ) ;                          gemm_strassen(d.subset(0 ,   nt , nt , nt ) ,                            e.subset(nt , nt , nt , nt ) ,                            c.subset(0 ,   0 ,   nt , nt ) ) ;              gemm_strassen(a.subset(0 ,   0 ,   nt , nt ) ,                            e.subset(0 ,   nt , nt , nt ) ,                            c.subset(0 ,   nt , nt , nt ) ) ;              gemm_strassen(d.subset(nt , nt , nt , nt ) ,                            b.subset(0 ,   0 ,   nt , nt ) ,                            c.subset(nt , 0 ,   nt , nt ) ) ;              gemm_strassen(d.subset(nt , 0 ,   nt , nt ) ,                            e.subset(0 ,   0 ,   nt , nt ) ,                            c.subset(nt , nt , nt , nt ) ) ;                gemm_strassen(std::move(m4 ) , std::move(m5 ) ,                            std::move(m1 ) ) ;              gemm_strassen(d.subset(0 ,   0 ,   nt , nt ) ,                            b.subset(nt , nt , nt , nt ) ,                            std::move(m2 ) ) ;              gemm_strassen(a.subset(nt , nt , nt , nt ) ,                            e.subset(nt , 0 ,   nt , nt ) ,                            std::move(m3 ) ) ;                  c.subset(0 ,   0 ,   nt , nt ) + = m1 ;              c.subset(nt , nt , nt , nt ) + = m1 ;              c.subset(0 ,   nt , nt , nt ) + = m2 ;              c.subset(0 ,   0 ,   nt , nt ) -= m2 ;              c.subset(0 ,   0 ,   nt , nt ) + = m3 ;              c.subset(nt , 0 ,   nt , nt ) + = m3 ;          } else {              gemm(a[0 ] , b[0 ] , c[0 ] ) ;          }      } ...."
  ],
  "abstract_text": [
    "<S> high performance computing is notorious for its long and expensive software development cycle . to address this challenge , we present bind : a `` partitioned global workflow '' parallel programming model for c++ applications that enables quick prototyping and agile development cycles for high performance computing software targeting heterogeneous distributed many - core architectures . </S>",
    "<S> we present applications of bind to linear algebra and mapreduce algorithms alongside with performance results . </S>"
  ]
}