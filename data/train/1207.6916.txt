{
  "article_text": [
    "forward simulations of population genetics , track either the genotype of every individual in the population , or the number of individuals that carry a particular genotype .",
    "the former has been implemented in a number of very flexible simulation packages @xcite . in large populations with a moderate number of loci ,",
    "storing the abundance of all possible @xmath4 genotypes is often faster .",
    "simulating such large populations with a small number of loci is for example essential when studying the evolution of drug resistance in viral or bacterial pathogens @xcite .",
    "individual - based population genetic simulations are quite straightforward and usually employ a discrete generation scheme in which processes such as mutation , selection , and migration are applied at every generation to every individual .",
    "individuals are then paired up via a mating scheme and recombinant offspring is produced .",
    "existing toolboxes often emphasize biological realism and allow the user to specify complex life cycles , see e.g.  @xcite .",
    "our emphasis here is on efficient simulation of large populations . instead of tracking individuals , we keep track of the distribution @xmath5 of gametes across all possible @xmath4 genotypes , denoted by @xmath6 where @xmath7 .",
    "this genotype distribution changes due to mutation , selection and recombination .",
    "the former two are again straightforward and require at most @xmath8 operations ( each genotype can mutate at any one of the @xmath1 loci ) . in our implementation , selection acts on haploid gametes , precluding dominance effects .",
    "recombination , however , is a computationally expensive operation since it involves pairs of parents ( of which there are @xmath9 ) which can combine their genome in many different ways ( @xmath4 ) . as a consequence",
    ", a naive implementation requires @xmath0 operations to calculate the distribution of recombinant genotypes .",
    "it is intuitive that the complexity of this algorithm can be reduced : given a recombination pattern , only a fraction of the genome is passed on in sexual reproduction and all genotypes that agree on that fraction contribute identically",
    ". we will show below that exploiting this redundancy allows to reduce the number of operations from @xmath0 to @xmath10 .",
    "after selection , mutation , and recombination , the population distribution @xmath5 contains the expected number of individuals of genotype @xmath11 in the next generation . for stochastic population genetics ,",
    "we still need to resample the population in way that mimics the randomness of reproduction .",
    "this is achieved by resampling individuals according to a poisson distribution with mean @xmath12 for each genotype , which will result in a population size of approximately @xmath13 .",
    "the probability of producing a genotype @xmath11 by recombination is @xmath14 where @xmath15 specifies the particular way the parental genomes are combined : @xmath16 if locus @xmath17 is derived from the mother ( resp .",
    "the genotype @xmath18 is summed over ; it represents the parts of the maternal ( @xmath19 ) and paternal ( @xmath20 ) genotypes that are not passed on to the offspring .",
    "we can decompose each parent into successful loci that made it into the offspring and wasted loci , as follows : @xmath21 and @xmath22 , where @xmath23 and a bar over a variable indicate respectively the elementwise and and not operators .",
    "the function @xmath24 assigns a probability to each inheritance pattern , see @xcite for a more detailed explanation . in a facultatively sexual population ,",
    "a fraction @xmath25 of @xmath5 is replaced by @xmath26 , while @xmath27 in an obligate sexual population .",
    "the central ingredient for the efficient recombination is a fast - fourier algorithm for functions on the l - dimensional binary hypercube .",
    "every function on the hypercube can be expressed as @xmath28 where @xmath29 and takes the values @xmath30 . in total",
    ", there are @xmath4 coefficients @xmath31 for every subset of @xmath32 loci out of a total of @xmath1 loci @xcite .",
    "similarly , each coefficient @xmath31 is uniquely specified by @xmath33 these nominally @xmath9 operations can be done in @xmath34 via the fft scheme illustrated in fig .",
    "[ fig : fft ] .     operations .",
    "arrow going up indicate addition , going down substraction . for the general @xmath1 dimensional hypercubes @xmath1 cycles are necessary where terms differing at different bits are combined . ]    with some algebra ( see online supplement ) , one can show that the generic fourier coefficient of @xmath26 is given by @xmath35 where the sum runs over all partitions of @xmath36 into groups of @xmath37 and @xmath38 denoted by @xmath39 and @xmath40 .",
    "variables such as @xmath41 are the fourier coefficients of the genotype distribution , @xmath42 , and the crossover function @xmath24 is expanded into @xmath43 the latter coefficients can be calculated efficiently by realizing that for @xmath44 , there is exactly one term unequal to zero .",
    "all subsequent terms can be calculated by successive marginalization of unobserved loci . in total",
    ", calculating @xmath45 requires @xmath46 operations .",
    "since there are @xmath47 terms of order @xmath32 , the entire calculation requires @xmath48 operations . in case of single crossover recombination",
    ", the algorithm can be sped up further to @xmath49 .",
    "ffpopsim is implemented in c++ with a python2 wrapper .",
    "documentation , a number of examples , and test routines are provided . as an example",
    ", we discuss here the problem of fitness valley crossing , which has received attention recently in the population genetics literature @xcite .",
    "consider a fitness landscape where the wild - type genotype has ( malthusian ) fitness @xmath50 , while the quadruple mutant has fitness @xmath51 .",
    "all intermediate genotypes have the same slightly deleterious fitness @xmath52 ( @xmath53 relative to wild - type ) . the time required for crossing the valley",
    "can be computed by the following routine :",
    ".... import ffpopsim l = 4 # number of loci n = 1e10 # population size # create population and set rates c = ffpopsim.haploid_lowd(l ) c.set_recombination_rates([0.01 ] * ( l-1 ) ) c.set_mutation_rate(1e-6 )    # start with wildtype : 0b0000 = 0 c.set_genotypes([0b0000],[n ] ) # set positive relative fitness for wildtype # and quadruple mutant : 0b1111 = 15 c.set_fitness_function([0b0000 , 0b1111 ] ,                          [ s1 , s1+s2 ] ) # evolve until the quadruple mutant spreads while c.get_genotype_frequency(0b1111)<0.5 :       c.evolve(100 ) print c.generation ....    the runtime and memory requirements of @xmath3 still preclude the simulation of more than @xmath54 loci . for this reason , we also include a streamlined individual based simulation package with the same interface that can simulate arbitrarily large number of loci and has an overall runtime and memory requirements @xmath55 in the worst case scenario .",
    "to speed up the simulation in many cases of interest , identical genotypes are grouped into clones .",
    "this part of the library was developed for whole genome simulations of large hiv populations ( @xmath56 , @xmath57 ) and a specific wrapper class for hiv applications is provided . as of now , the library does not support dominance effects which would require a fitness function that depends on pairs of haploid genomes .",
    "such an extension to diploid populations is straightforward .",
    "we would like to thank boris shraiman for many stimulating discussion and pointing us at the fft algorithm .",
    "this work is supported by the erc though stg-260686 .",
    "12 natexlab#1#1bibnamefont # 1#1bibfnamefont # 1#1citenamefont # 1#1url # 1`#1`urlprefix[2]#2 [ 2][]#2    , , * * ( ) , , issn , http://dx.doi.org/10.1016/s0167-739x(02)00171-1 .    , and , , * * ( ) , .    , , * * ( ) , ,",
    "issn , http://dx.doi.org/10.1109/mcse.2007.55 .    , , * * ( ) , .    , and , , * * ( ) , .    , , _",
    "_ , volume   ( ) .    , and , , * * ( ) ,",
    ".    , and , , * * ( ) , .    , , * * , .    , , , and , , * * ( ) , .    , , and , , * * ( ) ,",
    ".    , , and , , * * , .",
    "the toolbox makes extensive use of the gnu scientific library ( http://www.gnu.org/software/gsl/ ) and the boost c++ library ( http://www.boost.org/ ) .",
    "the python wrapper further requires numpy , scipy and matplotlib ( http://www.scipy.org ) .",
    "if all of these are installed and the appropriate path are set , ffpopsim can be compiled using make .",
    "installation instructions are provided in the ` install ` file .",
    "the building process creates files inside the folder ` pkg ` ; c++ headers are created in ` pkg / include ` , the static c++ library in ` pkg / lib ` , and the python module files in ` pkg / python ` .",
    "` ffpopsim ` contains two packages of c++ classes and python wrappers for forward population genetic simulations .",
    "one for large populations and relatively few loci ( @xmath58 ) , another one for longer genomes .",
    "the former is called ` hapoid_lowd ` and tracks the abundance of all possible genotypes .",
    "the other one is called ` haploid_highd ` and tracks only genotypes present in the population .",
    "the latter only allows for limited complextity of fitness functions and crossover patterns .",
    "these two parts of the library have very similar syntax but work quite differently under the hood .",
    "we will therefore describe them separately below .",
    "a complete documentation in html is generated automatically from the source using doxygen and can be found in ` doc / html / index.html ` .        since we assume that each locus is in one of two possible states @xmath59 , the genotype space is an @xmath1 dimensional binary hypercube .",
    "the population is a distribution of individuals on that hypercube , and so are the mutant and recombinant genotypes .",
    "also the fitness function @xmath60 , which assigns a number to each genotype @xmath61 , is a function on the hypercube .",
    "for this reason , ` hapoid_lowd ` makes extensive use of a class ` hypercube_lowd ` that stores an @xmath1 dimensional hypercube and implements a number of operations on the hypercube , including a fast - fourier transform ( fft ) .",
    "every function on the hypercube can be expressed as @xmath28 where @xmath62 , i.e. , simply a mapping from @xmath63 to @xmath64 .",
    "there are @xmath65 coefficients @xmath31 for every subset of @xmath32 loci out of @xmath1 loci , so in total @xmath4 coefficients  @xcite .",
    "a coefficient @xmath31 is uniquely specified by @xmath66 these nominally @xmath9 operations ( @xmath4 for each coefficient ) can be done in @xmath34 via the fft scheme illustrated in fig .",
    "[ fig : fft ] .",
    "both the forward and reverse transform are implemented in ` hypercube_lowd ` .",
    "arrow going up indicate addition , going down substraction . for the general @xmath1",
    "dimensional hypercubes @xmath1 cycles are necessary where terms differing at different bits are combined . ]",
    "an instance of ` hypercube_lowd ` can be initialized with the function values of the hypercube or with its fourier coefficients .",
    "the population class , ` haploid_lowd ` , holds instances of ` hypercube_lowd ` for the population , the mutant genotypes , the recombinant genotypes and the fitness function .    from a practical point of view",
    ", an instance of a low - dimensional population is initialized in three steps ,    a.   the class is instantiated + ....",
    "haploid_lowd::haploid_lowd(int l=1 , int rng_seed=0 )     .... + where l is the number of loci and ` rng_seed ` is a seed for the random number generator ( a random seed by default ) ; b.   the initial population structure is set by the functions + ....    int haploid_lowd::set_allele_frequencies(double * freq , unsigned long n )    int haploid_lowd::set_genotypes(vector < index_value_pair_t >",
    "gt )    int haploid_lowd::set_wildtype(unsigned long",
    "n )     .... + set the population size and composition .",
    "the first function initializes random genotypes in linkage equilibrium with the specifiec allele frequencies ` freq ` , the second explicitely sets a number of individuals for each genotype using the new type ` index_value_pair ` , and the last one sets a wildtype - only population of size ` n ` ; c.   the fitness hypercube is initialized directly by accessing the attribute + ....    haploid_lowd::fitness     .... + in the population class .      in traditional wright - fisher type models , in each generation ,",
    "the expected frequencies of gametes with a particular genotype after mutation , selection , and recombination are calculated and then the population resampled from this gamete distribution .",
    "we will now outline the steps required to update the population .",
    "a more detailed discussion can be found in @xcite .",
    "all the following steps are called by either one of the following functions :    * .... int haploid_lowd::evolve(int gen=1 ) ....",
    "+ updates the population looping over a specified number of generations ` gen ` ; * .... int haploid_lowd::evolve_norec(int gen=1 ) .... + is an alternative version that skips the resampling ( deterministic evolution ) ; * .... int haploid_lowd::evolve_deterministic(int gen=1 ) .... + is another alternative that skips the recombination step ( asexual evolution ) .      let @xmath5 be the genotype distribution at the beginning of a generation . denoting the mutation rate towards the @xmath67 or @xmath52 state at locus @xmath17 by @xmath68 , the expected @xmath5 after mutation will be @xmath69 where @xmath70 denotes genotype @xmath11 with locus @xmath17 flipped from @xmath52 to @xmath67 or vice versa .",
    "the first term is the loss due to mutation , while the second term is the gain due to mutation from neighbouring genotypes ( in terms of hamming distance ) .",
    "the mutation rates can be specified by the folowing set of overloaded functions : either a single double rate ( same for every position and in both forward and backward sense ) , two double rates ( forward and backward rates ) , a @xmath1 dimensional double array ( site - specific , identical forward and backward rates ) , or a @xmath71 dimensional double array ,    * .... int haploid_lowd::set_mutation_rate(double rate ) ; .... + takes a single rate and sets it for every position and in both forward and backward sense ; * .... int haploid_lowd::set_mutation_rate(double rate_forward , double rate_backward ) ; .... + takes two rates and sets ` rate_forward ` as the forward rate ( @xmath72 ) and ` rate_backward ` as the backward rate ( @xmath73 ) * .... int haploid_lowd::set_mutation_rate(double * rates ) ; .... + takes the pointer to an array of length l and sets site - specific rates , the same for forward and backward mutations ; * .... int haploid_lowd::set_mutation_rate(double * * rates ) .... + takes a pointer to a pair of ( pointers to ) arrays , each of length l , which contain the site - specific rates for forward ( ` rates[0 ] ` ) and backward ( ` rates[1 ] ` ) mutations .",
    "selection reweighs different the population of different genotypes according to their fitness as follows @xmath74 where @xmath75 is the population average of @xmath76 , which is required to keep the population size constant .",
    "the corresponding function is    .... int haploid_lowd::select_gametes ( ) ....      for deterministic modeling , one generation would be completed at this point and one would repeat the cycle , starting with mutation again . for stochastic population genetics , we still need to resample the population in a way that mimics the randomness of reproduction . the easiest and most generic way to do this is to resample a population of size @xmath2 using a multinomial distribution with the current @xmath5 as sampling probabilities of different genotypes .",
    "alternatively , one can sample individuals according to a poisson distribution with mean @xmath12 for each genotype , which will result in a population of approximately size @xmath13 . for large populations ,",
    "the two ways of resampling are equivalent and we chose the latter ( much faster ) alternative .",
    "the function    .... int haploid_lowd::resample ( ) ....    samples the next generation the expected genotype frequencies .",
    "the expected population size used in the resampling is the carrying capacity .      the computationally expensive part of the dynamics is recombination , which needs to consider all possible pairs of pairs of parents and all different ways in which their genetic information can be combined . in a facultatively sexual population ,",
    "a fraction @xmath25 of the individuals undergo mating and recombination . in obligate sexual populations , @xmath27 .",
    "the genotype distribution is updated according to the following rule : @xmath77    the distribution @xmath26 of recombinant gametes would naively be computed as follows : @xmath14 where @xmath78 specifies the particular way the parental genomes are combined : @xmath16 if locus @xmath17 is derived from the mother ( resp .",
    "father ) . the genotype @xmath18 is summed over ; it represents the part of the maternal ( @xmath19 ) and paternal ( @xmath20 ) genotypes that is not passed on to the offspring .",
    "we can decompose each parent into successful loci that made it into the offspring and wasted loci , as follows : @xmath79 and @xmath80 , where @xmath23 and a bar over a variable indicate respectively the elementwise and and not operators ( i.e. , @xmath81 ) .",
    "the function @xmath24 assigns a probability to each inheritance pattern . depending on whether the entire population undergoes sexual reproduction or only a fraction @xmath25 of it , the entire population or a fraction @xmath25",
    "is replaced with @xmath26 .",
    "the central ingredient for the efficient computation of @xmath26 is the fourier decomposition introduced above . the generic fourier coefficient of @xmath26 is given by @xmath82 just as @xmath20 and @xmath19",
    "can be expressed as a combination of @xmath11 and @xmath18 , we can invert the relation and express the generic @xmath83 as a function of @xmath20 and @xmath19 , as follows : @xmath84 . using this new basis and exchanging the order of summations ,",
    "we obtain @xmath85 notice that @xmath86 can be pulled out of the two inner sums , because the odds of inheriting a certain locus by the mother / father is independent of what their genetic makeup looks like .",
    "next we expand the product and introduce new labels for compactness , @xmath87 where @xmath37 is the number of loci inherited from the mother among the @xmath32 in @xmath88 .",
    "@xmath37 runs from @xmath52 ( everything happens to be contributed by the father ) to @xmath32 ( everything from the mother ) .",
    "@xmath89 and @xmath90 are all ( unordered ) partitions of @xmath17 into sets of size @xmath37 and @xmath38 , respectively .",
    "now we can group all @xmath91 in the inner sum with @xmath86 , all @xmath92 with @xmath93 , and all @xmath94 with @xmath95 .",
    "the three sums ( over @xmath78 , @xmath96 , and @xmath97 ) are now completely decoupled . moreover",
    ", the two sums over the parental genotypes happen to be the fourier decomposition of @xmath5 .",
    "hence , we have @xmath98 the quantity @xmath99 can be calculated efficiently , for each pair of partitions @xmath100 , by realizing that ( a ) for @xmath44 , there is exactly one term in the sum on the right that is non - zero and ( b ) all lower - order terms can be calculated by successive marginalizations over unobserved loci .",
    "for instance , let us assume that @xmath101 and that the only missing locus is the m - th one .",
    "we can compute @xmath102 there are @xmath65 ways of choosing @xmath32 loci out of @xmath1 , which can be inherited in @xmath103 different ways ( the partitions in @xmath104 and @xmath105 in eq .",
    "( [ eq : reccoeff ] ) ) such that the total number of coefficients is @xmath3 .",
    "note that these coefficients are only calculated when the recombination rates change .",
    "furthermore , this can be done for completely arbitrary recombination patterns , not necessarily only those with independent recombination events at different loci .    `",
    "haploid_lowd ` provides a function to calculate @xmath86 from recombination rates between loci assuming a circular or linear chromosome .",
    "the probability of a particular crossover pattern is calculated assuming independent crossovers .",
    "the function    .... int haploid_lowd::set_recombination_rate(double * rec_rates ) ....    assumes a double array of length @xmath106 for a linear chromosome and of length @xmath1 for a circular chromosome . for a linear ( resp .",
    "circular ) chromosome , the i - th element of the array is the probability of recombining after ( resp . before ) the i - th locus .",
    "furthermore , the mating probability @xmath25 must be specified explicitely via the attribute    .... haploid_lowd::outcrossing_rate ....    the default is obligate sexual reproduction .",
    "the code offers a simpler alternative for free recombination . in this case , only the global mating probability @xmath25 needs to be entered .",
    "if the user does not set the recombination rates via ` set_recombination_rate ` , free recombination is the default behaviour .",
    "otherwise , this option is controlled by the following boolean attribute    ....",
    "haploid_lowd::free_recombination ....    note that , in a circular chromosome , there is effectively one more inter - locus segment ( between the last and the first locus ) in which crossovers can occur , and the total number of crossovers has to be even . assuming independent crossovers , the global recombination rate of circular chromosomes is lower than a linear chromosome of the same length by a factor of @xmath107 , where @xmath108 is the recombination rate between the first and last loci .",
    "the recombination process itself is initiated by    .... int haploid_lowd::recombine ( ) ....      for more than @xmath109 loci , storing then entire genotype space and all possible recombinants becomes prohibitive .",
    "hence we also include a streamlined individual based simulation package that can simulate arbitrarily large number of loci and has an overall runtime and memory requirements @xmath55 in the worst case scenario .",
    "the many - loci package uses the same interface as the few - loci one .",
    "this makes it easy , for example , to first test an evolutionary scenario using many ( all ) loci and to focus on the few crucial ones afterwards .    to speed up the program in many cases of interest",
    ", identical genotypes are grouped into clones .",
    "this part of the library was developed for whole genome simulations of large hiv populations ( @xmath56 , @xmath57 ) . a specific wrapper class for hiv applications",
    "is provided .      for more than 20 loci ,",
    "it becomes infeasible to store the entire hypercube .",
    "instead , we store individual genotypes as bitsets .",
    "each genotype , together with the number of individuals that carry it , as well as traits and fitness associated with it is stored for as long as it is present in the population .",
    "all of this is aggregated in the structure ` clone_t ` .",
    "the population is a vector of clones .",
    "each generation clones size are updated and added to the new generation , new clones are produced , and empty ones deleted .",
    "fitness functions are again functions on the hypercube .",
    "the latter is implemented as ` hypercube_highd ` . instead of storing all possible fitness values , `",
    "` stores non - zero fourier coefficients .",
    "whenever a new genotype is produced , its fitness is calculated by summing the appropriate coefficients .      to implement mutation , a poisson distributed number @xmath110 with mean @xmath111",
    "is drawn for each locus @xmath17 and @xmath110 mutations are introduced at locus @xmath17 into @xmath110 randomly chosen genotypes .",
    "mutations are bit - flip operations in the bitset .",
    "only a global mutation rate is currently supported .",
    "prior to selection , the population average @xmath112 and a growth rate adjustment @xmath113 are computed .",
    "the latter is used to keep the population size close to the carrying capacity @xmath114 .",
    "the size of each clone is then updated with a poisson distributed number with mean @xmath115 , where @xmath116 is the recombination rate .",
    "another poisson distributed number with mean @xmath117 is set aside for recombination later .",
    "the individuals marked for sexual reproduction during the selection step are shuffled and paired .",
    "for each pair , a bitset representing the crossover pattern is produced and two new clones are produced from the two parental genomes .",
    "alternatively , all loci of the two genomes can be reassorted at random .",
    "the c++ library includes python bindings that greatly simplify interactive use and testing .",
    "the wrapping itself is done by swig  @xcite .",
    "most notably , the c++ classes ` haploid_lowd ` , ` haploid_highd ` and the hiv - specific subclass are fully exposed to python , including all their public members . the performance speed for evolving a population",
    "is unchanged , since the ` evolve ` function iterates all steps internally for an arbitary number of generations",
    ".    the bindings are not completely faithful to the c++ interface , to ensure a more intuitive user experience .",
    "for instance , c++ attribute set / get members are translated into python properties via the builtin ` property ` construct .",
    "furthermore , since direct access to the ` hypercube_lowd ` instances from python is not straightforward , a few utility functions have been written to do common tasks .",
    "the fitness hypercube can be set easily by either one of    ....",
    "haploid_lowd.set_fitness_function(genotypes , fitnesses ) haploid_lowd.set_fitness_additive(fitness_main ) ....    the former function is used to set specific points on the hypercube : it takes a sequence of genotypes ` genotypes ` ( integers or binary literals using ` 0b ` notation ) and a sequence of fitness values ` fitnesses ` , corresponding to those genotypes .",
    "any missing point on the fitness hypercube will be consider neutral .",
    "the second function creates an additive fitness landscape , in which main effects are specified by the l - dimensional input sequence ` fitness_main ` .",
    "after installation , the ffpopsim library can be used in python as a module , e.g.    .... from ffpopsim import haploid_lowd ....    the bindings make heavy use of the numpy library and its swig fragments and typemaps  @xcite .",
    "we therefore recommend to import numpy before ffpopsim , although this is not strictly necessary .",
    "moreover , the python binsings include a few functions for plotting features of the population , such as genetic diversity .",
    "the python module matplotlib is required for this purpose  @xcite .",
    "the hiv - specific part of the code has been expanded further in python to enable quick simulations of viral evolution under commonly studied conditions .",
    "in particular , random genotype - phenotype maps for viral replication capacity and drug resistance can be generated automatically from a few parameters , via the functions    ....",
    "hivpopulation.set_resistance_landscape ....    the input parameters reflect a number of typical properties of hiv populations , such as the fraction of sites carrying potentially adaptive mutations .",
    "see the inline python documentation for further details on these functions . moreover , since studies of hiv evolution often involve a large number of genotypic data , a function for saving the genotype of random individuals from the current population in a compressed format has been added .",
    "the syntax is the following :    .... hivpopulation.write_genotypes_compressed(filename , number_of_individuals ) ....    where ` filename ` is the name of the file , in which the data are to be stored , and ` number_of_individuals ` if the size of the random sample .",
    "the data can be accessed again by the standard numpy ` load ` function .",
    "one of the most striking effects of genetic epistasis is the slowdown of evolution when a combination of mutations is beneficial , but intermediate mutants are deleterious compared to wildtype .",
    "such scenario is relevant in applications , for instance for the emergence of bacterial or viral resistance to drugs  @xcite .",
    "not surprisingly , recombination plays a central role in this process . on the one hand",
    ", it enhances the production rate of multiple mutants , on the other it depletes the class of complete mutants by back - recombination with deleterious backgrounds .",
    "if the script is run with different recombination rates , the effect of this parameter on the time for valley crossing can be investigated , as shown in fig .",
    "[ fig : valley ] .",
    "the full scripts producing the figures is provides as separate file .          during an hiv infection ,",
    "the host immune system targets several viral epitopes simultaneously via a diverse arsenal of cytotoxic t - cells ( ctls ) .",
    "mutations at several loci are thus selected for and start to rise in frequency at the same time but , because of the limited amount of recombination , end up in wasteful competition ( interference ) at frequencies of order one .",
    "the theoretical description of genetic interference is involved and often limited to two - loci models , but ffpopsim makes the simulation of this process straightforward .",
    "the following script evolves a 4-loci population under parallel positive selection and tracks its genotype frequencies :            # evolve until fixation of the quadruple mutant , # storing times and genotype frequencies times = [ ] genotype_frequencies = [ ] while pop.get_genotype_frequency(0b1111 ) < 0.99 and pop.generation<1e7 :      pop.evolve ( )      times.append(pop.generation )      genotype_frequencies.append(pop.get_genotype_frequencies ( ) ) ....            hiv evolution during chronic infection is determined by a number of parallel processes , such as mutation , recombination , and selection imposed by the immune system . in combination , these processes give rise to a complicated dynamics and do nt understand how population features such as population diversity depend on model parameters .",
    "hence simulations are an important source of insight .",
    "ffpopsim offers a specific double c++/python interface to this problem via its class ` hivpopulation ` .",
    "the following script simulates an hiv population for one thousand generations , under a random static fitness landscape , and stores a hundred random genomes from the final population in a compressed file :              numpy can be used subsequently to analyze the genome sequences .",
    "alternatively , the internal python functions can be used , e.g. for calculating the fitness distribution directly using ` hivpopulation.get_fitness_histogram ` , as shown in fig .",
    "[ fig : hivfitness ] .",
    "the full scripts producing the figures is provides as separate file ."
  ],
  "abstract_text": [
    "<S> the analysis of the evolutionary dynamics of a population with many polymorphic loci is challenging since a large number of possible genotypes needs to be tracked . in the absence of analytical solutions , </S>",
    "<S> forward computer simulations are an important tool in multi - locus population genetics . </S>",
    "<S> the run time of standard algorithms to simulate sexual populations increases as @xmath0 with the number @xmath1 of loci , or with the square of the population size @xmath2 . </S>",
    "<S> we have developed algorithms that allow to simulate large populations with a run - time that scales as @xmath3 . </S>",
    "<S> the algorithm is based on an analog of the fast - fourier transform ( fft ) and allows for arbitrary fitness functions ( i.e.  any epistasis ) and genetic maps . </S>",
    "<S> the algorithm is implemented as a collection of c++ classes and a python interface . * </S>",
    "<S> availability : * http://code.google.com / p / ffpopsim/. </S>"
  ]
}