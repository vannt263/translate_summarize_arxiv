{
  "article_text": [
    "a simple but popular mechanism to allocate indivisible items is _ sequential allocation _ @xcite . in sequential allocation ,",
    "a sequence specifies the turns of the agents .",
    "for example , for sequence 1212 , agents 1 and 2 alternate with agent 1 taking the first turn .",
    "agent take turns according to the sequence and are given the the most preferred item that has not yet been allocated .",
    "sequential allocation is an ordinal mechanism since the outcome only depends on the ordinal preferences of agents over items .",
    "nevertheless , it is a standard assumption in the literature that agents have underlying additive utilities for the items .",
    "it has long been known that sequential allocation is not strategyproof in particular when agents do not have consecutive turns .",
    "this motivates the natural problem of computing best responses ( also referred to as manipulations ) .",
    "@xcite presented a polynomial - time algorithm to compute the optimal manipulation of an agent when there are two agents and the sequence is alternating ( 121212 .. ) .",
    "@xcite initiated further work on manipulation of sequential allocation .",
    "they showed that it can be checked in polynomial time whether an agent can be allocated a certain subset of items . since there can be exponential number of subsets ,",
    "the result does not show that finding the optimal response is polynomial - time solvable as well .",
    "[ [ results ] ] results + + + + + + +    we on focus on computing best responses ( or manipulations ) under sequential allocation .",
    "recently , @xcite presented a polynomial - time algorithm to compute a best response of an agent and claimed that ( 1 ) their algorithm correctly finds an optimal response and ( 2 ) each best response results in the same allocation for the manipulator .",
    "the result has been cited in a number of works  ( see e.g. , * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "we first show that both claims are false by the help of an example .",
    "we then show that in fact the problem of computing a best response is np - complete .",
    "the result has some interesting consequences since many allocation rules are based on sequential allocation and for all such rules , there can not be a general polynomial - time to manipulate the mechanism unless p = np .",
    "since manipulation by even one agent is np - hard , the np - hardness also implies a number of np - hardness results by @xcite on _ coalitional _ manipulation .",
    "we consider the setting in which we have @xmath0 a set of agents , @xmath1 a set of items , and the preference profile @xmath2 specifies for each agent @xmath3 his complete , strict , and transitive preference @xmath4 over @xmath5 .",
    "each agent may additionally express a cardinal utility function @xmath6 consistent with @xmath4 : @xmath7 we will assume that each item is positively valued , i.e , @xmath8 for all @xmath9 and @xmath10 .",
    "the set of all utility functions consistent with @xmath4 is denoted by @xmath11 .",
    "we will denote by @xmath12 the set of all utility profiles @xmath13 such that @xmath14 for each @xmath9 .",
    "when we consider agents valuations according to their cardinal utilities , then we will assume additivity , that is @xmath15 for each @xmath9 and @xmath16 .    at times",
    ", we will present an assignment in matrix form .",
    "assignment _ is an @xmath17 matrix @xmath18_{\\substack{1\\leq i\\leq n , 1\\leq j\\leq m}}$ ] such that for all @xmath9 , and @xmath19 , @xmath20 ; and for all @xmath21 , @xmath22 .",
    "an agent @xmath3 gets item @xmath23 if and only if @xmath24 .",
    "each row @xmath25 represents the _ allocation _ of agent @xmath3 .",
    "we say that utilities are _ lexicographic _ if for each agent @xmath9 , @xmath26 .",
    "by @xmath27 , we will mean @xmath28 .",
    "consider the setting in which @xmath29 , @xmath30 , the preferences of agents are @xmath31 then for the policy @xmath32 , agent @xmath33 gets @xmath34 while @xmath35 gets @xmath36 .",
    "the assignment resulting from sequential allocation ( sa ) can be represented as follows .",
    "in the next example , we highlight that for @xmath38 , the best response algorithm of @xcite does not work and that an optimal manipulation may not result in a unique allocation .",
    "observe the following preference profile .",
    "let the sequence be 1231 . now according to the best response algorithm of @xcite , the best response is one in which agent @xmath33 gets @xmath40 which can even be achieved by the truthful report .",
    "the reason the algorithm of @xcite returns the truthful report as the best response is because it first construct allocation @xmath41 and checks that it is achievable ; then it checks whether @xmath42 is achievable and finds that it is not achievable ; then it checks whether @xmath43 is achievable and finds that it is not achievable , and finally the algorithm terminates when it is found that @xmath40 is achievable for agent 1 via the truthful report .",
    "let us assume that agent @xmath33 misreports so that the reported preference profile is as follows : @xmath44    under the misreport , agent @xmath33 gets @xmath45 .",
    "agent 1 can not get @xmath42 or @xmath43 which are not achievable .",
    "but he can get @xmath40 or @xmath45 depending on what he reports .",
    "now which one is better clearly depends on the actual utilities and not just on the ordinal preferences .",
    "for example if the utilities are 3.1 , 3 , 2 and 1 then @xmath45 is preferred over @xmath40 and hence @xmath40 is not the best possible achievable allocation for agent @xmath33 which means that    moreover , if the utilities are @xmath46 , then agent @xmath33 is completely indifferent between the allocations @xmath40 and @xmath45 .",
    "this proves that there may be best responses that do not yield a unique allocation for the manipulator when the number of non - manipulators is 2 or more ( i.e. , when the total number of agents is 3 or more ) .",
    "the example above simply shows that algorithm of @xcite does not necessarily compute a best response that gives maximum utility to the agent .",
    "it does not settle the complexity of computing a best response .",
    "next , we show that the problem is np - hard .",
    "the reduction involves a similar high - level idea as that of the result by @xcite that manipulating the probabilistic serial ( ps ) mechanism is np - hard .",
    "however , the reduction requires new gadgets .",
    "also note that the np - hardness result for the ps mechanism does not directly imply a similar result for sequential allocation .",
    "similarly , np - hardness to manipulate sequential allocation does not imply np - hardness to manipulate the ps mechanism .",
    "[ th : main ] computing a best response for the sequential allocation mechanism is np - complete .    to show hardness , we prove that the following problem ( best response ) is np - complete : given an assignment setting and a utility function @xmath47 specifying the utility of each item for the manipulator ( agent @xmath33 ) and a target utility @xmath48 , can the manipulator specify preferences such that the utility for his allocation under the sequential allocation rule is at least @xmath48 ?",
    "the problem best response is clearly in np .",
    "the outcome with respect to the reported preference can be computed by simulating sequential allocation .",
    "the utility achieved by the agent can be computed by adding the utility of the items allocated to the agent .",
    "we reduce from a restricted np - complete version of 3sat where each literal appears exactly twice in the formula .",
    "the problem remains np - complete  ( lemma 1 , * ? ? ?",
    "given such a 3sat instance @xmath49 where @xmath50 is the set of variables and @xmath51 the set of clauses , we build an instance of best response where the manipulator can obtain utility @xmath52 if and only if the formula is satisfiable .",
    "we will denote by @xmath53 the set of literals .",
    "the set of agents is composed of    * agent 1 the manipulator / responder ; and * agents @xmath54 and @xmath55 for each literal @xmath56 .",
    "to summarize , the agent set is : @xmath57    the set of items @xmath5 is as follows :    * clause items @xmath58 for each clause @xmath59 ; * choice items @xmath60 for each literal @xmath56 ; * consistency items @xmath61 for each literal @xmath56 ; * dummy items @xmath62 for each literal @xmath56 .",
    "to summarize , the item set is : @xmath63    we view the sequential allocation process as follows .",
    "the preferences are built in a way so that the agents go through @xmath64 choice rounds corresponding to variables @xmath65 and then @xmath66 clause rounds corresponding to @xmath67 with one final round called the collection round in wich    [ [ high - level - idea ] ] high - level idea + + + + + + + + + + + + + + +    the items that agent @xmath33 potentially gets in each round have considerably more utility than items he is supposed to get in latter rounds . if agent @xmath33 does not get the items systematically , they will be taken by other agents and and then agent @xmath33 will not be able to make up for the loss of not getting those items first .",
    "this ensures that in each round agent @xmath33 makes a choice between the items corresponding to the positive and negative literals of a variable .",
    "there is negligible difference between the utility of the items corresponding to the literal and its negation ( for example @xmath68 and @xmath69 ) so what is important is that agent chooses one of the items corresponding to the literals .",
    "if agent @xmath33 makes the correct choices , then it will ensure that it gets a most preferred items corresponding to each of the clause items .",
    "we want to show that there is a satisfiable assignment if and only if agent @xmath33 gets utility @xmath48 .",
    "this is only possible if agent @xmath33 sets the choice variables in a consistent way and manages to get the most preferred clause item for each clause which is only possible if each clause is set to be true which in turn is only possible if the agents corresponding to the negation of the literal in the clause do not get the clause items . the way the reduction works is also illustrated in example  [ example : sat ] right after the proof .",
    "[ [ choice - round ] ] choice round + + + + + + + + + + + +    this choice round is composed of two back to back sub rounds in which agent @xmath33 has to choose a literal corresponding to a variable and then do this again .",
    "let us consider the truth assignment corresponding to the choices agent @xmath33 makes .",
    "a literal @xmath56 is considered to be true iff agent @xmath33 picks @xmath70 and @xmath71 in choice round @xmath3 .",
    "the sequence in choice round @xmath3 for variable @xmath56 is as follows    @xmath72    the preferences relevant for the choice round are as follows .",
    "each literal agent likes items corresponding to the negation of the literal .",
    "for each variable @xmath56 , agent @xmath33 has the following preferences    @xmath73    for each variable @xmath56 , the preferences of the related agents are as follows : @xmath74    any items that are not in the preference list of an agent are considered to be far down in the preference list .",
    "note the difference in the preferences of the negative versus the positive literals : the positive literal agents have a dummy item as the least preferred item relevant to the picking in the choice round whereas the negative literal agents have the consistency items as the least preferred items relevant to the picking in the choice round .",
    "the preferences agents in the choice round are made in such a way to that agent @xmath33 is compelled to make consistent choice so that it not only gets literal items corresponding to its choice but also one if its most two preferred consistency items . if agent makes a consistent choice @xmath75 and @xmath76 , or @xmath77 and @xmath78 , then @xmath33 gets either @xmath79 or @xmath80 for that round .",
    "this scenario is captured in table  [ table : consistent - true - new ] and table  [ table : consistent - false - new ] .",
    "if agent @xmath33 makes an inconsistent choice @xmath75 and @xmath78 , or @xmath77 and @xmath76 , then @xmath33 gets @xmath81 and @xmath82 .",
    "this scenario is captured in table  [ table : inconsistent - false - new ] and table  [ table : inconsistent - true - new ] .",
    "[ [ clause - round ] ] clause round + + + + + + + + + + + +    the sequence in clause round corresponding to clause @xmath83 is as follows .",
    "@xmath84    for each literal @xmath85 in the clause @xmath59 , there is an agent @xmath86 or @xmath87 that features in the round .",
    "agent @xmath86 features if @xmath59 is the first clause in which literal @xmath85 is present . agent @xmath87 features if @xmath59 is the second clause in which literal @xmath85 is present .",
    "recall that each literal occurs in exactly two clauses in the formula .",
    "after all the clause rounds are finished , agent @xmath33 gets @xmath66 turns to get a chance to get clause items in case they are available .    for agent @xmath33 ,",
    "the relevant preferences in the clause round are : @xmath88    for a variable @xmath85 , if @xmath85 is a literal in the clause , the relevant preferences in this round are :    @xmath89    for a variable @xmath85 , if @xmath90 is a literal in the clause , the relevant preferences in this round are :    @xmath91    please note that the items @xmath92 are the consistency items that featured in relevant items in the choice round corresponding to variable @xmath85 and @xmath93 and @xmath94 are the dummy items that featured in relevant items in the choice round corresponding to variable @xmath85 . if agent @xmath33 has made a consistent choice in the choice round corresponding to variable @xmath85 and set @xmath85 to `` true '' , then @xmath54 and @xmath55 already want to get clause items in their respective clause rounds .",
    "if agent @xmath33 has made a consistent choice in the choice round corresponding to variable @xmath85 and set @xmath85 to `` false '' , then @xmath95 and @xmath96 already want to get clause items in their respective clause rounds .    in the clause round ,",
    "any literal that is not satisfied , the agent corresponding to literal gets a clause item .",
    "so for example if literal @xmath85 is false , then @xmath86 gets a clause item for the first clause in which @xmath85 is present .",
    "@xmath97 gets a clause item for the second clause in which @xmath85 is present . therefore ,",
    "if all the literals of a clause @xmath59 are false , then agent @xmath33 does not get @xmath98 .",
    "if literal @xmath85 is satisfied , the agent @xmath99 corresponding to it gets a dummy or consistency item in that round instead of a clause item .",
    "this means that if all the literals of a clause are not satisfied , then all three clause items of a clause are gone , and agent @xmath33 does not get a clause item .",
    "he is only interested in one of the clause items @xmath98 .",
    "the other clause items are far down in his preference list so he would rather get all the top clause item @xmath98 for each clause @xmath59 rather than @xmath100 and @xmath101 .",
    "let us assume that for clause @xmath83 , variables @xmath102 , @xmath103 and @xmath104 are set to true i.e. , agent @xmath33 got choice items corresponding to the @xmath105 , @xmath106 and @xmath107 .",
    "this means that in the clause round , @xmath108 and @xmath109 are ready to take their clause items @xmath101 and @xmath100 but @xmath95 wants to get one of the unallocated consistency items before he is interested in consistency items @xmath110 .",
    "this is helpful for agent @xmath33 because he can get @xmath98 . since each literal occurs exactly twice in the formula , note that as long as @xmath33 makes a consistent choice , there will be another clause @xmath111 in which literal @xmath85 is present and",
    "if @xmath85 is set to true , then @xmath87 will get @xmath112 and hence @xmath33 will be able to get @xmath113 .",
    "note that after the clause rounds all the consistency items are already consumed so the agent @xmath33 can hope to get all the top clause items if they were not already taken in the clause rounds .",
    "[ [ collection - round ] ] collection round + + + + + + + + + + + + + + + +    the sequence in the collection round    @xmath114 the relevant preferences are : @xmath115    the idea is that if agent @xmath33 make choices that sets all the clauses as true , then agent @xmath33 gets all the clause items .",
    "note that if @xmath33 makes a consistent choice for the variables but does not pick up all the clause items in the collection round ( because the formula is unsatisfiable ) , then @xmath33 does not get all the clause items .",
    "since there are items less preferred by @xmath33 than the @xmath98s such as @xmath100 and @xmath101s , agent @xmath33 is forced to pick a much less preferred item in the collection round .",
    "[ [ utility - of - agent-1 ] ] utility of agent @xmath33 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the utility function @xmath116 of agent @xmath33 is specified as follows :    * there is negligible difference between @xmath117 and @xmath118 .",
    "the utility of both is considerably more than @xmath119 and @xmath120 .",
    "there is negligible difference between @xmath119 and @xmath120 .",
    "* for any variable @xmath56 , agent @xmath33 s preferences over the consistency items are as follows : @xmath121 the utility is set as follows : @xmath122 .",
    "* all items that agent @xmath33 is considering getting in a round ( choice or clause ) are considerably more preferred than the corresponding items in the latter rounds . *",
    "the utilities are set in a way so that as long as agent @xmath33 gets two items corresponding to a variable , at least one top choice consistency items in each round and his target clause item in each clause round , agent @xmath33 gets utility at least @xmath48 .",
    "based on construction of the choice and clause rounds , we are in a position to prove a series of claims .",
    "if agent @xmath33 does not make a consistent choice of the variable items , then it does not get utility @xmath48 .",
    "if @xmath33 does not make a choice in each choice round , his most preferred items corresponding to the literals are taken by the agents corresponding to the literal .",
    "if @xmath33 makes a choice in each choice round but does not make a consistent choice , then he gets @xmath123 which has much less utility than @xmath124 or @xmath125 which means he can not get total utility @xmath48 .",
    "if agent @xmath33 makes consistent choices but the assignment is not satisfying , then agent @xmath33 does not get utility @xmath48 .",
    "if some clause @xmath59 is set false , then agent @xmath33 is not able to @xmath98 because the literal agents in the clause round corresponding to @xmath59 take all the items @xmath126 .",
    "this means that agent @xmath33 does not get utility @xmath48 .",
    "if there exists a satisfying assignment , then agent @xmath33 can get utility @xmath48 .",
    "if there exists a satisfying assignment , then consider the preference report of agent @xmath33 in which in each choice round , he picks @xmath75 and @xmath76 if the @xmath56 is set to be false . by doing this he gets to pick a top consistency item in that round as well . since all the clauses are satisfied , in each clause round , agent @xmath33 is able to gets his clause item @xmath127 .",
    "the utilities are set in a way so that as long as agent @xmath33 gets two items corresponding to the same literal and hence at least one top choice consistency items in each round and his target clause item in each clause round , agent @xmath33 gets utility at least @xmath48 .",
    "the claims show that agent @xmath33 gets utility at least @xmath48 if and only if there is a satisfying truth assignment .",
    "[ example : sat ] we illustrate the reduction in the proof of theorem  [ th : main ] . for the following sat formula , we illustrate how we build an allocation setting with the agent set , item set , preferences of agents and the picking sequence .",
    "@xmath128    set of agents is @xmath129 .",
    "set of items is @xmath130    @xmath131    the picking sequence is as follows    @xmath132    the formula is satisfiable if @xmath133 is true , @xmath134 is false and @xmath135 is false .",
    "let us show how the allocation looks like when agent @xmath33 picks items according to the truth assignment .",
    "the insights and results of @xcite in their section 3.1 and 3.2 still hold for @xmath136 . for the sake of completeness , we outline the main arguments .",
    "we can ascertain that for @xmath136 , not only is there is a linear - time algorithm to compute a best response but each best response results in the same allocation irrespective of the cardinal utilities consistent with the ordinal preferences .",
    "we present a series of lemmas .",
    "[ lemma : simple - strategy ] let the set of items @xmath137 be such that @xmath138 . if @xmath139 is achievable by @xmath33 for some preference report , then agent @xmath33 can achieve @xmath139 by reporting @xmath140 .",
    "consider any report @xmath141 such that the result of @xmath142 is that agent @xmath33 gets @xmath139 .",
    "then changing @xmath141 to @xmath143 in which items in @xmath144 are moved to items after @xmath139 does not change the outcome . at each stage when agent @xmath145 picks , the most preferred available item of @xmath3 remains the same .",
    "we now show that if agent @xmath33 can achieve @xmath139 , he can do so by reporting @xmath146 .",
    "assume that agent @xmath33 does not get @xmath139 by report @xmath147 .",
    "we show that agent @xmath33 can not get @xmath139 by any other report .",
    "let us consider the earliest stage in which agent @xmath35 gets an item from @xmath139 .",
    "let the item be @xmath148 in stage @xmath149 .",
    "this means that by stage @xmath149 agent @xmath35 did not any items from @xmath150 which agent @xmath33 got .",
    "note that by stage @xmath149 , agent @xmath33 gets @xmath151 picks and agent @xmath35 gets @xmath152 picks .",
    "note that @xmath153 is the union of @xmath150 and the items in @xmath144 that agent @xmath35 got before stage @xmath149 .",
    "the most preferred @xmath149 items of agent @xmath35 include @xmath3 items from @xmath139 and @xmath154 other items .",
    "since agent @xmath35 has @xmath155 picks , he will be able to get one item from @xmath156 irrespective of what agent @xmath33 reports because by stage @xmath149 , agent @xmath33 has only @xmath151 picks .",
    "let the set of items @xmath137 be such that @xmath138 .",
    "then the following conditions are equivalent :    1 .",
    "@xmath139 is achievable .",
    "agent @xmath33 can achieve @xmath139 by reporting @xmath157 .",
    "when agent @xmath33 reports @xmath157 , for each picking stage @xmath149 in which agent @xmath33 picks his @xmath3-th , all the @xmath158 items allocated to @xmath35 by stage @xmath149 more preferred than @xmath148 .",
    "@xmath159 trivially implies @xmath160 .",
    "lemma  [ lemma : simple - strategy ] shows that @xmath159 implies @xmath160 .",
    "we prove that @xmath161 implies @xmath159 let us assume that for each picking stage @xmath149 in which agent @xmath33 picks his @xmath3-th , all the @xmath158 items allocated to @xmath35 by stage @xmath149 more preferred than @xmath148 .",
    "then agent @xmath35 is always busy getting more preferred items and agent @xmath33 get @xmath148 in his @xmath3-th pick .",
    "we prove that @xmath159 implies @xmath161 .",
    "now assume that in some picking stage @xmath149 in which agent @xmath33 picks his @xmath3-th item ( @xmath148 ) , not all the @xmath158 items allocated to @xmath35 by stage @xmath149 are more preferred than @xmath148 .",
    "but this means that @xmath35 would have picked @xmath148 already by stage @xmath149 .",
    "[ lemma : br - lex ] for two agents , lexicographic best response is polynomial - time computable .",
    "let us assume that the preferences of the manipulator are @xmath162 .",
    "we set the target set @xmath139 to empty and @xmath163 to @xmath5 .",
    "take the most preferred item @xmath164 and check whether @xmath165 is achievable by 1 .",
    "if yes , we append @xmath166 to @xmath139 . in either case",
    "we delete @xmath166 from @xmath163 .",
    "we continue in this fashion until @xmath163 is empty . for @xmath136",
    ", it can be easily checked whether a given subset @xmath139 of items is achievable by letting agent 1 express the items in @xmath139 in the same order of preferences as agent 2 s preferences over @xmath139 .",
    "this follows from lemma  [ lemma : simple - strategy ] .",
    "next , we see that for @xmath136 , the outcome of any best response is the same for the manipulator . the argument of @xcite works as it is directly for the case of two agents .",
    "[ lemma : achieve ] let @xmath167 and @xmath168 be achievable by agent 1 .",
    "let @xmath169 and assume that @xmath170 .",
    "let @xmath171 .",
    "then @xmath172 is achievable for agent @xmath33 .",
    "based on the lemmas above , the following theorem can be proved .    for @xmath136",
    ", there exists a polynomial - time algorithm to compute a best response .",
    "furthermore the allocation of responding agent as a result of the best response is unique .",
    "from lemma  [ lemma : achieve ] , we know that in order to compute a best response for a given utility function consistent with the ordinal preferences , it is sufficient to compute the best response for _ any _ utility function consistent with the ordinal preferences .",
    "we know from lemma  [ lemma : br - lex ] that there exists a polynomial - time algorithm to compute the best response for lexicographic utilities .    for @xmath136",
    ", there exists a polynomial - time algorithm to verify a pure nash equilibrium .",
    "if there exists a polynomial - time algorithm to compute a best response , it can be used to compute the best response of each agent .",
    "a profile is in pure nash equilibrium if and only if the best response of each agent yields at most the same utility as the preference reported in the given preference profile .",
    "in this paper , we showed that computing a best response under sequential allocation to maximize additive utility is np - hard .",
    "the result is surprising because previously it has been claimed in the literature ( comsoc 2014 and ecai 2014 ) that the problem admits a polynomial - time algorithm .",
    "our np - hardness result does not involve a constant number of agents .",
    "it remains an interesting open problem whether manipulating sequential allocation is np - hard when the number of agents is three or some other constant .",
    "lang , j. , rothe , j. , 2015 .",
    "fair division of indivisible goods . in : economics and computation an introduction to algorithmic game theory , computational social choice , and fair division .",
    "springer , pp ."
  ],
  "abstract_text": [
    "<S> sequential allocation is a simple allocation mechanism in which agents are given pre - specified turns and each agents gets the most preferred item that is still available . </S>",
    "<S> it has long been known that sequential allocation is not strategyproof .    </S>",
    "<S> bouveret and lang ( 2014 ) presented a polynomial - time algorithm to compute a best response of an agent with respect to additively separable utilities and claimed that ( 1 ) their algorithm correctly finds a best response , and ( 2 ) each best response results in the same allocation for the manipulator . </S>",
    "<S> we show that both claims are false via an example . </S>",
    "<S> we then show that in fact the problem of computing a best response is np - complete . on the other hand , </S>",
    "<S> the insights and results of bouveret and lang ( 2014 ) for the case of two agents still hold . </S>"
  ]
}