{
  "article_text": [
    "the evolution equations ( eveqs ) for parton distribution functions ( pdfs ) and parton momentum distributions are one of the most efficient tools in calculating the radiative corrections in quantum chromodynamics ( qcd ) because they perform resummation of certain types of corrections up to infinite order .",
    "the pdfs are indispensable in any analysis of scattering processes which involve hadrons .",
    "the non - perturbative information on hadron structure , for the time being not calculable , is extracted from the experimental data and then used to create the pdfs at low energy scale . among various types of evolution equations",
    "the most important is the family of the dglap - type equations @xcite .",
    "other widely used types of the eveqs include bfkl @xcite , ccfm @xcite or iree @xcite . in this paper",
    "we will discuss the dglap and modified - dglap types of eveqs .",
    "however , a comment on the relation to ccfm eveqs will be made .",
    "there are various numerical methods of solving the dglap - type eveqs : mellin transforms @xcite , evolution on a finite grid @xcite , expansion in laguerre polynomials @xcite , expansion in chebyshev polynomials @xcite , etc .",
    "the monte carlo ( mc ) methods differ from the other numerical techniques because , in addition to providing the inclusive parton distributions , they supply also the complete tree of parton emissions during evolution .",
    "this allows one to construct the mc parton shower programs which provide the actual four - momenta of emitted quarks and gluons  a necessary input for any realistic analysis which must include experimental apparatus effects .",
    "one can find numerous implementations of the leading order dglap evolution in the mc parton shower codes ; let us quote just a few examples : pythia  @xcite , herwig  @xcite , ariadne  @xcite , gr@xmath3ppa  @xcite .",
    "so far the mc methods _ have not been considered _ as a realistic alternative to the other numerical methods of solving eveqs due to low precision and long time of computation .",
    "the presented here mc code evolfmc is intended to fill - in this gap , profiting from the dramatic increase of the cpu power over two decades since nlo dglap evolution was formulated and solved numerically for the first time .",
    "it will be demonstrated in the following with the examples of numerical calculations that evolfmc can solve the ( modified ) dglap - type eveqs with high precision ( @xmath1 at least ) within a reasonable cpu time .",
    "the program evolfmc solves the eveqs for the parton momentum distributions by means of the mc simulation of the multiple emission of partons in the cascade .",
    "the emission process is of the markovian type , i.e.  each emission depends on the information from the previous emission only .",
    "the algorithms are constructed on the basis of the markovian process with simplified emission kernels which retain only the leading singularities .",
    "the complete kernels in the leading and next - to - leading approximation are then recovered by the standard reweighting procedure .",
    "the evolution is two - dimensional ( @xmath4 and @xmath5 ) by construction .",
    "however , the azimuthal angle can always be added with a flat probability density distribution .",
    "having identified the evolution time with certain kinematical variable , one can then reconstruct the four - momenta of all emitted partons .",
    "such a procedure of reconstructing the four - momenta is , of course , exact only in the lo approximation . in the nlo approximation",
    "the differential distributions will be strictly speaking correct only in the `` inclusive '' sense of the overall normalisation .",
    "this is , however , the common ( and in fact the only available ) approach to the parton shower mcs .",
    "it should be mentioned here that recently there have been a few attempts to construct a true nlo parton shower algorithm with the help of `` fully unintegrated '' or `` exclusive '' partonic functions @xcite .",
    "apart from the standard dglap , two modified - dglap - type eveqs can be solved by evolfmc .",
    "the modifications involve a change of the argument of the coupling constant together with the introduction of a finite cut - off on its minimal value .",
    "the program works in the weighted mode only . the first version of the code , the evolfmc v.1 ,",
    "was described in @xcite , but the actual code was not published .",
    "the version v.1 solved modified - dglap - type in the lo approximation only .",
    "the nlo evolution was available only in the standard dglap case .",
    "also the structure of the code is rebuilt in version v.2 .",
    "let us conclude this introduction with the following remark .",
    "the mc approach to eveqs has one important general advantage : with the help of the reweighting technique it is easy to introduce into evolution some additional effects or modifications . as an example",
    "let us mention the possibility of emulating the ccfm - type evolution . from the algorithmic point of view ,",
    "having generated the azimuthal angles and reconstructing the transverse momenta of the partons in the shower , one can trivially construct the so - called `` non - sudakov '' form factor and include it as a correcting weight .",
    "of course , one has to remember that from the theoretical point of view the definition of the non - sudakov form factor in the nlo case is a highly nontrivial problem ; even the complete lo analysis is difficult in the context of the ccfm equation @xcite .",
    "additional modifications in evolution kernels can be done as well .",
    "the paper is organized as follows . in section",
    "[ sect : general ] we give a short theoretical overview of the evolution equations and their solutions by means of mc methods .",
    "section  [ sect : software ] describes in some detail the architecture of the presented mc code , evolfmc version  2 . section  [ sect : install ] contains instructions on how to install the code on linux and mac os x platforms . in section  [",
    "sect : demos ] we present two demonstration programs included in the distributed version of the code . section  [ sect : precision ] contains a detailed study of the technical precision of evolfmc at the level of @xmath1 .",
    "a short summary in section  [ sect : summary ] concludes the paper .",
    "in this short theoretical overview we will only give a few formulae and definitions necessary to explain the notation , to define the problem and to present the solution .",
    "for detailed derivations and technical description of the algorithms we refer the reader to the extensive bibliography , which we will present here in more detail . the short and elementary description of the solution of the dglap - type eveqs in terms of the markovian process and its mc realization in the lo approximation has been presented in ref.@xcite .",
    "the extension to the nlo level and comprehensive description of mc algorithms that solve the markovian evolutions of pdfs and parton momentum distributions has been given in refs .",
    "the algorithms presented in @xcite have been implemented in the first version of the code , evolfmc v.1 .",
    "the extension to the modified - dglap - type evolutions and the detailed description of appropriate modified - dglap markovian algorithms has been given in refs .",
    "@xcite for the lo case ( implemented in evolfmc v.1 ) and in ref .",
    "@xcite for the nlo approximation .",
    "the implementation of algorithms from ref.@xcite as well as re - organization of the implementation of the dglap - type algorithms from ref .",
    "@xcite has been done in the second version of the code , evolfmc v.2 , presented in this paper . finally , in ref .",
    "@xcite the general and universal formalism of constructing markovian algorithms , common for all dglap - type and modified - dglap - type evolutions , has been presented on the basis of the operator language .",
    "it is this formulation @xcite that we will use in the rest of this section to describe the principles of the markovian mc evolution .",
    "the evolution equation and its solution in the form of a master iterative formula for the markovian mc algorithm can be expressed as follows : @xmath6 and @xmath7\\times \\\\ \\times &   { \\bf k}^r(t_{1 } )   { \\bf g}_{{\\bf k}^v}(t_{1},t_{0 } ) + \\bar{\\bf e}{\\bf g}_{{\\bf k}^v}(t , t_{0})\\delta_{t_1=t } \\bigg ) { \\bf d}(t_0 ) .",
    "\\end{split}\\ ] ] let us describe all the ingredients of eqs .",
    "( [ eq : op - evoleq ] ) and ( [ eq : evol5 ] ) .    * the multiplication of the matrices",
    "is understood as : @xmath8 .",
    "* @xmath9 is the parton density function of the parton @xmath10 .",
    "* @xmath11 is the generalized evolution kernel built from the real and virtual parts : @xmath12 * the operator @xmath13 is defined as @xmath14 , i.e.  it turns parton distributions into parton momentum distributions , whereas summing and integrating over final degrees of freedom means in the mc language that we generate all possible final state configurations without any constraints .",
    "* @xmath15 is the solution of the evolution equation with the virtual kernel @xmath16 only @xmath17 * @xmath18 is the sudakov form factor , expressed in terms of the real emission part of the evolution kernel @xmath19    the actual , normalized to unity , probability densities of the variables in each step of the markovian process are visible in each of the lines of the eq.([eq : evol5 ] ) , representing a single step in the emission chain : @xmath20 .",
    "\\end{split}\\ ] ] in the program evolfmc v.2 we have implemented three types of the evolution differing by the definition of the evolution kernel @xmath21 , @xmath22 : @xmath23 , \\end{split}\\ ] ] where @xmath24 .",
    "the parameter @xmath25 is an arbitrary cut - off on the argument of the coupling constant , greater than @xmath26 , necessary in order to avoid the singularity in the coupling constant .",
    "note that the part of the real emission phase space excluded by the cut - off @xmath25 is compensated for by the virtual form factor defined in eq .",
    "( [ eq : phireal ] ) as the integral over phase space of a real emission . as a consequence",
    "the momentum sum rule is preserved .",
    "@xmath27 takes one of the following three forms : + a : @xmath28 ,   ( the dglap evolution ) + b : @xmath29 ,   ( the modified - dglap b-type evolution ) + c : @xmath30 ,   ( the modified - dglap c-type evolution ) .",
    "the term @xmath31 is added to remove the double counting caused by the change of the argument of the coupling constant , according to the prescription of ref .",
    "namely , from the expansion @xmath32 one obtains @xmath33 note that in the case c we use the counter term identical as in the b case .",
    "the additional piece related to @xmath34 is of a genuine beyond - dglap origin , i.e.  it is absent in the dglap kernel .",
    "therefore , there is no double counting and no need to subtract it .",
    "the universal lo part @xmath35 and the nlo part @xmath36 are given in @xcite .",
    "finally , the coupling constant at the nlo level has the standard form @xmath37 on the technical side , in the actual mc algorithms implemented in evolfmc v.2 we do not use the complicated kernels ( [ kernbare ] ) . instead",
    ", a series of simplified kernels @xmath38 is introduced .",
    "each of them is chosen in such a way that it retains only the leading singularities of the exact kernel @xmath39 while all the complicated but finite structure is temporarily discarded : @xmath40 for the @xmath41 case and @xmath42 for the cases @xmath43 and @xmath44 .",
    "the variable @xmath24 .",
    "the constant @xmath45 is defined as @xmath46 and @xmath47 is a dummy technical parameter .",
    "the functions @xmath48 and @xmath49 are a convenient parametrization of the full lo kernels @xmath35 @xmath50 see appendix c of ref .",
    "@xcite for the complete list of them ( for example , for the @xmath51 kernel we have @xmath52 and @xmath53 ) .",
    "the nlo kernels @xmath54 in the form used in the code are explicitly given in appendix a of ref .",
    "the exact kernel @xmath39 is recovered at the end by the standard reweighting procedure .",
    "the correcting weight is @xmath55 the product runs over all generated partons in a given mc event with multiplicity @xmath56 , and the form factor @xmath57 is constructed from @xmath58 , in analogy to eq.([eq : phireal ] ) .",
    "the actual expressions for the form factors @xmath59 and @xmath60 are fairly complicated , especially for the cases b and c , and we will not quote them here , referring the interested reader to the original papers .",
    "let us only remark that , as seen in eq .",
    "( [ eq : phireal ] ) , the form factors are defined as two - dimensional integrals . in the case of the simplified form factor @xmath60 both integrals can be done analytically ) .",
    "this is for example why the @xmath61 term multiplies artificially also the @xmath62-function in eq.([simplebprim ] ) .",
    "the constant @xmath63 is added to avoid potentially dangerous zeroes at the nlo level . ] . on the contrary , in the full form factor @xmath59",
    "only one integration can be done analytically .",
    "the other one has to be done numerically on an event - per - event basis .",
    "the program evolfmc is written in the c++ language . to compile and link the code we use the autotools utility .",
    "it allows us to compile / link the code on many platforms in a simple way .",
    "the code has been routinely compiled and run under the linux and mac  os  x 10.5 operating systems . from the user point of view",
    ", the only difference between these two systems is in the compiler s options inside the file configure.in , which is included in the main folder of the project .",
    "the central part of the evolfmc source code is the markovmc library located in the markovmc folder .",
    "this folder includes the essential source code necessary to solve evolution equations .",
    "this part of the code requires only basic c++ libraries and an external random number generator ( rng ) .",
    "we use the generator trandom3 from the root package as a default rng . with this generator",
    "we have reached the precision below @xmath64 . in case when root is not available on a given system platform , one should replace in the _ wrapper _ class rndm the name trandom3 with the name of the other rng .",
    "a simple main program in the demo0 folder uses only the standard c++ libraries and can be built and executed without root . on the other hand",
    ", the more sophisticated source code in the demo1 folder of the distribution version of the project uses the root library , mainly for booking , filling and drawing histograms and more , see below .",
    "the library in the markovmc folder has a modular structure in the sense that the algorithms that solve a particular type of the evolution equations are implemented in separate classes and located in separate source files .",
    "each class implementing the markovian mc algorithm for a given type of evolution equation includes all formulae , in particular the sudakov form factors , specific to a given evolution type .",
    "all classes specific to one type of evolution inherit from the common base class markoviangen .",
    "this modular structure also makes it easier to add in the future any new type of the qcd evolution of the parton distributions to the code .      in the following the structure of the folders of evolfmc",
    "is described :    * markovmc  the folder containing the library of the markovian mc engines .",
    "source codes of the classes solving various types of the evolution equations are placed in separate files .",
    "* demo0  the folder with the simple demonstration program demo0 written in the c language .",
    "this program demonstrates the standalone usage of the library markovmc , without the use of root .",
    "* demo1  the folder hosting the demonstration program demo1 , a template program for the advanced user of evolfmc .",
    "demo1 requires root to be installed in the system .",
    "the subfolder demo1/work contains scripts necessary to run demo1 .",
    "* m4  the folder containing a script which defines properly a path for the root libraries .",
    "this script is used by the automake program .",
    "each of the above folders contains also scripts ( in the files makefile.am ) , which are required by the automake utility .",
    "the source code of the markovmc library consists of three categories of files : ( 1 ) the files containing base classes of the markovian mc generator , ( 2 ) the files which contain classes specific to a particular type of the qcd evolution equations , and ( 3 ) the files with some auxiliary classes .    1 .",
    "base classes * markoviangen.cxx , markoviangen.h : + the class markoviangen contains the essential part of the markovian mc algorithm , member functions and data members common to all types of the qcd evolution .",
    "in particular , it executes the main markovian loop over parton emissions .",
    "virtual member functions encapsulate evolution details .",
    "* kernels.cxx , kernels.h : this class defines the dglap lo kernels . *",
    "kernels_nlo.cxx , kernels_nlo.h : this class defines the dglap nlo kernels ; it inherits from the simpler class kernels . 2 .",
    "auxiliary classes * gaussintegral.cxx , gaussintegral.h : the standard gauss integration procedure , translated from the fortran gnu library to c++ . * rndm.cxx , rndm.h : the wrapper class of the random number generator ; it is derived from the root class trandom3 .",
    "classes implementing one particular type of the qcd evolution equation for the parton momentum distributions : * dglap_lo.cxx , dglap_lo.h : implementation of the dglap lo evolution ; this class is derived from the classes markoviangen and kernels .",
    "* dglap_nlo.cxx dglap_nlo.h : implementation of the dglap nlo evolution ; this class is derived from the classes markoviangen and kernels_nlo .",
    "* bprim_lo.cxx , bprim_lo.h : implementation of the modified - dglap evolution scheme b , the lo case ; this class is derived from the classes markoviangen , kernels and gaussintegral . *",
    "bprim_nlo.cxx , bprim_nlo.h : implementation of the modified - dglap evolution scheme b , the nlo case , the basic algorithm ; this class is derived from the classes markoviangen , kernels_nlo and gaussintegral .",
    "* bprim_nlo_aux.cxx , bprim_nlo_aux.h : implementation of the modified - dglap evolution scheme b , the nlo case , the auxiliary algorithm ( for tests only ! ) ; this class is derived from the classes markoviangen , kernels_nlo and gausintegral .",
    "* cprim_lo.cxx , cprim_lo.h : implementation of the modified - dglap evolution scheme c , the lo case ; this class is derived from the classes markoviangen , kernels and gaussintegral .",
    "* cprim_nlo.cxx , cprim_nlo.h : implementation of the modified - dglap evolution scheme c , the nlo case , the basic algorithm ; this class is derived from the classes markoviangen , kernels_nlo and gaussintegral .",
    "* cprim_nlo_aux.cxx , cprim_nlo_aux.h : implementation of the modified - dglap evolution scheme c , the nlo case , the auxiliary algorithm ( for tests only ! ) ; this class is derived from the classes markoviangen , kernels_nlo and gaussintegral .",
    "as already indicated , all the classes that are used to solve the evolution equations for the parton momentum distributions by means of the markovian mc method are derived from a few base classes .",
    "depending on the type of the qcd evolution , the base classes are : markoviangen , kernels and its derived class kernels_nlo , and the auxiliary class gaussintegral .",
    "the derived classes implement details of the particular type of the qcd evolution equations ( e.g. dglap_lo.cxx ) . in particular ,",
    "these classes include member functions which generate randomly the evolution time , the parton flavor and the @xmath65-variable , which are defined as virtual member functions in the base class markoviangen .",
    "the base class markoviangen implements all essential parts of the markovian algorithm and a few auxiliary functions .",
    "the central member function of this class is generateevent .",
    "the class markoviangen does not know the details of the evolution kernels  they are implemented in the class kernels and/or kernels_nlo .",
    "the gaussintegral class owns integration methods .",
    "these methods are necessary to calculate the sudakov form factors for more complicated types of the qcd evolution .    depending on the complexity of the equation , the structure of inheritance has different forms . as an example we present in fig .",
    "[ fig : ccfmnlouml ] the inheritance scheme for the most complicated case of the modified - dglap nlo c-type evolution .",
    "the classes of the markovmc library and the organization of the source code have been designed in such a way that ( a ) an infrastructure is available for any kind of the markovian mc implementing any kind of the qcd evolution , ( b ) it is easy to include or exclude any group of classes implementing any type of the qcd evolution .",
    "it is therefore not surprising that the classes which solve different evolution types are completely independent from each other .",
    "one can exclude a particular class from the code without loosing functionality of other classes .",
    "also , adding more evolution types would not modify the structure of the library . in the practical application ,",
    "if one needs , for instance , a solution of the modified - dglap nlo scheme c , then one should include only the header file cprim_nlo.h .",
    "a simple example will be shown in the demo0 program in the following sections .",
    "* virtual member functions .",
    "* + the member functions from this group are implemented in the derived classes :    * void markoviangen::generateevent(double & t , double & vx , double & weight , double tmax , int & flavor , double epstsolver = 0.0001 )  generates a single mc event according to the markovian algorithm .",
    "* void markoviangen::generateevent ( )  generates a single mc event according to the markovian algorithm , a `` wrapper '' function , see sect .",
    "[ demo1 ] for explanation . * double generatet(double rndm , double t_prev , double tstop , double epstsolver , double vx )  generates the evolution time . * double generatez(double rndm , double t , double t0 , double epstsolver , double vx )",
    " generates the actual light - cone variable z. * int",
    "generateflavor(double rndm , int oldflavor )  generates the parton - flavor index . * double kernelweight(double t , double z , double vx )",
    " provides part of the mc weight turning the simplified kernel into the exact kernel . * double deltarealpart(double t_new , double t_old , double z )  part of the mc weight from the sudakov form factor evaluated analytically . *",
    "double deltavirtualpart(double t_new , double t_old , double z )  part of the mc weight due to the sudakov form factor evaluated numerically .",
    "* virtual void init ( )  initialization of an object .",
    "* void addparticle(double t , double x , double z , int f , double weight , int index )  stores data of a single parton emission , a private function , not to be used outside the markoviangen class .",
    "* other auxiliary member functions used to transmit the flavor type between the class markoviangen and the class kernels : * * void setactualflavor(int flavor )  transmits the actual parton flavor to kernels . *",
    "* void setoldflavor(int flavor )  transmits the old flavor to kernels .",
    "* `` getter '' functions for the external users : * * bool getparticle(double & t , double & x , double & z , int & f , double & weight , int index )  provides the external user with the information about partons generated in the last mc event ; index runs from @xmath66 to eventmultiplicity , the variables t , x , z , f and weight describe the emission of the number index , weight is the cumulative weight ; index  @xmath67 returns information on the initial parameters of generateevent and in this case z @xmath68 . * * int geteventmultiplicity ( )  returns a number of particles generated in the last mc event .",
    "all parameters of the virtual functions belong to the following list :    * double rndm  the random number , * double t  the evolution time , * double t0  the start of the evolution time , * double tstop  the end of the evolution time , * double z  @xmath69 , * double vx  as input : the light - cone @xmath70 variable before the emission ; as output : the @xmath71 variable after the emission , * double t_new ",
    "@xmath72 the generated current evolution time , * double t_old  @xmath73 the evolution time of the previous emission , * double knew ",
    "@xmath74 the generated current flavor , * double kold  @xmath75 the flavor of the previous emission , * double flavor ",
    "the flavor ( depends on the function ",
    "explanation above ) , * double weight  as input : the initial weight to be assigned to the event ( for example from the generation of the initial condition ) ; as output : the cumulative weight of the event , * epstsolver  the precision for the tsolver function",
    ".      constructors and other methods of the classes in the markovmc library have as formal parameters several small parameters , which we call epsilon - parameters .",
    "they may be of technical or physical character .",
    "let us explain them with explicit examples .",
    "\\(1 ) the constructor    ....",
    "dglap_nlo(double t0 , double lambda , double numberofflavor ,                   rndm * rngen , double epsilon_irc = 0.0001 ,                                double epsilon_zmin = 0.0001 ) ....    contains two physical epsilon - parameters :    * epsilon_irc is the _ dummy _ infrared cut - off at @xmath76 for the dglap evolution .",
    "solutions of the evolution equations do not depend on its value as long as it is kept small enough ( @xmath77 by default ) .",
    "* epsilon_zmin is the minimal value of the final @xmath4-variable . in practice",
    "it is used as a cut - off for the @xmath65-variable in the kernels which exhibit a logarithmic divergency in the small @xmath65 limit .",
    "note that the mc program will generate the distribution for @xmath78 but it will be incorrect , see sect .",
    "[ simpledemo ] for more comments .",
    "\\(2 ) in more advanced classes , such as cprim_nlo , there is another technical epsilon - parameter : epstsolver .",
    "it is used in the method generateevent of the base class to set the precision of the important tsolver member function which inverts numerically an arbitrary one - dimensional function .",
    "\\(3 ) the last two technical epsilon - parameters are defined in the auxiliary class gaussintegral , see for instance one of its member functions    .... double dqags(double a , double b , double epsabs , double epsrel ,               double & abserr , int & neval , int & ier ) , ....    where epsabs and epsrel are used to set the technical absolute and relative precision of the numerical integration .",
    "the markovmc library does not generate the initial parton momentum distributions  the user is supposed to provide the initial values of @xmath4- and flavor - variables for the generateevent method .",
    "the actual generation of the initial parton momentum distributions is therefore done by an external mc application .",
    "we provide two examples of such an external environment . the first one , in the folder demo0 ( see section [ simpledemo ] ) , simply uses fixed values of starting xstart and flavor .",
    "the second , a more advanced example in the folder demo1 ( see section [ demo1 ] ) , uses the adaptive mc generator tfoam ( part of the root system ) to generate the initial densities . in demo1",
    "we use the gluon ( @xmath79 ) and quark singlet ( @xmath80 ) pdfs with three massless quarks in the following notation : @xmath81 and @xmath82 more details on the actual implementation of the tfoam - based generation can be found at the end of section [ demo1 ] .",
    "this section instructs the user of evolfmc v.2 how to install the program on two system platforms : linux and mac  os  x. the syntax of linux commands is given for the bash shell .",
    "the first few steps concern installation of the root package . as explained earlier , the library markovmc as such does not need root .",
    "however , in the distributed version the root package is required as a source of the random number generator for the library markovmc .",
    "the more advanced demonstration program demo1 exploits root as a histogramming package and uses its persistency mechnism",
    ".    a step - by - step installation procedure of evolfmc looks as follows :    1 .",
    "check if root is installed in the system and find its location . in the case",
    "there are several versions of root in the system , choose the preferred one .",
    "2 .   check if the environmental variable rootsys is defined correctly : echo $ rootsys . if several versions of root are in the system , define the rootsys variable as a path to the correct / preferred version : + export rootsys = path_to_your_root + check if the shell variable ld_library_path ( or dyld_library_path in mac  os  x ) contains a correct path to the root s library . if not , then execute : + under linux : + export ld_library_path=$ld_library_path:$rootsys / lib + under mac  os  x : + export dyld_library_path=$dyld_library_path:$rootsys / lib + it is convenient to put this command into the bash - shell configuration files : .bashrc or .bash_profile . finally , check if the $ path variable includes a correct path to the root binaries .",
    "3 .   add the path to the project to the variable ld_library_path ( dyld_library_path in mac  os  x ) .",
    "this is done under linux by : + export ld_library_path=$ld_library_path : path_to_the_project / lib + or under mac  os  x : + export dyld_library_path=$dyld_library_path : path_to_the_project / lib + _ note : _ for the demonstration programs demo0 and demo1 the user may skip the above commands because this path is already set in the appropriate makefiles .",
    "4 .   build the program from the commad line in the main project folder : + autoreconf -i force + under linux : ./configure + under macosx : ./configure enable - platform = macos + make 5 .",
    "test the correctness of the installation : + ( cd demo0 ; ./verify_benchmarks ) .",
    "+ for more details on the above test as well as on how to run two demonstration programs demo0/demo and demo1/demo1pr see the next section .",
    "the authors have also managed evolfmc using two popular integrated software development packages : kdevelop and eclipse .",
    "let us hint on how to initialize evolfmc as a project within these development tools :    1 .   kdevelop + from the main folder of the project just type in the shell : + kdevelop & + then from the menu choose and set to .",
    "next time you open kdevelop , the configuration files will be already in place .",
    "+ ( do not forget in the menu @xmath83<project  options>@xmath83<configure  options > : in the window to choose _ default _ instead of _",
    "debug_. ) 2 .   eclipse + the configuration files are included , so it is enough to invoke eclipse and from the menu @xmath83<import>@xmath83<general > choose .",
    "the list of existing projects should appear , including the current evolfmc .",
    "finally , let us explain how to test quickly the correctness of the installation .",
    "this is done by means of executing a special `` benchmark test '' in form of the bash script verify_benchmarks included in the subfolder demo0 of the distribution folder .",
    "this test compiles and links the program demo0/demo.cxx , and then runs it in a sequence for all eight implemented types of the evolution .",
    "text outputs from these runs , containing a printout of the variable @xmath4 , the flavor type and the mc weight for 100 events , are produced and compared using the diff utility against the benchmark outputs stored by the authors of the code in the subfolder demo0/bmarks_outputs .",
    "if the installation procedure and all the settings are correct , then there should be no differences between the stored and the current output disk files .",
    "the stored outputs have been generated on the system imac core 2 duo with gcc 4.2 under ubuntu 8 .",
    "+ summarizing :    1 .",
    "the benchmark test can be invoked as follows : + cd demo0 + with the help of the bash script + ./verify_benchmarks + 2 .",
    "if needed , the user may create his / her own new set of benchmark output files with the help of the bash - shell script in the demo0 folder : + ./create_benchmarks    alternatively , the above benchmark can be executed with the command make bmark .",
    "in the following we describe in a more detail two demonstration programs in the subfolders @xmath84 and @xmath85 , which the user should run after installation of evolfmc . they are also meant as the templates for applications which use evolfmc in studies related to the perturbative qcd ",
    "most likely as a testing tool for other mc programs implementing the qcd evolution of the parton momentum distributions , or as part of some bigger mc application .",
    "these two programs are already built during installation , see the previous section , and can be executed as follows :    1 .",
    "a simple demonstration program : + cd demo0 + make start 2",
    ".   a more advanced demonstration program : + cd demo1/work + make start + four histograms are recorded in the disk file . to visualize them : + make plot    let us describe these two demo programs in a more detail .      the simple demo.cxx program is included in the subfolder @xmath84 in order to demonstrate how to generate mc events for any of the eight evolution types supported by evolfmc .",
    "the listing of the whole program demo.cxx is given in the appendix .",
    "let us present and explain the crucial instructions in the demo.cxx source code , using the example of just one evolution type  lo dglap :    .... [ ... ] # include \" rndm.h \"                                            ( 1 ) # include \" dglap_lo.h \" [ ... ] int main ( ) {       [ ... ]    rndm      * rngen = new rndm ( ) ;                             ( 2 )    dglap_lo * dglap_ll = new dglap_lo(t0,lambda ,                   numberofflavors , rngen , epsirc , epszmin ) ;      ( 3 )    for(int i=0;i <",
    "numberofevents;i++ )    {      dglap_ll->generateevent(tc , xstart , weight , tstop , flavor ) ; ( 4 )      [ ... ]    }    [ ... ] } ....    1 .",
    "the appropriate header files are included : one for the class of the random number generator and another one for the class of the chosen evolution type .",
    "the object of the rngen class being the random number generator is created .",
    ", the mc generator object dglap_ll of the class dglap_lo is created .",
    "it is the central object of the above code and it is used to generate a series of the mc events .",
    "the arguments of the dglap_lo constructor are : the initial ( starting ) value of the evolution time tmin , the value of @xmath26 lambda , the number of active flavors numberofflavors and the pointer to the object of the random number generator rngen . in addition , the parameter epsirc is the technical cut - off used for regularizing the distribution @xmath86 at @xmath87 in the kernel @xmath88 of eq .",
    "( [ eq : evkernel ] ) .",
    "the final result will be independent of epsirc , if it is kept small enough .",
    "the last parameter , epszmin , is the minimal requested value of the @xmath4 variable to be generated .",
    "a non - zero value of the cut - off @xmath89 is necessary only in the nlo cases , due to the presence of the @xmath90 singularity in the nlo dglap kernels .",
    "@xmath91 in the kernels is cancelled for evolution of the momentum distributions but @xmath92 is still present , hence some form of a cut - off is needed .",
    "note that the solution for @xmath93 given by the program is always independent of this cut - off , see sect .",
    "[ smallparams ] for more details depends on this cut - off and therefore should not be trusted . ] .",
    "note that both epsirc and epszmin have default values assigned by the constructor and their redefinition , as done in the above example , is optional .",
    "finally , the mc events are generated with the method generateevent .",
    "the meaning of the arguments of generateevent is the following : + tc is a parameter for technical tests , not to be used .",
    "the initial conditions of the evolution are set by xstart and flavor , being the initial values of the @xmath4-variable and the flavor type .",
    "tstop is the maximal value of the evolution time , weight is the initial weight assigned to the event , normally set to 1 , epssolver is a technical parameter defining the accuracy of a procedure for inverting numerically certain functions  should not be modified ! the same parameters xstart and flavor return the generated final value of the @xmath4-variable and the final flavor type , while weight is the weight of the generated mc event .",
    "a detailed history of the evolution is recorded inside the object dglap_lo .",
    "in particular , the values of all generated @xmath4- and flavor - variables , including their initial values , are stored there ( in the m_x : markovmc and m_f : markovmc matrices ) .",
    "all these parameters can be accessed easily with the help of the functions getparticle and geteventmultiplicity .",
    "all other evolution types follow exactly the same pattern , as can be seen in the demo.cxx file .    the program demo.cxx prints in the output the final @xmath4 and the final flavor of the first 100 of the generated mc events .",
    "after completing the mc generation it calculates and prints the average of the mc weight .",
    "this average is equal to the sum over the final flavors integrated over the final @xmath4-variable .",
    "this , in turn , is _ almost _ equivalent to the unitary normalization of the momentum distribution functions according to momentum sum rule .",
    "it is _ almost _ equivalent because in the mc program the lower limit @xmath89 is imposed on the value of the generated final @xmath4-variables , @xmath94 , so there will be a tiny missing piece in the sum rule comming from the integral from @xmath66 to @xmath89 .",
    "note that this integral contains only _ integrable _ singularities of the @xmath92-type , so by lowering @xmath89 the sum rule can be tested to an arbitrary precision .",
    "the library of the classes in the folder markovmc is a collection of pure mc generators written in a clean and minimalistic way .",
    "as shown in the previous simple demo , it is easy to use the mc generator objects of these classes . in the real life , the pure mc generators are only a small part of a bigger code in which they are embedded .",
    "let us call this environmental code the _ mc application _ ( mcap ) and characterize briefly _ functionality _ and _ data structures _ of such a mcap .",
    "the functionality of mcap typically includes : ( a ) running many times for various input data a mc event generator and storing output data in a form of one and more dimensional histograms and/or mc events , in the systems with one processor ; ( b ) the same in systems with many processors , many nodes ( pc farms ) ; ( c ) visualization and quick analysis of the stored results after the mc `` production run '' is finished , or even while the mc production is still running , in particular , ( d ) comparisons with the stored `` benchmark '' results from the previous `` consolidated '' versions of the program , ( e ) comparisons with the results of analytical and other non - monte - carlo numerical calculations , ( f ) comparisons between the stored mc results from the runs with different input data and more .",
    "the data structure of mcap typically features : ( a ) a collection ( database ) of the input parameters with clear distinction between the parameters which are `` hardwired '' and changed only in very special technical tests , the default paremeters which are rarely changed , such that the user may normally ignore them , and , finally , the important steering parameters which are changed often or it is even obligatory to ( re-)define them .",
    "( b ) a data base of the output results from the consolidated well - tested versions of the program , important results from long cpu time mc runs , outputs used in the published works .",
    "( c ) some degree of persistency mechanism for writing / reading structured data in / from a disk file is absolutely necessary in organizing mcap .",
    "this persistency may be limited to data objects , such as mc events and histograms , or include a possibility to write into a disk file the objects of the random number generator , parts of the mc generator embedding important member data , or even the complete mc event generator in the `` ready - to - go '' state .",
    "in the presented distribution package we do not include the full scale mcap environment for the markovmc library .",
    "however , the demonstration program in the folder demo1 represents an essential step towards such an infrastructure .",
    "the demonstration program demo1/mainpr.cxx features to a large extent the points ( a ) , ( c ) , ( d ) and ( c ) of the above specification list and is meant as an useful template for the further development .",
    "let us first overview it briefly , and more details will follow later on .    in this example the markovian mc generator object m_mmc , being the instance of one of the eight classes of the markovmc library , is embedded as a member of the object m_mcgen of the container class mmcevol .",
    "the object m_mmc is created there , filled in with the input data , and used to generate mc events using the methods of the mmcevol and markoviangen classes . every mc event generated by m_mcgen->m_mmc",
    "is made available for histogramming .",
    "the object m_mcgen is embedded ( not created ) in the object of the class trobola .",
    "methods of this class perform several functions : book histograms , transfer input data and a pointer of an external random number generator m_rng object into m_mcgen , generate a single mc event , fill - in histograms and write histograms into a disk file .",
    "the object of the trobola class does not contain , however , the main loop over the mc event generation , nor creates the m_rng and m_mcgen objects . the main loop over the mc events",
    "is located and managed in a rather special way in the main program mainpr , while the objects of the external random number generator m_rng and of the mc generator m_mcgen are created in a separate small script demo1/work / start.c .",
    "this scrips , run by root in the interpreter mode , defines also all input data of the mc run .",
    "execution of start.c , building , running and stopping the main program ( as well as plotting the results ) is managed by demo1/makefile .",
    "the elements of the above five - level functionality and data structure ( makefile , the main program , the trobola class , the mmcevol class , the markoviangen class / library ) , sketched above , will be described in a more detail in the following . at the first glance",
    ", this may look overcomplicated .",
    "however , one has to remember that the fully functional mcap , defined in points ( a)(f ) , ( a)(c ) above , will unavoidably be rather complicated , especially for running on the multinode pc farm .",
    "the presented structure exploits years of experience of the authors in developing many similar mc infrastructures for running and testing mc event generators @xcite , and we hope that it may be useful for others as a template to develop it further and/or customize to their own needs .",
    "let us now add more details on the demo1 source code and its execution .",
    "all the c++ source code files specific to this demo program are located in the folder demo1 while the input / output files can be found in its subfolder demo1/work .",
    "the main ( ) program is located in the file mainpr.cxx .",
    "it consists of three main parts corresponding to the initialization , the generation of the mc event series and the final part of the mc program .",
    "the same three parts are present as three stages in the execution of the program . in the first stage ,",
    "the work / start.c script creates three objects : ( 1 ) an object of the mmcevol class , that is the mc generator , ( 2 ) an object of an external random number generator and ( 3 ) an auxiliary object of the class tsemaf .",
    "these objects are initialized with the default data residing in the class constructors , and then they are modified with the run - specific input data contained explicitly in the code of the start.c script ( in particular , a random number seed may optionally be redefined at this point ) .",
    "the object of tsemaf contains data for administering the main mc loop in the main program .",
    "the above three objects are written by start.c into the disk files _ semaf.root _ ( the object tsemaf ) and _ mcgen.root _ ( the objects mmcevol and random number generator ) . in the above and in the following the persistency feature of the root system is exploited to facilitate writing and reading the entire objects into / from the disk files .",
    "the run - specific input data are all provided in work / start.c , including all steering parameters of the mc generator the user wishes to reset from their default values .",
    "examples of such settings together with comments , specific to the demo1 run , can be found inside work / start.c .    after executing start.c",
    ", the main program mainpr comes into action .",
    "it reads all three stored objects from the disk files _ semaf.root _ and _ mcgen.root _ and creates a new object of the trobola class containing all histograms and the pointers to the mc generator m_mcgen and the random number generator m_rng . the event generation loop is started .",
    "the number of mc events is set by the variable nevtot which is read from the tsemaf class object . after generating every ngroup events ,",
    "the partial results of the mc generation are stored in a disk ( the ngroup variable is also taken from the tsemaf object ) . before going to the next group of the event generation , the status of the special semaphore - type flag in the tsemaf object in the disk file _ semaf.root _ is examined .",
    "if the status flag is equal to `` continue '' , then the event generation is continued , otherwise , if it is equal to `` stop '' , then main loop and the mc generation is terminated .",
    "the latter status flag can be reset by the user interactively by calling make stop from the subfolder work . at the start of the program",
    "the status of this flag is always set to `` start '' and it is redefined to `` continue '' immediately after generating the first group of the mc events .",
    "the class called tsemaf is defined in the files ( tsemaf.h , tsemaf.cxx ) .",
    "the semaphore object contains also some auxiliary information on the generated event sample , such as the number of events .",
    "once the event generation loop is terminated , the programs enters into the short finalization stage during which all the necessary statistics on the mc event sample are calculated and all histograms of the trobola class are stored in the output file histo.root .",
    "histograms are also recorded into histo.root after generating each group of mc events .",
    "the source code of class trobola is located in the files ( trobola.h , trobola.cxx ) .",
    "its main task is to create and fill - in appropriate histograms .",
    "this is done in three stages : booking , filling and storing of the histograms with the help of the class - member functions : hbook ( ) , production(double & ) , filedump ( ) , respectively .",
    "more details can be found in the source code .    the demonstration program demo1/demo1pr generates a sample of @xmath95 weighted events for the evolution of the parton momentum distributions from @xmath96gev to @xmath97gev .",
    "in the course of the mc event generation , the program fills - in histograms of the gluon and quark - singlet parton momentum distributions and the corresponding mc weights with the help of root .",
    "these histograms are stored in the disk file histo.root written in the root format . after completing the generation of the series of the mc events ,",
    "the stored histograms are plotted using the root graphics programs and compared graphically with the histograms pre - computed and stored in the distribution folder .",
    "the appropriate commands for running this demo program and plotting the results are make start and make plot , see the beginning of this section .",
    "another c++ program work / draw.cpp is included for analyzing / viewing the produced histograms and comparing them with some pre - computed results .",
    "if the instalation of the mc program is done correctly , the user - produced results should agree with the pre - computed ones within statistical errors .",
    "this program can be run in the interpreter mode of root with the help of a single command make plot .",
    "let us finally add a few details on embedding the object m_mmc of the markoviangen class inside the `` wrapper '' object of the class mmcevol .",
    "the object m_mmc is created by mmcevol::initialize ( ) using the constructor of one of the eight classes implementing a specific evolution type .",
    "which one to choose is decided by the steering data member m_evoltype of the mmcevol class .",
    "then , each mc event is generated by mmcevol::generate ( ) , which calls m_mmc->generateevent ( ) . here , the method markoviangen::generateevent ( ) does not have any parameters ( contrary to the one used in demo0 ) .",
    "this is why the getter markoviangen::settrange have to be used in mmcevol::initialize to define the range of the evolution time .",
    "also , prior to m_mmc->generateevent ( ) , @xmath4 and the flavor of the initial parton are generated using the tfoam utility of root and they are fed into the object m_mmc using the dedicated setter markoviangen::setinitparton .",
    "the corresponding part of the code in mmcevol::generate ( ) looks as follows :    .... //",
    "generate primordial / initial parton if ( m_foami ! = null ) {    m_foami->makeevent ( ) ;        // generate   x and parton type    m_wt = m_foami->getmcwt ( ) ;   // get weight } else    m_wt = 1.0 ; /// simulate qcd multiparton evolution m_mmc->setinitparton(m_flavini , m_xini ) ; // set initial parton m_mmc->generateevent ( ) ;                  //",
    "generate mc event m_mmc->getfinparton(m_flav , m_x ) ; //",
    "get final x and parton type m_wt * = m_mmc->getwt ( ) ;           //",
    "combine mc weight ....    the parton momentum distribution of the initial parton is provided to the object m_foami of the tfoam class by the dedicated function mmcevol::density located in demo1/mmcevol.cxx file .",
    "the user can easily modify here the shape of the initial distributions .",
    "the above organization is quite flexible and allows one to introduce into the game more mc generator objects , more mc event objects , etc .",
    "in this section we describe in some detail a variety of tests that we have performed on the evolfmc v.2 code in order to verify its correctness and determine its overall technical precision . to be specific , we have performed three different sets of the technical comparisons of the code evolfmc v.2 : + ( 1 ) with the semianalytical code qcdnum16 @xcite , + ( 2 ) with the semianalytical code apcheb40 @xcite , + ( 3 ) with the previous version of the evolfmc code : evolfmc v.1 , and + ( 4 ) between different algorithms within the evolfmc v.2 .",
    "+ we will describe them in turn .",
    "the target relative precision of the tests is @xmath1 ( half of a per mille ) .    at the end of this section",
    "we also present the weight distributions for all the algorithms and we compare speed of the algorithms .    as the initial distributions at 1 gev , for all of the tests we take @xmath98 the qcd constant @xmath99 and @xmath100 . for each of the tests we use statistics of the order of @xmath101 mc points .",
    "the previous version of the code , evolfmc v.1 , has been tested against the qcdnum16 code @xcite for the standard dglap evolution .",
    "the demonstrated agreement was @xmath1 for the lo case and @xmath102 for the nlo case , see @xcite .",
    "for consistency we have repeated these comparisons for evolfmc v.2 .",
    "-8 mm    in fig .",
    "[ fig : qcdnum16 ] we show the dglap nlo evolution up to 10 gev and 100 gev for both the gluon and quark singlet @xmath103 distributions as well as the ratio of the qcdnum16 to evolfmc results .",
    "the qcdnum16 results are based on the extended grid size of @xmath104 .",
    "the agreement is of the order of @xmath105 .",
    "we will demonstrate in the next subsection that these residual discrepancies are to be attributed to qcdnum16 .",
    "one has to remember that the comparisons with qcdnum16 are limited to the standard dglap evolution only .",
    "it is the most independent test of the evolfmc code .",
    "the semianalytical method of solving the evolution equations used by apcheb40 is entirely different from the mc method and also the library of the evolution kernels is completely independent . at first , in fig.[fig : apcheb - nlo ] , we show the comparisons for the standard dglap nlo evolution ( for this comparison we used the older version , 33 , of the apcheb code ) .    -8 mm    we show the evolution up to 10 gev and 100 gev for both the gluon and quark singlet @xmath103 distributions as well as the ratio of the apcheb33 to evolfmc results . as we see",
    "the agreement is remarkable , at the level of @xmath106 , limitted by the statistics .",
    "this result clarifies the source of residual disagreement seen in the fig .",
    "[ fig : qcdnum16 ] .",
    "-8 mm    the advantage of apcheb40 over other semianalytical codes , such as qcdnum  @xcite , is that it has the option of the modified - dglap evolution built - in , although only at the lo level , see @xcite for details . for the sake of comparisons",
    "we have modified the lo kernels in apcheb40 in such a way that the coupling constant is implemented in the nlo approximation , whereas the @xmath65-dependent parts remain in the lo approximation , i.e.  the modified kernels are @xmath107 in fig .",
    "[ fig : apcheb10 ] we show the c-type evolution up to 10 gev and 100 gev for both the gluon and quark singlet @xmath103 distributions as well as the ratio of the apcheb40 to evolfmc results .",
    "the apcheb40 results are based on the interpolation with 100 chebyshev polynomials .",
    "the agreement is again excellent , in most of the @xmath4-range below @xmath106 .    to summarise ,",
    "the results of comparison with apcheb40 indicate that technical precision of evolfmc is much better than our conservative target of @xmath108 .",
    "-6 mm    -6 mm    the old evolfmc v.1 has been extensively tested both for the dglap ( up to nlo ) and modified - dglap ( lo only ) cases with the overall relative precision tag of about @xmath109 @xcite . as an example of the backward compatibility tests we show in fig .",
    "[ fig : dglap_nlo_v1 ] the comparison of evolfmc v.1 with evolfmc v.2 for the dglap - type nlo evolution and in fig .",
    "[ fig : kt_lo_v1 ] for the modified - dglap c-type lo evolution , both up to 10 and 100 gev .",
    "as we can see the results agree within the statistical errors at the level of @xmath1 , as desired .",
    "as we have explained in introduction , the version v.1 of evolfmc has different overall structure and organisation of the code as well as different implementation of most of the methods .",
    "therefore this comparison can be regarded as a comparison with an `` almost '' independent code ( for the limited number of evolution types , of course ) .",
    "-8 mm    in this section we show the tests of the most advanced evolution : of the c-type in the nlo approximation .",
    "we have not found any other code that would solve this type of evolution .",
    "for this reason we have implemented in the evolfmc code the second , auxiliary , mc algorithm that solves this particular type of evolution .",
    "the key difference of the auxilliary algorithm with respect to the main algorithm is that the entire nlo correction ( including modifications in the argument of the coupling constant ) is introduced as a weight and the algorithm itself is based on the lo algorithm described in @xcite , see @xcite for details .    as an example in fig .",
    "[ fig : kt_nlo_q10 ] we show the comparisons of results of these two nlo algorithms of the c-type for two evolution time limits : 10 gev and 100 gev .",
    "as one can see the agreement is well below the level of @xmath1 .",
    "this result we consider as the principal test of the nlo c-type evolution in the code evolfmc v.2 . of course ,",
    "the auxiliary algorithm shares with the previous ones a lot of common parts of the code .",
    "these common parts however have been extensively tested by all the comparisons described in previous subsections .",
    "we conclude this series of tests with the conservative statement that the evolfmc v.2 code has the overall technical precision of @xmath110 !      in fig .",
    "[ fig : weights ] we show the weight distributions for all three main algorithms included in the program evolfmc v.2 .",
    "the evolutions are of the nlo type up to 100 gev",
    ".    -8 mm    the weights are well behaved and fall down exponentially .",
    "the distributions of modified evolutions have shorter tails as compared to the dglap case .",
    "this is the consequence of the finite ir cut - off used in the modified kernels , as compared to the infinitesimal one used in the dglap case .",
    "the plots indicate that the conversion to the unweighted events should be quite efficient , especially in the case of moderate target precision level .",
    "one has to remember that in the current version of the program we did not perform any additional weight optimization , as we restricted ourselves to the weighted events only .",
    "such an optimization could reduce the tails of the weight distributions even further .    finally , in fig .",
    "[ fig : speed ] we compare speed of all five algorithms included in the program evolfmc v.2 both in lo and nlo cases . as we see , despite their complexity and the presence of internal one - dimensional numerical integration , the nlo algorithms are slower only by a factor of few as compared to the very fast lo ones .",
    "the slowest one is the b-type algorithm .",
    "let us note that the algorithms are only partly optimized with respect to speed .",
    "in this paper we have presented the program evolfmc v.2 .",
    "it is a monte carlo generator that solves some of the qcd evolution equations for the parton momentum distributions in the weighted event mode . in the current version",
    "we have implemented the dglap evolution in the lo and nlo approximations and two modified - dglap type evolutions .",
    "these modifications include the replacement of the argument of the coupling constant by a more complicated functions of the @xmath4 and @xmath5 variables . in one case ( c )",
    "this function reconstructs the transverse momentum of the emitted partons and in the other case ( b ) the approximate transverse momentum .",
    "both of these modified - dglap evolutions are implemented in the lo as well as the nlo approximation .",
    "the code is written in the c++ language and has the modular structure , easy to extend to additional evolution types .",
    "the main limitation of the code is the fact that quarks are treated as massless .",
    "we have studied the technical precision of the program by means of extensive comparisons with the non - mc numerical program apcheb40 , with the previous version of the code , evolfmc v.1 , and by comparing two independent algorithms for the same evolution implemented in evolfmc v.2 .",
    "these tests have proved that the technical precision of the evolfmc v.2 is at least @xmath1 . to our knowledge",
    "it is the first so - precise solution of the qcd evolution equations by means of the monte carlo methods .",
    "authors would like to thank k. golec - biernat and z. was for discussions and comments .",
    "in this appendix we list the source code of the simple demo.cxx program from the demo0 folder .                      rngen = new rndm ( ) ;    double t0 = log(qmin ) ;    dglap_lo   * dglap_ll                 = new dglap_lo (      t0,lambda , numberofflavor , rngen ) ;    dglap_nlo * dglap_nll                 = new dglap_nlo (     t0,lambda , numberofflavor , rngen ) ;    cprim_lo   * cprim_ll                 = new cprim_lo (      t0,lambda , numberofflavor , rngen ) ;    cprim_nlo * cprim_nll                  = new cprim_nlo (     t0,lambda , numberofflavor , rngen ) ;    cprim_nlo_aux * cprim_nll_aux                  = new cprim_nlo_aux(t0,lambda , numberofflavor , rngen ) ;    bprim_nlo * bprim_nlo                 = new bprim_nlo (     t0,lambda , numberofflavor , rngen ) ;    bprim_lo   * bprim_lo                  = new bprim_lo (      t0,lambda , numberofflavor , rngen ) ;    bprim_nlo_aux * bprim_nlo_aux                  = new bprim_nlo_aux(t0,lambda , numberofflavor , rngen ) ;        printf(\"*******************starting parameters*****************\\n \" ) ;      printf(\"qmin=%4.2f\\n \" , qmin ) ;      printf(\"qmax=%4.2f\\n \" , qmax ) ;      printf(\"type of equation : % d\\n \" , typeofgenerator ) ;      printf(\"qcdlambda=%2.4f\\n \" , lambda ) ;      printf(\"numberofflavors=%d\\n \" , numberofflavor ) ;      printf(\"events to generate:%d\\n \" , numberofevents ) ;    printf(\"*******************initial conditions******************\\n \" ) ;      printf(\"flavor : % d\\n \" , init_flavor ) ;      printf(\"xstart : % 1.2f\\n \" , init_xstart ) ; printf(\"*************************events************************\\n \" ) ;                    switch ( typeofgenerator )          {          case cprim_nlo :                  cprim_nll->generateevent(tc , xstart , weight , tstop , flavor ) ;                  break ;              case cprim_nlo_aux :                  cprim_nll_aux->generateevent(tc , xstart , weight , tstop , flavor ) ;                  break ;          case cprim_lo :                  cprim_ll->generateevent(tc , xstart , weight , tstop , flavor ) ;                  break ;          case dglap_lo :                  dglap_ll->generateevent(tc , xstart , weight , tstop , flavor ) ;                  break ;              case dglap_nlo :                  dglap_nll->generateevent(tc , xstart , weight , tstop , flavor ) ;                  break ;          case bprim_lo :                  bprim_lo->generateevent(tc , xstart , weight , tstop , flavor ) ;                  break ;          case bprim_nlo :                  bprim_nlo->generateevent(tc , xstart , weight , tstop , flavor ) ;                  break ;          case bprim_nlo_aux :                  bprim_nlo_aux->generateevent(tc , xstart , weight , tstop , flavor ) ;                  break ;          }          sumwt = sumwt + weight ;          sumwt2=sumwt2 + weight*weight ;          noevents = noevents+1 ;          if ( noevents<100 )          {              printf(\"x=%1.6f , weight=%1.6f , flavor=%d\\n \" , xstart , weight , flavor ) ;          }      } double integral = sumwt / noevents ; double error = sqrt ( ( sumwt2/noevents                      - ( sumwt / noevents)*(sumwt / noevents ) ) /noevents ) ;    printf(\"***********************output**************************\\n \" ) ; printf(\"\\n [ sum_f = flavor ] [ int_eps^1 dx ] d_f(x , t)= % 1.6f + - % 1.6f\\n\\n \"                                                    , integral , error ) ; printf(\"*******************************************************\\n \" ) ;        k.  golec - biernat , s.  jadach , w.  paczek , and m.  skrzypek , acta phys . polon .",
    "* b37 * , 1785 ( 2006 ) , hep - ph/0603031 .",
    "lipatov , _ sov .",
    "phys . _ * 20 * ( 1975 ) 95 ; + v.n .",
    "gribov and l.n .",
    "lipatov , _ sov .",
    "phys . _ * 15 * ( 1972 ) 438 ; + g. altarelli and g. parisi , _ nucl .",
    "_ * 126 * ( 1977 ) 298 ; + yu .",
    "l. dokshitzer , _ sov .",
    "* 46 * ( 1977 ) 64 .",
    "lipatov , _ sov .",
    "* 23 * ( 1976 ) 338 ; + e.a .",
    "kuraev , l.n .",
    "lipatov and v.s .",
    "fadin , _ sov .",
    "* 45 * ( 1977 ) 199 ; + i.i . balitsky and l.n .",
    "lipatov , _ sov .",
    "_ * 28 * ( 1978 ) 822 ; + l.n .",
    "lipatov , _ sov .",
    "* 63 * ( 1986 ) 904 .",
    "s.  weinzierl , comput .",
    ". commun . * 148 * , 314 ( 2002 ) , hep - ph/0203112 .",
    "m.  miyama and s.  kumano , comput .",
    "* 94 * , 185 ( 1996 ) , hep - ph/9508246 . m.  botje , : a fast evolution program , 1977 , zeus note 97 - 066 , http://www.nikhef.nl/~h24/qcdcode/.    a.  chuvakin and j.  smith , comput",
    "commun . * 143 * , 257 ( 2002 ) , hep - ph/0103177 . c.  coriano and c.  savkli , comput .",
    "* 118 * , 236 ( 1999 ) , hep - ph/9803336 .",
    "r.  toldra , comput .",
    "phys . commun .",
    "* 143 * , 287 ( 2002 ) , hep - ph/0108127 .",
    "k.  golec - biernat , , the fortran code available on the request from the author , unpublished .    k.  golec - biernat , s.  jadach , w.  paczek , and m.  skrzypek , acta phys . polon .",
    "* b39 * , 115 ( 2008 ) , arxiv:0708.1906 [ hep - ph ] .",
    "t.  sjostrand , s.  mrenna , and p.  skands , ( 2007 ) , arxiv:0710.3820 [ hep - ph ] .",
    "t.  sjostrand _",
    "et  al . _ ,",
    ". commun . *",
    "135 * , 238 ( 2001 ) , hep - ph/0010017 .",
    "s.  gieseke _ et  al .",
    "_ , ( 2006 ) , hep - ph/0609306 .",
    "g.  corcella _ et  al .",
    "_ , jhep * 01 * , 010 ( 2001 ) , hep - ph/0011363 . l.  lonnblad , comput .",
    ". commun . * 71 * , 15 ( 1992 ) .",
    "y.  kurihara _ et  al .",
    "_ , nucl . phys . *",
    "b654 * , 301 ( 2003 ) , hep - ph/0212216 .",
    "s.  tsuno , t.  kaneko , y.  kurihara , s.  odaka , and k.  kato , comput .",
    "* 175 * , 665 ( 2006 ) , hep - ph/0602213 . j.  c. collins , t.  c. rogers , and a.  m. stasto , phys . rev .",
    "* d77 * , 085009 ( 2008 ) , arxiv:0708.2833 [ hep - ph ] .",
    "z.  nagy and d.  e. soper , jhep * 09 * , 114 ( 2007 ) , arxiv:0706.0017 [ hep - ph ] .",
    "s.  jadach and m.  skrzypek , ( 2009 ) , arxiv:0905.1399 [ hep - ph ] .",
    "m.  slawinska and a.  kusina , ( 2009 ) , arxiv:0905.1403 [ hep - ph ] .",
    "small x collaboration , b.  andersson _",
    "et  al . _ , eur .",
    "j. * c25 * , 77 ( 2002 ) , hep - ph/0204115 .",
    "s.  jadach and m.  skrzypek , acta phys . polon .",
    "* b35 * , 745 ( 2004 ) , hep - ph/0312355 . w.  paczek , k.  golec - biernat , s.  jadach , and m.  skrzypek , acta phys . polon . *",
    "b38 * , 2357 ( 2007 ) , arxiv:0704.3344 .",
    "k.  golec - biernat , s.  jadach , w.  paczek , p.  stephens , and m.  skrzypek , acta phys .",
    "b38 * , 3149 ( 2007 ) , hep - ph/0703317 .",
    "m.  skrzypek , s.  jadach , k.  golec - biernat , and w.  paczek , acta phys . polon . * b38 * , 2369 ( 2007 ) .",
    "p.  stoklosa , w.  paczek , and m.  skrzypek , ( 2008 ) , arxiv:0810.2670 [ hep - ph ] .",
    "r.  g. roberts , eur .",
    "j. * c10 * , 697 ( 1999 ) , hep - ph/9904317 .",
    "g.  curci , w.  furmanski , and r.  petronzio , nucl . phys . *",
    "b175 * , 27 ( 1980 ) .",
    "w.  furmanski and r.  petronzio , phys . lett . *",
    "b97 * , 437 ( 1980 ) .",
    "s.  jadach , w.  paczek , m.  skrzypek , b.  f.  l. ward , and z.  was , comput .",
    "commun . * 119 * , 272 ( 1999 ) , hep - ph/9906277 .",
    "s.  jadach , w.  paczek , m.  skrzypek , b.  f.  l. ward , and z.  was , comput .",
    "commun . * 140 * , 475 ( 2001 ) , hep - ph/0104049 . s.  jadach , w.  paczek , m.  skrzypek , b.  f.  l. ward , and z.  was , comput . phys . commun . * 140 * , 432 ( 2001 ) , hep - ph/0103163 .",
    "s.  jadach , w.  paczek , and b.  f.  l. ward , phys . lett . *",
    "b390 * , 298 ( 1997 ) , also hep - ph/9608412 ; the monte carlo program bhwide is available from http://cern.ch/placzek .",
    "s.  jadach , w.  paczek , e.  richter - was , b.  f.  l. ward , and z.  was , comput .",
    ". commun . * 102 * , 229 ( 1997 ) .",
    "s.  jadach , b.  f.  l. ward , and z.  was , comput .",
    ". commun . *",
    "130 * , 260 ( 2000 ) , hep - ph/9912214 , program source available from http://home.cern.ch / jadach/."
  ],
  "abstract_text": [
    "<S> we present the program evolfmc v.2 that solves the evolution equations in qcd for the parton momentum distributions by means of the monte carlo technique based on the markovian process . </S>",
    "<S> the program solves the dglap - type evolution as well as modified - dglap ones . in both cases </S>",
    "<S> the evolution can be performed in the lo or nlo approximation . </S>",
    "<S> the quarks are treated as massless . </S>",
    "<S> the overall technical precision of the code has been established at @xmath0 . this way , for the first time ever , we demonstrate that with the monte carlo method one can solve the evolution equations with precision comparable to the other numerical methods .    </S>",
    "<S> pacs : 12.38.-t , 12.38.bx , 12.38.cy    monte carlo , evolution equations , markovian process , radiative corrections , qcd , nlo , dglap , lhc , hera , pdf    = 1    * ifjpan - iv-2008 - 7 + *    * program summary / new version program summary *    _ manuscript title : _ the markovian monte carlo program evolfmc v.2 for solving qcd evolution equations + _ authors : _ s.  jadach , w.  paczek , m.  skrzypek , p.  stokosa + _ program title : _ evolfmc v.2 + _ </S>",
    "<S> journal reference : _ </S>",
    "<S> + _ catalogue identifier : _ </S>",
    "<S> + _ licensing provisions : _ </S>",
    "<S> none + _ programming language : _ </S>",
    "<S> c++ + _ computer : _ pc , mac + _ operating system : _ linux , mac os x + _ ram : _ less than 256 mb + _ number of processors used : _ 1 + _ supplementary material : _ </S>",
    "<S> + _ keywords : _ monte carlo , evolution equations , markovian process , radiative corrections , qcd , nlo , lhc , hera , dglap , pdf + _ pacs : _ 12.38.-t , 12.38.bx , 12.38.cy + _ </S>",
    "<S> classification : _ </S>",
    "<S> + _ external routines / libraries : _ root + _ subprograms used : _ </S>",
    "<S> + _ nature of problem : _ + solution of the qcd evolution equations for the parton momentum distributions of the dglap- and modified - dglap - type in the lo and nlo approximations . </S>",
    "<S> + _ solution method : _ + monte carlo simulation of the markovian process of a multiple emission of partons . </S>",
    "<S> + _ restrictions : _ + ( 1 ) limited to the case of massless partons . </S>",
    "<S> + ( 2 ) implemented in the lo and nlo approximations only . + </S>",
    "<S> ( 3 ) weighted events only . </S>",
    "<S> + _ unusual features : _ + modified - dglap evolutions included up to the nlo level . </S>",
    "<S> + _ additional comments : _ + technical precision established at @xmath1 . </S>",
    "<S> + the evolfmc version 1 was described in @xcite , but the actual code was not published . </S>",
    "<S> + _ running time : _ + for the @xmath2 events at 100 gev : dglap nlo : 27s ; c-type modified dglap nlo : 150s ( macbook pro with mac os x v.10.5.5 , 2.4 ghz intel core 2 duo , gcc 4.2.4 , single thread ) ; </S>"
  ]
}