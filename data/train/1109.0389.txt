{
  "article_text": [
    "the _ hidden surface removal _ ( hsr ) problem is one of the fundamental problems in computer graphics . given a set of objects in a three dimensional scene we want to compute the visible parts of the scene from a given viewpoint . as a result , pieces of objects that lay behind other objects with respect to the given viewpoint are invisible . in general , points are visible when the line between each point and the viewpoint is not intersected by other objects .",
    "a slightly easier problem than hsr is the hidden line elimination ( hle ) problem . in the hle problem",
    "it is assumed that surfaces do not carry information ( like color ) and only the visible line segments that define the exterior of each object are interesting .",
    "these problems are strongly connected but experience has shown that the hsr problem is more difficult the the hle problem .",
    "in particular , hidden line information does not necessarily allow us to determine the frontmost faces of the environment @xcite .",
    "in the general case of the hsr problem the scene may consist of arbitrary objects in the three dimensional space . a simple but important special case of",
    "the general hsr problem is one in which the scene consists of @xmath0 rectangles which are parallel to the @xmath4 plane and their edges are parallel to the @xmath5 and @xmath6 axis .",
    "these rectangles are called _ iso - oriented_. an iso - oriented rectangle @xmath7 can be fully specified by five coordinates , @xmath8\\times[r.y_{1},r.y_{2}]\\times r.z$ ] .",
    "it is assumed that no pair of rectangles intersects in a two dimensional region , though pairs may intersect along an edge .    in this paper , we consider a static scene ( changes are not allowed in the scene ) comprised of @xmath0 iso - oriented rectangles in the three - dimensional space . the goal is to to compute and depict all visible parts of these rectangles as they would be seen from an observer at a specified viewpoint .",
    "we assume that this viewpoint lies at @xmath9 .",
    "most of the algorithms known for scenes of iso - oriented rectangles are _",
    "output sensitive_. this means that their time complexity depends on the size of the output , that is the complexity of the visible part of the scene .",
    "these algorithms are generally more efficient than algorithms with time complexity depending solely on @xmath0 . for static scenes consisting of polygons ,",
    "mckenna @xcite has designed a worst case optimal algorithm with @xmath10 time and space complexity .",
    "note that the complexity of the visible scene can not be larger than @xmath10 when the polygons in the scene have @xmath0 edges in total .",
    "this is because the number of visible parts can not exceed the number of intersections between the objects .    gutting et al .",
    "@xcite proposed an output sensitive hle algorithm for static scenes of rectangles with time complexity @xmath11 , where @xmath2 is the number of reported visible segments .",
    "note , that when @xmath2 is small , then the time complexity is far less than @xmath10 .",
    "of course , for complicated scenes where @xmath12 this algorithm is less efficient than the algorithm of mckenna .",
    "this algorithm also handles @xmath13-oriented rectangles ( rectangles aligned with a fixed number of orientations , not just horizontal and vertical ) .",
    "atallah and goodrich @xcite have proposed an algorithm with @xmath14 time complexity .    for a static scene consisting of iso - oriented rectangles ,",
    "bern @xcite has designed an algorithm with @xmath1 time complexity and @xmath3 space complexity .",
    "he designed algorithms for the hle problem and later he extended them to tackle the hsr problem .",
    "mehlhron et al .",
    "@xcite proposed an algorithm with @xmath15 time complexity and @xmath3 space complexity for the hle problem .",
    "kitsios et al . @xcite",
    "have improved on this result by proposing an algorithm for the hle problem that uses linear space while retaining the above time complexity .",
    "this paper extends the last result of kitsios and tsakalidis to tackle the hsr problem in a scene consisting of iso - oriented rectangles .",
    "we propose an hsr algorithm with @xmath16 time complexity using linear space .",
    "our result improves the algorithm proposed by bern @xcite by a logarithmic factor in its space complexity .",
    "our algorithm modifies the algorithm of @xcite and extends it by adding appropriate data structures to store the necessary surface information .",
    "in addition , our algorithm needs only one pass of the scene , while the algorithm of kitsios et al . needs two , one pass for the vertical edges and one for the horizontal edges ( our algorithm can also be used for the hle problem with minor modifications ) .",
    "the only drawback is that in the hle problem the multiplicative factor of @xmath2 in the time complexity is @xmath17 , which in general is less than @xmath18 .",
    "this is due to the maintenance of the visible regions and is another indication that the hsr problem is generally more difficult than the hle problem .",
    "this special case of hidden surface removal has application to overlapping windows in computer displays .",
    "it allows us to solve window management problems efficiently .",
    "in addition , the algorithms for this restricted case of the hidden surface removal problem could find use in cartographic applications as well as used in vlsi design tools for many - layer technologies .",
    "the remainder of the paper is organized as follows . in section  [ sec : prel ] a description of the algorithm is given as well as some basic definitions and techniques , which are essential for the comprehension of the algorithm .",
    "the algorithm for the hsr problem is described in section  [ sec : alg ] .",
    "the description is divided into two parts , the first part describes the preprocessing stage while the second part describes the reporting stage . finally , in section",
    "[ sec : con ] we conclude with some final remarks .",
    "the hsr problem is considered in a static scene consisting of @xmath0 iso - oriented rectangles .",
    "our algorithm uses the plane sweep technique and cuts the scene into slabs in order to guarantee linear space .",
    "initially , the scene is divided into _",
    "slabs_. a plane parallel to the @xmath19 plane sweeps each slab along the @xmath5 axis from @xmath20 to @xmath21 .",
    "all edges of rectangles parallel to the @xmath5 axis are called _ horizontal _ while all parallel to the @xmath6 axis are called _",
    "vertical_. in this way , the intersection of the sweep plane and the scene in a random position is a set of vertical segments .",
    "assuming , without loss of generality , that all the @xmath5 , @xmath6 and @xmath22 coordinates are distinct then the intersection of the sweep plane and the scene in each sweep station consists of one and only one vertical edge .",
    "the sweep stations of the algorithm consist of the ordered set of the @xmath5 coordinates of the rectangles .",
    "the set of the vertical edges of each slab is stored in a segment tree .",
    "a segment tree  @xcite is constructed from scratch at the beginning of each slab .",
    "this tree has @xmath23 leaves and it is implemented as a binary balanced tree .",
    "its @xmath24-th leaf represents the elementary interval @xmath25 $ ] ( if we sort the @xmath6 coordinates then @xmath26 will be just before @xmath27 ) , which is termed a @xmath6-range .",
    "each internal node @xmath28 has a @xmath6-range equal to the union of the @xmath6-ranges of the leaves of the subtree rooted at @xmath28 .",
    "henceforth , the ends of a vertical segment @xmath29 will be represented as @xmath30 and @xmath31 , where @xmath32 . in this way",
    ", the @xmath6-range of @xmath28 is between @xmath33 and @xmath34 .",
    "let @xmath35 , @xmath36 and @xmath37 denote the father and the two children of @xmath28 respectively .",
    "a vertical segment is associated with @xmath18 nodes @xmath28 such that @xmath38 $ ] and @xmath39 $ ] .",
    "each node @xmath28 of the segment tree has a set @xmath40 of associated segments . by precomputing the lists of rectangles in each node of the segment tree",
    "we are able to reduce the time complexity by a logarithmic factor @xcite .",
    "the horizontal segments are stored in a binary search tree , called the _",
    "region tree_. the region tree is maintained during the transition between slabs . in this way ,",
    "information concerning the visible regions is transferred among slabs .",
    "the leaves of the region tree are linked by means of a double linked list .",
    "we implement the region tree as a red - black tree @xcite , so that the amortized cost of updates is constant .",
    "finally , the coordinates of a rectangle @xmath41\\times[y_{1},y_{2}]\\times z$ ] are denoted by @xmath42 , @xmath43 , @xmath44 , @xmath45 and @xmath46 respectively .",
    "the line segment defined by the endpoints @xmath47 and @xmath48 is referred as the left edge of the rectangle @xmath7 .",
    "the right , bottom and top edges are defined similarly .",
    "we say that a rectangle @xmath7 is higher than a rectangle @xmath49 , or that @xmath49 is lower than @xmath7 , when @xmath50 .",
    "the same goes for the edges .",
    "finally , we assume that there is a fictitious rectangle @xmath51 that lies behind the whole scene with height @xmath52 .",
    "the algorithm consists of two stages , the preprocessing stage and the reporting stage . in the former stage",
    "the necessary data structures are constructed and initialized appropriately . in the latter stage ,",
    "we use the available data structures to find all visible surfaces by using the plane sweep technique . in the following",
    ", we will first refer to the preprocessing stage and then move to the reporting stage .",
    "first of all , the vertices of the rectangles are sorted with respect to their @xmath5 , @xmath6 and @xmath22 coordinates .",
    "the @xmath6-order will be used for the construction of the segment tree .",
    "the @xmath5-order will be used for the plane sweep while the @xmath22-order will be used in depth computations .",
    "then , we cut the scene into slabs .",
    "each slab is defined by two planes normal to the @xmath5 axis , so that each plane contains @xmath53 vertical edges .",
    "since there are exactly @xmath54 vertical edges , the number of slabs will be @xmath55 .",
    "the set of vertical edges in one slab is called @xmath56 while the set of horizontal segments that span the slab is denoted by @xmath57 .",
    "note that @xmath58 by definition , while @xmath59 ( an example is depicted in figure  [ fig : example1 ] ) .",
    "and the clipped rectangles that form sets @xmath56 and @xmath57 . ]    in the beginning of each slab we build an enriched segment tree .",
    "in particular , let @xmath60 denote the highest segment of @xmath56 associated with node @xmath28 of the segment tree . if there is no such segment then @xmath61 .",
    "every node of the segment tree is augmented with the field @xmath62 , which contains the highest segment of @xmath57 that spans @xmath63 .",
    "note that @xmath62 remains invariable during the sweep in each slab .",
    "each node @xmath28 of the segment tree is also augmented with the following fields :    * @xmath64 , if @xmath28 is a leaf * @xmath65 and + @xmath66 , if @xmath28 is an internal node .",
    "let @xmath40 be the set consisting of segments in the subtree rooted at @xmath28 and segments of @xmath57 associated with the ancestors of @xmath28 .",
    "field @xmath67 is the lowest visible segment in the subscene restricted to @xmath63 consisting of segments of @xmath40 .",
    "field @xmath68 is analogously the highest segment among the segments of @xmath40 .",
    "assume a segment @xmath69 in the subtree of @xmath28 such that @xmath69 is visible in the subscene restricted to @xmath63 and it is lower than @xmath67 .",
    "assume that @xmath69 is associated with node @xmath70 .",
    "then , the minimum between @xmath71 and @xmath72 will be @xmath69 ( by assumption ) . if @xmath73 then @xmath69 is not visible since it is completely obscured by @xmath74 which contradicts our assumption . as a result",
    ", @xmath75 will be @xmath69 . applying the same procedure to all ancestors of @xmath70",
    ", we will reach @xmath28 and @xmath67 will be @xmath69 , which is a contradiction . as a result , @xmath67 is the lowest visible segment in @xmath40 . in the same way we can prove that @xmath68 is the highest segment among the segments of @xmath40 .",
    "the sweep plane traverses the slab from left to right .",
    "when a vertical edge @xmath29 of a rectangle @xmath76 is encountered , then the data structures must be appropriately updated and queried to report the visible regions located at the @xmath77 defined by this vertical edge . as a result , fields @xmath68 and @xmath67 are subject to changes .",
    "these changes are reflected to the nodes of the segment tree by removing or adding segments to their subtrees .",
    "let @xmath78 be the number of insertions / deletions in the subtree rooted at a node @xmath28 and let @xmath79 be the sequence of values of field @xmath68 after each such update operation .",
    "we precompute this sequence and store it in an array @xmath80 of @xmath81 entries . in a similar manner , we precompute the sequence @xmath82 for field @xmath67 . for both arrays we use a pointer @xmath83 that points to the current value of @xmath68 and @xmath67 in arrays @xmath80 and @xmath82 respectively .",
    "an insertion or deletion of a segment in the subtree rooted at @xmath28 is simulated by incrementing the pointer @xmath83 .",
    "the construction of @xmath80 and @xmath82 for each node @xmath28 is based on the auxiliary sequences @xmath84 , @xmath85 and @xmath86 .",
    "assume that @xmath87 is the ordered sequence of @xmath5 coordinates of segments of @xmath56 that are inserted or deleted to @xmath28 .",
    "assume that when @xmath88 a segment is inserted or deleted to @xmath40 possibly changing @xmath60 ( the highest segment of @xmath56 associated to node @xmath28 ) .",
    "the sequence @xmath84 has @xmath81 entries that record all changes of @xmath60 .",
    "specifically , @xmath89=s$ ] if @xmath90 for @xmath91 ( @xmath92 corresponds to the @xmath5 coordinate of the left vertical plane which defines the current slab , @xmath93 is defined analogously for the right plane ) .",
    "the sequence @xmath87 is stored in the array @xmath85 .",
    "similarly , let @xmath94 be the sequence of the @xmath5 coordinates of segments of @xmath56 that are inserted into or deleted from nodes in the subtree rooted at @xmath28 .",
    "after each insertion or deletion of such a segment the @xmath95 and @xmath96 fields of @xmath28 may change .",
    "this sequence is stored in @xmath86 .",
    "the construction of all these sequences is feasible in linear time .",
    "this is proved by using the following lemma :    we are given a set of @xmath97 horizontal line segments in the @xmath98 plane with integer @xmath99 coordinates in the range @xmath100 $ ] .",
    "the segments are given in decreasing @xmath22 order . in @xmath101 time it is possible to construct an array @xmath102 of @xmath103 entries that stores in its @xmath24-th entry the segment with highest @xmath22 coordinate among segments that span the @xmath99-interval @xmath104 $ ] .",
    "the proof is given in @xcite .",
    "sequences @xmath84 and @xmath85 for each node @xmath28 of the segment tree can be constructed in linear time .",
    "sequences @xmath62 for each leaf @xmath28 of the segment tree can be constructed in linear time .    the proof is given in @xcite .    [ lem : con - seg ] the sequences @xmath105 , @xmath106 and @xmath86 for all nodes can be computed in @xmath107 time .    the proof for this lemma is given in @xcite .",
    "we must add that during the construction of the segment tree the filling of the @xmath62 fields for all inner nodes @xmath28 can be accomplished by setting : @xmath108    apart from the segment tree we use an auxiliary leaf - oriented balanced binary search tree , which we call the _",
    "region tree_. the region tree @xmath109 is used to store the horizontal segments of the scene , ordered according to the @xmath6 coordinate , as well as the necessary information to report visible regions .",
    "a horizontal segment is stored in a leaf of @xmath109 only when it is intersected by the sweep plane and it is visible .",
    "the leaves of this tree form a double linked list .",
    "the region tree is dynamic red - black tree @xcite and remains the same during the transition between slabs .    in the region tree ,",
    "the visible horizontal segments ( edges of rectangles ) are inserted or deleted during the transition of the sweep plane between the sweep stations .",
    "apart from the edges , the leaves of the tree store the rectangle in which the area between two consecutive visible horizontal segments belongs to .",
    "assume that @xmath110 is a leaf of @xmath109 , @xmath111 is the leaf immediately right to @xmath110 and @xmath112 is the rectangle which owns the region between the horizontal segment stored in @xmath110 and @xmath111",
    ". if the area between two consecutive segments is not part of a rectangle , then @xmath113 .",
    "the traversal of the double linked list enables us to report visible regions .",
    "these regions are defined by the @xmath6 coordinates of two consecutive horizontal edges and the @xmath5 coordinates of the start of the region and the current position of the sweep plane .",
    "the @xmath5 coordinate of the start of the region is a field attached to @xmath112 and contains the @xmath5 coordinate of the sweep station where the field @xmath112 was updated for the last time . in the following , we will analyze the reporting procedure and specify how the region tree is updated .      at this point",
    "we will focus on a single slab .",
    "the necessary initialization for each slab is described in [ sub : preprocessing ] .",
    "the description of the reporting stage is split into two parts . in the first part",
    "we explore the case where the sweep plane intersects the left edge of a rectangle while in the second part we explore the case where the sweep plane intersects the right edge of a rectangle .",
    "first , we are going to explore what happens when a new edge in virtually ( due to the preprocessing ) inserted in the segment tree - that is the sweep plane intersects a left edge .",
    "the procedure @xmath114 is invoked when the left edge of a rectangle @xmath7 is encountered .",
    "this procedure updates the fields @xmath68 and @xmath67 for all nodes @xmath28 visited in the segment tree .",
    "assume that the position of the sweep plane is at @xmath115 . in figures  [ fig",
    ": left ] and [ fig : left1 ] a description of the algorithm for the insertion of the left edge of an arbitrary rectangle @xmath7 is given .",
    "= = = = = = * procedure * leftedge(rectangle @xmath7 , boolean @xmath116 , segment_tree_node @xmath28 ) + 1 .",
    "* if * @xmath117 * then * @xmath118 + 2 . *",
    "if * @xmath119 and @xmath120 * then * + 3 . *",
    "if * visible * then * leftreportregions(@xmath7,@xmath28 ) + 4 .",
    "* else * + 5 . *",
    "if * @xmath121 * then * leftedge(@xmath7,@xmath116,@xmath36 ) + 6 .",
    "* if * @xmath122 * then * leftedge(@xmath7,@xmath116,@xmath37 ) + 7 .",
    "@xmath123    = = = = = = * procedure * leftreportregions(rectangle @xmath7 , segment_tree_node @xmath28 ) + 1 . *",
    "if * @xmath117 * then return * + 2 . * if * @xmath124 * then * + 3 . find leaves @xmath125 and @xmath97 in @xmath109 so that @xmath126 and there is no other leaf @xmath127 such that @xmath128 + and act analogously for @xmath34 + 4 .",
    "output regions formed by the horizontal segments found between @xmath129 and @xmath130 + 5 .",
    "remove all horizontal segments found between @xmath129 and @xmath130 + 6 .",
    "* if * @xmath131 * then * insert in @xmath109 the segment @xmath29 with @xmath132 and @xmath133 + 7 . *",
    "if * @xmath134 * then * insert in @xmath109 the segment @xmath29 with @xmath132 and @xmath135 + 8 .",
    "update properly the fields region of @xmath125 , @xmath97 and the newly inserted leaves and then change the @xmath5 + field of each such field to be current @xmath5 + 9 . * else *",
    "leftreportregions(@xmath7,@xmath36 ) + 11 .",
    "leftreportregions(@xmath7,@xmath37 )    assume that the left edge of @xmath7 is divided into consecutive invisible and visible segments .",
    "let the visible segments be @xmath136 and the invisible segments @xmath137 , where @xmath138 and @xmath139 are nodes of the segment tree .",
    "the procedure given in figure  [ fig : left ] stops the recursive search when one of these nodes is reached .",
    "when a node @xmath138 is reached , the region tree @xmath109 is queried with the range @xmath140 .",
    "the result of this query are two leaves @xmath141 and @xmath142 .",
    "note that it may be the case that @xmath141 and @xmath142 are the same leaves . by using the double linked list , all leaves between @xmath141 and @xmath142",
    "are traversed to report the visible regions .",
    "after reporting all visible regions that are obscured by the new rectangle , we remove all leaves between @xmath141 and @xmath142 .",
    "finally , we make the necessary adjustments to reflect the fact that this region belongs to the new rectangle .    in particular ,",
    "if @xmath141 and @xmath142 are different leaves then we remove all leaves between them since the new rectangle @xmath7 will obscure the rectangles they represent . then",
    ", if the @xmath6-coordinates of the upper and lower edges of @xmath7 do not belong in @xmath140 , we just update the field region between @xmath141 and @xmath142 so that it belongs to @xmath7 . in any other case",
    "we must create a new leaf for either the upper or the lower edge or both updating appropriately the region fields .",
    "if @xmath141 and @xmath142 are the same leaf , then either we have to insert the upper or the lower edge of @xmath7 or there is a node @xmath143 such that @xmath140 and @xmath144 are adjacent and the same cases apply .",
    "the following lemma is essential in the construction of the region tree .",
    "[ lem : region ] a visible region in the region tree is defined by the @xmath5 coordinate of its insertion , the @xmath5 coordinate of the sweep plane and the @xmath6 coordinates of two edges of rectangles .",
    "this is trivially true for the @xmath5 coordinates .",
    "we have to show that each visible region is defined between two horizontal edges .",
    "this is true since each rectangle is characterized by only one @xmath22 coordinate . as a result",
    ", rectangles will always intersect among their edges .     before and after the insertion of a horizontal segment @xmath145 .",
    "the circles designate the owner of the region between the edges ( field @xmath146 ) . ]",
    "we give an example of how the region tree is handled .",
    "we assume that uppercase letters designate rectangles .",
    "indexes @xmath28 and @xmath147 in uppercase letters designate the upper and lower edge of the specified rectangle respectively . in figure",
    "[ fig : dlistleft ] , a part of the double linked list of the leaves of the region tree @xmath109 is depicted .",
    "initially , the sweep plane is at position @xmath148 and the list of the leaves of @xmath109 is shown in figure  [ fig : dlistleft](a ) .",
    "the next sweep station of the sweep plane is at @xmath115 . in this position ,",
    "the sweep plane intersects the left edge of the rectangle @xmath149 .",
    "assume that the range @xmath150 $ ] is between the leaves of @xmath109 with labels @xmath151 and @xmath152 as depicted in figure  [ fig : dlistleft](a ) .",
    "finally , assume that @xmath153 and that @xmath154 and @xmath155 .",
    "therefore , only the lower edge of @xmath149 will be inserted in @xmath109 yielding the list depicted in figure  [ fig : dlistleft](b ) .",
    "the visible regions reported are :    1 .",
    "the region of @xmath102 defined by @xmath156 and @xmath157 ( @xmath158 is the @xmath5 coordinate of the start of the region ) .",
    "2 .   the region of @xmath159 defined by @xmath160 and @xmath161 .    finally , the regions reported are removed from the region tree @xmath109 resulting in the list of figure  [ fig : dlistleft](c ) .",
    "note that the algorithm given in figures [ fig : left ] and [ fig : left1 ] would identify all nodes of the segment tree such that the union of their @xmath6-ranges would be equal to @xmath162 $ ] .",
    "then , the region tree would be updated for each such node .",
    "the crucial observation in the analysis of procedure @xmath163 is that procedure @xmath164 stops its recursive search whenever it reaches one of the @xmath138 or @xmath139 nodes ( figure  [ fig : leftex](a ) ) . as a result ,",
    "even a visible segment of the left edge hidden behind a complicated part of the scene costs only @xmath18 to discover .",
    "procedure @xmath164 explores a forest of subtrees of the segment tree .",
    "the roots of these subtrees are nodes that list @xmath7 ( @xmath7 is associated with these nodes ) , the nodes @xmath165 are leaves of these subtrees and the remaining leaves are nodes @xmath166 ( the proof of this argument can be found in @xcite ) . for each of the @xmath138 nodes we search the tree @xmath109 in @xmath18 time locating",
    "leaves @xmath125 and @xmath97 ( the search keys are the @xmath6 coordinates of the endpoints of the @xmath140 ) .",
    "when we find the leaves we may insert at most two new horizontal segments ( @xmath167 amortized time ) , then report all the regions which are defined between @xmath125 and @xmath97 in the double linked list and finally remove all the reported regions while updating the new region .",
    "the deletion of these regions ( leaves ) also incurs an @xmath167 amortized time cost per leaf . as a result , the cost for each node @xmath138 is @xmath168 , where @xmath169 is the number of reported regions .",
    "[ lem : left ] the procedure @xmath163 requires @xmath170 time to report @xmath2 visible regions for a scene of @xmath0 rectangles taking only into account the left edges .",
    "assume that the visible segments of the left edge of a rectangle @xmath171 are @xmath172 and the invisible segments are @xmath137 , where @xmath138 and @xmath139 are nodes of the segment tree .",
    "the discovery of the @xmath138 nodes is achieved in @xmath18 time . for every node @xmath138 , @xmath18 time",
    "is required to search the region tree .",
    "the cost of a single edge will be @xmath173 , where @xmath174 is the number of reported regions .",
    "this means that the cost for each visible segment in the segment tree is @xmath18 while the cost for each reported region is amortized @xmath167 . since the number of reported regions is at least equal to the number of reported segments we assume that the cost for each region is @xmath18 .",
    "thus , for all rectangles the time complexity will be :    @xmath175 where @xmath176 is the number of visible regions .",
    "s left edge divided into visible ( @xmath138 ) and invisible ( @xmath139 ) pieces , ( b ) @xmath7 s right edge and revealed rectangles beneath @xmath177 . ]",
    "the procedure @xmath178 is invoked when the right edge of a rectangle @xmath7 is encountered .",
    "this procedure is depicted in figures  [ fig : right ] and [ fig : right1 ] .",
    "= = = = = = * procedure * rightedge(rectangle @xmath7 , boolean @xmath116 , rectangle @xmath49 , segment_tree_node @xmath28 ) + 1 . * if * @xmath117 * then * @xmath118 + 2 . * if * ( ( @xmath179 ) and ( @xmath180 ) ) * then * + 3 . * if * @xmath181.z)$ ] * then * @xmath182 $ ] + 4 . * if * @xmath183 * then * @xmath184 + 5 .",
    "* if * visible * then * rightreportregions(@xmath7,@xmath116,@xmath49,@xmath28 ) + 6 .",
    "* else * + 7 . * if * @xmath181.z)$ ] * then * @xmath182 $ ] + 8 . * if * @xmath183 * then * @xmath184 + 9 . *",
    "if * @xmath121 * then * rightedge(@xmath7,@xmath116,@xmath49,@xmath36 ) + 10 .",
    "* if * @xmath122 * then * rightedge(@xmath7,@xmath116,@xmath49,@xmath37 ) + 11 .",
    "@xmath123    = = = = = = * procedure * rightreportregions(rectangle @xmath7 , boolean @xmath185 , rectagle @xmath49 , segment_tree_node @xmath28 ) + 1 . *",
    "if * @xmath117 * then return * + 2 . *",
    "if * ( @xmath124 and @xmath185 ) * then * + 3 . find leaves @xmath125 and @xmath97 in @xmath109 so that @xmath126 and there is no other leaf @xmath127 such that @xmath128 + and act analogously for @xmath34 + 4 .",
    "output region defined by @xmath129 , @xmath130 , @xmath5 coordinate of the sweep plane and @xmath5 coordinate of the field + showing the start of the region + 5 .",
    "output regions defined by @xmath125 and @xmath97 and the leaves next to them in the list + 6 . *",
    "if * @xmath186 * then * delete @xmath125 + 7 . *",
    "if * @xmath187 * then * delete @xmath97 + 8 .",
    "update properly the fields region of the adjacent leaves and the respective @xmath5 fields + 9 . * if * @xmath181.z)$ ] * then * @xmath182 $ ] + 10 . *",
    "if * @xmath188 * then * @xmath184 + 11 .",
    "* if * @xmath189 * then * + 12 . *",
    "if * @xmath190 * then * insert in @xmath109 the segment @xmath29 with @xmath191 current @xmath5 and @xmath192 + 13 .",
    "* if * @xmath193 * then * insert in @xmath109 the segment @xmath29 with @xmath191 current @xmath5 and @xmath194 + 14 .",
    "find leaves @xmath125 and @xmath97 of @xmath109 such that @xmath195 and update field @xmath196 and the @xmath5 field + 15 .",
    "* else * + 16 .",
    "rightreportregions(@xmath7,@xmath185,@xmath49,@xmath36 ) + 17 .",
    "rightreportregions(@xmath7,@xmath185,@xmath49,@xmath37 )    it is not hard to verify that the procedure @xmath197 updates appropriately the pointer @xmath83 while maintaining the visible segments ( by using the flag @xmath116 ) . in figure",
    "[ fig : leftex](b ) the case handled by procedure @xmath198 is depicted .",
    "as before , we assume that the right edge of @xmath7 is divided into consecutive invisible and visible segments .",
    "assume that the visible segments are @xmath136 and the invisible segments are @xmath137 , where @xmath138 and @xmath139 are nodes of the segment tree . in addition , the visible pieces of rectangles along and below the right edge of @xmath7 are divided into basic segments @xmath199 .",
    "the procedure @xmath198 is analogous to @xmath164 except that it continues exploring below nodes @xmath138 to discover the new visible pieces .",
    "this procedure maintains rectangle @xmath49 to be the second highest rectangle after @xmath7 listed on the path from the root to the current node @xmath28 .",
    "each node @xmath200 is a descendant of a visible node @xmath138 , such that @xmath201 is lower than the highest rectangle along the path from the root to @xmath200 .",
    "therefore , we are in position to appropriately update @xmath109 with information we have obtained concerning the revealed rectangle @xmath49 ( note that @xmath49 may as well be @xmath51 ) . thus , procedure @xmath198 explores a forest of trees of the segment tree .",
    "the roots of these subtrees are nodes that list @xmath7 , each @xmath138 is contained in a subtree , the nodes @xmath202 are leaves of these subtrees and the remaining leaves are @xmath166 ( the proof can be found in @xcite ) .",
    "the deletion of an edge affects the region tree in a similar way as the insertion of a vertical edge .",
    "first of all , the horizontal segments of the rectangle @xmath7 are removed from @xmath109 ( if they were stored ) and all the @xmath146 fields that belong to @xmath7 obtain the value @xmath203 ( reporting at the same time the respective regions ) . then , the subtree rooted at a node @xmath138 with leaves @xmath200 is traversed in an inorder fashion .",
    "many basic segments @xmath204 may belong to the same revealed rectangle @xmath49 . instead of accessing the tree @xmath109 for each of the nodes",
    "@xmath200 we save and combine the queries into one query .",
    "because of the inorder tree walk , all the basic segments belonging to a single region of a revealed rectangle will be accessed sequentially .",
    "thus , we have to access @xmath109 only once for each region of a revealed rectangle @xmath49 .",
    "this happens when we access a basic segment @xmath204 which belongs to a region of a different revealed rectangle .",
    ", ( c ) the list after the insertion of the segments of the revealed rectangles . ]    in figure  [ fig : dlistright ] an example of manipulation of @xmath109 is given when a right edge is encountered .",
    "assume that the sweep plane is at position @xmath205 and has reached the right edge of the rectangle @xmath149 . in a nutshell , the horizontal segment @xmath145 is removed from @xmath109 resulting in the list depicted in figure [ fig : dlistright](b ) .",
    "note that @xmath206 is not visible and thus not present in the tree .",
    "when this segment is removed , the following regions are reported :    1 .",
    "the region of @xmath149 defined by @xmath207 and @xmath208 .",
    "2 .   the region of @xmath102 defined by @xmath209 and @xmath210 .    after the deletion , the @xmath5 coordinate of the start of the region @xmath102 obtains the value @xmath205 .",
    "assume that @xmath211 and @xmath159 are the revealed rectangles and that only their lower horizontal edges are visible .",
    "we insert first @xmath159 and then @xmath211 and finally the resulting list is depicted in figure  [ fig : dlistright](c ) .    [ lem : right ]",
    "procedure @xmath197 requires @xmath170 time to report @xmath2 visible regions for a scene of @xmath0 rectangles taking only into account the right edges .",
    "assume that the visible segments of the right edge of a rectangle @xmath171 are @xmath172 and the invisible segments @xmath137 , where @xmath138 and @xmath139 are nodes of the segment tree .",
    "the discovery of each @xmath138 node requires @xmath18 time . in addition , for each such node we update the region tree in @xmath18 time in order to report the respective visible region . in this way ,",
    "the total time to report the visible regions for the right edge is @xmath212 . as a result ,",
    "the time complexity for all rectangles will be @xmath213 , which is bounded by @xmath170 .",
    "we must also consider the cost for computing and inserting in the region tree all revealed rectangles .",
    "assume that a visible segment @xmath214 is divided into basic segments @xmath199 .",
    "each of these basic segments cost @xmath18 time to be inserted in @xmath109 .",
    "however , this cost does not change the time complexity of the algorithm since each basic segment and the region it represents , will be reported later ( in another sweep station ) by either @xmath163 or @xmath197 . in the case of @xmath163 the visible region",
    "which is represented by a basic segment will be reported by accessing @xmath109 .",
    "thus , the @xmath18 time overhead for each basic segment is assigned to the cost of reporting it .",
    "the same goes for the right edge .",
    "the following theorem summarizes the result .",
    "the hidden surface removal problem for a set of @xmath0 iso - oriented rectangles can be solved in @xmath16 time and linear space , where @xmath2 is the number of reported regions .",
    "the time complexity of the algorithm is : + _ total time @xmath215 prepr .",
    "@xmath216 ( precomp . of segm .",
    "tree)@xmath217(#slabs ) @xmath216 ( reporting time ) _ + to sort the @xmath5 , @xmath6 and @xmath22 coordinates , @xmath218 time is required ( preprocessing ) . in each slab",
    "@xmath107 time is necessary ( lemma  [ lem : con - seg ] ) to construct the segment tree and the arrays for each node . as a result",
    ", @xmath218 time is needed in total because the scene is divided into @xmath18 slabs . from lemma  [ lem : left ] and lemma  [ lem : right ] we deduce that the reporting time is @xmath170 , where @xmath2 is the number of visible regions reported . from this discussion",
    "it is clear that the total time of the algorithm is @xmath16 .",
    "the space complexity of the algorithm is : + _ total space @xmath215 ( space for segment tree ) @xmath216 ( space for region tree ) _",
    "+ the sequences @xmath85 , @xmath84 and @xmath86 can be constructed ( lemma  [ lem : con - seg ] ) in linear time and so the space can not be more . the skeleton of the segment tree requires linear space ( since we store @xmath219 segments , each of which is associated with @xmath18 nodes ) . as a result ,",
    "the total space needed by the segment tree is linear . for the region tree ,",
    "the crucial observation is that at any position the sweep plane will intersect at most @xmath54 horizontal segments . as a result ,",
    "at most @xmath23 regions can be visible in any sweep station of the sweep plane .",
    "consequently , the region tree @xmath109 has at most @xmath23 leaves and so it requires linear space .",
    "therefore , the total space is @xmath107 .",
    "in this paper we designed an algorithm for hidden surface removal of iso - oriented rectangles in a static scene .",
    "our algorithm uses linear space and reports all visible regions in @xmath1 time , where @xmath0 is the number of rectangles present in the scene and @xmath2 is the number of reported regions .",
    "the open problem is to design an @xmath220 algorithm that uses linear space for this problem",
    ". it would be also nice if these techniques could be transferred to more general scenes consisting of arbitrary rectangles or even polygons ."
  ],
  "abstract_text": [
    "<S> we investigate the problem of finding the visible pieces of a scene of objects from a specified viewpoint . in particular , we are interested in the design of an efficient hidden surface removal algorithm for a scene comprised of iso - oriented rectangles . </S>",
    "<S> we propose an algorithm where given a set of @xmath0 iso - oriented rectangles we report all visible surfaces in @xmath1 time and linear space , where @xmath2 is the number of surfaces reported . </S>",
    "<S> the previous best result by bern , has the same time complexity but uses @xmath3 space .    * </S>",
    "<S> computational geometry , computer graphics , hidden surface removal , iso - oriented rectangles . * </S>"
  ]
}