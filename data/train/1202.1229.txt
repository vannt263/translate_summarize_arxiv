{
  "article_text": [
    "if a player , say , bob , receives a message @xmath6 that claims to come from alice , he might wish to know if this is true , or if the message was generated or modified by some adversary .",
    "this task is called _ authentication _ , and in their seminal work  @xcite , wegman and carter showed that it can be achieved with informationtheoretic security by appending a tag @xmath7 to the message ( often called a message authentication code or mac ) , where @xmath8 , @xmath9 is a family of almost strongly universal@xmath1 ( asu@xmath1 ) hash functions hashing was only formally defined later by stinson  @xcite .",
    "a family of functions is said to be asu@xmath1 if any two different messages are almost uniformly mapped to all pairs of tags .",
    "an exact definition is given in on .",
    "] , and @xmath10 is a secret key shared by alice and bob .",
    "there exist asu@xmath1 families @xmath11 that require @xmath12 bits of shared secret key  @xcite , where @xmath13 is the message alphabet and @xmath14 the tag alphabet .",
    "wegman and carter  @xcite propose a scheme to use even less bits of key when multiple messages are to be authenticated : each tag should be encrypted with a fresh one - time pad ( otp ) , but the same hash function can be used each time .",
    "alice thus appends the tag @xmath15 to her message @xmath16 , where @xmath17 is used for all messages and @xmath18 is a fresh key used only in this round .",
    "asymptotically this scheme consumes only @xmath19 bits of key per round .    to prove the security of this scheme , wegman and carter",
    "show that given any amount of messagetag pairs @xmath20 the secret key @xmath17 is still perfectly uniform .",
    "they then argue that the probability of an adversary successfully falsifying any new message is the same in every round , and guaranteed to be small by the properties of the asu@xmath1 hash functions .",
    "however , proving that a protocol is secure in a standalone model does not necessarily guarantee that it is still secure when combined with other protocols , not even when combined with itself like wegman and carter s scheme .",
    "a lot of research has gone into composability of cryptographic tasks in recent years . a general framework for proving composable security",
    "was developed by canetti  @xcite , and dubbed _ universally composable ( uc ) security_. independently , backes , pfitzmann and waidner  @xcite introduced the equivalent notion of _ reactive simulatability_. these security notions have been extended to the quantum setting by ben - or and mayers  @xcite and unruh  @xcite .",
    "an essential application of informationtheoretic authentication is in quantum key distribution ( qkd ) protocols .",
    "every ( classical ) message exchanged between the two parties generating the key needs to be authenticated with informationtheoretic security in order to guarantee the overall unconditional security of the protocol .",
    "recycling the hash function is a practical way to save a large part of the secret key consumed in each round . and",
    "as wegman and carter s security proof does not fit in any composable security framework , it raises the question of whether this qkd application is still secure .",
    "many works , e.g. ,  @xcite , reuse wegman and carter s authentication scheme with key recycling , and they all sketch the security using the same noncomposable argument as wegman and carter . composable security for key recycling in authentication has been studied in the case of quantum messages by hayden , leung and mayers  @xcite , but to the best of our knowledge has not been treated when the messages are classical .",
    "computationally secure variants of wegman and carter s scheme have been proposed  @xcite , but not analysed in a composable framework either .",
    "some works @xcite have pointed out that informationtheoretic authentication might not be composable with qkd .",
    "they attempt to study this problem by analyzing the security of authentication when the secret keys used are not perfect .",
    "in particular , abidin and larsson  @xcite suggest that when qkd and authentication with key recycling are combined recursively , and the ( imperfect ) secret key resulting from qkd is fed back into the next round of authentication and qkd , the total error could increase exponentially in the number of rounds .",
    "ben - or et al .",
    "@xcite and mller - quade and renner  @xcite provide a detailed treatment of the composability of qkd .",
    "in particular , the latter show that if the authentication and qkd schemes are proven to be composable , and if a short initial key is available , a continuous key stream can be generated with arbitrarily small error .",
    "we therefore study wegman and carter s authentication scheme with key recycling  @xcite using the uc framework from @xcite . even though we ultimately wish to show that this protocol is composable in a quantum world , it is sufficient to consider classical uc security , since unruh s lifting theorem  @xcite proves that classical uc security of a classical scheme implies quantum uc security .",
    "we show that the recycled hash function is gradually leaked to the adversary , even when the key used for the otp is perfect .",
    "this leakage is however very small : we prove that this scheme is indeed @xmath0-uc - secure if the hash functions used are @xmath0-asu@xmath1 .",
    "since for any good asu@xmath1 hash function construction @xmath0 decreases exponentially fast in the size of the family , @xmath21 , it can easily be made arbitrarily small . as a consequence , the doubts of @xcite are unfounded for all ranges of the parameter @xmath0 .",
    "in fact , the hash functions used are slightly weaker than asu@xmath1 hashing , namely almost xor universal@xmath1 ( axu@xmath1 ) hash functions . if the bitwise xor of the hash of any two different messages is almost uniform over the choice of hash function .",
    "see on for an exact definition .",
    "] we show that the recycled key is close to perfectly uniform and independent from all other random variables produced throughout the protocol .",
    "this means that the recycled key can be reused for any task , not only for subsequent rounds of authentication .",
    "an immediate implication of this and the composition theorem  @xcite is that if this authentication scheme is used @xmath2 times in each round of an @xmath5-uc - secure qkd protocol , which is run @xmath3 times , recycling the same hash function throughout , the final key has distance at most @xmath4 from uniform .      in",
    "we introduce the elements from the uc framework that we need in this work .",
    "we briefly define the security notion and state the universal composition theorem . in",
    "we model the uc security for standard authentication without recycling . in we",
    "then model authentication with key recycling , and prove that using @xmath0-axu@xmath1 hash functions and a otp results in a scheme which is @xmath0-uc - secure . in we take a closer look at the secret key which is leaked to the environment , and show that an optimal attack over @xmath2 rounds of authentication which takes advantage of this key leakage produces an error of size exactly @xmath22 . and finally in we illustrate the composition theorem by applying it to the case of many rounds of authentication with key recycling and qkd .    in we give a proof of security of standard authentication , as defined in . and in we provide some more details on impersonation attacks .",
    "the uc framework is a very general method allowing arbitrary multipartite cryptographic protocols to be represented and analyzed . here",
    "we focus only on the elements needed for our analysis of information - theoretic authentication , e.g. , we do not need to model corruption or consider the running time of the adversary or environment .",
    "in particular , it is sufficient to consider classical uc security , even though we need the scheme to be secure in a quantum world and composable with qkd .",
    "this is due to unruh s lifting theorem  ( * ? ? ?",
    "* theorem 15 ) , which shows that any classical protocol which is classically uc - secure is also quantum uc - secure . for a complete treatment of uc security",
    "we refer to @xcite and @xcite for the classical and quantum settings respectively .",
    "the essence of uc security is to compare the real situation  involving players following the given protocol and an active adversary  to some ideal process .",
    "if the two can not be distinguished by the environment  in particular , if the adversary can not achieve something which is impossible within the ideal process  then one can be substituted for the other in any setting .",
    "for example , if a key distribution protocol is indistinguishable from the ideal setting in which the parties receive a perfect key from a trusted source , then any encryption protocol that is secure with a perfect key is also secure when this key distribution protocol is used instead , i.e. , the two protocols can be composed .",
    "this gives rise to the universal composition theorem : any two protocols which are uc secure can be concurrently composed and remain secure .",
    "more precisely , for every task considered we need to define some ideal functionality @xmath23 , which takes all the inputs from the parties and performs the desired task in an ideal way .",
    "for example , in the case of authentication analyzed in , it is always possible for an adversary to cut or jumble the line , making sure the original message is not received .",
    "the ideal functionality can thus at best guarantee that the receiver gets either the original message or an error .",
    "it receives a message @xmath6 from the sender and either a ` block ` or a ` let through ` command from the adversary , and then delivers @xmath6 to the receiver or produces an error message depending on the adversary s choice .",
    "the environment @xmath24 is allowed to choose the inputs given to every party , receives all outputs and can communicate freely throughout the protocol with the adversary @xmath25 .",
    "since the communication between the adversary and the ideal functionality @xmath23 is different from when he interacts with the real players , he could immediately alert the environment @xmath24 of this . in the ideal process",
    "we therefore replace @xmath25 by a simulator @xmath26 , which can be seen as a buffer between the environment and the ideal functionality .",
    "@xmath26 often internally simulates @xmath25 , from which it gets its name .",
    "a protocol @xmath27 @xmath0-uc - realizes the ideal functionality @xmath23 , or , more succinctly , is @xmath0-uc - secure , if for all adversaries @xmath25 there exists a simulator @xmath26 for which no environment @xmath24 can distinguish with probability more than @xmath0 if it is interacting with @xmath25 and players running @xmath27 or @xmath26 and players using the ideal functionality @xmath23 .",
    "we illustrate this for the case of authentication in .",
    "the above definition can be simplified  @xcite : it is sufficient to consider a dummy adversary that forwards all messages to the environment and lets it decide what responses to send .",
    "security against all other adversaries holds if it holds for the dummy adversary . in the next sections we therefore restrict our proofs to the dummy adversary .",
    "the main composability theorem can now be stated :    [ thm : uc ] let @xmath27 and @xmath28 be two protocols such that @xmath28 @xmath29-uc - realizes @xmath23 and @xmath30 @xmath31-uc - realizes @xmath32 when using @xmath23 as a subroutine .",
    "then @xmath33 @xmath34-uc - realizes @xmath32 when using @xmath28 as a subroutine .",
    "informationtheoretic authentication is usually considered in a setting where two players @xmath35 and @xmath36 share a secret key @xmath37 and are connected by a channel under the control of an adversary .",
    "they wish to guarantee that a message received by @xmath36 claiming to come from player @xmath35 was neither generated nor altered by the adversary .",
    "these two types of attacks are often called _ impersonation _ and _",
    "substitution_.    for any protocol which authenticates a message by appending a tag , i.e. , sends @xmath38 when the message is @xmath6 , security against impersonation attacks follows from security against substitution attacks .",
    "since this is the only kind of protocol that we are concerned with , we only consider security against substitution attacks in the body of this paper , and refer to for the proof of this reduction .    in",
    "we define uc security for authentication , and in we describe a secure authentication protocol , the proof of which is given in in .",
    "( alice ) at ( 0,0 ) @xmath35 ; ( bob ) at ( 3,0 ) @xmath36 ; ( eve ) at ( 1.5,-1 ) @xmath25 ; ( ik ) at ( 1.5,1 ) key ; ( env ) at ( 1.5,-2 ) @xmath24 ;    ( -1.5,1.5 )  + + ( .25,0 )  + + ( 0,-3.25 )  + + ( 5.5,0 )",
    " + + ( 0,3.25 )  + +",
    "( .25,0 )  + + ( 0,-3.75 )  + + ( -6,0 )  cycle ;    ( even1 ) ; ( even2 ) ; ( eves1 ) ; ( eves2 ) ; ( envw ) at ( -1.25,0 |- alice.west ) ; ( enve ) at ( 4.25,0 |- bob.east ) ; ( envn1 ) at ( eves1 |- 0,-1.75 ) ; ( envn2 ) at ( eves2 |- 0,-1.75 ) ;    ( ik.west ) to node[arrowlabel , swap ] @xmath10 ( alice.north ) ; ( ik.east ) to node[arrowlabel ] @xmath10 ( bob.north ) ; ( alice ) -| node[arrowlabel , pos=.25 ] @xmath39 ( even1.center ) ; ( even2.center )    ( envn1.center ) ; ( envn2.center ) to ( eves2.center ) ; ( envw.center ) to node[arrowlabel ] @xmath6 ( alice ) ; ( bob ) to node[arrowlabel ] @xmath40 ( enve.center ) ;    ( alice ) at ( 0,0 ) @xmath35 ; ( bob ) at ( 3,0 ) @xmath36 ; ( eve ) at ( 1.5,-1 ) @xmath26 ; ( ia ) at ( 1.5,1 ) @xmath23 ; ( env ) at ( 1.5,-2 ) @xmath24 ;    ( -1.5,1.5 )  + + ( .25,0 )  + + ( 0,-3.25 )  + + ( 5.5,0 )  + + ( 0,3.25 )  + + ( .25,0 )  + + ( 0,-3.75 )  + + ( -6,0 )  cycle ;    ( even1 ) ; ( even2 ) ; ( eves1 ) ; ( eves2 ) ; ( envw ) at ( -1.25,0 |- alice.west ) ; ( enve ) at ( 4.25,0 |- bob.east ) ; ( envn1 ) at ( eves1 |- 0,-1.75 ) ; ( envn2 ) at ( eves2 |- 0,-1.75 ) ; ( ias1 ) at ( eves1 |- ia.south ) ; ( ias2 ) at ( eves2 |- ia.south ) ;    ( alice ) to node[arrowlabel , xshift=.1 cm ] @xmath6 ( ia ) ; ( ia ) to node[arrowlabel , xshift=-.2 cm ] @xmath41 ( bob ) ; ( ias1.center ) to node[arrowlabel , swap ] @xmath6 ( even1.center ) ; ( even2.center ) to node[arrowlabel , swap , pos=.3 ] ok,@xmath42 ( ias2.center ) ; ( eves1.center ) to ( envn1.center ) ; ( envn2.center ) to ( eves2.center ) ; ( envw.center ) to node[arrowlabel ] @xmath6 ( alice ) ; ( bob ) to node[arrowlabel ] @xmath41 ( enve.center ) ;    to send a message @xmath6 , @xmath35 uses the key @xmath10 to generate a new message @xmath39 containing some redundancy , e.g. , @xmath43 where @xmath44 is a family of hash functions . upon receiving @xmath45",
    ", @xmath36 checks whether it is valid given the key @xmath10 , and if so , outputs the corresponding has to be injective to guarantee the uniqueness of @xmath46 . ]",
    "@xmath46 . in the previous example with @xmath47 , @xmath36 checks that @xmath48 and accepts @xmath46 if this is the case or produces an error @xmath42 otherwise .",
    "this protocol is depicted on the left in .",
    "since the channel is completely under the control of the adversary , he can always cut it or completely jumble the message .",
    "hence in the ideal case it is not possible to guarantee that the original message is received , only that @xmath36 is not tricked into accepting a falsified message .",
    "the ideal functionality @xmath23 for authentication can be seen as a perfect channel with a switch controlled by the adversary : he can either switch it on and let the message through , or switch it off and let it produce an error .",
    "this is depicted on the right in .",
    "an authentication scheme is then @xmath0-uc - secure if the environment @xmath24 can not distinguish between these two situations . to get a more concrete security criterion",
    ", we need to define the simulator s actions in the case of the dummy adversary @xmath25 , who simply forwards @xmath39 to @xmath24 and forwards the response @xmath45 to @xmath36 .",
    "after receiving the message @xmath6 from the ideal functionality @xmath23 , the simulator @xmath26 must send some @xmath39 to @xmath24 .",
    "to do so , it picks a key @xmath37 uniformly at random and runs the same protocol as @xmath35 to generate @xmath39 .",
    "when it gets @xmath45 from @xmath24 , it checks whether @xmath49 and sends either ` ok ` or @xmath42 to @xmath23 .",
    "note that this simulator always accepts if the message was not modified , i.e. , the ideal case has perfect robustness .",
    "let @xmath50 be the random variable describing the initial message @xmath51 , @xmath52 the corresponding encoding generated by @xmath35 in the real case and @xmath26 in the ideal case , and @xmath53 the response from @xmath24 .",
    "let @xmath54 and @xmath55 be random variables over the alphabet @xmath56 describing the outputs of @xmath36 in the real and ideal cases respectively . in the real case @xmath24",
    "has access to the joint random variable @xmath57 and in the ideal case it sees @xmath58 .",
    "an authentication scheme is then @xmath0-uc - secure if for any @xmath50 and @xmath53 chosen by @xmath24 , the statistical distance between the real and ideal cases satisfies @xmath59    note that after rearranging the lhs of , we obtain the standard security criterion for authentication @xcite , see also .      to satisfy",
    "it is sufficient to use a family of strongly universal@xmath1 hash functions @xmath44 and define @xmath60 with the key @xmath10 distributed uniformly over @xmath61 .",
    "then , as described above , @xmath36 checks that @xmath48 for the @xmath47 he receives , and accepts @xmath46 if this is the case or produces an error @xmath42 otherwise .",
    "[ def : universalhash ] a family of hash functions @xmath62 is said to be @xmath0-almost strongly universal@xmath1 ( @xmath0-asu@xmath1 ) if for @xmath10 chosen uniformly at random and all @xmath63 with @xmath64 and all @xmath65 , @xmath66 \\leq      \\frac{\\eps}{|\\ct|}.\\ ] ]    [ rem : stdauth ] if we replace the authenticated message @xmath39 by its form @xmath67 in , we recover the security condition used by wegman and carter  @xcite and stinson  @xcite .",
    "it is therefore immediate that previous work on informationtheoretic authentication ( without key recycling ) is composable .",
    "however , since we use a simplification of the more common @xmath0-asu@xmath1 hashing definition , we can not directly apply stinson s proof  @xcite here .",
    "we therefore provide a new proof in that standard authentication with @xmath0-asu@xmath1 hashing results in an @xmath0-uc - secure scheme .",
    "if we wish to authenticate many messages and we use the protocol from , a new hash function and therefore a ( completely ) new key must be used in every round .",
    "this is however not necessary : as we show in , part of the key used to choose the hash function is @xmath0-close to uniform from the point of view of the environment , and can therefore be recycled for further use . before proving this , we first model this new protocol and its ideal functionality in .    like for standard authentication analyzed in",
    ", we consider only substitution attacks here , in which the adversary modifies a valid message and tag . for impersonation attacks we refer to .",
    "( alice ) at ( 0,0 ) @xmath35 ; ( bob ) at ( 3,0 ) @xmath36 ; ( eve ) at ( 1.5,-1 ) @xmath25 ; ( ik1 ) at ( .87,1 ) key@xmath68 ; ( ik2 ) at ( 2.13,1 ) key@xmath1 ; ( env ) at ( 1.5,-2 ) @xmath24 ;    ( -1.5,1.5 )  + + ( .25,0 )  + + ( 0,-3.25 )  + + ( 5.5,0 )  + + ( 0,3.25 )  + + ( .25,0 )  + + ( 0,-3.75 ) ",
    "+ + ( -6,0 )  cycle ;    ( alicew1 ) ; ( alicew2 ) ; ( alicee1 ) ; ( alicee2 ) ; ( bobe1 ) ; ( bobe2 ) ; ( bobw1 ) ; ( bobw2 ) ; ( even1 ) ; ( even2 ) ; ( eves1 ) ; ( eves2 ) ; ( envw1 ) at ( -1.25,0 |- alicew1 ) ; ( envw2 ) at ( -1.25,0 |- alicew2 ) ; ( enve1 ) at ( 4.25,0 |- bobe1 ) ; ( enve2 ) at ( 4.25,0 |- bobe2 ) ; ( envn1 ) at ( eves1 |- 0,-1.75 ) ; ( envn2 ) at ( eves2 |- 0,-1.75 ) ;    ( ik1.west ) to node[arrowlabel , swap , xshift=.1cm , yshift=-.1 cm ] @xmath17 ( alice.north ) ; ( ik2 ) to node[arrowlabel , xshift=-.14cm , yshift=.14cm , pos=.6 ] @xmath69 ( alicee1.center ) ; ( ik1 ) to node[arrowlabel , swap , xshift=.14cm , yshift=.14cm , pos=.6 ] @xmath17 ( bobw1.center ) ; ( ik2.east ) to node[arrowlabel , xshift=-.1cm , yshift=-.1 cm ] @xmath69 ( bob.north ) ; ( alicee2.center ) -| node[arrowlabel , pos=.25,swap ] @xmath39 ( even1.center ) ; ( even2.center ) |- node[arrowlabel , pos=.75,swap , yshift=.12 cm ] @xmath45 ( bobw2.center ) ; ( eves1.center ) to ( envn1.center ) ; ( envn2.center ) to ( eves2.center ) ; ( envw1.center ) to node[arrowlabel ] @xmath6 ( alicew1.center ) ; ( alicew2.center ) to node[arrowlabel ] @xmath17 ( envw2.center ) ; ( bobe1.center ) to node[arrowlabel ] @xmath40 ( enve1.center ) ; ( bobe2.center ) to node[arrowlabel , swap ] @xmath17 ( enve2.center ) ;    ( alice ) at ( 0,0 ) @xmath35 ; ( bob ) at ( 3,0 ) @xmath36 ; ( eve ) at ( 1.5,-1 ) @xmath26 ; ( ia ) at ( 1.5,1 ) @xmath23 ; ( env ) at ( 1.5,-2 ) @xmath24 ;    ( -1.5,1.5 )  + + ( .25,0 )  + + ( 0,-3.25 )  + + ( 5.5,0 )  + + ( 0,3.25 ) ",
    "+ + ( .25,0 )  + + ( 0,-3.75 )",
    " + + ( -6,0 )  cycle ;    ( alicew1 ) ; ( alicew2 ) ; ( alicen ) ; ( alicee1 ) ; ( bobe1 ) ; ( bobe2 ) ; ( bobn ) ; ( bobw1 ) ; ( even1 ) ; ( even2 ) ; ( eves1 ) ; ( eves2 ) ; ( envw1 ) at ( -1.25,0 |- alicew1 ) ; ( envw2 ) at ( -1.25,0 |- alicew2 ) ; ( enve1 ) at ( 4.25,0 |- bobe1 ) ; ( enve2 ) at ( 4.25,0 |- bobe2 ) ; ( envn1 ) at ( eves1 |- 0,-1.75 ) ; ( envn2 ) at ( eves2 |- 0,-1.75 ) ; ( ias1 ) at ( eves1 |- ia.south ) ; ( ias2 ) at ( eves2 |- ia.south ) ;    ( alicen.center ) to node[arrowlabel , xshift=.1cm , yshift=-.1 cm ] @xmath6 ( ia.west ) ; ( ia.east ) to node[arrowlabel , xshift=-.2cm , yshift=-.1 cm ] @xmath41 ( bobn.center ) ; ( ia ) to node[arrowlabel , xshift=-.13cm , yshift=.13cm , pos=.6 ] @xmath17 ( alicee1.center ) ; ( ia ) to node[arrowlabel , swap , xshift=.2cm , yshift=.2cm , pos=.6 ] @xmath17 ( bobw1.center ) ; ( ias1.center ) to node[arrowlabel , swap , pos=.7,xshift=.07 cm ] @xmath6 ( even1.center ) ; ( even2.center ) to node[arrowlabel , swap , pos=.3,xshift=-.07 cm ] ok,@xmath42 ( ias2.center ) ; ( eves1.center ) to ( envn1.center ) ; ( envn2.center ) to ( eves2.center ) ; ( envw1.center ) to node[arrowlabel ] @xmath6 ( alicew1.center ) ; ( alicew2.center ) to node[arrowlabel ] @xmath17 ( envw2.center ) ; ( bobe1.center ) to node[arrowlabel ] @xmath41 ( enve1.center ) ; ( bobe2.center ) to node[arrowlabel , swap ] @xmath17 ( enve2.center ) ;    to model the key recycling , we must view this recycled key as an extra output of the protocol .",
    "an authentication scheme with key recycling can be seen as a combination of a key distribution protocol  which only has one output , a secret key  and an authentication scheme  which only has one output , a message . for simplicity",
    "we also split the ideal secret key shared by the two players in two parts , @xmath70 , one which is recycled , @xmath17 , and one which is consumed , @xmath69 .",
    "the rest of the model is the same as for standard authentication described in : @xmath35 uses the shared key @xmath71 to generate a new message @xmath39 containing some redundancy , @xmath36 checks that @xmath45 is a valid message given @xmath71 and accepts the corresponding @xmath46 if that is the case .",
    "this is depicted on the left in .    in the ideal case",
    ", the ideal functionality @xmath23 generates a new secret key @xmath17 , which is therefore perfectly uniform and independent from the environment .",
    "the rest is identical to standard authentication .",
    "the ideal functionality also sends either the original message @xmath6 or an error @xmath42 to @xmath36 depending on the decision of the simulator @xmath26 .",
    "the simulator @xmath26 for the dummy adversary generates its own local keys @xmath17 and @xmath69 and runs the same protocol as @xmath35 to generate @xmath39 . upon receiving @xmath45 from the environment it checks whether @xmath72 and sends either @xmath73 or @xmath42 to @xmath23",
    "too , the simulator always accepts if the message was not modified , i.e. , the ideal case has perfect robustness .",
    "this is depicted on the right in .",
    "let @xmath50 be the random variable describing the initial message @xmath51 , @xmath52 the corresponding encoding generated by @xmath35 in the real case and @xmath26 in the ideal case , and @xmath53 the response from @xmath24 .",
    "let @xmath54 and @xmath55 be random variables over the alphabet @xmath56 describing the outputs of @xmath36 in the real and ideal cases respectively . and finally let @xmath74 and @xmath75 be the random variables for the distribution of @xmath17 in the real and ideal cases respectively .",
    "thus , in the real case @xmath24 has access to the joint random variable @xmath76 and in the ideal case it sees @xmath77 .",
    "an authentication scheme is then @xmath0-uc - secure if for any @xmath50 and @xmath53 chosen by @xmath24 , the statistical distance between the real and ideal cases satisfies @xmath78      the protocols we wish to analyze in this setting encode a message @xmath6 as @xmath79 , where @xmath80 is a family of hash functions that map the message to some bit string @xmath81 , @xmath82 and @xmath83 is the bitwise xor .",
    "then , as described above , @xmath36 checks that @xmath84 for the @xmath47 he receives , and accepts @xmath46 if this is the case or produces an error @xmath42 otherwise .",
    "these hash functions do not need to be @xmath0-asu@xmath1 , it is sufficient for @xmath85 to have this property .",
    "the property needed for @xmath86 has been dubbed _ @xmath0-almost xor universal@xmath1 _ by rogaway  @xcite , _",
    "@xmath0-otp secure _ by krawczyk  @xcite , and _",
    "@xmath87 universal _ by stinson  @xcite . instead of only bit strings . ]",
    "[ def : xorhash ] a family of hash functions @xmath62 for @xmath88 is said to be @xmath0-almost xor universal@xmath1 ( @xmath0-axu@xmath1 ) if for @xmath10 chosen uniformly at random and all @xmath63 with @xmath89 and all @xmath90 , @xmath91 \\leq \\eps.\\ ] ]    it is immediate from this definition that the hash function @xmath92 is @xmath0-asu@xmath1 , i.e. , for all @xmath63 with @xmath89 and all @xmath93 , @xmath94 \\leq \\frac{\\eps}{|\\ct|}.\\ ] ] since xoring a uniform string @xmath69 to any value yields a uniform string we also have @xmath95 = \\pr \\left [ g_{k_1,k_2}(x_1 ) = t_1      \\middle| \\tilde{k } = k_1\\right ] = \\frac{1}{|\\ct|},\\ ] ] where @xmath74 is the random variable for the recycled part of the key .",
    "combining the two equations above gives @xmath96    \\leq \\eps.\\ ] ]    we now have all the ingredients needed to prove the security .",
    "let @xmath27 be an authentication scheme that encodes a message @xmath6 as @xmath79 and recycles @xmath17 , where @xmath97 is a family of @xmath0-almost xor universal@xmath1 hash functions , and @xmath71 are chosen uniformly at random from @xmath98 .",
    "then @xmath27 is @xmath0-uc - secure .",
    "we need to show that is satisfied for any distributions @xmath99 and @xmath100 .",
    "first , for @xmath38 , if the environment chooses @xmath101 , then the real and ideal protocols both either accept @xmath6 if @xmath102 or reject it if @xmath103 .",
    "this means that @xmath104 hence @xmath54 and @xmath55 are completely determined by @xmath105 and can be dropped .",
    "the lhs of thus reduces to @xmath106 furthermore , from we know that @xmath74 is independent from @xmath107 , and therefore also from @xmath105 , hence @xmath108 .",
    "we can thus assume w.l.o.g .",
    "that the adversary chooses @xmath109 .    for @xmath47 and @xmath109 ,",
    "the random variable @xmath54 can take two values , @xmath42 if cheating was detected or @xmath46 if the players were fooled .",
    "@xmath55 however always produces an error @xmath42 .",
    "separating the summation in the lhs of over these two values gives @xmath110    we show in the following that @xmath111 for all values of @xmath112 .",
    "this implies that sums up to twice the value of the second term , which can be bounded in the following way : @xmath113 where to reach the last line we used @xmath114\\ ] ] and .",
    "finally , we show that holds .",
    "the lhs can be decomposed as @xmath115 because @xmath116 are chosen by the environment when holding @xmath117 , they do not influence the distribution of @xmath74 given @xmath107 , so @xmath118 and as argued above in the case where @xmath119 , from we know that @xmath74 is independent from @xmath107 , so @xmath120 .",
    "combining this with @xmath121 and proves .",
    "an immediate application of the uc security of authentication with key recycling is to reuse the same hash function to authenticate multiple messages , only renewing the part of the key xored to the tag .",
    "the universal composition theorem ( ) says that if we do this @xmath2 times and each individual protocol is @xmath0-uc - secure , then the composed protocol has error at most @xmath22 .    in this section",
    "we show that this composition theorem is tight for all protocols with @xmath122 , where @xmath14 is the alphabet for the tag , i.e. , there exists an attack such that after @xmath2 rounds the adversary has probability at least @xmath22 of having successfully forged a message , for any @xmath123 .",
    "let us define @xmath124 to be a sequence of random variables taking the value @xmath125 if the adversary successfully falsifies a message in any of the first @xmath2 rounds , and @xmath126 otherwise .",
    "then a quick calculation shows us that for any @xmath127 , @xmath128 this means that in every successive round , the adversary s probability of successfully forging a message increases .",
    "this happens because  as we show in here below  some information about the hash function is leaked in every round , even if the key used for the otp is perfectly uniform .",
    "the entropy of the hash function gradually decreases , until the adversary has enough information to successfully falsify a new message with probability @xmath125 .",
    "this result contrasts strongly with the noncomposable analysis found in  @xcite .",
    "there , the adversary simply collects the pairs of messages and tags @xmath129 , and attempts to falsify a message in each round , independently from the attempts in previous rounds . in this case , due to the hiding property of the otp",
    ", the distribution of the hash function always remains perfectly uniform given these messagetag pairs .",
    "[ thm : lowerbound ] let @xmath27 be an authentication scheme that encodes a message @xmath6 as @xmath130 and recycles @xmath17 , where @xmath131 is a family of @xmath132-almost xor universal@xmath1 hash functions . for any @xmath133",
    ", let this protocol be used @xmath2 times with the same key @xmath134 initially chosen uniformly at random , and a new uniformly random @xmath135 in each round .",
    "then , there exists an attack that allows the adversary to successfully falsify one of the first @xmath2 messages with probability at least @xmath136 .",
    "furthermore , after @xmath2 rounds , the entropy of the recycled key @xmath137 is bounded by @xmath138 where @xmath139 consists of all the inputs and outputs of the protocol ( except for @xmath137 ) and the communication with the dummy adversary from these @xmath2 rounds .    since the environment can choose the distribution of the messages to be authenticated in the @xmath2 rounds , we take them to always be the same message @xmath6 .",
    "the environment also always substitutes the same message @xmath109 for @xmath6 in each round . to be successful , it needs to guess correctly the value @xmath140 , since @xmath141 , where @xmath7 is the tag that comes with @xmath6 and @xmath142 is the correct tag for @xmath46 .",
    "the environment therefore makes a list of the @xmath143 possible values for @xmath144 , and in each round eliminates one from its list .    in the first round the environment",
    "is given @xmath145 by the dummy adversary .",
    "it picks a @xmath146 from its list and sends @xmath147 back to the dummy adversary .",
    "the legitimate player accepts the message received from the adversary only if @xmath148 , which happens with probability @xmath149 .",
    "if the environment is unsuccessful at falsifying the message , it can cross @xmath146 off its list . in the second round it then receives @xmath150 , picks a new @xmath151 , and sends @xmath152 .",
    "this time its success probability is @xmath153 , since it only has @xmath154 elements @xmath144 left on its list .    if we repeat this for each round , the success probability in the round given that the previous @xmath155 were unsuccessful is @xmath156 .",
    "we now prove by induction that the probability of successfully falsifying at least one message with this strategy is exactly @xmath136 .",
    "let @xmath157 be a random variable taking the value @xmath125 if the adversary successfully falsifies a message in any of the first @xmath2 rounds , and @xmath126 otherwise .",
    "we have @xmath158 . and if @xmath159 , then @xmath160    let @xmath161 represent any value of @xmath139 in which the adversary fails to falsify any message , and @xmath162 be the case where he does trick the players . if he is successful , he immediately learns the correct value @xmath144 , and thus @xmath163 if the adversary is not successful , he has still managed to cross @xmath2 values for @xmath144 off his list , so @xmath164    combining the two equations above with the corresponding probabilities , we get @xmath165",
    "2.8    ( ideal11 ) at ( 0,-0 * ) ideal ; ( ideal12 ) at ( 2.8,-0 * ) ideal ; ( ideal13 ) at ( 5.6,-0 * ) ideal ; ( env1 ) at ( 7.4,1 - 0 * ) @xmath24 ; ( tip11 ) at ( -1.2,-1.6 - 0 * ) ; ( tip12 ) at ( 7.8,1.4 - 0 * ) ;    ( 7,1.4 - 0 * )  + + ( .8,0 )  + + ( 0,-3 )  + + ( -9,0 )  + + ( 0,.4 )  + + ( 8.2,0 )  cycle ;    ( first ) [ fit=(tip11)(tip12 ) ] ;    ( ideal21 ) at ( 0,-1 * ) ideal ; ( ideal22 ) at ( 2.8,-1 * ) ideal ; ( real23 ) at ( 5.6,-1 * ) real ; ( env21 ) at ( 7.4 - 0*,1 - 1 * ) @xmath24 ; ( env22 ) at ( 7.4 - 1*,1 - 1 * ) @xmath166 ; ( tip21 ) at ( -1.2,-1.6 - 1 * ) ; ( tip22 ) at ( 7.8,1.4 - 1 * ) ;    ( 7,1.4 - 1 * )  + + ( .8,0 )  + + ( 0,-3 )  + + ( -9,0 ) ",
    "+ + ( 0,.4 )  + + ( 8.2,0 )  cycle ; ( 7 - 1*,-1.2 - 1 * )  + + ( 0,2.6 ) ",
    "+ + ( ,0 ) ;    ( second ) [ fit=(tip21)(tip22 ) ] ;    ( ideal31 ) at ( 0,-2 * ) ideal ; ( real32 ) at ( 2.8,-2 * ) real ; ( real33 ) at ( 5.6,-2 * ) real ; ( env31 ) at ( 7.4,1 - 2 * ) @xmath24 ; ( env32 ) at ( 7.4 - 1*,1 - 2 * ) @xmath166 ; ( env33 ) at ( 7.4 - 2*,1 - 2 * ) @xmath167 ; ( tip31 ) at ( -1.2,-1.6 - 2 * ) ; ( tip32 ) at ( 7.8,1.4 - 2 * ) ;    ( 7,1.4 - 2 * ) ",
    "+ + ( .8,0 )  + + ( 0,-3 )  + + ( -9,0 )  + + ( 0,.4 )  + + ( 8.2,0 )  cycle ; ( 7 - 1*,-1.2 - 2 * )  + + ( 0,2.6 )  + + ( ,0 ) ; ( 7 - 2*,-1.2 - 2 * )  + + ( 0,2.6 ) ",
    "+ + ( ,0 ) ;    ( third ) [ fit=(tip31)(tip32 ) ] ;    ( real41 ) at ( 0,-3 * ) real ; ( real42 ) at ( 2.8,-3 * ) real ; ( real43 ) at ( 5.6,-3 * ) real ; ( env41 ) at ( 7.4,1 - 3 * ) @xmath24 ; ( env42 ) at ( 7.4 - 1*,1 - 3 * ) @xmath166 ; ( env43 ) at ( 7.4 - 2*,1 - 3 * ) @xmath167 ; ( tip41 ) at ( -1.2,-1.6 - 3 * ) ; ( tip42 ) at ( 7.8,1.4 - 3 * ) ;    ( 7,1.4 - 3 * )  + + ( .8,0 )  + + ( 0,-3 )  + + ( -9,0 )  + + ( 0,.4 )  + + ( 8.2,0 )  cycle ; ( 7 - 1*,-1.2 - 3 * )  + + ( 0,2.6 )  + + ( ,0 ) ; ( 7 - 2*,-1.2 - 3 * )  + + ( 0,2.6 ) ",
    "+ + ( ,0 ) ;    ( fourth ) [ fit=(tip41)(tip42 ) ] ;    ( first ) to node[arrowlabel ] @xmath0 ( second ) ; ( second ) to node[arrowlabel ] @xmath0 ( third ) ; ( third ) to node[arrowlabel ] @xmath0 ( fourth ) ;    ( key223 ) key@xmath1 ; ( key232 ) key@xmath1 ; ( key233 ) key@xmath1 ; ( key241 ) keys ; ( key242 ) key@xmath1 ; ( key243 ) key@xmath1 ; ( key223 ) to ( real23 ) ; ( key232 ) to ( real32 ) ; ( key233 ) to ( real33 ) ; ( key241 ) to ( real41 ) ; ( key242 ) to ( real42 ) ; ( key243 ) to ( real43 ) ;    ( enve13 ) at ( 7 - 0*,0 |- ideal11 ) ; ( enve12 ) at ( 7 - 1*,0 |- ideal11 ) ; ( enve11 ) at ( 7 - 2*,0 |- ideal11 ) ; ( ideal13 ) to node[arrowlabel ] @xmath17 ( enve13.center ) ; ( ideal12 ) to node[arrowlabel ] @xmath168 ( enve12.center ) ; ( ideal11 ) to node[arrowlabel ] @xmath169 ( enve11.center ) ;    ( enve23 ) at ( 7 - 0*,-1*|- ideal21 ) ; ( enve21 ) at ( 7 - 2*,-1*|- ideal21 ) ; ( real23 ) to node[arrowlabel ] @xmath17 ( enve23.center ) ; ( ideal22 ) to node[arrowlabel , pos=.25 ] @xmath17 ( real23 ) ; ( ideal21 ) to node[arrowlabel ] @xmath168 ( enve21.center ) ;    ( enve33 ) at ( 7 - 0*,-2*|- ideal31 ) ; ( real33 ) to node[arrowlabel ] @xmath17 ( enve33.center ) ; ( real32 ) to node[arrowlabel , pos=.25 ] @xmath17 ( real33 ) ; ( ideal31 ) to node[arrowlabel , pos=.25 ] @xmath17 ( real32 ) ;    ( enve43 ) at ( 7 - 0*,-3*|- real41 ) ; ( real43 ) to node[arrowlabel ] @xmath17 ( enve43.center ) ; ( real42 ) to node[arrowlabel , pos=.25 ] @xmath17 ( real43 ) ; ( real41 ) to node[arrowlabel , pos=.25 ] @xmath17 ( real42 ) ;    ( id111 ) ; ( id114 ) ; ( envn111 ) at ( id111 |- 0,-1.2 - 0 * ) ; ( envn114 ) at ( id114 |- 0,-1.2 - 0 * ) ; ( envn111.center ) to ( id111.center ) ; ( id114.center ) to ( envn114.center ) ;    ( id121 ) ; ( id124 ) ; ( envn121 ) at ( id121 |- 0,-1.2 - 0 * ) ; ( envn124 ) at ( id124 |- 0,-1.2 - 0 * ) ; ( envn121.center ) to ( id121.center ) ; ( id124.center ) to ( envn124.center ) ;    ( id131 ) ; ( id134 ) ; ( envn131 ) at ( id131 |- 0,-1.2 - 0 * ) ; ( envn134 ) at ( id134 |- 0,-1.2 - 0 * ) ; ( envn131.center ) to ( id131.center ) ; ( id134.center ) to ( envn134.center ) ;    ( id211 ) ; ( id214 ) ; ( envn211 ) at ( id211 |- 0,-1.2 - 1 * ) ; ( envn214 ) at ( id214 |- 0,-1.2 - 1 * ) ; ( envn211.center ) to ( id211.center ) ; ( id214.center ) to ( envn214.center ) ;    ( id221 ) ; ( id224 ) ; ( envn221 ) at ( id221 |- 0,-1.2 - 1 * ) ; ( envn224 ) at ( id224 |- 0,-1.2 - 1 * ) ; ( envn221.center ) to ( id221.center ) ; ( id224.center ) to ( envn224.center ) ;    ( r231 ) ; ( r234 ) ; ( envn231 ) at ( r231 |- 0,-1.2 - 1 * ) ; ( envn234 ) at ( r234    ( envn234.center ) ;    ( id311 ) ; ( id314 ) ; ( envn311 ) at ( id311 |- 0,-1.2 - 2 * ) ; ( envn314 ) at ( id314 |- 0,-1.2 - 2 * ) ; ( envn311.center ) to ( id311.center ) ; ( id314.center ) to ( envn314.center ) ;    ( r321 ) ; ( r324 ) ; ( envn321 ) at ( r321 |- 0,-1.2 - 2 * ) ; ( envn324 ) at ( r324    ( envn324.center ) ;    ( r331 ) ; ( r334 ) ; ( envn331 ) at ( r331 |- 0,-1.2 - 2 * ) ; ( envn334 ) at ( r334    ( envn334.center ) ;    ( r411 ) ; ( r414 ) ; ( envn411 ) at ( r411 |- 0,-1.2 - 3 * ) ; ( envn414 ) at ( r414    ( envn414.center ) ;    ( r421 ) ; ( r424 ) ; ( envn421 ) at ( r421 |- 0,-1.2 - 3 * ) ; ( envn424 ) at ( r424    ( envn424.center ) ;    ( r431 ) ; ( r434 ) ; ( envn431 ) at ( r431 |- 0,-1.2 - 3 * ) ; ( envn434 ) at ( r434    ( envn434.center ) ;    as illustration of the universal composition theorem ( ) we sketch the security proof for a composition of quantum key distribution ( qkd ) and authentication with key recycling .",
    "the two players must share an initial key which is long enough to select the hash function and encrypt the tags for every message exchanged during the first round of qkd .",
    "the recycled key and new key produced by the qkd protocol are then used for the authentication in subsequent rounds . w.l.o.g .",
    "we assume the initial key to be perfect . if the authentication scheme is @xmath29-uc - secure , and is needed @xmath2 times in each round of qkd , and the qkd protocol is @xmath31-uc - secure and repeated @xmath3 times , it is immediate from the composition theorem that the final key  the concatenation of all unused secret key bits produced in each round and the recycled hash function",
    " has distance at most @xmath170 from uniform .    to sketch this",
    ", we first consider the composition of the @xmath2 rounds of authentication with key recycling , which we illustrate in . in the ideal",
    "setting , the different rounds of the ideal authentication are all independent .",
    "so the statistical distance between the environment s ( @xmath24 ) view of @xmath2 rounds of ideal authentication and @xmath155 rounds of ideal authentication with @xmath125 round of the real protocol is at most @xmath29 . likewise ,",
    "if we compare the second and third lines of , the environment @xmath166 can notice a difference with probability at most @xmath29 .",
    "since @xmath166 is simply @xmath24 with an additional internal round of authentication ( which @xmath24 can run on its own anyway ) , @xmath24 does not have an advantage greater than @xmath29 either . by repeating this reasoning and using the triangle inequality for the statistical distance",
    ", we find that @xmath2 rounds of authentication with key recycling have error at most @xmath171 .",
    "next , we look at the composition of @xmath2 rounds of authentication and @xmath125 round of qkd .",
    "let @xmath172 be the key recycled by the authentication protocols , @xmath173 the output of the qkd protocol , let @xmath137 and @xmath174 be their ideal counterparts , and let @xmath175 and @xmath176 be the quantum states held by the environment in the real and ideal cases , consisting of all the information it gathered , the classical messages , tags , falsified messages , and quantum information gleaned from the quantum channel .",
    "we need to show that the ( trace ) distance and @xmath177 is the quantum generalization of the statistical distance , and is given by @xmath178 , where @xmath179 . ] between the real and ideal situations is bounded by @xmath180 , i.e. , @xmath181    since the composition of authentication protocols is close to ideal for all environments , it is in particular secure for an environment that runs a qkd protocol and attempts to distinguish between the real and ideal settings by looking at the output of the qkd protocol .",
    "hence @xmath182 where @xmath183 is the output of the qkd protocol run with the ideal authentication . by the security definition of qkd",
    "@xcite , the protocol is @xmath31-uc - secure if , when using an ideal authentication protocol , we have @xmath184 combining the two equations above and the triangle inequality proves .",
    "the final step consists in showing that @xmath3 rounds of qkd and authentication has error at most @xmath170 .",
    "the reasoning is however identical to the @xmath2 sequential compositions of just authentication depicted in , so we omit it .",
    "the author would like to thank renato renner and christoph pacher for valuable discussions .",
    "this work has been funded by the swiss national science foundation ( via grant no .",
    "200020 - 135048 and the national centre of competence in research ` quantum science and technology ' ) , the european research council ",
    "erc ( grant no .",
    "258932 )  and by the vienna science and technology fund ( wwtf ) through project ict10 - 067 ( hipanq ) .",
    "we prove here the security of standard authentication with @xmath0-asu@xmath1 hashing as defined in .",
    "note that this proof does not need the extra requirement that @xmath185 = \\frac{1}{|\\ct|}$ ] , which is often part of the @xmath0-asu@xmath1 definition ( see on ) .",
    "let @xmath27 be an authentication scheme that encodes a message @xmath6 as @xmath186 , where @xmath187 is a family of @xmath0-almost strongly universal@xmath1 hash functions , and @xmath10 is chosen uniformly at random from @xmath61 .",
    "then @xmath27 is @xmath0-uc - secure .",
    "we need to show that is satisfied for any distributions @xmath99 and @xmath100 .",
    "let @xmath38 and @xmath188 .",
    "if the environment chooses @xmath119 , both the real protocol and ideal functionally behave identically and are indistinguishable  they both accept @xmath6 if @xmath102 and produce an error otherwise .",
    "we can therefore assume w.l.o.g .",
    "that the environment always chooses @xmath109 . in this case , the simulator in the ideal situation always outputs an error @xmath42 , i.e. , @xmath189 .",
    "the security criterion therefore reduces to @xmath190    splitting the random variable @xmath191 in its two parts , and combining the following equations , @xmath192 , \\\\",
    "p_{\\tilde{x}|xyy'}(x'|x,(x , t),(x',t ' ) ) & = \\pr [ h_k(x ' ) = t ' | h_k(x ) = t],\\end{aligned}\\ ] ] we get @xmath193 \\\\    & \\qquad \\leq \\sum_{x , t , x',t ' } p_{x}(x ) p_{y'|xt}(x',t'|x , t )    \\frac{\\eps}{|\\ct| } \\\\    &",
    "\\qquad = \\sum_{t } \\frac{\\eps}{|\\ct| } = \\eps . \\qedhere\\end{aligned}\\ ] ]",
    "in an impersonation attack , the adversary ( or environment in case of a dummy adversary ) does not wait for the legitimate parties to authenticate a message , instead he generates his own @xmath45 before receiving any @xmath39 .",
    "in the ideal case , the simulator then always sends an error @xmath42 to the ideal functionality who transmits it to @xmath36 .",
    "since no input @xmath6 and corresponding @xmath39 are present , the security criterion for standard authentication ( ) then reduces to @xmath194 and we say that an authentication protocol is @xmath0-uc - secure against impersonation attacks if holds .    in the case of key recycling",
    ", the decision of @xmath36 to accept or reject the message might be correlated to the key @xmath17 , i.e. , the random variables @xmath54 and @xmath74 can be correlated .",
    "it is therefore important that in this setting too , the ideal functionality produces a new key @xmath75 which is perfectly uniform and independent from @xmath195 .",
    "the corresponding security criterion ( ) then reduces to @xmath196 and we say that an authentication protocol with key recycling is @xmath0-uc - secure against impersonation attacks if holds .    although these might , at first look , seem like a simplification of their substitution - attack counterparts , it is in fact possible to construct ( artificial ) protocols that have an impersonation error roughly twice as large as the substitution error .",
    "be a set of functions such that for all @xmath10 , @xmath197 , and @xmath125 is uniformly mapped ( over the choice of @xmath10 ) to all @xmath198 .",
    "let the authentication protocol encode the message @xmath199 as @xmath200 .",
    "if the environment performs an impersonation attack by sending the message @xmath201 , this will be accepted with probability @xmath125 .",
    "if the environment performs a substitution attack , he first has to choose a message @xmath6 , then receives the corresponding @xmath39 from the dummy adversary , and has to choose a new @xmath202 . for all @xmath6 , with probability @xmath203",
    "the corresponding encoding is @xmath201 , and so the impersonation attack outlined above works only with probability @xmath203 .",
    "] however , in the special case where the encoding of the message @xmath6 is of the form @xmath38 , we show in the following section that security against impersonation attacks follows from security against substitution attacks .",
    "[ lem : impersonation ] let @xmath27 be an authentication scheme ( with or without key recycling ) that encodes a message @xmath6 as @xmath38 . if @xmath27 is @xmath0-uc - secure ( against substitution attacks ) , then it is also @xmath0-uc - secure against impersonation attacks .",
    "we assume that the protocol is not @xmath0-uc - secure against impersonation attacks , and construct a substitution attack .",
    "let @xmath204 then there exists a specific @xmath47 for which @xmath205 so w.l.o.g .",
    "we can take @xmath206 .    for the corresponding substitution attack , let the environment choose any distribution @xmath99 such that @xmath207 .",
    "then upon receiving @xmath39 , it sends @xmath47 . in the ideal case ,",
    "the simulator and ideal functionality therefore always transmit an error , and in the real case @xmath36 accepts the message @xmath46 with the same probability as for the impersonation attack .",
    "so @xmath208 and @xmath209 have exactly the same distributions in the cases of substitution and impersonation attacks .",
    "hence @xmath210      the bound on the impersonation error from is not always tight . in particular , in the case of the authentication protocol with key recycling given in it",
    "is possible to get a better result . due to the tight bound in we find that this scheme is @xmath132-uc - secure against impersonation attacks .",
    "let @xmath27 be an authentication scheme that encodes a message @xmath6 as @xmath79 and recycles @xmath17 , where @xmath97 is a family of @xmath0-almost xor universal@xmath1 hash functions , and @xmath71 are chosen uniformly at random from @xmath98 .",
    "then @xmath27 is @xmath132-uc - secure against impersonation attacks .",
    "we need to show that for all distributions @xmath100 , holds for @xmath211 . since in the ideal case @xmath212 and @xmath75 is independent from @xmath195 , the lhs of reduces to @xmath213 and because from , @xmath214\\\\      & = p_{\\tilde{k}}(k_1 ) \\pr \\left [ h_{k_1}(x ) \\xor",
    "k_2 = t \\middle|        \\tilde{k } = k_1 \\right ] = \\frac{1}{|\\ck||\\ct|},\\end{aligned}\\ ] ] is equal to @xmath132 .",
    "note that in the case of standard authentication with @xmath0-asu@xmath1 hashing , if we had made the extra assumption that @xmath215 = \\frac{1}{|\\ct|}$ ] ( see on ) , we would also have found that the corresponding scheme is @xmath132-uc - secure against impersonation attacks .",
    "however , from alone , we can at best get the bound @xmath216 = \\sum_{t ' } \\pr \\left[h_k(x ) = t \\text { and } h_k(x ' ) = t'\\right ] \\leq \\eps,\\ ] ] which only guarantees that the scheme is @xmath0-uc - secure against impersonation attacks .",
    "jrgen bierbrauer , thomas johansson , gregory kabatianskii , and ben smeets . on families of hash functions",
    "via geometric codes and concatenation . in _ proceedings of the 13th annual international cryptology conference on advances in cryptology , crypto  93 _ , pages 331342 .",
    "springer , 1994 . .",
    "birgit pfitzmann and michael waidner .",
    "composition and integrity preservation of secure reactive systems . in _ proceedings of the 7th acm conference on computer and communications security , css  00",
    "_ , pages 245254 .",
    "acm , 2000 . .",
    "michael backes , birgit pfitzmann , and michael waidner . a general composition theorem for secure reactive systems . in _ proceedings of the first theory of cryptography conference , tcc  04 _ , pages 336354 .",
    "springer , 2004 . .",
    "mustafa atici and douglas  r. stinson .",
    "universal hashing and multiple authentication . in _ proceedings of the 16th annual international cryptology conference on advances in cryptology , crypto  96",
    "_ , pages 1630 .",
    "springer , 1996 . .",
    "victor shoup . on fast and provably secure message authentication based on universal hashing .",
    "in _ proceedings of the 16th annual international cryptology conference on advances in cryptology , crypto  96 _ , pages 313328 .",
    "springer , 1996 . .",
    "michael ben - or , michael horodecki , debbie leung , dominic mayers , and jonathan oppenheim . the universal composable security of quantum key distribution . in _ proceedings of the second theory of cryptography conference , tcc  05 _ , pages 386406 .",
    "springer , 2005 . ."
  ],
  "abstract_text": [
    "<S> in their seminal work on authentication , wegman and carter propose that to authenticate multiple messages , it is sufficient to reuse the same hash function as long as each tag is encrypted with a one - time pad . </S>",
    "<S> they argue that because the one - time pad is perfectly hiding , the hash function used remains completely unknown to the adversary .    since their proof is not composable , we revisit it using a universally composable framework . </S>",
    "<S> it turns out that the above argument is insufficient : information about the hash function is in fact leaked in every round to the adversary , and after a bounded finite amount of rounds it is completely known . </S>",
    "<S> we show however that this leak is very small , and wegman and carter s protocol is still @xmath0-secure , if @xmath0-almost strongly universal@xmath1 hash functions are used . </S>",
    "<S> this implies that the secret key corresponding to the choice of hash function can be recycled for any task without any additional error than this @xmath0 .    </S>",
    "<S> we illustrate this by applying it to quantum key distribution ( qkd ) : if the same hash function is recycled to authenticate the classical communication in every round of a qkd protocol , and used @xmath2 times per round , the total error after @xmath3 rounds is upper bounded by @xmath4 , where @xmath5 is the error of one round of qkd given an authentic channel . </S>"
  ]
}