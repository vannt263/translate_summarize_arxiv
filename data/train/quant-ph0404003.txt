{
  "article_text": [
    "a primary motivation for the study of reversible circuits is the possibility of nearly energy - free computation .",
    "landauer  @xcite showed that traditional irreversible circuits necessarily dissipate energy due to the erasure of information . on the other hand , in principle ,",
    "reversible computation can be performed with arbitrarily small energy dissipation  @xcite .",
    "though the fraction of the power consumption in current vlsi circuits attributable to information loss is negligible , this is expected to change as increasing packing densities force the power consumption per gate operation to decrease  @xcite , making reversible computation an attractive alternative .",
    "many applications in the fields of cryptography , communications and digital signal processing require computations that transform the data without erasing any of the original information .",
    "these applications are particularly well - suited to a reversible circuit implementation . however",
    ", the applicability of reversible circuits is not limited to inherently reversible applications .",
    "conventional irreversible computation can be implemented reversibly using limited overhead  @xcite .",
    "furthermore , reversible circuits are not just a theoretical area of study : de vos et al .",
    "@xcite have built reversible cmos circuits that are powered entirely from the input pins without the assistance of additional power supplies .",
    "a major new motivation for the study of reversible circuits is provided by the emerging field of quantum computation  @xcite . in a quantum circuit",
    "the operations are performed on quantum states or qubits rather than bits .",
    "since quantum evolution is inherently reversible , the resulting quantum computation is as well .",
    "classical reversible circuits form an important subclass of these quantum circuits .",
    "while logic synthesis , and hardware implementations for reversible circuits have been studied in previous work , very little research has considered reversibility in the context of testing .",
    "one exception is research at montpellier , where reversibility was used to synthesize on - line test structures for irreversible circuits  @xcite .",
    "in contrast , our focus is on testing inherently reversible circuits , particularly , generating efficient test sets for these circuits .",
    "though this is a hard problem for conventional irreversible circuits , it can be significantly simplified in our case .",
    "agrawal  @xcite has shown that fault detection probability is greatest when the information output of a circuit is maximized .",
    "this suggests that it may be easier to detect faults in reversible circuits , which are information lossless , than in irreversible ones . while this previous work focused on probabilistic testing , here we are concerned with complete deterministic testing .",
    "we show that surprisingly few test vectors are necessary to fully test a reversible circuit under the multiple stuck - at fault model , with the number growing at most logarithmically both in the number of inputs and the number of gates .",
    "this provides additional motivation for studying reversible circuits , namely they may be much easier to test than their irreversible counterparts .    in section",
    "[ sec : rev_circ ] we give some basic background on reversible circuits .",
    "we then present some theoretical results on complete test sets for reversible circuits in section  [ sec : complete ] , and results on such sets for worst - case circuits in section  [ sec : worst - case ] . in section  [ sec : ilp ]",
    "we give a practical algorithm for generating efficient complete test sets , present simulation results , and make comparisons to conventional atpg  ( automatic test pattern generation ) .",
    "we extend our results to the more general cell - fault model in section  [ sec : cell_fault ] , and conclude in section  [ sec : concl ] .",
    "a logic gate is _ reversible _ if the mapping of inputs to outputs is bijective , that is , every distinct input yields a distinct output , and the numbers of input and output wires are equal . if it has @xmath0 inputs  ( and outputs ) , we call it a _ reversible @xmath1 gate_. three commonly used gates , composing the @xmath2-gate library , are shown in figure  [ fig : cnt ] . the not gate inverts the input , the c - not gate passes the first input through and inverts the second if the first is 1 , and the toffoli gate passes the first two inputs through and inverts the third if the first two are both 1",
    ".     +    a _ well - formed reversible circuit _ is constructed by starting with @xmath3 wires , forming the basic circuit , and iteratively concatenating reversible gates to some subset of the output wires of the previous circuit .",
    "the outputs of each reversible gate replace the wires at its input .",
    "this iterative construction naturally gives us the notion of _ levels _ in the circuit ; the inputs to the circuit are at level 0 , and the outputs of any gate are at one plus the highest level of any of its inputs .",
    "for convenience in cases where a wire at the input of a gate is at level @xmath4 and the outputs are at level @xmath5 , we say the input is at all levels between @xmath4 and @xmath6 inclusively .",
    "this gives us @xmath3 wires at each level .",
    "figure  [ fig : ex_circuit ] shows an example of a reversible circuit with the levels denoted by dotted lines .",
    "the propagation of an input vector through the circuit is shown to illustrate the circuit s operation .",
    "the _ depth _ @xmath7 of the circuit is the maximum level , which can be no larger than the number of gates in the circuit",
    ". we will often find it convenient to use an @xmath3-bit vector to refer to the values of the wires at a given level in the circuit .",
    "a binary vector has _ weight _",
    "@xmath0 if it contains exactly @xmath0 1 s , and we denote the all-0 s and all-1 s vectors by @xmath8 and @xmath9 , respectively .",
    "the foregoing iterative construction also leads to the notion of a _ sub - circuit _ , the part of the original circuit between levels @xmath4 and @xmath10 , or more specifically , the circuit formed by the gates with outputs at level greater than @xmath4 and less than @xmath11 .",
    "we denote the function computed by the sub - circuit as @xmath12 and its inverse as @xmath13 .",
    "if we omit the first subscript @xmath4 it should be assumed to be @xmath14 .",
    "the function of the entire circuit is then @xmath15 .",
    "we say a reversible circuit is _",
    "@xmath16-constructible _ , if it can be formed using the @xmath16-gate library .",
    "some important gate libraries used here are the @xmath2-gate library mentioned above , the c - not gate library consisting of only c - not gates , and the universal or @xmath17-gate library which consists of all possible reversible @xmath18 gates .",
    "these three gate libraries compute the set of even permutations , the set of linear reversible functions , and the set of all permutations respectively  @xcite . in order to compute any function that is not an even permutation , at least one gate that spans all @xmath3 wires",
    "is required . unlike the @xmath17-library , practical gate libraries are unlikely to contain such large gates .",
    "the @xmath2-gate library has been well studied  @xcite and computes essentially all functions that are practically realizable .",
    "consequently , we will focus on it for most of our work .",
    "given a reversible circuit @xmath19 and a fault set @xmath20 , we want to generate a set of test vectors that detect all faults in @xmath20 .",
    "we call such a test set _ complete_. a complete test set with the fewest possible vectors is _ minimal_.     +    two important properties of reversibility simplify the test set generation problem .",
    "the first is _ controllability _ : there is a test vector that generates any given desired state on the wires at any given level .",
    "the second is _ observability _ : any single fault that changes an intermediate state in the circuit also changes the output .",
    "neither property holds , in general , for irreversible circuits .    to illustrate these two properties , consider the reversible circuit shown in figure  [ fig : ex_circuit ] .",
    "the controllability property enables us to set the wires at any level in the circuit to any desired set of values using a unique input vector , found by reversing the action of the circuit .",
    "for example , to find the input vector necessary to set the wires at level 2 to the vector 0101 , we first backtrack through the three - input gate between levels 1 and 2 .",
    "this gives us the vector 0111 at level 1 .",
    "backtracking once more gives the vector 0110 at the input .",
    "reversibility guarantees that this backtracking is always possible and always yields a unique vector at the input . the observability property enables us to observe any intermediate change in the circuit at the output .",
    "this is because each vector at any level in the circuit corresponds to exactly one output vector .",
    "for example , only the vector 0101 at level 2 in the circuit yields the output vector 1001 ; any other vector at this level will yield a different output .    for most of this paper",
    "we adopt the standard stuck - at fault model used in testing conventional circuits , which includes all faults that fix the values of wires in the circuit to either @xmath14 or @xmath21 . for reversible circuits",
    "we show that any test set that detects all single stuck - at faults , also detects any number of simultaneous faults . in section  [ sec : cell_fault ] we extend our results to the more general cell - fault model , where the fault set consists of single gate failures .",
    "the following proposition provides a simple necessary and sufficient condition for a test set to be complete for the stuck - at fault model .",
    "[ prop : suff ] under the single stuck - at fault model a test set is complete if and only if each wire at every level can be set to both 0 and 1 by the test set .",
    "* proof * assume without loss of generality that a test set does not set a wire at level @xmath4 to @xmath14 .",
    "a stuck - at @xmath21 fault at this point in the circuit is then undetectable , since the outputs from the test set are unaffected . on the other hand ,",
    "if all wires at every level can be set to both @xmath14 and @xmath21 by the test set , then a stuck - at fault must affect at least one test vector , changing the value of the wire at that level from a @xmath14 to a @xmath21 or vice versa . by the observability property",
    "this change will affect the output .",
    "@xmath22    to illustrate this proposition consider the fault site on the second wire at level 4 in the circuit in figure  [ fig : ex_circuit ] . in order to detect a stuck - at 0 fault , the test set must be able to set this wire to 1 , otherwise the fault would not have any effect on the test set , and would therefore be undetected . if a stuck - at 0 fault does occur , then a test vector that sets the wire to 1 would generate an incorrect output , namely a 1 instead of a 0 on the second wire at the output .",
    "similarly , to detect a stuck - at 1 fault on this wire , the test set must be able to set the wire to 0 .",
    "the next proposition shows that the single stuck - at and the multiple stuck - at fault models are essentially identical for reversible circuits ; specifically , a test set that is complete for one model is also complete for the other .",
    "the intuition behind this property is that in the case of multiple faults the final fault(s ) , i.e. , those closest to the outputs , can be detected by working backwards from the outputs .",
    "[ prop : suff_mult ] any test set that is complete for the single stuck - at fault model is also complete for the multiple stuck - at fault model .    *",
    "proof * suppose we have a counter - example",
    ". then there must be a complete test set @xmath23 for some reversible circuit under the single fault model , which is not complete for multiple faults .",
    "so at least one multiple fault @xmath24 is undetectable by @xmath23 . since @xmath24 is undetectable , the response of the circuit to @xmath23 must be the same as those of the fault - free circuit .",
    "now @xmath24 is composed of faults at various levels .",
    "let @xmath4 be the deepest level containing a sub - fault of @xmath24 . since no sub - faults occur at any level greater than @xmath4 , the reversible sub - circuit between level @xmath4 and the outputs is identical to the corresponding sub - circuit in the fault - free circuit",
    ". therefore , since the response to @xmath23 and the reversible sub - circuit between level @xmath4 and the outputs are the same as for the fault - free circuit , the values of the wires at level @xmath4 must also be the same as for the fault - free circuit .",
    "since @xmath23 is complete under the single fault model , by proposition  [ prop : suff ] each wire at level @xmath4 must take both the value 0 and 1 .",
    "however this is a contradiction , since there is at least one sub - fault at level @xmath4 that fixes the value of a wire .",
    "@xmath22    this correspondence between the single and multiple stuck - at fault models allows us to restrict our attention to the conceptually simpler case of single faults .",
    "if we have an @xmath3-wire circuit with @xmath25 gates of sizes @xmath26 , then a total of @xmath27 single stuck - at faults can occur : stuck - at 0 and stuck - at 1 faults for each gate input and circuit output .",
    "reversibility then implies the following result , which will be useful later .",
    "[ lemma : count ] each test vector covers exactly half of the possible faults , and each fault is covered by exactly half of the possible test vectors .",
    "* proof * each test vector @xmath28 sets the bit at each fault site to either 0 or 1 , detecting either a stuck - at 1 or stuck - at 0 fault , respectively .",
    "therefore , @xmath28 detects precisely half of the possible single stuck - at faults . for",
    "a given stuck - at fault there are @xmath29 possible bit vectors at that level that can detect the fault , namely those that set the faulty bit to the opposite of the stuck - at value .",
    "since the circuit is reversible , each of these can be traced back to a distinct input vector .",
    "therefore , half of the @xmath30 input vectors detect the fault .",
    "@xmath22    we can obtain some properties of a minimal test set of a circuit by decomposing the circuit into sub - circuits . for example , the size of a minimal test set for a reversible circuit is greater than or equal to that of any of its sub - circuits . on the other hand ,",
    "the size of a minimal test set for a circuit formed by concatenating reversible circuits @xmath31,@xmath32 , @xmath33 is no greater than the sum of the sizes of minimal test sets for the individual @xmath34 s .",
    "finally if two reversible circuits @xmath31 and @xmath35 , with minimal test sets of sizes @xmath36 and @xmath37 respectively , act on a disjoint set of input / output bits , then the size of the minimal test set of the circuit formed by concatenating @xmath31 and @xmath35 is equal to @xmath38 .",
    "these properties can be used to bound the size of the minimal test set , and in some cases , to simplify the problem of finding a minimal test set .",
    "the following proposition gives a number of complete test set constructions , implicitly providing upper bounds on the size of a minimal test set .",
    "[ prop : constr ] a complete test set for an @xmath3-wire reversible circuit with depth @xmath7 and a total of @xmath25 gates with sizes @xmath26 is given by :    * any @xmath39 distinct test vectors * the following @xmath40 test vectors @xmath41 * some set of @xmath42 test vectors .    * proof * + ( a ) the value of a wire at a given level is set to @xmath14 ( or @xmath21 ) by exactly @xmath29 input vectors .",
    "therefore , if the test set contains @xmath39 vectors , then at least one will set it to @xmath21 ( or @xmath14 ) .",
    "since this is true for all fault sites , by proposition  [ prop : suff ] the test set is complete .",
    "\\(b ) the vector @xmath43 sets the wires at level @xmath4 to the bitwise inverse of the values set by the @xmath8 vector .",
    "therefore each wire at every level can be set to both @xmath14 and @xmath21 by the test set . by proposition  [ prop : suff ]",
    "the test set is complete .",
    "\\(c ) to prove this part we first prove that given a reversible circuit and an incomplete set of test vectors , there is a test vector that can be added that covers at least half of the remaining faults .",
    "let @xmath44 be the number of test vectors given , @xmath45 be the faults covered by this set , and @xmath19 the size of @xmath45 .",
    "if none of the remaining @xmath46 input vectors cover at least half of the remaining faults , then they must each cover more than half of the faults in @xmath45 . by lemma  [ lemma : count ] every test vector covers exactly @xmath47 faults and every fault is covered by exactly @xmath29 test vectors .",
    "therefore , the number of times faults in @xmath45 are covered by all input vectors cumulatively is @xmath48 , implying the following inequalities : @xmath49 the second inequality is false since the number of faults covered can not be larger than the total number of faults that can occur .",
    "therefore we have a contradiction , and there must be a test vector that can be added to cover at least half of the remaining faults .    recursively applying this observation",
    "we can eliminate all uncovered faults in no more than @xmath50 steps ( test vectors ) .",
    "@xmath22    proposition  [ prop : constr ] limits the size of the minimal test set based on the size of the reversible circuit both in terms of its depth and the number of input / output bits . for the circuit in figure  [ fig : ex_circuit ] , parts a - c of the proposition give upper bounds of 9 , 7 , and 6 test vectors , respectively .",
    "the final part of the proposition implies that a reversible circuit can be tested by a very small set of tests . as an example",
    ", a reversible circuit on 64 wires with a million @xmath51 gates can be tested using no more than 23 input vectors . however , while the first two parts of proposition  [ prop : constr ] give practical constructions , the last one does not ; consequently , it may not be easy to find such a test set .",
    "we say a test set is _",
    "@xmath52-complete _ for gate library @xmath16 acting on @xmath3 wires , if it is complete for all circuits formed by the library .",
    "the following proposition shows that a circuit requiring such a test set exists for any gate library .",
    "any reversible gate library @xmath16 acting on @xmath3 wires has an @xmath52-complete set of test vectors that is minimal for some circuit in the set .",
    "* proof * let @xmath53 be a set of circuits that computes the set of all functions computable using @xmath16 , and @xmath54 .",
    "then any test set that is complete for @xmath19 must be complete for any circuit formed by @xmath16 .",
    "therefore , a minimal test set for @xmath19 is @xmath52-complete . @xmath22",
    "the following proposition characterizes @xmath52-complete test sets for three classes of reversible circuits : @xmath19-constructible , @xmath17-constructible , and @xmath2-constructible .",
    "@xmath55    * a @xmath56-complete test set must have at least @xmath57 vectors .",
    "one such set comprises the all-0 s vector and the @xmath3 weight-1 vectors .",
    "* a @xmath58-complete test set must have at least @xmath39 vectors , and any @xmath39 test vectors will give such a set .",
    "* an @xmath59-complete test set must have at least @xmath39 vectors , and any @xmath39 test vectors will give such a set .    *",
    "proof * + ( a ) any input to the circuit can be written as a linear combination of the @xmath3 weight-1 vectors . furthermore , since the gate library is linear  ( under the operation of bitwise xor ) , the corresponding values of the wires at the @xmath4th level can be written as the same linear combination of the values for these weight-1 vectors . if any input vector sets the value of a wire at the @xmath4th level to 1 , then so must at least one weight-1 vector",
    ". since there are inputs that do , the weight-1 vectors are sufficient for setting all wires to 1 .",
    "furthermore , since the circuit is linear , the all-0 s vector sets all wires at all levels to 0 .",
    "therefore , this is a @xmath56-complete test set . in general",
    "any @xmath3 linearly independent vectors along with the all-0 s vector forms a @xmath56-complete test set .",
    "on the other hand , if the test set consists of only @xmath3 input vectors , we have two possibilities : either the set spans the @xmath3-dimensional space or it does not . if the latter case , a linear reversible circuit can be constructed that maps the test set into the @xmath60-dimensional subspace @xmath61 , implying that the test set is not complete .",
    "if the test set spans the entire @xmath3-dimensional space , a linear reversible circuit can be constructed that maps them to the linearly independent vectors : @xmath62 since the first wire can not be set to 0 , the test set is not complete for this circuit .",
    "\\(b ) suppose we have a @xmath58-complete test set with @xmath29 test vectors .",
    "because the gate library computes all permutations , we can generate a circuit mapping all @xmath29 test vectors to output vectors of the form @xmath63 .",
    "this test set does not set the first output bit to @xmath21 , and thus is not complete for this @xmath17-gate circuit .",
    "this implies it is not @xmath58-complete . by proposition  [ prop : constr]a",
    ", any @xmath39 test vectors will give @xmath58-completeness .",
    "\\(c ) any permutation can be composed from a series of transpositions .",
    "the @xmath2 gate library can construct circuits computing any even permutation of the input values  @xcite , that is , a permutation that can be composed from an even number of transpositions .",
    "following the proof for part b , a permutation can map any @xmath29 test vectors to output vectors of the form @xmath64 .",
    "if this permutation is even we have shown that this is an incomplete test set , otherwise we can add a transposition that exchanges the outputs @xmath65 and @xmath66 .",
    "this new permutation is even and still maps the test vectors to the set of outputs @xmath64 , and therefore , the test set is not complete for this @xmath2-circuit . by proposition  [ prop : constr]a , any @xmath39 test vectors will give @xmath59-completeness .",
    "@xmath22    note that any two gate libraries that can compute the same set of functions are equivalent with respect to @xmath52-completeness .",
    "this is because the function of every gate of one library can be computed by the other .",
    "therefore , if a test set is not @xmath52-complete for one library , it can not be for the other either , implying that the two libraries share the same @xmath52-complete test sets .",
    "this means that the above result for the @xmath17-gate library is applicable to any library that can compute all @xmath3-bit reversible functions .",
    "@xmath19-constructible circuits are analogous to xor - trees , since c - not gates are simply xor gates with an additional output that is equal to one of the inputs .",
    "consequently , part ( a ) of the above proposition can be considered the reversible analog of the well - known result that any xor - tree can be tested for single stuck - at faults using no more than four tests  @xcite .",
    "we consider linear reversible circuits separately here , primarily because they can be tested with a very simple set of tests just as xor - trees in conventional irreversible circuit testing  @xcite .",
    "while proposition  [ prop : constr]c guarantees that an efficient test set exists for any reversible circuit , it gives no practical construction . in this section , we formulate the problem of constructing a minimal test set as an integer linear program  ( ilp ) with binary variables .",
    "we then use this to find a practical heuristic for generating efficient test sets .",
    "we can formulate the minimal test set problem as an ilp with binary decision variables @xmath67 associated with each input vector @xmath68 ; @xmath67 takes a value of one if the corresponding input vector is in the test set , and zero otherwise .",
    "a fault is detected if a decision variable with value one corresponds to a vector that detects the fault .",
    "the values of the wires at the @xmath10-th level for input @xmath68 are @xmath69 , so to detect all stuck - at 0 faults at level @xmath10 the following inequalities must be satisfied @xmath70 these inequalities guarantee that each wire at the @xmath10-th level is set to 1 by some test vector , ensuring that all stuck - at 0 faults are detected .",
    "a similar set of inequalities ensures that all stuck - at 1 faults are also detected . in total ,",
    "@xmath71 linear inequality constraints are used to guarantee completeness .",
    "we determine a minimal test set by minimizing the sum of the @xmath67 s , that is , by minimizing the size of the complete test set , subject to these constraints .",
    "the general ilp formulation of the minimal test set problem for a reversible circuit on @xmath3 wires and with depth @xmath7 is : @xmath72    each feasible solution gives a complete test set composed of those vectors @xmath4 for which @xmath73 .",
    "for relatively small circuits this ilp can be solved efficiently with an off - the - shelf optimization tool such as cplex  @xcite .",
    "@xmath74{cccc } t_0 \\rightarrow \\begin{array}{c|c|c } 0 & 0 & 0\\\\ 0 & 0 & 0\\\\ 0 &    0 & 0\\end{array } &   t_1 \\rightarrow \\begin{array}{c|c|c } 0 & 0 & 0\\\\ 0 & 0 & 0\\\\ 1 &    1 & 1\\end{array } &   t_2 \\rightarrow \\begin{array}{c|c|c } 0 & 0 & 0\\\\ 1 & 1 & 1\\\\ 0 &    0 & 1\\end{array } &   t_3 \\rightarrow \\begin{array}{c|c|c } 0 & 0 & 0\\\\ 1 & 1 & 1\\\\ 1 &    1 & 0\\end{array } \\\\ \\\\",
    "t_4 \\rightarrow \\begin{array}{c|c|c }    1 & 1 & 1\\\\ 0 & 1 & 1\\\\ 0 & 0 & 1\\end{array } & t_5",
    "\\rightarrow \\begin{array}{c|c|c } 1 & 1 & 1\\\\ 0 & 1 & 1\\\\ 1 &    1 & 0\\end{array } &   t_6 \\rightarrow \\begin{array}{c|c|c } 1 & 1 & 1\\\\ 1 & 0 & 0\\\\ 0 &    0 & 0\\end{array } &   t_7 \\rightarrow \\begin{array}{c|c|c }    1 & 1 & 1\\\\ 1 & 0 & 0\\\\ 1 & 1 & 1\\end{array } \\\\ \\\\ \\end{array}$ ] + ( a ) ( b )    consider the circuit shown in figure  [ fig : ex_circuit2 ] .",
    "the corresponding ilp formulation is : @xmath75 \\cdot   \\left[\\renewcommand{\\arraystretch}{.6}{\\begin{array}{c } t_0\\\\ t_1\\\\ \\vspace{.05 in } t_2\\\\ t_3\\\\",
    "t_4\\\\ \\vspace{.05 in } t_5\\\\",
    "t_6\\\\ t_7\\\\ \\end{array}}\\right ]   \\ge   \\left[\\renewcommand{\\arraystretch}{.6}{\\begin{array}{c } 1\\\\1\\\\ \\vspace{.07 in } 1\\\\1\\\\1\\\\ \\vspace{.07 in } 1\\\\1\\\\1\\\\1 \\end{array}}\\right]\\\\ \\\\",
    "\\begin{array}{c } \\sum_{i=0}^{7 } \\overline{f_0\\left(t_i\\right)}\\cdot t_i \\ge \\underline{1}\\\\ \\\\ \\sum_{i=0}^{7 } \\overline{f_1\\left(t_i\\right)}\\cdot t_i \\ge \\underline{1}\\\\ \\\\",
    "\\sum_{i=0}^{7 } \\overline{f_2\\left(t_i\\right)}\\cdot t_i \\ge \\underline{1}\\\\   \\end{array } & \\longleftrightarrow & \\left[\\renewcommand{\\arraystretch}{.6}{\\begin{array}{ccccccccc } 1&1&1&1&0&0&0&0\\\\ 1&1&0&0&1&1&0&0\\\\ \\vspace{.07 in } 1&0&1&0&1&0&1&0\\\\   1&1&1&1&0&0&0&0\\\\ 1&1&0&0&0&0&1&1\\\\ \\vspace{.07 in } 1&0&1&0&1&0&1&0\\\\   1&1&1&1&0&0&0&0\\\\ 1&1&0&0&0&0&1&1\\\\ 1&0&0&1&0&1&1&0 \\end{array}}\\right]\\cdot   \\left[\\renewcommand{\\arraystretch}{.6}{\\begin{array}{c } t_0\\\\ t_1\\\\   t_2\\\\ t_3\\\\ t_4\\\\ t_5\\\\ t_6\\\\ t_7\\\\ \\end{array}}\\right ]   \\ge   \\left[\\renewcommand{\\arraystretch}{.6}{\\begin{array}{c } 1\\\\1\\\\ \\vspace{.07 in } 1\\\\1\\\\1\\\\ \\vspace{.07 in } 1\\\\1\\\\1\\\\1 \\end{array}}\\right]\\end{array}\\\\ & & \\mbox{where } t_i\\in \\left\\{0,1\\right\\}\\end{aligned}\\ ] ] the first set of inequalities guarantees that each of the fault sites can be set to 1 , and the second set guarantees that they can be set to 0 .",
    "solving the ilp , we find that three test vectors are required to detect all stuck - at faults in the circuit .",
    "one such solution is @xmath76 .    using the ilp formulation and cplex 7.0 , we obtained minimal test sets for all optimal 3-wire @xmath2-circuits .",
    "cplex solved the ilp for each circuit in a fraction of a second on a sun sparc .",
    "table  [ tab : ilp ] gives a distribution of minimum test set size with respect to the number of gates in the circuit .",
    "the optimal @xmath2 implementation of a given function is not unique , and therefore the distribution in table  [ tab : ilp ] may be dependent on the particular optimal set chosen .     & * 0 & * 1 & * 2 & * 3 & * 4 & * 5 & * 6 & * 7 & * 8 + * 2 & 1 & 6 & 24 & 67 & 134 & 155 & 105 & 21 & - + * 3 & - & 6 & 78 & 558 & 2641 & 8727 & 16854 & 10185 & 577 + * 4 & - & - & - & - & 5 & 39 & 90 & 47 & - + * * * * * * * * * * * *    as expected , the size of the minimal test set generally increases with the length of the circuit . on the other hand ,",
    "there are long circuits that have smaller minimal test sets than much shorter circuits .",
    "the largest minimal test set has 4 vectors ; however , suboptimal circuits requiring 5 test vectors can be constructed .      solving",
    "the ilp exactly is feasible for small circuits ; however , since the number of variables increases exponentially with the number of input / output bits , it is impractical for large circuits .",
    "an alternative approach is to decompose the original circuit into smaller sub - circuits acting on fewer input / output bits , and use the ilp formulation iteratively for these sub - circuits combining the test vectors dynamically ; a similar approach has been used for irreversible circuits  @xcite . while the resulting test set is not guaranteed to be minimal , it is generally small enough to enable efficient testing .",
    "furthermore , it may be possible to use lower bounds to ensure the test set is not much larger than a minimal one .",
    "for example , the size of the minimal test set of a sub - circuit can be used to bound that of the larger circuit .    the algorithm shown in figure  [",
    "fig : alg ] uses this decomposition approach .",
    "the circuit is first decomposed into a series of circuits acting on a smaller number of wires .",
    "one way to do this is to start at the input of the circuit , and add gates to the first sub - circuit @xmath77 until no more can be added without having @xmath77 act on more than @xmath44 wires .",
    "this is continued with @xmath31 , and so on until the entire circuit has been decomposed .",
    "the remaining steps in the algorithm are best illustrated by an example .    [ cols= \" <",
    ", < \" , ]     consider the decomposition of the reversible circuit in figure  [ fig : decomp_ex ] .",
    "though the entire circuit acts on six wires , each sub - circuit acts on no more than four .",
    "using the ilp formulation on @xmath77 gives test vectors : @xmath78 where the x s represent do nt cares and the left and right halves represent the test vectors at the input and output of @xmath77 , respectively .",
    "sub - circuit @xmath31 acts on wires @xmath79 , @xmath80 , @xmath81 and @xmath82 .",
    "we generate the ilp for @xmath31 , and add the following constraints : @xmath83     +    solving this ilp gives the solution @xmath84 . incorporating these values into the previous test vectors we have : @xmath85 sub - circuit @xmath35 acts on wires @xmath79 , @xmath80 , @xmath86 , and @xmath87 .",
    "we generate the ilp for this sub - circuit , and incorporate the current test set using the following constraints : @xmath88 solving this ilp gives solutions @xmath89 , @xmath90 , @xmath91 , and @xmath92 .",
    "the last three can be incorporated into the previous test set , however the first test vector must be added : @xmath93 filling the do nt cares with 0 s and applying @xmath94 to the test set yields a complete test set for @xmath19 . while the resulting test set is not guaranteed to be minimal , in this case it is , as can be shown by applying the ilp method on the entire circuit .",
    "the circuit decomposition method in the previous section generally produces redundant test sets .",
    "one way to reduce this redundancy is to compact the test set , that is , find the smallest complete subset .",
    "this approach has been used previously in atpg algorithms for conventional circuits  @xcite . the ilp formulation in section  [ subsec : ilp",
    "] can be used to perform the test set compaction .",
    "we simply eliminate all test vectors that are not in the original complete test set , along with the corresponding columns in the constraint matrix .",
    "generally , this ilp can be solved more efficiently than the ilp for the minimal test set , since it has fewer variables .",
    "consider the example in the previous section .",
    "since the circuit decomposition method yields a complete test set with four test vectors the ilp formulation for the test set compaction problem only requires four variable , significantly less than the 64 required in the ilp formulation for the minimal test set problem .",
    "@xmath95    we conducted a set of simulations to evaluate the performance of our algorithm .",
    "we generated random @xmath2-circuits of various lengths over 8 , 16 , 24 and 32 wires .",
    "the circuits were generated by selecting at random from the set of all allowable not , c - not , and toffoli gates .",
    "each circuit was decomposed into sub - circuits acting on at most 8 wires , and our algorithm was used to find a complete test set . figure  [ fig : test_size]a shows the average number of test vectors needed as a function of the circuit length .",
    "at least 150 circuits were generated for each data point .",
    "the average execution time for the algorithm seems to increase linearly with circuit length and does not vary very much with the number of input / output wires , with the exception of the 8-wire case for which execution time appears to increase exponentially with circuit length  ( figure  [ fig : test_size]b ) .",
    "this latter case is most likely because the number of constraints increases linearly with the number of gates , yielding increasingly difficult ilps .",
    "on the other hand , for the circuits on more than 8 wires , an increase in the length of circuit does not generally lead to significantly harder individual ilps , rather only a ( linearly ) larger number of them to solve .",
    "test compaction , as expected , is most effective for longer circuits , eliminating an average of approximately one redundant test vector for circuits containing @xmath96 or more gates .",
    "@xmath97    a number of atpg software packages are available for generating test sets for conventional combinational circuits , and some of these can be readily modified for the reversible case .",
    "here we used the atpg tool atalanta  @xcite , because of its ease of use and the availability of its source code .",
    "since the toffoli gate used in our reversible circuits is not a standard combinational logic gate , we had to make some minor modification to the code to handle this gate .",
    "basically , we replaced each toffoli gate by an equivalent combinational circuit using conventional irreversible gates , and modified the code to ignore faults in the internal nodes of these sub - circuits .",
    "figure  [ fig : atpg ] shows the average size of test sets generated by atalanta as a function of the number of gates in the reversible circuit .",
    "results are shown for 8 , 16 , 24 and 32 input / output wires .",
    "as the figure illustrates , the test sets given by atalanta are , on average , almost twice as large as those given by our circuit decomposition algorithm , and their average size is greater than the upper bound of proposition  [ prop : constr]c .",
    "however , atalanta is significantly faster than our algorithm requiring an average of less than 10 seconds for circuits with 32 wires and 1600 gates ; this compares to approximately 30 minutes for the circuit decomposition algorithm .",
    "however , the execution time for atalanta appears to increase at a much faster rate with respect to the circuit length than that of the circuit decomposition algorithm .",
    "while the use of the stuck - at fault model has been very effective in conventional circuit testing , other fault models may be more appropriate for reversible circuits , especially in the quantum domain .",
    "for example , the cell fault model  @xcite , where the function of the faulty @xmath1 gate changes arbitrarily from the desired function , may be more realistic . in this section",
    "we extend some of our results to this model .",
    "the following proposition provides a basic necessary and sufficient condition for a test set to be complete for the cell fault model . while this condition is also necessary for irreversible circuits , in that latter case it is not sufficient .",
    "[ prop : suff_comp2 ] under the cell fault model a test set is complete if and only if the inputs of every @xmath1 gate in the circuit can be set to all @xmath98 possible values by the test set .    *",
    "proof * if a test set does not set the input wires of a gate to a particular value say @xmath99 , then it would not be able to detect a failure in this gate that only affects the output of @xmath99 . on the other hand ,",
    "if the input wires of every gate in the circuit can be set to all possible values by the test set , then any single - gate failure will affect at least one test vector , changing the value at the output of the gate . by the observability property of reversible circuits ,",
    "this will be reflected in a change at the output .",
    "@xmath22    as an example , consider a circuit with a c - not gate . in order to detect any fault in the c - not gate the test set should be able to set the inputs of the gate to @xmath100 .",
    "if the gate is faulty , it will operate incorrectly on at least one of these input values which will then be reflected in an incorrect circuit output .",
    "let @xmath101 be the gates in a reversible circuit , and @xmath26 the respective gate sizes .",
    "if we consider every possible value at the input of each gate as representing a distinct fault , the total number of faults that need to be covered is @xmath102 . under this definition",
    ", we have the following lemma .",
    "[ lemma : count2 ] each input vector covers exactly @xmath25 faults , and a fault associated with a @xmath1 gate is covered by exactly @xmath103 input vectors .    * proof * each input vector sets the bits at the inputs of each gate to some value .",
    "therefore , since there are @xmath25 gates , the vector can detect @xmath25 faults . for a given fault associated with a @xmath1 gate",
    "there are @xmath103 possible values for the @xmath3 bits at that level that can detect it .",
    "since the circuit is reversible , each of these can be traced back to a distinct input vector . @xmath22    the following proposition , which is analogous to proposition  [ prop : constr ] , gives upper bounds on the size of the minimal test set under the cell fault model .",
    "[ prop : cf_bounds ] a complete test set under the cell fault model for an @xmath3-wire reversible circuit with a total of @xmath25 gates with sizes @xmath104 is given by    * any @xmath105 distinct test vectors * a set of @xmath106 test vectors * some set of at most @xmath107 test vectors    * proof * + ( a ) for any @xmath1 gate in the circuit there are @xmath103 distinct inputs that yield a particular value at its input .",
    "therefore , if the test set has @xmath105 vectors ( implying that fewer than @xmath103 are not included ) then it must include at least one such input . since this is true for all gates in the circuit , by proposition  [ prop : suff_comp2 ] , the test set is complete .",
    "+ ( b ) any input vector will cover @xmath25 faults leaving @xmath108 . by the controllability property we can cover these with one test vector each .",
    "therefore , all of the faults can be covered with no more than @xmath109 test vectors .",
    "+ ( c ) we first prove that given an incomplete set of @xmath44 test vectors covering faults in the set @xmath45 , there must be a test vector that covers at least @xmath110 of the remaining faults , where @xmath111 is the size of the gate associated with fault @xmath112 .",
    "suppose this is false .",
    "by lemma  [ lemma : count2 ] every test vector covers exactly @xmath25 faults and a fault @xmath112 is covered by exactly @xmath113 input values .",
    "therefore the number of times faults in @xmath45 can be covered is @xmath114 and the current test set accounts for @xmath115 of these .",
    "furthermore , each of the remaining input vectors must cover more than @xmath116 of the already covered faults , otherwise our assertion would be true . combining these",
    "we have the following inequalities . @xmath117",
    "the second inequality is false since the right side can be no larger than @xmath25 .",
    "therefore , we have a contradiction , and our proposition must be true .    iteratively removing @xmath118 faults from the set of uncovered faults eventually leaves the set empty . the number of iterations needed to do this is an upper bound on the number of test vectors needed for completeness .",
    "the floor function in the equation makes it difficult to obtain a closed form for the bound , but we can weaken the above result to do this . to cover the first @xmath119 faults we need at most @xmath120 test vectors , since each test vector we add covers @xmath25 faults . to cover the next @xmath121 faults we need at most @xmath122 test vectors , and so on .",
    "thus , we can cover all single cell faults using no more than @xmath123 test vectors .",
    "@xmath22    for a reversible circuit on 64 wires with a million @xmath51 gates , parts a - c of proposition  [ prop : cf_bounds ] give upper bounds of approximately @xmath124 , @xmath125 and @xmath126 test vectors , respectively .",
    "however , since part c uses the property illustrated in equation  ( [ eqn : propc ] ) very conservatively in order to obtain a closed form , a much tighter bound can be obtained by applying this property directly .",
    "in fact , by iteratively applying this property , one can show that no more than @xmath127 test vectors are needed for complete testing .",
    "in general we can approximate this tighter bound if we assume that the number of faults covered after any given iteration when taken mod @xmath98 is uniformly distributed on the integers 0 through @xmath128 inclusively .",
    "the expected value of  ( [ eqn : propc ] ) is then @xmath129 = \\mbox{e}\\left[l -      \\left\\lfloor\\frac{\\left|f_c\\right|}{2^{k}}\\right\\rfloor\\right ] =       l-\\frac{\\left|f_c\\right|}{2^{k}}+\\frac{2^k-1}{2^{k+1}}\\ ] ] this then gives the following recursion on @xmath130 , the minimum number of faults that can be covered by @xmath3 test vectors : @xmath131 letting @xmath132 and @xmath133 , @xmath134 in order to cover all faults , @xmath130 must be greater than or equal to the total number of faults : @xmath135 on rearranging we have @xmath136 this result strongly suggests the number of test vectors needed for completeness under the cell fault model grows logarithmically in the number of gates , just as in the stuck - at fault case .",
    "@xmath137    to obtain an ilp formulation for the cell fault model only the constraints given in section  [ sec : ilp ] need to be modified . for each @xmath1 gate at each level we generate @xmath98 constraints , one for each of the possible inputs to the gate .",
    "the circuit decomposition method from section  [ subsec : circ_decomp ] as well as the test set compaction method in section  [ subsec : test_comp ] can be applied as in the stuck - at fault case .",
    "figure  [ fig : cf_test_size ] shows simulation results for the circuit decomposition algorithm under the cell fault model .",
    "the staircase graph represents the upper bound obtained by iterating  ( [ eqn : propc ] ) .",
    "the average size of the generated test set is generally below this bound .",
    "test set compaction results in the elimination of 4 - 5 test vectors on average , with more vectors eliminated for longer circuits and fewer for shorter ones .",
    "empirically , the algorithm requires half the execution time of the stuck - at fault case , with the exception of the 8-wire case for which we were unable to obtain results due to prohibitive execution times .",
    "we have considered the test set generation problem for reversible circuits , and shown that the property of reversibility fundamentally simplifies the problem . for example , a test set that detects all single stuck - at faults in a reversible circuit also detects all multiple faults .",
    "we have derived test set completeness conditions under both the stuck - at and cell fault models .",
    "we have then used these to find general test set constructions that implicitly yield upper bounds on the number of test vectors needed for completeness .",
    "one bound shows that the test set size increases at most logarithmically with the length of circuit , strengthening our assertion that reversible circuits are easier to test than conventional ones .",
    "we have also given a practical algorithm for finding complete test sets .",
    "our algorithm generates test sets that are approximately half the size of those produced by conventional atpg .",
    "in addition to the fault detection problem we have investigated here , we also plan to study fault diagnosis , that is , using test sets to localize faults . as with the detection problem",
    ", fault diagnosis may be easier for reversible circuits than for irreversible ones .",
    "finally , though we have focused on testing for classical reversible circuits , we also hope to extend our work to the quantum case .",
    "the latter is likely to be very different from the former : while fault - free classical circuits are deterministic , fault - free quantum ones are inherently probabilistic .",
    "thus , the goal for the quantum case may be to determine as efficiently as possible , and with a given degree of confidence , whether the circuit contains a fault or not . a step towards this goal may be to find a small set of test vectors that sufficiently exercises the internal gates in the circuit",
    ". our results for the cell fault model studied in section  [ sec : cell_fault ] may be particularly useful for this ."
  ],
  "abstract_text": [
    "<S> applications of reversible circuits can be found in the fields of low - power computation , cryptography , communications , digital signal processing , and the emerging field of quantum computation . furthermore , prototype circuits for low - power applications are already being fabricated in cmos . regardless of the eventual technology adopted , </S>",
    "<S> testing is sure to be an important component in any robust implementation .    </S>",
    "<S> we consider the test set generation problem . </S>",
    "<S> reversibility affects the testing problem in fundamental ways , making it significantly simpler than for the irreversible case . </S>",
    "<S> for example , we show that any test set that detects all single stuck - at faults in a reversible circuit also detects all multiple stuck - at faults . </S>",
    "<S> we present efficient test set constructions for the standard stuck - at fault model as well as the usually intractable cell - fault model . </S>",
    "<S> we also give a practical test set generation algorithm , based on an integer linear programming formulation , that yields test sets approximately half the size of those produced by conventional atpg . </S>"
  ]
}