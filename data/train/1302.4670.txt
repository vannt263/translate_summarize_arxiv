{
  "article_text": [
    "distributed data storage systems can encode and disperse information ( a message ) to multiple storage nodes ( or disks ) in the network such that a user can retrieve it by accessing only a subset of them .",
    "this kind of systems is able to provide superior reliability performance in the event of disk corruption or network congestion . in order to reduce the amount of storage redundancy required to guarantee such reliability performance ,",
    "erasure correction codes can be used instead of simple replication of the data .",
    "when the data is coded by an erasure code , data repair ( _ e.g. _ , due to node failure ) becomes more involved , because the information stored at a given node may not be directly available from any one the remaining storage nodes , but it can be nevertheless reconstructed since it is a function of the information stored at these nodes .",
    "one key issue that affects the system performance is the total amount of information that the remaining nodes need to transmit to the new node .",
    "consider a storage system which has a total of @xmath1 storage nodes , and the data can be reconstructed by accessing any @xmath2 of them .",
    "a failed node is repaired by requesting any @xmath3 of the remaining nodes to provide information , and then using the received information to construct a new data storage node .",
    "a naive approach is to let these helper nodes transmit sufficient data such that the underlying complete data can be reconstructed , and then the information that needs to be stored at the new node can be subsequently generated .",
    "this approach is however rather wasteful , since the data stored at the new node is only a fraction of the complete data .",
    "dimakis _ et al .",
    "_ in @xcite provided a theoretical framework , namely regenerating codes , to investigate the tradeoff between the amount of storage at each node ( _ i.e. , _ data storage ) and the amount of data transfer for repair ( _ i.e. , _ repair bandwidth ) .",
    "it was shown that for the case when the regenerated information at the new node only needs to fulfill the role of the failed node functionally ( _ i.e. _ , functional - repair ) , but not to replicate exactly the original information content at the failed node ( _ i.e. _ , exact - repair ) , the problem can be converted to an equivalent network multicast problem , and thus the celebrated network coding result @xcite can be applied . by way of this equivalence ,",
    "the optimal tradeoff between the storage and repair bandwidth was completely characterized in @xcite for functional - repair regenerating codes .",
    "the two important extreme cases of the optimal tradeoff , where the data storage is minimized and the repair bandwidth is minimized , are referred to minimum storage regenerating ( msr ) codes and minimum bandwidth regenerating ( mbr ) codes , respectively .",
    "the problem of functional - repair regenerating codes is well understood and constructions of such codes are available @xcite .",
    "the functional - repair framework implies that the repair rule and the decoding rule in the system may evolve over time , which incurs additional system overhead .",
    "furthermore , functional repair does not guarantee the data to be stored in systematic form , which is an important practical requirement to consider .",
    "in contrast , exact - repair regenerating codes do not have such disadvantages .",
    "the problem of exact - repair regenerating codes was investigated in @xcite , all of which address either the mbr case or the msr case .",
    "particularly , the optimal code constructions in @xcite and @xcite show that the more stringent exact - repair requirement does not incur any penalty for the mbr case ; the constructions in @xcite show that this is also true for the msr case .",
    "these results may lead to the impression that enforcing exact - repair never incurs any penalty compared to functional repair .",
    "however , the result in @xcite shows that this is not the case , and in fact a large portion of the optimal tradeoffs achievable by functional - repair codes can not be strictly achieved by exact - repair codes .",
    "codes achieving tradeoff other than the mbr or the msr points may be more suitable for a system employing exact - repair regenerating codes . from a practical point of view , codes achieving other tradeoff points may have lower complexity than using the time - sharing approach , because the msr point requires interference alignment , and it is known to be impossible for linear codes to achieve the msr point for some parameters without symbol extension @xcite . as such , it is important to find such codes with competitive performance and low complexity .",
    "however , it is in fact unknown whether there even exist codes that can achieve a storage - bandwidth tradeoff better than simply time - sharing between an mbr code and an msr code . in this work ,",
    "we provide a linear code construction based on the combination of two layers of erasure correction codes and combinatorial block designs , which is indeed able to achieve tradeoff points better than the time - sharing between an mbr code and an msr code .",
    "the two erasure correction codes are not independent , which must be jointly designed to satisfy certain full rank conditions to guarantee successful decoding . in this work we mainly focus on the case when @xmath4 , _ i.e. _ , when the repair requires the access to all the other storage nodes , however it can indeed to generalized to the case @xmath5 .",
    "the conceptually straightforward code construction we propose has the property that the nodes participating in the repair do not need to perform any computation , but can simply transmit certain stored information for the new node to synthesis and recover the lost information .",
    "the uncoded repair property is appealing in practice , since it reduces and almost completely eliminates the computation burden at the helper nodes .",
    "this property also holds in the constructions proposed in @xcite and @xcite .",
    "in fact our construction was partially inspired by and may be viewed as a generalization of these codes .",
    "another closely related work is @xcite , where repetition and erasure correction codes are combined to construct codes for the mbr point , and one of constructions indeed relies on steiner systems .",
    "the model in @xcite is however different from ours ( and that in @xcite ) , where the repair procedure only needs to guarantee the existence of one particular @xmath3-helper - node combination ( fix - access repair ) , instead of the more stringent requirement that the repair information can come from any @xmath3-helper - node combination ( random - access repair ) .",
    "though both models have their merits , we focus on the more stringent and thus more robust random - access repair model in this work .    the rest of the paper is organized as follows . in section [ sec : definition ] , a formal definition is given for the coding problem and several relevant existing results are reviewed .",
    "section [ sec : example ] provides an example to illustrate the structure of the proposed construction .",
    "section [ sec : dequalsnminus1 ] provides the general code construction in three progressive steps , and in section [ sec : performance ] the performance is analyzed .",
    "finally [ sec : conclusion ] concludes the paper .",
    "in this section , we first provide a formal definition of exact - repair regenerating codes . some existing results on regenerating codes , basics on maximum separable regenerating codes and block designs",
    "are also briefly reviewed .",
    "an @xmath6 exact - repair regenerating code is a storage system with a total of @xmath1 storage nodes ( disks ) , where any @xmath2 of them can be used to reconstruct the complete data , and furthermore to repair a lost disk , the new disk may access data from any @xmath3 of the remaining @xmath7 disks .",
    "let the total amount of raw data stored be @xmath8 units and let each storage site stores @xmath9 units of data , which implies that the redundancy of the system is @xmath10 . to repair a disk failure ( regenerate a new disk ) , each contributing disk transmits @xmath11 units of data to the new node , which results in a total of @xmath12 units of data transfer for repair .",
    "it is clear that the quantities @xmath9 and @xmath11 scale linearly with @xmath13 , because a code can simply be concatenated .",
    "for this reason we shall normalize them the other two quantities using @xmath11 @xmath14 and use them as the measure of performance from here on .",
    "formally , the problem can be defined as follows .",
    "the notation @xmath15 is used to denote the set @xmath16 , and without loss of generality we assume @xmath17 .",
    "an @xmath18 exact - repair regenerating code consists of a total of @xmath1 encoding function @xmath19 , a total of @xmath20 decoding functions @xmath21 , a total of @xmath22 repair encoding functions @xmath23 , and a total of @xmath24 repair decoding functions @xmath25 , where @xmath26 which map the message @xmath27 to @xmath1 pieces of coded information , @xmath28 which maps the @xmath2 pieces of coded information in a set @xmath29 to the original message , @xmath30 which maps a piece of coded information to an index that will be made available to the new node , and @xmath31 which maps @xmath3 of such indices from the helper nodes to reconstruct the information stored at the lost node .",
    "the functions must satisfy the data reconstruction conditions @xmath32 and the repair conditions @xmath33    a normalized pair @xmath34 is said to be achievable for @xmath6 regenerating if for any @xmath35 there exists an @xmath18 code such that @xmath36 and @xmath37    the quantity @xmath38 in the definition above is introduced to include the case when the storage - bandwidth tradeoff may be approached asymptotically , _",
    "e.g. _ , the case discussed in @xcite .",
    "it is sometimes insightful to consider the case when @xmath1 is large while @xmath39 and @xmath40 where @xmath41 and @xmath42 are fixed positive constant integers such that @xmath43 . for this purpose ,",
    "the following two quantities become relevant .",
    "an @xmath44-pair @xmath45 where @xmath46 is @xmath47-achievable if @xmath48 is achievable for @xmath49 regenerating .",
    "the collection of all @xmath47-achievable pairs is denoted as @xmath50 .",
    "the achievable redundancy - data - rate exponent region @xmath51 is the closure of @xmath52 .    in section [ sec : performance ]",
    ", we shall show that the proposed codes are able to achieve the entire exponent region @xmath51 , while time - sharing between the msr point and the mbr point can not .",
    ".[fig : cutset],width=377 ]    as mentioned earlier , the functional - repair regenerating coding problem can be converted to a multicast problem , and through this connection , a precise characterization of the optimal storage - bandwidth tradeoff was obtained in @xcite using cut - set analysis . since",
    "exact - repair is a more stringent requirement than functional - repair , this characterization provides an outer bound for exact - repair regenerating codes .",
    "[ theorem : cutset ] any exact - repair regenerating codes must satisfy the following condition @xmath53    one extreme case of this outer bound is when the storage is minimized , _",
    "i.e. _ , the minimum storage regenerating ( msr ) point , which is @xmath54 the other extreme case is when the repair bandwidth is minimized , _",
    "i.e. _ , the minimum bandwidth regenerating ( mbr ) point , which is @xmath55 both of these two extreme points are achievable @xcite also for the exact - repair case .",
    "the functional repair outer bound is however not tight in general , which implies that the exact - repair condition will indeed incur a penalty in many cases @xcite@xcite .",
    "the cut - set outer bound and the two extreme points are illustrated in fig .",
    "[ fig : cutset ] for @xmath56 ; note that the bound is piece - wise linear .",
    "the segment between the msr point and the origin @xmath57 is given by the trivial bound @xmath58 , and it is essentially a degenerate regime because to achieve this segment of tradeoff , we can simply utilize an msr code but let the helper nodes send more than necessary amount ( _ i.e. , _ more than @xmath11 units ) of data .",
    "a linear code of length-@xmath1 and dimension @xmath2 is called an @xmath59 code .",
    "the singleton bound ( see _ e.g. _ , @xcite ) is a well known upper bound on the minimum distance for any @xmath59 code .    the minimum distance @xmath60 for an @xmath59 code is bounded by @xmath61 .",
    "an @xmath59 code that satisfies the singleton bound with equality is called a maximum distance separable ( mds ) code .",
    "a key property of an mds code is that it can correct any @xmath62 or less erasures .",
    "there are many ways to find mds codes for any given @xmath59 values , @xmath63 .",
    "for example , any randomly generated @xmath64 matrix in a sufficiently large alphabet is a generator matrix for an mds code with high probability .",
    "any @xmath64 vandermonde matrix can also generate an mds code when the entries in the second column are all distinct .",
    "another explicit construction approach is by puncturing a reed - solomon code of an appropriate alphabet ( see _ e.g. _ , @xcite ) .",
    "block design has been considered in combinatorial mathematics with applications in experimental design , finite geometry , software testing , cryptography , and algebraic geometry . generally speaking ,",
    "a block design is a set together with a family of subsets ( _ i.e. _ , blocks ) whose members are chosen to satisfy some properties that are deemed useful for a particular application .",
    "usually the blocks are required to all have the same number of elements , and in this case a given block design with parameter @xmath59 is specified by @xmath65 where @xmath66 is an @xmath1-element set and @xmath67 is a collection of @xmath2-element subsets of @xmath66 .",
    "one important class of block designs is the @xmath0-designs .",
    "the class of @xmath0-designs with parameter @xmath68 is denoted as @xmath69 ; a valid @xmath0-design in @xmath69 is a pair @xmath65 where @xmath66 is @xmath1-element set and @xmath67 is a collection of @xmath70-element subsets of @xmath66 with the property that every element in @xmath66 appears in exactly @xmath71 blocks and every @xmath0-element subset of @xmath66 is contained in exactly @xmath72 blocks . without loss of generality , one can always use @xmath73 , and we shall use this convention from here on .",
    "the most extensively researched class of block designs is perhaps steiner systems , which is the case when @xmath74 and @xmath75 . in this case ,",
    "the subscript @xmath72 is usually omitted and we directly write it as @xmath76 .",
    "the simplest design in this class is when @xmath77 and @xmath78 , which is the particularly well understood steiner triple systems @xmath79 .",
    "it is known that there exists a steiner triple system @xmath79 if and only if @xmath80 , or @xmath1 modulo @xmath81 is @xmath82 or @xmath83 ; see , _",
    "e.g. _ , @xcite .",
    "it follows that the smallest positive integer which gives us a non - trivial steiner system is @xmath84 and the next is @xmath85 .",
    "examples of @xmath86 , @xmath87 are given in table [ table : steiner79 ] , where a design for @xmath88 is also included .",
    "another well - known special class of @xmath0-designs is balanced incomplete block designs ( bibds ) , which is a special case of @xmath0-designs for the case @xmath77 .",
    "it is clear that steiner systems @xmath79 are also bibds .",
    ".example steiner triple systems @xmath86 , @xmath87 and @xmath88 .",
    "[ cols=\"^,^\",options=\"header \" , ]     * repair : *    let us suppose the first disk fails . to regenerate , for example , symbol @xmath89 , first obtain @xmath90 and @xmath91 from disk-3 and disk-5 , respectively , and then compute @xmath92 .",
    "clearly , other symbols on the disk can also be repaired following a similar procedure .",
    "this procedure also applies to other disk failures .",
    "it can also be checked that for any disk failure , each remaining disk sends a single symbol during the repair , which is in fact guaranteed by the basic property of block designs in this case .",
    "* reconstruction : *    for data reconstruction , several different cases need to be considered . before going into the details of these cases , consider a scenario where disk @xmath82 and disk @xmath93 are not accessible .",
    "notice that although @xmath94 are not accessible directly , @xmath95 can be recovered using the symbols on other disks , as discussed in the repair procedure above ; thus parity groups @xmath96 are not effected . as a consequence ,",
    "only symbols in the @xmath97-th parity group can not be completely recovered , but even in this parity group , @xmath98 is still accessible on disk-@xmath81 .",
    "the reconstruction cases can be classified according to which parity group is effected ( _ i.e. _ , can not be completely recovered directly ) and which symbol within this parity group is still accessible .    1 .",
    "the @xmath99-th parity group , @xmath100 , is effected , but @xmath101 or @xmath102 is still accessible within it .",
    "an example case is when disk-@xmath83 and disk-@xmath103 are not accessible .",
    "note @xmath104 is still available in this case , and @xmath105 can be computed using @xmath106 after eliminating @xmath107 pairs for @xmath108 and @xmath109 , from which @xmath110 can be solved .",
    "the information vector can be obtained by rearranging the symbols .",
    "the @xmath99-th parity group , @xmath111 , is effected , but the parity symbol @xmath112 is still accessible within it .",
    "an example case is when disk-@xmath93 and disk-@xmath83 are not accessible . in this case",
    "@xmath107 pairs for @xmath113 can be recovered .",
    "in addition , @xmath114 and @xmath105 are available , from which @xmath110 can be solved .",
    "parity group @xmath115 is effected , but @xmath116 is still accessible .",
    "this case is trivial since all @xmath117 , @xmath118 have been directly recovered .",
    "parity group @xmath115 is effected , but @xmath119 is still accessible . in this case",
    "@xmath120 for @xmath121 can be recovered , and thus only @xmath109 needs to be recovered .",
    "but we have @xmath122 , from which @xmath109 can now be obtained .",
    "parity group @xmath115 is effected , but @xmath123 is still accessible . again",
    "@xmath107 pairs for @xmath121 can be recovered .",
    "additionally we have @xmath124 , from which @xmath109 can be obtained .",
    "let us compare this code with the time - sharing code using an mbr code and an msr code . for @xmath56 ,",
    "the msr point is @xmath125 and the mbr point is @xmath126 .",
    "our construction achieves @xmath127 , while the time sharing performance between the mbr point and the msr point at @xmath128 gives @xmath129 , thus the example construction indeed achieves an improvement on @xmath130 while keeping @xmath131 the same .",
    "this example illustrates the main components in the proposed construction , _",
    "i.e. _ , a block design , a first layer long mds code , and a second layer short mds code .",
    "the coefficients used in the two parity symbols of the two codes can not be set arbitrarily , for example , if we were to set @xmath132 , then in the second case discussed in the reconstruction procedure , a decoding failure would occur .",
    "the basic idea is to use the short mds code to recover as many data symbols as possible which will render most of the parity symbols in the short mds code redundant , and then use the remaining parity symbol in the short mds code together with the parity symbol in the long mds code to jointly solve the remaining unknown data symbol .",
    "in this section , we first describe an explicit code construction for @xmath133 code based on steiner system @xmath134 .",
    "this construction however only applies to the case when a steiner system exists for such @xmath1 , and as aforementioned , steiner systems may not exist for all @xmath135 pairs .",
    "then based on bibds @xmath136 , the method is generalized to the case any @xmath6 triples such that @xmath137 and @xmath4 .",
    "since a complete block design can be viewed as a special case of bibds , the construction applies to any value of positive integer @xmath1 .",
    "this construction can be further generalized to the case when @xmath5 , which will be discussed briefly .",
    "given a block design @xmath138 , the exact - repair regenerating code with parameters @xmath139 we shall construct has the following parameters @xmath140 where we have used @xmath141 to denote @xmath142 for notational simplicity .",
    "note that these parameters are all integers for a valid steiner system , moreover , @xmath143 is a multiple of @xmath144 , which can be seen using proposition [ theorem : numberofblocks ] and its corollary .",
    "the alphabet for this code can be chosen to be any finite field @xmath145 with a field size @xmath146 , and the addition and multiplication operations in the encoding and decoding process are performed in this field .",
    "let the @xmath8 information symbols in @xmath145 be given in a @xmath147 matrix except the bottom - right entry @xmath148 , which is left blank .",
    "the code has several components :    * encoding : *    1",
    ".   choose @xmath149 distinct non - zero elements @xmath150 in @xmath145 , which satisfy @xmath151 for @xmath152 .",
    "generate a parity symbol and assign it to @xmath148 as @xmath153 2 .",
    "for each column @xmath154 , generate new parity symbols as @xmath155 the collection @xmath156 will be referred to as the @xmath99-th parity group ; 3 .",
    "for each block @xmath157 , @xmath154 , distribute the symbols in the @xmath158-th parity group onto disk @xmath159 , one symbol onto each disk .",
    ".[fig : code1],width=377 ]    * repair : *    suppose disk-@xmath160 fails .",
    "in order to recover the symbols on this disk , find in @xmath67 all blocks @xmath161 such that @xmath162 .",
    "recall there are a total of @xmath9 such blocks , and let them be denoted as @xmath163 . for each of this block @xmath164 , @xmath165 , obtain the symbols in the parity group @xmath166 from the disks in the set @xmath167 , and recover the symbol in this parity group on disk-@xmath99 using the relation ( [ eqn : paritygroup ] ) .",
    "* reconstruction : *    several cases need to be considered , when two disks have failed :    1 .",
    "the @xmath99-th parity group loses two symbols which are the parity symbol @xmath112 and one data symbol @xmath168 , and the other parity groups each lose one symbol or less .",
    "this implies that the other parity groups can recover all its data using ( [ eqn : paritygroup ] ) , and thus only @xmath168 needs to be recovered .",
    "it can be obtained through @xmath148 , by eliminating in ( [ eqn : longmds ] ) the symbols in the other parity group , and then eliminating @xmath169 , @xmath170 .",
    "2 .   the @xmath99-th parity group loses two symbols which are two data symbols @xmath171 and @xmath172 , and the other parity groups each lose one symbol or less .",
    "other data symbols can be obtained as in the previous case , and only @xmath171 and @xmath172 need to be recovered . since @xmath148 is still available , by eliminating the symbols in the other parity group in ( [ eqn : longmds ] ) , and then eliminating @xmath169 , @xmath173 and @xmath174 , we obtain @xmath175 . by eliminating @xmath169 , @xmath173 and @xmath174 in ( [ eqn : paritygroup ] ) , we obtain @xmath176 . since @xmath177 and they are both non - zero , @xmath171 and @xmath172 can be solved using these two equations . 3 .",
    "parity group @xmath141 loses two symbols , which are the parity symbols @xmath148 and @xmath178 .",
    "this case is trivial since all data symbols have been directly recovered .",
    "parity group @xmath141 loses two symbols , which are the parity symbols @xmath178 and a data symbol @xmath179 , @xmath180 . by eliminating the symbols in the other parity group in @xmath148 using ( [ eqn : longmds ] ) , and then eliminating @xmath181 , @xmath170 , we obtain @xmath179 .",
    "parity group @xmath141 loses two symbols , which are the parity symbols @xmath148 and a data symbol @xmath179 , @xmath180 .",
    "note that @xmath182 is still available and @xmath183 by eliminating the symbols in the other parity group in @xmath178 and then eliminating @xmath181 , @xmath170 , we obtain @xmath184 for some @xmath180 , and since @xmath185 for such @xmath158 , @xmath179 can be correctly obtained .",
    "the code construction is illustrated in fig .",
    "[ fig : code1 ] . in the disk repair and data reconstruction procedure given above",
    ", we have inherently assumed that the following two facts hold :    * * fact one : * during the repair , each remaining disk contributes exactly one symbol ; * * fact two : * when two disks are not accessible , only one parity group has two inaccessible symbols , and the other parity groups each have only one symbol or less inaccessible symbol .",
    "these are indeed true by invoking the basic property of steiner system , more precisely , that any pair of elements in @xmath186 appears exactly in one of the blocks in @xmath67 .",
    "the long code in the construction is an @xmath187 systematic mds code whose parity symbol is specified by ( [ eqn : longmds ] ) , and the short code is a @xmath188 systematic mds code whose parity symbol is specified by ( [ eqn : paritygroup ] ) . it should be noted that the coefficients in forming the parity symbols are certainly not unique , and we have only given a convenient choice here . in many cases , the performance of codes is better than time - sharing between msr and mbr points , however , we leave the detailed analysis to the next section to avoid repetition .      in this subsection , we generalize the construction previously described to the setting of exact - repair regenerating codes for any positive integer @xmath1 , @xmath4 and any @xmath137 , based on bibds @xmath189 .",
    "the validity of the construction relies on application of the schwarz - zippel lemma , which is used to show that there exists a valid choice of long mds code when the alphabet is large than a given threshold .",
    "first fix a bibd @xmath190 , and again denote @xmath191 as @xmath141 . first define the quantity @xmath192 where @xmath193 and @xmath194 , then further define @xmath195 the relevance of this quantity will become clear shortly .",
    "when @xmath196 , the definition of bibds gives @xmath197 .",
    "the construction given in the previous subsection belongs to this case with @xmath198 . in general , the quantity is dependent on the particular block design , and does not appear to have an explicit formula , however , we shall discuss a bound on this quantity in the next section .",
    "the code we construct has the following parameters @xmath199 note that although @xmath9 is always an integer , @xmath200 is not necessarily a multiple of @xmath201 here , unlike in the previous construction .",
    "this implies that @xmath131 may not be an integer .",
    "let the @xmath8 information symbols in @xmath145 be given in a vector @xmath202 , and use it to fill the first @xmath8 entries in a @xmath147 matrix @xmath203 following the column - wise order , _",
    "i.e. _ , the first column ( top - down ) , and the second column , etc . ; the rest of the @xmath204-entries of the matrix are left blank .",
    "the code requires a matrix @xmath205 of size @xmath206 , whose entries are also in @xmath145 .",
    "the matrix @xmath205 is used to generate the parity symbols for the long mds code , and we shall specify the condition for @xmath205 shortly . *",
    "encoding : *    the encoding procedure is similar to the procedure given in the previous subsection , with the only difference being that we first compute the multiplication @xmath207 and then fill the rest of @xmath203 matrix using the resultant @xmath204 parity symbols in a column - wise manner .",
    ".[fig : code2],width=377 ]    * repair : *    the repair is precisely the same as the repair procedure given in the previous subsection .",
    "note that each remaining disk contributes exactly @xmath72 symbols , which is implied by the definition of @xmath136 .",
    "* reconstruction : *    let @xmath62 disks in the set @xmath29 be inaccessible , where @xmath208 . for each parity group @xmath154 , construct a length-@xmath70 vector @xmath209 as follows    *",
    "if @xmath210 : collect , and if necessary , compute using ( [ eqn : paritygroup ] ) , the symbols @xmath168 , @xmath211 ; let @xmath212 ; * if @xmath213 : collect the available symbols in this parity group , denoted as @xmath214 , assign @xmath215 to the @xmath216 positions of vector @xmath217 , and let the rest of @xmath217 be zeros .    finally let @xmath218^t$ ] , _ i.e. _ , concatenate the vectors @xmath217s .",
    "the entries of @xmath219 are linear combinations of @xmath202 .",
    "our claim is that by properly choosing @xmath205 , the vector @xmath202 can be reconstructed from @xmath219 for any possible set @xmath29 .",
    "this construction is illustrated in fig .",
    "[ fig : code2 ] , from which the difference and similarity from the construction given in the previous subsection is straightforward . for the case",
    "@xmath220 , the proposed construction is precisely the repair - by - transfer construction in @xcite . in this case , the parity symbol @xmath112 is a simple repetition , and the @xmath221 design is when @xmath222 in the trivial complete design .",
    "next we show that a matrix @xmath205 with the desired properties indeed exists .",
    "note that as long as the transfer matrix between @xmath219 and @xmath202 has rank @xmath8 , the information vector @xmath202 can be correctly reconstructed . to identify this matrix , first construct a template matrix @xmath223 of size @xmath224 as @xmath225^t$ ] , where @xmath226 is the identity matrix , and",
    "@xmath227 is the all one vector of length @xmath201 . for each @xmath154 , construct matrix @xmath228 of size @xmath224 as follows ,    * if @xmath210 , let @xmath228 be @xmath223 with the last row set to all zeros ; * if @xmath229 , then let the corresponding symbols in the @xmath158-th parity group stored on disks @xmath230 be @xmath231 . keep the rows @xmath216 in @xmath223 , and assign the other rows as all zeros , and let the resultant matrix be @xmath228 .",
    "finally form a matrix @xmath232 of size @xmath233 using matrix @xmath228s as the diagonal , _",
    "i.e. _ , @xmath234\\end{aligned}\\ ] ] clearly , we have @xmath235 where @xmath236^t$ ] .",
    "thus as long as @xmath237 has rank @xmath8 for each set @xmath238 such that @xmath194 , the information vector @xmath202 can be correctly decoded no matter which @xmath239 disks are inaccessible .",
    "we have the following proposition .    among the @xmath240 distinct assignments of @xmath205 , at most a fraction of @xmath241 may induce a matrix @xmath237 with rank less than @xmath8 for some @xmath238 such that @xmath194 .",
    "the proof is a direct application of the schwartz - zippel lemma in its counting form .",
    "for each @xmath238 such that @xmath194 , if we can show that the fraction of assignments resulting in @xmath242 is bounded by @xmath243 , then the bound given in the proposition is obtained by a simple union over all choices of @xmath29 . to show this ,",
    "first remove the all - zero rows in @xmath232 , and then remove the first @xmath244 rows in the remaining matrix , resulting in a matrix @xmath245 .",
    "note that @xmath246 is of size @xmath247 , and thus as long as @xmath246 has full rank , the matrix @xmath237 has rank @xmath8 .",
    "however , @xmath246 having full rank is equivalent to @xmath248 .",
    "since @xmath249 is a polynomial @xmath250 of the entries of @xmath205 , as long as @xmath250 is not identically zero , we can apply the schwartz - zippel lemma and conclude the proof .",
    "the polynomial @xmath250 is indeed not identically zero , which is proved in the appendix .    as a consequence of this proposition , when @xmath251 , there exists at least one valid choice of matrix @xmath205 ; in fact , when @xmath252 is sufficiently large , almost all the assignments of @xmath205 are valid .",
    "the problem of explicitly constructing the matrix @xmath205 is open , however it may not be as complex as it seems .",
    "one possible approach is to let @xmath205 be the parity portion of a systematic mds code generator matrix , and then check whether the full rank conditions are satisfied for each possible set @xmath238 with @xmath208 , which is a total of @xmath20 conditions .",
    "the code construction for exact - repair regenerating codes presented in the previous section can be generalized to the case @xmath5 , by using general @xmath0-design instead of bibds .",
    "the resulting codes may require different amounts of data contributions from disks during repair , and thus do not strictly belong to the class of codes defined in section [ sec : definition ] .",
    "for this reason , instead of considering per - disk rate @xmath11 during repair , we shall only consider total repair bandwidth @xmath71 here .",
    "a special class of code , based on complete block designs @xmath253 , can be made symmetric by time - sharing among different repair rate allocations , as shall be discussed shortly .",
    "given a particular @xmath0-design @xmath254 , we shall construct an exact - repair regenerating codes of parameter @xmath6 using @xmath65 , where @xmath255 and @xmath17 .",
    "similarly as in the last subsection , define the quantity @xmath256 where @xmath193 and @xmath194 , then further define @xmath195    the code we construct has the following parameters ( note instead of @xmath11 , here @xmath71 is given ) @xmath257",
    ".[fig : code3],width=377 ]",
    "the difference from the construction given in the last section is that instead of only one parity symbol , @xmath258 parity symbols @xmath259 are generated in the parity group @xmath99 , using a fixed systematic @xmath260 mds code ; see fig .",
    "[ fig : code3 ] .",
    "any symbol on a failed disk has a maximum of @xmath261 symbols from the same parity group that are not participating in the repair , however the @xmath260 mds code guarantees that this symbol can be recovered using the remaining at least @xmath262 symbols on the other disks .",
    "note that the amounts of data contributions from these disks are in general not symmetric , although there may be many choices to choose which symbols to use in the repair .",
    "similarly as in the previous case , it can be shown that there exists a matrix @xmath205 of size @xmath206 which guarantees correct decoding in a sufficiently large alphabet , and thus we omit the details to avoid repetition .",
    "one particularly interesting case is when the complete block design @xmath253 is used . in this case , although the data contributions from the disks during repair may not be symmetric , one can always time - share among different helper rate contribution allocations , due to the symmetry of the code .",
    "thus this time - sharing version of the codes based on complete block design indeed belongs to the class of codes defined in section [ sec : definition ] .",
    "in this section , we analyze the performance of the proposed codes more systematically . recall that the quantity @xmath204 includes an optimization problem , and it is block design dependent .",
    "thus in general @xmath263 of a particular code can not be explicitly evaluated . however , for the codes based on complete block designs , the performance can indeed be explicitly evaluated . moreover , for any given @xmath135 , a complete block design @xmath264 in fact offers the best performance among all possible bibds @xmath189 , in terms of the normalized measure @xmath34 , which is shown next .",
    "given an @xmath6 code @xmath265 constructed using @xmath0-design of @xmath266 , which achieves @xmath267 , and an @xmath6 code @xmath268 constructed using the complete design @xmath269 , which achieves @xmath270",
    ". then @xmath271 , with inequality holds if and only if in @xmath272 the quantity @xmath273 is uniform for all set @xmath238 with @xmath208 .",
    "the @xmath204 function on both @xmath266 and on the complete design @xmath269 need to be considered , and in order to distinguish them , we shall the latter as @xmath274 .",
    "consider the block design resulting from a permutation @xmath275 of the elements of @xmath15 , which also operates on the blocks in @xmath272 , and denoted the @xmath276 function on this permuted block design as @xmath277 , and the @xmath204 function on this permuted block design as @xmath278 .",
    "construct a new and larger block design by taking all the blocks resulting through the @xmath279 permutation of the design @xmath272 ; note that there might be repetition of the same blocks , which is allowed in this new design .",
    "we shall denote the @xmath276 function operating on this new design as @xmath280 , and the corresponding @xmath204 function as @xmath281 .",
    "this new compound design is apparently a complete block design where each block is repeated @xmath282 times , and thus @xmath283 however , since it is the combination of @xmath279 permutation of the block design @xmath272 , we also have @xmath284 thus @xmath285 , which when combined with ( [ eqn : n ] ) and ( [ eqn : performancegeneral ] ) , gives @xmath271 .",
    "clearly equality holds if and only if @xmath286 for all @xmath275 , which is equivalent to @xmath287 for all @xmath238 with @xmath208 .",
    "the proof is complete .",
    "although complete block designs provide the best @xmath34 among all the @xmath0-designs in the same class , other incomplete block designs may lead to simpler code , as illustrated in the following example .",
    "* example : * consider a code based on the complete block design @xmath288 , and thus @xmath289 . using the general code construction based on bibds , we have a @xmath290 exact - repair regenerating code with @xmath291 the @xmath205 matrix for the first layer code in this case is of size @xmath292 , _",
    "i.e. _ , @xmath293 parity symbols generated by @xmath294 information symbols .",
    "in contrast , in the example given in section [ sec : example ] , also a @xmath290 exact - repair regenerating code , has a first layer code with only a single parity symbol , generated by @xmath295 information symbols .",
    "note however both code achieve the same normalized measure @xmath296 .",
    "recall that @xmath253 can be used to construct codes with different @xmath2 values , where @xmath297 . with complete block designs , the value @xmath204 can be explicitly evaluated as follows using the symmetry @xmath298    it is clear that the code has a normalized @xmath131 as @xmath299 and a normalized @xmath130 as @xmath300 clearly for @xmath301 , we need @xmath302 . since at the msr point , @xmath303 , it is more meaningful to choose @xmath304 however , choosing @xmath70 greater than this value is also valid , which may yield codes that although not efficient in terms of @xmath305 , but nevertheless useful due to its simplicity .",
    ".[fig : example1],width=377 ]     parameters when @xmath306.[fig : example2 ] the dashed blue lines are the cut - set bounds , the dotted black lines are the time - sharing lines , and the red solid lines are the tradeoff achieved by the proposed codes . , width=566 ]    there does not seem to be any simplification for specific @xmath6 parameters .",
    "we provide a few examples to illustrate the performance of the code for various @xmath6 . in fig .",
    "[ fig : example1 ] , we plot the performance of the proposed codes for the case of @xmath56 , and for reference the cut - set bound and time - sharing line are also included .",
    "it can be seen that in addition to the code example given in section [ sec : example ] , there is one more parameter @xmath307 that yields a performance above the time - sharing line ; the proposed code also achieves the point @xmath308 , which is not surprising since in this case it reduces to the optimal construction in @xcite .",
    "the operating point @xmath309 is worth noting , because although it is not as good as the msr point @xmath310 , the penalty is surprisingly small .",
    "this suggests that the proposed codes may even be a good albeit not optimal choice to replace an msr code , particularly when such msr codes have high complexity .    in fig .",
    "[ fig : example2 ] we plot the performance of codes for different parameters @xmath311 when @xmath306 .",
    "it can be seen that when @xmath312 , the performance is the most competitive , and often superior to the time sharing line .",
    "as @xmath3 value decreases , the method become less effective in terms of its @xmath34 , and becomes worse than the time - sharing line . for the same @xmath3 value ,",
    "the code is most effective when @xmath2 is large , and becomes less so as @xmath2 value decreases .",
    "it should be noted that the lower left corner is the msr point , and in a wide range of parameters the proposed scheme in fact operates rather close to it , despite the simple coding structure .       and the exponent region achieved by time - sharing.[fig : asymptotics],width=377 ]    in this subsection ,",
    "we consider the asymptotic performance of the proposed codes when @xmath1 is large .",
    "recall the case under consideration is when @xmath39 and @xmath40 where @xmath41 and @xmath42 are fixed constant integers .",
    "we have the following theorem .",
    "let @xmath313 be the collections of @xmath314 pair such that @xmath315 then @xmath316 , and moreover , @xmath313 can be asymptotically achieved by the proposed code construction .",
    "we first show that @xmath317 by utilizing the cut - set bound in theorem [ theorem : cutset ] . for better clarify ,",
    "we shall write @xmath34 for a fixed @xmath1 explicitly as @xmath48 . first notice that the bound implies that for any integer @xmath318 $ ] @xmath319 taking @xmath320 gives @xmath321 which implies that @xmath322 and thus for any @xmath323 , @xmath324 . by taking @xmath325 , we have @xmath326 which implies that @xmath327 it follows that @xmath328 and thus @xmath329 for any @xmath323 . next rewrite ( [ eqn : boundrewrite ] )",
    "when as follows @xmath330 where the second inequality is due to ( [ eqn : takectobek ] ) .",
    "rearrange the right hand side of the above inequality to be a quadratic function in @xmath331 , we have @xmath332 when the following condition holds @xmath333 that is @xmath334 we can choose @xmath335 and arrive at the bound @xmath336 this implies that when ( [ eqn : errange ] ) is true , for any sufficiently large @xmath1 and any @xmath337 @xmath338 and thus @xmath339 when @xmath340 .",
    "this completes the converse proof .    for the forward proof",
    ", we shall first fix a quantity @xmath341 , and consider a sequence of code @xmath342 . from ( [ eqn : finalalpha ] ) , we get @xmath343    note that @xmath344 thus from ( [ eqn : finalm ] ) we have @xmath345 this implies that for any @xmath337 and sufficiently large @xmath1 , there exists a code using the proposed design such that @xmath346 .",
    "furthermore , we have @xmath347 which implies that for any @xmath337 and sufficiently large @xmath1 , there exists a code using the proposed design such that @xmath348 .",
    "because the region @xmath51 is a closed set , it follows that the pair @xmath349 is achievable for any @xmath350 , and thus the region @xmath351 is achievable for any @xmath352 .",
    "the case @xmath353 can be simply addressed by taking a sequence of @xmath354 such that @xmath355 ; the case of @xmath356 can be addressed similarly .",
    "the regions when @xmath357 and @xmath358 are degenerate and they are easily shown achievable either by increasing unnecessarily the redundancy in the code , or increasing unnecessarily the amount of repair bandwidth .",
    "the proof is thus complete .    for comparison ,",
    "let us consider the time - sharing scheme between an msr and an mbr code .",
    "note that the msr point corresponds to @xmath359 and mbr point corresponds to @xmath356 .",
    "for a code using a time - sharing weight @xmath360 , the rate can be bounded as @xmath361 and the redundancy can be bounded as @xmath362 for any sequence of such a time - sharing codes index by @xmath1 , we have @xmath363 which implies that for any @xmath337 and sufficiently large @xmath1 , @xmath364 and it follows that @xmath365 when @xmath340 . using ( [ eqn : m1 ] ) and ( [ eqn : m2 ] ) , we can also write @xmath366 which implies that when @xmath367 , we must have @xmath368 using the time - sharing strategy",
    ". see fig .",
    "[ fig : asymptotics ] for an illustration of this region .",
    "the gap between @xmath51 and the time - sharing scheme shows that the improvement of our proposed codes over the time - sharing scheme increases with @xmath1 , and it can be unbounded .",
    "a new construction for @xmath6 exact - repair regenerating codes is proposed by combining two layers of error correction codes together with combinatorial block designs .",
    "the resultant codes have the desirable uncoded repair property where the nodes participating in the repair simply send certain stored data without performing any computation . we show that the proposed code is able to achieve performance better than the time - sharing between an msr code and an mbr code for some parameters . for the case of @xmath4 and @xmath369 , an explicit construction is given in a finite field @xmath145 where @xmath252 is greater or equal to the block size in the combinatorial block designs .",
    "for more general @xmath370 parameters , we show that there exist systematic linear codes in a sufficiently large finite field .    in this appendix , we prove @xmath249 , as a function of the entries of the matrix @xmath205 , is not identically zero . for this purpose",
    ", we shall revisit the matrix @xmath232 .",
    "set the first @xmath244 non - zero rows in @xmath232 to be all zeros , and denote the resulting matrix as @xmath371 ; let us omit the subscript @xmath29 from here on for simplicity .",
    "if there exists an assignment of @xmath205 such that @xmath372 has rank @xmath8 , then clearly @xmath373 , since @xmath374 is simply @xmath375 without the all - zero rows .    recall the matrix @xmath375 is of size @xmath376 with @xmath8 non - zero rows , and the matrix @xmath377 is of size @xmath378 , where @xmath379 .",
    "let the quotient and the remainder of @xmath8 divided by @xmath149 be @xmath380 and @xmath381 , respectively , _",
    "i.e. _ , @xmath382 .",
    "let us partition the matrix @xmath375 into four sub - matrices as @xmath383=\\left[\\begin{array}{cc}q_{11}&0\\\\ q_{21}&q_{22}\\end{array}\\right]\\end{aligned}\\ ] ] where @xmath384 is of size @xmath385 , which implies @xmath386 is an all - zero matrix .",
    "it follows that @xmath387\\cdot \\left[\\begin{array}{c}i\\\\s\\end{array}\\right]=\\left[\\begin{array}{c}q_{11}\\\\q_{21}+q_{22}\\cdot s\\end{array}\\right].\\end{aligned}\\ ] ] in order to show @xmath372 has rank @xmath8 , our plan is to specify an auxiliary matrix @xmath388 , which satisfies the following two conditions .",
    "we start by first assuming that there exists at least one all - zero row in the bottom @xmath391 rows of @xmath392 ; the other case will be addressed shortly .",
    "a set of @xmath393 intermediate matrics @xmath394 shall be constructed as follows . for @xmath395 , find the all - zero rows in @xmath228 , and denote the indices as @xmath396 ; if @xmath397 , then the matrix @xmath398 is of size @xmath399 , where the @xmath158-th row has all zeros except the @xmath400 position , which is assigned @xmath82 . for @xmath401 ,",
    "find the all - zero rows in the first @xmath381 rows of @xmath392 , denote the indices as @xmath402 ; the matrix @xmath403 is of size @xmath404 , where the @xmath158-th row has all zeros except the @xmath405 position , which is assigned @xmath82 .",
    "the matrix @xmath388 , which has the same size as @xmath406 , if formed by first assigning all zeros to the rows that are all zeros in @xmath407 $ ] , then assign the rows of @xmath394 into the remaining rows of @xmath388 in any order .",
    "we have inherently assumed above that the total number of rows in @xmath394 is the same as the number of rows in @xmath407 $ ] that have non - zero entries .",
    "this is indeed true because the former together with the number of rows in @xmath408 $ ] that are have non - zero entries totals to @xmath8 , while the latter also satisfies this relation .    to see that condition",
    "one holds , notice that in matrix @xmath388 , by exchanging the rows @xmath409 in @xmath384 ( _ i.e. _ , the rows corresponding to the first @xmath410 all - zero rows in @xmath228 ) and the rows of @xmath411 , each block matrix @xmath228 can have rank @xmath201 ; by similar operation , the top @xmath381 rows of matrix @xmath392 is an identity matrix . due to the block diagonal structure of the matrix @xmath384",
    ", this indeed implies that the matrix @xmath389 $ ] has rank @xmath412 .    to see that condition two also holds , we solve for @xmath205 block by block .",
    "first consider the block @xmath413 in @xmath414 , and assume @xmath415 . due to the block structure of @xmath414 ,",
    "the determination of the last @xmath149 rows of @xmath205 only depends on @xmath413 and the last @xmath70 rows of @xmath388 , but not any other entries in @xmath375 and @xmath388 .",
    "let us denote the sub - matrix consisting of the last @xmath201 rows of @xmath205 as @xmath416 , and denote the sub - matrix consisting of the last @xmath70 rows of @xmath388 as @xmath417 .",
    "the problem essentially reduces to finding a solution for @xmath418 .",
    "denote the indices of the rows which have non - zero entries in @xmath413 as @xmath419 , then the column span of @xmath413 is the space spanned by columns with a single @xmath82 at the @xmath419 positions ; this further relies on the structure of @xmath413 and the fact that there is at least one all - zero row in it .",
    "it follows that the column span of @xmath417 is in the column span of @xmath413 , and thus there indeed exists a solution for @xmath416 .",
    "repeat this process for the other blocks , as well as the partial block of @xmath392 in @xmath414 , a solution for @xmath205 is found .",
    "the case that there exists no all - zero row in the bottom @xmath391 rows of @xmath392 introduce the complication that for the partial block of @xmath392 in @xmath414 , because in this case its column span is one - dimension less than the space spanned by columns with a single @xmath82 at the desired positions .",
    "however , the only change required is the following : the @xmath420-th row of @xmath388 is chosen to be the summation of its first @xmath421 rows and the @xmath420-th row of @xmath422 .",
    "it is straightforward to check that both condition one and condition two can still be made to hold for this case .",
    "the proof is complete .",
    "n. b. shah , k. v. rashmi , p. v. kumar and k. ramchandran , distributed storage codes with repair - by - transfer and non - achievability of interior points on the storage - bandwidth tradeoff , , vol .",
    "1837 - 1852 , mar .",
    "n. b. shah , k. v. rashmi , p. v. kumar and k. ramchandran , interference alignment in regenerating codes for distributed storage : necessity and code constructions , , vol .",
    "4 , pp . 2134 - 2158 , apr .",
    "k. v. rashmi , n. b. shah , and p. v. kumar , optimal exact - regenerating codes for distributed storage at the msr and mbr points via a product - matrix construction , , vol .",
    "57 , no . 8 , pp .",
    "5227 - 5239 , aug .",
    "v. cadambe , s. jafar , h. maleki , k. ramchandran and c. suh , asymptotic interference alignment for optimal repair of mds codes in distributed storage , preprint , submitted to , _ ieee transactions on information theory _ , sep .",
    "2011 .",
    "s. el rouayheb and k. ramchandran , fractional repetition codes for repair in distributed storage systems , in proceedings _ 48th annual allerton conference on communication , control and computation _ , monticello , sep ."
  ],
  "abstract_text": [
    "<S> a new class of exact - repair regenerating codes is constructed by combining two layers of erasure correction codes together with combinatorial block designs , _ e.g. _ , steiner systems , balanced incomplete block designs and @xmath0-designs . </S>",
    "<S> the proposed codes have the uncoded repair property where the nodes participating in the repair simply transfer part of the stored data directly , without performing any computation . </S>",
    "<S> the layered error correction structure makes the decoding process rather straightforward , and in general the complexity is low . </S>",
    "<S> we show that this construction is able to achieve performance better than time - sharing between the minimum storage regenerating codes and the minimum repair - bandwidth regenerating codes . </S>"
  ]
}