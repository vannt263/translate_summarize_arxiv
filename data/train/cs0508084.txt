{
  "article_text": [
    "is well known that huffman coding  @xcite yields a prefix code minimizing expected length for a known finite probability mass function .",
    "less well known are the many variants of this algorithm that have been proposed for related problems@xcite .",
    "for example , in his doctoral dissertation , humblet discussed two problems in queueing that have nonlinear terms to minimize@xcite .",
    "these problems , and many others , can be reduced to a certain family of generalizations of the huffman problem introduced by campbell in @xcite .    in all such source coding problems",
    ", a source emits symbols drawn from the alphabet @xmath6 , where @xmath7 is an integer ( or possibly infinity ) .",
    "symbol @xmath3 has probability @xmath4 , thus defining probability mass function  @xmath8 .",
    "we assume without loss of generality that @xmath9 for every @xmath10 , and that @xmath11 for every @xmath12 ( @xmath13 ) .",
    "the source symbols are coded into codewords composed of symbols of the @xmath14-ary alphabet @xmath15 , most often the binary alphabet , @xmath16",
    ". the codeword @xmath17 corresponding to symbol @xmath3 has length @xmath18 , thus defining length distribution @xmath19 .",
    "finding values for @xmath19 is sufficient to find a corresponding code .",
    "huffman coding minimizes @xmath20 .",
    "campbell s formulation adds a continuous ( strictly ) monotonic increasing _ _ cost function @xmath21 . the value to minimize is then @xmath22 campbell called ( [ campcost ] )",
    "the `` mean length for the cost function @xmath5 '' ; for brevity , we refer to it , or any value to minimize , as the _ _ penalty .",
    "penalties of the form ( [ campcost ] ) are called _ _ quasiarithmetic or _ _ quasilinear ; we use the former term in order to avoid confusion with the more common use of the latter term in convex optimization theory .    note",
    "that such problems can be mathematically described if we make the natural coding constraints explicit : the integer constraint , @xmath23 , and the kraft ( mcmillan ) inequality  @xcite , @xmath24    given these constraints , examples of @xmath5 in ( [ campcost ] ) include a quadratic cost function useful in minimizing delay due to queueing and transmission , @xmath25 for nonnegative @xmath26 and @xmath27@xcite , and an exponential cost function useful in minimizing probability of buffer overflow , @xmath28 for positive @xmath29@xcite .",
    "these and other examples are reviewed in the next section .",
    "campbell noted certain properties for convex @xmath5 , such as those examples above , and others for concave @xmath5 .",
    "strictly concave @xmath5 penalize shorter codewords more harshly than the linear function and penalize longer codewords less harshly .",
    "conversely , strictly convex @xmath5 penalize longer codewords more harshly than the linear function and penalize shorter codewords less harshly .",
    "convex @xmath5 need not yield convex @xmath30 , although @xmath31 is clearly convex if and only if @xmath5 is .",
    "note that one can map decreasing @xmath5 to a corresponding increasing function @xmath32 without changing the value of @xmath30 ( e.g. , for @xmath33 ) .",
    "thus the restriction to increasing @xmath5 can be trivially relaxed",
    ".    we can generalize @xmath30 by using a two - argument cost function @xmath34 instead of @xmath35 , as in ( [ cost ] ) , and adding @xmath36 to its range .",
    "we usually choose functions with the following property :    a cost function @xmath34 and its associated penalty @xmath37 are _ _ differentially monotonic if , for every @xmath38 , whenever @xmath39 is finite and @xmath40 , @xmath41 .",
    "[ difmon ]    this property means that the contribution to the penalty of an @xmath42th bit in a codeword will be greater if the corresponding event is more likely .",
    "clearly any @xmath43 will be differentially monotonic .",
    "this restriction on the generalization will aid in finding algorithms for coding such cost functions , which we denote as _ _ generalized quasiarithmetic penalties :    let @xmath44 \\rightarrow \\rp \\cup \\{\\infty\\}$ ] be a function nondecreasing in @xmath42 .",
    "then @xmath45 is called a _ _ generalized quasiarithmetic penalty .",
    "further , if @xmath46 is convex in @xmath42 , it is called a _ _ generalized quasiarithmetic convex penalty .",
    "as indicated , quasiarithmetic penalties  mapped with @xmath5 using @xmath47 to @xmath48  are differentially monotonic , and thus can be considered a special case of differentially monotonic generalized quasiarithmetic penalties .    in this paper , we seek properties of and algorithms for solving problems of this form , occasionally with some restrictions ( e.g. , to convexity of @xmath5 ) . in the next section ,",
    "we provide examples of the problem in question . in section  [ props ] , we investigate campbell s quasiarithmetic penalties , expanding beyond campbell s properties for a certain class of @xmath5 that we call _ _ subtranslatory .",
    "this will extend properties  entropy bounds , existence of optimal codes  previously known only for linear @xmath5 and , in the case of entropy bounds , for @xmath5 of the exponential form @xmath28 .",
    "these properties pertain both to finite and infinite input alphabets , and some are applicable beyond subtranslatory penalties .",
    "we then turn to algorithms for finding an optimal code for finite alphabets in section  [ alg ] ; we start by presenting and extending an alternative to code tree notation , nodeset notation , originally introduced in @xcite . along with the coin collector s problem",
    ", this notation can aid in solving coding problems with generalized quasiarithmetic convex penalties .",
    "we explain , prove , and refine the resulting algorithm , which is @xmath49 time and @xmath50 space when minimizing for a differentially monotonic generalized quasiarithmetic penalty ; the algorithm can be extended to other penalties with a like or slightly greater complexity .",
    "this is an improvement , for example , on a result of larmore , who in @xcite presented an @xmath51-time @xmath51-space algorithm for cost function ( [ quadratic ] ) in order to optimize a more complicated penalty related to communications delay .",
    "our result thus improves overall performance for the quadratic problem and offers an efficient solution for the more general convex quasiarithmetic problem .",
    "conclusions are presented in section  [ conclusion ] .",
    "the additive convex coding problem considered here is quite broad .",
    "examples include @xmath52 for @xmath53 , the moment penalty ; see , e.g. , @xcite .",
    "although efficient solutions have been given for @xmath54 ( the huffman case ) and @xmath55 ( the quadratic moment ) , no polynomial - time algorithms have been proposed for the general case .",
    "the quadratic moment was considered by larmore in @xcite as a special case of the quadratic problem ( [ quadratic ] ) , which is perhaps the case of greatest relevance . restating this problem in terms of @xmath46 , @xmath56 this",
    "was solved with cubic space and time complexity as a step in solving a problem related to message delay .",
    "this larger problem , treated first by humblet@xcite then flores@xcite , was solved with an @xmath57-time @xmath51-space algorithm that can be altered to become an @xmath58-time @xmath49-space algorithm using methods in this paper .",
    "another quasiarithmetic penalty is the exponential penalty , that brought about by the cost function @xmath59 for @xmath60 , @xmath14 being the size of the output alphabet .",
    "this was previously proposed by campbell@xcite and algorithmically solved as an extension of huffman s algorithm ( and thus with linear time and space for sorted probability inputs ) in @xcite .",
    "as previously indicated , in @xcite this is a step in minimizing the probability of buffer overflow in a queueing system .",
    "thus the quasiarithmetic framework includes the two queueing - related source coding problems discussed in @xcite .",
    "a related problem is that with the concave cost function @xmath61 for @xmath62 , which has a similar solution@xcite .",
    "this problem relates to a problem in @xcite which is based on a scenario presented by rnyi in @xcite .",
    "whereas all of the above , being continuous in @xmath2 and linear in  @xmath4 , are within the class of cases considered by campbell , the following convex problem is not , in that its range includes infinity .",
    "suppose we want the best code possible with the constraint that all codes must fit into a structure with @xmath63 symbols . if our measure of the `` best code '' is linear , then the appropriate penalty is @xmath64 for some fixed @xmath65 .",
    "this describes the length - limited linear penalty , algorithmically solved efficiently using the package - merge algorithm in @xcite ( with the assumption that @xmath66 ) .",
    "this approach will be a special case of our coding algorithm .",
    "note that if the measure of a `` best code '' is nonlinear , a combination of penalties should be used where length is limited .",
    "for example , if we wish to minimize the probability of buffer overflow in a queueing system with a limited length constraint , we should combine  ( [ expon ] ) and  ( [ llhuff ] ) : @xmath67 this problem can be solved via dynamic programming in a manner similar to @xcite , but this approach takes @xmath68 time and @xmath69 space for @xmath70 and greater complexity for @xmath71 @xcite .",
    "our approach improves on this considerably .",
    "in addition to the above problems with previously known applications  and penalties which result from combining these problems  one might want to solve for a different utility function in order to find a compromise among these applications or another trade - off of codeword lengths .",
    "these functions need not be like campbell s in that they need not be linear in @xmath72 ; for example , consider @xmath73 although the author knows of no use for this particular cost function , it is notable as corresponding to one of the simplest convex - cost penalties of the form ( [ cost ] ) .",
    "campbell s quasiarithmetic penalty formulation can be restated as follows : @xmath74 in the case of linear @xmath5 , the integer constraint is often removed to obtain bounds related to entropy , as we do in the nonlinear case : @xmath75 note that , given @xmath8 and @xmath5 , @xmath76 , the minimum for the relaxed ( real - valued ) problem ( [ ideal ] ) , will necessarily be less than or equal to @xmath77 , the minimum for the original ( integer - constrained ) problem ( [ arith ] ) .",
    "let @xmath78 and @xmath79 be corresponding minimizing values for the relaxed and constrained problems , respectively . restating , and adding a fifth definition : @xmath80 this is a slight abuse of @xmath81 notation since @xmath77 could have multiple corresponding optimal length distributions ( @xmath79 ) .",
    "however , this is not a problem , as any such value will suffice .",
    "note too that @xmath82 satisfies the kraft inequality and the integer constraint , and thus @xmath83 .",
    "we obtain bounds for the optimal solution by noting that , since @xmath5 is monotonically increasing , @xmath84    these bounds are similar to shannon redundancy bounds for huffman coding . in the linear / shannon case , @xmath85 , so the last expression is @xmath86 , where @xmath87 is the shannon entropy , so @xmath88 .",
    "these shannon bounds can be extended to quasiarithmetic problems by first defining @xmath5-entropy as follows :    _ _ generalized entropy or _ _ @xmath5-entropy is @xmath89 where here infimum is used because this definition applies to codes with infinite , as well as finite , input alphabets@xcite .",
    "campbell defined this as a generalized entropy @xcite ; we go further , by asking which cost functions , @xmath5 , have the following property : @xmath90    these bounds exist for the exponential case ( [ expon ] ) with @xmath91 , where @xmath92 , and @xmath93 denotes rnyi @xmath26-entropy@xcite .",
    "the bounds extend to exponential costs because they share with the linear costs ( and only those costs ) a property known as the _ _ translatory property , described by aczl@xcite , among others :    a cost function @xmath5 ( and its associated penalty ) is _ _ translatory if , for any @xmath94 , probability mass function  @xmath8 , and @xmath95 , @xmath96 where @xmath97 denotes adding @xmath98 to each @xmath2 in @xmath19 @xcite .",
    "we broaden the collection of penalty functions satisfying such bounds by replacing the translatory equality with an inequality , introducing the concept of a _ _ subtranslatory penalty :    a cost function @xmath5 ( and its associated penalty ) is _ _ subtranslatory if , for any @xmath94 , probability mass function @xmath8 , and @xmath95 , @xmath99    for such a penalty , ( [ fbound ] ) still holds .",
    "if @xmath5 obeys certain regularity requirements , then we can introduce a necessary and sufficient condition for it to be subtranslatory .",
    "suppose that the invertible function @xmath100 is real analytic over a relevant compact interval .",
    "we might choose this interval to be , for example , @xmath101 $ ] for some @xmath102 .",
    "( let @xmath103 to show the following argument is valid over all @xmath104 . )",
    "we assume @xmath105 is also real analytic ( with respect to interval @xmath106 ) .",
    "thus all derivatives of the function and its inverse are bounded .",
    "given real analytic cost function @xmath5 and its real analytic inverse @xmath105 , @xmath5 is subtranslatory if and only if , for all positive @xmath19 and all positive @xmath8 summing to  @xmath107 , @xmath108 where @xmath109 is the derivative of @xmath5 .",
    "first note that , since all values are positive , inequality ( [ transsuff ] ) is equivalent to @xmath110    we show that , when ( [ theq ] ) is true everywhere , @xmath5 is subtranslatory , and then we show the converse .",
    "let @xmath111 .",
    "using power expansions of the form @xmath112 on @xmath5 and @xmath105 , @xmath113 step ( a ) is due to ( [ theq ] ) , step ( b ) due to the power expansion on @xmath105 , step ( c ) due to the power expansion on @xmath5 , and step ( d ) due to the power expansion on @xmath105 ( where the bounded derivative of @xmath105 allows for the asymptotic term to be brought outside the function ) .",
    "next , evoke the above inequality @xmath114 times : @xmath115 taking @xmath116 , @xmath117 thus , the fact of ( [ transsuff ] ) is sufficient to know that the penalty is subtranslatory .    to prove the converse ,",
    "suppose @xmath118 for some valid @xmath19 and @xmath72 .",
    "because @xmath5 is analytic , continuity implies that there exist @xmath119 and @xmath120 such that @xmath121 for all @xmath122 .",
    "the chain of inequalities above reverse in this range with the additional multiplicative constant . thus ( [ phiphi ] ) becomes @xmath123 for @xmath124 , and ( [ epsineq ] ) becomes , for any @xmath125 , @xmath126 which , taking @xmath116 , similarly leads to @xmath127 and thus the subtranslatory property fails and the converse is proved .",
    "therefore , for @xmath5 satisfying ( [ transsuff ] ) , we have the bounds of ( [ fbound ] ) for the optimum solution .",
    "note that the right - hand side of ( [ transsuff ] ) may also be written @xmath128 ; thus ( [ transsuff ] ) indicates that the average derivative of @xmath5 at the codeword length values is at most the derivative of @xmath5 at the value of the penalty for those length values .",
    "the linear and exponential penalties satisfy these equivalent inequalities with equality .",
    "another family of cost functions that satisfies the subtranslatory property is @xmath129 for fixed @xmath53 , which corresponds to @xmath130 proving this involves noting that lyapunov s inequality for moments of a random variable yields @xmath131 which leads to @xmath132 which , because @xmath133 , is @xmath134 the inequality we desire .    another subtranslatory penalty is the quadratic quasiarithmetic penalty of ( [ quadratic ] ) , in which @xmath135 for @xmath136 .",
    "this has already been shown for @xmath137 ; when @xmath138 , @xmath139 we achieve the desired inequality through algebra : @xmath140 we thus have an important property that holds for several cases of interest .    one might be tempted to conclude that every @xmath5  or every convex and/or concave @xmath5  is subtranslatory .",
    "however , this is easily disproved .",
    "consider convex @xmath141 .",
    "using cardano s formula , it is easily seen that ( [ transsuff ] ) does not hold for @xmath142 and @xmath143 .",
    "the subtranslatory test also fails for @xmath144 .",
    "thus we must test any given penalty for the subtranslatory property in order to use the redundancy bounds .      because all costs are positive",
    ", the redundancy bounds that are a result of a subtranslatory penalty extend to infinite alphabet codes in a straightforward manner .",
    "these bounds thus show that a code with finite penalty exists if and only if the generalized entropy is finite , a property we extend to nonsubtranslatory penalties in the next subsection .",
    "however , one must be careful regarding the meaning of an `` optimal code '' when there are an infinite number of possible codes satisfying the kraft inequality with equality .",
    "must there exist an optimal code , or can there be an infinite sequence of codes of decreasing penalty without a code achieving the limit penalty value ?    fortunately , the answer is the former , as the existence results of linder , tarokh , and zeger in @xcite can be extended to quasiarithmetic penalties .",
    "consider continuous strictly monotonic @xmath145 ( as proposed by campbell ) and @xmath146 such that @xmath147 is finite .",
    "consider , for an arbitrary @xmath148 , optimizing for @xmath5 with weights @xmath149 ( we call the entries to this distribution `` weights '' because they do not necessarily add up to @xmath107 . ) denote the optimal code a _",
    "_ truncated code , one with codeword lengths @xmath150 thus , for convenience , @xmath151 for @xmath12 .",
    "these lengths are also optimal for @xmath152 , the distribution of normalized weights .",
    "following @xcite , we say that a sequence of codeword length distributions @xmath153 _ _ converges to an infinite prefix code with codeword lengths @xmath154 if , for each @xmath3 , the @xmath3th length in each distribution in the sequence is eventually @xmath2 ( i.e. , if each sequence converges to @xmath2 ) .",
    "given quasiarithmetic increasing @xmath5 and @xmath8 such that @xmath155 is finite , the following hold :    1 .",
    "there exists a sequence of truncated codeword lengths that converges to optimal codeword lengths for @xmath8 ; thus the infimum is achievable .",
    "2 .   any optimal code for @xmath8 must satisfy the kraft inequality with equality .",
    "because here we are concerned only with cases in which the first length is at least @xmath107 , we may restrict ourselves to the domain @xmath156 .",
    "recall @xmath157    then there exists near - optimal @xmath158 such that @xmath159 and thus , for any integer @xmath7 , @xmath160",
    "so , using this to approximate the behavior of a minimizing @xmath161 , we have @xmath162 yielding an upper bound on terms @xmath163 for all @xmath164 .",
    "this implies @xmath165    thus , for any @xmath166 , the sequence @xmath167 is bounded for all @xmath168 , and thus has a finite set of values ( including @xmath169 ) .",
    "it is shown in @xcite that this sufficies for the desired convergence , but for completeness a slightly altered proof follows .",
    "because each sequence @xmath170 has a finite set of values , every infinite indexed subsequence for a given @xmath3 has a convergent subsequence .",
    "an inductive argument implies that , for any @xmath171 , there exists a subsequence indexed by @xmath172 such that @xmath173 converges for all @xmath174 , where @xmath175 is a subsequence of @xmath176 for @xmath177 .",
    "codeword length distributions @xmath178 ( which we call @xmath179 ) thus converge to the codeword lengths of an infinite code @xmath180 with codeword lengths @xmath181 .",
    "clearly each codeword length distribution satisfies the kraft inequality .",
    "the limit does as well then ; were it exceeded , we could find @xmath182 such that @xmath183 and thus @xmath184 such that @xmath185 causing a contradiction .",
    "we now show that @xmath180 is optimal .",
    "let @xmath186 be the codeword lengths of an arbitrary prefix code .",
    "for every @xmath171 , there is a @xmath187 such that @xmath188 for any @xmath174 if @xmath189 . due to the optimality of each @xmath161 , for all @xmath189 : @xmath190 and , taking @xmath191 , @xmath192 , leading directly to @xmath193 and the optimality of @xmath180 .",
    "suppose the kraft inequality is not satisfied with equality for optimal codeword lengths @xmath194 .",
    "we can then produce a strictly superior code .",
    "there is a @xmath195 such that @xmath196 .",
    "consider code @xmath197 .",
    "this code satisfies the kraft inequality and has penalty @xmath198 .",
    "thus @xmath199 is not optimal .",
    "therefore the kraft inequality must be satisfied with equality for optimal infinite codes .",
    "note that this theorem holds not just for subtranslatory penalties , but for any quasiarithmetic penalty .",
    "recall the definition of ( [ entropy ] ) , @xmath200 for @xmath100 .",
    "if @xmath201 is finite and either @xmath5 is subtranslatory or @xmath202 ( which includes all concave and all polynomial @xmath5 ) , then the coding problem of ( [ ccstar ] ) , @xmath203 has a minimizing @xmath79 resulting in a finite value for @xmath204 .    if @xmath5 is subtranslatory , then @xmath205 . if @xmath202 , then there are @xmath206 such that @xmath207 for all @xmath208 .",
    "then @xmath209 so @xmath210 and the infimum , which we know to also be a minimum , is finite .",
    "we now examine algorithms for finding minimum penalty codes for convex cases with finite alphabets .",
    "we first present a notation for codes based on an approach of larmore @xcite .",
    "this notation is an alternative to the well known code tree notation , e.g. , @xcite , and it will be the basis for an algorithm to solve the generalized quasiarithmetic ( and thus campbell s quasiarithmetic ) convex coding problem .    in the literature nodeset notation is generally used for binary alphabets , not for general alphabet coding . although we briefly sketch how to adapt this technique to general output alphabet coding at the end of subsection  [ refine ] , an approach fully explained in @xcite , until then we concentrate on the binary case ( @xmath211 ) .",
    "_ the key idea : _ each node @xmath212 represents both the share of the penalty @xmath213 ( weight ) and the share of the kraft sum @xmath214 ( width ) assumed for the @xmath42th bit of the @xmath3th codeword .",
    "if we show that total weight is an increasing function of the penalty and show a one - to - one correspondence between optimal nodesets and optimal codes , we can reduce the problem to an efficiently solvable problem , the coin collector s problem .    in order to do this ,",
    "we first assume bounds on the maximum codeword length of possible solutions , e.g. , the maximum unary codeword length of @xmath215 .",
    "alternatively , bounds might be explicit in the definition of the problem .",
    "consider for example the length - limited coding problems of ( [ llhuff ] ) and ( [ expll ] ) , upper bounded by @xmath63 .",
    "a third possibility is that maximum length may be implicit in some property of the set of optimal solutions@xcite ; we explore this in subsection  [ refine ] .",
    "we therefore restrict ourselves to codes with @xmath7 codewords , none of which has greater length than @xmath63 , where @xmath216 $ ] . with this",
    "we now introduce the _ _ nodeset notation for binary coding :    a _ _ node is an ordered pair of integers @xmath217 such that @xmath218 and @xmath219 .",
    "call the set of all @xmath220 possible nodes  @xmath221 .",
    "usually @xmath221 is arranged in a grid ; see example in fig .",
    "[ nodesetnum ] .",
    "the set of nodes , or _ _ nodeset , corresponding to item @xmath3 ( assigned codeword  @xmath17 with length  @xmath2 ) is the set of the first  @xmath2 nodes of column  @xmath3 , that is , @xmath222 .",
    "the nodeset corresponding to length distribution  @xmath19 is @xmath223 @xmath224 ; this corresponds to a set of @xmath7 codewords , a code .",
    "we say a node @xmath212 has _",
    "_ width @xmath225 and _ _ weight @xmath226 , as in the example in fig .",
    "[ nodesetnum ] .    if @xmath221 has a subset @xmath227 that is a valid nodeset , then it is straightforward to find the corresponding length distribution and thus a code .",
    "we can find an optimal valid nodeset using the coin collector s problem .",
    "let @xmath228 denote the set of all integer powers of two .",
    "the coin collector s problem of size @xmath229 considers @xmath229 `` coins '' with width @xmath230 ; one can think of width as coin face value , e.g. , @xmath231 for a quarter dollar ( 25 cents ) .",
    "each coin also has weight @xmath232 .",
    "the final problem parameter is total width , denoted @xmath29 .",
    "the problem is then : @xmath233 we thus wish to choose coins with total width @xmath29 such that their total weight is as small as possible .",
    "this problem is an input - restricted variant of the knapsack problem , which , in general , is np - hard ; no polynomial - time algorithms are known for such np - hard problems@xcite .",
    "however , given sorted inputs , a linear - time solution to ( [ knap ] ) was proposed in @xcite .",
    "the algorithm in question is called the _ _ package - merge algorithm .    in the appendix ,",
    "we illustrate and prove a slightly simplified version of the package - merge algorithm .",
    "this algorithm allows us to solve the generalized quasiarithmetic convex coding problem  ( [ cost ] ) .",
    "when we use this algorithm , we let @xmath234 represent the @xmath229 items along with their weights and widths .",
    "the optimal solution to the problem is a function of total width @xmath29 and items @xmath234 .",
    "we denote this solution as @xmath235 ( read , `` the [ optimal ] coin collection for @xmath234 and @xmath29 '' ) . note that , due to ties , this need not be unique , but we assume that one of the optimal solutions is chosen ; at the end of subsection  [ linear ] , we discuss which of the optimal solutions is best to choose .",
    "we now formalize the reduction from the generalized quasiarithmetic convex coding problem to the coin collector s problem .",
    "we assert that any optimal solution @xmath227 of the coin collector s problem for @xmath236 on coins @xmath237 is a nodeset for an optimal solution of the coding problem .",
    "this yields a suitable method for solving generalized quasiarithmetic convex penalties .    to show this reduction ,",
    "first define @xmath238 for any @xmath239 : @xmath240 because the kraft inequality is @xmath241 , @xmath238 must lie in @xmath242 for prefix codes .",
    "the kraft inequality is satisfied with equality at the left end of this interval .",
    "optimal binary codes have this equality satisfied , since a strict inequality implies that the longest codeword length can be shortened by one , strictly decreasing the penalty without violating the inequality .",
    "thus the optimal solution has @xmath243 .",
    "also define : @xmath244 note that @xmath245 @xmath246 is a constant given fixed penalty and probability distribution .",
    "thus , if the optimal nodeset corresponds to a valid code , solving the coin collector s problem solves this coding problem . to prove the reduction",
    ", we need to prove that the optimal nodeset indeed corresponds to a valid code .",
    "we begin with the following lemma :    [ lllemma ] suppose that @xmath227 is a nodeset of width @xmath247 where @xmath171 and @xmath208 are integers and @xmath248",
    ". then @xmath227 has a subset @xmath249 with width @xmath250 .",
    "we use induction on the cardinality of the set .",
    "the base case @xmath251 is trivial since then @xmath252 .",
    "assume the lemma holds for all @xmath253 , and suppose @xmath254 .",
    "let @xmath255 and @xmath256 .",
    "we can see @xmath257 as the smallest contribution to the width of @xmath258 and @xmath250 as the portion of the binary expansion of the width of @xmath258 to the right of @xmath259 .",
    "then clearly @xmath250 must be an integer multiple of @xmath257 . if @xmath260",
    ", @xmath261 is a solution . otherwise let @xmath262 ( so @xmath263 ) and let @xmath264 be the subset obtained from solving the lemma for set @xmath265 of width @xmath266",
    ". then @xmath267 .",
    "we are now able to prove the main theorem :    [ cceqll ] any @xmath227 that is a solution of the coin collector s problem for @xmath268 has a corresponding @xmath269 such that @xmath270 and @xmath271 .    by monotonicity of the penalty function ,",
    "any optimal solution satisfies the kraft inequality with equality .",
    "thus all optimal length distribution nodesets have @xmath272 .",
    "suppose @xmath227 is a solution to the coin collector s problem but is not a valid nodeset of a length distribution .",
    "then there exists an @xmath212 with @xmath38 such that @xmath273 and @xmath274 .",
    "let @xmath275 .",
    "then @xmath276 and , due to convexity , @xmath277 .",
    "thus , using lemma  [ lllemma ] with @xmath278 , @xmath279 , and @xmath280 , there exists an @xmath281 such that @xmath282 and @xmath283 .",
    "since we assumed @xmath227 to be an optimal solution of the coin collector s problem , this is a contradiction , and thus any optimal solution of the coin collector s problem corresponds to an optimal length distribution .",
    "note that the generality of this algorithm makes it trivially extensible to problems of the form @xmath284 for @xmath7 different functions @xmath285 .",
    "this might be applicable if we desire a nonlinear weighting for codewords  such as an additional utility weight  in addition to and possibly independent of codeword length and probability .",
    "because the coin collector s problem is linear in time and space , the overall algorithm finds an optimal code in @xmath286 time and space for any `` well - behaved '' @xmath287 , that is , any @xmath46 of the form specified for which same - width inputs would automatically be presorted by weight for the coin collector s problem .",
    "the complexity of the algorithm in terms of @xmath7 alone depends on the structure of both @xmath46 and  @xmath8 , because , if we can upper - bound the maximum length codeword , we can run the package - merge algorithm with fewer input nodes . in addition , if @xmath46 is not `` well - behaved , '' input to the package - merge algorithm might need to be sorted .    to quantify these behaviors , we introduce one definition and",
    "recall another :    a ( coding ) problem space is called a _ _ flat class if there exists a constant upper bound @xmath288 such that @xmath289 for any solution @xmath19 .",
    "for example , the space of linear huffman coding problems with all @xmath290 is a flat class .",
    "( this may be shown using @xcite . )",
    "recall definition  [ difmon ] given in section  [ intro ] : a cost function @xmath34 and its associated penalty @xmath37 are _ _ differentially monotonic or _ _ d.m .",
    "if , for every @xmath38 , whenever @xmath39 is finite and @xmath40 , @xmath41 .",
    "this implies that @xmath46 is continuous in  @xmath8 at all but a countable number of points . without loss of generality , we consider only cases in which it is continuous everywhere .",
    "if @xmath34 is differentially monotonic , then there is no need to sort the input nodes for the algorithm .",
    "otherwise , sorting occurs on @xmath63 rows with @xmath291 on each row , @xmath292 total .",
    "also , if the problem space is a flat class , @xmath63 is @xmath293 ; it is @xmath50 in general .",
    "thus time complexity for this solution ranges from @xmath291 to @xmath294 with space requirement @xmath291 to @xmath49 ; see table  [ complexity ] for details . as indicated in the table , space complexity can be reduced in differentially monotonic instances .    @xmath295      note that the length distribution returned by the algorithm need not have the property that @xmath296 whenever @xmath297 .",
    "for example , if @xmath298 , we are guaranteed no particular inequality relation between @xmath2 and @xmath299 since we did not specify a method for breaking ties . also ,",
    "even if all @xmath4 were distinct , there are cost functions for which we would expect the inequality relation reversed from the linear case .",
    "an example of this is @xmath300 , although this represents no practical problem that the author is aware of .",
    "practical cost functions will , given a probability distribution for nonincreasing @xmath4 , generally have at least one optimal code of monotonically nondecreasing length .",
    "differentially monotonicity is a sufficient condition for this , and we can improve upon the algorithm by insisting that the problem be differentially monotonic and all entries @xmath4 in @xmath8 be distinct ; the latter condition we later relax .",
    "the resulting algorithm uses only linear space and quadratic time .",
    "first we need a definition :    a _ _ monotonic nodeset , @xmath227 , is one with the following properties : @xmath301 this definition is equivalent to that given in @xcite .",
    "an example of a monotonic nodeset is the set of nodes enclosed by the dashed line in fig .",
    "note that a nodeset is monotonic only if it corresponds to a length distribution @xmath19 with lengths sorted in nondecreasing order .",
    "[ dmlemma ] if a problem is differentially monotonic and monotonically increasing and convex in each @xmath2 , and if @xmath8 has no repeated values , then any optimal solution @xmath302 is monotonic .",
    "the second monotonic property ( [ validlen ] ) was proved for optimal nodesets in theorem  [ cceqll ] , and the first is now proved with a simple exchange argument , as in @xcite .",
    "suppose we have optimal @xmath227 that violates the first property ( [ firstprop ] ) .",
    "then there exist unequal @xmath3 and @xmath164 such that @xmath303 and @xmath304 for optimal codeword lengths @xmath19 ( @xmath239 ) .",
    "consider @xmath305 with lengths for symbols @xmath3 and @xmath164 interchanged .",
    "then @xmath306 where we recall that @xmath307 and the final inequality is due to differential monotonicity .",
    "however , this implies that @xmath19 is not an optimal code , and thus we can not have an optimal nodeset without monotonicity unless values in @xmath8 are repeated .    taking advantage of this relation to trade off",
    "a constant factor of time for drastically reduced space complexity has been done in @xcite for the case of the length - limited ( linear ) penalty ( [ llhuff ] ) .",
    "we now extend this to all convex differentially monotonic cases .",
    "note that the total width of items that are each less than or equal to width @xmath308 is less than @xmath309 .",
    "thus , when we are processing items and packages of width @xmath308 , fewer than @xmath310 packages are kept in memory .",
    "the key idea in reducing space complexity is to keep only four attributes of each package in memory instead of the full contents . in this manner , we use linear space while retaining enough information to reconstruct the optimal nodeset in algorithmic postprocessing .",
    "define @xmath311 .",
    "package attributes allow us to divide the problem into two subproblems with total complexity that is at most half that of the original problem .",
    "for each package @xmath312 , we retain the following attributes :    1 .",
    "weight : @xmath313 2 .",
    "width : @xmath314 3 .",
    "midct : @xmath315 4 .",
    "hiwidth : @xmath316    where @xmath317 and @xmath318 .",
    "we also define @xmath319 .",
    "this retains enough information to complete the `` first run '' of the algorithm with @xmath50 space .",
    "the result will be the package attributes for the optimal nodeset @xmath227 .",
    "thus , at the end of this first run , we know the value for @xmath320 , and we can consider @xmath227 as the disjoint union of four sets , shown in fig .",
    "[ abcd ] :    1 .",
    "@xmath321 = nodes in @xmath322 with indices in @xmath323 $ ] , 2 .",
    "@xmath324 = nodes in @xmath322 with indices in @xmath325 $ ] , 3 .",
    "@xmath326 = nodes in @xmath327 , 4 .",
    "@xmath328 = nodes in @xmath329 .",
    "due to monotonicity of @xmath227 , it is trivial that @xmath330 \\times \\{l_\\mid\\}$ ] and @xmath331 \\times [ 1 , l_\\mid-1]$ ] .",
    "note then that @xmath332 and @xmath333 $ ] .",
    "thus we need merely to recompute which nodes are in @xmath321 and in @xmath328 .    because @xmath328 is a subset of @xmath334 , @xmath335 and @xmath336 .",
    "given their respective widths , @xmath321 is a minimal weight subset of @xmath323 \\times [ 1,l_{\\mid}-1]$ ] and @xmath328 is a minimal weight subset of @xmath337 \\times [ l_{\\mid}+1,l_{\\max}]$ ] .",
    "the nodes at each level of @xmath321 and @xmath328 may be found by recursive calls to the algorithm . in doing so",
    ", we use only @xmath50 space .",
    "time complexity , however , remains the same ; we replace one run of an algorithm on @xmath220 nodes with a series of runs , first one on @xmath220 nodes , then two on an average of at most @xmath338 nodes each , then four on @xmath339 , and so forth . formalizing this analysis :    the above recursive algorithm for generalized quasiarithmetic convex coding has @xmath286 time complexity .",
    "@xcite    as indicated , this recurrence relation is considered and proved in @xcite , but we analyze it here for completeness . to find the time complexity , set up the following recurrence relation : let @xmath340 be the worst case time to find the minimal weight subset of @xmath341 \\times [ 1,l]$ ] ( of a given width ) , assuming the subset is monotonic .",
    "then there exist constants @xmath342 and @xmath343 such that , if we define @xmath344 and @xmath345 , and we let an adversary choose the corresponding @xmath346 , @xmath347 where @xmath348 is the base case",
    ". then @xmath349 , where @xmath350 is any function satisfying the recurrence @xmath351 which @xmath352 does .",
    "thus , the time complexity is @xmath286 .",
    "the overall complexity is @xmath50 space and @xmath286 time  @xmath291 considering only flat classes , @xmath49 in general , as in table  [ complexity ] .",
    "however , the assumption of distinct @xmath353 puts an undesirable restriction on our input . in their original algorithm from @xcite ,",
    "larmore and hirschberg suggest modifying the probabilities slightly to make them distinct , but this is unnecessarily inelegant , as the resulting algorithm has the drawbacks of possibly being slightly nonoptimal and being nondeterministic ; that is , different implementations of the algorithm could result in the same input yielding different outputs .",
    "a deterministic variant of this approach could involve modifications by multiples of a suitably small variable @xmath111 to make identical values distinct . in @xcite , another method of tie - breaking",
    "is presented for alphabetic length - limited codes . here , we present a simpler alternative analogous to this approach , one which is both deterministic and applicable to all differentially monotonic instances .",
    "recall that @xmath8 is a nonincreasing vector .",
    "thus items of a given width are sorted for use in the package - merge algorithm ; use this order for ties .",
    "for example , if we use the nodes in fig .",
    "[ nodesetnum ]  @xmath354 , @xmath355  with probability @xmath356 , then nodes @xmath357 and @xmath358 are the first to be paired , the tie between @xmath359 and @xmath358 broken by order .",
    "thus , at any step , all identical - width items in one package have adjacent indices .",
    "recall that packages of items will be either in the final nodeset or absent from it as a whole .",
    "this scheme then prevents any of the nonmonotonicity that identical @xmath353 might bring about .    in order to ensure that the algorithm is fully deterministic",
    " whether or not the linear - space version is used  the manner in which packages and single items are merged must also be taken into account .",
    "we choose to merge nonmerged items before merged items in the case of ties , in a similar manner to the two - queue bottom - merge method of huffman coding@xcite .",
    "thus , in our example , the node @xmath360 is chosen whereas the package of items @xmath357 and @xmath358 is not .",
    "this leads to the optimal length vector @xmath361 , rather than @xmath362 or @xmath363 , which are also optimal . as in bottom - merge huffman coding ,",
    "the code with the minimum reverse lexicographical order among optimal codes is the one produced .",
    "this is also the case if we use the position of the `` last '' node in a package ( in terms of the value of @xmath364 ) in order to choose those with lower values , as in @xcite .",
    "however , the above approach , which is easily shown to be equivalent via induction , eliminates the need for keeping track of the maximum value of @xmath364 for each package .      in this case",
    "using a bottom - merge - like coding method has an additional benefit : we no longer need assume that all @xmath365 to assure that the nodeset is a valid code . in finding optimal binary codes , of course , it is best to ignore an item with @xmath366 .",
    "however , consider nonbinary output alphabets , that is , @xmath367 .",
    "as in huffman coding for such alphabets , we must add `` dummy '' values of @xmath366 to assure that the optimal code has the kraft inequality satisfied with equality , an assumption underlying both the huffman algorithm and ours .",
    "the number of dummy values needed is @xmath368 where @xmath369 and where the dummy values each consist of @xmath63 nodes , each node with the proper width and with weight @xmath370 . with this preprocessing step ,",
    "finding an optimal code should proceed similarly to the binary case , with adjustments made for both the package - merge algorithm and the overall coding algorithm due to the formulation of the kraft inequality and maximum length .",
    "a complete algorithm is available , with proof of correctness , in @xcite .",
    "note that we have assumed for all variations of this algorithm that we knew a maximum bound for length , although in the overall complexity analysis for binary coding we assumed this was @xmath215 ( except for flat classes ) .",
    "we now explore a method for finding better upper bounds and thus a more efficient algorithm .",
    "first we present a definition due to larmore :    consider penalty functions @xmath46 and @xmath371 .",
    "we say that @xmath371 is _ _ flatter than @xmath46 if , for probabilities @xmath372 and @xmath373 and positive integers @xmath42 and @xmath374 where @xmath375 , @xmath376 ( where , again , @xmath377 ) @xcite .",
    "a consequence of the convex hull theorem of @xcite is that , given @xmath371 flatter than @xmath46 , for any @xmath8 , there exist @xmath46-optimal @xmath378 and @xmath371-optimal @xmath379 such that @xmath378 is greater lexicographically than @xmath379 ( again , with lengths sorted largest to smallest ) .",
    "this explains why the word `` flatter '' is used .",
    "thus , for penalties flatter than the linear penalty , we can obtain a useful upper bound , reducing complexity .",
    "all convex quasiarithmetic penalties are flatter than the linear penalty .",
    "( there are some generalized quasiarithmetic convex coding penalties that are not flatter than the linear penalty  e.g. , @xmath380  and some flatter penalties that are not campbell / quasiarithmetic  e.g. , @xmath381  so no other similarly straightforward relation exists . ) for most penalties we have considered , then , we can use the upper bounds in @xcite or the results of a pre - algorithmic huffman coding of the symbols to find an upper bound on codeword length .    a problem in which pre - algorithmic huffman coding would be useful is delay coding , in which the quadratic penalty ( [ quadratic ] ) is solved for @xmath49 values of @xmath26 and @xmath27@xcite .",
    "in this application , only one traditional huffman coding would be necessary to find an upper bound for all quadratic cases .    with other problems",
    ", we might wish to instead use a mathematically derived upper bound . using the maximum unary codeword length of @xmath215 and techniques involving the golden mean",
    ", @xmath382 , buro in @xcite gives the upper limit of length for a ( standard ) binary huffman codeword as @xmath383 which would thus be an upper limit on codeword length for the minimal optimal code obtained using any flatter penalty function , such as a convex quasiarithmetic function .",
    "this may be used to reduce complexity , especially in a case in which we encounter a flat class of problem inputs .",
    "in addition to this , one can improve this algorithm by adapting the binary length - limited huffman coding techniques of moffat ( with others ) in @xcite .",
    "we do not explore these , however , as these can not improve asymptotic results with the exception of a few special cases .",
    "other approaches to length - limited huffman coding with improved algorithmic complexity@xcite are not suited for extension to nonlinear penalties .",
    "with a similar approach to that taken by shannon for shannon entropy and campbell for rnyi entropy , one can show redundancy bounds and related properties for optimal codes using campbell s quasiarithmetic penalties and generalized entropies .",
    "for convex quasiarithmetic costs , building upon and refining larmore and hirschberg s methods , one can construct efficient algorithms for finding an optimal code .",
    "such algorithms can be readily extended to the generalized quasiarithmetic convex class of penalties , as well as to the delay penalty , the latter of which results in more quickly finding an optimal code for delay channels .",
    "one might ask whether the aforementioned properties can be extended ; for example , can improved redundancy bounds similar to @xcite be found ? it is an intriguing question , albeit one that seems rather difficult to answer given that such general penalties lack a huffman coding tree structure .",
    "in addition , although we know that optimal codes for infinite alphabets exist given the aforementioned conditions , we do not know how to find them .",
    "this , as with many infinite alphabet coding problems , remains open .    it would also be interesting if the algorithms could be extended to other penalties , especially since complex models of queueing can lead to other penalties aside from the delay penalty mentioned here .",
    "also , note that the monotonicity property of the examples we consider implies that the resulting optimal code can be alphabetic , that is , lexicographically ordered by item number .",
    "if we desire items to be in a lexicographical order different from that of probability , however , the alphabetic and nonalphabetic cases can have different solutions .",
    "this was discussed for the length - limited penalty in @xcite ; it might be of interest to generalize it to other penalties using similar techniques and to prove properties of alphabetic codes for such penalties .",
    "the author wishes to thank thomas cover , john gill , and andrew brzezinski for feedback on this paper and research , as well as the anonymous reviewers for their numerous suggestions for improvement .",
    "discussions and comments from the stanford information theory group and benjamin van roy are also greatly appreciated , as is encouragement from brian marcus .    here",
    "we illustrate and prove the correctness of a recursive version of package - merge algorithm for solving the coin collector s problem .",
    "this algorithm was first presented in @xcite , which also has a linear - time iterative implementation .",
    "restating the coin collector s problem : @xmath384 in our notation , we use @xmath385 to denote both the index of a coin and the coin itself , and @xmath234 to represent the @xmath229 items along with their weights @xmath386 and widths @xmath387 . the optimal solution , a function of total width @xmath29 and items @xmath234 , is denoted @xmath235 .",
    "note that we assume the solution exists but might not be unique . in the case of distinct solutions , tie resolution for minimizing arguments may for now be arbitrary or rule - based ; we clarify this in subsection  [ linear ] .",
    "a modified version of the algorithm considers the case where a solution might not exist , but this is not needed here . because a solution exists , assuming @xmath60 , @xmath388 for some unique odd @xmath389 and @xmath390 .",
    "( note that @xmath391 need not be an integer . if @xmath392 , @xmath393 and @xmath391 are not defined . )                    _ case 2b .",
    "@xmath399 , @xmath397 , and @xmath402 : _ create @xmath182 , a new item with weight @xmath403 and width @xmath404 .",
    "this new item is thus a combined item , or _ _ package , formed by combining items @xmath405 and @xmath406 .",
    "let @xmath407 ( the optimization of the packaged version ) .",
    "if @xmath408 , then @xmath409 ; otherwise , @xmath410 .",
    "we show that the package - merge algorithm produces an optimal solution via induction on the depth of the recursion .",
    "the basis is trivially correct , and each inductive case reduces the number of items by one .",
    "the inductive hypothesis on @xmath411 and @xmath412 is that the algorithm is correct for any problem instance that requires fewer recursive calls than instance @xmath413 .    if @xmath414 and @xmath415 , or if @xmath416 , then there is no solution to the problem , contrary to our assumption . thus all feasible cases are covered by those given in the procedure .",
    "case 1 indicates that the solution must contain an odd number of elements of width  @xmath257 .",
    "these must include the minimum weight item in @xmath417 , since otherwise we could substitute one of the items with this `` first '' item and achieve improvement .",
    "case  2 indicates that the solution must contain an even number of elements of width  @xmath257 .",
    "if this number is @xmath370 , neither @xmath405 nor @xmath406 is in the solution",
    ". if it is not , then they both are .",
    "if @xmath418 , the number is @xmath370 , and we have case 2a . if not , we may `` package '' the items , considering the replaced package as one item , as in case 2b . thus the inductive hypothesis holds and the algorithm is correct .",
    "[ pm ] presents a simple example of this algorithm at work , finding minimum total weight items of total width @xmath419 ( or , in binary , @xmath420 ) . in the figure , item width represents numeric width and item area represents numeric weight",
    "initially , as shown in the top row , the minimum weight item with width @xmath421 is put into the solution set .",
    "then , the remaining minimum width items are packaged into a merged item of width @xmath422 ( @xmath423 ) .",
    "finally , the minimum weight item / package with width @xmath424 is added to complete the solution set , which is now of weight @xmath425 .",
    "the remaining packaged item is left out in this case ; when the algorithm is used for coding , several items are usually left out of the optimal set .",
    "a.  rnyi , _ a diary on information theory_.1em plus 0.5em minus 0.4emnew york , ny : john wiley & sons inc . ,",
    "1987 , original publication : _ napl az informcielmletrl _ , gondolat , budapest , hungary , 1976 .",
    "j.  aczl , `` on shannon s inequality , optimal coding , and characterizations of shannon s and rnyi s entropies , '' in _ symposia mathematica _ , vol .",
    "15.1em plus 0.5em minus 0.4em new york , ny : academic press , 1973 , pp . 153179 .",
    "j.  katajainen , a.  moffat , and a.  turpin , `` a fast and space - economical algorithm for length - limited coding , '' in _ proceedings of the international symposium on algorithms and computation _ , dec .",
    "1995 , p. 1221 .",
    "a.  aggerwal , b.  schieber , and t.  tokuyama , `` finding a minimum - weight @xmath171-link path on graphs with the concave monge property and applications , '' _ discrete and computational geometry _ ,",
    "263280 , 1994 ."
  ],
  "abstract_text": [
    "<S> huffman coding finds a prefix code that minimizes mean codeword length for a given probability distribution over a finite number of items . </S>",
    "<S> campbell generalized the huffman problem to a family of problems in which the goal is to minimize not mean codeword length @xmath0 but rather a generalized mean of the form @xmath1 , where @xmath2 denotes the length of the @xmath3th codeword , @xmath4 denotes the corresponding probability , and @xmath5 is a monotonically increasing cost function . such generalized means </S>",
    "<S>  also known as quasiarithmetic or quasilinear means  have a number of diverse applications , including applications in queueing . </S>",
    "<S> several quasiarithmetic - mean problems have novel simple redundancy bounds in terms of a generalized entropy . </S>",
    "<S> a related property involves the existence of optimal codes : for `` well - behaved '' cost functions , optimal codes always exist for ( possibly infinite - alphabet ) sources having finite generalized entropy . solving finite instances of such problems is done by generalizing an algorithm for finding length - limited binary codes to a new algorithm for finding optimal binary codes for any quasiarithmetic mean with a convex cost function . </S>",
    "<S> this algorithm can be performed using quadratic time and linear space , and can be extended to other penalty functions , some of which are solvable with similar space and time complexity , and others of which are solvable with slightly greater complexity . </S>",
    "<S> this reduces the computational complexity of a problem involving minimum delay in a queue , allows combinations of previously considered problems to be optimized , and greatly expands the space of problems solvable in quadratic time and linear space . </S>",
    "<S> the algorithm can be extended for purposes such as breaking ties among possibly different optimal codes , as with bottom - merge huffman coding .    </S>",
    "<S> optimal prefix code , huffman algorithm , generalized entropies , generalized means , quasiarithmetic means , queueing . </S>"
  ]
}