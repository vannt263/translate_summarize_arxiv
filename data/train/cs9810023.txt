{
  "article_text": [
    "this is a reaction to leslie lamport s `` processes are in the eye of the beholder '' @xcite .",
    "lamport writes :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ a concurrent algorithm is traditionally represented as the composition of processes .",
    "we show by an example that processes are an artifact of how an algorithm is represented .",
    "the difference between a two - process representation and a four - process representation of the same algorithm is no more fundamental than the difference between @xmath0 and @xmath1 . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    to demonstrate his thesis , lamport uses two different programs for a first - in , first - out ring buffer of size @xmath2 .",
    "he represents the two algorithms by temporal formulas and proves the equivalence of the two temporal formulas .",
    "we analyze in what sense the two algorithms are and are not equivalent . there is no one notion of equivalence appropriate for all purposes and thus the `` insubstantiality of processes '' may itself be in the eye of the beholder .",
    "there are other issues where we disagree with lamport .",
    "in particular , we give a direct equivalence proof for two programs without representing them by means of temporal formulas .",
    "this paper is self - contained . in the remainder of this section",
    ", we explain the two ring buffer algorithms and discuss our disagreements with lamport . in section  [ eaintro ] ,",
    "we give a brief introduction to evolving algebras . in section  [ ringeas ]",
    ", we present our formalizations of the ring buffer algorithms as evolving algebras . in section  [ equivpf ] , we define a version of lock - step equivalence and prove that our formalizations of these algorithms are equivalent in that sense .",
    "finally , we discuss the inequivalence of these algorithms in section  [ inequiv ] .",
    "the ring buffer in question is implemented by means of an array of @xmath2 elements . the @xmath3th input ( starting with @xmath4 )",
    "is stored in slot @xmath5 until it is sent out as the @xmath3th output .",
    "items may be placed in the buffer if and only if the buffer is not full ; of course , items may be sent from the buffer if and only if the buffer is not empty",
    ". input number @xmath3 can not occur until ( 1 )  all previous inputs have occurred and ( 2 )  either @xmath6 or else output number @xmath7 has occurred .",
    "output number @xmath3 can not occur until ( 1 )  all previous outputs have occurred and ( 2 )  input number @xmath3 has occurred .",
    "these dependencies are illustrated pictorially in figure  [ equivsketch1 ] , where circles represent the actions to be taken and arrows represent dependency relationships between actions .",
    "lamport writes the two programs in a semi - formal language reminiscent of csp @xcite which we call pseudo - csp . the first program , which we denote by @xmath8 , is shown in figure  [ rpcsp ] .",
    "it operates the buffer using two processes ; one handles input into the buffer and the other handles output from the buffer .",
    "it gives rise to a row - wise decomposition of the graph of moves , as shown in figure  [ equivsketch2 ] .",
    "the second program , which we denote by @xmath9 , is shown in figure  [ cpcsp ] .",
    "it uses @xmath2 processes , each managing input and output for one particular slot in the buffer .",
    "it gives rise to a column - wise decomposition of the graph of moves , as shown in figure  [ equivsketch3 ] .",
    "in pseudo - csp , the semicolon represents sequential composition , @xmath10 represents parallel composition , and @xmath11 represents iteration .",
    "the general meanings of ? and !",
    "are more complicated ; they indicate synchronization . in the context of @xmath8  and @xmath9 ,",
    "`` in ? '' is essentially a command to place the current input into the given slot , and `` out ! ''",
    "is essentially a command to send out the datum in the given slot as an output . in section  [ ringeas ] , we will give a more complete explanation of the two programs in terms of evolving algebras .",
    "after presenting the two algorithms in pseudo - csp , lamport describes them by means of formulas in tla , the temporal logic of actions @xcite , and proves the equivalence of the two formulas in tla . he does not prove that the tla formulas are equivalent to the corresponding pseudo - csp programs .",
    "the pseudo - csp presentations are there only to guide the reader s intuition .",
    "as we have mentioned , pseudo - csp is only semi - formal ; neither the syntax nor the semantics of it is given precisely .",
    "however , lamport provides a hint as to why the two programs themselves are equivalent .",
    "there is a close correspondence of values between @xmath12 and @xmath13 , and between @xmath14 and @xmath15 .",
    "figure  [ pptable ] , taken from @xcite , illustrates the correspondence between @xmath12 and @xmath13 for @xmath16 .",
    "the @xmath17th row describes the values of variables @xmath12 and @xmath13 after @xmath17 inputs .",
    "the predicate isnext(pp , i ) is intended to be true only for one array position @xmath3 at any state ( the position that is going to be active ) ; the box indicates that position .",
    "there are three issues where we disagree with lamport .",
    "[ [ issue-1-the - notion - of - equivalence . ] ] issue 1 : the notion of equivalence .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    what does it mean that two programs are equivalent ? in our opinion , the answer to the question depends on the desired abstraction @xcite .",
    "there are many reasonable definitions of equivalence . here",
    "are some examples .    1 .",
    "the two programs produce the same output on the same input .",
    "the two programs produce the same output on the same input , and the two programs are of the same time complexity ( with respect to your favorite definition of time complexity ) .",
    "[ ordertime ] 3 .",
    "given the same input , the two programs produce the same output and take _ precisely _ the same amount of time .",
    "[ sametime ] 4 .",
    "no observer of the execution of the two programs can detect any difference .",
    "[ obs ]    the reader will be able to suggest numerous other reasonable definitions for equivalence .",
    "for example , one could substitute space for time in conditions ( [ ordertime ] ) and ( [ sametime ] ) above . the nature of an `` observer '' in condition ( [ obs ] ) admits different plausible interpretations , depending upon what aspects of the execution the observer is allowed to observe .",
    "let us stress that we do not promote any particular notion of equivalence or any particular class of such notions .",
    "we only note that there are different reasonable notions of equivalence and there is no one notion of equivalence that is best for all purposes .",
    "the two ring - buffer programs are indeed `` strongly equivalent '' ; in particular , they are equivalent in the sense of definition ( [ sametime ] ) above .",
    "however , they are not equivalent in the sense of definition ( [ obs ] ) for certain observers , or in the sense of some space - complexity versions of definitions ( [ ordertime ] ) and ( [ sametime ] ) .",
    "see section  [ inequiv ] in this connection .",
    "[ [ issue-2-representing - programs - as - formulas . ] ] issue 2 : representing programs as formulas .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    again , we quote lamport @xcite :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ we will not attempt to give a rigorous meaning to the program text .",
    "programming languages evolved as a method of describing algorithms to compilers , not as a method for reasoning about them .",
    "we do not know how to write a completely formal proof that two programming language representations of the ring buffer are equivalent . in section  2",
    ", we represent the program formally in tla , the temporal logic of actions @xcite . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we believe that it is not only possible but also beneficial to give a rigorous meaning to one s programming language and to prove the desired equivalence of programs directly .",
    "the evolving algebra method has been used to give rigorous meaning to various programming languages @xcite . in a similar way",
    ", one may try to give formal semantics to pseudo - csp ( which is used in fact for describing algorithms to humans , not compilers ) .",
    "taking into account the modesty of our goals in this paper , we do not do that and represent @xmath8  and @xmath9  directly as evolving algebra programs @xmath18  and @xmath19and then work with the two evolving algebras .",
    "one may argue that our translation is not perfectly faithful .",
    "of course , no translation from a semi - formal to a formal language can be proved to be faithful .",
    "we believe that our translation is reasonably faithful ; we certainly did not worry about the complexity of our proofs as we did our translations .",
    "also , we do not think that lamport s tla description of the pseudo - csp is perfectly faithful ( see the discussion in subsection  3.2 ) and thus we have two slightly different ideals to which we can be faithful .",
    "in fact , we do not think that perfect faithfulness is crucially important here .",
    "we give two programming language representations @xmath18  and @xmath19  of the ring buffer reflecting different decompositions of the buffer into processes .",
    "confirming lamport s thesis , we prove that the two programs are equivalent in a very strong sense ; our equivalence proof is direct .",
    "then we point out that our programs are inequivalent according to some natural definitions of equivalence .",
    "moreover , the same inequivalence arguments apply to @xmath8  and @xmath9  as well .",
    "[ [ issue-3-the - formality - of - proofs . ] ] issue 3 : the formality of proofs .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    continuing , lamport writes @xcite :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ we now give a hierarchically structured proof that @xmath20 and @xmath21 [ the tla translations of @xmath8  and @xmath9   gh ] are equivalent @xcite .",
    "the proof is completely formal , meaning that each step is a mathematical formula .",
    "english is used only to explain the low - level reasoning .",
    "the entire proof could be carried down to a level at which each step follows from the simple application of formal rules , but such a detailed proof is more suitable for machine checking than human reading . our complete proof , with `` q.e.d . ''",
    "steps and low - level reasoning omitted , appears in appendix a. _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we prefer to separate the process of explaining a proof to people from the process of computer - aided verification of the same proof @xcite .",
    "a human - oriented exposition is much easier for humans to read and understand than expositions attempting to satisfy both concerns at once .",
    "writing a good human - oriented proof is the art of creating the correct images in the mind of the reader .",
    "such a proof is amenable to the traditional social process of debugging mathematical proofs .",
    "granted , mathematicians make mistakes and computer - aided verification may be desirable , especially in safety - critical applications . in this connection",
    "we note that a human - oriented proof can be a starting point for mechanical verification .",
    "let us stress also that a human - oriented proof need not be less precise than a machine - oriented proof ; it simply addresses a different audience .",
    "[ [ revisiting - lamports - thesis ] ] revisiting lamport s thesis + + + + + + + + + + + + + + + + + + + + + + + + + + +    these disagreements do not mean that our position on `` the insubstantiality of processes '' is the direct opposite of lamport s .",
    "we simply point out that `` the insubstantiality of processes '' may itself be in the eye of the beholder .",
    "the same two programs can be equivalent with respect to some reasonable definitions of equivalence and inequivalent with respect to others .",
    "evolving algebras were introduced in @xcite ; a more detailed definition has appeared in @xcite . since its introduction , this methodology has been used for a wide variety of applications : programming language semantics , hardware specification , protocol verification , _",
    "etc._. it has been used to show equivalences of various kinds , including equivalences across a variety of abstraction levels for various real - world systems , _",
    "e.g. _ @xcite .",
    "see @xcite for numerous other examples .",
    "we recall here only as much of evolving algebra definitions @xcite as needed in this paper . evolving algebras ( often abbreviated _ ealgebras _ or _ ea _ ) have many other capabilities not shown here : for example , creating or destroying agents during the evolution .    those already familiar with ealgebras may wish to skip this section .",
    "states are essentially logicians structures except that relations are treated as special functions .",
    "they are also called _ static algebras _ and indeed they are algebras in the sense of the science of universal algebra .",
    "a _ vocabulary _ is a finite collection of function names , each of fixed arity .",
    "every vocabulary contains the following _ logic symbols _ : nullary function names _ true , false , undef _ , the equality sign , ( the names of ) the usual boolean operations and ( for convenience ) a unary function name bool .",
    "some function symbols are tagged as relation symbols ( or predicates ) ; for example , bool and the equality sign are predicates .    a _ state _ @xmath22 _ of vocabulary _",
    "@xmath23 is a non - empty set @xmath24 ( the _ basic set _ or _ superuniverse _ of @xmath22 ) , together with interpretations of all function symbols in @xmath23 over @xmath24 ( the _ basic functions _ of @xmath22 ) .",
    "a function symbol @xmath25 of arity @xmath26 is interpreted as an @xmath26-ary operation over @xmath24 ( if @xmath27 , it is interpreted as an element of @xmath24 ) .",
    "the interpretations of predicates ( the _ basic relations _ ) and the logic symbols satisfy the following obvious requirements .",
    "the elements ( more exactly , the interpretations of ) _ true _ and _ false _ are distinct .",
    "these two elements are the only possible values of any basic relation and the only arguments where bool produces _",
    "true_. they are operated upon in the usual way by the boolean operations .",
    "the interpretation of _ undef _ is distinct from those of _",
    "true _ and _ false_. the equality sign is interpreted as the equality relation .",
    "we denote the value of a term @xmath28 in state @xmath22 by @xmath29 .    domains .",
    "let @xmath25 be a basic function of arity @xmath26 and @xmath30 range over @xmath26-tuples of elements of @xmath22 . if @xmath25 is a basic relation then the _ domain of @xmath25 _ at @xmath22 is @xmath31 .",
    "otherwise the _ domain of @xmath25 _ at @xmath22 is @xmath32",
    ".    universes .",
    "a basic relation @xmath25 may be viewed as the set of tuples where it evaluates to _",
    "true_. if @xmath25 is unary it can be viewed as a _",
    "universe_. for example , bool is a universe consisting of two elements ( named ) _ true _ and _ false_. universes allow us to view states as many - sorted structures",
    ".    types .",
    "let @xmath25 be a basic function of arity @xmath26 and @xmath33 be universes .",
    "we say that @xmath25 is _ of type _",
    "@xmath34 in the given state if the domain of @xmath25 is @xmath35 and @xmath36 for every @xmath30 in the domain of @xmath25 .",
    "in particular , a nullary @xmath25 is of type @xmath37 if ( the value of ) @xmath25 belongs to @xmath37 .",
    "consider a directed ring of nodes with two tokens ; each node may be colored or uncolored .",
    "we formalize this as a state as follows .",
    "the superuniverse contains a non - empty universe nodes comprising the nodes of the ring . also present",
    "is the obligatory two - element universe bool , disjoint from nodes .",
    "finally , there is an element ( interpreting ) _ undef _ outside of bool and outside of nodes .",
    "there is nothing else in the superuniverse .",
    "( usually we skip the descriptions of bool and _ undef _ ) .",
    "a unary function next indicates the successor to a given node in the ring .",
    "nullary functions token1 and token2 give the positions of the two tokens .",
    "a unary predicate colored indicates whether the given node is colored .",
    "there is a way to view states which is unusual to logicians .",
    "view a state as a sort of memory .",
    "define a _ location _ of a state @xmath22 to be a pair @xmath38 , where @xmath25 is a function name in the vocabulary of @xmath22 and @xmath30 is a tuple of elements of ( the superuniverse of ) @xmath22 whose length equals the arity of @xmath25 .",
    "( if @xmath25 is nullary , @xmath39 is simply @xmath25 . ) in the two - token ring example , let @xmath40 be any node ( that is , any element of the universe nodes )",
    ". then the pair ( next,@xmath40 ) is a location .",
    "an _ update _ of a state @xmath22 is a pair @xmath41 , where @xmath39 is a location of @xmath22 and @xmath42 is an element of @xmath22 . to",
    "@xmath43 at @xmath22 , put @xmath42 into the location @xmath39 ; that is , if @xmath38 , redefine @xmath22 to interpret @xmath44 as @xmath42 ; nothing else ( including the superuniverse ) is changed .",
    "we say that an update @xmath45 of state @xmath22 is _ trivial _ if @xmath42 is the content of @xmath39 in @xmath22 .",
    "in the two - token ring example , let @xmath40 be any node .",
    "then the pair ( token1 , @xmath40 ) is an update . to fire this update , move the first token to the position @xmath40 .",
    "remark to a curious reader . if @xmath39 = ( next,@xmath40 ) , then ( @xmath46 ) is also an update .",
    "to fire this update , redefine the successor of @xmath40 ; the new successor is @xmath40 itself .",
    "this update destroys the ring ( unless the ring had only one node ) . to guard from such undesirable changes ,",
    "the function next can be declared static ( see @xcite ) which will make any update of next illegal .",
    "an _ update set _ over a state @xmath22 is a set of updates of @xmath22 .",
    "an update set is _ consistent _ at @xmath22 if no two updates in the set have the same location but different values . to fire a consistent set at @xmath22 , fire all its members simultaneously ; to fire an inconsistent set at @xmath22 , do nothing .",
    "in the two - token ring example , let @xmath47 be two nodes",
    ". then the update set @xmath48 is consistent if and only if @xmath49 .",
    "we introduce rules for changing states .",
    "the semantics for each rule should be obvious . at a given state @xmath22 whose vocabulary includes that of a rule @xmath50",
    ", @xmath50 gives rise to an update set @xmath51 ; to execute @xmath50 at @xmath22 , one fires @xmath51 .",
    "we say that @xmath50 is _ enabled _ at @xmath22 if @xmath51 is consistent and contains a non - trivial update .",
    "we suppose below that a state of discourse @xmath22 has a sufficiently rich vocabulary .",
    "an _ update instruction _",
    "@xmath50 has the form    = = @xmath52    where @xmath25 is a function name of arity @xmath26 and each @xmath53 is a term .",
    "( if @xmath27 we write `` @xmath54 '' rather than `` @xmath55 '' . )",
    "the update set @xmath51 contains a single element @xmath45 , where @xmath42 is the value @xmath56 of @xmath57 at @xmath22 and @xmath58 with @xmath59 . in other words , to execute @xmath50 at @xmath22 , set @xmath60 to @xmath56 and leave the rest of the state unchanged . in the two - token ring example , `` token1 : = next(token2 ) '' is an update instruction . to execute it , move token 1 to the successor of ( the current position of ) token 2 .",
    "a _ block rule _",
    "@xmath50 is a sequence @xmath61 of transition rules . to execute @xmath50 at @xmath22 , execute all the constituent rules at @xmath22 simultaneously .",
    "more formally , @xmath62 .",
    "( one is supposed to write `` * block * '' and `` * endblock * '' to denote the scope of a block rule ; we often omit them for brevity . ) in the two - token ring example , consider the following block rule :    = = token1 : = token2 + token2 : = token1    to execute this rule , exchange the tokens .",
    "the new position of token1 is the old position of token2 , and the new position of token2 is the old position of token1 .",
    "a _ conditional rule _ @xmath50 has the form    = = * if  * @xmath14 * then  * @xmath63 * endif *    where @xmath14 ( the _ guard _ ) is a term and @xmath63 is a rule . if @xmath14 holds ( that is , has the same value as _ true _ ) in @xmath22 then @xmath64 ; otherwise @xmath65 .",
    "( a more general form is `` * if  * @xmath14 * then  * @xmath63 * else  * @xmath66 * endif * '' , but we do not use it in this paper . ) in the two - token ring example , consider the following conditional rule :    = = * if  * token1 = token2 * then  * + colored(token1 ) : = true + * endif *    its meaning is the following : if the two tokens are at the same node , then color that node .",
    "basic rules are sufficient for many purposes , e.g. to give operational semantics for the c programming language @xcite , but in this paper we need two additional rule constructors .",
    "the new rules use variables .",
    "formal treatment of variables requires some care but the semantics of the new rules is quite obvious , especially because we do not need to nest constructors with variables here .",
    "thus we skip the formalities and refer the reader to @xcite . as above @xmath22 is a state of sufficiently rich vocabulary .    a _ parallel synchronous rule _",
    "( or _ declaration rule _",
    ", as in @xcite ) @xmath50 has the form :    = = = * var  * @xmath67 * ranges over  * @xmath68 + @xmath69 + * endvar *    where @xmath67 is a variable name , @xmath68 is a universe name , and @xmath69 can be viewed as a rule template with free variable @xmath67 . to execute @xmath50 at @xmath22 , execute simultaneously all rules @xmath70 where @xmath71 ranges over @xmath68 . in the two - token ring example , ( the execution of ) the following rule colors all nodes except for the nodes occupied by the tokens .",
    "= = = * var  * @xmath67 * ranges over  * nodes + * if  * @xmath72 token1 * and  * @xmath72 token2 * then  * + colored(x ) : = true + * endif * + * endvar *    a _ choice rule _ @xmath50 has the form    = = = * choose  * @xmath67 * in  * @xmath68 + @xmath69 + * endchoose *    where @xmath67 , @xmath68 and @xmath69 are as above .",
    "it is nondeterministic . to execute the choice rule ,",
    "choose arbitrarily one element @xmath71 in @xmath68 and execute the rule @xmath70 .",
    "in the two - token ring example , each execution of the following rule either colors an unoccupied node or does nothing .",
    "= = = * choose  * @xmath67 * in  * nodes + * if  * @xmath72 token1 * and  * @xmath72 token2 * then  * + colored(x ) : = true + * endif * + * endchoose *      let @xmath23 be a vocabulary that contains the universe _",
    "agents _ , the unary function _ mod _ and the nullary function _",
    "me_. a _ distributed ea program _",
    "@xmath73 of vocabulary @xmath23 consists of a finite set of _ modules _ , each of which is a transition rule with function names from @xmath23 .",
    "each module is assigned a different name ; these names are nullary function names from @xmath23 different from _",
    "me_. intuitively , a module is the program to be executed by one or more agents .",
    "a ( global ) _ state _ of @xmath73 is a structure @xmath22 of vocabulary @xmath23\\{me } where different module names are interpreted as different elements of @xmath22 and the function _ mod _ assigns",
    "( the interpretations of ) module names to elements of _ agents _ ; _ mod _ is undefined ( that is , produces _ undef _ ) otherwise .",
    "if _ mod _ maps an element @xmath43 to a module name @xmath74 , we say that @xmath43 is an _ agent _ with program @xmath74 .    for each agent @xmath43 , view@xmath75 is the reduct of @xmath22 to the collection of functions mentioned in the module mod(@xmath43 ) , expanded by interpreting _ me _ as @xmath43 . think about view@xmath75 as the local state of agent @xmath43 corresponding to the global state @xmath22 .",
    "we say that an agent @xmath43 is _ enabled _ at @xmath22 if mod(@xmath43 ) is enabled at view@xmath75 ; that is , if the update set generated by mod(@xmath43 ) at view@xmath75 is consistent and contains a non - trivial update .",
    "this update set is also an update set over @xmath22 . to",
    "@xmath43 at @xmath22 , execute that update set .      in this paper , agents are not created or destroyed . taking this into account , we give a slightly simplified definition of runs .    a _ run _ @xmath76 of a distributed ealgebra program @xmath73 of vocabulary @xmath23 from the initial state @xmath77 is a triple @xmath78 satisfying the following conditions .    1 .",
    ": :    @xmath74 , the set of _ moves _ of @xmath76 , is a    partially ordered set where every @xmath79    is finite .",
    "+    intuitively , @xmath80 means that move @xmath81    completes before move @xmath82 begins .",
    "if @xmath74 is    totally ordered , we say that @xmath76 is a _ sequential _ run .",
    ":    @xmath83 assigns agents ( of @xmath77 ) to moves in such    a way that every non - empty set @xmath84    is linearly ordered .",
    "+    intuitively , @xmath85 is the agent performing move    @xmath82 ; every agent acts sequentially .",
    "3 . : :    @xmath86 maps finite initial segments of @xmath74    ( including @xmath87 ) to states of @xmath73 .",
    "+    intuitively , @xmath88 is the result of performing all    moves of @xmath24 ; @xmath89 is the    initial state @xmath77 .",
    "states @xmath88 are    the _ states of @xmath76_. 4 . : :    _ coherence_. if @xmath82 is a maximal element of a finite    initial segment @xmath90 of @xmath74 , and    @xmath91 , then @xmath85 is enabled at    @xmath88 and @xmath92 is obtained by    firing @xmath85 at @xmath88",
    ".    it may be convenient to associate particular states with single moves .",
    "we define @xmath93 .",
    "the definition of runs above allows no interaction between the agents on the one side and the external world on the other . in such a case ,",
    "a distributed evolving algebra is given by a program and the collection of initial states . in a more general case , the environment can influence the evolution .",
    "here is a simple way to handle interaction with the environment which suffices for this paper .",
    "declare some basic functions ( more precisely , some function names ) _ external_. intuitively , only the outside world can change them .",
    "if @xmath22 is a state of @xmath73 let @xmath94 be the reduct of @xmath22 to ( the vocabulary of ) non - external functions .",
    "replace the coherence condition with the following :    4@xmath95 .",
    ": :    _ coherence_. if @xmath82 is a maximal element of a finite    initial segment @xmath90 of @xmath74 , and    @xmath91 , then @xmath85 is enabled in    @xmath88 and @xmath96 is obtained by    firing @xmath85 at @xmath88 and forgetting    the external functions .    in applications ,",
    "external functions usually satisfy certain constraints .",
    "for example , a nullary external function input may produce only integers . to reflect such constraints ,",
    "we define _ regular runs _ in applications .",
    "a distributed evolving algebra is given by a program , the collection of initial states and the collection of regular runs .",
    "( of course , regular runs define the initial states , but it may be convenient to specify the initial states separately . )",
    "the evolving algebras @xmath18and @xmath19 , our `` official '' representations of @xmath8  and @xmath9 , are given in subsections  [ officialrea ] and [ officialcea ] ; see figures  [ rea ] and [ cea ] .",
    "the reader may proceed there directly and ignore the preceding subsections where we do the following .",
    "we first present in subsection  [ r1sect ] an elaborate ealgebra r1 that formalizes @xmath8  together with its environment ; r1 expresses our understanding of how @xmath8  works , how it communicates with the environment and what the environment is supposed to do .",
    "notice that the environment and the synchronization magic of csp are explicit in r1 . in subsection  [ r2sect ]",
    ", we then transform r1 into another ealgebra r2 that performs synchronization implicitly .",
    "we transform r2 into @xmath18  by parallelizing the rules slightly and making the environment implicit ; the result is shown in subsection  [ officialrea ] .",
    "( in a sense , r1 , r2 , and @xmath18  are all equivalent to another another , but we will not formalize this . )",
    "we performed a similar analysis and transformation to create @xmath19from @xmath9 ; we omit the intermediate stages and present @xmath19  directly in subsection  [ officialcea ] .",
    "the program for r1 , given in figure  [ r1 ] , contains six modules .",
    "the names of the modules reflect the intended meanings .",
    "in particular , modules bufffrontend and buffbackend correspond to the two processes receiver and sender of @xmath8 .",
    "= = =    ' '' ''     + module inputenvironment + * if  * mode(me ) = work * then  * + * choose  * @xmath97 * in  * data + inputdatum : = @xmath97 + * endchoose * + mode(me ) : = ready + * endif * +    ' '' ''     + module outputenvironment + * if  * mode(me ) = work * then  * mode(me ) : = ready * endif * +    ' '' ''     + module inputchannel + * if  * mode(sender(me ) ) = ready * and  * mode(receiver(me ) ) = ready * then  * + buffer(@xmath98 ) : = inputdatum + mode(sender(me ) ) : = work + mode(receiver(me ) ) : = work + * endif * +    ' '' ''     + module outputchannel + * if  * mode(sender(me ) ) = ready * and  * mode(receiver(me ) ) = ready * then  * + outputdatum : = buffer(@xmath99 ) + mode(sender(me ) ) : = work + mode(receiver(me ) ) : = work + * endif * +    ' '' ''     + module bufffrontend + rule frontwait + * if",
    "* mode(me ) = wait * and  * @xmath100 * then  * mode(me ) : = ready * endif * + rule frontwork + * if  * mode(me ) = work * then  * @xmath12 : = @xmath101 , mode(me ) : = wait * endif * +    ' '' ''     + module buffbackend + rule backwait + * if  * mode(me ) = wait * and  * @xmath102 * then  * mode(me ) : = ready * endif * + rule backwork + * if  * mode(me ) = work * then  * @xmath14 : = @xmath103 , mode(me ) : = wait * endif * +    ' '' ''    comment for ealgebraists . in terms of @xcite ,",
    "the inputchannel agent is a two - member team comprising the inputenvironment and the bufffrontend agents ; functions sender and receiver are similar to functions member@xmath104 and member@xmath105 .",
    "similarly the outputchannel agent is a team .",
    "this case is very simple and one can get rid of unary functions sender and receiver by introducing names for the sending and receiving agents .",
    "comment for csp experts .",
    "synchronization is implicit in csp .",
    "it is a built - in magic of csp .",
    "we have doers of synchronization .",
    "( in this connection , the reader may want to see the ea treatment of occam in @xcite . )",
    "nevertheless , synchronization remains abstract . in a sense",
    "the abstraction level is even higher : similar agents can synchronize more than two processes .",
    "the nondeterministic formalizations of the input and output environments are abstract and may be refined in many ways .    [ [ initial - states . ] ] initial states .",
    "+ + + + + + + + + + + + + + + +    in addition to the function names mentioned in the program ( and the logic names ) , the vocabulary of r1 contains universe names data , integers , @xmath106 , @xmath107 , modes and a subuniverse senders - and - receivers of agents .",
    "initial states of r1 satisfy the following requirements .    1 .",
    "the universe integers and the arithmetical function names mentioned in the program have their usual meanings .",
    "the universe @xmath106  consists of integers modulo @xmath2 identified with the integers @xmath108 .",
    "the universe @xmath107  is similar .",
    "buffer is of type @xmath106@xmath110 data ; inputdatum and outputdatum take values in data .",
    "2 .   the universe agents contains six elements to which mod assigns different module names .",
    "we could have special nullary functions to name the six agents but we do nt ; we will call them with respect to their programs : the input environment , the output environment , the input channel , the output channel , buffer s front end and buffer s back end respectively . sender(the input channel ) = the input environment , receiver(the input channel ) = buffer s front end , sender(the output channel ) = buffer s back end , and receiver(the output channel ) = the output environment .",
    "the universe senders - and - receivers consists of the two buffer agents and the two environment agents .",
    "nullary functions ready , wait and work are distinct elements of the universe modes .",
    "the function mode is defined only over senders - and - receivers . for the sake of simplicity of exposition",
    ", we assign particular initial values to mode : it assigns wait to either buffer agent , work to the input environment agent , and ready to the output environment agent .    [ [ analysis ] ] analysis + + + + + + + +    in the rest of this subsection , we prove that r1 has the intended properties .    in every state of any run of r1 ,",
    "the dynamic functions have the following ( intended ) types .    1 .",
    "mode : senders - and - receivers @xmath110 modes . 2 .",
    "inputdatum , outputdatum : data .",
    "3 .   @xmath111 : integers .",
    "buffer : @xmath106  @xmath110 data .    by induction over states .",
    "let @xmath76 be an arbitrary run of r1 . in every state of @xmath76 , @xmath112 .",
    "furthermore , if @xmath113 then mode(buffer s back end ) = wait , and if @xmath114 then mode(buffer s front end ) = wait .",
    "an obvious induction .",
    "see lemma  [ lem1 ] in this regard .",
    "[ orderingr1 ] in any run of r1 , we have the following .    1 .",
    "if @xmath82 is a move of the input channel and @xmath81 is a move of buffer s front end then either @xmath115 or @xmath116 .",
    "if @xmath82 is a move of the output channel and @xmath81 is a move of buffer s back end then either @xmath115 or @xmath116 .",
    "3 .   for any buffer slot @xmath117 ,",
    "if @xmath82 is a move of the input channel involving slot @xmath117 and @xmath81 is a move of the output channel involving slot @xmath117 then either @xmath115 or @xmath116 .",
    "let @xmath118 be a run of r1 .    1 .",
    "[ orderingpt1 ] suppose by contradiction that @xmath82 and @xmath81 are incomparable and let @xmath119 so that , by the coherence requirements on the run , both agents are enabled at @xmath88 , which is impossible because their guards are contradictory .",
    "+ since the input channel is enabled , the mode of buffer s front end is ready at @xmath24 . but then buffer s front end is disabled at @xmath24 , which gives the desired contradiction .",
    "similar to part ( [ orderingpt1 ] ) .",
    "3 .   suppose by contradiction that @xmath82 and @xmath81 are incomparable and let @xmath120 so that both agents are enabled at @xmath88 . since @xmath82 involves @xmath117 , @xmath121 mod @xmath2 in @xmath88 .",
    "similarly , @xmath122 mod @xmath2 in @xmath88 .",
    "hence @xmath123 mod @xmath2 in @xmath88 . by the p and g lemma , either @xmath113 or @xmath114 in @xmath88 . in the first case ,",
    "the mode of buffer s back end is wait and therefore the output channel is disabled . in the second case ,",
    "the mode of buffer s front end is wait and therefore the input channel is disabled .",
    "in either case , we have a contradiction .",
    "recall that the state of move @xmath82 is @xmath124 . by the coherence requirement ,",
    "the agent @xmath85 is enabled in @xmath125 .",
    "consider a run of r1 .",
    "let @xmath126 ( respectively , @xmath127 ) be the @xmath3th move of the input channel ( respectively , the output channel ) .",
    "the value @xmath128 of inputdatum in @xmath129 ( that , is the datum to be transmitted during @xmath126 ) is the _ @xmath3th input datum _ , and the sequence @xmath130 is the _ input data sequence_. ( it is convenient to start counting from @xmath131 rather than @xmath132 . ) similarly , the value @xmath133 of outputdatum in @xmath134 is the _",
    "@xmath135th output datum of @xmath50 _ and the sequence @xmath136 is the _ output data sequence_.    lamport writes :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ to make the example more interesting , we assume no liveness properties for sending values on the _ in _ channel , but we require that every value received in the buffer be eventually sent on the _ out _ channel . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    with this in mind , we call a run _ regular _ if the output sequence is exactly as long as the input sequence .    for a regular run ,",
    "the output sequence is identical with the input sequence .",
    "let @xmath137 be the moves of the input channel and @xmath138 be the moves of the output channel .",
    "a simple induction shows that @xmath126 stores the @xmath3th input datum @xmath128 at slot @xmath139 and @xmath140 at @xmath129 .",
    "similarly , @xmath141 sends out the @xmath135th output datum @xmath133 from slot @xmath142 and @xmath143 at @xmath134 . if @xmath144 , then @xmath145 . we show that , for all @xmath3 , @xmath146 .    by the @xmath12 and @xmath14 lemma , @xmath147 in @xmath134 for any @xmath135 , and @xmath148 in @xmath149 for any @xmath135 .    1 .",
    "suppose @xmath150 . taking into account the monotonicity of @xmath12 , we have the following at @xmath151 : @xmath152 , @xmath153 and therefore @xmath154 which is impossible .",
    "2 .   suppose @xmath155 .",
    "taking into account the monotonicity of @xmath14 , we have the following at @xmath156 : @xmath157 , @xmath158 , and therefore @xmath159 which is impossible .    by the ordering lemma , @xmath127 is order - comparable with both @xmath126 and @xmath160 .",
    "it follows that @xmath146 .",
    "one obvious difference between @xmath8  and r1 is the following : r1 explicitly manages the communication channels between the buffer and the environment , while @xmath8  does not . by playing with the modes of senders and receivers , the channel modules of r1",
    "provide explicit synchronization between the environment and the buffers .",
    "this synchronization is implicit in the `` ? '' and `` ! ''",
    "operators of csp . to remedy this",
    ", we transform r1 into an ealgebra r2 in which communication occurs implicitly .",
    "r2 must somehow ensure synchronization .",
    "there are several options .    1 .",
    "allow bufffrontend ( respectively , buffbackend ) to modify the mode of the input environment ( respectively , the output environment ) to ensure synchronization .",
    "+ this approach is feasible but undesirable .",
    "it is unfair ; the buffer acts as a receiver on the input channel and a sender on the output channel but exerts complete control over the actions of both channels .",
    "imagine that the output environment represents another buffer , which operates as our buffer does ; in such a case both agents would try to exert complete control over the common channel .",
    "2 .   assume that bufffrontend ( respectively , buffbackend ) does not execute until the input environment ( respectively , the output environment ) is ready .",
    "+ this semantical approach reflects the synchronization magic of csp .",
    "it is quite feasible .",
    "moreover , it is common in the ea literature to make assumptions about the environment when necessary .",
    "it is not necessary in this case because there are very easy programming solutions ( see the next two items ) to the problem .",
    "3 .   use an additional bit for either channel which tells us whether the channel is ready for communication or not .",
    "+ in fact , a state of a channel comprises a datum and an additional bit in the tla part of lamport s paper .",
    "one can avoid dealing with states of the channel by requiring that each sender and receiver across a channel maintains its own bit ( a well - known trick ) which brings us to the following option .",
    "4 .   use a bookkeeping bit for every sender and every receiver .",
    "it does not really matter , technically speaking , which of the four routes is chosen . to an extent ,",
    "the choice is a matter of taste .",
    "we choose the fourth approach .",
    "the resulting ealgebra r2 is shown in figure  [ r2 ] .",
    "= = =    ' '' ''     + module inputenvironment + * if  * insendbit = inreceivebit then + * choose  * @xmath97 * in  * data + inputdatum : = @xmath97 + * endchoose * + insendbit : = 1  insendbit + * endif * +    ' '' ''     + module outputenvironment + * if  * outsendbit @xmath161 outreceivebit * then  * + outreceivebit : = 1  outreceivebit + * endif * +    ' '' ''     + module bufffrontend + rule frontwait + * if  * mode(me ) = wait * and  * @xmath100 * then  * mode(me ) : = ready * endif * +   + rule frontcommunicate + * if  * mode(me ) = ready * and  * insendbit @xmath161 inreceivebit * then  * + buffer(@xmath98 ) : = inputdatum + mode(me ) : = work + inreceivebit : = 1  inreceivebit + * endif * +   + rule frontwork + * if  * mode(me ) = work * then  * @xmath12 : = @xmath101 , mode(me ) : = wait * endif * +    ' '' ''     + module buffbackend + rule backwait + * if  * mode(me ) = wait * and  * @xmath102 * then  * mode(me ) : = ready * endif * +   + rule backcommunicate + * if  * mode(me ) = ready * and  * outsendbit = outreceivebit * then  * + outputdatum : = buffer(@xmath99 ) + mode(me ) : = work + outsendbit : = 1  outsendbit + * endif * +   + rule backwork + * if  * mode(me ) = work * then  * @xmath14 : = @xmath103 , mode(me ) : = wait * endif * +    ' '' ''    notice that the sender can place data into a channel only when the synchronization bits match , and the receiver can read the data in a channel only when the synchronization bits do not match .",
    "the initial states of r2 satisfy the first condition on the initial states of r1 .",
    "the universe agents contains four elements to which mod assigns different module names ; we will call them with respect to their programs : the input environment , the output environment , buffer s front end , and buffer s back end , respectively . the universe bufferagents contains the buffer s front end and buffer s back end agents .",
    "nullary functions insendbit , inreceivebit , outsendbit , outreceivebit are all equal to @xmath131 .",
    "nullary functions ready , wait and work are distinct elements of the universe modes .",
    "the function mode is defined only over bufferagents ; it assigns wait to each buffer agent .",
    "inputdatum and outputdatum take values in data .",
    "define the input and output sequences and regular runs as in r1 .",
    "let @xmath162 be the vocabulary of r1 and @xmath163 be the vocabulary of r2 .",
    "every run @xmath164 of r1 induces a run @xmath165 of r2 where :    1 .   if @xmath166 and @xmath85 is not a channel agent , then @xmath167 . if @xmath85 = the input channel , then @xmath168 = buffer s front end . if @xmath85 = the output channel , then @xmath168 = buffer s back end .",
    "2 .   let @xmath24 be a finite initial segment of @xmath74 .",
    "@xmath169 is the unique state satisfying the following conditions : 1 .",
    "@xmath170 2 .",
    "inreceivebit = @xmath171 if the mode of buffer s front end is wait or ready , and @xmath172 otherwise .",
    "outsendbit = @xmath173 if the mode of buffer s back end is wait or ready , and @xmath174 otherwise .",
    "insendbit = inreceivebit if the mode of the input environment is work , and @xmath175 inreceivebit otherwise .",
    "outreceivebit = outsendbit if the mode of the output environment is ready , and @xmath175 outsendbit otherwise .",
    "we check that @xmath76 is indeed a run of r2 . by the ordering lemma for r1 ,",
    "the moves of every agent of r2 are linearly ordered .",
    "it remains to check only the coherence condition ; the other conditions are obvious .",
    "suppose that @xmath90 is a finite initial segment of @xmath2 with a maximal element @xmath82 and @xmath91 .",
    "using the facts that @xmath85 is enabled in @xmath88 and @xmath92 is the result of executing @xmath85 in @xmath88 , it is easy to check that @xmath168 is enabled in @xmath169 and @xmath176 is the result of executing @xmath168 at @xmath169 .",
    "conversely , every run of r2 is induced ( in the sense of the preceding lemma ) by a unique run of r1 .",
    "the proof is easy and we skip it .      after establishing that @xmath100 and before executing the frontcommunicate rule , buffer s front end goes to mode ready .",
    "this corresponds to nothing in @xmath8  which calls for merging the frontwait and frontcommunicate rules . on the other hand",
    ", @xmath8  augments @xmath12 _ after _ performing an act of communication .",
    "there is no logical necessity to delay the augmentation of @xmath12 . for aesthetic reasons we merge the frontwork rule with the other two rules of bufffrontend .",
    "then we do a similar parallelization for buffbackend .",
    "finally we simplify the names bufffrontend and buffbackend to frontend and backend respectively .",
    "a certain disaccord still remains because the environment is implicit in @xmath8 . to remedy this ,",
    "we remove the environment modules , asserting that the functions inputdatum , insendbit , and outreceivebit which were updated by the environment modules are now external functions .",
    "the result is our official ealgebra @xmath18 , shown in figure  [ rea ] .",
    "= = =    ' '' ''     + module frontend + * if  * @xmath100 * and  * insendbit @xmath161 inreceivebit * then  * + buffer(@xmath98 ) : = inputdatum + inreceivebit : = 1 - inreceivebit + @xmath12 : = @xmath101 + * endif * +    ' '' ''     + module backend + * if  * @xmath102 * and  * outsendbit @xmath177 outreceivebit * then  * + outputdatum : = buffer(@xmath99 ) + outsendbit : = 1 - outsendbit + @xmath14 : = @xmath103 + * endif * +    ' '' ''    the initial states of @xmath18  satisfy the first condition on the initial states of r1 :  the universe integers and the arithmetical function names mentioned in the program have their usual meanings ; the universe @xmath106  consists of integers modulo @xmath2 identified with the integers @xmath108 ; the universe @xmath107  is similar ; @xmath109 ; buffer is of type @xmath106  @xmath110 data ; inputdatum and outputdatum take values in data .    additionally , the universe agents contains two elements to which mod assigns different module names .",
    "insendbit , inreceivebit , outsendbit , and outreceivebit are all equal to @xmath131 .",
    "inputdatum and outputdatum take values in data .",
    "the definition of regular runs of @xmath18  is slightly more complicated , due to the presence of the external functions inputdatum , insendbit , and outreceivebit .",
    "we require that the output sequence is at least as long as the input sequence , inputdatum is of type data , and insendbit and outreceivebit are both of type @xmath107 .",
    "we skip the proof that @xmath18  is faithful to r2 .      the evolving algebra @xmath19  is shown in figure [ cea ] below .",
    "it can be obtained from @xmath9  in the same way that @xmath18  can be obtained from @xmath8 ; for brevity , we omit the intermediate stages .    = = =    ' '' ''     + module slot +   + rule get + * if  * mode(me)=get * and  * inputturn(me ) + * and  * insendbit @xmath161 inreceivebit * then  * + buffer(me ) : = inputdatum + inreceivebit : = 1 - inreceivebit + @xmath178 : = @xmath179 + mode(me ) : = put + * endif * +   + rule put + * if  * mode(me)=put * and  * outputturn(me ) + * and  * outsendbit = outreceivebit * then  * + outputdatum : = buffer(me ) + outsendbit : = 1 - outsendbit + @xmath180 : = @xmath181 + mode(me ) : = get + * endif * +   + inputturn(x ) abbreviates + * or  * [ @xmath182 * and  * @xmath183 + outputturn(x ) abbreviates + * or  * [ @xmath182 * and  * @xmath184 +    ' '' ''    [ [ initial - states ] ] initial states + + + + + + + + + + + + + +    the initial states of @xmath19  satisfy the following conditions .    1 .   the first condition for the initial states of r1 is satisfied except we do nt have functions @xmath12 and @xmath14 now .",
    "instead we have dynamic functions @xmath13 and @xmath15 with domain @xmath106  and @xmath185 for all @xmath3 in @xmath106 .",
    "the universe agents consists of the elements of @xmath106 , which are mapped by mod to the module name slot .",
    "nullary functions get and put are distinct elements of the universe modes .",
    "the dynamic function mode is defined over agents ; mode@xmath186=get for every @xmath67 in @xmath106 .",
    "inputdatum and outputdatum are elements of data .",
    "nullary functions insendbit , inreceivebit , outsendbit , outreceivebit are all equal to @xmath131 .",
    "regular runs are defined similarly to @xmath18 ; we require that the output sequence is at least as long as the input sequence , inputdatum is of type data , and insendbit and outreceivebit take values in @xmath107 .",
    "we define a strong version of lock - step equivalence for ealgebras which for brevity we call _ lock - step equivalence_. we then prove that  @xmath18  and  @xmath19  are lock - step equivalent .",
    "we start with an even stronger version of lock - step equivalence which we call _ strict lock - step equivalence_.    for simplicity , we restrict attention to ealgebras with a fixed superuniverse . in other words , we suppose that all initial states have the same superuniverse",
    ". this assumption does not reduce generality because the superuniverse can be always chosen to be sufficiently large .",
    "let @xmath187 and @xmath188 be ealgebras with the same superuniverse and suppose that @xmath189 is a one - to - one mapping from the states of @xmath187 onto the states of @xmath188 such that if @xmath190 then @xmath40 and @xmath191 have identical interpretations of the function names common to @xmath192 and @xmath188 . call a run @xmath193 of @xmath187 _ strictly @xmath189-similar _ to a partially ordered run @xmath194 of @xmath188 if there is an isomorphism @xmath195 such that for every finite initial segment @xmath24 of @xmath74 , @xmath196 , where @xmath197 .",
    "call @xmath187 and @xmath188 _ strictly @xmath189-similar _ if every run of @xmath187 is strictly @xmath189-similar to a run of @xmath188 , and every run of @xmath188 is @xmath198-similar to a run of @xmath187 . finally call @xmath187 and @xmath188 _ strictly lock - step equivalent _ if there exists an @xmath189 such that they are strictly @xmath189-similar .",
    "ideally we would like to prove that @xmath18  and @xmath19  are strictly lock - step equivalent .",
    "unfortunately this is false , which is especially easy to see if the universe data is finite . in this case ,",
    "any run of @xmath19  has only finitely many different states ; this is not true for @xmath18  because @xmath12 and @xmath14 may take arbitrarily large integer values .",
    "one can rewrite either @xmath18  or @xmath19  to make them strictly lock - step equivalent .",
    "for example , @xmath19  can be modified to perform math on @xmath13 and @xmath15 over integers instead of @xmath107 .",
    "we will not change either ealgebra ; instead we will slightly weaken the notion of strict lock - step equivalence .",
    "if an agent @xmath43 of an ealgebra @xmath187 is enabled at a state @xmath40 , let result@xmath199 be the result of firing @xmath43 at @xmath40 ; otherwise let result@xmath200 .",
    "say that an equivalence relation @xmath201 on the states of @xmath187 _ respects _ a function name @xmath25 of @xmath187 if @xmath25 has the same interpretation in equivalent states .",
    "the equivalence classes of @xmath40 will be denoted @xmath202 $ ] and called the _ configuration _ of @xmath40 .",
    "call @xmath201 a _ congruence _ if @xmath203 for any states @xmath204 and any agent @xmath43 .",
    "let @xmath187 and @xmath188 be ealgebras with the same superuniverse and congruences @xmath205 and @xmath206 respectively .",
    "( we will drop the subscripts on @xmath201 when no confusion arises . )",
    "we suppose that either congruence respects the function names common to @xmath187 and @xmath188 .",
    "further , let @xmath189 be a one - to - one mapping of @xmath205-configurations onto @xmath206-configurations such that , for every function name @xmath25 common to @xmath187 and @xmath188 , if @xmath207 ) = [ b]$ ] , then @xmath208",
    ".    call a partially ordered run @xmath193 of @xmath187 _ @xmath189-similar _ to a partially ordered run @xmath194 of @xmath188 if there is an isomorphism @xmath195 such that , for every finite initial segment @xmath24 of @xmath74 , @xmath209 ) = [ \\tau(y)]$ ] , where @xmath197 . call @xmath187 and @xmath188 _ @xmath189-similar _",
    "if every run of @xmath187 is @xmath189-similar to a run of @xmath188 , and every run of @xmath188 is @xmath198-similar to a run of @xmath187 . call @xmath187 and @xmath188 _",
    "lock - step equivalent _",
    "( with respect to @xmath205 and @xmath206 ) if there exists an @xmath189 such that @xmath187 and @xmath188 are @xmath189-similar .",
    "note that strict lock - step equivalence is a special case of lock - step equivalence , where @xmath205 and @xmath206 are both the identity relation .",
    "assuming that @xmath18  and @xmath19  have the same superuniverse , we will show that @xmath18  is lock - step equivalent to @xmath19  with respect to the congruences defined below .",
    "the assumption that @xmath18  and @xmath19  have the same superuniverse means essentially that the superuniverse of @xmath19  contains all integers even though most of them are not needed .",
    "it is possible to remove the assumption .",
    "this leads to slight modifications in the proof .",
    "one can not require that a common function name @xmath25 has literally the same interpretation in a state of @xmath18  and a state of @xmath19 .",
    "instead require that the interpretations are essentially the same .",
    "for example , if @xmath25 is a predicate , require that the set of tuples where @xmath25 is true is the same .    for states @xmath210 of @xmath19 ,",
    "@xmath211 if @xmath212 .",
    "since each configuration of @xmath19  has only one element , we identify a state of @xmath19  with its configuration .",
    "let @xmath213 denote the value of an expression @xmath214 at a state @xmath40 .    for states @xmath47 of @xmath18 , @xmath215 if :    * @xmath216 * @xmath217 * @xmath208 for all other function names @xmath25 .",
    "let @xmath218 represent integer division : @xmath219 .",
    "[ lem0 ] if @xmath220 then we have the following modulo @xmath221 :    * @xmath222 = @xmath223 * @xmath224 = @xmath225    we prove the desired property for @xmath12 ; the proof for @xmath14 is similar .    by the definition of @xmath226",
    ", we have the following modulo @xmath227 : @xmath228 .",
    "thus , there are non - negative integers @xmath229 such that @xmath230 , @xmath231 , @xmath232 , and @xmath233 . hence @xmath234 and @xmath235 , which are equal modulo @xmath221 .",
    "we define a mapping @xmath189 from configurations of @xmath18  onto configurations of @xmath19 .    if @xmath40 is a state of @xmath18 , then @xmath207)$ ] is the state @xmath236 of @xmath19  such that @xmath237 and for all common function names @xmath25 , @xmath238 .",
    "thus , @xmath189 relates the counters @xmath239 used in @xmath18  and the counters @xmath240 used in @xmath19 .",
    "( notice that by lemma [ lem0 ] , @xmath189 is well - defined . ) we have not said anything about _ mode _ because _ mode _ is uniquely defined by the rest of the state ( see lemma [ modelem ] in section [ proofs ] ) and is redundant .",
    "we now prove that @xmath18  and @xmath19  are @xmath189-similar .",
    "we say that @xmath40 is a state of a run @xmath241 if @xmath242 for some finite initial segment @xmath24 of @xmath74 .",
    "[ lem1 ] for any state @xmath191 of any run of @xmath18 , @xmath243 .    by induction .",
    "initially , @xmath244 .",
    "let @xmath241 be a run of @xmath18 .",
    "let @xmath24 be a finite initial segment of @xmath74 with maximal element @xmath82 , such that @xmath245 holds in @xmath246 .",
    "let @xmath247 .    *",
    "if @xmath85 is the front end agent and is enabled in @xmath40 , then @xmath248 .",
    "the front end agent increments @xmath12 but does not alter @xmath14 ; thus , @xmath249 . * if @xmath85 is the back end agent and is enabled in @xmath40 , then @xmath250 .",
    "the back end agent increments @xmath14 but does not alter @xmath12 ; thus , @xmath251 .",
    "[ lemk ] fix a non - negative integer @xmath252 . for any run @xmath193 of @xmath18",
    ", the k - slot moves of @xmath74 ( that is , the moves of @xmath74 which involve buffer(@xmath117 ) ) are linearly ordered .",
    "similar to lemma  [ orderingr1 ] .",
    "[ lem2 ] for any run of @xmath19 , there is a mapping in from states of @xmath19  to @xmath106  such that if @xmath253 , then :    * inputturn(me ) is true for agent @xmath117 and for no other agent .",
    "* for all @xmath254 , @xmath255 .",
    "* for all @xmath256 , @xmath257 .    by induction",
    "initially , agent @xmath131 ( and no other ) satisfies _",
    "inputturn(me ) _ and @xmath258 holds for every agent @xmath3 .",
    "thus , if @xmath236 is an initial state , @xmath259 .",
    "let @xmath241 be a run of @xmath19 .",
    "let @xmath90 be a finite initial segment of @xmath74 with maximal element @xmath82 , such that the requirements hold in @xmath260 .",
    "let @xmath261 .",
    "if @xmath85 executes rule put , @xmath13 is not modified and @xmath262 .",
    "otherwise , if rule get is enabled for @xmath85 , executing rule get increments @xmath13 ; the desired @xmath263 .",
    "this is obvious if @xmath264 .",
    "if @xmath265 , then all values of @xmath13 are equal in @xmath266 and @xmath267 satisfies the requirements .",
    "[ lem3 ] for any run of @xmath19 , there is a mapping out from states of @xmath19  to @xmath106  such that if @xmath268 , then :    * outputturn(me ) is true for agent @xmath117 and no other agent .",
    "* for all @xmath254 , @xmath269 .",
    "* for all @xmath256 , @xmath270 .",
    "parallel to that of the last lemma .",
    "it is easy to see that every move @xmath82 of @xmath19  involves an execution of rule get or rule put but not both .",
    "( more precisely , consider finite initial segments @xmath90 of moves where @xmath82 is a maximal element of @xmath90 .",
    "any such @xmath90 is obtained from @xmath271 either by executing get in state @xmath272 , or executing put in state @xmath272 . ) in the first case , call @xmath82 a get move . in the second case , call @xmath82 a put move .",
    "[ lem4 ] in any run @xmath193 of @xmath19 , all get moves are linearly ordered and all put moves are linearly ordered .",
    "we prove the claim for rule get ; the proof for rule put is similar . by contradiction , suppose that are two incomparable get moves @xmath82 and @xmath81 . by the coherence condition for runs , both rules are enabled in state @xmath273 . by lemma [ lem2 ] , a(@xmath82 ) = a(@xmath81 ) .",
    "but all moves of the same agent are ordered ; this gives the desired contradiction .",
    "[ lem5 ] [ modelem ] in any state @xmath266 of any run of @xmath19 , for any agent k , @xmath274    we fix a @xmath117 and do induction over runs .",
    "initially , @xmath275 and @xmath276 for every agent @xmath117 .",
    "let @xmath90 be a finite initial segment of a run with maximal element @xmath82 such that ( by the induction hypothesis ) the required condition holds in @xmath277 .",
    "let @xmath261 .",
    "if @xmath278 , none of @xmath279 , @xmath280 , and @xmath281 are affected by executing @xmath85 in @xmath236 , so the condition holds in @xmath266 . if @xmath282 , we have two cases .    *",
    "if agent @xmath117 executes rule get in state @xmath236 , we must have @xmath283 ( from rule get ) and @xmath284 ( by the induction hypothesis ) . firing rule get yields @xmath285 and @xmath286 . *",
    "if agent @xmath117 executes rule put in state @xmath236 , we must have @xmath287 ( from rule put ) and @xmath288 ( by the induction hypothesis ) .",
    "firing rule get yields @xmath289 and @xmath290",
    ".    remark .",
    "this lemma shows that function _",
    "is indeed redundant .",
    "[ leminout ] if @xmath207 ) = c$ ] , then @xmath291 and @xmath292 .",
    "recall that _",
    "in(c ) _ is the agent @xmath117 for which _ inputturn(k)_@xmath293 holds .",
    "lemma [ lem2 ] asserts that @xmath294 has one value for @xmath254 and another for @xmath295 . by the definition of @xmath189 ,",
    "this `` switch - point '' in @xmath13 occurs at @xmath296 .",
    "the proof for @xmath297 is similar .",
    "[ lem11 ] module frontend is enabled in state @xmath40 of @xmath18  iff rule get is enabled in state @xmath298)$ ] of @xmath19  for agent @xmath299 .",
    "let @xmath300 , so that _ inputturn(k)@xmath293 _ holds .",
    "both frontend and get have _ insendbit @xmath161 inreceivebit _ in their guards .",
    "it thus suffices to show that @xmath301 iff @xmath302 = get . by lemma [ lem5 ] , it suffices to show that @xmath301 iff @xmath284 .",
    ". there exist non - negative integers @xmath304 such that @xmath305 , @xmath306 , and @xmath307 .",
    "( note that by lemma [ leminout ] , @xmath308 . )    by lemma [ lem1 ] , @xmath248 .",
    "there are two cases .    *",
    "@xmath309 and @xmath310 . by definition of @xmath189",
    ", we have that , modulo 2 , @xmath311 and for all @xmath312 , @xmath313 .",
    "since @xmath310 , we have that , modulo 2 , @xmath314 , as desired . *",
    "@xmath315 and @xmath316 . by definition of @xmath189",
    ", we have that , modulo 2 , @xmath311 and for all @xmath317 , @xmath318 = 1 - @xmath319 . since @xmath316 , we have that , modulo 2 , @xmath320 , as desired .",
    "on the other hand , suppose @xmath321 .",
    "then @xmath222 and @xmath322 differ by 1 . by definition of @xmath189 , @xmath323 for all @xmath3 , including @xmath117 .",
    "[ lem12 ] module backend is enabled in state @xmath40 iff rule put is enabled in state @xmath298)$ ] for agent @xmath297 .",
    "similar to that of the last lemma .",
    "[ lem13 ] suppose that module frontend is enabled in a state @xmath40 of @xmath18  for the front end agent @xmath324 and rule get is enabled in a state @xmath298)$ ] of @xmath19  for agent @xmath299 .",
    "let @xmath325 and @xmath326 .",
    "then @xmath327)$ ] .",
    "we check that @xmath328 ) = d$ ] .",
    "* both agents execute _ inreceivebit : = 1  inreceivebit_. * the front end agent executes _",
    "buffer(@xmath12 mod n ) : = inputdatum_. agent @xmath299 executes _",
    "buffer(in(c ) ) : = inputdatum_. by lemma [ leminout ] , _",
    "in(c ) = @xmath296 _ , so these updates are identical . *",
    "the front end agent executes @xmath329 .",
    "agent @xmath299 executes @xmath330 .",
    "the definition of @xmath189 and the fact that @xmath331)}$ ] for all @xmath332 imply that @xmath333)}$ ] .",
    "* agent @xmath299 executes _",
    "mode(in(c ) ) : = put_. by lemma [ lem5 ] , this update is redundant and need not have a corresponding update by the front end agent .    [ lem14 ] suppose that module backend is enabled in a state @xmath40 of @xmath18  for the back end agent @xmath334 and rule put is enabled in a state @xmath298)$ ] of @xmath19for agent @xmath297 .",
    "let @xmath335 and @xmath336 .",
    "then @xmath337)$ ] .",
    "parallel to that of the last theorem .",
    "[ isequiv ] @xmath18  is lock - step equivalent to @xmath19 .",
    "let @xmath338 and @xmath339 .",
    "we begin by showing that any run @xmath193 of @xmath18  is @xmath189-similar to a run of @xmath19 , using the definition of @xmath189 given earlier .",
    "construct a run @xmath340 of @xmath19 , where @xmath341)$ ] and @xmath342 is defined as follows .",
    "let @xmath82 be a move of @xmath74 , @xmath343 , and @xmath344)$ ] .",
    "then @xmath345 if @xmath85 is the front end agent , and @xmath346 if @xmath85 is the back end agent .",
    "we check that @xmath340 satisfies the four requirements for a run of @xmath19  stated in section [ runs ] .    1 .",
    "trivial , since @xmath193 is a run .",
    "2 .   by lemma",
    "[ lemk ] , it suffices to show that for any @xmath82 , if @xmath347 , then @xmath85 is a @xmath117-slot move . by the construction above and lemma [ leminout ]",
    ", we have modulo n that @xmath348 if @xmath85 is the front end agent and @xmath349 if @xmath85 is the back end agent . in either case",
    ", @xmath82 is a @xmath117-slot move .",
    "3 .   since @xmath350 , @xmath351 maps finite initial segments of @xmath74 to states of @xmath19 .",
    "coherence_. let @xmath90 be a finite initial segment of @xmath74 with a maximal element @xmath82 , and @xmath91 .",
    "result(a(@xmath82),@xmath86(x ) ) = @xmath86(y)_. by lemma [ lem11 ] or [ lem12 ] , @xmath352 is enabled in @xmath353 . by lemma [ lem13 ] or [ lem14 ] , _",
    "result(@xmath354 ) = @xmath355_.    continuing , we must also show that for any run @xmath340 of @xmath19 , there is a run @xmath193 of @xmath18which is @xmath189-similar to it .",
    "we define @xmath83 as follows .",
    "consider the action of agent @xmath352 at state @xmath356 .",
    "if @xmath352 executes rule get , set @xmath85 to be the front end agent .",
    "if @xmath352 executes rule put , set @xmath85 to be the back end agent .",
    "we check that the moves of the front end agent are linearly ordered . by lemma [ lem4 ]",
    ", it suffices to show that if @xmath85 is the front end agent , then @xmath352 executes get in state @xmath356  which is true by construction of @xmath83 .",
    "a similar argument shows that the moves of the back end agent are linearly ordered .",
    "we define @xmath86 inductively over finite initial segments of @xmath74 .",
    "@xmath89 is the unique initial state in @xmath357 .",
    "let @xmath90 be a finite initial segment with a maximal element @xmath82 such that @xmath86 is defined at @xmath91 .",
    "choose @xmath92 from @xmath358 such that @xmath359 .",
    "is it possible to select such a @xmath92 ?",
    "yes . by lemma [ lem11 ] or [ lem12 ] ,",
    "@xmath85 is enabled in @xmath88 iff @xmath352 is enabled in @xmath353 . by lemma [ lem13 ] or [ lem14 ] , _",
    "result(@xmath360 ) @xmath361 @xmath198(result(@xmath362))_. it is easy to check that @xmath241 is a run of @xmath18  which is @xmath189-similar to @xmath363 .",
    "we have proven that our formalizations @xmath18  and @xmath19  of @xmath8  and @xmath9  are lock - step equivalent .",
    "nevertheless , @xmath8  and @xmath9  are inequivalent in various other ways . in the following discussion",
    "we exhibit some of these inequivalences .",
    "the discussion is informal , but it is not difficult to prove these inequivalences using appropriate formalizations of @xmath8  and @xmath9 .",
    "let @xmath364 and @xmath365 .",
    "@xmath366 uses unrestricted integers as its counters ; in contrast , @xmath367 uses only single bits for the same purpose .",
    "we have already used this phenomenon to show that @xmath18and @xmath19  are not strictly lock - step equivalent .",
    "one can put the same argument in a more practical way .",
    "imagine that the universe data is finite and small , and that a computer with limited memory is used to execute @xmath366 and @xmath367 .",
    "@xmath366 s counters may eventually exceed the memory capacity of the computer .",
    "@xmath367 would have no such problem .",
    "@xmath366 shares access to the buffer between both processes ; in contrast , each process in @xmath367 has exclusive access to its portion of the buffer .",
    "conversely , processes in @xmath367 share access to both the input and output channels , while each process in @xmath366 has exclusive access to one channel .",
    "imagine an architecture in which processes pay in one way or another for acquiring a channel .",
    "@xmath367 would be more expensive to use on such a system .      how many internal locations used by each algorithm must be shared between processes ?",
    "@xmath366 shares access to @xmath368 locations : the @xmath2 locations of the buffer and @xmath221 counter variables .",
    "@xmath367 shares access to @xmath227 locations : the @xmath227 counter variables .",
    "sharing locations may not be without cost ; some provision must be made for handling conflicts ( _ e.g. _ read / write conflicts ) at a given location .",
    "imagine that a user must pay for each shared location ( but not for private variables , regardless of size ) .",
    "in such a scenario , @xmath367 would be more expensive than @xmath366 to run .",
    "these contrasts can be made a little more dramatic .",
    "for example , one could construct another version of the ring buffer algorithm which uses @xmath227 processes , each of which is responsible for an input or output action ( but not both ) to a particular buffer position .",
    "all of the locations it uses will be shared .",
    "it is lock - step equivalent to @xmath366 and @xmath367 ; yet , few people would choose to use this version because it exacerbates the disadvantages of @xmath367 .",
    "alternatively , one could write a single processor ( sequential ) algorithm which is equivalent in a different sense to @xmath366 and @xmath367 ; it would produce the same output as @xmath366 and @xmath367 when given the same input but would have the disadvantage of not allowing all orderings of actions possible for @xmath366 and @xmath367 .",
    "e. brger and d. rosenzweig , `` the wam - definition and compiler correctness , '' in l.c .",
    "beierle and l. pluemer , eds . , _ logic programming : formal methods and practical applications _ , north - holland series in computer science and artificial intelligence , 1994 .",
    "y. gurevich , `` evolving algebras : an attempt to discover semantics '' , _ current trends in theoretical computer science _ , eds . g. rozenberg and a. salomaa , world scientific , 1993 , 266292 .",
    "( first published in bull .",
    "eatcs 57 ( 1991 ) , 264284 ; an updated version appears in @xcite . )"
  ],
  "abstract_text": [
    "<S> in a recent provocative paper , lamport points out `` the insubstantiality of processes '' by proving the equivalence of two different decompositions of the same intuitive algorithm by means of temporal formulas . </S>",
    "<S> we point out that the correct equivalence of algorithms is itself in the eye of the beholder . </S>",
    "<S> we discuss a number of related issues and , in particular , whether algorithms can be proved equivalent directly .    6.5 in 8.5 in </S>"
  ]
}