{
  "article_text": [
    "a _ beacon _ is a facility or a device that attracts objects within a given domain .",
    "we assume that objects in the domain , such as mobile agents or robots , know the exact location or the direction towards an activated beacon in the domain , even if it is not directly visible .",
    "more precisely , given a polygonal domain @xmath1 , a beacon is placed at a fixed point in @xmath1 . when a beacon @xmath5 is activated , an object @xmath6 moves along the ray starting at @xmath7 and towards the beacon @xmath8 until it either hits the boundary @xmath9 of @xmath1 , or it reaches @xmath8 .",
    "( see figure  [ fig : intro]a . )",
    "if @xmath7 hits an edge @xmath10 of @xmath1 , then it continues to move along @xmath10 in the direction such that the euclidean distance to @xmath8 decreases .",
    "when @xmath7 reaches an endpoint of @xmath10 , it may move along the ray from the current position of @xmath7 towards @xmath8 , if possible , until it again hits the boundary @xmath9 of @xmath1 .",
    "so , @xmath7 is pulled by @xmath8 in a greedy way , so that the euclidean distance to @xmath8 is monotonically decreasing , as an iron particle is pulled by a magnet .",
    "there are two possible outcomes : either @xmath7 finally reaches @xmath8 , or it stops at a local minimum , called a _",
    "dead point _",
    ", where there is no direction in which , locally , the distance to @xmath8 strictly decreases . in the former case",
    ", @xmath7 is said to be _ attracted _ by the beacon @xmath8 .",
    "this model of beacon attraction was recently suggested by biro  @xcite , and extends the classical notion of visibility .",
    "we consider two problems based on this model : the _ coverage _ and the _ routing _",
    "problem , introduced by biro  @xcite and biro et al .",
    "@xcite . in the beacon - based coverage problem",
    ", we need to place beacons in @xmath1 so that any point @xmath11 is attracted by at least one of the beacons . in this case , we say the set of beacons _ covers _ or _ guards _ @xmath1 . in the beacon - based routing problem ,",
    "we want to place beacons in @xmath1 so that every pair @xmath12 of points can be routed : we say that @xmath13 is _ routed _ to @xmath14 if there is a sequence of beacons in @xmath1 that can be activated and deactivated one at a time , such that the source @xmath13 is successively attracted by each of beacon of this sequence , and finally reaches the target @xmath14 , which is regarded as a beacon .    in this paper , we are interested in combinatorial bounds on the number of beacons required for coverage and routing , in particular when the given domain @xmath1 is a simple rectilinear polygon .",
    "our bounds are variations on visibility - based guarding results , such as the well - known _ art gallery theorem _",
    "@xcite and its relatives  @xcite .",
    "the beacon - based coverage problem is analogous to the art gallery problem , while the beacon - based routing problem is analogous to the _ guarded guards _",
    "problem  @xcite , which asks for a set of point guards in @xmath1 such that every point is visible from at least one guard and every guard is visible from another guard . for the art gallery problem",
    ", it is known that @xmath15 point guards are sufficient , and sometimes necessary , to guard a simple polygon @xmath1 with @xmath2 vertices  @xcite . if @xmath1 is rectilinear , then @xmath16 are necessary and sufficient  @xcite . in the guarded guards problem",
    ", this number becomes @xmath17 for simple polygons and @xmath15 for simple rectilinear polygons  @xcite .",
    "other related results are mentioned in the book  @xcite by orourke or the surveys by shermer  @xcite and urrutia  @xcite .",
    "biro et al .",
    "@xcite initiated research on combinatorial bounds for beacon - based coverage and routing problems , with several nontrivial bounds for different types of domains such as rectilinear or non rectilinear polygons , with or without holes .",
    "when the domain @xmath1 is a simple rectilinear polygon with @xmath2 vertices , they showed that @xmath16 beacons are sufficient to cover any rectilinear polygon with @xmath2 vertices , while @xmath18 beacons are necessary to cover the same example in  [ fig : intro ] , and conjectured that @xmath18 would be the tight bound .",
    "they also proved that @xmath19 beacons are always sufficient for routing , and some domains , such as the domain depicted in  [ fig : intro]a , require @xmath20 beacons .",
    "c|c|c|c|c & &    ' '' ''    ' '' ''     + & best results & our results & best results & our results    ' '' ''    ' '' ''     + coverage & @xmath18 @xcite & @xmath21 [ theorem  [ thm : covering ] ] & @xmath22 @xcite & @xmath21    ' '' ''    ' '' ''     + routing & @xmath23 @xcite & @xmath24 & @xmath25 @xcite & @xmath26    ' '' ''    ' '' ''     +    [ [ our - results . ] ] our results . + + + + + + + + + + + +    in this paper , we first prove tight bounds on beacon - based coverage problems for simple rectilinear polygons .",
    "( see  [ tbl : summary ] . ) in section  [ sec : coverage ] , we give a lower bound construction that requires @xmath0 beacons , and then we present a method of placing the same number of beacons to cover @xmath1 , which matches the lower bound we have constructed .",
    "these results settle the open questions on the beacon - based coverage problems for simple rectilinear polygons posed by biro et al .",
    "we also consider the case of monotone polygons : for routing in a monotone rectilinear polygon , the same bound @xmath20 holds , while @xmath18 beacons are always sufficient to cover a monotone rectilinear polygon .",
    "we next improve the upper bound from @xmath27 to @xmath3 for the routing problem in section  [ sec : routing ] .",
    "we also slightly improve the lower bound from @xmath28 to @xmath24 for any @xmath29 .",
    "we also present an optimal linear - time algorithm that computes the _ beacon kernel _ @xmath30 of a simple rectilinear polygon @xmath1 in section  [ sec : kernel ] .",
    "the beacon kernel @xmath30 of @xmath1 is defined to be the set of points @xmath11 such that placing a single beacon at @xmath7 is sufficient to completely cover @xmath1 .",
    "biro first presented an @xmath31-time algorithm that computes the kernel @xmath30 of a simple polygon @xmath1 in his thesis  @xcite , and kouhestani et al .",
    "@xcite soon improved it to @xmath32 time with the observation that @xmath30 has a linear complexity .",
    "our algorithm is based on a new , yet simple , characterization of the kernel @xmath30 .     by biro et al .",
    "a point @xmath6 is attracted by a beacon @xmath8 through the beacon attraction path depicted by the thick gray path , while @xmath33 is not since it stops at the dead point @xmath34 .",
    "( b ) another rectilinear polygon @xmath1 .",
    "if one partitions @xmath1 by the horizontal cut @xmath35 ( dashed segment ) at @xmath36 into two subpolygons @xmath37 and @xmath38 and handle each separately , then it does not guarantee that @xmath1 is guarded . in this case , @xmath39 is attracted by @xmath8 inside the subpolygon @xmath37 while it is not the case in the whole domain @xmath1 . ]",
    "a _ simple rectilinear polygon _ is a simple polygon whose edges are either horizontal or vertical .",
    "the internal angle at each vertex of a rectilinear polygon is always @xmath40 or @xmath41 .",
    "we call a vertex with internal angle @xmath40 a _ convex vertex _ , and a vertex with internal angle @xmath41 is called a _",
    "reflex vertex_. for any simple rectilinear polygon @xmath1 , we let @xmath42 be the number of its reflex vertices . if @xmath1 has @xmath2 vertices in total , then @xmath43 , because the sum of the signed turning angles along @xmath9 is @xmath44 .",
    "an edge of @xmath1 between two convex vertices is called a _ convex edge _ , and an edge between two reflex vertices",
    "is called a _ reflex edge_. each convex or reflex edge @xmath10 shall be called _ top _ , _ bottom _ , _ left _ or _ right _ according to its orientation : if @xmath10 is horizontal and the two adjacent edges of @xmath10 are downwards from @xmath10 , then @xmath10 is a top convex or reflex edge .",
    "( the edge @xmath10 in  [ fig : intro]b is a top reflex edge . ) for each edge @xmath10 of @xmath1 , we are often interested in the half - plane @xmath45 whose boundary supports @xmath10 and whose interior includes the interior of @xmath1 locally at @xmath10 .",
    "we shall call @xmath45 the _ half - plane supporting @xmath10_.    a rectilinear polygon @xmath1 is called _ @xmath46-monotone _ ( or _ @xmath47-monotone _ ) if any vertical ( resp . ,",
    "horizontal ) line intersects @xmath1 in at most one connected component .",
    "if @xmath1 is both @xmath46-monotone and @xmath47-monotone , then @xmath1 is said to be _",
    "@xmath48-monotone_. from the definition of the monotonicity , we observe the following .",
    "[ obs : monotone ] a rectilinear polygon @xmath1 is @xmath46-monotone if and only if @xmath1 has no vertical reflex edge . hence , @xmath1 is @xmath48-monotone if and only if @xmath1 has no reflex edge .",
    "our approach to attain tight upper bounds relies on partitioning a given rectilinear polygon @xmath1 into subpolygons by cuts .",
    "more precisely , a _ cut _ in @xmath1 is a chord of a polygon is a line segment between two points on the boundary such that all points on @xmath35 except the two endpoints lie in the interior of the polygon .",
    "] of @xmath1 that is horizontal or vertical . there is a unique cut at a point @xmath7 on the boundary @xmath9 of @xmath1 unless @xmath7 is a vertex of @xmath1 . if @xmath7 is a reflex vertex , then there are two cuts at @xmath7 , one of which is _ horizontal _ and the other is _ vertical _ , while there is no cut at @xmath7 if @xmath7 is a convex vertex .",
    "any horizontal cut @xmath35 in @xmath1 partitions @xmath1 into two subpolygons : one below @xmath35 , denoted by @xmath49 , and the other above @xmath35 denoted by @xmath50 .",
    "analogously , for any vertical cut @xmath35 , let @xmath49 and @xmath50 denote the subpolygons to the left and to the right of @xmath35 , respectively .    for a beacon @xmath8 and a point @xmath11 ,",
    "the _ beacon attraction path _ of @xmath7 with respect to @xmath8 , or simply the _ @xmath8-attraction path _ of @xmath7 , is the piecewise linear path from @xmath7 created by the attraction of @xmath8 as described in section  [ sec : intro ] .",
    "( see  [ fig : intro]a . )",
    "if the @xmath8-attraction path of @xmath7 reaches @xmath8 , then we say that @xmath7 is _ attracted _ to @xmath8 .",
    "as was done for the classical visibility notion  @xcite , a natural approach would find a partition of @xmath1 into smaller subpolygons of similar size , and handle them recursively .",
    "however , we must be careful when choosing a partition of @xmath1 , because an attraction path within a subpolygon may not be an attraction path within @xmath1 .",
    "( see  [ fig : intro]b . )",
    "so @xmath1 is not necessarily guarded by the union of the guarding sets of the subpolygons .",
    "thus , when applying a cut in @xmath1 , we want to make sure that beacon attraction paths in a subpolygon @xmath51 of @xmath1 do not _ hit _ the new edge of @xmath51 produced by @xmath35 . to be more precise , we say that an edge @xmath10 of @xmath1 is _ hit _ by @xmath7 with respect to @xmath8 if the @xmath8-attraction path of @xmath7 makes a bend along @xmath10 .",
    "[ obs : convex_edge ] let @xmath8 be a beacon in @xmath1 and @xmath11 be any point such that @xmath7 is attracted by @xmath8 .",
    "if the @xmath8-attraction path of @xmath7 hits an edge @xmath10 of @xmath1 , then @xmath52 and @xmath53 , where @xmath45 denotes the half - plane supporting @xmath10 .",
    "therefore , no beacon attraction path hits a convex edge of @xmath1 .",
    "thus , if we choose a cut that becomes a convex edge on both sides , then we will be able to handle each subpolygon separately .    in this paper",
    ", we make the general position assumption that _ no cut in @xmath1 connects two reflex vertices .",
    "_ this general position can be obtained by perturbing the reflex vertices of @xmath1 locally , and such a perturbation does not harm the upper bounds on our problems in general .",
    "it will be discussed in the full version of the paper .",
    "before continuing to the beacon - based coverage problem , we consider simple rectilinear polygons that can be covered by a single beacon .",
    "this is related to the _ beacon kernel _ @xmath30 of a simple polygon @xmath1 , defined to be the set of all points @xmath6 such that a beacon placed at @xmath7 attracts all points in @xmath1 .",
    "specifically , we give a characterization of rectilinear polygons @xmath1 such that @xmath54 .",
    "our characterization is simple and constructive , resulting in a linear - time algorithm that computes the beacon kernel @xmath30 of any simple rectilinear polygon @xmath1 .",
    "let @xmath55 be the set of reflex vertices of @xmath1 .",
    "let @xmath56 be any reflex vertex with two incident edges @xmath57 and @xmath58 .",
    "for @xmath59 , define @xmath60 to be the closed half - plane whose boundary is the line orthogonal to @xmath61 through @xmath36 and whose interior excludes @xmath61 .",
    "let @xmath62 .",
    "observe that @xmath63 is a closed cone with apex @xmath36 .",
    "biro  ( * ? ? ? * theorem 5.2.8 ) showed that the kernel @xmath30 of @xmath1 is the set of points in @xmath1 that lie in @xmath63 for all reflex vertices @xmath56 :    [ lem : kernel_biro ] for any simple polygon @xmath1 with set @xmath55 of reflex vertices , it holds that @xmath64 where @xmath65 denotes the complement of @xmath63 .",
    "note that lemma  [ lem : kernel_biro ] holds for any simple polygon @xmath1 .",
    "we now assume that @xmath1 is a simple rectilinear polygon .",
    "then , for any reflex vertex @xmath66 , the set @xmath63 forms a closed cone with aperture angle @xmath41 whose boundary consists of two rays following the two edges incident to @xmath36",
    ". let @xmath67 be the set of reflex vertices incident to a reflex edge , and let @xmath68 .",
    "so a vertex in @xmath69 is adjacent to at least one reflex vertex that also belongs to @xmath69 , and a vertex in @xmath70 is always adjacent to two convex vertices .",
    "we then observe the following .",
    "[ lem : kernel_lem ] for any simple rectilinear polygon @xmath1 , @xmath71    for a contradiction , suppose that there exists a point @xmath6 that is included in @xmath72 but avoids @xmath73 .",
    "then , there must exist a reflex vertex @xmath74 such that @xmath75 , or equivalently , @xmath76 .",
    "that is , @xmath77 and @xmath78 have a nonempty intersection .",
    "let @xmath79 and @xmath80 be the two vertices adjacent to @xmath36 such that @xmath79 , @xmath36 , and @xmath80 appear on @xmath9 in counterclockwise order .",
    "note that both @xmath79 and @xmath80 are convex since @xmath74 .",
    ".,scaledwidth=70.0% ]    since @xmath81 and @xmath78 is an open set , the boundary @xmath9 of @xmath1 crosses @xmath82 at some points other than the two edges @xmath83 and @xmath84 .",
    "let @xmath85 be the first point in @xmath86 that we encounter when traveling along @xmath9 counterclockwise , starting at @xmath80 .",
    "analogously , let @xmath87 be the first point in @xmath86 that we encounter when traveling along @xmath9 clockwise , starting at @xmath79 .",
    "let @xmath88 and @xmath89 be the paths described above from @xmath80 to @xmath85 and from @xmath79 to @xmath87 , respectively . as @xmath90 and @xmath91 are subpaths of @xmath9 , they do not intersect , and we have @xmath92 and @xmath93 .",
    "the boundary @xmath82 of @xmath78 consists of two rays @xmath94 and @xmath95 , starting from @xmath36 towards @xmath80 and @xmath79 , respectively .",
    "we claim that either @xmath85 lies on @xmath94 or @xmath87 lies on @xmath95 .",
    "( see  [ fig : kernel]a . ) indeed , suppose that @xmath96",
    ". then @xmath90 should be contained in the region bounded by the simple closed curve @xmath97 , since @xmath90 does not intersect @xmath98 .",
    "this implies that @xmath85 must lie on @xmath99 .",
    "hence , our claim is true .    without any loss of generality , we assume that @xmath100 , the edge @xmath84 is horizontal , and the interior of @xmath1 lies locally above @xmath84 , as shown in  [ fig : kernel]b",
    ". then , the path @xmath90 must contain at least one top reflex edge @xmath10 lying above the line through @xmath80 and @xmath85 , since @xmath80 and @xmath85 have the same @xmath47-coordinate and @xmath90 avoids @xmath78 .",
    "let @xmath101 and @xmath102 be the two endpoints of @xmath10 , so @xmath103 . then @xmath104 is the half - plane @xmath45 supporting @xmath10 . since @xmath10 is a top reflex edge , @xmath105",
    "this is a contradiction to our assumption that @xmath106 intersects @xmath78 .",
    "let @xmath107 be the intersection of the half - planes @xmath45 supporting @xmath10 over all reflex edges @xmath10 of @xmath1 .",
    "we conclude the following .",
    "[ thm : kernel ] let @xmath1 be a simple rectilinear polygon .",
    "a point @xmath6 lies in its beacon kernel @xmath30 if and only if @xmath108 for any reflex edge @xmath10 of @xmath1 .",
    "therefore , it always holds that @xmath109 , and the kernel @xmath30 can be computed in linear time .",
    "recall that @xmath63 for any @xmath110 forms a cone with apex @xmath36 and aperture angle @xmath41 . since any @xmath110 is adjacent to another reflex vertex @xmath111 the intersection @xmath112 forms exactly the half - plane @xmath45 supporting the reflex edge @xmath10 with endpoints @xmath36 and @xmath80 .",
    "it implies that @xmath113 .",
    "so by lemma  [ lem : kernel_lem ] , we have @xmath114    the set @xmath107 is an intersection of axis - parallel halfplanes , so it is a ( possibly unbounded ) axis - parallel rectangle . in order to compute the kernel @xmath30",
    ", we identify the extreme reflex edge in each of the four directions to compute @xmath107 , and then intersect it with @xmath1 .",
    "this can be done in linear time .",
    "in this section , we study the beacon - based coverage problem for rectilinear polygons .",
    "a set of beacons in @xmath1 is said to _ cover _ or _ guard _",
    "@xmath1 if and only if every point @xmath11 can be attracted by at least one of them .",
    "our main result is the following .",
    "[ thm : covering ] let @xmath1 be a simple rectilinear polygon @xmath1 with @xmath115 vertices and @xmath116 reflex vertices",
    ". then @xmath117 beacons are sufficient to guard @xmath1 , and sometimes necessary .",
    "moreover , all these beacons can be placed at reflex vertices of @xmath1 .",
    "we now sketch the proof of theorem  [ thm : covering ] .",
    "the lower bound construction is a rectangular spiral @xmath118 consisting of a sequence of @xmath119 thin rectangles , as depicted in  [ fig : spirals ] .",
    "the sequence of vertices @xmath120 , where @xmath121 are the reflex vertices of @xmath118 , form a polyline called the _ spine _ of the spiral .",
    "the key idea is the following .",
    "consider the case @xmath122 (  [ fig : spirals]a ) . at first glance ,",
    "it looks like the spiral can be covered by two beacons @xmath123 and @xmath124 placed near @xmath102 and @xmath125 , respectively . however , at closer look , it appears that the small shaded triangular region on the bottom left corner is not covered .",
    "hence , @xmath126 requires @xmath127 beacons , as announced .",
    "more generally , we can prove that for a suitable choice of the edge lengths of the spine of @xmath118 , an optimal coverings for @xmath118 consists in placing a beacon at every third rectangle of @xmath118 , which yields the bound @xmath128 .",
    "the spine of @xmath118 is depicted in  [ fig : spirals]b and c , where the aspect ratio of the rectangles is roughly @xmath129 .     and",
    "@xmath124 in @xmath126 near @xmath102 and @xmath125 is not enough to cover the shaded region near the reflex vertex @xmath130 .",
    "( b)(c ) the spine of our construction @xmath118 for @xmath131 and for @xmath132 . ]",
    "the construction for the upper bound in theorem  [ thm : covering ] is more involved .",
    "we first prove that for any polygon with at most 3 reflex vertices , one beacon placed at a suitable reflex vertex is sufficient .",
    "for a larger number @xmath133 of reflex vertices , we proceed by induction .",
    "so we partition @xmath1 using a cut , and we handle each side recursively . as mentioned in section  [ sec : pre ] , the difficulty is that in some cases , the union of the two guarding sets of the subpolygons do not cover @xmath1 .",
    "so we will first try to perform a _ safe cut _",
    "@xmath35 , that is , a cut @xmath35 which is not incident to any reflex vertex , such that there is at least one reflex vertex on each side , and such that @xmath134 .",
    "( see  [ fig : covering_intro]a . )",
    "if such a cut exists , then we can recurse on both side . by observation  [ obs : convex_edge ] , the union of the guarding sets of the two subpolygons guards @xmath1 .",
    "unfortunately , some polygons do not admit any safe cut . in this case",
    ", we show by a careful case analysis that we can always find a suitable cut .",
    "( see the example in  [ fig : covering_intro]b . )     of a polygon with @xmath135 reflex vertices .",
    "( b ) this polygon admits no safe cut .",
    "we cut along @xmath34 , and the polygon is guarded by any two beacons @xmath8 and @xmath136 placed at reflex vertices of @xmath137 and @xmath138 , respectively .",
    "[ fig : covering_intro ] ]      in this section , we prove the lower bound in theorem  [ thm : covering ] .",
    "our construction is a spiral - like rectilinear polygon @xmath118 that can not be guarded by less than @xmath139 beacons .",
    "( see  [ fig : spirals ] . )",
    "more precisely , a rectilinear polygon is called a _ spiral _ if all its reflex vertices are consecutive along its boundary .",
    "the _ spine _ of a spiral @xmath1 with @xmath140 reflex vertices is the portion of its boundary @xmath9 connecting @xmath141 consecutive vertices @xmath142 such that @xmath143 are the reflex vertices of @xmath1 .",
    "( see  [ fig : spirals3]a . )",
    "note that the two end vertices @xmath144 and @xmath145 of the spine of a spiral are the only convex vertices that are adjacent to a reflex vertex .",
    "the spine can also be specified by the sequence of edge lengths @xmath146 such that @xmath147 is the length of the edge @xmath148 for @xmath149",
    ".     appears before @xmath150 along the spine , so @xmath151 .",
    "( b ) the partition of @xmath126 into rectangles @xmath152 .",
    "[ fig : spirals3 ] ]    we define an order @xmath153 among points in any spiral @xmath1 as follows .",
    "let @xmath154 be two points in @xmath1 .",
    "let @xmath155 and @xmath156 denote the closest point to @xmath7 and @xmath157 on the spine , according to the geodesic distance within @xmath1 .",
    "( see  [ fig : spirals3]a . )",
    "then we say that @xmath7 precedes @xmath157 , which we denote by @xmath151 , if @xmath155 precedes @xmath156 along the spine , that is , @xmath155 is on the portion of the spine between @xmath144 and @xmath156 .",
    "we will use the following partition of a spiral @xmath1 with @xmath140 reflex vertices into @xmath158 rectangular subpolygons .",
    "it is obtained by applying the vertical and horizontal cuts at @xmath159 for each @xmath160 and the cut at the midpoint of edge @xmath148 for each @xmath161 .",
    "we call these rectangles @xmath162 , ordered along the spine .",
    "( see  [ fig : spirals3]b . )    for any integer @xmath163 , let @xmath118 be the spiral with @xmath140 reflex vertices whose spine is determined by the following edge length sequence @xmath146 : for any nonnegative integer @xmath164 , @xmath165 where @xmath166 is a sufficiently small positive number and @xmath167 is a constant .",
    "( see  [ fig : spirals ] . )",
    "therefore , the rectangles @xmath152 corresponding to @xmath118 are as follows , for any @xmath168 .",
    "rectangle @xmath169 and @xmath170 have side lengths @xmath171 and @xmath172 .",
    "rectangle @xmath173 has side lengths @xmath174 and @xmath175 , both of which are strictly less than @xmath176 .",
    "let @xmath177 denote the smallest possible number of beacons that can guard @xmath118 .",
    "we will say that a sequence of beacons @xmath178 is a _ greedy placement _",
    "if @xmath179 , and the sequence @xmath180 is maximum in lexicographical order .",
    "so intuitively , we obtain the greedy placement by pushing the beacons as far as possible from the origin @xmath144 of the spiral , and giving priority to the earliest beacons in the sequence .",
    "clearly , @xmath123 must be placed in @xmath181 .",
    "we then observe the following for @xmath182 .",
    "[ lem : spiral_sub ] for @xmath183 , the @xmath168-th beacon @xmath184 in a greedy placement for @xmath118 is in @xmath185 .    .",
    "]    we prove the lemma by induction on @xmath168 .",
    "we first verify the lemma for @xmath124 . without loss of generality , we assume that the edge @xmath186 is a top reflex edge .",
    "let @xmath187 be the line through @xmath130 and @xmath123 .",
    "observe that @xmath123 attracts all points in @xmath188 , but not all of those in @xmath189 .",
    "more precisely , @xmath123 attracts those in @xmath189 below @xmath187 but miss those above @xmath187 .",
    "hence , @xmath124 must be placed on @xmath187 to cover the points in @xmath189 above @xmath187 .",
    "for our purpose , we compare the slopes of @xmath187 and any line through @xmath130 and a point in @xmath190 .",
    "( see  [ fig : spirals2]a . )",
    "recall that @xmath167 .",
    "the slope of @xmath187 is at least @xmath191 since @xmath192 , @xmath193 , @xmath194 , and the width @xmath195 of @xmath188 is at most @xmath176 . on the other hand ,",
    "the slope of any line through @xmath130 and a point in @xmath190 is at most @xmath196 since @xmath197 , @xmath198 , and the height @xmath199 of @xmath200 is at most @xmath176 .",
    "this implies that @xmath187 can not intersect @xmath190 .",
    "thus , if @xmath201 , then @xmath124 fails to attract some points near @xmath130 and above @xmath187 , similarly as in  [ fig : spirals]a , so @xmath124 must lie in @xmath200",
    ".    for the inductive step , assume that @xmath202 and @xmath203 lies in @xmath204 .",
    "if @xmath205 , then @xmath203 attracts all points in @xmath206 , that is , @xmath203 must be the last beacon in the greedy placement .",
    "but this is not the case for our assumption that @xmath207 .",
    "we thus have @xmath208 .",
    "then , @xmath209 can not be completely covered by @xmath203 , so the next beacon @xmath210 must cover @xmath209 partially .",
    "more precisely , @xmath210 must lie on the line @xmath211 through @xmath212 and @xmath203 . without loss of generality ,",
    "we assume that the edge @xmath213 is a right reflex edge .",
    "also , note that @xmath214 , since otherwise placing @xmath210 completes the greedy placement and thus @xmath215 , which is not the case .",
    "let @xmath216 , and let @xmath217 be the positive number such that @xmath218 . recall that @xmath219 is the length of edge @xmath220 . we then have @xmath221 , @xmath222 , @xmath223 , and @xmath224 .",
    "see  [ fig : spirals2](b ) .",
    "similarly to the above argument , the slope of @xmath225 is at least @xmath226 since @xmath227 lies in @xmath204 and @xmath228 . on the other hand ,",
    "the slope of any line through @xmath212 and any point in @xmath229 is at most @xmath230 since @xmath231 , this implies that the next beacon @xmath210 also must be placed in @xmath232 .",
    "the main result of this section follows :    [ lem : coverage_lower_bound ] the spiral @xmath118 defined above can not be guarded by less than @xmath233 beacons , where @xmath2 denotes the number of vertices of @xmath118 .      in this section , we prove the matching upper bound @xmath139 .",
    "our proof is by induction on @xmath140 .",
    "the following lemma handles the base case .",
    "[ lem : coverage_base ] any rectilinear polygon @xmath1 with at most three reflex vertices can be guarded by a single beacon . moreover",
    ", the beacon can be placed at a reflex vertex of @xmath1 , provided that @xmath1 has at least one .",
    "let @xmath1 be a rectilinear polygon with @xmath234 .",
    "if @xmath1 has no reflex edge , then @xmath1 is @xmath48-monotone by observation  [ obs : monotone ] , and thus a beacon placed at any point in @xmath1 guards @xmath1 by theorem  [ thm : kernel ] .",
    "observe that @xmath1 has at most two reflex edges , and this is possible only when its three reflex vertices are consecutive .",
    "assume that this is the case .",
    "then , the two reflex edges @xmath10 and @xmath235 of @xmath1 must be adjacent and share a reflex vertex @xmath36 .",
    "hence , the region @xmath236 forms a cone with the right angle at apex @xmath36 .",
    "since @xmath36 is obviously contained in @xmath1 , theorem  [ thm : kernel ] implies that @xmath237 , so placing a beacon at @xmath36 is sufficient to guard @xmath1 .",
    "now , suppose that @xmath1 has exactly one reflex edge @xmath10 .",
    "then , @xmath238 forms a half - plane , and @xmath10 is contained in @xmath1 .",
    "we place a beacon @xmath8 at a reflex vertex incident to @xmath10 .",
    "since @xmath239 by theorem  [ thm : kernel ] , @xmath8 guards @xmath1 .",
    "if @xmath133 , then we will partition @xmath1 using cuts .",
    "cut is a cut that is not incident to any vertex of @xmath1 .",
    "we will try to use normal cuts as often as possible , as the new edges in the subpolygons created by a normal cut are convex , and thus by observation  [ obs : convex_edge ] , these subpolygons can be handled separately .",
    "we are more interested in normal cuts with an additional property : a normal cut @xmath35 in @xmath1 is called _ safe _ if @xmath240 , @xmath241 , and @xmath242 .",
    "a normal cut @xmath35 in @xmath1 is called an _ @xmath243-cut _ if @xmath244 .",
    "we will abuse notation and write @xmath245 instead of @xmath246 .",
    "[ lem : safe_cut ] let @xmath35 be any normal cut in @xmath1 such that @xmath240 and @xmath241 .",
    "then , @xmath35 is safe if and only if either @xmath247 , or @xmath35 is a @xmath248-cut or an @xmath140-cut .",
    "let @xmath249 and @xmath250 .",
    "note that @xmath251 .",
    "since we assume that @xmath252 and @xmath253 , the cut @xmath35 is safe if and only if @xmath254 .",
    "first , suppose that @xmath247 . if @xmath35 is a @xmath248-cut or a @xmath255-cut , then @xmath256 or @xmath257 , which implies @xmath258 .",
    "if on the other hand @xmath35 is a @xmath259-cut , then we have @xmath260 , and thus @xmath261    now we assume that @xmath262 , that is , @xmath263 or @xmath264 . then @xmath35 is a @xmath248-cut or an @xmath140-cut if and only if @xmath256 or @xmath257 , which is equivalent to @xmath265 .",
    "if there is a safe cut @xmath35 in @xmath1 when @xmath133 , then one can partition @xmath1 into two subpolygons @xmath37 and @xmath38 by @xmath35 and attain the target bound @xmath266 on the number of beacons by handling each subpolygon by our induction hypothesis .",
    "but , this is not always the case : there exist rectilinear polygons @xmath1 that do not admit a safe cut when @xmath262 .    [ lem:1-cut ] suppose that @xmath1 admits no safe cut and @xmath267 .",
    "then , there exists a horizontal normal cut @xmath35 in @xmath1 such that either @xmath35 is a @xmath255-cut with @xmath268 , or @xmath35 is a @xmath259-cut with @xmath269 .    since @xmath1 admits no safe cut , we know that @xmath263 or @xmath264 by lemma  [ lem : safe_cut ] .",
    "we separately handle the cases where @xmath263 or @xmath270 .    ]    first , assume that @xmath270 . in this case , we show a stronger claim (  [ fig:1-cut]a ) :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ if @xmath270 , then for any top convex edge @xmath271 of @xmath1 , the first reflex vertex @xmath36 below @xmath271 is not an endpoint of any horizontal reflex edge of @xmath1 . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    this automatically proves the lemma : a normal cut @xmath35 just below @xmath36 is a @xmath255-cut and @xmath272 .",
    "suppose to the contrary that it is not the case , so there is a top convex edge @xmath271 of @xmath1 such that the first reflex vertex @xmath36 below @xmath271 is an endpoint of a reflex edge @xmath10 of @xmath1 .",
    "let @xmath273 be the other endpoint of @xmath10 .",
    "there are two cases : either @xmath10 is a top reflex edge (  [ fig:1-cut]b ) , or a bottom reflex edge (  [ fig:1-cut]c ) .",
    "consider the first case , where @xmath10 is a top reflex edge .",
    "let @xmath35 and @xmath274 be normal cuts just below @xmath36 and @xmath273 , respectively .",
    "we can not have @xmath275 as it would imply that @xmath276 , an hence @xmath274 would be a safe cut .",
    "similarly , we have @xmath277 . so by lemma  [ lem : safe_cut ] , as there is no safe cut in @xmath1 , both @xmath35 and @xmath274 must be @xmath255-cuts , and thus @xmath278 .",
    "it implies @xmath279 , a contradiction .",
    "now , consider the latter case where @xmath10 is a bottom reflex edge .",
    "see  [ fig:1-cut]c .",
    "let @xmath35 be a normal cut just below @xmath10 and let @xmath274 be a normal cut just above @xmath273 .",
    "since @xmath280 and since there is no safe cut in @xmath1 , both @xmath35 and @xmath274 must be @xmath255-cuts , so @xmath281 , a contradiction .",
    "thus , our claim for the case @xmath264 is true .",
    "assume now that @xmath282 , and thus @xmath283 .",
    "by our assumption that @xmath1 has not safe cut , there is no @xmath248-cut @xmath274 with @xmath284 and @xmath285 .",
    "now suppose that the lemma is false . then , we have @xmath286 for any @xmath255-cut @xmath35 in @xmath1 , and @xmath287 for any @xmath259-cut @xmath35 in @xmath1 .",
    "pick any @xmath259-cut @xmath35 in @xmath1 . if there is no @xmath259-cut in @xmath1",
    ", then we rotate @xmath1 by @xmath288 so that every @xmath255-cut is transformed into a @xmath259-cut .",
    "note that @xmath287 and @xmath289 .",
    "let @xmath36 be the first reflex vertex below @xmath35 . if @xmath36 is not incident to a horizontal reflex edge , then a normal cut @xmath290 just below @xmath36 is a @xmath255-cut with @xmath291 , a contradiction .",
    "thus , @xmath36 is incident to a horizontal reflex edge @xmath10 .",
    "there are two cases : either @xmath10 is a top reflex edge or a bottom reflex edge .",
    "assume that @xmath10 is a top reflex edge .",
    "let @xmath292 and @xmath293 be normal cuts just below @xmath36 and @xmath273 , respectively , where @xmath273 is the other vertex incident to @xmath10 .",
    "( see  [ fig:1-cut]c . ) for any @xmath59 , if @xmath294 is a @xmath259-cut , then @xmath295 and @xmath296 , a contradiction .",
    "thus , neither @xmath292 nor @xmath293 can be a @xmath259-cut .",
    "moreover , since @xmath297 , we must have @xmath298 .",
    "since @xmath1 admits no safe cut , it implies that @xmath299 , and hence @xmath300 , a contradiction to the assumption that @xmath301 .",
    "assume that @xmath10 is a bottom reflex edge .",
    "let @xmath292 be a normal cut just below @xmath36 and @xmath293 be a normal cut just above @xmath273 .",
    "( see  [ fig:1-cut]c . ) in this case , @xmath292 can not be a @xmath259-cut since @xmath302 , while @xmath293 can not be a @xmath255-cut since @xmath303 .",
    "on the other hand , we have @xmath304 , and thus @xmath305 .",
    "so , we must have @xmath298 .",
    "since @xmath1 has no safe cut , it implies that @xmath306 , and thus @xmath300 , a contradiction .",
    "now , we are ready to prove the main result of this section .",
    "[ lem : covering ] let @xmath1 be a simple rectilinear polygon @xmath1 with @xmath115 vertices and @xmath116 reflex vertices . then",
    ", @xmath117 beacons are sufficient to guard @xmath1 . moreover",
    ", all these beacons can be placed at reflex vertices of @xmath1 .",
    "our proof is by induction on @xmath140 .",
    "the base case where @xmath307 is already handled by lemma  [ lem : coverage_base ] , so we assume that @xmath133 .",
    "if @xmath1 admits a safe cut @xmath35 , then we partition it into two subpolygons @xmath37 and @xmath38 , and we handle each subpolygon recursively . our guarding set for @xmath1 is the union of the guarding sets for @xmath37 and @xmath38 . as @xmath35 is safe , the total number of beacons we place is at most @xmath308 these beacons indeed guard @xmath1 , because @xmath35 is a convex edge of each subpolygon , and thus by observation  [ obs : convex_edge ] , no beacon attraction path hits @xmath35 .",
    "now we assume that @xmath1 admits no safe cut .",
    "then , by lemma  [ lem : safe_cut ] , we have @xmath262 , so @xmath309 , and there is no @xmath248-cut or @xmath140-cut with at least one reflex vertex on each side .",
    "consider the set @xmath310 of all @xmath255-cuts @xmath274 in @xmath1 with @xmath311 . by lemma  [ lem:1-cut ]",
    ", we may assume that @xmath310 is nonempty : if @xmath264 , then it immediately follows that @xmath312 , and if @xmath263 and @xmath313 , then we rotate @xmath1 by @xmath288 .    pick a @xmath255-cut @xmath314 such that @xmath315 is minimum .",
    "let @xmath36 be the first reflex vertex of @xmath1 below @xmath35 .",
    "if @xmath36 is not an endpoint of a horizontal reflex edge , then a normal cut @xmath274 just below @xmath36 is a @xmath248-cut with @xmath284 and @xmath285 , so it is a safe cut , a contradiction to the assumption that @xmath1 admits no safe cut .",
    "hence , @xmath36 must be an endpoint of a horizontal reflex edge @xmath10 .",
    "we have two cases : either @xmath10 is a top reflex edge , or a bottom reflex edge .     when @xmath10 is a top reflex edge .",
    "( a ) when @xmath292 is a @xmath248-cut and @xmath293 is a @xmath259-cut .",
    "( b1)(b3 ) when @xmath292 and @xmath293 are @xmath255-cuts . ]",
    "[ [ when - e - is - a - top - reflex - edge . ] ] when @xmath10 is a top reflex edge .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    assume the former case where @xmath10 is a top reflex edge .",
    "let @xmath101 and @xmath102 be the left and right endpoint of @xmath10 , respectively , and @xmath292 and @xmath293 be normal cuts just below @xmath101 and @xmath102 , respectively .",
    "also , let @xmath316 be such that @xmath292 is an @xmath317-cut and @xmath293 is an @xmath318-cut . we then observe that @xmath319 , that is , @xmath320 . we treat separately the two possible cases : case ( a ) , where @xmath321 or @xmath322 , and case ( b ) , where @xmath323 .",
    "( see  [ fig : covering_top ] . )",
    "a.   assume that @xmath324 , so @xmath292 is a @xmath248-cut and @xmath293 is a @xmath259-cut .",
    "( the case where @xmath325 is symmetric , and can be handled in the same way . ) as @xmath292 is not a safe cut , we have @xmath326 .",
    "consider the horizontal cut @xmath274 at @xmath102 .",
    "( see  [ fig : covering_top]a . )",
    "we have @xmath327 , and @xmath328 .",
    "we then place beacons in @xmath329 and @xmath330 separately and recursively .",
    "the total number of beacons placed is at most @xmath331 + we still need to make sure that these beacons indeed guard @xmath1 , our induction hypothesis implies that all the beacons are placed at reflex vertices of @xmath1 .",
    "so there is no beacon placed below the horizontal cut at @xmath101 , and thus , by observation  [ obs : convex_edge ] , no beacon attraction path in @xmath329 hits @xmath274 .",
    "again by observation  [ obs : convex_edge ] , the beacons placed in @xmath330 indeed guard the region @xmath330 in @xmath1 since @xmath274 is a convex edge of @xmath330 .",
    "this ensures that the beacons we placed separately in @xmath329 and @xmath330 indeed guard @xmath1 .",
    "b.   we now consider the case where @xmath332 .",
    "then , we have @xmath333 by our choice of @xmath35 .",
    "let @xmath57 and @xmath58 be the edges other than @xmath10 incident to @xmath101 and @xmath102 , respectively . if @xmath57 is not a reflex edge , then a beacon placed at @xmath102 guards @xmath38 since its kernel @xmath334 is nonempty .",
    "the other part @xmath37 can be guarded by at most @xmath335 guards placed on reflex vertices of @xmath37 . since @xmath35 is a normal cut , these @xmath336 beacons together guard @xmath1 . as @xmath337 ,",
    "the number of beacons is bounded by @xmath338 as desired .",
    "the case where @xmath58 is not a reflex edge can be handled symmetrically by placing a beacon at @xmath101 .",
    "+ thus , we now assume that both @xmath57 and @xmath58 are reflex edges .",
    "let @xmath339 and @xmath340 be the vertical cuts at @xmath101 and @xmath102 , respectively .",
    "we handle three subcases separately : ( i ) either @xmath341 or @xmath342 for some @xmath343 , ( ii ) @xmath264 and @xmath344 for each @xmath345 , or ( iii ) @xmath282 and @xmath346 for each @xmath345 .",
    "if we are not in case ( i ) , we have either case ( ii ) or ( iii ) .",
    "so these three cases cover all possible situations .",
    "a.   without loss of generality , we assume that @xmath347 or @xmath348 . in this case , we handle @xmath349 and @xmath350 recursively .",
    "the union of the two guarding sets of @xmath349 and @xmath350 guards @xmath1 , as all these beacons are placed at reflex vertices .",
    "( see  [ fig : covering_top](b1 ) . )",
    "the number of beacons is at most @xmath351 , since @xmath352 and @xmath353 .",
    "b.   assume that @xmath264 and @xmath344 for each @xmath354 .",
    "we partition @xmath1 into @xmath355 and @xmath356 and handle them recursively .",
    "the total number of beacons is at most @xmath357 these beacons guard @xmath1 , as they are all placed at reflex vertices of @xmath1 . c.   the remaining case is when @xmath263 and @xmath346 for each @xmath358 .",
    "then a vertical cut just to the left of @xmath339 is a @xmath248-cut , and a vertical cut just to the right of @xmath340 is a @xmath248-cut .",
    "since @xmath1 admits no safe cut , this implies that @xmath359 .",
    "+ let @xmath80 be the first reflex vertex above @xmath35 , and let @xmath34 be the vertical cut at @xmath80 .",
    "we consider two cases : either @xmath80 is incident to a bottom reflex edge , or not . in the former case ,",
    "let @xmath85 be the other endpoint of the bottom reflex edge .",
    "( see  [ fig : covering_top](b2 ) . )",
    "since @xmath35 is a @xmath255-cut and @xmath282 , one of the two horizontal cuts just above @xmath80 and @xmath85 must be either a @xmath248-cut or a @xmath259-cut . without loss of generality ,",
    "assume that the cut above @xmath80 is either a @xmath248-cut or a @xmath259-cut .",
    "as @xmath263 , it means that the number of reflex vertices above this cut is @xmath248 or @xmath255 modulo 3 , and hence @xmath360 or @xmath259 .",
    "+ in the latter case , where @xmath80 is not incident to a bottom reflex edge , we may assume without loss of generality that the horizontal edge incident to @xmath80 is to the left of @xmath80 .",
    "( see  [ fig : covering_top](b3 ) . )",
    "so we still have @xmath360 or @xmath259 .",
    "+ in both cases , we partition @xmath1 by the vertical cut @xmath34 at @xmath80 into @xmath361 and @xmath362 .",
    "the endpoint of @xmath34 other than @xmath80 always lies on the reflex edge @xmath10 , since @xmath359 . since @xmath363 or @xmath259 , and @xmath364 , and @xmath365",
    ", we have either @xmath363 or @xmath366 .",
    "we handle @xmath361 and @xmath362 , separately , and recursively",
    ". then the total number of beacons placed in @xmath1 is at most @xmath367 we still need to verify that these beacons guard @xmath1 . as @xmath368 ,",
    "by our induction hypothesis , there must be a beacon at one of the endpoints of @xmath57 .",
    "such a beacon attracts all points to the left of @xmath339 , and thus the region @xmath361 is covered by the beacons in @xmath1 . since @xmath34 is a convex edge of @xmath362 , no attraction path hits @xmath34 inside @xmath362 either .",
    "this completes the proof for the case where @xmath10 is a top reflex edge .     when @xmath10 is a bottom reflex edge .",
    "( a ) when @xmath264 .",
    "( b ) when @xmath263 and @xmath293 is a @xmath248-cut .",
    "( c ) when @xmath263 , @xmath292 is a @xmath248-cut , and @xmath293 is a @xmath255-cut .",
    "( d ) when @xmath263 , @xmath292 is a @xmath255-cut , and @xmath293 is a @xmath259-cut . ]    [ [ when - e - is - a - bottom - reflex - edge . ] ] when @xmath10 is a bottom reflex edge .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we now assume that @xmath10 is a bottom reflex edge .",
    "let @xmath273 be the other endpoint of @xmath10 .",
    "( see  [ fig : covering_bottom ] . ) without loss of generality , we assume that @xmath36 is to the left of @xmath273 . let @xmath292 be a normal horizontal cut just below @xmath10 and @xmath293 be a normal cut just above @xmath273 .",
    "also , let @xmath369 be such that @xmath292 is an @xmath317-cut and @xmath293 is an @xmath318-cut .",
    "so we have @xmath370 , that is , @xmath371 . recall that @xmath372 has been chosen to be a @xmath255-cut with the smallest value of @xmath315 among all @xmath255-cuts @xmath274 of @xmath1 with @xmath311 .",
    "we first assume that @xmath264 , and thus @xmath373 .",
    "if @xmath374 , then @xmath292 is a safe cut .",
    "similarly , if @xmath375 , then @xmath293 is a safe cut .",
    "since @xmath1 admits no safe cut , we have that @xmath376 .",
    "so by our choice of @xmath35 , we have @xmath377 .",
    "let @xmath80 be the unique reflex vertex in @xmath378 .",
    "we pick any normal vertical cut @xmath34 at any point on @xmath10 .",
    "( see  [ fig : covering_bottom]a . )",
    "since @xmath34 is not a safe cut , @xmath34 must be a @xmath255-cut , that is , @xmath379 .",
    "on the other hand , we have @xmath380 if @xmath381 , and @xmath382 if @xmath383 .",
    "as @xmath35 is a @xmath255-cut , it implies that either @xmath384 or @xmath385 , a contradiction , so @xmath386 .",
    "we hence have @xmath263 and @xmath387 .",
    "we first rule out @xmath375 .",
    "so we assume , for sake of contradiction , that @xmath375 .",
    "we must have @xmath388 , as otherwise @xmath293 would be safe cut .",
    "we make a cut @xmath389 to the left of @xmath36 .",
    "( see  [ fig : covering_bottom]b . ) as @xmath389 is a 1-cut , we have @xmath390 , and @xmath391 .",
    "we recursively construct guarding sets of beacons for @xmath392 and @xmath393 .",
    "we claim that these beacons together guard @xmath1 .",
    "indeed , the only way a point @xmath7 may not be covered would be that @xmath7 lies in @xmath394 and its attraction path crosses @xmath389 from below .",
    "but then @xmath7 would be attracted , within @xmath394 , by the same beacon as @xmath273 .",
    "this is impossible because there is no reflex vertex above the cut @xmath293 , and by our induction hypothesis , beacons are placed at reflex vertices . to complete the proof for this case , we only need to bound the number of beacons we placed .",
    "it is at most @xmath395    we now rule out the case where @xmath396 . if it were the case , then we would have @xmath326 since @xmath1 has no safe cut .",
    "we pick any normal vertical cut @xmath34 at any point on @xmath10 .",
    "since @xmath34 is a @xmath248-cut and both sides of @xmath34 contain at least one reflex vertex , it is a safe cut , which contradicts our assumptions .",
    "( see  [ fig : covering_bottom]c . )",
    "we thus have @xmath397 .",
    "note that @xmath377 by our choice of @xmath35 .",
    "let @xmath80 be the unique reflex vertex in @xmath378 .",
    "( see  [ fig : covering_bottom]d . )",
    "then @xmath80 must be to the left of @xmath36 , because otherwise , there would be a normal vertical cut @xmath34 at a point on @xmath10 such that @xmath80 lies to the right of @xmath34 , and @xmath34 would be a safe cut .",
    "let @xmath389 be the horizontal cut at @xmath36 and @xmath398 be the vertical cut at @xmath36 .",
    "we then handle the two subpolygons @xmath394 and @xmath399 , separately , in a recursive way , though they partially overlap .",
    "due to the overlap , the union of the set of beacons placed separately in each subpolygon guard the whole polygon @xmath1 .",
    "since @xmath400 and @xmath401 , the number of beacons we placed is at most @xmath402 this completes the proof .",
    "our last result is to show that in the worst case , monotone rectilinear polygons require fewer beacons than simple rectilinear polygons .",
    "it matches the lower bound by biro  @xcite .",
    "[ thm : coverage_monotone ] for any rectilinear monotone polygon @xmath1 with @xmath2 vertices , @xmath140 of which are reflex , @xmath403 beacons are sufficient to guard @xmath1 , and sometimes necessary .    without loss of generality , we assume that @xmath1 is @xmath46-monotone .",
    "thus , @xmath1 has no vertical reflex edge by observation  [ obs : monotone ] .",
    "our proof is by induction on the number @xmath140 of reflex vertices .",
    "if @xmath1 has at most one reflex edge @xmath10 , then we observe that any point on @xmath10 is contained in the kernel @xmath30 by theorem  [ thm : kernel ] .",
    "thus , one beacon is sufficient to guard @xmath1 .",
    "now , assume that @xmath1 has at least two reflex edges .",
    "this implies that @xmath133 since @xmath1 is @xmath46-monotone .",
    "let @xmath404 be the right endpoints of the reflex edges sorted from left to right .",
    "let @xmath57 and @xmath58 be the reflex edges that are incident to @xmath101 and @xmath102 , respectively .",
    "let @xmath35 be the vertical cut at @xmath102 .",
    "we partition @xmath1 into @xmath37 and @xmath38 by @xmath35 .",
    "then the left side subpolygon @xmath38 has at most one reflex edge @xmath57 , and thus can be guarded by a single beacon placed at any point on @xmath57 .",
    "the right side subpolygon @xmath37 has @xmath337 reflex vertices .",
    "thus , by induction , at most @xmath405 beacons can guard @xmath37 .",
    "the total number of beacons placed in @xmath1 is at most @xmath406 as desired .    finally , observe that cutting by @xmath35 always makes a new convex edge in @xmath38 and @xmath37 since there is no vertical reflex edge in @xmath1 .",
    "this implies that separately guarding @xmath38 and @xmath37 is sufficient to guard the whole @xmath1 by observation  [ obs : convex_edge ] .",
    "in this section , we give an improved upper bound for the beacon - based routing problem in a simple rectilinear polygon @xmath1 with @xmath140 reflex vertices .",
    "our result in this section is as follows .",
    "[ thm : routing ] for any simple rectilinear polygon @xmath1 with @xmath407 vertices , @xmath163 of which are reflex , @xmath408 beacons are always sufficient to route between all pairs of points in @xmath1 .",
    "there are simple rectilinear polygons in which @xmath409 beacons are necessary to route all point pairs for any @xmath29 .      the polygon constructed by biro et al .",
    "@xcite to show the lower bound @xmath410 is @xmath46-monotone .",
    "( see  [ fig : intro]a . ) but we can construct non - monotone polygons for which @xmath411 beacons are necessary for any @xmath412 , i.e. , @xmath29 . when @xmath413 , @xmath1 is @xmath48-monotone , so no beacon is needed .",
    "we construct a spiral polygon @xmath118 with @xmath140 reflex vertices .",
    "the construction is similar to the one for the lower bound on the coverage problem , so we explain only the idea of the construction . for @xmath414 , no beacon is needed , and for @xmath415 , one beacon is necessary , so it suffices to construct @xmath118 for @xmath416 .     for the lower bound on the routing problem .",
    "( a ) @xmath417 .",
    "( b ) @xmath418 .",
    "( c ) @xmath419 . ]    as a base case for the construction , we consider @xmath417 .",
    "see  [ fig : lb_for_routing]a .",
    "let @xmath7 and @xmath157 be the end convex vertices of the spine of @xmath118 . for a point @xmath123 to be attracted to @xmath7 , @xmath123 must be in a polygonal region above the line @xmath420 , otherwise its beacon - based path to @xmath7 is blocked by the reflex edge connecting @xmath102 and @xmath421 . if another point @xmath124 would be attracted to @xmath157 , then @xmath124 must be in a polygonal region below the line @xmath422 . since such two regions are disjoint except at @xmath102 , one beacon is not sufficient .",
    "note here that a beacon placed at @xmath102 is attracted neither to @xmath7 nor to @xmath157 because two paths toward @xmath101 and @xmath421 are both valid .",
    "so @xmath417 needs ( at least ) @xmath423 beacons . from @xmath417",
    ", we construct @xmath118 incrementally .",
    "let us look at @xmath418 .",
    "two beacons are sufficient and necessary for @xmath418 as in  [ fig : lb_for_routing]b . we know that the second beacon @xmath124 should be placed in the region bounded by the line @xmath424 and the line @xmath425 , otherwise @xmath124 can not be attracted to @xmath123 due to the obstruction of the edge from @xmath130 to @xmath157 .",
    "then we can make @xmath419 with the endpoint @xmath157 , as in  [ fig : lb_for_routing]c , such that the line @xmath426 passes above the region where @xmath124 is placed .",
    "this implies that @xmath124 can not be attracted to @xmath157 because @xmath124 lies below the line @xmath426 , so the third beacon is necessary .",
    "it is not hard to check that this argument can be applied to construct @xmath118 from @xmath427 for any @xmath428 .",
    "this shows the lower bound for the routing problem as follows .",
    "[ lem : coverage_lower_bound ] the spiral @xmath118 defined above can not be guarded by less than @xmath429 beacons , where @xmath2 denotes the number of vertices of @xmath118 , i.e. , @xmath430 , for any @xmath431 or @xmath29 .      we now explain how to place @xmath432 beacons to route all pairs of points in @xmath1 .",
    "when @xmath1 is @xmath48-monotone , we do not need to place any beacon in order to route between a pair @xmath433 of points in @xmath1 , since the target @xmath14 is regarded as a beacon .",
    "we thus focus on the case where @xmath1 ifs not @xmath48-monotone .",
    "our approach is to cut @xmath1 by extending some of its edges , and handle the resulting parts separately .",
    "more precisely , for any reflex vertex @xmath36 of @xmath1 incident to an edge @xmath10 , we denote by @xmath434 the cut obtained by extending @xmath10 through @xmath36 .",
    "so when @xmath10 is horizontal , @xmath434 is the horizontal cut at @xmath36 , and if @xmath10 is vertical , then @xmath434 denotes the vertical cut at @xmath36 .",
    "the cut @xmath434 splits @xmath1 into two subpolygons @xmath435 and @xmath436 , one of which does not contain @xmath10 .",
    "we call this subpolygon the _ pocket _ of @xmath10 at @xmath36 , denoted by @xmath437 . for instance , if @xmath10 is a top reflex edge , then we have @xmath438 .",
    "so for any reflex edge @xmath10 with endpoints @xmath36 and @xmath80 , there are two cuts @xmath434 and @xmath439 extending @xmath10 , and two pockets @xmath437 and @xmath440 of @xmath10 .",
    "( see  [ fig : monotone_pocket]a . )",
    "our solution to the routing problem is based on the following key lemma .     and @xmath439 extending a reflex edge @xmath10 and the pockets of @xmath10 , when @xmath10 is a top reflex edge .",
    "( b ) proof of lemma  [ lem : monotone_pocket ] .",
    "[ fig : monotone_pocket ] ]    [ lem : monotone_pocket ] suppose that @xmath1 is not @xmath48-monotone .",
    "then there exist a reflex edge @xmath10 of @xmath1 and an endpoint @xmath36 of @xmath10 such that the pocket @xmath437 of @xmath10 at @xmath36 is @xmath48-monotone .",
    "let @xmath10 be a reflex edge of @xmath1 , and @xmath36 be an endpoint of @xmath10 , such that the number of vertices of the pocket @xmath437 is minimum . if the pocket @xmath437 has no reflex edge , then @xmath437 is @xmath48-monotone by observation  [ obs : monotone ] .",
    "suppose that @xmath437 contains at least one reflex edge @xmath235 .",
    "we claim that one of the two pockets of @xmath235 is always contained in @xmath437 . if our claim is true , then such a pocket of @xmath235 has fewer vertices than @xmath437 does , a contradiction .",
    "let @xmath101 and @xmath102 be the two endpoints of @xmath235 .",
    "( see  [ fig : monotone_pocket]b . )",
    "suppose that our claim is false , that is , neither @xmath441 nor @xmath442 is contained in @xmath437 .",
    "it means that each pocket contains points on both sides of @xmath434 .",
    "pockets are simple polygons , and hence they are connected .",
    "thus , @xmath434 contains a point @xmath443 of @xmath441 and a point @xmath444 of @xmath442 .",
    "so the boundaries of @xmath441 and @xmath442 must cross @xmath434 between @xmath443 and @xmath444 , which implies that @xmath445 and @xmath446 cross @xmath434 .",
    "this is impossible , as @xmath445 and @xmath446 are collinear .",
    "we are now ready to prove our upper bound @xmath447 on the beacon - based routing problem .",
    "our proof is by induction on the number @xmath42 of reflex vertices of @xmath1 based on partitioning @xmath1 into @xmath48-monotone subpolygons in a recursive manner .",
    "[ lem : routing ] for any simple rectilinear polygon @xmath1 with @xmath2 vertices , @xmath140 of which are reflex , @xmath408 beacons are always sufficient to route between all pairs of points in @xmath1 .",
    "our proof is by induction on @xmath42 , the number of reflex vertices of @xmath1 .",
    "first consider the base case where @xmath448 . in this case",
    ", @xmath1 is @xmath48-monotone by observation  [ obs : monotone ] , so no beacon is required for @xmath1 as discussed above .",
    "hence , the upper bound holds .    now , suppose that @xmath1 is not @xmath48-monotone , and thus @xmath449 .",
    "then , lemma  [ lem : monotone_pocket ] implies the existence of a pocket @xmath437 of @xmath1 that is @xmath48-monotone , where @xmath36 is an endpoint of a reflex edge @xmath10 of @xmath1 . without loss of generality",
    ", we assume that @xmath10 is a top reflex edge and @xmath36 is the left endpoint of @xmath10 .",
    "let @xmath273 be the other endpoint of @xmath10 , so @xmath438 and @xmath450 .",
    "we consider three subpolygons , as in figure  [ fig : routing]a , @xmath451 , @xmath452 , and @xmath453 .",
    "let @xmath7 be the endpoint other than @xmath36 of @xmath454 and let @xmath157 be the end point than @xmath273 of @xmath455 .",
    "note that @xmath456 .",
    "we split into two cases : either @xmath457 , or @xmath458 .    .",
    "( a ) when @xmath459 , two beacons @xmath123 and @xmath124 are placed at @xmath7 and @xmath157 ( marked by @xmath460 ) .",
    "( b ) when @xmath457 , a beacon @xmath123 is first placed just above @xmath273 ( marked by @xmath460 ) , and other beacons will be placed more according to the shape of @xmath310.,scaledwidth=80.0% ]    we first consider the case that @xmath459 .",
    "we place two beacons @xmath123 and @xmath124 at @xmath7 and @xmath157 , respectively , then place @xmath461 beacons in @xmath462 and @xmath463 beacons in @xmath310 recursively .",
    "since @xmath458 , @xmath464 . using this fact",
    ", we can bound the total number of beacons we have placed below by @xmath465    we now check if any pair of @xmath13 and @xmath14 can be routed via these beacons .",
    "segments @xmath466 , @xmath467 , and @xmath468 used for the partition are all the convex edges of the corresponding subpolygons , so by observation  [ obs : convex_edge ] , none of the segments are hit by any beacon - based routing path between two points in a subpolygon .",
    "this implies that once @xmath13 is routed to some point in ( or on the boundary of ) a subpolygon , it can be routed to any target @xmath14 in the subpolygon by the induction hypothesis .",
    "@xmath454 contains @xmath123 and @xmath469 contains @xmath124 .",
    "moreover , @xmath123 and @xmath124 can attract each other along @xmath468 , so any pair of @xmath470 for @xmath471 can be routed via @xmath123 or via @xmath124 or both of them .",
    "this completes the case where @xmath458 .",
    "now , we consider the other case where @xmath472 , which means @xmath473 is a rectangle .",
    "we place a beacon @xmath123 infinitesimally above @xmath273 as in fig .  [",
    "fig : routing]b .",
    "note that @xmath123 is placed inside @xmath462 , but it can attract any point in @xmath473 , and it can be attracted to any point in @xmath473 because it is located above the line connecting @xmath273 and the lower right corner of @xmath473 .",
    "we place @xmath461 beacons in @xmath462 recursively . for @xmath310 ,",
    "we need a more careful placement method as follows .",
    "we first suppose that @xmath474 . then no beacons inside @xmath310 are required because @xmath123 can attract any point in @xmath310 and it can be attracted to any point in @xmath310 . using this fact",
    ", we can easily verify that any two points in @xmath475 can be routed to each other via @xmath123 .",
    "the route between @xmath123 and a point in @xmath462 is always possible by the induction hypothesis , which implies that any pair @xmath470 can be routed wherever @xmath13 and @xmath14 belong to .",
    "the number of beacons we have placed is at most @xmath476 since @xmath477 .",
    "thus , from now on , we assume that @xmath478 .    for @xmath478 , we partition @xmath310 into at most three smaller subpolygons as follows .",
    "we sweep the interior of @xmath310 with an initial sweeping line segment @xmath479 downward as long as the swept region remains @xmath48-monotone .",
    "see fig .",
    "[ fig : routing_c ] .",
    "if the @xmath48-monotonicity is violated , then there must be a reflex edge @xmath235 that @xmath480 intersects .",
    "then @xmath235 would be either horizontal or vertical .",
    "is horizontal .",
    "( a ) @xmath235 is a bottom reflex edge .",
    "the beacon @xmath481 is placed because @xmath482 .",
    "( b ) @xmath235 is a top reflex edge , which is connected from @xmath157 .",
    "the beacon @xmath481 is not placed because @xmath483 .",
    "the symmetric case where a top reflex edge @xmath235 is connected from @xmath273 is omitted in this figure . ]",
    "let us suppose that @xmath235 is horizontal .",
    "for this case , @xmath235 could be either a bottom reflex edge as in fig .",
    "[ fig : routing_c]a or a top reflex edge as in fig .",
    "[ fig : routing_c]b",
    ". then we split @xmath310 into three subpolygons by cutting @xmath310 along the sweeping segment @xmath480 containing @xmath235 ; @xmath484 is the @xmath48-monotone piece , @xmath181 and @xmath188 are the other two pieces as in fig .",
    "[ fig : routing_c]a - b .",
    "we place the beacons in @xmath181 and @xmath188 ( not in @xmath484 ) recursively , and place additional beacons as follows .",
    "we place two beacons @xmath124 and @xmath485 at two end points of @xmath480 , where @xmath124 is assumed to be in the left of @xmath485 .",
    "we place one more beacon @xmath481 at the point @xmath157 only when @xmath482 .",
    "it holds that @xmath486 .",
    "when @xmath482 , the total number of beacons we have placed is @xmath487 when @xmath488 , the beacon @xmath481 is not placed , so the number of the beacons is @xmath489    let us check if @xmath13 can be routed to @xmath14 in this placement . as in the previous case where @xmath458 , all the segments used for the partition are convex edges in their associated subpolygons .",
    "so , it is sufficient to show that any pair of beacons from @xmath490 can be routed to each other .",
    "first , @xmath124 and @xmath485 are attracted to each other along the cut @xmath480 , and so are @xmath123 and @xmath481 because they are visible each other .",
    "second , @xmath124 or @xmath485 is on the boundary of @xmath484 , and @xmath484 is @xmath48-monotone , so if @xmath482 , i.e. , @xmath481 exists , then @xmath481 can be routed to @xmath124 or @xmath485 . otherwise , if @xmath488 as in fig .",
    "[ fig : routing_c]b , then @xmath484 is either a rectangle or a union of two rectangles with the unique reflex vertex @xmath79 .",
    "we here claim that @xmath123 can be attracted to @xmath124 or @xmath485 , and @xmath123 can also attract @xmath124 or @xmath485 . if @xmath123 can see directly the one of them , then it is done .",
    "suppose that they are not visible from @xmath123 .",
    "for this to happen , @xmath79 and an end vertex of @xmath235 must obstruct the sight from @xmath123 to @xmath124 and to @xmath485 .",
    "then there are four situations as in fig .",
    "[ fig : routing_c1 ] . in the first three situations ( fig .",
    "[ fig : routing_c1]a - c ) , @xmath123 can be clearly attracted to @xmath124 or @xmath485 . for the last situation as in fig .",
    "[ fig : routing_c1]d , it can not be attracted to @xmath124 , but it can be attracted to @xmath485 via the end vertex of @xmath235 and along the cut containing @xmath235 .",
    "thus @xmath123 can always reach @xmath124 or @xmath485 .",
    "the reverse attraction is also possible .",
    "if @xmath123 can see @xmath124 or @xmath485 , say @xmath124 , then @xmath485 first goes to @xmath124 then reaches @xmath123 .",
    "otherwise , only the last situation in fig .",
    "[ fig : routing_c1]d would be in trouble because @xmath485 can not be attracted to @xmath123 .",
    "but @xmath124 can be attracted to @xmath123 , thus @xmath485 can reach @xmath123 via @xmath124 . as a result , the beacons in @xmath490 can be routed to each other , which means that any pair @xmath470 can be routed in this partition",
    ".     sees neither @xmath124 nor @xmath485 . ]",
    "we now consider the last case where @xmath235 is a vertical reflex edge .",
    "see fig .",
    "[ fig : routing_last ] .",
    "let @xmath80 be the lower end vertex of @xmath235 , and let @xmath491 be the horizontal edge incident to @xmath80 with the other end vertex @xmath85 .",
    "if @xmath491 is a reflex edge , that is , @xmath85 is reflex , then it should be a top reflex edge , thus we cut @xmath310 along @xmath480 into three pieces @xmath484 , @xmath181 , and @xmath188 , where @xmath188 is a pocket @xmath492 , and @xmath493 .",
    "we place two beacons @xmath124 and @xmath485 at two end points of @xmath480 .",
    "we place @xmath481 at @xmath157 only when @xmath482 .",
    "finally , we place the beacons in @xmath181 and @xmath188 recursively .",
    "if @xmath491 is not a reflex edge , i.e. , @xmath85 is convex , then we cut @xmath310 along @xmath494 into two pieces @xmath484 and @xmath181 , where @xmath495 .",
    "we place a beacon @xmath124 at the endpoint of @xmath494 ( not at @xmath80 ) , and one more beacon @xmath481 at @xmath157 regardless of the size of @xmath496 .",
    "note that @xmath124 and @xmath481 are located both at the convex vertices of @xmath484 .     is a vertical reflex edge .",
    "the symmetric cases are omitted in this figure.,scaledwidth=80.0% ]    the partition @xmath497 actually corresponds to the previous case where @xmath235 is horizontal , so we can apply the same arguments to bound the number of beacons and to ensure that any pair @xmath470 can be routed .",
    "we now focus only on the partition @xmath498 .",
    "we have placed three beacons @xmath499 .",
    "note here that @xmath500 because @xmath484 always contains the upper reflex vertex of @xmath235 . using this with the fact that @xmath501 , we can bound the number of beacons by @xmath502 let us check if @xmath13 can be routed to @xmath14 .",
    "the cuts used for the partition are again served as convex edges in associated subpolygons .",
    "thus it suffices to prove that three beacons @xmath499 are routed to each other .",
    "the two beacons @xmath123 and @xmath481 are visible , so they can attract each other . because @xmath481 and @xmath124 are both in the @xmath48-monotone subpolygon @xmath484",
    ", they also attract each other .",
    "thus the three beacons can attract each other .",
    "this completes the proof of the theorem .",
    "in this paper , we attempt to reduce the gaps between the lower and upper bounds on the number of beacons required in beacon - based coverage and routing problems for a simple rectilinear polygon @xmath1 . for the coverage problem",
    ", we raised its lower bound , and presented an algorithm to place the same number of beacons to cover @xmath1 .",
    "these results settle the open questions on the coverage problem . for the routing problem",
    ", we improved the lower and upper bounds , but there is still a gap between them , which is an immediate open question .",
    "furthermore , we presented an optimal linear time algorithm of computing the beacon - based kernel of @xmath1 .",
    "but it remains open to compute the _",
    "inverse kernel _ of @xmath1 , which is defined as a set of points in @xmath1 that are attracted to all the points in @xmath1 , in a subquadratic time ."
  ],
  "abstract_text": [
    "<S> we establish tight bounds for beacon - based coverage problems , and improve the bounds for beacon - based routing problems in simple rectilinear polygons . </S>",
    "<S> specifically , we show that @xmath0 beacons are always sufficient and sometimes necessary to cover a simple rectilinear polygon @xmath1 with @xmath2 vertices . </S>",
    "<S> we also prove tight bounds for the case where @xmath1 is monotone , and we present an optimal linear - time algorithm that computes the beacon - based kernel of @xmath1 . for the routing problem </S>",
    "<S> , we show that @xmath3 beacons are always sufficient , and @xmath4 beacons are sometimes necessary to route between all pairs of points in @xmath1 . </S>"
  ]
}