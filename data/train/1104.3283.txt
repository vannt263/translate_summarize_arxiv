{
  "article_text": [
    "_ split decomposition _ ranks among the classical hierarchical graph decomposition techniques , and can be seen as a generalization of modular decomposition  @xcite and the decomposition of a graph into @xmath2-connected components  @xcite .",
    "it was introduced by cunningham and edmonds  @xcite as a special case of the more general framework of bipartitive families . since then , a number of extensions and applications have been developed .",
    "for example , the decomposition scheme used in the proof of the strong perfect graph theorem  @xcite and in the recognition of berge graphs  @xcite is based in part on the 2-join decomposition , which generalizes split decomposition .",
    "also , clique - width theory  @xcite and rank - width theory  @xcite can be considered generalizations of split decomposition theory .",
    "indeed , split decomposition is one of the important subroutines in the polynomial - time recognition of clique - width @xmath2 graphs  @xcite .",
    "moreover , the graphs of rank - width one are precisely the graphs that are totally decomposable by split decomposition ( i.e. the distance - hereditary graphs  @xcite or completely - separable graphs  @xcite ) .    as with distance",
    "hereditary graphs  @xcite , parity graphs can be characterized by their split decomposition  @xcite . in  @xcite",
    ", split decomposition is used to define a hierarchy of graph families between distance hereditary and parity graphs .",
    "split decomposition also appears in the recognition of circular arc graphs  @xcite and in structure theorems of various graph classes ( see e.g.  @xcite ) .",
    "one of the more important applications of split decomposition is with respect to circle graphs ; these are the intersection graphs of chords inscribing a circle .",
    "prime circle graphs  those indecomposable by split decomposition  have unique chord representations ( up to reflection )  @xcite ( see also  @xcite ) .",
    "all of the fastest circle graph recognition algorithms are based on this fact  @xcite .",
    "recent work has focused on their connection to rank - width and vertex - minors  @xcite . for a brief introduction to split decomposition , the reader may refer to  @xcite .",
    "the first polynomial - time algorithm for split decomposition appeared in  @xcite , and ran in time @xmath3 .",
    "ma and spinrad later developed an @xmath4 algorithm  @xcite , which yields an @xmath4 circle graph recognition algorithm when combined with their prime testing procedure in  @xcite .",
    "the only linear time algorithms for split decomposition are due to dahlhaus  @xcite and , more recently , montgolfier et al .",
    "however , so far neither of these linear time algorithms seems to extend to circle graph recognition .",
    "this paper develops a split decomposition algorithm that runs in time @xmath5 , where @xmath1 is the inverse ackermann function @xcite ( we point out that this function is so slowly growing that it is bounded by @xmath6 for all practical purposes . for all integer @xmath7 and for all @xmath8 . ] ) hence , there is essentially no running time tradeoff in using our algorithm .",
    "moreover , the algorithm presented here is used by the companion paper  @xcite to derive the first sub - quadratic circle graph recognition algorithm .",
    "our algorithm benefits from the recent reformulation of split decomposition in terms of graph - labelled trees ( glts ) , introduced in  @xcite ( see section 2 ) .",
    "that paper enabled the authors to derive fully - dynamic recognition algorithms for distance - hereditary graphs and various subfamilies .",
    "glts are a combinatorial structure designed to capture precisely the underlying structure of split decomposition @xcite and in other similar reformulations that have been considered in the literature , for instance in a logical context  @xcite or in a distance - hereditary graph drawing context  @xcite .",
    "glts can also be understood as a special case of a term in a graph grammar  @xcite .",
    "they are valuable here for greatly simplifying the consideration of split decomposition and providing the insight for the results in this paper .",
    "the overview of our algorithm appears as algorithm [ alg : over ] , where @xmath9 refers to the empty graph , @xmath10 denotes the subgraph of @xmath11 induced on @xmath12 , and @xmath13 denotes the glt ( called the split - tree ) that captures the split decomposition of @xmath10 .",
    "@xmath14 null using algorithm [ alg : lbfs ] , do an lbfs on @xmath11 to produce ordering @xmath15    we use glts to derive a combinatorial incremental characterization of split decomposition , generalizing that given for distance - hereditary graphs in  @xcite ( see section 4 ) .",
    "note that in theorem [ th : cases ] and its subsequent propositions , we characterize all possible ways in which @xmath16 is modified to produce @xmath13 .",
    "glts are also used to demonstrate properties of split decomposition with respect to lexicographic breadth - first search ( lbfs )  @xcite ( see section 3 ) .",
    "sections 3 and 4 are independent , and their content provides general results and constructions that may be useful on their own .",
    "notably , the results of section 4 easily yield an efficient split decomposition dynamic algorithm supporting vertex insertion and deletion .",
    "by applying the incremental characterization to an lbfs ordering we achieve a split decomposition algorithm that is conceptually straightforward , but requires a careful and detailed explanation of the implementation in order to achieve the stated running time ( see section 5 ) .",
    "we develop a charging argument based on the structure of glts that allows us to evaluate the amortized cost of inserting each vertex , according to an lbfs ordering .",
    "we use it to prove the @xmath0 running time ( see section 6 ) .",
    "furthermore , our algorithm extends to circle graph recognition ; the companion paper  @xcite uses it to develop the first sub - quadratic circle graph recognition algorithm , which also runs in @xmath0 time .",
    "note that different versions of both the split decomposition algorithm and the circle graph recognition algorithm appear in @xcite .",
    "all graphs in this document are simple , undirected , and connected .",
    "the set of vertices in the graph @xmath11 is denoted @xmath17 and the set of edges by @xmath18 .",
    "the graph _ induced _ on the set of vertices @xmath19 is signified by @xmath20 $ ] .",
    "we let @xmath21 , or simply @xmath22 , denote the neighbours of vertex @xmath23 , and for @xmath19 a set of vertices @xmath24 .",
    "a vertex is _ universal to _ a set of vertices @xmath19 if @xmath25 ; it is _ isolated _ from @xmath19 if @xmath26 .",
    "a vertex is _ universal in _ a graph if it is adjacent to every other vertex in the graph .",
    "we use @xmath27 = n(x ) \\cup \\{x\\}$ ] to denote the _ closed neighbourhood of a vertex_. two vertices @xmath23 and @xmath28 are _ twins _ if @xmath29 .",
    "a _ pendant _ is a vertex of degree one .",
    "clique _ is a graph in which every pair of vertices is adjacent .",
    "a _ star _ is a graph with at least three vertices in which one vertex , called its _ centre _ , is universal , and no other edges exist ; the vertices other than the centre are called its _",
    "degree-1 vertices_. the clique on @xmath30 vertices is denoted @xmath31 ; the star on @xmath30 vertices is denoted @xmath32 .    the graph @xmath33 is formed by adding the vertex @xmath23 to the graph @xmath11 adjacent to the subset @xmath22 of vertices , its neighbourhood ; when @xmath22 is clear from the context , we simply write @xmath34 . the graph @xmath35 is formed from @xmath11 by removing @xmath23 and all its incident edges .",
    "the non - leaf vertices of a tree @xmath36 are called its _",
    "nodes_. the edges in a tree not incident to leaves are its _ internal _ edges .",
    "if @xmath19 is a set of leaves of @xmath36 , then @xmath37 denotes the smallest connected subtree spanning @xmath19 .",
    "if @xmath36 is a tree , then @xmath38 represents its number of nodes and leaves . in a rooted tree @xmath36 ,",
    "every node or leaf @xmath23 ( except the root ) has a unique _ parent _ , namely its neighbour on the path to the root .",
    "a _ child _ of a node @xmath23 is a neighbour of @xmath23 distinct from its parent .",
    "this subsection recalls original definitions from @xcite .",
    "a _ split _ of a connected graph @xmath39 is a bipartition @xmath40 of @xmath41 , where @xmath42 such that every vertex in @xmath43 is universal to @xmath44 .",
    "the sets @xmath45 and @xmath46 are called the _ frontiers _ of the split .",
    "a graph not containing a split is called _",
    "prime_. a bipartition is _ trivial _ if one of its parts is the empty set or a singleton .",
    "cliques and stars are called _ degenerate _ since every non - trivial bipartition of their vertices is a split :    [ degenerate ] let @xmath40 be a bipartition of the vertices in a clique or a star such that @xmath47 . then @xmath40 is a split .",
    "degenerate graphs and prime graphs represent the base cases in the process defining split decomposition :    [ def : split - dec - tree ] _ split decomposition _ is a recursive process decomposing a given graph @xmath11 into a set of disjoint graphs @xmath48 , called _",
    "split components _",
    ", each of which is either prime or degenerate .",
    "there are two cases :    1 .",
    "if @xmath11 is prime or degenerate , then return the set @xmath49 ; 2 .",
    "if @xmath11 is neither prime nor degenerate , it contains a split @xmath40 , with frontiers @xmath45 and @xmath46 .",
    "the split decomposition of @xmath11 is then the union of the split decompositions of the graphs @xmath50 + a$ ] and @xmath51 + b$ ] , where @xmath52 and @xmath53 are new vertices , called _ markers _ , such that @xmath54 + a}(a ) = a'$ ] and @xmath55 + b}(b ) = b'$ ] .",
    "notice that during the split decomposition process , the marker vertices can be matched by so called _",
    "split edges_. then given a split decomposition , provided the marker vertices and their matchings are specified , the input graph @xmath11 can be reconstructed without ambiguity .",
    "the set of split edges merely defines the _ split decomposition tree _ whose nodes are the components of the split decomposition .",
    "cunningham showed that every graph has a canonical split decomposition tree  @xcite .",
    "as cunningham s original work was on the decomposition of a graph by a family of bipartitions of the vertex set , his paper focuses on the tree representation of the family of splits to obtain a canonical tree rather than on how the graph s adjacencies can be retrieved from its split decomposition tree . at first sight , it is not immediately clear how the graph s adjacencies are encoded by the split decomposition tree , and what role the marker vertices play in determining them .",
    "tellingly , the base case treats prime and degenerate graphs the same ; looking at the tree , the viewer is left to guess which one applied . in recent papers",
    "@xcite , split decomposition is represented by the _ skeleton graph _ which is the union of the split components connected by the split edges .",
    "the fact that @xmath11 s vertices and the marker vertices are mixed is a drawback of this representation .",
    "a recent reformulation of split decomposition in terms of graph - labelled trees ( glts ) aims to clarify this  @xcite .",
    "our investigation of split decomposition takes place entirely in this new glt setting , which is described below .",
    "this subsection recalls definitions from @xcite and adds useful terminology .    [ @xcite ] a _ graph - labelled tree _ ( glt ) is a pair @xmath56 , where @xmath36 is a tree and @xmath57 a set of graphs , such that each node @xmath58 of @xmath36 is _ labelled _ by the graph @xmath59 , and there exists a bijection @xmath60 between the edges of @xmath36 incident to @xmath58 and the vertices of @xmath61 .",
    "( see figure  [ fig : gltexample ] . )",
    "when we refer to a node @xmath58 in a glt , we usually mean the node itself in @xmath36 ( non - leaf vertex ) . we may sometimes use the notation @xmath58 as a shortcut for its label @xmath59 ; the meaning will be clear from the context .",
    "for instance , notation will be simplified by saying @xmath62 .",
    "the vertices in @xmath63 are called _ marker vertices _ , and the edges between them in @xmath61 are called _ label - edges_. for a label - edge @xmath64 we may say that @xmath58 and @xmath65 are _ the vertices of _ @xmath66 .",
    "the edges of @xmath36 are _ tree - edges_. the marker vertices @xmath67 and @xmath68 of the internal tree - edge @xmath69 are called the _ extremities _ of @xmath66 . furthermore , @xmath68 is the _ opposite _ of @xmath67 ( and vice versa ) .",
    "a leaf is also considered an _",
    "extremity _ of its incident edge , and its opposite is the other extremity of the edge ( marker vertex or leaf ) . for convenience , we will use the term _ _ adjacent _ _ between : a tree - edge and one of its extremities ; a label - edge and one of its vertices ; two extremities of a tree - edge , etc .",
    ", as long as the context is clear .",
    "the most important notion for glts with respect to split decomposition is that of _ accessibility _ :    [ @xcite ] let @xmath56 be a glt .",
    "the marker vertices @xmath70 and @xmath71 are _ accessible _ from one another if there is a sequence @xmath72 of marker vertices @xmath73 such that :    1 .",
    "every two consecutive elements of @xmath72 are either the vertices of a label - edge or the extremities of a tree - edge ; 2 .   the edges thus defined alternate between tree - edges and label - edges .",
    "two leaves are accessible from one another if their opposite marker vertices are accessible ; similarly for a leaf and marker vertex being accessible from one another ; see figure  [ fig : gltexample ] where the leaves accessible from @xmath70 include both 3 and 15 but neither 2 nor 11 . by convention ,",
    "a leaf or marker vertex is accessible from itself .",
    "note that , obviously , if two leaves or marker vertices are accessible from one another , then the sequence @xmath72 with the required properties is unique , and the set of tree - edges in @xmath72 forms a path in the tree @xmath36 .",
    "let @xmath56 be a glt . then its _ accessibility graph _",
    ", denoted @xmath74 , is the graph whose vertices are the leaves of @xmath36 , with an edge between two distinct leaves @xmath75 and @xmath76 if and only if they are accessible from one another .",
    "conversely , we may say that @xmath56 _ is a glt of _ @xmath74 .",
    "accessibility allows us to view glts as encoding graphs ; an example appears in figure  [ fig : gltexample ] .     and its accessibility graph @xmath74 . ]",
    "let @xmath56 be a glt , and let @xmath70 be a marker vertex belonging to the node @xmath58 of @xmath36 and corresponding to the tree - edge @xmath66 of @xmath36 .",
    "then we denote :    - @xmath77 the set of leaves of @xmath36 from which there is a path to @xmath58 using @xmath66 ;    - @xmath78 the subset of leaves of @xmath77 that are accessible from @xmath70 ;    - @xmath79 the smallest subtree of @xmath36 that spans the leaves @xmath77 ; note that @xmath80 .    to unify our notation , for a leaf @xmath75 of @xmath36 ,",
    "the sets @xmath81 , @xmath82 , @xmath83 can be similarly defined , so that @xmath84 , @xmath75 s neighbourhood in @xmath85 , and @xmath86 .",
    "[ def : descendant ] let @xmath56 be a glt and let @xmath70 and @xmath87 be distinct marker vertices .",
    "then @xmath87 is a _ descendant _ of @xmath70 if @xmath88 , that is if @xmath89 is a subtree of @xmath90 .",
    "the above notation and definitions are illustrated in figure  [ fig : treeexample ] .",
    "also note that a leaf is never a descendant of a leaf or a marker vertex .",
    ", with @xmath91 and @xmath92 .",
    "bold edges are those used in sequences certifying the accessibility between @xmath70 and elements of @xmath78 .",
    "the vertices of the subtree @xmath90 are the elements of @xmath77 together with the three upper nodes .",
    "the marker vertex @xmath87 with @xmath93 is a descendant of @xmath70 .",
    "the marker vertex @xmath94 is the opposite of @xmath70 , and is not a descendant of @xmath70 . ]",
    "we conclude this subsection by a series of remarks following directly from the definitions .",
    "[ connectedlabels ] if a graph @xmath11 is connected , then every label in a glt of @xmath11 is connected .    for any marker vertex @xmath70 in a glt of a connected graph , @xmath95 .    as a consequence , by choosing one element of @xmath78 for every marker vertex @xmath70 in the label",
    "we see that every label in a glt of a connected graph @xmath11 is an induced subgraph of @xmath11 .",
    "[ rem : hered ]",
    "let @xmath87 and @xmath70 be two marker vertices of a glt such that @xmath87 is a decendent of @xmath70 .",
    "if @xmath87 and @xmath70 are accessible from one another , then @xmath96 . if @xmath87 and @xmath70 are non - accessible from one another , then @xmath97 .",
    "this subsection reformulates split decomposition @xcite in the glt setting , as done in @xcite .",
    "let @xmath66 be a tree - edge incident to nodes @xmath58 and @xmath98 in a glt , and let @xmath99 and @xmath100 be the extremities of @xmath66 .",
    "the _ node - join _ of @xmath101 replaces @xmath58 and @xmath98 with a new node @xmath65 labelled by the graph formed from @xmath61 and @xmath102 as follows : all possible label - edges are added between @xmath103 and @xmath104 , and then @xmath70 and @xmath71 are deleted .",
    "see figure  [ fig : njoinnsplitexample ] .",
    "[ def : node - split ] the _ node - split _ is the inverse of the node - join .",
    "more precisely , let @xmath65 be a node such that @xmath105 contains the split @xmath40 with frontiers @xmath45 and @xmath46 .",
    "the node - split with respect to @xmath40 replaces @xmath65 with two new adjacent nodes @xmath58 and",
    "@xmath98 labelled by @xmath50 + q$ ] and @xmath51 + q'$ ] , respectively , where @xmath70 and @xmath71 are the extremities of the new tree - edge thus created , @xmath70 being universal to @xmath45 , and @xmath71 being universal to @xmath46 .",
    "the extremities of the tree - edges incident to @xmath65 remain unchanged .",
    "see figure  [ fig : njoinnsplitexample ] .",
    "when a node - split or a node - join operation is performed , a marker vertex of the initial glt is _ inherited by _ the resulting glt through the operation if its corresponding tree - edge has not been affected by the operation , i.e. if its corresponding tree - edge is not created or deleted in one of the above definitions .",
    "the key property to observe is :    the node - join operation and the node - split operation preserve the accessibility graph of the glt .",
    "hence , glts do not uniquely encode graphs .",
    "in particular , recursive application of the node - join on every edge of a glt of @xmath11 leads to the glt with a unique node labelled by the accessibility graph @xmath11 . and",
    "conversely , any glt of a graph @xmath11 can be obtained by recursive application of the node - split from the glt consisting of a unique node labelled by @xmath11 . also , observe that , as a consequence , the accessibility graph @xmath11 of a glt and the tree structure of the glt ( with leaves labelled by @xmath17 ) completely determine the node labels of the glt .",
    "therefore , transforming a glt into another glt using node - splits and node - joins can be done using any ordering for such operations . in particular , performing a set of node - joins can be done in any order without changing the result ( the final tree structure is obtained by contracting edges from the initial tree ) . and concerning node - splits , creating two tree - edges using these operations can be done equally by creating first one tree - edge or the other .",
    "we emphasize these two remarks , as they will guarantee the consistency of further constructive statements .",
    "[ rem : node - join - commutative ] applying a sequence of node - joins on a glt yields the same glt , regardless of the order of the node - joins .",
    "[ rem : node - split - commutative ] recalling the notation of definition [ def : node - split ] , let @xmath65 be a node of a glt and let @xmath40 and @xmath106 be two splits of @xmath105 such that @xmath107 . then applying the _ node - split _ on @xmath65 with respect to @xmath40 and then on node @xmath98 with respect to @xmath108 or applying the _ node - split _ on @xmath65 with respect to @xmath106 and then on node @xmath58 with respect to @xmath109 yields the same glt .    of special interest",
    "are those node - joins / splits involving degenerate nodes .",
    "the _ clique - join _ is a node - join involving adjacent cliques : its result is a clique node ; the _ clique - split _ is its inverse operation .",
    "the _ star - join _ is a node - join involving adjacent stars whose common incident tree - edge has exactly one extremity that is the centre of its star : its result is a star node ; the _ star - split _ is its inverse operation .",
    "figure  [ fig : cliquestarexample ] provides examples .",
    "a glt is _ reduced _ if all its labels are either prime or degenerate , and no clique - join or star - join is possible .",
    "we can now state the main result of @xcite , as reformulated in @xcite .",
    "[ @xcite ] [ theo : reduced - glt ] for any connected graph @xmath11 , there exists a unique , reduced graph - labelled tree @xmath56 such that @xmath85 .",
    "the unique glt guaranteed by the previous theorem is the _ split - tree _ , and is denoted @xmath110 .",
    "the glt in figure  [ fig : gltexample ] is the split - tree for the accessibility graph pictured there .",
    "the split - tree is the intended replacement for cunningham s split decomposition tree .",
    "the following theorem first appeared in cunningham s seminal paper  @xcite in an equivalent form .",
    "we phrase it in terms of glts and the split - tree :    [ prop : split_list ] let @xmath11 be a connected graph .",
    "a bipartition @xmath40 is a split of @xmath11 if and only if either there exists an internal tree - edge of @xmath110 with extremities @xmath87 and @xmath70 such that @xmath111 and @xmath112 , or there exists a degenerate node @xmath58 and a split @xmath113 of @xmath61 such that @xmath114 and @xmath115 .    in order words ,",
    "the split - tree can be understood as a compact representation of the family of splits of a connected graph .",
    "indeed it is easy to show that the size of the split - tree @xmath110 of a graph is linear in the size of @xmath11 ( the sum of the sizes of label graphs of @xmath110 is linear in the size of @xmath11 ) , whereas a graph can have exponentially many splits ( it is the case for the clique and the star ) .",
    "the following corollary is simply a rephrasing of theorem  [ prop : split_list ] based on the node - split operation .",
    "[ @xcite][cor : split_list ] let @xmath116 .",
    "any split of @xmath11 is the bipartition ( of leaves ) induced by removing an internal tree - edge from @xmath117 , where @xmath118 , or @xmath117 is obtained from @xmath36 by exactly one node - split of a degenerate node .",
    "compared to cunnigham s split decomposition tree or the skeleton graph representation ( see the remarks following definition  [ def : split - dec - tree ] ) , the advantage of the split - tree is manifest . the adjacency relation in the underlying graph is now explicitly represented by the accessibility relation , and the role played by the marker vertices ( and their own adjacencies ) is established .",
    "all this added information comes with no space - tradeoff :    [ @xcite ] [ treesize ] let @xmath116 . if @xmath119 , then @xmath120 .",
    "as mentioned in the introduction , our algorithm incrementally builds the split - tree by adding vertices one at a time from the input graph . now , adding a single vertex to the split - tree of a graph with @xmath30 vertices can require @xmath121 changes , as demonstrated in figure  [ fig : badexample ] .",
    "however , later in the paper we prove that if vertices are added according to a lexicographic breadth - first search ( lbfs ) ordering , then the total cost of inserting all vertices of @xmath11 can be amortized to linear time up to inverse ackermann function .",
    "changes to the split - tree ( the neighbours of @xmath23 appear as the grey leaves ) . ]    this section presents new lbfs results on the split decomposition and more generally on glts .",
    "we first present the lbfs algorithm and some known results .",
    "lexicographic breadth - first search ( lbfs ) was developed by rose , tarjan , and lueker for the recognition of chordal graphs  @xcite and has since become a standard tool in algorithmic graph theory  @xcite .",
    "an _ ordering _ @xmath122 of a graph @xmath11 is a linear ordering of its set of vertices @xmath17 .",
    "formally , we can define it either as an injective mapping from @xmath17 to the integers , or as an ordering binary relation .",
    "we slightly abuse notation by allowing @xmath122 to represent such a mapping as well as the ordering , and we let @xmath123 denote the binary relation : @xmath124 is equivalent to @xmath125 .",
    "in such a case , we say that `` @xmath23 appears before @xmath28 '' , or `` earlier than @xmath28 '' , in @xmath122 .",
    "similarly , by `` first '' , `` last '' and `` penultimate '' , we denote respectively , the smallest element of @xmath123 , the greatest element and the element appearing immediately before the last one . by an lbfs ordering of the graph @xmath11 , we mean any ordering produced by algorithm  [ alg : lbfs ] on input graph @xmath11 . notice that such an ordering can be built in linear time ( see e.g.  @xcite ) .",
    "the next result characterizes lbfs orderings :    [ @xcite ] [ 4vertex ] an ordering @xmath122 of a graph @xmath11 is an lbfs ordering if and only if for any triple of vertices @xmath126 with @xmath127 , @xmath128 , there is a vertex @xmath129 such that @xmath130 , @xmath131 .    for a subset @xmath19 of @xmath17 , @xmath132 $ ] denotes the restriction of @xmath122 to @xmath19 .",
    "a _ prefix _ of an ordering @xmath122 is a set @xmath19 such that @xmath124 and @xmath133 implies @xmath134 .",
    "one obvious result is the following :    [ prefix ] let @xmath19 be a prefix of any lbfs ordering @xmath122 of connected graph @xmath11 .",
    "then @xmath132 $ ] is an lbfs ordering of @xmath20 $ ] , and @xmath20 $ ] is connected .",
    "we now introduce a general lemma about split decomposition , followed by lemmas relating lbfs orderings and split decomposition .",
    "[ newsplit ] let @xmath11 and @xmath34 be two connected graphs such that @xmath11 is prime but @xmath34 is not .",
    "then either @xmath23 is a pendant vertex or @xmath23 has a twin .",
    "since @xmath135 is not prime , it has a split @xmath40 .",
    "let @xmath45 and @xmath46 be the frontiers of the split . without loss of generality , assume that @xmath136 . since @xmath137 is not a split in @xmath11 , we know that @xmath138 . if @xmath139 , then @xmath11 is disconnected .",
    "if @xmath140 , then @xmath28 is a twin of @xmath23 . if @xmath141 , then @xmath142 , since @xmath34 is connected .",
    "therefore @xmath23 is a pendant .",
    "[ lbfstwin ] let @xmath11 and @xmath34 be two connected graphs and let @xmath122 be an lbfs ordering of @xmath34 in which @xmath23 appears last .",
    "if @xmath11 is prime and @xmath23 has a twin @xmath28 , then @xmath28 is either universal in @xmath11 or is the penultimate vertex in @xmath122 .",
    "observe that if @xmath143 , then @xmath28 is unique since @xmath11 is prime .",
    "consider an execution of algorithm  [ alg : lbfs ] that produced the ordering @xmath122 .",
    "let @xmath19 be the set of vertices with the same label as @xmath28 at the time @xmath28 is numbered by algorithm  [ alg : lbfs ] ( of course @xmath133 ) . as @xmath23 and @xmath28 are twins , we must have @xmath144 .",
    "we can assume that @xmath145 as otherwise @xmath28 would be the penultimate vertex of @xmath122 .",
    "let @xmath146 be the set of vertices numbered before @xmath28 by algorithm  [ alg : lbfs ] .",
    "observe that @xmath147 as otherwise @xmath11 would contain the split @xmath148 .",
    "consider the case where @xmath149 .",
    "then @xmath28 is the first vertex in @xmath122 and immediately following @xmath28 are the vertices in @xmath150 . if @xmath28 is not universal in @xmath11 , then the set @xmath151 is non - empty and in @xmath122 , all of its vertices appear after those in @xmath150 .",
    "we claim that there is a join between @xmath150 and @xmath152 .",
    "suppose for contradiction that there is no such join .",
    "then there is a vertex @xmath153 that is not universal to @xmath152 .",
    "consider some vertex @xmath154 such that @xmath155 .",
    "with @xmath23 and @xmath28 twins , it follows that @xmath156 .",
    "hence , @xmath157 , and @xmath156 but @xmath155 .",
    "therefore , by lemma  [ 4vertex ] , there is a vertex @xmath158 such that @xmath159 but @xmath160 .",
    "but @xmath23 is universal to @xmath150 since it is @xmath28 s twin , and thus @xmath161 .",
    "given the restrictions on @xmath122 noted above , it follows that @xmath162 .",
    "but then @xmath163 , since @xmath154 , providing the desired contradiction .",
    "that means there is a join between @xmath150 and @xmath152 .",
    "but now , unless @xmath164 , @xmath165 is a split in @xmath11 contradicting @xmath11 being prime . when @xmath164 , if @xmath166 , then @xmath11 is a star on three vertices and @xmath135 is a star on four vertices , where the penultimate vertex is a twin of @xmath23 ( note that by lemma  [ 4vertex ] , @xmath167 ) ; if @xmath168 , @xmath169 is a split in @xmath11 .",
    "thus @xmath146 is not empty .",
    "so let @xmath170 be the unique vertex of @xmath146 .",
    "now @xmath19 , as ordered by @xmath122 , consists of @xmath28 followed by @xmath171 , followed by @xmath172 ( vertices of @xmath173 not adjacent to @xmath28 ) ; @xmath23 is the last element of @xmath19 as @xmath145 , we have that @xmath174 . since @xmath23 and @xmath28 are twins , @xmath23 is universal to @xmath175 and not adjacent to any vertices in @xmath172 . since @xmath28 is not universal in @xmath11 , @xmath176 and thus by lemma  [ 4vertex ] , @xmath23 is not adjacent to @xmath28 . if @xmath177 , then unless @xmath178 , @xmath11 has the split @xmath179 .",
    "if @xmath178 , then , as in the @xmath149 case , @xmath11 is a star on three vertices and @xmath34 is a star on four vertices , where the penultimate vertex is a twin of @xmath23 .",
    "thus @xmath180 and @xmath176 . by the application of lemma  [ 4vertex ] to @xmath181 , where @xmath182 , we see that @xmath183 and thus @xmath184 is a split of @xmath11 , contradicting @xmath11 being prime .",
    "let @xmath58 be a node in a glt @xmath56 .",
    "notice that the sets @xmath185 partition the leaves of @xmath36 .",
    "in other words , each marker vertex can be associated with a distinct leaf in @xmath36 .",
    "this allows us to define a type of induced lbfs ordering on @xmath61 as demonstrated below .",
    "let @xmath58 be a node of a glt @xmath56 and let @xmath122 be an ordering of @xmath85 . for any marker vertex @xmath87 , let @xmath186 be the earliest vertex of @xmath187 in @xmath122 .",
    "define @xmath188 $ ] to be the ordering of @xmath61 such that for @xmath189 , @xmath190 } r$ ] if @xmath191 .",
    "[ inducedlbfs ] let @xmath122 be an lbfs ordering of a connected graph @xmath85 , and let @xmath58 be a node in @xmath56",
    ". then @xmath188 $ ] is an lbfs ordering of @xmath61 .",
    "first observe that if we collect in a set @xmath19 one leaf @xmath192 of @xmath78 for every marker vertex @xmath193 , then the induced subgraph @xmath20 $ ] is isomorphic to @xmath61 .",
    "notice that @xmath188 $ ] is then the ordering @xmath132 $ ] if each selected leaf @xmath192 is chosen to be the earliest in @xmath122 .",
    "we prove by induction on the number of nodes in @xmath36 that @xmath132=\\sigma[g(u)]$ ] is an lbfs ordering of @xmath61 . to that aim",
    ", we use lemma  [ 4vertex ] .    as an induction hypothesis ,",
    "assume the lemma holds for all graphs whose split - tree has fewer nodes than @xmath110 .",
    "the lemma clearly holds if @xmath56 contains only one node , because @xmath20 $ ] is isomorphic to @xmath11 in this case .",
    "so assume that @xmath56 contains more than one node .",
    "then there is a @xmath99 such that @xmath90 contains at least one node .",
    "let @xmath194 be the leaf associated with @xmath70 in @xmath188 $ ] .",
    "let @xmath195 $ ] .",
    "remove @xmath90 from @xmath56 , choosing @xmath192 to be the leaf that replaces its nodes ; let @xmath196 be the resulting glt . clearly @xmath197 . for simplicity ,",
    "let @xmath198 $ ] .",
    "suppose @xmath52 , @xmath53 and @xmath199 form a triple of vertices of @xmath200 as in lemma  [ 4vertex ] . as @xmath122 is an lbfs ordering of @xmath11 , there exists",
    "@xmath201 appearing earlier than @xmath52 in @xmath122 which is adjacent to @xmath53 but not to @xmath199 .",
    "suppose that @xmath202 does not belong to @xmath200 , i.e. @xmath203 and @xmath204 .",
    "let @xmath87 be @xmath70 s opposite in @xmath56 . as @xmath205 is a split of @xmath11 , the vertex @xmath53 either belongs to @xmath206 or @xmath77 . in the former case , since @xmath53 is adjacent to a vertex in @xmath77 , @xmath207 and thus @xmath208 .",
    "by the choice of @xmath192 , it can replace vertex @xmath202 .",
    "( note that @xmath209 and thus @xmath210 and @xmath199 are not adjacent . ) in the latter case , since @xmath192 is the only @xmath77 vertex in @xmath211 , @xmath212 and @xmath213 .",
    "moreover , by the choice of @xmath192 , @xmath202 belongs to @xmath214 .",
    "we now prove that @xmath52 can not appear before @xmath53 in @xmath122 , yielding a contradiction .",
    "as @xmath53 is the only vertex of @xmath77 present in @xmath200 , so vertex @xmath52 belongs to @xmath215 . by the choice of @xmath192 , no vertex of @xmath78 appears before @xmath52 in @xmath122 . by remark  [ prefix ] ,",
    "the subgraph of @xmath11 induced on the vertices of @xmath122 up to , and including @xmath52 is connected .",
    "but , there can be no path in the subgraph connecting @xmath216 and @xmath52 since @xmath78 is a separator for @xmath202 and @xmath52 , and @xmath212 is the earliest vertex of @xmath78 in @xmath122 .",
    "thus @xmath52 can not appear before @xmath53 in @xmath122 , thereby contradicting the existence of the triple @xmath217 .",
    "it follows that @xmath218 is an lbfs ordering of @xmath211 .",
    "of course , @xmath196 has fewer nodes than @xmath56 .",
    "we can therefore apply our induction hypothesis .",
    "hence , @xmath132 $ ] is an lbfs ordering of @xmath219 $ ] .",
    "but notice that @xmath219 $ ] is isomorphic to @xmath20 $ ] which is isomorphic to @xmath61 .",
    "the induction step follows .",
    "throughout this section we assume that the graphs @xmath11 and @xmath135 are both connected .",
    "we provide a simple combinatorial description of the updates required in @xmath110 to arrive at @xmath220 . the proof is obtained by a case by case analysis of the properties of @xmath110 when removing @xmath23 from @xmath220 , which turns out to be easily invertible .",
    "most results in the paper rely on the next definition . intuitively , its aim is to allow a characterization of the portions of the split - tree that change or fail to change under the insertion of a new  vertex .",
    "[ def : states ] let @xmath56 be a glt , and let @xmath70 be one of its leaves or marker vertices .",
    "let @xmath19 be a subset of @xmath36 s leaves .",
    "then the _ state ( with respect to _ @xmath19 _ _ ) of _ _ @xmath70 is :    - _ perfect _ if @xmath221 ;    - _ empty _ if @xmath222 ;    - and _ mixed _ otherwise .    for a node @xmath58 ,",
    "define the sets @xmath223 , @xmath224 , and @xmath225 ( `` ne '' for `` not - empty '' ) .",
    "see figure  [ fig : stateexample ] .",
    "[ rk : inherited - states ] the state of a marker vertex before and after a node - split or a node - join is the same .",
    "notice that the opposite of any leaf @xmath226 must be either perfect ( if @xmath227 or empty ( if @xmath228 .",
    "we extend the state definition to subtrees : if a marker vertex ( or leaf ) @xmath70 is perfect ( respectively empty , mixed ) , then the _ subtree @xmath90 is perfect _ ( respectively _ empty , mixed _ ) as well .",
    "a node @xmath58 of @xmath36 is _ hybrid _ if every marker vertex @xmath193 is either perfect or empty and @xmath70 s opposite is mixed .",
    "a tree - edge @xmath66 of @xmath36 is _ fully - mixed _ if both of its extremities are mixed .",
    "a _ fully - mixed subtree _",
    "@xmath229 of @xmath36 is one that contains at least one tree - edge , all of its tree - edges are fully - mixed , and it is maximal for inclusion with respect to this property . for a degenerate node @xmath58 ,",
    "we denote : @xmath230 we now describe some basic properties .",
    "the first key lemma follows directly from remark  [ rem : hered ] , and implies the subsequent corollary .",
    "[ lem : hereditary ] let @xmath56 be a glt marked with respect to a subset of leaves @xmath19",
    ". then    1 .",
    "a marker vertex @xmath70 is perfect if and only if every accessible descendant of @xmath70 is perfect and every non - accessible descendant of @xmath70 is empty .",
    "a marker vertex @xmath70 is empty if and only if every descendant of @xmath70 is empty .",
    "[ cor : hereditary ] let @xmath56 be a glt marked with respect to a subset of leaves @xmath19 .    1 .",
    "if marker vertex @xmath70 is mixed , then every marker vertex having @xmath70 as a descendant is mixed .",
    "if a tree - edge has a perfect or empty extremity @xmath70 with a mixed opposite , then , for every tree - edge in @xmath90 , the extremity that is a descendant of @xmath70 is perfect or empty and its opposite is mixed .",
    "if there exists a hybrid node , then it is unique .",
    "4 .   in a clique node , if every marker vertex is perfect , then every opposite of a marker vertex is also perfect .",
    "5 .   in a star node ,",
    "if every marker vertex is empty , except the centre which is perfect , then every opposite of a marker vertex is perfect , except the opposite of the centre which is empty .",
    "this subsection is devoted to technical lemmas , which aim to enumerate and characterize in terms of states all possible cases for the deletion of @xmath23 from @xmath220 .",
    "their proofs rely on an extensive use of the hereditary property ( lemma  [ lem : hereditary ] ) and corollary  [ cor : hereditary ] .",
    "these lemmas will only be used in the proofs of the next subsection to describe how to update @xmath110 when inserting a new vertex .    in this subsection , we let @xmath58 denote the node of @xmath220 to which the leaf @xmath23 is attached .",
    "let @xmath231 be the glt , obtained from @xmath220 by removing leaf @xmath23 and @xmath232 its opposite marker vertex in the label of @xmath58 , and let @xmath233 be the node corresponding to @xmath58 in @xmath234 , such that @xmath235 .",
    "note that the accessibility graph of @xmath234 is @xmath11 . for convenience , but contrary to the definition , the glt @xmath234 is allowed to have a binary node @xmath233 in the case where @xmath58 was ternary ; in this case , `` _ contraction of @xmath233 to @xmath66 _ '' refers to the operation of replacing @xmath233 and its two adjacent tree - edges by a single tree - edge @xmath66 . to simplify ,",
    "we may identify a marker vertex in @xmath234 with the corresponding marker vertex in @xmath220 .",
    "finally , we assume that @xmath110 and @xmath234 are marked with respect to @xmath236 .",
    "notice we consider @xmath23 to have the perfect state and thus the states of the descendants of @xmath23 in @xmath234 are determined to be either perfect or empty by applying lemma [ lem : hereditary]-1 in @xmath220 . to shorten statements ,",
    "a tree - edge is said to be @xmath237 ,",
    "@xmath238 , @xmath239 , @xmath240 , or @xmath241 ( i.e. fully - mixed ) , depending on the states of its two extremities , where @xmath242 , @xmath243 , and @xmath244 , stands respectively for perfect , empty , and mixed .    in the following subsections",
    ", we deal with all possibilities of @xmath58 , the node in @xmath220 to which @xmath23 is adjacent .",
    "[ lem : x_to_clique_states ] assume @xmath23 is adjacent to a clique @xmath58 in @xmath220 .",
    "then every tree - edge of @xmath234 incident to @xmath233 is @xmath237 , and every other edge in @xmath234 is either @xmath239 or @xmath240 .",
    "every marker vertex of @xmath233 is a descendant of @xmath23 in @xmath220 and hence it is perfect by the hereditary property ( lemma  [ lem : hereditary]-1 ) .",
    "then by corollary  [ cor : hereditary]-4 , every opposite @xmath87 of a marker vertex @xmath245 of @xmath233 is perfect .",
    "so every tree - edge incident to @xmath233 is @xmath237 .",
    "let @xmath65 be a node adjacent to @xmath233 by the tree - edge @xmath66 , and let @xmath87 and @xmath245 be respectively the extremities of @xmath66 in @xmath65 and in @xmath233 .",
    "let @xmath94 be the opposite of a marker vertex @xmath70 of @xmath65 distinct from @xmath87 .",
    "observe that @xmath246 contains the node @xmath233 and thus @xmath94 has a perfect descendant . so by the hereditary property ( lemma  [ lem : hereditary]-2 ) , @xmath94 can not be empty .",
    "we now prove that if @xmath94 is perfect then , by the hereditary property ( lemma  [ lem : hereditary]-1 ) , @xmath65 is a clique node .",
    "observe first that lemma  [ lem : hereditary]-1 applied on @xmath94 and @xmath87 implies that @xmath87 and @xmath70 are adjacent .",
    "since @xmath105 is connected and contains at least @xmath2 marker vertices , @xmath65 contains a marker vertex distinct from @xmath87 and @xmath70 adjacent to at least one of @xmath87 or @xmath70 .",
    "as every such vertex @xmath170 is a descendant of @xmath245 and @xmath94 ( both being perfect ) , lemma  [ lem : hereditary]-1 implies that @xmath170 is adjacent to both @xmath87 and @xmath70 .",
    "it follows that either @xmath247 forms a split in @xmath105 or @xmath65 is ternary .",
    "since @xmath220 is reduced , in both cases @xmath65 is degenerate and by the adjacencies between @xmath87 , @xmath70 and @xmath170 , @xmath65 is a clique node .",
    "so we proved that if @xmath94 is perfect , then @xmath220 contains two adjacent clique nodes : contradiction .",
    "it follows that @xmath94 is mixed . by the hereditary property ( lemma  [ lem : hereditary]-1 ) ,",
    "since @xmath245 is perfect , @xmath70 is either perfect or empty . hence , every tree - edge not incident to @xmath233 is @xmath239 or @xmath240 by corollary [ cor : hereditary]-2 .",
    "[ lem : x_to_clique ] assume @xmath23 is adjacent to a clique node @xmath58 in @xmath220 .    1 .",
    "if @xmath58 is ternary , let @xmath56 be the glt resulting from the contraction of @xmath233 to @xmath66 in @xmath234",
    "if @xmath56 is reduced then @xmath248 and @xmath66 is the unique @xmath237 tree - edge of @xmath110 , every other tree - edge is @xmath239 or @xmath240 .",
    "2 .   otherwise , @xmath110 results from the star - join in @xmath56 of the nodes incident to @xmath66 ( let @xmath65 be the resulting node ) .",
    "then @xmath65 is the unique hybrid node of @xmath110 , and every tree - edge is @xmath239 or @xmath240 .",
    "if @xmath58 is not ternary then @xmath249 , @xmath233 is the unique clique node of @xmath110 whose marker vertices are all perfect , the tree - edges incident to @xmath233 are @xmath237 and every other tree - edge is @xmath239 or @xmath240 .",
    "the correctness of the construction of @xmath110 follows directly from the definition of the split - tree since the involved operations preserve the accessibility graph @xmath11 and yield a reduced glt .",
    "the state properties of tree - edges come directly from lemma [ lem : x_to_clique_states ] since , by remark [ rk : inherited - states ] , states of marker vertices are preserved by the involved operations .",
    "this conclude the proof for cases 1(a ) and 2 since uniqueness follows in both cases from lemma  [ lem : x_to_clique_states ] .    in case 1(b ) , let @xmath87 and @xmath70 denote the two marker vertices of @xmath233 .",
    "observe that as @xmath58 is a clique node and as @xmath56 is not reduced , the two neighbours @xmath250 and @xmath251 of @xmath233 are star nodes such that the centre of @xmath250 is the opposite of @xmath87 , whereas the centre of @xmath251 is not the opposite of @xmath70 .",
    "it follows that @xmath110 results from a star - join of @xmath250 and @xmath251 .",
    "note that the node @xmath65 ( resulting from the star - join ) inherits from @xmath250 and @xmath251 the descendants of @xmath23 in @xmath220 .",
    "it follows by the hereditary property ( lemma  [ lem : hereditary]-1 ) , that the marker vertices of @xmath65 are perfect or empty .",
    "finally observe that @xmath65 contains empty and perfect marker marker vertices : the non - centre marker vertices inherited from @xmath251 are empty , all the others are perfect .",
    "it follows that @xmath65 is a hybrid node and it is unique ( by corollary [ cor : hereditary]-3 ) .",
    "[ lem : x_to_star_states ] assume @xmath23 is adjacent to a star node @xmath58 in @xmath220 .",
    "then every tree - edge of @xmath234 incident to @xmath233 is @xmath238 , and every other edge in @xmath234 is either @xmath239 or @xmath240 .",
    "let @xmath199 be the centre of the star @xmath61 .",
    "since @xmath11 is connected , @xmath232 the opposite of @xmath23 is a degree-1 marker vertex of @xmath61 .",
    "it follows that @xmath252 , and thus , @xmath199 is perfect and , by corollary [ cor : hereditary]-5 , its opposite @xmath87 is empty .",
    "now let @xmath70 be a marker vertex of @xmath233 distinct from @xmath199 and let @xmath94 be its opposite . by the hereditary property ( lemma  [ lem : hereditary]-2 ) , as a descendant of @xmath87 , @xmath70 is empty . by corollary [ cor : hereditary]-5",
    ", @xmath94 is perfect .",
    "so we proved that every tree - edge incident to @xmath233 is @xmath238 .",
    "we now prove that every tree - edge non - incident to @xmath233 is either pm or em .",
    "let @xmath65 be a node adjacent to @xmath233 by the tree - edge @xmath66 , and let @xmath87 and @xmath245 be respectively the extremities of @xmath66 in @xmath65 and in @xmath233 .",
    "let @xmath94 be the opposite of a marker vertex @xmath70 of @xmath65 distinct from @xmath87 .    assume first that @xmath253",
    ". then by lemma  [ lem : hereditary]-2 , since @xmath199 is a perfect descendant of @xmath94 , @xmath94 is not empty .",
    "so suppose for contradiction that @xmath94 is perfect .",
    "observe first that lemma  [ lem : hereditary]-1 applied to @xmath94 and @xmath87 implies that @xmath87 and @xmath70 are adjacent and that by lemma  [ lem : hereditary]-2 , as a descendant of @xmath245 , @xmath70 is empty .",
    "since @xmath105 is connected and contains at least @xmath2 marker vertices , @xmath65 contains a marker vertex @xmath170 distinct from @xmath87 and @xmath70 adjacent to at least one of @xmath87 or @xmath70 . as @xmath252",
    ", we have that @xmath254 implying that @xmath170 is empty . as @xmath170 is a descendant of @xmath94 , by lemma  [ lem : hereditary]-1 , @xmath170 is not adjacent to @xmath70 and thereby it is adjacent to @xmath87 .",
    "it follows that in @xmath105 , the marker vertex @xmath70 has degree one .",
    "then @xmath65 has to be a star node whose centre is @xmath87 : this contradicts the fact that @xmath220 is reduced .",
    "it follows that @xmath94 is mixed ( it can not be perfect or empty ) .",
    "assume now that @xmath255 . if @xmath94 is empty , by definition @xmath256 .",
    "for every neighbour @xmath71 of @xmath87 , there exists a leaf accessible from @xmath199 in @xmath257 , and hence an element of @xmath19 is in @xmath257 .",
    "but now , for every @xmath258 , @xmath259 which contradicts @xmath256 .",
    "thus @xmath70 is the only neighbour of @xmath87 in @xmath105 , and @xmath65 has to be a star node whose centre is @xmath70 ; this contradicts the fact that @xmath220 is reduced .",
    "so @xmath94 is perfect or mixed .",
    "now assume @xmath94 is perfect .",
    "since @xmath87 is an empty descendant of @xmath94 , by lemma  [ lem : hereditary]-1 , @xmath87 and @xmath70 are not adjacent in @xmath105 .",
    "since @xmath105 is connected and contains at least @xmath2 marker vertices , @xmath65 contains a marker vertex distinct from @xmath87 and @xmath70 adjacent to at least one of @xmath87 or @xmath70 .",
    "as every such vertex @xmath170 is a descendant of @xmath94 and @xmath199 , both being perfect , lemma  [ lem : hereditary]-1 implies that @xmath170 is adjacent to @xmath87 and @xmath70 .",
    "it follows that either @xmath247 forms a split in @xmath105 or @xmath65 is ternary . in both cases ,",
    "@xmath65 is degenerate and by the adjacencies between @xmath87 , @xmath70 and @xmath170 , @xmath65 is a star node whose centre is @xmath170 .",
    "this contradicts the fact that @xmath220 is reduced .",
    "it follows in this case also that @xmath94 is mixed ( it can not be perfect or empty ) .",
    "so @xmath94 is always mixed and @xmath70 is perfect or empty by the hereditary property ( lemma [ lem : hereditary]-1 applied to the marker vertices of @xmath233 ) .",
    "then , every tree - edge not incident to @xmath233 is @xmath239 or @xmath240 by corollary [ cor : hereditary]-2 .",
    "[ lem : x_to_star ] assume @xmath23 is adjacent to a star node @xmath58 in @xmath220 .    1 .",
    "if @xmath58 is ternary , let @xmath56 be the glt resulting from the contraction of @xmath233 to @xmath66 in @xmath234",
    "if @xmath56 is reduced then @xmath248 and @xmath66 is the unique @xmath238 tree - edge of @xmath110 , and every other tree - edge is @xmath239 or @xmath240 .",
    "2 .   otherwise , @xmath110 results from the star - join or a clique - join in @xmath56 of the nodes incident to @xmath66 ( let @xmath65 be the resulting node ) .",
    "then @xmath65 is the unique hybrid node of @xmath110 , and every tree - edge is @xmath239 or @xmath240 .",
    "if @xmath58 is not ternary then @xmath249 , @xmath233 is its unique star node whose marker vertices are all empty except the centre , which is perfect , tree - edges adjacent to @xmath233 are @xmath238 , and all other tree - edges are @xmath239 or @xmath240 .",
    "the proof follows the same lines as the proof of lemma [ lem : x_to_clique ] , using lemma [ lem : x_to_star_states ] instead of lemma [ lem : x_to_clique_states ] .",
    "only the arguments to show that @xmath65 is a hybrid node in case 1(b ) differ slightly .",
    "so assume case 1(b ) holds .",
    "as @xmath58 is ternary and @xmath56 is not reduced , the two neighbours @xmath250 and @xmath251 of @xmath58 are either clique nodes or star nodes .",
    "suppose that the centre @xmath199 of @xmath58 is the extremity of the tree - edge @xmath260 .",
    "let : @xmath261 be the opposite of @xmath199 ; @xmath262 be the marker vertex of @xmath251 s extremity of the tree - edge @xmath263 ; and @xmath70 be the opposite of @xmath262 .",
    "observe that @xmath261 is universal in @xmath264 : this is trivial if @xmath264 is a clique node ; if @xmath264 is a star node , then the fact that @xmath220 is reduced implies that @xmath261 is the centre of the star .",
    "now , due to their adjacency with @xmath232 ( the opposite of @xmath23 ) , @xmath199 is perfect and @xmath70 is empty .",
    "it follows by lemma  [ lem : hereditary]-1 , that the marker vertices of @xmath250 distinct from @xmath261 are perfect ( since they are accessible descendants of @xmath199 ) .",
    "similarly , by lemma  [ lem : hereditary]-2 , the marker vertices of @xmath251 distinct from @xmath262 are empty ( since they are descendant of @xmath70 ) . as all these marker vertices are inherited by @xmath65 , @xmath65 is an hybrid node which is unique ( by corollary [ cor : hereditary]-3 ) .",
    "here we have two cases depending on whether or not @xmath265 is also prime .",
    "[ lem : x_to_prime_hybrid ] assume that @xmath23 is adjacent to a prime node @xmath58 in @xmath220 such that @xmath265 is also prime .",
    "then @xmath249 , @xmath233 is its unique hybrid node , and every tree - edge is @xmath239 or @xmath240 .",
    "observe that by construction , every marker vertex of @xmath233 is either perfect or empty .",
    "let @xmath87 be the opposite of a marker vertex @xmath245 of @xmath233 .",
    "assume that @xmath87 is perfect .",
    "then , in @xmath61 , @xmath245 is a twin of @xmath232 , the opposite of @xmath23 : contradicting the fact that @xmath58 is a prime node of @xmath220 .",
    "so assume that @xmath87 is empty .",
    "then , by the hereditary property ( lemma [ lem : hereditary]-2 ) , every marker vertex @xmath70 distinct from @xmath245 in @xmath233 is empty .",
    "it follows that @xmath266 and thereby @xmath245 is the only neighbour of @xmath232 in @xmath61 .",
    "this is again a contradiction with the fact that @xmath58 is a prime node of @xmath220 , since a prime graph does not contain pendant vertices .",
    "thus @xmath87 is mixed and now the proof follows from corollary [ cor : hereditary ] ( -2 and -3 ) .",
    "it remains to analyse the case where @xmath23 is adjacent to a prime node @xmath58 in @xmath220 but @xmath265 is not prime . to that aim",
    ", we describe a three step construction that computes @xmath110 from @xmath220 .",
    "note that this construction is not part of the split decomposition algorithm itself .",
    "let us first recall that when a node - join or a node - split has been performed on an initial glt , then a marker vertex is _ inherited _ by the resulting glt if its corresponding tree - edge is not affected by the operation .",
    "we say that a tree - edge @xmath64 of a glt is _ non - reduced _ if a node - join on @xmath58 and @xmath65 yields a star node or a clique node .",
    "the announced construction is the following ; it uses @xmath234 as input :    1 .",
    "while the current glt contains a node @xmath65 which is neither prime nor degenerate , find a split in @xmath105 and perform the node - split accordingly .",
    "while the resulting glt contains a non - reduced tree - edge @xmath66 both extremities of which are not inherited from @xmath234 , perform the corresponding node - join .",
    "let @xmath267 be the resulting glt .",
    "3 .   while the current glt contains a non - reduced tree - edge , perform the corresponding node - join .",
    "let @xmath56 be the resulting glt .",
    "the rest of the results in this section should be interpreted in the context of the above construction , which will subsequently be referred to as the _ prime - splitting construction _ for simplicity .",
    "the following observation concerning the prime - splitting construction follows from the fact that a node - join and a node - split do not change the accessibility of a glt and that @xmath56 is clearly reduced .",
    "[ obs : st(g ) ] the glt @xmath56 resulting from the prime - splitting construction is the split - tree @xmath110 .",
    "intuitively , the glt @xmath267 is obtained from @xmath268 by replacing the node @xmath233 with the split - tree @xmath269 .",
    "such a replacement is obtained by accurately identifying the leaves of @xmath269 with the marker vertices opposite the marker vertices of @xmath233 . indeed",
    ", note that in the case where @xmath34 is prime , but not @xmath11 , then @xmath270 . to help the intuition of the following lemmas , we state the summarizing lemma ( lemma [ lem : x_to_prime ] ) in the context of this special case .",
    "we will now describe the properties of @xmath110 and of the intermediate glt @xmath267 in terms of the states of their marker vertices . recall that by remark  [ rk : inherited - states ] , the states of inherited marker vertices remain unchanged . also observe that after a series of node - joins and node - splits , a tree - edge @xmath66 of the resulting glt has its two extremities either both inherited or both non - inherited . in the former case , @xmath66 is an _ inherited tree - edge _ , in the latter case a _ non - inherited tree - edge_. finally observe that if @xmath66 is a non - inherited tree - edge , then it corresponds to a split @xmath271 of @xmath265 since it results from the first and second steps of the prime - splitting construction . intuitively , the non - inherited tree - edges correspond to the internal tree - edges of @xmath269 .",
    "[ lem : x_to_prime_states ] consider the prime - splitting construction .",
    "assume that @xmath23 is adjacent to a prime node @xmath58 in @xmath220 .",
    "then every non - inherited tree - edge of @xmath267 is mm and every inherited tree - edge is pm or em .",
    "note that if @xmath265 is prime , the result is trivial .",
    "we first prove that inherited tree - edges are pm or em . to that aim",
    "we first argue that every opposite @xmath70 of a marker vertex @xmath87 of @xmath233 is mixed in @xmath234 marked with respect to @xmath19 .",
    "observe that @xmath70 can not be perfect , since otherwise @xmath87 and @xmath232 are twins in @xmath61 , contradicting node @xmath58 being a prime node ( a prime graph can not have a pair of twins ) .",
    "so assume that @xmath70 is empty .",
    "then @xmath87 can not be empty since otherwise we would have @xmath272 ( as @xmath273 ) .",
    "if @xmath87 is perfect , then @xmath87 has degree @xmath274 in @xmath61 ( since @xmath275 ) .",
    "thus @xmath87 is a pendant vertex of @xmath61 : contradiction , a prime graph can not have a pendant vertex .",
    "it follows by corollary  [ cor : hereditary]-2 that every tree - edge of @xmath234 is pm or em .",
    "now by remark  [ rk : inherited - states ] , the state of the inherited marker vertices are preserved under node - joins and node - splits .",
    "thus every inherited tree - edge of @xmath267 is pm or em",
    ".    we now deal with non - inherited tree - edges .",
    "let @xmath87 be the extremity of such a tree - edge @xmath66 in @xmath267 .",
    "denote by @xmath40 the split of @xmath11 corresponding to @xmath66 with @xmath276 . as noticed before",
    ", @xmath66 also corresponds to a split @xmath271 of @xmath265 ( we see that @xmath277 and @xmath278 ) .",
    "we prove that if @xmath87 is not mixed , then @xmath61 contains a split , a contradiction with @xmath58 being a prime node .",
    "so assume first that @xmath87 is empty . then by definition @xmath279 .",
    "it follows that the bipartition @xmath280 is a split of @xmath34 and thus @xmath281 is a split of @xmath61 .",
    "assume now that @xmath87 is perfect , then @xmath282 .",
    "it follows that @xmath280 is a split of @xmath34 ( here @xmath23 belongs to the frontier of @xmath283 ) .",
    "thereby @xmath281 is again a split of @xmath61 . thus @xmath87 is mixed , as required .",
    "[ lem : x_to_prime_cleaning ] consider the prime - splitting construction .",
    "assume that @xmath23 is adjacent to a prime node @xmath58 in @xmath220 .",
    "let @xmath284 be a degenerate node incident to a non - inherited tree - edge in @xmath267 .    1 .   if @xmath284 is a star , the centre of which is perfect , then @xmath284 has no empty marker vertex and at most two perfect marker vertices .",
    "otherwise @xmath284 has at most one empty marker vertex and at most one perfect marker vertex .",
    "first observe that the result is trivial if @xmath265 is prime .",
    "note that every empty or perfect marker vertex @xmath87 is inherited .",
    "otherwise @xmath87 would be the extremity of a tree - edge @xmath66 corresponding to a split @xmath271 of @xmath265 and being empty or perfect would imply that @xmath285 is a split of @xmath61 , contradicting @xmath58 being prime .    1 .   _",
    "@xmath284 is a star node , the centre @xmath199 of which is perfect : _ suppose that @xmath284 has an empty marker vertex @xmath70 ( distinct from @xmath199 ) .",
    "as @xmath70 is inherited from @xmath233 and not accessible from every marker vertex inherited from @xmath233 , @xmath70 is a pendant vertex in @xmath61 : contradicting @xmath58 being a prime node .",
    "so no marker vertex of @xmath284 is empty .",
    "suppose now that @xmath284 has two perfect marker vertices @xmath87 and @xmath286 distinct from @xmath199 .",
    "again @xmath87 and @xmath286 are inherited from @xmath233 . moreover ,",
    "every inherited vertex from @xmath233 accessible to @xmath87 is accessible to @xmath286 ( and vice versa ) .",
    "it follows that @xmath87 and @xmath286 form a pair of twins in @xmath61 : contradicting @xmath58 being a prime node .",
    "so @xmath284 contains at most two perfect marker vertices ( including @xmath199 ) .",
    "_ otherwise : _ suppose that @xmath284 is a clique node containing two perfect ( or two empty ) marker vertices @xmath87 and @xmath286 .",
    "again @xmath87 and @xmath286 are inherited from @xmath233 and have the same accessibility set among the inherited marker vertices of @xmath233 . thereby @xmath87 and @xmath286",
    "are twins in @xmath61 : contradicting @xmath58 being a prime node .",
    "+ assume that @xmath284 is a star node , the centre @xmath199 of which is not perfect . if @xmath199 is mixed , then the same argument as for the clique node proves the property .",
    "so assume that @xmath199 is empty .",
    "then the same argument as in case 1 applies .",
    "if @xmath284 contains an empty marker vertex @xmath70 distinct from @xmath199 , then @xmath70 is pendant in @xmath61 .",
    "if @xmath284 contains two perfect marker vertices @xmath87 and @xmath286 ( distinct from @xmath199 by hypothesis ) , then @xmath87 and @xmath286 are twins in @xmath61 .",
    "both cases lead to a contradiction .",
    "the following lemma summarizes what we have found so far and completes the picture .",
    "recall that @xmath287 is perfect and not the centre of a star@xmath288 and that @xmath289 is empty , or @xmath70 is perfect and the centre of a star@xmath288 .",
    "[ lem : x_to_prime ] consider the prime - splitting construction .",
    "assume that @xmath23 is adjacent to a prime node @xmath58 in @xmath220 such that @xmath265 is not prime .",
    "then :    1 .   @xmath248 ; 2 .",
    "every tree - edge of @xmath110 both extremities of which are not inherited from @xmath234 is @xmath241 and all other tree - edges are @xmath239 or @xmath240 ; 3 .   a degenerate node @xmath65 of @xmath56 incident to a non - inherited tree - edge results from at most two node - joins during step 3 of the construction and",
    "these node - joins respectively generate the split @xmath290 and/or @xmath291 of @xmath105 .",
    "the first assertion is given by observation  [ obs : st(g ) ] and the second follows from lemma  [ lem : x_to_prime_states ] and remark  [ rk : inherited - states ] .",
    "so it remains to prove the third property .",
    "let @xmath65 be a degenerate node of @xmath56 incident to a non - inherited tree - edge ( i.e. an @xmath241 tree - edge ) .",
    "observe that if @xmath65 results from the node - join of nodes @xmath284 and @xmath292 during the third step , then the tree - edge @xmath293 is inherited ( i.e. @xmath240 or @xmath239 ) and exactly one of the two nodes , say @xmath284 is incident to an @xmath241 tree - edge .",
    "let @xmath87 the extremity of @xmath66 in @xmath284 and @xmath70 be the ( mixed ) extremity of @xmath66 in @xmath292 .",
    "we need to examine all the possibilities for @xmath87 and @xmath284 .",
    "we provide all details for the first case ; the others use similar arguments .    if @xmath284 is a star node and @xmath87 its perfect centre , then @xmath70 is a degree-1 marker vertex of @xmath292 .",
    "the resulting star node @xmath65 contains the split @xmath291 where @xmath294 is the set of inherited marker vertices of @xmath292 ( @xmath294 contains the perfect centre and the empty degree-1 marker vertices of @xmath292 ) .",
    "this follows from lemma  [ lem : x_to_prime_cleaning]-1 which shows that @xmath70 is the only empty marker vertex and from remark  [ rk : inherited - states ] that claims that the states of inherited marker vertices are unchanged under node - join .",
    "the other cases follow from lemma  [ lem : x_to_prime_cleaning]-2 .",
    "if @xmath87 is an empty marker vertex of @xmath284 ( in that case , the node @xmath284 can be a star or a clique as well ) , then node @xmath65 contains the split @xmath291 with @xmath294 is the set of inherited marker vertices of @xmath292 .",
    "now if @xmath87 is a perfect marker vertex but not the centre of a star , then the resulting node contains the split @xmath290 where @xmath295 is composed of the marker vertices inherited from @xmath292 .",
    "finally , by lemma [ lem : x_to_prime_cleaning ] a degenerate node incident to an @xmath241 tree - edge contains at most two non - mixed marker vertices , and thus at most two node - joins are required to generate node @xmath65 .",
    "we mention that forthcoming figure [ fig : case4cleaning ] illustrates the two inverse node - split operations on @xmath65 .",
    "having shown how @xmath110 can be derived from @xmath220 , we now use these results to characterize how @xmath220 can be derived from @xmath110 .",
    "the various cases of the following theorem drive our split decomposition algorithm in section [ sec : algo ] . recall that by definition , a fully - mixed subtree is maximal .",
    "[ th : cases ] let @xmath116 be marked with respect to a subset @xmath19 of leaves",
    ". then exactly one of the following conditions holds :    1 .",
    "@xmath110 contains a clique node , whose marker vertices are all perfect , and this node is unique ; 2 .",
    "@xmath110 contains a star node , whose marker vertices are all empty except the centre , which is perfect , and this node is unique ; 3 .",
    "@xmath110 contains a unique hybrid node , and this node is prime ; 4 .",
    "@xmath110 contains a unique hybrid node , and this node is degenerate ; 5 .",
    "@xmath110 contains a @xmath237 tree - edge , and this edge is unique ; 6 .",
    "@xmath110 contains a @xmath238 tree - edge , and this edge is unique ; 7 .",
    "@xmath110 contains a unique fully - mixed subtree .",
    "moreover , in every case , the unique node / edge / subtree is obtained from @xmath36 by deleting , for every tree - edge @xmath66 with a perfect or empty extremity @xmath70 whose opposite @xmath94 is mixed , the tree - edge @xmath66 and the node or leaf corresponding to @xmath94 . in case 1 and case 2 , the node , together with its adjacent edges , is obtained in this way .    by lemmas [ lem : x_to_clique ] , [ lem : x_to_star ] , [ lem : x_to_prime_hybrid ] or [ lem : x_to_prime ] , applied to @xmath34 with @xmath296 , we directly know that ( at least ) one condition holds",
    ". a more careful look at these lemmas also proves that exactly one condition holds , implying directly with corollary [ cor : hereditary]-2 the given construction by deletion of @xmath239 and @xmath240 edges .",
    "first , notice that the following conditions are mutually exclusive : there exists a @xmath237 edge ; there exists a @xmath238 edge ; there exists an @xmath241 edge .",
    "indeed , every time one of these conditions holds , all the tree - edges of another type are known to be @xmath239 or @xmath240 ( lemmas [ lem : x_to_clique ] , [ lem : x_to_star ] , and [ lem : x_to_prime ] ) .",
    "these three cases are mutually exclusive from the existence of a hybrid node ( lemmas [ lem : x_to_clique ] , [ lem : x_to_star ] , and [ lem : x_to_prime_hybrid ] ) .",
    "together , these four cases  existence of a pp edge , pe edge , mm edge , and hybrid node  determine the cases in the theorem : if there is exactly one ( respectively at least two ) @xmath237 edge(s ) , then case 5 ( respectively case 1 ) holds ; if there is exactly one ( respectively at least two ) @xmath238 edge(s ) , then case 6 ( respectively case 2 ) holds ; if there is a hybrid node , then it is either prime ( case 3 ) or degenerate ( case 4 ) but not both ; if there is an @xmath241 edge , then case 7 holds .",
    "[ cases 1 , 2 and 3 of theorem  [ th : cases ] ] [ prop : unique - node - cases123 ] let @xmath116 be marked with respect to a subset @xmath22 of leaves . if @xmath110 contains :    * [ case 1 ] a unique clique node @xmath58 the marker vertices of which are all perfect , or * [ case 2 ] a unique star node @xmath58 the marker vertices of which are all empty except its centre which is perfect , or * [ case 3 ] a unique hybrid node @xmath58 which is prime ,    then @xmath220 is obtained by adding to node @xmath58 a marker vertex @xmath70 adjacent in @xmath61 to @xmath297 and making the leaf @xmath23 the opposite of @xmath70 .",
    "trivial by the definition of the split - tree ; the resulting glt is reduced and its accessibility graph is @xmath34 . notice that each of these three cases is the converse construction of the one provided in lemma [ lem : x_to_clique]-2 , or lemma [ lem : x_to_star]-2 , or lemma [ lem : x_to_prime_hybrid ] , respectively .",
    "[ prop : hybrid - degen - case4 ] let @xmath116 be marked with respect to a subset @xmath22 of leaves . if @xmath110 contains a unique hybrid node @xmath58 which is degenerate , then @xmath220 is obtained in two steps :    1 .",
    "performing the node - split corresponding to @xmath298 thus creating a tree - edge @xmath66 both of whose extremities are perfect or empty ( see figure  [ fig : case3example ] ) ; 2 .   subdividing @xmath66 with a new ternary node adjacent to @xmath23 and @xmath66 s extremities , such that the node is a clique if both extremities of @xmath66 are perfect , and such that the node is a star whose centre is the opposite of @xmath66 s empty extremity otherwise ( see figure  [ fig : cases12example ] ) .",
    "first , observe that @xmath298 is a split since @xmath299 and @xmath300 , otherwise the degenerate node @xmath58 would either be a clique adjacent to a @xmath237 edge or a star adjacent to a @xmath238 edge , contradicting @xmath58 being hybrid .",
    "then the construction follows easily from the definition of the split - tree : the resulting glt is reduced and its accessibility graph is @xmath34 .",
    "notice that this construction is the converse of the one provided in lemma  [ lem : x_to_clique]-1(b ) if the label is a clique , or lemma [ lem : x_to_star]-1(b ) if the label is a star .    ,",
    "first step of proposition [ prop : hybrid - degen - case4 ] ) .",
    "the dashed rectangle shows where the local transformation takes place , as described by the second step of proposition [ prop : hybrid - degen - case4 ] ( figure [ fig : cases12example ] ) . ]     in case 4 of theorem  [ th : cases ] , second step of proposition [ prop : hybrid - degen - case4 ] and when there is a unique edge with no mixed extremity ( cases 5 or 6 of theorem  [ th : cases ] , proposition [ prop : unique - edge - case56 ] ) .",
    "the dashed rectangle shows where the local transformation is made . ]",
    "[ cases 5 and 6 of theorem  [ th : cases ] ] [ prop : unique - edge - case56 ] let @xmath116 be marked with respect to a subset @xmath22 of leaves . if @xmath110 contains :    * [ case 5 ] a unique tree - edge @xmath66 both of whose extremities are perfect , then @xmath220 is obtained by subdividing @xmath66 with a new clique node adjacent to @xmath23 and @xmath66 s extremities ( see figure [ fig : cases12example ] ) ; * [ case 6 ] a unique tree - edge @xmath66 one of whose extremities is perfect and the other empty , then @xmath220 is obtained by subdividing @xmath66 with a new star node adjacent to @xmath23 and @xmath66 s extremities , such that the centre of the star is opposite @xmath66 s empty extremity ( see figure [ fig : cases12example ] ) .",
    "direct by the definition of the split - tree ; the resulting glt is reduced and its accessibility graph is @xmath34 . notice that each of these two cases is the converse construction of the one provided in lemma [ lem : x_to_clique]-1(a ) , or lemma [ lem : x_to_star]-1(a ) , respectively .",
    "[ def : cleaning ] let @xmath56 be a glt marked with respect to a subset of leaves and having a fully - mixed subtree .",
    "_ cleaning _ the glt consists of performing , for every degenerate node @xmath58 of the fully - mixed subtree , the node - splits defined by @xmath301 and/or @xmath302 as long as they are splits of @xmath61 . the resulting glt is denoted @xmath303 .",
    "the above definition makes sense thanks to remark [ rem : node - split - commutative ] since @xmath304 ; the two node - splits corresponding to these splits can be done in any order with the same result .",
    "figure [ fig : case4cleaning ] illustrates the possible local transformations at each node @xmath58 .    ) . the left picture ( as shown with dashed label - edges ) applies equally to a clique or star node with a mixed centre .",
    "the right picture concerns a star node with a perfect centre .",
    "bold edges are fully - mixed . ]",
    "[ rk : cleaning ] with lemma [ lem : hereditary ] and the fact that @xmath58 contains at least one mixed marker vertex whose opposite is mixed , one can easily show that @xmath301 , respectively @xmath302 , is a split of @xmath58 if and only if @xmath305 , respectively @xmath306 .",
    "[ prop : fully - mixed - case-7 ] let @xmath116 be marked with respect to a subset @xmath22 of leaves . if @xmath110 contains a fully - mixed tree - edge @xmath66 , then @xmath220 is obtained by :    * contracting , by a series of node - joins , the fully - mixed subtree of @xmath307 into a single node  @xmath58 ; * adding to node @xmath58 a marker vertex @xmath308 adjacent in @xmath61 to @xmath297 and making @xmath23 , @xmath308 s opposite .",
    "the resulting node @xmath58 is prime .",
    "see figure [ fig : case4example ] for an illustration of the whole process .",
    "first , observe that the series of node - joins is well defined by remark [ rem : node - join - commutative ] .",
    "this construction is exactly the inverse of the prime - splitting construction referenced in lemma [ lem : x_to_prime ] .",
    "more precisely , the glt @xmath309 here is exactly the glt @xmath267 there .",
    "so the fully - mixed subtree of @xmath309 here is the fully - mixed subtree induced by @xmath269 there . and",
    "the series of node - joins applied to this subtree leads to the node labelled by @xmath233 , to which @xmath23 is added naturally",
    ".     applies ( proposition [ prop : fully - mixed - case-7 ] ) .",
    "the dashed rectangle contains the fully - mixed subtree of @xmath110 in the left picture , and the fully - mixed subtree of @xmath309 in the middle one . ]    throughout the rest of the paper , we will use the phrase _ contraction step _ , or simply _ contraction _ , to refer to the procedure involved in proposition [ prop : fully - mixed - case-7 ] which transforms the fully - mixed subtree of @xmath307 into a prime node that has the new vertex @xmath23 attached .    to end this section",
    ", we point out a number of observations that follow from the results in this section .",
    "first , the construction provided by propositions  [ prop : unique - node - cases123 ] , [ prop : hybrid - degen - case4 ] , and  [ prop : unique - edge - case56 ] applied to a distance hereditary graph ( i.e. when every node is degenerate ) , amounts to the one provided in @xcite .",
    "thus , the present construction is a generalization to arbitrary graphs .",
    "secondly , note that we chose to separate the cases in theorem [ th : cases ] for consistency with our next algorithm .",
    "but other shorter and equivalent presentations would have been possible ; for instance : case 1 and case 5 ( respectively case 2 and case 6 ) could be grouped and treated the same way as they are the only cases where there exists a @xmath237 ( respectively @xmath238 ) edge , with a clique - join or star - join after insertion if the edge was not unique ; case 4 comes to cases 5 and 6 by making a @xmath237 or @xmath238 edge appear after splitting the node ; case 1 could be considered as a trivial subcase of case 7 .    finally , the results of this subsection , together with lemmas [ lem : x_to_prime_states ] and [ lem : x_to_prime_cleaning ] yield the following theorem which plays an important role in our circle graph recognition algorithm @xcite .    [ circle ]",
    "a graph @xmath135 is a prime graph if and only if @xmath110 , marked with respect to @xmath22 , satisfies the following :    1 .",
    "every marker vertex not opposite a leaf is mixed , 2 .",
    "let @xmath284 be a degenerate node .",
    "if @xmath284 is a star node , the centre of which is perfect , then @xmath284 has no empty marker vertex and at most two perfect marker vertices ; otherwise , @xmath284 has at most one empty marker vertex and at most one perfect marker vertex .",
    "[ sec : algo ]    our combinatorial characterization , described by theorem  [ th : cases ] and the subsequent propositions  [ prop : unique - node - cases123 ] , [ prop : hybrid - degen - case4 ] ,  [ prop : unique - edge - case56 ] and  [ prop : fully - mixed - case-7 ] , immediately suggests an incremental split decomposition algorithm .",
    "our characterization makes no assumption about the order vertices are to be inserted . for the sake of complexity issues ,",
    "we choose to add vertices according to an lbfs ordering @xmath122 , which we assume to be built by a preprocess . from remark",
    "[ prefix ] , such an ordering is compatible with the assumption made in section [ sec : characterization ] : all iterations of the algorithm satisfy the condition that @xmath11 and @xmath135 are connected .",
    "roughly speaking , the lbfs ordering will play two crucial parts : first , it permits a costless twin test allowing us to avoid `` touching '' non - neighbours of the new vertex when identifying states ( subsection [ subsec : cases ] ) ; second , it means that successive updates of the split - tree have an efficient amortized cost ( section [ sec : runningtime ] ) .    as in the previous section ,",
    "we assume throughout that @xmath116 , and that leaves and marker vertices in @xmath110 are assigned states according to the set @xmath22 ; then we consider the changes required to form @xmath220 .",
    "algorithm  [ alg : vertexinsertion ] outlines how the split - tree is updated to insert the last vertex of an lbfs ordering .",
    "determine whether @xmath110 contains either a tree - edge neither of whose extremities is mixed , or a hybrid node , or a fully - mixed subtree    the first task consists of identifying which of the cases of theorem  [ th : cases ] holds , at line [ line : cases ] of algorithm  [ alg : vertexinsertion ] .",
    "the implementation of line  [ line : cases ] is by a procedure which also returns the states of the involved marker vertices ( see subection [ subsec : cases ] ) , and hence allows us to apply the constructions provided by the propositions . at line  [ line : pp - pe ] , testing the uniqueness of the tree - edge @xmath66 amounts to a check as to whether @xmath66 is incident to a clique or a star node .",
    "this is required to discriminate between cases 1 and 5 or cases 2 and 6 .",
    "more precisely , if @xmath66 has two perfect extremities and is adjacent to a clique @xmath58 , then all the marker vertices of @xmath58 are perfect by lemma [ lem : hereditary ] , and then proposition  [ prop : unique - node - cases123 ] is applied to this clique node . if @xmath66 has a perfect extremity @xmath70 and its opposite @xmath94 is empty , and if @xmath70 is the centre of a star or @xmath94 is a degree-1 vertex of a star , then by lemma [ lem : hereditary ] , this star has all of its marker vertices empty except the centre , which is perfect , and then proposition  [ prop : unique - node - cases123 ] is applied to this star node .",
    "these tests at line  [ line : pp - pe ] can be done in constant time in the data - structure we use , as well as the updates required in these simplest cases ( proposition  [ prop : unique - node - cases123 ] and proposition  [ prop : unique - edge - case56 ] ) . they will not be considered again in the implementation .",
    "now , this section fills out the framework by specifying procedures for the state assignment , node - split , node - join , cleaning , and contraction involved at lines [ line : cases ] , [ line : split ] , and [ line : contraction ] of algorithm [ alg : vertexinsertion ] .",
    "we first describe our data - structures which is partly based on _ union - find _  @xcite .",
    "we then provide a complexity analysis of the insertion algorithm parameterized by elementary union - find requests .",
    "an amortized complexity analysis is developed in the next section .      in order to achieve the announced time complexity",
    ", we implement a glt @xmath56 with the well - known union - find data - structure  @xcite , making @xmath36 a rooted tree .",
    "there are two reasons for this choice .",
    "first , identifying empty and perfect subtrees is easier if the tree @xmath36 is rooted .",
    "second , in the contraction step , we ll need to union the neighbourhoods of two nodes to perform a node - join .",
    "we first present how the tree @xmath36 will be encoded with a union - find data - structure .",
    "we then detail how each node and its labels are represented .",
    "a union - find data - structure maintains a collection of disjoint sets .",
    "each set maintains a distinguished member called its _ set - representative_. union - find supports three operations :    1 .   `",
    "initialize`@xmath310 : creates the singleton set @xmath311 ; 2 .   `",
    "find`@xmath310 : returns the set - representative of the set containing @xmath23 ; 3 .   ` union`@xmath312 : forms the union of @xmath313 and @xmath314 , and returns the new set - representative , chosen from amongst those of @xmath313 and @xmath314 .",
    "the initialization step takes @xmath315 time , and a combination of @xmath7 union and find operations takes time @xmath316 , where @xmath317 is the number of elements in the collection of disjoint sets and @xmath1 is the inverse ackermann function  @xcite .",
    "the complexity of the algorithms described in this section will be parameterized by ` initialize - cost ` , ` find - cost ` , ` union - cost ` the respective costs of the above requests .",
    "our algorithm will store a glt @xmath56 as a _ rooted glt _ where a leaf of @xmath36 will serve as _ the root _",
    "( it is the leaf corresponding to the first inserted vertex ) .",
    "each node or leaf of @xmath36 , except the root , has a _ parent pointer _ to its parent ( which is a node or the root leaf ) in @xmath36 with respect to the root .",
    "to each prime node is associated a _",
    "children - set _ containing the set of its children in @xmath36 with respect to the root ( nodes or leaves ) .",
    "the children - sets of prime nodes form the collection of disjoint sets maintained by the union - find data - structure .",
    "every children - set has a set representative , which is a child of the node in @xmath36 .",
    "a parent pointer may be active or not .",
    "the nodes or leaves with an _ active _ parent pointer are : the child of the root , the children of degenerate nodes ( clique or star ) , and the nodes or leaves that are the set representative of the children - set of a prime node .",
    "a non - active parent pointer is just one that will never be used again ; there is no need to update information for it .",
    "[ rem : traversal ] a traversal of a rooted glt @xmath56 can be implemented in time @xmath318 .",
    "union - find is required only to update the tree structure ( child - parent relationship ) efficiently .",
    "as the node - splits only apply to degenerate nodes ( lines  [ line : split ] , [ line : contraction ] ) , union - find is not required here .",
    "union operations are performed after the cleaning step , during the contraction step ( line  [ line : contraction ] ) .",
    "[ rem : data ] the data - structure described here concerns a split - tree , whose labels are either prime or degenerate , since after each step of the construction it is such a glt that will be obtained .",
    "still , we need to allow node - joins in the data - structure . in",
    "what follows , during the successive node - joins in the contraction step ( proposition [ prop : fully - mixed - case-7 ] ) , the glt has one non - degenerate node whose label graph will eventually become prime only after the final insertion step .",
    "the data - structure for such a glt remains the same by recording the type of this non - degenerate node as prime , and dealing with it the same way as a prime node .",
    "it is important to note that removing elements from sets is not supported in the union - find data - structure .",
    "it follows that when a node - join is performed and the children - set of a node @xmath98 is unioned with the children - set of its parent @xmath58 , the node object corresponding to @xmath98 still exists in the children - set of @xmath58 .",
    "as we will see later , the persistence of these _ fake _ nodes is not a problem .",
    "indeed , their total number will be suitably bounded , they will never be selected again as set representatives , and the data - structure we develop below guarantees that they will never be accessed again . in particular ,",
    "no active parent pointer points to a fake node .",
    "that is why the children - set of a prime node may strictly contain its set of children in @xmath36 .        to complete our data - structure",
    "we define a data - object for every node and leaf in the rooted glt .",
    "these data - objects will maintain several fields :    * we already mentioned that every node and leaf , except the root , has a parent pointer .",
    "each node @xmath58 has a distinguished marker vertex , called the _ root marker vertex _ , which is the extremity of the tree - edge between @xmath58 and its parent .",
    "every node maintains a pointer to its root marker vertex .",
    "as already implied , we need to store the _ type _ of every node ( prime , clique , or star ) , and we also store the _ number of its children_.    on the top of that , depending on its type , every node @xmath58 maintains the following fields :    * if @xmath58 is prime : an _ adjacency - list representation _ of @xmath61 ; a pointer to the _ last marker vertex _ in @xmath188 $ ] ; a pointer to its _ universal marker vertex _",
    "( if it exists ) ; * if @xmath58 is degenerate : a _ list of its marker vertices _ @xmath63 ; and a pointer to its _ centre _ if it is a star ;    to each leaf and marker vertex , we associate :    * a pointer , called the _ opposite pointer _ , to its opposite marker vertex ; a field for its _ perfect - state _",
    "( at each new vertex insertion , perfect states , but no other state , will be computed and recorded , and the content of these fields from previous vertex insertions is not reused ) ; and , for every root marker vertex , a pointer , called the _ node pointer _ , toward the node to which it belongs .",
    "figure  [ fig : union - find ] illustrates this rooted glt data - structure . for instance , notice how a prime node accesses its children - set using this data - structure : pick a non - root marker vertex of the node , then its opposite marker vertex , then the node to which this marker vertex belongs , then the ` find ` on this node gives the set - representative of the corresponding children - set .",
    "prior to any update , a preprocessing of the split - tree is required to identify which of the cases of theorem  [ th : cases ] holds .",
    "this preprocessing is based on state assignment and tree traversals .",
    "the lbfs ordering will play an important role here .",
    "the procedure we use for the empty subtrees detection ( algorithm  [ alg : emptypruning ] ) differs from that for perfect subtrees ( algorithm  [ alg : perfectpruning ] ) .",
    "if a marker vertex or leaf @xmath70 is empty , then , by definition , @xmath90 contains no leaf in @xmath22 , and thus it will be unchanged under @xmath23 s insertion . for the sake of complexity issues , we will want to avoid `` touching '' @xmath70 and any part of @xmath90 .",
    "we are fortunate that identifying such empty subtrees can be simulated indirectly :    [ emptypruning ] consider @xmath116 , and let @xmath319 be the smallest connected subtree of @xmath36 spanning the leaves @xmath22 .",
    "then @xmath70 is an empty leaf or an empty marker vertex if and only if @xmath90 and @xmath319 are node disjoint .",
    "it s important to recall that if @xmath193 , then the node @xmath58 is not part of @xmath90 . if @xmath70 is empty , then @xmath320 , meaning @xmath90 and @xmath319 must be disjoint .",
    "if @xmath90 and @xmath319 are disjoint , then @xmath320 , meaning @xmath70 is empty .",
    "mark each leaf of @xmath22 as _ active _ ( other nodes and leaves are considered inactive )    let @xmath229 be the subtree of @xmath36 induced by the visited leaves and nodes    we can compute @xmath319 using the procedure specified in  @xcite , which is repeated here as algorithm  [ alg : emptypruning ] .",
    "it was proved in  @xcite that a call to algorithm  [ alg : emptypruning ] runs in time @xmath321 , assuming each node maintains a pointer to its parent .",
    "therefore , given the data - structure proposed above , a ` find ( ) ` request is needed to move from a node to its parent , when prime .",
    "so the following holds :    [ emptypruningtime ] given a glt @xmath56 , algorithm  [ alg : emptypruning ] returns a subtree of @xmath36 that is node disjoint from every empty subtree , and runs in time @xmath322__`find - cost`__@xmath323 .",
    "as @xmath36 is rooted , the subtree @xmath324 has a root which is a leaf or a node of @xmath36 . for every node @xmath58 of @xmath229 , the marker vertices of @xmath58 which are the extremity of a tree - edge in @xmath229 form the set @xmath325 ( recall definition  [ def : states ] ) .",
    "the next task is to identify the perfect subtrees and derive the case identification used at line [ line : cases ] of algorithm [ alg : vertexinsertion ] .",
    "our procedure , described in detail as algorithm  [ alg : perfectpruning ] , outputs either a tree - edge or a hybrid node , or the fully - mixed subtree of @xmath110 .",
    "( recall that a fully - mixed subtree is maximal , by definition . )",
    "it works in three main steps :    1 .",
    "first it traverses the subtree @xmath319 in a bottom - up manner to identify the pendant perfect subtrees : for each non - leaf node @xmath58 , we test if the marker @xmath70 opposite @xmath58 s root marker is perfect and if so remove @xmath58 from @xmath229 and move to @xmath58 s parent .",
    ", if the root of the remaining subtree @xmath229 has a unique child @xmath65 in @xmath229 , we check whether @xmath65 s root marker vertex @xmath94 is perfect and if so remove the root from @xmath229 and move to @xmath65 .",
    "this test is repeated until the current root of @xmath229 neighbours at least two nodes in @xmath229 or is the unique remaining node of @xmath229 .",
    "3 .   in the former case ,",
    "we are done and the resulting tree @xmath229 is fully - mixed . in the latter case , we still need to test whether the remaining node is hybrid or contains a marker vertex opposite a perfect leaf , in which case the output is this edge . as we will see , using the lbfs ordering allows us to test only two marker vertices .",
    "the next remark explains how one can test whether a given marker vertex is perfect and will be used in the bottom - up and top - down traversal of @xmath319 .",
    "[ twintest ] let @xmath99 be a marker vertex in @xmath110 , and let @xmath94 be @xmath70 s opposite",
    ". then @xmath94 is perfect if and only if :    1 .",
    "@xmath326 , or @xmath327 $ ] ; and 2 .",
    "@xmath328 or @xmath329 .",
    "remark  [ twintest ] must not be applied , at the third step of our procedure , to every marker vertex of the unique remaining node @xmath58 .",
    "indeed , consider @xmath330 , and let @xmath94 and @xmath331 be their opposites , respectively . to test",
    "if @xmath94 and @xmath331 are perfect using remark  [ twintest ] requires us to test if @xmath332 and @xmath333 .",
    "but if @xmath334 , then this involves `` touching '' marker vertices of @xmath58 multiple times . in general , we can not bound the number of times marker vertices in @xmath58 will have to be `` touched '' .",
    "the solution for a degenerate node follows from the next lemma . in the case of a prime node",
    ", we will use the lbfs lemmas  [ lbfstwin ] and  [ inducedlbfs ] of section  [ sec : lbfs ] .",
    "[ degeneratetwintest ] let @xmath58 be a degenerate node of @xmath110 , the marker vertices of which are all either perfect or empty ( i.e. @xmath335 ) .",
    "there exists a marker vertex @xmath99 whose opposite @xmath94 is perfect if and only if one of the following conditions holds :    1 .",
    "@xmath336 ( in this case , if @xmath58 is a clique then any @xmath99 is suitable , and if @xmath58 is a star then @xmath70 is its centre ) ; 2 .",
    "@xmath337 and , when @xmath58 is a star , @xmath70 is the centre of @xmath58 ; 3 .",
    "@xmath338 and @xmath58 is a star with centre @xmath199 ( in this case any @xmath339 is suitable ) ; 4 .",
    "@xmath340 and @xmath58 is a star with centre @xmath199 .",
    "choose some @xmath99 and let @xmath94 be its opposite marker vertex .",
    "assume that @xmath94 is perfect .",
    "then if @xmath58 is a clique or a star with centre @xmath70 , all marker vertices in @xmath341 are accessible descendants of @xmath94 and are therefore perfect , by lemma  [ lem : hereditary]-1",
    ". therefore either items 1 or 2 of the lemma hold .",
    "so assume that @xmath58 is a star with centre @xmath342 .",
    "then @xmath199 is an accessible descendant of @xmath94 , and all marker vertices in @xmath343 are inaccessible descendants of @xmath94 .",
    "thus , @xmath199 is perfect and the marker vertices in @xmath343 are empty , by lemma  [ lem : hereditary]-1 .",
    "it follows that either items 3 or 4 of the lemma hold .",
    "now assume that one of items 1 - 4 of the lemma holds .",
    "if items  1 or  2 hold , then all marker vertices in @xmath341 are accessible descendants of @xmath94 , and all are perfect .",
    "so by lemma  [ lem : hereditary]-1 , @xmath94 is perfect as well . and if items  3 or  4 hold , then only @xmath199 is perfect , and only @xmath199 is an accessible descendent of @xmath94 .",
    "it follows that @xmath94 is perfect , once again by lemma  [ lem : hereditary]-1 .",
    "applying lemma  [ degeneratetwintest ] at node @xmath58 is straightforward as soon as @xmath297 has been computed .",
    "notice that in cases 2 and 3 , the marker vertex @xmath70 is empty , but it can be determined without considering other empty marker vertices . hence at most one empty marker vertex is involved in this step of the procedure .",
    "let us now turn to prime nodes .",
    "first observe the following remark , which is a straightforward application of the definitions :    [ twins ] let @xmath99 be a marker vertex in @xmath110 , and let @xmath94 be its opposite .",
    "let @xmath245 be a marker vertex added to @xmath58 , made adjacent precisely to @xmath297",
    ". then @xmath94 is perfect if and only if @xmath70 and @xmath245 are twins .",
    "the next lemma merely translates lemma  [ lbfstwin ] to the split - tree ; its corollary is the important result for our purposes :    [ lbfstwinnode ] let @xmath122 be an lbfs of the connected graph @xmath135 in which @xmath23 appears last , and let @xmath58 be a prime node in @xmath110 .",
    "let @xmath94 be the opposite of some @xmath99 . if @xmath94 is perfect , then @xmath70 is universal in @xmath61 or @xmath70 appears last in @xmath188 $ ] .",
    "let @xmath98 be the same as @xmath58 but with a new marker vertex @xmath245 adjacent precisely to @xmath297 .",
    "consider the glt @xmath196 that results from replacing @xmath58 with @xmath98 , and adding a new leaf @xmath75 opposite @xmath245 .",
    "let @xmath344 be the same as @xmath122 but with @xmath23 replaced by @xmath75 . since @xmath245 is only adjacent to @xmath297 , we have @xmath345 .",
    "therefore @xmath344 is an lbfs of @xmath346 in which @xmath75 appears last , and @xmath347 $ ] is an lbfs of @xmath102 in which @xmath245 appears last , by lemma  [ inducedlbfs ] applied to the split - tree .",
    "assume that @xmath94 is perfect .",
    "then @xmath70 and @xmath245 are twins , by remark  [ twins ] .",
    "therefore @xmath98 is not prime . but recall that @xmath58 was prime .",
    "so by lemma  [ lbfstwin ] , either @xmath70 is universal in @xmath61 or it is the penultimate vertex in @xmath347 $ ] . if it is the penultimate vertex in @xmath347 $ ] , then it must be the last vertex in @xmath188 $ ] .",
    "[ primetwintest ] let @xmath122 be an lbfs of @xmath34 in which @xmath23 appears last .",
    "let @xmath75 be a leaf adjacent to a prime node @xmath58 in @xmath110 , and let @xmath99 be @xmath75 s opposite",
    ". then @xmath75 is perfect if and only if @xmath70 is universal in @xmath61 or @xmath70 appears last in @xmath188 $ ] .    a direct consequence of remark  [ twins ] and lemma  [ lbfstwinnode ] .    therefore to perform the third step of the case identification procedure , at most two marker vertices of the remaining prime node @xmath58 can have opposites that are perfect",
    "thus , remark  [ twintest ] needs to be applied at most twice .",
    "remember that our data - structure keeps track of these two marker vertices .",
    "@xmath348 , the result of algorithm  [ alg : emptypruning ] with input @xmath36 and @xmath22 set the non - root marker vertices opposite leaves of @xmath22 to _ perfect _ ( these markers belong to nodes of @xmath229 )    let @xmath58 be the root of @xmath229    [ lem : pruningcorrectness ] given an lbfs ordering of a connected graph @xmath34 and the split - tree @xmath110 , algorithm  [ alg : perfectpruning ] returns :    * a tree - edge @xmath66 , one of whose extremities is perfect and the other is either empty or perfect , if case 1 , 2 , 5 or 6 of theorem  [ th : cases ] applies ; * a hybrid node @xmath58 , if case 3 or 4 of theorem  [ th : cases ] applies ; * the full - mixed subtree @xmath229 of @xmath36 , if case 7 of theorem  [ th : cases ] applies ;    it can be implemented to run in time @xmath322__`find - cost`__@xmath323 .    by lemma  [ emptypruningtime ] , we know that @xmath319 , and thus @xmath229 , is node disjoint from every empty subtree of @xmath110 . clearly , before the while loop at line  [ pruned : top - down ] , the current subtree @xmath229 is disjoint from every pendant perfect subtree of @xmath110 .",
    "thus , if the root of the tree belongs to a perfect subtree @xmath89 , then the nodes of @xmath349 can only form a path of @xmath229 : otherwise @xmath89 should contain a node @xmath58 with two non - root marker vertices @xmath70 and @xmath94 which are neither perfect nor empty , as @xmath90 and @xmath246 have not been removed so far , contradicting the fact that @xmath89 is perfect .    concerning the correctness of the third step ( case identification ) ,",
    "first observe that if , at line  [ prune : identification ] , @xmath229 contains more than one node , then every tree - edge in @xmath229 is fully - mixed ( otherwise one of its extremities would have been removed during the tree traversals ) .",
    "thus case 7 of theorem  [ th : cases ] holds .",
    "so assume that @xmath229 consists of one node .",
    "it follows from lemma  [ degeneratetwintest ] , remark [ twins ] and corollary  [ primetwintest ] , that a single tree - edge is returned by the algorithm if there exists a tree - edge with a perfect extremity and the other extremity either perfect or empty .",
    "notice that we do not test the uniqueness of such a tree - edge .",
    "if none of the previous cases applies , then , by theorem  [ th : cases ] , @xmath110 contains a hybrid node which is correctly identified by the algorithm .",
    "this corresponds to cases 3 and 4 of theorem  [ th : cases ] .    by remark  [ rem : traversal ] , the cost of performing the tree traversals is @xmath350 . during the algorithm , either remark  [ twintest ] or lemma  [ degeneratetwintest ]",
    "is applied a constant number of times at each node .",
    "the cost to apply each remark / lemma in the context of the data - structure presented above is clearly @xmath351 , where @xmath225 ( recall definition  [ def : states ] ) .",
    "but every @xmath352 has its corresponding edge in @xmath319 , by lemma  [ emptypruning ] and the definition of @xmath325 .",
    "so the total cost of applying remark  [ twintest ] and lemma  [ degeneratetwintest ] is @xmath321 . of course ,",
    "once @xmath70 is found to be perfect , then @xmath58 can be removed from @xmath229 in constant time .    before describing how the split - tree is updated in each of the different cases , let us point out how the states ( perfect , empty , mixed ) of marker vertices are computed ( or not ) during algorithm  [ alg : perfectpruning ] :    [ rem : state - algo ] algorithm  [ alg : perfectpruning ] assigns a state to a marker vertex @xmath70 and updates the data - structure accordingly only if @xmath70 is perfect . from these recorded _ perfect - state _ fields , the states of all marker vertices involved in the output of algorithm [ alg : perfectpruning ] can be deduced .",
    "it is not a problem to avoid explicitly computing the state of all the marker vertices .",
    "indeed , computing them would affect our complexity .",
    "moreover , notice that in every case ( see propositions  [ prop : unique - node - cases123 ] , [ prop : hybrid - degen - case4 ] ,  [ prop : unique - edge - case56 ] and  [ prop : fully - mixed - case-7 ] ) the knowledge of the perfect marker vertices is enough to determine the state of every other marker vertex which will be affected in the successive steps of the updates .",
    "for example , in a hybrid node , the non - perfect marker vertices are by definition empty .",
    "similarly if @xmath110 contains a fully - mixed subtree @xmath229 , then a marker vertex of a node of @xmath229 is empty if and only if it is not perfect and not incident to a tree - edge of @xmath229 .",
    "if follows that , once algorithm  [ alg : perfectpruning ] has been performed , we can conclude that the state of every useful marker vertex has been determined .",
    "the node - split operation ( see definition  [ def : node - split ] ) is required when cases 4 and 7 of theorem  [ th : cases ] hold .",
    "case 4 , existence of a degenerate hybrid node @xmath58 ( proposition [ prop : hybrid - degen - case4 ] ) , only requires the node - split of @xmath58 according to @xmath353 .",
    "case 7 potentially implies a large number of node - splits since , before the contraction step , the cleaning of @xmath110 is necessary ( proposition [ prop : fully - mixed - case-7 ] ) . notice that degenerate nodes are the only nodes that are ever node - split .    to be as efficient as possible , to perform a node - split we wo nt create two new nodes as seemingly required by the definition . instead",
    ", we will reuse the node being split so that only one new node has to be created .",
    "this is presented in algorithm  [ alg : nsplit ] .",
    "replace the vertices in @xmath283 with a new marker vertex @xmath70 adjacent precisely to @xmath46 call the result @xmath98    create a new node @xmath58 consisting of the vertices in @xmath283 , plus one new marker vertex @xmath94 adjacent precisely to @xmath45    add an internal tree - edge between @xmath58 and @xmath98 having extremities @xmath70 and @xmath94    [ nsplittime ] algorithm  [ alg : nsplit ] performs a node - split @xmath40 for a degenerate node in time @xmath354 .",
    "the correctness follows from the definitions .",
    "the time complexity is obvious as well from a simple examination of our data - structure .",
    "recall that every child of a degenerate node maintains a parent pointer ( unlike for prime nodes which use the union - find ) . depending on whether the root marker vertex of @xmath65 belongs to @xmath283 or @xmath146",
    ", @xmath98 becomes a child of @xmath58 or vice - versa .",
    "the root marker vertices ( and their respective node pointers ) of the resulting nodes are updated accordingly .",
    "as these two nodes are degenerate , they need to have a list of their marker vertices : @xmath98 inherits the list of @xmath65 in which @xmath283 has been removed plus the new marker vertex @xmath70 , while @xmath58 s list is created and contains @xmath355 .",
    "meanwhile , the marker vertices of @xmath283 update their node pointer .",
    "this work requires @xmath354 time .",
    "other information such as type of the node , number of children , pointer to the centre ( if it is a star ) or opposite pointer , perfect - states , is easily updated in constant time .    cleaning was introduced in definition  [ def : cleaning ] along with the notation @xmath307 .",
    "notice that it amounts to repeated application of the node - split operation .",
    "the cleaning step will proceed according to algorithm  [ alg : cleaning ] . to determine if a degenerate node needs to be node - split according to @xmath302 , algorithm  [ alg : cleaning ] takes advantage of the equivalence : @xmath356 , where @xmath357 and @xmath358 are deduced directly from perfect - states fields and the fully - mixed subtree structure . as before ,",
    "the reason is one of efficiency ; we want to avoid `` touching '' empty subtrees .",
    "to this end , it is important that the node - split is performed only `` touching '' perfect and mixed marker vertices of @xmath359 .",
    "this is the reason for defining algorithm  [ alg : nsplit ] as we did .",
    "the rest of algorithm  [ alg : cleaning ] is a direct implementation of the definition .",
    "assume all nodes are marked _ unvisited _",
    "recursively perform node - joins to contract @xmath229 into a single node @xmath58 , using algorithm  [ alg : njoin ]    add a marker vertex @xmath70 to @xmath58 , adjacent precisely to @xmath297 , then make @xmath23 opposite  @xmath70 let @xmath361 be the resulting node and mark @xmath70 as the last marker vertex of @xmath362 $ ] @xmath23 s parent is @xmath361    [ contractiontime ] if @xmath110 contains a fully - mixed subtree , given @xmath363 and its fully - mixed subtree @xmath229 , algorithm  [ alg : contraction ] computes @xmath220 .",
    "it can be implemented to run in time : @xmath364 where @xmath7 is the number of fully - mixed tree - edges of @xmath229 .    from remark  [ rem : node - join - commutative ] , the glt resulting from the node - joins between nodes incident to the tree - edges of @xmath229 is independent of the order in which they are applied .",
    "if @xmath58 is the node resulting from the contraction of @xmath229 ( together with the new vertex insertion ) , then observe that @xmath365 .",
    "if follows that the accessibility graph of the resulting glt is @xmath34 .",
    "now from proposition  [ prop : fully - mixed - case-7 ] , @xmath58 is prime thereby showing that algorithm  [ alg : contraction ] computes @xmath220 since its result is reduced .",
    "the nodes participating in each phase can be located by performing a single pass over the tree .",
    "this traversal can be performed in time @xmath350 .",
    "once the nodes participating in each phase have been located , the node - joins can proceed .",
    "the cost of each one is described by lemma  [ njointime ] .",
    "the outcome of these node - joins is a single node @xmath58 . at this point ,",
    "all of @xmath58 s children are organized into a children - set .",
    "the new vertex @xmath23 is made a neighbour of @xmath58 , which in our situation means it is made a child of @xmath58 .",
    "this requires @xmath23 to be added to the set that represents @xmath58 s children . to do",
    "so we need one ` initialization ( ) ` operation and one ` union ( ) ` operation .",
    "the opposite of @xmath23 is a new marker vertex @xmath70 added to @xmath61 and made adjacent precisely to @xmath297 .",
    "recall that our split - tree algorithm inserts vertices according to an lbfs ordering , say @xmath122 .",
    "notice that @xmath70 clearly becomes the last vertex in @xmath366 $ ] .",
    "so given the data - structure assumed earlier , the cost of adding @xmath70 is @xmath367 .",
    "but every marker vertex in @xmath325 has its corresponding edge in @xmath319 , by lemma  [ emptypruning ] and the definition of @xmath325 .",
    "therefore the total cost of adding @xmath70 is @xmath321 .    at this point of the paper ,",
    "the reader can completely compute the split decomposition of a graph with our algorithm .",
    "it is the number of node - joins involved in successive uses of lemma [ contractiontime ] for contraction that prevents us from concluding its running time .",
    "we have already seen one example where the number of node - joins required by contraction is linear in the size of the split - tree ( see figure  [ fig : badexample ] ) .",
    "but later we emphasized that this was worst - case behaviour .",
    "we promised that our lbfs ordering would make it possible to amortize the cost of contraction .",
    "we finally prove this in the next section .",
    "this section completes the proof for the running time of our algorithm , described completely in section [ sec : algorithm ] .",
    "our main goal is to amortize the cost of contraction ( lemma [ contractiontime ] ) , involving the number of updates and requests to the union - find data - structure , and the number of created label - edges and vertices involved in the adjacency lists of label graphs .",
    "so far , the number of ` find ( ) ` operations required by our algorithm has always been bounded by @xmath368 .",
    "this will directly imply a suitable bound ( by lemma [ lem : numsubtree ] in subsection [ sub : final ] ) .",
    "the ` initialization ( ) ` routine is always performed just prior to a ` union ( ) ` during a node - join operation and it involves a child of a degenerate node or the new vertex to be inserted ( algorithm [ alg : njoin ] line [ line : children - set ] ) .",
    "it follows that the number of ` initialization ( ) ` operations is bounded by the number of non - root marker vertices belonging to a degenerate node that appear at some step of the algorithm ( when @xmath23 is inserted or when a node - split is performed ) . bounding the number of such vertices is also required since they participate in the data - structure ( see subsection [ sub : degenerate - marker ] ) .",
    "the ` union ( ) ` operations are performed during a node - join ( algorithm [ alg : njoin ] line [ line : children - set ] ) once together with each ` initialization ( ) ` operation , and once to finalize the node - join .",
    "the total number for the first part is bounded the same way as ` initialization ( ) ` operations , and the total number for the second part is bounded by the total number of node - joins , which is bounded by the total number of created label - edges , since each node - join implies the creation of a label - edge ( lemma [ njointime ] ) .",
    "therefore , bounding the number of created label - edges is the key to the complexity analysis and is the difficult part of our complexity argument . to count and bound",
    "the number of label - edges created during the whole algorithm , we use a charging argument in which the role of lbfs is critical ( see subsection [ sub : charging ] ) .",
    "we prove that the number of non - root marker vertices that are created in some degenerate node during the process of building @xmath110 is linearly bounded by the number of vertices of the input graph @xmath11 .",
    "the idea is to show that at each vertex insertion , only a constant number of such marker vertices are generated by our incremental algorithm .",
    "[ lem : degenerate - marker ] let @xmath11 be a connected graph .",
    "the insertion of vertex @xmath23 in the process of building @xmath220 creates at most two new non - root marker vertices belonging to a degenerate node in the rooted glt data - structure .",
    "consider forming the split - tree @xmath220 , where @xmath23 is some new vertex not already in @xmath11 .",
    "we consider the changes required of @xmath110 to form @xmath220 , as described by theorem  [ th : cases ] and the subsequent propositions .",
    "notice that the set of marker vertices belonging to some degenerate node is modified in three different ways :    * _ the leaf @xmath23 is attached to a degenerate node .",
    "_ this occurs when cases 1 , 2 , 4 , 5 and 6 of theorem  [ th : cases ] apply .",
    "two subcases are to be considered .",
    "if the degenerate node @xmath58 neighbouring leaf @xmath23 has degree @xmath2 ( that is case 4 , 5 or 6 holds and @xmath58 is a new node ) , then exactly two new non - root marker vertices have been created .",
    "it also follows that the degree in @xmath61 of these two marker vertices is at most two .",
    "otherwise ( case 1 or 2 ) , the only new non - root marker vertex @xmath193 is the opposite of @xmath23 . * _ a node - split is performed on a degenerate node .",
    "_ this occurs when cases 4 or 7 ( during cleaning ) of theorem  [ th : cases ] applies .",
    "observe that every split creates exactly two new marker vertices , one of which is the root of its node . in case 4 ,",
    "only one node - split is performed , thereby creating one extra non - root marker vertex in a degenerate node .",
    "+ so let us consider the node - splits performed during the cleaning step when case 7 holds .",
    "each degenerate node @xmath58 of the fully - mixed subtree is involved in at most two node - splits ( see figure [ fig : case4cleaning ] ) . among the two nodes resulting from each node - split",
    ", one will eventually be node - joined to form a prime node and the other remains degenerate in @xmath220 .",
    "let us call @xmath65 such a created degenerate node .",
    "all marker vertices inherited by @xmath65 through the node - split are reused , and remain non - root marker vertices if they were non - root marker vertices in @xmath58 .",
    "hence the only case where a non - root marker vertex is created in @xmath65 is when @xmath65 inherits the root marker of @xmath58 and thus a non - root marker vertex is created as the extremity of the new tree - edge resulting from the split .",
    "of course , this case can happen at most once for any degenerate node @xmath58 affected by a node - split .",
    "moreover , this can only happen at the node at the root of the fully - mixed subtree .",
    "thus at most one non - root degenerate marker is created during the series of node - split required by @xmath23 s insertion . * _ a node - join is performed and involves a degenerate node . _ this only occurs during the contraction step while a prime node is being formed . in this case ,",
    "marker vertices of a degenerate node are lost .",
    "the invariant trivially holds .",
    "each ` initialization ( ) ` operation takes constant time .",
    "they are only employed prior to a node - join involving a degenerate node ( see lemma  [ njointime ] ) , and when the vertex @xmath23 to be inserted is made a neighbour of a newly formed prime node ( see lemma  [ contractiontime ] ) .",
    "of the latter , there can be at most @xmath369 .",
    "the ` initialization ( ) ` operations of the former are dealt with below .",
    "every such ` initialization ( ) ` operation corresponds to a child of a degenerate node , or equivalently to a non - root marker vertex of a degenerate node .",
    "thus by lemma  [ lem : degenerate - marker ] , building @xmath110 requires @xmath369 calls to ` initialization ( ) ` .",
    "we shall first recall that , in our data - structure , degenerate nodes do not store any label - edge .",
    "label - edges belong to prime nodes , which are only formed by contraction .",
    "so , the label - edges in the resulting prime node either existed previously or were created by a node - join during contraction ( lemma [ njointime ] ) .",
    "recall also that label - edges adjacent to marker vertices that disappear during a node - join are lost since these are not reused , but of course they count in the total number of created label - edges . to bound the number of created label - edges ,",
    "we develop a charging argument driven by a stamping scheme .",
    "the stamps will help us to spread and distribute the charge over the successive steps of our algorithm . the charging argument depends on our lbfs ordering . keep in mind",
    "that the split - tree construction algorithm does not involve the stamping scheme , nor the subsequent charging argument .",
    "these are only defined for the sake of counting created label - edges and of the amortized complexity analysis .",
    "let us sketch the construction .",
    "first , we need to show as a preliminary result that our lbfs ordering regulates how stars are formed during the construction of the split - tree : see subsubsection [ sub : lbfs_and_stars ] .",
    "second , every non - root marker vertex is associated with some _ stamps _ ( 0 , 1 or 2 depending on its type ) , which are vertices of the input graph : see subsubsection [ sub : stamping ] .",
    "independently , marker vertices are associated with _",
    "charge lists _ such that spreading units of charge in the lists during the incremental process serves to count created label - edges : see subsubsection [ sub : charging ] .",
    "lastly , the way stamps and charge lists are associated with marker vertices will allow us to evaluate the total number of units of charge in terms of parameters of the input graph ( number of edges and vertices ) , and hence to get the awaited complexity bound : see lemma [ chargebound ] in subsection [ sub : final ] .",
    "let us introduce extra notation and definitions related to an lbfs ordering @xmath122 ( see section  [ sec : lbfs ] ) .",
    "first we will abusively use @xmath370 instead of @xmath371 to denote the @xmath372-th vertex in @xmath122 .",
    "then @xmath10 stands for the subgraph induced by the subset @xmath373 of vertices and we denote by @xmath374 the set of vertices appearing before @xmath370 ( not including @xmath370 ) .",
    "let @xmath122 be an lbfs ordering of a connected graph @xmath11 .",
    "a subset of consecutive vertices @xmath375 ( with @xmath376 ) is a _ slice _ of @xmath122 if for every @xmath133 , @xmath377 .",
    "the set @xmath378 denotes the largest slice starting at vertex @xmath370 .",
    "in addition to the properties proved in subsection  [ sub : lbfs ] , lbfs controls the formation of star nodes . during the split - tree construction process , some new marker vertices appear ( e.g. the one opposite the new leaf , or when a node - split is performed ) , some disappear ( when a node - join is performed ) and some others are kept . more formally :    let @xmath122 be an lbfs ordering of a connected graph @xmath11 .",
    "building on the definition given in subsection [ subsec : split - tree ] , we say that @xmath379 _ inherits _ a marker vertex @xmath70 of a node in @xmath13 if @xmath70 is not the extremity of a fully - mixed tree - edge of @xmath13 marked by the neighbourhood of @xmath380 .",
    "+ by extension , @xmath381 , with @xmath382 , _ inherits _ the marker vertex @xmath70 from @xmath13 if @xmath383 inherits @xmath70 from @xmath13 and @xmath70 is not the extremity of a fully - mixed tree - edge of @xmath383 marked by the neighbourhood of @xmath384 .",
    "recall that in a split - tree the centre of a star is never the opposite of a degree-1 marker vertex ( since otherwise the split - tree would nt be reduced ) . for our charging argument",
    ", we need to extend this property over the life time of a marker vertex that was created as the centre of a star , assuming the vertex insertion follows an lbfs ordering .",
    "[ lem : star ] let @xmath122 be an lbfs ordering of a connected graph @xmath11 .",
    "assume that to insert vertex @xmath370 , a degree three node @xmath385 labelled by a star has been created .",
    "let @xmath386 be the centre of @xmath385 and @xmath387 be the degree-1 marker vertex of @xmath385 not opposite @xmath370 . if @xmath388 , then @xmath381 contains a star node @xmath389 which contains @xmath386 as centre and @xmath387 as one of its degree-1 marker vertices .",
    "moreover @xmath389 contains a degree-1 marker vertex @xmath390 such that @xmath391 .",
    "the result clearly holds if @xmath392 .",
    "consider the case @xmath393 .",
    "notice that @xmath380 is a twin of @xmath370 since @xmath394 .",
    "this implies that , if @xmath13 is marked by the neighbourhood of @xmath380 , then @xmath386 is perfect and @xmath387 is empty .",
    "in other words the tree - edges respectively incident to @xmath386 and @xmath387 are not fully - mixed .",
    "so by definition , @xmath386 and @xmath387 are inherited by @xmath379 . obviously , the opposite of @xmath370 is either perfect or empty in @xmath13 and is inherited by @xmath379 .",
    "it follows that @xmath379 contains the desired star node @xmath395 .",
    "assume that for @xmath396 , @xmath397 has a star node @xmath398 in which @xmath386 is the centre and @xmath387 is the degree-1 marker vertex identified at the creation of @xmath385 .",
    "notice that by the definition of a star , @xmath399 .",
    "it follows that for every @xmath7 such that @xmath396 , @xmath400 is a split of @xmath401 .",
    "moreover , observe that @xmath402 . consider the glt obtained by a node - split of @xmath398 , creating a tree - edge @xmath66 corresponding to the split @xmath400 .",
    "since @xmath403 is also a split of @xmath404 , the extremity @xmath70 of @xmath66 such that @xmath405 is perfect or empty in this glt marked with respect to the neighbourhood of @xmath406 .",
    "so , by our incremental split - tree construction , the marker vertices in @xmath90 , and in particular @xmath386 and @xmath387 , are inherited by @xmath407 .",
    "hence @xmath407 contains the desired star node @xmath408 .",
    "[ lem : phase1limit ] let @xmath122 be an lbfs ordering of a connected graph @xmath11 .",
    "let @xmath386 be the centre marker vertex of a star @xmath385 in @xmath13 .",
    "if @xmath386 is inherited by @xmath381 , with @xmath409 , then it is not opposite a degree-1 marker vertex of a star in @xmath381 .",
    "assume without loss of generality that @xmath386 has been generated by @xmath370 s insertion , that is @xmath385 is a degree three node @xmath385 labelled by a star .",
    "let @xmath387 be the degree-1 marker vertex of @xmath385 not opposite @xmath370 in @xmath13 .",
    "let @xmath7 be the smallest index such that @xmath386 is inherited by @xmath397 and is opposite a degree-1 marker vertex . clearly as @xmath13 is reduced , @xmath410 . by assumption , in @xmath411 ,",
    "@xmath386 s opposite has degree at least two . by propositions  [ prop : unique - node - cases123 ] , [ prop : hybrid - degen - case4 ] , [ prop : unique - edge - case56 ] and  [ prop : fully - mixed - case-7 ] ,",
    "the only way to make @xmath386 the opposite of a degree-1 marker vertex in @xmath397 is to subdivide the tree - edge @xmath66 incident to @xmath386 in @xmath411 by a star node adjacent to @xmath412 .",
    "that is , case 6 of theorem  [ th : cases ] holds and @xmath66 was the unique tree - edge with one perfect and one empty extremity ( the perfect extremity being @xmath386 ) .",
    "observe that the node @xmath58 containing @xmath386 in @xmath411 can not be a star node ( corollary [ cor : hereditary]-5 ) .",
    "we now contradict this fact . to that aim observe that as @xmath386 is perfect in @xmath411 and in @xmath13 , we have @xmath413 . as @xmath410 , for @xmath122 to be a lbfs ordering , we have @xmath414 ; in other words , @xmath415 . but now lemma  [ lem : star ] implies that @xmath58 is a star : contradiction .",
    "the last results rely on the crucial assumption that an lbfs ordering is followed .",
    "one way of interpreting them is to say that once a star is created , it is then expanded maximally .",
    "the important consequence is what the last result says about the phase 1 node - joins defined by algorithm  [ alg : contraction ] .",
    "recall that phase 1 node - joins involve a star whose root marker vertex is its centre , and one of its children .",
    "lemma  [ lem : phase1limit ] therefore restricts the number of phase 1 node - joins a node can undergo .",
    "we need this fact to bound the number of new label - edges created during contraction .",
    "the amortized complexity analysis relies on two stamping schemes .",
    "first , every non - root marker vertex @xmath70 of a degenerate node is stamped with a vertex of the input graph @xmath11 , called the _ degenerate stamp _ of @xmath70 . as a consequence of lemma  [ lem : degenerate - marker ] ,",
    "degenerate stamps can be assigned such that every vertex of @xmath11 is used at most three times . intuitively , the role of degenerate stamping is to amortize the cost of the creation of the label - edges of degenerate nodes prior to some node - join operation .",
    "in addition , another stamping scheme is developed to amortize the cost of the creation of the label - edges generated by the node - join operations during contraction .",
    "consider the following inductive procedure which , given a reduced glt , assigns a stamp @xmath416 to every non - root marker vertex @xmath70 that is not the centre of a star :    1 .   if @xmath70 is opposite the leaf @xmath28 , then @xmath417 .",
    "2 .   let @xmath418 be an internal tree - edge in the split - tree @xmath110 with extremities @xmath99 and @xmath419 , where @xmath58 is the parent of @xmath65 : 1 .",
    "if @xmath420 , then set @xmath421 for two ( arbitrary ) neighbours @xmath245 and @xmath422 of @xmath94 ; 2 .",
    "if @xmath423 , and therefore @xmath65 is a star with centre @xmath199 , then set @xmath424 , and then remove @xmath199 s stamp .",
    "we will refer to @xmath425 as @xmath70 s _ primary stamp _ and @xmath426 as @xmath70 s _ secondary stamp_. we are interested in primary stamps ; secondary stamps only exist to be `` passed up '' in step 2(a ) above .",
    "the procedure guarantees the following properties of these stamps :              let @xmath418 be an arbitrary edge in @xmath36 , where @xmath58 is the parent of @xmath65 , and let @xmath99 and @xmath428 be arbitrary non - root marker vertices , where @xmath87 is accessible from @xmath70 .",
    "we let @xmath28 be an arbitrary vertex and examine how occurrences of @xmath28 in @xmath429 can be transmitted to @xmath430 .",
    "note that the stamp @xmath431 applies to the marker vertex opposite @xmath28 , and thus a bottom - up argument starts with @xmath28 having appeared once as a primary stamp .",
    "first , we observe that no step of the algorithm allows a primary occurrence of @xmath28 in @xmath429 to be a secondary occurrence of @xmath28 in @xmath430 .",
    "suppose for contradiction that a primary occurrence of @xmath28 in @xmath429 is also a primary occurrence of @xmath28 in @xmath430 .",
    "this can only happen by execution of step 2(b ) , but now the stamp is removed from @xmath87 .",
    "thus this case does not allow an increase in the number of times that @xmath23 appears as a primary stamp .",
    "finally , suppose that a secondary occurrence of @xmath28 in @xmath429 becomes a primary occurrence of @xmath28 in @xmath430 .",
    "step 2(a ) allows this to happen thereby increasing by one the number of times that @xmath28 can appear as a primary stamp .",
    "the preceding argument shows that this can not occur again .    what these properties will allow us to do , after the next subsubsection ,",
    "is to transfer the charge assigned to marker vertices ( that are not centres of stars ) to their primary stamps .",
    "lemma  [ fact2 ] allows us to associate charge with an edge ( incident to the primary stamp ) in the underlying accessibility graph .",
    "lemma  [ fact3 ] allows us to associate the charge with a vertex ( i.e. the primary stamp ) in the underlying accessibility graph ( and to do this at most twice for each vertex )",
    ". then we will be able to bound the total charge in terms of the input graph parameters .",
    "the idea of the charging argument is to charge the creation of each new label - edge to one of its incident marker vertices . to that aim , each marker vertex @xmath70",
    "is associated throughout its lifetime with a list of vertices @xmath432 that can be given units of charge .",
    "let @xmath70 be a marker vertex of a node @xmath58 in a ( rooted ) split - tree @xmath110 of a connected graph @xmath11 .",
    "the list @xmath432 of vertices of @xmath11 contains a set of vertices of @xmath11 such that :    * each element in the list can be given a number of units of charge ; * the vertices are divided into groups , one for each of @xmath70 s neighbours in @xmath61 ; * the vertices in neighbour @xmath245 s group are the vertices in @xmath433 ; * the root marker vertex s group ( if it exists ) is called the _",
    "root group_.      the way we assign charge during the algorithm is described precisely in forthcoming lemmas [ prop : amortized1 ] , [ prop : phase1 ] , [ prop : phase2 ] and [ prop : phase3 ] .",
    "of course , the charge lists are not static during the construction of @xmath110 : as new vertices are inserted , new elements must be added to some @xmath436 lists ; and as node - joins and node - splits occur , new groups are created and destroyed , respectively . however , throughout these changes , the following invariant will be maintained :      * if @xmath70 is a marker vertex of a node @xmath58 of @xmath110 , then 1 .",
    "the list @xmath432 is free of charge if 1 .",
    "@xmath58 is a degenerate node or at some intermediate step of the contraction , @xmath70 has degree one in @xmath61 ; 2 .",
    "@xmath70 is a root marker vertex and has never been the centre of a star at some prior step ; 2 .",
    "if @xmath70 is adjacent to the root of @xmath61 , then the root group in @xmath432 is free of charge ; 3 .   at most one vertex in each group in @xmath432 has been assigned charge ; 4 .",
    "every vertex in @xmath432 has been assigned at most one unit of charge if @xmath70 is a root marker vertex , and at most three units of charge otherwise . *",
    "if @xmath23 is a leaf of @xmath110 , then each vertex in @xmath434 is assigned at most three units of charge .",
    "let us observe that a marker vertex can have degree one ( condition 1(a ) ) and not belong to a degenerate node only at some intermediate step of the contraction prior to the vertex insertion .",
    "of course , once the new vertex is inserted , this is no longer possible since the current glt is a split - tree ( see proposition  [ prop : fully - mixed - case-7 ] ) .",
    "assume the invariants hold for the split - tree @xmath110 .",
    "now consider forming the split - tree @xmath220 , where @xmath23 is is the last vertex in an lbfs ordering of @xmath34 .",
    "we will consider the changes required of @xmath110 to form @xmath220 , as described by propositions  [ prop : unique - node - cases123 ] , [ prop : hybrid - degen - case4 ] , [ prop : unique - edge - case56 ] and [ prop : fully - mixed - case-7 ] .",
    "[ prop : amortized1 ] let @xmath23 be the last vertex of an lbfs ordering of the connected graph @xmath34 .",
    "if invariant  [ invariant1 ] is satisfied by @xmath110 and if @xmath110 does not contain a fully - mixed edge , then invariant  [ invariant1 ] is satisfied by @xmath220 .    in every case , except if @xmath110 contains a unique hybrid prime node ( case 3 of theorem  [ th : cases ] ) , the modifications performed on @xmath110 to obtain @xmath220 only involve degenerate nodes .",
    "thus no label - edge is created . by condition 1 of invariant  [ invariant1 ] every list @xmath432 for a marker vertex of a degenerate node is free of charge , and invariant  [ invariant1 ]",
    "is still valid after @xmath23 s insertion .    in the case",
    "@xmath110 contains a unique hybrid prime node @xmath58 , then by proposition  [ prop : unique - node - cases123 ] new label - edges are created incident to @xmath23 s opposite , namely @xmath193 the new created marker vertex .",
    "clearly @xmath70 is not the root marker of @xmath58 and @xmath432 is divided in @xmath438 groups .",
    "one vertex of each of these groups receives a unit charge .",
    "if one of these group is the root group , then the charge assigned to one of its vertices is shifted to one of the other already charged vertices of @xmath432 .",
    "it follows that invariant  [ invariant1 ] it still satisfied .",
    "we now deal with the case where @xmath110 contains a fully - mixed subtree @xmath229 . by the arguments used in the proof above ,",
    "since the cleaning step only involves degenerate nodes and thus does not create any label - edges , the glt @xmath307 still satisfies invariant  [ invariant1 ] .",
    "our split - tree algorithm uses algorithm  [ alg : contraction ] to perform contraction . recall that it separates node - joins into three phases .",
    "phase 1 node - joins involve star nodes whose root marker vertex is its centre .",
    "phase 2 node - joins involve nodes whose root marker vertex has degree one .",
    "phase 3 node - joins are all those remaining .",
    "no matter the phase , a node - join creates new label - edges .",
    "we need to assign charge to account for every one of these edges .",
    "however , this is done differently for each of contraction s three phases , as explained below .",
    "[ prop : phase1 ] let @xmath23 be the last vertex of an lbfs ordering of the connected graph @xmath34 and assume @xmath307 satisfies invariant  [ invariant1 ] . if the node - join@xmath439 is performed on @xmath307 between a star node @xmath58 , whose root marker vertex is its centre , and a child @xmath98 of @xmath58 , then the resulting glt satisfies invariant  [ invariant1 ] .",
    "let @xmath199 be the centre of @xmath58 .",
    "notice that @xmath440 is free of charge , by condition  4 of invariant  [ invariant1 ] .",
    "let @xmath441 and @xmath442 be the extremities of the tree - edge between @xmath58 and @xmath98 .",
    "notice that @xmath245 is a degree one marker vertex .",
    "prior to the node - join , we need to create the label - edges of the graph @xmath61 since it is degenerate and of @xmath102 if @xmath98 is degenerate .",
    "every such label - edge @xmath66 is incident to a non - root marker vertex @xmath70 whose degenerate stamp is a vertex @xmath443 of @xmath11 .",
    "let @xmath28 be a leaf of @xmath444 , where @xmath71 is the other marker vertex incident to @xmath66 .",
    "observe that @xmath28 belongs to @xmath445 .",
    "then one unit is charged to @xmath28 s entry in @xmath445 for the cost of the creation of @xmath66 .",
    "as @xmath443 appears at most three times as a degenerate stamp ( see lemma  [ lem : degenerate - marker ] ) , invariant  [ invariant1 ] is satisfied .",
    "so assume the label - edges of @xmath61 and @xmath102 exist .",
    "if @xmath446 , then the node - join of @xmath58 and @xmath98 results in @xmath447 extra label - edges being created .",
    "but notice that it also results in @xmath245 s group in @xmath440 being replaced by @xmath447 new groups , each free of charge .",
    "so to each of these new groups we assign one unit of charge .",
    "if @xmath422 is a degree one marker vertex , then recall the node - join is handled differently ( see algorithm  [ alg : njoin ] ) .",
    "only one new label - edge is added between @xmath199 and @xmath422 s unique neighbour .",
    "again , for this we assign one unit of charge to what was @xmath245 s group in @xmath440 .",
    "now , since @xmath448 , we know @xmath449 is free of charge , by condition  1(a ) of invariant  [ invariant1 ] .",
    "we also know that @xmath422 is not the centre of a star , because @xmath110 is reduced .",
    "moreover , @xmath422 can never have been the centre of a star , because of lemma  [ lem : phase1limit ] and the fact that @xmath448 .",
    "it follows from condition  1(b ) of invariant  [ invariant1 ] that @xmath450 is free of charge . in other words ,",
    "no charge is lost in deleting @xmath449 and @xmath450 along with @xmath245 and @xmath422 .",
    "it follows easily that the number of label - edges created so far is bounded by the total charge on all the @xmath437 lists .",
    "it is also easy to verify that every condition of invariant  [ invariant1 ] continues to hold , although we single out condition  1(b ) for comment .",
    "the key for condition  1(b ) is that @xmath199 is no longer the centre of a star after the node - join is performed , and thus is allowed to have charge .",
    "we can now assume that all phase 1 node - joins are complete .",
    "let us turn to phase 2 node - joins .",
    "recall from algorithm  [ alg : contraction ] that a phase 2 node - join involves a node @xmath58 and one of its children @xmath98 such that the root of @xmath98 is a degree one marker vertex .",
    "this type of node - join is implemented differently ( see algorithm  [ alg : njoin ] ) .",
    "observe also that @xmath98 could not have resulted from any node - join in phase 1 .",
    "[ prop : phase2 ] let @xmath23 be the last vertex of an lbfs ordering of the connected graph @xmath34 .",
    "assume that all the phase 1 node - joins have been performed on @xmath307 and that the resulting glt satisfies invariant  [ invariant1 ] .",
    "if the node - join@xmath439 is performed between a node @xmath58 and one of its children @xmath98 which is a star node rooted at a degree one marker vertex , then the resulting glt satisfies invariant  [ invariant1 ] .",
    "first observe that as @xmath98 is a star node and @xmath58 is possibly a clique node , the label - edges of @xmath61 and @xmath102 have to exist prior to the node - join .",
    "the cost of this creation can be charged , as described in the proof of lemma  [ prop : phase1 ] , to the degenerate stamps of their non - root marker vertices .",
    "let @xmath94 be the root of @xmath98 ( @xmath94 has degree one in @xmath102 ) and let @xmath199 be the centre of @xmath98 .",
    "let @xmath70 be the opposite of @xmath94 .",
    "the node - join proceeds by deleting @xmath199 s neighbours ( other than @xmath94 ) from @xmath98 , and adding them to @xmath58 as neighbours of @xmath70 .",
    "suppose that @xmath7 neighbours of @xmath199 are moved in this way .",
    "then @xmath7 new label - edges are created by the node - join .",
    "but notice that adding the new edges incident to @xmath70 creates @xmath7 new groups in @xmath432 , each being free of charge by virtue of being new .",
    "so to each of these groups we assign one new unit of charge .    by condition  1(a ) of invariant  [ invariant1 ] , both @xmath440 and @xmath451 are free of charge .",
    "so no charge is lost deleting @xmath440 and @xmath451 along with @xmath199 and @xmath94 .",
    "therefore the number of label - edges created so far is bounded by the total charge on all the @xmath437 lists .",
    "[ prop : phase3 ] let @xmath23 be the last vertex of an lbfs ordering of the connected graph @xmath34 .",
    "assume that all the phase 1 and phase 2 node - joins have been performed on @xmath307 and that the resulting glt satisfies invariant  [ invariant1 ] .",
    "if the node - join@xmath439 is performed , then the resulting glt satisfies invariant  [ invariant1 ] .",
    "as discussed in the proof of lemma  [ prop : phase1 ] , if @xmath58 or @xmath98 is a degenerate node ( it must be a clique in this case ) , then the cost of creating the corresponding label - edges can be charged to the list of some degenerate stamps while preserving invariant  [ invariant1 ] .",
    "let @xmath99 and @xmath452 be the extremities of the edge @xmath453 .",
    "since all phase 1 and phase 2 joins have been performed , we can assume that @xmath454 and @xmath420 . before assigning charge to account for the @xmath455 new label - edges that are created",
    ", we will want to redistribute any charge on @xmath432 and @xmath451 .",
    "first consider the redistribution of the charge on @xmath432 .",
    "let @xmath245 be a neighbour of @xmath70 in @xmath61 .",
    "if @xmath245 is the root marker vertex , then @xmath245 s group in @xmath432 is free of charge by condition  2 of invariant  [ invariant1 ] , and so no charge in this group needs to be redistributed .",
    "so let @xmath245 be a non - root marker vertex that is a neighbour of @xmath70 .",
    "then by condition  3 of invariant  [ invariant1 ] , we know that at most one vertex in @xmath245 s group in @xmath432 has been assigned charge",
    ". if such a vertex exists , then call it @xmath456 .",
    "notice that during the @xmath101 node - join , @xmath449 will lose @xmath70 s group but will gain the @xmath420 groups in @xmath451 . by condition  3 of invariant  [ invariant1 ] ,",
    "at least one of these groups ( say @xmath457 ) will be free of charge .",
    "the charge on @xmath456 is reassigned to one of the vertices in @xmath457 in this case . continuing this for all such @xmath245",
    "removes all charge on @xmath432 , and so it can be deleted along with @xmath70 and no charge is lost .",
    "we now turn to the redistribution of the charge on @xmath451 .",
    "let @xmath422 be a neighbour of @xmath94 in @xmath102 , and notice that by condition  3 of invariant  [ invariant1 ] , at most one vertex in @xmath422 s group in @xmath451 has been assigned charge .",
    "if such a vertex exists , call it @xmath458 . by condition  4 of invariant  [ invariant1 ] , we know that @xmath458 has been assigned no more than one unit of charge .",
    "now , once more by condition  2 of invariant  [ invariant1 ] , we know that @xmath94 s group in @xmath450 is free of charge . furthermore , during the join , @xmath450 will lose @xmath94 s group but will gain the @xmath454 groups in @xmath432 .",
    "let @xmath459 be one of these new groups .",
    "in this case we reassign @xmath458 s one unit of charge ( if it exists ) to a label in @xmath459 . continuing this for all such @xmath422",
    "removes all charge on @xmath451 , and so it can be deleted along with @xmath94 and no charge is lost .",
    "we finally assign @xmath455 new units of charge .",
    "let @xmath422 and @xmath459 be as above .",
    "so @xmath94 s former group in @xmath450 is replaced by @xmath454 new groups , one of them called @xmath459 . only @xmath459 ( possibly ) has any charge assigned to it , and only one unit at that ; the other @xmath460 groups are free of charge . to @xmath461 of the groups free of charge we assign one unit of charge , and to the remaining group free of charge we assign two units of charge .",
    "lastly , if one of the groups corresponds to the root marker vertex of @xmath58 , then the charge just assigned to that group is shifted to another , which must exist .",
    "the result is that only one vertex in each group contains charge , none having been assigned more than three units , and the root group becomes free of charge .",
    "lemmas  [ prop : amortized1 ] , [ prop : phase1 ] , [ prop : phase2 ] and [ prop : phase3 ] guarantee that invariant  [ invariant1 ] holds during the lbfs incremental construction of the split - tree of @xmath11 .",
    "consequently , the total number of label - edges created all along the construction is bounded by the total charge residing on all @xmath436 lists .",
    "[ chargebound ] let @xmath11 be a connected graph .",
    "the total number of label - edges created during our lbfs incremental construction of @xmath110 is @xmath462 , where @xmath30 is the number of vertices in @xmath11 and @xmath463 is the number of its edges .",
    "assign primary stamps to the marker vertices in @xmath110 as described earlier . by condition  1(a ) of invariant  [ invariant1 ] , we can focus on the @xmath436 lists residing on marker vertices in prime nodes and on leaves of @xmath110 .    by invariant  [ invariant1 ] , the elements of the lists @xmath434 received at most @xmath2 units of charge . as these lists contain exactly @xmath464 elements , the total charge on these lists",
    "is bounded by @xmath465 .",
    "let @xmath58 be a prime node , and let @xmath466 be @xmath58 s root marker vertex , and let @xmath70 be one of @xmath58 s non - root marker vertices .",
    "if @xmath70 and @xmath94 are adjacent , then download all the charge from @xmath70 s group in @xmath451 to @xmath94 s group in @xmath432 . by condition  4 of invariant  [ invariant1 ] ,",
    "the total charge in @xmath94 s group in @xmath432 is not more than four units . by the same condition  4 ,",
    "the total charge in the other groups in @xmath432 is no more than three units .",
    "now , by choice of @xmath70 and lemma  [ fact1 ] , we can assume that @xmath70 has been assigned a primary stamp .",
    "moreover , the vertex @xmath425 acting as primary stamp is in @xmath78 , by lemma  [ fact2 ] .",
    "so by definition of @xmath432 , we know @xmath425 is adjacent to every label in @xmath432 .",
    "the total charge on all such @xmath436 lists is therefore @xmath462 , by lemma  [ fact3 ] and our discussion above .",
    "[ numnjoins ] let @xmath11 be a connected graph .",
    "the total number of node - joins and _ ` union ( ) ` _ operations performed by our lbfs incremental construction of @xmath110 is @xmath462 , where @xmath30 is the number of vertices in @xmath11 and @xmath463 is the number of its edges .",
    "there are exactly three ways our algorithm applies a ` union ( ) ` operation : once after each ` initalization ( ) ` in a node - join , once for finalizing every node - join , and once when a new prime node is formed .",
    "the number of such applications of the first way is @xmath369 by lemma [ initializationcost ] , the number of the second way is @xmath462 as said above , and the number of the third way is @xmath369 , since at most one new prime node is formed for each vertex inserted .",
    "[ lem : numsubtree ] let @xmath467 be a connected graph with @xmath30 vertices and @xmath463 edges whose split - tree is incrementally constructed by repeated application of algorithm  [ alg : vertexinsertion ] ; that is @xmath468 is built from @xmath469 for @xmath470 .",
    "then the sum of @xmath471 over all @xmath470 is @xmath462 .    for a fixed @xmath372 , let @xmath11 denote @xmath10 , @xmath36 denote @xmath472 , @xmath23 denote @xmath380 , and @xmath22 denote @xmath473 .",
    "we can divide the nodes of @xmath319 into two groups : those that remain in @xmath220 , and those that do not .",
    "the number of those that remain is @xmath474 , by lemma  [ treesize ] .",
    "so the total number of nodes in the first group over the entire execution of our algorithm is @xmath462 .",
    "every node in the second group participates in at least one node - join .",
    "so the total number of nodes in the second group over the entire execution of our algorithm is also @xmath462 , by lemma  [ numnjoins ] .",
    "[ numfinds ] let @xmath11 be a connected graph .",
    "the total number of _ ` find ( ) ` _ operations performed by our lbfs incremental construction of @xmath110 is @xmath462 , where @xmath30 is the number of vertices in @xmath34 and @xmath463 is the number of its edges .",
    "our algorithm uses ` find ( ) ` operations to traverse the split - tree",
    ". these traversals can take place during case identification and state assignment , cleaning , and contraction . case identification and state assignment",
    "take place according to algorithm  [ alg : perfectpruning ] ; cleaning takes place according to algorithm  [ alg : cleaning ] ; and contraction takes place according to algorithm  [ alg : contraction ] .",
    "so by lemmas  [ lem : pruningcorrectness ] ,  [ cleaningtime ] , and  [ contractiontime ] , the total number of @xmath475 operations required for the insertion of @xmath23 is @xmath321 .",
    "so the total number for the whole algorithm is @xmath462 by lemma [ lem : numsubtree ] .",
    "[ numnodes ] let @xmath11 be a connected graph .",
    "the total number of nodes ( including fake nodes ) created in the rooted glt data - structure used by our algorithm , and the total number of elements in the union of children - sets , is @xmath462 .",
    "a node is created either when the new vertex @xmath23 is inserted , or when a node - split is performed . at most one node - split",
    "is performed in the case where there is no fully - mixed subtree .",
    "therefore , the total number of nodes created in this case and by the insertion of @xmath23 is @xmath369 over the course of the lbfs construction of @xmath110 .",
    "if there is a fully - mixed subtree , then node - splits are performed during the cleaning step and they involve nodes in @xmath319 . at most two node - splits",
    "are performed at each such node .",
    "so the total number of created nodes for the whole algorithm is @xmath462 by lemma [ lem : numsubtree ] .",
    "elements of children - sets in the data - structure are either leaves or some nodes created at some step of the algorithm , hence their total number is also @xmath462 .",
    "[ bigtheorem ] the split - tree @xmath110 of a graph @xmath39 with @xmath30 vertices and @xmath463 edges can be built incrementally according to an lbfs ordering in time @xmath0 , where @xmath1 is the inverse ackermann function .",
    "lemma  [ lem : degenerate - marker ] establishes an @xmath369 bound on the number of non - root degenerate marker vertices .",
    "as every node has degree at least @xmath2 , the total number of degenerate marker vertices created during the lbfs incremental construction is @xmath369 .",
    "the total number of label - edges created during the lbfs incremental construction is @xmath462 , by lemma  [ chargebound ] .",
    "therefore our algorithm generates an @xmath462 size data - structure .",
    "in addition to the cost of computing an lbfs , which takes time @xmath462  @xcite , we have to bound the cost of the tree traversals , based on ` find ( ) ` operations , plus the total cost of the ` initialization ( ) ` , ` union ( ) ` operations involved in the contraction steps .",
    "the sum , over all the algorithm , of the term @xmath476 in lemmas  [ lem : pruningcorrectness ] ,  [ cleaningtime ] , and  [ contractiontime ] , is @xmath462 , by lemma  [ lem : numsubtree ] . the total cost of ` initialization ( ) ` operations required by the algorithm is @xmath369 , by lemma  [ initializationcost ] .",
    "the total number of @xmath477 and @xmath475 operations is @xmath462 , by lemmas  [ numnjoins ] and  [ numfinds ] , respectively .",
    "finally , the cost of the union - find requests amounts to @xmath478 , where @xmath317 is the total number of elements in the union of children - sets .",
    "this number @xmath317 is @xmath462 by lemma [ numnodes ] .",
    "it is easy to prove that @xmath479 for any fixed constant @xmath480 . indeed , because of the way the ackermann function increases , for any @xmath30 , @xmath481 implies @xmath482 for every @xmath7 large enough . hence @xmath483 for @xmath30 large enough , which implies @xmath484 . in particular , we have that @xmath485 .      to conclude ,",
    "let us mention that we are prevented from achieving linear time only by the node - join .",
    "let @xmath58 and @xmath98 be two adjacent nodes , with @xmath58 the parent of @xmath98 . to effect their node - join ,",
    "the children of @xmath98 must be made children of @xmath58 .",
    "that is the bottleneck .",
    "our implementation does its best to avoid it by using union - find , but the optimal complexity for union - find involves the inverse ackemann function .",
    "it seems to us that our charging argument can not be extended to cover the cost of reassigning @xmath98 s children , thereby eliminating union - find and achieving linear time .",
    "however , it is worth emphasizing that , from the practical viewpoint , the inverse ackermann function can be thought of as a constant , and that every other aspect of our algorithm is consistent with linear time .",
    "this paper s companion  @xcite extends our split decomposition algorithm to recognize circle graphs in same time .",
    "it is the first sub - quadratic circle recognition algorithm , and the first progress on the problem in fifteen years .",
    "f.  dragan , f.  nicolai , and a.  brandstdt .",
    "lexbfs - orderings and powers of graphs . in _ international workshop on graph theoretical concepts in computer science ( wg ) , lecture notes in computer science _ , 1197:166180 , 1996 .",
    "e.  gioan and c.  paul .",
    "dynamic distance hereditary graphs using split decomposition . in _ international symposium on algorithms and computation ( isaac ) , lecture notes in computer science _",
    ", 4835:4151 , 2007 .",
    "m.  habib , r.m .",
    "mcconnell , c.  paul , and l.  viennot .",
    "lex - bfs and partition refinement , with applications to transitive orientation , interval graph recognition and consecutive ones testing .",
    ", 234:5984 , 2000 ."
  ],
  "abstract_text": [
    "<S> split decomposition of graphs was introduced by cunningham ( under the name join decomposition ) as a generalization of the modular decomposition . </S>",
    "<S> this paper undertakes an investigation into the algorithmic properties of split decomposition . </S>",
    "<S> we do so in the context of graph - labelled trees ( glts ) , a new combinatorial object designed to simplify its consideration . </S>",
    "<S> glts are used to derive an incremental characterization of split decomposition , with a simple combinatorial description , and to explore its properties with respect to lexicographic breadth - first search ( lbfs ) . applying the incremental characterization to an lbfs ordering results in a split decomposition algorithm that runs in time @xmath0 , where @xmath1 is the inverse ackermann function , </S>",
    "<S> whose value is smaller than 4 for any practical graph . compared to dahlhaus linear time split decomposition algorithm @xcite , which does not rely on an incremental construction , </S>",
    "<S> our algorithm is just as fast in all but the asymptotic sense and full implementation details are given in this paper . </S>",
    "<S> also , our algorithm extends to circle graph recognition , whereas no such extension is known for dahlhaus algorithm . </S>",
    "<S> the companion paper  @xcite uses our algorithm to derive the first sub - quadratic circle graph recognition algorithm . </S>"
  ]
}