{
  "article_text": [
    "alice ( owning a private variable @xmath2 ) and bob ( owning a private variable @xmath3 ) wish to determine the truth value of the predicate `` @xmath4 '' without disclosing any of their private data except for what is implied by the result .",
    "this article details the attempts to solve this problem efficiently by using techniques different from the ones already presented .",
    "this problem is famously known as _ the millionaire problem _ in the literature .",
    "the solution to the millionaire problem finds applications in e - commerce and data mining ; and also forms a sub - procedure in solving _ the vector dominance problem _ @xcite .",
    "the remainder of the article discusses the related research in this area ( section [ sec2 ] ) and presents three new constructions  termed ` ' , ` ' and ` ' ( section [ sec3 ] ) .",
    "each protocol starts with definitions , terminologies and constructions used , followed by the protocol , its complexity and a brief security analysis .",
    "any other added details in a protocols are included thereafter .",
    "finally , in section [ sec4 ] , we conclude and mention some directions that can be taken to further this research .",
    "@xcite gave the first protocol for solving the secure comparison problem .",
    "however , the solution was exponential in time and space requirements . in 1987",
    ", @xcite proposed a solution using scrambled circuits to any secure multiparty computation problem .",
    "@xcite presented a constant - round solution for multi - party computation .",
    "@xcite , @xcite , and @xcite have studied fairness in two - party computations with extension to multiparty computation .",
    "@xcite study the multi - party secure computation models in the presence of an untrusted third party which does not learn anything about the inputs .",
    "@xcite also presented an elegant and practical solution to the millionaire problem using an untrusted third party @xmath5 based on the @xmath6-hiding assumption .",
    "@xcite used _ threshold homomorphic encryption schemes _ to solve the multiparty computation problem .",
    "@xcite proposed a two - round protocol for solving the millionaire problem in the setting of semi - honest parties using _ multiplicative or additive _ homomorphic encryption schemes .",
    "@xcite constructed a two - round protocol for the millionaire problem using the goldwasser - micali encryption scheme ( the computation cost of the protocol is @xmath7 modular multiplications , where @xmath8 is the security parameter and the communication cost is @xmath9 , where @xmath10 is the modulus ) .",
    "@xcite presented a two - round protocol for the problem using the _ additive homomorphic paillier cryptosystem_. its computation cost is @xmath11 and the communication cost is @xmath11 .",
    "a symmetric cryptographic solution to the millionaires problem and evaluation of secure multiparty computations was presented by @xcite . in 2003",
    ", @xcite proposed an efficient protocol for the problem , having a suboptimal time and communication complexity . in 2009",
    ", @xcite proposed the first fully homomorphic encryption scheme which allows one to compute arbitrary functions over encrypted data .",
    "we work out three protocol constructions that are efficient and simple .      assumption : we assume the existence of an efficient partially homomorphic encryption . by partial ,",
    "we mean that the homomorphic encryption should have the properties of additivity and bit - wise xor .",
    "alice owns a private value @xmath12 and bob owns the private value @xmath13 . here",
    "we represent @xmath12 and @xmath13 in two s compliment form such that the sign of any integer ( represented as a binary string ) is stored as the most significant bit of its corresponding binary string .",
    "also , all xor operations performed are bitwise .    1 .",
    "bob owns a homomorphic public key encryption scheme @xmath14 .",
    "2 .   bob now computes @xmath15 and sends it to alice .",
    "3 .   alice generates a random number @xmath16 and computes : 1 .",
    "@xmath17 , 2 .",
    "then @xmath18 + and sends @xmath19 to bob .",
    "note that @xmath20 by the properties of homomorphic encryption .",
    "4 .   bob decrypts @xmath19 to obtain @xmath21 and sends the most significant bit ( msb ) of the decrypted value to alice  it contains the information about the sign of the operation @xmath22 . 5 .",
    "alice then takes the xor of the obtained bit from bob and the msb of @xmath16 to obtain the output : if @xmath23 .",
    "the security analysis of protocol is trivial and is based on the security of the corresponding homomorphic encryption scheme and the fact that one time pads are secure for a single use of a key .",
    "communication overhead : let the input with larger number of bits be @xmath12 . then the communication overhead can be seen to be : @xmath24 .",
    "computation : the protocol is efficient . the computation overhead is : @xmath1(complexity of encrypting a variable ) + ( complexity of subtraction in the homomorphic scheme ) + ( complexity of xor in the homomorphic scheme ) + ( complexity of xor of 2 bits ( step 5 of the protocol ) ) .",
    "the first term depends on the encryption scheme used ; the second and third term depend on the homomorphic scheme used and the last term is a constant .      as we will formalize the protocol , we will also note that even if a single party , out of the two involved parties , is computationally powerful , the protocol will be able to exploit the computation power of that party to perform the computationally expensive tasks in the protocol .",
    "we begin with the following definition .",
    "( * order preserving function : * ) a function @xmath25 ( where @xmath26 ) is called an order preserving function if @xmath27 @xmath28 , @xmath29 .",
    "for example , @xmath30 is , clearly , an order preserving function .",
    "suppose alice and bob have some random order preserving function @xmath25 , unknown to a third party .",
    "later we ll see how to construct such an order preserving function .",
    "now if alice and bob send @xmath31 and @xmath32 to ursula ( the third party ) , then @xmath23 _ iff _ @xmath33  follows from the definition of order preserving function .",
    "let the input size be @xmath35 bits , i.e. , @xmath36 . as we will present the construction",
    ", we will note that that construction need not know the input sizes in advance and neither does it require the inputs to have the same bit - sizes .    then to construct @xmath34",
    ", we consider @xmath35 random functions : @xmath37 , where each @xmath38 is used to encode the @xmath39 least significant input bit .",
    "let us assume that the mappings follow the following constraints : @xmath40    we can always find such values for @xmath41 satisfying the above constraints .",
    "for a sample construction of @xmath34 , refer to section [ excons ]    let @xmath42 , for @xmath43 , denote the @xmath39 least significant bit in the binary representation of an input @xmath12",
    ". then define @xmath44 where , @xmath45 .",
    "[ ope ] @xmath34 is an order preserving function .",
    "let @xmath46 .",
    "assume , without the loss of generality , @xmath47 .",
    "let @xmath48 correspond to the binary representation of @xmath49 respectively . here",
    "we show that @xmath51 , where @xmath34 is constructed as above .",
    "we denote the @xmath39 bit ( starting from the least significant bit numbered @xmath52 ) of a bit string @xmath2 by @xmath53 .",
    "since @xmath4 , @xmath2 must have a @xmath52 at the first bit position at which @xmath2 and @xmath3 _ differ _ , starting from the most significant bit .",
    "let this position be @xmath54 . by the construction of the function @xmath34",
    ", we have : @xmath55    now , @xmath56 and @xmath57    so , @xmath58 since , all bits at positions higher than @xmath54 are equal for @xmath2 and @xmath3 and hence , their mappings being equal , cancel out .",
    "thus for @xmath51 , we require @xmath59    to show that inequality holds , we show that it holds for the maximum value of the rhs .",
    "rhs is maximum when we have @xmath60 and @xmath61 ( this is because if we have @xmath62 or @xmath63 , then @xmath64 , and since @xmath65 , by construction ; hence for @xmath66 , we have @xmath67 , i.e. it has a positive contribution to the sum on the r.h.s ) .",
    "so , we require that : @xmath68 which we know is true by the construction of @xmath34 ( see equation ) .",
    "the proof for @xmath69 @xmath70 @xmath71 is analogous .",
    "this completes the proof .",
    "let us consider an order preserving function @xmath72 .",
    "an order preserving function @xmath34 can be thought as a sequence of functions mapping each bit position , i.e. , @xmath73 where @xmath74 represents the mapping corresponding to the @xmath39 bit starting from the least significant bit ( which is the first bit . )    while constructing the functions @xmath74 , we need to take care of the following constraints : @xmath75    the computation of @xmath74s is tabulated in table [ tab:1 ]    .computation of @xmath76 [ cols=\"^,^,^,^,^\",options=\"header \" , ]     for the worst case , + @xmath77 and , + @xmath78 .    clearly , the worst case number of bits required to represent @xmath79 ( corresponding to @xmath80 ) is @xmath81 .",
    "also note that , since the function preserves order only with respect to the value @xmath13 , thus , it is possible to construct an _ order preserving function at @xmath13 _ , with an output space having cardinality lesser than that of the input space .",
    "for example , the function : @xmath34 defined as : @xmath82 @xmath83 , and @xmath84 @xmath83 , is also an _ order preserving function at point @xmath13 _ having an output space of cardinality 2 .      protocol uses 1 out of 2 oblivious transfer(ot ) protcol as a subroutine .",
    "some details of 1-out - of-2 ot protocol @xcite have been discussed at the end of this subsection .",
    "assume that alice owns the private variable @xmath12 , and bob owns the private variable @xmath13 .",
    "let the bound on the length of the input be @xmath85 bits .    1 .",
    "bob constructs the above mentioned function @xmath34 w.r.t .",
    "@xmath13 . for generating the random values of @xmath74s using a single seed @xmath86 ,",
    "refer to section [ sec : prg ] 2 .",
    "alice uses _ @xmath52-out - of-@xmath1 ot _ for each input bit @xmath42 to obtain the bit encoding @xmath87 for each @xmath88 and then computes @xmath89 .",
    "bob then sends @xmath90 to alice , who then compares @xmath91 and @xmath90 and tells the result to bob .",
    "the correctness of the protocol follows from the correctness of the construction of the desired function @xmath34 ( w.r.t .",
    "@xmath13 ) .    _",
    "1-out-2 oblivious transfer _ : for ot ( 1 out of 2 ) , sender(s ) has two secrets , @xmath92 and @xmath93 , and would like the receiver(r ) to receive one of them , as per her choice . but , r does not want s to know which secret it chooses and s wants r to know only the secret of her choice , revealing no information about the other secret . in our case , bob has the secrets @xmath94 and @xmath95 , and alice has a bit @xmath42 , corresponding to which she wants the secret @xmath96 . in the process",
    ", alice wants her bit value to remain a secret and bob wants alice to obtain only the mapping corresponding to her bit value , hiding the mapping of the other bit .    practically used 1-out - of-2 oblivious transfer involves four encryptions and two decryptions in a commutative encryption scheme , like rsa . practically , public - key cryptography is expensive and hence it is preferrable to use a linear ( even if large ) number of cheap operations ( in oblivious transfer ) .",
    "we first consider a prg @xmath97 , where @xmath98 is the bit size of the seed @xmath86 used in the generation of random number in @xmath99 , and @xmath85 is the bound on bit - size of input",
    ".    we can then split up the output of @xmath99 into @xmath100 pieces each of size @xmath98 and sequentially use the @xmath100 pieces as seeds in a generator @xmath101 to obtain the random values of @xmath74s in the desired ranges .",
    "the security of this method has been argued in `` foundations of cryptography - basic tools '' by @xcite .",
    "communication overhead : the protocol uses @xmath85 parallel rounds of _ @xmath52-out - of-@xmath1 ot _ , each on @xmath102 bit numbers and requiring a different key .",
    "@xmath102 bits are required in step 3 to communicate @xmath90 to alice .",
    "a single bit is transferred at the end to convey the result of the protocol ( determined by alice ) to bob .",
    "computation complexity : the protocol requires : @xmath35 additions ( requiring a total of @xmath103 ) + @xmath104 @xmath105 ( complexity of generating an @xmath35-bit random number ) .",
    "since pseudorandom numbers can be generated efficiently , hence , the computations involved can be done efficiently .",
    "security : alice gets to see @xmath96 for all @xmath88 .",
    "however , since for each @xmath88 either @xmath94 or @xmath95 is chosen uniformly at random ( according to our construction of f ( section [ consc ] ) ) ; and also , alice does nt know which of @xmath94 or @xmath95 is chosen at random , and neither does she know the range from which the parameters @xmath106 are chosen ( which are also chosen uniformly at random ) , hence , it is difficult for her to deduce any information about the bob s private variable @xmath13 .",
    "the security of the protocol also depends on the security of the prg used and the security of the 1-out - of-2 ot protocol used to transfer @xmath107s .",
    "it has been demonstrated that millionaires problem can be solved using linear communication overhead with an untrusted non - colluding third party and quadratic communication overhead without a third party .",
    "however , we still need to concretely prove a lower bound on the communication and computational complexity of solving the millionaire s problem , later extending it to the computation of general functions .",
    "a proof of lower bound would give us an insight in the difficulty of securely and jointly computing any function in general and hence would aid us in designing protocols for efficiently computing those functions ."
  ],
  "abstract_text": [
    "<S> we present three simple and efficient protocol constructions to solve yao s millionaire problem when the parties involved are non - colluding and semi - honest . the first construction uses a partially homomorphic encryption scheme and is a @xmath0-round scheme using @xmath1 encryptions </S>",
    "<S> , @xmath1 homomorphic circuit evaluations ( subtraction and xor ) and a single decryption . </S>",
    "<S> the second construction uses an untrusted third party and achieves a communication overhead linear in input bit - size with the help of an order preserving function.moreover , the second construction does not require an apriori input bound and can work on inputs of different bit - sizes . </S>",
    "<S> the third construction does not use a third party and , even though , it has a quadratic communication overhead , it is a fairly simple construction .    </S>",
    "<S> * keywords : * secure two - party computation , cryptography , security </S>"
  ]
}