{
  "article_text": [
    "we consider a real - time streaming system where messages are created sequentially at the source , and are encoded for transmission to the receiver over a packet erasure link .",
    "each message must subsequently be decoded at the receiver within a given delay from its creation time .",
    "we seek to construct an erasure correction code that withstands a specified set of erasure patterns ( erasure model ) , allowing all messages to be decoded by their respective deadlines .",
    "in particular , we consider three erasure models : the first model limits the number of erasures in each coding window , the second model limits the number of erasures in each sliding window , while the third model limits the length of erasure bursts . for each erasure model , the objective is to find an optimal code that achieves the maximum message size , among all codes that allow all messages to be decoded by their respective deadlines under all admissible erasure patterns .",
    "we present an explicit intrasession code construction which specifies an allocation of link bandwidth or data packet space among the different messages ; coding occurs within each message but not across messages .",
    "intrasession coding is attractive due to its relative simplicity , but it is not known in general when intrasession coding is sufficient or when intersession coding is necessary .",
    "we show that for an asymptotic number of messages , our code construction achieves the optimal message size among all codes ( intrasession or intersession ) for the first and second models with any given maximum number of erasures per window , and for the third model when the given maximum erasure burst length is sufficiently short or long .    in related work ,",
    "et al . _",
    "@xcite provided constructions of streaming codes that minimize the delay required to correct erasure bursts of a given length . streaming codes in which the decoding error probability decays exponentially with delay , called tree codes or anytime codes ,",
    "are considered in  @xcite .",
    "et al . _",
    "@xcite considered erasure correction coding for a non - real - time streaming system where all messages are initially present at the encoder .    we begin with a formal definition of the problem in section  [ sec : problemdefinition ] , and proceed to describe the construction of our intrasession code in section  [ sec : codeconstruction ] .",
    "we then demonstrate the optimality of this code under each erasure model in the subsequent sections .",
    "proofs of theorems are deferred to appendix  [ sec : proofsoftheorems ] .",
    "is assigned a unique color .",
    "messages are created at the source at regular intervals of @xmath0 time steps , and must be decoded at the receiver within @xmath1 time steps from their respective creation times . at each time step  @xmath2",
    ", the source is allowed to transmit a single data packet of normalized unit size over the link . ]",
    "consider a discrete - time data streaming system comprising a source and a receiver , with a directed unit - bandwidth packet erasure link from the source to the receiver .",
    "independent messages of uniform size are created at the source at regular intervals of time steps , and must be decoded at the receiver within time steps from their respective creation times . at each time step , the source is allowed to transmit a single data packet of normalized unit size over the link .",
    "[ fig : systemdiagram ] depicts this real - time streaming system for an instance of .",
    "more precisely , each message   is created at time step , and is to be decoded by time step .",
    "the coded data transmitted at each time step   must be a function of messages created at time step  @xmath2 or earlier .",
    "let coding window @xmath3 be the interval of @xmath1 time steps between the creation time and the decoding deadline of message  @xmath4 , i.e. , @xmath5 we shall assume that so as to avoid the degenerate case of nonoverlapping coding windows for which it is sufficient to code individual messages separately .",
    "consider the first @xmath6 messages , and the union of their ( overlapping ) coding windows @xmath7 given by @xmath8 an erasure pattern specifies a set of erased data transmissions over the link .",
    "more precisely , if , then none of the data transmitted at time step  @xmath2 is received by the receiver ( i.e. , the entire data packet is erased ) ; if , then all of the data transmitted at time step  @xmath2 is received by the receiver at time step  @xmath2 ( i.e. , the entire data packet is received without delay ) .",
    "an erasure model specifies a set of erasure patterns that an erasure correction code should withstand .    for a given pair of positive integers @xmath9 and @xmath10",
    ", we define the offset quotient @xmath11 and remainder @xmath12 to be the unique integers satisfying the following three conditions : @xmath13 where @xmath14 denotes the set of nonnegative integers , i.e. , .",
    "note that our definition departs from the usual definition of quotient and remainder in that @xmath12 can be equal to @xmath10 but not @xmath15 .",
    "we present an intrasession code which codes only within each message and not across different messages .",
    "we begin by specifying the amount of link bandwidth or data packet space allocated for the encoding of each message at each time step .",
    "an appropriate code ( e.g. , random linear coding , mds code ) is then applied to the allocation so that each message can be decoded whenever the total amount of received data that encodes that message is at least the message size  @xmath16 .",
    "the allocation of link bandwidth follows a simple rule : the link bandwidth at each time step is divided evenly among all _ active _ messages .",
    "we say that message  @xmath4 is active at time step  @xmath2 if and only if @xmath2 falls within its coding window , i.e. , .",
    "[ fig : codeconstruction ] shows how much link bandwidth at each time step is allocated to each message , for two instances of .",
    "+    for a given choice of , the messages that are encoded at a given time step   can be stated explicitly as follows : first , we define @xmath17 to be the set of active messages at time step  @xmath2 , i.e. , @xmath18 treating nonpositive messages @xmath19 as dummy messages , we can write @xmath20 expressing this in terms of @xmath21 , @xmath22 , @xmath23 , @xmath24 yields @xmath25 it follows that the number of active messages @xmath26 varies over time depending on the value of @xmath24 ; specifically , two cases are possible :    if , then @xmath27 which implies that , and @xmath28 the messages of @xmath17 are therefore encoded at time step  @xmath2 , with each message allocated @xmath29 amount of link bandwidth .    if , then @xmath30 which implies that , and @xmath31 the messages of @xmath17 are therefore encoded at time step  @xmath2 , with each message allocated @xmath32 amount of link bandwidth .",
    "note that when @xmath1 is a multiple of @xmath0 , we have for any @xmath2 , which implies that messages are encoded at every time step .    in our subsequent performance analysis of this code ,",
    "we make repeated use of two key code properties ; these are presented as technical lemmas in appendix  [ sec : codeproperties ] .",
    "for the first erasure model , we look at erasure patterns that have a limited number of erasures per coding window .",
    "consider the first @xmath6 messages , and the union of their ( overlapping ) coding windows @xmath7 .",
    "let @xmath34 be the set of erasure patterns that have @xmath33 or fewer erasures in each coding window @xmath3 , i.e. , @xmath35 the objective is to construct a code that allows all @xmath6 messages to be decoded by their respective deadlines under any erasure pattern .",
    "let @xmath36 be the maximum message size that can be achieved by such a code , for a given choice of .",
    "we observe that over a finite time horizon ( i.e. , when the number of messages @xmath6 is finite ) , intrasession coding can be suboptimal .",
    "the following example shows that an intersession code can achieve a message size that is strictly larger than the message size achieved by an optimal intrasession code :    suppose that @xmath37 . the maximum message size that can be achieved by an intrasession code",
    "is @xmath38 ; one such optimal intrasession code , which can be found by solving a linear program , is as follows ( the amount of link bandwidth allocated to each message is indicated in parentheses ) :        the following intersession code achieves a strictly larger message size of @xmath39 ( @xmath40 denotes message  @xmath4 ) :        using a simple cut - set bound argument , we can show that this is also the maximum achievable message size , i.e. , @xmath41 .",
    "however , it turns out that the intrasession code constructed in section  [ sec : codeconstruction ] is _ asymptotically _ optimal ; the gap between the maximum achievable message size @xmath36 and the message size achieved by the code vanishes as the number of messages @xmath6 goes to infinity :    [ thm : theorem : codingwindowoptimalcode ] the code constructed in section  [ sec : codeconstruction ] is asymptotically optimal in the following sense : the code achieves a message size of @xmath42 which is equal to the asymptotic maximum achievable message size @xmath43 , where is defined as @xmath44    the achievability claim of this theorem is a consequence of lemma  [ thm : lemma : achievability ] ; to prove the converse claim , we consider a cut - set bound corresponding to a specific _ worst - case _ erasure pattern in which exactly @xmath33 erasures occur in every coding window .",
    "this erasure pattern is chosen with the help of lemma  [ thm : lemma : partitioncodingwindows ] ; specifically , the erased time steps are chosen to coincide with the larger blocks allocated to each message in the constructed code .",
    "for the second erasure model , we look at erasure patterns that have a limited number of erasures per sliding window of @xmath1 time steps . consider the first @xmath6 messages , and the union of their ( overlapping ) coding windows @xmath7 .",
    "let sliding window @xmath45 denote the interval of @xmath1 time steps beginning at time step  @xmath2 , i.e. , @xmath46 let @xmath47 be the set of erasure patterns that have @xmath33 or fewer erasures in each sliding window @xmath45 , i.e. , @xmath48 the objective is to construct a code that allows all @xmath6 messages to be decoded by their respective deadlines under any erasure pattern .",
    "let @xmath49 be the maximum message size that can be achieved by such a code , for a given choice of .",
    "we note that since , we therefore have .",
    "for the special case of , each sliding window is also a coding window , and so this sliding window erasure model reduces to the coding window erasure model of section  [ sec : codingwindow ] , i.e. , . over a finite time horizon ,",
    "intrasession coding can also be suboptimal for this erasure model ; the illustrating example from section  [ sec : codingwindow ] applies here as well .",
    "surprisingly , the constructed intrasession code also turns out to be asymptotically optimal over all codes ; the omission of erasure patterns in @xmath47 compared to @xmath34 has not led to an increase in the maximum achievable message size ( cf .",
    "theorem  [ thm : theorem : codingwindowoptimalcode ] ) :    [ thm : theorem : slidingwindowoptimalcode ] the code constructed in section  [ sec : codeconstruction ] is asymptotically optimal in the following sense : the code achieves a message size of @xmath42 which is equal to the asymptotic maximum achievable message size @xmath50 .",
    "proving the converse claim of this theorem requires a different approach from that of theorem  [ thm : theorem : codingwindowoptimalcode ] .",
    "when @xmath1 is a multiple of @xmath0 , we need only consider a cut - set bound corresponding to an obvious _ worst - case _ erasure pattern in which exactly @xmath33 erasures occur in every sliding window , specifically , a periodic erasure pattern with alternating intervals of @xmath33 erased time steps and unerased time steps .",
    "when @xmath1 is not a multiple of @xmath0 , no single admissible erasure pattern provides a cut - set bound that matches the constructed code ; instead , we need to combine different erasure patterns for different messages . to pick these erasure patterns ,",
    "we first choose a specific _ base _ erasure pattern  @xmath51 ( which may not be admissible in general ) with the help of lemma  [ thm : lemma : partitioncodingwindows ] .",
    "we then derive admissible erasure patterns from @xmath51 by taking its intersection with each coding window , i.e. , .",
    "these derived erasure patterns are used in the inductive computation of an upper bound for the conditional entropy @xmath52 \\,\\big|\\ , m_1^n , x_1^{(n-1)c } \\big),\\ ] ] where @xmath53 is a random variable representing the coded data transmitted at time step  @xmath2 , @xmath40 is a random variable representing message  @xmath4 , and @xmath54\\triangleq(x_t)_{t\\in a}$ ] . intuitively , this conditional entropy term expresses how much space is left in the unerased data packets of the coding window for message  @xmath6 , after encoding the first @xmath6 messages , and conditioned on the previous time steps .",
    "the nonnegativity of the conditional entropy leads us to a bound for @xmath49 that matches the message size achieved by the constructed code in the limit .",
    "for the third erasure model , we look at erasure patterns that contain erasure bursts of a limited number of time steps .",
    "consider the first @xmath6 messages , and the union of their ( overlapping ) coding windows @xmath7 .",
    "let @xmath55 be the set of erasure patterns in which each erasure burst is @xmath33 or fewer time steps in length , and consecutive bursts are separated by a gap of or more unerased time steps , i.e. , @xmath56 the objective is to construct a code that allows all @xmath6 messages to be decoded by their respective deadlines under any erasure pattern .",
    "let @xmath57 be the maximum message size that can be achieved by such a code , for a given choice of .    using the proof technique of theorem  [ thm : theorem : slidingwindowoptimalcode ]",
    ", we can show that the constructed intrasession code is asymptotically optimal when @xmath1 is a multiple of @xmath0 , or when the maximum erasure burst length  @xmath33 is sufficiently short or long :    [ thm : theorem : burstyoptimalcode ] if    1 .",
    "@xmath1 is a multiple of @xmath0 , or 2 .",
    "@xmath1 is not a multiple of @xmath0 and , or 3 .",
    "@xmath1 is not a multiple of @xmath0 and ,    then the code constructed in section  [ sec : codeconstruction ] is asymptotically optimal in the following sense : the code achieves a message size of @xmath42 which is equal to the asymptotic maximum achievable message size @xmath58 .",
    "when the maximum erasure burst length  @xmath33 takes on intermediate values , intersession coding may become necessary .",
    "we are currently studying optimal convolutional codes for this case .",
    "the first property describes when it is possible to decode each message :    [ thm : lemma : achievability ] consider the code constructed in section  [ sec : codeconstruction ] for a given choice of . if message size @xmath16 satisfies the inequality @xmath59 where is as defined in theorem  [ thm : theorem : codingwindowoptimalcode ] , then each message   can be decoded from the data at any @xmath60 time steps in its coding window @xmath3 .",
    "note that the maximum message size  @xmath16 that can be supported by the code is given by , which corresponds to the choice of .",
    "the second property describes a way of partitioning time steps into sets with certain specific properties , which are used in our specification of the worst - case erasure patterns :    [ thm : lemma : partitioncodingwindows ] consider the code constructed in section  [ sec : codeconstruction ] for a given choice of .",
    "consider the first @xmath6 messages , and the union of their ( overlapping ) coding windows @xmath7 .",
    "the set of time steps  @xmath7 can be partitioned into @xmath1 sets @xmath61 , given by @xmath62 \\big\\ { \\big(j\\,q_{d , c}+q_{i , c}\\big)c+r_{i , c } \\hspace{2.3em}\\in t_n : j\\in{{\\mathbb{z}}}^+_0 \\big\\ } \\\\",
    "\\hspace{15.5em } \\text{if } r_{i , c}>r_{d , c } , \\end{cases}\\end{aligned}\\ ] ] with the following properties :    1 .",
    "[ item : partitionproperty1 ] over the time steps in the set @xmath63 , each message is allocated @xmath29 amount of link bandwidth if , and @xmath32 amount of link bandwidth if . 2 .",
    "[ item : partitionproperty2 ] the allocated link bandwidth in @xmath63 for each message is contained within a single time step in its coding window @xmath3 ( as opposed to being spread over multiple time steps or being outside of the coding window ) .",
    "[ item : partitionproperty3 ] the total amount of link bandwidth over all time steps in @xmath63 , i.e. , @xmath64 , has the following upper bound : @xmath65 \\displaystyle \\frac{n}{q_{d , c}}+2 & \\text{if } r_{i , c}>r_{d , c}. \\end{cases}\\end{aligned}\\ ] ]     +    fig .",
    "[ fig : codepartition ] shows how the set of time steps  @xmath7 is partitioned into the @xmath1 sets @xmath61 , for two instances of @xmath66 .",
    "consider a given message   and its coding window @xmath67 at each time step  , message  @xmath4 is allocated either @xmath29 or @xmath32 amount of link bandwidth ; at all other time steps  , message  @xmath4 is allocated zero link bandwidth .",
    "let @xmath68 be the amount of link bandwidth at time step @xmath69 that is allocated to message  @xmath4 .",
    "writing @xmath2 in terms of @xmath70 and @xmath71 produces @xmath72 it follows from the code construction that the value of @xmath68 depends on @xmath71 ; specifically , two cases are possible :    if , then . since , this condition corresponds to the case where and .",
    "therefore , message  @xmath4 is allocated @xmath29 amount of link bandwidth per time step for a total of time steps in the coding window @xmath3 .    if , then . since , this condition corresponds to the case where and .",
    "therefore , message  @xmath4 is allocated @xmath32 amount of link bandwidth per time step for a total of time steps in the coding window @xmath3 .",
    "observe that @xmath73 is simply a vector containing the elements of @xmath74 sorted in ascending order .",
    "since @xmath75 it follows that over any @xmath60 time steps in the coding window @xmath3 , the total amount of link bandwidth allocated to message  @xmath4 is at least .",
    "therefore , as long as the message size  @xmath16 does not exceed , message  @xmath4 can always be decoded from the data at any @xmath60 time steps in @xmath3 .",
    "the stated partition can be constructed by assigning each time step to the set  @xmath76 , where @xmath77 q_{t , c}-{{\\left\\lfloor{\\frac{q_{t , c}}{q_{d , c}}}\\right\\rfloor}}q_{d , c } & \\text{if } r_{t , c}>r_{d , c}. \\end{cases}\\end{aligned}\\ ] ] note that index since when , and when . to prove the required code properties , we consider two separate cases :    consider the set @xmath63 for a choice of @xmath78 satisfying . since each time step",
    "can be expressed as @xmath79 it follows from the code construction that the set of active messages at each time step contains messages , and is given by @xmath80 the smallest time step in @xmath63 corresponds to the choice of , which produces and the set of active messages @xmath81 note that @xmath82 contains message  @xmath39 since , which implies that @xmath83 at the other extreme , let the largest time step in @xmath63 correspond to the choice of ; we therefore have @xmath84 and the final set of active messages @xmath85 from the first inequality of , we obtain @xmath86 where the final step follows from the fact that , which implies that @xmath87 from the second inequality of , we obtain @xmath88 where the final step follows from the fact that , which implies that @xmath89 by combining inequalities and , we arrive at @xmath90 which enables us to infer that @xmath91 contains message  @xmath6 .    for any pair of consecutive time steps , where @xmath92 we observe that the smallest message in @xmath93 is exactly one larger than the largest message in @xmath94 , i.e. , @xmath95 thus , there are no overlapping or omitted messages among the sets of active messages corresponding to @xmath63",
    ". properties  [ item : partitionproperty1 ] and [ item : partitionproperty2 ] therefore follow .",
    "the total amount of link bandwidth over all time steps in @xmath63 , i.e. , @xmath64 , can be computed by summing over the link bandwidth allocated to the @xmath6 messages , and adding the unused link bandwidth in the smallest time step ( which is allocated to nonpositive dummy messages ) and in the largest time step ( which is allocated to messages larger than @xmath6 ) ; this produces the required upper bound of property  [ item : partitionproperty3 ] .",
    "consider the set @xmath63 for a choice of @xmath78 satisfying .",
    "since each time step can be expressed as @xmath96 it follows from the code construction that the set of active messages at each time step contains @xmath21 messages , and is given by @xmath97 the smallest time step in @xmath63 corresponds to the choice of , which produces and the set of active messages @xmath98 note that @xmath82 contains message  @xmath39 since , and therefore @xmath99 at the other extreme , let the largest time step in @xmath63 correspond to the choice of ; we therefore have @xmath100 and the final set of active messages @xmath101 from the first inequality of , we obtain @xmath102 where the final step follows from the fact that , which implies that @xmath103 from the second inequality of , we obtain @xmath104 where the final step follows from the fact that , which implies that @xmath105 by combining inequalities and , we arrive at @xmath106 which enables us to infer that @xmath91 contains message  @xmath6 .    for any pair of consecutive time steps , where @xmath107 we observe that the smallest message in @xmath93 is exactly one larger than the largest message in @xmath94 , i.e. , @xmath108 thus , there are no overlapping or omitted messages among the sets of active messages corresponding to @xmath63 . properties  [ item : partitionproperty1 ] and [ item : partitionproperty2 ] therefore follow .",
    "the total amount of link bandwidth over all time steps in @xmath63 , i.e. , @xmath64 , can be computed by summing over the link bandwidth allocated to the @xmath6 messages , and adding the unused link bandwidth in the smallest time step ( which is allocated to nonpositive dummy messages ) and in the largest time step ( which is allocated to messages larger than @xmath6 ) ; this produces the required upper bound of property  [ item : partitionproperty3 ] .",
    "consider the code constructed in section  [ sec : codeconstruction ] for a given choice of . according to lemma  [ thm : lemma : achievability ] , if message size  @xmath16 satisfies the inequality @xmath109 then each message can be decoded from the data at any time steps in its coding window  @xmath3 .",
    "therefore , the code achieves a message size of , by allowing all @xmath6 messages to be decoded by their respective deadlines as long as there are @xmath33 or fewer erasures in each coding window @xmath3 , or equivalently , under any erasure pattern . to demonstrate the asymptotic optimality of the code",
    ", we will show that this message size matches the maximum achievable message size  @xmath36 in the limit , i.e. , @xmath110    to obtain an upper bound for @xmath36 , we consider the cut - set bound corresponding to a specific erasure pattern @xmath51 from @xmath34 .",
    "let be partitioned into two sets @xmath111 and @xmath112 , where @xmath113 let be defined as , where @xmath114 is the vector containing the elements of @xmath111 sorted in ascending order , and @xmath115 is the vector containing the elements of @xmath112 sorted in ascending order .",
    "define the erasure pattern as follows : @xmath116 where @xmath63 is as defined in lemma  [ thm : lemma : partitioncodingwindows ] .",
    "the erased time steps in @xmath51 have been chosen to coincide with the larger blocks allocated to each message in the constructed code . to show that @xmath51 is",
    "an admissible erasure pattern , we introduce the following lemma :      since the code constructed in section  [ sec : codeconstruction ] allocates a positive amount of link bandwidth to each message at every time step in its coding window  @xmath3 , it follows from property  [ item : partitionproperty2 ] of lemma  [ thm : lemma : partitioncodingwindows ] that for each , we have @xmath118 equation   therefore follows from the fact that @xmath61 are disjoint sets .",
    "now , consider a code that achieves the maximum message size @xmath36 .",
    "such a code must allow all @xmath6 messages to be decoded under the specific erasure pattern  @xmath51 .",
    "we therefore have the following cut - set bound for @xmath36 : @xmath120 applying the upper bounds in property  [ item : partitionproperty3 ] of lemma  [ thm : lemma : partitioncodingwindows ] , and writing the resulting expression in terms of @xmath121 produces @xmath122 since a message size of is known to be achievable ( by the constructed code ) , we have the following upper and lower bounds for @xmath36 : @xmath123 these turn out to be matching bounds in the limit as : @xmath124 we therefore have as required .",
    "consider the code constructed in section  [ sec : codeconstruction ] for a given choice of . according to lemma  [ thm : lemma : achievability ] , if message size  @xmath16 satisfies the inequality @xmath109 then each message can be decoded from the data at any time steps in its coding window  @xmath3 .",
    "therefore , the code achieves a message size of , by allowing all @xmath6 messages to be decoded by their respective deadlines as long as there are @xmath33 or fewer erasures in each coding window @xmath3 , which is indeed the case when there are @xmath33 or fewer erasures in each sliding window @xmath45 , or equivalently , under any erasure pattern . to demonstrate the asymptotic optimality of the code",
    ", we will show that this message size matches the maximum achievable message size  @xmath49 in the limit , i.e. , @xmath125 we consider two cases separately , depending on whether @xmath1 is a multiple of @xmath0 :      to obtain an upper bound for @xmath49 , we consider the cut - set bound corresponding to a specific periodic erasure pattern given by @xmath127 since @xmath51 comprises alternating intervals of @xmath33 erased time steps and unerased time steps , we have exactly @xmath33 erasures in each sliding window @xmath45 ; therefore , @xmath51 is an admissible erasure pattern , i.e. , .",
    "now , consider a code that achieves the maximum message size @xmath49 .",
    "such a code must allow all @xmath6 messages to be decoded under the specific erasure pattern  @xmath51 .",
    "we therefore have the following cut - set bound for @xmath49 : @xmath128 where @xmath129 further simplification produces @xmath130 since a message size of is known to be achievable ( by the constructed code ) , we have the following upper and lower bounds for @xmath49 : @xmath131 these turn out to be matching bounds in the limit as : @xmath132 we therefore have as required .",
    "suppose that @xmath1 is not a multiple of @xmath0 .",
    "consider a specific _ base _ erasure pattern given by @xmath116 where @xmath63 is as defined in lemma  [ thm : lemma : partitioncodingwindows ] , and is as defined in the proof of theorem  [ thm : theorem : codingwindowoptimalcode ] .",
    "the erased time steps in @xmath51 have been chosen to coincide with the larger blocks allocated to each message in the constructed code . from @xmath51",
    ", we derive the erasure patterns @xmath133 given by @xmath134 applying lemma  [ thm : lemmma : tnwkintersection ] with produces @xmath135 which implies that @xmath136 for each .",
    "thus , @xmath137 is an admissible erasure pattern , i.e. , , for each .",
    "[ thm : lemma : entropybound ] suppose that a code achieves a message size of @xmath16 under a given set of erasure patterns  @xmath138 for a given choice of .",
    "let @xmath53 be a random variable representing the coded data transmitted at time step , let @xmath40 be a random variable representing message , and define . if is such that is an admissible erasure pattern , i.e. , , for each , then for each , @xmath139 \\,\\big|\\ , m_1^k , x_1^{(k-1)c } \\big ) \\leq \\big|t_k\\backslash e\\big|-k\\,s .",
    "\\label{eq : entropybound}\\end{aligned}\\ ] ]      ( base case ) consider the case of . from the definition of mutual information ,",
    "we have @xmath140\\,;\\,m_1\\big ) & = h\\big(x[w_1\\backslash e]\\big ) - h\\big(x[w_1\\backslash e]\\,\\big|\\,m_1\\big ) \\\\ & = h\\big(m_1\\big ) -",
    "h\\big(m_1\\,\\big|\\,x[w_1\\backslash e]\\big).\\end{aligned}\\ ] ] rearranging terms produces @xmath141\\,\\big|\\,m_1\\big ) & = h\\big(x[w_1\\backslash e]\\big ) - h\\big(m_1\\big ) \\notag \\\\ * & \\hspace{1.2em } + h\\big(m_1\\,\\big|\\,x[w_1\\backslash e]\\big ) .",
    "\\label{eq : hxw1em1}\\end{aligned}\\ ] ] since and for any @xmath2 because of the unit link bandwidth , we have @xmath141\\big ) = h\\big(x[t_1\\backslash e]\\big ) \\leq",
    "\\big|t_1\\backslash e\\big| .",
    "\\label{eq : hxw1e}\\end{aligned}\\ ] ] furthermore , since is an admissible erasure pattern , message  @xmath39 must be decodable from the coded data at time steps @xmath37 @xmath37 , and so @xmath142\\big ) = 0 .",
    "\\label{eq : hm1}\\end{aligned}\\ ] ] substituting , , and into yields @xmath143\\,\\big|\\,m_1\\big ) \\leq \\big|t_1\\backslash e\\big|-s,\\ ] ] as required .",
    "( inductive step ) suppose that @xmath139 \\,\\big|\\ , m_1^k , x_1^{(k-1)c } \\big ) \\leq \\big|t_k\\backslash e\\big|-k\\,s \\label{eq : hxwkeinductivehypothesis}\\end{aligned}\\ ] ] for some . from the definition of conditional mutual information",
    ", we have @xmath144\\,;\\ , m_{k+1}\\,\\big|\\,m_1^k , x_1^{kc}\\big ) \\\\ & = h\\big(x[w_{k+1}\\backslash e]\\,\\big|\\ , m_1^k , x_1^{kc}\\big ) \\\\ * & \\hspace{3em } - h\\big(x[w_{k+1}\\backslash e]\\,\\big|\\ , m_1^{k+1},x_1^{kc}\\big ) \\\\ & = h\\big(m_{k+1}\\,\\big|\\ , m_1^k , x_1^{kc}\\big ) \\\\ * & \\hspace{3em } - h\\big(m_{k+1}\\,\\big|\\ , m_1^k , x[\\{1,\\ldots , kc\\ } \\cup ( w_{k+1}\\backslash e)]\\big).\\end{aligned}\\ ] ] rearranging terms produces @xmath145\\,\\big|\\ , m_1^{k+1},x_1^{kc}\\big ) \\notag \\\\ & = h\\big(x[w_{k+1}\\backslash e]\\,\\big|\\ , m_1^k , x_1^{kc}\\big ) \\notag \\\\ * & \\hspace{2em } - h\\big(m_{k+1}\\,\\big|\\ , m_1^k , x_1^{kc}\\big ) \\notag \\\\ * & \\hspace{2em } + h\\big(m_{k+1}\\,\\big|\\ , m_1^k , x[\\{1,\\ldots , kc\\}\\cup(w_{k+1}\\backslash e)]\\big ) .",
    "\\label{eq : hxwk1ek1}\\end{aligned}\\ ] ] since messages are independent and message is created at time step , we have @xmath146 furthermore , since is an admissible erasure pattern , message must be decodable from the coded data at time steps @xmath37 @xmath37 , and so @xmath147\\big ) = 0 .",
    "\\label{eq : hmk1m1kx}\\end{aligned}\\ ] ] substituting and into yields @xmath145\\,\\big|\\ , m_1^{k+1},x_1^{kc}\\big ) \\notag \\\\ & = h\\big(x[w_{k+1}\\backslash e]\\,\\big|\\ , m_1^k , x_1^{kc}\\big ) - s \\notag \\\\ & \\overset{\\text{(a)}}{\\leq } h\\big(x\\big[(w_k\\backslash e)\\cup ( w_{k+1}\\backslash e)\\big]\\,\\big|\\ , m_1^k , x_1^{kc}\\big ) - s \\notag \\\\ & \\overset{\\text{(b)}}{\\leq } h\\big(x\\big[(w_k\\backslash e)\\cup ( w_{k+1}\\backslash e)\\big]\\,\\big|\\ , m_1^k , x_1^{(k-1)c}\\big ) - s \\notag \\\\ &",
    "\\overset{\\text{(c)}}{\\leq } h\\big(x[w_k\\backslash e]\\,\\big|\\ , m_1^k , x_1^{(k-1)c}\\big ) \\notag \\\\ * & \\hspace{1.5em } + h\\big(x\\big[(w_{k+1}\\backslash e ) \\big\\backslash(w_k\\backslash e)\\big]\\,\\big ) - s \\notag \\\\ & \\overset{\\text{(d)}}{\\leq } \\big|t_k\\backslash e\\big|-k\\,s + \\big|(w_{k+1}\\backslash e)\\big\\backslash ( w_k\\backslash e)\\big| - s \\notag \\\\ & \\overset{\\text{(e)}}{= } \\big|t_{k+1}\\backslash e\\big|-(k+1)s , \\notag\\end{aligned}\\ ] ] as required , where    * follows from the addition of random variables in the entropy term ; * follows from the removal of conditioned random variables in the entropy term ; * follows from the chain rule for joint entropy , and the removal of conditioned random variables , , and in the second entropy term ; * follows from the inductive hypothesis  , and the fact that for any @xmath2 because of the unit link bandwidth ; * follows from the fact that @xmath148    applying lemma  [ thm : lemma : entropybound ] with and to an optimal code that achieves a message size of @xmath49 produces @xmath149 \\,\\big|\\ , m_1^k , x_1^{(k-1)c } \\big ) \\leq \\big|t_k\\backslash e'\\big|-k\\,s_n^{{\\textup{\\textsf{\\tiny{sw}}}}}\\ ] ] for any .",
    "since the conditional entropy term is nonnegative , it follows that for the choice of , we have @xmath150 applying the upper bounds in property  [ item : partitionproperty3 ] of lemma  [ thm : lemma : partitioncodingwindows ] , and writing the resulting expression in terms of @xmath121 produces @xmath151 since a message size of is known to be achievable ( by the constructed code ) , we have the following upper and lower bounds for @xmath49 : @xmath152 these turn out to be matching bounds in the limit as : @xmath153 we therefore have as required .    observe that under each erasure pattern , the coding window  @xmath3 for each message contains at most @xmath33 erasures : if @xmath3 intersects with zero erasure bursts , then it contains zero erasures ; if @xmath3 intersects with exactly one erasure burst , then it contains at most @xmath33 erasures , i.e. , the maximum length of a burst ; if @xmath3 intersects with two or more erasure bursts , then it contains a gap of at least unerased time steps between consecutive bursts , and therefore contains at most @xmath33 erasures .    consider the code constructed in section  [ sec : codeconstruction ] for a given choice of . according to lemma  [ thm : lemma : achievability ] ,",
    "if message size  @xmath16 satisfies the inequality @xmath109 then each message can be decoded from the data at any time steps in its coding window  @xmath3 .",
    "therefore , the code achieves a message size of , by allowing all @xmath6 messages to be decoded by their respective deadlines as long as there are @xmath33 or fewer erasures in each coding window @xmath3 , which is indeed the case under any erasure pattern . to demonstrate the asymptotic optimality of the code",
    ", we will show that this message size matches the maximum achievable message size  @xmath57 in the limit , i.e. , @xmath154 for the following three cases :    suppose that @xmath1 is a multiple of @xmath0 . in this case ,",
    "the message size achieved by the constructed code simplifies to @xmath126 to obtain an upper bound for @xmath57 , we consider the cut - set bound corresponding to a specific periodic erasure pattern given by @xmath127 since @xmath51 comprises alternating intervals of @xmath33 erased time steps and unerased time steps , it is an admissible erasure pattern , i.e. , .",
    "suppose that @xmath1 is not a multiple of @xmath0 , and . in this case , the message size achieved by the constructed code simplifies to @xmath155 consider a specific _ base _ erasure pattern given by @xmath116 where @xmath63 is as defined in lemma  [ thm : lemma : partitioncodingwindows ] , and is as defined in the proof of theorem  [ thm : theorem : codingwindowoptimalcode ] .",
    "the erased time steps in @xmath51 have been chosen to coincide with the larger blocks allocated to each message in the constructed code . in this case , @xmath51 simplifies to @xmath156 & \\hspace{7.3em } j\\in{{\\mathbb{z}}}^+_0 , r_{i , c}\\in\\{c - z+1,\\ldots , c\\ } \\big\\},\\end{aligned}\\ ] ] which follows from the definition of @xmath63 and the fact that when .",
    "observe that @xmath51 comprises alternating intervals of @xmath33 erased time steps and unerased time steps , with each interval of erased time steps corresponding to a specific choice of .",
    "since each erased time step can be expressed as @xmath157 it follows from section  [ sec : codeconstruction ] that the set of active messages @xmath17 at time step  @xmath2 is given by @xmath158 therefore , the set of active messages @xmath17 is the same at every time step  @xmath2 in a given interval of @xmath33 erased time steps ( corresponding to a specific @xmath159 ) .    from @xmath51",
    ", we derive the erasure patterns @xmath133 given by @xmath134 applying lemma  [ thm : lemmma : tnwkintersection ] with produces @xmath160 let be one of the @xmath33 erased time steps in @xmath3 under erasure pattern  @xmath137 . as previously established , @xmath161 belongs to an interval of @xmath33 erased time steps in @xmath51 that have the same set of active messages @xmath162 ( which contains message  @xmath4 ) .",
    "it follows that this interval of @xmath33 erased time steps is also in @xmath137 , and must therefore constitute @xmath137 itself .",
    "thus , @xmath137 is an admissible erasure pattern , i.e. , , for each , because it comprises a single erasure burst of @xmath33 time steps .    applying lemma  [ thm : lemma : entropybound ] with and to an optimal code that achieves a message size of @xmath57 produces @xmath149 \\,\\big|\\ , m_1^k , x_1^{(k-1)c } \\big ) \\leq \\big|t_k\\backslash e'\\big|-k\\,s_n^{{\\textup{\\textsf{\\tiny{b}}}}}\\ ] ] for any .",
    "since the conditional entropy term is nonnegative , it follows that for the choice of , we have @xmath163 the rest of the proof leading to the obtainment of is the same as that of case  2 in the proof of theorem  [ thm : theorem : slidingwindowoptimalcode ] , with @xmath49 replaced by @xmath57 .",
    "suppose that @xmath1 is not a multiple of @xmath0 , and . in this case ,",
    "the message size achieved by the constructed code simplifies to @xmath164 consider a specific _ base _ erasure pattern given by @xmath116 where @xmath63 is as defined in lemma  [ thm : lemma : partitioncodingwindows ] , and is as defined in the proof of theorem  [ thm : theorem : codingwindowoptimalcode ] . the erased time steps in @xmath51 have been chosen to coincide with the larger blocks allocated to each message in the constructed code . in this case",
    ", @xmath51 simplifies to @xmath165 & \\hspace{7.8em } j\\in{{\\mathbb{z}}}^+_0 , r_{i , c}\\in\\{1,\\ldots , d - z\\ } \\big\\},\\end{aligned}\\ ] ] which follows from the definition of @xmath63 and the fact that when .",
    "observe that @xmath51 comprises alternating intervals of unerased time steps and @xmath37 erased time steps , with each interval of unerased time steps corresponding to a specific choice of .",
    "since each unerased time step can be expressed as @xmath166 it follows from section  [ sec : codeconstruction ] that the set of active messages @xmath17 at time step  @xmath2 is given by @xmath167 therefore , the set of active messages @xmath17 is the same at every time step  @xmath2 in a given interval of unerased time steps ( corresponding to a specific @xmath159 ) .    from @xmath51",
    ", we derive the erasure patterns @xmath133 given by @xmath134 applying lemma  [ thm : lemmma : tnwkintersection ] with produces @xmath160 let be one of the unerased time steps in @xmath3 under erasure pattern  @xmath137 .",
    "as previously established , @xmath161 belongs to an interval of unerased time steps in that have the same set of active messages @xmath162 ( which contains message  @xmath4 ) .",
    "it follows that this interval of unerased time steps is also in , and must therefore constitute itself .",
    "thus , @xmath137 is an admissible erasure pattern , i.e. , , for each , because it comprises either a single erasure burst of @xmath33 time steps , or two erasure bursts with a combined length of @xmath33 time steps separated by a gap of unerased time steps .",
    "applying lemma  [ thm : lemma : entropybound ] with and to an optimal code that achieves a message size of @xmath57 produces @xmath149 \\,\\big|\\ , m_1^k , x_1^{(k-1)c } \\big ) \\leq \\big|t_k\\backslash e'\\big|-k\\,s_n^{{\\textup{\\textsf{\\tiny{b}}}}}\\ ] ] for any .",
    "since the conditional entropy term is nonnegative , it follows that for the choice of , we have @xmath163 the rest of the proof leading to the obtainment of is the same as that of case  2 in the proof of theorem  [ thm : theorem : slidingwindowoptimalcode ] , with @xmath49 replaced by @xmath57 ."
  ],
  "abstract_text": [
    "<S> we consider a real - time streaming system where messages are created sequentially at the source , and are encoded for transmission to the receiver over a packet erasure link . </S>",
    "<S> each message must subsequently be decoded at the receiver within a given delay from its creation time . </S>",
    "<S> the goal is to construct an erasure correction code that achieves the maximum message size when all messages must be decoded by their respective deadlines under a specified set of erasure patterns ( erasure model ) . </S>",
    "<S> we present an explicit intrasession code construction that is asymptotically optimal under erasure models containing a limited number of erasures per coding window , per sliding window , and containing erasure bursts of a limited length . </S>"
  ]
}