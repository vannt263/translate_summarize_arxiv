{
  "article_text": [
    "* the background and the problem . * broadcasting and gossiping are fundamental communication tasks in networks . in broadcasting ,",
    "one node of a network , called the _ source _ , has a message that must be learned by all other nodes . in gossiping",
    ", every node has a ( possibly different ) input message , and all messages must be learned by all nodes .",
    "we study these well - researched tasks in a very weak communication model , called the _ beeping model_. communication proceeds in synchronous rounds . in each round",
    ", a node can either listen , i.e. , stay silent , or beep , i.e. , emit a signal .",
    "a node hears a beep in a round , if it listens in this round and if one or more adjacent nodes beep in this round .",
    "the beeping model has been introduced in @xcite for vertex coloring and used in @xcite to solve the mis problem .",
    "the beeping model is widely applicable , as it makes small demands on communicating devices , relying only on carrier sensing .",
    "in fact , as mentioned in @xcite , beeps are an even weaker way of communicating than using one - bit messages , as the latter ones allow three different states ( 0,1 and no message ) , while beeps permit to differentiate only between a signal and its absence .",
    "the network is modeled as a simple connected undirected graph .",
    "initially all nodes are dormant .",
    "the adversary wakes up the source in the case of broadcasting and some nonempty subset of nodes , at possibly different times , in the case of gossiping .",
    "a woken up node starts executing the algorithm .",
    "a dormant node is woken up by a beep of any neighbor .",
    "our aim is to provide fast deterministic algorithms for broadcasting and gossiping in the beeping model .",
    "the time of broadcasting is defined as the number of rounds between the wakeup of the source and the round in which all nodes of the network acquire the source message .",
    "the time of gossiping is defined as the number of rounds between the wakeup of the first node and the round in which all nodes acquire all messages .",
    "messages are considered as binary strings and the size of a message is the length of this string . in the case of broadcasting ,",
    "our algorithm does not assume any information about the network , and it does not require any labeling of nodes . in the case of gossiping , we assume that all nodes have different labels from the set @xmath0 and that they know @xmath7 .",
    "moreover , we assume that all nodes know the same upper bound @xmath1 on the size of the network and the same upper bound @xmath4 on the size of all input messages . without loss of generality",
    "we may assume that @xmath8 .",
    "indeed , the parameter @xmath7 known to nodes is an upper bound on the size of the network , as all nodes have different labels .",
    "let @xmath2 be the diameter of the network , initially unknown to the nodes .",
    "* our results .",
    "* for the task of broadcasting we give an algorithm working in time @xmath5 for arbitrary networks , where @xmath3 is the size of the source message .",
    "this complexity is optimal .",
    "for the task of gossiping we give an algorithm working in time @xmath6 for arbitrary networks .    due to space restrictions",
    "several proofs are moved to the appendix",
    ".    * related work . * broadcasting and gossiping have been studied in various models for over four decades .",
    "early work focused on the telephone model , where in each round communication proceeds between pairs of nodes forming a matching , and nodes that communicate exchange all previously acquired information .",
    "deterministic broadcasting in this model has been studied , e.g. , in @xcite and deterministic gossiping in @xcite . in @xcite",
    "the authors studied randomized broadcasting . in the telephone model studies focused on the time of the communication task and on the number of messages it uses .",
    "early literature on communication in the telephone and related models is surveyed in @xcite .",
    "fault tolerant aspects of broadcasting and gossiping are surveyed in @xcite .    more recently , broadcasting and gossiping have been studied in the radio model .",
    "while radio networks model wireless communication , similarly as the beeping model , in radio networks nodes send entire messages of some bounded , or even unbounded size in a single round , which makes communication drastically different from that in the beeping model .",
    "the focus in the literature on radio networks was usually on the time of communication .",
    "deterministic broadcasting in the radio model was studied , e.g. , in @xcite and deterministic gossiping in @xcite .",
    "randomized broadcasting was studied in @xcite and randomized gossiping in @xcite .",
    "the book @xcite is devoted to algorithmic aspects of communication in radio networks .",
    "randomized leader election in the radio and in the beeping model was studied in @xcite .",
    "deterministic leader election in the beeping model was studied in @xcite .",
    "the authors showed an algorithm working in time @xmath9 in networks of diameter @xmath2 with labels polynomial in the size @xmath10 of the network .",
    "in this section we consider the simpler of our two communication tasks , that of broadcasting .",
    "even for this easier task , the restrictions of the beeping model require the solution of the basic problem of detecting the beginning and the end of the transmitted message . the naive idea would be to adapt the method of beeping waves , used in @xcite in a different context , and transmit a message by coding bit 1 by a beep and bit 0 by silence , other nodes relaying these signals after getting them .",
    "however , in this coding there is no difference between message @xmath11 and message @xmath12 because both these messages are coded by a single beep .",
    "hence we need to reserve some sequence of beeps to mark the beginning and end of a message , and code bits by some other sequences of beeps and silent rounds .",
    "one way of defining such a coding is the following .",
    "consider the message @xmath13 that has to be transmitted by some node @xmath14 .",
    "let @xmath15 denote a round in which @xmath14 beeps , and let @xmath16 denote a round in which @xmath14 is silent .",
    "the beginning and end of the message are marked by the sequence @xmath17 , bit @xmath18 is coded by @xmath19 , and bit @xmath20 is coded by @xmath21 .",
    "hence message @xmath22 is transmitted as the sequence @xmath23 , where + @xmath24 , for @xmath25 , and + @xmath26 and @xmath27 , if @xmath28 , for @xmath29 , + @xmath30 and @xmath31 , if @xmath32 , for @xmath29 .",
    "a node @xmath33 hearing the sequence @xmath23 of beeps and silent rounds can correctly decode message @xmath22 as follows . upon hearing two beeps in the first two rounds it divides the successive rounds into segments of",
    "length 2 and records all beeps and silent rounds until a segment with two consecutive beeps .",
    "each segment between the two segments @xmath17 is either of the from @xmath19 or of the form @xmath21 .",
    "the node @xmath33 decodes each segment @xmath19 as 1 and each segment @xmath21 as 0 . in this way , message @xmath22",
    "is correctly reconstructed .",
    "note that the time of transmitting this message is @xmath34 and hence linear in its size .",
    "we will call the above sequence of beeps and silent rounds , chosen by a node @xmath14 for the message @xmath22 , the _ canonical sequence _ for @xmath22 transmitted by node @xmath14 . the way of reconstructing message @xmath22 by node @xmath33",
    "is called the _ canonical decoding_. using canonical sequences we formulate our broadcasting algorithm that works for arbitrary networks .",
    "* algorithm broadcast *    let @xmath35 be the round in which the source is woken up . given a source message @xmath22",
    ", the source transmits the canonical sequence for @xmath22 in rounds @xmath36 , for @xmath37 , and stops . more precisely , if @xmath38 , then the source beeps in round @xmath36 , and if @xmath39 , then the source is silent in this round . in all other rounds the source is silent .",
    "every other node @xmath33 that is woken up by a beep in round @xmath40 , beeps in round @xmath41 .",
    "if it hears a beep in a round @xmath42 , for some positive integer @xmath43 , it beeps in round @xmath44 . in all other rounds",
    "node @xmath33 is silent .",
    "it divides all rounds @xmath42 , for @xmath45 , into segments of length 2 .",
    "after the second segment when it hears @xmath17 , the node decodes the source message using the canonical decoding of the sequence received in rounds @xmath42 , for @xmath45 . then it beeps in the next round and stops .",
    "@xmath46    [ broad - trees ] algorithm broadcast is a correct broadcasting algorithm working in any network of diameter @xmath2 in time @xmath5 , where @xmath3 is the size of the source message .",
    "the time complexity of this algorithm is optimal .",
    "consider any network and define its @xmath47th layer as the set of nodes at distance @xmath47 from the source .",
    "consider any node @xmath33 in the @xmath47th layer of this network , other than the source , and suppose that @xmath33 is woken up in round @xmath40 .",
    "hence nodes in layer @xmath48 beep only in rounds @xmath42 , nodes in layer @xmath47 beep only in rounds @xmath44 , and nodes in layer @xmath49 beep only in rounds @xmath50 , for some integer @xmath43 .",
    "consequently , in rounds @xmath42 the node @xmath33 hears a beep in exactly these rounds in which nodes from the layer @xmath48 beep .",
    "by induction on the distance of @xmath33 from the source we get that @xmath33 gets correctly the canonical sequence for the source message and hence decodes the source message correctly . if the source is woken up in round @xmath35 and @xmath33 is at distance @xmath47 from the source , it starts receiving transmissions in round @xmath51 and stops in round @xmath52 .",
    "since @xmath53 , it follows that the algorithm works in time @xmath5 .    in order to prove that this time complexity is optimal , it is enough to show that every algorithm requires at least time @xmath54 and at least time @xmath55 .",
    "the first fact is immediate because the farthest node from the source must be at distance at least @xmath56 from it , and no signal can get to this node from the source faster than after @xmath56 rounds .",
    "the second fact holds even in the two - node network .",
    "suppose that some broadcasting algorithm transmits every message of size @xmath3 from one node of this network ( the source ) to the other , in time @xmath57 .",
    "the number of sequences of length @xmath58 with terms from the set @xmath59 is @xmath60 .",
    "since the number of possible source messages of size @xmath3 is @xmath61 , it follows that for two distinct source messages the source must behave identically , and hence the input of the other node is identical .",
    "hence the other node must decode the same message in both cases , which contradicts the correctness of the algorithm . @xmath62",
    "in this section we investigate the more complex task of gossiping . one way to accomplish",
    "this task is to have each node broadcast its input message .",
    "however , in the highly contrived beeping model , periods of broadcasting by different nodes should be disjoint , otherwise messages , transmitted as series of beeps and silent rounds , risk to become damaged , when a node receives simultaneously a beep being part of the transmission of one message and should hear a silent round being part of the transmission of another message .",
    "the receiving node will then just hear the beep and the transmission of the message requiring this round to be silent becomes scrambled .    in order to broadcast in disjoint time intervals",
    ", nodes must establish an order between them and reserve the @xmath47th time interval to the broadcast of the @xmath47th node in this order .",
    "this yields the following high - level idea of a gossiping algorithm .",
    "first we establish a procedure that finds the node with the largest label .",
    "this is done in such a way that all nodes learn the largest label .",
    "( notice that we can not use the leader election algorithm from @xcite because this algorithm works only under an additional strong assumption that all nodes that are woken by the adversary  and not by hearing a beep  are woken simultaneously in the first round of the algorithm execution . ) next , using this elected leader , all nodes are synchronized : they agree on a common round , and hence can simultaneously start the rest of the algorithm execution .",
    "then the procedure of finding the largest - labeled node is repeated at most @xmath1 times , where @xmath1 is an upper bound on the size of the network , each time the currently found largest - labeled node withdrawing from the competition . in this way , after at most @xmath1 repetitions all nodes know the order between them , and subsequently they broadcast their values in disjoint time intervals , in this order .",
    "we assume that all nodes know the size @xmath7 of the label space .",
    "let @xmath63 and let @xmath64 be the binary representation of the integer @xmath65 .",
    "we assume that all sequences @xmath64 are of length @xmath66 , the representations being padded by a prefix of 0 s , if necessary .",
    "hence the representation of a smaller integer is lexicographically smaller than the representation of a larger integer .",
    "we also assume that all nodes know a common upper bound @xmath1 on the number of nodes in the network .",
    "our first procedure finds the largest label among a set @xmath67 called the set of _ participating nodes_.    * procedure find max *    when a node is woken up in round @xmath68 , either by the adversary or by a beep , it defines the following round numbers : @xmath69 , for @xmath70 .",
    "then , for @xmath71 , the node defines the time interval @xmath72 $ ] .",
    "note that these intervals are pairwise disjoint .",
    "the node beeps in round @xmath73 .",
    "the rest of the procedure is divided into @xmath66 stages , corresponding to time intervals @xmath74 , for @xmath71 .",
    "first assume that the node is participating .",
    "let @xmath75 be the binary representation of the node s label , of length @xmath66 .",
    "in the beginning of the first stage the node is _",
    "active_.    if the node is still active at the beginning of the @xmath43th stage , then it behaves as follows .",
    "if @xmath76 , the node listens in all rounds of the time interval @xmath74 until it hears a beep . if it does not hear any beep , it remains active and proceeds to stage @xmath77 .",
    "if it hears a beep for the first time in some round @xmath35 , then it beeps in round @xmath78 and becomes non - active .",
    "if @xmath79 , the node listens until it hears a beep or until round @xmath80 , whichever comes earlier .",
    "if it hears a beep in some round @xmath81 , it beeps in round @xmath78 , listens till the end of time interval @xmath74 and remains active .",
    "otherwise , it beeps in round @xmath80 , listens till the end of time interval @xmath74 and remains active .",
    "if the node is non - active at the beginning of the @xmath43th stage , then it listens in all rounds of the time interval @xmath74 until it hears a beep .",
    "if it does not hear any beep , it remains non - active and proceeds to stage @xmath77 .",
    "if it hears a beep for the first time in some round @xmath35 , then it beeps in round @xmath78 , listens till the end of time interval @xmath74 and remains non - active .",
    "a non - participating node is never active .",
    "it listens in all rounds of the time interval @xmath74 until it hears a beep .",
    "if it does not hear any beep , it remains non - participating and proceeds to stage @xmath77 .",
    "if it hears a beep for the first time in some round @xmath35 , then it beeps in round @xmath78 , listens till the end of the stage and remains non - participating .    at the end of stage @xmath66 ,",
    "the ( unique ) participating node that remained active till the end of this stage is the node with the largest label among participating nodes .",
    "@xmath46    [ find - max ] at the end of the execution of procedure find max , there is exactly one active participating node .",
    "this node has the largest label among participating nodes .",
    "all nodes know the label of this node .",
    "procedure find max takes time @xmath82 .",
    "the goal of our next procedure is synchronizing all processors .",
    "the procedure will be used upon completion of procedure find max , and hence we assume that the largest label is known to all nodes .",
    "let @xmath83 be the node with the largest label . upon completion of procedure synchronization",
    ", each node declares a specific round to be _ red _ , and this round is the same for all nodes .    *",
    "procedure synchronization *    each node other than @xmath83 has an integer variable @xmath84 initially set to 0 .",
    "let @xmath85 .",
    "for every integer @xmath86 , let @xmath87 be the binary representation of @xmath47 of length @xmath88 , padded by a prefix of 0 s , if necessary .",
    "a string @xmath87 will be transmitted by nodes of the network , using the canonical sequence , as it was done for broadcasting in section 2 .",
    "we briefly recall this coding .",
    "let @xmath15 denote a round in which @xmath14 beeps , and let @xmath16 denote a round in which @xmath14 is silent .",
    "in @xmath89 rounds , node @xmath14 transmits the following message @xmath90 . the beginning and end of the message",
    "are marked by the sequence @xmath17 , every bit @xmath18 of @xmath87 is coded by @xmath19 , and every bit @xmath20 of @xmath87 is coded by  @xmath21 .    at the beginning of the procedure node @xmath83",
    "transmits @xmath91 starting in round @xmath78 , where @xmath35 is the round in which @xmath83 completed the execution of procedure find max . after completing this transmission",
    ", node @xmath83 waits till round @xmath92 and declares it to be _",
    "red_. every node other than @xmath83 that is at @xmath84 0 waits until it hears two consecutive beeps .",
    "then it partitions the following rounds into consecutive segments of length 2 , and decodes each segment of the form @xmath19 as 1 and each segment of the form @xmath21 as 0 .",
    "as soon as it hears a segment @xmath93 consisting of two beeps , it considers the previously decoded string of bits as the binary representation of an integer @xmath43 .",
    "it changes the value of its variable @xmath84 to @xmath77 , transmits @xmath94 in @xmath89 rounds , starting in the round @xmath40 following the segment @xmath93 , then waits till round @xmath95 and declares it to be _",
    "red_. @xmath46    [ synch ] all nodes declare the same round to be _",
    "red_. procedure synchronization takes time @xmath96 .",
    "we prove the following invariant by induction on @xmath97 .    1 .   in time interval",
    "@xmath98 $ ] the only message transmitted is @xmath99 and it is transmitted by all nodes at distance @xmath97 from node @xmath83 and only by these nodes ; 2 .",
    "a node at distance @xmath97 from the node @xmath83 declares round @xmath92 as _",
    "red_.    the invariant is clearly satisfied for @xmath100 .",
    "suppose that it holds for some @xmath101 .",
    "the only nodes that hear the beeps transmitted in time interval @xmath98 $ ] are those at distance at most @xmath102 from node @xmath83 .",
    "the only nodes among them that have value of @xmath84 0 are nodes at distance exactly @xmath102 from node @xmath83 .",
    "since all the nodes at distance @xmath97 from @xmath83 transmit the same message @xmath99 in this time interval , they all beep exactly in the same rounds of the interval .",
    "hence the value of @xmath97 is correctly decoded by all nodes at distance @xmath102 from node @xmath83 .",
    "these nodes , and only these nodes , transmit @xmath103 in the time interval @xmath104 $ ] .",
    "this proves the first part of the invariant .",
    "all these nodes set their value of @xmath84 to @xmath102 and declare as _ red _ the round @xmath105 , where @xmath40 is the last round of the preceding time interval , i.e. , @xmath106 .",
    "hence the declared round is @xmath107 , which proves the second part of the invariant .",
    "this implies , in particular , that part 2 of the invariant is true for nodes at any distance @xmath97 from node @xmath83 , and hence all nodes of the network declare the same round as _",
    "red_.    since there are at most @xmath1 time intervals used in the procedure and each of them has length @xmath108 , the entire procedure takes time @xmath96 .",
    "@xmath62    as we mentioned at the beginning of this section , we want to use our broadcasting algorithm many times , each time starting from a different node . in order to take advantage of the efficiency of broadcasting , which depends on the diameter and not on the size of the network , all nodes need to have a linear upper bound on the diameter of the network .",
    "note , that in order to accomplish one execution of this algorithm , from one source node , no such upper bound was needed .",
    "it becomes needed for multiple broadcasts , as we want to execute each of them in a separate time interval , and thus we need a good estimate of the time of each execution . recall , that we assume knowledge of a bound @xmath1 on the size of the network but no knowledge of any such bound on the diameter .",
    "clearly @xmath1 is an upper bound on the diameter as well , but may be vastly larger than the diameter .",
    "the following procedure is devoted to obtaining a linear upper bound on the diameter @xmath2 of a network .",
    "it will be executed after the execution of procedure find max and procedure synchronization .",
    "hence we may assume that the largest of all labels is known to all nodes .",
    "let @xmath83 be the node with this label .",
    "we may also assume that all nodes declared the same round @xmath40 as _ red_. moreover , each node other than @xmath83 has its variable @xmath84 set to its distance from @xmath83 ( this is done in procedure synchronization ) .",
    "* procedure diameter estimation *    each node defines consecutive time intervals @xmath109 $ ] , for positive integers @xmath43 . in time interval @xmath110 each node at level @xmath111 beeps in round @xmath111 of this interval . for @xmath112 ,",
    "if a node at @xmath84 @xmath111 heard a beep in round @xmath113 of interval @xmath114 , then it beeps in round @xmath111 of interval @xmath115 . in the first round @xmath16 of the form @xmath116",
    "in which @xmath83 does not hear a beep , it sets @xmath117 .",
    "let @xmath22 be the binary representation of the integer @xmath118 and let @xmath3 be the size of message @xmath22 .",
    "all nodes execute algorithm broadcast with node @xmath83 as the source and message @xmath22 as the source message . in this execution",
    "the role of round @xmath35 in which @xmath83 is woken up is played by round @xmath119 .",
    "every node decodes the integer @xmath120 as an upper bound on the diameter @xmath2 of the network .",
    "all nodes declare round @xmath121 as _ blue_. @xmath46    [ diamest ] upon completion of procedure diameter estimation all nodes have the same linear upper bound @xmath122 on the diameter of the graph .",
    "they all declare the same round as _ blue _ , and procedure diameter estimation is completed by this round .",
    "procedure diameter estimation takes time @xmath123 .",
    "if nodes know a linear upper bound @xmath122 on the diameter of the network , procedure find max can be modified to work faster .",
    "the modifications are detailed below .",
    "* procedure modified find max *    in procedure find max replace the wakeup round @xmath68 by some round @xmath124 , given as input in its call .",
    "round @xmath125 will be called the _ starting round _ of the procedure .",
    "let @xmath126 instead of @xmath69 , for @xmath70 .",
    "let @xmath127 $ ] instead of @xmath72 $ ] , for @xmath71 .",
    "the rest of procedure find max remains unchanged .",
    "@xmath46    the proof of the following proposition is the same as that of lemma [ find - max ] , using the above modifications .",
    "[ prop1 ] at the end of the execution of procedure modified find max , there is exactly one active participating node .",
    "this node has the largest label among participating nodes .",
    "all nodes know the label of this node .",
    "procedure modified find max takes time @xmath128 .",
    "using procedure modified find max we now establish the order between all nodes as follows . the procedure will be called after the execution of procedure find max , procedure synchronization and procedure diameter estimation .",
    "hence we assume that @xmath83 is the node with the largest label , found by procedure find max , and that @xmath15 is the common _ blue _ round found by all nodes in procedure diameter estimation .",
    "all nodes start procedure ordering in round @xmath129 .",
    "let @xmath130 be an upper bound on the duration of procedure modified find max , established in proposition [ prop1 ] .",
    "* procedure ordering *    @xmath131 the set of all nodes except node @xmath83",
    "node @xmath83 assigns itself rank 0    * for * @xmath132 * to * @xmath1 * do * + execute procedure modified find max in the time interval + @xmath133 $ ] , with the set @xmath134 of participating nodes ; + the node found in the current execution of procedure modified find max + removes itself from @xmath134 and assigns itself @xmath135 .",
    "@xmath46    [ ranks ] ranks assigned to nodes in the execution of procedure ordering define a strictly decreasing function of the node labels .",
    "procedure ordering is completed in round @xmath136 and takes time @xmath137 .",
    "since after each execution of procedure modified find max , the node with the largest label among participating nodes is found , and this node stops participating in the following executions , the rank assigned to the @xmath43th largest node is @xmath138 .",
    "since there are @xmath1 time intervals , each of length @xmath139 , the time estimate follows .",
    "@xmath62    we are now ready to formulate a gossiping algorithm working for arbitrary networks .",
    "let @xmath4 be the upper bound on the size of all input messages , known to all nodes .",
    "let @xmath140 be the upper bound on the duration of algorithm broadcast established in theorem [ broad - trees ] , for the value @xmath122 of the diameter and for the size @xmath4 of the message .",
    "* algorithm gossiping *    1 .",
    "execute procedure find max ; let @xmath83 be the node with the largest label ; 2 .",
    "execute procedure synchronization ; let @xmath40 be the _ red _ round found in this procedure ; 3 .",
    "execute procedure diameter estimation starting in round @xmath41 ; let @xmath122 be the upper bound on the diameter of the network found in this procedure ; let @xmath15 be the _ blue _ round found in procedure diameter estimation ; 4 .",
    "execute procedure ordering starting in round @xmath129 ; 5 .",
    "let @xmath74 be the time interval @xmath141 $ ] ; 6 .   in time",
    "interval @xmath74 execute algorithm broadcast with node of rank @xmath43 , found in procedure ordering , as the source , and the input message of this node as the source message .",
    "( for each @xmath43 , the role of the round @xmath35 when the source is woken up is played by the first round of interval @xmath74 . ) @xmath46    * remark . *",
    "note that , in the first step of the algorithm , we have to use procedure find max instead of the more efficient procedure modified find max because at this point the only estimate on the diameter , known to nodes , is @xmath142 .",
    "however , since this procedure is executed only once , it does not increase the time complexity of the entire algorithm .",
    "algorithm gossiping is a correct gossiping algorithm working in any network of diameter @xmath2 with at most @xmath1 nodes in time @xmath6 , where @xmath4 is an upper bound on the size of all input messages , known to all nodes .    by lemma [ find - max ] ,",
    "procedure find max correctly finds the node @xmath83 with the largest label . by lemma [ synch",
    "] , all nodes compute the same round @xmath40 , and hence start procedure diameter estimation in the same round @xmath41 . by lemma",
    "[ ranks ] , there is at most one node with any rank @xmath143 . by lemma [ diamest ]",
    ", @xmath122 is a linear upper bound on the diameter of the network .",
    "hence , in view of theorem [ broad - trees ] , the upper bound @xmath144 is indeed an upper bound on the time of execution of algorithm broadcast starting from any source node .",
    "this implies that all nodes broadcast their messages in pairwise disjoint time intervals , and hence all broadcasts are correct , in view of theorem [ broad - trees ] .",
    "this proves the correctness of algorithm gossiping .",
    "it remains to estimate the execution time of the algorithm .",
    "procedure find max takes time @xmath82 .",
    "procedure synchronization takes time @xmath96 .",
    "procedure diameter estimation takes time @xmath145 .",
    "procedure ordering takes time @xmath137 . at most @xmath1 executions of algorithm broadcast in step 6 of algorithm gossiping",
    "take time @xmath146 .",
    "hence algorithm gossiping takes time @xmath6 .",
    "@xmath62    we conclude with the following lower bound on the time of gossiping that holds even for the class of trees of bounded diameter .",
    "[ lb ] assume that all input messages have size @xmath147 for some constant @xmath148 .",
    "then there exist bounded diameter trees of size @xmath149 for which every gossiping algorithm takes time @xmath150 .",
    "we considered two basic communication tasks , broadcasting and gossiping , in the arguably weakest communication model , in which in every round each node has only the choice to beep or to listen .",
    "for the task of broadcasting , we proposed an optimal algorithm working in time @xmath5 for arbitrary networks of diameter @xmath2 , where @xmath3 is the message size .",
    "for the task of gossiping , we presented an algorithm working in time @xmath6 for arbitrary networks of diameter @xmath2 with at most @xmath1 nodes . here",
    "@xmath4 denotes an upper bound on the size of all input messages , known to all nodes .",
    "it remains open if this complexity can be improved in general .",
    "note however , that our gossiping algorithm has optimal time for networks of diameter bounded by a constant , if the following two assumptions are satisfied : the size of all input messages is the same , it is known to all nodes , and satisfies @xmath147 for some constant @xmath148 , and the size @xmath7 of the label space is polynomial in @xmath1 . indeed , in this case @xmath151 and @xmath152 . since for bounded @xmath2 , we have @xmath153 , algorithm gossiping works in time @xmath154 in this case , which matches the lower bound @xmath150 , shown in proposition [ lb ] .",
    "the two above assumptions do not seem to be overly strong .",
    "indeed , in most applications , we want messages exchanged by gossiping nodes to be large enough to hold at least the node s label and some other useful information , which justifies the assumption @xmath147 for some constant @xmath148 . on the other hand , labels of nodes are often assumed to be polynomial in the size of the network , as there is usually no need of larger labels .",
    "notice , moreover , that if these assumptions are satisfied , the complexity of our gossiping algorithm is @xmath155 , i.e. , it exceeds the lower bound @xmath150 only by a factor of @xmath2 , for any value of the diameter @xmath2 .",
    "thus , our gossiping algorithm is not only optimal for networks of bounded diameter , but it is close to optimal for `` shallow '' networks , e.g. , networks whose diameter is logarithmic in their size , such as the hypercube .",
    "let @xmath156 be the earliest round in which some node is woken up by the adversary .",
    "( there may be several nodes woken up in round @xmath156 ) . since each node beeps in the round following its wakeup ( either by the adversary or by a beep ) , all nodes are woken up until round @xmath157 .        in order to prove the claim , first note that stage @xmath43 of node @xmath14 starts after round @xmath158 . for any node @xmath159 and any non - negative integer @xmath47 ,",
    "let @xmath160 denote the round @xmath161 computed by node @xmath159 ( relative to its wakeup round ) .",
    "since non - active nodes beep in some round @xmath162 only if they heard a beep in round @xmath163 , it follows that if @xmath14 heard a beep in some round @xmath35 of its stage @xmath43 , then an active node @xmath33 must have beeped in some round @xmath164 , such that no node beeped in round @xmath165 . according to the procedure ,",
    "the only reason for such a beep is that , for some @xmath166 , @xmath167 , node @xmath33 is active in its stage @xmath166 , and that @xmath168 , where @xmath75 is the binary representation of the label of @xmath33 .",
    "suppose that @xmath169 .",
    "this implies @xmath170 , hence @xmath171 .",
    "hence the wakeup rounds of nodes @xmath14 and @xmath33 differ by more than @xmath1 , which is a contradiction",
    ". thus @xmath166 can not be smaller than @xmath43 . for similar reasons",
    ", @xmath166 can not be larger than @xmath43 .",
    "this leaves the only possibility of @xmath172 , which proves the claim .",
    "next , we prove that the node @xmath83 with the largest label among participating nodes remains active till the end of its stage @xmath66 .",
    "let @xmath173 be the binary representation of this label .",
    "suppose , for contradiction , that @xmath83 becomes passive in some stage @xmath174 .",
    "according to the procedure , this implies that it heard a beep in stage @xmath43 and that @xmath175 . in view of the claim ,",
    "there is a node @xmath33 active in stage @xmath43 , with the binary representation @xmath176 of its label , such that @xmath79 .",
    "consider any index @xmath169 . if @xmath177 then also @xmath178 .",
    "otherwise , since node @xmath83 is active in stage @xmath166 , it beeps in stage @xmath166 and hence node @xmath33 would become passive in stage @xmath166 , which contradicts the fact that it became passive only in stage @xmath43 .",
    "this proves that the sequence @xmath173 is lexicographically smaller than the sequence @xmath176 , which contradicts the assumption that @xmath83 has the largest label among participating nodes .",
    "further , we prove that no node other than the node @xmath83 with the largest label among participating nodes remains active till the end of its stage @xmath66 .",
    "let @xmath33 be such a node with the binary representation @xmath176 of its label , and let @xmath16 be the first index where @xmath179 . since @xmath83 is active in stage @xmath16 and @xmath180 ,",
    "node @xmath83 beeps in stage @xmath16 , and hence @xmath33 hears it and becomes passive ( at the latest ) in stage  @xmath16 .",
    "it follows that @xmath83 is the only participating node that is active at the end of the execution of procedure find max .",
    "node @xmath83 knows that it remained active at the end , so it knows that it has the largest label .",
    "every other node @xmath33 ( it is passive at the end of the procedure execution ) deduces the binary representation @xmath173 of the label of @xmath83 as follows : @xmath181 , if and only if @xmath33 heard a beep in stage  @xmath47 . indeed , if @xmath181 then it beeped in stage @xmath47 , because it was active in this stage , and hence @xmath33 heard a beep at most @xmath1 rounds later , hence still in its stage @xmath47 .",
    "if @xmath182 , then no node beeped in stage @xmath47 because all nodes that have 1 as the @xmath47th term of the binary representation of their label must be already passive in stage @xmath47 , as this representation is lexicographically smaller than @xmath173 .        let @xmath184 be the largest distance of any node from @xmath83 .",
    "for every node other than @xmath83 , the value of the variable @xmath84 is its distance from @xmath83 .",
    "hence in time interval @xmath115 exactly nodes at distance at most @xmath185 from @xmath83 beep .",
    "it follows that @xmath186 is the first round of the form @xmath116 in which @xmath83 does not hear a beep",
    ". consequently @xmath187 . by the correctness of algorithm broadcast",
    ", all nodes correctly decode the integer @xmath120 . since @xmath156 is the largest distance of any node from @xmath83 ,",
    "the diameter @xmath2 of the network satisfies inequalities @xmath188 . thus @xmath122 is a linear upper bound on the diameter of the network .    after decoding the integer @xmath122 ,",
    "all nodes know @xmath1 , @xmath40 , @xmath156 and @xmath3 .",
    "hence the round declared as _ blue _ is the same for all nodes .",
    "it was follows from the proof of theorem [ broad - trees ] that algorithm broadcast takes time at most @xmath189 . since @xmath83 starts broadcasting in round @xmath119 , by round _",
    "blue _ the procedure is completed .",
    "it takes time @xmath190 .",
    "consider the star @xmath67 with @xmath191 leaves , i.e. , a tree with one node @xmath14 of degree @xmath191 and with @xmath191 nodes of degree 1 .",
    "@xmath67 is a tree of diameter 2 .",
    "let @xmath33 be any leaf .",
    "consider any algorithm @xmath192 accomplishing gossiping in @xmath67 in time @xmath35 .",
    "the leaf @xmath33 can obtain information only from node @xmath14 . in time",
    "@xmath35 node @xmath14 can transmit @xmath193 sequences with terms in the set @xmath59 , where @xmath15 denotes a beep and @xmath16 denotes silence .",
    "consider the family @xmath194 of possible sets of input messages initially held by the @xmath191 nodes of @xmath67 other than @xmath33 , assuming that each node has a different message of size @xmath4 .",
    "if @xmath195 , then node @xmath14 executing algorithm @xmath192 must generate the same sequence with terms in the set @xmath59 for two distinct sets of messages initially held by the @xmath191 nodes of @xmath67 other than @xmath33 , and consequently @xmath33 can not correctly deduce the set of messages held by other nodes of @xmath67 .",
    "this implies that @xmath196 ."
  ],
  "abstract_text": [
    "<S> broadcasting and gossiping are fundamental communication tasks in networks . in broadcasting , </S>",
    "<S> one node of a network has a message that must be learned by all other nodes . in gossiping </S>",
    "<S> , every node has a ( possibly different ) message , and all messages must be learned by all nodes . </S>",
    "<S> we study these well - researched tasks in a very weak communication model , called the _ beeping model_. communication proceeds in synchronous rounds . in each round </S>",
    "<S> , a node can either listen , i.e. , stay silent , or beep , i.e. , emit a signal . </S>",
    "<S> a node hears a beep in a round , if it listens in this round and if one or more adjacent nodes beep in this round . </S>",
    "<S> all nodes have different labels from the set @xmath0 .    </S>",
    "<S> our aim is to provide fast deterministic algorithms for broadcasting and gossiping in the beeping model . </S>",
    "<S> let @xmath1 be an upper bound on the size of the network and @xmath2 its diameter . </S>",
    "<S> let @xmath3 be the size of the message in broadcasting , and @xmath4 an upper bound on the size of all input messages in gossiping . </S>",
    "<S> for the task of broadcasting we give an algorithm working in time @xmath5 for arbitrary networks , which is optimal . </S>",
    "<S> for the task of gossiping we give an algorithm working in time @xmath6 for arbitrary networks .    </S>",
    "<S> * keywords : * algorithm , broadcasting , gossiping , deterministic , graph , network , beep .    at the time of writing this paper </S>",
    "<S> we were unaware of the paper + a. czumaj , p. davis , communicating with beeps , arxiv:1505.06107 [ cs.dc ] which contains the same results for broadcasting and a stronger upper bound for gossiping in a slightly different model . </S>"
  ]
}