{
  "article_text": [
    "we consider the following problem .",
    "we are given a set of computational agents connected by a ( physical or logical ) ring , and a set of items , each associated to one color from a given set .",
    "initially each agent holds a set of items and items with the same color may be held by different agents ( _ e.g. _ see fig  [ fig : problem].(a ) ) .",
    "we wish the agents to agree on an assignment of colors to agents in such a way that each color is assigned to one agent only and that the maximum over all agents of the number of different colors assigned to the same agent is minimum .",
    "we call this a _ balanced assignment _ : fig  [ fig : problem].(b ) and fig  [ fig : problem].(c ) show two possible balanced assignments . among all such assignments ,",
    "we seek the one that minimizes the total number of items that agents have to collect from other agents in order to satisfy the constraints .",
    "for example , agent @xmath3 in fig  [ fig : problem].(b ) is assigned colors @xmath4 and @xmath5 , and therefore needs just to collect four items colored @xmath4 , since no other agent has items colored @xmath5 .",
    "[ fig : problem ]    the problem can be formalized as follows .",
    "let @xmath6 be a set of @xmath1 agents connected by a ring and let @xmath7 be a set of @xmath0 colors .",
    "let @xmath8 be the number of items with color @xmath9 initially held by agent @xmath10 , for every @xmath11 , and for every @xmath12 .",
    "[ def : bc ]    a balanced coloring is an assignment @xmath13 of the @xmath0 colors to the @xmath1 agents in such a way that :    * for every color @xmath9 , there is at least one agent @xmath10 such that @xmath14 ; * for every agent @xmath10 , @xmath15 ; _ i.e. _ , the number of color assigned to agents has to be balanced .",
    "in particular , @xmath16 colors are assigned to @xmath17 $ ] agents , and @xmath18 colors to the remaining @xmath19 agents .",
    "any balanced coloring then assigns almost the same number of colors to each agent , and when @xmath0 is a multiple of @xmath1 , then each agent is assigned exactly the same number of colors .",
    "[ def : cost ] the distributed balanced color assignment problem aims at distributively finding a balanced coloring of minimum cost , where the _ cost _ of a balanced coloring @xmath13 is defined as    @xmath20    the cost of the optimal assignment will be denoted by @xmath21 .",
    "the _ approximation ratio _ of a sub - optimal algorithm a is the quantity @xmath22 , where @xmath23 is the cost of the solution computed by a.    [ [ motivations . ] ] motivations .",
    "+ + + + + + + + + + + +    the scenario defined above may arise in many practical situations in which a set of agents independently search a common space ( distributed crawlers , sensor networks , peer - to - peer agents , etc ) and then have to reorganize the retrieved data ( items ) according to a given classification ( colors ) , see for example @xcite . in these cases , determining a distributed balanced color assignment may guarantee specialization by category with maximal use of data stored in local memory or balanced computational load of agents minimizing the communication among agents .",
    "a similar scenario may also arise in computational economics  @xcite .",
    "the distributed balanced color assignment formalizes a combinatorial auction problem where agents are the bidders and colors represent auction objects .",
    "the number of items that an agent holds for each color can be interpreted as a measure of _ desire _ for certain objects ( colors ) . balancing the number of colors per agent and minimizing the cost guarantees the maximum bidders satisfaction .",
    "[ [ the - model . ] ] the model .",
    "+ + + + + + + + + +    we assume that the agents in @xmath24 are connected by a ring : agent @xmath10 can communicate only with its two neighbors @xmath25 ( clockwise ) and @xmath26 ( anti - clockwise ) .",
    "we assume that each agent knows @xmath1 ( the number of agents ) , and @xmath27 ( the set of colors ) .",
    "each agent @xmath10 is able to compute @xmath28 independently , _",
    "i.e. _ , the maximum number of items it stores having the same color , while @xmath29 is unknown to the agents .    we will consider both synchronous and asynchronous rings , always specifying which case we are working with or if results hold for both models .    for synchronous and asynchronous rings , we measure message complexity in the standard way ( cf .",
    "@xcite ) , _",
    "i.e. _ , we assume that messages of bit length at most @xmath30 , for some constant @xmath31 ( called _ basic messages _ ) , can be transmitted at unit cost .",
    "one message can carry at most a constant number of agent i d s .",
    "non basic messages of length @xmath32 are allowed , and we charge a cost @xmath33 for their transmission , for some constant @xmath34 .    for what concerns time complexity , in the synchronous case we assume that agents have access to a global clock and that the distributed computation proceeds in rounds . in each round",
    "any agent can check if it has received a message ( sent in the previous round ) , make some local computation , and finally send a message . in the asynchronous case",
    "agents do nt have access to a global clock , but the distributed computation is _ event driven _",
    "( `` upon receiving message @xmath35 , take action @xmath36 '' ) .",
    "a message sent from one agent to another will arrive in a finite but _ unbounded _ amount of time .    throughout the paper we will use the generic term _ time unit _ to designate the time needed for a message to traverse a link both in the synchronous and asynchronous case : for the synchronous case a time unit ( also called round or time slot ) is the time elapsed between two consecutive ticks of the clock ; for the asynchronous setting a time unit can be any bounded finite amount of time .",
    "nevertheless , in both cases the time complexity can be simply measured as the number of time units needed to complete the algorithm s execution .",
    "[ [ outline - of - the - results . ] ] outline of the results .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    the goal of this paper is to analyze the efficiency with which we can solve the distributed balanced color assignment problem . in section  [ pre ]",
    "we discuss some related problems and show the equivalence with the so called weighted @xmath36-assignment problem in a centralized setting  @xcite .",
    "we also show that a brute force approach that first gathers all information at one agent , then computes the solution locally and finally broadcasts it , has a high message complexity of @xmath37 .",
    "fortunately , we can do better than this . in section  [ lowerbound ]",
    "we give an @xmath38 lower bound on the message complexity to determine a feasible solution ( suitable for both synchronous and asynchronous cases ) . in section  [ alg ] we present an algorithm that finds a feasible solution to the problem whose message complexity is @xmath39 , which is then optimal when @xmath0 is bounded by a polynomial in @xmath1 .",
    "interestingly enough , message complexity is never affected by the value @xmath40 , while running time is .",
    "we then show how to adapt the algorithm to work also in the asynchronous case at the expenses of a slight increase in message complexity ; this time the messege cost depends also on @xmath40 , but the asymptotic bound is affected only when @xmath40 is very large ( i.e. , only if @xmath41 ) . in section  [ approx ]",
    "we show that the proposed algorithm ( both synchronous and asynchronous versions ) computes a balanced coloring whose cost is only a factor of three off the optimal one , and we also show that the analysis of the approximation is tight .",
    "finally , we show that we can find balanced colorings with a better approximation ratio at the expenses of the message and/or time complexity .    a preliminary version of this work appeared in @xcite . in the previous version",
    "it was assumed that parameter @xmath40 ( the maximum number of items of a given color ) was known to the computational agents . since in practical situations it is difficult to have a good estimate of such a global parameter , in this new version we removed this assumption .",
    "this required both new algorithmic ideas and technical efforts .",
    "the algorithm for the asynchronous communication model was also not contained in the preliminary version .",
    "finally , we enriched the proof of the lower bound with new insights that could be useful for further generalizations to different network topologies .",
    "in this section we relate the distributed balanced color assignment problem to known matching problems that have been well studied in centralized settings . we will first show that when @xmath42 our problem is equivalent to a maximum weight perfect matching problem on complete bipartite graphs . on the other hand ,",
    "when @xmath43 , our problem reduces to the weighted @xmath36-assignment problem .",
    "the class of @xmath36-assignment problems has been introduced by chang and lee @xcite , in the context of the problems of assigning jobs to workers , in order to incorporate the problem of balancing the work load that is given to each worker . in the weighted @xmath36-assignment problem one",
    "aims at minimizing the maximum number of jobs assigned to each worker .",
    "the interested reader can find useful references on these problems , their complexity , and related approximation issues in @xcite .",
    "we associate to agents and colors the complete bipartite graph on @xmath44 vertices , which we denote by @xmath45 .",
    "we add weights to @xmath46 as follows : the weight of the edge joining agent @xmath10 and color @xmath9 is @xmath47 .",
    "[ [ case - m - n . ] ]   case @xmath48 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    given a graph @xmath49 , a perfect matching is a subset @xmath50 of edges in @xmath51 such that no two edges in @xmath50 share a common vertex and each vertex of @xmath52 is incident to some edge in @xmath50 .",
    "when edges of the graph have an associated weight , then a maximum weight perfect matching is a perfect matching such that the sum of the weights of the edges in the matching is maximum .",
    "[ maxmatching ] when @xmath42 , a maximum weight perfect matching on @xmath46 is a minimum cost solution to the balanced color assignment problem .    given a perfect matching @xmath53 on @xmath46 , for every @xmath54 we assign color @xmath9 to agent @xmath10 .",
    "as @xmath46 is complete and @xmath51 is a perfect matching on @xmath46 , every color is assigned to one and only one agent and vice - versa .",
    "moreover , the cost of any color assignment @xmath51 can be written as @xmath55 , and this expression achieves its minimum when @xmath51 is a maximum weight perfect matching .",
    "finding matchings in graphs is one of the most deeply investigated problems in computer science and operations research ( see @xcite for a comprehensive description of the different variants , theoretical properties , and corresponding algorithms ) . the best algorithm known to find a perfect matching in a bipartite graph is due to hopcroft and karp @xcite , and runs in @xmath56 time , where @xmath52 and @xmath51 denote the vertex and edge sets , respectively .",
    "the best known algorithm for finding a maximum weight perfect matching is the _ hungarian method _",
    ", due to kuhn @xcite , which runs in time @xmath57 .",
    "[ [ case - mgeq - n . ] ] case @xmath43 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + +    the @xmath36-assignment problem is defined on a bipartite graph @xmath58 where @xmath59 is the bipartition of the vertex set .",
    "a @xmath36-assignment of @xmath60 in @xmath46 is a subset of the edges @xmath61 such that , in the induced subgraph @xmath62 , the degree of every vertex in @xmath60 is exactly one .",
    "let @xmath63 be the maximum degree , in @xmath64 , of vertices in @xmath65 and let @xmath66 be the minimum value of @xmath63 among all possible @xmath36-assignments @xmath67 .",
    "the weighted @xmath36-assignment problem consists of finding a @xmath36-assignment @xmath67 with @xmath68 which maximizes the total weight of the edges in @xmath67 .",
    "the following lemma is straightforward .",
    "the balanced color assignment problem is a weighted @xmath36-assignment of @xmath27 in the complete bipartite graph @xmath69 , with @xmath70 .",
    "the fastest known algorithm to solve the weighted @xmath36-assignment problem is due to chang and ho @xcite and runs in @xmath71 .",
    "while the maximum weighted perfect matching problem ( and its variants ) has been widely investigated in the distributed setting ( see @xcite ) , no distributed results are known for the weighted @xmath36-assignment problem .    [ [ a - brute - force - approach . ] ] a brute force approach .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    a brute force distributed solution to the problem can be obtained by asking all the agents to send their color information to one specific agent ( a priori chosen or elected as the leader of the ring ) ; such an agent will then solve the problem locally and send the solution back to all the other agents .",
    "the factor dominating the message complexity of the algorithm above is the information collecting stage .",
    "indeed , each agent sends @xmath72 non - basic messages , each corresponding to @xmath73 basic messages , through @xmath74 links , on the average .",
    "this results in a message complexity of @xmath75 . on the other hand",
    ", we might think of an algorithm in which each agent selects the correct number of colors basing its choice just on local information ( _ e.g. _ its label ) .",
    "this requires no communication at all , but , even if we are able to prove that the agents agree correctly on a balanced coloring , we have no guarantee on how good the solution is .",
    "as we already said , we show that we can do better than this .",
    "in this section we prove a lower bound on the message complexity of the problem that applies to both synchronous and asynchronous rings .",
    "we prove the lower bound on a particular subset @xmath76 of the instances of the problem .",
    "let @xmath1 be even and let @xmath77 , for some integer @xmath78 .",
    "since we are only interested in asymptotic bounds , for the sake of simplicity , we will also assume that @xmath0 is a multiple of @xmath1 , i.e. @xmath79 is an integer .",
    "for any agent @xmath10 , let @xmath80 denote the agent at maximum distance from @xmath10 on the ring . in the following",
    "we say that _ a color is assigned to the pair _",
    "@xmath81 , for @xmath82 , to mean that it is assigned to both agents of the pair .",
    "we also say that a set @xmath83 of colors is assigned to agent @xmath84 iff all the colors in @xmath83 are assigned to @xmath84 .",
    "let @xmath85 be a partition of the set of colors such that @xmath86 for all @xmath87 .",
    "set @xmath76 consists of all instances of the distributed balanced color assignment problem such that for any @xmath82 , the following two conditions hold :    \\(a ) for any color @xmath88 both agents of pair @xmath81 hold at least one item of color @xmath89 , _ i.e. _ @xmath90 ;    \\(b ) neither @xmath10 nor @xmath80 hold colors not in @xmath91 .    [",
    "le : pair ] given an instance in @xmath76 , any optimal solution assigns to @xmath81 _ only _ colors from set @xmath92 , for @xmath93 .",
    "consider any solution to an instance from set @xmath76 that assigns to the agent @xmath10 a color @xmath94 initially held by some pair @xmath95 , with @xmath96 .",
    "since any optimal solution is perfectly balanced on input instances of @xmath97 , there must be at least one color @xmath98 initially stored in @xmath81 that is assigned to some other agent , say @xmath99 . the same argument can in turn be applied to @xmath99 and so on until ( since the number of colors / agents is finite ) we fall back on @xmath100 .",
    "formally , there exists @xmath101 , @xmath102 , such that @xmath103 , and a sequence of indices @xmath104 , with @xmath105 , @xmath106 and @xmath107 , such that    * color @xmath108 is assigned to agent @xmath109 ; * color @xmath110 is assigned to agent @xmath111 ; + * color @xmath112 is assigned to agent @xmath113 .",
    "let @xmath114 denote the cost of such a solution and let @xmath115 be the contribution to the cost given by colors different from @xmath116 . then",
    ", recalling condition ( b ) of the definition of @xmath117 , we have @xmath118    consider now a solution that differs from the previous one only by the fact that every color in @xmath119 is assigned to agent @xmath120 for @xmath121 .",
    "namely ,    * @xmath122 is assigned to @xmath123 ; * @xmath124 is assigned to @xmath125 ; + * @xmath126 is assigned to @xmath127 .",
    "this is clearly a perfectly balanced solution , since each agent `` loses '' and `` gains '' exactly one color with respect to the previous case .",
    "letting @xmath128 be the cost of such a solution , we have @xmath129    hence ,    @xmath130 where the inequality follows from condition ( 1 ) of the definition of @xmath76 .",
    "we now consider two specific instances in @xmath76 that will be used in the following proofs .     for each pair @xmath131 , for @xmath132 , and",
    "its initially allocated set of colors @xmath133 , fix any @xmath134 and partition set @xmath92 into subsets @xmath135 and @xmath136 , each of cardinality @xmath137 .",
    "we define instance @xmath138 for the pair @xmath81 in the following way :    @xmath139    hence , by construction , instance @xmath140 has the property that for any @xmath141 , @xmath142 .",
    "[ ex : uno ] consider a pair @xmath131 with a set of colors @xmath143 .",
    "let @xmath144 . if @xmath145 and @xmath146 , then instance @xmath140 will be as follows :    [ cols=\"<,<,<,<,<,<,<,<,<\",options=\"header \" , ]      observe that , from @xmath10 point of view , instances @xmath147 and @xmath148 are indistinguishable",
    "nevertheless , the optimal solution for instance @xmath148 is to assign to @xmath10 the complement set of indices with respect to the optimal solution to instance @xmath140 .",
    "analogously as the previous lemma we can prove the following result .    [",
    "l : optdue ] there is only one optimal solution for instance @xmath148 : assign colors in @xmath135 to @xmath80 and colors in @xmath136 to @xmath149 .",
    "the proof is very similar to that of lemma  [ l : optuno ] .",
    "the cost of the solution defined in the statement is now :    @xmath150 the cost of any other solution is calculated as in the proof of lemma  [ l : optuno ] with the exception that now instance @xmath148 has the property that for any @xmath141 , @xmath151 .",
    "the core of the lower bound s proof lies in the simple observation that agent @xmath10 is not able to distinguish between instance @xmath152 and instance @xmath148 without knowing also the quantities @xmath153 for colors @xmath89 falling into partition @xmath136 .    [ no_optimal ] if agent @xmath10 knows at most @xmath137 colors held by @xmath80 , it can not compute its optimal assignment of colors .    construct a partition of @xmath92 in the following way : place index @xmath89 in @xmath135 if @xmath10 has knowledge of @xmath153 and in @xmath136 in the other case . if the cardinality of @xmath135 is smaller than @xmath137 , arbitrarily add indices to reach cardinality @xmath137 .",
    "agent @xmath10 can not distinguish between instances @xmath140 and @xmath148 constructed according to this partition of @xmath92 and , hence , by lemmas [ l : optuno ] and [ l : optdue ] can not decide whether it is better to keep colors whose indices are in @xmath135 or in @xmath136 .",
    "finally , observe that in both instances indices in @xmath135 are exactly in the same position in the ordering of the colors held by @xmath80 , thus the knowledge of these positions does not help .",
    "[ msgcompl ] the message complexity of the distributed color assignment problem on ring is @xmath38 .",
    "let a be any distributed algorithm for the problem running on instances in @xmath76 .",
    "by the end of the execution of a , each agent has to determine its own assignment of colors .",
    "fix any pair @xmath81 and consider the time at which agent @xmath10 decides its own final assignment of colors .",
    "assume that at this time @xmath10 knows information about at most @xmath154 colors of agent @xmath80 .",
    "by lemma  [ no_optimal ] , it can not determine an assignment of colors for itself yielding the optimal solution .    therefore , for all @xmath155 pairs @xmath81 , agent @xmath10 has to get information concerning at least @xmath156 of the colors held by @xmath80 .",
    "we use shannon s entropy to compute the minimum number of bits @xmath157 to be exchanged between any pair @xmath81 so that this amount of information is known by @xmath10 .",
    "we have :    @xmath158    using stirling s approximation and the inequality @xmath159 , we get    @xmath160    as a basic message contains @xmath161 bits , any pair @xmath81 needs to exchange at least @xmath162 basic messages .",
    "each such message must traverse @xmath155 links of the ring to get to one agent of the pair to the other .",
    "as we have @xmath155 pairs of agents , the lower bound on message complexity is given by    @xmath163",
    "in this section we first describe an algorithm that exhibits optimal message complexity on synchronous ring .",
    "we will then show how to adapt the algorithm to the case of an asynchronous ring . in the next section",
    "we will prove that the algorithm is guaranteed to compute an approximation of the color assignment that is within a factor three from the optimal solution ( for both synchronous and asynchronous ring ) .      at a high level ,",
    "the algorithm consists of three phases : in the first phase , the algorithm elects a leader @xmath3 among the set of agents .",
    "the second phase of the algorithm is devoted to estimate the parameter @xmath164 , _",
    "i.e. _ the maximum number of items of a given color held by agents . finally , the last phase performs the assignment of colors to agents in such a way to be consistent with definition  [ def : bc ] . in the following",
    "we describe the three phases in detail .    * algorithm sync - balance *    * phase 1 . * the first phase is dedicated to leader election that can be done in @xmath74 time with a message complexity of @xmath165 on a ring of @xmath1 nodes , even when the nodes are not aware of the size @xmath1 of the ring @xcite .",
    "leader election has also been studied in arbitrary wired networks @xcite .",
    "an @xmath166 polylog@xmath167 time deterministic algorithm is available even for ad hoc radio networks of _ unknown and arbitrary _ topology without a collision detection mechanism , even though the size of the network must be known to the algorithm code ( see @xcite for the currently best result ) .    without loss of generality , in the following we will assume that agent @xmath3 is the leader and that @xmath168 are the other agents visiting the ring clockwise . in the rest of this paper",
    ", we will refer to agent @xmath169 ( resp .",
    "@xmath170 ) as to the _ preceding _ ( resp .",
    "_ following _ ) _ neighbor _ of @xmath10 .",
    "* phase 2 . * in this phase agents agree on an upper bound @xmath171 of @xmath40 such that @xmath172 .    given any agent @xmath10 and an integer @xmath173 ,",
    "we define : @xmath174    this phase is organized in consecutive stages labeled @xmath175 at stage @xmath176 , the leader sets an integer variable @xmath177 to zero , which will be updated at the end of each stage and used to determine when to end this phase .    in stage @xmath178 , agent @xmath10 , for @xmath179",
    ", waits for @xmath180 time units from the beginning of the stage . at that time",
    "a message @xmath50 might arrive from its preceding neighbor . if no message arrives , then it is assumed that @xmath181 .",
    "agent @xmath10 computes @xmath182 and , at time unit @xmath183 , sends @xmath50 to its following neighbor only if @xmath184 , otherwise it remains silent .",
    "after @xmath1 time slots in stage @xmath185 , if the leader receives a message @xmath186 from the preceding neighbor , then it updates variable @xmath187 , and , if @xmath188 , proceeds to stage @xmath189 of phase 2 ; otherwise it sends a message clockwise on the ring containing the index of the last stage @xmath190 performed in phase 2 . each agent then computes @xmath191 , forwards the message clockwise , waits for @xmath192 time units and then proceeds to phase 3 .",
    "[ l : ph2 ] phase 2 of algorithm sync - balance computes an upper bound @xmath171 of @xmath40 such that @xmath172 within @xmath193 time units and using @xmath194 basic messages .    we will say that agent @xmath10 _ speaks up _ in stage @xmath185 when @xmath195 . throughout the execution of the algorithm , integer variable @xmath177 records the number of agents that have spoken up so far .",
    "any agent @xmath10 speaks up in one stage only .",
    "indeed , given the color @xmath196 for which agent @xmath10 has the maximum number of items , then @xmath195 only at stage @xmath185 such that @xmath197 falls in the ( unique ) interval @xmath198 .",
    "let @xmath199 be the agent having the largest amount of items of the same color among all agents , _",
    "i.e. _ , such that @xmath200 , for some @xmath201 $ ] .",
    "then @xmath202 for stage @xmath185 such that @xmath203 , _ i.e. _ , agent @xmath199 speaks up when @xmath204 . observe that at the end of stage @xmath190 the leader sets @xmath205 , as all @xmath1 agents must have spoken up by that time . therefore , considering also the last extra stage in which the agents are informed of the value of @xmath190 , phase 2 ends after @xmath206 stages , i.e. @xmath207 time units .    for what concerns message complexity , in each stage , for @xmath208 , either no messages are sent , or a message traverses a portion of the ring .",
    "observe that , as each agent speaks up only once during this phase , messages circulating on the ring must always be originated by different agents .",
    "hence , the number of stages in which a message circulates on the ring is at most @xmath1 and there must be at least @xmath209 silent stages . in conclusion ,",
    "phase 2 message complexity is bounded by @xmath194 .    as for the ratio between the actual value of @xmath40 and its approximation @xmath171 computed in phase 2 , by construction we have that @xmath210 and    @xmath211    * phase 3 . * as a preliminary step , each agent @xmath10 computes the number of colors it will assign to itself and stores it in a variable @xmath212 .",
    "namely , each agent @xmath10 , for @xmath213 computes @xmath214 and then sets @xmath212 as follows ( recall definition  [ def : bc ] ) : @xmath215 in the rest of this phase , the agents agree on a color assignment such that each agent @xmath10 has exactly @xmath212 colors .",
    "algorithms  [ b3.1 ] and [ b3.2 ] report the pseudo - code of the protocol performed by a general agent @xmath10 in this phase and that is here described .",
    "let @xmath171 be the upper bound on @xmath40 computed in phase 2 .",
    "phase 3 consists of @xmath216 stages . in each stage @xmath185 , for @xmath217 , the agents take into consideration only colors whose weights fall in interval @xmath218 defined as follows :    @xmath219    observe that in consecutive stages , agents consider weights in decreasing order , as @xmath220 .    at the beginning of each stage",
    "@xmath185 , all agents have complete knowledge of the set of colors @xmath221 that have already been assigned to some agent in previous stages . at the beginning of this phase , @xmath222 is the empty set , and after the last stage is performed , @xmath223 must be the set of all colors .",
    "stage @xmath185 is , in general , composed of two steps ; however , the second step might not be performed , depending on the outcome of the first one . in the first step ,",
    "the agents determine if there is at least one agent with a weight falling in interval @xmath224 , by forwarding a message around the ring only if one of the agents is in this situation .",
    "if a message circulates on the ring in step one , then all agents proceed to step two in order to assign colors whose weight fall in interval @xmath224 and to update the set of assigned colors .",
    "otherwise , step two is skipped .",
    "now , if there are still colors to be assigned ( _ i.e. _ , if @xmath225 ) , all agents proceed to stage @xmath226 ; otherwise , the algorithm ends . in more details :    step 1 .",
    "agent @xmath10 ( leader included ) waits @xmath180 time units ( zero for the leader ) from the beginning of the stage , and then acts according to the following protocol :    case 1 : : :    if @xmath10 receives a message from its preceding neighbor    containing the label @xmath227 of some agent @xmath100 ,    it simply forwards the same message to its following neighbor and    waits for @xmath228 time units ;    otherwise    case 2 : : :    if @xmath10 has a weight falling into interval    @xmath224 , then it sends a message containing its label    @xmath180 to its following neighbor and waits for    @xmath229 time units ;    otherwise    case 3 : : :    it does nothing and waits for @xmath1 time units .",
    "if case 1 or case 2 occurred , then agent @xmath10 knows that step 2 is to be performed and that it is going to start after waiting the designed time units .",
    "otherwise , if case 3 occurred , after @xmath1 units of time , agent @xmath10 might receive a message ( containing label @xmath227 ) from its preceding neighbor , or not .",
    "if it does , then @xmath10 learns that case 2 occurred at some agent @xmath230 having label @xmath231 and that step 2 is to be performed . hence , it forwards the message to its following neighbor in order to inform all agents having labels in the interval @xmath232 $ ] , unless this interval is empty ( meaning that @xmath10 was the last agent to be informed ) .",
    "then , after waiting for another @xmath233 time units , agent @xmath10 proceeds to step 2 . on the contrary",
    ", if @xmath10 got no message , it learns that case 2 did not occur at any agent and hence , step 2 needs not be performed . after waiting for @xmath234 time units",
    ", @xmath10 can proceed to the next stage @xmath226 .",
    "observe that , when step 2 has to be performed , step 1 lasts exactly @xmath235 time units for all agents , where @xmath227 is the smallest agent s label at which case 2 occurs , while it lasts exactly @xmath236 time units for all agents in the opposite case . indeed , referring to the pseudo - code in algorithm  [ b3.1 ] , completion time is given by the sum of the time units in the following code lines : in case 1 of lines 7 and 10 ( @xmath237 ) ; in case 2 of lines 7 and 15 ( @xmath238 ) ; in case 3 of lines 7 , 18 and 22 if agents proceed to step 2 ( @xmath237 ) , and lines 7 and 26 otherwise .    as the time",
    "needed by agents to agree on skipping step 2 is larger than the time needed to agree in performing it , it is not possible that some agent proceeds to step 2 and some other to stage @xmath226 . on the contrary ,",
    "agents are perfectly synchronized to proceed to step 2 or stage @xmath226 .",
    "when this step is performed , there exists a non empty subset of agents having at least one weight falling into interval @xmath224 . only these agents actively participate to the color assignment phase , while the others just forward messages and update their list of assigned colors .",
    "color assignment is done using a greedy strategy : agent @xmath10 assigns itself the colors it holds which fall into interval @xmath224 and that have not been already assigned to other agents . once a color is assigned to an agent , it will never be re - assigned to another one .    to agree on the assignment ,",
    "the agents proceed in the following way : agent @xmath10 creates the list @xmath239 of colors it holds whose weights fall into interval @xmath224 and that have not been assigned in previous stages .",
    "then , @xmath10 waits @xmath180 time units ( zero for the leader ) from the beginning of the step . at that time , either @xmath10 receives a message @xmath240 from its preceding neighbor or not . in the first case ,",
    "the message contains the set of colors assigned in this stage to agents closer to the leader ( obviously , this case can never happen to the leader ) .",
    "agent @xmath10 then checks if there are some colors in its list @xmath239 that are not contained in @xmath241 ( empty message in the case of the leader ) , and then assigns itself as many such colors as possible , without violating the constraint @xmath212 on the maximum number of colors a single agent might be assigned .",
    "then , @xmath10 updates message @xmath240 by adding the colors it assigned itself , and finally sends the message to its following neighbor .",
    "if @xmath239 is empty , or it contains only already assigned colors , @xmath10 just forwards message @xmath240 as it was . in both cases",
    ", @xmath10 then waits for a new message @xmath242 that will contain the complete list of colors assigned in this stage .",
    "@xmath242 is used by all @xmath10 to update the list of already assigned colors and is forwarded on the ring .",
    "when the message is back to the leader , stage @xmath226 can start .",
    "@xmath171 computed in phase 2 compute @xmath212 @xmath243 @xmath244    wait @xmath180 time units    forward message @xmath240 to its following neighbor wait @xmath245 time units send message @xmath246 to its following neighbor wait @xmath247 time units wait @xmath1 time units forward message @xmath240 to its following neighbor wait for @xmath248 wait @xmath249 time units    [ l : worst ] let @xmath250 be the number of colors assigned in stage @xmath185 of phase 3 , then stage @xmath185 can be completed in at most @xmath74 time units using at most @xmath251 basic messages .",
    "the bound on the time complexity follows straightforwardly by observing that each of the two steps requires at most @xmath236 time units .    for what concerns message complexity",
    ", step 1 requires no messages if step 2 is skipped , and @xmath247 otherwise .",
    "in fact , only one basic message goes clockwise on the ring from @xmath100 to @xmath252 , where @xmath227 is the smallest index at which case 2 occurs .",
    "the worst case for step 2 is the case in which the leader itself assigns some colors , as a possibly long message containing color i d s must go twice around the ring . as there are @xmath0 colors , one color can be codified using @xmath253 bits , then , sending @xmath250 colors requires no more than @xmath254 basic messages . in conclusion ,",
    "the total number of basic messages is upper bounded by @xmath251 .",
    "wait @xmath180 time units @xmath255 create empty message @xmath240 self assign maximum number of colors among those in @xmath239 add self assigned colors to @xmath256 send message @xmath240 to the following neighbor wait for message @xmath242 from preceding neighbor with list of colors @xmath257 forward message @xmath242 to the following neighbor wait for @xmath249 time units    [ cor : ph3 ] phase 3 of algorithm sync - balance can be completed within @xmath258 time units and using @xmath259 basic messages .",
    "it will suffice to sum up the worst cases for message and time complexity from lemma  [ l : worst ] over all stages @xmath260 , where @xmath172 ( lemma  [ l : ph2 ] ) .",
    "the upper bound on the time complexity is straightforward .",
    "let @xmath250 be defined as in the statement of lemma  [ l : worst ] , i.e. as the number of colors assigned in a generic stage @xmath185 of phase 3 .",
    "the upper bound on the message complexity follows by observing that @xmath261 , as the total number of assigned colors during the @xmath262 stages is exactly the given number of colors .",
    "we are now ready to prove that our algorithm is correct . in section  [ approx ]",
    "we will evaluate the ratio of the cost of the solution found by this algorithm and the one of the optimal solution .",
    "assuming @xmath263 , for some constant @xmath31 , algorithm sync - balance finds a feasible solution to the balanced color assignment problem in time @xmath258 using @xmath264 messages .",
    "to prove correctness , we show that any assignment of colors to agents computed by algorithm sync - balance satisfies the two following conditions :    * a color @xmath9 can not be assigned to more than one agent .",
    "* all colors are assigned .",
    "@xmath265 the algorithm can assign a new color @xmath9 to agent @xmath10 only in line 9 of algorithm  [ b3.2 ] .",
    "this can only happen if @xmath9 has not been already assigned in a previous stage , or in the current stage to an agent with smaller label .",
    "since , in the stage , the color assignment is done sequentially ( starting from the leader and following the ring clockwise ) , no color can be assigned to two different agents . moreover , in lines 15 - 17 of algorithm  [ b3.2 ] , all agents update the list of colors assigned in the current stage and , hence , in later stages , already assigned colors will not be assigned again .",
    "therefore sync - balance prevents the assignment of the same color to two different agents .",
    "@xmath266 if an available color @xmath9 of weight @xmath267 is not taken by @xmath10 during stage @xmath185 , it is only because @xmath10 has enough colors already ( line 9 ) .",
    "however , this circumstance may not occur at all agents during the same stage ( for this would imply that there were more than @xmath0 colors ) .",
    "thus , either the color is taken by a higher labeled agent in stage @xmath185 , or is `` left free '' for agents for which the weight of @xmath9 is less than @xmath268 . by iterating the reasoning , we may conclude that , if not taken before , the color must be eventually assigned in stage @xmath269 , where agents are allowed to pick colors for which their weight is zero .    as for upper bounds on time and message complexities , by summing up upper bounds for the three phases",
    ", we have @xmath270    where we used lemma  [ l : ph2 ] , corollary  [ cor : ph3 ] , and the facts that @xmath43 and that @xmath271 , under the given hypothesis .      in an asynchronous ring such instructions as _ `` wait for i time units '' _ ( see algorithm  [ b3.1 ] and [ b3.2 ] ) can not guarantee a correct completion of the global algorithm . here",
    "we discuss how to make simple modifications to sync - balance in order to get an algorithm ( named async - balance ) that correctly works in the asynchronous case as well .",
    "the leader election in phase 1 can be done in @xmath74 time with a message complexity of @xmath272 even on an asynchronous ring of @xmath1 nodes @xcite .",
    "therefore , the main differences are in phase 2 and phase 3 .    in phase 2",
    "we propose a slightly different strategy that works in only 2 stages , instead of @xmath273 .",
    "this better time complexity translates , in general , into an extra cost in terms of message complexity . nevertheless , under reasonable hypothesis",
    "( namely when @xmath274 ) , the message complexity reduces to the same bound as for the synchronous setting .    finally ,",
    "in phase 3 , the main ideas remain the same , but there are no `` silent stages '' and the leader acts differently from the other agents , as it is the one originating all messages circulating on the ring .    in the following we highlight the main differences with the synchronous protocol :    * algorithm async - balance *    * phase 1 .",
    "* leader election can be accomplished with an @xmath275 message complexity  @xcite .",
    "* phase 2 .",
    "* this phase consists of only two stages . in the first stage",
    "the agents compute @xmath276 .",
    "let @xmath277 , _ i.e. _ the maximum number of items of the same color agent @xmath10 posseses .",
    "the leader originates a message containing @xmath278 . upon reception of a message @xmath50 from its preceding neighbor , agent @xmath10 computes @xmath279 and forwards @xmath50 to its following neighbor .",
    "the message that gets back to the leader contains @xmath40 and it is forwarded once again on the ring to inform all agents .    observe that phase 2 requires no more than @xmath280 basic messages , as @xmath281 basic messages are needed to send the @xmath282 s and @xmath40 .",
    "* phase 3 . *",
    "changes in this phase concern both the execution of step 1 and step 2 , that are to be modified in the following way :    step 1 .",
    "each agent @xmath10 computes its list of assignable colors @xmath239 and sets @xmath283 if @xmath284 , and @xmath285 otherwise .",
    "the leader starts the step by sending , to its following neighbor , a basic boolean message containing @xmath286 . upon reception of a message @xmath50 from its preceding neighbor , agent @xmath10 computes @xmath287 and forwards @xmath50 to its following neighbor .",
    "when the leader gets the message back , it forwards the message again on the ring , and the same is done by all agents , until the message arrives to @xmath288 .",
    "the second time one agent ( leader included ) gets the message , it checks its content : if it is a one , then it knows that it has to proceed to step 2 ; otherwise , if it contains a zero , it proceeds to the next stage .",
    "the leader starts the step by sending , to its following neighbor , a ( possibly empty ) list of self assigned colors , obtained exactly as in the synchronous case .",
    "then agents act as in the synchronous protocol , with the exception that they are activated by the arrival of a message from the preceding neighbor and not by a time stamp .",
    "agents proceed to the next stage after forwarding the complete list of colors assigned in the stage .",
    "let @xmath250 be the number of colors assigned in stage @xmath185 of phase 3 , then stage @xmath185 can be completed using at most @xmath289 basic messages .",
    "step 1 is always performed and a basic message is forwarded ( almost stops the message . ] ) twice around the ring . hence , @xmath74 basic messages are used . when step 2 is performed , a message containing color i d s goes ( almost ) twice around the ring .",
    "analogously to the synchronous case , we can prove that no more than @xmath290 messages are needed .",
    "analogously to the synchronous case , we can prove the following corollary .",
    "phase 3 of algorithm async - balance can be completed using @xmath291 basic messages .",
    "assuming @xmath263 , for some constant @xmath31 , algorithm async - balance finds a feasible solution to the balanced color assignment problem , on asynchronous rings , within time @xmath258 using @xmath292 basic messages .",
    "the correctness proof is analogous to the synchronous case .",
    "the time complexity is asymptotically equivalent to the synchronous case . indeed ,",
    "as already mentioned , the leader election in phase 1 can be completed in @xmath74 time , phase 2 requires 2 circles around the ring and , finally , phase 3 includes @xmath293 stages , each of them requiring 2 circles around the ring .    for what concerns message complexity , summing up upper bounds for single phases , we get    @xmath294    as @xmath263 .    when we also have that @xmath295 , the algorithm exhibits the same _ optimal _ message complexity as in the synchronous setting .",
    "namely , we can state the following result .",
    "[ c19 ] if @xmath263 , for some constant @xmath31 , and @xmath296 , then algorithm async - balance finds a feasible solution to the balanced color assignment problem , on asynchronous rings , using @xmath297 messages .",
    "the main result of this section is that the cost of the solution ( as defined in definition  [ def : cost ] ) computed by the algorithms presented in the previous sections is at most a small _ constant _ factor larger than the cost of the optimal solution .",
    "namely , we will show that it is at most three times the optimal solution and that the analysis is tight .",
    "moreover , we will show how to modify the algorithm to get a @xmath298-approximation ratio at the expenses of a little increase of message complexity , and , for the synchronous case only , how to get a @xmath299-approximation ratio ( for every @xmath300 ) at the expenses of an increase in time complexity .",
    "since , under the same assumptions of corollary [ c19 ] , the cost of the solution is the same both in the synchronous and asynchronous versions ( the assignment of colors is exactly the same in both cases ) , in this section we will address both sync - balance and async - balance with the generic name balance . in the following some results",
    "are expressed in terms of the value @xmath171 ( respectively , @xmath40 ) computed by the agents in the synchronous ( resp .",
    "asynchronous ) case during phase 2 of the algorithm .",
    "as these results hold for both @xmath171 and @xmath40 , to avoid repeating the distinction between @xmath171 and @xmath40 over and over again , we will indicate with @xmath301 both values @xmath171 and @xmath40 .",
    "we begin with the following lemma :    [ stessostage ] let color @xmath9 be assigned to agent @xmath10 in stage @xmath185 ( of phase 3 ) by algorithm balance .",
    "let @xmath230 be a different agent such that @xmath302 . then @xmath303    if @xmath304 ( _ i.e. _ , is the last stage )",
    ", then it must be @xmath305 , and we are done .",
    "otherwise , as @xmath9 is assigned to agent @xmath10 in stage @xmath185 then it must be @xmath267 and the thesis easily follows from    @xmath306    let @xmath307 be the assignment of colors to agents determined by algorithm balance , and let @xmath308 be an optimal assignment . define a partition of the set of colors based on their indices , as follows :    * @xmath309 ; _ i.e. _ , color indices for which the assignment made by algorithm balance coincides with ( that of ) the optimal solution . * @xmath310 ; _ i.e. _ , colors indices for which the assignment made by algorithm balance is different from the one of the optimal solution .",
    "[ massimo ] assume @xmath311 is not empty ( for otherwise the assignment computed by ` balance ` would be optimal ) and let @xmath312 .",
    "let @xmath313 be any other color index in @xmath314 such that @xmath315 .",
    "then @xmath316     first observe that , as @xmath317 and @xmath318 , we have that @xmath319 .",
    "if @xmath320 we are clearly done .",
    "suppose now that @xmath321 , then we can prove that @xmath322 .",
    "the fact that @xmath312 means that balance assigned color @xmath9 to a different agent compared to the assignment of the optimal solution .",
    "let @xmath185 be the stage of balance execution in which agent @xmath323 processed color @xmath9 ( _ i.e. _ , @xmath324 ) and could not self assign @xmath9 , then ( in principle ) one of the following conditions was true at stage @xmath185 :    1 .",
    "@xmath323 already reached its maximum number of colors before stage @xmath185 .",
    "+ however , this is impossible .",
    "it is in fact a contradiction that @xmath323 gets color @xmath325 ( recall that @xmath326 ) but does not get color @xmath9 under ` balance ` , since we are assuming @xmath327 , which means that the assignment of @xmath325 can not be done earlier than @xmath9 s assignment .",
    "color @xmath9 has already been assigned to @xmath328 .",
    "this might happen because 1 .",
    "@xmath9 has been assigned to @xmath328 in a previous stage . +",
    "this implies that @xmath328 has a larger number of items of color @xmath9 with respect to @xmath323 , _",
    "i.e. _ , that @xmath329 .",
    "@xmath9 has been assigned to @xmath328 in the same stage , because it has a smaller label on the ring .",
    "+ by lemma  [ stessostage ] we then have that @xmath322 .    balance is a @xmath330-approximation algorithm for the distributed balanced color assignment problem .    [ 3approx ]    let @xmath331 and @xmath21 be the cost of the solutions given by algorithm balance and @xmath332 , respectively . we can express these costs in the following way ( where , for simplicity , we omit index @xmath180 s range , that is always @xmath333 $ ] ) :    @xmath334    analogously , @xmath335 by definition , @xmath336 , for @xmath337 , and thus @xmath338 , _",
    "i.e. _ , the cost associated with color @xmath339 is exactly the same for balance and @xmath332 .",
    "notice also that the term @xmath340 appears in both cost expressions .",
    "hence , to prove that @xmath341 , it is sufficient to show that    @xmath342    we can assume without loss of generality that @xmath0 is a multiple of @xmath1 . indeed , if otherwise @xmath1 does not divide @xmath0 , we can add @xmath185 dummy colors ( for @xmath343 ) , i.e. such that @xmath344 for all agents @xmath180 and dummy color @xmath89 . since in our algorithm",
    "the agents consider the weights in decreasing order , the dummy colors will be processed at the end and therefore they have no effect on the assignment of the other colors .",
    "moreover , as their weights are zero , they do not cause any change in the cost of the solution .    to prove ( [ eq : diff ] ) , we build a partition of the set @xmath314 according to the following procedure .",
    "we start from any @xmath345 in @xmath314 and find another index @xmath346 such that @xmath347 for some @xmath348 .",
    "note that , since @xmath0 is a multiple of @xmath1 , every agent must have @xmath156 colors and therefore such an index @xmath346 must exist .",
    "if @xmath349 the procedure ends , otherwise we have found another index @xmath350 such that @xmath351 .",
    "again , if @xmath352 the procedure ends , otherwise we repeat until , for some @xmath353 , we eventually get @xmath354",
    ". we then set    @xmath355    if during this procedure we considered all indices in @xmath314 we stop , otherwise , we pick another index not appearing in @xmath356 and repeat the same procedure to define a second set @xmath357 , and so on until each index of @xmath314 appears in one @xmath92 . observe that each @xmath92 contains at least two pairs of indices and that each index @xmath312 appears in exactly two pairs of exactly one @xmath92 .",
    "then , using lemma  [ massimo ] , we get    @xmath358    the following theorem shows that the approximation factor given in theorem  [ 3approx ] is tight .    [ epsilon ] for any @xmath359 , there exist instances of the balanced color assignment problem such that @xmath360 is a factor @xmath361 larger than the optimal cost , for some @xmath362 .",
    "consider the following instance of the balanced color assignment problem .",
    "for the sake of presentation , we assume that @xmath42 and that @xmath1 is even , but it is straightforward to extend the proof to the general case .    fix any rational @xmath363 , and let @xmath364 be such that @xmath365 is an integer and @xmath366 .",
    "consider an instance of the problem such that colors are distributed as follows :    @xmath367 and that @xmath3 is the leader elected in the first stage of algorithm balance , and that the labels assigned to agents @xmath368 are @xmath369 , respectively .",
    "consider agents @xmath370 and @xmath371 , for any @xmath372 .",
    "we can always assume that @xmath373 is such that    @xmath374    for some @xmath185 .",
    "that is , the weights of color @xmath375 for agents @xmath370 and @xmath371 belong to the same interval @xmath376 .",
    "it is easy to see that the optimal assignment gives @xmath377 to @xmath370 and @xmath375 to @xmath371 .",
    "the corresponding cost is @xmath378 . on the other hand , algorithm balance assigns @xmath375 to @xmath370 and @xmath377 to @xmath371 , with a corresponding cost @xmath379 .",
    "hence , for the approximation factor , we get    @xmath380    even if the approximability result is tight , if we are willing to pay something in message complexity , we can get a @xmath298-approximation algorithm .",
    "algorithm balance can be transformed into a @xmath298-approximation algorithm , by paying an additional multiplicative @xmath381 factor in message complexity .",
    "algorithm balance is modified in the following way : colors in stage @xmath185 of step 2 in phase 3 are assigned to the agent having the largest number of items ( falling in the interval @xmath224 ) and not to the one close to the leader .",
    "this can be achieved by making the agent forward on the ring , not only their choice of colors , but also their @xmath382s for those colors .",
    "this requires extra @xmath293 bits per color , increasing total message complexity of such a multiplicative factor .",
    "for what concerns the approximation factor , this modification to the algorithm allows to restate the thesis of lemma  [ stessostage ] without the @xmath298 multiplicative factor and , following the same reasoning of theorem  [ 3approx ] , conclude the proof .    finally ,",
    "if we are not willing to pay extra message complexity , but we are allowed to wait for a longer time , we get a @xmath299-approximation algorithm .    assuming @xmath263 , for some constant @xmath31 , for any @xmath383 , there is a @xmath299-approximation algorithm for the distributed balanced color assignment problem with running time @xmath384 and message complexity @xmath385 .",
    "modify the two interval threshold values of algorithm sync - balance in the following way : @xmath386 and redefine    @xmath387    accordingly , the statement of lemma  [ stessostage ] becomes @xmath388 , and the statement of lemma  [ massimo ] can be rewritten as    @xmath389    the result on the approximation factor then follows by the same arguments of the proof of theorem  [ 3approx ] .",
    "the message complexity is not affected by these changes , while the running time now depends on the number of stages in phase 3 , that is @xmath390",
    "in this paper we have considered the distributed balanced color assignment problem , which we showed to be the distributed version of different matching problems . in",
    "the distributed setting , the problem models situations where agents search a common space and need to rearrange or organize the retrieved data .",
    "our results indicate that these kinds of problems can be solved quite efficiently on a ring , and that the loss incurred by the lack of centralized control is not significant .",
    "we have focused our attention to distributed solutions tailored for a ring of agents .",
    "a natural extension would be to consider different topologies and analyze how our techniques and ideas have to be modified in order to give efficient algorithms in more general settings .",
    "we believe that the main ideas contained in this work could be useful to extend the results even to arbitrary topologies .",
    "indeed , an @xmath166 polylog@xmath167 distributed leader election protocol ( that is needed in our algorithm ) is also available for arbitrary ad hoc radio networks @xcite .    for what concerns the ring topology , it is very interesting to note that the value @xmath40 never appears in the message complexity for the synchronous case ( not even if the polynomial relation between @xmath0 and @xmath1 does not hold ) , while a factor @xmath273 appears in the asynchronous case .",
    "it is still an open question if it is possible to devise an asynchronous algorithm that shows optimal message complexity , under the same hypothesis of the synchronous one ; _",
    "i.e. _ , if it is possible to eliminate the extra @xmath391 factor ."
  ],
  "abstract_text": [
    "<S> consider a set of items and a set of @xmath0 colors , where each item is associated to one color . </S>",
    "<S> consider also @xmath1 computational agents connected by a ring . </S>",
    "<S> each agent holds a subset of the items and items of the same color can be held by different agents . </S>",
    "<S> we analyze the problem of distributively assigning colors to agents in such a way that ( a ) each color is assigned to one agent only and ( b ) the number of different colors assigned to each agent is minimum . </S>",
    "<S> since any color assignment requires the items be distributed according to it ( _ e.g. _ all items of the same color are to be held by only one agent ) , we define the cost of a color assignment as the amount of items that need to be moved , given an initial allocation . </S>",
    "<S> we first show that any distributed algorithm for this problem requires a message complexity of @xmath2 and then we exhibit an optimal message complexity algorithm for synchronous rings that in polynomial time determines a color assignment with cost at most three times the optimal . </S>",
    "<S> we also discuss solutions for the asynchronous setting . </S>",
    "<S> finally , we show how to get a better cost solution at the expenses of either the message or the time complexity .    </S>",
    "<S> * keywords : * algorithms ; distributed computing ; leader election ; ring .    </S>",
    "<S> [ definition]theorem [ definition]lemma [ definition]corollary [ definition]example </S>"
  ]
}