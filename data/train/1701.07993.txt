{
  "article_text": [
    "a recent trend in computer networks and cloud computing is to virtualize network functions , in order to provide higher scalability , reducing maintenance costs , and increasing reliability of network services .",
    "virtual network functions as a service ( vnfaas ) is currently under attentive study by telecommunications and cloud stakeholders , as a promising business and technical direction consisting of providing network functions ( i.e. , firewall , intrusion detection , caching , gateways ... ) as a service instead of delivering standalone network appliances . while legacy network services are usually implemented by means of highly reliable hardware specifically built for a single purpose middlebox , vnfaas moves such services to a virtualized environment  @xcite , named _",
    "nfv infrastructure ( nfvi ) _ and based on commercial - off - the - shelf hardware  @xcite .",
    "services implementing network functions are called _ virtual network functions ( vnfs)_. one of the open issues for nfvi design is indeed to guarantee high levels of vnf availability @xcite , i.e. , the probability that the network function is working at a given time .",
    "in other words , a higher availability corresponds to a smaller downtime of the system , and it is required to satisfy stringent _",
    "service level agreements ( sla)_. failures may result in a temporary unavailability of the services , but while in other contexts it may be tolerable , in nfvi network outages are not acceptable , since the failure of a single vnf can induce the failure of all the overlying services @xcite . to achieve high availability , backup vnfs can be placed into the nfvi , acting as replicas of the running vnfs , so that when the latter fail , the load is rerouted to the former . however , not all vnfs are equal ones : the software implementing a network function of the server where a vnf is running may be more prone to errors than others , influencing the availability of the overall infrastructure .",
    "also , client requests may be routed via different network paths , with different availability performance . therefore to guarantee high levels of availability",
    "it is important not only to increase the number of replicas placed on an nfvi , but it is also crucial to select where they are placed and which requests they serve .    in this context , we study and model the _ high availability virtual network function placement ( ha - vnfp ) _ problem , that is the problem of placing vnfs on an nfvi in order to serve a given set of clients requests guaranteeing high availability .",
    "our contribution consist of :    a quantitative probabilistic model to measure the expected availability of vnf placement ;    a proof that the problem is @xmath0-hard and that it belongs to the class of nonlinear optimization problems ;    a linear mathematical programming formulation that can be solved to optimality for instances of limited size ;    a _ variable neighborhood search ( vns ) _",
    "heuristic for both online and offline planning ;    an extensive simulation campaign , and algorithm integration in a decision support system ( dss ) tool  @xcite .",
    "the paper is organized as follows : in [ sec : description ] we present the ha - vnfp , and in [ sec : literature ] we briefly describe previous works on vm / vnf placement in cloud / nfvi systems . in [ sec : modelling ] we formally describe the optimization problem and propose a linearization of the problem and a mathematical programming formulation that can solve it to optimality . in [ sec : algorithms ] we describe our heuristic methodologies , which are then tested in an extensive simulation campaign in [ sec : simulation ] .",
    "we briefly conclude in [ sec : conclusion ] .",
    "we consider an nfvi with several geo - distributed datacenters or _ clusters _ ( see [ figure : nfv - abstract - infrastructure ] ) .",
    "each cluster consists of a set of heterogeneous servers with limited available computing resources .",
    "several instances of the same vnf type can be placed on the nfvi but on different servers .",
    "each vnf instance can be assigned to a single server allocating some of its computing resources .",
    "indeed each server has a limited amount of computing resources that can not be exceeded .",
    "a network connects together all servers of the nfvi : we suppose that the communication links inside a cluster are significantly more reliable than those between servers in different clusters .",
    "an access network with multiple access points connects servers to clients .",
    "links connecting access points to clusters can differ in the availability level , depending on the type of the connection or the distance from the cluster .        in this article",
    ", we assume that the total amount of resources and network capacities are sufficient to manage the expected client requests at any time .",
    "however assignment decisions may artificially produce congestion over the servers .",
    "we analyze how to find assignments providing a trade - off between nfvi availability and system congestion .",
    "we are given an estimation of the expected client vnf requests , each characterized by a computing resource demand .",
    "an assigned request consumes part of the resources reserved by a vnf instance . indeed the consumed resources must not exceed the reserved ones .",
    "requests can be assigned using two different policies : _ demand load balancing _ and",
    "_ split demand load balancing_. in the former , a client request is always fully assigned to a single server , while in the latter it may be split among different ones . splitting a request also splits proportionally its demand of computing resources .",
    "indeed , when a demand is split it relies on the availabilities of many vnf instances , decreasing the expected availability of the service , but increasing the chance of finding a feasible assignment in case of congestion .",
    "we suppose a multi - failure environment in which vnfs , servers , clusters , and networks may fail together .",
    "our aim is to improve the vnf availability by replicating instances on the nfvi .",
    "we distinguish between _ master _ and _ slave _ vnfs : the former are active vnf instances , while the latter are idle until masters fail .",
    "an example of vnf placement is depicted in [ figure : nfv - abstract - placement ] .",
    "each master may be _ protected _ by many slaves - we assume in this article that a slave can protect only a master , must be placed on a different server , and must allocate at least the same amount of computing resources of its master .",
    "each master periodically saves and sends its state to its slaves , e.g. using technologies such as the one presented in  @xcite , in such a way that the latter has always an updated state and can consistently restore the computation in case of failure of the former .",
    "we suppose that if a master is unreachable , a searching process is started in order to find a slave that can complete the computation .",
    "if the searching process fails and all slaves are unreachable , then the service is considered unavailable .",
    "a representation of vnf protection is in [ figure : nfv - dp ] .     and",
    "@xmath1 , while slave are running on @xmath2 and @xmath3 .",
    "each link between vnf instances represents the connection between a master and its slave . ]",
    "even if vm and vnf resource placement in cloud systems is a recent area of research ( see @xcite for a high - level comprehensive study ) , however there already exists orchestrators that are driven by optimization algorithms for the placement , such as  @xcite .",
    "we now present few works in literature studying the optimization problems that arises in this context .    [",
    "[ placement - of - virtual - machines ] ] placement of virtual machines + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    @xcite studies the problem of placing vms in datacenters minimizing the average latency of vm - to - vm communications .",
    "such a problem is @xmath0-hard and falls into the category of _ quadratic assignment problems_. the authors provide a polynomial time heuristic algorithm solving the problem in a _",
    "`` divide et impera '' _ fashion . in @xcite",
    "the authors deal with the problem of placing vms in geo - distributed clouds minimizing the inter - vm communication delays .",
    "they decompose the problem in subproblems that they solve heuristically .",
    "they also prove that , under certain conditions , one of the subproblems can be solved to optimality in polynomial time .",
    "@xcite studies the vm placement problem minimizing the maximum ratio of the demand and the capacity across all cuts in the network , in order to absorb unpredictable traffic burst .",
    "the authors provide two different heuristics to solve the problem in reasonable computing time .",
    "[ [ placement - of - virtual - network - functions ] ] placement of virtual network functions + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    @xcite applies nfv to lte mobile core gateways proposing the problem of placing vnfs in datacenters satisfying all client requests and latency constraints while minimizing the overall network load .",
    "instead , in  @xcite the objective function requires to minimize the total system cost , comprising the setup and link costs .",
    "@xcite introduces the vnf orchestration problem of placing vnfs and routing client requests through a chain of vnfs . the authors minimize the setup costs while satisfying all client demands .",
    "they propose both an ilp and a heuristic to solve such problem .",
    "also @xcite considers the vnf orchestration problem with vnf switching piece - wise linear latency function and bit - rate compression and decompression operations .",
    "two different objective functions are studied : one minimizing costs and one balancing the network usage .",
    "[ [ placement - with - protection ] ] placement with protection + + + + + + + + + + + + + + + + + + + + + + + + +    in @xcite vms are placed with a protection guaranteeing @xmath4-resiliency , that is at least @xmath4 slaves for each vm .",
    "the authors propose an integer formulation that they solve by means of constraint programming . in  @xcite the recovery problem of a cloud system",
    "is considered where slaves are usually turned off to reduce energy consumption but can be turned on in advance to reduce the recovery time .",
    "the authors propose a bicriteria approximation algorithm and a greedy heuristic . in  @xcite",
    "the authors solve a problem where links connecting datacenters may fail , and a star connection between vms must be found minimizing the probability of failure .",
    "the authors propose an exact and a greedy algorithms to solve both small and large instances , respectively . within disaster - resilient vm placement",
    ", @xcite proposes a protection scheme in which for each master a slave is selected on a different datacenter , enforcing also path protection . in  @xcite",
    "the authors solve the problem of placing slaves for a given set of master vms without exceeding neither servers nor link capacities .",
    "their heuristic approaches decompose the problems in two parts : the first allocating slaves , and the second defining protection relationships .    in a recent work",
    "@xcite , the authors model the vm availability by means of a probabilistic approach and solve the placement problem over a set of servers by means of a nonlinear mathematical formulation and greedy heuristics . this is the only work offering an estimation of the availability of the system .",
    "however , it considers only the availability of the servers , while in our problem we address a more generic scenario : when datacenters are geo - distributed , a client request shall be assigned to the closest datacenter , since longer connections may have a higher failure rate .",
    "therefore , the source of the client requests may affect the placement of the vnfs on the nfvi , and must be taken into account in the optimization process and in the estimation of the availability .",
    "in the following we propose a formal definition to the ha - vnfp and a mathematical programming formulation .",
    "[ [ clusters - and - servers ] ] clusters and servers + + + + + + + + + + + + + + + + + + + +    we are given the set of clusters @xmath5 and the set of servers @xmath6 .",
    "each server @xmath7 belongs to a cluster @xmath8 , and we define as @xmath9 the set of servers of cluster @xmath10 .",
    "we represent the usual distinct types of computing resources ( cpu , ram , ... ) of server @xmath11 by the same global amount @xmath12 of available resources .",
    "[ [ virtual - network - functions ] ] virtual network functions + + + + + + + + + + + + + + + + + + + + + + + + +    a set @xmath13 of vnf types is given .",
    "each vnf instance runs on a single server .",
    "each server can host multiple vnf instances , but at most one master for each type .",
    "[ [ networks ] ] networks + + + + + + + +    an inter - cluster network allows synchronization between clusters , while an access network connects clusters to a set of access points @xmath14 .",
    "we are given sets @xmath15 and @xmath16 of logical links @xmath17 connecting clusters @xmath18 , and logical links @xmath19 connecting cluster @xmath20 to access point @xmath21 , respectively .    [ [ clients - requests ] ] clients requests + + + + + + + + + + + + + + + +    a set of clients requests @xmath22 is given .",
    "each request @xmath23 is a tuple @xmath24 of the requested vnf type @xmath25 , a subset of available access points @xmath26 , and the resources demand @xmath27 .    [ [ availability ] ] availability + + + + + + + + + + + +    taking into account explicit availability in nfvi design becomes necessary to ensure slas  @xcite .",
    "we suppose that the availabilities of each component ( server , cluster , vnf , link ) are given ( see [ tab : data ] ) , each corresponding to the probability that a component is working .    [ [ objective - function ] ] objective function + + + + + + + + + + + + + + + + + +    all clients requests must be assigned to servers maximizing the availability of the system , we measure as the minimum availability among all requests .",
    "c|l|c|l @xmath5 & set of clusters & @xmath6 & set of servers + @xmath28 & set of servers in cluster @xmath10 & @xmath13 & set of vnf types + @xmath22 & set of requests & @xmath14 & set of access points + @xmath29 & set of synchro .",
    "links & @xmath16 & set of access links + @xmath30 & set of request access points & + @xmath31 & capacity of server @xmath7 & @xmath32 & demand of request @xmath33 + @xmath8 & cluster of server @xmath7 & @xmath34 & vnf of request @xmath33 + @xmath35 & availability of vnf @xmath36 & @xmath37 & availability of server @xmath7 + @xmath38 & availability of synchro . link @xmath39 & @xmath40 & availability of access link @xmath41 + @xmath42 & availability of cluster @xmath10 & +      concerning the assignment of requests , we can prove that :    [ theo : feasibility - split ] when demand split is allowed and @xmath43 , ha - vnfp has always a feasible solution that can be found in polynomial time .",
    "in fact since the requests can be split among servers , the feasibility of an instance can be found applying a next - fit greedy algorithm for the bin packing problem with item fragmentation ( bppif ) @xcite : servers can be seen as bins , while requests as items that must be packed into bins .",
    "the algorithm iteratively pack items to an open bin . when there is not enough residual capacity , the item is split , the bin is filled and closed , and a new bin is open packing the rest of the item .",
    "when requests can be split , such algorithm produces a feasible solution for the ha - vnfp : if a request is assigned to a server , then a master vnf serving such a request is allocated on that server too .",
    "the next - fit algorithm runs in @xmath44 and therefore a feasible solution can be found in polynomial time .",
    "[ theo : feasibility - nosplit ] the feasibility of a ha - vnfp instance without demand split is a @xmath0-hard problem .",
    "indeed we can see again the feasibility problem as a bin packing problem ( bpp ) .",
    "however , without split each item must be fully packed into a single bin .",
    "therefore , finding a feasible solution is equivalent to the feasibility of a bpp , which is @xmath0-hard , and it directly follows that :    [ theo : complexity - nosplit ] the ha - vnfp without demand split is @xmath0-hard .",
    "that is , for unsplittable demands , it is @xmath0-hard finding both a feasible solution and the optimum solution .",
    "it is less straightforward to also prove that :    [ theo : complexity - split ] the ha - vnfp with demand split is @xmath0-hard .",
    "in fact , let us suppose a simple instance where all components ( servers , clusters , links , ... ) are equal ones and where @xmath45 , which means that there will be no slaves in our placement .",
    "the problem can be seen again as a bppif in which the objective is to minimize the number of splits of the item that is split the most : in fact , every time a request is split , the availability of the system decreases . in such scenarios",
    "the best solution is the one in which no request is split at all - however , if we could solve such a problem in polynomial time , then we could solve also the feasibility problem of a bpp in polynomial time , which instead is @xmath0-hard . therefore , since we can reduce a feasibility problem of bpp to an instance of bppif , and the latter to an instance of ha - vnfp , the ha - vnfp with split is @xmath0-hard .      in the following we propose a mathematical programming formulation of ha - vnfp starting from the definition of the set of the solutions : a _ request assignment _",
    "@xmath46 is a pair @xmath47 indicating the subset of servers @xmath48 running either the master or the slaves of a vnf instance , and the server @xmath49 where the master is placed .",
    "we also define @xmath50 as the set of all request assignments . an _ assignment configuration _",
    "@xmath51 ( see [ fig : assignment - configurations ] ) is a set of all request assignments @xmath46 for all the fragments of a request .",
    "we define as @xmath52 the set of all assignment configurations @xmath51 , that is @xmath53    , where request @xmath54 is split and assigned to two different master vnfs on servers @xmath55 and @xmath56 . both masters have slaves : the master vnf on server @xmath55 has slaves on servers @xmath2 and @xmath57 , while the one on server @xmath56 has slaves on servers @xmath3 and @xmath58 . ]",
    "[ [ availability - computation ] ] availability computation + + + + + + + + + + + + + + + + + + + + + + + +    we compute the nfvi availability for a request @xmath33 by means of a probabilistic approach @xcite .",
    "given a cluster and a set of access points , @xmath59 is the function computing the probability that at least one of the access links is working : @xmath60 given a vnf and a set of servers , @xmath61 is the function computing the probability that at least one instance of vnf is working : @xmath62 given a request @xmath33 and a request assignment @xmath63 , @xmath64 is the function computing the probability that at least one of the instances of @xmath46 is working : @xmath65\\end{gathered}\\ ] ] when a request @xmath33 is split , we compute its availability @xmath66 as the probability that all of its parts succeed : @xmath67 we remark that such formula is nonlinear and produces a integer nonlinear programming formulation which can not be solved by common integer solvers like cplex .",
    "therefore we propose a mip linearization of such nonlinear formulation in which for each assignment configuration @xmath68 we have a binary variable stating if such configuration is selected in the solution .    [ [ variables ] ] variables + + + + + + + + +    the following variables are needed : @xmath69    [ [ model ] ] model + + + + +    ha - vnfp can be modeled as follows : @xmath70 constraints and ensure that each request is fully assigned and selects an assignment configuration , respectively . constraints and set the allocated resources of masters and slaves , respectively .",
    "constraints ensure that servers capacities are not exceeded .",
    "constraints impose that at most one assignment configuration is selected for each request .",
    "constraints compute the minimum availability .",
    "our formulation can model both the ha - vnfp with and without split : in fact by simply setting @xmath71 for each configuration @xmath51 we forbid configurations splitting a request .",
    "solving ha - vnfp as a mip using an integer solver works only for small nfvi , since the number of variables is exponential w.r.t the size of the instances .",
    "therefore we propose two different heuristic approaches for ha - vnfp : the first is an adaptation of well - known greedy policies for the bpp that will serve as comparison , while the second is a _ variable neighborhood search _ heuristic using different algorithmic operators to explore the neighborhood of a starting point .",
    "most of the heuristics for the placement of vms or vnfs are based on a greedy approach , and bpp heuristics are often exploited to obtain suitable algorithms for the placement , such as in @xcite .",
    "we also exploit bpp heuristics to obtain three different greedy approaches for the ha - vnfp : _ best availability _ , _ best fit _ , and _ first fit _ greedy heuristics .",
    "the algorithm , reported in [ algo : greedy ] , starts from an empty initial placement and for each request @xmath33 it looks for a server having enough residual capacity to satisfy the demand @xmath32 .",
    "if such a server is found , then the request is assigned to it , otherwise the algorithm fails without finding a feasible solution .",
    "however , we can observe that :    when @xmath72 and split is allowed , our greedy heuristic always finds a feasible solution .",
    "in fact we can always split a request between two servers , as stated also in [ theo : feasibility - split ] .",
    "the selection of the server is performed by the procedure @xmath73 which discards the servers without sufficient resources to satisfy demand @xmath74 , and selects a server depending on the chosen policy :    * _ best fit _ : the server whose capacity best fits the demand ; * _ first fit _ :",
    "the first server found ; * _ best availability _ : the server with the highest availability",
    ".    while the first three policies are well - know for the bpp , the fourth one is designed for the ha - vnfp .",
    "master vnfs are placed during the assignment of the requests .",
    "then , in a similar way , the algorithm places additional slaves : for each master the algorithm looks for a server having enough capacity for a slave still using @xmath75 procedure . after a server is found",
    ", the slave is placed .",
    "such a procedure is repeated until no additional slave is placed .",
    "@xmath76 assignment of requests create vnf @xmath34 if it does not exists in @xmath77 assign request @xmath33 to server @xmath78 in @xmath77 demand @xmath32 is decreased infeasible add slaves @xmath79 servers of @xmath6 without @xmath80 and its slaves create slave of vnf @xmath80 on server @xmath78 in @xmath77 @xmath77      the _ variable neighborhood search ( vns ) _ is a meta - heuristic that systematically changes the neighborhood within the local search algorithm , in order to escape from local optima . in other words",
    ", it starts from an initial solution , applies a local search algorithm until it improves , and then changes the type of local search algorithm applied to change the neighborhood .",
    "our vns algorithm explores @xmath81 different neighborhoods and it is initialized with several starting points , each obtained using a different greedy algorithm .",
    "@xmath82 , , @xmath83 @xmath84 @xmath85 @xmath86 @xmath87 apply @xmath88 to @xmath77 @xmath89 * break * @xmath90    the main logic of our vns algorithm is sketched in [ algo : vns ] : we generate @xmath91 starting points by using the greedy heuristics of [ sec : greedy ] and we explore their neighborhood for a placement improving the availability .",
    "if no improvement can be found , the algorithm switches the neighborhood .",
    "indeed applying local search is time expensive , but we can observe that a max - min objective function divides the requests in two sets : a set of requests having an availability equal to the objective function and another set having a better availability .",
    "we refer to the former as the set of the _ worst requests _ , since they are the ones whose improvement will also improve the availability of the entire solution . to reduce the computing time and focus our algorithm we found to be profitable to restrict the explored neighborhood to the worst requests only .",
    "also , after applying each operator we look for new slaves , as in the greedy procedure [ algo : greedy ] .    given two feasible placements , we say that one is improving if it has a higher availability or if it has the same availability but fewer worst requests .    in the following",
    "we describe the neighborhoods of our vns .",
    "[ [ vnfs - swap ] ] vnfs swap + + + + + + + + +    the first neighborhood consists of swapping vnfs ( see [ fig : vnf - swap - n ] ) : given a vnf , we swap it with a subset of vnfs deployed on a different server . if the placement is improved , then we store the result as the best local change .",
    "in general our operator is @xmath92 but we found profitable to set an upper bound of @xmath93 to the cardinality of the set of swapped vnfs , obtaining a @xmath94 operator .     and",
    "@xmath3 are swapped .",
    "if a vnf is a master , then all its assigned requests are redirected to the new server.,title=\"fig : \" ]   and @xmath3 are swapped .",
    "if a vnf is a master , then all its assigned requests are redirected to the new server.,title=\"fig : \" ]   and @xmath3 are swapped .",
    "if a vnf is a master , then all its assigned requests are redirected to the new server.,title=\"fig : \" ]    [ [ slave - vnfs - swap ] ] slave vnfs swap + + + + + + + + + + + + + + +    we explore the neighborhood where a slave vnf is removed to free resources for an additional slave of a different master vnf ( see [ fig : b - swap - n ] ) .",
    "the complexity of this operator is @xmath94 .",
    "[ [ requests - swap ] ] requests swap + + + + + + + + + + + + +    we also explore the neighborhood where requests are swapped ( see [ fig : r - swap - n ] ) : given a request we consider a subset of requests assigned to a different server and then swap the former with the latter . similarly to the swap of vnfs , the complexity of this operator is @xmath95 .",
    "however , by setting an upper bound of @xmath93 to the cardinality of the swapped requests set we obtain a @xmath44 operator .     and @xmath96 are swapped changing the respective servers . when swapping a request , a new vnf instance is created if none existed on the new server .",
    ", title=\"fig : \" ]   and @xmath96 are swapped changing the respective servers . when swapping a request , a new vnf instance",
    "is created if none existed on the new server .",
    ", title=\"fig : \" ]   and @xmath96 are swapped changing the respective servers . when swapping a request , a new vnf instance",
    "is created if none existed on the new server .",
    ", title=\"fig : \" ]    [ [ request - move ] ] request move + + + + + + + + + + + +    in the last exploration we consider the neighbors where a request is simply moved to a different server ( see [ fig : r - move - n ] ) .",
    "the complexity of this operator is @xmath97 .",
    "is moved and assigned to a different server .",
    ", title=\"fig : \" ]   is moved and assigned to a different server .",
    ", title=\"fig : \" ]   is moved and assigned to a different server .",
    ", title=\"fig : \" ]    in principle , even if all the operators polynomial time our vns algorithm is not .",
    "however , an upper bound @xmath4 to the number of iterations can be set , obtaining a @xmath98 heuristic .",
    "also , in the following we show that our vns requires small computing time for nfvi of limited size and it can be parameterized to end within a time limit , making it suitable for both online and offline planning .",
    "we evaluate empirically the quality of our methodologies : the greedy heuristic using four different policies ( best fit , first fit , and best availability ) , the vns algorithm , and the mathematical programming formulation as a mip .",
    "however we could run our mip only on small instances with @xmath91 or @xmath81 servers and @xmath99 requests . in our framework",
    "we first run the algorithms using the demand load balancing policy , and allowing split only if the former fails to assign all the requests .",
    "all methodologies are implemented in c++ , while cplex 12.6.3 @xcite is used to solve the mip .",
    "the simulations have been conducted on intel xeon x5690 at 3.47 ghz .",
    "we also produced a graphical dss tool integrating the vns and the greed algorithms ( in python ) working on arbitrary 2-hop topologies and made it available in  @xcite .",
    "we generated a random dataset consisting of instances that differ for the number of requests , total amount of computing resources , and availabilities of the network components .",
    "we set the number of vnf types provided by our nfvi to @xmath100 .",
    "we assumed an nfvi with @xmath91 clusters ( @xmath101 ) and @xmath91 access points ( @xmath102 ) .",
    "each request has a random demand @xmath103 $ ] , while each server has a random capacity @xmath104 $ ] .",
    "the availabilities of all the components of our nfvi are selected between @xmath105 as in @xcite .",
    "we generated @xmath106 instances for each combination of :    * number of requests @xmath107 ; * number of access points for each request @xmath108 .",
    "the number of servers depends on the number of requests , the total amount of the demands , and the random capacities : we generated a set of servers such that their capacities are enough to serve all the demands @xmath109 .",
    "note that such condition guarantees the feasibility only when splitting requests is allowed .",
    "servers are randomly distributed among all the clusters , in such a way that for each pair of clusters @xmath10 and @xmath110 we have @xmath111 under these conditions we obtained instances with around @xmath91 servers when @xmath112 and @xmath113 servers when @xmath114 .",
    "we first evaluate the quality of our vns heuristic against the solutions obtained by the mip solver and the greedy heuristics . in order to study",
    "how the nfvi behaves on different levels of congestion , we let its computing resources to grow from an initial value of @xmath115 , to @xmath116 , with a step of @xmath117 .",
    "due to the exponential number of the variables of our formulation , the mip solver could handle only small instances with @xmath99 requests .",
    "all tests have been performed setting a time limit of two hours each and all the algorithms managed to assign all requests without splits .    in [ fig : test - time - random ] we show the average computing time of the algorithms : while the mip hits several times the time limit , computing times are negligible for all the heuristics , and vns can be considered as a good alternative for online orchestration when the set of the requests is small .",
    "the optimization problem seems harder when the amount of computing resources is scarce : in fact , the average computing time of the mip is closer to the time limit when the overall capacity is less than @xmath118 . instead , with higher quantities of resources the mip always find the optimal solution within the time limit .    in [ fig : test - availability-50 ] we show that the results of our vns heuristic are close to the mip ones , while there is a significant gap between the latters and the greedy heuristic ones . in fact , both the mip and the vns succeed in finding solutions with an availability of three nines even with scarce resources .",
    "eventually all the algorithms reach an high level of availability when computing resources are doubled .    in [ fig : availability-50-aps ] we show the variation of the availability when the number of access points for each request increases : in [ fig : availability-50 - 11 ] , [ fig : availability-50 - 22 ] , and [ fig : availability-50 - 33 ] we report the average availability when requests can be routed to the nfvi using @xmath93 , @xmath119 , and @xmath91 access points , respectively .",
    "the path protection obtained by using more than one access point substantially increases the level of the availability .",
    "however , having more than @xmath119 access points does not provide additional benefits .",
    "[ fig : availability-100-vns ]      in a second round of experiments , we evaluated how our vns algorithm behave when scaling up the number of requests .",
    "however , when the number of servers increases its is not possible to use the mip .",
    "therefore , in the following analysis we compare the results of our vns algorithm to the greedy ones only .",
    "in addition , since our vns algorithm has not polynomial time complexity , we include in the comparison the results obtained by setting a time limit of @xmath120 at the exploration of each starting solution",
    ".    we can first observe in [ fig : test - time - big ] that the computing time of the vns algorithm grows exponentially when the number of requests increases . indeed setting a time limit",
    "reduces the overall computing time , which is always less than a minute .    in [ fig : test - availability - big ]",
    "we show that on average there is always a substantial gap between the results obtained by our vns algorithms and the greedy heuristics .",
    "we can also observe that on average the vns time limit does not penalize substantially the results .",
    "therefore our vns algorithm with time limit can reduce computing times with minimal loss in availability .    from [ fig : availability-100 ] to [ fig : availability-500 ] we show the results on instances having from @xmath121 to @xmath122 requests individually .",
    "we can observe that the greedy heuristics progressively loose in quality of the solutions , and the gap with the vns algorithms increases with the number of the requests .    finally in [ fig : availability - vns ]",
    "we show only the results concerning the vns algorithm without time limit and how it behaves when both the number of requests and the overall capacity increase .",
    "we can observe that the curves are similar and the quality of the solutions provided by our algorithm is not affected by the increasing of the size of the instances .",
    "our vns algorithm always provides placements with an availability of three nines even when resources are scarce , and it always reaches four nines when the capacity is doubled .",
    "we defined and modeled the ha - vnfp , that is the problem of placing vnfs in nfvi guaranteeing high availability .",
    "we provided a quantitative model based on probabilistic approaches to offer an estimation of the availability of a nfvi .",
    "we proved that the arising nonlinear optimization problem is @xmath0-hard and we modelled it by means of a linear formulation with an exponential number of variables .",
    "however , to solve instances with a realistic size we designed both efficient and effective heuristics . by extensive simulations ,",
    "we show that our vns algorithm finds solution close to the mip ones , but in computing times smaller of orders of magnitude .",
    "we highlighted the substantial gap between the availability obtained using classic greedy policies , and the one obtained with a more advanced vns algorithm , when the nfvi is congested .",
    "our vns algorithm showed to be a good compromise to solve ha - vnfp in reasonable computing time , proving to be a good alternative for both online and offline planning .",
    "we integrated our ha - vnfp algorithms in a graphical simulator made available with tutorial videos in  @xcite .",
    "this article is based upon work from cost action ca15127 ( `` resilient communication services protecting end - user applications from disaster - based failures - recodis '' ) supported by cost ( european cooperation in science and technology ) .",
    "this work was funded by the anr reflexion ( contract nb : anr-14-ce28 - 0019 ) and the fed4pmr projects ."
  ],
  "abstract_text": [
    "<S> virtual network functions as a service ( vnfaas ) is currently under attentive study by telecommunications and cloud stakeholders as a promising business and technical direction consisting of providing network functions as a service on a cloud ( nfv infrastructure ) , instead of delivering standalone network appliances , in order to provide higher scalability and reduce maintenance costs . </S>",
    "<S> however , the functioning of such nfvi hosting the vnfs is fundamental for all the services and applications running on top of it , forcing to guarantee a high availability level . indeed </S>",
    "<S> the availability of an vnfaas relies on the failure rate of its single components , namely the servers , the virtualization software , and the communication network . </S>",
    "<S> the proper assignment of the virtual machines implementing network functions to nfvi servers and their protection is essential to guarantee high availability . </S>",
    "<S> we model the high availability virtual network function placement ( ha - vnfp ) as the problem of finding the best assignment of virtual machines to servers guaranteeing protection by replication . </S>",
    "<S> we propose a probabilistic approach to measure the real availability of a system and design both efficient and effective algorithms that can be used by stakeholders for both online and offline planning . </S>"
  ]
}