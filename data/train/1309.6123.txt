{
  "article_text": [
    "the amount of mobile data traffic is growing tremendously .",
    "the total global mobile traffic was about @xmath0 petabytes per month at the end of 2012 , and is expected to keep increasing @xcite . as traditional techniques for increasing the capacity of wireless systems have their limits , new ways of reducing the load of the access network are needed .",
    "recently , device - to - device ( d2d ) communication has been suggested as a means of increasing the capacity and the throughput of cellular systems , as well as improving the energy consumption of user devices , see @xcite-@xcite . as the storage capacity of mobile devices increases ,",
    "data files could be stored and retrieved from the mobile users themselves in order to offload download traffic from the infrastructure network .",
    "distributed storage in delay tolerant , ad hoc and d2d networks has been suggested in  @xcite . in these , mobile terminals ( with backup connections to an infrastructure network ) are used to cache and distribute data files . to increase the reliability of transmissions within the storage community",
    ", packet level erasure coding is investigated in  @xcite .    in this paper , we concentrate on a system consisting of a base station and a set of mobile users within the range of the base station , forming a d2d storage community .",
    "the community consists of mobile users that will , sooner or later , leave the system . in order to avoid losing stored data files",
    ", redundancy can be added to the stored data . the simplest way to do",
    "this is to store several copies of the files .",
    "however , erasure coding can increase the performance of distributed data storage @xcite .",
    "further , codes that are tailor - made for distributed storage can improve system performance @xcite .",
    "we apply regenerating codes @xcite to a d2d storage community and assess their performance . in  @xcite",
    ", we investigated a similar system , under more complicated assumptions . here , we assume a wide - sense stationary storage community , with a constant expected number of nodes .",
    "we assume that the community is able to recover and regenerate the lost data after each single node departure before another departure takes place .",
    "we concentrate on the communication cost incurred by file requests and storage regeneration , assuming that the nodes have infinite storage capacities .",
    "we find that , under the considered system assumptions , the simplest method of storing redundancy , i.e. storing one redundant replica of a file , is also the optimal method in terms of energy consumption .",
    "it should be noted that , in this paper , we fully confine ourselves to assessing the theoretical performance of the storage and distribution methods at hand , and that we do not discuss the practical implementation of such methods .",
    "likewise , we do not go into d2d device discovery , signaling , synchronization , power control , code construction etc .",
    "the remainder of this paper is organized as follows : section [ systemmodelsec ] explains the system model that we use throughout this paper .",
    "section [ analysissec ] derives analytical expressions for the select distribution methods .",
    "section [ numericalresultssec ] shows both theoretical and simulated numerical results .",
    "finally , section [ conclusionssec ] provides concluding remarks .",
    "we consider a wireless cellular system where mobile devices , referred to as nodes , roam freely in and out of a geographically limited area .",
    "we assume that the nodes themselves can be used to store ( cache ) data and they can , upon request , transmit data to one another .",
    "a set of nodes that are within a specified distance from each other forms a storage community , or a local network .",
    "the local nodes can communicate with each other in d2d mode , without the help of the base station .",
    "also , the base station can be used to transmit data to the nodes but there is no need to relay data from a node to another node via the base station .",
    "nodes arrive in the system according to a poisson process with exponentially distributed inter - arrival times .",
    "the expected time for which a single node sojourns in the system is denoted by @xmath1 , the expected _",
    "node lifetime_. the expected _ number of nodes _ in the system is denoted by @xmath2 . by little s law @xcite ,",
    "the _ arrival rate _ of the nodes is @xmath3 .",
    "the expected inter - arrival time of two consecutive nodes is @xmath4 , which is also the expected time between two consecutive node departures .",
    "these times are exponentially distributed .",
    "the flow into system equals the flow out of the system , and the number of nodes fluctuates around @xmath2 .",
    "[ fluct ] exemplifies this fluctuation .",
    "and the expected node lifetime is @xmath5 . ]",
    "the time development of the number of local nodes can , thus , be described with the m / m/@xmath6 markov model , depicted in fig .",
    "[ mchain ] .",
    "the steady - state probabilities for the m / m/@xmath6 model are well - known @xcite .",
    "the probability that there are @xmath7 nodes in the system is @xmath8    [ -latex , auto , auto , node distance=2 cm and 2cm , on grid , semithick , state/.style = circle , thick , draw , blue , text = blue , minimum width=1.1 cm ] ( x ) @xmath2 ; ( xm ) [ left = of x ] @xmath9 ; ( xp ) [ right = of x ] @xmath10 ; ( finish ) [ left of = xm ] ... ; ( end ) [ right of = xp ] ... ; ( finish ) edge [ bend right=-45,color = eogreen ] node[above=0.1cm]@xmath11 ( xm ) ; ( xm ) edge [ bend right=-45,color = eogreen ] node[above=0.1cm]@xmath11 ( x ) ; ( x ) edge [ bend left=45,color = eogreen ] node[above=0.1cm]@xmath11 ( xp ) ; ( xp ) edge [ bend right=-45,color = eogreen ] node[above=0.1cm]@xmath11 ( end ) ; ( end ) edge [ bend right=-45,color = red ] node[below=0.1cm]@xmath12 ( xp ) ; ( xp ) edge [ bend right=-45,color = red ] node[below=0.1cm]@xmath13 ( x ) ; ( x ) edge [ bend left=45,color = red ] node[below=0.1cm]@xmath11 ( xm ) ; ( xm ) edge [ bend right=-45,color = red ] node[below=0.1cm]@xmath14 ( finish ) ;    we assume that local nodes themselves can be used to cache data .",
    "for simplicity , we assume that the storage capacity of each node is infinite .",
    "we rationalize this by observing that the storage capacity of mobile devices has been dramatically increasing .",
    "this is why we presume that each node has some free capacity that could be used for the common good .",
    "the main motivation for assuming an infinite storage capacity is that the storage problem of multiple files decouples .",
    "accordingly , it is sufficient to consider the storage and distribution problem of a single file , with a specified request rate .",
    "we denote the request rate of one file by one local node by @xmath15 .",
    "the inter - arrival time of two consecutive file requests follow the exponential distribution with mean @xmath16 .",
    "we normalize the size of the file to @xmath17 ( bit ) .",
    "similarly , we say that the cost ( in transmit energy ) of transmitting one file from a local node to another local node is also @xmath17 ( joule ) .",
    "all the simplifying assumptions mentioned here allow for tractable , tangible results .",
    "we assume that there is one data file . at random time instants , local nodes request the file and download it .",
    "the file can either be retrieved from the base station or from the local nodes through d2d communications .",
    "it is , on average , @xmath18 times as expensive to download a bit from the base station as compared to downloading a bit from another local node , with @xmath19 .",
    "the caching model is depicted in fig .",
    "[ bs ] .",
    "the downloading node can download the file from the local nodes only if the file is cached . in this paper",
    ", we compare two caching methods :    * _ simple caching _ : if the requested file is already cached on another local node , the caching node transmits the file to the requesting node in d2d mode . if the file is not cached on any of the local nodes , the base station transmits the file to the requesting node .",
    "thence , the requesting node caches the file and , later on , transmits it to other users upon request .",
    "only one local node at a time is caching the data file and , thus , there is no redundancy . *",
    "_ redundant caching _ : a subset of the local nodes is used to transmit parts of the file to the downloading node and the original file is reconstructed at the downloading node . two or more nodes",
    "are caching the file or a fraction of the file .",
    "one of the caching nodes is redundant .",
    "the simplest way of redundant caching is allocating two exact replicas of the whole file on two different nodes .",
    "we call this method _ 2-replication_.    retrieving a file from the base station is never beneficial as long as the file is available in the storage community , and it is more expensive to retrieve data from the base station than to retrieve data from another node .",
    "we assume that the file is always available  only the cost ( in transmit energy ) and the data traffic load on the base station change depending on the distribution method . whether it is beneficial to use _ simple caching _ or _ redundant caching _",
    "depends on the system parameters and the popularity ( request rate ) of the requested file .",
    "( base ) bs ; ( base.100 )  ( base.80 )  ( base.110 )  ( base.70 ) ",
    "( base.north west ) ",
    "( base.north east ) ; ( base.100 )  ( base.70 ) ( base.110 )  ( base.north east ) ; ( [ yshift=0pt]base.north ) [ antenna=1 ] ; / in 3.5/0.2/ ( , ) circle ( .3 cm ) ; / in 5.0/0.5/,6.3/-0.14/ ( , ) circle ( .3 cm ) ; / in 2.7/1.3/,5.4/-1.3/,3.7/-1.34/,2.4/-0.66/,4.85/1.7/,6.0/1.25/,7.0/-1.1/,7.2/1.0/,4.6/-0.6/,4.1/1.0/ ( , ) circle ( .3 cm ) ; ( 0.5,1.2 ) edge node [ sloped , below , text = black , opacity=1 ] r ( 3.0,0.4 ) ; ( 4.6,0.4 ) edge node [ sloped , below , text = black , opacity=1 ] 1 ( 3.9,0.25 ) ;    we define the _ cost _ as the expected total amount of transmit energy per time unit that must be used by the local nodes and the base station .",
    "our objective is to find expressions for the expected total cost of different distribution methods given the system parameters @xmath20 and @xmath1 .",
    "eventually , we find the distribution method that yields the smallest expected cost given the aforementioned system parameters .",
    "in this section , we derive closed - form expressions ( approximations ) for the expected total costs of simple caching and redundant caching . later in this section ,",
    "we compare these methods with each other .      initially , suppose that the file is already cached on one of the local nodes",
    ". thus , as long as the node that is caching the file stays in the system , all file requests result in retrievals from this node .",
    "there are on average @xmath2 local nodes that generate requests , each at rate @xmath15 , and the expected lifetime of any of the nodes is @xmath1 .",
    "therefore , the expected number of requests during the lifetime of the caching node is @xmath21 .",
    "now suppose that the cost of retrieving the file ( of size @xmath17 ) from another local node is simply @xmath17 .",
    "hence , the expected cost of downloading the file from the base station is @xmath18 . if the caching node has left the system , the next node that requests the file has to download it from the base station .",
    "the expected time in which this happens is @xmath16 as the expected total request rate is @xmath22 .",
    "thus , the time in which an expected number of @xmath23 requests are generated is @xmath24 .",
    "the expected cost of these requests is @xmath25 and , thereby , the expected cost of simple caching becomes : @xmath26      here we use a @xmath27 regenerating code @xcite to cache the file on a set of local nodes in a distributed manner .",
    "thus , any @xmath28 nodes that are caching an encoded fraction of the file can be used to reconstruct or repair the file .",
    "the file is fractioned into @xmath28 encoded blocks and one block is allocated to @xmath29 different caching nodes .",
    "one block is redundancy , and @xmath30 .",
    "hence , should any of the caching nodes leave the system , the remaining ( _ surviving _ ) @xmath28 nodes can be used to _ regenerate _ the lost block .",
    "the repair bandwidth of a regenerating code is defined as the number of data communicated when a lost block is regenerated . as we consider infinite storage capacities , only the repair bandwidth of is relevant .",
    "for this reason , we choose to use the minimum bandwidth regenerating ( mbr ) code ( see fig . [ tradeoff ] ) .    )",
    "is @xmath17 .",
    "]    whenever there is a _ failure _ , i.e. one of the caching nodes leaves the system , the lost block is repaired to another local node .",
    "this requires @xmath31 bits to be transmitted for the mbr code with repair degree @xmath32 @xcite .",
    "the repair bandwidth of an mbr code is equal to the size of the encoded ( cached ) block @xmath33 .",
    "thus , in total , @xmath34 bits must be transmitted whenever a local node downloads the file from a set of @xmath28 caching nodes .",
    "next , we derive an approximation for the expected cost of redundant caching with the @xmath35 regenerating code .",
    "we note that the expected state of the system is such that there are @xmath2 nodes in the system and @xmath29 out of these @xmath2 nodes are caching an encoded data block .",
    "the expected sojourn time of all of these @xmath2 nodes in the system equals the expected node lifetime @xmath1 .",
    "when one of these caching nodes leaves , @xmath31 bits need to be communicated in order to repair the lost data block and store it on another node . setting the cost of transmitting a bit from a local node to another local node to @xmath17 ,",
    "the expected repair cost becomes @xmath36 which is , interestingly , independent of @xmath28 , and equals the cost of the repair process of 2-replication as there are two blocks , each of size @xmath17 ( the file size ) . ] the process of 2-replication is depicted in fig .",
    "[ failure ] . even though increasing @xmath28 decreases the repair bandwidth @xmath37 , it also increases the expected number of failures , as a failure takes place whenever a caching node leaves the system .",
    "these effects cancel out each other .    for simplicity ,",
    "let us assume that the number of local nodes never drops below @xmath28 and the repair process is so fast ( immediate ) that no nodes leave the system before the repair process is complete .",
    "thence , we never need to reallocate data from the base station , and only repairs incur upkeep costs . therefore , the expected cost per time unit of redundant caching becomes @xmath38 as all requests result in local downloads and the expected cost of retrieving ( reconstructing ) the file is @xmath39 .",
    "it is easy to see that @xmath40 is minimized at @xmath41 .",
    "this is not a regenerating code  _ the method that minimizes the expected total cost of redundant caching is 2-replication_. note that @xmath42 also minimizes the probability that a file request results in a local download .",
    "this is because in order for a local request to take place , there must to be at least @xmath28 nodes in the system .",
    "the expected cost of 2-replication becomes @xmath43 it should be noted that more than two copies of the file could be replicated on the nodes .",
    "the derivation of the cost in this case would be similar .",
    "having more than just two copies of the file would enable the system to withstand more than one caching node leaving the system .",
    "however , as we assume that the file can be repaired before another node leaves the system , we restrict ourselves to the case where there is only one redundant copy of the data file in the system .    besides having the smallest possible repair bandwidth",
    ", another benefit of 2-replication over regenerating codes is its simplicity .",
    "there is no need to perform excessive computations when the file is reconstructed or requested  the file is simply copied from a caching to the requesting node .",
    "similarly , at repair , the file is simply copied to the newcomer node .",
    "see fig . [",
    "failure ] for an illustration of the repair process .    / in 3.5/0.2/",
    "( , ) circle ( .3 cm ) ; / in 6.3/-0.14/ ( , ) circle ( .3 cm ) ; / in 5.0/0.5/ ( , ) circle ( .3 cm ) ; / in 2.7/1.3/,5.4/-1.3/,3.7/-1.34/,2.4/-0.66/,4.85/1.7/,6.0/1.25/,7.0/-1.1/,7.2/1.0/,4.6/-0.6/,4.1/1.0/ ( , ) circle ( .3 cm ) ; ( 6.6,-0.14 ) edge node [ sloped , below , text = black , opacity=1 ] departure ( 8.9,-0.14 ) ; ( 4.6,0.4 ) edge node [ sloped , below , text = black , opacity=1 ] repair ( 3.9,0.25 ) ;    if 2-replication is used , the file , or a redundant copy of the file , needs to be reallocated from the base station only if the number of nodes drops below two . according to ( [ poisson ] ) , the probability of this is @xmath44 . for large @xmath2",
    ", we can approximate this to be zero ( for instance , already for @xmath45 ) .",
    "this is the reason why we ignore the cost of reallocating the file to the nodes from the base station .",
    "this is also the reason why we assume that , when 2-replication is used , there is always a node to which we can copy the file whenever a caching node leaves the system .",
    "this allows us to approximate the total repair cost in  ( [ repaireq ] ) as @xmath46 , as discussed earlier .",
    "here we derive a straightforward decision rule on when to use simple caching ( without redundancy ) and when to use redundant caching ( 2-replication with one redundant copy ) . simply by setting @xmath47 ( , ) , we find that redundant caching outperforms simple caching if @xmath48 which yields @xmath49    fig .",
    "[ region ] shows the decision boundary of .",
    "it is interesting to note that as long as @xmath50 , the best method is , independently of the other parameters , simple caching .",
    "also , note that @xmath21 can be interpreted as the expected number of file requests made in the system during the lifetime of a single node .",
    "for example , if the expected number of requests during the lifetime of a node is greater than two , @xmath51 is enough to justify redundant caching .",
    "( white region ) , 2-replication yields the lowest expected cost . otherwise ( red region ) , simple caching should be used instead . ]",
    "it might seem tempting to use redundant caching ( 2-replication ) over simple caching whenever condition is met .",
    "however , simple caching only takes up half of the storage space of 2-replication .",
    "consequently , simple caching can store twice as many files as 2-replication .",
    "in addition , 2-replication requires a d2d connection to be established for the repair process whenever a caching node leaves the system .",
    "even though d2d data distribution may reduce the traffic load on the base station and decrease the overall power consumption , it should be noted that the power consumption of the users that store and distribute data may increase considerably . this is why the caching users should be provided with perks , e.g. they could be granted more download bandwidth .",
    "table [ tab ] concludes this section by comparing the expected costs ( or their approximations ) of the considered caching methods .",
    ".comparison of caching methods [ cols=\"^,^,^\",options=\"header \" , ]     [ tab ]",
    "this section provides simulation results of the expected cost for simple caching and 2-replication .",
    "all the simulations are conducted over @xmath52 time units , where @xmath1 is the expected node lifetime , and the average cost per time unit over the runs is presented .",
    "simulation results are compared with the theoretical results .",
    "overall , it can be concluded that the expected theoretical values coincide with the average simulated values .",
    "however , there is some ( yet negligible ) discrepancy due to the random nature of the simulations .",
    "figures [ costvr ] and [ costvn ] illustrate the expected theoretical costs and the average simulated costs as functions of the expected cost ratio @xmath18 and the expected number of nodes @xmath2 , respectively .",
    "the expected cost behaves similarly as a function @xmath2 and @xmath15 ( see table [ tab ] ) .     with parameter values @xmath53 and @xmath54 .",
    "the cost of simple caching is linear w.r.t .",
    "@xmath18 , while the cost of 2-replication is practically independent of @xmath18 .",
    "the simulation results are well in line with equation ; 2-replication outperforms simple caching as long as @xmath55 . ]     with parameter values @xmath56 and @xmath54 . ]     with parameter values @xmath57 and @xmath58 .",
    "as @xmath1 tends to infinity , the expected cost of simple caching tends to @xmath59 as does that of 2-replication ( table [ tab ] ) .",
    "as @xmath1 tends to @xmath60 , the expected cost of 2-replication tends to infinity , while the expected cost of simple caching tends to @xmath61 . ]    finally , fig .",
    "[ costvt ] shows the expected theoretical costs and the average simulated costs as functions of the expected node lifetime @xmath1 .",
    "as @xmath1 tends to infinity , the expected cost of simple caching tends to that of 2-replication , namely , @xmath22 ( table [ tab ] ) .",
    "this means that if the nodes stay in the system for a long period of time , all the file requests result in local downloads from the caching nodes and the distribution method is irrelevant .",
    "conversely , if @xmath1 tends to @xmath60 , the expected cost of 2-replication tends to infinity , while the expected cost of simple caching tends to @xmath62 .",
    "thus , 2-replication should not be used for highly unstable systems with short node lifetimes  a short node lifetime implies a high departure rate of caching nodes and , consequently , a high repair cost .",
    "we have shown that , for the @xmath35 regenerating code , the expected total repair bandwidth is practically independent of @xmath28 and coincides with that of 2-replication .",
    "also , we have demonstrated that , under our assumptions , the expected total cost of 2-replication is lower than that of the aforementioned regenerating code . finally , we have found a simple decision rule for choosing between simple caching and 2-replication in order to minimize the expected total cost in terms of energy consumption .",
    "cisco visual networking index : global mobile data traffic forecast update , 2012 - 2017 . [ online ] .",
    "available : http://www.cisco.com/en/us/solutions/collateral/ns341/ns525/ns537/ + ns705/ns827/white_paper_c11 - 520862pdf .",
    "n. golrezaei , a. g. dimakis , and a. f. molisch ,  base station assisted device - to - device communications for high - throughput wireless video networks , \" _ ieee international conference on communications , realizing advanced video optimized wireless networks _ , 2012 .",
    "a. datta , and f. oggier ,  an overview of codes tailor - made for networked distributed data storage , \" _ association for computing machinery special interest group on algorithms and computation theory news _ ,",
    "1 , march 2013 , pp . 89 - 105 .",
    "a. g. dimakis , p. b. godfrey , y. wu , m. o. wainwright , and k. ramchandran ,  network coding for distributed storage systems , \" _ ieee transactions on information theory _ , vol .",
    "9 , pp . 4539 - 4551 , september , 2010 ."
  ],
  "abstract_text": [
    "<S> as an alternative to downloading content from a cellular access network , mobile devices could be used to store data files and distribute them through device - to - device ( d2d ) communication . </S>",
    "<S> we consider a d2d - based storage community that is comprised of mobile users . assuming that transmitting data from a base station to a mobile user consumes more energy than transmitting data between two mobile users , we show that it can be beneficial to use redundant storage to ensure that data files stay available to the community even if some of the storing users leave the network . </S>",
    "<S> we derive a tractable closed - form equation stating when redundancy should be used in order to minimize the expected energy consumption of data retrieval . </S>",
    "<S> we find that replication is the preferred method of adding redundancy as opposed to regenerating codes . </S>",
    "<S> our findings are verified by computer simulations . </S>"
  ]
}