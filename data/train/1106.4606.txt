{
  "article_text": [
    "we work with decision problems derived from optimization problems . the reader is assumed to have some background in finite model theory .",
    "if not , the book by ebbinghaus and flum @xcite serves as a good introduction .",
    "publications @xcite and @xcite are also relevant material for this line of research .",
    "our main result is the following theorem :    existential second order logic with a first order part that is universal horn ( or simply , eso universal horn ) is insufficient to capture the class * p , the class of problems decidable in polynomial time , even assuming that the input structures come with a successor relation . @xmath0",
    "[ thm : esohierarchy ] *    we provide two proofs of theorem [ thm : esohierarchy ] : ( a ) one based on reduced products , and ( b ) a second proof based on approximability theory ( this proof assumes that * p @xmath1 * np ) . * *    we first introduce some notation and definitions .",
    "* eso universal horn is defined as existential second order ( eso ) logic where the first order part is a universal horn formula . @xmath0 *    * maximum matching .",
    "given an undirected graph @xmath2 and a non - negative integer @xmath3 , is there a matching in @xmath4 such that the number of matched edges is at least @xmath3 ?",
    "assume that @xmath4 has ( i ) no self - loops ; and ( ii ) at most one edge between any pair of vertices .",
    "@xmath0 [ def : matching ] *    ( * a note about k )",
    ".  readers may ask ,  how is @xmath3 represented in the input ?",
    "in binary or unary ? \" .",
    "this may be relevant for problems with large data , such as maximum flow or minimum cost flow , where edge weights are part of the input .",
    "however , the issue is irrelevant for problems such as maximum matching where the solution value lies in the @xmath5 $ ] range , where @xmath6 and @xmath7 is the number of vertices . if @xmath8 , then the solution is immediately disqualified  there can not be a solution to the maximum matching problem with the number of matched edges higher than @xmath9 . if @xmath10 , the input size for @xmath3 is at most that of @xmath9 , whether in binary or unary .",
    "@xmath0 *    for simplicity , assume the following for problem [ def : matching ] :    @xmath11 , where @xmath7 is the number of vertices in the input graph of the problem instance .",
    "also , throughout this article , @xmath3 is a part of the input instance ; it can vary from instance to instance ; it is _ not a fixed constant over all instances . @xmath0",
    "[ ass : kleqn ] _",
    "we represent decision versions of optimization problems as a conjunction of a single objective function constraint ( ofc ) and a set of basic feasibility constraints ( bfc ) .",
    "the motivation for this comes from a general mathematical programming framework where optimization problems are expressed in the form : @xmath12 & \\mbox{subject to the following constraints : } \\\\[2 mm ]    & \\mbox{$\\ds g_i(\\mb{x } ) \\le 0 $ , ~ $ 1 \\le i \\le m$ } , \\\\[1 mm ] & \\mbox{$\\ds h_j(\\mb{x } ) = 0 $ , ~ $ 1 \\le j \\le p$ } , \\\\[2 mm ]    & \\mbox{and $ \\mb{x } \\in x$ ( for example , $ x = \\bb{r}^n$)}. \\end{array}\\ ] ] additionally , for the decision problem , we are given a number @xmath3 as a part of the input .",
    "above , the bfc comprises the @xmath13 constraints @xmath14 and @xmath15 , and the ofc comprises the single constraint @xmath16 for maximization problems ( @xmath17 for minimization problems ) .",
    "the proof is a counterexample .",
    "it relies on the fact that universal horn formulae are preserved under reduced products .",
    "that is , if @xmath18 is a universal horn formula and structures @xmath19 and @xmath20 satisfy @xmath18 , then so does their reduced product @xmath21 .   from the definition of problem [ def :",
    "matching ] , note that any feasible solution to _ maximum matching consists of at least @xmath3 matched edges .",
    "_    maximum matching can not be expressed in eso universal horn logic , even assuming that the input structures come with a successor relation . @xmath0",
    "[ lem : matchingreducedproducts ]    suppose we have a signature divided into two parts : a set of relation symbols @xmath22 , and a separate set @xmath23 of relation and constant symbols .",
    "@xmath24 is true iff @xmath25 is a matched edge .",
    "the relations in @xmath23 are first order ( input ) , hence the horn restriction does not apply to these . on the other hand ,",
    "the relations in @xmath26 are second order ( quantified ) , and hence the horn condition applies to these relations . in particular , it applies to @xmath27 , which is unknown ; it is not a part of the input .",
    "let us introduce this definition ( henceforth referred to as property [ def : maxmatchprop ] ) :    ( maximum matching property ) .",
    "given @xmath28 and an integer @xmath3 , is there a matching @xmath29 such that @xmath30 ? @xmath0 [ def : maxmatchprop ]    let * a and * b be two input structures on the same universe @xmath31 ( @xmath32 ) with a successor relation ; furthermore , for all symbols in the signature @xmath23 , let * a and * b agree on the interpretation of the symbols ; however , they may differ on relations in @xmath26 . * * * *    now define a product structure * a.b to be the structure on the domain @xmath31 with a linear ordering , in which every symbol in the signatures @xmath26 and @xmath23 is interpreted as the _ intersection of the two interpretations in * a and * b.  then it is easy to show that any horn formula @xmath33 that is satisfied in both * a and * b is also satisfied in * a.b .",
    "( this is exactly by the argument that shows that horn formulae are closed under direct products ; see chapter 9 , page 417 , of @xcite , or see page 493 of @xcite . ) * * * * * _ *    then suppose we let * a and * b be structures with , say , @xmath34 vertices @xmath31 .",
    "assume that in both structures , we have edges from the set @xmath35 .",
    "* *    in * a , we let @xmath27 consist of the @xmath36 edges @xmath37 ;  and in * b , we let @xmath27 consists of the @xmath36 edges @xmath38 .  thus @xmath27 indeed defines a matching in both structures .",
    "* *    also , we let @xmath39 in both structures .",
    "so , property [ def : maxmatchprop ] is true in both * a and * b.  that is , there exists a matching of size at least @xmath36 in * a and * b. * * * *    however , property [ def : maxmatchprop ] is false in * a.b , since in this structure , @xmath27 is empty , even though the lower bound @xmath3 is still equal to @xmath36 .",
    "it follows that property [ def : maxmatchprop ] can not be expressed as a horn formula , and hence we conclude that _ maximum matching , a problem in the class * p , can not be expressed in eso universal horn logic .",
    "@xmath0 * _ *    notes on the above proof :    * readers may ask , _ is it not necessary to look for a solution @xmath27 ( a matching ) in the product structure ?  the answer is no , it is _ not necessary .",
    "if property [ def : maxmatchprop ] can indeed be expressed in eso universal horn logic , and assuming that the property is satisfied in * a and * b , then it must be satisfied in the product structure * a.b , according to the results in @xcite and @xcite . * * * _ _ * recall that the proof is a counterexample .",
    "this allows us to choose any value for @xmath27 ( that it could possibly take ) in the structures * a and * b. * * * also note that this proof does _ not deal with the sub - property  @xmath40 \" alone  it deals with the whole _ maximum matching property ( property [ def : maxmatchprop ] ) . _ _ * in place of _ maximum matching , we could have used any decision problem in * p derived from a maximization problem . * _",
    "this proof assumes that @xmath41 .",
    "we use approximability theory to show that some decision problems in the class * p , derived from optimization problems , can not be expressed in eso universal horn logic .",
    "in particular , we rely on proven upper and lower bounds on the approximation ratios ( defined below ) for the vertex cover problem .",
    "we disprove the following proposition , which appeared as a theorem in @xcite ( also as theorem 3.2.17 in @xcite ) : *    assuming a successor relation as a part of the input structure , every problem in the class * p can be expressed in eso universal horn logic . @xmath0",
    "[ thm : esohornyes ] *    @xcite a * np - optimization problem @xmath42 is a tuple @xmath43 , where *    1 .",
    "@xmath44 is a set of instances to @xmath45 , 2 .",
    "@xmath46 is the set of feasible solutions to instance @xmath47 , 3 .",
    "@xmath48 is the _ objective function _ value to a solution @xmath49 of an instance @xmath50 .",
    "it is a function @xmath51 \\rightarrow \\bb{r}^+_0 $ ] ( non - negative reals ) , computable in time polynomial in the size @xmath52 of the domain of @xmath47 , 4 .",
    "for an instance @xmath50 , @xmath53 is either the minimum or maximum possible value that can be obtained for the objective function , taken over all feasible solutions in @xmath54 .",
    "+ @xmath55 ( for np - maximization problems ) , + @xmath56 ( for np - minimization problems ) , 5 .",
    "the following decision problem is in * np : _ given an instance @xmath47 and a non - negative integer @xmath3 , is there a feasible solution @xmath57 , such that @xmath58 ( for an np - maximization problem ) , or @xmath59 ( for an np - minimization problem ) ? _ *    the set of all such np - optimization problems is the @xmath60 class . @xmath0",
    "[ def : npoptproblem ]    note : _ feasibility as defined in point ( ii ) above has nothing to do with any upper or lower bounds on the objective function value @xmath61 .",
    "it only concerns the bfc , see sec .",
    "[ sec : bfcofc ] .",
    "this also applies to def .",
    "[ def : decisionproblem ] below . _    * decision versions .",
    "[ def : npoptproblem ] . given a non - negative integer @xmath3 and an instance @xmath50 , the decision version of an np - optimization problem @xmath42 asks whether there is a feasible solution @xmath57 , such that @xmath58 ( if @xmath42 is a maximization problem ) , or @xmath59 ( if @xmath42 is a minimization problem ) . @xmath0 [ def : decisionproblem ] *    ( see theorem 3.2.17 in page 147 of @xcite . ) if a decision problem @xmath62 can be represented by an eso universal horn sentence , then @xmath62 can solved in polynomial time . @xmath0",
    "[ thm : gradel ]    the above theorem follows from the fact that hornsat ( satisfiability of a propositional horn formula ) can be solved in ptime @xcite .",
    "* approximation ratio .",
    "given an instance @xmath47 of an optimization problem @xmath42 ( as in def .",
    "[ def : npoptproblem ] ) and a feasible solution @xmath57 , the approximation ratio is defined as @xmath63 for minimization problems and @xmath64 for maximization problems .",
    "we assume that @xmath65 , where @xmath66 is the optimal solution value to instance @xmath47 . @xmath0",
    "[ def : approxratio ] *    * approximation problems @xmath67 and @xmath68 . *    : an instance @xmath47 of a problem @xmath69 ( cf .",
    "[ def : npoptproblem ] ) .",
    "( upper bound ) problem @xmath70 .",
    "is there a feasible solution @xmath71 , such that the approximation ratio is at most @xmath72 ?    ( lower bound ) problem @xmath73 .",
    "is there a feasible solution @xmath57 , such that the approximation ratio have the phrase  at most \" in their definitions .",
    "this is * not a typographical error . * ] is at most @xmath74 ?",
    "( @xmath75 . )",
    "[ def : approxproblem ] @xmath0    some remarks about def .",
    "[ def : approxproblem ] ( also see the appendix ) :    a _ feasible solution as mentioned in the definition of @xmath76 and @xmath77 has nothing to do with the objective function value @xmath61 .",
    "hence it has nothing to do with the approximation ratio either .",
    "this feasibility only concerns the constraints in the bfc .",
    "[ sec : bfcofc ] .",
    "[ def : approxproblem ] is irrelevant for problems in * p , hence we assume that the decision version of problem @xmath42 is not known to be polynomially solvable .",
    "@xmath0 *    * the apx class .",
    "consider a problem @xmath42 from the class @xmath60 ( cf .",
    "[ def : npoptproblem ] ) .",
    "then @xmath42 is defined to be a member of apx iff the decision problem @xmath78 can be solved in ptime for some constant @xmath79 . @xmath0",
    "[ def : apx ] *    strictly speaking , the upper bound problem @xmath78 depends on the parameter @xmath72 .  however , for ease of discussion , let us assume that @xmath72 is pre - defined for @xmath80 ; assume that @xmath72 is  in - built \" into @xmath80 .  thus henceforth , we simply write @xmath80 rather than @xmath78 .",
    "we make a similar assumption for the lower bound problem @xmath81 and the related parameter @xmath74 ; we will write @xmath81 rather than @xmath82 .    for a proven upper bound @xmath72 , @xmath83 is ptime solvable . similarly , for a proven lower bound @xmath74 , @xmath84 is np - complete .",
    "example : steiner tree is a problem in apx , with parameter @xmath85 . hence given an instance @xmath47 of the steiner tree problem , there is a ptime algorithm which can decide whether there is a feasible solution to @xmath47 with an approximation ratio of at most two .",
    "however , @xmath72 is an _ upper bound on the approximation ratio ; we know that there is a ptime algorithm that guarantees a feasible solution within this upper bound .",
    "furthermore , many problems ( such as vertex cover , below ) in the class apx also have a proven _ lower bound @xmath74 .  for such problems ,",
    "the approximation problem @xmath86 is known to be * np - complete .",
    "* _ _    * vertex cover ( optimization version ) . *    : a graph @xmath28 .",
    ": mark vertices in @xmath87 in such a way that ( i )  for any @xmath88 where @xmath89 , if @xmath90 , then either @xmath91 of @xmath92 is marked , and ( ii )  the number of marked vertices is to be minimized .    :",
    "a set of marked vertices that obeys property ( i ) .",
    "[ prob : vertexcover ] @xmath0    let @xmath93 and @xmath94 be the approximation problems @xmath95 and @xmath96 respectively ( from def .",
    "[ def : approxproblem ] ) , applied to vertex cover .",
    "@xmath93 and @xmath94 are members of the class * np ; in particular , @xmath93 is a member of the class * p , and @xmath94 is * np - complete . * * *    the upper bound @xmath97 and the lower bound @xmath98 @xcite .  in fact , for @xmath99 , one could use any number @xmath100 such that @xmath101 .  for ease of representation in an eso formula ,",
    "let us use @xmath102",
    ".    here is the [ page : corearg ] core argument :    proposition [ thm : esohornyes ] is incorrect .",
    "[ lem : esohornno ] @xmath0    since @xmath103 , theorem [ thm : esohornyes ] can be applied .",
    "then it follows that @xmath93 can be expressed as an eso universal horn sentence @xmath104 .",
    "this sentence can be written as a conjunction of two sub - formulae :    1 .",
    "( the feasibility condition ) one stating that every edge is covered , which is easily written as @xmath105 and 2 .",
    "( the approximation ratio condition ) another stating that the approximation ratio @xmath106 is at most two , that is , @xmath107    however , if we replace the sub - formula for the condition @xmath108 with the sub - formula for @xmath109 , we obtain a new eso universal horn sentence @xmath110 which captures @xmath94 .",
    "though @xmath111 is known to be * np - complete , we have just obtained an eso universal horn sentence ( @xmath112 ) for this problem , implying that @xmath111 can be decided in ptime , when we apply theorem [ thm : gradel ] .",
    "but this contradicts our assumption that * p @xmath1 * np . @xmath0 * * *    hence we have shown the following :    assuming that * p @xmath1 * np , and assuming a successor relation as a part of the input vocabulary , @xmath93 , a problem solvable in ptime , can not be expressed as an eso universal horn sentence . @xmath0 * *    this concludes the second proof of theorem [ thm : esohierarchy ] .",
    "we note a discrepancy between the results in theorems [ thm : esohierarchy ] and [ thm : esohornyes ] .",
    "we observe that there is a fundamental difference between the types of expressions dealt with by the two theorems .",
    "theorem [ thm : esohierarchy ] is about _ structure level expressions ( sle ) which deal  directly \" with properties of mathematical structures , whereas theorem [ thm : esohornyes ] is about _ machine level expressions ( mle ) which represent encodings of machine level computations of properties ; these merely encode the * steps ( * moves ) of the computation . * * _ _    we note that ( eso universal horn ) = * p at the _ machine level , whereas ( eso universal horn ) @xmath113 * p at the _ structure level . _ * _ *    observe that in the two proofs , we * do not use a turing machine ; the expressions * are not the result of an output from a turing machine computation . * *      the precise definitions for _ structure level and _ machine level are provided later in the paper  but first , we describe intuitive notions . _ _",
    "a few observations are in order :    1 .",
    "descriptive complexity is a very useful tool at the structure level , _ not at the machine level . _",
    "2 .   a large subset of problems in the class *",
    "np is derived from optimization problems , hence this is a important sub - class .",
    "( problem [ def : matching ] has also been derived from an optimization problem . ) * 3 .   in spite of the important sub - class described above",
    ", we were unable to locate any _ structure level expression for such problems in the literature ( although one can construct _ machine level expressions using the methods in @xcite , chapter 7 of @xcite or @xcite ) .",
    "this is a key motivation for our line of research .",
    "_ _    from a mathematician s viewpoint , sle s are the natural choice to express a problem / property , _ not the mle s .  to logically express a property of a given mathematical structure , what is the need to put it through computation first ? _",
    "to write an mle for a given property @xmath114 , we first need to design a tm which will decide whether @xmath114 is true ( for any given input ) . but",
    "this means that the space / time complexity to decide @xmath114 is already known , hence it is pointless writing an mle for @xmath114 .    to elaborate on the item numbered one above : the usefulness of descriptive complexity lies in the fact that if one could write a structure level expression in a certain logic for a decision problem @xmath115 , then it can be deduced that @xmath115 requires a certain amount of resource ( time and/or space ) for its computation ; that is , we can recognize the complexity class that @xmath115 belongs to",
    "however , our main result ( theorem [ thm : esohierarchy ] ) shows that even though a large class of problems ( those derived from optimization ) is ptime solvable , they can not be expressed in eso universal horn logic at the structure level .",
    "hence for such problems , the usefulness of descriptive complexity is lost while using this particular logic .      * machine level expressions ( mle ) .",
    "these express the _ computation of a property ( in a turing machine , for instance ) . here , _",
    "computation of a property is defined as _ checking whether a property is true using a computation device , for a given input . _ _ _ *    such an expression encodes the computation steps of a turing machine ( tm ) , for example , as in the proof by fagin @xcite that eso logic captures the class * np and the proof by immerman @xcite that lfp ( under ordered structures ) captures the class * p.  these expressions state that ( i ) if we go through the steps of a computation device such as a tm , and ( ii ) if the tm finally reaches an accepting state , then the property must be true for the given input structure . * *    for example , to write a machine level expression for _ hamiltonian cycle ( hc ) , we should first design a tm that solves hc , then encode the steps of the tm in an expression . _    * structure level expressions ( sle ) . on the other hand , structure level logical expressions",
    "do not express the _ computation of a property ; rather , they directly express the truth of a property of a mathematical structure .",
    "_ no computation is involved in such a description . _",
    "_ *    _ machine level expressions for the class * np ( class * p ) were provided by fagin @xcite ( grdel @xcite ) respectively . * * _      since the structure level is indeed proven to be different from the machine level , we can then state the following :    at the structure level , the validity of fagin s theorem is completely open  it is unknown whether eso sentences can characterize the class * np at this level . @xmath0 *    in the last 40 years , important contributions have been made at the  machine level \" , such as fagin s theorem and the immerman - vardi theorem .",
    "however , these do not represent the full picture .",
    "the formal mathematical definitions for concepts such as mle and sle explain accurately as to why theorems [ thm : esohierarchy ] and [ thm : esohornyes ] are correct in their respective  domains \" ( the machine computation domain and the mathematical structure domain ) .",
    "we now provide the formal definitions of mle and sle .      given a structure @xmath116 as input , defined on a first order vocabulary @xmath117 , we provide the following definitions :    * higher order predicates are those that are not defined in the first order vocabulary of the input structure . [",
    "def : hopred ] *    \\(a ) let @xmath118 be the set of expressions in logic @xmath119 such that a structure @xmath116 possesses property @xmath114 iff @xmath120 for every expression @xmath121 .",
    "\\(b ) we let @xmath122 be the set of * machine level expressions ( mle ) for @xmath114 .  naturally , @xmath123 .  we define @xmath122 as follows . *",
    "let @xmath124 be turing machines that have at least one halting computation iff @xmath116 possesses property @xmath114 where @xmath125 .",
    "hence when @xmath116 satisfies @xmath114 , let @xmath126 be the @xmath127 halting computation of @xmath124 where @xmath128 .",
    "over the set of all turing machines \\{@xmath129 , the set of halting computations is the set @xmath130 .",
    "let @xmath131 be an encoding of @xmath126 in @xmath119 .",
    "then @xmath122 = @xmath132 .",
    "the predicates that encode machine computations are of higher order ( cf .",
    "[ def : hopred ] ) .",
    "[ def : mle ] @xmath0    above , we say  at least one halting computation \" to take into account the fact that @xmath133 could be a non - deterministic tm .",
    "next , we define structure level expressions , as a subset of @xmath118 .",
    "consider the set @xmath118 in def .",
    "[ def : mle ] .",
    "we let @xmath134 be the set of * structure level expressions ( sle ) for @xmath114 .  naturally , @xmath135 .  we define @xmath134 as follows :",
    "for every expression @xmath136 , ( i ) the higher order predicates of @xmath137 range over tuples from the universe of @xmath116 , and ( ii ) the variables and first order predicate symbols in @xmath137 are from @xmath117 .",
    "[ def : sle ] @xmath0 *      although def .",
    "[ def : mle ] explains how to generate an mle , it does nt tell us how to recognise an mle when we see one ; it does nt tell us how to distinguish an mle from an sle .",
    "this can be achieved quite easily since the vocabulary of the two expression types are different . for an sle ,",
    "the language consists of variables and relation symbols from the input vocabulary @xmath117 of structure @xmath116 ( as in def .",
    "[ def : sle ] ) .",
    "however for an mle , the language consists of * machine encodings for ( i ) the tape symbols of a tm ; ( ii ) the tape head movement and transitions of the tm ; and ( iii ) the variables and relation symbols in @xmath117 as well as the higher order predicate symbols used to encode the computation . *",
    "for the class * p , it is a case of ",
    "easier done than said \" .",
    "one can let the computation of a decision problem run through a turing machine and obtain an expression in eso universal horn logic",
    ". however , _ without computation , eso universal horn is insufficient to capture * p ( we need a stronger logic ) , as the two proofs of theorem [ thm : esohierarchy ] show . * _ *",
    "nerio borges , anuj dawar , ian hodkinson , leonid libkin and anand pillay .    10    i. dinur and s. safra . , 162(1):439485 , july 2005 .    .",
    "springer , 1999 .",
    "r.  fagin . .",
    "in r.  karp , editor , _ complexity of computations _ , pages 4373 .",
    "siam - ams proceedings ( no.7 ) , 1974 .    . .",
    "stacs 1991 : proceedings of the 8th annual symposium on theoretical aspects of computer science  lecture notes in computer science 280 _ , pages 466477 .",
    "springer - verlag , 1991 .",
    "e. grdel , p.g .",
    "kolaitis , l. libkin , m. marx , j. spencer , m.y .",
    "vardi , y. venema , and s. weinstein . .",
    "texts in theoretical computer science .",
    "springer , 2007 .",
    "w. hodges . .",
    "cambridge university press , 1993 .",
    "w. hodges . .",
    "in dov m. gabbay , c.j .",
    "hogger and j.a .",
    "robinson ( eds . ) , _ handbook of logic in artificial intelligence and logic programming ( vol .",
    "1 ) _ , pages 449503 . oxford university press ( ny ) , 1993 .    n. immerman . .",
    "springer - verlag , 1999 .",
    "n. immerman . . ,",
    "68(1 - 3):86104 , 1986 .",
    "jones and w.t .",
    "laaser . . ,",
    "3(1):105117 , october 1976 .",
    "a. panconesi and d. ranjan .",
    "quantifiers and approximation . , 107:145163 , 1993 .",
    "this paper was presented at the asian logic conference , wellington , nz , in december 2011 .",
    "some readers who read a draft of this paper , after reading def .",
    "[ def : approxproblem ] , remarked , ",
    "these problems are very easy \" .",
    "well , i doubt if these problems can be categorised as  very easy \" .",
    "however , points to note include the following :    1 .",
    "a _ feasible solution means that the solution obeys the bfc ( cf .",
    "[ sec : bfcofc ] )  feasibility here has nothing to do with the objective function nor the approximation ratio ; _ 2 .   if @xmath138 , then @xmath139 and @xmath140 has no meaning .",
    "+ conversely , if we can design an algorithm that solves @xmath141 in polynomial time for @xmath139 , then @xmath142 ; 3 .",
    "if the answer is yes ( to either of the problems defined ) , then a  feasible \" solution @xmath143 that obeys the bound ( @xmath72 or @xmath74 ) must be returned ; 4 .",
    "the approximation ratio is _ not given to us ; we are only given a _",
    "bound on the approximation ratio ( @xmath72 or @xmath74 , as the case may be ) ; _ _ 5 .   hence , for the upper bound problem @xmath83 , to answer the question with a yes or no within polynomial time , over all instances",
    ", we should develop a polynomial time algorithm for @xmath42 ( which is not a trivial task for many a problem @xmath69 ) ; and 6 .   for a proven upper bound @xmath72 , @xmath83 is ptime solvable .",
    "similarly , for a proven lower bound @xmath74 , @xmath84 is np - complete .",
    "note that @xmath75 .",
    "it is the gap between @xmath74 and @xmath72 that we seek to exploit .",
    "a reader raised a concern as to why should the expression for @xmath93 consist of a sub - formula for the condition @xmath144 .",
    "the answer is , it is _ not a question of * should , but a question of * can .   yes , we _ can express @xmath93 as a conjunction of the ( sub - formulae ) for the two conditions  the feasibility condition , and the approximation ratio condition ."
  ],
  "abstract_text": [
    "<S> we show that eso universal horn logic ( existential second logic where the first order part is a universal horn formula ) is insufficient to capture * p , the class of problems decidable in polynomial time . </S>",
    "<S> this statement is true in the presence of a successor relation in the input vocabulary . </S>",
    "<S> we provide two proofs  one based on reduced products of two structures , and another based on approximability theory ( the second proof is under the assumption that * p is not the same as * np ) .  </S>",
    "<S> we show that the difference between the results here and those in @xcite , is due to the fact that the expressions this paper deals with are at the  structure level \" , whereas the expressions in @xcite are at the  machine level \"  a case of _ easier done than said . _ * * *    _ keywords : descriptive complexity , optimization , existential second order logic , machine level and structure level . _    </S>",
    "<S> acm subject classification : f.1.3 , f.4.1 . </S>"
  ]
}