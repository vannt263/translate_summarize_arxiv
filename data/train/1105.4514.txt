{
  "article_text": [
    "in information theory , it is known that any binary sequence with a finite period can be generated by a _ binary machine _ shown in figure  [ bin_machine ] @xcite .",
    "an @xmath0-stage binary machine consists of an @xmath0-stage binary register , @xmath0 updating boolean functions , and a clock . at each clock cycle , the current values of all stages of the register are synchronously updated to the next values computed by the updating functions .",
    "binary machines can be viewed as a more general version of feedback shift registers ( fsrs ) .",
    "suppose we would like to construct a binary machine which generates the following binary sequence : @xmath1    since the output of a binary machine equals to the least significant bit of its current state , any assignment of states @xmath2 such that @xmath3 mod @xmath4 results in a binary machine with generates @xmath5 .",
    "for example , we can use @xmath6 where even and odd integers are assigned in an increasing order . from @xmath7",
    "we can easily see how many stages a binary machine should have to generate @xmath8 .",
    "the largest element of @xmath7 is 21 .",
    "we need 5 bits to expand it in binary .",
    "thus , a binary machine generating @xmath8 should have at least 5 stages .",
    "as in the case of traditional finite state machines ( fsm ) synthesis  @xcite , for different state assignments we usually get different next state functions .",
    "the circuit complexity of these functions may vary substantially for different state assignments .",
    "we can also use the one - hot encoding instead of the binary one .",
    "then , the number of stages will increase , but the complexity of functions might decrease in some cases .",
    "next we describe an intuitive idea behind the algorithm for synthesis of parallel binary machines presented in this paper .",
    "suppose that we use the encoding ( 00 ) = 0 , ( 01 ) = 1 , ( 10 ) = 2 , ( 11 ) = 3 to encode the binary sequence @xmath8 from the example above into the following quaternary sequence : @xmath9 we can construct a quaternary machine generating @xmath10 ( in which the stages of the register can store 4 different values and the updating functions are 4-valued ) by choosing a sequence of states @xmath11 such that @xmath3 mod @xmath12 .",
    "for example , we can assign the states as follows : @xmath13 note that the largest element of @xmath14 is 15 .",
    "we need 2 quaternary digits to represent it .",
    "thus , we can generate @xmath10 using a quaternary machine with 2 stages ( see figure  [ bin_mv](a ) ) .",
    "such a quaternary machine can , in turn , be converted into a binary machine by encoding each 4-valued function by a pair of boolean functions and by replacing each quaternary stage by two binary stages ( see figure  [ bin_mv](b ) ) .",
    "the resulting 4-stage binary machine generates the same binary sequence @xmath15 as in the example above , but two bits per clock cycle .",
    "note , that is the example above we needed 5 stages to generate @xmath8 one bit per clock cycle .",
    "so , we constructed a parallel binary machine which has fewer stages than the theoretical lower bound on the number of stages in a binary machines generating the same sequence sequentially bit by bit .",
    "later in the paper , we show that the number of stages can be reduced even further by using the 8-ary encoding . what is even more important , we reduce not only the number of stages , but also the circuit complexity of the updating functions .",
    "our experimental results show that for sequences with high linear complexity such as complementary , legendre , or truly random , parallel binary machines are an order of magnitude smaller than parallel fsrs generating the same sequence .",
    "therefore , the presented approach can potentially be useful for any application which requires sequences with high spectrum efficiency or high security .",
    "such applications include data transmission , wireless communications , cryptography , and many others  @xcite .",
    "a particularly attractive application is encryption and authentication systems for smartcards and radio frequency identification ( rfid ) tags .",
    "a low - cost rfid tag can spare only a few hundred gates for security functionality  @xcite .",
    "none of the available cryptographic systems satisfies this requirement at present  @xcite .",
    "the rest of the paper is organised as follows .",
    "section  [ prel ] describes basic notation and definitions used in the sequel . in section  [ sa1 ] ,",
    "we present an algorithm for constructing an @xmath16-ary machine with the minimum number of stages generating a given @xmath16-ary sequence . in section  [ bin",
    "] , we show how @xmath16-ary machines can be encoded to generate binary sequences in parallel and demonstrate that such an encoding can be of advantage .",
    "section  [ exp ] presents the experimental results .",
    "section  [ con ] concludes the paper .",
    "let @xmath17 . an @xmath16-_ary sequence _ is vector @xmath18 where @xmath19 for all @xmath20 .",
    "if there exist @xmath21 and @xmath22 such that @xmath23 for all @xmath24 , then @xmath5 is called _ eventually _ ( or _ ultimately _ ) _ periodic_. if @xmath25 , then @xmath5 is called _ purely periodic _ , or simply _ periodic_. the least integers @xmath26 and @xmath27 with this property are called _ pre - period _ and _ period _ of the sequence , respectively  @xcite .    for a multiple - valued function @xmath28 , the @xmath29-_set of _ @xmath30 is defined by  @xcite @xmath31 in the binary case , 0-set and 1-set correspond to off - set and on - set of @xmath30 , respectively  @xcite .    an @xmath16-_ary _ @xmath0-_stage machine _ consists of @xmath0 @xmath16-ary storage elements , called _",
    "stages_. each stage @xmath32 has an associated _ state variable _ @xmath33 which represents the current value of the stage @xmath29 and an _ updating function _",
    "@xmath34 which determines how the value of @xmath35 is updated .    a _ state _ of an @xmath0-stage machine is a vector of values of its state variables . at every clock cycle",
    ", the next state of a machine is determined from its the current state by updating the values of all stages simultaneously to the values of the corresponding @xmath36 s .",
    "the _ degree of parallelization _ of an @xmath0-stage machine is the number of stages @xmath37 , @xmath38 , which are used to produce its output at each clock cycle .",
    "[ prev ]    for the case of linear fsrs ( lfsrs ) , there are two main approaches to constructing an lfsr with the degree of parallelization @xmath37 : ( 1 ) synthesis of subsequences representing @xmath37 decimation of some phase shift of the original lfsr sequence and ( 2 ) computation of the set of states reachable from any state in @xmath37 steps .",
    "let @xmath39 be a sequence produced by an lfsr whose characteristic polynomial @xmath40 of degree @xmath0 is irreducible in @xmath41 .",
    "let @xmath42 be a root of @xmath40 and let @xmath43 be the period of @xmath39 . in the method based of synthesis of subsequences  @xcite , the sequence @xmath39 is decomposed into @xmath37 subsequences @xmath44 , each representing a @xmath37 decimation of @xmath45th phase shift of @xmath39 .",
    "in other words , the @xmath29th element of @xmath44 is equal to @xmath46 element of @xmath39 . by zierler s theorem  @xcite , for @xmath47 , the subsequences @xmath44",
    "can be generated by an lfsr with the following properties :    * the minimum polynomial of @xmath48 in @xmath49 is the characteristic polynomial @xmath50 of the new lfsr which has : * * period @xmath51 , * * degree @xmath52 , which is the multiplicative order of 2 in @xmath53 .    the berlekamp - massey algorithm  @xcite or its generalizations  @xcite can be used to find the smallest lfsr for each subsequence @xmath44 .",
    "the size of each lfsr is @xmath52 , which is at most @xmath0 , i.e. the overall number of bits in @xmath37 lfsrs is at most @xmath54 .",
    "this method is applicable to any degree of parallelization @xmath37 which is not a multiple of the period @xmath43 .",
    "the second approach is based on computing the set of states reachable from any state in @xmath37 steps .",
    "this is usually done by computing @xmath37th power of the connection matrix of the lfsr  @xcite .",
    "such an approach is applicable to the degrees of parallelization @xmath38 .",
    "the size of the register with the degree of parallelization @xmath37 in this case is the same as the size of the original lfsr , @xmath0 .    for the case of non - linear fsrs ( nlfsrs ) , algorithms for finding a shortest nlfsr generating a given binary sequence",
    "have been presented in  @xcite , and  @xcite .",
    "an nlfsr with the degree of parallelization @xmath37 can be constructed by computing the set of states reachable from any state in @xmath37 steps , as in the approach ( 2 ) for lfsr .",
    "this can be done by computing @xmath37th power of the transition relation of the nlfsr .",
    "however , the size of @xmath37th power of the transition relation of an nlfsr usually grows much faster than in the lfsr case .",
    "therefore , in practice , in applications which use nlfsrs with the degree of parallelization @xmath37 , nlfsrs are selected so that variables of the @xmath37 left - most stages of the nlfsr are not used in the updating functions .",
    "in such a case , an nlfsr with the degree of parallelization @xmath37 can be constructed by duplicating the updating functions @xmath37 times  @xcite .    for binary machines with the degree of parallelization one ,",
    "an algorithm for constructing a shortest binary machine generating a given binary sequence has been presented in  @xcite .",
    "@xmath55 ; /*counts the number of digits with value @xmath56*/ @xmath57 ; @xmath58 @xmath59 @xmath60 ; @xmath61 $ ] is an arbitrary permutation of @xmath62 ; @xmath63 ; /*records how many elements of @xmath64 were used*/    @xmath65 ; /*@xmath66 is the @xmath67th element of @xmath68*/ @xmath69 ; @xmath70 ; expand @xmath71 as an @xmath16-ary vector @xmath72 ; + /*the resulting sequence @xmath73 is interpreted as a sequence of states of an @xmath16-ary @xmath0-stage machine*/ @xmath74 ; @xmath75 ; @xmath76 ; return @xmath77 ;",
    "the algorithm presented in this section exploits the property of @xmath16-ary @xmath0-stage machines that _ any _",
    "@xmath16-ary @xmath0-tuple can be the next state of a given current state .",
    "note that , in the traditional @xmath0-stage nlfsrs in the fibonacci configuration  @xcite , the next state overlaps with a current state in @xmath78 positions .",
    "nlfsrs in the galois configuration are more flexible . however , since they do not allow feedforward connections , their set of possible next states is still restricted to a certain subset of all possible states  @xcite .",
    "the input of the algorithm is an @xmath16-ary sequence @xmath5 of length @xmath27 .",
    "first , we show how to construct a sequence of integers @xmath73 such that @xmath71 mod @xmath79 for all @xmath80 .",
    "we count the number of occurrences of each of digits with the value @xmath56 in @xmath5 , @xmath81 , and determine the largest number of occurrences , @xmath82 .",
    "let @xmath62 be a set consisting of @xmath83 non - negative integers of type @xmath84 for all @xmath85 and all @xmath56 .",
    "let @xmath86 $ ] be an arbitrary permutation of @xmath62 .    initially , for all @xmath56",
    ", we set to zero a counter @xmath87 which counts how many digits of @xmath64 have been used .",
    "then , for every @xmath45 from 0 to @xmath88 , we take the @xmath45th element of the sequence @xmath5 , @xmath89 , and assign @xmath71 to @xmath67th element of @xmath68 .",
    "it is easy to see from our construction that @xmath71 mod @xmath16 is equal to @xmath90 .",
    "let @xmath73 be a sequence constructed as described above .",
    "each integer @xmath91 can be represented as an @xmath16-ary expansion @xmath92 where @xmath0 is the number of @xmath16-ary digits needed to represent the largest integer of @xmath39 and @xmath93 is the least significant digit of the expansion .",
    "we interpret each @xmath0-tuple @xmath94 as a state of an @xmath16-ary @xmath0-stage machine . by construction , @xmath95 for all @xmath96 .",
    "next , we define a mapping @xmath97 , for all @xmath98 , where @xmath99 is mod @xmath27",
    ". this mapping assigns @xmath100 to be the next state of a current state @xmath3 of an @xmath16-ary @xmath0-stage machine .",
    "each of @xmath101 remaining states of the @xmath16-ary @xmath0-stage machine are left unspecified .",
    "this gives us a freedom to specify the updating functions in a way which minimizes their circuit complexity .",
    "the @xmath29-sets of the updating functions implementing the resulting mapping are derived as follows .",
    "initially @xmath102 , for all @xmath103 and all @xmath56 . for every @xmath45 from 0 to @xmath88 , and every @xmath37 from 0 to @xmath78 , if @xmath104 , where @xmath99 is mod @xmath27 , then we add @xmath105 to the @xmath29-set of @xmath106 where @xmath75 .",
    "the algorithm described above is summarized as algorithm  [ alg2 ] .",
    "its worst - case time complexity is @xmath107 ( assuming @xmath108 which is normally the case ) .",
    "[ th1 ] the algorithm  [ alg2 ] constructs an @xmath16-ary @xmath0-stage machine generating an @xmath16-ary sequence @xmath5 of length @xmath27 with the degree of parallelization one where @xmath0 is given by @xmath109 where @xmath82 .",
    "* proof : * at the step 7 of the algorithm  [ alg2 ] , for each @xmath56 , @xmath81 equals to the number of digits with the value @xmath29 in the sequence @xmath5 . from the step 6 of the algorithm  [ alg2 ]",
    "we can conclude that , for each @xmath56 , the largest integer @xmath110 such that @xmath3 mod @xmath111 is equal to @xmath112 .",
    "we need @xmath113 @xmath16-ary digits to express this integer for any @xmath114 .",
    "since @xmath115 , the number of stages in the @xmath16-ary @xmath0-stage machine is given by @xmath116 where @xmath82 .",
    "@xmath117    the lemma below shows under which conditions that the bound given by  ( [ bound ] ) is an exact lower bound .    [ th2 ] given a purely periodic @xmath16-ary sequence @xmath118 with the period @xmath27 , any @xmath16-ary machine which generates @xmath118 the degree of parallelization one has at least @xmath0 stages , where @xmath0 is given by  ( [ bound ] ) .",
    "* proof : * the existence of an @xmath16-ary machine with @xmath119 stages which can generate @xmath118 follows from the theorem  [ th1 ] .",
    "it remains to prove that no @xmath16-ary @xmath120-stage machine with @xmath121 can generate @xmath118 .",
    "assume that such a machine exists .",
    "then , if @xmath118 is purely periodic and has the period @xmath27 , to be able to generate one digit of @xmath118 per clock cycle with the period @xmath27 , the @xmath16-ary @xmath120-stage machine must have at least @xmath81 distinct states whose 0the stage has the value @xmath29 .",
    "we need at least @xmath113 @xmath16-ary stages to implement the largest of these states for any @xmath114 .",
    "so , we can conclude that @xmath122 which contradicts the assumption that @xmath121 .",
    "@xmath117    as an example , consider the 4-ary sequence from the introduction section : @xmath123 we have @xmath124 .",
    "so : @xmath125 suppose we use following permutations of @xmath62s : @xmath126,\\\\ b_1 = [ 1,5,9,13],\\\\ b_2 = [ 2,6,10,14],\\\\ b_3 = [ 3,7,11,15].\\\\ \\end{array}\\ ] ] then we get : @xmath13    since @xmath124 , from the theorem  [ th1 ] we can conclude that the quaternary machine which generates @xmath5 has 2 stages . by applying the mapping described in the algorithm  [ alg2 ] to @xmath39 , we get the following @xmath29-sets for the updating functions @xmath127 and @xmath128 : @xmath129 1{\\mbox{\\em - set}}(f_1 ) =   \\{(01),(13),(23)\\ } \\\\[1 mm ] 2{\\mbox{\\em - set}}(f_1 ) =    \\{(02),(33)\\ } \\\\[1 mm ] 3{\\mbox{\\em - set}}(f_1 ) =    \\{(22)\\ } \\\\[1 mm ] 0{\\mbox{\\em - set}}(f_0 ) =   \\{(13),(20),(33)\\ } \\\\[1 mm ] 1{\\mbox{\\em - set}}(f_0 ) =   \\{(03)\\ } \\\\[1 mm ] 2{\\mbox{\\em - set}}(f_0 ) =   \\{(10),(23)\\ } \\\\[1 mm ] 3{\\mbox{\\em - set}}(f_0 ) =   \\{(00),(01),(02),(12)\\}. \\\\[1 mm ] \\end{array}\\ ] ]",
    "the defining tables of these functions are shown is figure  [ f_k ] .",
    "the symbol `` - '' stands for a do nt care value .    [ cols=\"^,^,^,^,^\",options=\"header \" , ]",
    "to evaluate the presented approach , we compared the areas of binary machines , lfsrs and nlfsrs generating the same sequence for 3 types of sequences : truly random , complementary , and legendre .",
    "all experiments were run on a pc with intel dual - core 1.8 ghz processor and 2 gbytes of memory .",
    "the area was computed using abc synthesis tool  @xcite by first optimizing the circuits with _",
    "resyn _ script and then by mapping them with _",
    "map_. in the results reported below , 1 unit of area is equal to the area of a 2-input nand gate .    in the first set of experiments ,",
    "for each @xmath0 in the range @xmath130 , we generated 20 truly random sequences of length @xmath131 using the method  @xcite .",
    "columns 2 - 4 of table  [ ta1 ] show the areas of the resulting lfsrs , nlfsrs and binary machines ( bm ) for the degree of parallelization one .",
    "columns 5 - 7 of table  [ ta1 ] shows similar results for the degree of parallelization equal to the number of stages in binary machines ( which is always less or equal to the number of stages in lfsrs and nlfsrs ) .",
    "each entry is an average for 20 sequences .",
    "lfsrs are quite bad for generating truly random sequences .-",
    "sequences , for which lfsrs are extremely efficient .",
    "an @xmath0-stage lfsr with a primitive polynomial of degree @xmath0 generates an @xmath16-sequence of length @xmath132 .",
    "if the primitive polynomial has @xmath27 non - zero terms , then to implement such an lfsr with the degree of parallelization @xmath37 , we need @xmath0 stages and no more than @xmath133 xors . however , due to the linearity of lfsrs @xmath16-sequences they are easy to reconstruct from a short segment . ]",
    "the number of their stages grows roughly as a half of the sequence length . for nlfsrs",
    ", the number of stages grows much slower .",
    "however , the combinatorial area of parallel nlfsrs grows so fast that they become hard to synthesize for random sequences longer than 256 bits . as we can see from table  [ ta1 ] , on average , the area of parallel binary machines",
    "is an order of magnitude smaller than the area of parallel lfsrs and nlfsrs .",
    "table  [ ta2 ] shows the results for complementary sequences .",
    "_ complementary _ sequences are a pair of sequences whose aperiodic autocorrelation coefficients sum up to zero  @xcite .",
    "these sequences are known to have a tightly low peak - to - mean envelope power ratio , good error detection capabilities , and high nonlinearity  @xcite .",
    "they are recommended for orthogonal frequency division multiplexing  @xcite and for multicarrier code division multiple access systems  @xcite we can see that , on average , parallel binary machines are an order of magnitude smaller than parallel lfsrs and nlfsrs .",
    "table  [ ta3 ] shows the results for extended legendre sequences .",
    "extended legendre sequences are known to have the asymptotic merit factor of 6.3421 , which is the highest of all known families of sequences of an arbitrary length  @xcite .",
    "the higher the merit factor of a sequence which is used to modulate a signal , the more uniformly the signal energy is distributed over the frequency range .",
    "this is important for spread - spectrum communication systems , ranging systems , and radar systems  @xcite .",
    "again , on average , parallel binary machines are an order of magnitude smaller than parallel lfsrs and nlfsrs .",
    "in this paper , we present a method for constructing binary machines with the minimum number of stages for a given degree of parallelization .",
    "our experimental results show that , for sequences with high linear complexity , such as complementary , legendre , or truly random sequences , parallel binary machines are an order of magnitude smaller than parallel lfsrs and nlfsrs generating the same sequence .    our results can be beneficial for any application which requires sequences with high spectrum efficiency or high security , such as data transmission , wireless communications , and cryptography .",
    "this work was supported in part by a research grant 621 - 2010 - 4388 from the swedish research council .",
    "g.  de  micheli , r.  brayton , and a.  sangiovanni - vincentelli , `` optimal state assignment for finite state machines , '' _ computer - aided design of integrated circuits and systems , ieee transactions on _ , vol .  4 , pp .",
    "269  285 , july 1985 .",
    "k.  limniotis , n.  kolokotronis , and n.  kalouptsidis , `` on the nonlinear complexity and lempel - ziv complexity of finite length sequences , '' _ ieee transactions on information theory _ , vol .",
    "53 , no .  11 , pp .  42934302 , 2007 .",
    "g.  l. feng and k.  k. tzeng , `` algorithm for multisequence shift - register synthesis with applications to decoding cyclic codes , '' _ ieee transactions on information theory _ , vol .",
    "37 , no .  5 , pp .",
    "12741287 , 1991 .",
    "s.  mukhopadhyay and p.  sarkar , `` application of lfsrs for parallel sequence generation in cryptologic algorithms , '' in _ computational science and its applications - iccsa 2006 _ , vol .",
    "3982 of _ lecture notes in computer science _ , pp .  436445 , springer berlin / heidelberg , 2006 .",
    "c.  j.  a. jansen , `` the maximum order complexity of sequence ensembles , '' in _ proceedings of the 10th international conference on theory and application of cryptographic techniques _ , eurocrypt91 , ( berlin , heidelberg ) , pp .  153159 , springer - verlag , 1991 .",
    "b.  gittins , h.  a. landman , s.  oneil , and r.  kelson , `` a presentation on vest hardware performance , chip area measurements , power consumption estimates and benchmarking in relation to the aes , sha-256 and sha-512 . '' cryptology eprint archive , report 2005/415 , 2005 ."
  ],
  "abstract_text": [
    "<S> binary machines are a generalization of feedback shift registers ( fsrs ) in which both , feedback and feedforward , connections are allowed and no chain connection between the register stages is required . in this paper , we present an algorithm for synthesis of binary machines with the minimum number of stages for a given degree of parallelization . </S>",
    "<S> our experimental results show that for sequences with high linear complexity such as complementary , legendre , or truly random , parallel binary machines are an order of magnitude smaller than parallel fsrs generating the same sequence . </S>",
    "<S> the presented approach can potentially be of advantage for any application which requires sequences with high spectrum efficiency or high security , such as data transmission , wireless communications , and cryptography .    </S>",
    "<S> feedback shift register , sequences , nonlinear complexity </S>"
  ]
}