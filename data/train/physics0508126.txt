{
  "article_text": [
    "lelaps is a fast detector simulation that swims particles through detectors with magnetic fields , accounting for multiple scattering and energy loss .",
    "it produces parameterized showers in em and hadronic calorimeters , supports decays of certain short - lived particles ( `` v '' decays ) and converts gammas .",
    "lelaps performance is on the order of 1 typical ( e.g. zz ) event / second at 1 ghz , with everything turned on and writing an lcio output file .",
    "lelaps consists of a set of c++ class libraries and a main program , which itself is called lelaps . the main class library is called cepack , the actual simulation toolkit .",
    "it reads stdhep generator files and produces sio or lcio output files .",
    "lelaps has built - in support for ldmar01 , sdjan03 and sdmar04 .",
    "it also reads detector geometries in the new godl format .    for details on lelaps ,",
    "see references  @xcite and  @xcite . in the next section ,",
    "a brief reminder is provided .",
    "the rest of this paper gives an introduction to the godl detector description language .",
    "the main class library for lelaps is called cepack and it contains the simulation tool kit .",
    "it deals with geometry , materials and tracking particles through the geometry while taking into account magnetic fields , multiple scattering , energy loss , parameterized showers in em and hadronic calorimeters , particle decays and gamma conversions . a lelaps - simulated zz event in the sid detector is shown in figure  [ fig : sidid ] .",
    "the same event simulated in the ld detector is shown in figure  [ fig : ldid ] .",
    "cc    cc      specifying materials is very easy in lelaps .",
    "all elements are built in with default pressure and temperature for gasses or density for solids and liquids .",
    "any compound can be specified by chemical formula and density or ( for gasses ) temperature and pressure .",
    "mixtures can be created by mixing elements and compounds by volume or by weight .",
    "all needed quantities are calculated automatically .",
    "this includes constants needed for multiple scattering and energy loss , radiation lengths , interaction lengths and constants needed for shower parameterization .",
    "the lelaps distribution comes with a little program called matprop that allows one to view various material properties .",
    "an online version of matprop is available  @xcite .",
    "tracking is performed by taking steps along a linear trajectory with endpoints on a helix , such that the sagitta stays below a certain maximum .",
    "after each step , the amount of material traversed is checked : if enough material was traversed , multiple scattering and energy loss is performed and track parameters are updated . when an intersection occurs within a step ,",
    "the fractional step is executed , the volume is entered , and the remaining fraction of the step follows .",
    "multiple scattering is performed using the algorithm of lynch and dahl  @xcite .",
    "material is saved up along the track until there is enough . de / dx is calculated using the methods by sternheimer and peierls  @xcite .",
    "all constants are precalculated by the material classes .",
    "electromagnetic showers are parameterized using the algorithms of grindhammer and peters  @xcite .",
    "calorimeters are treated as homogeneous media .",
    "the longitudinal shower profile is given by a gamma distribution with coefficients depending on the material ( z ) and energy .",
    "the profiles are fluctuated and correlations between the coefficients are taken into account .    for each step of one radiation length ,",
    "a radial profile is computed consisting of two distributions , one describing the core of the shower and the other the tail .",
    "the energy to be deposited is divided into spots thrown in radius according to the radial profile , and uniformly in @xmath0 .",
    "roughly , about 400 spots are generated per gev of shower energy and reported as hits .",
    "hadronic showers are parameterized in a similar way , with some modifications .",
    "the location where the shower starts is simulated using an exponential law with attenuation given by the interaction length .",
    "the longitudinal profile uses the bock parameterization  @xcite .",
    "a combination of two gamma distributions , one using radiation lengths and the other interaction lengths , is used .",
    "the bock parameterization does not specify radial profiles . for the moment we use a radial profile similar to grindhammer and peters ( for em showers ) but with radiation lengths replaced by interaction lengths and faster spread with depth . the parameters still need to be fine - tuned .",
    "these parameterizations were compared to results from geant4  @xcite . in general pretty good agreement",
    "was found for em showers ( see figure  [ fig : compg4id ] ) .",
    "hadronic showers agree pretty well longitudinally , but not as well radially .",
    "hadronic shower parameterization has been tweaked since then , but needs further work .",
    "cc    cepack supports decays of unstable particles and gamma conversions .",
    "supported unstable particles are @xmath1 , @xmath2 , @xmath3 , @xmath4 , @xmath5 and @xmath6 . only decay modes with branching fractions greater than 2%",
    "are supported ( mostly `` v decays '' ) .",
    "see figure  [ fig : decaygamid ] .",
    "a new feature in lelaps is the ability to read in detector descriptions written in a new language called godl .",
    "this language was especially designed to describe all aspects of detector geometry , materials , detector - subdetector relationships , as well as the output formats for any hits produced in sensitive parts of the detectors .",
    "we will start with a subsection on the features of godl and conclude with the current status of implementation .",
    "godl is a more or less complete programming language with variables and operations .",
    "this means that one does not have to hard - code dimensions and locations but can instead compute dimensions and locations from previously defined ones .",
    "godl has control constructs ( loops , if ) which make repetitive operations easier .",
    "there are built - in math functions , which allows calculating derived quantities ( e.g. the tangent of an angle ) .",
    "the language is human readable and editable ( like xml but more so ) and portable ( since it is in plain text ) .",
    "the interpreter catches mistakes ( like xml but better ) .",
    "godl knows about units and enforces them .",
    "for example , one can mix microns and meters .",
    "one can define new units based on built - in ones and use them .",
    "the interpreter enforces consistent usage of units in operations and function calls .",
    "godl has list objects .",
    "built - in objects describe materials , objects , placements etc .",
    "godl supports volume hierarchies .",
    "this saves simulation time by allowing embedding of sub - detector elements into mother volumes .",
    "godl allows specification of arbitrary calorimeter segmentation and encoding of tracker and calorimeter i d s . for this",
    ", it has a built - in , postscript - like , parser which `` compiles '' a suitable i d code specification to byte - code for fast execution .",
    "this allows one to change encoding and/or segmentation without modifying the simulator source code .",
    "godl supports levels of detail .",
    "this allows one to use a low level of detail for fast simulation and higher level of detail for full simulation , all encoded in the same godl source file .",
    "godl comes with a simple api which currently comprises 11 virtual methods , which are all fully implemented in lelaps .",
    "lelaps comes with a godl - to - heprep converter ( these hepreps require the newest wired4 for viewing ) .",
    "a geant4 implementation is planned .",
    "godl supports ( in principle ) all geant4 solid types ( with the possible exception of breps ) .",
    "not all of them are implemented at this time , but it would be easy to do . and finally , godl supports ( in principle ) combinatorial ( `` boolean '' ) geometry ( `` csg '' in geant4 ) .",
    "this is not yet implemented , but should be straightforward .",
    "godl is an extensible typeless programming language .",
    "type is determined by assignment :    ....     a = 2.4 ;       # real     b = 2 ;         # integer     c = \" text \" ;    # string     d = true ;      # boolean ....    it has variables and operations that can be performed on them :    ....     a + = 1 ;     b = a * 12 ;     d = c + \" more text \" ;     e = false ;     b = e !",
    "= true ; ....    it also supports array - like constructs :    ....     i = 5 ; foo.i = 12 ;        #   same as foo.5 = 12 ; ....    these arrays are much like `` stem '' variables in rexx .",
    "godl supports the following set of operators , although some can not be used in some contexts :    ....     + - * / = + = -= * = /= = =",
    "< > < = > = ! = ! & & || ....    the meaning of these operators is just like in c. note the absence of @xmath7 and @xmath8 operators .",
    "there is also a reference operator @xmath9 :    ....     a = 12 ;     b = @a ; print(b , \" \\n \" ) ; ....    which would print out :    ....     @a->(12 ) ....    this is useful for referencing objects multiple times without recreating them , see later .",
    "godl knows about the usual set of math functions :    ....     exp , log , sqrt , pow , cos , sin , tan , acos , asin , atan , atan2 , cosh , sinh , tanh ,     acosh , asinh , atanh , log10 , abs , fabs , ceil , floor and mod . ....",
    "in addition there is a list function :    ....     a = list(a , b , c , d ) ;     # creates unnamed list ....    and a print function :    ....     print(a , \" \\n \" ) ;     print(a , \" \\n \" , b , \" \\n \" ) ; ....    it is possible to use a godl parser as a `` shell '' .",
    "when arguments are provided , argc and argv work more or less like they do in c.    there is also a `` unit '' function , see later .",
    "godl has a limited set of c - style control constructs :    ....     for ( i = 0 ; i < 25 ; i + = 1 ) {    ...    }       while ( true ) {        ...        if ( something ) break ;     }       if ( a < b ) {    ...    } ....      variables can be list objects . to construct a generic list with name `` foo '' :    ....     a = foo(a , b , c , d ) ; ....    lists can contain objects of any type , including other lists . to add objects to a list :    ....     a + = e ;     a + = f ; ....    note that this is not necessarily the same as :    ....     a + = e + f ; ....    which would first add f to e and then the result to a. if e and f are list objects , this adds to `` a '' a single list `` e '' which in turn contains `` f '' .",
    "note that the godl parser built into lelaps will disallow any named lists whose names do not match one of the set of lists it recognizes ( see later ) .",
    "variables can have units , and units are enforced across operations and in arguments to function calls and list objects :    ....     m = _ meter ;      # _ meter is a built - in unit     unit(\"m \" ) ;       # declare as unit     a = 2 m ;     b = 12 * a ;     area = a * b ;     area + = 5 ;       # error : incorrect units     d = cos(area ) ;   # error : cos ( ) only takes angles ....    available basic units are ( like clhep ) :    ....     _ meter , _ second , _ joule , _ coulomb , _",
    "kelvin , _ mole , _",
    "candela , _",
    "radian , and _ steradian .",
    "....    built - in units derived from these are :    ....     _ angstrom , _ parsec , _ barn , _ degree , _ hertz , _ becquerel , _ curie , _ electronvolt ,     _ gram ,   _ watt , _",
    "newton , _ pascal , _ bar , _ atmosphere , _ ampere , _",
    "volt , _ ohm ,     _ farad , _ weber ,   _ tesla , _ gauss , _ henry , _ gray , _ lumen , and _ lux .",
    "....    one can create new units :    ....     m = _ meter ;",
    "g = _ gram ; # for convenience     unit(\"m \" , \" g \" )          # declare as units     gcc = g / cm3 ;            # new unit of density     unit(\"gcc \" ) ;            # declare ....    si prefixes and powers are automatically converted :    ....     a = 1 cm2 ;              # = 0.0001 _ meter squared ....    there are some built - in constants :    ....     _ pi ( 3.14 ... ) ( has units of rad )     _ e_si          ( electron charge , 1.6 ... 10 - 19 c )     _ e ( 2.71 ... )   ( dimensionless ) ....      for debugging , there are two functions :    ....     verbose        prints a lot of debugging information to stdout     _ _ printvars    prints a list of all variables to stdout ....    further , there are some control variables for the print ( ) function :    ....     printlevel _ : ( default 1 ) controls how much information to print ( mostly for for object lists ) .     precision _ :   controls how many digits are displayed for floating point numbers .",
    "fieldwidth _ : controls how much space a printed number takes up . ....      materials are declared using the element , material or mixture list objects ( note the use of the @xmath9 operator to pass by reference ) :    ....     si      = element(\"si \" ) ;     vacuum = material(\"vacuum \" ) ;     o2      = material(formula(\"o2 \" ) , pressure(1.0 atm ) , temperature(293.15 k ) ) ;     tyvek   = material(name(\"tyvek \" ) , formula(\"ch2ch2 \" ) , density(0.935 g / cm3 ) ) ;     air     = mixture(part(@o2 , 20.946 ) , part(@n2 , 78.084 ) , part(@ar , 0.934 ) , by(\"volume \" ) ) ; ....      in order to construct a geometry , we first define a world volume :    ....     world = cylinder(radius(700.0 cm ) , length(14.0 m ) , @vacuum ) ; ....    to define another volume we use , for example :    ....     em_ec_irad   = 21.0 cm ;                   em_ec_orad    = 125.0 cm ;     em_b_irad    = em_ec_orad + 2.0 cm ;       em_thickness = 15 cm ;     em_b_orad    = em_b_irad + em_thickness ; em_nlayers    = 30 ;     em_sampfrac = 0.02664 ;                   em_b_length   = 368.0 cm ;       em_barrel = cylinder(name(\"em barrel \" ) , innerradius(em_b_irad ) , outerradius(em_b_orad ) ,                          length(em_b_length ) , @siw , type(\"emcal \" ) , nlayers(em_nlayers ) ,                          samplingfraction(em_sampfrac ) ) ; ....    now we add this to world using a placement :    ....     world + = placement(@em_barrel ) ; ....    we can use loops to do repetitive tasks and if statements for conditionals :    ....     vertex_barrel = cylinder(name(\"vertex barrel \" ) , innerradius(v_irad ) ,                              outerradius(v_orad ) , length(v_lenmax ) ) ;     for ( i = 1 ; i < = v_nlayers ; i + = 1 ) {        vlen = v_leninner ;        if ( i > 1 ) vlen = v_lenmax ;        vertex_barrel.i = cylinder(name(\"vertex barrel \" + i ) , ... ) ;        vertex_barrel + = placement(@vertex_barrel.i ) ; # notice hierarchy     }     world + = placement(@vertex_barrel ) ; ....    .level of detail specification syntax [ cols=\"<,^,<\",options=\"header \" , ]     [ table : levelid ]      to specify levels of detail we use the `` level '' tag :    ....     had_endcap = cylinder(name(\"had endcap \" ) , level(1 ) , ... ) ;     had_endcap + = placement(@something , ... , level(max(0 ) ) , ... ) ;     had_endcap + = placement(@something_else , ... , level(min(1 ) ) , ... ) ;     world + = placement(@had_endcap , translate(0 , 0 , 0.5 * ( had_b_length - had_thickness ) ) ) ;     world + = placement(@had_endcap , rotate(axis(\"y \" ) , angle(180 degrees ) ) ,                        translate(0 , 0 , -0.5 * ( had_b_length - had_thickness ) ) ) ; ....    the full level syntax is described in table  [ table : levelid ] .",
    "i d calculation ( such as calorimeterid and trackerid ) is generally used for two purposes : to specify segmentation of a detector  hits with the same i d are combined to a single energy deposition  and to specify an abbreviated version of the location of an energy deposition .",
    "the problem is : how can one change the amount or method of segmentation without changing the c++ source code of the simulator ?",
    "one solution is the ability to specify the segmentation method in the geometry file and `` interpret '' it inside the simulator .",
    "the godl api provides a simple , fast , interpreter to do that .",
    "in fact , it `` compiles '' the segmentation specification into byte - code , and runs the byte code for each hit during the simulation . in practice , this is fast enough to not cause a significant overall performance hit .    as an example",
    "let us consider tracker ids .",
    "for the vertex detector barrel we would use :    ....     vertex_barrel.i = cylinder(name(\"vxd \" ) , ... ,                                 idcode(code(tb_code ) , data(\"system \" , 1 ) , data(\"id \" , i - 1 ) ) ) ; ....    the i d calculation in idcode is specified as a string in a `` code '' list object .",
    "the algorithm for the vertex and barrel trackers is :    ....     tb_code = \" x : fp0 y : fp1 z : fp2 layer : d3 i d z h 0x40000000 mul or system 28 bitshift                or stop \" ....    for the tracker end cap it is :    ....     \" x : fp0 y : fp1 z : fp2 layer : d3 i d 0x80000000 or z h 0x40000000 mul or system 28 bitshift      or stop \" ; ....    here , `` x : fp0 '' means that the api routine that evaluates the byte code associated with the above , expects x to be given in the first floating point `` register '' .",
    "similarly , `` layer '' is provided as an integer in the fourth register .",
    "the code itself is a reverse polish , postscript - like , language with some limitations and some extras : some named variables must be provided by the simulator as standard arguments ( x , y , z , layer ) , and some named variables are provided using `` data '' object lists in the specification . in the above , h is the heaviside step function : 1 if the argument is positive , 0 otherwise .",
    "the language includes a standard set of math functions that may be used .",
    "there is slightly more work for the calorimeter i d s . for the end caps we have :    ....     cal_code_ec",
    "= \" x x mul y y mul add sqrt z atan2 theta_seg mul _ pi div \" + standard_code ; ....    for the barrel we have :    ....     cal_code_b = \" x x mul y y mul add sqrt z atan2 cos 1.0 add theta_seg mul 2.0 div \"                  + standard_code ; ....    where standard_code is :    ....     standard_code = \" truncate 11 bitshift y x atan2 m phi_seg mul 0.5 mul _ pi div truncate                      or layer 21 bitshift or system 28 bitshift or stop \" ; ....    here , atan2 m is the same as atan2 , except that the result is given in the range 0 to @xmath10 .",
    "we have to add standard argument specifications to this , for example :    ....     cal_code_ec = \" x : fp0 y : fp1 z : fp2 layer : d3 \" + cal_code_ec ;     ....      the godl api consists of four classes : godlparser , mcode , mstack and mvar .",
    "there are ( currently ) 11 virtual functions that the api implementer must write .",
    "for example :    ....     virtual int constructcylinder (        const char    * nameforfuturereference ,        const char    * objectname ,        double         innerradius,// length units : meter        double         outerradius ,        double         length ,        const char    * materialrefname ,        const char    * type ,        int            nlayers ,        int            nslices ,        double         samplingfraction ,        const mstack & idcode ) ....    other functions that must be implemented are :    ....     constructcone ( ... ) ,     addfield ( ... ) ,   addplacement ( ... ) ,      constructplacement ( ... ) ,     rotate ( ... ) ,            translate ( ... ) , constructelement ( ... ) , constructcompound ( ... ) ,     constructmixture ( ... ) , addmixture ( ... ) ....    the api reads the godl file ( which typically has extension .godl ) and calls the `` construct '' routines to construct objects and placements .",
    "it then calls rotate and translate on the placements , and addmixtures to add materials to the mixtures .",
    "finally it calls addplacement to instantiate an actual placement of an object .",
    "the godl parser and evaluator are essentially complete and the api layer to access the volume list exists .",
    "godl was first completely implemented in lelaps v03 - 23 - 26 , including levels of detail and hit i d calculation .",
    "godl representations of the sdmar04 and sdjan03 detectors exist , the latter with two different levels of detail .",
    "as mentioned , a godl - to - heprep converter exists and comes with the lelaps distribution .",
    "new features that are planned for lelaps / cepack include support for combinatorial geometry and the ability for shower continuation into the next volume .",
    "more tuning of hadronic showers is needed",
    ". for godl , planned new features include adding the remaining standard geometrical shapes and implementing support for combinatorial geometry"
  ],
  "abstract_text": [
    "<S> lelaps is a fast detector simulation program which reads stdhep generator files and produces sio or lcio output files . </S>",
    "<S> it swims particles through detectors taking into account magnetic fields , multiple scattering and de / dx energy loss . </S>",
    "<S> it simulates parameterized showers in em and hadronic calorimeters and supports gamma conversions and decays . </S>",
    "<S> in addition to three built - in detector configurations , detector descriptions can also be read from files in the new godl file format . </S>"
  ]
}