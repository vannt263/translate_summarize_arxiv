{
  "article_text": [
    "in his seminal papers that gave birth to the field of information theory , shannon showed that the capacity of a channel could be achieved using codes whose codewords are random bit strings @xcite . despite this optimality ,",
    "random codes have no practical use because we do not know how to decode them efficiently , i.e. in a time polynomial in the number of encoded bits . in 1978 ,",
    "berlekamp , mceliece , and van tilborg @xcite ( see also @xcite ) showed that decoding a classical linear code is an @xmath0 problem , which strongly indicates that no efficient algorithm will ever be found to decode generic classical codes .",
    "a central problem in coding theory therefore consists in designing codes that retain the essential features of random codes , but yet have enough structure to be efficiently ( approximately ) decoded .",
    "quantum information science poses additional challenges to coding theory .",
    "while the stabilizer formalism establishes many key parallels between classical and quantum coding @xcite , important distinctions remain . on the one hand ,",
    "quantum code design is obstructed by the additional burden that check operators must mutually commute .",
    "for that reason , it has proven difficult to quantize some of the best families of classical codes , such as low density parity check ( ldpc ) codes @xcite and turbo codes @xcite . on the other hand",
    ", quantum codes can be _ degenerate _ , which means that distinct errors can have the same effect on all codewords .",
    "this changes the nature of the decoding problem @xcite , and our goal here is to explore how degeneracy impacts the computational complexity of the decoding problem .",
    "the conceptually simplest method to decode a stabilizer code is to ignore error degeneracy and to proceed as with classical linear codes : amongst all errors consistent with the error syndrome , find the one with the highest probability .",
    "we call this decoding method _ quantum maximum likelihood decoding _ ( @xmath2 ) .",
    "it was shown in @xcite that @xmath2 is @xmath0 .    in the presence of degeneracy however",
    ", errors naturally fall into equivalence classes , with all errors in the same class having the same effect on all codewords .",
    "the optimal decoding method searches over all equivalence classes of errors that are consistent with the error syndrome , the one with the largest probability .",
    "the probability of a class of error is simply the sum of the probabilities of all errors it contains .",
    "we call this decoding method _ degenerate quantum maximum likelihood decoding _ ( @xmath3 ) .",
    "our main result is the following theorem .",
    "( [ main - theorem ] ) * ( informally ) @xmath4 _ up to polynomial - time turing reduction .",
    "_    we need turing reduction since decoding is not a counting problem , while problems in @xmath5 consist in counting the number of solutions to a decision problem in @xmath6 .",
    "our result can be understood intuitively from the fact that in order to compute the probability associated to an equivalence class , @xmath3 must determine how many errors of a given weight belong to an equivalence class , hence the need to count . our proof uses a reduction from the problem of evaluating the _ weight enumerator _ of a classical ( binary ) linear code , which was shown by vyalyi to be @xmath1 @xcite .",
    "the rest of this paper is organized as follows . for self - containment ,",
    "the next two sections provide elementary introductions to computational complexity and to the stabilizer formalism .",
    "( [ decoding - problem ] ) formally defines the decoding problem with a particular emphasis on the role of degeneracy .",
    "this section also contains an informal discussion on the importance of error degeneracy and how it impacts the decoding problem in specific settings .",
    "( [ sec - hardness ] ) presents the main result , which is proved in sec .",
    "( [ sec - red - over ] ) ; the expert reader can jump directly to these two sections .",
    "the conclusion proposes possible extensions of the present work .",
    "two key resources required to solve any problem in computer science are space and time .",
    "one way of classifying problems is based on the runtime of a corresponding algorithm for that problem .",
    "this time is expected to depend on the size of the input , @xmath7 , to the problem . instead of precisely denoting the runtime as a function @xmath8 , which would depend on the underlying hardware of the solver",
    ", it is largely classified by its _ limiting behavior _ as : @xmath9 and so on .",
    "consequently , the class of problems for which there exists an algorithm which runs in time @xmath10 , on an input of size @xmath7 , @xmath11 being a constant independent of @xmath7 , is called @xmath12 . note that any problem in @xmath12 is a decision problem , i.e , one for which the solution space is binary . if the problem is formulated to produce an output string , then the existence of a polynomial time algorithm classifies this problem in the class @xmath13 .",
    "there are problems to which any witness or certificate for a solution can be verified in polynomial time . these fall into the class called @xmath6 and clearly , @xmath14 .",
    "a problem @xmath15 is _ at least as hard as _",
    "@xmath16 if we could use the solver for @xmath15 to solve @xmath16 .",
    "this is formalized by the notion of a _ reduction _ , which enables the classification of problems that are harder than a particular class , thereby introducing @xmath17 and @xmath0 , the latter being a class of hardest problems in @xmath6 .",
    "besides decision problems , a category of problems involve enumerating the elements of a set .",
    "when this set is in @xmath6 , the corresponding enumeration problem is classified as @xmath5 @xcite .",
    "@xmath5 : [ sharpp - defn ] a counting function @xmath18 is in @xmath5 if @xmath19 a problem @xmath20 such that @xmath21 , @xmath22 .    hence , a function in @xmath5 counts the number of solutions to a corresponding decision problem in @xmath6 .",
    "one can also compare the relative hardness of two counting problems as is done for the @xmath6 case , using the notion of counting reductions .",
    "let @xmath23 be counting functions .",
    "the function @xmath24 is turing reducible to @xmath25 , if @xmath26 , @xmath27 .",
    "that is , @xmath28 can be computed in polynomial - time with polynomially many queries to an oracle for @xmath29 , for any @xmath30 .",
    "subsequently , analogous to @xmath0 , a notion of reduction for counting functions defines the hardest problems in @xmath5 , as the class @xmath1 @xcite .",
    "@xmath1 : a counting function @xmath24 is in @xmath1 iff @xmath24 is in @xmath5 and @xmath31 , @xmath32 .    the last criterion can also be replaced with : @xmath33 , for some @xmath34 .",
    "we will prove @xmath1-ness of the problem of our concern , by adhering to such a recursive definition .",
    "the level of hardness of a @xmath1 problem can be appreciated by a consequence of a result shown by toda @xcite , stating that a polynomial time algorithm that is allowed a single access to a @xmath5 oracle , can solve any problem in @xmath35 , i.e , @xmath36 .",
    "a particular example of a counting function that will be of interest in the coming sections is the _ weight enumerator _",
    "function for a linear code .",
    "@xmath37 : [ we - def - code ] given a @xmath38 linear code @xmath39 and a positive integer @xmath40 , compute @xmath41 , the number of codewords of hamming - weight @xmath42 .",
    "the corresponding decision problem , which is to determine if there exists a codeword in @xmath43 of weight @xmath40 , is known to be in @xmath0 @xcite .",
    "this immediately implies that @xmath44 , and furthermore , it is known to be complete for this class @xcite .",
    "hardness of @xmath37 : [ we - sharpp - complete ] for a linear code @xmath43 and @xmath45 , @xmath46 .    hence to show that a problem of computing @xmath24 is in @xmath1 , in addition to its membership in @xmath5 , it suffices to show that for any @xmath38 linear code @xmath39 , @xmath47 , @xmath48 can be computed in polynomial - time by allowing at most polynomially many queries to an oracle for computing @xmath24 .",
    "in this section , we will provide the necessary background material on stabilizer codes , see @xcite for more complete introductions . in the setting of quantum coding , information is encoded into @xmath49qubit states in @xmath50 .",
    "errors are operators acting on this space , modeled as elements of the _ pauli group _ @xmath51 .",
    "[ def - pauli - group ] the pauli group on @xmath52-qubit , denoted by @xmath53 is a matrix group over @xmath54 , generated by the pauli matrices ; @xmath55 .",
    "the pauli group on @xmath7-qubits is the group generated by the set of pauli matrices acting on @xmath7-qubits , denoted by @xmath56 .",
    "though the definition of the pauli group in def .",
    "( [ def - pauli - group ] ) contains the scalars @xmath57 , they are often considered unimportant for error detection or correction as they do not affect the error syndrome nor the error correction .",
    "this enables us to define the effective pauli group by identifying operators that are related by a multiplicative constant in @xmath57 , denoted by @xmath58 .",
    "the number of qubits affected by an error @xmath59 is the number of non - identity components in the tensor product form of @xmath60 , and is called the _ weight _ of the error , denoted by @xmath61 .    a quantum stabilizer code is defined by a set of check operators , which are also elements of the pauli group .",
    "[ def - stabilizer - codes ] a stabilizer code is a subspace of the @xmath7-qubit vector space @xmath62 , described as the common + 1 eigenspace of an abelian and hermitian subgroup of @xmath51 , called the stabilizer subgroup .",
    "hence , for a stabilizer code @xmath63 , the stabilizers are defined by : @xmath64 equivalently , we can define the code @xmath63 in terms of its stabilizers @xmath65    stabilizer codes are by far the most widely studied codes in the quantum setting .",
    "when @xmath66 is generated by @xmath67 independent _ stabilizer generators _ @xmath68 , the subspace @xmath63 has dimension @xmath69 , so it encodes @xmath11 logical qubits , and we denote its parameters by @xmath70 $ ] .",
    "all the elements in @xmath71 that leave the code @xmath63 globally invariant belong to the _ normalizer _ of @xmath66 in @xmath72 , denoted by @xmath73 .",
    "the normalizer @xmath73 forms a group generated by @xmath74 generators and @xmath75 .",
    "however , not all operators in @xmath73 necessarily fix every state in @xmath63 .",
    "since the action of @xmath66 is trivial on all code states , we define a subset of operators in @xmath73 called the _",
    "logical operators _ that represent the quotient space @xmath76 , each of which have a distinct action on individual states in @xmath63 . for a shorthand notation",
    ", we will identify these representative with elements of @xmath77 .",
    "this group has @xmath78 _ canonical logical generators _",
    "@xmath79 , such that all generators mutually commute except the pairs @xmath80 and @xmath81 that anti - commute .",
    "the smallest weight of a nontrivial logical operation is the distance of the code , @xmath82    note that the operators defined so far , @xmath68 and @xmath79 do not generate @xmath71 . to complete the basis , we need to define the group of _ pure errors _ @xmath83 , which is also abelian",
    ". we can always find a set of _ canonical pure error generators _",
    "@xmath84 such that @xmath85 commutes with all other pure error generators , all logical generators , and all stabilizer generators except @xmath86 with which it anti - commutes . to summarize",
    ", we have the canonical basis of the pauli group @xmath87 with all commutation relations trivial , except @xmath88 any pauli operator @xmath89 can be expressed as a product of elements in these respective groups : @xmath90 decomposition in this basis will be particularly useful to formulate the decoding problem .",
    "two errors @xmath60 and @xmath91 are called _ degenerate _ if they have an identical effect on all code states , i.e. @xmath92 .",
    "given the decomposition in eq .",
    "( [ decomp - pauli - op ] ) and the definition of the code in eq .",
    "( [ eq - stabilize ] ) , we see that this is only possible if the two errors are related by an element of @xmath66 , i.e. , @xmath93 for some @xmath94 .",
    "this naturally leads to an equivalence relation between errors , with two errors belonging to the same equivalence class if they are related by an element of @xmath66 .",
    "in other words , the set of equivalence classes is the quotient space @xmath95 .",
    "we can thus label the equivalence classes by @xmath96 with @xmath97 and @xmath98 . for a fixed @xmath99 ,",
    "the different classes labelled by @xmath100 are referred to as _",
    "logical classes _ and each class is of size @xmath101 .",
    "the class labelled by @xmath102 and @xmath103 is @xmath66 itself .",
    "any other logical class can be expressed as a coset of @xmath66 , but however they are not groups by themselves .",
    "note that degeneracy is unique to the quantum error correction setting .",
    "when a bit flip pattern @xmath104 is applied to a classical bit string @xmath30 , the resulting string @xmath105 always differs from the original one , except for the trivial error @xmath106 .",
    "consequently , each logical class contains only one element .",
    "our main result in this paper shows that accounting for degenerate errors in decoding stabilizer codes greatly increases its computational complexity .",
    "there is a one - to - one correspondence between _ classical symplectic linear codes _ in @xmath107 and stabilizer codes @xcite , which follows from a mapping @xmath108 of pauli operators in @xmath71 into binary strings of length @xmath109 .",
    "the mapping is performed by first expressing every @xmath110 in the form : @xmath111 and substituting @xmath112 and @xmath113 by @xmath114 and @xmath115 by @xmath116 .",
    "for instance , @xmath117 .",
    "this maps @xmath118 into its _ symplectic representation _ in @xmath107 .",
    "moreover , any two mutually commuting operators @xmath119 are mapped into binary strings @xmath120 that are orthogonal under the _ symplectic product _ , defined by @xmath121 with @xmath122 .",
    "this immediately implies that @xmath123 is a vector space ( code ) which is the kernel of @xmath124 under the symplectic product .",
    "the parity check matrix for this classical code is @xmath125 and its generator matrix is @xmath126 . for a @xmath109-bit",
    "string @xmath127 expressed as the concatenation of two @xmath7-bit stings , we denote the inverse mapping @xmath128 where we use the shorthand notation @xmath129 .",
    "the mapping @xmath108 implicitly indicates that we consider a @xmath130type pauli operation as a @xmath131type operation followed by a @xmath132 type operation , in other words , as an error of weight two .",
    "consequently , we define the _ symplectic - weight _ of the pauli error as @xmath133 with @xmath134 denoting the usual hamming weight . clearly , @xmath135 .",
    "this correspondence with classical linear codes is the key to most of the complexity results @xcite involving stabilizer codes , including ours . in many cases",
    "it can be used to build parallels to already known results for classical ( linear ) symplectic codes .",
    "an error model assigns probabilities to various errors , which are then used by the decoder to statistically infer what recovery is most likely given the error syndrome .",
    "we restrict ourselves to errors from @xmath71 , so the corresponding error model is referred to as a _",
    "pauli channel_. there are multiple type of pauli channels which are often used in studying error correcting codes @xcite . here",
    ", we will further assume that errors act independently on each qubit .",
    "[ def - pauli - ch ] on a memoryless pauli channel , the probability of error @xmath136 , with @xmath137 , is @xmath138 where the @xmath139 are properly normalized probability vectors on @xmath140 .    in general , the probabilities @xmath141 can be different for all qubits .",
    "one important feature of memoryless pauli channels is that they can be efficiently specified ( to finite accuracy ) , i.e. using @xmath142 bits of information .",
    "an obvious simplification of the above channel is made by supposing that the noise rates are the same for all @xmath143 type errors on each qubit .",
    "this specifies to a _ depolarizing channel _ , and can be expressed as @xmath144 alternatively , one can assume that each qubit is first affected by @xmath112-type errors , and a then by @xmath113-type errors , and moreover , these errors are independent of each other .",
    "a @xmath145-type error occurs only when both a @xmath131type as well as an @xmath132type error affect a qubit .",
    "this specifies a _",
    "independent @xmath146 channel _ , which we will use to prove our main result .    [ def - xz - ch",
    "] an independent @xmath146 channel is a memoryless pauli channel defined by @xmath147 , @xmath148 , and @xmath149 for each qubit .",
    "the probability of an error @xmath150 can thus be written as @xmath151 where @xmath152 is the symplectic weight of @xmath60 , see sec .",
    "( [ sec - symplectic ] ) .",
    "one key feature of both the depolarizing channel and the independent @xmath146 channel is that the probability of an error depends only on its weight ( either @xmath153 or @xmath154 ) . as a consequence , evaluating the probability of a logical class can be done by counting the number of its elements of a given weight , which puts the problem in @xmath5 .",
    "notice also that @xmath155 is monotonically decreasing with its weight for @xmath156 $ ] , implying that in such a range , a minimum weight error has the maximum probability",
    ". we will often refer to @xmath157 to as the error - rate per qubit or the physical noise - rate .",
    "in this section we define the decoding problem more formally , and explain how it is affected by the existence of degenerate errors as defined in sec .",
    "( [ sec - deg - err ] ) .",
    "the qubits are prepared in a code state @xmath158 and are subject to the memoryless pauli channel ( def .",
    "[ def - pauli - ch ] ) .",
    "the received state is @xmath159 where @xmath160 is an unknown error chosen from the distribution @xmath161 . _",
    "decoding _ refers to the operation performed by the receiver in recovering the state @xmath162 from the state @xmath163 .",
    "since all pauli operators square to the identity , it suffices for the receiver to determine @xmath60 and apply it to the system to recover the original state , i.e. @xmath164 .    the error , being an element of the pauli group , can either commute or anti - commute with each of the stabilizer generators .",
    "thus , upon measurement of each stabilizer generator , we obtain an eigenvalue @xmath165 indicating that @xmath60 commutes ( anti - commutes ) with the stabilizer generator : @xmath166 each @xmath167 measurement outcome @xmath168 is encoded into a bit @xmath169 such that @xmath170 .",
    "the outcomes of measuring all the check operators is encoded as a @xmath171 bit vector @xmath172 called the _",
    "error syndrome_.      the decoding problem consists in identifying @xmath60 conditioned on knowledge of the error syndrome . as in the classical case @xcite , the conceptually simplest strategy is to choose @xmath60 that has the highest probability amongst all errors consistent with the measured syndrome .",
    "this is called _ quantum maximum likelihood decoding _ ( @xmath2 ) @xcite , and can be formulated mathematically as : @xmath173 using the decomposition eq .  ( [ decomp - pauli - op ] ) , we can view the error probability @xmath155 as a joint probability over the group @xmath174 , @xmath77 , and @xmath66 in a natural way : @xmath175 using the commutation relations given at eq .",
    "( [ commutations ] ) , it follows that the knowledge of @xmath176 is equivalent to knowledge of @xmath99 , since @xmath85 is the only element of this basis that anti - commutes with @xmath86 .",
    "thus , we have @xmath177 , and all errors in @xmath178 are consistent with the syndrome @xmath172 . hence , at this stage a _",
    "best guess _ for the elements in @xmath179 and @xmath180 needs to be employed .",
    "this involves finding @xmath181 that _ maximizes the likelihood _ of @xmath182 , implying an equivalent definition of @xmath2 : @xmath183 where the conditional probability is given by bayes rule @xmath184 with the marginal defined as usual @xmath185 .",
    "informally speaking , @xmath2 addresses the problem of determining the element of @xmath186 , whose probability is maximum , given an error rate and a syndrome . for the special cases of the depolarizing channel eq .",
    "( [ eq - depol - err ] ) and the independent @xmath146 channel def .",
    "( [ def - xz - ch ] ) , the search for an operator with maximum probability is synonymous to the search for an operator of minimum weight ( with two possible notions of weight , one over the @xmath71 and the other over @xmath187 ) .",
    "consequently , @xmath2 is also known as a _ minimum - weight decoder_.    one subtlety arises in case where the maximum probability is a close tie , as we can not expect a decoder to discriminate probabilities within an arbitrary accuracy .",
    "thus , we can define @xmath2 as the problem of identifying the optimal couple @xmath188 , but we tolerate that it fails when more than one choice have probabilities that are within a small distance @xmath189 from the optimal . the standard way of formalizing this notion is with a _ promise gap _ , where we just assume in the definition of the problem that there is no close tie .",
    "@xmath2 : [ defn - qmld ] + * input : * an @xmath7-qubit quantum code with stabilizer group @xmath66 specified by @xmath67 independent generators , a memoryless pauli channel @xmath155 , an error syndrome @xmath190 , and a promise gap @xmath189 . + * promise : * there exists a couple @xmath191 and @xmath192 such that @xmath193 * output : * @xmath194 .    as mentioned above , for the depolarizing channel and the independent @xmath146 channel @xmath2",
    "is formally equivalent to a minimum - weight decoder , in which case the promise gap is irrelevant and can be set to @xmath195 .",
    "we will now explain how degeneracy changes the decoding strategy . as explained in sec .",
    "( [ sec - deg - err ] ) , errors can be classified into equivalence classes labelled by @xmath96 , with all errors within a class having the same effect on the code and therefore all being correctable by the same operation . as a consequence",
    ", we see that @xmath2 is a suboptimal decoding strategy  in the sense that it does not reach the maximum probability of correctly decoding  because it fails to recognize the equivalence between degenerate errors . instead of searching the most likely error",
    ", the optimal decoder seeks for the most likely equivalence class of errors , with the probability of a class of errors equal to the sum of the probability of the errors it contains .",
    "since all errors in an equivalence class are related by an element of @xmath66 and their @xmath174 component is fixed by the syndrome , we can write the probability of a class conditioned on syndrome @xmath172 as @xmath196 where we use standard bayesian calculus as above .",
    "the _ degenerate maximum likelihood decoding _ ( @xmath3 )",
    "problem can be formulated mathematically as determining an error in the most probable logical class , for a given syndrome , eq .",
    "( [ eq : pls ] ) .",
    "@xmath3 [ def - dqmld ] + * input : * an @xmath7-qubit quantum code with stabilizer group @xmath66 specified by @xmath67 independent generators , a memoryless pauli channel @xmath155 , an error syndrome @xmath190 , and a promise gap @xmath189 . +",
    "* promise : * there exists an @xmath192 such that @xmath197 * output : * @xmath198 .    note that the promise gap can be expressed as a relative gap or an additive gap , the former being the right one in our setting . this is because the relative promise gap can be related to the failure probability of the code under optimal decoding . consider a large promise gap @xmath199 . rewriting the promise as @xmath200 and summing over all @xmath201 ( of which there are @xmath202 )",
    ", we arrive at @xmath203 , which simply says that the probability that the error that occurred is not equivalent to @xmath198and hence that the decoder fails  is at most @xmath204 .",
    "note also that for a fixed @xmath99 , the probabilities @xmath205 and @xmath206 differ only by a constant , so we can perform the optimization in def .",
    "( [ def - dqmld ] ) on the joint probability instead of the conditional probability .",
    "the sum appearing in the this probability eq .",
    "( [ eq : pls ] ) , being over @xmath101 terms , forbids a polynomial - time direct computation of its value . however , for i.i.d .",
    "pauli channels such as the depolarizing channel and the independent @xmath146 channel , by grouping terms of equal weight in the sum , we can express the sum in eq .",
    "( [ eq - logical - prob ] ) more succinctly . for the case of the independent @xmath146 channel def .",
    "( [ def - xz - ch ] ) , the above joint probability can be expressed as @xmath207 where @xmath208 . by grouping terms of equal weight in the sum",
    ", we arrive at a sum involving only @xmath209 terms @xmath210 the coefficients @xmath211 are called the _ weight enumerators of the coset _ associated to @xmath176 and @xmath212 .",
    "note that the coset weight enumerators play a very important role in estimating the decoder performances of both @xmath2 as well as @xmath3 .",
    "the sum in eq .",
    "( [ dqmld - we - coeff ] ) is now over polynomially many terms unlike its previous form eq .",
    "( [ eq - logical - prob ] ) .",
    "computing such a sum for each logical operator and subsequently optimizing over their values would solve @xmath3 .",
    "an @xmath70 $ ] stabilizer code has @xmath213 , implying that even if the weight enumerators can be computed efficiently , a polynomial - time optimization can not be performed over the different cosets labeled by @xmath212 , unless @xmath214 , which is the regime that we are interested in .",
    "furthermore , we believe @xmath3 is at least as hard otherwise , i.e for @xmath215 .    at this stage , we like to remark that though @xmath2 and @xmath3 are stated as decision problems in @xcite , the problem of practical interest is one of determining a pauli operator that maximizes the respective probabilities in defs.([defn - qmld ] ) and ( [ def - dqmld ] ) .",
    "to enable a decision problem formulation in @xcite , both @xmath2 and @xmath3 are defined to take as input an additional constant @xmath216 .",
    "subsequently , @xmath3 would be made to decide the existence of an @xmath100 whose probability eq .",
    "( [ eq - logical - prob ] ) is at least @xmath216 .",
    "this appears to be achieving more than what is really expected from of @xmath3 ( or @xmath2 ) in practice . in particular , by varying this constant @xmath216 , along with the input in def .",
    "( [ def - dqmld ] ) , one could use the oracle to not only learn the optimal correction but also the probability of its equivalence class .",
    "the latter is not necessary to perform error correction and thus gives more power to the decoder oracle than it should .",
    "this is why we formulated @xmath3 as a function problem that does not explicitly reveal the probability of the equivalence class of the optimal correction , and therefore we consider it to be closer to the real world decoding problem .      before addressing the computational complexity of degenerate decoding ,",
    "we close this section with a discussion of its practical relevance .",
    "the two decoders @xmath2 and @xmath3 will provide different answers whenever the most likely equivalence class does not contain the error with the largest probability . consider the hypothetical scenario where the class of error @xmath217 contains a single error of low weight @xmath218 and @xmath219 errors of high weight @xmath220 , and that the class @xmath221 contains @xmath101 errors of intermediate weight c , @xmath222 . the @xmath2 would chose the error from the class @xmath217 , because it is the most likely error . on the other hand ,",
    "the probabilities of these two classes are given by @xmath223 thus , we see that @xmath3 would provide a different answer if @xmath224 , or equivalently @xmath225 , and that the two decoders would agree otherwise .",
    "thus , for sufficiently low error rates , and in particular in the extreme limit @xmath226 , degeneracy does not affect the decoding problem .",
    "more importantly , degeneracy becomes unimportant when the _ failure rate _ of the code is very low , which does nt necessarily require a low physical noise rate .",
    "remember sec .",
    "( [ sec - deg - dec ] ) that the failure rate @xmath204 of the code is related to the @xmath3 promise gap @xmath199 .",
    "the following lemma , whose proof is presented in app .",
    "( [ app - large - gap ] ) , shows that for @xmath227 , @xmath2 provides the same answer as @xmath3 , which in turn implies that @xmath3 is in @xmath6 with such a large gap .",
    "[ lemma - large - gap ] with a promise gap @xmath228 and on an independent @xmath146 channel , @xmath3 and @xmath2 are equivalent .    in the light of these observations",
    ", one might imagine that in general , @xmath3 can at most offer a marginal improvement over @xmath2 , i.e. that for a given code and noise rate , the decoding error probability of @xmath2 is upper bounded by a function of the decoding error probability of @xmath3 .",
    "there is strong evidence that this is not the case however .",
    "monte carlo simulations @xcite have shown that @xmath2 and @xmath3 achieve different error thresholds with kitaev s topological code .",
    "( this statement is equivalent to the fact that the critical disorder strength separating the ordered from the disordered phase in the random bound ising model decreases below the nishimori temperature . ) thus , for noise rates @xmath157 falling between these two thresholds , the failure probability of @xmath3 tends to 0 as the number of qubit @xmath7 increases , while the failure probability of @xmath2 tends to @xmath229 ( the failure probability of a random guess ) , so the performances of both decoders can be significantly different .",
    "degeneracy can also severely impact the performances of certain decoding algorithms .",
    "due to degeneracy of quantum errors , the ability to correct errors does not imply that the a posteriori marginal error probability over individual qubits is sharply peaked , in contrast to the classical setting .",
    "this is the case in particular for low density parity check ( ldpc ) codes .",
    "these codes have the property of admitting a set of stabilizer generators @xmath86 of weight bounded by a constant . as a consequence ,",
    "the weight of equivalent errors @xmath60 and @xmath91 related by a stabilizer generator @xmath230 will differ at most by a small constant .",
    "thus , we expect degeneracy to play an important role : each equivalence class contains many errors of roughly the same weights . as discussed in @xcite , conventional decoding algorithms for ldpc codes ( belief propagation @xcite )",
    "are _ marginal decoders _ in the sense that they optimize the probability of error independently for each qubit .",
    "but in the presence of degeneracy , we can have a probability sharply peaked over a single equivalence class of errors  ensuring the success of @xmath3but yet have a very broad marginal distribution over individual qubits  leading to a failure of a marginal decoder .",
    "so the existence of a good , general purpose decoder for quantum ldpc codes , playing a role analogous to belief propagation in the classical setting , remains an outstanding open question .",
    "this situation is best illustrated with kitaev s topological code @xcite . in this code , errors correspond to strings on a regular square lattice , and error syndromes are located at the endpoints of the strings .",
    "the weight of an error is equal to the length of the corresponding string .",
    "lastly , the different equivalence classes of errors correspond to the homology classes of the lattice . for a syndrome configuration shown at fig .",
    "( [ fig - toric - code - marginal ] ) , all the short paths have the same homology , so the probability is sharply peaked over one equivalence class .",
    "but there are several distinct strings of the same length compatible with this syndrome , so the marginal error probability over individual qubits is very broad .    [ fig - toric - code - errors ]",
    "lastly , we note that to achieve the true capacity of certain quantum channels ( as opposed to the single - shot capacity ) , it is necessary to encode the information in a degenerate code @xcite . in other words , there are certain channels that could not be used to send any quantum information if a non - degenerate code was used , but can reliably do so at a finite rate with degenerate codes .",
    "we do not know however if degeneracy also needs to be taken into account during the decoding process to realize this .",
    "in particular , the example in @xcite uses a generalization of shor s code @xcite , for which @xmath2 and @xmath3 always yield the same output .",
    "we know of only a few examples of codes for which @xmath3 can be computed efficiently , namely concatenated codes @xcite , convolutional codes @xcite , and bacon - shor codes @xcite .",
    "there exist heuristic methods to take degeneracy into account in topological codes @xcite and turbo codes @xcite .",
    "the one - to - one correspondence between @xmath231 $ ] stabilizer codes and @xmath232 symplectic linear codes @xcite is used in @xcite to show that a solution for @xmath2 can be used to decide an @xmath0 problem in polynomial time .",
    "consequently , @xmath233 .",
    "@xmath3 was shown to be @xmath17 for the case of an independent @xmath146 channel in @xcite and depolarizing channel in @xcite , using a reduction from a @xmath0 problem pertaining to classical linear code .",
    "we now state our main result , which establishes that @xmath3 is in fact much harder than what there previous results anticipated .    [",
    "main - theorem ] @xmath3 ( c.f . def .",
    "( [ def - dqmld ] ) ) of an @xmath234 $ ] stabilizer code on an independent @xmath146 channel and with a promise gap @xmath235^{-1}$ ] , with @xmath236 , is in @xmath1 .    in the following sections",
    ", we will show that for a classical binary linear code @xmath39 and @xmath237 $ ] , the problem of computing @xmath238 for @xmath239 is polynomial time turing reducible to @xmath3 on an independent @xmath146 channel , for @xmath235^{-1}$ ] .    in the case of a general memoryless pauli channel",
    ", it is not always possible to express the probability of a logical class as a weight enumerator sum eq .",
    "( [ dqmld - we - coeff ] ) with polynomially many terms in the sum .",
    "hence , in such cases , the containment of @xmath3 in @xmath5 is not known and we can only claim that it is @xmath240 . however , whenever one can express @xmath241 as a sum with polynomially many terms , each of which is a @xmath5 function , then @xmath3 can be put into @xmath5 .    for the independent @xmath146 channel , the containment in @xmath5 is straightforward .",
    "[ dqmld - sharpp ] @xmath3 in def .",
    "( [ def - dqmld ] ) on a @xmath70 $ ] stabilizer code with @xmath242 on an independent @xmath146 channel eq .",
    "( [ eq - prob - xz ] ) or a depolarizing channel , is in @xmath5 .",
    "from the definition of @xmath3 , one can subdivide it into two problems .",
    "the first step consists of computing the probabilities of all the logical classes , corresponding to the given syndrome , followed next by an optimization over the probabilities , thereby choosing an error from the logical class with the largest probability . since @xmath242",
    ", there are at most polynomially many logical classes and hence a naive search for the maximum amongst the set of probabilities of all the logical classes can be achieved in polynomial - time .",
    "it now remains to show that for each logical class , its probability eq .",
    "( [ we - coeff - sum ] ) for a general noise rate @xmath157 , is a @xmath5 function .",
    "this immediately follows from the polynomial form in @xmath157 , taken by the logical class probabilities , eq .",
    "( [ dqmld - we - coeff ] ) and the observation that the the coefficients of the polynomial are weight enumerator coefficients of a suitable linear code sec .",
    "( [ sec - symplectic ] ) .",
    "the promise gap @xmath189 is irrelevant to the containment of @xmath3 in @xmath5 unless @xmath243 .",
    "a gap of @xmath244 is essential since the probabilities of various logical classes are represented as bit - strings for performing arithmetic and they must differ in the first polynomially many bits .",
    "in this section , we present a polynomial time algorithm that accepts as input a classical linear code @xmath43 and outputs @xmath245 as in def .",
    "( [ we - def - code ] ) by querying a @xmath3 oracle with an independent @xmath146 noise model and a promise gap @xmath189 which is @xmath246 .",
    "the correspondence between symplectic linear codes and stabilizer codes discussed in sec .  ( [ sec - symplectic ] ) implies that with an independent @xmath146 channel , the probability of a logical class is related to the weight enumerator polynomial of a classical linear code . in particular , with the trivial syndrome @xmath247 and at very low noise rate @xmath248 ,",
    "the most likely equivalence class is always the trivial one @xmath102 .",
    "hence , in this setting , the probability of the trivial logical class for a quantum code with stabilizers @xmath66 can be expressed , similar to eq .",
    "( [ dqmld - we - coeff ] ) , in terms of a corresponding classical code @xmath249 as follows @xmath250    since this probability is a polynomial of degree @xmath109 , determining its value for @xmath251 distinct values of the physical noise rate @xmath157 would enable us to determine the weight enumerator of the corresponding classical code .",
    "there are two caveats to this approach .",
    "first , this approach only works for classical codes @xmath249 whose generator matrix corresponds to the symplectic representation of a quantum stabilizer code .",
    "second , this approach requires knowledge of the probability of a certain equivalence class , while @xmath3 only outputs the equivalence class with the largest probability ; it does not reveal the value of the corresponding probability .",
    "the first caveat can easily be circumvented , for instance by padding the @xmath7-bit classical code with @xmath7 additional @xmath195s , thus obtaining a valid symplectic representation of a @xmath7-qubit quantum code ( one whose stabilizer generators contain only @xmath113 operators ) .",
    "consequently , all stabilizers have weights between 0 and @xmath7 and the probability of the trivial logical class can be expressed as eq .",
    "( [ prob - i - we ] ) , where the range of sum is up to @xmath7 . to circumvent the second caveat , we need to use the @xmath3 oracle to obtain equality constraints on the weight enumerator of @xmath39 .",
    "this is done by varying the physical noise rate @xmath157 , always keeping the syndrome trivial . as mentioned above , at very low noise rate",
    "the optimal logical class is @xmath252 . increasing the noise rate @xmath157",
    ", we will reach a _ crossing point _ @xmath253 where the @xmath3 output changes from @xmath115 to @xmath254 . at this point , the promise gap condition is violated , i.e , @xmath255 , which can be expressed in terms of weight enumerators as : @xmath256 where @xmath257 are the weight enumerators of an affine code . in the case where @xmath258 , this crossing point provides an equality condition between two polynomials , which is what we are seeking .",
    "but since these are polynomials with integer coefficients , knowing the location of a crossing point within a finite accuracy , which translate into a finite promise gap @xmath189 , is enough to determine the exact crossing point , see lemma .",
    "( [ gap - size - qpoly ] ) .",
    "as we will show , there exists a fixed range of @xmath157 that provably contains a unique crossing point , enabling a polynomial - time accurate determination of the crossing point using a binary search procedure .",
    "this gives us one potential equality , but introduces more unknown coefficients @xmath257 . to get additional linear constraints , we modify the code in a very special way , described in sec .",
    "( [ sec - stab - cons ] ) .",
    "this modification requires adding one _ tunable _ qubit and one stabilizer generator . by varying the noise rate on the tunable qubit over a range of values",
    ", we can change the location of the crossing point , and thus obtain new linear constraints relating @xmath259 and the @xmath260 . repeating this procedure @xmath261 times and making sure that all the linear constraints are linearly independent sec .",
    "( [ sec - indep - cons ] ) enable us to determine the weight enumerator coefficients . while the ability to change the noise rate of the tunable qubit gives us more linear constraints , it breaks the requirement that the noise model be the independent @xmath146 channel with the same strength on all qubits .",
    "we will fix this problem in app .",
    "( [ app - concatenate ] ) by showing that the required channel can be simulated by concatenating the code with a shor code .",
    "in fact , we will use this technique repeatedly in our proof .",
    "let @xmath262 be the @xmath263 generator matrix of an @xmath38 classical linear code @xmath264 .",
    "denote @xmath265 the rows of @xmath262 and let @xmath266 be a generating set of the complement of the row space of @xmath262 , i.e. in such a way that @xmath267 span @xmath268 . construct a matrix @xmath269 with rows@xmath267 .",
    "this matrix is full rank , and therefore has an inverse @xmath270 that can be computed efficiently , and obeys @xmath271 .",
    "denote the rows of @xmath270 by @xmath272 .",
    "we define a @xmath273 $ ] quantum code with stabilizer generators and logical operators given by @xmath274 where it is implicitly assumed that operators are padded to the right by identities to be elements of @xmath275 .",
    "the validity of the resulting code can be verified from the fact that    1 .",
    "there are in total @xmath276 qubits .",
    "the @xmath277 stabilizer generators are independent .",
    "this follows from the linear independence of the @xmath278 and the linear independence of the @xmath279 , together with the fact that @xmath112-type operators are linearly independent of @xmath113 type generators .",
    "the stabilizer generators mutually commute .",
    "this is trivial among the first @xmath280 generators as they contain only @xmath113 operators and similarly among the last @xmath281 last generators . between these two sets ,",
    "the commutation follows from the fact that @xmath282 except when @xmath283 , in which case the presence of additional @xmath112 and @xmath113 on the @xmath284th qubit ensures commutation .",
    "the logical operators commute with the stabilizer generators .",
    "this follows from the fact that @xmath285 for @xmath286 , and the fact that @xmath112-type operators commute among themselves and similarly for @xmath113-type operators .    as discussed in sec .",
    "( [ sec - deg - dec ] ) , the probability of the trivial logical class @xmath252 given a trivial syndrome @xmath247 is simply the sum of the probabilities of all stabilizer group elements .",
    "suppose now that the last @xmath281 qubits are error - free , while the other qubits are subject to an independent @xmath146 channel .",
    "then , the probability of an element of @xmath66 is zero if it contains a generator @xmath287 from the above list with @xmath288 .",
    "otherwise , this element of @xmath66 can be written as @xmath289 for some @xmath290 and its probability is @xmath291 .",
    "we conclude that the probability of the trivial logical class is given by eq .",
    "( [ prob - i - we ] ) with @xmath39 the classical code defined by the generating matrix @xmath262 .",
    "constraints on the weight enumerator polynomial will be obtained by finding crossing points where @xmath292 with @xmath293 . for technical reasons",
    ", we would like to be able to choose which @xmath212 will be the one realizing the crossing .",
    "this is because we want to force the crossing to happen with the same @xmath212 every time . to do this",
    ", we will modify the stabilizer by adding an extra qubit and making the transformations @xmath294 to the stabilizers and logical operators , and adding the following stabilizer generator @xmath295 this defines an @xmath296 $ ] stabilizer code , and its validity can easily be verified given the commutation relations worked out above .",
    "moreover , if we assume that the added @xmath297th qubit is also error - free , then the probability of the trivial logical class @xmath252 given a trivial syndrome @xmath247 is unchanged , and moreover the only other logical class with non - zero probability is the one associated to @xmath298 , i.e. @xmath299 .",
    "we need to perform one last modification to the code in order to be able to tune the crossing point , and hence obtain linearly independent equalities between @xmath300 and @xmath301 .",
    "this transformation is quite similar to the previous one , and given by @xmath302 and adding the following stabilizer generator @xmath303 for this last qubit , we will assume a noise model where @xmath304 , @xmath305 , and @xmath306 with @xmath307 being a tunable parameter . with this last choice ,",
    "the only two non - zero probabilities of logical class conditioned on the trivial syndrome are given by @xmath308 where @xmath309 as above , @xmath310 is a suitable normalization factor , and @xmath311 are the weight enumerators of the affine code associated to the @xmath298 logical class @xmath312 a crossing point is observed when @xmath313 where @xmath314 is a tunable parameter over the positive reals .",
    "changing the value of @xmath315 will change the crossing point between these two logical classes , and provide linear constraints between two degree @xmath7 polynomials .",
    "if we can identify @xmath251 such crossing points , it would provide enough information to retrieve the two polynomials , and hence solve the weight enumerator problem .",
    "at this point , we have a deterministic procedure that , given any classical linear code @xmath39 , can be used to generate linear constrains on its weight enumerator coefficients . clearly , the overhead in the runtime of this procedure is the time required to spot a crossing point .",
    "a crossing point can potentially be observed at a physical noise rate @xmath157 anywhere between 0 and 1 .",
    "one obvious indication of a crossing point is the switch in the output of the @xmath3 oracle as we move @xmath157 across the crossing point .",
    "however if we move @xmath157 across two crossing points , we will not notice any net switch in the outputs of the @xmath3 oracle .",
    "for this reason , we now want to restrict the values of @xmath157 to a range where we can prove that there is at most one crossing point .",
    "this will be possible by restricting the tunable parameter @xmath315 to a small interval near 0 .",
    "[ gap - size - qpoly ] given the stabilizer code defined above with a tunable parameter @xmath316 , where @xmath317 is the distance between @xmath39 and @xmath318 , then there exists exactly one crossing point between the pair of logical classes @xmath115 and @xmath319 in the interval @xmath320 .",
    "first , note that for sufficiently small @xmath157 and for any value of @xmath315 , @xmath3 will output the identity class , simply because its probability is a polynomial in @xmath157 with a constant term , and the probabilities of all other logical classes contain no constant term .",
    "furthermore , we claim that the probability of the trivial logical class is a strictly decreasing function of the noise rate @xmath157 , when @xmath321 . to justify this , it suffices to show that the derivative of @xmath322 is strictly negative in the prescribed range of noise rates . recalling the weight enumerator polynomial for @xmath322 and computing the derivative w.r.t @xmath157",
    ", we find :    & = _ i = 0^n_i()()^i(1-)^2n - i + & = _ i=1^n_i()()^i(1-)^2n - i- n(1-)^2n-1 [ eq : rand ]    where the last term is added because we have changed the range of summation .",
    "it only remains to show that the expression above is strictly negative .",
    "clearly , this can not be true for all @xmath323 $ ] .",
    "however , when @xmath324 , we know that the first term in eq .",
    "( [ eq : rand ] ) is non - negative . indeed ,",
    "all of its terms are positive by definition , except the one in square bracket which is non - negative when @xmath324 .",
    "we claim now that when @xmath324 , the second term of eq .",
    "( [ eq : rand ] ) is negative and greater in norm than the first one , so the entire expression is strictly negative .",
    "this can be observed by the following inequality :    _ i=1^n_i()()^i(1-)^2n - i & < _ i=1 ^ 2n()^i(1-)^2n - i + & = _",
    "i=0 ^ 2n()^i(1-)^2n - i+ n(1-)^2n-1 + & = n(1-)^2n-1 .",
    "hence , we see that indeed the probability of the trivial logical class is strictly decreasing when @xmath321 .",
    "since there are only two logical classes in our setting , it is clear that the probability associated to the other class is increasing in that interval .",
    "we have identified an interval where the probabilities are monotonic , and what remains to be shown is that there is indeed a crossing point inside this interval when the parameter @xmath315 is chosen carefully .",
    "intuitively , we can see that decreasing the value of @xmath315 ( and hence of the trivial logical class ) will decrease the value of @xmath157 where the first crossing point occurs .",
    "we will now set an upper bound @xmath325 on the value of @xmath157 where the first crossing point occurs .",
    "the first crossing point will occur at the latest when @xmath326 , so equivalently @xmath327 . on the other hand ,",
    "the ratio @xmath328 is lower - bounded by @xmath329^d$ ] since each word in @xmath330 is mapped onto a word @xmath331 of weight at most @xmath332 in @xmath333 .",
    "hence , the first crossing occurs for a value of @xmath157 lower or equal to the point where @xmath334^{d } ,",
    "\\ { \\rm or\\ equivalently\\ } p_{\\max } =   \\dfrac{2}{1 + ( 1 - \\delta)^{\\frac{1}{d}}\\thickspace v^{-\\frac{1}{d}}}.\\ ] ] by choosing @xmath335 we are sure that the first crossing point occurs in the monotonic region , and hence that the interval @xmath321 contains a single crossing point .",
    "the existence of a unique crossing point in the interval @xmath336 $ ] enables a _ binary - search like _ procedure to narrow down on the possible location of a crossing point .",
    "if @xmath3 produces the same output for a pair of @xmath157 s in that interval , it implies that no such crossing point exists between them , and furthermore , that a crossing point lies outside of this interval .",
    "this halves the size of the interval between the next pair of points to be queried with .",
    "hence the location of the crossing point can be obtained to an accuracy of @xmath337 with at most @xmath338 queries to @xmath3 .",
    "we have described a polynomial - time method to estimate the location of crossing points within exponential accuracy , i.e. values of @xmath157 where eq .",
    "( [ cpv ] ) is fulfilled .",
    "it remains to show that a polynomial number of such linear constraints are sufficient to determine the weight enumerators of the linear code .",
    "every crossing point provides a linear constraint on @xmath339 .",
    "however these conditions are inequalities . in the following lemma",
    ", we establish that for @xmath189 sufficiently small , the system of inequalities provides the same integer solutions as the system of equalities ( i.e. , obtained with @xmath258 ) .",
    "[ lemma - gap - size ] provided that @xmath235^{-1}$ ] , the first @xmath340 weight enumerator coefficients @xmath341 can be extracted efficiently from the value of @xmath251 crossing points @xmath342 that produce linearly independent inequalities eq .",
    "( [ cpv ] ) .    given a crossing point @xmath342 , we can rewrite the inequality eq .",
    "( [ cpv ] ) as an equality @xmath343 = 0\\end{gathered}\\ ] ] by introducing an unknown parameter @xmath344 . given @xmath251 distinct crossing points @xmath342",
    ", we obtain a linear system @xmath345 , where @xmath346 and @xmath347 is the vector containing the weight enumerator coefficients .",
    "since the location of a crossing point is invariant under multiplying both weight enumerators @xmath348 by a constant , it is clear that @xmath251 linear independent constraints alone would result in the trivial solution .",
    "however , the normalization condition @xmath349 along with the @xmath251 linearly independent constraints obtained from the location of crossing points is sufficient to determine the weight enumerators coefficients in @xmath350 , @xmath351\\cdot\\sfm \\thinspace\\right]^{-1}\\cdot \\vec{b } \\label{eq - m - inv - gap}\\end{gathered}\\ ] ] where we have defined @xmath352 \\label{constraint - matrix } \\\\",
    "\\vec{b } = \\begin{pmatrix}0 & \\cdots 0 & 2^{n}\\end{pmatrix}^{\\sft } \\textsf { , } \\vec{\\omega } = \\begin{pmatrix } b_{0 } & \\cdots & b_{n } & \\operatorname{\\textsf{we}}_{0}(\\cc ) & \\cdots & \\operatorname{\\textsf{we}}_{n}(\\cc)\\end{pmatrix}^{\\sft } \\label{weight - enumerator - coefficients - vector - b } \\\\",
    "\\cj = \\left[\\begin{array}{ccc|ccc } 0 & & & & & \\\\ & \\ddots   & & & { \\fontsize{50}{60}\\selectfont \\textsf{0 } } & \\\\ & & 0 & & & \\\\ \\hline & & & -\\delta_{1 } & & \\\\ & { \\fontsize{50}{60}\\selectfont \\textsf{0 } } & & & \\ddots & \\\\ & & & & & -\\delta_{n+1 } \\\\",
    "\\hline 0 & \\dots & 0 & 0 & \\dots & 1 \\end{array}\\right ] \\text { with } 0 \\leq \\delta_{i } \\leq 1 , \\thickspace \\forall \\thinspace 1\\leq i\\leq n+1 , \\label{gap - error } \\\\   { \\rm and\\ } v_{k } = \\dfrac{\\sum_{i=0}^{n}b_{i}\\tilde{p}_{k}^{i}}{\\sum_{i=0}^{n}\\operatorname{\\textsf{we}}(\\cc)_{i}\\tilde{p}_{k}^{i}}. \\label{vk - we - ratio}\\end{gathered}\\ ] ]    denote @xmath353 the solution of this linear system in the case where @xmath258 , i.e. , @xmath354 .",
    "this solution is not the weight enumerator , because we omitted the @xmath355 term .",
    "however , since the weight enumerator coefficients are integers , we expect that for @xmath189 sufficiently small , rounding up each component of @xmath356 to the nearest integer will give the correct answer @xmath357 . for this approach to succeed",
    ", it suffices to ensure that @xmath358 . using eq .",
    "( [ eq - m - inv - gap ] ) for @xmath350 and a similar one for @xmath359 ( with @xmath258 ) , we can rewrite this condition in terms of the constraint matrix in eq .",
    "( [ constraint - matrix ] ) as : @xmath360 which ensures that only the elements in the last column of the inverse matrix have a non - trivial contributions to the components of @xmath350 .    using properties of matrix multiplication and the @xmath361-norms of matrices in eq .",
    "( [ gap - effect - we ] ) , we obtain @xmath362\\cdot\\sfm \\thinspace\\right]^{-1 } - \\sfm^{-1 } \\thinspace\\right|_{i , n } \\thickspace \\leq \\left(\\left|\\left|\\thinspace \\left[\\mathbb{i } + \\delta\\thickspace \\cj\\right]^{-1 } \\thinspace\\right|\\right|_{\\infty } - 1\\right ) \\thickspace \\left|\\left[\\sfm^{-1}\\right]_{i , n}\\right| .\\label{eq - inv - norm}\\end{gathered}\\ ] ] the explicit form of the matrix in eq .",
    "( [ gap - error ] ) can be used to verify that @xmath363 and also @xmath364_{i , n}\\thinspace 2^{n } = \\operatorname{\\textsf{we}}_{i}(\\cc ) \\leq n^{i } , \\thickspace\\forall \\thinspace 1\\leq i\\leq n+1 $ ] .",
    "hence we can now state a sufficient condition for eq .",
    "( [ gap - effect - we ] ) to hold : @xmath365 \\thinspace n^{i } \\thickspace \\leq \\thickspace \\dfrac{1}{2 } , \\quad \\forall \\thinspace 1\\leq i\\leq n+1\\label{gap - error - wei}\\end{gathered}\\ ] ] the lemma follows by imposing this condition for all @xmath366 , yielding @xmath365 \\thinspace n^{\\lambda } \\thickspace \\leq \\thickspace \\dfrac{1}{2 } \\thickspace \\rightarrow \\thickspace \\delta \\leq \\dfrac{2}{2 + n^{\\lambda}}. \\label{gap - qpoly}\\end{gathered}\\ ] ]    though it is clear that we must have @xmath251 linearly independent constraints on @xmath339 along with a promise gap of @xmath235^{-1}$ ] , it is not immediately clear how many distinct crossing points need to be located to obtain these constraints , i.e. some of the crossing points associated to distinct pairs @xmath367 may result in linearly dependent constraints eq .",
    "( [ cpv ] ) .",
    "the following lemma ensures that we can always efficiently find linearly independent constraints .",
    "[ indep - cons ] the identification of at most @xmath368 distinct crossing points @xmath367 of eq .",
    "( [ cpv ] ) will produce @xmath251 linearly independent constraints .    the @xmath369 matrix in eq .",
    "( [ constraint - matrix ] ) can be represented as @xmath370 $ ] where @xmath371 is a @xmath372 _ vandermonde matrix _ and @xmath373 is a diagonal square matrix .",
    "we shall prescribe a polynomial - time method to construct a full - rank matrix of this form .",
    "let @xmath374 represent the sub - matrix of @xmath375 formed by taking the first @xmath376 column entries of the first @xmath376 rows .",
    "hence @xmath374 is a square matrix .",
    "moreover , notice that a sufficient condition for the the matrix in eq .",
    "( [ constraint - matrix ] ) to describe @xmath376 independent constraints is that @xmath374 must have a non - vanishing determinant .",
    "hence , it suffices to show that each new constraint can be generated such that the corresponding square matrix @xmath374 satisfy @xmath377 .",
    "consider the simple case when @xmath378 .",
    "in this case , @xmath374 is always given by a _",
    "vandermonde matrix _ , which is full rank if and only if all @xmath379 are distinct @xcite .",
    "hence , this implies that @xmath209 distinct values of @xmath380 suffice to generate @xmath209 constraints that are necessarily independent , since different @xmath315 s necessarily produce different @xmath157 s ( see lemma .",
    "( [ crossing - acc ] ) ) .    for @xmath381 , it is not immediately clear if the procedure prescribed in sec .",
    "( [ sec - stab - cons ] ) will provide linearly independent constraints even if we choose all @xmath380 to be distinct .",
    "however , a sufficient condition for independency is again the non - vanishing of @xmath382 .",
    "assume that the choices of @xmath383 are such that @xmath384 .",
    "the laplace - expansion of the determinant suggests that @xmath385 when @xmath386 is given by : @xmath387 where @xmath388 and @xmath389 are constants ( independent of @xmath390 ; they are minors of @xmath391 and @xmath392 respectively ) .",
    "the above equation classifies the particular values of @xmath386 that fail to generate @xmath376 linearly independent constraints on @xmath393 .",
    "note that @xmath394 are related by eq .",
    "( [ vk - we - ratio ] ) .",
    "hence , equating this with eq .",
    "( [ indep - det0 ] ) results in a rational polynomial in @xmath395 , which has at most @xmath109 roots , unless the expressions in eqs . and are identical .",
    "assume for now that these expressions are not identical .",
    "then we can choose to sample @xmath251 different values of @xmath386 according to eq .",
    "( [ vk - we - ratio ] ) , and for at least one of them , the resulting @xmath395 will violate eq .  ( [ indep - det0 ] ) , so the pair @xmath394 will produces a linearly independent constraint . on the other hand , if the two functions in eqs . and",
    "are identical , then we have that @xmath396 : @xmath397 the above relation immediately fixes the coefficients @xmath393 by just comparing the powers of @xmath398 .    since we must sample at most @xmath251 crossing points to obtain a linearly independent constraint on @xmath393 , we require at most @xmath399 or ( for expressional convenience ) @xmath400 distinct crossing points to construct the a full rank matrix of the form in eq .",
    "( [ constraint - matrix ] ) .",
    "the last ingredient we need is a bound on the distance between crossing points .",
    "remember that we are only able to locate the value of a crossing probability @xmath342 to exponential accuracy .",
    "thus , it is necessary that changing the tunable parameter @xmath315 has a significant effect on the value of the crossing point in order to generate linearly independent constraints ( with significantly different values of @xmath342 ) . combining the restriction on the values of the tunable parameter in eq .",
    "( [ eq - max - crossing ] ) with lemma .",
    "( [ indep - cons ] ) immediately tells that the smallest change in the tunable parameter will be at least @xmath401 .",
    "this naturally implies a minimum separation between two crossing points , as the lemma below addresses :    [ crossing - acc ] let @xmath402 denote crossing points of a stabilizer code constructed as above with @xmath403^{-1}$ ]",
    ". then @xmath404 .",
    "we need to relate the difference in @xmath315 to a difference in @xmath157 . for this , let us recall that if @xmath405 is a small change in @xmath315 and @xmath406 a small change in @xmath157 , then @xmath407 , or equivalently : @xmath408 . computing the derivative using the expression for @xmath315 in eq .",
    "( [ vk - we - ratio ] ) , we have :    & = ( ) + & ( ) + &    since @xmath409 , we find : @xmath410 .    hence it suffices to estimate the location of each crossing point to within an accuracy of @xmath411 , implying that we must run at most @xmath412 iterations of the above binary - search like procedure , mentioned at the end of sec .",
    "( [ sec - crossing ] ) , to locate the crossing point .",
    "assuming that each query to a @xmath3 oracle is answered in constant time , the above procedure takes @xmath413 time .    in appendix app .",
    "( [ app - concatenate ] ) we construct a repetition code with polynomially many qubits to encode a single qubit , such that the resulting noise on the encoding qubit obeys @xmath305 , @xmath414 , and @xmath415 with an exponential accuracy ( the error - free model is a special case @xmath416 ) .",
    "this implies that the tunable parameters @xmath417 used to find crossing points can be set to exponential accuracy .    with these , we are in a position to prove our main result .    given an input classical linear code @xmath39 , we built a generating set for a stabilizer code , with two logicals , that satisfies eq .",
    "( [ prob - i - we ] ) . appending additional qubits to this code and choosing a specific channel sec .",
    "( [ sec - stab - cons ] ) , on those qubits , enabled the introduction of a tunable parameter in the logical class probabilities eqs . and .",
    "varying this tunable parameter as per lemma .",
    "( [ gap - size - qpoly ] ) , with a polynomial number of queries to a @xmath3 oracle , we can estimate the location of a crossing point to within exponential accuracy , thereby providing a linear constraint on the weight enumerator coefficients . repeating this procedure @xmath251 times , we showed in lemma .",
    "( [ lemma - gap - size ] ) that , as long as the promise gap is @xmath418^{-1}$ ] , the system of inequalities yield the same solution to the first @xmath340 weight enumerator coefficients of @xmath39 , up to an integer approximation , as the system of equalities considered without any promise gap . since @xmath419 in thm .",
    "( [ main - theorem ] ) , it suffices to have a promise gap in @xmath3 that is @xmath420 .",
    "it followed from lemma .",
    "( [ indep - cons ] ) that at most @xmath400 crossing points are sufficient to generate the necessary linearly independent constraints on the weight enumerator coefficients and from lemma .",
    "( [ crossing - acc ] ) that the accuracy on their location , achievable in polynomial time , is sufficient .",
    "lastly , we showed in app .",
    "( [ app - concatenate ] ) that it suffices to direct all queries to a @xmath3 oracle on a independent @xmath146 channel .",
    "thus we prove thm .",
    "( [ main - theorem ] ) .",
    "we will close with mentioning a few open problems which we were not able to address in this paper .",
    "in the course of this paper we have addressed the optimal decoding problem on an independent @xmath146 channel .",
    "however , the same can be done for a depolarizing channel by introducing the notion of a generalized weight described in @xcite . hence , sec .",
    "( [ sec - stab - cons ] ) of the paper will undergo certain modifications when choosing to address a depolarizing channel .",
    "the key problem turns out to be the classification of the _ parametrized _ complexity of the decoding with the promise gap parameter def .",
    "( [ def - dqmld ] ) , denoted by @xmath189 .",
    "we know the complexities for two extreme cases , namely @xmath3 is @xmath1 when @xmath421 , c.f .",
    "( [ main - theorem ] ) and in @xmath6 when @xmath422 , c.f .",
    "( [ lemma - large - gap ] ) .",
    "however , for a vast intermediate range of @xmath189 , complexity of @xmath3 remains open . as described in sec .",
    "( [ sec - deg - dec ] ) , for a code encoding a single qubit , the promise gap @xmath189 is related to the decoding failure probability @xmath423 as @xmath424 .",
    "thus , the two extreme cases considered above correspond respectively to optimal decoding in a very noisy regime ( failure probability approaching unity ) and optimal decoding with an exponentially small failure probability .",
    "unfortunately , the case of practical interest falls somewhere in between .",
    "the complexity of any problem is only a highlight of the runtime of any algorithm on the worst case instance of the problem .",
    "hence it is of practical interest to know the runtime of the algorithm for any _ typical _ instance .",
    "this could refer for instance to a typical syndrome or a random code .",
    "it is well known however that random codes are non - degenerate @xcite , so the decoding is not expected to be affected by the degeneracy in errors , so our result is probably not relevant in this setting .",
    "however , for the practically relevant class of _ sparse codes _ , the complexity of optimal decoding strategy remains an important open question .",
    "lastly , our analysis has focused on stabilizer codes over pauli channels .",
    "this is particularly convenient due to the discrete nature of the resulting decoding problem .",
    "this setting could be generalized in two obvious ways .",
    "first , we could consider codes that are not stabilizer codes , defined from a set of commuting projectors .",
    "there exists a growing interest for those codes , particularly in the setting of topological quantum order @xcite . in this setting",
    ", we could study for instance the decoding problem for systems that support non - abelian anyons @xcite .",
    "second , we could consider errors that are not described by pauli operators .",
    "this problem is of practical importance because no real - world device undergoes a pauli channel ; for instance the physical process of relaxation is not described by a pauli channel .",
    "we thank daniel gottesman for stimulating discussions and guillaume duclos - cianci for careful reading of this manuscript .",
    "this work was partly funded by canada s nserc and by the lockheed martin corporation .    10    e.  berlekamp , r.  mceliece , and h.  van tilborg , `` on the inherent intractability of certain coding problems ( corresp . ) '' , _ information theory , ieee transactions on _ , vol .",
    "24 , pp .  384  386 , 1978 .",
    "a.  vardy , `` the intractability of computing the minimum distance of a code '' , _ ieee transactions on information theory _ , vol .",
    "43 , no .  6 , pp .",
    "17571766 , 1997 .",
    "hsieh and f.  le  gall , `` np - hardness of decoding quantum error - correction codes '' , _ phys .",
    "a _ , vol .",
    "83 , p.  052331",
    ", 2011 .",
    "kuo and c .- c .",
    "lu , `` on the hardness of decoding quantum stabilizer codes under the depolarizing channel '' , in _ information theory and its applications ( isita ) , 2012 international symposium on _ , pp .  208 211 , 2012 .    c.  e. shannon , `` a mathematical theory of communication '' , _ bell system tech .",
    "_ , vol .  27 , pp .  379 , 623 , 1948 .    d.  gottesman , _ stabilizer codes and quantum error correction _ , phd thesis , california institute of technology , 1997 .    a.  r. calderbank , e.  m. rains , p.  w. shor , and n.  j.  a. sloane , `` quantum error correction and orthogonal geometry '' , _ phys",
    "_ , vol .",
    "78 , pp .  405408 , 1997 .",
    "m.  freedman and d.  meyer , `` projective plane and planar quantum codes '' , _ found .",
    "_ , vol .  1 , p.  325",
    ", 2001 .",
    "d.  j.  c. mackay , g.  mitchison , and p.  l. mcfadden , `` sparse graph codes for quantum error - correction '' , _ ieee trans .",
    "_ , vol .",
    "50 , no .",
    "10 , pp .  23152330 , 2004 .",
    "t.  camara , h.  ollivier , and j .- p .",
    "tillich , `` a class of quantum ldpc codes : construction and performances under iterative decoding '' , in _ isit _ , p.  811",
    ", 2007 .",
    "tillich and g.  zemor , `` quantum ldpc codes with positive rate and minimum distance proportional to @xmath425 '' , in _ ieee international symposium on information theory , 2009 .",
    "isit 2009 _ , pp .",
    "799 803 , 2009 .",
    "d.  poulin , j .-",
    "tillich , and h.  ollivier , `` quantum serial turbo codes '' , _ ieee trans .",
    "_ , vol .",
    "55 , pp .  27762798 , 2009 .",
    "c.  wang , j.  harrington , and j.  preskill , `` confinement - higgs transition in a disordered gauge theory and the accuracy threshold for quantum memory '' , _ annals of physics _ , vol",
    ".  303 , pp .  3158 , 2003 .",
    "d.  poulin , `` optimal and efficient decoding of concatenated quantum block codes '' , _ physical review a _ , vol .",
    "74 , no .  5 , 2006 .    g.  duclos - cianci and d.  poulin , `` fast decoders for topological quantum codes '' , _ phys",
    "_ , vol .",
    "104 , p.  050504",
    ", 2010 .",
    "e.  pelchat and d.  poulin , `` degenerate viterbi decoding '' , _ ieee transactions on information theory _",
    "59 , no .  6 , pp .",
    "39153921 , 2013 .",
    "kuo and c .- c .",
    "lu , `` on the hardnesses of several quantum decoding problems '' , 2013 .",
    "m.n.vyalyi , `` hardness of approximating the weight enumerator of a binary linear code '' , 2003 .",
    "i.  briquel , _ complexity issues in counting , polynomial calculation and zero finding _ ,",
    "phd thesis , ecole normale de lyon and city university of hong kong , 2011 .",
    "l.  g. valiant , `` the complexity of enumeration and reliability problems '' , _ siam journal on computing _ , vol .  8 , no .  3 , pp .",
    "410421 , 1979 .",
    "s.  arora and b.  barak , _ computational complexity : a modern approach _ , cambridge university press , 2009 .",
    "s.  toda , `` pp is as hard as the polynomial - time hierarchy '' , _ siam journal on computing _ , vol .  20 , no .  5 , pp .  865877 , 1991 .",
    "a.  barg , `` complexity issues in coding theory '' , 1997 .",
    "m.  nielsen and i.  chuang , _ quantum computation and quantum information _ , cambridge series on information and the natural sciences , cambridge university press , 2000",
    ".    j.  preskill , `` quantum error correction '' , ch.7 , lecture notes for physics 229 : quantum information and computation , 1998 .",
    "e.  berlekamp , _ algebraic coding theory _ , mcgraw - hill series in systems science , aegean park press , 1984 .",
    "a.  honecker , m.  picco , and p.  pujol , `` nishimori point in the 2d @xmath426 random - bond ising model '' , _ phys .",
    "_ , vol .",
    "87 , p.  047201",
    ", 2001 .",
    "h.  bombin , r.  s. andrist , m.  ohzeki , h.  g. katzgraber , and m.  a. martin - delgado , `` strong resilience of topological codes to depolarization '' , _ physical review x _ , vol .  2 , p.  021004",
    ", 2012 .",
    "d.  poulin and y.  chung , `` on the iterative decoding of sparse quantum codes '' , _ quantum information and computation _ , vol .  8 , pp .  9871000 , 2008 .",
    "s.  aji and r.  mceliece , `` the generalized distributive law '' , _ ieee transactions on information theory _ , vol .  46 , no .  2 , p.  325 , 2000 .    a.  y. kitaev , `` fault - tolerant quantum computation by anyons '' , _ ann .",
    "_ , vol .  303 , p.  2",
    ", 2003 .",
    "g.  smith and j.  a. smolin , `` degenerate coding for pauli channels '' , _ phys .",
    "_ , vol .",
    "98 , p.  030501",
    ", 2007 .",
    "p.  w. shor , `` scheme for reducing decoherence in quantum computer memory '' , _ phys .",
    "a _ , vol .",
    "52 , p.  2493",
    ", 1995 .",
    "j.  napp and j.  preskill , `` optimal bacon - shor codes '' , _ quantum information and computation _ , vol .",
    "13 , pp .  490510 , 2013 .",
    "k.  b. petersen and m.  s. pedersen , _ the matrix cookbook _",
    ", technical university of denmark , 2012 .",
    "a.  ashikhmin , a.  barg , e.  knill , and s.  litsyn , `` quantum error detection .ii .",
    "bounds '' , _ ieee transactions on information theory _ , vol .",
    "46 , no .  3 , pp .",
    "789800 , 2000 .",
    "j.  haah and j.  preskill , `` logical operator tradeoff for local quantum codes '' , _ phys .",
    "a _ , vol .",
    "86 , p.  032308",
    ", 2012 .",
    "o.  landon - cardinal and d.  poulin , `` local topological order inhibits thermal stability in 2d '' , _ phys .",
    "_ , vol .  110 , p.  090502",
    ", 2013 .",
    "n.  e. bonesteel and d.  p. divincenzo , `` quantum circuits for measuring levin - wen operators '' , _ physical review b _ , vol .",
    "86 , p.  165113",
    ", 2012 .    c.  brell , s.  burton , g.  dauphinais , s.  flammia , and d.  poulin , `` quantum error correction for non - abelian anyons '' , in preparation",
    "in our reduction , we have used two features of the a general memoryless pauli channel , that are not intrinsic to an independent @xmath146 channel .",
    "they involve the freedom of assigning unequal noise rates for @xmath427 and @xmath113 type errors on some qubits of the code .",
    "however , when a qubit of the code is encoded into an auxiliary code , the the optimal decoder on this concatenated code will replace the physical noise rates for the qubit with the logical noise rates ( logical class probabilities ) of the auxiliary code @xcite .",
    "therefore , the physical noise rates for that qubit can be controlled by controlling the logical class probabilities of the auxiliary code .",
    "the latter can be achieved by varying the syndrome on the auxiliary code .    in our case , the auxiliary code is the shor code @xcite on a @xmath428 qubits , with @xmath429 .",
    "the stabilizers of this code can be represented graphically on a @xmath430 lattice with a qubits at each vertex , see fig .",
    "( [ sim - shor - code ] ) .",
    "each horizontal link between a pair of vertices represents a @xmath132type stabilizer on the qubits corresponding to the vertices .",
    "a pair of rows represents a @xmath131type stabilizer on the qubits corresponding to the vertices on those rows .",
    "any @xmath131type error chain will turn on a syndrome , represented by a pair of points on two ends of the chain , c.f .",
    "( [ sim - shor - errors ] ) .",
    "let us denote the smallest number of links between the points as @xmath431 .",
    "we will restrict to the case where there is a single continuous error chain , which is confined to a row of the lattice .",
    "hence @xmath431 completely defines the syndrome . for the syndrome in ( fig .",
    "[ sim - shor - errors ] ) , one can immediately write the probabilities for the four logical classes @xmath432 ,",
    "@xmath433 , @xmath319 and @xmath434 as : @xmath435^{\\ell}\\left[\\left(1-\\dfrac{p}{2}\\right)\\left(1-\\dfrac{p}{2}\\right)\\right]^{n_{2}-\\ell}}{\\tilde{p}(s ) } \\label{shor - prob - i } \\\\ \\operatorname{\\textsf{prob}}(\\overline{z}|\\vec{s } ) = \\dfrac{\\left[\\dfrac{p}{2}\\left(1 - \\dfrac{p}{2}\\right)\\right]^{n_{2}-\\ell}\\left[\\left(1-\\dfrac{p}{2}\\right)\\left(1-\\dfrac{p}{2}\\right)\\right]^{\\ell}}{\\tilde{p}(s ) } \\label{shor - prob - z } \\\\ \\operatorname{\\textsf{prob}}(\\overline{x}|\\vec{s } ) = \\dfrac{\\left[\\dfrac{p}{2}\\left(1 - \\dfrac{p}{2}\\right)\\right]^{\\ell}\\left[\\left(1-\\dfrac{p}{2}\\right)\\left(1-\\dfrac{p}{2}\\right)\\right]^{n_{2}-\\ell}\\sum_{i=1}^{n_{2}}\\binom{n_{2}}{i}\\left(\\dfrac{p}{2}\\right)^{n_{1 } i}\\left(1-\\dfrac{p}{2}\\right)^{2n_{1}n_{2 } - n_{1}i}}{\\tilde{p}(s ) } \\label{shor - prob - x } \\\\ \\operatorname{\\textsf{prob}}(\\overline{y}|\\vec{s } ) = \\dfrac{\\left[\\dfrac{p}{2}\\left(1 - \\dfrac{p}{2}\\right)\\right]^{n_{2}-\\ell}\\left[\\left(1-\\dfrac{p}{2}\\right)\\left(1-\\dfrac{p}{2}\\right)\\right]^{\\ell}\\sum_{i=1}^{n_{2}}\\binom{n_{2}}{i}\\left(\\dfrac{p}{2}\\right)^{n_{1 } i}\\left(1-\\dfrac{p}{2}\\right)^{2n_{1}n_{2 } - n_{1}i}}{\\tilde{p}(s ) }   \\label{shor - prob - y}\\\\ \\text{where : } \\tilde{p}(\\vec{s } ) = \\left[\\left(\\dfrac{p}{2}\\right)^{\\ell}\\left(1-\\dfrac{p}{2}\\right)^{2n_{2}-\\ell } + \\left(\\dfrac{p}{2}\\right)^{n_{2}-\\ell}\\left(1-\\dfrac{p}{2}\\right)^{2\\ell}\\right]\\sum_{i=0}^{n_{2}}\\binom{n_{2}}{i}\\left(\\dfrac{p}{2}\\right)^{n_{1 } i}\\left(1-\\dfrac{p}{2}\\right)^{2n_{1}n_{2 } - n_{1}i } \\label{shor - prob - synd}\\end{gathered}\\ ] ]    given a constant @xmath315 , we wish to simulate a channel , on the encoded qubit , with @xmath436 such that @xmath437 . this implies a ratio between @xmath438 and @xmath439 equal to @xmath315 , and @xmath431 given by @xmath440^{2\\ell}\\thinspace \\left[\\dfrac{2(1-p)}{p}\\right]^{n_{2 } } \\thickspace \\rightarrow \\thickspace \\ell = \\dfrac{1}{2}\\left(n_{2 } + \\dfrac{\\left|\\log_{2}v\\right|}{1 + \\log_{2}\\frac{1-p}{p}}\\right ) \\label{shor - synd}\\end{gathered}\\ ] ] where in the last simplification , we have assumed @xmath441 . as a consequence of the upper bound on @xmath315 in eq .",
    "( [ eq - max - crossing ] ) it suffices to choose @xmath442 .",
    "we will fix the number of columns in the auxiliary code fig .",
    "( [ sim - shor - code ] ) to @xmath109 .",
    "in addition to the ratio between @xmath443 and @xmath444 , the channel on the encoded qubit also requires that @xmath445 . to achieve this",
    ", we must choose a value of @xmath446 such that the expressions in eqs . and are vanishingly small .",
    "note that the ratio of the combinatorial sums in the the expressions for @xmath447 and @xmath448 can be bounded from above as :    & ( ) ^n_1 + + & ( 2n-1)^-n_1 + [ shor - zy - sums ]    hence it suffices to take @xmath449 for the above ratio to be bounded above by a vanishingly small number .",
    "moreover , as the ratio is an upper bound for @xmath450 and @xmath447 , we will fix the number of rows in the auxiliary code fig .",
    "( [ sim - shor - code ] ) to @xmath109 .    summarizing ,",
    "the qubit is encoded into a shor code on a @xmath451 lattice fig .",
    "( [ fig - toric - code - errors ] ) and the syndrome is chosen as indicated in fig .",
    "( [ sim - shor - errors ] ) with @xmath431 specified by eq .",
    "( [ shor - synd ] ) . as a result",
    "we have a channel on the qubit with @xmath452 , to within exponential error bars .",
    "note that an error free channel is a special case of the above channel , with @xmath453 .",
    "hence , we repeat the same encoding but choose the syndrome on the shor code to be trivial .",
    "in this appendix , we present a proof of lemma .",
    "( [ lemma - large - gap ] ) which states that with a promise gap @xmath454 and on an independent @xmath146 channel , the outputs of @xmath2 and @xmath3 are equivalent .",
    "it suffices to demonstrate that , for any syndrome @xmath172 , the logical class containing the minimum weight error @xmath455 must satisfy eq .",
    "( [ eq - dqmld - gap ] ) with @xmath456 .",
    "this will be true whenever @xmath457 , or in other words @xmath458 suppose that @xmath459 is the minimum weight of an error , consistent with the syndrome @xmath172 .",
    "let us derive lower and upper bounds separately for the numerator and the denominator of eq .",
    "( [ app - gap - cond ] ) , respectively .",
    "every element in the logical class of @xmath460 is constructed by taking the product of the minimum weight error with every stabilizer in @xmath66 . to find the lowest possible value of the probability of the product ,",
    "we suppose that each product results in an element whose weight is the sum of @xmath459 and that of the corresponding stabilizer .",
    "hence we have : @xmath461^{2n}\\sum_{i = 0}^{n}b_{i}\\tilde{p}^{i + a(\\vec{s } ) } \\label{app - gap - lmin}\\end{gathered}\\ ] ] where @xmath309 and @xmath462 is a weight enumerator coefficient of @xmath66 .",
    "similarly , all the errors consistent with the syndrome @xmath172 can be constructed by taking the error of weight @xmath459 and taking its product with every element of the normalizer @xmath73 . for an upper bound to the probability of this product ,",
    "let us suppose that each product has a weight equal to the difference between @xmath459 and the weight of the corresponding stabilizer .",
    "as the weight of the product can not be lower than @xmath459 itself , this gives : @xmath463^{2n}\\left[\\sum_{i=0}^{2a(\\vec{s})}b^{\\perp}_{i}\\tilde{p}^{a(\\vec{s } ) } + \\sum_{i=2a(s)+1}^{n}b^{\\perp}_{i}\\tilde{p}^{i - a(\\vec{s})}\\right ] \\label{app - gap - synd}\\end{gathered}\\ ] ] where @xmath464 is a weight enumerator coefficient of @xmath73 @xcite ."
  ],
  "abstract_text": [
    "<S> in this article we address the computational hardness of optimally decoding a quantum stabilizer code . much like classical linear codes , errors are detected by measuring certain check operators which yield an error syndrome , and the decoding problem consists of determining the most likely recovery given the syndrome . </S>",
    "<S> the corresponding classical problem is known to be @xmath0 @xcite , and a similar decoding problem for quantum codes is also known to be @xmath0 @xcite . however , </S>",
    "<S> this decoding strategy is not optimal in the quantum setting as it does not take into account error degeneracy , which causes distinct errors to have the same effect on the code . here </S>",
    "<S> , we show that optimal decoding of stabilizer codes is computationally much harder than optimal decoding of classical linear codes , it is @xmath1 . </S>"
  ]
}