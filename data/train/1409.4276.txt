{
  "article_text": [
    "if we want to find structure in a collection of data , then we can organize the data into clusters such that the data in the same cluster are similar and the data in different clusters are dissimilar . in general",
    "there is no best criterion to determine the clusters .",
    "one approach is to let the user determine the criterion that suits his or hers needs .",
    "alternatively , we can let the data itself determine `` natural '' clusters .",
    "since it is not likely that natural data determines unequivocal disjoint clusters , it is common to hierarchically cluster the data @xcite .",
    "in cluster analysis there are basically two methods for hierarchical clustering . in the bottom - up approach initially every data item constitutes its own cluster , and pairs of clusters are merged as one moves up the hierarchy . in the top - down approach",
    "the set of all data constitutes the initial cluster , and splits are performed recursively as one moves down the hierarchy .",
    "generally , the merges and splits are determined in a greedy manner .",
    "the main disadvantages of the bottom - up and top - down methods are firstly that they do not scale well because the time complexity is nonlinear in terms of the number of objects , and secondly that they can never undo what was done before .",
    "thus , they are lacking in robustness and uniqueness since the results depend on the earlier decisions .",
    "in contrast , the method which we propose here is robust and gives unique results in the limit .",
    "the results of hierarchical clustering are usually presented in a dendrogram @xcite . for a small number of data items this has the added advantage that the relations among the data can be subjected to visual inspection .",
    "such a dendrogram is a ternary tree where the leaves or external nodes are the basic data elements .",
    "two leaves are connected to an internal node if they are more similar to one another than to the other data elements .",
    "dendrograms are used in computational biology to illustrate the clustering of genes or the evolutionary tree of species . in the latter case",
    "we want a rooted tree to see the order in which groups of species split off from one another .    in biology dendrograms ( phylogenies )",
    "are ubiquitous , and methods to reconstruct a rooted dendrogram from a matrix of pairwise distances abound .",
    "one of these methods is quartet tree reconstruction as explained in section  [ sect.quartet ] .",
    "since the biologists assume there is a single right tree ( the data are `` tree - like '' ) they also assume one quartet topology , of the three possible ones of every quartet , is the correct one . hence their aim is to embed ( definition  [ def.consistent ] ) the largest number of correct quartet topologies in the target tree .",
    "the quartet tree method is described in section  [ sect.quartet ] .",
    "a much - used heuristic called the quartet puzzling problem was proposed in @xcite . there , the quartet topologies are provided with a probability value , and for each quartet the topology with the highest probability is selected ( randomly , if there are more than one ) as the maximum - likelihood optimal topology . the goal is to find a dendrogram that embeds these optimal quartet topologies . in the biological setting it is assumed that the observed genomic data are the result of an evolution in time , and hence can be represented as the leaves of an evolutionary tree . once we obtain a proper probabilistic evolutionary model to quantify the evolutionary relations between the data we can search for the true tree . in a quartet method",
    "one determines the most likely quartet topology for every quartet under the given assumptions , and then searches for a ternary tree ( a dendrogram ) that contains as many of the most likely quartets as possible . by lemma  [ lem.unique ] ,",
    "a dendrogram is uniquely determined by the set of embedded quartet topologies that it contains .",
    "these quartet topologies are said to be consistent with the tree they are embedded in .",
    "thus , if all quartets are embedded in the tree in their most likely topologies , then it is certain that this tree is the optimal matching tree for the given quartet topologies input data . in practice",
    "we often find that the set of given quartet topologies are inconsistent or incomplete .",
    "inconsistency makes it impossible to match the entire input quartet topology set even for the optimal , best matching tree .",
    "incompleteness threatens the uniqueness of the optimal tree solution .",
    "quartet topology inference methods also suffer from practical problems when applied to real world data . in many biological ecosystems",
    "there is reticulation that makes the relations less tree - like and more network - like .",
    "the data can be corrupted and the observational process pollutes and makes errors .",
    "thus , one has to settle for embedding as many most likely quartet topologies as possible , do error correction on the quartet topologies , and so on .",
    "hence in phylogeny , finding the best tree according to an optimization criterion may not be the same thing as inferring the tree underlying the data set ( which we tend to believe , but usually can not prove , to exist ) . for @xmath1 objects",
    ", there are @xmath2 unrooted dendrograms . to find the optimal tree turns out to be np  hard , see section [ sect.hard ] , and hence infeasible in general .",
    "there are two main avenues that have been taken :    \\(i ) incrementally grow the tree in random order by stepwise addition of objects in the locally optimal way , repeat this for different object orders , and add agreement values on the branches , like dnaml @xcite , or quartet puzzling @xcite . these methods",
    "are fast , but suffer from the usual bottom - up problem : a wrong decision early on can not be corrected later . another possible problem is as follows .",
    "suppose we have just 32 items . with quartet puzzling we",
    "incrementally construct a quartet tree from a randomly ordered list of elements , where each next element is optimally connected to the current tree comprising the previous elements .",
    "we repeat this process for , say , 1000 permutations .",
    "subsequently , we look for percentage agreement of subtrees common to all such trees . but the number of permutations is about @xmath3 , so why would the incrementally locally optimal trees derived from 1000 random permutations be a representative sample from which we can conclude anything about the globally optimal tree ?",
    "\\(ii ) approximate the global optimum monotonically or compute it , using a geometric algorithm or dynamic programming @xcite , linear programming @xcite , or semi - definite programming @xcite .",
    "these latter methods , other methods , as well as methods related to the minimum quartet consistency ( mqc ) problem ( definition  [ def.mqc ] ) , can not handle more than 1530 objects @xcite directly , even while using farms of desktops . to handle more objects one needs to construct a supertree from the constituent quartet trees for subsets of the original data sets , @xcite , as in @xcite , incurring again the bottom - up problem of being unable to correct earlier decisions .",
    "the minimum quartet tree cost ( mqtc ) problem is proposed in section  [ sect.mqtc ] ( definition  [ def.mqtc ] ) .",
    "it is a quartet method for general hierarchical clustering of nontree - like data in non - biological areas that is also applicable to phylogeny construction in biology .",
    "in contrast to the mqc problem , it is used for general hierarchical clustering .",
    "it does not suppose that for every quartet a single quartet topology is the correct one .",
    "instead , we aim at optimizing the summed quartet topology costs .",
    "if we determine the quartet topology costs from a measure of distance , then the data themselves are not required : all that is used is a distance matrix . to solve it we present a computational heuristic that is a monte carlo method , as opposed to deterministic methods like local search , section  [ sect.mc ] .",
    "our method is based on a fast randomized hill - climbing heuristic of a new global optimization criterion .",
    "improvements that dramatically decrease the running speed are given in section  [ sect.previous ] .",
    "the algorithm does not address the problem of how to obtain the quartet topology weights from sequence data @xcite , but takes as input the weights of all quartet topologies and executes the step of how to reconstruct the hierarchical clustering from there .",
    "alternatively , we can start from the distance matrix and construct the quartet topology cost as the sum of the distances between the siblings , dramatically speeding up the heuristic as in section  [ sect.previous ] . since the method globally optimizes the tree it does not suffer from the the disadvantage treated in item ( i ) of section  [ sect.relwork ] .",
    "the running time is much faster than that of the methods treated in item ( ii ) of section  [ sect.relwork ] .",
    "it can also handle much larger trees of at least 300 objects .",
    "the algorithm presented produces a sequence of candidate trees with the objects as leaves .",
    "each such candidate tree is scored as to how well the tree represents the information in the weighted quartet topologies on a scale of 0 to 1 . if a new candidate scores better than the previous best candidate , the former becomes the new best candidate .",
    "the globally optimal tree has the highest score , so the algorithm monotonically approximates the global optimum .",
    "the algorithm terminates on a given termination condition .",
    "in contrast to the general case of bottom - up and top - down methods , the new quartet method can undo what was done before and eventually reaches a global optimum .",
    "it does not assume that the data are tree like ( and hence that there is a single `` right tree '' ) , but simply hierarchically clusters data items in every domain .",
    "the scalability is improved by the reduction of the running time from @xmath4 per generation in the original version ( with an implementation of at least @xmath5 ) to @xmath6 per generation in the current optimised version in section  [ sect.previous ] and implemented in complearn @xcite from version 1.1.3 onward .",
    "( here @xmath1 is the number of data items . )",
    "recently , in @xcite several alternative approaches to the here - introduced solution heuristic are proposed .",
    "some of the newly introduced heuristics perform better both in results and running times than our old implementation",
    ". however , even the best heuristic in @xcite appears to have a slower running time for natural data ( with @xmath7 typically over 50% ) than the current version of our algorithm ( complearn version 1.1.3 or later . )    in section  [ sect.ncd ] we treat compression - based distances and previous experiments with the mqtc heuristic using the complearn software . in section  [ sect.splitstree ] compare performance and running time of mqtc heuristic in complearn versions 0.9.7 and 1.1.3 ( before and after the speedup in section  [ sect.previous ] ) with those of other modern methods .",
    "these are upgma , bionj , and nj , as implemented in the splitstree version 4.6 .",
    "we consider artificial and natural data sets .",
    "note that biological packages like splitstree assume tree - like data and are not designed to deal with arbitrary hierarchical clustering like the mqtc heuristic .",
    "the artificial and natural data sets we use are tree structured .",
    "thus , the comparison is unfair to the new mqtc heuristic .",
    "the mqtc problem and heuristic were originally proposed in @xcite . there , the main focus is on compression - based distances , but to visually present the results in tree form we focused on a quartet method for tree reconstruction .",
    "we also believed such a quartet tree method to be more sensitive and objective than other methods .",
    "the available quartet tree methods were too slow when they were exact or global , and too inaccurate or uncertain when they were statistical incremental .",
    "they also addressed only biological phylogeny .",
    "hence , we developed a new approach aimed at general hierarchical clustering .",
    "this approach is not a top - down or bottom - up method that can be caught in a local optimum . in the above references the approach is described as an auxiliary notion in one or two pages .",
    "it is a major new method to do general hierarchical clustering . here",
    "we give the first complete treatment .",
    "some details of the mqtc problem , its computational hardness , and our heuristic for its solution , are as follows .",
    "the goal is to use a quartet method to obtain high - quality hierarchical clustering of data from arbitrary ( possibly heterogeneous ) domains , not necessarily only biological phylogeny data .",
    "traditional quartet methods derive from biology .",
    "there , one assumes that there exists a true evolutionary tree , and the aim is to embed as many optimal quartet topologies as is possible . in the new method for general hierarchical clustering , for @xmath1 objects we consider all @xmath0 possible quartet topologies , each with a given weight .",
    "our goal is to find the tree such that the summed weights of the embedded quartet topologies is optimal .",
    "we develop a randomized hill - climbing heuristic that monotonically approximates this optimum , and a figure of merit ( definition  [ def.st ] ) that quantifies the quality of the best current candidate tree on a linear scale .",
    "we give an explicit proof of np - hardness ( theorem  [ theo.nphard ] ) of the mqtc problem .",
    "moreover , if a polynomial time approximation scheme ( ptas ) ( definition  [ def.ptas ] ) for the problem exists , then p = np ( theorem  [ theo.ptas ] ) . given the np  hardness of phylogeny reconstruction in general relative to most commonly - used criteria , as well as the non - trivial algorithmic and run - time complexity of all previously - proposed quartet - based heuristics , such a simple heuristic is potentially of great use .",
    "the data samples we used , here or in referred - to previous work , were obtained from standard data bases accessible on the internet , generated by ourselves , or obtained from research groups in the field of investigation .",
    "contrary to biological phylogeny methods , we do not have agreement values on the branches : we generate the best tree possible , globally balancing all requirements .",
    "the quality of the results depends on how well the hierarchical tree represents the information in the set of weighted quartet topologies .",
    "the mqtc clustering heuristic generates a tree together with a goodness score .",
    "the latter is called standardized benefit score or @xmath8 value in the sequel ( definition  [ def.st ] ) . in certain natural data sets , such as h5n1 genomic sequences ,",
    "consistently high @xmath8 values are returned even for large sets of objects of 100 or more nodes , @xcite . in other nontree - structured natural data sets",
    "however , as treated in @xcite , the @xmath8 value deteriorates more and more with increasing number of elements being put in the same tree .",
    "the reason is that with increasing size of a nontree - structured natural data set the projection of the information in the cost function into a ternary tree may get increasingly distorted .",
    "this is because the underlying structure in the data is incommensurate with any tree shape whatsoever . in this way",
    ", larger structures may induce additional `` stress '' in the mapping that is visible as lower and lower @xmath8 scores .",
    "experience shows that in nontree - structured data the mqtc hierarchical clustering method seems to work best for small sets of data , up to 25 items , and to deteriorate for some ( but by no means all ) larger sets of , say , 40 items or more .",
    "this deterioration is directly observable in the @xmath8 scores and degrades solutions in two common forms .",
    "the first form is tree instability when different or very different solutions are returned on successive runs .",
    "the second form is tree `` overlinearization '' when some data sets produce caterpillar - like structures only or predominantly .    in case",
    "a large set of objects , say 100 objects , clusters with high @xmath8 value this is evidence that the data are of themselves tree - like , and the quartet - topology weights , or underlying distances , truely represent to similarity relationships between the data .",
    "generating trees from the same weighted quartet topologies many times resulted in the same tree in case of high @xmath8 value , or a similar tree in case of moderately high @xmath8 value .",
    "this happened for every weighting we used , even though the heuristic is randomized .",
    "that is , there is only one way to be right , but increasingly many ways to be increasingly wrong .",
    "given a set @xmath9 of @xmath1 objects , we consider every subset of four elements ( objects ) from our set of @xmath1 elements ; there are @xmath10 such sets .",
    "such a set is called a _",
    "quartet_. from each quartet @xmath11 we construct a tree of arity 3 , which implies that the tree consists of two subtrees of two leaves each .",
    "let us call such a tree a _ quartet topology_. we denote a partition @xmath12 of @xmath11 by @xmath13 .",
    "there are three possibilities to partition @xmath11 into two subsets of two elements each : ( i ) @xmath13 , ( ii ) @xmath14 , and ( iii ) @xmath15 . in terms of the tree topologies : a vertical bar divides the two pairs of leaf nodes into two disjoint subtrees ( figure  [ figquart ] ) .    the set of @xmath16 quartet topologies induced by @xmath9 is denoted by @xmath17 .",
    "consider the class @xmath18 of undirected trees of arity 3 with @xmath19 leaves ( external nodes of degree 1 ) , labeled with the elements of @xmath9 .",
    "such trees have @xmath1 leaves and @xmath20 internal nodes ( of degree 3 ) .",
    "[ def.consistent ] for tree @xmath21 and four leaf labels @xmath22 , we say @xmath23 is _ consistent _ with @xmath13 , or the quartet topology @xmath13 is _ embedded _ in @xmath23 , if and only if the path from @xmath24 to @xmath25 does not cross the path from @xmath26 to @xmath27 .",
    "it is easy to see that precisely one of the three possible quartet topologies of a quartet of four leaves is consistent for a given tree from @xmath18 .",
    "therefore a tree from @xmath18 contains precisely @xmath10 different quartet topologies .",
    "commonly the goal in the quartet method is to find ( or approximate as closely as possible ) the tree that embeds the maximal number of consistent ( possibly weighted ) quartet topologies from a given set @xmath28 of quartet topologies",
    "@xcite ( figure  [ figexquart ] ) .",
    "a _ weight function _",
    "@xmath29 , with @xmath30 the set of real numbers determines the weights .",
    "the unweighted case is when @xmath31 for all @xmath32 .",
    "[ def.mqc ] the ( weighted ) _ maximum quartet consistency ( mqc ) optimization _ problem is defined as follows :    given : @xmath9 , @xmath33 , and @xmath34 .",
    "question : find @xmath35 and @xmath36 is consistent with @xmath37 .",
    "the rationale for the mqc optimization problem reflects the genesis of the method in biological phylogeny . under the assumption that",
    "biological species developed by evolution in time , and @xmath9 is a subset of the now existing species , there is a phylogeny @xmath38 that represents that evolution .",
    "the set of quartet topologies consistent with this tree has one quartet topology per quartet which is the true one .",
    "the quartet topologies in @xmath39 are the ones which we assume to be among the true quartet topologies , and weights are used to express our relative certainty about this assumption concerning the individual quartet topologies in @xmath39 .",
    "however , the data may be corrupted so that this assumption is no longer true . in the general case of hierarchical clustering",
    "we do not even have a priori knowledge that certain quartet topologies are objectively true and must be embedded .",
    "rather , we are in the position that we can somehow assign a relative importance to the different quartet topologies .",
    "our task is then to balance the importance of embedding different quartet topologies against one another , leading to a tree that represents the concerns as well as possible .",
    "we start from a cost - assignment to the quartet topologies : given a set @xmath9 of @xmath1 objects , let @xmath17 be the set of quartet topologies , and let @xmath40 be a _",
    "cost function _ assigning a real valued cost @xmath41 to each quartet @xmath42 .",
    "[ def.costs ] the _ cost _ @xmath43 of a tree @xmath23 with a set @xmath9 of leaves is defined by @xmath44 is consistent with @xmath45the sum of the costs of all its consistent quartet topologies .",
    "[ def.mqtc ] given @xmath9 and @xmath46 , the _ minimum quartet tree cost ( mqtc ) _ is @xmath47 @xmath23 is a tree with the set @xmath9 labeling its leaves@xmath48 .",
    "we normalize the problem of finding the mqtc as follows : consider the list of all possible quartet topologies for all four - tuples of labels under consideration . for each group of three possible quartet topologies for a given set of four labels @xmath49 ,",
    "calculate a best ( minimal ) cost @xmath50 , and a worst ( maximal ) cost @xmath51 .",
    "summing all best quartet topologies yields the best ( minimal ) cost @xmath52 .",
    "conversely , summing all worst quartet topologies yields the worst ( maximal ) cost @xmath53 .",
    "for some cost functions , these minimal and maximal values can not be attained by actual trees ; however , the score @xmath43 of every tree @xmath23 will lie between these two values . in order to be able to compare the scores of quartet trees for different numbers of objects in a uniform way , we now rescale the score linearly such that the worst score maps to 0 , and the best score maps to 1 :    [ def.st ] the _ normalized tree benefit score _",
    "@xmath8 is defined by @xmath54 .",
    "our goal is to find a full tree with a maximum value of @xmath8 , which is to say , the lowest total cost .",
    "now we can rephrase the mqtc problem in such a way that solutions of instances of different sizes can be uniformly compared in terms of relative quality :    definition of the _ mqtc optimization problem _ :    given : @xmath9 and @xmath46 .",
    "question : find a tree @xmath55 with @xmath56 @xmath23 is a tree with the set @xmath9 labeling its leaves@xmath48 .",
    "definition of the _ mqtc decision problem _ :    given : @xmath9 and @xmath46 and a rational number @xmath57 .",
    "question : is there a binary tree @xmath23 with the set @xmath9 labeling its leaves and @xmath58 .",
    "the hardness of quartet puzzling is informally mentioned in the literature @xcite , but we provide explicit proofs . to express the notion of computational difficulty one uses the notion of `` nondeterministic polynomial time ( np ) '' .",
    "if a problem concerning @xmath1 objects is np  hard this means that the best known algorithm for this ( and a wide class of significant problems ) requires computation time at least exponential in @xmath1 .",
    "that is , it is infeasible in practice .",
    "let @xmath9 be a set of @xmath1 objects , let @xmath23 be a tree of which the @xmath1 leaves are labeled by the objects , and let @xmath17 be the set of quartet topologies and @xmath59 be the set of quartet topologies embedded in @xmath23 .",
    "the _ mqc decision problem _ is the following :    given : a set of quartet topologies @xmath28 , and an integer @xmath60 .",
    "decide : is there a binary tree @xmath23 such that @xmath61 .",
    "in @xcite it is shown that the mqc decision problem is np  hard .",
    "sometimes this problem is called the _",
    "incomplete _ mqc decision problem .",
    "the less general _ complete mqc decision problem _ requires @xmath33 to contain precisely one quartet topology per quartet ( that is , per each subset of @xmath62 elements out of the @xmath1 elements ) , and is proved to be np  hard as well in @xcite .",
    "[ theo.nphard ] ( i ) the mqtc decision problem is np  hard .",
    "\\(ii ) the mqtc optimization problem is np  hard .",
    "\\(i ) by reduction from the mqc decision problem . for every mqc decision problem",
    "one can define a corresponding mqtc decision problem that has the same solution : give the quartet topologies in @xmath33 cost 0 and the ones in @xmath63 cost 1 .",
    "consider the mqtc decision problem : is there a tree @xmath23 with the set @xmath9 labeling its leaves such that @xmath64 ? an alternative equivalent formulation is : is there a tree @xmath23 with the set @xmath9 labeling its leaves such that @xmath65 note that every tree @xmath23 with the set @xmath9 labeling its leaves has precisely one out of the three quartet topologies of every of the @xmath10 quartets embedded in it .",
    "therefore , the cost @xmath66 . if the answer to the above question is affirmative , then the number of quartet topologies in @xmath33 that are embedded in the tree exceeds @xmath60 ; if it is not then there is no tree such that the number of quartet topologies in @xmath33 embedded in it exceeds @xmath60 . this way the mqc decision problem can be reduced to the mqtc decision problem , which shows also",
    "the latter to be np  hard .",
    "\\(ii ) an algorithm for the mqtc optimization problem yields an algorithm for the mqtc decision problem with the same running time up to a polynomial additive term : if the answer to the mqtc optimization problem is a tree @xmath55 , then we determine @xmath67 in @xmath68 time .",
    "let @xmath60 be the bound of the mqtc decision problem .",
    "if @xmath69 then the answer to the decision problem is `` yes , '' otherwise `` no . ''",
    "the proof shows that negative complexity results for mqc carry over to mqtc .",
    "[ def.ptas ] a _ polynomial time approximation scheme ( ptas ) _ is a polynomial time approximation algorithm for an optimization problem with a performance guaranty .",
    "it takes an instance of an optimization problem and a parameter @xmath70 , and produces a solution of an optimization problem that is optimal up to an @xmath71 fraction .",
    "for example , for the mqc optimization problem as defined above , a ptas would produce a tree embedding at least @xmath72 quartets from @xmath33 .",
    "the running time of a ptas is required to be polynomial in the size of the problem concerned for every fixed @xmath71 , but can be different for different @xmath71 . in @xcite a ptas for a restricted version of the mqc optimization problem , namely the `` complete '' mqc optimization problem defined above , is exhibited .",
    "this is a theoretical approximation that would run in something like @xmath73 . for general",
    "( what we have called `` incomplete '' ) mqc optimization it is shown that even such a theoretical algorithm does not exist , unless p = np .",
    "[ theo.ptas ] if a ptas for the mqtc optimization problem exists , then p = np .",
    "the reduction in the proof of theorem  [ theo.nphard ] yields a restricted version of the mqtc optimization problem that is equivalent to the mqc optimization problem .",
    "there is an isomorphism between every partial solution , including the optimal solutions involved : for every tree @xmath23 with @xmath9 labeling the leaves , the mqtc cost @xmath66 where @xmath74 is the set of mqc consistent quartets .",
    "the reduction is also poly - time approximation preserving , since the reduction gives a linear time computable isomorphic version of the mqtc problem instance for each mqc problem instance . since @xcite has shown that a ptas for the mqc optimization problem does not exist unless p = np , it also holds for this restricted version of the mqtc optimization problem that a ptas does not exist unless p = np , the full mqtc optimization problem is at least as hard to approximate by a ptas , from which the theorem follows .",
    "is it possible that the best @xmath8 value is always one , that is , there always exists a tree that embeds all quartets at minimum cost quartet topologies ? consider the case @xmath75 .",
    "since there is only one quartet , we can set @xmath55 equal to the minimum cost quartet topology , and have @xmath76 .",
    "a priori we can not exclude the possibility that for every @xmath9 and @xmath46 there always is a tree @xmath55 with @xmath76 . in that case , the mqtc optimization problem reduces to finding that @xmath55 .",
    "however , the situation turns out to be more complex .",
    "note first that the set of quartet topologies uniquely determines a tree in @xmath18 , @xcite .",
    "[ lem.unique ] let @xmath77 be different labeled trees in @xmath18 and let @xmath78 be the sets of embedded quartet topologies , respectively .",
    "then , @xmath79 .",
    "a _ complete set _ of quartet topologies on @xmath9 is a set containing precisely one quartet topology per quartet .",
    "there are @xmath80 such combinations , but only @xmath81 labeled undirected graphs on @xmath1 nodes ( and therefore @xmath82 ) .",
    "hence , not every complete set of quartet topologies corresponds to a tree in @xmath18 .",
    "this already suggests that we can weight the quartet topologies in such a way that the full combination of all quartet topologies at minimal costs does not correspond to a tree in @xmath18 , and hence @xmath83 for @xmath84 realizing the mqtc optimum . for an explicit example of this",
    ", we use that a complete set corresponding to a tree in @xmath18 must satisfy certain transitivity properties , @xcite :    [ cl1 ] let @xmath23 be a tree in the considered class with leaves @xmath9 , @xmath17 the set of quartet topologies and @xmath85",
    ". then @xmath86 uniquely determines @xmath23 if    \\(i ) @xmath86 contains precisely one quartet topology for every quartet , and    \\(ii ) for all @xmath87 , if @xmath88 then @xmath89 , as well as if @xmath90 then @xmath91 .",
    "there are @xmath9 ( with @xmath92 ) and a cost function @xmath46 such that , for every @xmath21 , @xmath8 does not exceed @xmath93 .",
    "consider @xmath94 and @xmath95 , @xmath96 , and @xmath97 for all remaining quartet topologies @xmath98 .",
    "we see that @xmath99 , @xmath100 .",
    "the tree @xmath101 has cost @xmath102 , since it embeds quartet topologies @xmath103 .",
    "we show that @xmath55 achieves the mqtc optimum .",
    "_ case 1 : _ if a tree @xmath104 embeds @xmath36 , then it must by item ( i ) of lemma  [ cl1 ] also embed a quartet topology containing @xmath105 that has cost 1 .    _",
    "case 2 : _ if a tree @xmath104 embeds @xmath106 and @xmath107 , then it must by item ( ii ) of the lemma  [ cl1 ] also embed @xmath108 , and hence have cost @xmath109 .",
    "similarly , all other remaining cases of embedding a combination of a quartet topology not containing @xmath105 of 0 cost with a quartet topology containing @xmath105 of 0 cost in @xmath23 , imply an embedded quartet topology of cost 1 in @xmath23 .",
    "altogether , the mqtc optimization problem is infeasible in practice , and natural data can have an optimal @xmath110 .",
    "in fact , it follows from the above analysis that to determine the optimal @xmath8 in general is np  hard .",
    "if the deterministic approximation of this optimum to within a given precision can be done in polynomial time , then that implies the generally disbelieved conjecture p = np .",
    "therefore , any practical approach to obtain or approximate the mqtc optimum requires some type of heuristics , for example monte carlo methods .",
    "our algorithm is a monte carlo heuristic , essentially randomized hill - climbing where undirected trees evolve in a random walk driven by a prescribed fitness function .",
    "we are given a set @xmath9 of @xmath1 objects and a cost function @xmath46 .",
    "we define a _ simple mutation _ on a labeled undirected ternary tree as one of the following possible transformations :    1 .   a _ leaf interchange _ : randomly choose two leaves that are not siblings and interchange them .",
    "2 .   a _ subtree interchange _ : randomly choose two internal nodes @xmath111 , or an internal node @xmath24 and a leaf @xmath26 , such that the shortest path length between @xmath24 and @xmath26 is at least three steps .",
    "that is , @xmath112 is a shortest path in the tree .",
    "disconnect @xmath24 ( and the subtree rooted at @xmath24 disjoint from the path ) from @xmath27 , and disconnect @xmath26 ( and the subtree rooted at @xmath26 disjoint from the path if @xmath26 is not a leaf ) from @xmath105 .",
    "attach @xmath24 and its subtree to @xmath105 , and @xmath26 ( and its subtree if @xmath26 is not a leaf ) to @xmath27 .",
    "3 .   a _ subtree transfer _ , whereby a randomly chosen subtree ( possibly a leaf ) is detached and reattached in another place , maintaining arity invariants .",
    "each of these simple mutations keeps the number of leaf nodes and internal nodes in the tree invariant ; only the structure and placements change .",
    "clearly , mutations 1 ) and 2 ) can be together replaced by the single mutation below .",
    "but in the implementation they are separated as above .    * a _",
    "subtree and/or leaf interchange _ , which consists of randomly choosing two nodes ( either node or both can be leaves or internal nodes ) , say @xmath111 , such that the shortest path length between @xmath24 and @xmath26 is at least three steps .",
    "that is , @xmath112 is a shortest path in the tree .",
    "disconnect @xmath24 ( and the subtree rooted at @xmath24 disjoint from the path ) from @xmath27 , and disconnect @xmath26 ( and the subtree rooted at @xmath26 disjoint from the path ) from @xmath105 .",
    "attach @xmath24 and its subtree to @xmath105 , and @xmath26 and its subtree to @xmath27 .",
    "a sequence of these mutations suffices to go from every ternary tree with @xmath1 labeled leaves and @xmath20 unlabeled internal nodes to any other ternary tree with @xmath1 labeled leaves and @xmath20 unlabeled internal nodes , theorem  [ theo.mutations ] in appendix  [ sect.mutations ] .",
    "@xmath60-mutation _ is a sequence of @xmath60 simple mutations .",
    "thus , a simple mutation is a 1-mutation .",
    "the algorithm is given in figure  [ fig.alg ] .",
    "we comment on the different steps :    _ comment on step 2 : _ a tree is consistent with precisely @xmath113 of all quartet topologies , one for every quartet .",
    "a random tree is likely to be consistent with about @xmath113 of the best quartet topologies  but because of dependencies this figure is not precise .    *",
    "step 1 : * first , a random tree @xmath21 with @xmath114 nodes is created , consisting of @xmath1 leaf nodes ( with 1 connecting edge ) labeled with the names of the data items , and @xmath20 non - leaf or _",
    "internal _ nodes . when we need to refer to specific internal nodes , we label them with the lowercase letter `` k '' followed by a unique integer identifier .",
    "each internal node has exactly three connecting edges .",
    "* step 2 : * for this tree @xmath23 , we calculate the summed total cost of all embedded quartet topologies , and compute @xmath8 .",
    "* step 3 : * the _ currently best known tree _",
    "variable @xmath55 is set to @xmath23 : @xmath115 .",
    "* step 4 : * draw a number @xmath60 with probability @xmath116 and @xmath117 for @xmath118 , where @xmath119 .",
    "by @xcite it is known that @xmath120 .",
    "* step 5 : * compose a @xmath60-mutation by , for each of the constituent sequence of @xmath60 simple mutations , choosing one of the three types listed above with equal probability .",
    "for each of these simple mutations , we uniformly at random select leaves or internal nodes , as appropriate .",
    "* step 6 : * in order to search for a better tree , we simply apply the @xmath60-mutation constructed in _ step 5 _ to @xmath55 to obtain @xmath23 , and then calculate @xmath8 .",
    "if @xmath121 , then replace the current candidate in @xmath55 by @xmath23 ( as the new best tree ) : @xmath115 .",
    "* step 7 : * if @xmath122 or a _ termination condition _ to be discussed below holds , then output the tree in @xmath55 as the best tree and halt .",
    "otherwise , go to _ step 4_.    _ comment on step 3 : _ this @xmath55 is used as the basis for further searching .",
    "_ comment on step 4 : _ this number @xmath60 is the number of simple mutations that we will constitute the next @xmath60-mutation .",
    "the probability mass function @xmath123 for @xmath124 is @xmath125 with @xmath126 . in practice",
    ", we used a `` shifted '' fat tail probability mass function @xmath127 for @xmath128 .",
    "_ comment on step 5 : _ notice that trees which are close to the original tree ( in terms of number of simple mutation steps in between ) are examined often , while trees that are far away from the original tree will eventually be examined , but not very frequently .",
    "we have chosen @xmath123 to be a `` fat - tail '' distribution , with one of the fattest tails possible , to concentrate maximal probability also on the larger values of @xmath60 .",
    "that way , the likelihood of getting trapped in local minima is minimized .",
    "in contrast , if one would choose an exponential scheme , like @xmath129 , then the larger values of @xmath60 would arise so scarcely that practically speaking the distinction between being absolutely trapped in a local optimum , and the very low escape probability , would be insignificant . considering positive - valued probability mass functions",
    "@xmath130 $ ] , with @xmath131 the natural numbers , as we do here , we note that such a function ( i ) @xmath132 , and ( ii ) @xmath133 .",
    "thus , every function of the natural numbers that has strictly positive values and converges can be normalized to such a probability mass function . for smooth analytic functions that can be expressed as a series of fractional powers and logarithms , the borderline between converging and diverging is as follows : @xmath134 , @xmath135 and so on diverge , while @xmath136,@xmath137 and so on converge .",
    "therefore , the maximal fat tail of a `` smooth '' function @xmath138 with @xmath139 arises for functions at the edge of the convergence family .",
    "the probability mass function @xmath140 is as close to the edge as is reasonable .",
    "let us see what this means for our algorithm using the chosen probability mass function @xmath123 where we take @xmath141 for convenience .    for @xmath7 we can change any tree in @xmath18 to any other tree in @xmath18 with a squence of at most @xmath142 simple mutations ( theorem  [ theo.mutations ] in appendix  [ sect.mutations ] ) .",
    "the probability of such a complex mutation occurring is quite large with such a fat tail : @xmath143 .",
    "the expectation is about 7 times in 100,000 generations .",
    "the @xmath144 is a crude upper bound ; we believe that the real value is more likely to be about @xmath1 simple mutations .",
    "the probability of a sequence of @xmath1 simple mutations occurring is @xmath145 .",
    "the expectation increases to about 63 times in 100.000 generations .",
    "if we can already get out of a local minimum with only a 16-mutation , then this occurs with probability is @xmath146 , so it is expected about 195 times in 100.000 generations , and with an 8-mutation the probability is @xmath147 , so the expectation is more than 694 times in 100.000 generations .",
    "the main problem with hill - climbing algorithms is that they can get stuck in a local optimum .",
    "however , by randomly selecting a sequence of simple mutations , longer sequences with decreasing probability , we essentially run a of simulated annealing @xcite algorithm at random temperatures .",
    "since there is a nonzero probability for every tree in @xmath18 being transformed into every other tree in @xmath18 , there is zero probability that we get trapped forever in a local optimum that is not a global optimum .",
    "that is , trivially :    \\(i ) the algorithm approximates the mqtc optimal solution monotonically in each run .",
    "\\(ii ) the algorithm without termination condition solves the mqtc optimization problem eventually with probability 1 ( but we do not in general know when the optimum has been reached in a particular run ) .",
    "the main question therefore is the convergence speed of the algorithm on natural data in terms of @xmath8 value , and a termination criterion to terminate the algorithm when we have an acceptable approximation .",
    "practically , from figure  [ figprogress ] it appears that improvement in terms of @xmath8 eventually gets less and less ( while improvement is still possible ) in terms of the expended computation time .",
    "theoretically , this is explained by theorem  [ theo.ptas ] which tells us that there is no polynomial - time approximation scheme for mqtc optimization .",
    "whether our approximation scheme is expected polynomial time seems to require proving that the involved metropolis chain is rapidly mixing @xcite , a notoriously hard and generally unsolved problem .",
    "however , in our experiments there is unanimous evidence that for the natural data and the cost function we have used , convergence to close to the optimal value is always fast .    the running time is determined as follows .",
    "we have to determine the cost of @xmath10 quartets to determine each @xmath8 value in each generation .",
    "hence , trivially ,    the algorithm in figure  [ fig.alg ] runs in time @xmath148 per generation where @xmath1 is the number of objects .",
    "( the implementation uses even @xmath149 time . )    the input to the algorithm in figure  [ fig.alg ] is the quartet topology costs .",
    "if one constructs the quartet - topology costs from more basic quantities , such as the cost of @xmath150 equals the sum of the distances @xmath151 for some distance measure @xmath152 , then one can use the additional structure thus supplied to speed up the algorithm as in section  [ sect.previous ] . then , while the original implementation of the algorithm uses as much as @xmath149 time per generation it is sped up to @xmath6 time per generation , lemma  [ lem.previous ] , and we were able to analyze a 260-node tree in about 3 hours cpu time reaching @xmath153 .    in experiments we found that for the same data set different runs consistently showed the same behavior , for example figure  [ figprogress ] for a 60-object computation .",
    "there the @xmath8 value leveled off at about 70,000 examined trees , and the termination condition was `` no improvement in 5,000 trees . '' different random runs of the algorithm nearly always gave the same behavior , returning a tree with the same @xmath8 value , albeit a different tree in most cases since here @xmath154 , a relatively low value .",
    "that is , there are many ways to find a tree of optimal @xmath8 value if it is low , and apparently the algorithm never got trapped in a lower local optimum . for problems with high @xmath8 value",
    "the algorithm consistently returned the same tree .",
    "note that if a tree is ever found such that @xmath155 , then we can stop because we can be certain that this tree is optimal , as no tree could have a lower cost .",
    "in fact , this perfect tree result is achieved in our artificial tree reconstruction experiment ( section  [ sect.artificial ] ) reliably for 32-node trees in a few seconds using the improvement of section  [ sect.previous ] . for real - world data",
    ", @xmath8 reaches a maximum somewhat less than @xmath156 .",
    "this presumably reflects distortion of the information in the cost function data by the best possible tree representation , or indicates getting stuck in a local optimum .",
    "alternatively , the search space is too large to find the global optimum .",
    "on typical problems of up to 40 objects this tree - search gives a tree with @xmath157 within half an hour ( fot the unimproved version ) and a few seconds with the improvement of section  [ sect.previous ] . for large numbers of objects , tree scoring itself",
    "can be slow especially without the improvements of section  [ sect.previous ] .",
    "current single computers can score a tree of this size with the unimproved algorithm in about a minute . for larger experiments",
    ", we used the c program called partree ( part of the complearn package @xcite ) with mpi ( message passing interface , a common standard used on massively parallel computers ) on a cluster of workstations in parallel to find trees more rapidly .",
    "we can consider the graph mapping the achieved @xmath8 score as a function of the number of trees examined .",
    "progress occurs typically in a sigmoidal fashion towards a maximal value @xmath158 , figure  [ figprogress ] .",
    "the _ termination condition _ is of two types and which type is used determines the number of objects we can handle .",
    "_ simple termination condition : _ we simply run the algorithm until it seems no better trees are being found in a reasonable amount of time . here we typically terminate if no improvement in @xmath8 value is achieved within 100,000 examined trees .",
    "this criterion is simple enough to enable us to hierarchically cluster data sets up to 80 objects in a few hours even without the improvement in section  [ sect.previous ] and at least up to 300 objects with the improvement .",
    "this is way above the 1530 objects in the previous exact ( non - incremental ) methods ( see introduction ) .",
    "_ agreement termination condition : _ in this more sophisticated method we select a number @xmath159 of runs , and we run @xmath160 invocations of the algorithm in parallel . each time an @xmath8 value in run @xmath161 is increased in this process it is compared with the @xmath8 values in all the other runs . if they are all equal , then the candidate trees of the runs are compared .",
    "this can be done by simply comparing the ordered lists of embedded quartet topologies , in some standard order .",
    "this works since the set of embedded quartet topologies uniquely determines the quartet tree by @xcite .",
    "if the @xmath160 candidate trees are identical , then terminate with this quartet tree as output , otherwise continue the algorithm .",
    "this termination condition takes ( for the same number of steps per run ) about @xmath160 times as long as the simple termination condition .",
    "but the termination condition is much more rigorous , provided we choose @xmath160 appropriate to the number @xmath1 of objects being clustered .",
    "since all the runs are randomized independently at startup , it seems very unlikely that with natural data all of them get stuck in the same local optimum with the same quartet tree instance , provided the number @xmath1 of objects being clustered is not too small . for @xmath162 and",
    "the number of invocations @xmath163 , there is a reasonable probability that the two different runs by chance hit the same tree in the same step .",
    "this phenomenon leads us to require more than two successive runs with exact agreement before we may reach a final answer for small @xmath1 . in the case of @xmath164 ,",
    "we require 6 dovetailed runs to agree precisely before termination . for @xmath165 , @xmath166 . for @xmath167 , @xmath168 . for @xmath169 , @xmath170 . for all other @xmath171 , @xmath172 .",
    "this yields a reasonable tradeoff between speed and accuracy .",
    "these specifications of @xmath160-values relative to @xmath1 are partially common sense , partially empirically derived .",
    "it is clear that there is only one tree with @xmath173 ( if that is possible for the data ) , and it is straightforward that random trees ( the majority of all possible quartet trees ) have @xmath174 .",
    "this gives evidence that the number of quartet trees with large @xmath8 values is much smaller than the number of trees with small @xmath8 values .",
    "it is furthermore evident that the precise relation depends on the data set involved , and hence can not be expressed by a general formula without further assumptions on the data .",
    "however , we can safely state that small data sets , of say @xmath175 objects , that in our experience often lead to @xmath8 values close to 1 and a single resulting tree have very few quartet trees realizing the optimal @xmath8 value . on the other hand , those large sets of 60 or more objects that contain some inconsistency and",
    "thus lead to a low final @xmath8 value also tend to exhibit more variation in the resulting trees .",
    "this suggests that in the agreement termination method each run will get stuck in a different quartet tree of a similar @xmath8 value , so termination with the same tree is not possible .",
    "experiments show that with the rigorous agreement termination we can handle sets of up to 40 objects , and with the simple termination up to at least 80200 objects on a single computer with varying degrees of quality and consistency depending on the data involved , even without the improvements of section  [ sect.previous ] .",
    "basically the algorithm evaluates all quartet topologies in each generated tree , which leads to an @xmath4 algorithm per generation or @xmath6 per generation for the improved version in section  [ sect.previous ] . with the improvement one can attack problems of over 300 objects .",
    "recently , @xcite has used various other heuristics different from the ones presented here to obtain methods that are both faster and yield better results than our old implementation .",
    "but even the best heuristic there appears to have a slower running time for natural data ( with @xmath7 typically over 50% ) than our current implementation ( in complearn ) using the speedups of section  [ sect.previous ] .",
    "we used the complearn package , @xcite , to analyze a `` 10-mammals '' example with _",
    "compression yielding a @xmath176 distance matrix , similar to the examples in section  [ sect.nat ] .",
    "the algorithm starts with four randomly initialized trees .",
    "it tries to improve each one randomly and finishes when they match .",
    "thus , every run produces an output tree , a maximum score associated with this tree , and has examined some total number of trees , @xmath23 , before it finished .",
    "figure  [ fig.plot ] shows a graph displaying a histogram of @xmath23 over one thousand runs of the distance matrix .",
    "the @xmath27-axis represents a number of trees examined in a single run of the program , measured in thousands of trees and binned in 1000-wide histogram bars .",
    "the maximum number is about 12000 trees examined .",
    "the graph suggests a poisson probability mass function . about @xmath177rd of the trials",
    "take less than 4000 trees . in the thousand trials",
    "above , 994 ended with the optimal @xmath178 .",
    "the remaining six runs returned 5 cases of the second - highest score , @xmath179 and one case of @xmath180 .",
    "it is important to realize that outcome stability is dependent on input matrix particulars .",
    "another interesting probability mass function is the mutation stepsize .",
    "recall that the mutation length is drawn from a shifted fat - tail probability mass function .",
    "but if we restrict our attention to just the mutations that improve the @xmath8 value , then we may examine these statistics to look for evidence of a modification to this distribution due to , for example , the presence of very many isolated areas that have only long - distance ways to escape .",
    "figure  [ fig.mutplot ] shows the histogram    of successful mutation lengths ( that is , number of simple mutations composing a single `` kept '' complex mutation ) and rejected lengths ( both normalized ) which shows that this is not the case . here",
    "the @xmath27-axis is the number of mutation steps and the @xmath105-axis is the normalized proportion of times that step size occurred .",
    "this gives good empirical evidence that in this case , at least , we have a relatively easy search space , without large gaps .      with natural data sets ,",
    "say genomic data , one may have the preconception ( or prejudice ) that primates should be clustered together , rodents should be clustered together , and so should ferungulates .",
    "however , the genome of a marsupial may resemble the genome of a rodent more than that of a monotreme , or vice versa  the very question one wants to resolve .",
    "thus , natural data sets may have ambiguous , conflicting , or counter intuitive outcomes . in other words ,",
    "the experiments on natural data sets have the drawback of not having an objective clear `` correct '' answer that can function as a benchmark for assessing our experimental outcomes , but only intuitive or traditional preconceptions . in section  [ sect.artificial ]",
    "the experiments show that our program indeed does what it is supposed to do  at least in these artificial situations where we know in advance what the correct answer is .",
    "recall that our quartet heuristic consists of two parts : ( i ) extracting the quartet topology costs from the data , and ( ii ) repeatedly randomly mutating the current quartet tree and determining the cost of the new tree .",
    "both the mqtc problem and the original heuristic is actually concerned only with item ( ii ) . to speed up the method we also look at how the quartet topology costs can be derived from the distance matrix ,",
    "that is , we also look at item ( i ) .",
    "* speedup by faster quartet topology cost computation : * assume that the cost of a quartet topology is the sum of the distances between each pair of neighbors @xmath181 for a given distance measure @xmath182",
    ". in the original implementation of the heuristic one used the quartet topology costs to calculate the @xmath8 value of a tree @xmath23 without worrying how those costs arose .",
    "then , the heuristic runs in time order @xmath183 per generation ( actually @xmath184 if one counts certain details proportional to the internal path length as they were implemented ) . if the quartet topology costs are derived",
    "according to , then we can reduce the running time of the implementation by two orders of magnitude .",
    "* subroutine with distance matrix input : *    we compute the quartet topology costs according to .",
    "let there be @xmath1 leaves in a ternary tree @xmath23 .",
    "for every internal node ( there are @xmath20 ) determine a sum as follows .",
    "let @xmath185 be the set of internal nodes ( the nodes in @xmath23 that are not leaves ) .",
    "there are three edges incident with the internal node @xmath186 , say @xmath187 , @xmath188 and @xmath189 .",
    "let the subtrees attached to @xmath190 have @xmath191 leaves ( @xmath192 ) so that @xmath193 .",
    "for every edge @xmath190 there are @xmath194 pairs of leaves in its subtree @xmath195 .",
    "each such pair can form a quartet with pairs @xmath196 sich that @xmath24 is a leaf in the subtree @xmath197 of @xmath198 and @xmath25 is a leaf in the subtree @xmath199 of @xmath200 .",
    "define @xmath201 ( @xmath202 and @xmath203 are not equal to one another ) . for internal node @xmath204",
    "let the cost @xmath205 .",
    "compute the cost @xmath43 of the tree @xmath23 as @xmath206 .",
    "the cost @xmath43 of the tree @xmath23 satisfies @xmath206 .",
    "if the tree @xmath23 has @xmath1 leaves , then the subroutine above runs in time @xmath207 per internal node and hence in @xmath6 overall to determine the sum @xmath43 .",
    "an internal node @xmath204 has three incident edges , say @xmath208 .",
    "let @xmath195 be the subtree rooted at @xmath204 containing edge @xmath190 having @xmath191 leaves ( @xmath209 ) so that @xmath193 . let @xmath196 be a leaf pair with @xmath210 and @xmath211 , and @xmath212 be leaves in @xmath199 ( @xmath202 and @xmath203 unequal ) .",
    "let @xmath213 be defined as the set of all these quartet topologies @xmath36 . clearly , if @xmath214 and @xmath215 , then @xmath216 .",
    "the @xmath196 parts of quartet topologies @xmath217 have a summed cost @xmath218 given by @xmath201 .",
    "then , the cost of @xmath213 is @xmath219 .",
    "every quartet topology @xmath36 in tree @xmath23 is composed of two pairs @xmath196 and @xmath220 .",
    "every pair @xmath196 determines an internal node @xmath204 such that the paths from @xmath24 to @xmath204 and from @xmath25 to @xmath204 are node disjoint except for the end internal node @xmath204 .",
    "every internal node @xmath204 determines a set of such pairs @xmath196 , and for different internal nodes the associated sets are disjoint .",
    "all quartet topologies embedded in the tree @xmath23 occur this way .",
    "hence , @xmath221 where @xmath59 was earlier defined as the set of quartet topologies embedded in @xmath23 . by , the summed cost @xmath43 ( definition  [ def.costs ] ) of all quartet topologies embedded in @xmath23 satisfies @xmath222 .",
    "the running time of determining @xmath223 for a @xmath186 is dominated by the summing of the @xmath224 s for the pairs @xmath196 of leaves in different subtrees with @xmath204 as root .",
    "there are @xmath225 such pairs . since @xmath226 the lemma follows .",
    "this immediately yields the following :    [ lem.previous ] with as input a distance matrix between @xmath1 objects , the quartet topology costs as in , the subroutine above lets the algorithm in figure  [ fig.alg ] ( and its implementation ) run in time @xmath227 per generation .",
    "* speedup by mmc : * a metropolis markov chain ( mmc ) @xcite is implemented inside the mutation chains of the algorithm .",
    "so , instead of doing a qroup of mutations and at the end check if the result improves upon the original ( that is , hill climbing ) , we do the following .",
    "after every mutation , a metropolis acceptance step is performed , rolling back the changes when the step is rejected .",
    "acceptance is calculated on the raw scores of the tree ( unnormalized , thus being more selective with larger trees ) . during the metropolis",
    "walk , the best tree found is kept , at the end this best tree is returned and checked for improvement ( hill climbing ) .",
    "this serves three purposes :    * the search is faster because after every change , the trees are focused on improving the @xmath8 value .",
    "this gives less spurious drift .",
    "* the global search behavior is maintained , as there is a nonzero probability that a tree is transformed into any other tree .",
    "* there is less dependency on the number of mutations to perform in an individual step .",
    "it is no longer necessary to try a few mutations more often than many mutations , simply because the trees are no longer allowed to drift away very far from the current best in an unchecked manner .    by theorem  [ theo.mutations ] in appendix  [ sect.mutations ]",
    ", every tree with @xmath20 unlabeled internal nodes and @xmath1 labeled leaves can be transformed in every other such tree in at most @xmath144 simple mutations ( @xmath19 ) .",
    "we believe that the real value of the number of required simple mutations is about @xmath1 , and therefore have set the trial length to @xmath1 .",
    "the setting does influence the global search properties of the algorithm , longer trial length meaning larger probability of finding the global optimum . in the limit of infinite trial length",
    ", the algorithm will behave as a regular mmc algorithm with associated convergence properties .",
    "the newest version of the mqtc heuristic is at @xcite and has been incorporated in complearn @xcite from version 1.1.3 onwards .",
    "altogether , with both types of speedup , the resulting speedup is at least of the order of 1.000 to 10.000 for common sets of objects with , say , @xmath228 .",
    "to be able to make unbiased comparisons between phylogeny reconstruction algorithms that take distance matrices as input , we use the compression - based ncd distance .",
    "this metric distance was co - developed by us in @xcite , as a normalized version of the `` information metric '' of @xcite .",
    "the mathematics used is based on kolmogorov complexity theory @xcite , which is approximated using real - world compression software .",
    "roughly speaking , two objects are deemed close if we can significantly `` compress '' one given the information in the other , the idea being that if two pieces are more similar , then we can more succinctly describe one given the other .",
    "let @xmath229 denote the binary length of the file @xmath27 compressed with compressor @xmath230 ( for example `` gzip '' , `` bzip2 '' , or `` ppmz '' ) .",
    "the _ normalized compression distance _ ( ncd ) is defined as @xmath231 which is actually a family of distances parameterized with the compressor @xmath230 .",
    "the better @xmath230 is , the better the results are , @xcite .",
    "this ncd is used as distance @xmath182 in to obtain the quartet topology costs .",
    "the ncd in and a precursor have initially been applied to , among others , alignment - free whole genome phylogeny , @xcite , chain letter phylogeny @xcite , constructing language trees @xcite , and plagiarism detection @xcite .",
    "it is in fact a parameter - free , feature - free , data - mining tool .",
    "a variant has been experimentally tested on all time sequence data used in all the major data - mining conferences in the last decade @xcite . that paper compared the compression - based method with all major methods used in those conferences .",
    "the compression - based method was clearly superior for clustering heterogeneous data , and for anomaly detection , and was competitive in clustering domain data .",
    "the ncd method turns out to be robust under change of the underlying compressor - types : statistical ( ppmz ) , lempel - ziv based dictionary ( gzip ) , block based ( bzip2 ) , or special purpose ( gencompress ) .",
    "while there may be more appropriate special - purpose distance measures for biological phylogeny , incorporating decades of research , the ncd is a robust objective platform to test the unbiased performance of the competing phylogeny reconstruction algorithms .",
    "oblivious to the problem area concerned , simply using the distances according to the ncd of and the derived quartet topology costs , the mqtc heuristic described in sections [ sect.mc ] , [ sect.previous ] fully automatically clusters the objects concerned .",
    "the method has been released in the public domain as open - source software : the complearn toolkit @xcite is a suite of simple utilities that one can use to apply compression techniques to the process of discovering and learning patterns in completely different domains , and hierarchically cluster them using the mqtc heuristic .",
    "in fact , complearn is so general that it requires no background knowledge about any particular subject area .",
    "there are no domain - specific parameters to set , and only a handful of general settings . from complearn version 1.1.3 onwards the speedups and improvements in section  [ sect.previous ]",
    "have been implemented .      using the complearn package , in @xcite we studied hypotheses concerning mammalian evolution , by reconstructing the phylogeny from the mitochondrial genomes of 24 species .",
    "these were downloaded from the genbank database on the internet . in another experiment",
    ", we used the mitochondrial genomes of molds and yeasts .",
    "we clustered the sars virus after its sequenced genome was made publicly available , in relation to potentially similar viruses .",
    "the ncd distance matrix was computed using the compressor bzip2 .",
    "the resulting tree @xmath23 ( with @xmath232 ) was very similar to the definitive tree based on medical - macrobio - genomics analysis , appearing later in the new england journal of medicine , @xcite . in @xcite",
    ", 100 different h5n1 sample genomes were downloaded from the ncbi / nih database online , to analyze the geographical spreading of the bird flu h5n1 virus in a large example .    in general hierarchical clustering , we constructed language trees , cluster both russian authors in russian , russian authors in english translation , english authors , handwritten digits given as two - dimensional ocr data , and astronomical data .",
    "we also tested gross classification of files based on heterogeneous data of markedly different file types : genomes , novel excerpts , music files in midi format , linux x86 elf executables , and compiled java class files , @xcite . in @xcite , midi data were used to cluster classical music , distinguish between genres like pop , rock , and classical , and do music classification . in @xcite ,",
    "the complearn package was used to analyze network traffic and to cluster computer worms and viruses .",
    "complearn was used to analyze medical clinical data in clustering fetal heart rate tracings @xcite .",
    "other applications by different authors are in software metrics and obfuscation , web page authorship , topic and domain identification , protein sequence / structure classification , phylogenetic reconstruction , hurricane risk assessment , ortholog detection , and other topics . using code - word lengths obtained from the page - hit counts returned by google from the internet , we obtain a semantic distance between _ names _ for objects ( rather than the objects themselves ) using the ncd formula and viewing google as a compressor .    both the compression method and the google method",
    "have been used many times to obtain distances between objects and to hierarchically cluster the data using complearn @xcite . in this way",
    ", the mqtc method and heuristic described here has been used extensively .",
    "for instance , in many of the references in google scholar to @xcite . here",
    "we give a first full and complete treatment of the mqtc problem , the heuristic , speedup , and comparison to other methods .",
    "we compared the performance of the mqtc heuristic as implemented in the complearn package against that of a leading application to compute phylogenetic trees , a program called splitstree  @xcite .",
    "other methods include @xcite .",
    "our experiments were initially performed with complearn version 0.9.7 before the improvements in section  [ sect.previous ] . but with the improvements of section  [ sect.previous ] in complearn version 1.1.3 and",
    "later , sets of say 34 objects terminated commonly in about 8 cpu seconds . below we use sets of 32 objects .",
    "we choose splitstree version 4.6 for comparison and selected three tree reconstruction methods to benchmark : nj , bionj , and upgma .",
    "to make comparison possible , we require a tree reconstruction implementation that takes a distance matrix as input .",
    "this requirement ruled out some other possibilities , and motivated our choice . to score the quality of the trees produced by complearn and splitstree we converted the splitstree output tree to the complearn output format .",
    "then we used the @xmath8 values in the complearn output and the converted splitstree output to compare the two .",
    "the quartet topology costs were derived from the distance matrix concerned as in section  [ sect.previous ] .",
    "the upgma method consistently performed worse than the other two methods in splitstree .",
    "in several trials it failed to produce an answer at all ( throwing an unhandled java exception ) , which may be due to an implementation problem . therefore , attention was focused on the other two methods .",
    "both nj @xcite and bionj @xcite are neighbor - joining methods . in all tested cases",
    "they produced the same trees , therefore we will treat them as the same ( splitstree bionj = nj ) in this discussion .",
    "our mqtc heuristic has through the complearn package already been extensively tested in hierarchical clustering of nontree - structured data as reviewed in section  [ sect.prevexp ] .",
    "therefore , we choose to run the mqtc heuristic and splitstree on data favoring splitstree , that is , tree - structured data , both artificial and natural .",
    "we first test whether the mqtc heuristic and the splitstree methods are trustworthy .",
    "we generated 100 random samples of an unrooted binary tree @xmath23 with 32 leaves as follows : we started with a linear tree with each internal node connected to one leaf node , a prior internal node , and a successive internal node .",
    "the ends have two leaf nodes instead .",
    "this initial tree was then mutated 1000 times using randomly generated instances of the complex mutation operation defined earlier .",
    "next , we derived a metric from the scrambled tree by defining the distance between two nodes as follows : given the length of the path from @xmath233 to @xmath234 in an integer number of edges as @xmath235 , let @xmath236 except when @xmath237 , in which case @xmath238 .",
    "it is easy to verify that this simple formula always gives a number between 0 and 1 , is monotonic with path length , and the resulting matrix is symmetric .",
    "given only the @xmath239 matrix of these normalized distances , our quartet method precisely reconstructed the original tree one hundred times out of one hundred random trials .",
    "similarly , splitstree nj and bionj also reconstructed each tree precisely in all trials .",
    "however upgma was unable to cope with this test .",
    "it appears there is a mismatch of assumptions in this experimental ensemble and the upgma preconditions , or there may be an error in the splitstree implementation .",
    "the running time of complearn without the improvement of section  [ sect.previous ] was about 3 hours per example , but with the improvement of section  [ sect.previous ] only at most 5 seconds per example .",
    "splitstree had a similar but slightly higher running time . since the performance of complearn and splitstree ( both nj and bionj ) was 100% correct on the artificial data we feel that all the methods except splitstree upgma perform satisfactory on artificial tree - structured data .",
    "[ cols= \" < , < , < , < \" , ]      in the biological setting the data are ( parts of ) genomes of currently existing species , and the purpose is to reconstruct the evolutionary tree that led to those species .",
    "thus , the species are labels of the leaves , and the tree is traditionally binary branching with each branching representing a split in lineages .",
    "the internal nodes and the root of the tree correspond with extinct species ( possibly a still existing species in a leaf directly connected to the internal node ) .",
    "the root of the tree is commonly determined by adding an object that is known to be less related to all other objects than the original objects are with respect to each other . where the unrelated object joins the tree is where we put the root . in this",
    "setting , the direction from the root to the leaves represents an evolution in time , and the assumption is that there is a true tree we have to discover .",
    "however , we can also use the method for hierarchical clustering , resulting in an unrooted ternary tree .",
    "the interpretation is that objects in a given subtree are pairwise closer ( more similar ) to each other than any of those objects is with respect to any object in a disjoint subtree .",
    "to evaluate the quality of tree reconstruction for natural genomic data , we downloaded 45 mitochondrial gene sequences , figure  [ figanimtab ] , and randomly selected 100 subsets of 32 species each .",
    "we used complearn with ppmd to compute ncd matrices for each of the 100 trials and fed these matrices ( as nexus files ) to both complearn and splitstree .",
    "complearn without the speedup in section  [ sect.previous ] took about 10 hours per tree , but with the speedup of section  [ sect.previous ] complearn takes at most 6 seconds for collections of 32 objects in 66% of the cases , at most 10 seconds in 90% of the cases , and occasionally ( about 10% of the cases ) between 10 seconds and 2 minutes .",
    "splitstree used about 10 seconds per trial . in all but one case out of 100 trials , complearn performed as good or better in the sense of producing trees with an as good or higher s(t ) score than the best method ( with upgma performing badly and nj and bionj giving the same scores ) from splitstree",
    "the results are shown in the histogram figure  [ fig.nathisto ] , which shows that out of 100 trials complearn produced a better tree in 69% of the trials .",
    "complearn had an _",
    "@xmath8 of 0.99487068 .",
    "splitstree achieved the _",
    "@xmath8 with both nj and bionj at 0.99243944 . at this high level",
    "the absolute magnitude of the difference is small , yet it can still imply significant    changes in the structure of the tree .",
    "figure  [ fig.bt ] and figure  [ fig.clt ] depict one example showing both bionj = nj and complearn trees applied to the same input matrix from one of the natural data test cases described above . in this case",
    "there are important differences in placement of at least two species ; _ hexatrygon bickelli _ and _ synodus variegatus_.    although we can not know for sure the true maximum value that can be attained for the @xmath8 , given an arbitrary distance matrix , we can still define a useful quantity .",
    "let @xmath240 and term @xmath241 the _ room for improvement _ for tree @xmath23 .",
    "this is especially apt in cases like the present one where we know that the optimal tree @xmath242 has @xmath243 close to 1 .",
    "suppose complearn produces tree @xmath23 in trial @xmath244 and splitstree produces tree @xmath245 in trial @xmath244 .",
    "define @xmath246 and @xmath247 using .",
    "we can compute the decibel gain @xmath248 as the logarithm of the ratio of room for improvement in trial @xmath244 of splitstree s answer versus complearn s answer with the formula @xmath249 hence if @xmath250 then @xmath251 , and @xmath252 means that @xmath253 .",
    "this is statistically significant according to almost every reasonable criterion .",
    "note that the room for improvement decibel gain @xmath248 in represents also a conservative estimate of the true improvement decibel gain in real error terms .",
    "this is because the true maximum @xmath8 score of a tree @xmath23 resulting from a distance matrix is always less than or equal to 1 .",
    "using the @xmath243 value of the real optimal tree @xmath242 instead of 1 would only make the gain more extreme .",
    "we plot the decibel room for improvement gain in figure  [ fig.edeci ] , using different binning boundaries than in figure [ fig.nathisto ] . on the horizontal axis",
    "the bins are displayed where for every trial @xmath244 we put @xmath248 in the appropriate bin . on the vertical axis the percentage of the number of elements in a particular bin to the total is depicted .    because now we use different boundaries for each bin , the percentage of trials with the same room for improvement for both complearn and splitstree is slightly higher than the percentage of trials with the same @xmath8 values between complearn and splitstree in figure  [ fig.nathisto ] .",
    "yet now we can see the important difference in room for improvement between complearn and splitstree expressed in decibels .",
    "thus , about 38% of the complearn trials gives no positive integer decibel reduction in room for improvement over the splitstree performance ( and 1% gave a negative reduction ) .",
    "about 27% gives a 1db reduction in room for improvement , about 22% gives a 2db reduction in room for improvement , about 10% gives a 3db in room for improvement .",
    "overall , about 61% of the complearn trials gives a 1 or more decibel reduction in room for improvement over the splitstree performance . in more than 1/3 of the trials",
    "complearn achieves at least a 2db reduction in room for improvement as compared to splitstree .",
    "we have introduced a new quartet tree problem , the minimum quartet tree cost ( mqtc ) problem , suited for general hierarchical clustering .",
    "this new method relies on global optimization of the constructed tree in contrast to bottom - up or top - down methods that can get stuck in local optima , such as quartet puzzling , neighbor joining , and the like .",
    "is is shown that this mqtc problem is np - hard by a reduction to the ( weighted ) maximum quartet consistency ( mqc ) problem that is more suited for the restricted case of biological phylogeny . moreover , if there is a polynomial time approximation scheme ( ptas ) for the mqtc optimization problem , then p = np .",
    "given the hardness of the mqtc problem we introduce a monte carlo heuristic based on randomized hill climbing .",
    "this heuristic runs in time which is theoretically @xmath4 per generation where @xmath1 is the number of objects , and @xmath5 per generation in the implemented version .",
    "the improvement in section  [ sect.previous ] based on the distance matrix and quartet topology costs in runs in time @xmath6 per generation both as algorithm and implementation . the new method including the improvement is available for general use in the open software complearn toolkit @xcite from version 1.1.3 onward .",
    "it has been used widely for general hierarchical clustering and also for biological phylogeny . here , we tested our mqtc heuristic on artificial data and natural data , and compared it with the neighbor - joining method available in the ( highly competitive ) splitstree package ( version 4 .",
    "6 ) designed for tree - structured data in biological phylogeny .",
    "( bionj and nj in the splitstree package always gave the same results in our experiments , so we treat them as one , and the upmg method in the splitstree package did not work for us . ) to make the comparison more disadvantageous to our mqtc heuristic and more advantageous to splitstree we tested it on tree - structured data , rather than general hierarchical clustering on data of unknown structure .",
    "splitstree was generally slower ( sometimes 10 seconds versus 6 seconds for complearn version 1.1.3 and later , that is , 2/3rd more ) than our mqtc heuristic with the improvements in section  [ sect.previous ] . on our artificial data experiments",
    "both our mqtc heuristic and the splitstree methods gave 100% correct results .",
    "on the natural data experiments the _ average case _ of our mqtc heuristic was better than the _",
    "best case _ of the splitstree heuristics . to amplify the differences we compared the decibel gain in room for improvement of splitstree s answers versus our mqtc heuristic s answers . in 61% of the trials",
    "our mqtc heuristic s performance gave a positive integer decibel reduction in room for improvement over splitstree s performance , and in 33% of the trials",
    "our mqtc heuristic s performance gave a 2db reduction in room for improvement over splitstree .",
    "other heuristics for the mqtc optimization problem are recently given in @xcite .",
    "but even the best method in @xcite has a slower running time for natural data ( with @xmath7 typically about 50% ) than the implementation of the mqtc heuristic in complearn from version 1.1.3 onward .",
    "[ theo.mutations ] every ternary tree with @xmath1 leaves labeled @xmath254 and @xmath20 unlabeled internal nodes can be transformed in every other ternary tree with @xmath1 leaves labeled @xmath254 and @xmath20 unlabeled internal nodes by a sequence of @xmath255 mutations consisting of subtree to leaf swaps or leaf to leaf swaps where @xmath256 and @xmath257 for @xmath19 .    for convenience of the discussion",
    "we attach labels to the internal nodes , but actually the internal nodes are unlabeled , only the leaves are labeled .. the proof is by induction on the number of nodes .",
    "_ base case : @xmath258 .",
    "_ there is one internal node , so the theorem is vacuously true . for @xmath259",
    "there are two internal nodes , so the theorem is true as well using at most one leaf swap .    _",
    "induction _ : assume the theorem is correct for every @xmath60 with @xmath260 .",
    "we prove that it holds for @xmath261 . for @xmath262 consider a ternary tree @xmath55 with @xmath20 unlabeled internal nodes @xmath263 and @xmath1 labeled leaves that has to be transformed into a ternary tree @xmath264 with the same unlabeled internal nodes and labeled leaves .",
    "assume that the initial tree @xmath55 has a path @xmath265 where @xmath105 is an end internal node with two leaves and @xmath27 is an internal node with one leaf .",
    "if @xmath55 is not of that form then we make it of that form by a subtree to leaf swap : take another end internal node @xmath24 ( possibly @xmath266 ) and swap the 3-node tree rooted at @xmath24 ( @xmath24 and its two leaves ) with a leaf of @xmath105 .",
    "this results in a path @xmath267 where @xmath24 is an end internal node with two leaves and @xmath105 is an internal node with a single leaf .",
    "we start from the resulting tree which we call @xmath55 now .    for the sake of the argument",
    "we number the nodes so that @xmath20 is an end internal node connected to an internal node @xmath268 which has a single leaf @xmath269 .",
    "glue the internal nodes @xmath268 and @xmath20 and the leaf @xmath269 together in a single internal node now denoted as @xmath268 . the new @xmath268 is an end internal node connected to two leaves formerly connected to the old @xmath20 .",
    "this results in an @xmath268 unlabeled internal node ternary tree @xmath270 with @xmath271 labeled leaves .    by the induction assumption",
    "we can transform @xmath270 into any ternary tree @xmath272 with @xmath268 unlabeled internal nodes and @xmath271 labeled leaves in @xmath273 subtree to leaf or leaf to leaf mutations .",
    "take @xmath272 to be a subtree of @xmath264 with the following exceptions .",
    "since @xmath264 has one more internal node than @xmath274 we can choose that extra internal node as an end internal node attached to tree @xmath274 at the place where there is now a leaf . let that leaf be leaf @xmath275 .",
    "note that leaf @xmath269 is not a leaf of @xmath274 ( since it is incorporated in internal node @xmath268 ) .",
    "if @xmath269 should be a leaf of @xmath272 to make it a subtree of @xmath264 then we swap @xmath269 with the leaf @xmath276 in the place where @xmath269 has to go in a leaf - to - leaf swap . for convenience",
    "we still denote the leaf left in the composite node @xmath268 by @xmath269 .",
    "now expand in @xmath272 the internal node @xmath268 into the path @xmath277 together with leaf @xmath269 connected to @xmath278 .",
    "this yields a ternary tree with @xmath20 unlabeled internal nodes and @xmath1 labeled leaves .",
    "there are three cases .    * case 1 . * initially , in @xmath272 the node @xmath268 is an end internal node connected to an internal node @xmath24 as in the path @xmath279 .",
    "the expansion takes us to the situation that we have a path @xmath280 and leaf @xmath269 connected to @xmath268 .",
    "the old internal node @xmath268 being an end internal node had two leaves . in the path @xmath277",
    "both these leaves stay connected to the new end internal node @xmath20 and leaf @xmath269 stays connected to @xmath268 .",
    "assume first that @xmath275 is not in de 5-node subtree rooted at the new @xmath268 containing the path @xmath277 .",
    "we interchange this 5-node subtree with the leaf @xmath275 .",
    "next , we interchange the 3-node subtree rooted at @xmath20 with the leaf @xmath275 at its new location . in this way , @xmath268 being now in the former position of leaf @xmath275 is the missing internal node of @xmath264 .",
    "the new internal node @xmath268 is an end internal node with two leaves @xmath281 of which @xmath275 is in the correct position .",
    "there is still the leaf @xmath276 being possibly in the wrong position .",
    "all the other leaves are in the correct position for @xmath264 .",
    "after we swap the leaves @xmath282 if necessary , all leaves are in the correct position .",
    "assume second that @xmath275 is in the subtree rooted at @xmath268 containing the path @xmath277 .",
    "then , the new @xmath20 being an end internal node in the former position of leaf @xmath275 is the missing internal node of @xmath264 .",
    "the total number of mutations used is at most three consisting of two subtree to leaf swaps and possibly one leaf to leaf swap .",
    "* initially , the node @xmath268 in @xmath274 is connected to two internal nodes yielding a path @xmath283 such that @xmath268 is connected also to one leaf , say @xmath284 .",
    "the expansion takes us to the situation that we have a path @xmath285 .",
    "the old internal node @xmath268 was connected to leaf @xmath284 which leaf is now connected to @xmath20 . the leaf @xmath269 is still connected to the new @xmath268 .",
    "assume first that @xmath275 is not in the subtree rooted at the new @xmath268 ( containing @xmath279 ) .",
    "we interchange the subtree rooted at @xmath268 ( containing @xmath279 ) with leaf @xmath275 .",
    "next we interchange the subtree rooted at @xmath24 ( not containing @xmath268 and leaf @xmath269 ) with @xmath275 again .",
    "now the new @xmath268 takes the place of the missing internal node of @xmath264 and it is an end internal node connected to leaves @xmath281 . of these , leaf @xmath275 is in correct position .",
    "all the other leaves except possibly @xmath282 are in correct position for @xmath264 .",
    "if necessary we interchange leaves @xmath282 .    assume second that @xmath275 is in the subtree rooted at the new @xmath268 ( containing @xmath279 ) .",
    "interchange the subtree rooted at @xmath268 ( containing @xmath277 ) with leaf @xmath275 .",
    "next we interchange the subtree rooted at @xmath20 ( not containing @xmath268 and leaf @xmath269 ) with @xmath275 again .",
    "now the new @xmath268 takes the place of the missing internal node of @xmath264 and it is an end internal node connected to leaves @xmath281 . of these , leaf",
    "@xmath275 is in correct position .",
    "all the other leaves except possibly @xmath282 are in correct position for @xmath264 .",
    "if necessary we interchange leaves @xmath282 .",
    "the total number of mutations used is at most three consisting of two subtree to leaf swaps and possibly one leaf to leaf swap .",
    "* initially , in @xmath274 the node @xmath268 is connected to three internal nodes forming the path @xmath283 and there is a path @xmath286 with @xmath287 .",
    "the expansion yields the path @xmath285 with leaf @xmath269 connected to @xmath268 and @xmath20 is also in a path @xmath288 .",
    "assume first that @xmath275 is not in the subtree rooted at the new @xmath268 ( containing @xmath279 ) .",
    "we interchange the subtree rooted at the new @xmath268 containing the edge @xmath279 and leaf @xmath269 with the leaf @xmath275 .",
    "subsequently , we interchange the subtree rooted at @xmath24 ( not containing @xmath268 and the connected leaf @xmath269 ) with @xmath275 again .",
    "now node @xmath268 is in the position of the missing internal node of @xmath274 and it is an end internal node with two leaves @xmath281 . of these , @xmath275 is in correct position .",
    "moreover , all the other leaves are in correct position except possibly @xmath282 .",
    "if necessary we interchange leaves @xmath282 .    assume second that @xmath275 is in the subtree rooted at the new @xmath268 ( containing @xmath279 ) .",
    "interchange the subtree rooted at the new @xmath268 containing the edge @xmath277 and leaf @xmath269 with the leaf @xmath275 .",
    "subsequently , we interchange the subtree rooted at @xmath20 ( not containing @xmath268 and the connected leaf @xmath269 ) with @xmath275 again .",
    "now node @xmath268 is in the position of the missing internal node of @xmath274 and it is an end internal node with two leaves @xmath281 . of these , @xmath275 is in correct position .",
    "moreover , all the other leaves are in correct position except possibly @xmath282 .",
    "if necessary we interchange leaves @xmath282 .",
    "the total number of mutations used is at most three consisting of two subtree to leaf swaps and possibly one leaf to leaf swap .",
    "we count the number of mutations as follows .",
    "initially , tree @xmath274 required at most @xmath273 mutations to be obtained from tree @xmath289 . by the above analysis @xmath290 ( remember the possibly necessary initial subtree to leaf swap to bring @xmath55 in t he required form , and the possibly ncessary leaf to leaf swap between @xmath269 comprised in the composite node @xmath268 and @xmath276 just before * case 1 * ) .",
    "the base case shows that @xmath256 and @xmath291 .",
    "hence , @xmath292 for @xmath293 .",
    "note that the only mutations used are leaf - to - leaf swaps and subtree to leaf swaps .",
    "this shows that the other mutations , that is subtree to subtree swaps , and subtree transfers are superfluous in terms of completeness .",
    "however , they may considerably reduce the number of total mutations required to go from one tree to another . using the full set of mutations",
    "we believe it is possible to go from a ternary tree as above to another one in at most @xmath1 mutations as given .",
    "we thank maarten keijzer for the improvements in the heuristic and its implementation described in section  [ sect.previous ] .              v. berry , t. jiang , p. kearney , m. li , t. wareham , quartet cleaning : improved algorithms and simulations .",
    "algorithms , in : proc .",
    "7th european symp .",
    "( esa99 ) , lect .",
    "notes comp .",
    "1643 , springer , berlin , 1999 , pp .",
    "313324 .",
    "p. buneman , the recovery of trees from measures of dissimilarity , in : f. hodson , d. kenadall , p. tautu ( eds . ) , proc . of the anlo - romanian conference , the royal society of london and the academy of the socialist republic of romania , the university press , edinburgh , scotland , uk , 1971 , pp .",
    "387395 .",
    "r. piaggio - talice , j. gordon burleigh , o. eulenstein , quartet supertrees .",
    "chapter 4 in : o.r.p .",
    "beninda - edmonds ( ed . ) , phylogenetic supertrees : combining information to reveal the tree of life , computational biology , vol . 3 ( a. dress , series ed . ) , kluwer academic publishers , 2004 , pp . 173191 .",
    "u. roshan , b.m.e .",
    "moret , t. warnow , t.l .",
    "williams , performance of supertree methods on various datasets decompositions , in : o.r.p .",
    "beninda - edmonds ( ed . ) , phylogenetic supertrees : combining information to reveal the tree of life , computational biology , vol .",
    "3 ( a. dress , series ed . ) , kluwer academic publishers , 2004 , pp . 301328 ."
  ],
  "abstract_text": [
    "<S> the minimum quartet tree cost problem is to construct an optimal weight tree from the @xmath0 weighted quartet topologies on @xmath1 objects , where optimality means that the summed weight of the embedded quartet topologies is optimal ( so it can be the case that the optimal tree embeds all quartets as nonoptimal topologies ) . </S>",
    "<S> we present a monte carlo heuristic , based on randomized hill climbing , for approximating the optimal weight tree , given the quartet topology weights . </S>",
    "<S> the method repeatedly transforms a dendrogram , with all objects involved as leaves , achieving a monotonic approximation to the exact single globally optimal tree . the problem and the solution heuristic has been extensively used for general hierarchical clustering of nontree - like ( non - phylogeny ) data in various domains and across domains with heterogeneous data . </S>",
    "<S> we also present a greatly improved heuristic , reducing the running time by a factor of order a thousand to ten thousand . </S>",
    "<S> all this is implemented and available , as part of the complearn package . </S>",
    "<S> we compare performance and running time of the original and improved versions with those of upgma , bionj , and nj , as implemented in the splitstree package on genomic data for which the latter are optimized .    _ </S>",
    "<S> keywords_ data and knowledge visualization , pattern matching  clustering  algorithms / similarity measures , pattern matching  </S>",
    "<S> applications ,    _ index terms_ hierarchical clustering , global optimization , monte carlo method , quartet tree , randomized hill - climbing , </S>"
  ]
}