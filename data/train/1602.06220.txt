{
  "article_text": [
    "it is well known that there are two ways to define a function by recursion .",
    "one way is through a _ diagonal construction_. this method owes its popularity to cantor , and forms the backbone of a large number of classic diagonalization theorems .",
    "diagonal constructions are a very concrete , syntactic , and computational method of obtaining fixed points , which we use to obtain recursion .",
    "another way is through some sort of _ least fixed point _",
    ", achievable as a result of some kind of infinite ( or even transfinite ) iteration .",
    "this kind of construction is less computational , but more mathematical .",
    "it is a very common trope in the study of the semantics of programming languages , particularly those based on _ domain theory _ @xcite .",
    "the origins of the fixed - point result that enables this kind of construction are lost in the mists of time @xcite .",
    "both of these constructions were famously used by stephen c. kleene @xcite for the explicit purpose of definition by recursion .",
    "the least fixed point construction is the basis of kleene s _ first recursion theorem ( frt ) _",
    "@xcite , whereas the diagonal construction is the at the heart of his _ second recursion theorem ( srt ) _",
    "@xcite .",
    "it is less well - known , however , that there is a slight mismatch in the contexts where each theorem applies .",
    "the frt is essentially a theorem about _ computation at higher types _ , whereas the srt is a _ first - order theorem _ of a syntactic nature .",
    "modulo the above mismatch , it so happens that _ the srt is more general than the frt_. indeed , the srt allows for a computationally ` stronger ' kind of recursion  namely _ intensional recursion_whereas the frt is of a more _ extensional _ flavour . however , under certain slightly mysterious conditions , the recursion afforded by both is identical .    in the sequel",
    ", we shall investigate these two types of recursion , and their intricate interaction .",
    "first , we explain the extra generality afforded by intensional recursion , and sketch a number of speculative directions for possible applications .",
    "subsequently , we state and prove prove both the frt and the srt .",
    "we investigate when each of them applies , and when their conclusions match , or diverge .",
    "in loose philosophical terms , to be _ intensional _ is to contain not only _ reference _ , but also _ sense_. the distinction between these two notions is due to frege ( see e.g. @xcite ) .",
    "an intensional sign denotes an external _ referent _ , yet inherently connotes more information  its elusive _",
    "sense_. the classic example is that of the planet venus , which may be referred to as either the morning star , or the evening star .",
    "most mainstream mathematics is rather _ extensional _ : we normally reason about underlying , ` ideal ' mathematical object , and not their concrete descriptions ; the latter are , in a way , only there for our referential convenience . in most presentations of set theory ,",
    "for example , the _ axiom of extensionality _ equates any two sets whose members are the same .",
    "thus , in the mathematical sense , _ to be intensional is to be finer than some presupposed ` extensional equality . ' _",
    "it is not difficult to argue that this setting is most inadequate for computer science . on a very rough level",
    ", extensions correspond to _ what may be computed _ , whereas pre - specified correspond to the _ programs and processes that carry out the computation _",
    "( see e.g. @xcite ) .",
    "once more , there is a distinction to be made : programs may be understood by the ideal objects that they refer to ( e.g. functions ) , or their internal characteristics : length , structure , and , ultimately , the _ algorithm _ they express .    the former aspect  viz .",
    "the study of ideal objects behind programs  is the domain of _ computability _ , or _",
    "recursion theory _",
    ", where the object of study is ` effectively computable ' functions over the natural numbers .",
    "computability theory began with a ` confluence of ideas ' @xcite that occurred in the late 1930s , stemming from the attempts of multiple researchers in characterising the notion of ` automatic ' or ` mechanical ' calculability .",
    "remarkably , all roads led to rome : different notions were shown to coincide , leading to the identification of the class of _ partial recursive functions_. subsequent to this fortuitous development , things took a subtle but decisive turn , as further developments mostly concerned the study of the _",
    "incomputable_.    so much for the extensional side .",
    "what about intensions ? here",
    ", we encounter a diverse ecosystem , with no discernible equilibrium . on one side , fixing the _ turing machine _ as one s model of computation leads to _ complexity theory _ and the classification of algorithmic problems , in an attempt to identify their inherent need in resources such as time and space in solving them .",
    "this aspect is largely reliant on more on _ combinatorial reasoning_. alternatively , adopting the @xmath0-calculus as a point of reference leads to _ programming language theory _ , which includes  amongst other things  type systems , program semantics , and program logics . here",
    ", the emphasis is on _ logical aspects_. finally , the subject of concurrent and interactive computation unfolds as a still bewilderingly obscure landscape ; see @xcite .",
    "it is , however , a curious state of affairs that standard recursion theory  as presented in classic textbooks , for example @xcite  begins by formulating a small essential core of abstract results about numberings of partial recursive functions .",
    "these are really results that pertain to all numberings , and hence all ` programming languages ' ; in that sense , they are _",
    "the assumptions required of the numberings are mild .",
    "consequently , the aforementioned parcel of results can be shown to hold for any model of computation we might consider ` reasonable . '    a clear and complete account of this part of the theory can be found in the classic textbook of odifreddi @xcite .",
    "a more modern account that is deeply aware of modern issues of programming language design is that of neil jones @xcite .",
    "the story begins to unfold as soon as we encode _ programs as data _ , by assigning partial recursive functions to numbers .",
    "following tradition , we write @xmath1 for an arbitrary numbering , and @xmath2 for the partial recursive function indexed by @xmath3 , under the numbering @xmath1 .    from a programming perspective",
    ", we may consider @xmath4 to be a ` program , ' and @xmath1 a semantic function , mapping programs to the functions they compute . in practice",
    ", @xmath3 is usually is a gdel number encoding the syntax of a turing machine , or a program for a register machine , or even a @xmath0-term .",
    "let us write @xmath5 for _ kleene equality _",
    ", viz . to mean that expressions @xmath6 and @xmath7 are both undefined , or both defined and equal in value .",
    "we shall require of this numbering the following conditions :    turing - completeness : :    that for each partial recursive function @xmath8 there exists    a @xmath4 such that @xmath9 .",
    "universal function : :    that there is a program @xmath10 such that    @xmath11 for all    @xmath12 .",
    "s - m - n : :    that there is a _ total _ recursive function @xmath13 such that    @xmath14 for all    @xmath15 .    that the first and second conditions are achievable was popularised by @xcite , and the third is a result of kleene @xcite .",
    "the first condition corresponds , by the church - turing thesis , to the fact that our programming language is as expressive as possible in extensional terms .",
    "the second corresponds to the ability to write a _ self - interpreter _ , under suitable gdel coding . and",
    "the third allows us to computably ` fix ' an argument into the source code of a two - argument program ; essentially , it requires that substitution is computable ( c.f .",
    "one - step @xmath16-reduction in the @xmath0-calculus ) .    in logical terms",
    ", we may regard these as sanity conditions for gdel numberings of the partial recursive functions .",
    "the ` sane ' numberings that satisfy them are variously known as _ acceptable numberings _",
    "2.10 ) , _ acceptable programming systems _",
    "@xcite , or _",
    "systems of indices _ @xcite .",
    "it was first shown by rogers @xcite that acceptable numberings have very pleasant properties .",
    "for numberings @xmath1 and @xmath17 , define @xmath18 we then say that @xmath1 rogers - reduces to @xmath17 , and @xmath19 is a preorder .    hence , thinking of @xmath1 and @xmath17 as different programming languages , @xmath20 just if every @xmath1-program may be effectively translated  or _",
    "compiled_to a @xmath17 program .",
    "then @xmath21{\\mbox{\\normalfont\\tiny def}}}{=}}}\\    \\leq_{r } \\cap \\geq_{r}$ ] is an equivalence relation .",
    "quotienting by it yields the _",
    "rogers semilattice _ under the extension of @xmath19 to the equivalence classes ( see _ op .",
    "cit _ ) . more specifically ,    [ thm : indices ] the following are equivalent :    1 .",
    "@xmath17 is an acceptable numbering , as above .",
    "2 .   @xmath17 is a member of the unique top element of the rogers semilattice .",
    "@xmath17 is an enumeration for which there is a universal function , and a total recursive @xmath22 such that @xmath23    the first two equivalences are due to rogers ( see _ op .",
    "cit _ , and @xcite ) , and",
    "the third is due to matchtey , winklmann and young ( * ? ? ?",
    "* theorem 3.2 ) .",
    "note that one should exercise great caution with these equivalences , for their proofs liberally invoke church s thesis , alongside the use of various pairing tricks .",
    "finally , the equivalence between ( 1 ) and ( 2 ) above was slightly strengthened by rogers @xcite to    [ rogers isomorphism theorem ] any two acceptable enumerations are recursively isomorphic .    the possible numberings of the partial recursive functions , whether acceptable or pathological , as well as the various forms of srts that may or may not hold of them , have been investigated by the school of john case and his students : d. riccardi @xcite , j. royer @xcite and , more recently , s. moelius @xcite . for example , this community has that there are numberings where certain known theorems , just as the s - m - n theorem or kleene s second recursion theorem , are not ` effective , ' or simply do not hold .",
    "earlier work on this front seems to have concentrated on enumerations of subrecursive classes of the partial recursive functions and complexity - theoretic issues , whilst the work of case and his students concentrated on _ control structures _ ,",
    "i.e. constructs which provide `` a means of forming a composite program from given constituent programs and/or data . ''",
    "the central intensional result of computability is _",
    "kleene s second recursion theorem ( srt ) _ , also first proved in @xcite .",
    "for any partial recursive @xmath24 , there exists @xmath25 such that @xmath26    consider the function defined by @xmath27 since @xmath8 is partial recursive and , by simple arguments regarding the computability of composition and substitution , @xmath28 is partial recursive .",
    "hence , since @xmath1 is turing - complete , @xmath29 for some @xmath30 .",
    "consider @xmath31 ; then @xmath32 the second equality follows by the s - m - n theorem , and the rest are simply by definition or construction .    in the above theorem ,",
    "consider @xmath33 is a function that treats its first argument as code , and its second argument as data .",
    "the equation @xmath34 implies that @xmath35 is a program which , when run on some data , will behave as @xmath8 with @xmath35 being its first argument .",
    "more conceptually , _",
    "kleene s srt allows us to construct programs that may refer to their own source code .",
    "_    in hindsight , the trick has become standard : @xmath33 is a ` blueprint ' that specifies what to do with its own code @xmath35 , and we take its fixed point ( c.f .",
    "the functionals in the @xmath0-calculus to which we apply the @xmath36 combinator ) .",
    "moreover , in much the same way that the @xmath36 combinator is available _ within the language _ , it so happens that the srt is ` constructive ' , or rather , ` effective ' :    [ thm : cksrt ] there is a total recursive @xmath37 such that , for every @xmath3 , @xmath38    that is : in the original statement , we may calculate a code for @xmath28 from a code for @xmath8 , and hence obtain @xmath35 in an effective manner .",
    "the kleene srt lies at the heart many proofs in computability , especially diagonalization proofs , or results pertaining to fixed points , self - reference and the like . a smattering of more theoretical applications this ` amazing ' theorem has been compiled by moschovakis @xcite .",
    "the srt is perhaps more familiar in the form popularised by hartley rogers jr . in @xcite .",
    "we state a slightly generalised version , and prove it from kleene s version .",
    "we write @xmath39 to mean that the expression @xmath35 has a defined value .    for partial recursive @xmath40",
    ", there is a @xmath25 such that , if @xmath41 , @xmath42    ( * ? ? ?",
    "* lemma 14.3.7 ) define @xmath43 again , by standard arguments , @xmath44 is partial recursive . by kleene",
    "s srt , there is a @xmath25 such that , for all @xmath45 , @xmath46 which is to say @xmath47 .",
    "this result is equivalent to the previous formulation ( * ? ? ?",
    ". we may summarise it in the following slogan :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ every computable syntactic program transformation has a semantic fixed point . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    moreover , this version of the srt also comes in a ` constructive ' variant  see @xcite or @xcite :    [ constructive rogers srt ] [ thm : fprt ] there is a total recursive @xmath48 such that , for any @xmath49 such that @xmath50 is total , @xmath51    all the above variants of the srt are _ equivalent _ under the assumption that @xmath1 is an acceptable enumeration . however , there are ways to compare the generality of the two formulations .",
    "riccardi @xcite showed that that there are enumerations of the partial recursive functions for which there exist rogers - type fixed points , but not kleene - type fixed points . in a rather technical section of his thesis ,",
    "moelius @xcite painstakingly compares the various entailments between forms of the recursion theorem , and concludes instead that kleene s is more natural and general .",
    "we shall not dwell on this particular discussion  no matter how enticing .",
    "in fact , we shall avoid it because it does not fit our view of programming .",
    "any numbering that is _ not _ acceptable is somehow pathological : by contraposition , it implies either that substitution is not computable ( and the s - m - n theorem does not hold ) , or that there is no self - interpreter ( universal function)which , by turing - completeness , means that the interpreter as a function is not computable .",
    "things are even more subtle if the language is _ not _ turing - complete  we then have a _ subrecursive _ indexing @xcite  and we shall not tread down this path either .      from the point of view of computer science , the very general and still rather hazy application of the srt is the ability to define functions by _",
    "intensional recursion_. this means that ",
    "apart from merely calling itself on a finite set of arguments , which is the well - known extensional viewpoint it can also examine its own _ intension _ , insofar as a program and its source code are a complete and finite representations of it .    indeed , the srt is the only basic tool available in standard ( non - higher - order ) accounts of computability which allows one to make any ` unrestricted ' recursive definition whatsoever . for example , defining @xmath52 then , applying kleene s srt yields a code @xmath25 such that @xmath53 is the factorial function .",
    "however , the above use is slightly misleading , in that it is _ extensional _ : @xmath54 is only used as an argument to the universal function @xmath55 .",
    "hence , the resulting behaviour does not depend on the code , but only on the values of the function it represents .",
    "the following definition captures that phenomenon .",
    "a total recursive @xmath56 is _ extensional _ just if @xmath57 for any @xmath58 .",
    "that is , @xmath59 is extensional just if the program transformation it effects depends solely on the extension of the program being transformed .",
    "such transformations correspond to a certain class of functionals , by a classic result of myhill and shepherdson @xcite , which we discuss in the sequel .",
    "however , even if a @xmath40 is extensional , the paradigm of intensional recursion strictly increases our expressive power .",
    "for example , suppose that we use the srt to produce a program @xmath35 satisfying a recursive definition of the form @xmath60 for some @xmath61 .",
    "then , we could use the s - m - n function to replace this recursive call by something of the form @xmath62 this is an equivalent definition , in the sense that @xmath63 .",
    "but if the s - m - n function @xmath64 performs some _ optimisation _ based on the argument @xmath54which it sometimes does  then @xmath65 may be a more efficient definition , in that it makes the code for the recursive call simpler and more efficient , before actually calling it .",
    "this line of thought is a common driving force in the _ partial evaluation _",
    "community : there , the s - m - n function is called a _ specializer _ or a _ partial evaluator _ , and it is designed so that its acts in a useful manner on the programs it is called to process .",
    "see below for more pointers and references .",
    "finally , we ought to stress once more the idea that the srt allows recursive definitions which are _ not functional _ , in that the ` blueprint ' of which we take a fixed point may not be extensional .",
    "for example , one may may be as daft as to define @xmath66 this @xmath40 is total recursive , but decidedly not extensional .",
    "however , we may still use rogers theorem to obtain a fixed point @xmath25 such that @xmath47 , and the resulting behaviour will depend on the parity of @xmath35 ( ! ) . to this day",
    ", it is unclear what the use of this power is , except of course its tremendous ability to underlie all sorts of diagonal arguments ",
    "see @xcite  as well as many kinds of _",
    "reflection_.      in @xcite , abramsky observed that the srt , as well as other simple results on program codes , are strangely absent from computer science at large .",
    "he comments :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` [ ... ] this reflects the fact which we have already alluded to , that while computer science embraces wider notions of processes than computability theory , it has tended to refrain from studying intensional computation , despite its apparent expressive potential .",
    "this reluctance is probably linked to the fact that it has proved difficult enough to achieve software reliability even while remaining within the confines of the extensional paradigm .",
    "nevertheless , it seems reasonable to suppose that understanding and harnessing intensional methods offers a challenge for computer science which it must eventually address . [ ... ] '' _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in many ways , we empathise with this programme .",
    "consequently , we catalogue some applications of such intensional ` results about program codes ' , both within and on the fringes of computer science , and then engage in some speculation regarding various future directions .",
    "kleene s s - m - n theorem allows one to ` specialize , ' or ` partially evaluate ' a certain program by fixing some of its arguments .",
    "it appears simple and innocuous , even though it is an essential result in computability theory , in that it is in the core of many arguments .    however , its application bestowed considerable success upon the _ partial evaluation _ community , which began with the _ futamura projections _",
    "futamura observed that the ability to write an interpreter for a language ( a universal function ) , as well as the ability to ` specialize ' an argument of a program ( s - m - n function ) , followed by source - level optimisation , yields an easy approach to generate a compiler , thus leading to the three _",
    "futamura projections_. writing @xmath67 , where @xmath13 is the s - m - n function , and @xmath10 for the program corresponding to the universal function , we have : @xmath68{\\mbox{\\normalfont\\tiny def}}}{=}}}\\phi_s(u , \\text{source code } ) \\\\      \\text{compiler } & { \\mathrel{\\overset{\\makebox[0pt]{\\mbox{\\normalfont\\tiny def}}}{=}}}\\phi_s(s , u ) \\\\      \\text{compiler generator } & { \\mathrel{\\overset{\\makebox[0pt]{\\mbox{\\normalfont\\tiny def}}}{=}}}\\phi_s(s , s )    \\end{aligned}\\ ] ] one can then verify that these equations do yield the desired behaviour , as shown in an elementary fashion by jones @xcite .",
    "this led to a successful programme of automatic generation of compilers , first realised in copenhagen .",
    "the results are documented in jones @xcite , and the book of jones , gomard and sestoft @xcite .",
    "contrasting the simplicity of the s - m - n theorem with its success in the partial evaluation community also led jones to ponder whether the srt , which is a much more powerful result , could have interesting practical applications . quoting from @xcite :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` while this theorem has many applications in mathematics , it is not yet clear whether it will be as constructively useful in computer science as the s - m - n theorem has turned out to be . ''",
    "_ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    taking this as a point of departure , he has posed a number of questions : if one implements the srt , how can the accumulating layers of self - interpretation be avoided ?",
    "we aspire to answer this .",
    "further , what is the exact relationship between the first and second recursion theorems ?",
    "this last question has already been answered a long time ago ; see section [ sec : higher ] .",
    "experiments with the srt and further discussion are reported in hansen et al .",
    "@xcite , and jones @xcite .",
    "computer viruses rely heavily on the ability to propagate their own code , which is a sort of textual _",
    "reflection_. this was noticed by cohen @xcite , who first introduced the term _ computer virus _ to computer science , and presented an early a turing machine model of them .",
    "later , cohen s supervisor , leonard adleman , concocted a model based on computability @xcite , in which computer viruses are program transformations , from ordinary programs to their ` infected ' versions .",
    "therein , the connection with the srt was made explicit : adleman invokes it to construct a program that , under his own definitions , is classed as a virus .",
    "he also proves a result on his model that crucially used the srt for a diagonal construction .",
    "these were the two cornerstones that laid the foundation of _ abstract computer virology_. in more recent years , there have been further developments , owing to the work of bonfante , kaczmarek & marion @xcite , who discuss and classify different types of viruses that correspond to multiple variants of the srt .",
    "see also @xcite .",
    "the concept of _ reflection _ was introduced in programming languages by brian cantwell smith in his voluminous thesis @xcite .",
    "the underlying intuition is that a program may be considered to be running on an interpreter , which interpreter itself is running on another copy of this interpreter , etc .",
    "ad infinitum .",
    "a special construct is available in the programming language which allows one to inject code in the interpreter that lies a level underneath .",
    "it is thus that a program has access not only to its code , but the entire state of the interpreter that runs it , and even the interpreter that runs the interpreter !",
    "this is embodied by the language 3-lisp , introduced in _ op .",
    "_ smith reflection has captured the imagination of many , but the obscure imagery of _ reflective towers _ does not aid in a clear logical interpretation .",
    "a series of publications by friedman , wand et al .",
    "@xcite have made partial attempts to explain this construction in more concrete terms .",
    "the concept of reflection , however , seems to be more general , and rather ill - defined .",
    "nevertheless , most programming languages have reflective or ` introspective ' facilities , which are usually hard to use without introducing bugs , or generally wreaking havoc .",
    "some ideas regarding reflection seem to be experiencing a resurgence of interest , mainly because of the logical foundation provided by barry jay s _ pattern calculus _ , as well as his various combinatory factorisation calculi , in joint work with given - wilson @xcite .",
    "as the srt is a fundamentally reflective result , we believe that a better understanding of intensional recursion can be instrumental in laying a logical foundation for reflection .",
    "there are certain approaches to economics that explicitly incorporate principles from computability , at ground and higher types .",
    "for example , @xcite outlines the author s ideas for a _ computable economics _ , which is sharply critical of mathematical modelling in economic theory .",
    "in another approach , vassilakis uses category theory @xcite to construct various structures used to model various economic scenarios . in @xcite ,",
    "scott domains are used to model the ` change of institutions ' in game theory .",
    "perhaps our better understanding of issues as presented in this manuscript could aid in creating more practical tools on which efforts such as the above could be based .",
    "suppose that we have some @xmath40 that is total and extensional .",
    "it is not hard to see that  by the definition of extensionality of a function  it uniquely induces a very specific type of functional .",
    "let us write @xmath69 for the set of partial recursive functions .",
    "a functional @xmath70 is an _ effective operation _",
    ", if there exists a total , extensional @xmath40 such that @xmath71    again : this is well - defined precisely because @xmath8 is extensional ! even though we are entering the realm of _ higher types _",
    ", by computing functions from functions , we are doing so in a very finitary sense .",
    "even if our maps map infinite objects to infinite objects , this computation can be , so to speak , _ tracked _ on the level of program codes in a very finitistic manner .",
    "functionals such as the one defined above are perhaps one of the most straightforward ways to define ` computable functionals , ' namely as effective code transformations .",
    "surprisingly , myhill and shepherdson @xcite showed in 1955 that this definition can also be stated in a much more abstract manner , hence dispensing with code transformations entirely .",
    "in fact , and one that anyone familiar with the domain - theoretic semantics of the @xmath0-calculus will recognise the definition immediately .",
    "to state this definition , we need to understand the simple order - theoretic structure that underlies partial functions .",
    "writing @xmath72 for the set of unary partial functions , we see that we may order @xmath72 by _ subset inclusion _ :",
    "@xmath73 this makes @xmath72 into a @xmath74-complete partial order ( @xmath74-cpo ) , in that least upper bounds of increasing chains always exist , and they are unions .",
    "this fact gives rise to a notion of computable functions on @xmath72 :    a functional @xmath75 is _ effectively continuous _ just if it satisfies the following properties :    monotonicitity : :    @xmath76 continuity : :    for any increasing sequence of partial functions ,    @xmath77 we have    @xmath78 effectivity on finite elements : :    given an encoding @xmath79 of the graph of every    finite function @xmath80 as a number    @xmath81 , there is a partial    recursive    @xmath82    such that , for every finite    @xmath83 , and for    all @xmath84 ,    @xmath85    these are called _ recursive functionals _ in @xcite ; we beseech the reader to exercise caution , as terminology varies , and it varies wildly !",
    "continuity may equivalently be formulated as follows ( see @xcite ) :    [ compactness ] @xmath75 is continuous if and only if @xmath86 for all @xmath87 .",
    "even though very learned and involved , the above consequence shows that the definition is very strongly _ computational _ and _ effective _ , in that the value of @xmath88 only depends on a finite part of the graph of @xmath8 .",
    "in fact , it is strong enough that the behaviour of @xmath89 on finite elements completely determines it :    [ algebraicity ] let @xmath75 be continuous .",
    "then @xmath90    how do these functionals , which are computable in finite approximations , relate to the aforementioned effective operations , which are based on computations on indices ? the answer is astonishingly , and  modulo the domain of definition  simple :    [ myhill - shepherdson ] an effective operation @xmath91 can be uniquely extended to an effectively continuous functional @xmath92 ( with @xmath93 ) .",
    "conversely , any effectively continuous functional , when restricted to the partial recursive functions @xmath69 , is an effective operation .    for proofs , see ( * ? ?",
    "* -2 ) , @xcite , or @xcite .",
    "our discussion of functionals began with effective operations , viz .",
    "extensional operations on codes , as the most natural definition of higher - order computation .",
    "there is , however , an alternative , which some would argue is even more simple : one may envisage the implementation of any functional @xmath75 as a turing machine which has access to an _ oracle _ for the argument of the functional . during a computation ,",
    "the machine may write a number @xmath54 on a separate tape , and then enter a special state , in order to query the oracle . the oracle then replaces @xmath54 with @xmath94 , if @xmath8 is defined at @xmath54 , or causes the machine to diverge , essentially by making it eternally await an answer from the oracle .    computation with oracles was first considered by turing @xcite , leading to the intricate theory of _ turing reducibility _ and _ relative computability _ , as well as many results in _",
    "relativized complexity_. however , turing - type oracles are _ fixed _ in relative computability , whilst we consider them as _",
    "arguments to a computation_. this shift in perspective , as well as the first concrete results involving higher types , are due to kleene @xcite .    in this context ,",
    "subtle issues arise with _ non - determinism_. it is well - known that non - deterministic turing machines are equivalent to deterministic turing machines at the first order , but at higher order this is no longer true .",
    "in fact , the following theorem was first shown  to the best of our knowledge  by moschovakis @xcite , even though it was simply labelled as the myhill - shepherdson theorem :    [ moschovakis ] [ thm : ims ] a functional @xmath95 is an effective operation if and only if @xmath96 is computable by a non - deterministic turing machine , with an oracle for @xmath8 .",
    "great care has to be taken in combining non - determinism with oracles : the machine should be designed so as to never end up with two halting branches with different outputs .",
    "similar restrictions occur in defining what it means to non - deterministically compute a polynomial time function ",
    "see @xcite . however , in this case , non - halting branches do not harm anyone , and are allowed , or , in some sense we shall discuss below , even necessary .",
    "we have seen that effectively continuous functionals have an impressive amount of inherent structure .",
    "most of it is related to the order structure of the partial functions @xmath72 . by the myhill - shepherdson theorem ,",
    "this structure emerges automatically once a functional can be ` realised ' on codes by an extensional function .",
    "the inherent structure of effectively continuous functionals is the basis of the proof of the first recursion theorem ( frt ) .",
    "this was first noticed by dana scott , who noticed that the core argument in the proof of the frt applies to all so - called _ simple types _ .. @xmath97 is supposed to connote the _ booleans _ , and @xmath98 the type of natural numbers . ]",
    "this discovery of scott led to the development of _ domain theory _ and the study of @xcite , both of which were the firstfruits of the study of programming language semantics . indeed , scott acknowledged his debts ; quoting from @xcite :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ [ ... ] it is rather strange that the present model was not discovered earlier , for quite sufficient hints are to be found in the early paper of myhill and shepherdson and in rogers book ( especially   9.7 - 9.8 ) .",
    "these two sources introduce effective enumeration operators and indicate that there is a certain amount of algebra about that that gives these operators a pleasant theory , but no one seemed ever to take the trouble to find out what it was .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the central result underlying the frt is this .    [ the fixpoint theorem ] let @xmath99 be a @xmath74-cpo with a least element @xmath100 , and let @xmath101 be a continuous function",
    ". then @xmath89 has a _ least fixed point _ ,",
    "defined explicitly by @xmath102    this is largely considered a folk theorem : its origins are difficult to trace , and many variants of it have been proved and used widely in logic and computer science  see lassez et al .",
    "@xcite for an attempt at pinning down its history . in _ op .",
    "cit _ , the authors note that kleene knew of it at least as early as 1938 @xcite .    in fact , it is high time that we show to the reader how it constitutes the first half of kleene s frt . but first , a caveat : the version of the frt that we will now prove pertains to effective operations ( _  la _ myhill & shepherdson ) , and a proof similar to ours may be found in cutland s book @xcite .",
    "the _ original _",
    "statement , found in kleene s book @xcite concerns partial recursive functionals , which we discuss in  [ sec : prf ] ; see also @xcite .",
    "[ first recursion theorem ] [ thm : frt ] every effectively continuous functional @xmath75 has a least fixed point @xmath103 , which is partial recursive .",
    "furthermore , let @xmath104 be an extensional function that realises @xmath89 on the partial recursive functions , i.e. @xmath105 .",
    "then , a @xmath3 such that @xmath106 may be computed effectively from any such @xmath107 .",
    "the existence of the least fixed point follows from the fact @xmath108 is a @xmath74-cpo , and the fixpoint theorem .    by the myhill ",
    "shepherdson theorem , the functional @xmath89 corresponds to some extensional @xmath109 .",
    "the proof of the fixpoint theorem constructs a chain , @xmath110 where @xmath111 , and the least fixed point is @xmath112 .",
    "the @xmath113 may be construed as increasingly defined , yet consistent , ` approximations ' to @xmath8 .",
    "the key to this proof lies in using the extensional @xmath114 to obtain indices that _ track _ each element of this chain : @xmath115 so that @xmath116 and hence , by induction , @xmath117 for all @xmath118 .",
    "then , by church s thesis , we define @xmath3 by writing a program that performs the following steps : on input @xmath119 ,    1 .",
    "set @xmath120 .",
    "2 .   begin a _ simulation _ of the program @xmath121 running on @xmath119 .",
    "3 .   loop : 1 .   for each @xmath122 ,",
    "simulate one step of @xmath123 on @xmath119 .",
    "2 .   if any of these simulations have halted and produced a value @xmath124 , halt and output @xmath124 .",
    "3 .   otherwise , compute @xmath116 , and begin a simulation of @xmath125 on input @xmath119 .",
    "set @xmath126 .",
    "since the @xmath113 s are a chain , this program can not accidentally produce two different values depending on which extensional @xmath114 we use .",
    "but since @xmath127 , if @xmath128 , then @xmath129 for some @xmath130 , so that @xmath9 .    in both @xcite and @xcite , the above proof is obtained after the recursively enumerable sets are characterised as the @xmath131 sets in the arithmetical hierarchy .",
    "we prefer the more primitive , ` algorithmic version ' above , because we can isolate the expressive ` programming power ' we need , in very intensional terms .",
    "so , what do we make use of ?",
    "the program in the proof curiously calls for _ countable dovetailing_. we require access to the code of the relevant extensional function , exactly in order that we can use it to compute a potentially infinite number of other codes .",
    "furthermore , we require a handle on a number of simulations we spawn , so that we can pause them , schedule some steps of each , and possibly even discard some .",
    "it is worth remarking once more that _ the output of this procedure is obviously deterministic , but there is inherent non - determinism and parallelism in the method we use to compute it ! _ this is very much in line with moschovakis version of the myhill ",
    "shepherdson theorem ( theorem [ thm : ims ] ) .",
    "up to this point , we have mostly discussed effective operations , and the corresponding notion of effectively continuous functionals .    in our discussion leading up to theorem [ thm : ims ]",
    ", we also mentioned a slightly different paradigm , that of _ oracle computation_. theorem [ thm : ims ] , however , guaranteed that non - deterministic computation coincided with effective continuity .",
    "in contrast , if we adopt deterministic oracle computation as our main worldview , we are led to a different notion of computable functional .",
    "this kind of functional was first discussed by kleene @xcite :    a functional @xmath132 is a _ partial recursive functional _ if @xmath96 can be obtained from @xmath56 and the initial functions by composition , primitive recursion , and minimalisation .",
    "if the domain is restricted to the set @xmath133 of total functions , such a functional @xmath134 is called a _ restricted partial recursive functional_.    thus , if @xmath135 , then we say that @xmath136 is partial recursive _ uniformly in @xmath8_.    an implementation of such a functional @xmath89 would resemble a deterministic turing machine with an oracle for its argument .",
    "but in this case , notice that , as there is no non - determinism , calls to the oracle have to happen in a predetermined way .",
    "as soon as we decide to make a query at an undefined point , the computation diverges : there is no other branch of the computation to save the day !",
    "informally , we can say that _ calls to the oracle may not be dovetailed_. in effect , partial recursive functionals deal with their arguments as _ pure extensions _ , whereas effectively continuous functionals interacted in a more involved manner with the phenomenon of non - termination",
    ".    in the case of total inputs , the above connection was made precise by kleene :    @xcite a functional @xmath137 is a restricted partial recursive functional if and only if it is computed by a deterministic turing machine with an oracle .",
    "we are not aware of a plausible analogue of this theorem for partial recursive functionals and deterministic turing machines .",
    "the definition of partial recursive functionals has a lot of undesirable consequences ( see the discussion in platek s thesis @xcite ) .",
    "thus , the definition is often restricted to total inputs , for which the above characterisation of kleene through turing machines exists .",
    "the underlying reason seems to be that , for total inputs , we may _ enumerate _ the graph of the oracle , for no call to it will diverge .    let us not forget this trivial but pleasant consequence :    [ lem : prfprec ] let @xmath75 be a partial recursive functional . if @xmath138 , then @xmath139 .",
    "it is in this setting that kleene obtained the first recursion theorem , which first appeared in @xcite :    [ frt for partial recursive functionals ] let @xmath140 be a partial recursive functional .",
    "then @xmath89 admits a partial recursive least fixed point .",
    "see @xcite . as before",
    ", the existence of the least fixed point follows from the fixpoint theorem .",
    "the fact it is partial recursive follows from lemma [ lem : prfprec ] . by induction , we conclude that all the @xmath113 s are partial recursive .",
    "the least fixed point is @xmath141 , we have that @xmath142 since the @xmath113 s are partial recursive , the predicate on the rhs of this equivalence is recursively enumerable , and hence so is the graph of @xmath8 .",
    "notice how all references to indices have disappeared completely , and all that we are left with is abstract characterisations .",
    "the following was shown by uspenskii and nerode ",
    "see @xcite for a proof :    [ thm : nerode ] every partial recursive functional is effectively continuous .",
    "in particular , if we restrict a partial recursive functional to the partial recursive functions , it is an effective operation .",
    "the converse was shown to fail by sasso ",
    "see @xcite :    the functional @xmath143 is effectively continuous , but not partial recursive .",
    "this clearly demonstrates , once more , that there is inherent _ parallelism _ or _ non - determinism _ in effective operations , whilst partial recursive functionals are purely _ sequential_. in particular , to compute the above functional we would have to concurrently query the argument at two points , and dovetail the computations . a deterministic turing machine would have to either query @xmath8 at either @xmath144 or @xmath145 first ;",
    "if the first call were to an undefined point , it would diverge and never examine the second !",
    "a non - deterministic turing machine would deal with the same difficulty by branching at the point where a choice between @xmath144 and @xmath145 is to be made .",
    "suppose we would like to construct a fixed point in a more simplistic and syntactic manner than the construction employed in theorem [ thm : frt ] .",
    "to do so , all we need to do is use the myhill - shepherdson theorem to restrict an effectively continuous functional to an effective operation , extract an extensional function from it , and then apply the srt .",
    "use church s thesis , kleene s srt , and the function @xmath119 from [ thm : fprt ] to define @xmath153 such that @xmath154 where @xmath155 is an index for the constant zero function , i.e. @xmath156 for all @xmath84 .",
    "observe that , as @xmath119 is total recursive , @xmath157 is total recursive .",
    "it is also extensional .",
    "essentially , @xmath157 asks : is the input my own uniform _  la _ rogers fixed point ?",
    "if yes , output code for the constant zero function ; otherwise , echo the input .",
    "thus , if @xmath158 , we have that @xmath159 , so that @xmath160 . otherwise",
    ", as @xmath161 is a fixed point ( ! ) , @xmath162 in either case , @xmath157 is extensional , and it defines the identity functional , whose least fixed point is the empty function .",
    "so , we compute the fixed point of that functional , and its code is @xmath161 .",
    "however , @xmath163 so that @xmath164 , which is equal to the constant zero function .",
    "the key aspect of this construction seems to be that , unlike oracle computation , an extensional function is able to syntactically inspect its input , thus creating a ` singularity ' at one point .",
    "we maintain extensionality by arranging that , incidentally , the point of the ` singularity ' is  its own fixed point ! that is to say : effective operations really hide something more than ` pure extension ' under the hood .",
    "can this situation be mended ?",
    "the answer is positive : _ any extensional function can be brought into a `` standard form '' , which guarantees that the srt really defines a minimal fixed point .",
    "_ this is the exact sense in which the srt implies the frt .",
    "the construction is a generalisation of a proof due to rogers @xcite .",
    "the original statement is horribly complicated , and involves multiple layers of enumeration ; there is a lot of concurrency happening here , and we can not do much better than keep the description informal !    for the following ,",
    "we assume that there is also a standard way to enumerate the graph of a partial recursive function , given its index .",
    "this may be done by dovetailing simulations of @xmath165 and emitting pairs @xmath166 as soon as the @xmath130th simulation halts .",
    "we do not care about the exact details , but we do care that the exact same construction is used throughout .      we will define an extensional @xmath169 , which is _ co - extensional _ with @xmath8 , in the sense that @xmath170 and which is in `` standard form . ''",
    "moreover , we may effectively compute an index for @xmath171 from an index for @xmath8 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath172  on input @xmath54 , run the following processes in parallel :    1 .",
    "one process enumerates the encoded graphs of all finite functions , starting with the empty function : @xmath173 this may be done in many ways , but it is necessary that we begin with the empty function , in order to cover the covert base case in the strong induction of the following theorem .",
    "2 .   there is a total recursive @xmath174 which turns a graph of a finite function into an index for that function ( by writing code that simply checks if the input is in the graph , outputting the relevant value if so , and diverging otherwise ) .",
    "our second process receives the encoded graphs of the finite functions above , and enumerates codes , @xmath175 with @xmath176 .",
    "a third process receives messages from the second process , and applies @xmath8 to those codes , outputting @xmath177 with @xmath178 .",
    "we thus obtain codes for all the applications of the effective operation @xmath89 on all the finite functions .",
    "nb that these functions @xmath179 may now be infinite",
    "( this is the process where partiality enters the construction . )",
    "enumerate , simultaneously , all the pairs of @xmath180 , as well as the graphs of @xmath178 .",
    "this can be done using the method postulated above .",
    "as soon as we find that @xmath181 for some @xmath155 , we halt and output that @xmath155 .",
    "this may be done by periodically checking whether @xmath54 is defined in the enumeration of some @xmath182 , and then confirming that the entire graph @xmath183 of that @xmath184 is contained in the enumeration of @xmath180 .",
    " _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    notice that , in this construction , the code for @xmath8 may be abstracted away .",
    "using the s - m - n theorem , we can then effectively produce code for it from any index of @xmath8 .",
    "trivially , @xmath171 is total .    by the continuity of @xmath89 , which follows from the theorem of myhill and shepherdson , we know that ,",
    "@xmath185 if and only if @xmath186 for some finite @xmath187 .",
    "this construction will always find such a @xmath184 if there exists one .",
    "hence @xmath171 defines the same functional as @xmath8 .",
    "we have that @xmath190 so that @xmath189 behaves exactly as @xmath171 would if @xmath191 were fixed to be its own code .",
    "that is to say , we can read @xmath192 wherever @xmath180 is enumerated , and the check @xmath193 becomes @xmath194 which is to say that the program checks whether each finite function is a subset of its own graph !",
    "this defines a fixed point for the functional @xmath89 , by lemma [ lem : srtfix ] .    to prove that this fixed point is least",
    ", we proceed by _ strong induction on the number of steps taken to enumerate the graph of @xmath192_. that is , we shall show that if we begin enumerating @xmath192 using our standard enumeration procedure on the code @xmath189 , all the pairs produced will belong to the least fixed point , hence @xmath195 , whence @xmath196 .",
    "begin enumerating @xmath192 .",
    "this involves running the code @xmath189 .",
    "one of the sub - processes in that code involves enumerating @xmath192 itself , using the same procedure as we are .",
    "since this is a _ sub - computation _ of our enumeration , it is always shorter in length .",
    "hence , by the inductive hypothesis , we assume that the enumeration in the sub - computation produces the least fixed point .",
    "hence , if the check @xmath197 succeeds , we know that @xmath198 by monotonicity , it follows that @xmath199 hence , when the check @xmath200 succeeds and the pair @xmath201 is output by the enumeration , we know it belongs to the least fixed point .",
    "it follows that every pair produced by the enumeration is in the least fixed point .",
    "we have not used any particular properties of the function @xmath202 that produces intensional fixed points ; in fact , we believe our proof resolves an open question of rogers , found in @xcite : any such function will do !    finally , notice that in in the definition of the ` standard form ' @xmath171 of @xmath8 , we needed to enumerate the @xmath179 , for , in general , they will not be finite functions .",
    "this situation , through domain theory , later let girard to consider _ coherence spaces _ , thus leading to the linear decomposition @xmath203 and linear logic @xcite .",
    "in contrast with effective operations , the situation is simpler in the case of oracle computation : because partial recursive functionals are decidedly extensional in their behaviour , the problems that arose in the preceding section vanish .",
    "there is no ` inherent ' parallelism in computing such a functional , and the srt immediately yields least fixed points .",
    "let @xmath75 be a partial recursive functional , and define @xmath204 then @xmath8 is partial recursive .",
    "moreover , there exists @xmath205 such that ( a ) @xmath206 and ( b ) the function @xmath207 of theorem [ thm : cksrt ] produces a code @xmath208 such that @xmath209 .",
    "as @xmath89 is a partial recursive functional , it is also an effective operation on the partial recursive functions , by theorem [ thm : nerode ] .",
    "we define @xmath210 by church s thesis : on input @xmath211 , process the code of @xmath35 with the total extensional function associated to @xmath89 by myhill - shepherdson , and call the resulting code on @xmath54 .",
    "it remains to show minimality .",
    "the proof is by _ strong induction on the length of computations of @xmath214 on its arguments_. suppose @xmath215 .",
    "@xmath89 is effectively continuous , so there exists a finite @xmath216 such that @xmath217 by compactness .",
    "choose a minimal such @xmath218 , and let @xmath219 by construction , the @xmath220 are exactly the ` questions ' with which a turing machine that computes @xmath89 would query the oracle , on input @xmath54 .    by using kleene s srt ,",
    "we have replaced calls to the oracle by recursive calls to another copy of itself !",
    "it follows that the computation of each @xmath221 is strictly shorter in length than the overall computation of @xmath222 .",
    "hence , by the induction hypothesis , @xmath223 for all @xmath130 , and @xmath224 ."
  ],
  "abstract_text": [
    "<S> this is an elementary expository article regarding the application of kleene s recursion theorems in making definitions by recursion . whereas the second recursion theorem ( srt ) is applicable in a first - order setting , the first recursion theorem ( frt ) requires a higher - order setting . in some cases both theorems are applicable , but one is stronger than the other : the frt always produces least fixed points , but this is not always the case with the srt </S>",
    "<S> nevertheless , an old result by rogers allows us to bridge this gap by subtly redefining the implementation of a higher - order functional in order to bring it to a ` standard form . ' </S>"
  ]
}