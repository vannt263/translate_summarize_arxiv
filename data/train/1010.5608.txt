{
  "article_text": [
    "the classic coupon collector problem asks for the expected number of runs to collect a complete set of @xmath1 different coupons while during each run the collector randomly gets a coupon .",
    "the answer is @xmath4 where @xmath5 is the harmonic number @xcite .",
    "one can further ask for the expected number of runs to collect @xmath3 complete sets of coupons , which has been addressed by newman and shepp @xcite .",
    "the coupon collector problem and its variants are of traditional and recurrent interest @xcite . besides of their rich theoretical structures and implications , there are various applications of them as well including dynamic resource allocation , hashing and online load balancing @xcite , to just name a few .",
    "in particular , we want to point out that these problems also serve as basic models to analyze delay for opportunistic scheduling in broadcast wireless fading channels @xcite .",
    "for example , to maximize system throughput , we should serve to the user whose channel condition is the best at every time slot . in order to evaluate performance ,",
    "one may ask about the expected number of time slots needed for all users to be served at least once . assuming all channels are i.i.d . , then this is equivalent to the classic coupon collector problem .    in this paper",
    ", we investigate a natural generalization of the coupon collector problem . instead of getting one coupon",
    ", the collector gets @xmath0 ( @xmath6 ) _ distinct _ coupons randomly each run and he picks one that so far he has the least .",
    "formally , we denote the number of runs ( a `` run '' often referred to a unit of `` time slot '' or simply a unit of `` time '' in this paper ) that are used to collect @xmath3 sets of coupons as @xmath7 and we are interested in characterizing the mean value of this random variable @xmath7 especially in the asymptotic region when @xmath1 is large . clearly , when @xmath8 , we go back to the classic cases ; when @xmath9 , there is no randomness and @xmath10 . in the scheduling transmission context we just discussed ,",
    "@xmath0 can be viewed as a parameter to control the tradeoff between efficiency ( high throughput ) and fairness among all users with @xmath8 purely focusing on efficiency while @xmath9 giving out perfect fairness .    in the remaining part of this paper ,",
    "we first briefly review existing related results in section [ sec : existing ] .",
    "although they are all special cases of the general problem , the techniques used to derive them can not be applied directly to the general case .",
    "instead , we develop a new technique to characterize @xmath11 and provide upper and lower bounds for @xmath11 in section [ lower ] and section [ sec : upper ] .",
    "an asymptotic analysis shows that the upper bound and lower bound match in the asymptotic regime of @xmath12 in section [ sec : approximation ] .",
    "furthermore , for any finite @xmath1 , an algorithm is motivated and proposed in section [ sec : accurate ] to calculate @xmath11 exactly .",
    "finally , we use numerical examples to validate our theoretical predictions in section [ sec : simulation ] .",
    "the existing results on special cases are listed below .",
    "if @xmath8 , then the problem is solved for all @xmath13 . if @xmath14 , then only the @xmath15 case is known .    * @xmath16 ( @xcite ) .",
    "it is clear that the number of runs needed to obtain @xmath17-th coupon after obtaining the @xmath18-th one follows a geometric distribution with parameter @xmath19 .",
    "therefore , @xmath20 for large @xmath1 , @xmath21 one sees that the randomness cost is expressed approximately by a factor @xmath22 .",
    "* @xmath23 ( @xcite ) .",
    "@xmath24 where @xmath25 . + for fixed @xmath3 and large @xmath1 , @xmath26 it is interesting to note that although collecting the first set of coupons needs about @xmath27 runs , all later sets only need @xmath28 runs per set .",
    "* @xmath29 ( @xcite ) .",
    "this has applications in the scheduling of data packets transmission over wireless channels . here",
    "+ @xmath30 + where @xmath31 if @xmath32 .",
    "+ for fixed @xmath3 and large @xmath1 , @xmath33 this shows that for the @xmath15 case , allowing choosing @xmath0 coupons randomly each time decreases the expected number of runs and most of the decreases occurs from @xmath8 to @xmath34 . * @xmath35 . in the mentioned context of scheduling ,",
    "if a transmitter wants to send @xmath3 packets to each of the @xmath1 users , but each time he can only transmits one packet to one user chosen from the @xmath0 users who have the best wireless communication channels . due to the time varying nature of the wireless channels , it is natural to assume that for each time index , the @xmath0 users who have the best communication channels are uniformly distributed among the @xmath1 users",
    "so @xmath36 gives an estimate on the total delay in delivering these @xmath3 packets , and , in this paper , we will offer a characterization of @xmath36 .",
    "we will first lower bound @xmath37 by considering a different coupon collecting process . in this new process , each time we uniformly select @xmath0 distinct coupons out of @xmath1 coupons , and instead of keeping only one coupon out of these @xmath0 selected coupons , we would keep all these @xmath0 coupons .",
    "apparently , the expected time of collecting @xmath3 sets of coupons in this way will be no larger than the process which only keeps one coupon a time .",
    "however , it is not so straightforward to directly get a estimate for this new process . this motivates us to consider another process in which each time , one will collect @xmath0 uniformly , independently chosen ( allowing repeating ) coupons and keep all of them .",
    "this process stops when @xmath3 sets of coupons are fully collected .",
    "[ lem : distinctcloseness ] let @xmath38 be the expected time to collected @xmath3 sets of coupons for the process in which each time @xmath0 uniformly chosen distinct coupons are kept .",
    "let @xmath39 be the expected time to collected @xmath3 sets of coupons for the process in which each time @xmath0 uniformly chosen ( allowing repetition ) coupons are kept .",
    "then    @xmath40    we simulate the process of choosing @xmath0 distinct coupons through an expurgated process of choosing @xmath0 independent coupons ( allowing repetition ) .",
    "if the @xmath0 coupons we independently choose ( allowing repeating ) are not distinct , we will discard this group of @xmath0 coupons ; if they are all distinct @xmath0 coupons , we will keep them .",
    "the kept coupons from expurgated process follow the same distribution as the chosen @xmath0 distinct coupons .",
    "however , the expected time for one to get a group of @xmath0 distinct coupons is clearly @xmath41 .",
    "so in the worst case , @xmath42 .    in summary , in order to give a lower bound on @xmath37 , we will first need a lower bound on @xmath43 for the process of keeping @xmath0 uniformly randomly chosen coupons ( allowing reptition ) . to do this",
    ", we follow the approach of generating functions in @xcite .",
    "let @xmath44 be the probability of failure of obtaining @xmath3 sets of coupons when we have kept @xmath18 coupons .",
    "let @xmath45 be a power series and let @xmath46 be the power series when all terms having all exponents @xmath47 have been removed . by these notations ,",
    "@xmath48 and @xmath49 with @xmath50 all equal to @xmath51 .",
    "in addition , we know @xmath52 where @xmath25 @xcite .",
    "we also notice that @xmath44 is nonincreasing as @xmath18 grows , so @xmath53",
    "so by ( [ eqnud ] ) , we know @xmath54",
    "in this section , we will upper bound the expected time of collecting @xmath3 complete sets of coupons . to achieve this",
    ", we will upper bound the expected time for collecting @xmath3 complete sets of coupons in a suboptimal process . in this new process , each time , we will uniformly and independently choose @xmath0 coupons ( allowing repetition ) . among this group of @xmath0 coupons , we will start looking at them one by one .",
    "if the @xmath18-th ( @xmath55 ) coupon is the first such a coupon that we so far have fewer than @xmath3 copies , then we will keep this @xmath18-th coupon and discard the remaining @xmath56 coupons .",
    "first of all , we observe that @xmath0 distinct coupons are favorable in terms of minimizing the collection time compared with @xmath0 coupons with possible repeating .",
    "[ thm : bound2 ] the minimized expected time of collecting @xmath3 sets of coupons , when each time the coupon collector is given @xmath0 uniformly chosen distinct coupons but is only allowed to keep @xmath51 coupon , is no bigger than the minimized expected time of collecting @xmath3 set of coupons , when each time the coupon collector is given @xmath0 uniformly chosen coupons ( allowing repeating ) but is only allowed to keep @xmath51 coupon .    apparently , when the coupon collector is given @xmath0 distinct coupons , he has more choices in making his decisions .",
    "secondly , we show that it is an optimal strategy for the coupon collector to keep the coupon out of the @xmath0 incoming coupons ( whether allowing repetition or not ) , for which he has the fewest copies .",
    "[ thm : bound1 ] the expected time of collecting @xmath3 sets of coupons is minimized when each time , the coupon collector keeps the coupon which he has the fewest so far , if the coupon collector is allowed to keep only @xmath51 out of the @xmath0 offered coupons .",
    "suppose ( before the coupon collector finishes collecting all @xmath3 sets of coupons ) among the uniformly chosen @xmath0 ( either distinct or allowing repeating ) coupons , the @xmath57-th type of coupon ( there are in total @xmath1 types of coupons and @xmath58 ) is what he has the fewest , say @xmath59 copies .",
    "suppose further that he chooses instead to keep a different type of coupon , say the @xmath60-th ( @xmath61 , @xmath62 ) type of coupon , and , for this type of coupon , the coupon collector has already got @xmath63 copies , where @xmath64 .",
    "immediately , we know that after keeping the @xmath60-th type of coupon , we have at least @xmath65 copies of @xmath60-th type of coupons , which satisfies @xmath66 .",
    "we call the resulting state for the kept coupons as @xmath67 , identified by the tuple @xmath68",
    ". otherwise we would just keep the @xmath57-th type of coupon , then we will have @xmath69 coupons of type @xmath57 and @xmath63 coupons of type @xmath60 .",
    "we call the resulting state in this case as @xmath70 , identified by the tuple @xmath71",
    ".    now we argue that to collect @xmath3 sets of coupons , on average starting from state @xmath70 will take no longer time than starting from state @xmath67 . the main idea is to let the collector starting from @xmath70 follows the strategy of the collector starting from @xmath67 , and do no worse in the expected delay .",
    "let us consider two coupon collectors , one starting from state @xmath67 and the other starting from state @xmath70 .",
    "at each time index , these two collectors get the same @xmath0 coupons",
    ". a coupon collector will keep one coupon only if he has fewer than @xmath3 copies of coupons of that type .",
    "suppose that the coupon collector starting from state @xmath67 follows his optimized `` keeping '' decision such that his expected time to fully collect @xmath3 sets of coupons is minimized",
    ". then we let the coupon collector starting from state @xmath70 follow the same decision process as the coupon collector starting from state @xmath67 , until some time index when the coupon collector starting from state @xmath67 decides to keep a coupon of type @xmath57 or type @xmath60 . at that time index",
    ", we also let the coupon collector starting from state @xmath70 keep the same type of coupon as the coupon collector starting from state @xmath67 does .",
    "then let @xmath72 denote the resulting numbers of kept coupons of type @xmath57 and type @xmath60 , for the collector starting from state @xmath67 ; and likewise define @xmath73 for the collector starting from state @xmath70 .",
    "now we can take an inspection of state @xmath72 and state @xmath73 .",
    "there are two scenarios to discuss separately .    in the first scenario , @xmath74 and it is the coupon of type @xmath57 that the coupon collector decides to keep at that time index",
    ". then @xmath75 and @xmath76 . apparently @xmath72 and @xmath73",
    "are just the permutations of each other , and so by symmetry , the optimized time from these two new states to the completion of collecting @xmath3 sets of coupons will be the same .    in the second scenario",
    ", we have @xmath77 . in this scenario",
    ", we update state @xmath67 as @xmath72 and update state @xmath70 as @xmath73 ; and then construct an iterative process of evolving states @xmath67 and @xmath70 as follows .",
    "( to keep the notations consistent , at the beginning of a new iteration , we always represent state @xmath67 and state @xmath70 by @xmath72 and @xmath73 , even though they are different numbers than in previous iterations .",
    "we also remark that during these iterations , @xmath78 always satisfy the listed constraints ( [ eq : cnst])-([eq : cnst2 ] ) , which will be obvious from the iterative process description . )    at the beginning of each iteration , we have two coupon collectors starting from states @xmath67 and @xmath70 respectively . at each time index",
    ", the coupon collector starting from state @xmath70 will keep the same type of coupon as the coupon collector starting from state @xmath67 , until some run they keep a coupon of either type @xmath57 or type @xmath60 .",
    "again , we have two cases to consider .    in the first case , @xmath79 and it is the coupon of type @xmath57 that the coupon collectors decide to keep at that time index . after keeping that coupon , we have states @xmath80 and @xmath81 for the collectors starting from @xmath67 and starting from @xmath70 , respectively .",
    "so if @xmath82 , then by symmetry , @xmath83 and @xmath80 are two equivalent states , and we are done ( note that @xmath84 ) ; otherwise , if @xmath85 , we update state @xmath67 and @xmath70 as @xmath80 and @xmath86 respectively . in the second case , after keeping that new coupon of type @xmath57 or type @xmath60 , we simply update state @xmath67 and state @xmath70 respectively to record the new numbers of type @xmath57 and type @xmath60 coupons for these two coupon collectors . then we go back to the beginning of another iteration .    note in all these iterations , we always maintain @xmath87 because of this , in each iteration , when the coupon collector starting from @xmath67 can keep a certain type of coupon , the coupon collector starting from state @xmath70 can also keep the same type of coupon . because for every iteration , we will increase @xmath88 and @xmath89 , and",
    "@xmath90 , if we iterate the previous processes , we will eventually run into a pair of symmetric states in some iteration for these two coupon collectors . since we can always end up in a symmetric state for the two coupon collectors , starting from @xmath70 to collect @xmath3 sets of coupons will not take longer time than starting from @xmath67 .",
    "in fact , the previous arguments can essentially show that starting from a state @xmath72 has no bigger expected collection time than from the state @xmath73 , if @xmath91 and @xmath84 .    at this point",
    ", we are ready to present the following upper bound for @xmath37 .",
    "suppose that the coupon collector is given @xmath0 uniformly randomly chosen @xmath0 distinct coupons and he is only allowed to keep one out of these @xmath0 distinct coupons .",
    "then the expected time @xmath92 .    from theorem [ thm : bound1 ] and [ thm : bound2 ]",
    ", we will consider an upper bound on the expected finishing time if each run the coupon collector is given @xmath0 independently chosen coupons ( allowing repeating ) and he decides to keep only the first `` useful '' coupon when it is available among the @xmath0 coupons . here",
    "a kept `` useful '' coupon means this coupon is kept before the coupon collector has @xmath3 copies of that type of coupon .",
    "the idea of the proof is to upper bound the expected finishing time conditioning on a a specific sequence of kept coupons , until we have @xmath3 sets of coupons . by a specific sequence of `` keeper '' coupons , we mean a sequence of kept `` useful '' coupons , specified in their types and the order of keeping them .",
    "we note that a specific sequence of `` keeper '' coupons contain @xmath93 coupons .",
    "first we make a key observation about the probability that the coupon collector follows a specific sequence of `` keeper '' coupons",
    ". this probability will be the same as the corresponding probability that he follows this specific sequence of kept coupons , in another collection process where each run he is only offered @xmath51 instead of @xmath0 independently , uniformly chosen coupons .",
    "this is because , when the coupon collector is offered @xmath0 coupons , he still checks them one by one and only keeps the first one that is `` useful '' .",
    "now , conditioning on a specific sequence of kept coupons , we are interested in the expected time to collect that sequence .",
    "suppose that right after the @xmath94-th coupon in this `` keeper '' sequence has just been kept , there are @xmath95 types of coupons for which the coupon collector have @xmath3 copies .",
    "we then want to know what is the expected number of runs needed to collect the next @xmath96-th `` keeper '' coupon , conditioning on the whole `` keeper '' coupon sequence is known .    through the conditional event that the `` keeper '' sequence has already specified",
    ", it is a standard exercise to show that the average time the coupon collector takes to collect the @xmath96-th `` keeper '' coupon will be @xmath97    in fact , conditioned on the fact that the next `` keeper '' coupon is already specified , unless the next inspected coupon belongs to the @xmath95 types of coupons for which the collector has already had @xmath3 copies , it must be the @xmath96-th `` keeper '' coupon .",
    "so conditioned on the already specified next `` keeper '' ( the same as conditioned on the whole `` keeper '' sequence is known , because the collecting process is a markov chain ) , a uniformly chosen coupon is the specified `` keeper '' with probability @xmath98 .",
    "so conditioned on the @xmath96-th `` keeper '' is known , with probability @xmath99 , none of the @xmath0 uniformly chosen ( allowing repeating ) coupons is the known @xmath96-th `` keeper ''",
    ".    however , we note that if the coupon collector is only offered @xmath51 instead of @xmath0 coupons each time , then the expected time to get the @xmath96-th coupon in that sequence on average will be @xmath100    by lemma [ lem : asymptotics0 ] proven latter than , we know that @xmath101 for any @xmath102 .    since there are exactly @xmath93 coupons in any specific sequence of `` keeper '' coupons , the total expected time @xmath103 for collecting a whole `` keeper '' sequence @xmath104 , when each time the coupon collector has @xmath0 coupons ( allowing repeating ) to choose from , and the total expected time @xmath105 for collecting the same `` keeper '' sequence @xmath104 , when each time the coupon collector only has @xmath51 incoming random coupon , satisfy @xmath106    by invoking the fact that the coupon collector follows any specific sequence of `` keeper '' coupons with the same probability for both the @xmath8 case and the @xmath107 , ( [ eqn5 ] ) implies @xmath108 for any @xmath0 , which is exactly the theorem statement .",
    "[ lem : asymptotics0 ] function @xmath109 is decreasing for @xmath110 ; and , @xmath111 for @xmath110 .",
    "* we need to show that the derivative @xmath112 for @xmath113 $ ] .",
    "let @xmath114 so @xmath115    also let @xmath116 so @xmath117 and @xmath118 for @xmath119 . because @xmath120 we have @xmath121 this translates into @xmath122 so @xmath123 namely @xmath124 plugging in @xmath125 , we have @xmath126 so @xmath127 calculating @xmath128 , we have @xmath129",
    "in this section , we will give an asymptotic analysis of the upper and lower bounds for @xmath131 and see how it behaves asymptotically for fixed @xmath0 and @xmath3 as @xmath1 goes to @xmath132 .",
    "we will begin with an asymptotic analysis through an exact expression for @xmath133 .",
    "[ thm : asymptotics0 ] when @xmath1 is large enough and @xmath14 , @xmath134=n\\left(\\frac{\\log n}{d}+o(1)\\right)\\ ] ]    * proof . *",
    "@xmath135\\\\ & = & \\sum_{i=0}^{n-1}\\frac{1}{1-\\frac{{i \\choose d}}{{n \\choose d } } } = \\sum_{i=0}^{n-1}\\frac{1}{1-\\frac{i(i-1)\\ldots(i - d+1)}{n(n-1)\\ldots(n - d+1)}}\\\\ & \\geq & d+\\sum_{i = d}^{n-1}\\frac{1}{1-\\left(\\frac{i - d+1}{n - d+1}\\right)^d}\\\\ % & = & \\sum_{i=1}^{n}\\frac{1}{1-\\left(\\frac{n - d+1-i}{n - d+1}\\right)^d } =   \\sum_{i=1}^{n}\\frac{1}{1-\\left(1-\\frac{i}{n - d+1}\\right)^d}\\\\ & = & d+\\sum_{i=1}^{n - d}\\frac{1}{1-\\left(1-\\frac{i}{n - d+1}\\right)^d}. % & = & \\sum_{i=1}^{n}\\frac{1}{1-\\sum_{j=0}^d { d \\choose j } ( -\\frac{i}{n - d+1})^j}\\\\ % & = & \\sum_{i=1}^{n}\\frac{1}{-\\sum_{j=1}^d { d \\choose j } ( -\\frac{i}{n - d+1})^j}\\end{aligned}\\ ] ]    since @xmath136 for @xmath137 , @xmath138 as @xmath130 .    @xmath139    [ thm : asymptoticsnlarge ] when @xmath3 is fixed , then for any @xmath14 , @xmath140    * proof .",
    "* from the lower bound and upper bound for @xmath11 in section [ lower ] and section [ sec : upper ] , we know @xmath141 then the asymptotic expression emerges immediately by recalling the asymptotic expression for @xmath142 .",
    "in this section , we will give an algorithm which calculates exactly @xmath37 for specified @xmath3 , @xmath1 and @xmath0 based on a state - space representation of the markov process of collecting the coupons .",
    "for each @xmath143 satisfying @xmath144 , define @xmath145 to be the state where @xmath146 ( @xmath147 ) is the number of coupons that the coupon collector has collected @xmath18 times .",
    "hence , @xmath148 is the expected number of runs for the coupon collector to go from state @xmath149 to state @xmath150 .",
    "[ sec : accurate ] we now provide an algorithm to calculate @xmath11 .",
    "define @xmath151 clearly , @xmath152    suppose we are at state @xmath145 .",
    "after one run , the transition probability from @xmath153 to the following two states are as follows ( w.p . is abbreviation for `` with probability '' ) : @xmath154 where @xmath155 .",
    "therefore , we have the equation @xmath156\\\\ & = & 1 + { { n_m } \\choose d}/{n \\choose d } \\times e[n_m^d(n_0,\\cdots , n_m)]\\\\ & + & \\sum\\limits_{i=0}^{m-1}p_i e[n_m^d(n_0,\\cdots , n_i-1,n_{i+1}+1,\\cdots , n_m)].\\end{aligned}\\ ] ] so @xmath156\\nonumber\\\\ & = & \\frac{{n \\choose d}}{{n \\choose d}-{{n_m } \\choose d } } \\nonumber\\\\ & & \\sum\\limits_{i=0}^{m-1}\\left ( \\frac{{{\\sum_{t = i}^m n_t } \\choose d}-{{\\sum_{t = i+1}^m n_t } \\choose d}}{{n \\choose d}-{{n_m } \\choose d } } \\right)\\label{eqn4}\\\\ & & \\times e[n_m^d(n_0,\\cdots , n_i-1,n_{i+1}+1,\\cdots , n_m)].\\nonumber\\end{aligned}\\ ] ]    define map @xmath157 , where @xmath158 obviously , @xmath159 is an injection and @xmath160 since @xmath161 by ( [ eqn4 ] ) , the expected number of runs from a state @xmath104 only depends on the expected number of runs from states @xmath162 s with @xmath163 .",
    "therefore , we can order all the states @xmath164 according to the value of @xmath165 and compute @xmath166 $ ] one by one , from the starting state @xmath167 to the last state @xmath168 .",
    "the algorithm is described in algorithm [ algorithm 1 ] .",
    "@xmath169=0\\\\ \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\text{\\textbf{else } \\ \\ use equation ( \\ref{eqn4 } ) to compute}\\\\ \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ ; \\ e[n_m^d(n_0,\\cdots , n_m ) ] \\end{array}\\ ] ]    since the number of non - negative integer solutions to the equation @xmath170 is @xmath171 , the number of states is @xmath171 , and the complexity of algorithm [ algorithm 1 ] is @xmath172 .    to conclude this section",
    ", we now use a simple example ( @xmath173 ) to illustrate algorithm [ algorithm 1 ] .",
    "when @xmath174 , each state has @xmath175 parameters @xmath176 , @xmath177 , and @xmath178 . since @xmath179 , we could draw the state transition diagram as in figure [ fig10 ] .",
    "algorithm [ algorithm 1 ] computes @xmath180 $ ] for each state @xmath181 by the order shown in figure [ fig20 ] .",
    "this is right because    * the expected number of runs from any state only depends on the number of runs from its descents in figure [ fig10 ] .",
    "* the computation of @xmath182 $ ] for any state is done after the computations for its descents by figure [ fig20 ] .",
    "the values of @xmath180 $ ] for each state @xmath181 is shown in figure [ fig30 ] .",
    "we now engage in numerical exercises to support results in the last two sections , i.e. correctness of algorithm [ algorithm 1 ] and the derived upper and lower bounds on @xmath36 .",
    "first , we give numerical results for the expected collection time when @xmath183 and @xmath184 respectively , in three tables .",
    "the results show that algorithm [ algorithm 1 ] gives an expected delay consistent with the simulation results .    .@xmath15,@xmath183",
    "[ cols=\"^,^,^,^,^,^ \" , ]      two cases are considered : @xmath185 and @xmath186 . for each case , three lines are plotted .",
    "first , the lower bound from theorem [ thm : bound1 ] is plotted .",
    "second , the upper bound is from theorem [ thm : bound2 ] is computed .",
    "finally , both plots are compared against the result computed from the algorithm for @xmath1 from @xmath187 to @xmath188 .",
    "the results show that the upper bound and lower bound bound the expected collecting time very well . in fact , when @xmath3 and @xmath0 are fixed , the upper bound and lower bound will both scale as @xmath189 as @xmath12 .    , @xmath190 .",
    "]    , @xmath190 . ]",
    "in this paper , we considered a generalized coupon collector problem where the coupon collector needs to collect @xmath13 sets of coupons and has the freedom of keeping one coupon out of @xmath191 coupons offered each time .",
    "we obtained asymptotically matching upper and lower bounds for the expected collection time .",
    "we also provided an algorithm to calculate the expected collection time exactly based on a state representation for the coupon collecting process .",
    "we should note that asymptotically even if the coupon collector is only allowed to keep @xmath51 coupon out of the @xmath0 coupons , the needed time will still be shortened by a factor of @xmath0 , as if the coupon collector is allowed to keep all the @xmath0 coupons offered each time .",
    "there is much avenue for future work on this problem .",
    "first , one could attempt to get a closed - form expression for @xmath36 .",
    "second , one could attempt to improve algorithm 1 .",
    "algorithm 1 has a runtime of @xmath171 . to take advantage of this runtime requires constant time indexing .",
    "the direct approach is to index the states in an @xmath1-dimensional matrix of size @xmath192 .",
    "however , since there are a total of @xmath171 states , a large fraction of the matrix space is not required .",
    "hence , it would be helpful to find an algorithm which carries out triangular indexing in constant time .",
    "this would reduce the memory requirements and increase the range of parameters over which the problem is computationally feasible .",
    "one could further observe that although there are @xmath171 states , only @xmath193 are actually needed at any time .",
    "so with constant time triangular indexing , one can reduce the memory requirements further although the gain from the second reduction is minimal .",
    "the research is supported by nsf under ccf-0835706 .",
    "the authors would like to thank the input of wuhan desmond cai ."
  ],
  "abstract_text": [
    "<S> this paper provides analysis to a generalized version of the coupon collector problem , in which the collector gets @xmath0 coupons each run and he chooses the one that he has the least so far . in the asymptotic case when the number of coupons @xmath1 goes to infinity , </S>",
    "<S> we show that on average @xmath2 runs are needed to collect @xmath3 sets of coupons . an efficient exact algorithm is also developed for any finite case to compute the average needed runs exactly . </S>",
    "<S> numerical examples are provided to verify our theoretical predictions . </S>"
  ]
}