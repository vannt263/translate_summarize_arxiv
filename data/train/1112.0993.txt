{
  "article_text": [
    "a priority queue is a fundamental data structure that maintains a set of elements and supports the operations , , , , , and . in the comparison - based model , from the @xmath2 lower bound for sorting it follows",
    "that , if can be performed in @xmath3 time , must take @xmath4 time .",
    "also , if can be performed in @xmath5 time , must take @xmath6 time @xcite .",
    "in addition , if can be performed in constant time , would not be asymptotically faster than . based on these observations ,",
    "a priority queue is said to provide _",
    "optimal time bounds _ if it can support , , , and in constant time ; and and in @xmath7 time , where @xmath1 denotes the number of elements stored .    after the introduction of binary heaps @xcite , which are not optimal with respect to all priority - queue operations , an important turning point was when fredman and tarjan introduced fibonacci heaps @xcite .",
    "fibonacci heaps provide optimal time bounds for all standard operations in the amortized sense .",
    "driscoll et al .",
    "@xcite introduced run - relaxed heaps , which have optimal time bounds for all operations in the worst case , except for .",
    "later , kaplan and tarjan @xcite ( see also @xcite ) introduced fat heaps , which guarantee the same worst - case bounds as run - relaxed heaps . on the other side ,",
    "brodal @xcite introduced meldable priority queues , which provide the optimal worst - case time bounds for all operations , except for .",
    "later , by introducing several innovative ideas , brodal @xcite was able to achieve the worst - case optimal time bounds for all operations .",
    "though deep and involved , brodal s data structure is complicated and should just be taken as a proof of existence .",
    "kaplan et al .",
    "@xcite said the following about brodal s construction : `` this data structure is very complicated however , much more complicated than fibonacci heaps and the other meldable heap data structures '' . to appreciate the conceptual simplicity of our construction ,",
    "we urge the reader to scan through brodal s paper @xcite . on the other side",
    ", we admit that while trying to simplify brodal s construction , we had to stick with many of his innovative ideas .",
    "we emphasize that in this paper we are mainly interested in the theoretical performance of the priority queues discussed .",
    "however , some of our ideas may be of practical value .",
    "most priority queues with worst - case constant , including the one to be presented by us , rely on the concept of _ violation reductions_. a _ violation _ is a node that may , but not necessarily , violate the heap order by being smaller than its parent . when the number of violations becomes high , a violation reduction is performed in constant time to reduce the number of violations .",
    "a _ numeral system _ is a notation for representing numbers in a consistent manner using symbols_digits_. in addition , operations on these numbers , as increments and decrements of a given digit , must obey the rules governing the numeral system .",
    "there is a connection between numeral systems and data - structural design @xcite .",
    "the idea is to relate the number of objects of a specific type in the data structure to the value of a digit .",
    "a representation of a number that is subject to increments and decrements of arbitrary digits can be called a _",
    "counter_. a _ regular counter _",
    "@xcite uses the digits @xmath8 in the representation of a number and imposes the rule that between any two @xmath9 s there must be a @xmath10 .",
    "such a counter allows for increments ( and also decrements , under the assumption that the digit being decreased was non - zero ) of arbitrary digits with a constant number of digit changes per operation . for an integer @xmath11 ,",
    "an _ extended regular @xmath12-ary counter _ uses the digits @xmath13 with the constraints that between any two @xmath14 s there is a digit other than @xmath12 , and between any two @xmath10 s there is a digit other than @xmath15 .",
    "an extended regular counter @xcite allows for increments and decrements of arbitrary digits with a constant number of digit changes per operation .",
    "kaplan and tarjan @xcite ( see also @xcite ) introduced fat heaps as a simplification of brodal s worst - case optimal priority queues , but these are not meldable in @xmath16 worst - case time . in fat heaps ,",
    "an extended regular ternary counter is used to maintain the trees in each heap and an extended regular binary counter to maintain the violation nodes . in this paper , we describe yet another simplification of brodal s construction .",
    "one of the key ingredients in our construction is the utilization of extended regular binary counters . throughout our explanation of the data structure ,",
    "in contrary to @xcite , we distinguish between the operations of the numeral system and other priority - queue operations .",
    "our motives for writing this paper were the following .    1 .",
    "we simplify brodal s construction and devise a priority queue that provides optimal worst - case bounds for all operations (  @xmath9 and  @xmath17 ) .",
    "the gap between the description complexity of worst - case optimal priority queues and binary heaps @xcite is huge .",
    "one of our motivations was to narrow this gap .",
    "we describe a strikingly simple implementation of the extended regular counters (  4 ) . in spite of their importance for many applications , the existing descriptions @xcite for such implementations are sketchy and incomplete .",
    "3 .   with this paper",
    ", we complete our research program on the comparison complexity of priority - queue operations .",
    "all the obtained results are summarized in table  [ table : results ] .",
    "elsewhere , it has been documented that , in practice , worst - case efficient priority queues are often outperformed by simpler non - optimal priority queues . due to the involved constant factors in the number of element comparisons , this is particularly true if one aims at developing priority queues that achieve optimal time bounds for all the standard operations .",
    ".the best - known worst - case comparison complexity of different priority - queue operations .",
    "the worst - case performance of is the same as that of . using **",
    "indicates that the operation is not supported optimally .",
    "[ table : results ] [ cols=\"<,^,^,^,^,^\",options=\"header \" , ]     it is a long - standing open issue how to implement a heap on a pointer machine such that all operations are performed in optimal time bounds .",
    "a fibonacci heap is known to achieve the optimal bounds in the amortized sense on a pointer machine @xcite , a fat heap in the worst case provided that is not supported @xcite , and the meldable heap in @xcite provided that is supported in @xmath7 time . in this paper , we offer a pointer - machine implementation for which and are supported in @xmath18 worst - case time .",
    "let us begin with a high - level description of the data structure .",
    "the overall construction is similar to that used in @xcite .",
    "however , the use of extended regular counters is new . in accordance ,",
    "the rank rules , and hence the structure , are different from @xcite .",
    "the set of violation - reduction routines are in turn new .    [ 0.14ex][0.14ex]1  : :    if @xmath19 exists , @xmath20 .",
    "[ 0.14ex][0.14ex]2  : :    an extended regular binary counter is used to keep track of the    children of each of @xmath21 and @xmath19 . [ 0.14ex][0.14ex]3  : :    for each node , including @xmath21 and @xmath19 , its    rank sequence    @xmath22    must obey the following rules : for all    @xmath23 ( i )    @xmath24 and ( ii ) if @xmath25 , then    @xmath26 or @xmath27 or    @xmath28 .",
    "[ 0.14ex][0.14ex]4  : :    each node guards a list of violations ; @xmath21 guards two :    one containing active violations and another containing inactive    violations .",
    "[ 0.14ex][0.14ex]5  : :    the active violations of @xmath21 are kept in a violation    structure consisting of a resizable array , in which the    @xmath29th entry refers to violations of rank @xmath29 ,    and a doubly - linked list linking the entries of the array that have    more than two violations .",
    "for an illustration of the data structure , see fig .",
    "[ fig : abstract ] .",
    "each priority queue is composed of two multi - way trees @xmath30 and @xmath31 , with roots @xmath21 and @xmath19 respectively ( @xmath31 can be empty ) .",
    "the atomic components of the priority queues are nodes , each storing a single element .",
    "the _ rank _ of a node @xmath32 , denoted @xmath33 , is an integer that is logarithmic in the size ( number of nodes ) of the subtree rooted at @xmath32 .",
    "the rank of a subtree is the rank of its root .",
    "the trees @xmath30 and @xmath31 are heap ordered , except for some violations ; but , the element at @xmath21 is the minimum among the elements of the priority queue .",
    "if @xmath19 exists , the rank of @xmath21 is less than that of @xmath19 , i.e.  @xmath34 .    with each priority queue , a _ violation structure _",
    "is maintained ; an idea that has been used before in @xcite .",
    "this structure is composed of a resizable array , called _ violation array _ , in which the @xmath29th entry refers to violations of rank @xmath29 , and a doubly - linked list , which links the entries of the array that have more than two violations each .",
    "similar to @xcite , each violation is guarded by a node that has a smaller element .",
    "hence , when a minimum is deleted , not all the violations need to be considered as the new minimum candidates .",
    "to adjust this idea for our purpose , the violations guarded by @xmath21 are divided into two groups : the so - called _ active violations _ are used to perform violation reductions , and the so - called _ inactive violations _ are violations whose ranks were larger than the size of the violation array at the time when the violation occurred .",
    "all the active violations guarded by @xmath21 , besides being kept in a doubly - linked list , are also kept in the violation structure ; all inactive violations are kept in a doubly - linked list .    any node @xmath32 other than @xmath21 only guards a single list of @xmath7 violations .",
    "these are the violations that took place while node @xmath32 stored the minimum of its priority queue .",
    "such violations must be tackled once the element associated with node @xmath32 is deleted .",
    "in particular , in the whole data structure there can be up to @xmath35 violations , not @xmath7 violations as in run - relaxed heaps and fat heaps .",
    "when a violation is introduced , there are two phases for handling it accordingly to whether the size of the violation array is as big as the largest rank or not . during the first phase ,",
    "the following actions are taken .",
    "1 ) the new violation is added to the list of inactive violations .",
    "2 ) the violation array is extended by a constant number of entries . during the second phase ,",
    "the following actions are taken .",
    "1 ) the new violation is added to the list of active violations and to the violation structure .",
    "2 ) a violation reduction is performed if possible .",
    "the children of a node are stored in a doubly - linked list in non - decreasing rank order .",
    "in addition to an element , each node stores its rank and six pointers pointing to : the left sibling , the right sibling ( the parent if no right sibling exists ) , the last child ( the rightmost child ) , the head of the guarded violation list , and the predecessor and the successor in the violation list where the node may be in . to decide whether the right - sibling pointer of a node @xmath32 points to a sibling or a parent , we locate the node @xmath36 pointed to by the right - sibling pointer of @xmath32 and check if the last - child pointer of @xmath36 points back to @xmath32 .",
    "next , we state the rank rules implying the structure of the multi - way trees :    ( a ) : :    the rank of a node is one more than the rank of its last child .",
    "the    rank of a node that has no children is @xmath10 .",
    "( b ) : :    the _ rank sequence _ of a node specifies the multiplicities of the    ranks of its children .",
    "if the rank sequence has a digit    @xmath37 , the node has @xmath37 children of rank    @xmath29 .",
    "the rank sequences of @xmath21 and    @xmath19 are maintained in a way that allows adding and    removing an arbitrary subtree of a given rank in constant time .",
    "this    is done by having the rank sequences of those nodes obey the rules of    a numeral system that allows increments and decrements of arbitrary    digits with a constant number of digit changes per operation .",
    "when we    add a subtree or remove a subtree from _ below _ @xmath21 or    @xmath19 , we also do the necessary actions to reestablish the    constraints imposed by the numeral system .",
    "( c ) : :    consider a node @xmath32 that is not @xmath21 ,    @xmath19 , or a child of @xmath21 or    @xmath19",
    ". if the rank of @xmath32 is @xmath29 ,    there must exist at least one sibling of @xmath32 whose rank is    @xmath38 , @xmath29 or @xmath39 .",
    "note that    this is a relaxation to the rules applied to the rank sequences of    @xmath21 and @xmath19 , for which the same rule also    applies @xcite .",
    "in addition , the number of siblings having the same    rank is upper bounded by at most three .    among the children of a node , there are consecutive subsequences of nodes with consecutive , and possibly equal , ranks .",
    "we call each maximal subsequence of such nodes a _ group_. by our rank rules , a group has at least two _",
    "members_. the difference between the rank of a member of a group and that of another group is at least two , otherwise both constitute the same group .",
    "[ log ] the rank and the number of children of any node in our data structure is @xmath40 , where @xmath1 is the size of the priority queue .    we prove by induction that the size of a subtree of rank @xmath29 is at least @xmath41 , where @xmath41 is the @xmath29th fibonacci number .",
    "the claim is clearly true for @xmath42 .",
    "consider a node @xmath32 of rank @xmath43 , and assume that the claim holds for all values smaller than @xmath29 .",
    "the last child of @xmath32 has rank @xmath38 .",
    "our rank rules imply that there is another child of rank at least @xmath44 . using the induction hypothesis ,",
    "the size of these two subtrees is at least @xmath45 and @xmath46 .",
    "then , the size of the subtree rooted at @xmath32 is at least @xmath47 .",
    "hence , the maximum rank of a node is @xmath48 . by the rank rules , every node has at most three children of the same rank .",
    "it follows that the number of children per node is @xmath7 .",
    "two trees of rank @xmath29 can be _ joined _ by making the tree whose root has the larger value the last subtree of the other .",
    "the rank of the resulting tree is @xmath39 .",
    "alternatively , a tree rooted at a node @xmath32 of rank @xmath39 can be _ split _ by detaching its last subtree .",
    "if the last group among the children of @xmath32 now has one member , the subtree rooted at this member is also detached .",
    "the rank of @xmath32 becomes one more than the rank of its current last child . in accordance",
    ", two or three trees result from a _ split _ ; among them , one has rank @xmath29 and another has rank @xmath38 , @xmath29 , or @xmath39 .",
    "join _ and _ split _ operations are used to maintain the constraints imposed by the numeral system .",
    "note that one element comparison is performed with the _ join _ operation , while the _ split _ operation involves no element comparisons .",
    "one complication , also encountered in @xcite , is that not all violations can be recorded in the violation structure .",
    "the reason is that , after a , the violation array may be too small when the old @xmath21 with the smaller rank becomes the new @xmath21 of the melded priority queue .",
    "assume that we have a violation array of size @xmath49 associated with @xmath21 .",
    "the priority queue may contain nodes of rank @xmath50 .",
    "hence , violations of rank @xmath29 can not be recorded in the array .",
    "we denote the violations that are recorded in the violation array as active violations and those that are only in the violation list as inactive violations .",
    "violation reductions are performed on active violations whenever possible . throughout the lifetime of @xmath21 ,",
    "the array is incrementally extended by the upcoming priority - queue operations until its size reaches the largest rank .",
    "once the array is large enough , no new inactive violations are created . since each priority - queue operation",
    "can only create a constant number of violations , the number of inactive violations is @xmath7 .",
    "the violation structures can be realized by letting each node have one pointer to its violation list , and two pointers to its predecessor and successor in the violation list where the node itself may be in . by maintaining all active violations of the same rank consecutively in the violation list of @xmath21",
    ", the violation array can just have a pointer to the first active violation of any particular rank .    in connection with every or ,",
    "if @xmath31 exists , a constant number of subtrees rooted at the children of @xmath19 are removed from below @xmath19 and added below @xmath21 .",
    "once @xmath51 , the whole tree @xmath31 is added below @xmath21 . to be able to move all subtrees from below @xmath19 and finish the job on time , we should always pick a subtree from below @xmath19 whose rank equals the current rank of @xmath21",
    ".    the priority queue operations aim at maintaining the following invariants :    1 .",
    "the minimum is associated with @xmath21 .",
    "the second - smallest element is either stored at @xmath19 , at one of the children of @xmath21 , or at one of the violation nodes associated with @xmath21 .",
    "the number of entries in the violation list of a node is @xmath7 , assuming that the priority queue that contains this node has @xmath1 elements .",
    "we are now ready to describe how the priority - queue operations are realized .",
    "@xmath52 : : :    following the first invariant , the minimum is at @xmath21 .",
    "@xmath53 : : :    a new node @xmath32 is given with the value @xmath54 . if    @xmath54 is smaller than the value of @xmath21 , the    roles of @xmath32 and @xmath21 are exchanged by    swapping the two nodes . the node @xmath32 is then added below    @xmath21 . @xmath55",
    ": : :    this operation involves at most four trees @xmath30 ,    @xmath31 , @xmath56 , and @xmath57 , two for    each priority queue ; their roots are named correspondingly using    lower - case letters .",
    "assume without loss of generality that    @xmath58 .",
    "the tree @xmath30    becomes the first tree of the melded priority queue .",
    "the violation    array of @xmath59 is dismissed .",
    "if @xmath30 has the    maximum rank , the other trees are added below @xmath21    resulting in no second tree for the melded priority queue .",
    "otherwise ,    the tree with the maximum rank among @xmath60 , and    @xmath61 becomes the second tree of the melded priority    queue .",
    "the remaining trees are added below the root of this tree , and    the roots of the added trees are made violating . to keep the number of    active violations within the threshold",
    ", two violation reductions are    performed if possible .",
    "finally , the regular counters that are no    longer corresponding to roots are dismissed .",
    "@xmath62 : : :    the element at node @xmath32 is replaced by element    @xmath54 . if @xmath54 is smaller than the element at    @xmath21 , the roles of @xmath32 and @xmath21    are exchanged by swapping the two nodes ( but not their violation    lists ) . if @xmath32 is either @xmath21 ,    @xmath19 , or a child of @xmath21 , stop .",
    "otherwise ,    @xmath32 is denoted violating and added to the violation    structure of @xmath21 ; if @xmath32 was already    violating , it is removed from the violation structure where it was in .    to keep the number of active violations within the threshold , a    violation reduction is performed if possible .",
    "@xmath52 : : :    by the first invariant , the minimum is at @xmath21 .",
    "the node    @xmath19 and all the subtrees rooted at its children are    added below @xmath21 .",
    "this is accompanied with extending the    violation array of @xmath30 , and dismissing the regular    counter of @xmath31 . by the second invariant , the new minimum",
    "is now stored at one of the children or violation nodes of    @xmath21 . by lemma [ log ] and the third invariant ,",
    "the number    of minimum candidates is @xmath40 .",
    "let @xmath32    be the node with the new minimum .",
    "if @xmath32 is among the    violation nodes of @xmath21 , a tree that has the same rank as    @xmath32 is removed from below @xmath21 , its root is    made violating , and is attached in place of the subtree rooted at    @xmath32 .",
    "if @xmath32 is among the children of    @xmath21 , the tree rooted at @xmath32 is removed from    below @xmath21 .",
    "the inactive violations of @xmath21    are recorded in the violation array .",
    "the violations of @xmath32    are also recorded in the array .",
    "the violation list of    @xmath21 is appended to that of @xmath32 .",
    "the node    @xmath21 is then deleted and replaced by the node    @xmath32 .",
    "the old subtrees of @xmath32 are added , one by    one , below the new root . to keep the number of violations within the    threshold , violation reductions are performed as many times as    possible . by the third invariant , at most @xmath40    violation reductions are to be performed .",
    "@xmath53 : : :    the node @xmath32 is swapped with @xmath21 , which is    then made violating . to remove the current root @xmath32 ,",
    "the    same actions are performed as in .    in our description , we assume that it is possible to dismiss an array in constant time .",
    "we also assume that the doubly - linked list indicating the ranks where a reduction is possible is realized inside the violation array , and that a regular counter is compactly represented within an array .",
    "hence , the only garbage created by freeing a violation structure or a regular counter is an array of pointers .",
    "if it is not possible to dismiss an array in constant time , we rely on incremental garbage collection .",
    "in such case , to dismiss a violation structure or a regular counter , we add it to the garbage pile , and release a constant amount of garbage in connection with every priority - queue operation .",
    "it is not hard to prove by induction that the sum of the sizes of the violation structures , the regular counters , and the garbage pile remains linear in the size of the priority queue .",
    "each time when new violations are introduced , we perform equally many violation reductions whenever possible .",
    "a violation reduction is possible if there exists a rank recording at least three active violations .",
    "this will fix the maximum number of active violations at @xmath7 .",
    "our violation reductions diminish the number of violations by either getting rid of one violation , getting rid of two and introducing one new violation , or getting rid of three and introducing two new violations .",
    "we use the powerful tool that the rank sequence of @xmath21 obey the rules of a numeral system , which allows adding a new subtree or removing an existing one from below @xmath21 in worst - case constant time .",
    "when a subtree with a violating root is added below @xmath21 , its root is no longer violating .",
    "one consequence of allowing @xmath35 violations is that we can not use the violation reductions exactly in the form described for run - relaxed heaps or fat heaps . when applying the cleaning transformation to a node of rank @xmath29 ( see @xcite for the details ) ,",
    "we can not any more be sure that its sibling of rank @xmath39 is not violating , simply because there can be violations that are guarded by other nodes .",
    "we then have to avoid executing the cleaning transformation by the violation reductions .",
    "let @xmath63 , @xmath64 , and @xmath65 be three violations of the same rank @xmath29 .",
    "we distinguish several cases to be considered when applying our reductions :    case 1 .",
    ": :    if , for some @xmath66 , @xmath67 is    neither the last nor the second - last child , detach the subtree rooted    at @xmath67 from its parent and add it below    @xmath21 .",
    "the node @xmath67 will not be anymore    violating .",
    "the detachment of @xmath67 may leave one or two    groups with one member ( but not the last group ) .",
    "if this happens , the    subtree rooted at each of these singleton members is then detached and    added below @xmath21 .",
    "( we can still detach the subtree of    @xmath67 even when @xmath67 is one of the last two    children of its parent , conditioned that such detachment leaves this    last group with at least two members and retains the rank of the    parent . )    for the remaining cases , after checking case @xmath15 , we assume that each of @xmath68 , and @xmath65 is either the last or the second - last child of its parent .",
    "let @xmath69 , @xmath70 , and @xmath71 be the other member of the last two members of the groups of @xmath63 , @xmath64 , and @xmath65 , respectively .",
    "let @xmath72 , @xmath73 , and @xmath74 be the parents of @xmath63 , @xmath64 , and @xmath65 , respectively . assume without loss of generality that @xmath75 .    case 2 .",
    ": :    @xmath76 ,    or    @xmath77 ,    or @xmath78 and    @xmath79 :    +    ( a ) ; ;      @xmath80 : detach the subtrees rooted      at @xmath63 and @xmath64 , and add them below      @xmath21 ; this reduces the number of violations by two .",
    "detach the subtree rooted at @xmath70 and attach it below      @xmath72 ( retain rank order ) ; this does not introduce any      new violations . detach the subtree rooted at the last child of      @xmath73 if it is a singleton member , detach the remainder      of the subtree rooted at @xmath73 , change the rank of      @xmath73 to one more than that of its current last child ,      and add the resulting subtrees below @xmath21 . remove a      subtree with the old rank of @xmath73 from below      @xmath21 , make its root violating , and attach it in the old      place of the subtree rooted at @xmath73 .",
    "( b ) ; ;      @xmath81 : change the roles of      @xmath82 and @xmath83 , and apply      the same actions as in case 2(a ) .",
    ": :    @xmath84 and    @xmath85 :    +    ( a ) ; ;      @xmath80 : apply the same actions as      in case 2(a ) .",
    "( b ) ; ;      @xmath81 : detach the subtrees rooted at      @xmath63 and @xmath64 , and add them below      @xmath21 ; this reduces the number of violations by two .",
    "detach the subtree rooted at @xmath70 if it becomes a      singleton member of its group , detach the remainder of the subtree      rooted at @xmath73 , change the rank of @xmath73 to      one more than that of its current last child , and add the resulting      subtrees below @xmath21 .",
    "detach the subtree rooted at      @xmath69 , and attach it in the old place of the subtree      rooted at @xmath73 ; this does not introduce any new      violations .",
    "detach the subtree rooted at the current last child of      @xmath72 if such child becomes a singleton member of its      group , detach the remainder of the subtree rooted at      @xmath72 , change the rank of @xmath72 to one more      than that of its current last child , and add the resulting subtrees      below @xmath21 .",
    "remove a subtree of rank @xmath86      from below @xmath21 , make its root violating , and attach it      in the old place of the subtree rooted at @xmath72 .",
    ": :    @xmath87 :    +    assume without loss of generality that @xmath88 .",
    "detach the subtrees of    @xmath89 , and @xmath65 , and add them below    @xmath21 ; this reduces the number of violations by three .",
    "detach the subtrees of @xmath70 and @xmath71 , and    join them to form a subtree of rank @xmath29 .",
    "attach the    resulting subtree in place of @xmath63 ; this does not    introduce any new violations . detach the subtree rooted at the current    last child of each of @xmath73 and @xmath74 if such    child becomes a singleton member of its group , detach the remainder of    the subtrees rooted at @xmath73 and @xmath74 , change    the rank of each of @xmath73 and @xmath74 to one    more than that of its current last child , and add the resulting    subtrees below @xmath21 . remove two subtrees of rank    @xmath39 from below @xmath21 , make the roots of each    of them violating , and attach them in the old places of the subtrees    rooted at @xmath73 and @xmath74 .",
    ": :    @xmath84 and    @xmath90 :    +    ( a ) ; ;      @xmath91 : apply      same actions as case 4 .",
    "( b ) ; ;      @xmath81 : apply the same actions as in      case 3(b ) .",
    "( c ) ; ;      @xmath92 : change the roles of      @xmath83 to @xmath93 , and apply      the same actions as in case 3(b ) .",
    "the following properties are the keys for the success of our violation - reduction routines .",
    "1 ) since there is no tree @xmath31 when a violation reduction takes place , the rank of @xmath21 will be the maximum rank among all other nodes . in accordance , we can remove a subtree of any specified rank from below @xmath21 .",
    "2 ) since @xmath21 has the minimum value of the priority queue , its children are not violating . in accordance",
    ", we can add a subtree below @xmath21 and ensure that its root is not violating .",
    "an extended regular binary counter represents a non - negative integer @xmath1 as a string @xmath94 of digits , least - significant digit first , such that @xmath95 , @xmath96 , and @xmath97 .",
    "the main constraint is that every @xmath17 is preceded by a @xmath10 or @xmath15 possibly having any number of @xmath9 s in between , and that every @xmath10 is preceded by a @xmath9 or @xmath17 possibly having any number of @xmath15 s in between .",
    "this constraint is stricter than the standard one , which allows the first @xmath17 and the first @xmath10 to come after any ( or even no ) digits .",
    "an extended regular counter @xcite supports the increments and decrements of arbitrary digits with a constant number of digit changes per operation .",
    "brodal @xcite showed how , what he calls a _ guide _ , can realize a regular binary counter ( the digit set has three symbols and the counter supports _ increments _ in constant time ) . to support _",
    "decrements _ in constant time as well , he suggested to couple two such guides back to back .",
    "we show how to implement an extended regular binary counter more efficiently using much simpler ideas .",
    "the construction described here was sketched in @xcite ; our description is more detailed .",
    "we partition any sequence into _ blocks _ of consecutive digits , and digits that are in no blocks .",
    "we have two categories of blocks : blocks that end with a @xmath17 are of the forms @xmath98 , and blocks that end with a @xmath10 are of the forms @xmath99 ( we assume that least - significant digits come first , and @xmath100 means zero or more repetitions )",
    ". we call the last digit of a block the _ distinguishing digit _ , and the other digits of the block the _ members_. note that the distinguishing digit of a block may be the first member of a block from the other category .    to efficiently implement _ increment _ and _ decrement _ operations , a",
    "_ fix _ is performed at most twice per operation .",
    "a fix does not change the value of a number . when a digit that is a member of a block is increased or decreased by one",
    ", we may need to perform a fix on the distinguishing digit of its block .",
    "we associate a forward pointer @xmath101 with every digit @xmath102 , and maintain the invariant that all the members of the same block point to the distinguishing digit of that block .",
    "the forward pointers of the digits that are not members of a block point to an arbitrary digit . starting from any member",
    ", we can access the distinguishing digit of its block , and hence perform the required fix , in constant time .    as a result of an _ increment _ or a _ decrement _ ,",
    "the following properties make such a construction possible .",
    "* a block may only extend from the beginning and by only one digit . in accordance ,",
    "the forward pointer of this new member inherits the same value as the forward pointer of the following digit .",
    "* a newly created block will have only two digits . in accordance , the forward pointer of the first digit is made to point to the other digit . * a fix that is performed unnecessarily is not harmful ( keeps the representation regular ) . in accordance , if a block is destroyed when fixing its distinguishing digit , no changes are done with the forward pointers .",
    "a string of length zero represents the number @xmath10 . in our pseudo - code , the change in the length of the representation is implicit ; the key observation is that the length can only increase by at most one digit with an _ increment _ and decrease by at most two digits with a _",
    "decrement_.    for @xmath103 , a _ fix - carry _ for @xmath104 is performed as follows :    ' '' ''     + * algorithm * _ fix - carry_(@xmath94 , @xmath105 ) +    ' '' ''     + 1:*assert *  @xmath106 * and *  @xmath103 + 2:@xmath107 + 3:increase @xmath108 by @xmath15 + 4:*if *  @xmath109 + 5 : @xmath110  //",
    "a new block of two digits + 6:*else *   + 7:@xmath111  // extending a _",
    "possible _ block from the beginning +    ' '' ''    as a result of a _ fix - carry _ the value of a number does not change . accompanying a _ fix - carry _",
    ", two digits are changed . in the corresponding data structure ,",
    "this results in performing a _ join _ , which involves one element comparison .",
    "the following pseudo - code summarizes the actions needed to increase the @xmath112th digit of a number by one .    ' '' ''",
    "+ * algorithm * _ _ increment__@xmath113 +    ' '' ''     + 1:*assert *  @xmath114 + 2:*if *  @xmath115 + 3:_fix - carry_(@xmath94 , @xmath112 )  // either this fix is executed + 6:@xmath116 + 7:*if *  @xmath117 * and *  @xmath118 + 8:_fix - carry_(@xmath94 , @xmath105 ) + 8:increase @xmath102 by @xmath15 + 10:*if *  @xmath115 + 11 : _ fix - carry_(@xmath94 , @xmath112 )  // or this fix +    ' '' ''    using case analysis , it is not hard to verify that this operation maintains the regularity of the representation .    for @xmath119 , a _ fix - borrow _ for @xmath104 is performed as follows :    ' '' ''     + * algorithm * _ fix - borrow_(@xmath94 , @xmath105 ) +    ' '' ''     + 1:*assert *  @xmath120 * and *  @xmath119 + 2:@xmath121 + 3:decrease @xmath108 by @xmath15 + 4:*if *  @xmath122 + 5 : @xmath110  // a new block of two digits + 6:*else *   + 7:@xmath111  // extending a _",
    "possible _ block from the beginning +    ' '' ''    as a result of a _ fix - borrow _ the value of a number does not change . accompanying a _ fix - borrow _ ,",
    "two digits are changed . in the corresponding data structure ,",
    "this results in performing a _ split _ , which involves no element comparisons .",
    "the following pseudo - code summarizes the actions needed to decrease the @xmath112th digit of a number by one .    ' '' ''     + * algorithm * _ _ decrement__@xmath113 +    ' '' ''     + 1:*assert *  @xmath123 + 2:*if *  @xmath124 + 3:_fix - borrow_(@xmath94 , @xmath112 )  // either this fix is executed + 6:@xmath116 + 7:*if *  @xmath125 * and *  @xmath126 + 8:_fix - borrow_(@xmath94 , @xmath105 ) + 8:decrease @xmath102 by @xmath15 + 10:*if *  @xmath127 * and *  @xmath124 + 11 : _ fix - borrow_(@xmath94 , @xmath112 )",
    "// or this fix +    ' '' ''    using case analysis , it is not hard to verify that this operation maintains the regularity of the representation .    in our application ,",
    "the outcome of splitting a tree of rank @xmath39 is not always two trees of rank @xmath29 as assumed above .",
    "the outcome can also be one tree of rank @xmath29 and another of rank @xmath39 ; two trees of rank @xmath29 and a third tree of a smaller rank ; or one tree of rank @xmath29 , one of rank @xmath38 , and a third tree of a smaller rank .",
    "we can handle the third tree , if any , by adding it below @xmath21 ( executing an _ increment _ just after the _ decrement _ ) .",
    "the remaining two cases , where the _ split _ results in one tree of rank @xmath29 and another of rank either @xmath39 or @xmath38 , are pretty similar to the case where we have two trees of rank @xmath29 . in the first case",
    ", we have detached a tree of rank @xmath39 and added a tree of rank @xmath29 and another of rank @xmath39 ; this case maintains the representation regular . in the second case ,",
    "we have detached a tree of rank @xmath39 and added a tree of rank @xmath29 and another of rank @xmath38 ; after that , there may be three or four trees of rank @xmath38 , and one _ join _ ( executing a _ fix - carry _ ) at rank @xmath38 may be necessary to make the representation regular . in the worst case , a _ fix - borrow _ may require three element comparisons : two because of the extra addition ( _ increment _ ) and one because of the extra _ join_. a _ decrement _ , which involves two fixes , may then require up to six element comparisons .",
    "let us analyse the number of element comparisons performed per . recall that the maximum rank is bounded by @xmath128 .",
    "the sum of the digits for an integer obeying the extended regular binary system is two times the maximum rank , i.e.  at most @xmath129 .",
    "it follows that the number of children of any node is at most @xmath130 . for an extended regular counter",
    ", an _ increment _ requires at most two element comparisons and a _ decrement _ at most six element comparisons .",
    "recall also that the number of active violations can not be larger than @xmath130 , since if there were more than two violations per rank a violation reduction would be possible .",
    "the number of inactive violations is less than @xmath131 , where @xmath132 ; its actual value depends on the speed we extend the violation array and the number of new violations per operation .",
    "a realistic value would be @xmath133 .",
    "first , when @xmath19 and its children are moved below @xmath21 , at most @xmath134 element comparisons are performed .",
    "second , when finding the new minimum , during the scan over the children of @xmath21 at most @xmath130 element comparisons are made , and during the scan over the violations of @xmath21 @xmath135 element comparisons are made .",
    "third , when all the inactive violations are made active , @xmath136 element comparisons are performed .",
    "fourth , when the old children of @xmath32 are merged with those of the old root , at most @xmath130 element comparisons are performed .",
    "fifth , when performing the necessary violation reductions , case 4 turns out to be the most expensive : ( i ) the minimum value of three elements is to be determined ( this requires two element comparisons ) .",
    "( ii ) a _ join _ requires one element comparison .",
    "( iii ) up to seven _ increments _ and up to two _ decrements _ at the extended regular counter of @xmath21 may be necessary . in total",
    ", a single violation reduction may require @xmath137 element comparisons , and @xmath138 such reductions may take place ( the @xmath139 accounts for the inactive violations of @xmath21 ) . to sum up",
    ", the total number of element comparisons performed is at most @xmath140 , which is at most @xmath141 element comparisons .",
    "an extra optimization is still possible . during the violation reduction , instead of adding the subtrees of @xmath64 and @xmath65 below @xmath21 ( an operation that requires two element comparisons per subtree )",
    ", we can join the two subtrees ( an operation that requires one element comparison ) using the fact that they have equal ranks .",
    "in addition , we can attach the resulting subtree in the place of the subtree that was rooted at @xmath73 .",
    "hence , we only need to remove one tree from below @xmath21 instead of two ( an operation that requires six element comparisons per subtree ) . in total",
    ", we perform at most one minimum - finding among three elements , two joins , five _",
    "increments _ and one _ decrement _ per violation reduction . in accordance , a single violation reduction may require at most @xmath142 element comparisons .",
    "this reduces the number of element comparisons per to at most @xmath143 element comparisons .",
    "in a nutshell , a pointer machine is a model of computation that only allows pointer manipulations ; arrays , bit tricks , or arithmetic operations are not allowed . in the literature ,",
    "the definitions ( and names ) of this type of machines differ , and it seems that all of these machines do not have the same computational power .",
    "we want to emphasize that the model considered here is a restricted one that may be called a _ pure pointer machine _ ( for a longer discussion about different versions of pointer machines and their computational power , see @xcite ) .",
    "the memory of a pointer machine is a directed graph of cells , each storing a constant number of pointers to other cells or to the cell itself .",
    "all cells are accessed via special centre cells seen as incarnations of registers of ordinary computers .",
    "the primitive operations allowed include the creation of cells , destruction of cells , assignment of pointers , and equality comparison of two pointers .",
    "it is assumed that the elements manipulated can be copied and compared in constant time , and that all primitive operations require constant time .    in connection with the initial construction",
    ", we allocate two cells to represent the bits 0 and 1 , and three cells to represent the colours white , black , and red .",
    "since we use ranks and array indices , we should be able to represent integers in the range between 0 and the maximum rank of any priority queue .",
    "for this purpose , we use the so - called _ rank entities _ ; we keep these entities in a doubly - linked list , each entity representing one integer .",
    "the rank entities are shared by all the priority queues .",
    "every node can access the entity corresponding to its rank in constant time by storing a pointer to this rank entity . with this mechanism , increments and decrements of ranks , rank copying , and",
    "equality comparisons between two ranks can be carried out in constant time .",
    "the maximum rank may only be increased or decreased by at most one with any operation . when the maximum rank is increased , a new entity is created and appended to the list .",
    "to decide when to release the last entity , the rank entities are reference counted .",
    "this is done by associating with each entity a list of cells corresponding to the nodes having this rank .",
    "when the last entity has no associated cells , the entity is released .",
    "we also build a complete binary tree above the rank entities ; we call this tree the _ global index_. starting from a rank entity , the bits in the binary representation of its rank are obtained by accessing the global index upwards .    the main idea in our construction is to simulate a resizable array on a pointer machine . given the binary representation of an array index , which in our case is a rank , the corresponding location can be accessed without relying on the power of a random - access machine , by having a complete binary tree built above the array entries ; we call this tree the _ local index_. starting from the root of the tree , we scan the bits in the representation of the rank , and move either to the left or to the right until we reach the sought entity that corresponds to an array entry ; we call such entities the _ location entities_. the last location entity corresponds to the maximum node rank ; that is the rank of @xmath19 ( or @xmath21 if @xmath31 is empty ) .    to facilitate the dynamization of indexes ,",
    "we maintain four versions of each ; one is under construction , one is under destruction , and two are complete ( one of them is in use ) .",
    "the sizes of the four versions are consecutive powers of two , and there is always a version that is larger and another that is smaller than the version in use . at the right moment , we make a specific version the current index , start destroying an old version , and start constructing a new version .",
    "to accomplish such a change , each entity must have three pointers , and we maintain a switch that indicates which pointer leads to the index in use .",
    "index constructions and destructions are done incrementally by distributing the work on the operations using the index , a constant amount of work per operation .    to decide the right moment for index switching , we colour the leaves of every index . consider an index with @xmath144 leaves .",
    "the rightmost leaf is coloured red , the leaf that is at position @xmath145 from the left is coloured black , and all other leaves are coloured white .",
    "when the current index becomes full , i.e.  the red cell is met by the last entity , we switch to the next larger index .",
    "when a black cell is met by the last entity , we switch to the next smaller index .",
    "let us now consider how these tools are used to implement our data structure on a pointer machine .",
    "one should be aware that the following two operations require @xmath146 worst - case time on a pointer machine :    * when we access an array to record a violation or adjust the numeral system ( in or in ) , we use the global index to get the bits in the binary representation of the rank of the accessed entity and then a local index to find the corresponding location .",
    "we use the height of the local index to determine how many bits to extract from the global index .",
    "* when we compare two ranks ( in ) , we extract the bits from the global index and perform a normal comparison of two bit sequences .",
    "when two priority queues are melded , we keep the local index of the violation structure of one priority queue , and move the other to the garbage pile .",
    "the unnecessary regular counters are also moved to the garbage pile .",
    "as pointed out earlier , incremental garbage collection ensures that the amount of space used by each priority queue is still linear in its size . because of the rank comparison",
    ", the update of the violation structure of @xmath21 , and the update of the regular counter of @xmath19 , takes @xmath146 worst - case time .",
    "also involves several array accesses , so its worst - case cost becomes @xmath146 .",
    "lastly , must be implemented carefully to avoid a slowdown in its running time .",
    "this is done by bypassing the local indexes and creating a one - to - one mapping between the rank entities and the location entities maintained for the violation structure of @xmath21 and the regular counters of @xmath21 and @xmath19 .",
    "first , the rank and location entities are simultaneously scanned , one by one , and a pointer to the corresponding location entity is stored at each rank entity . hereafter ,",
    "any node keeping a pointer to a rank entity can access the corresponding location entity with a constant delay . this way ,",
    "deletions can be carried out asymptotically as fast as on a random - access machine .",
    "we have proved the following theorem .",
    "there exists a priority queue that works on a random - access machine and supports the operations , , , and in constant worst - case time ; and and in @xmath7 worst - case time , where @xmath1 is the number of elements in the priority queue .",
    "the amount of space used by the priority queue is linear .    for our structure ,",
    "the number of element comparisons performed by is at most @xmath147 , where @xmath148 is around seventy . for the data structure in @xcite , some implementation details",
    "are not specified , making such analysis depend on the additional assumptions made . according to our rough estimates ,",
    "the constant factor @xmath148 for the priority queue in @xcite is much more than one hundred .",
    "we note that for both data structures further optimizations may still be possible .",
    "we summarize our storage requirements as follows .",
    "every node stores an element , a rank , two sibling pointers , a last - child pointer , a pointer to its violation list , and two pointers for the violation list it may be in .",
    "the violation structure and the regular counters require a logarithmic amount of space . in @xcite , in order to keep external references valid , elements should be stored indirectly at nodes , as explained in ( * ? ? ?",
    "* chapter 6 ) .",
    "the good news is that we save four pointers per node in comparison with @xcite .",
    "the bad news is that , for example , binomial queues @xcite can be implemented with only two pointers per node .",
    "we have also proved the following theorem .",
    "there exists a priority queue that works on a pure pointer machine and supports the operations and in constant worst - case time , and in @xmath146 worst - case time , and and in @xmath7 worst - case time , where @xmath1 is the number of elements stored in the resulting priority queue .",
    "the amount of space used by the priority queue is linear .",
    "we showed that a simpler data structure achieving the same asymptotic bounds as brodal s data structure @xcite exists .",
    "we were careful not to introduce any artificial complications when presenting our data structure .",
    "our construction reduces the constant factor hidden behind the big - oh notation for the worst - case number of element comparisons performed by .",
    "theoretically , it would be interesting to know how low such factor can get .",
    "we summarize the main differences between our construction and that in @xcite . on the positive side of our treatment :    * we use a standard numeral system with fewer digits ( four instead of six ) .",
    "besides improving the constant factors , this allows for the logical distinction between the operations of the numeral system and other operations .",
    "* we use normal joins instead of three - way joins , each involving one element comparison instead of two .",
    "* we do not use parent pointers , except for the last children .",
    "this saves one pointer per node , and allows swapping of nodes in constant time .",
    "since node swapping is possible , elements can be stored directly inside nodes .",
    "this saves two more pointers per node .",
    "* we gathered the violations associated with every node in one violation list , instead of two .",
    "this saves one more pointer per node . * we bound the number of violations by restricting their total number to be within a threshold , whereas the treatment in @xcite imposes an involved numeral system that constrains the number of violations per rank .    on the negative side of our treatment",
    ":    * we check more cases within our violation reductions .",
    "* we have to deal with larger ranks ; the maximum rank may go up to @xmath48 , instead of @xmath149 .",
    "it is a long - standing open issue how to implement a priority queue on a pointer machine such that all operations are performed in optimal time bounds .",
    "fibonacci heaps are known to achieve the optimal bounds in the amortized sense on a pointer machine @xcite .",
    "meldable priority queues described in @xcite can be implemented on a pointer machine , but requires @xmath150 time .",
    "fat heaps @xcite can be implemented on a pointer machine , but is not supported . in @xcite , a pointer - machine implementation of run - relaxed weak heaps",
    "is given , but requires @xmath7 time and @xmath146 time .",
    "we introduced a pointer - machine implementation that supports and in @xmath146 time so that no arrays , bit tricks , or arithmetic operations are used .",
    "we consider the possibility of constructing worst - case optimal priority queues that work on a pointer machine as a major open question .",
    "we thank robert tarjan for motivating us to simplify brodal s construction , gerth brodal for taking the time to explain some details of his construction , and claus jensen for reviewing this manuscript and teaming up with us for six years in our research on the comparison complexity of priority - queue operations .",
    "10 [ 1]`#1 `    ben - amram , a.m. : what is a `` pointer machine '' ?",
    "acm sigact news 26(2 ) , 8895 ( 1995 )    brodal , g.s .",
    ": fast meldable priority queues . in : 4th international workshop on algorithms and data structures .",
    "lncs , vol .",
    "springer ( 1995 )    brodal , g.s . : worst - case efficient priority queues . in : proceedings of the 7th acm - siam symposium on discrete algorithms .",
    "acm / siam ( 1996 )    clancy , m. , knuth , d. : a programming and problem - solving seminar .",
    "technical report stan - cs-77 - 606 , cs department , stanford university ( 1977 )    cormen , t.h . ,",
    "leiserson , c.e . ,",
    "rivest , r.l . , stein , c. : introduction to algorithms . the mit press , 3nd edn .",
    "( 2009 )    driscoll , j.r .",
    ", gabow , h.n . , shrairman , r. , tarjan , r.e . :",
    "relaxed heaps : an alternative to fibonacci heaps with applications to parallel computation .",
    "communications of the acm 31(11 ) , 13431354 ( 1988 )    elmasry , a. , jensen , c. , katajainen , j. : multipartite priority queues .",
    "acm transactions on algorithms 5(1 ) , article 14 ( 2008 )    elmasry , a. , jensen , c. , katajainen , j. : two - tier relaxed heaps .",
    "acta informatica 45(3 ) , 193210 ( 2008 )    elmasry , a. , jensen , c. , katajainen , j. : strictly - regular number system and data structures . in : 12th scandinavian symposium and workshops on algorithm theory .",
    "lncs , vol .",
    "6139 , pp .",
    "2637 ( 2010 )    elmasry , a. , jensen , c. , katajainen , j. : relaxed weak queues and their implementation on a pointer machine .",
    "cph stl report 2010 - 4 , department of computer science , university of copenhagen ( 2010 )    fredman , m.l .",
    ", tarjan , r.e .",
    ": fibonacci heaps and their uses in improved network optimization algorithms .",
    "journal of the acm 34(3 ) , 596615 ( 1987 )    kaplan , h. , shafrir , n. , tarjan , r.e .",
    ": meldable heaps and boolean union - find . in : 34th annual acm symposium of theory of computing",
    "pp . 573582 ( 2002 )    kaplan , h. , tarjan , r.e . : thin heaps , thick heaps .",
    "acm transactions on algorithms 4(1 ) , article 3 ( 2008 )    kaplan , h. , tarjan , r.e . : new heap data structures .",
    "technical report tr-597 - 99 , department of computer science , princeton university ( 1999 )    vuillemin , j. : a data structure for manipulating priority queues .",
    "communications of the acm 21(4 ) , 309315 ( 1978 )    williams , j.w.j . : algorithm 232 : heapsort .",
    "communications of the acm 7(6 ) , 347348 ( 1964 )",
    "this appendix was written for our non - expert readers , to give them insight into the technical details  of which there are still many  skipped in the main body of the text .",
    "our hope is that after reading this appendix the reader would get the details used for obtaining a worst - case optimal priority queue .",
    "one complication encountered in our construction is the dynamization of the arrays maintained . at some point",
    ", an array may be too small to record the information it is supposed to hold .",
    "sometimes it may also be necessary to contract an array so that its size is proportional to the amount of recorded information .",
    "a standard solution for this problem is to rely on doubling , halving , and incremental copying .",
    "each array has a _ size _ , i.e.  the number of objects stored , and a _ capacity _ ,",
    "i.e.  the amount of space allocated for it , measured in the number of objects too",
    ". the representation of an array is composed of up to two memory segments , and integers indicating their size and capacity .",
    "let us call the two segments @xmath151 and @xmath152 ; @xmath151 is the main structure , and @xmath152 is the copy under construction , which may be empty .",
    "the currently stored objects are found in at most two consecutive subsegments , one at the beginning of @xmath151 and another in the middle of @xmath152 .",
    "initially , @xmath153 and @xmath154 . with this organization ,",
    "the array operations are performed as follows :    ( @xmath155 , @xmath112 ) .",
    ": :    to access the object with index @xmath112 in array    @xmath155 , return @xmath156 $ ] if    @xmath157 ; otherwise , return    @xmath158 $ ] .",
    "( no out - of - bounds index checking is done . )",
    "( @xmath155 ) .",
    ": :    if @xmath152 does not exist and    @xmath159 , increase    @xmath160 by one and stop . if @xmath152    does not exist and    @xmath161 , allocate space    for @xmath152 where    @xmath162 and    set @xmath163 .",
    "copy one object    from the end of @xmath151 to the corresponding position in    @xmath152 , decrease @xmath160 by one and    increase @xmath164 by one .",
    "if    @xmath160 is zero , release the array    @xmath151 and rename @xmath152 as @xmath151 .",
    "( @xmath155 ) .",
    ": :    if @xmath152 does not exist and    @xmath165 ,    decrease @xmath160 by one and stop . if    @xmath152 does not exist and    @xmath166 ,    allocate space for @xmath152 where    @xmath167    and set @xmath163 .",
    "copy two    ( or one , if only one exists ) objects from the end of @xmath151    to the corresponding positions in @xmath152 , decrease    @xmath160 as such and decrease    @xmath164 by one . if    @xmath160 is zero , release the array    @xmath151 and rename @xmath152 as @xmath151 .",
    "because of the speed objects are copied , a copying process can always be finished before it will be necessary to start a new copying process .",
    "clearly , in connection with each operation , the amount of work done is @xmath16 .",
    "additionally , since only a constant fraction of the allocated memory is unused , the amount of space used is proportional to the number of objects stored in the array .",
    "we assume that the atomic components of the priority queues manipulated are nodes , each storing an element .",
    "further , we assume that the memory management related to the nodes is done outside the priority queue . for , the user must give a pointer to a node as its argument ; the node is then made part of the data structure .",
    "the ownership of the node is returned back to the user when it is removed from the data structure .",
    "after such removal , it is the user s responsibility to take care of the actual destruction of the node .",
    "a meldable ( minimum ) priority queue should support the following operations .",
    "all parameters and return values are pointers or references to objects . when describing the effect of an operation , we write ( for the sake of simplicity ) `` object @xmath32 '' instead of `` the object pointed to by @xmath32 '' .",
    ": :    create and return a new priority queue that contains no elements .",
    "( @xmath168 ) .",
    ": :    destroy priority queue @xmath168 under the precondition that the    priority queue contains no elements .",
    "( @xmath168 ) .",
    ": :    return the node of a minimum element in priority queue    @xmath168 .",
    "( @xmath168 , @xmath32 ) .",
    ": :    insert node @xmath32 ( storing an element ) into priority queue    @xmath168 .",
    "( @xmath168 , @xmath32 , @xmath169 ) .",
    ": :    replace the element stored at node @xmath32 in priority queue    @xmath168 with element @xmath169 such that @xmath169    is not greater than the old element .",
    "( @xmath168 , @xmath32 ) .",
    ": :    remove node @xmath32 from priority queue @xmath168 .",
    "( @xmath168 ) .",
    ": :    remove and return the node of a minimum element from priority queue    @xmath168 .",
    "this operation has the same effect as followed by    using its return value as argument . @xmath170 .",
    ": :    move the nodes from priority queues @xmath171 and    @xmath172 into a new priority queue and return that priority    queue .",
    "priority queues @xmath171 and @xmath172 are    dismissed by this operation .",
    "observe that it is essential for the operations and to take ( a handle to ) a priority queue as one of their arguments .",
    "kaplan et al .",
    "@xcite showed that , if this is not the case , the stated optimal time bounds are not achievable .        * a pointer to @xmath21 ( the root of @xmath30 ) * a pointer to @xmath19 ( the root of @xmath31 ) * a pointer to the beginning of the list of active violations of @xmath21 * a pointer to the beginning of the list of inactive violations of @xmath21 * a pointer to the violation structure recording the active violations of @xmath21 * a pointer to the regular counter keeping track of the children of @xmath21 ;",
    "both the rank sequence @xmath173 and pointers to the children are maintained * a pointer to the regular counter keeping track of the children of @xmath19                    * if the element at node @xmath32 is smaller than that at @xmath21 , swap @xmath32 and @xmath21 ( but not their violation lists ) . *",
    "make @xmath32 the child of @xmath21 .",
    "* update the regular counter of @xmath21 ( by performing an _ increment _ at position @xmath10 ) .",
    "* let the involved roots be @xmath21 and @xmath19 ( for @xmath171 ) , and @xmath59 and @xmath176 ( for @xmath172 ) .",
    "assume without loss of generality that the element at @xmath21 is smaller than that at @xmath59 .",
    "* make @xmath21 the root of the new first tree of the resulting priority queue .",
    "* dismiss the violation array of @xmath59 .",
    "* let @xmath49 denote the node of the highest rank among the roots @xmath21 , @xmath19 , @xmath59 , and @xmath176 . *",
    "if @xmath177 * * move the other roots as the children of @xmath21 .",
    "* * update the regular counter of @xmath21 accordingly . * otherwise : * * make @xmath49 the root of the new second tree of the resulting priority queue . * * move the other ( at most two ) roots below @xmath49 , and make these roots violating ( by adding them to the violation structure of @xmath21 ) . * * update the regular counter of @xmath49 accordingly . * * perform two violation reductions , if possible . *",
    "dismiss the regular counters of the roots moved below @xmath21 and @xmath49 .",
    "* extend the violation array of @xmath21 by @xmath16 locations , if necessary . *",
    "if @xmath178 , repeat @xmath16 times : * * move a child of @xmath179 from below @xmath49 to below @xmath21 . *",
    "* update the regular counter of @xmath21 ( by performing an _ increment _ at position @xmath179 ) . *",
    "* update the regular counter of @xmath49 ( by performing a _ decrement _ at position @xmath179 ) . * if @xmath178 and @xmath180 * * move the whole tree of @xmath49 below @xmath21 . * * update the regular counter of @xmath21 ( by performing an _ increment _ at position @xmath181 ) . *",
    "* dismiss the regular counter of @xmath49 .",
    "* replace the element at node @xmath32 with element @xmath169 . *",
    "if the element at @xmath32 is smaller than that at @xmath21 , swap @xmath32 and @xmath21 ( but not their violation lists ) .",
    "a swap should be followed by an update of the external pointers referring to @xmath32 . if a swap was executed and if any of the arrays ( regular counters or violation array ) had a pointer to @xmath32 , update this pointer at @xmath182 to point to @xmath21 instead .",
    "* if @xmath32 is @xmath21 , @xmath19 , or a child of @xmath21 , stop . *",
    "if @xmath32 was violating , remove it from the violation structure where it was in . *",
    "make @xmath32 violating by adding it to the violation structure of @xmath21 ( either as an active or an inactive violation depending on its rank ) .",
    "* perform one violation reduction , if possible .",
    "* extend the violation array of @xmath21 by @xmath16 locations , if necessary .",
    "* if @xmath31 exists , repeat @xmath16 times : * * move a child of @xmath179 from below @xmath19 to below @xmath21 . * * update the regular counters @xmath21 ( by performing an _ increment _ at position @xmath179 ) . *",
    "* update the regular counter of @xmath19 ( by performing a _ decrement _ at position @xmath179 ) . *",
    "if @xmath31 exists and @xmath183 * * move the whole tree @xmath31 below @xmath21 . * * update the regular counter of @xmath21 ( by performing an _ increment _ at position @xmath184 ) . * * dismiss the regular counter of @xmath19 .      *",
    "merge @xmath19 ( as a single node ) and all its subtrees with the children of @xmath21 , while extending and updating the regular counter of @xmath21 accordingly .",
    "* dismiss the regular counter of @xmath19 .",
    "* determine the new minimum by scanning the children of @xmath21 and all violations in the violation lists of @xmath21 .",
    "let @xmath32 be the node containing the new minimum . *",
    "if @xmath32 is a violation node * * remove a child of @xmath185 from below @xmath21 . * * update the regular counter of @xmath21 accordingly . *",
    "* make the detached node violating , and attach it in place of @xmath32 .",
    "* otherwise * * remove @xmath32 from below @xmath21 . * * update the regular counter of @xmath21 accordingly .",
    "* merge the children of @xmath32 with those of @xmath21 , and update the regular counter accordingly . *",
    "append the violation list of @xmath21 to that of @xmath32 .",
    "* make the violation array large enough , and add all violations of @xmath32 that are not already there to the violation array .",
    "* release @xmath21 and move @xmath32 to its place .",
    "* perform as many violation reductions as possible",
    ".      * swap node @xmath32 and @xmath21 . *",
    "if any of the arrays ( regular counters or violation array ) had a pointer to @xmath32 , update this pointer at @xmath182 to point to @xmath21 instead .",
    "* make the current node @xmath32 violating .",
    "* remove the current root of @xmath30 as in ."
  ],
  "abstract_text": [
    "<S> we consider the classical problem of representing a collection of priority queues under the operations , , , , , and . in the comparison - based model , </S>",
    "<S> if the first four operations are to be supported in constant time , the last two operations must take at least logarithmic time . </S>",
    "<S> brodal showed that his worst - case efficient priority queues achieve these worst - case bounds . </S>",
    "<S> unfortunately , this data structure is involved and the time bounds hide large constants . we describe a new variant of the worst - case efficient priority queues that relies on extended regular counters and provides the same asymptotic time and space bounds as the original . due to the conceptual separation of the operations on regular counters and all other operations , </S>",
    "<S> our data structure is simpler and easier to describe and understand . also , the constants in the time and space bounds are smaller . </S>",
    "<S> in addition , we give an implementation of our structure on a pointer machine . for our pointer - machine implementation , and are asymptotically slower and require @xmath0 worst - case time , where @xmath1 denotes the number of elements stored in the resulting priority queue . </S>"
  ]
}