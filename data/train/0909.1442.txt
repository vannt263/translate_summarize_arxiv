{
  "article_text": [
    ".the standard genetic code . assignment of the 64 possible codons to amino acids or stop signals , with polar requirement of the amino acids indicated in brackets . [ cols= \" < , < , < , < \" , ]     [ tab : tab7 ]    in table [ tab : tab7 ] we have listed the possible ways to fill a single box that are compatible with the considered trna wobble rules .",
    "let @xmath2 enumerate the possible trna patterns as listed in the rightmost column of table [ tab : tab7 ] .",
    "we write @xmath3 , @xmath4 , @xmath5 for the number of amino acids , stop codons and unassigned codons present in pattern @xmath6",
    ". +   + * problem .",
    "* we now consider the problem of filling 16 boxes ( 64 codons in total ) using 20 different amino acids , @xmath7 stop codons and @xmath8 unassigned codons .",
    "it is useful to solve a slightly more general problem : the number of ways to fill @xmath9 boxes using    * @xmath10 amino acids , * each of the first @xmath11 amino acids at least once , * exactly @xmath7 stop codons , and * exactly @xmath8 unassigned codons .",
    "the original problem is obtained by setting @xmath12 and @xmath13 . +   + * recurrence . * we denote the number of such fillings by @xmath14 and compute their values by the recurrence @xmath15 with basis @xmath16 * rationale . *",
    "the reasoning behind is the following .",
    "we fill box number @xmath9 first , and worry about the remaining boxes later .",
    "we iterate over the possible trna patterns with variable @xmath17 .",
    "to realise pattern @xmath18 we need @xmath19 amino acids , @xmath20 stop codons and @xmath21 unassigned codons .",
    "there is only one way to choose stop codons and unassigned codons , but we can obtain the amino acids from two sources . we can take some from the @xmath11 still - to - use amino acids that we have to use at least once , and we must take the others from the @xmath22 free amino acids that can be used as desired .",
    "we consider all possible ways to realise the choice : we first iterate over the number of amino acids that we take from the still - to - use pool with variable @xmath23 . selecting @xmath23 out of @xmath11 still - to - use amino acids can be done in @xmath24 ways .",
    "similarly , taking the remaining @xmath25 amino acids from @xmath22 free amino acids can be done in @xmath26 ways .",
    "all these @xmath19 chosen amino acids are different , and so there are @xmath27 ways to instantiate the pattern using them .",
    "now we still have to fill the remaining @xmath28 boxes , using the remaining @xmath29 still - to - use amino acids at least once , while using exactly @xmath30 stop codons and leaving @xmath31 codons unassigned .",
    "+   + * implementation .",
    "* the value @xmath32 can be efficiently evaluated by dynamic programming .",
    "this is achieved by storing all intermediate values of @xmath33 that are computed in memory , and recalling them when they are needed instead of reevaluating @xmath33 .",
    "this way , @xmath14 can be evaluated in time and space @xmath34 .",
    "note that a single call to @xmath14 computes @xmath35 for many @xmath36 , @xmath37 , @xmath38 and @xmath39",
    ". +   + * sampling . *",
    "the above dynamic programming implementation has the advantage that it allows uniform sampling over the space of all codes .",
    "we first sample a number uniformly between @xmath40 and @xmath14 .",
    "then we use the recurrence in reverse to determine which code this number corresponds to .",
    "this is done as follows .",
    "say the number sampled was @xmath41 .",
    "we then incrementally evaluate the sum of .",
    "once the partial sum up to @xmath17 surpasses @xmath41 , we know that pattern @xmath18 was used in code number @xmath41 . similarly we decode which amino acids are used and in which order they are placed . by explicitly keeping track of the set of still - to - use amino acids we can retrieve the entire code recursively .",
    "we gratefully acknowledge steven de rooij for taking part in the effort to determine the global minimum .",
    "furthermore we gratefully acknowledge the large improvements of the manuscript by comments from paul g. higgs and two anonymous referees .",
    "novozhilov as , wolf yi , koonin ev , evolution of the genetic code : partial optimization of a random code for robustness to translation error in a rugged fitness landscape , _ biology direct _ 2 , 24 ( 2007 ) .",
    "takai k , classification of the possible pairs between the first anticodon and the third codon positions based on a simple model assuming two geometries with which the pairing effectively potentiates the decoding complex , _ journal of theoretical .",
    "biology _ 242 , 564580 ( 2006 ) .",
    "massey se , searching of code space for an error - minimized genetic code via codon capture leads to failure , or requires at least 20 improving codon reasignments via the ambiguous intermediate mechanism , _",
    "_ 70 , 106115 ( 2010 ) ."
  ],
  "abstract_text": [
    "<S> the genetic code has been shown to be very error robust compared to randomly selected codes , but to be significantly less error robust than a certain code found by a heuristic algorithm . </S>",
    "<S> we formulate this optimisation problem as a quadratic assignment problem and thus verify that the code found by the heuristic is the global optimum . </S>",
    "<S> we also argue that it is strongly misleading to compare the genetic code only with codes sampled from the fixed block model , because the real code space is orders of magnitude larger . </S>",
    "<S> we thus enlarge the space from which random codes can be sampled from approximately @xmath0 codes to approximately @xmath1 codes . </S>",
    "<S> we do this by leaving the fixed block model , and using the wobble rules to formulate the characteristics acceptable for a genetic code . by relaxing more </S>",
    "<S> constraints three larger spaces are also constructed . using a modified error function , </S>",
    "<S> the genetic code is found to be more error robust compared to a background of randomly generated codes with increasing space size . </S>",
    "<S> we point out that these results do not necessarily imply that the code was optimized during evolution for error minimization , but that other mechanisms could explain this error robustness .    </S>",
    "<S> genetic code , error robustness , origin of life . </S>"
  ]
}