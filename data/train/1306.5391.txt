{
  "article_text": [
    "the problem of finding maximum flow in planar graphs has a long history , starting with the work of ford and fulkerson  @xcite in which the max - flow , min - cut theorem was proved and the augmenting - paths algorithm was introduced .",
    "since then , algorithms for maximum flow in planar graphs have fallen into one of three paradigms : augmenting paths , divide and conquer using small balanced planar separators , or via shortest paths in the dual .",
    "we note a subset of these results that are relevant to this paper .",
    "borradaile and klein gave an augmenting - paths algorithm for maximum @xmath2-flow in directed planar graphs that uses dynamic trees to achieve an @xmath1 running time  @xcite .",
    "for the special case when @xmath3 and @xmath4 are on the same face , an augmenting - paths algorithm can be simulated via dijkstra s algorithm or , equivalently , determined from shortest - path distances in the dual graph  @xcite ( details in section  [ sec : max - flow - shortest ] ) .",
    "borradaile et  al",
    ".  gave a rather complicated @xmath5-time divide - and - conquer algorithm for when there are multiple sources and sinks ( not necessarily on a common face )  @xcite .",
    "for the special case when these sources and sinks are all on a common face ( such as the boundary of the embedded graph ) , miller and naor gave a simpler divide - and - conquer algorithm  @xcite .    in this work",
    "we give an iterative algorithm for this last _ boundary - to - boundary _ case .",
    "while our algorithm does not improve on the asymptotic running time of miller and naor s work , in order for miller and naor s algorithm to be implemented in @xmath1 time , one requires repeated applications of the linear - time shortest - paths algorithm of henzinger et al .",
    "this shortest - paths algorithm is arguably impractical : it is also a divide - and - conquer algorithm using small planar separators , involves ` large constants ' and , to our knowledge , has not been implemented .",
    "our algorithm , on the other hand , requires just @xmath0 ( with a small constant ) queries to simple data structures : namely a priority queue and a linked list  @xcite .",
    "our algorithm is an augmenting - paths algorithm that iterates over the source - sink pairs .",
    "we simulate finding the flow between a given source and sink using hassin s method  via dijkstra s algorithm in the dual graph . in order to prevent searching the same region of the graph multiple times , we search the graph in a biased way  @xcite , such that we need only reuse the boundary of the searched region for augmenting further source - sink pairs . in order to reuse these boundaries efficiently",
    ", we use a simple generalization of priority queues in which queues are merged whose relative priorities differ by a constant or _ offset_. these _ offset queues _ are implemented using edge weights to encode the offset in a tree implementation of the heap ; doing so does not affect the asymptotic running time of the basic priority queue operations .",
    "details are given in appendix  [ app : pq ] .",
    "we believe that the methods used in this paper may be applicable to other planar flow problems .",
    "for example , in a companion paper  @xcite , we argue that the augmenting - paths algorithm of borradaile and klein for maximum @xmath2-flow in directed planar graphs can also be simulated by dijkstra in the dual graph ; the details of the implementation in this paper may lead to an @xmath1 algorithm for maximum @xmath2-flow in directed planar graphs that does not require the more cumbersome dynamic - trees data structure .",
    "we give a brief outline of definitions where we may stray from convention . for more complete and formal definitions",
    ", please refer to borradaile s dissertation  @xcite .",
    "we extend any function or property on elements to sets of elements in the natural way .",
    "our algorithms are for directed graphs , but we consider the underlying undirected graph where each edge has two oppositely directed darts .",
    "darts are oriented from _ tail _ to _ head_. capacities , @xmath6 , on the darts are positive and asymmetric , reflecting the original directed problem .",
    "paths and cycles are sequences of darts and so are naturally directed ; a path or a cycle may visit the same vertex multiple times ; those that do not are _ simple _ ; a path may be trivial , in which case it is a vertex .",
    "@xmath7 $ ] denotes the @xmath8-to-@xmath9 subpath of @xmath10 where @xmath10 is a path , cycle or tree ; @xmath11 denotes the concatenation of paths ( which may result in a cycle ) .",
    "a flow @xmath12 is an assignment of real numbers to darts that is antisymmetric ( for a dart and its reverse ) , respects capacities and is balanced at all non - terminal ( non - source , sink ) vertices .",
    "the value @xmath13 of a flow is the net flow entering the sinks .",
    "a flow is a circulation if there are no terminals .",
    "the residual capacities @xmath14 of capacities @xmath6 w.r.t .",
    "flow @xmath12 are given by : @xmath15 = { \\bm{c}}[d]-{{\\bm{f}}}[d],\\ \\forall \\text{darts } d\\ ] ] a path or cycle @xmath10 is residual if the residual capacity of every dart in @xmath10 is strictly positive .",
    "a dart is saturated if its residual capacity is zero .",
    "residuality is w.r.t .",
    "capacities ( such as @xmath6 or @xmath16 ) .",
    "an @xmath17-cut in @xmath18 is a set of darts @xmath19 , the removal of which leaves no @xmath20-to-@xmath21 paths .",
    "the value of a cut is the total capacity of its darts .",
    "the value of the _ minimum _ @xmath17-cut equals to that of the maximum @xmath17-flow  @xcite .",
    "we use the usual definitions for planar graphs and their duals . we denote any path , cycle , vertex , face , dart in the dual graph with a @xmath22-superscript .",
    "if @xmath23 is a dart in @xmath18 , then @xmath24 is the corresponding dual dart ; if @xmath25 is a vertex and @xmath26 is a face in @xmath18 , @xmath27 is a _ face _ and @xmath28 is a _ vertex _ in @xmath29 . the boundary of the graph is denoted @xmath30 and is taken to be clockwise .",
    "we refer to simple cycles as being clockwise ( c.w . ) or counterclockwise ( c.c.w . ) ; c.w .  and c.c.w .",
    "depend on the choice of infinite face , @xmath31 , which , throughout this paper , we will take to be the face common to all the sources and sinks .    for two non - crossing @xmath20-to-@xmath21 paths",
    "@xmath32 and @xmath33 , we say @xmath32 is left of @xmath33 if @xmath34 is c.w .",
    "a path is leftmost if there are no paths left of it . for an @xmath20-to-@xmath21 path @xmath32 that starts and ends on @xmath30",
    ", we say a face , edge , path , etc .",
    "@xmath10 is ( strictly ) left of @xmath32 if @xmath10 is ( strictly ) contained by the c.w .  cycle @xmath35 \\circ { \\ensuremath{\\mbox{\\it rev}\\,(p)}}$ ] .",
    "we say that a planar flow @xmath12 is _ leftmost _ if every c.w .",
    "cycle is non - residual w.r.t .",
    "we say that capacities are c.w .",
    "acyclic if every c.w .",
    "cycle is non - residual w.r.t .  the capacities .",
    "khuller , naor and klein  @xcite showed that a flow that is derived from shortest - path distances in the dual is c.w .",
    "acyclic . formally :    [ thm : cwsat ] let @xmath36 be the shortest - path distances in @xmath29 from @xmath37 interpreting capacities as lengths .",
    "then every c.w .",
    "cycle is non - residual w.r.t .",
    "the flow @xmath38 =      { \\bm{d}}[{\\ensuremath{\\mathit head}}(d^*)]-{\\bm{d}}[{\\ensuremath{\\mathit tail}}(d^ * ) ] \\ \\forall \\text { darts }      d \\label{eq : st - flow}\\ ] ] where @xmath39 and @xmath40 are the head and tail vertices of @xmath24 in @xmath29 .",
    "earlier , hassin had used this idea to find a maximum @xmath2-flow in an @xmath2-planar graph  @xcite .",
    "we can view his algorithm by turning it into a circulation problem : introduce a new infinite - capacity arc @xmath41 embedded so that every @xmath3-to-@xmath4 residual path forms a c.w .",
    "cycle with @xmath41 and then saturate the c.w .  cycles .",
    "we describe an equivalent formulation which we use in this paper . split the dual vertex @xmath37 into two vertices @xmath42 and",
    "@xmath43 such that all the darts in @xmath44^*$ ] are incident to @xmath42 and all the darts in @xmath45^*$ ] are incident to @xmath43 ; denote the resulting graph @xmath46 .",
    "let @xmath47 $ ] be the shortest - path distance from @xmath42 to @xmath48 in @xmath49 , viewing capacities as lengths .",
    "then the flow assignment @xmath50 for @xmath18 given as in equation  ( [ eq : st - flow ] ) is a maximum @xmath2-flow .",
    "it follows directly from theorem  [ thm : cwsat ] that @xmath50 is the leftmost maximum @xmath2-flow .    since simple cuts in the primal map to simple cycles in the dual ( and vice versa )  @xcite , the darts of an @xmath2-cut @xmath19 form an @xmath42-to-@xmath43 path @xmath51 in @xmath46 .",
    "if @xmath19 is a minimum cut , @xmath51 is a shortest path .",
    "[ obs : leftmost - acyclic ] a leftmost flow w.r.t .  c.w .",
    "acyclic residual capacities is acyclic .",
    "@xcite    because of this acyclicity , one can easily show :    [ obs : path - decomp ] let @xmath6 be c.w .",
    "acyclic capacities and let @xmath12 the leftmost , max @xmath2-flow for @xmath3 and @xmath4 on @xmath52 . then there is a decomposition of @xmath12 into unique , non - crossing @xmath3-to-@xmath4 paths @xmath53 where @xmath54 carries @xmath55 units of flow and @xmath54 is left of @xmath56 @xmath57 .",
    "further , an augmenting - paths algorithm that always saturates the leftmost path first saturates the paths @xmath58 in order .",
    "our algorithm requires c.w .",
    "acyclic capacities ; the analysis will use this fact indirectly by invoking observation  [ obs : path - decomp ] .",
    "we will achieve this property in a preprocessing step and maintain this as an invariant throughout the algorithm .",
    "it follows from equation  ( [ eq : st - flow ] ) and observation  [ obs : path - decomp ] that , for every primal face @xmath20 ( dual vertex @xmath48 ) : @xmath59 = \\left\\ {      \\begin{array}[c]{ll }        \\sum_{j = 1}^i f_j & \\text{if $ x$ is right of $ p_i$ and left of $ p_{i+1}$ } \\\\",
    "\\sum_{j = 1}^\\ell f_j = |{{\\bm{f}}}| & \\text{if $ x$ is right of $ p_\\ell$ }      \\end{array}\\right.\\ ] ]      we describe how to find an @xmath2-planar flow via biased search ( in the dual ) that does not necessarily search the entire graph , assuming that the initial capacities are c.w .",
    "we assume that there are no degree-2 vertices in the primal ; any such vertex could be removed by merging the adjacent darts ( in each direction ) and keeping the minimum of the capacities .",
    "parallel darts ( not antiparallel ) can be merged by taking the sum of their capacities .",
    "we additionally assume that the finite faces of the primal are triangulated ( which can be achieved by the addition of 0-capacity edges ) .",
    "r0.5    we implicitly and iteratively build a decomposition as given in observation  [ obs : path - decomp ] using dijkstra s algorithm in the dual . initially @xmath60 $ ] . in phase @xmath61 , we have already found path @xmath54 ; we maintain that , at the start of phase @xmath61 , the faces adjacent to and right of @xmath54 are in the queue @xmath62 .",
    "( keep in mind that faces are vertices in the dual , and we are really just finding shortest paths in the dual graph , applying the standard rules for dijkstra s algorithm . ) the priority of face @xmath20 is the capacity of the minimum - capacity dart bounding @xmath20 in @xmath54 .",
    "say the minimum priority in the queue is @xmath63 ; to find @xmath64 we pop faces off the queue with priority @xmath63 until the minimum priority in the queue is @xmath65 .",
    "now we have popped off all the faces between @xmath54 and @xmath64 ( by equation  ( [ eq : distances ] ) ) and @xmath66 contains all the faces to the right of and adjacent to @xmath64 .",
    "so far , we have just described hassin s algorithm , but have made explicit the augmenting paths that are implicit in his algorithm . we have also identified _",
    "phases_. in each phase , all the faces of a given distance label are explored via 0-length darts ( in the dual ) .",
    "we modify the algorithm so that we do not explore the entire graph .",
    "note that all the faces to the right of @xmath67 ( the last augmenting path ) , by equation  ( [ eq : distances ] ) have distance label @xmath13 .",
    "rather than label all these faces , after getting to the start of phase @xmath68 , we wish to find the _",
    "leftmost cut_. let @xmath51 be the leftmost , shortest @xmath42-to-@xmath43 path in @xmath46 ; @xmath19 is the leftmost cut .",
    "the part of @xmath51 that is strictly to the right of @xmath67 consists of 0-length darts , since the sum of the capacities of the darts in @xmath51 that are in @xmath58 is @xmath13 by equation  ( [ eq : distances ] ) .",
    "in addition to identifying the leftmost cut , we wish to not explore any part of the graph strictly right of @xmath67 and @xmath51 .",
    "( see figure  [ fig : witness ] . )",
    "we find the leftmost cut by at each phase additionally maintaining an ordering @xmath69 of the faces in @xmath62 that reflects their order along @xmath54 from @xmath4 to @xmath3 .",
    "we maintain and query the ordering using the order maintenance data structure dsorder due to dietz and sleator  @xcite which is a circularly linked list with order information determined using 2 s complement arithmetic .",
    "( see appendix  [ app : order ] for details .",
    "each of the operations takes either @xmath70 or @xmath71 time per visited face . ) during a phase , we :    \\(1 ) start with faces that are closest to @xmath4 in the ordering .",
    "\\(2 ) explore along 0-length darts in the dual in a depth - first _ leftmost _ fashion ; this can be done by following the combinatorial embedding of the darts around a vertex in a c.w .",
    "order , using the parent dart in the search tree implicit to dijkstra s algorithm  @xcite .",
    "\\(3 ) if we reach @xmath43 during this search , we immediately stop the algorithm .",
    "( more details of this are given below . )",
    "\\(4 ) at the end of this 0-length exploration , we remove from the queue and order any faces that we have reached in this exploration .",
    "suppose @xmath72 is the dual search tree we have explored that contains the shortest paths found by dijkstra s algorithm , rooted at a face adjacent to @xmath54 .",
    "we add the never - visited faces adjacent to @xmath72 in their c.w .",
    "order around @xmath72 ( according to their shortest adjacency to @xmath72 ) .",
    "this ordering is easily visualized by contracting the edges of @xmath72 and considering the c.w .",
    "ordering of the darts around the new ( dual ) vertex .    at the start of each phase ,",
    "the queue and the order contain the same set of elements .",
    "the leftmost - bias to the search additionally guarantees that the final dual search tree @xmath72 contains leftmost shortest paths .",
    "this can be easily shown via induction .",
    "since we stop as soon as we reach @xmath43 and we search in a leftmost fashion , @xmath72 does not contain any darts _ strictly _ right of both the last flow path @xmath67 found and @xmath73 $ ] . in this way",
    ", we also guarantee :    [ obs : end ] at the end of this biased search , the queue and order contain the faces adjacent to and right of @xmath67 .    in our multi - source , multi - sink algorithm",
    ", we will reuse this queue and order .",
    "to do so , we need to know the residual capacities of the darts in @xmath67 .",
    "if a face @xmath26 in the queue has exactly one",
    "bounding arc in @xmath67 , then the priority of @xmath26 reflects exactly the residual capacity of that dart .",
    "if @xmath26 has two bounding darts @xmath74 and @xmath75 in @xmath67 ( i.e. , the head of @xmath76 and @xmath77 in @xmath29 is @xmath28 ) , then , _ to the right of @xmath67 _ , we can only push the minimum of these darts residual capacities along this section of @xmath67 .",
    "( put another way , if we remove everything strictly to the left of @xmath67 , @xmath74 and @xmath75 would be incident to a degree 2 vertex , which we would remove according to the rule at the start of this section . )",
    "we get :    [ obs : res - cap ] the priority of a face @xmath26 in the queue reflects the residual capacity of the dart(s ) bounding the face in @xmath67 ; the residual capacity is the priority less @xmath13 .",
    "subtracting @xmath13 from the priorities in the ending queue can be done in @xmath70 time using offset queues ( appendix  [ app : pq ] ) .",
    "finally , the dsorder data structure does not allow us to pull the _ first _ element of the order ( having minimum priority in the queue ) but does allow us to sort a subset of items .",
    "in doing so , we spend @xmath71-amortized time per element . we do not wish to repeat this work .",
    "if we reach @xmath43 in the middle of a phase and have a subset of items @xmath10 that we have sorted using dsorder , we break the ties in the priorities of these items in the priority queue .",
    "when we return to use this queue / order , we will not need to resort these items .",
    "for simplicity of presentation we will assume that the terminals are alternating sources and sinks along @xmath30 .",
    "this can be attained by taking a consecutive group of sources @xmath78 , introducing a new source and connecting the new source to every source in @xmath78 with an infinite capacity arc .",
    "we number the sources and sinks according to their c.w .  ordering on @xmath30 , @xmath79 , starting with an arbitrary source .",
    "we return the difference between the original capacities and final residual capacities , which , by equation  ( [ eq : res ] ) , is the corresponding flow .",
    "[ tab : algo - super - high - level ] abstractflow ( @xmath18 , @xmath80 , @xmath6 ) + saturate all @xmath81-to-@xmath82 residual paths @xmath57 and all c.w .  cycles .",
    "+ let @xmath83 be the resulting residual capacities .",
    "+ for @xmath84 : + for @xmath85 : + = let @xmath86 be the current residual capacities .",
    "+ find the leftmost @xmath87-to-@xmath88 flow @xmath89 w.r.t .",
    "+ let @xmath90 be the residual capacities of @xmath86 w.r.t .",
    "+ return @xmath91-{\\bm{c}}_{mm}[d]$ ] for all darts @xmath23 .",
    "\\(a ) ( b ) -to-@xmath92 path , since the method for saturating all c.c.w .  cycles ( like for c.w .",
    "cycles ) saturates all largest such cycles .",
    "however , doing so would create a residual path from @xmath93 to @xmath94.,title=\"fig : \" ]    the first step can be done with one shortest - path computation in the dual as follows ( in @xmath1 time using dijkstra s algorithm , for example ) ; refer to figure  [ fig : preprocess](a ) .",
    "embed a vertex @xmath20 in @xmath52 .",
    "connect @xmath20 to every source and every sink with infinite - capacity arcs .",
    "embed these arcs so that @xmath95 , @xmath96 and @xmath20 are on the infinite face .",
    "let @xmath12 be the circulation that saturates all the c.w .",
    "residual cycles in this graph ( theorem  [ thm : cwsat ] ) .",
    "let @xmath83 be the residual capacities of the darts in @xmath18 w.r.t .",
    "consider any simple path @xmath32 from @xmath81 to @xmath82 in @xmath18 .",
    "for @xmath97 , @xmath98 is a c.w .",
    ". therefore @xmath19 must be non - residual w.r.t .",
    "@xmath83 and , since the arcs @xmath99 and @xmath100 have infinite capacity , @xmath32 must be non - residual w.r.t .",
    "@xmath83 .    note that while the iterative part of the algorithm saturates all @xmath87-to-@xmath88 paths @xmath57 , we can not achieve this with a symmetric application of the first step .",
    "the simple example in figure  [ fig : preprocess](b ) illustrates why .",
    "in the remainder of the paper we will give an efficient implementation of the double loop of abstractflow .",
    "we first show that the abstract algorithm guarantees several useful invariants that limit the region of the graph that is involved in each iteration .",
    "these invariants allow us to explore the graph in such a way that no region is explored multiple times .",
    "correctness of abstractflow will also follow from these invariants . by iteration @xmath101 ,",
    "we will mean iteration @xmath61 of the inner loop and iteration @xmath102 of the outer loop .",
    "since only leftmost flows are augmented we get ( by definition and induction ) :    [ inv : no - cw - cycles ] there are no clockwise residual cycles in @xmath18 w.r.t .",
    "@xmath103 .",
    "since the sink is in common to all the iterations of the inner loop , for a given iteration of the outer loop , we get :    [ inv : inner - loop ] there are no residual @xmath81-to-@xmath104 paths w.r.t .",
    "@xmath105 for @xmath97 .",
    "more formally , this follows from the sinks lemma  @xcite .",
    "the following invariant shows that we do not undo the progress made by the first step of abstractflow .",
    "[ inv : no - back - flow ] there are no @xmath87-to-@xmath88 residual paths s.t .",
    "@xmath106 w.r.t .",
    "@xmath83 or @xmath107 , @xmath108 .",
    "we prove this invariant by induction .",
    "it holds w.r.t .",
    "@xmath83 as argued in section  [ sec : max - flow - shortest ] . for a contradiction ,",
    "let @xmath109 be the first residual capacities that introduce an @xmath87-to-@xmath88 residual path @xmath110 ( @xmath111 ) .",
    "then there must be an @xmath112-to-@xmath113 path @xmath114 that is augmented in iteration @xmath115 and that uses a dart @xmath23 in @xmath116 .",
    "let @xmath20 and @xmath21 be the last and first , resp . , vertices of @xmath110 that are in @xmath114 .",
    "@xmath114 , @xmath117 $ ] and @xmath118 $ ] are residual w.r.t .",
    "@xmath119 ( the residual capacities at the start of iteration @xmath115 ) .",
    "it follows that @xmath120 and @xmath121 , for otherwise we contradict the inductive hypothesis .",
    "however , iteration @xmath115 comes after @xmath122 in abstractflow .",
    "invariant  [ inv : inner - loop ] tells us that there can not be an @xmath87-to-@xmath123 path that is residual w.r.t .",
    "@xmath119 , contradicting the existence of @xmath117 \\circ    a[y , t_\\ell]$ ] .",
    "the optimality of the flow found by abstractflow follows from the last invariant ( along with invariants  [ inv : inner - loop ] and  [ inv : no - back - flow ] ) :    [ inv : overall - progress ] there are no @xmath87-to-@xmath88 residual paths w.r.t .",
    "@xmath124 for any @xmath68 and any @xmath125 .",
    "we prove this invariant by induction .",
    "it holds w.r.t .",
    "@xmath126 by invariant  [ inv : inner - loop ] . for a contradiction ,",
    "let @xmath124 be the first residual capacities that introduce an @xmath87-to-@xmath88 residual path @xmath110 .",
    "w.l.o.g .",
    "assume that @xmath127 as the case @xmath106 is handled by invariant  [ inv : no - back - flow ] .",
    "then there must be an @xmath128-to-@xmath104 path @xmath114 that is augmented in iteration @xmath129 and that uses a dart @xmath23 in @xmath116 .",
    "let @xmath20 and @xmath21 be the first and last , resp .",
    ", vertices of @xmath110 that @xmath114 shares . since @xmath114 and @xmath130 $ ] are residual , @xmath131 by invariant  [ inv : no - back - flow ] . however , by invariant  [ inv : inner - loop ] , there are no @xmath128-to-@xmath88 paths that are residual w.r.t .",
    "@xmath132 , so @xmath133 , a contradiction .",
    "we will illustrate our implementation of abstractflow with a recursive algorithm . to that end , we show that the cut and the flow found in iteration @xmath101 separates the graph into two pieces that act independently for the remainder of the algorithm .",
    "let @xmath32 be the rightmost path in the path decomposition of @xmath89 given in observation  [ obs : path - decomp ] ( that has non - zero flow ) .",
    "the following lemma allows us to delete everything strictly to the left of @xmath32 at the end of iteration @xmath101 for future iterations without affecting optimality .",
    "[ lem : path - bdy ] there are no paths from @xmath112 to @xmath32 that are residual w.r.t .",
    "@xmath90 for @xmath134 .",
    "first we make an observation .",
    "inner iterations @xmath135 are equivalent to adding a new source @xmath3 , connecting @xmath3 to @xmath136 by high - capacity arcs and saturating the leftmost max @xmath137-flow . by observation  [ obs : path - decomp ] , this is done by saturating a set of non - crossing @xmath3-to-@xmath104 paths @xmath138 ordered from left to right . in abstractflow , iteration @xmath129 will saturate a contiguous subset @xmath139 of @xmath140 for @xmath141 . by saturating these paths in order , we first cut @xmath81 from @xmath104 by saturating @xmath142 , then cut @xmath143 from @xmath104 and so on .    for @xmath144",
    ", the lemma follows from the fact that iteration @xmath145 precedes @xmath101 : a path @xmath33 , from @xmath112-to-@xmath32 concatenated with the suffix of @xmath32 , would be saturated before @xmath32 . for @xmath125",
    ", @xmath33 would be residual w.r.t .",
    "capacities @xmath86 since @xmath89 does not change the capacities of darts strictly to the right of @xmath32 ; @xmath33 violates invariant  [ inv : no - back - flow ] .",
    "let @xmath19 be the leftmost minimum @xmath146-cut .",
    "the next lemma shows that we can delete the darts in @xmath19 ( among others on the @xmath88 side of the cut ) without affecting optimality . in the biased - search algorithm ( section  [ sec : biased ] ) , the darts satisfying lemma  [ lem : unusable - cuts ] are exactly those that are searched to the right of the last flow path ( @xmath72 ) in finding the leftmost cut ( @xmath19 ) .    [",
    "lem : unusable - cuts ] let @xmath147 be any from-@xmath42 @xmath148-length path in @xmath149 that is left of @xmath51 .",
    "then no @xmath3-to-@xmath4 path that is residual w.r.t .",
    "@xmath90 uses a dart in @xmath150 .    for a contradiction , suppose there is a @xmath112-to-@xmath123 path @xmath110 that is residual w.r.t",
    "@xmath90 that uses a dart of @xmath150 .",
    "since , by invariant  [ inv : no - back - flow ] , @xmath151 , @xmath112 must be on the @xmath88 side of @xmath19 for otherwise , @xmath110 would have to cross back and forth across @xmath19 , but the darts of @xmath19 are only residual w.r.t .",
    "@xmath90 from the @xmath88 side to the @xmath87 side .",
    "we have just finished iteration @xmath101 , @xmath125 , and",
    "so , by invariant  [ inv : no - back - flow ] , there is an @xmath152-cut @xmath153 .",
    "take @xmath153 to be the _ rightmost _ of these cuts ( defined analogously to leftmost ) . in @xmath149",
    ", @xmath154 is a c.c.w .",
    "cycle through @xmath43 ; @xmath154 is 0-length ( or , equivalently , composed entirely of darts that are non - residual w.r.t .",
    "@xmath90 ) .",
    "@xmath154 must be left of @xmath51 , for otherwise , the leftmost - ness of @xmath51 and the rightmost - ness of @xmath154 would be violated .",
    "if @xmath110 uses a dart @xmath23 of @xmath150 , then @xmath23 must be on the @xmath112 side of @xmath153 .",
    "then , in the dual , @xmath147 must intersect @xmath154 at a dual vertex @xmath48 .",
    "but then @xmath155 \\circ k^*[x^*,b_\\infty^*]$ ] is a @xmath42-to-@xmath43 path of length at most that of @xmath147 ; @xmath155 \\circ k^*[x^*,b_\\infty^*]$ ] is left of @xmath51 , contradicting that @xmath19 is a leftmost cut .",
    "lemmas  [ lem : path - bdy ] and  [ lem : unusable - cuts ] allow us to implement abstractflow recursively .",
    "that is , abstractrecursiveflow , below , finds the same ( non - zero ) flows @xmath89 in the same order as abstractflow .",
    "the recursive algorithm has a slightly different input , as there may be several consecutive sources for the recursive calls .",
    "we illustrate the algorithm without explicitly returning the flow .",
    "it is trivial to determine the flow from the residual capacities found throughout the algorithm .",
    "abstractrecursiveflow(@xmath18 , @xmath156 , @xmath6 ) + = saturate all @xmath81-to-@xmath82 residual paths @xmath57 and all c.w .  cycles .",
    "+ let @xmath83 be the resulting residual capacities .",
    "+ ( @xmath18 , @xmath157 , @xmath156 , @xmath83 )    abstractrecursiveflowhelper(@xmath18 , @xmath158 } , @xmath159 , @xmath6 ) + = find the leftmost @xmath128-to-@xmath123 flow @xmath12 w.r.t .",
    "+ let @xmath160 be the residual capacities of @xmath6 w.r.t .",
    "+ let @xmath32 be the rightmost path in the path - decomposition of @xmath12 and let @xmath19 be the leftmost cut .",
    "+ let @xmath161 and @xmath162 be the components resulting from deleting all the darts + = strictly to the left of @xmath32 and the darts of @xmath19 from @xmath18 .",
    "+ if @xmath163 : + let @xmath164 be the greatest index s.t .",
    "+ ( @xmath162 , @xmath157 , @xmath166 , @xmath160 ) + let @xmath167 be the smallest index @xmath168 s.t .",
    "+ extend @xmath33 and @xmath114 to contain all the faces in @xmath170 that are incident to @xmath42 + @xmath171 , @xmath172 + else : + let @xmath102 be the greatest index @xmath173 s.t .",
    "+ ( @xmath161 , @xmath175 , @xmath176 , @xmath160 ) +    r0.55      abstractrecursiveflow implements abstractflow .",
    "refer to figure  [ fig : subprob ] . by lemmas  [ lem : path - bdy ] and  [ lem : unusable - cuts ] , the deleted edges are _ safe _ to remove : solving the problem in the two subproblems",
    "will indeed find an optimal solution .",
    "the @xmath177 augmentation performed by abstractrecursiveflowhelper corresponds to an iteration of abstractflow .",
    "if there are residual source - to-@xmath123 paths remaining after this augmentation , then there would necessarily be one such path from @xmath95 , and @xmath178 .",
    "abstractrecursiveflowhelper would continue to push flow from earlier sources to @xmath123 , just as abstractflow .",
    "otherwise , both abstract- and abstractrecursive - flow would move onto the next sink , in which case @xmath163 .",
    "we show how to implement abstractrecursiveflow using @xmath0 queries to simple data structures : the priority queue and dsorder data structure ( which is at heart a linked list ) . the challenge in doing so can be illustrated by a simple example .",
    "suppose @xmath95 has a high - capacity path @xmath32 with many edges ending with a low - capacity star that connects to each of the sinks .",
    "in each iteration of the outer loop , we could require augmenting the flow along this long path .",
    "we overcome this barrier by reusing the work from earlier iterations in later iterations .",
    "we give an implementation ( recursiveflow ) of abstractrecursiveflowhelper .",
    "to implement the first step of abstractrecursiveflowhelper , we use the biased - search algorithm described in section  [ sec : biased ] . note that the subproblem corresponding to terminal sets @xmath179 , @xmath180 results from having found maximum flows from @xmath181 to @xmath123 .",
    "we keep the queue and order at the end of the biased - search algorithm used to find these flows .",
    "formally , we will pass to recursiveflow a queue and order for each source @xmath87 , @xmath182 .",
    "the queue @xmath62 and order @xmath69 contains all the faces adjacent to and right of @xmath183 $ ] for @xmath184 and @xmath185 $ ] for @xmath186 .",
    "the order reflects the c.c.w .",
    "ordering of the faces along @xmath30 .",
    "the priority of a face @xmath26 in @xmath62 is the current residual capacity of the primal copy of the dart @xmath187 .",
    "recall from section  [ sec : biased ] that the biased - search algorithm guarantees this at the end of the search .",
    "recursiveflow@xmath188 , @xmath159 , @xmath189 + 1= find the leftmost @xmath177-flow @xmath12 via biased - search using @xmath190 as the starting queue , order .",
    "+ 2 let @xmath32 be the rightmost path in @xmath12 and let @xmath72 be the search tree .",
    "+ 3 let @xmath191 be the queue and order at the end of this search .",
    "+ 4 subtract @xmath13 from the priorities in @xmath33 .",
    "+ 5 delete everything to the left of @xmath32 in @xmath18 .",
    "+ 6 delete from @xmath18 the darts in @xmath72 that are left of @xmath32 creating components + = @xmath161 ( that contains @xmath95 ) and @xmath162 .",
    "+ 7 if @xmath163 : + 8 initialize the queue @xmath192 and ordering @xmath193 of the dual vertices + adjacent to @xmath42 in @xmath194 + 9 let @xmath164 be the greatest index s.t .",
    "+ 10 @xmath195 + 11 let @xmath167 be the smallest index @xmath168 s.t .",
    "+ 12 extend @xmath33 and @xmath114 to contain all the faces in @xmath196 that are incident to @xmath42 + not currently in @xmath197 with the appropriate priority / order .",
    "+ 13@xmath198 , @xmath199 + 14 else : + 15 let @xmath102 be the greatest index @xmath173 s.t .",
    "+ 16 extend @xmath200 to @xmath33 and @xmath201 to @xmath114 , adding the missing faces in @xmath202 that are incident to @xmath42 .",
    "+ 17@xmath203 , @xmath204    [ [ running - time - and - correctness - of - recursiveflow ] ] running time and correctness of recursiveflow + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    by observation  [ obs : res - cap ] , step 4 results in the priorities reflecting exactly the residual capacities of the darts in @xmath32 after saturating @xmath12 .",
    "@xmath161 and @xmath162 are the same as the subgraphs created in abstractrecursiveflow , as are the subproblems considered .",
    "the removed darts create a new boundary and so maintain triangulation of the finite faces .",
    "step 12 can be done in @xmath71 per new face added ( appendices  [ app : pq ] and  [ app : order ] ) . adding the faces can be achieved by a left - first search from @xmath33 ( or from @xmath200 to @xmath33 ) ; this creates the queue and order along the boundary of the graph . in order to combine the orders @xmath201 and @xmath114 in line 16",
    ", we observe that the order @xmath201 is guaranteed to be right of the order @xmath114 when they are joined together .",
    "the dsorder data structure allows us to concatenate these orders efficiently ( details in appendix  [ app : order ] ) .    finally , we argue that the entire algorithm requires only @xmath0 queries to priority queue and dsorder data structure .",
    "the biased - search algorithm uses @xmath205 priority - queue and dsorder queries where @xmath164 is the size of the search tree discovered ( section  [ sec : biased ] ) .",
    "this is in part due to the triangulation of the finite faces ; the degree of the vertices from which we search during the biased - search algorithm have degree 3 , so the 0-length darts leaving a vertex can be determined in constant time .    for the subproblem @xmath161 ,",
    "we start with queues that have already been initialized , so , as argued at the end of section  [ sec : biased ] , we essentially pick up the search where we left off , not repeating any computation at the boundary where we left off ( the rightmost path in a previous flow ) . for the subproblem @xmath162 , @xmath32 forms part of the boundary and so part of the queue / order ending at @xmath123",
    "appear in this subgraph .",
    "however , by lemma  [ lem : path - bdy ] , no residual path intersects @xmath32 .",
    "since the finite faces are triangulated , no path can intersect a face adjacent to @xmath32 without intersecting @xmath32 .",
    "therefore , none of the faces in the queue / order along @xmath32 will be used in the subproblem corresponding to @xmath162 .",
    "it follows that there are a constant number of data - structure queries per finite face of the original graph",
    ".    13    m.  bender , r.  cole , e.  demaine , m.  farach - colton , j.  zito .",
    "two simplified algorithms for maintaining order in a list . in _ proc .",
    "esa _ , pages 152164 , 2002 .",
    "g.  borradaile and a.  harutyunyan .",
    "maximum st - flow in directed planar graphs via shortest paths . to appear in _ proc .",
    "iwoca _ , 2013 .",
    "g.  borradaile and p.  klein .",
    "an @xmath206 algorithm for maximum st - flow in a directed planar graph .",
    ", 56(2):130 , 2009 .",
    "g.  borradaile , p.  klein , s.  mozes , y.  nussbaum , c.  wulff - nilsen .",
    "multiple - source multiple - sink maximum flow in directed planar graphs in near - linear time . in _ proc .",
    "focs _ , pages 170179 , 2011 .",
    "g.  borradaile . .",
    "phd thesis , brown university , 2008 .",
    "dietz and d.  sleator . two algorithms for maintaining order in a list . in _ proc .",
    "stoc _ , pages 365372 , 1987 .",
    "c.  ford and d.  fulkerson .",
    "maximal flow through a network .",
    ", 8:399404 , 1956 .",
    "a.  goldberg and c.  harrelson .",
    "computing the shortest path : a search meets graph theory . in _ proc .",
    "pages 156165 , 2005 .",
    "r.  hassin .",
    "maximum flow in @xmath207 planar networks .",
    ", 13:107 , 1981 .",
    "m.  henzinger , p.  klein , s.  rao , s. subramanian .",
    "faster shortest - path algorithms for planar graphs .",
    ", 55(1):323 , 1997 .",
    "s.  khuller , j.  naor , p.  klein .",
    "the lattice structure of flow in planar graphs .",
    ", 6(3):477490 , 1993 .",
    "g.  miller and j.  naor flow in planar graphs with multiple sources and sinks .",
    ", 24(5):10021017 , 1995 .",
    "h.  whitney planar graphs . , 21:7384 , 1933 .",
    "we show how to efficiently change all the priorities in a queue by a fixed amount .",
    "this will be used when we wish to merge two priority queues whose relative priorities differ by a constant .",
    "that is , we have two priority queues @xmath32 and @xmath33 that we want to merge , but the priorities of the items in @xmath32 are _ offset _ from those in @xmath33 by some amount @xmath208 .",
    "we illustrate this for a binomial - heap implementation of priority queues , but this technique is not limited to a specific implementation ( although the details of handling the offsets will depend on the implementation ) .    for the purposes of this discussion the details of a binomial heap , beyond the fact that it is a set of rooted trees , are irrelevant .",
    "we refer the reader to any data structures textbook for details .",
    "we will argue that the standard operations ( insert , find minimum , delete minimum , decrease key and merge ) will have the same asymptotic running time with offsets as without . to do so",
    ", we annotate the edges of the trees in the heap with weights , initially zero . we give the roots of the trees a dummy parent edge so that every item in the queue ( node in a tree ) @xmath20 has a unique parental edge weight @xmath209 .",
    "we say that node @xmath20 has a local priority @xmath210 and a global priority @xmath211 where @xmath211 is the sum of @xmath210 plus the parental edge weights on the path to the root of the binomial tree containing @xmath20 ( including the weight of the dummy root edge ) .",
    "initially the global priorities are the same as the local priorities .",
    "we will maintain that the heap property holds for the global priorities ( ie .",
    "my children s global priorities are lower than mine ) .",
    "we describe the modifications we make to the binomial - heap - based priority queue operations :    insert : :    unchanged as insert reduces to merge .",
    "find min : :    the minimum priority element is guaranteed to be a root of one of the    trees .",
    "when comparing the roots of the trees , first sum the local    priority and dummy root edge weight .",
    "delete min : :    the standard operation is to delete the root that is the minimum    priority element and then merge the resulting child trees with the    remaining trees .",
    "we first add the weight of the dummy root edge to the    weights of the child edges ; these child edges become dummy parent    edges of the trees before they are merged .",
    "decrease key : :    the standard operation traverses the path from the node in question ,    @xmath20 to the root and swaps nodes that violate the heap    property . first compute the global priorities of the nodes on the    @xmath20 to root path . then traverse to the to - root path :",
    "say    @xmath20 is a child of @xmath21 such that    @xmath212 ; let @xmath213 be the weight of the    edge @xmath17 .",
    "swap @xmath20 and @xmath21 , add    @xmath213 to @xmath210 and subtract    @xmath213 from @xmath214 .",
    "merge : :    if we want to merge heap @xmath32 with heap @xmath33 in    such a way that the priorities in @xmath32 are by an offset    @xmath208 higher than those in @xmath33 , @xmath208    is added to the weight of the dummy root edges of @xmath32 and    in comparing the priorities of the roots of trees in @xmath32    to those in @xmath33 , the global priorities are used .",
    "merging    binomial heaps is otherwise trivial .",
    "we note that our modifications to not increase the asymptotic complexity of the operations .",
    "although we do not need to maintain local priorities for our algorithm , we point out that local priorities can be retained .",
    "however , in the decrease - key operation , the weight of sibling edges would need to be modified as well , and , for binomial heaps , would require @xmath215 time .",
    "in order to maintain the left - to - right order of faces in the priority queue we refer to an order maintenance data structure dsorder due to dietz and sleator  @xcite .",
    "dsorder supports the following operations :    1 .",
    "@xmath216 : insert a new element @xmath217 immediately after element @xmath10 in the total order .",
    "@xmath218 : remove an element @xmath10 from the total order .",
    "@xmath219 : determine whether @xmath10 precedes @xmath217 in the total order    while there are other data structures that are more efficient asymptotically  @xcite , dsorder is attractive for its simplicity , as it only relies on basic data structures .",
    "dsorder is implemented as a circularly linked list that implicitly encodes the label bits to represent paths in a hypothetical @xmath220 tree and uses @xmath221 s complement arithmetic and a wrapping modulo to efficiently perform renumbering , giving :      dsorder generally draws its labels from integers in @xmath223 , where @xmath224 is sufficiently large , where @xmath222 is the size of the order . ] . since in our algorithm",
    "every face in a newly created order is _ right of _ the faces in the previous order , we modify this range as we move left - to - right to make simple concatenation possible .",
    "i.e. if @xmath225 is the largest label in the order @xmath69 , the labels for @xmath226 are drawn from @xmath227 , where @xmath224 is large w.r.t .",
    "the size of the graph .",
    "then , an order @xmath228 created after an order @xmath114 , can be appended to @xmath114 in constant time via standard linked list operations ."
  ],
  "abstract_text": [
    "<S> we give an iterative algorithm for finding the maximum flow between a set of sources and sinks that lie on the boundary of a planar graph . </S>",
    "<S> our algorithm uses only @xmath0 queries to simple data structures , achieving an @xmath1 running time that we expect to be practical given the use of simple primitives . </S>",
    "<S> the only existing algorithm for this problem uses divide and conquer and , in order to achieve an @xmath1 running time , requires the use of the ( complicated ) linear - time shortest - paths algorithm for planar graphs .    flow , multiple terminal , planar graphs </S>"
  ]
}