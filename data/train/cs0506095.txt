{
  "article_text": [
    "probabilistic logic programming ( plp ) is a framework that extends the expressive power of bayesian networks with first - order logic @xcite .",
    "the core of the plp framework is a backward - chaining procedure , which generates a bayesian network graphic structure from a logic program in a way quite like query evaluation in logic programming .",
    "therefore , existing plp methods use a slightly adapted _ sld- _ or _ sldnf - resolution _ @xcite as the backward - chaining procedure .",
    "recursive loops in a logic program are sld - derivations of the form @xmath5 where for any @xmath6 , @xmath1 is the same as @xmath7 up to variable renaming .",
    "such loops present a challenging problem to the plp framework . on the one hand",
    ", they loop forever so that the plp backward - chaining inferences would never stop . on the other hand",
    ", they may generate cyclic influences , which are disallowed in bayesian networks .",
    "two representative approaches have been proposed to avoid recursive loops .",
    "the first one is by ngo and haddawy @xcite and kersting and de raedt @xcite , who restrict to considering only acyclic logic programs @xcite .",
    "the second approach , proposed by glesner and koller @xcite , uses explicit time parameters to avoid occurrence of recursive loops .",
    "it enforces acyclicity using time parameters in the way that every predicate has a time argument such that the time argument in the clause head is at least one time step later than the time arguments of the predicates in the clause body . in this way , each predicate @xmath8 is changed to @xmath9 and each clause @xmath10 is rewritten into @xmath11 , where @xmath12 , @xmath13 and @xmath14 are time parameters .    in this paper",
    ", we propose a solution to the problem of recursive loops under the plp framework .",
    "our method is not restricted to acyclic logic programs , nor does it rely on explicit time parameters .",
    "instead , it makes use of recursive loops to derive a stationary dynamic bayesian network .",
    "we will make two novel contributions .",
    "first , we introduce the _ well - founded _",
    "semantics @xcite of logic programs to the plp framework ; in particular , we use the well - founded model of a logic program to define the direct influence relation and apply _ slg - resolution _",
    "@xcite ( or _ sltnf - resolution _",
    "@xcite ) to make the backward - chaining inferences . as a result ,",
    "termination of the plp backward - chaining process is guaranteed .",
    "second , we observe that under the plp framework recursive loops ( cyclic influences ) define feedbacks , thus implying a time sequence .",
    "for instance , the clause @xmath15 introduces recursive loops @xmath16 together with some other clauses in a logic program , these recursive loops may generate cyclic influences of the form @xmath17 such cyclic influences represent feedback connections , i.e. , that @xmath18 _ is _ infected with aids ( in the current time slice @xmath19 ) depends on whether @xmath18 _ was _ infected with aids earlier ( in the last time slice @xmath20 ) .",
    "therefore , recursive loops of form ( [ loop1 ] ) imply a time sequence of the form @xmath21 where @xmath2 is a ground instance of @xmath22 . it is this observation that leads us to viewing a logic program with recursive loops as a special temporal model .",
    "such a temporal model corresponds to a stationary dynamic bayesian network and thus can be compactly represented as a two - slice dynamic bayesian network .",
    "the paper is structured as follows . in section 2 ,",
    "we review some concepts concerning bayesian networks and logic programs . in section 3",
    ", we introduce a new plp formalism , called bayesian knowledge bases . a bayesian knowledge base consists mainly of a logic program that defines a direct influence relation over a space of random variables . in section 4 ,",
    "we establish a declarative semantics for a bayesian knowledge base based on a key notion of influence clauses .",
    "influence clauses contain only ground atoms from the space of random variables and define the same direct influence relation as the original bayesian knowledge base does . in section 5 ,",
    "we present algorithms for building a two - slice dynamic bayesian network from a bayesian knowledge base .",
    "we describe related work in section 6 and summarize our work in section 7 .",
    "we assume the reader is familiar with basic ideas of bayesian networks @xcite and logic programming @xcite .",
    "in particular , we assume the reader is familiar with the well - founded semantics @xcite as well as slg - resolution @xcite . here",
    "we review some basic concepts concerning dynamic bayesian networks ( dbns ) .",
    "dbns are introduced to model the evolution of the state of the environment over time @xcite .",
    "briefly , a dbn is a bayesian network whose random variables are subscripted with time steps ( basic units of time ) or time slices ( i.e. intervals ) . in this paper , we use time slices .",
    "for instance , @xmath23 , @xmath24 and @xmath25 are random variables representing the weather situations in time slices @xmath20 , @xmath19 and @xmath26 , respectively .",
    "we can then use a dbn to depict how @xmath23 influences @xmath24 .",
    "a dbn is represented by describing the intra - probabilistic relations between random variables in each individual time slice @xmath19 ( @xmath27 ) and the inter - probabilistic relations between the random variables of each two consecutive time slices @xmath20 and @xmath19 .",
    "if both the intra- and inter - probabilistic relations are the same for all time slices ( in this case , the dbn is a repetition of a bayesian network over time ; see figure [ dbn - fig ] ) , the dbn is called a _",
    "dbn @xcite ; otherwise it is called a _ flexible _ dbn @xcite . as far as we know , most existing dbn systems reported in the literature are stationary dbns .    in a stationary dbn",
    "as shown in figure [ dbn - fig ] , the state evolution is determined by random variables like @xmath28 , @xmath29 and @xmath2 , as they appear periodically and influence one another over time ( i.e. , they produce cycles of direct influences ) .",
    "such variables are called _ state variables_. note that @xmath30 is not a state variable . due to the characteristic of stationarity ,",
    "a stationary dbn is often compactly represented as a two - slice dbn .    _ a _ two - slice _",
    "dbn for a stationary dbn consists of two consecutive time slices , @xmath20 and @xmath19 , which describes ( 1 ) the intra - probabilistic relations between the random variables in slice @xmath19 and ( 2 ) the inter - probabilistic relations between the random variables in slice @xmath20 and the random variables in slice @xmath19 .",
    "_    a two - slice dbn models a feedback system , where a cycle of direct influences establishes a feedback connection . for convenience ,",
    "we depict feedback connections with dashed edges .",
    "moreover , we refer to nodes coming from slice @xmath20 as _ state input nodes _ ( or _ state input variables _ ) .    _",
    "the stationary dbn of figure [ dbn - fig ] can be represented by a two - slice dbn as shown in figure [ feedback ] , where @xmath2 , @xmath28 and @xmath29 form a cycle of direct influences and thus establish a feedback connection .",
    "this stationary dbn can also be represented by a two - slice dbn starting from a different state input node such as @xmath31 or @xmath32 .",
    "these two - slice dbn structures are equivalent in the sense that they model the same cycle of direct influences and can be unrolled into the same stationary dbn ( figure [ dbn - fig ] ) .",
    "_    observe that in a two - slice dbn , all random variables except state input nodes have the same subscript @xmath19 . in the sequel ,",
    "the subscript @xmath19 is omitted for simplification of the structure .",
    "for instance , the two - slice dbn of figure [ feedback ] is simplified to that of figure [ feedback2 ] .",
    "in the rest of this section , we introduce some necessary notation for logic programs .",
    "variables begin with a capital letter , and predicate , function and constant symbols with a lower - case letter .",
    "we use @xmath33 to refer to any predicate / atom whose predicate symbol is @xmath34 and use @xmath35 to refer to @xmath36 where all @xmath37s are variables .",
    "there is one special predicate , @xmath38 , which is always logically true .",
    "a predicate @xmath35 is _ typed _ if its arguments @xmath39 are typed so that each argument takes on values in a well - defined finite domain .",
    "a ( general ) logic program @xmath40 is a finite set of clauses of the form @xmath41 where @xmath2 , the @xmath42s and @xmath43s are atoms .",
    "we use @xmath44 and @xmath45 to denote the herbrand universe and herbrand base of @xmath40 , respectively , and use @xmath46@xmath47@xmath48 to denote the well - founded model of @xmath40 , where @xmath49 , and every @xmath2 in @xmath50 is true and every @xmath2 in @xmath51 is false in @xmath52 . by a _ ( herbrand ) ground instance _ of a clause / atom @xmath28 we refer to a ground instance of @xmath28 that is obtained by replacing all variables in @xmath28 with some terms in @xmath44 .    a logic program @xmath40 is a _ positive _ logic program if no negative literal occurs in the body of any clause .",
    "@xmath40 is a _",
    "datalog _ program if no clause in @xmath40 contains function symbols .",
    "@xmath40 is an _",
    "logic program if there is a mapping @xmath53 from the set of ground instances of atoms in @xmath40 into the set of natural numbers such that for any ground instance @xmath54 of any clause in @xmath40 , @xmath55 @xmath56 @xcite .",
    "@xmath40 is said to have the _ bounded - term - size property _ w.r.t .",
    "a set of predicates @xmath57 if there is a function @xmath58 such that for any @xmath59 whenever a top goal @xmath60 has no argument whose term size exceeds @xmath61 , no atoms in any sldnf- ( or slg- ) derivations for @xmath62 have an argument whose term size exceeds @xmath58",
    "( this definition is adapted from @xcite ) .",
    "in this section , we introduce a new plp formalism , called bayesian knowledge bases .",
    "bayesian knowledge bases accommodate recursive loops and define the direct influence relation in terms of the well - founded semantics .",
    "[ kb ]    _ a _ bayesian knowledge base _ is a triple @xmath63@xmath64@xmath48 , where _    * @xmath65 is a logic program , each clause in @xmath66 being of the form @xmath67 where ( i ) the predicate symbols @xmath68 only occur in @xmath66 and ( ii ) @xmath33 is typed so that for each variable @xmath37 in it with a finite domain @xmath69 ( a list of constants ) there is an atom @xmath70 in the clause body .",
    "* @xmath71 is a set of conditional probability tables ( cpts ) of the form @xmath72 @xmath73 , each being attached to a clause ( [ cll-2 ] ) in @xmath66 .",
    "* @xmath74 is a combination rule such as _ noisy - or , min _ or _",
    "max _ @xcite .",
    "a bayesian knowledge base contains a logic program that can be divided into two parts , @xmath66 and @xmath75 .",
    "@xmath66 defines a direct influence relation , each clause ( [ cll-2 ] ) saying that the atoms @xmath76 have direct influences on @xmath33 in the context that @xmath77 @xmath78 @xmath79 is true in @xmath65 under the well - founded semantics . note that the special literal @xmath38 is used in clause ( [ cll-2 ] ) to mark the beginning of the context ; it is always true in the well - founded model @xmath80 . for each variable @xmath37 in the head @xmath33",
    ", @xmath70 is used to enforce the type constraint on @xmath37 , i.e. the value of @xmath37 comes from its domain @xmath69 .",
    "@xmath75 assists @xmath66 in defining the direct influence relation by introducing some auxiliary predicates ( such as @xmath81 ) to describe contexts .",
    "can be defined in @xmath75 using a unit clause . ]",
    "clauses in @xmath75 do not describe direct influences .",
    "recursive loops are allowed in @xmath66 and @xmath75 .",
    "in particular , when some @xmath82 in clause ( [ cll-2 ] ) is the same as the head @xmath33 , a cyclic direct influence occurs .",
    "such a cyclic influence models a feedback connection and is interpreted as @xmath33 at present depending on itself in the past .    in this paper , we focus on datalog programs , although the proposed approach applies to logic programs with the bounded - term - size property ( w.r.t . the set of predicates appearing in the heads of clauses in @xmath66 ) as well .",
    "datalog programs are widely used in database and knowledge base systems @xcite and have a polynomial time complexity in computing their well - founded models @xcite . in the sequel",
    ", we assume that except for the predicate @xmath81 , @xmath65 is a datalog program .    for each clause ( [ cll-2 ] ) in @xmath66",
    ", there is a unique cpt , @xmath83 , in @xmath71 specifying the degree of the direct influences .",
    "such a cpt is shared by all instances of clause ( [ cll-2 ] ) .",
    "a bayesian knowledge base has the following important property .",
    "[ th - ground ] ( 1 ) all unit clauses in @xmath66 are ground .",
    "( 2 ) let @xmath84 be a goal with @xmath34 being a predicate symbol occurring in the head of a clause in @xmath66",
    ". then all answers of @xmath62 derived from @xmath85 by applying slg - resolution are ground .",
    "* proof : * ( 1 ) if the head of a clause in @xmath66 contains variables , there must be atoms of the form @xmath70 in its body .",
    "this means that clauses whose head contains variables are not unit clauses .",
    "therefore , all unit clauses in @xmath66 are ground .",
    "\\(2 ) let @xmath2 be an answer of @xmath62 obtained by applying slg - resolution to @xmath85",
    ". then @xmath2 must be produced by applying a clause in @xmath66 of form ( [ cll-2 ] ) with a most general unifier ( mgu ) @xmath86 such that @xmath87 and the body @xmath88",
    "@xmath89 @xmath90 is evaluated true in the well - founded model @xmath80 .",
    "note that the type constraints @xmath91 being evaluated true by slg - resolution guarantees that all variables @xmath37s in the head @xmath33 are instantiated by @xmath86 into constants in their domains @xmath69s .",
    "this means that @xmath2 is ground .",
    "@xmath92 + for the sake of simplicity , in the sequel for each clause ( [ cll-2 ] ) in @xmath66 , we omit its type constraints @xmath70 ( @xmath93 ) . therefore , when we say that the context @xmath94 @xmath95 is true , we assume that the related type constraints are true as well .",
    "[ aids - eg ]    _ we borrow the well - known aids program from @xcite ( a simplified version ) as a running example to illustrate our plp approach .",
    "it is formulated by a bayesian knowledge base @xmath96 with the following logic program:@xmath97@xmath48 may well contain contexts that describe a person s background information .",
    "the contexts together with @xmath98 , @xmath99 and @xmath100 are omitted here for the sake of simplicity . ] _",
    "@xmath101 = 1 .",
    "@xmath102 + 2 .",
    "@xmath103 + 3 . @xmath104 + 4 .",
    "@xmath105 + 5 .",
    "@xmath106 + 6 .",
    "@xmath107    note that both the 3rd and the 4-th clause produce recursive loops .",
    "the 3rd clause also has a cyclic direct influence .",
    "conceptually , the two clauses model the fact that the direct influences on @xmath108 come from whether @xmath109 was infected with aids earlier ( the feedback connection induced from the 3rd clause ) or whether @xmath109 has contact with someone @xmath110 who is infected with aids ( the 4-th clause ) .",
    "in this section , we formally describe the space of random variables and the direct influence relation defined by a bayesian knowledge base @xmath111 .",
    "we then define probability distributions induced by @xmath111 .",
    "a bayesian knowledge base @xmath111 defines a direct influence relation over a subset of @xmath112 .",
    "recall that any random variable in a bayesian network is either an input node ( with no parent nodes ) or a node on which some other nodes ( i.e. its parent nodes ) in the network have direct influences .",
    "since an input node can be viewed as a node whose direct influences come from an empty set of parent nodes , we can define a space of random variables from a bayesian knowledge base @xmath111 by taking all unit clauses in @xmath66 as input nodes and deriving the other nodes iteratively based on the direct influence relation defined by @xmath66 .",
    "formally , we have    [ bn - node ]    _ the _ space of random variables _ of @xmath111 , denoted @xmath113 , is recursively defined as follows : _    1 .",
    "all unit clauses in @xmath66 are random variables in @xmath113 .",
    "2 .   let @xmath114 be a ground instance of a clause in @xmath66 .",
    "if the context @xmath115 is true in the well - founded model @xmath80 and @xmath116 @xmath117 , then @xmath2 is a random variable in @xmath113 . in this case , each @xmath1 is said to have a _",
    "direct influence _ on @xmath2 .",
    "3 .   @xmath113 contains only those ground atoms satisfying the above two conditions .",
    "[ inf - by ] _ for any random variables @xmath2 , @xmath29 in @xmath113 , we say @xmath2 is _ influenced by _",
    "@xmath29 if @xmath29 has a direct influence on @xmath2 , or for some @xmath28 in @xmath113 @xmath2 is influenced by @xmath28 and @xmath28 is influenced by @xmath29 .",
    "cyclic influence _ occurs if @xmath2 is influenced by itself . _",
    "[ aids - eg - space ] _ the clauses 1 , 2 , 5 and 6 are unit clauses , thus random variables .",
    "@xmath118 is then derived applying the 4-th clause .",
    "consequently , @xmath119 .",
    "@xmath120 and @xmath118 have a direct influence on each other .",
    "there are three cyclic influences : @xmath121 is influenced by itself for each @xmath122 .",
    "_    let @xmath123@xmath47@xmath48 be the well - founded model of @xmath65 and let @xmath124 occurs in the head of some clause in @xmath125 .",
    "the following result shows that the space of random variables is uniquely determined by the well - founded model .",
    "[ v - is - ipb ] @xmath126 .",
    "* proof : * first note that all unit clauses in @xmath66 are both in @xmath113 and in @xmath127 .",
    "we prove this theorem by induction on the maximum depth @xmath128 of backward derivations of a random variable @xmath2 .",
    "( @xmath129 ) let @xmath130 .",
    "when @xmath131 , @xmath2 is a unit clause in @xmath66 , so @xmath132 . for the induction step ,",
    "assume @xmath133 for any @xmath134 whose maximum depth @xmath135 of backward derivations is below @xmath136 .",
    "let @xmath137 for @xmath2 .",
    "there must be a ground instance @xmath138 of a clause in @xmath66 such that the @xmath1s are already in @xmath113 and @xmath139 @xmath140 is true in the well - founded model @xmath80 .",
    "since the head @xmath2 is derived from the @xmath1s in the body , the maximum depth for each @xmath1 must be below the depth @xmath136 for the head @xmath2 . by the induction hypothesis ,",
    "the @xmath1s are in @xmath127 . by definition of the well - founded model",
    ", @xmath2 is true in @xmath80 and thus @xmath132 .",
    "( @xmath141 ) let @xmath132 .",
    "when @xmath131 , @xmath2 is a unit clause in @xmath66 , so @xmath130 . for the induction step ,",
    "assume @xmath134 for any @xmath133 whose maximum depth @xmath135 of backward derivations is below @xmath136 .",
    "let @xmath137 for @xmath2 .",
    "there must be a ground instance @xmath142 of a clause in @xmath66 such that the body is true in @xmath80 .",
    "note that the predicate symbol of each @xmath1 occurs in the head of a clause in @xmath66 .",
    "since the head @xmath2 is derived from the literals in the body , the maximum depth of backward derivations for each @xmath1 in the body must be below the depth @xmath136 for the head @xmath2 . by the induction hypothesis ,",
    "the @xmath1s are in @xmath113 . by definition [ bn - node ] , @xmath130 .",
    "@xmath92 + theorem [ v - is - ipb ] suggests that the space of random variables can be computed by applying an existing procedure for the well - founded model such as slg - resolution or sltnf - resolution . since slg - resolution has been implemented as the well - known @xmath143 system @xcite , in this paper we apply it for the plp backward - chaining inferences .",
    "slg - resolution is a tabling mechanism for top - down computation of the well - founded model . for any atom @xmath2 , during the process of evaluating a goal @xmath144 , slg - resolution stores all answers of @xmath2 in a space called _ table _ , denoted @xmath145 .",
    "let @xmath146 be the set of predicate symbols occurring in the heads of clauses in @xmath66 , and let @xmath147 .",
    "+ * algorithm 1 : computing random variables .",
    "*    1 .   @xmath148 .",
    "2 .   for each @xmath149 in @xmath150 1 .   compute the goal @xmath149 by applying slg - resolution to @xmath151 .",
    "2 .   @xmath152 .",
    "3 .   return @xmath153 .",
    "[ th - vi ] algorithm 1 terminates , yielding a finite set @xmath154 .",
    "* proof : * let @xmath123@xmath47@xmath48 be the well - founded model of @xmath65",
    ". by the soundness and completeness of slg - resolution , algorithm 1 will terminate with a finite output @xmath153 that consists of all answers of @xmath155 ( @xmath59 ) . by theorem [ th - ground ] , all answers in @xmath153 are ground .",
    "this means @xmath156 . hence , by theorem [ v - is - ipb ] @xmath154 .",
    "@xmath92 + we introduce the following principal concept .",
    "[ inf - clause ] _ let @xmath138 be a ground instance of the @xmath136-th clause in @xmath66 such that its body is true in the well - founded model @xmath80 .",
    "we call @xmath157 an _ influence clause_. '' would be omitted sometimes for the sake of simplicity . ]",
    "all influence clauses derived from all clauses in @xmath66 constitute the _ set of influence clauses _ of @xmath111 , denoted @xmath158 .",
    "_    the following result is immediate from definition [ bn - node ] and theorem [ v - is - ipb ] .",
    "[ icl - ground ] for any influence clause ( [ infcl ] ) , @xmath2 and all @xmath1s are random variables in @xmath113 .",
    "influence clauses have the following principal property .",
    "[ main - inf ] for any @xmath1 and @xmath2 in hb(pb ) , @xmath1 has a direct influence on @xmath2 , which is derived from the @xmath136-th clause in @xmath66 , if and only if there is an influence clause in @xmath158 of the form @xmath159 .",
    "* proof : * ( @xmath129 ) assume @xmath1 has a direct influence on @xmath2 , which is derived from the @xmath136-th clause in @xmath66 . by definition [ bn - node ] ,",
    "the @xmath136-th clause has a ground instance of the form @xmath160 such that @xmath94 @xmath95 is true in @xmath80 and @xmath161 @xmath117 . by theorem [ v - is - ipb ] ,",
    "@xmath162 is true in @xmath80 .",
    "thus , @xmath159 is an influence clause in @xmath158 .",
    "( @xmath141 ) assume that @xmath158 contains an influence clause @xmath163 @xmath164 .",
    "then the @xmath136-th clause in @xmath66 has a ground instance of the form @xmath165 @xmath166 such that its body is true in @xmath167 @xmath168 and ( by theorem [ icl - ground ] ) @xmath169 . by definition",
    "[ bn - node ] , @xmath130 and @xmath1 has a direct influence on @xmath2 .",
    "@xmath92 + the following result is immediate from theorem [ main - inf ] .",
    "[ corr1 ] for any atom @xmath2 , @xmath2 is in @xmath113 if and only if there is an influence clause in @xmath158 whose head is @xmath2 .",
    "theorem [ main - inf ] shows the significance of influence clauses : they define the same direct influence relation over the same space of random variables as the original bayesian knowledge base does .",
    "therefore , a bayesian network can be built directly from @xmath158 provided the influence clauses are available .",
    "observe that to compute the space of random variables ( see algorithm 1 ) , slg - resolution will construct a proof tree rooted at the goal @xmath149 for each @xmath59 @xcite . for each answer @xmath2 of @xmath155 in @xmath113",
    "there must be a success branch ( i.e. a branch starting at the root node and ending at a node marked with _ success _ ) in the tree that generates the answer .",
    "let @xmath170 be the @xmath136-th clause in @xmath66 that is applied to expand the root goal @xmath149 in the success branch and let @xmath86 be the composition of all mgus along the branch .",
    "then @xmath171 and the body @xmath172 is evaluated true , with the mgu @xmath86 , in @xmath80 by slg - resolution .",
    "this means that for each @xmath173 , @xmath174 is an answer of @xmath175 that is derived by applying slg - resolution to @xmath176 where @xmath177 is @xmath175 or some instance of @xmath175 . by theorem",
    "[ th - ground ] , all @xmath174s are ground atoms .",
    "therefore , @xmath178 is an influence clause .",
    "hence we have the following result .",
    "[ inf - branch ] let @xmath179 be a success branch in a proof tree of slg - resolution , @xmath180 @xmath181 be the @xmath136-th clause in @xmath66 that expands the root goal in @xmath179 , and @xmath86 be the composition of all mgus along @xmath179 .",
    "@xmath179 produces an influence clause @xmath178 .",
    "every success branch in a proof tree for a goal in @xmath150 produces an influence clause .",
    "the set of influence clauses can then be obtained by collecting all influence clauses from all such proof trees in slg - resolution .",
    "+ * algorithm 2 : computing influence clauses . *    1 .   for each goal @xmath149 in @xmath150 , compute all answers of @xmath155 by applying slg - resolution to @xmath151 while for each success branch starting at the root goal @xmath149 , collecting an influence clause from the branch into @xmath182 .",
    "2 .   return @xmath182 .",
    "[ th - infcl ] algorithm 2 terminates , yielding a finite set @xmath183 .",
    "* proof : * that algorithm 2 terminates is immediate from theorem [ th - vi ] , as except for collecting influence clauses , algorithm 2 makes the same derivations as algorithm 1 .",
    "the termination of algorithm 2 then implies @xmath182 is finite .    by theorem [ inf - branch ] ,",
    "any clause in @xmath182 is an influence clause in @xmath158 .",
    "we now prove the converse .",
    "let @xmath184 be an influence clause in @xmath158 .",
    "then the @xmath136-th clause in @xmath66 @xmath185 . has a ground instance of the form @xmath186 whose body is true in @xmath80 . by the completeness of slg - resolution , there must be a success branch in the proof tree rooted at a goal @xmath149 in @xmath150 where ( 1 ) the root goal is expanded by the @xmath136-th clause , ( 2 ) the composition of all mgus along the branch is @xmath86 , and ( 3 ) @xmath187 is an instance of @xmath188 . by theorem [ inf - branch ] , @xmath189 is an influence clause .",
    "since any influence clause is ground , @xmath189 is the same as @xmath184 .",
    "this influence clause from the success branch will be collected into @xmath182 by algorithm 2 .",
    "thus , any clause in @xmath158 is in @xmath182 .",
    "@xmath92    [ aids - eg - infcl ]    _ there are two predicate symbols , @xmath190 and @xmath191 , in the heads of clauses in @xmath192",
    ". let @xmath193 .",
    "algorithm 2 will generate two proof trees rooted at @xmath194 and @xmath195 , respectively , as shown in figures [ slg - aids ] and [ slg - aids2 ] . in the proof trees ,",
    "a label @xmath196 on an edge indicates that the @xmath197-th clause in @xmath66 is applied , and the other labels like @xmath198 on an edge show that an answer from a table is applied .",
    "each success branch yields an influence clause .",
    "for instance , expanding the root goal @xmath194 by the 3rd clause produces a child node @xmath194 ( figure [ slg - aids ] ) . then applying the answers of @xmath108 from the table @xmath199 to the goal of this node leads to three success branches . applying the mgu @xmath86 on each success branch to the 3rd clause yields three influence clauses of the form 3 .",
    "@xmath200 ( @xmath122 ) . as a result ,",
    "we obtain the following set of influence clauses : _    @xmath201 = 1 .",
    "@xmath102 + 2 .",
    "@xmath103 + 3 . @xmath202 + 3 .",
    "@xmath203 + 3 . @xmath204 + 4 .",
    "@xmath205 + 4 .",
    "@xmath206 + 5 .",
    "@xmath106 + 6 .",
    "@xmath107    for the computational complexity , we observe that the cost of algorithm 2 is dominated by applying slg - resolution to evaluate the goals in @xmath150 .",
    "it has been shown that for a datalog program @xmath40 , the time complexity of computing the well - founded model @xmath52 is polynomial @xcite .",
    "more precisely , the time complexity of slg - resolution is @xmath207 , where @xmath208 is the number of clauses in @xmath40 , @xmath209 is the maximum number of literals in the body of a clause , and @xmath210 , the number of atoms of predicates in @xmath40 that are not variants of each other , is a polynomial in the number of ground unit clauses in @xmath40 @xcite .",
    "@xmath65 is a datalog program except for the @xmath211 predicates ( see definition [ kb ] ) . since each domain",
    "@xmath69 is a finite list of constants , checking if @xmath37 is in @xmath69 takes time linear in the size of @xmath69 . let @xmath212 be the maximum number of @xmath211 predicates used in a clause in @xmath40 and @xmath213 be the maximum size of a domain @xmath69 . then the time of handling all @xmath211 predicates in a clause is bounded by @xmath214 . since each clause in @xmath40",
    "is applied at most @xmath210 times in slg - resolution , the time of handling all @xmath211s in all clauses in @xmath40 is bounded by @xmath215 .",
    "this is also a polynomial , hence slg - resolution computes the well - founded model @xmath80 in polynomial time .",
    "therefore , we have the following result .",
    "[ th - comp1 ]",
    "the time complexity of algorithm 2 is polynomial .      for any random variable @xmath2",
    ", we use @xmath216 to denote the set of random variables that have direct influences on @xmath2 ; namely @xmath216 consists of random variables in the body of all influence clauses whose head is @xmath2 .",
    "assume that the probability distribution @xmath217 is available ( see section [ sec_cpt ] ) .",
    "furthermore , we make the following _ independence assumption_.    [ ind - ass ] _ for any random variable @xmath2 , we assume that given @xmath216 , @xmath2 is probabilistically independent of all random variables in @xmath113 that are not influenced by @xmath2 . _",
    "we define probability distributions induced by @xmath111 in terms of whether there are cyclic influences .",
    "[ no - cycle ] _ when no cyclic influence occurs , the probability distribution induced by @xmath111 is @xmath218 . _",
    "[ th - prob ] @xmath219 under the independence assumption .",
    "* proof : * when no cyclic influence occurs , the random variables in @xmath113 can be arranged in a partial order such that if @xmath1 is influenced by @xmath175 then @xmath220 . by the independence assumption , we have @xmath218 @xmath221 @xmath222 @xmath221 @xmath223 @xmath221 @xmath224 @xmath221 @xmath225 @xmath221 @xmath226 @xmath92 + when there are cyclic influences , we can not have a partial order on @xmath113 . by definition [ inf - by ] and theorem [ main - inf ] , any cyclic influence , say ",
    "@xmath22 is influenced by itself , \" must be resulted from a set of influence clauses in @xmath158 of the form @xmath227 these influence clauses generate a chain ( cycle ) of direct influences @xmath228 which defines a feedback connection . since a feedback system can be modeled by a two - slice dbn ( see section [ subsec-1 - 1 ] ) , the above influence clauses represent the same knowledge as the following ones do : @xmath229 here the @xmath1s are state variables and @xmath230 is a state input variable . as a result ,",
    "@xmath22 being influenced by itself becomes @xmath22 being influenced by @xmath230 . by applying this transformation ( from influence clauses ( [ cyc - inf ] ) to ( [ cyc - inf2 ] ) ) , we can get rid of all cyclic influences and obtain a _",
    "generalized set _",
    "@xmath231 of influence clauses from @xmath158 .",
    "[ aids - eg - infclg ]    _ @xmath232 can be transformed to the following generalized set of influence clauses by introducing three state input variables @xmath233 , @xmath234 and @xmath235 .",
    "_    @xmath236 = 1 .",
    "@xmath102 + 2 .",
    "@xmath103 + 3 . @xmath237 + 3 .",
    "@xmath238 + 3 . @xmath239 + 4 .",
    "@xmath240 + 4 .",
    "@xmath206 + 5 .",
    "@xmath106 + 6 .",
    "@xmath107    when there is no cyclic influence , @xmath111 is a non - temporal model , represented by @xmath158 . when cyclic influences occur , however , @xmath111 becomes a temporal model , represented by @xmath231 .",
    "let @xmath241 be @xmath113 plus all state input variables introduced in @xmath231 .",
    "[ with - cycle ] _ when there are cyclic influences , the probability distribution induced by @xmath111 is @xmath242 . _    by extending the independence assumption from @xmath113 to @xmath241 , we obtain the following result .",
    "[ th - prob2 ] @xmath243 under the independence assumption .",
    "* proof : * since @xmath231 produces no cyclic influences , the random variables in @xmath241 can be arranged in a partial order such that if @xmath1 is influenced by @xmath175 then @xmath220 .",
    "the proof then proceeds in the same way as that of theorem [ th - prob ] .",
    "from a bayesian knowledge base @xmath111 , we can derive a set of influence clauses @xmath158 , which defines the same direct influence relation over the same space @xmath113 of random variables as @xmath65 does ( see theorem [ main - inf ] ) .",
    "therefore , given a probabilistic query together with some evidences , we can depict a network structure from @xmath158 , which covers the random variables in the query and evidences , by backward - chaining the related random variables via the direct influence relation .",
    "let @xmath244 be a probabilistic query and @xmath245 a set of evidences , where all random variables come from @xmath113 ( i.e. , they are heads of some influence clauses in @xmath158 ) .",
    "let @xmath246 consist of these random variables .",
    "an _ influence network _ of @xmath244 and @xmath245 , denoted @xmath247 , is constructed from @xmath158 using the following algorithm . +",
    "* algorithm 3 : building an influence network . *    1 .   [ alg3-item-1 ] initially , @xmath247 has all random variables in @xmath246 as nodes .",
    "[ alg3-item-2 ] remove the first random variable @xmath2 from @xmath246 . for each influence clause in @xmath158 of the form",
    "@xmath248 , if @xmath249 then add to @xmath247 an edge @xmath250 .",
    "otherwise , for each @xmath1 in the body 1 .   [ alg3-item-2a ] if @xmath1 is not in @xmath247 then add @xmath1 to @xmath247 as a new node and add it to the end of @xmath246 .",
    "2 .   [ alg3-item-2b ]",
    "add to @xmath247 an edge @xmath251 .",
    "repeat step 2 until @xmath246 becomes empty .",
    "4 .   return @xmath247 .",
    "[ aids - eg - inf - net ] _ to build an influence network from @xmath96 that covers @xmath120 , @xmath118 and @xmath252 , we apply algorithm 3 to @xmath253 @xmath254 while letting @xmath255 .",
    "it generates an influence network @xmath256 as shown in figure [ aids - inf - net ] .",
    "_    an influence network is a graphical representation for influence clauses .",
    "this claim is supported by the following properties of influence networks .",
    "[ th - alg3 ] for any @xmath257 in @xmath247 , @xmath175 is a parent node of @xmath1 , connected via an edge @xmath258 , if and only if there is an influence clause of the form @xmath259 in @xmath158 .",
    "* proof : * first note that termination of algorithm 3 is guaranteed by the fact that any random variable in @xmath113 will be added to @xmath246 no more than one time ( line [ alg3-item-2a ] ) .",
    "let @xmath257 be nodes in @xmath247 .",
    "if @xmath175 is a parent node of @xmath1 , connected via an edge @xmath258 , this edge must be added at line [ alg3-item-2b ] , due to applying an influence clause in @xmath158 of the form @xmath259 ( line [ alg3-item-2 ] ) .",
    "conversely , if @xmath158 contains such an influence clause , it must be applied at line [ alg3-item-2 ] , with edges of the form @xmath258 added to the network at line [ alg3-item-2b ] . @xmath92",
    "[ th - alg3 - 2 ] for any @xmath257 in @xmath247 , @xmath1 is a descendant node of @xmath175 if and only if @xmath1 is influenced by @xmath175 .",
    "* proof : * assume @xmath1 is a descendant node of @xmath175 , with a path @xmath260 by theorem [ th - alg3 ] , @xmath158 must contain the following influence clauses @xmath261 by theorem [ main - inf ] and definition [ inf - by ] , @xmath1 is influenced by @xmath175 .",
    "conversely , if @xmath1 is influenced by @xmath175 , there must be a chain of influence clauses of the form as above .",
    "since @xmath257 are in @xmath247 , by theorem [ th - alg3 ] there must be a path of form ( [ eq - k ] ) in the network .",
    "[ th - alg3 - 3 ] let @xmath262 be the set of nodes in @xmath247 and let @xmath263 for some @xmath264 , @xmath1 is influenced by @xmath265 .",
    "@xmath266 .",
    "* proof : * that @xmath247 covers all random variables in @xmath246 follows from line [ alg3-item-1 ] of algorithm 3 .",
    "we first prove that if @xmath267 then @xmath268 .",
    "assume @xmath267 .",
    "there must be a chain of influence clauses of form ( [ alg3-inf - chain ] ) with @xmath264 . in this case , @xmath269 will be recursively added to the network ( line [ alg3-item-2 ] ) . thus @xmath268 .",
    "we then prove that if @xmath268 and @xmath270 then @xmath267 .",
    "assume @xmath268 and @xmath270 .",
    "@xmath175 must not be added to @xmath262 at line [ alg3-item-1 ] .",
    "instead , it is added to @xmath262 at line [ alg3-item-2a ] .",
    "this means that for some @xmath264 , @xmath1 is a descendant of @xmath175 . by theorem [ th - alg3 - 2 ]",
    ", @xmath1 is influenced by @xmath175 .",
    "hence @xmath267 .",
    "@xmath92 + theorem [ th - prob ] shows that the probability distribution induced by @xmath111 can be computed over @xmath158 .",
    "let @xmath271 denote an influence network that covers all random variables in @xmath113 .",
    "we show that the same distribution can be computed over @xmath271 . for any node @xmath1 in @xmath271 ,",
    "let @xmath272 denote the set of parent nodes of @xmath1 in the network .",
    "observe the following facts : first , by theorem [ th - alg3 ] , @xmath273 .",
    "second , by theorem [ th - alg3 - 2 ] , @xmath1 is a descendant node of @xmath175 in @xmath271 if and only if @xmath1 is influenced by @xmath175 in @xmath158 .",
    "this means that the independence assumption ( assumption [ ind - ass ] ) applies to @xmath271 as well , and that @xmath158 produces a cycle of direct influences if and only if @xmath271 contains the same ( direct ) loop .",
    "combining these facts leads to the following immediate result .",
    "[ th - prob-1 ] when no cyclic influence occurs , the probability distribution induced by @xmath111 can be computed over @xmath271 .",
    "that is , @xmath218 @xmath221",
    "@xmath226 @xmath221 @xmath274 under the independence assumption .",
    "theorem [ th - prob-1 ] implies that an influence network without loops is a bayesian network structure .",
    "let us consider influence networks with loops . by theorem [ th - alg3 - 2 ] ,",
    "loops in an influence network are generated from recursive influence clauses of form ( [ cyc - inf ] ) and thus they depict feedback connections of form ( [ cyc - feedback ] ) .",
    "this means that an influence network with loops can be converted into a two - slice dbn , simply by converting each loop of the form    into a two - slice dbn path @xmath275 by introducing a state input node @xmath230 .    as illustrated in section [ subsec-1 - 1 ]",
    ", a two - slice dbn is a snapshot of a stationary dbn across any two time slices , which can be obtained by traversing the stationary dbn from a set of state variables backward to the same set of state variables ( i.e. , state input nodes ) .",
    "this process corresponds to generating an influence network @xmath247 from @xmath158 incrementally ( adding nodes and edges one at a time ) while wrapping up loop nodes with state input nodes .",
    "this leads to the following algorithm for building a two - slice dbn structure , @xmath276 , directly from @xmath158 , where @xmath244 , @xmath245 and @xmath246 are the same as defined in algorithm 3 . + * algorithm 4 : building a two - slice dbn structure . *",
    "1 .   initially , @xmath276 has all random variables in @xmath246 as nodes .",
    "2 .   remove the first random variable @xmath2 from @xmath246 . for each influence clause in @xmath158 of the form @xmath277 , if @xmath249 then add to @xmath276 an edge @xmath250 .",
    "otherwise , for each @xmath1 in the body 1 .   if @xmath1 is not in @xmath276 then add @xmath1 to @xmath276 as a new node and add it to the end of @xmath246 .",
    "[ loopcut ] if adding @xmath251 to @xmath276 produces a loop , then add to @xmath276 a node @xmath278 and an edge @xmath279 , else add an edge @xmath251 to @xmath276 .",
    "repeat step 2 until @xmath246 becomes empty .",
    "4 .   return @xmath276 .",
    "[ aids - eg2 ]    _ to build a two - slice dbn structure from @xmath96 that covers @xmath120 , @xmath118 and @xmath252 , we apply algorithm 4 to @xmath253 @xmath254 while letting @xmath255 .",
    "it generates @xmath280 as shown in figure [ aids ] . note that loops are cut by introducing three state input nodes @xmath233 , @xmath234 and @xmath235 .",
    "the two - slice dbn structure concisely depicts a feedback system where the feedback connections are as shown in figure [ feedback1 ] . _",
    "algorithm 4 is algorithm 3 enhanced with a mechanism for cutting loops ( item [ loopcut ] ) , i.e. when adding the current edge @xmath251 to the network forms a loop , we replace it with an edge @xmath279 , where @xmath278 is a state input node .",
    "this is a process of transforming influence clauses ( [ cyc - inf ] ) to ( [ cyc - inf2 ] ) .",
    "therefore , @xmath276 can be viewed as an influence network built from a generalized set @xmath231 of influence clauses .",
    "let @xmath241 be the set of random variables in @xmath231 , as defined in theorem [ th - prob2 ] .",
    "let @xmath281 denote a two - slice dbn structure ( produced by applying algorithm 4 ) that covers all random variables in @xmath241 .",
    "we then have the following immediate result from theorem [ th - prob-1 ] .",
    "[ th - prob-2 ] when @xmath158 produces cyclic influences , the probability distribution induced by @xmath111 can be computed over @xmath281 .",
    "that is , @xmath242 @xmath221 @xmath282 @xmath283 @xmath221 @xmath284 under the independence assumption .    _ note that algorithm 4 produces a dbn structure without using any explicit time parameters .",
    "it only requires the user to specify , via the query and evidences , what random variables are necessarily included in the network .",
    "algorithm 4 builds a two - slice dbn structure for any given query and evidences whose random variables are heads of some influence clauses in @xmath158",
    ". when no query and evidences are provided , we may apply algorithm 4 to build a _",
    "complete _ two - slice dbn structure , @xmath281 , which covers the space @xmath113 of random variables , by letting @xmath246 consist of all heads of influence clauses in @xmath158 .",
    "this is a very useful feature , as in many situations the user may not be able to present the right queries unless a bayesian network structure is shown .",
    "_    also note that when there is no cyclic influence , algorithm 4 becomes algorithm 3 and thus it builds a regular bayesian network structure .",
    "after a bayesian network structure @xmath276 has been constructed from a bayesian knowledge base @xmath111 , we associate each ( non - state - input ) node @xmath2 in the network with a cpt .",
    "there are three cases .",
    "( 1 ) if @xmath2 ( as a head ) only has unit clauses in @xmath158 , we build from the unit clauses a _",
    "prior _ cpt for @xmath2 as its prior probability distribution .",
    "( 2 ) if @xmath2 only has non - unit clauses in @xmath158 , we build from the clauses a _ posterior _ cpt for @xmath2 as its posterior probability distribution .",
    "( 3 ) otherwise , we prepare for @xmath2 both a prior cpt ( from the unit clauses ) and a posterior cpt ( from the non - unit clauses ) . in this case",
    ", @xmath2 is attached with the posterior cpt ; the prior cpt for @xmath2 would be used , if @xmath2 is a state variable , as the probability distribution of @xmath2 in time slice 0 ( only in the case that a two - slice dbn is unrolled into a stationary dbn starting with time slice 0 ) .",
    "assume that the parent nodes of @xmath2 are derived from @xmath61 ( @xmath285 ) different influence clauses in @xmath158 .",
    "suppose these clauses share the following cpts in @xmath71 : @xmath286 , ... , and @xmath287 .",
    "( recall that an influence clause prefixed with a number @xmath136 shares the cpt attached to the @xmath136-th clause in @xmath66 . )",
    "then the cpt for @xmath2 is computed by combining the @xmath61 cpts in terms of the combination rule @xmath74 specified in definition [ kb ] .",
    "_ let cpt@xmath288 denote the cpt attached to the @xmath197-th clause in @xmath192 .",
    "consider the random variables in @xmath280 .",
    "since @xmath120 has three parent nodes , derived from the 3rd and 4-th clause in @xmath192 respectively , the posterior cpt for @xmath120 is computed by combining cpt@xmath289 and cpt@xmath290 .",
    "@xmath120 has also a prior cpt , cpt@xmath291 , derived from the 1st clause in @xmath192 .",
    "for the same reason , the posterior cpt for @xmath118 is computed by combining cpt@xmath289 and cpt@xmath290 .",
    "the posterior cpt for @xmath252 is cpt@xmath289 and its prior cpt is cpt@xmath292 . @xmath293 and @xmath294 have only prior cpts , namely cpt@xmath295 and cpt@xmath296 .",
    "note that state input nodes , @xmath233 , @xmath234 and @xmath235 , do not need to have a cpt ; they will be expanded , during the process of unrolling the two - slice dbn into a stationary dbn , to cover the time slices involved in the given query and evidence nodes . if the resulting stationary dbn starts with time slice 0 , the prior cpts , cpt@xmath297 and cpt@xmath298 , for @xmath120 and @xmath252 are used as the probability distributions of @xmath299 and @xmath300 . _    note that @xmath118 is a state variable , but there is no unit influence clause available to build a prior cpt for it .",
    "we have two ways to derive a prior cpt , cpt@xmath301 , for @xmath118 from some existing cpts .",
    "( 1 ) cpt@xmath301 comes from averaging cpt@xmath297 and cpt@xmath298 .",
    "for instance , let the probability of @xmath302 be @xmath303 in cpt@xmath297 and the probability of @xmath304 be @xmath305 in cpt@xmath298 .",
    "then the probability of @xmath306 is @xmath307 in cpt@xmath301 .",
    "( 2 ) cpt@xmath301 comes from averaging the posterior probability distributions of @xmath118 .",
    "for instance , let @xmath308 be the posterior probabilities of @xmath306 in the posterior cpt for @xmath118 .",
    "then the probability of @xmath306 is @xmath309 in cpt@xmath301 .",
    "a recent overview of existing representational frameworks that combine probabilistic reasoning with logic ( i.e. logic - based approaches ) or with relational representations ( i.e. non - logic - based approaches ) is given by de raedt and kersting @xcite .",
    "typical non - logic - based approaches include probabilistic relational models ( prm ) , which are based on the entity - relationship ( or object - oriented ) model @xcite , and relational markov networks , which combine markov networks and sql - like queries @xcite .",
    "representative logic - based approaches include frameworks based on the kbmc ( knowledge - based model construction ) idea @xcite , stochastic logic programs ( slp ) based on stochastic context - free grammars @xcite , parameterized logic programs based on distribution semantics ( prism ) @xcite , and more .",
    "most recently , a unifying framework , called _ markov logic _ , has been proposed by domingos and richardson @xcite .",
    "markov logic subsumes first - order logic and markov networks . since our work follows the kbmc idea focusing on how to build a bayesian network directly from a logic program , it is closely related to three representative existing plp approaches : the context - sensitive plp developed by haddawy and ngo @xcite , bayesian logic programming proposed by kersting and raedt @xcite , and the time parameter - based approach presented by glesner and koller @xcite . in this section ,",
    "we make a detailed comparison of our work with the three closely related approaches .",
    "the core of the context - sensitive plp is a probabilistic knowledge base ( pkb ) . in order to see the main differences from our bayesian knowledge base ( bkb ) ,",
    "we reformulate its definition here .",
    "[ pkb ]    _ a _",
    "probabilistic knowledge base _ is a four tuple @xmath63@xmath310@xmath48 , where _",
    "* @xmath311 defines a set of probabilistic predicates ( _ p - predicates _ ) of the form @xmath312 @xmath313 where all arguments @xmath314s are typed with a finite domain and the last argument @xmath262 takes on values from a probabilistic domain @xmath315 . *",
    "@xmath66 consists of _ probabilistic rules _ of the form @xmath316 where @xmath317 , the @xmath1s are p - predicates , and the @xmath318s and @xmath319s are context predicates ( _ c - predicates _ ) defined in @xmath75 .",
    "* @xmath75 is a logic program , and both @xmath66 and @xmath75 are acyclic .",
    "* @xmath74 is a combination rule .    in a probabilistic rule ( [ p - rule ] ) , each p - predicate @xmath1 is of the form @xmath320 , which simulates an equation @xmath321 with @xmath322 being a value from the probabilistic domain of @xmath323 .",
    "for instance , let @xmath324 be the probabilistic domain of @xmath325 , then the p - predicate @xmath326 simulates @xmath327 , meaning that the color of @xmath109 is @xmath328 .",
    "the left - hand side @xmath329 expresses that the probability of @xmath330 conditioned on @xmath331 is @xmath332 .",
    "the right - hand side @xmath333 is the _ context _ of the rule where the @xmath318s and @xmath319s are c - predicates .",
    "note that the sets of p - predicate and c - predicate symbols are disjoint . a separate logic program @xmath75",
    "is used to evaluate the context of a probabilistic rule . as a whole ,",
    "the above probabilistic rule states that for each of its ( herbrand ) ground instances @xmath334 if the context @xmath335 is true in @xmath75 under the program completion semantics , the probability of @xmath336 conditioned on @xmath337 is @xmath332 .",
    "pkb and bkb have the following important differences .    first , probabilistic rules of form ( [ p - rule ] ) in pkb contain both logic representation ( right - hand side ) and probabilistic representation ( left - hand side ) and thus are not logic clauses . the logic part and the probabilistic part of a rule",
    "are separately computed against @xmath75 and @xmath66 , respectively .",
    "in contrast , bkb uses logic clauses of form ( [ cll-2 ] ) , which naturally integrate the direct influence information , the context and the type constraints .",
    "these logic clauses are evaluated against a single logic program @xmath65 , while the probabilistic information is collected separately in @xmath71 .",
    "second , logic reasoning in pkb relies on the program completion semantics and is carried out by applying sldnf - resolution .",
    "but in bkb , logic inferences are based on the well - founded semantics and are performed by applying slg - resolution .",
    "the well - founded semantics resolves the problem of inconsistency with the program completion semantics , while slg - resolution eliminates the problem of infinite loops with sldnf - resolution .",
    "note that the key significance of bkb using the well - founded semantics lies in the fact that a unique set of influence clauses can be derived , which lays a basis on which both the declarative and procedural semantics for bkb are developed .",
    "third , most importantly pkb has no mechanism for handling cyclic influences . in pkb ,",
    "cyclic influences are defined to be _ inconsistent _ ( see definition 9 of the paper @xcite ) and thus are excluded ( pkb excludes cyclic influences by requiring its programs be acyclic ) . in bkb , however , cyclic influences are interpreted as feedbacks , thus implying a time sequence .",
    "this allows us to derive a stationary dbn from a logic program with recursive loops .",
    "recently , fierens , blockeel , ramon and bruynooghe @xcite introduced _ logical bayesian networks _",
    "lbn is similar to pkb except that it separates logical and probabilistic information .",
    "that is , lbn converts rules of form ( [ p - rule ] ) into the form @xmath338 where the @xmath1s are p - predicates with the last argument @xmath262 removed , and the @xmath318s and @xmath319s are c - predicates defined in @xmath75 .",
    "this is not a standard clause of form ( [ eq1 ] ) as defined in logic programming @xcite . like pkb",
    ", lbn differs from bkb in the following : ( 1 ) it has no mechanism for handling cyclic influences ( see section 3.2 of the paper @xcite ) , and ( 2 ) although the well - founded semantics is also used for the logic contexts , neither declarative nor procedural semantics for lbn has been formally developed .      building on ngo and haddawy s work , kersting and de raedt @xcite",
    "introduce the framework of bayesian logic programs .",
    "a _ bayesian logic program _ ( blp ) is a triple @xmath63@xmath339@xmath48 where @xmath40 is a well - defined logic program , @xmath71 consists of cpts associated with each clause in @xmath40 , and @xmath74 is a combination rule .",
    "a distinct feature of blp over pkb is its separation of probabilistic information ( @xmath71 ) from logic clauses ( @xmath40 ) . according to @xcite",
    ", we understand that a _",
    "well - defined _ logic program is an acyclic positive logic program satisfying the range restriction .",
    "for instance , a logic program containing clauses like @xmath340 ( cyclic ) or @xmath341 ( not range - restricted ) is not well - defined .",
    "blp relies on the least herbrand model semantics and applies sld - resolution to make backward - chaining inferences .",
    "blp has two important differences from bkb .",
    "first , it applies only to positive logic programs . due to this",
    ", it can not handle contexts with negated atoms .",
    "( in fact , no contexts are considered in blp . )",
    "second , it does not allow cyclic influences .",
    "bkb can be viewed as an extension of blp with mechanisms for handling contexts and cyclic influences in terms of the well - founded semantics .",
    "such an extension is clearly nontrivial .",
    "the time parameter - based framework ( tpf ) proposed by glesner and koller @xcite is also a triple @xmath63@xmath339@xmath48 , where @xmath74 is a combination rule , @xmath71 is a set of cpts that are represented as decision trees , and @xmath40 is a logic program with the property that each predicate contains a time parameter and that in each clause the time argument in the head is at least one time step later than the time arguments in the body .",
    "this framework is implemented in prolog , i.e. clauses are represented as prolog rules and goals are evaluated applying sldnf - resolution .",
    "glesner and koller @xcite state :  ... in principle , this free variable @xmath110 can be instantiated with every domain element .",
    "( this is the approach taken in our implementation . ) \" by this we understand that they consider typed logic programs with finite domains .",
    "we observe the following major differences between tpf and bkb .",
    "first , tpf is a temporal model and its logic programs contain a time argument for every predicate .",
    "it always builds a dbn from a logic program even if there is no cyclic influence .",
    "in contrast , logic programs in bkb contain no time parameters .",
    "when there is no cyclic influence , bkb builds a regular bayesian network from a logic program ( in this case , bkb serves as a non - temporal model ) ; when cyclic influences occur , it builds a stationary dbn , represented by a two - slice dbn ( in this case , bkb serves as a special temporal model ) .",
    "second , tpf uses time steps to describe direct influences ( in the way that for any @xmath2 and @xmath29 such that @xmath29 has a direct influence on @xmath2 , the time argument in @xmath29 is at least one time step earlier than that in @xmath2 ) , while bkb uses time slices ( implied by recursive loops of form ( [ loop1 ] ) ) to model cycles of direct influences ( feedbacks ) .",
    "time - steps based frameworks like tpf are suitable to model flexible dbns , whereas time - slices based approaches like bkb apply to stationary dbns .",
    "third , most importantly tpf avoids recursive loops by introducing time parameters to enforce acyclicity of a logic program .",
    "a serious problem with this method is that it may lose and/or produce wrong answers to some queries . to explain this ,",
    "let @xmath40 be a logic program and @xmath342 be @xmath40 with additional time arguments added to each predicate ( as in tpf ) .",
    "if the transformation from @xmath40 to @xmath342 is correct , it must hold that for any query @xmath33 over @xmath40 , an appropriate time argument @xmath343 can be determined such that the query @xmath344 over @xmath342 has the same set of answers as @xmath33 over @xmath40 when the time arguments in the answers are ignored .",
    "it turns out , however , that this condition does not hold in general cases .",
    "note that finding an appropriate @xmath210 for a query @xmath33 such that evaluating @xmath344 over @xmath342 ( applying sldnf - resolution ) yields the same set of answers as evaluating @xmath33 over @xmath40 corresponds to finding an appropriate depth - bound @xmath345 such that cutting all sldnf - derivations for the query @xmath33 at depth @xmath345 does not lose any answers to @xmath33 .",
    "the latter is the well - known loop problem in logic programming @xcite .",
    "since the loop problem is undecidable in general , there is no algorithm for automatically determining such a depth - bound @xmath345 ( rep .",
    "a time argument @xmath210 ) for an arbitrary query @xmath33 @xcite .",
    "we further illustrate this claim using the following example .",
    "[ eg - last ]    _ the following logic program defines a @xmath346 relation ; i.e. there is a path from @xmath109 to @xmath110 if either there is an edge from @xmath109 to @xmath110 or for some @xmath347 , there is a path from @xmath109 to @xmath347 and an edge from @xmath347 to @xmath110 . _",
    "@xmath348 @xmath349 = 1 .",
    "@xmath350 + 2 . @xmath351 + @xmath352 + 99 .",
    "@xmath353 + 100 .",
    "@xmath354 + 101 . @xmath355 + 102 .",
    "@xmath356    to avoid recursive loops , tpf may transform @xmath40 into the following program .",
    "@xmath348 @xmath357 = 1 .",
    "@xmath358 + 2 .",
    "@xmath359 + @xmath352 + 99 .",
    "@xmath360 + 100 .",
    "@xmath361 + 101 . @xmath362 + 102 .",
    "@xmath363 + 103 .",
    "@xmath364    @xmath342 looks more complicated than @xmath40 .",
    "in addition to having time arguments and time formulas , it has a new clause , the 101st clause , formulating that @xmath365 being true at present implies it is true in the future .",
    "let us see how to check if there is a path from @xmath366 to @xmath367 .",
    "in the original program @xmath40 , we simply pose a query @xmath368 . in the transformed program @xmath342",
    ", however , we have to determine a specific time parameter @xmath210 and then pose a query @xmath369 , such that evaluating @xmath370 over @xmath40 yields the same answer as evaluating @xmath371 over @xmath342 .",
    "interested readers can practice this query evaluation using different values for @xmath210 .",
    "the answer to @xmath370 over @xmath40 is @xmath372 however , we would get an answer @xmath373 to the query @xmath371 over @xmath342 if we choose any @xmath374 .",
    "we have developed a novel theoretical framework for deriving a stationary dbn from a logic program with recursive loops .",
    "we observed that recursive loops in a logic program imply a time sequence and thus can be used to model a stationary dbn without using explicit time parameters .",
    "we introduced a bayesian knowledge base with logic clauses of form ( [ cll-2 ] ) .",
    "these logic clauses naturally integrate the direct influence information , the context and the type constraints , and are evaluated under the well - founded semantics .",
    "we established a declarative semantics for a bayesian knowledge base and developed algorithms that build a two - slice dbn from a bayesian knowledge base .",
    "we emphasize the following three points .",
    "1 .   recursive loops ( cyclic influences ) and recursion through negation are unavoidable in modeling real - world domains , thus the well - founded semantics together with its top - down inference procedures is well suitable for the plp application .",
    "recursive loops define feedbacks , thus implying a time sequence .",
    "this allows us to derive a two - slice dbn from a logic program containing no time parameters .",
    "we point out , however , that the user is never required to provide any time parameters during the process of constructing such a two - slice dbn .",
    "a bayesian knowledge base defines a unique space of random variables and a unique set of influence clauses , whether it contains recursive loops or not . from the viewpoint of logic ,",
    "these random variables are ground atoms in the herbrand base ; their truth values are determined by the well - founded model and will never change over time .",
    "therefore , a bayesian network is built over these random variables , independently of any time factors ( if any ) .",
    "once a two - slice dbn has been built , the time intervals over it would become clearly specified , thus the user can present queries and evidences over the dbn using time parameters at his / her convenience .",
    "3 .   enforcing acyclicity of a logic program by introducing time parameters is not an effective way to handle recursive loops .",
    "firstly , such a method transforms the original non - temporal logic program into a more complicated temporal program and builds a dynamic bayesian network from the transformed program even if there exist no cyclic influences ( in this case , there is no state variable and the original program defines a regular bayesian network ) .",
    "secondly , it relies on time steps to define ( individual ) direct influences , but recursive loops need time slices ( intervals ) to model cycles of direct influences ( feedbacks ) .",
    "finally , to pose a query over the transformed program , an appropriate time parameter must be specified . as illustrated in example",
    "[ eg - last ] , there is no algorithm for automatically determining such a time parameter for an arbitrary query .    promising future work includes ( 1 ) developing algorithms for learning bkb clauses together with their cpts from data and ( 2 ) applying bkb to model large real - world problems .",
    "we intend to build a large bayesian knowledge base for traditional chinese medicine , where we already have both a large volume of collected diagnostic rules and a massive repository of diagnostic cases .",
    "we are grateful to several anonymous referees for their constructive comments , which greatly helped us improve the presentation .",
    "p. domingos and m. richardson , markov logic : a unifying framework for statistical relational learning , in : _ proc . of the icml-2004 workshop on statistical relational learning and its connections to other fields _ , banff , canada , 2004 , pp .",
    "49 - 54 .",
    "s. glesner and d. koller , constructing flexible dynamic belief networks from first - order probabilistic knowledge bases , in : c. froidevaux and j. kohlas , eds .",
    ", _ proceedings of the european conference on symbolic and quantitative approaches to reasoning under uncertainty _ , fribourg , switzerland , july 1995 , pages 217 - 226 .",
    "k. kanazawa , d. koller and s. russell , stochastic simulation algorithms for dynamic probabilistic networks , in : _ proc . of the eleventh annual conference on uncertainty in artificial intelligence _ , 1995 .",
    "k. kersting and l. de raedt , bayesian logic programs , in : j. cussens and a. frisch , eds , _ work - in - progress reports of the tenth international conference on inductive logic programming _ , london , u.k . ,",
    "( a full version : technical report 151 , university of freiburg institute for computer science . )                  k. sagonas , t. swift , d.s . warren , j. freire and p. rao , _ the xsb programmer s manual ( version 1.8)_. department of computer science , suny at stony brook .",
    "available from http://www.cs.sunysb.edu/  sbprolog / xsb - page.html .",
    "b. taskar , p. abeel and d. koller , discriminative probabilistic models for relational data , in : _ proc . of the eighteenth conf . on uncertainty in artificial intelligence _ ,",
    "edmonton , canada , 2002 , pp.485 - 492 ."
  ],
  "abstract_text": [
    "<S> recursive loops in a logic program present a challenging problem to the plp framework . on the one hand </S>",
    "<S> , they loop forever so that the plp backward - chaining inferences would never stop . on the other hand </S>",
    "<S> , they generate cyclic influences , which are disallowed in bayesian networks . </S>",
    "<S> therefore , in existing plp approaches logic programs with recursive loops are considered to be problematic and thus are excluded . in this paper </S>",
    "<S> , we propose an approach that makes use of recursive loops to build a stationary dynamic bayesian network . </S>",
    "<S> our work stems from an observation that recursive loops in a logic program imply a time sequence and thus can be used to model a stationary dynamic bayesian network without using explicit time parameters . </S>",
    "<S> we introduce a bayesian knowledge base with logic clauses of the form @xmath0 , which naturally represents the knowledge that the @xmath1s have direct influences on @xmath2 in the context @xmath3 under the type constraints @xmath4 . </S>",
    "<S> we then use the well - founded model of a logic program to define the direct influence relation and apply slg - resolution to compute the space of random variables together with their parental connections . </S>",
    "<S> we introduce a novel notion of influence clauses , based on which a declarative semantics for a bayesian knowledge base is established and algorithms for building a two - slice dynamic bayesian network from a logic program are developed . </S>",
    "<S> + * key words : * probabilistic logic programming ( plp ) , the well - founded semantics , slg - resolution , stationary dynamic bayesian networks . </S>"
  ]
}