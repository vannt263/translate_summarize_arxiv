{
  "article_text": [
    "let @xmath0 be a plane graph with straight edges and vertices in general position ; that is , a straight - line drawing of a planar graph with no edge crossings and no three vertices on a line in which the vertices are identified with their positions .",
    "we refer to the open line segment between a pair of non - adjacent graph vertices as a _ non - edge _ of @xmath2 .",
    "an _ obstacle representation _ of @xmath0 is a pair @xmath3 where @xmath4 is a set of polygons ( not necessarily convex ) called _ obstacles _ , such that :    1 .   @xmath0 does not meet any obstacle , and 2 .",
    "every non - edge of @xmath0 meets at least one obstacle .",
    "equivalently , @xmath0 is the visibility graph on @xmath1 determined by the obstacles in @xmath4 .",
    "the size of an obstacle representation is the cardinality of @xmath4 .",
    "denote by _ orpg _ the problem of computing a minimum - size obstacle representation of @xmath0 ( the optimum of which is called the _ obstacle number _ of @xmath0 ) .",
    "alpert , koch , and laison introduced the notions _",
    "obstacle representation _ and _ obstacle number _ for abstract graphs @xcite and noted that in any minim__al _ _ obstacle representation , each obstacle can be identified with the face it lies in .",
    "hence , we will use the terms _ face _ and _ obstacle _ interchangeably .",
    "if the faces have weights then we can seek a minimum - weight obstacle representation .",
    "finding a minimum - size obstacle representation of a straight - line graph drawing was treated as a computational problem in the setting in which @xmath2 and @xmath0 need not be planar @xcite .",
    "this problem was reduced to hypergraph transversal ( hitting set ) , with @xmath5 faces available to pierce @xmath6 non - edges ( @xmath7 faces and @xmath8 non - edges in the orpg special case ) . a randomized @xmath9-approximation algorithm based on bounding the vapnik - chervonenkis dimension of the corresponding hypergraph family",
    "was given in @xcite .",
    "left open was the question of whether better approximations or perhaps optimal algorithms were feasible .    in this note",
    "we give partial answers to that question .",
    "we show that computing the obstacle number is np - hard already in the special case of plane graphs ; nonetheless , we show that orpg admits a polynomial - time approximation scheme ( ptas ) and is fixed - parameter tractable ( fpt ) .",
    "we show hardness by a reduction from planar vertex cover ; the positive results are consequences of a solution value - preserving reduction to maximum degree 3 planar vertex cover .",
    "orpg is np - hard .",
    "[ thm : orpg_npcomplete ]    we reduce from planar vertex cover",
    ". recall that in the decision version of planar vertex cover , we are given an abstract planar graph @xmath0 having ( without loss of generality ) no isolated vertex , and a number @xmath10 .",
    "let @xmath11 , @xmath12 , and denote by @xmath13 the number of faces in any crossing - free planar drawing of @xmath0 .",
    "we will transform @xmath0 in polynomial time into a plane graph @xmath14 in such a way that @xmath0 has a vertex cover of size @xmath10 if and only if @xmath14 has an obstacle representation of size @xmath15 ( for @xmath15 defined below ) .",
    "first , we construct from the planar vertex cover instance @xmath0 a planar vertex cover problem instance @xmath16 with maximum degree 3 , adapting and extending the construction of @xcite .",
    "the graph @xmath16 admits a vertex cover of size @xmath15 if and only if @xmath0 admits a vertex cover of size @xmath10 .",
    "second , we construct an orpg instance @xmath14 in such a way that an obstacle representation of @xmath14 will correspond to a vertex cover of @xmath16 of the same size , and vice versa .    .2cm**constructing the maximum degree 3 planar vertex cover instance @xmath16 . * * the planar graph @xmath16 is constructed as follows .",
    "we transform each vertex @xmath17 of @xmath0 into a cycle @xmath18 of length @xmath19 , with @xmath20 ( with the exact value decided below ) .",
    "we color the vertices of @xmath18 alternating between blue and red .",
    "we then create a single leaf vertex @xmath21 adjacent to some arbitrary red vertex of @xmath18 .",
    "we transform each edge @xmath22 of @xmath0 into a path @xmath23 with _ three _ edges whose endpoints are _ distinct _ blue vertices of @xmath18 and @xmath24 .",
    "we finally create @xmath13 copies of the 3-vertex path graph @xmath25 , each constituting a component of @xmath16 .",
    "we claim that @xmath0 has a vertex cover of size at most @xmath10 if and only if @xmath16 has one of size at most @xmath26 .",
    "( @xmath27 ) : for each vertex @xmath17 in a given vertex cover for @xmath0 of size @xmath10 , we select @xmath21 and all the blue vertices of @xmath18 , thus including an endpoint of each path @xmath23 ; and for each @xmath17 not in the cover , we select all the red vertices of @xmath18 ( a total so far of @xmath28 vertices ) . since for every path @xmath23 at least one of the cycles @xmath18 and @xmath24 will have all its blue vertices chosen , thus including at least one endpoint of @xmath23 , choosing one internal vertex from each @xmath23 ( @xmath29 more ) , and the central vertex of each @xmath25 ( @xmath13 more ) suffices to complete a size @xmath15 vertex cover for @xmath16 .    ( @xmath30 ) : given a vertex cover for @xmath16 of size @xmath15 , we obtain a canonical vertex cover for @xmath16 of size @xmath31 in the following way .",
    "each copy of @xmath25 contributes at least one vertex to a cover , so have it contribute exactly its central vertex , for a total of @xmath13 vertices .",
    "each path @xmath23 contributes at least one of its internal vertices to cover its central edge .",
    "if both internal vertices of a path @xmath23 are in the given cover , take one internal vertex out and ensure that its blue neighbor is in , which makes for @xmath29 internal vertices from these paths .",
    "note that every cycle @xmath32 contributes at least @xmath33 vertices , lest some edge of the cycle be uncovered .",
    "this holds with equality only if @xmath32 contributes ( including ` its ' @xmath21 ) exactly its red vertices . otherwise ,",
    "ensure that @xmath32 contributes exactly @xmath34 vertices : ` its ' @xmath21 and its blue vertices .",
    "denote by @xmath35 the size of this resulting canonical vertex cover .",
    "the cycles in @xmath16 contributing blue vertices therefore correspond to a vertex cover for @xmath0 of size @xmath36 .    .2cm**constructing the orpg instance @xmath37 . * * in the remainder of the proof , we show how to `` implement '' the graph @xmath16 as an equivalent orpg problem instance .",
    "the basic building blocks of the construction are _ empty triangles _ and _ diamonds_. an _ empty triangle _ is a face of a plane graph that is surrounded by three edges and has no vertex inside .",
    "a _ diamond _",
    "consists of two empty triangles sharing an edge and having their _ four _ vertices in convex position . observe that a diamond contains a non - edge between two of its vertices .",
    "hence at least one empty triangle of every diamond must be chosen in an obstacle representation .",
    "the @xmath13 copies of @xmath25 in @xmath16 will match the faces of @xmath37 besides empty triangles , all of which must be chosen .",
    "the remaining vertices of @xmath16 will match the empty triangles of @xmath37 , such that the edges among them match the diamonds of @xmath37 .",
    "hence there will be a natural bijection between vertex covers of @xmath16 and obstacle representations of @xmath37 .    to begin the construction",
    ", we use the linear - time algorithm of de fraysseix , pach , and pollack @xcite to obtain a planar imbedding of @xmath0 on a portion of the integer lattice and then perturb the coordinates to obtain general position .",
    "( we do not distinguish between @xmath0 and this imbedding . )",
    "we first visualize @xmath37 as a bold drawing @xcite of @xmath0 , whose vertices are represented by small disks and edges by solid rectangles : we draw each vertex @xmath38 of @xmath0 as a disk @xmath39 about @xmath38 ( with boundary @xmath40 ) , and every edge @xmath41 as a solid rectangle @xmath42 .",
    "[ fig : bolddraw ] .",
    "each @xmath42 has two vertices @xmath43,@xmath44 on @xmath40 and two vertices @xmath45 on @xmath46 such that the line @xmath41 is a midline of @xmath42 , and @xmath47 is a counterclockwise ordering of the vertices of a convex hexagon .",
    "we draw the disks small enough to ensure that they are well - separated from one another .",
    "we set the radius @xmath48 of every disk to the smaller of 1/4 and half of the minimum distance between a vertex @xmath38 and an edge @xmath49 ( @xmath50 ) of @xmath0 .",
    "to fix a single width for all rectangles ( i.e. , @xmath51 ) , we set a global angle measure @xmath52 to the smaller of @xmath53 and half of the smallest angle between two edges of @xmath54 incident on the same vertex of @xmath1 .",
    "@xmath37 is modeled on the bold drawing , by implementing each edge of @xmath0 ( path @xmath23 of @xmath16 ) with an edge gadget and each vertex of @xmath0 ( cycle @xmath18 of @xmath16 ) with a vertex gadget .",
    "the edge gadget , consisting of four triangles forming three diamonds , is shown in fig .",
    "[ fig : gprimeforsingleedge ] .",
    "( note that each pair @xmath55 defines a non - edge . )",
    "the vertex gadget is a modified wheel graph whose triangles correspond to the vertices of cycles @xmath32 in @xmath16 ( see fig . [",
    "fig : nodegadget ] ) . on every circle @xmath40 , for every edge @xmath41 in @xmath0 , we color blue the arc of measure @xmath52 centered about the intersection of circle @xmath40 with @xmath41 ( a non - edge in @xmath37 ) .",
    "we place @xmath43 and @xmath44 at the endpoints of this arc so that @xmath56 is a counterclockwise triple . by the choice of @xmath52 , all blue arcs are well - separated , and hence the rectangles are well - separated from one another and from other disks , by the choice of @xmath48 .",
    "we color the remaining arcs red to obtain a red - blue striped pattern on each circle @xmath40 , corresponding in color to the vertices of the corresponding @xmath32 in @xmath16 .",
    "[ initial circle with blue ( solid ) arcs of measure @xmath52 and red ( dashed ) arcs has a large red arc of measure in @xmath57 , @xmath58 . ]",
    "\\(p ) at ( -2- 0.8 , -2- 0.8 * 0.9 ) ; ( q ) at ( 2 + 0.8 , 2 + 0.8 * 0.9 ) ; ( p ) rectangle ( q ) ; ( ui ) at ( 0,0 ) [ label = left:@xmath38 ] ; ( ui ) circle ( 2 ) ; ( ti0 ) at ( 10:2 ) ; ( vi0 ) at ( -10:2 ) ;    ( ti1 ) at ( ( 58 + 10):2 ) ; ( vi1 ) at ( ( 58- 10):2 ) ;    ( ti2 ) at ( ( 135 + 10):2 ) ; ( vi2 ) at ( ( 135- 10):2 ) ; ( vi0 ) arc ( -10:10:2 ) ; ( ti0 ) at ( ti0 ) [ label = right : @xmath60 ; ( vi0 ) at ( -10:2 ) [ label = right : @xmath61 ; ( vi1 ) arc ( 58 - 10:58 + 10:2 ) ; ( ti1 ) at ( ti1 ) [ label = above right : @xmath62 ; ( vi1 ) at ( vi1 ) [ label = right : @xmath63 ; ( vi2 ) arc ( 135 - 10:135 + 10:2 ) ; ( ti2 ) at ( ti2 ) [ label = above left : @xmath64 ; ( vi2 ) at ( vi2 ) [ label = above : @xmath65 ; ( ui )  ( ti0 ) ; ( ui ) ",
    "( vi0 ) ; ( ui )  ( ti1 ) ; ( ui )  ( vi1 ) ; ( ui )  ( ti2 ) ; ( ui )  ( vi2 ) ;    [ fig : nodegadget ]    on every circle @xmath40 , we will add the remaining edges between consecutive vertices of @xmath40 to complete the union of the triangles @xmath66 , forming a wheel graph on hub @xmath67 , such that every pair of triangles sharing a spoke form a diamond . if a red arc has measure at least @xmath68 , however , we must add additional spokes . by the general position assumption , at most one red arc per wheel",
    "can have such great measure .",
    "if such a red arc has measure less than @xmath69 , we divide it evenly into _ three _ parts and color the middle part blue ( see fig . [",
    "fig : nodegadget ] ) ; otherwise , we divide it evenly into _ five _ parts and color the second and fourth parts blue ( see fig .",
    "[ fig : subdividelargeredarc ] ) , maintaining the striped pattern in both cases .",
    "we place dummy @xmath70 and @xmath71 vertices .",
    "] at the newly created ( _ zero _ , _ two _ or _ four _ ) arc endpoints . finally , we add the requisite edges to complete the wheel graph .",
    "we place a vertex @xmath72 on an arbitrary red arc of @xmath40 and connect it in @xmath37 to the end vertices ( say @xmath43 and @xmath73 ) of that arc .",
    "thus an empty triangle @xmath74 is formed in @xmath37 as part of a diamond with @xmath38 , corresponding to @xmath21 and its incident edge in @xmath16 .    in the unbounded face of @xmath37 we place two isolated vertices inducing a non - edge inside the unbounded face , thus requiring this face to be chosen in any solution .",
    "every non - triangular face of @xmath37 must be selected as an obstacle , since every simple polygon with at least 4 vertices has an internal diagonal ( i.e. , a non - edge ) .",
    "the selection of these faces are forced moves and correspond to the selection , in a vertex cover for @xmath16 , of the central vertex of each @xmath25 .",
    "this completes the construction of @xmath37 .",
    "since each pair of neighboring triangles in @xmath37 indeed form a diamond and every non - triangular face is indeed a forced move , the result follows .    to represent coordinates _",
    "exactly _ as described would require a very permissive unit - cost ram model of computation in which it is possible to represent real numbers and perform arithmetic and trigonometric functions in unit time .",
    "the reduction above can be modified in such a way that each vertex position of @xmath37 is represented using @xmath75 bits .    in an alternate proof strategy ,",
    "we can begin with a special _ touching polygons _ representation of @xmath0 instead of a bold drawing .",
    "this strategy would involve topologically `` collapsing '' each rectangle @xmath42 to a single edge shared by the wheel graphs on hubs @xmath38 and @xmath76 , which is the unique edge crossing segment @xmath41 .",
    "there is a linear - time algorithm for computing a touching polygons representation where the number of sides in a polygon is at most _ six _",
    "@xcite , this algorithm can be modified to ensure that every side of a polygon is an edge of @xmath37 .",
    "the linear - time algorithm for computing a touching polygons representation given in @xcite can easily be modified to ensure that every edge of @xmath0 corresponds to a distinct side between two polygons , but using this method there is no guaranteed way to place hubs inside their corresponding polygons such that every pair of adjacent polygons have hubs that define non - edges that meet the shared polygon side .",
    "nonetheless , a polynomial - time algorithm by mohar @xcite does ensure this .",
    "weighted orpg is reducible to weighted maximum degree 3 planar vertex cover by an optimal solution value - preserving reduction .",
    "[ reductiontop - vc-3 ]    given a plane graph @xmath0 on @xmath77 vertices in general position , we construct a graph @xmath78 that admits a vertex cover of cost @xmath10 if and only if @xmath0 admits an obstacle representation of cost @xmath10 .",
    "every bounded non - triangular face of @xmath0 must be selected as an obstacle ; moreover , the unbounded face must be chosen if and only if its convex hull boundary contains a non - edge .",
    "since these are forced moves , we henceforth assume without loss of generality that every non - edge we must block meets at least two faces .",
    "recall that an _",
    "empty triangle _ is a bounded face on three vertices not containing any other vertices , and that a _ diamond _ consists of two empty triangles that share an edge and have their four vertices in convex position .",
    "we claim that every non - edge must meet the two triangles forming some diamond , and hence must meet those triangles shared edge .",
    "assume for contradiction that some remaining non - edge @xmath79 never crosses the diagonal edge of a diamond .",
    "denote by @xmath80 and @xmath81 the endpoints of @xmath79 , and orient the plane such that @xmath80 is directly below @xmath81 . obtain a sequence of empty triangles @xmath82 by tracing @xmath79 from @xmath80 ( a vertex on @xmath83 ) to @xmath81 ( a vertex on @xmath84 ) .",
    "denote by @xmath17 ( for @xmath85 ) the unique vertex in face @xmath84 that is not a vertex of @xmath86 ( so that @xmath87 ) . without loss of generality ,",
    "the reflex angle of @xmath83 and @xmath88 is to the right of @xmath79 , which implies that @xmath89 is to the right of @xmath79 . in order for @xmath90 to be the next face in this sequence",
    ", @xmath91 must be to the left of @xmath79 . in general , in order for @xmath92 to be the next face in this sequence",
    ", @xmath17 must be on the other side of @xmath79 from @xmath93 .",
    "this pattern must continue indefinitely , lest two consecutive triangles form a diamond .",
    "the indefinite continuation of this pattern implies an infinite sequence of faces defined by @xmath79 , and hence a contradiction .",
    "we now define @xmath78 , which is a subgraph of the dual of @xmath0 : each edge of @xmath94 corresponds to diamond of @xmath0 . the graph @xmath94 is induced by these edges ( with vertex weights set to the correspond face weights ) . for each diamond , at least one its two triangles must be chosen in any obstacle representation .",
    "thus every obstacle representation of @xmath94 corresponds to a vertex cover of @xmath0 of the same cost , and vice versa .",
    "we may wish to adopt the more realistic bit model , since a plane graph drawing may have been expressed using a number of bits super - polynomial in @xmath77 for vertex coordinates . in this model ,",
    "the reduction would require time super - polynomial in @xmath95 but nonetheless polynomial in the number of input bits used for representing @xmath0 .",
    "[ rem : whatpolynomial ]                alternatively , using the fpt algorithm by alber et al .",
    "@xcite for planar vertex cover on @xmath78 , we can to compute an obstacle representation for @xmath0 with @xmath10 obstacles in additional time at most @xmath98 ."
  ],
  "abstract_text": [
    "<S> an _ obstacle representation _ of a plane graph @xmath0 is @xmath1 together with a set of opaque polygonal obstacles such that @xmath0 is the visibility graph on @xmath1 determined by the obstacles . </S>",
    "<S> we investigate the problem of computing an obstacle representation of a plane graph ( orpg ) with a minimum number of obstacles . </S>",
    "<S> we call this minimum size the _ obstacle number _ of @xmath0 .    </S>",
    "<S> first , we show that orpg is np - hard by reduction from planar vertex cover , resolving a question posed by @xcite . </S>",
    "<S> second , we give a reduction from orpg to maximum degree 3 planar vertex cover . </S>",
    "<S> since this reduction preserves solution values , it follows that orpg is fixed parameter tractable ( fpt ) and admits a polynomial - time approximation scheme ( ptas ) . </S>"
  ]
}