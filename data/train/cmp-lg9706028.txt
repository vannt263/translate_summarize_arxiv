{
  "article_text": [
    "one of the most central problems that any nl system must face is the ubiquitous phenomenon of ambiguity . in the last few years a whole new branch developed in semantics that investigates _ underspecified _ semantic representations in order to cope with this phenomenon .",
    "such representations do not stand for the real or intended meaning of sentences , but rather for the possible options of interpretation .",
    "quantifier scope ambiguities are a semantic variety of ambiguity that is handled especially well by this approach",
    ". pioneering work in that direction has been @xcite and @xcite .",
    "more recently there has been growing interest in developing the underspecification approach to also cover syntactic ambiguities ( cf .",
    "schiehlen s approach is outstanding in that he fully takes into account syntactic constraints . in @xcite",
    "he presents an algorithm which directly constructs a single underspecified semantic structure from the ideal `` underspecified '' syntactic structure , a parse forest .    on the other hand , a method for producing `` packed semantic structures '' , in that case `` packed quasi - logical forms '' ,",
    "has already been used in the core language engine , informally described in ( * ? ? ?",
    "however , this method only produces a structure that is virtually isomorphic to the parse forest , since it simply replaces parse forest nodes by their corresponding semantic operators .",
    "no attempt is made to actually apply semantic operators in the phase where those `` packed qlfs '' are constructed .",
    "moreover , the packing of the qlfs seems to serve no purpose in the processing phases following semantic analysis . already the immediately succeeding phase `` sortal filtering '' requires qlfs to be unpacked , i.e. enumerated .",
    "contrary to the cle method , schiehlen s method actively packs semantic structures , even when they result from distinct syntactic structures , extracting common parts .",
    "his method , however , may take time exponential w.r.t . sentence length",
    "already the semantic representations it produces can be exponentially large , because they grow linear with the number of ( syntactic ) readings and that can be exponential , e.g. , for sentences that exhibit the well - known attachment ambiguity of prepositional phrases .",
    "it is therefore an interesting question to ask , whether we can compute compact semantic representations from parse forests without falling prey to exponential explosion .",
    "the purpose of the present paper is to show that construction of compact semantic representations like in schiehlen s approach from parse forests is not only possible , but also cheap , i.e. , can be done in polynomial time .    to illustrate our method we use a simple dcg grammar for pp - attachment ambiguities , adapted from @xcite , that yields semantic representations ( called udrss ) according to the underspecified discourse representation theory @xcite .",
    "the grammar is shown in fig .",
    "[ fig : pp - att - dcg ] .",
    "the udrss constructed by the grammar are flat lists of the udrs - constraints @xmath1 ( subordination ( partial ) ordering between labels ; prolog representation : lt(@xmath2,@xmath3 ) ) , @xmath4 ( condition introduction in subudrs labeled @xmath2 ) , @xmath5 ( referent introduction in @xmath2 ) , @xmath6 ( generalised quantifier ) and an anchoring function .",
    "the meaning of a udrs as a set of denoted drss can be explained as follows . all conditions with the same label form a subudrs and labels occurring in subudrss denote locations ( holes ) where other subudrss can be plugged into .",
    "the whole udrs denotes the set of well - formed drss that can be formed by some plugging of the subudrss that does not violate the ordering @xmath7 .",
    "scope of quantifiers can be underspecified in udrss , because subordination can be left partial .",
    "in our example grammar every nonterminal has three arguments .",
    "the 2nd and the 3rd argument represent a udrs list as a difference list , i.e. , the udrs is `` threaded through '' .",
    "the first argument is a list of objects occurring in the udrs that play a specific role in syntactic combinations of the current node .",
    "an example of a udrs , however a packed udrs , is shown later on in  [ sec : impl ] .    to avoid the dependence on a particular grammar formalism we present our method for a constraint - based grammar abstractly from the actual constraint system employed .",
    "we only require that semantic rules relate the semantic ` objects ' or structures that are associated with the nodes of a local tree by employing constraints .",
    "e.g. , we can view the dcg rule @xmath8 as a relation between three ` semantic construction terms ' or variables sems , semnp , semvp equivalent to the constraints +    .... sems = [ [ event , verbl , doml , topl],drs_i , drs_o ] semnp = [ [ x , verbl , doml , topl],drs_i , drs1 ] semvp = [ [ event , x , verbl , doml , topl],drs1,drs_o ] ....    here is an overview of the paper .  [ sec : problem ] gives the preliminaries and assumptions needed to precisely state the problem we want to solve .",
    " [ sec : algo ] presents the abstract algorithm .",
    "complexity considerations follow in  [ sec : complexity ] .",
    "finally , we consider implementation issues , present results of an experiment in ",
    "[ sec : impl ] , and close with a discussion .",
    "as mentioned already , we aim at calculating from given parse forests the same compact semantic structures that have been proposed by @xcite , i.e. structures that make explicit the common parts of different syntactic readings , so that subsequent semantic processes can use this generalised information . as he does , we assume a constraint - based grammar , e.g. a dcg @xcite or hpsg @xcite , in which syntactic constraints and constraints that determine a resulting semantic representation can be seperated and parsing can be performed using the syntactic constraints only .",
    "second , we assume that the set of syntax trees can be compactly represented as a parse forest ( cf .",
    "parse forests are rooted labeled directed acyclic graphs with and - nodes ( standing for context - free branching ) and or - nodes ( standing for alternative subtrees ) , that can be characterised as follows ( cf . fig .",
    "[ fig : forest1 ] for an example).[multiblock footnote omitted ]    1 .",
    "the terminal yield as well as the label of two and - nodes are identical , if and only if they both are children of one or - node .",
    "every tree reading is a valid parse tree .",
    "tree readings of such graphs are obtained by replacing any or - node by one of its children .",
    "parse forests can represent an exponential number of phrase structure alternatives in @xmath9 space , where @xmath10 is the length of the sentence .",
    "the example uses the 3 or - nodes ( a , b , c ) and the and - nodes 1 through 32 to represent 5 complete parse trees , that would use @xmath11 nodes .",
    "third , we assume the rule - to - rule hypothesis , i.e. , that the grammar associates with each local tree a ` semantic rule ' that specifies how to construct the mother node s semantics from those of its children .    hence , input to the algorithm is    * a parse forest * an associated semantic rule for every local tree ( and - node together with its children ) therein * and a semantic representation for each leaf ( coming from a semantic lexicon ) .    to be more precise , we assume a constraint language @xmath12 over a denumerable set of variables @xmath13 , that is a sublanguage of predicate logic with equality and is closed under conjunction , disjunction , and variable renaming . small greek letters @xmath14 will henceforth denote constraints ( open formulae ) and letters @xmath15 ( possibly with indeces ) will denote variables .",
    "writing @xmath16 shall indicate that @xmath17 are the free variables in the constraint @xmath18 .",
    "frequently used examples for constraint languages are the language of equations over first - order terms for dcgs , patr - style feature - path equations , or typed feature structure description languages ( like the constraint languages of ale @xcite or cuf @xcite ) for hpsg - style grammars .    together with the constraint language we require a constraint solver , that checks constraints for satisfiability , usually by transforming them into a normal form ( also called ` solved form ' ) .",
    "constraint solving in the dcg case is simply unification of terms .",
    "the semantic representations mentioned before are actually not given directly , but rather as a constraint on some variable , thus allowing for partiality in the structural description . to that end",
    "we assume that every node in the parse forest @xmath19 has associated with it a variable @xmath20 that is used for constraining the ( partial ) semantic structure of @xmath19 .",
    "the semantics of a leaf node @xmath21 is hence given as a constraint @xmath22 , called a _",
    "leaf constraint_.    a final assumption that we adopt concerns the nature of the ` semantic rules ' .",
    "the process of semantics construction shall be a completely monotonous process of gathering constraints that _ never leads to failure_. we assume that any associated ( instantiated ) semantic rule @xmath23 of a local tree ( and - branching ) @xmath24 determines @xmath19 s semantics @xmath25 as follows from those of its children : @xmath26{@{}l@ { } } \\phi_{r(\\nu)}(x_{\\nu},x_{\\nu_1},\\ldots , x_{\\nu_k } ) \\wedge\\mbox{}\\\\   \\sigma(\\nu_1 ) \\wedge \\ldots \\wedge \\sigma(\\nu_k ) ) .",
    "\\end{array}\\ ] ] the constraint @xmath27 is called the _ rule constraint _ for @xmath19 .",
    "it is required to only depend on the variables @xmath28 .",
    "note that if the same rule is to be applied at another node , we have a different rule constraint .",
    "note that any @xmath25 depends only on @xmath20 and can be thought of as a unary predicate .",
    "now , let us consider semantics construction for a single parse tree for the moment . the leaf constraints together with the rules define a semantics constraint @xmath25 for every node @xmath19 , and the semantics of the full sentence",
    "is described by the @xmath29-constraint of the root node , @xmath30 . in the @xmath29-constraints",
    ", we actually can suppress the existential quantifiers by adopting the convention that any variable other than the one of the current node is implicitly existentially bound on the formula toplevel .",
    "name conflicts , that would force variable renaming , can not occur . therefore @xmath30 is ( equivalent to ) just a big conjunction of all rule constraints for the inner nodes and all leaf constraints .",
    "moving to parse forests , the semantics of an or - node @xmath24 is to be defined as @xmath31{@{}l@ { } } \\sigma(\\nu_1)\\wedge x_{\\nu}{=}x_{\\nu_1 } \\vee \\ldots\\\\   \\mbox{}\\vee \\sigma(\\nu_k)\\wedge x_{\\nu}{=}x_{\\nu_k } ) , \\end{array}\\ ] ] specifying that the set of possible ( partial ) semantic representations for @xmath19 is the union of those of @xmath19 s children .",
    "however , we can simplify this formula once and for all by assuming that for every or - node there is only one variable @xmath20 that is associated with it _ and all of its children_.",
    "using the same variable for @xmath32 is unproblematic , because no two of these nodes can ever occur in a tree reading .",
    "hence , the definition we get is @xmath33 now , in the same way as in the single - tree case , we can directly `` read off '' the @xmath29-constraint for the whole parse forest representing the semantics of all readings .",
    "although this constraint is only half the way to the packed semantic representation we are aiming at , it is nevertheless worthwhile to consider its structure a little more closely . fig .",
    "[ fig : sigma - constr ] shows the structure of the @xmath29-constraint for the or - node @xmath34 in the example parse forest .",
    "@xmath35{@{}c@ { } } \\underbrace { \\phi_{r(6)}\\wedge\\phi_{23}\\wedge\\phi_{r(10)}\\wedge\\phi_{24 } \\wedge",
    "\\phi_{r(12)}\\wedge\\phi_{25}\\wedge\\phi_{r(15)}\\wedge\\phi_{26}\\wedge \\begin{array}[t]{@{}c@ { } } \\underbrace{\\phi_{r(18)}\\wedge\\phi_{27}\\wedge\\phi_{r(21)}\\wedge    \\phi_{28}\\wedge \\phi_{29}}\\\\ \\sigma(18 ) \\end{array } } \\\\ \\sigma(6 ) \\end{array}\\\\ \\vee\\\\ \\begin{array}[t]{@{}c@ { } } \\underbrace { \\phi_{r(7)}\\wedge\\phi_{r(14)}\\wedge\\phi_{23}\\wedge\\phi_{r(17)}\\wedge\\phi_{24 } \\wedge\\phi_{r(20)}\\wedge\\phi_{25}\\wedge\\phi_{26}\\wedge \\begin{array}[t]{@{}c@ { } } \\underbrace{\\phi_{r(18)}\\wedge\\phi_{27}\\wedge\\phi_{r(21)}\\wedge    \\phi_{28}\\wedge \\phi_{29}}\\\\ \\sigma(18 ) \\end{array}}\\\\ \\sigma(7 ) \\end{array } \\end{array}\\ ] ]    in a way the structure of this constraint directly mirrors the structure of the parse forest .",
    "however , by writing out the constraint , we loose the sharings present in the forest . a subformula coming from a shared subtree ( as @xmath36 in fig .",
    "[ fig : sigma - constr ] ) has to be stated as many times as the subtree appears in an unfolding of the forest graph . in our pp - attachment example",
    "the blowup caused by this is in fact exponential .    on the other hand , looking at a @xmath29-constraint as a piece of syntax , we can _ represent _ this piece of syntax in the same manner in which trees are represented in the parse forest , i.e. we can have a representation of @xmath30 with a structure isomorphic to the forest s graph structure . in practice",
    "this difference becomes a question of whether we have full control over the representations the constraint solver employs ( or any other process that receives this constraint as input ) .",
    "if not , we can not contend ourselves with the _ possibility _ of compact representation of constraints , but rather need a means to enforce this compactness on the constraint level .",
    "this means that we have to introduce some form of functional abstraction into the constraint language ( or anything equivalent that allows giving names to complex constraints and referencing to them via their names ) .",
    "therefore we enhance the constraint language as follows .",
    "we allow to our disposition a second set of variables , called names , and two special forms of constraints    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ l@r + & name definition + 2 . &",
    "name use _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    with the requirements , that a name may only be used , if it is defined and that its definition is unique .",
    "thus , the constraint @xmath37 above can be written as @xmath38{@{}l@ { } } \\phi_{r(6)}\\wedge\\ldots\\wedge\\phi_{26}\\wedge \\mbox { \\bf n } \\\\",
    "\\mbox{}\\vee \\phi_{r(7)}\\wedge\\ldots\\wedge\\phi_{26}\\wedge \\mbox { \\bf n } ) \\end{array } \\\\ \\mbox{}\\wedge \\mbox { \\tt def({\\bf n } ,    }",
    "\\phi_{r(18)}\\wedge\\phi_{27}\\wedge\\phi_{r(21)}\\wedge     \\phi_{28}\\wedge \\phi_{29}\\mbox { ) } \\end{array}\\ ] ]    the packed semantic representation as constructed by the method described so far still calls for an obvious improvement .",
    "very often the different branches of disjunctions contain constraints that have large parts in common .",
    "however , although these overlaps are efficiently handled on the representational level , they are invisible at the _ logical level_. hence , what we need is an algorithm that factores out common parts of the constraints on the logical level , pushing disjunctions down .",
    "example such a factoring makes the use of the name * n * superfluous . in general , however , use of names is actually necessary to avoid exponentially large constraints .",
    "subtrees may be shared by quite different parts of the structure , not only by disjuncts of the same disjunction . in the pp - attachment example",
    ", a compression of the @xmath29-constraint to polynomial size can not be achieved with factoring alone .",
    "] there are two routes that we can take to do this efficiently .    in the first we consider only the structure of the parse forest",
    ", however ignore the content of ( rule or leaf ) constraints .",
    "i.e. we explore the fact that the parts of the @xmath29-constraints in a disjunction that stem from nodes shared by all disjuncts must be identical , and hence can be factored out .",
    "more precisely , we can compute for every node @xmath19 the set must - occur@xmath39 of nodes ( transitively ) dominated by @xmath19 that must occur in a tree of the forest , whenever @xmath19 occurs .",
    "we can then use this information , when building the disjunction @xmath25 to factor out the constraints introduced by nodes in must - occur@xmath39 , i.e. , we build the factor @xmath40 and a ` remainder ' constraint @xmath41 for each disjunct .",
    "the other route goes one step further and takes into account the content of rule and leaf constraints . for it",
    "we need an operation generalise that can be characterised informally as follows .    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ for two satisfiable constraints @xmath18 and @xmath42 , generalise@xmath43 yields the triple @xmath44 , such that @xmath45 contains the ` common part ' of @xmath18 and @xmath42 and @xmath46 represents the ` remainder ' @xmath47 and likewise @xmath48 represents @xmath49 . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the exact definition of what the ` common part ' or the ` remainder ' shall be , naturally depends on the actual constraint system chosen . for our purpose",
    "it is sufficient to require the following properties :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ if generalise@xmath50 , then @xmath51 and @xmath52 and @xmath53 and @xmath54 . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we shall call such a generalisation operation _ simplifying _ if the normal form of @xmath45 is not larger than any of the input constraints normal form .",
    "* example : * an example for such a generalisation operation for prolog s constraint system ( equations over first - order terms ) is the so - called anti - unify operation , the dual of unification , that some prolog implementations provide as a library predicate .",
    "two terms @xmath55 and @xmath56 ` anti - unify ' to @xmath57 , iff @xmath57 is the ( unique ) most specific term that subsumes both @xmath55 and @xmath56 .",
    "the ` remainder constraints ' in this case are the residual substitutions @xmath58 and @xmath59 that transform @xmath57 into @xmath55 or @xmath56 , respectively .",
    "let us now state the method informally .",
    "we use generalise to factor out the common parts of disjunctions .",
    "this is , however , not as trivial as it might appear at first sight .",
    "generalise should operate on solved forms , but when we try to eliminate the names introduced for subtree constraints in order to solve the corresponding constraints , we end up with constraints that are exponential in size . in the following section we describe an algorithm that circumvents this problem .",
    "we call an order @xmath60 on the nodes of a directed acyclic graph @xmath61 with nodes @xmath62 and edges @xmath63 _ bottom - up _ ,",
    "iff whenever @xmath64 ( `` @xmath65 is a predecessor to @xmath66 '' ) , then @xmath67 .",
    "for the sake of simplicity let us assume that any nonterminal node in the parse forest is binary branching .",
    "furthermore , we leave implicit , when conjunctions of constraints are normalised by the constraint solver .",
    "recall that for the generalisation operation it is usually meaningful to operate on solved forms .",
    "however , at least the simplifications @xmath68 and @xmath69 should be assumed .",
    "[ cols= \" < , < \" , ]     construction of sentences of the form i saw a man ( on a hill)@xmath70 for different @xmath10 .",
    "the machine used for the experiment was a sun ultra-2 ( 168mhz ) , running sicstus 3.0#3 . in a further experiment",
    "an n - ary anti_unify operation was implemented , which improved execution times for the larger sentences , e.g. , the 16 pp sentence took 750 msec .",
    "these results approximately fit the expectations from the theoretical complexity bound .",
    "our algorithm and its implementation show that it is not only possible in theory , but also feasible in practice to construct packed semantical representations directly from parse forests for sentence that exhibit massive syntactic ambiguity .",
    "the algorithm is both in asymptotic complexity and in real numbers dramatically faster than an earlier approach , that also tries to provide an underspecified semantics for syntactic ambiguities .",
    "the algorithm has been presented abstractly from the actual constraint system and can be adapted to any constraint - based grammar formalism .",
    "a critical assumption for the method has been that semantic rules never fail , i.e. , no search is involved in semantics construction .",
    "this is required to guarantee that the resulting constraint is a kind of ` solved form ' actually representing so - to - speak the free combination of choices it contains .",
    "nevertheless , our method ( modulo small changes to handle failure ) may still prove useful , when this restriction is not fulfilled , since it focuses on computing the common information of disjunctive branches .",
    "the conjunctive part of the output constraint of the algorithm can then be seen as an approximation of the actual result , if the output constraint is satisfiable .",
    "moreover , the disjunctive parts are reduced , so that a subsequent full - fledged search will have considerably less work than when directly trying to solve the original constraint system .",
    "s.  billot and b.  lang .",
    "the structure of shared forests in ambiguous parsing . in _ proceedings of the 27th annual meeting of the acl , university of british columbia _ , pp .",
    "143151 , vancouver , b.c . ,",
    "canada , 1989 .",
    "j.  drre and m.  dorna .",
    " a formalism for linguistic knowledge representation . in j.",
    "drre ( ed . ) , _ computational aspects of constraint - based linguistic description i , dyana-2 deliverable r1.2.a_. esprit , basic research project 6852 , july 1993 .",
    "m.  egg and k.  lebeth .",
    "semantic underspecification and modifier attachment ambiguities . in j.",
    "kilbury and r.  wiese ( eds . ) , _ integrative anstze in der computerlinguistik .",
    "beitrge zur 5 .",
    "fachtagung der sektion computerlinguistik der deutschen gesellschaft fr sprachwissenschaft ( dgfs ) _ , pp .",
    "dsseldorf , germany , 1995 ."
  ],
  "abstract_text": [
    "<S> we investigate the problem of determining a compact underspecified semantical representation for sentences that may be highly ambiguous . due to combinatorial explosion , </S>",
    "<S> the naive method of building semantics for the different syntactic readings independently is prohibitive . </S>",
    "<S> we present a method that takes as input a syntactic parse forest with associated constraint - based semantic construction rules and directly builds a _ packed semantic structure_. the algorithm is fully implemented and runs in @xmath0 in sentence length , if the grammar meets some reasonable ` normality ' restrictions . </S>"
  ]
}