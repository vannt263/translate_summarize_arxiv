{
  "article_text": [
    "a muller game @xcite@xcite is played on a finite directed graph in which the vertices are two - colored , say with colors red and blue .",
    "there is a token on an initial vertex and two players , call them red and blue , move the token along edges ; it is red s move if the token is on a red vertex , and otherwise it is blue s move . to determine the winner , a muller game also contains a collection @xmath1 of sets of vertices .",
    "one assumes that there are no dead ends and so the play is an infinite walk . at each turn one records the vertex under the token .",
    "the winner is determined by the set @xmath2 of vertices that occur infinitely often ; red wins if @xmath2 is in @xmath1 , and otherwise blue wins .    every two - player perfect - information game with borel winning condition",
    "is determined : one of the players has a winning strategy . in particular , every muller game is determined : either red or blue has a winning strategy .",
    "to _ solve a muller game _ is to determine for every vertex which player has a winning strategy when play starts from the given vertex .",
    "this set of vertices is called that player s _ winning region_. one application of these games is to solve church s synthesis problem : construct a finite - state procedure that transforms any input sequence letter by letter into an output sequence such that the pair of sequences satisfies a given specification .",
    "the modern solution to this problem goes through muller games @xcite .",
    "the first part of this paper ( section [ main - result ] ) characterizes the winning region of a muller game @xmath3 in terms of a two player reachability game .",
    "the length of this reachability game is a measure of the alternating structure of the traps in @xmath3 ; we call it the _ trap - depth _ of @xmath3 .",
    "we briefly explain .",
    "muller games admit natural substructures , _ attractors _ and _ traps_. the red - attractor  @xcite of a subset @xmath4 of vertices is the set of vertices from which red can force the token into @xmath4 ; this may be computed in linear time .",
    "a red - trap  @xcite is a subset @xmath5 of vertices in which blue may keep the token within @xmath5 indefinitely ( no matter what red does ) ; i.e. if the token is in @xmath5 , blue may choose to trap red in the set @xmath5 .",
    "it should be evident that the complement of a red - attractor is a red - trap .",
    "of course , all notions here ( and elsewhere ) defined for red may be symmetrically defined for blue .",
    "thus we talk of blue - attractors and blue - traps .",
    "now , consider the following game played on the same arena as a muller game @xmath3 . the _ trap - depth game on @xmath3 in which red goes first _ ( definition  [ trap_depth_game ] ) proceeds as follows ( the traps discussed in the following are all nonempty ) : red picks a blue - trap @xmath6 ( here @xmath7 are the vertices of the muller game @xmath3 ) which is winning for red ( i.e. @xmath8 ) .",
    "then blue picks a red - trap @xmath9 in the smaller game induced by @xmath10 , where @xmath9 is winning for blue ( i.e. @xmath11 ) . then red picks a blue - trap @xmath12 in the game induced by @xmath9 such that @xmath12 is winning for red .",
    "red and blue continue like this , alternately choosing traps .",
    "the first player that can not move ( i.e. , that can not find an appropriate nonempty trap ) loses . as shown in theorem  [ main_theorem ] ,    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ red has a nonempty winning region in the muller game if and only if red has a winning strategy in the trap - depth game in which red goes first . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    and if red has a winning strategy in this trap - depth game , the first move of any winning strategy , @xmath10 , contains only vertices in red s winning region of the original muller game .",
    "the second part of the paper ( section [ parityalg ] ) is algorithmic and applies the characterization of winning regions to a particular class of muller games , parity games .",
    "a parity game  @xcite is played on a directed graph with vertices labeled by integers called _",
    "priorities_. this game is played between two players , even and odd , who move a token along edges .",
    "a vertex is called even if its priority is even , otherwise it is called odd . even moves when the token is on an even vertex , and odd moves when the token is on an odd vertex .",
    "play starts from a specific vertex ; we assume there are no dead ends in the graph and so a play is an infinite walk .",
    "even wins a play if the largest priority occurring infinitely often is even , otherwise odd wins the play .",
    "it is evident that parity games may be expressed as muller games : the set @xmath1 consists of all subsets @xmath4 of vertices in which the largest priority of vertices in @xmath4 is even .",
    "parity games are intertwined with a logical problem : the model checking problem for modal @xmath13-calculus formulas is log - space equivalent to solving parity games  @xcite .",
    "complexity - wise , the problem is known to be in @xmath14  @xcite , and even @xmath15  @xcite : one of the few combinatorial problems in that category that is not known to be in @xmath16 .",
    "the algorithmically - minded reader may observe a potential drawback with reinterpreting games as a game of alternating traps .",
    "the number of traps in a game can grow exponentially with the size of the game ( just take a graph with only self - loops ) , and what s worse is that we are looking at chains of alternating traps .",
    "nonetheless , we apply the characterization to parity games : say that a graph has _ even trap - depth at most @xmath17 _ if even can guarantee that , in the trap - depth game in which even goes first , the game ends in a win for even within @xmath17 rounds . then , despite the previous observation , we present an algorithm tda@xmath18 ( here @xmath3 is a parity game , @xmath19 is a player , and @xmath17 an integer ) that runs in time @xmath20 and , as shown in theorem [ theorem_tda ] ,    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ returns the largest ( possibly empty ) set starting with which @xmath19 can guarantee a win in at most @xmath17 moves in the trap - depth game on @xmath3 . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    note that the definition of trap depth may be applied to muller games as well , though we do not have an algorithmic application ; one might hope that there are particularly efficient algorithms for finding winning vertices in muller games of small trap depth .",
    "let s put this all together .",
    "say that a parity game has _ trap - depth at most @xmath17 _ if either it has even trap - depth at most @xmath17 or odd trap - depth at most @xmath17 . in figure",
    "[ figure 2 ] we exhibit , for every integer @xmath17 , a parity game with @xmath21 vertices and edges that has trap - depth exactly @xmath17 . by the end of the paper",
    "we will have algorithmically solved the following problems :    1 .",
    "decide if a given parity game @xmath3 has trap - depth at most @xmath17 .",
    "2 .   find a nonempty subset of one of the player s winning region assuming the game has trap depth at most @xmath17 .",
    "moreover , these problems can be solved in time @xmath22 where @xmath23 is the number of vertices and @xmath24 the number of edges of a parity game @xmath3 .",
    "[ preliminaries ]    a _ muller game _ @xmath25 satisfies the following conditions : @xmath26 is a directed graph in which every vertex has an outgoing edge , @xmath7 is partitioned into _ red vertices _ @xmath27 and _ blue vertices _",
    "@xmath28 , and @xmath29 is a collection of subsets of @xmath7 . the muller game is played between two players , red and blue .",
    "red will move when the token is on a red vertex , and otherwise blue will move . starting from some vertex @xmath30 ,",
    "blue s and red s moves result in an infinite sequence of vertices , called a",
    "_ play _ , @xmath31 where @xmath32 .",
    "taking inf@xmath33 to be the set of vertices that occur infinitely often in the play , i.e. @xmath34 if and only if there are infinitely many @xmath35 so that @xmath36 , we say red _ wins the play _",
    "if inf@xmath37 , and otherwise blue wins the play .",
    "take @xmath38 ( we write @xmath39 for the other player , so if @xmath19 is red then @xmath40 is blue , and vice versa ) . a _",
    "@xmath19-strategy _ is an instruction giving player @xmath41 s next move given the current token position and play history .",
    "formally , it is a function whose domain is the set of finite strings of vertices @xmath42 : @xmath43 and whose range is @xmath44 : @xmath45 , the neighborhood of @xmath46 . a @xmath19-strategy is _ winning from vertex @xmath30 _ if , for all plays starting at @xmath30 and for which that strategy is followed whenever it is @xmath19 s turn , the resulting play is winning for @xmath19 .",
    "finally , a @xmath19-strategy is _ memoryless _ if it gives @xmath19 s move while taking into consideration only the current token position ; i.e. , it is a strategy in which the value on @xmath47 depends only on @xmath48 . a given memoryless @xmath19-strategy @xmath49 in a muller game @xmath3 induces a subgame @xmath50 in which we restrict the outgoing edges of any @xmath19 vertex to the edge defined by @xmath49 .",
    "it is worth noting that if both players fix a strategy for the game , then the resulting play is completely determined by the starting vertex , since given the current history we can determine which vertex is visited next .",
    "muller games are determined ( since they are borel we can apply @xcite , although for the special case of regular games see @xcite ) : starting from any vertex , there is a player that has a winning strategy .",
    "determinacy partitions @xmath7 into the respective _ winning regions _ @xmath51 and @xmath52 ( where @xmath53 if and only if @xmath19 has a winning strategy starting from @xmath46 in @xmath3 ) . in contexts where the meaning is clear , we will use @xmath54 for @xmath55 .",
    "it follows easily that for a player @xmath19 there is a single strategy that wins starting from any vertex in @xmath55 ; such a strategy is called a winning strategy .",
    "we now introduce various important substructures of muller games that capture some of the essential concepts of reachability and restriction ( see chapter @xmath56 of @xcite ) .",
    "a _ @xmath19-trap _ is a collection of vertices @xmath57 where : @xmath58 and @xmath59    no @xmath19-vertex in @xmath4 has an outgoing edge leaving the trap , and every @xmath60-vertex in @xmath4 has at least one outgoing edge that stays in the trap .",
    "consequently , if the token ever enters @xmath4 , @xmath60 has a strategy through which the token will never leave @xmath4 , no matter what @xmath19 does .",
    "it is apparent that @xmath61 is a @xmath60-trap .",
    "_ notation .",
    "_ we write @xmath62 to denote the set of nonempty @xmath19-traps in @xmath3",
    "@xmath19-attractor of a set of vertices @xmath5 _ is the set of vertices starting from which @xmath19 has a strategy that guarantees @xmath5 will be reached ( after finitely many , possibly @xmath63 , steps ) .",
    "we denote the attractor of a set @xmath4 in a graph @xmath3 with respect to a player @xmath19 by @xmath64 , and it is worth noting that the attractor of a set may be computed in time linear in the size of the graph ; the algorithm for doing so is presented below  @xcite .",
    "@xmath65 @xmath66 @xmath67 @xmath68 @xmath69    [ alg1 ]    on each iteration , the @xmath19 vertices that have an edge into the part of the attractor that has already been computed are added , and the @xmath60 vertices that have only edges into that part are added .",
    "we briefly argue correctness : by induction on the number of iterations , we see that starting anywhere in the computed set , @xmath19 has a strategy to reach @xmath4 , and starting outside the computed set it is easy to see that @xmath60 has a strategy to avoid the computed set indefinitely ( every @xmath60 vertex outside the set has some edge that does not enter the set , and every @xmath19 vertex outside of it has no edge that enters it ) , so this does compute the attractor .",
    "the _ induced subgame of @xmath3 by @xmath4 _ is the muller game using the vertices @xmath70 and the edges @xmath71 ; we sometimes refer to this as `` @xmath3 restricted to @xmath4 '' and use the notation @xmath72 $ ] .",
    "naturally , @xmath72 $ ] should have no dead - ends if it is to be a muller game .",
    "it is apparent that @xmath3 restricted to a trap @xmath4 is a muller game . when @xmath4 is a trap we use _ subtraps",
    "_ to mean the traps of @xmath72 $ ] .",
    "@xcite [ reducibility ] if @xmath73 then , taking @xmath74 , we have @xmath75 , \\sigma}$ ] .    in other words , if we know that @xmath19 can win from a set",
    ", then we can remove that set s attractor from the graph and just find the winning region for @xmath19 in the smaller graph .",
    "@xcite [ traps ] if @xmath73 and @xmath4 is a @xmath19-trap , then @xmath76,\\sigma}=x$ ] .",
    "intuitively , this holds because in the induced game @xmath72 $ ] player @xmath19 can continue to use the same winning strategy that @xmath19 had in @xmath3 .",
    "we end the section with the statements of some technical lemmas that will be useful .",
    "their proofs are routine .",
    "@xcite if @xmath4 is a @xmath19-trap in @xmath3 and @xmath5 is a @xmath19-trap in @xmath72 $ ] , then @xmath5 is a @xmath19-trap in @xmath3 .",
    "the next lemma states that if we take the @xmath19 attractor of some set @xmath5 and are interested in how it intersects with some @xmath19-trap @xmath4 , then the intersection is contained in the attractor of @xmath77 in the game restricted to @xmath4 .",
    "@xcite if @xmath4 is a @xmath19-trap in @xmath3 , @xmath5 is a set of vertices , and @xmath78 , then @xmath79,x \\cap y , \\sigma)$ ] .",
    "if @xmath4 is a @xmath19-trap in @xmath3 and @xmath5 is a @xmath60-trap in @xmath3 , then @xmath77 is a @xmath60-trap in @xmath72 $ ] .      a _ parity game _ @xmath80 satisfies the following conditions : @xmath26 is a directed graph in which every vertex has an outgoing edge",
    ", @xmath81 denotes a starting vertex , and @xmath82 is a function assigning priorities to the vertices .",
    "the parity game is played between two players , even and odd , where each player moves the token along a directed edge of @xmath3 whenever the token is on a vertex of the corresponding parity .",
    "we say a vertex is even if it has even priority and odd if it has odd priority .",
    "even s and odd s moves result in an infinite play : @xmath83 where @xmath32 .",
    "even wins the play if @xmath84 is even and odd wins otherwise : i.e. , the largest priority that occurs infinitely often determines the winner of the play .",
    "note that , given a parity game , we may define the corresponding muller game by placing @xmath46 in @xmath27 if and only if @xmath85 is even",
    ". then @xmath86 has @xmath87 if and only if @xmath88 is even , and otherwise @xmath88 is odd and @xmath89 .",
    "the corresponding muller game is then @xmath90 .",
    "note that a play is winning in the muller game if and only if it is winning in the parity game .    not only are parity games determined , they are _ memorylessly determined _",
    "@xcite : for every vertex @xmath91 , exactly one of the two players has a memoryless strategy that guarantees a win starting from @xmath46 .",
    "moreover , for each player there is a single memoryless strategy which , if followed , will result in a winning play starting from any vertex in that player s winning region ; this is a called a memoryless winning strategy .",
    "note that muller games are not memorylessly determined ; they may require a strategy that uses some of the play history .",
    "as mentioned in the introduction , our main result relies on a characterization stemming from chains of alternating subtraps .",
    "each subtrap represents the decision of the corresponding player to further restrict the token s movement .",
    "this goes on until the final restriction leaves one player incapable of preventing a winning play for their opponent .",
    "we now formalize this idea .",
    "we begin by defining a set of statements related to chains of alternating traps .",
    "define @xmath92 to be @xmath1 if @xmath19 is red and @xmath93 otherwise .",
    "the statement @xmath94 says that if the set of vertices that occurs infinitely often is @xmath2 , then player @xmath19 wins .",
    "recall that @xmath62 is the set of _ nonempty _ @xmath19-traps in @xmath3 .",
    "our boolean statements @xmath95 are defined recursively and have three parameters : the player @xmath19 , the game @xmath3 , and the iteration ( or depth ) number @xmath17 .    for player @xmath19 , game @xmath3 , and integer @xmath17 ,",
    "the value of @xmath96 is @xmath97 . for @xmath98 ,",
    "the value of @xmath99 is @xmath100 if and only if there exists @xmath101 such that    * @xmath102 , and * @xmath103 ) \\text { we have } y \\in r_\\sigma \\text { or }   \\delta_{\\sigma}(g[y ] , k-1)$ ] .",
    "each statement @xmath99 asserts that @xmath19 can restrict the token s movement via a trap @xmath4 in such a way that if every vertex in the trap occurs infinitely often , player @xmath19 wins , i.e. @xmath102 , ( intuitively then , player @xmath40 must choose to further restrict play ) and , no matter how @xmath60 further restricts the token s movement via a subtrap @xmath5 , either still @xmath104 or we have that @xmath105,k-1)$ ] is true .",
    "so , in particular , @xmath106 states that there is a blue - trap @xmath4 in @xmath3 with @xmath107 such that every red - subtrap @xmath5 has @xmath108 .",
    "the above definitions make it easy to see that the statements make references to natural structures in muller games , but they can be rather cumbersome to work with , so we present an equivalent but easier to visualize way to think about them .",
    "[ trap_depth_game ] let @xmath3 be a muller game .",
    "define the _ trap - depth game on g in which @xmath19 goes first _ as follows : in the beginning of the @xmath109 round ( @xmath110 ) there will be some current muller game @xmath111 .",
    "the game starts with @xmath112 . in the @xmath109 round player",
    "@xmath19 moves first by choosing a trap @xmath113 with @xmath114 .",
    "player @xmath60 replies by choosing a @xmath19-trap @xmath115 in the subgame @xmath116 $ ] , i.e. @xmath117)$ ] , so that @xmath118 .",
    "this completes the @xmath119 round .",
    "define @xmath120 $ ] .",
    "the first player that has no legal move loses .    in a muller game",
    ", this will terminate in at most @xmath121 rounds , as each time a player chooses a trap , a vertex must be removed .",
    "if the muller game is a parity game , then the condition @xmath102 simply states that the largest priority of a vertex in @xmath4 is of parity @xmath19 . for a parity game ,",
    "the number of rounds is at most @xmath122 , since the size of the largest vertex still in play decreases twice per round .",
    "in particular , every play in this game is finite and ends in a win for one of the players .",
    "therefore , the game is determined ( i.e. one of the players has a winning strategy ) .",
    "the value of @xmath123 is @xmath100 if and only if @xmath19 has a strategy that ensures their opponent loses the trap - depth game in which @xmath19 goes first in at most @xmath17 rounds ( so @xmath60 would lose on or before the @xmath124 move ) .",
    "this is easily verified by identifying player moves with the quantifiers in the expression for @xmath123 .",
    "we now arrive at the first main result of this paper :    [ main_theorem ] let @xmath3 be a muller game",
    ". then @xmath125 if and only if @xmath19 has a winning strategy in the trap - depth game on @xmath3 in which @xmath19 goes first . moreover , any first move @xmath4 in a winning strategy by @xmath19 satisfies @xmath126 .",
    "so player @xmath41 has some nonempty winning region in the game @xmath3 if and only if @xmath19 has a winning strategy in the trap - depth game in which @xmath19 goes first .",
    "note the following simple corollary :    the following two statements are equivalent :    * parity games can be solved in polynomial time . * the player with a winning strategy in the trap - depth game described by a parity game can be determined in polynomial time .",
    "this theorem also motivates a new parameter for parity games :    the _ trap - depth _ of a parity game @xmath3 is the minimum integer @xmath17 such that @xmath127 or @xmath128 .",
    "note that this is a parameter that fundamentally depends on both the graph and the priorities of the vertices .",
    "although having bounded trap - depth is much more general , one simple class of parity games that has this property is those with a bounded number of priorities .",
    "the above definition applies equally well to muller games , though we do not have an algorithmic application .",
    "similarly , one can define the _ @xmath19-trap - depth _ of @xmath3 as the minimum integer @xmath17 ( if it exists ) such that @xmath123 ; so @xmath129 if and only if the @xmath19-trap depth of @xmath3 is at most @xmath122 .",
    "this upper bound can be achieved , as shown by figure [ figure 2 ] .",
    "we will first prove the characterization of muller games ( the first two sentences of theorem [ main_theorem ] ) for games in which player @xmath19 has a memoryless strategy that wins starting from any vertex in @xmath54 .",
    "intuitively , traps do not distinguish between memoried and memoryless strategies ; we will formalize this intuition and this will allow us to extend the main theorem to all muller games .",
    "[ lemma_maxismine ] let @xmath3 be a nonempty muller game with @xmath130 , that is in which @xmath19 wins starting from any vertex , and @xmath49 a memoryless winning strategy for @xmath19 .",
    "then there is a nonempty @xmath60-trap @xmath131 in @xmath3 such that @xmath132,\\sigma}=t$ ] , @xmath133 , and , if @xmath49 is followed , then any play starting in @xmath131 will not leave @xmath131 ( i.e. @xmath49 does not prescribe leaving @xmath131 ) .",
    "fix a memoryless winning strategy @xmath49 for @xmath19 in @xmath3 , and take @xmath50 to be the subgame induced by @xmath49 ; that is , leave only one edge out of each @xmath19 vertex , the one corresponding to the strategy @xmath49 . take @xmath131 to be a strongly connected component ( scc ) of @xmath50 such that @xmath131 has no edges into any other scc .",
    "note that @xmath131 is a @xmath60-trap in @xmath50 , and so also in @xmath3 . since @xmath131",
    "is strongly connected and player @xmath19 only has one possible move at any vertex , @xmath60 has a strategy ( not necessarily memoryless ) such that starting from any vertex in @xmath131 , if the strategy is followed , every vertex in @xmath131 occurs infinitely often .",
    "then , by the assumption that @xmath49 was winning , we must have @xmath133 . by construction , @xmath49 does not prescribe leaving @xmath131 .",
    "the following two propositions establish the theorem for muller games in which @xmath19 has a memoryless winning strategy .",
    "[ prop1 ] if @xmath125 and @xmath19 has a memoryless winning strategy , then @xmath19 has a winning strategy on the trap - depth game on @xmath3 in which @xmath19 goes first .",
    "fix @xmath49 a memoryless winning strategy for @xmath19 .",
    "we describe a strategy for @xmath19 in the trap - depth game so that for every @xmath110 player @xmath19 has a valid move @xmath134 satisfying that @xmath49 does not prescribe leaving @xmath135 and any potential response @xmath115 satisfies the invariant @xmath136,\\sigma}=y_i$ ] . to get the induction going",
    "we define @xmath137 and note that @xmath138,\\sigma}=y_0 $ ] .",
    "note that such a strategy ensures that player @xmath19 always has a valid move and thus wins the trap - depth game .",
    "suppose @xmath139 rounds have been played , and assume by induction that @xmath19 wins the muller game starting from any vertex in @xmath115 .",
    "then , by lemma [ lemma_maxismine ] , there is some @xmath60-trap @xmath140 in @xmath141 $ ] with @xmath142 such that @xmath143,\\sigma}=x_{i+1}$ ] and @xmath49 does not prescribe leaving @xmath140 ; have @xmath19 play such an @xmath140 .",
    "then , if player @xmath60 has some response @xmath144 , we have that @xmath144 is a @xmath19-trap in @xmath145 $ ] and so by lemma  [ traps ] @xmath146,\\sigma}=y_{i+1}$ ] , as required .    [ prop2 ]",
    "if @xmath147 and player @xmath60 has a memoryless winning strategy , then @xmath60 has a strategy that wins the trap - depth game on @xmath3 in which @xmath19 goes first .",
    "let @xmath4 be player @xmath19 s first move .",
    "then , since @xmath4 is a @xmath60-trap , we have @xmath76,\\overline\\sigma } = x \\neq \\emptyset$ ] by lemma  [ traps ] .",
    "note that now we simply play the trap - depth game on @xmath72 $ ] in which @xmath60 goes first and @xmath148 is a memoryless winning strategy on @xmath72 $ ] , and so by the previous proposition we have that @xmath60 has a winning strategy .",
    "the previous two propositions show the desired characterization of muller games , assuming that players have memoryless winning strategies .",
    "while muller games do not , in general , have memoryless strategies , a player need only use a finite amount of memory . to formalize this notion",
    ", we define a bounded - state strategy .    for any muller game @xmath3 , any positive integer @xmath149 , and any function @xmath150 \\rightarrow [ n]$ ] , define the @xmath151-sequence with respect to any play @xmath152 by @xmath153 and @xmath154",
    ".    intuitively , in the above , @xmath155 $ ] is the ( joint ) memory used by the players and @xmath156 depends only on @xmath157 and on the most recent move .    for any muller game @xmath3 , any positive integer @xmath149 , and any function @xmath150 \\rightarrow [ n]$ ] , a strategy @xmath158 for player @xmath19 is a bounded - state @xmath151-strategy if there is some @xmath159 \\rightarrow v$ ]",
    "so that if @xmath160 is any play consistent with @xmath158 and @xmath161 is the corresponding @xmath151-sequence , then @xmath158 depends only on @xmath157 .",
    "i.e. , there is some function @xmath159 \\rightarrow v$ ] so that for each @xmath19-vertex @xmath162 , we have @xmath163 .",
    "the following theorem is proved in @xcite .",
    "it states that , while muller games may not have memoryless strategies , players need only a bounded amount of memory .    for any muller game",
    "@xmath3 there is some positive integer @xmath149 and some @xmath150 \\rightarrow [ n]$ ] so that , for each player @xmath19 , there is a bounded - state @xmath151-strategy @xmath158 satisfying that , starting from any vertex in @xmath19 s winning region , @xmath158 is a winning strategy for @xmath19 .    given any muller game @xmath3 , take @xmath149 a positive integer and @xmath150 \\rightarrow [ n]$ ] as in the previous theorem .",
    "we define the memoried muller game associated with @xmath3 , call it @xmath164 , to have vertex set @xmath165 $ ] ( where @xmath149 depends on @xmath3 as in the previous theorem ) .",
    "intuitively , @xmath164 will simulate @xmath3 , but each vertex @xmath166 $ ] in the memoried game records the current state of the memory , with @xmath167 representing the current position in @xmath3 .",
    "thus , given @xmath168 vertices in the memoried game , @xmath169 is an edge of the memoried game if and only if @xmath170 is an edge in @xmath3 and @xmath171 ( here @xmath172 is the first coordinate of @xmath46 and @xmath173 $ ] is the second coordinate ) .",
    "define the vertices belonging to player @xmath19 , @xmath174 , by @xmath175 if and only if @xmath176 .",
    "similarly , @xmath177 is winning for red , i.e. has @xmath178 , if and only if the corresponding vertices are winning for red in the original muller game @xmath3 , i.e. if and only if @xmath179 .",
    "note that by the previous theorem and the construction of the memoried games , both players have memoryless winning strategies in @xmath164 .",
    "the remainder of this section argues that the trap - structure of @xmath164 is very similar to that of @xmath3 .",
    "intuitively , the following lemma says that if , when playing the trap - depth game on @xmath164 , player @xmath40 simply pretends it s the trap - depth game on @xmath3 , then any edge out of a @xmath40 vertex that would have existed were the game played on @xmath3 also exists in the game on @xmath164 .",
    "assume , in a trap - depth game on @xmath164 whenever the current set of vertices is @xmath180 and it is @xmath40 s turn to move , that @xmath40 s move has the following form : taking @xmath181 , there is some @xmath19-trap @xmath5 in @xmath72 $ ] so that @xmath40 s move is @xmath182)$ ] .",
    "then , at every point in the game , if the current set of vertices is @xmath180 , take @xmath183 .",
    "for any @xmath184 with @xmath185 and for any @xmath186 so that @xmath187 is an edge of @xmath3 , there is some @xmath188 so that @xmath169 is an edge of @xmath164 and @xmath189 .",
    "we proceed by induction on the number of plays in the game . in the base case ,",
    "the game is the whole graph and this is true by construction of @xmath164 .",
    "take @xmath180 to be the current set of vertices and @xmath181 .",
    "if it is @xmath19 s turn to move , @xmath19 chooses some @xmath60 trap @xmath190 .",
    "taking @xmath191 , for any @xmath192 with @xmath185 and for any @xmath186 so that @xmath187 is an edge of @xmath3 , by induction there is some @xmath188 so that @xmath169 is an edge of @xmath164 and @xmath189 .",
    "but @xmath190 is a @xmath60 trap , so since @xmath192 and @xmath46 is a @xmath40 vertex we get @xmath193 .",
    "if it is @xmath60 s turn to move , @xmath60 chooses some @xmath19 trap @xmath190 of the form @xmath182)$ ] where @xmath5 is a @xmath19 trap in @xmath4 .",
    "note that @xmath194 , so this notation is consistent with previous notation .",
    "given any @xmath60 vertex @xmath192 and any @xmath195 so that @xmath187 is an edge of @xmath3 , by induction there must be some @xmath188 with @xmath196 so that @xmath169 is an edge of @xmath164 .",
    "but then @xmath193 since @xmath197 and @xmath198 .",
    "player @xmath19 has a winning strategy in a trap - depth game ( in which either @xmath19 or @xmath40 goes first ) on @xmath3 if and only if player @xmath19 has a winning strategy in a trap - depth game on @xmath164 ( in which the same player goes first ) .",
    "assume player @xmath19 has a winning strategy in a trap - depth game on @xmath164 .",
    "then player @xmath19 is to play a trap - depth game on @xmath3 and we wish to show that player @xmath19 has a winning strategy ; we define player @xmath19 s strategy by emulating the game on @xmath164 .",
    "with each move , player @xmath19 will maintain a set of vertices @xmath180 which represents the state of the emulated game on @xmath164 .",
    "assume the current set of vertices in the game on @xmath3 is @xmath4 , and @xmath19 has maintained the state @xmath180 .",
    "we will inductively show that @xmath19 has a strategy that maintains @xmath199 and that , starting from @xmath180 with the appropriate player moving , is winning for @xmath19 in the game @xmath164 . in the base case , @xmath200 and @xmath201 .",
    "if it is @xmath40 s turn to move , @xmath40 will pick some @xmath19 trap @xmath202 .",
    "then we claim @xmath203\\right)$ ] is a @xmath19-trap in @xmath180 : since @xmath5 is a @xmath19-trap in @xmath4 , it must be the case that given any @xmath19 vertex in @xmath190 , any neighbor it had in @xmath180 is also in @xmath190 . given a @xmath60 vertex @xmath46 in @xmath190 , since @xmath5 is a @xmath19-trap we have that @xmath167 has a neighbor in @xmath5 , and so @xmath46 has a neighbor @xmath204 in @xmath190 by the previous lemma , thus verifying that @xmath190 is a @xmath19-trap .",
    "then @xmath205 so @xmath206 since @xmath202 .",
    "since @xmath180 was winning for @xmath19 , we have @xmath190 is as well ( since any move by @xmath40 must result in a winning position ) .",
    "if it is @xmath19 s turn to move , by assumption we are in some winning position @xmath180",
    ". then @xmath19 may choose some @xmath60 trap @xmath207 in @xmath208 $ ] so that @xmath190 is winning for @xmath19 .",
    "we claim @xmath209 is a @xmath60 trap in @xmath4 .",
    "since @xmath190 is a @xmath60 trap in @xmath180 , given any @xmath19 vertex @xmath195 choose @xmath192 with @xmath210 ; @xmath46 must have some neighbor @xmath193 , so @xmath170 is an edge of @xmath5 . given any @xmath60 vertex @xmath211 and any neighbor @xmath195 , we may choose @xmath192 with @xmath212 and then we have that there is some @xmath188 which is a neighbor of @xmath46 with @xmath189 by the previous lemma , but @xmath190 is a @xmath60-trap , so @xmath193 and so @xmath213 , as desired .",
    "we ve shown that , if @xmath19 has a winning strategy on @xmath164 , then @xmath19 has a winning strategy on @xmath3 .",
    "symmetrically , if @xmath40 has a winning strategy on @xmath164 , then @xmath40 has a winning strategy on @xmath3 , thus proving the theorem .    by combining the previous theorem with propositions [ prop1 ] and [ prop2 ]",
    ", we may remove the assumptions regarding having memoryless winning strategies :    if @xmath125 , then player @xmath19 has a winning strategy on the trap - depth game on @xmath3 in which @xmath19 goes first .",
    "if @xmath147 , then player @xmath60 has a winning strategy on the trap - depth game on @xmath3 in which @xmath19 goes first .",
    "assume @xmath131 is the first - move @xmath60-trap in the trap - depth game on @xmath3 where @xmath19 goes first and that @xmath19 wins starting from @xmath214 $ ] if @xmath40 goes first .",
    "if @xmath215 , then @xmath4 is a @xmath19-trap in @xmath214 $ ] with @xmath76,\\overline\\sigma}=x$ ] .",
    "so , by lemma [ lemma_maxismine ] , if we consider @xmath180 in @xmath164 , @xmath60 has a viable move @xmath216 such that @xmath217,\\overline\\sigma}=y_m$ ] . by our previous arguments",
    "we then get that @xmath40 can win in the trap depth game in which @xmath19 goes first on @xmath218 $ ] where @xmath205 is a @xmath19-trap in @xmath72 $ ] .",
    "then @xmath5 is a valid move for @xmath60 in @xmath214 $ ] , contradicting the assumption that @xmath19 can win from @xmath214 $ ] if @xmath60 goes first .    if @xmath131 is the first - move of a winning @xmath19-strategy in the trap - depth game where @xmath19 goes first , then @xmath219 .",
    "this completes the proof of theorem [ main_theorem ] .",
    "it is interesting to understand how these nested traps will interact with modifications to the graph .",
    "the following theorem says that via one such modification not much information is lost ; this is particularly useful if one wishes to run the algorithms discussed in the next section .",
    "[ intersecttrap ] let @xmath3 be a muller game .",
    "assume that , in the trap depth game on @xmath3 , @xmath4 is a valid first move for @xmath19 that allows @xmath19 to guarantee a win in at most @xmath17 rounds and that @xmath220 is a @xmath19-trap so that @xmath221 is non - empty",
    ". then there is @xmath222 where @xmath5 is a valid first move for @xmath19 that allows @xmath19 to win in at most @xmath17 rounds on the trap depth game on @xmath223 $ ] .    since @xmath4 is a @xmath40 trap in @xmath3 and @xmath220",
    "is a @xmath19 trap in @xmath3 , we have @xmath224 is a @xmath40 trap in @xmath223 $ ] .",
    "furthermore , @xmath224 is a @xmath19 trap in @xmath72 $ ] .",
    "if @xmath224 is in @xmath225 then @xmath224 is a valid move for @xmath40 in the trap depth game on @xmath3 after @xmath19 plays @xmath4 .",
    "therefore , @xmath19 must have a response @xmath5 that leads to a win in at most @xmath226 rounds ; then @xmath5 is a @xmath40 trap in @xmath224 and therefore also in @xmath220 , so it is a valid first move for @xmath19 in @xmath223 $ ] .    otherwise , @xmath224 is in @xmath92 .",
    "we will make @xmath224 player @xmath19 s first move in the trap depth game on @xmath223 $ ] .",
    "assume @xmath40 has a response @xmath227 so that @xmath19 can not win from @xmath227 in at most @xmath226 rounds .",
    "then @xmath227 is a @xmath19 trap in @xmath228 $ ] and therefore also in @xmath72 $ ] , so @xmath227 is a valid response for @xmath40 in the trap depth game on @xmath3 to the play @xmath4 , contradicting the assumption .    finally , in preparation for the next section ,",
    "we translate the above into the language of parity games .",
    "define the `` max '' of a set of vertices to be those vertices in the set with maximum priority .",
    "recall that @xmath62 is the set of nonempty @xmath19-traps in @xmath3 .",
    "then the condition @xmath102 becomes @xmath229 .",
    "for example , we may rewrite the statements @xmath230 :    @xmath231 false ; + @xmath232 \\text { and } $ ] +    in the definition of trap - depth game , for example , when it is player @xmath19 s turn , player @xmath19 will choose a @xmath60 trap whose largest priority is of parity @xmath19 .",
    "recall for a parity game @xmath3 that @xmath233 returns the largest set @xmath4 which , as a first move for @xmath19 , allows @xmath19 to win in at most @xmath17 rounds in the trap - depth game on @xmath3 .",
    "theorem [ intersecttrap ] tells us that the @xmath17th trap - depth algorithm is robust in the following sense : if one determines that some vertices are winning for @xmath19 and removes their attractor from the graph , either one removes all of @xmath233 or else one can find the rest of @xmath233 by repeatedly running the @xmath17th trap depth algorithm on the remaining set .",
    "in this section of the paper , all discussions are with regards to parity games .",
    "we present a collection of algorithms that return subsets of the vertices of a parity game , culminating in the trap - depth algorithm ( tda ) .",
    "we will have two versions of tda ( which take different inputs ) .",
    "we will discuss the first of the algorithms later .",
    "the characterization of the second algorithm , tda@xmath18 , follows easily from the first , and it takes as its inputs a parity game @xmath3 , a player @xmath19 , and an integer @xmath17 .",
    "we will ultimately show the following characterization of the second tda algorithm :    [ theorem_tda ] tda@xmath18 returns the largest ( possibly empty ) set @xmath2 so that if @xmath19 uses @xmath2 as a first move , @xmath19 can guarantee a win in at most @xmath17 moves in the trap - depth game on @xmath3 .",
    "note that , by theorem [ main_theorem ] , this implies in particular that tda@xmath234 .      due to the complexity of the tda",
    ", we will first introduce some simpler algorithms .",
    "understanding the simpler algorithms will help significantly in understanding the tda .",
    "the overall structure of the tda resembles that of a classical algorithm for solving bchi games , which we present here . a bchi game is a parity game in which all of the priorities are",
    "either @xmath63 or @xmath235 is just based on the parity of @xmath85 .",
    "if we had given an alternative , equivalent , definition of parity games in such a way that these two notions were separated , i.e. if the player who chooses where to move the token may depend on @xmath46 itself , then parity games in which all priorities are either 0 or 1 would be bchi games .",
    "simpler algorithms exist under our simplified definition of bchi games . however , the algorithm for solving the original problem is instructive , even when applied to the simplified bchi games , so we present it here . ] .",
    "therefore , odd wins a bchi game if and only if odd has a strategy that reaches vertices of priority @xmath235 infinitely many times .",
    "the algorithm takes as input a bchi game @xmath3 and returns the winning region for odd .",
    "@xmath236 @xmath237 @xmath238 @xmath239 @xmath240 @xmath241 @xmath242    [ buchi ]    the classical algorithm for bchi games begins each iteration of its while - loop with a set of target vertices @xmath243 .",
    "it then computes the attractor of @xmath244 .",
    "this provides the largest set of vertices from which odd has a strategy for reaching the set @xmath244 .",
    "the attractor by itself , however , does not provide any strategy for @xmath19 after the token reaches @xmath244 . to remedy this",
    ", the algorithm then tests each vertex in @xmath244 to check if it has the option to continue this strategy by returning the token back to the attractor of @xmath244 . if not , then that vertex is removed from being a target .",
    "this process repeats until the set @xmath244 stabilizes",
    ".    we will first observe that the algorithm outputs a subset of odd s winning region . to see this , take @xmath242 to be the output of the algorithm and @xmath131 to be the final set of target vertices ( so that @xmath245 ) .",
    "consider the following strategy for odd : from any vertex of @xmath131 , odd chooses to enter @xmath242 ( this is possible by the termination condition of the algorithm ) . from any vertex of @xmath246 , odd follows a strategy to reach @xmath131 .",
    "this guarantees that the vertices of @xmath131 are visited infinitely often ; since these vertices have priority @xmath235 , this is a winning strategy for odd .",
    "conversely , even has a winning strategy from any vertex not in @xmath242 . to see this ,",
    "let @xmath247 be the sequence of values of @xmath248 at the beginning of the while loop in the execution of bchi@xmath249 ( with the final value repeated ) .",
    "take @xmath250 .",
    "note that @xmath251 , and therefore @xmath252 , is a decreasing sequence .",
    "we claim that any odd vertex in @xmath252 must be in @xmath251 .",
    "if some odd vertex @xmath204 were in @xmath252 but not in @xmath251 , then there must be some edge from @xmath204 into @xmath252 .",
    "however , @xmath204 must have been removed from @xmath253 for some @xmath254 , which means there is no edge from @xmath204 into @xmath255",
    ". however , the sequence of @xmath255 is decreasing , a contradiction .",
    "we now proceed by induction to show that even has a winning strategy from any vertex not in @xmath252 .",
    "note that @xmath256 . therefore , any vertex not in @xmath257 is not in the attractor of @xmath258 , so from any such vertex even has a strategy that never visits any vertex of priority @xmath235 .",
    "take for an inductive hypothesis that , for some @xmath35 , any vertex not in @xmath252 is winning for even",
    ". then @xmath259 .",
    "assume for contradiction that there is some vertex @xmath46 that is not in @xmath260 so that @xmath46 is winning for odd",
    ". then @xmath46 must be in @xmath261 , as otherwise @xmath46 is winning for even by the inductive hypothesis . since @xmath46 is not in @xmath260 ,",
    "even has a strategy starting from @xmath46 that avoids @xmath262 indefinitely .",
    "then consider even playing the following strategy : as long as the token remains in @xmath252 , even plays any strategy that avoids entering @xmath262 .",
    "if the token ever leaves @xmath252 , then even has a winning strategy and uses it . since @xmath46 is winning for odd , odd must have some winning strategy .",
    "consider the play induced by even playing the aforementioned strategy and odd playing a winning strategy .",
    "this play can not leave @xmath252 , as otherwise even wins .",
    "however , some vertex @xmath263 of priority @xmath235 must be visited .",
    "since even avoids @xmath262 indefinitely , we must have that @xmath204 is not in @xmath262 .",
    "since all odd vertices in @xmath252 are in @xmath251 , we therefore have that @xmath204 is in @xmath264 . however , by definition of @xmath262 , this means that there are no edges from @xmath204 into @xmath252 , so the next vertex in the play is not in @xmath252 , a contradiction .",
    "this completes the proof of the correctness of the classical bchi games algorithm .",
    "the algorithm for solving trap - depth @xmath235 parity games closely resembles that for bchi games .",
    "the main difference is that , rather than taking the attractor of the target set , we take a  safe \" version of the attractor .",
    "this takes a parameter @xmath266 ; the @xmath266-safe attractor in @xmath3 of a set @xmath4 for player @xmath19 is the set of vertices from which @xmath19 has a strategy that guarantees @xmath4 will be reached and that , in the process , no vertices ( excluding those in @xmath4 ) of priority at least @xmath266 are visited .",
    "@xmath65 @xmath66 @xmath67 @xmath267 @xmath69    [ alg2 ]    at each iteration of the `` while '' loop , the set @xmath69 ( initially @xmath4 ) is enlarged by adding any vertices ( of priority less than @xmath266 ) in @xmath268 or in @xmath269 that , respectively , have an edge going into @xmath69 or have only edges going into @xmath69 .",
    "note the similarities to the attractor , algorithm  [ alg1 ] .",
    "indeed , one sees that @xmath270 if @xmath271 . and",
    ", just like the regular attractor , one sees that the safe attractor stabilizes its own output ; i.e. , @xmath272 .    however , it is not obvious how to directly substitute the safe attractor into algorithm [ buchi ] , as there does not appear to be a canonical choice for the parameter @xmath266",
    ". this motivates the sequential safe attractor algorithm , which , in the trap - depth @xmath265 case , iteratively applies the @xmath266-safe attractor to @xmath19-vertices of priority at least @xmath266 . recall that we defined the max of a set of vertices to be the vertices of largest priority in that set .",
    "below , if @xmath2 is a set of vertices that all have the same priority , then @xmath273 is that priority ( rather than the singleton containing that priority ) .",
    "@xmath274 @xmath275 @xmath276 @xmath277 @xmath278 @xmath242    at the beginning of the `` while '' loop above , we have a set @xmath242 and a list @xmath279 of target vertices to process .",
    "each iteration of the loop calls the safe attractor algorithm .",
    "the sequential attractor removes the issue of a priority bound inside the safe attractor . for any vertex @xmath91 ,",
    "seqattr@xmath280 tests if @xmath19 has a strategy to move the token from @xmath46 towards some @xmath281 in which any resulting path did not visit any vertices of priority at least @xmath282 .",
    "the algorithm for solving trap - depth @xmath235 parity games , tda@xmath283 , simply substitutes the sequential safe attractor for the attractor in the bchi games algorithm , algorithm [ buchi ] .",
    "@xmath237 @xmath238 @xmath239 @xmath284 @xmath241 @xmath242    tda@xmath283 returns the largest @xmath40 trap @xmath4 in @xmath3 so that every @xmath19-subtrap @xmath5 has that the vertices of largest priority in @xmath5 belong to player @xmath19 .",
    "we will sketch a proof of this fact ; a complete proof will follow from the arguments in the next section .",
    "the proof will argue three different points , from which the characterization of tda@xmath283 follows immediately :    1 .",
    "( monotonicity ) : if @xmath220 is a @xmath60-trap in @xmath3 , then we have tda@xmath285,\\sigma ) \\subseteq \\text{tda}_1(g,\\sigma)$ ] .",
    "completeness ) : if @xmath7 satisfies that every @xmath19-trap in @xmath7 has a vertex whose maximum priority is of parity @xmath19 , then tda@xmath286 .",
    "soundness ) : tda@xmath287 is a @xmath60-trap in @xmath3 whose maximum priority is of parity @xmath19 and which satisfies that every @xmath19-subtrap has maximum priority @xmath19 .    to argue monotonicity , one first argues that the safe attractor algorithm is monotonic with respect to its parameter @xmath266 , its input set @xmath4 , and sometimes with respect to the parity game .    explicitly ,",
    "if @xmath288 , if @xmath289 , and if @xmath220 is a @xmath60-trap in @xmath3 , then @xmath290,\\lambda_1,x_1,\\sigma ) \\subseteq \\text{safeattr}(g,\\lambda_2,x_2,\\sigma).\\ ] ] this is intuitive , but will be proven carefully in the next section .    from this ,",
    "monotonicity of seqattr@xmath291 easily follows .",
    "if @xmath289 and if @xmath220 is a @xmath60-trap in @xmath3 , then seqattr@xmath285,x_1,\\sigma ) \\subseteq \\text{seqattr}_1(g , x_2,\\sigma)$ ] . a generalization of this will be proven in the next section .",
    "finally , from this , point ( 1 ) , monotonicity of tda@xmath291 , easily follows . again , a generalization is carefully proved in the next section .",
    "now we will argue completeness .",
    "assume the whole vertex set @xmath7 satisfies that every @xmath19-trap in @xmath7 has maximum priority of parity @xmath19 .",
    "then we claim that seqattr@xmath292 .",
    "this will imply that tda@xmath291 terminates after the first call to seqattr and returns @xmath7 , as desired . to see that seqattr@xmath293 , consider the first iteration of the  while \" loop : since @xmath7 is a @xmath19-trap in @xmath7 , the first iteration computes the @xmath19-safe - attractor of @xmath294 with @xmath295 .",
    "however , since these are the vertices of maximum priority , this is the same as computing the attractor .",
    "the remaining set is a @xmath19-trap in @xmath7 , and so has maximum priority of parity @xmath19 . by induction , this continues until @xmath279 is empty and seqattr@xmath291 returns all of @xmath7 .",
    "finally , we argue the soundness of tda@xmath291 . at the end of the execution of tda@xmath291 , there is some final set of target vertices @xmath131 satisfying every vertex of @xmath131 has an edge into seqattr@xmath296 . by our observations about seqattr@xmath291 ,",
    "starting from any vertex in tda@xmath283 , @xmath19 has some strategy to reach some vertex @xmath204 in @xmath131 so that along the way only priorities less than @xmath282 are visited .",
    "furthermore , by the terminating condition of tda@xmath291 , every vertex in @xmath131 has an edge back into tda@xmath283 .",
    "this gives that tda@xmath283 is indeed a @xmath60-trap .",
    "furthermore , starting from the largest vertex in any @xmath19-trap , @xmath19 may follow the strategy that allows @xmath19 to reach some vertex @xmath204 in @xmath131 without seeing larger vertices along the way ; @xmath19 can not force the play to leave the trap , and therefore the largest priority in the trap must be @xmath204 , a @xmath19-vertex , as desired .",
    "the main difference between the general trap - depth algorithm ( tda ) and tda@xmath291 is that we change the call to safe attractor in tda@xmath291 to a stronger algorithm , the generalized safe attractor .",
    "indeed , we prove a more general result than theorem [ theorem_tda ] , allowing us to strengthen any algorithm that satisfies certain conditions .",
    "let paralg@xmath287 be an algorithm that takes as input a parity game @xmath3 and a player @xmath19 and returns a subset of the vertices of @xmath3 .",
    "we say paralg is _ nice with traps _ if :    * for any parity game @xmath3 and any @xmath40 trap @xmath220 in @xmath3 , paralg@xmath297,\\sigma)\\subseteq \\text { paralg}(g,\\sigma)$ ] . * for any parity game @xmath3 , taking @xmath298 , for any @xmath40-trap @xmath220 containing @xmath2 , paralg@xmath297,\\sigma)=s$ ] , and for any @xmath19-trap @xmath220 intersecting @xmath2 , paralg@xmath297,\\sigma)$ ] is nonempty . *",
    "paralg@xmath287 always returns a @xmath40-trap whose largest priority belongs to player @xmath19 .",
    "if paralg is nice with traps , then we can strengthen it via the tda .",
    "[ generaltda ] let paralg@xmath287 be an algorithm that takes as input a parity game @xmath3 and a player @xmath19 and returns a subset of the vertices of @xmath3 . if paralg is nice with traps , then tda@xmath299 returns the largest @xmath40-trap @xmath4 whose maximum priority is of parity @xmath19 so that , for every @xmath19-subtrap @xmath5 , either the maximum priority of @xmath5 belongs to @xmath19 or we have paralg@xmath300,\\sigma)$ ] is nonempty .",
    "recursively applying theorem [ generaltda ] will give theorem [ theorem_tda ] .",
    "we will introduce terminology to talk about the conditions on the set @xmath4 from theorem [ generaltda ] .",
    "let paralg@xmath287 be an algorithm that takes as input a parity game @xmath3 and a player @xmath19 and returns a subset of the vertices of @xmath3 . given a parity game @xmath3 and",
    "a set of vertices @xmath4 , we say @xmath4 is @xmath301 for paralg with respect to player @xmath19 if @xmath4 is a @xmath40-trap whose maximum priority is of parity @xmath19 so that for every @xmath19-subtrap @xmath5 , either the maximum priority of @xmath5 belongs to @xmath19 or we have paralg@xmath300,\\sigma)$ ] is nonempty .    when the context is clear , we will simply say that @xmath4 is good .",
    "we said that tda is obtained from tda@xmath291 by replacing the call to safe attractor , so let us first present the generalized safe attractor algorithm .",
    "the idea behind the safe attractor is to guarantee reaching a target set of vertices in a @xmath266-safe way , so that along the way we do nt see vertices of priority at least @xmath266 .",
    "the idea behind the generalized safe attractor is to guarantee that , if @xmath19 fails to reach a target set of vertices , then @xmath19 wins the play ; this all happens in a manner that is careful with vertices of priority at least @xmath266 , which we informally refer to as  @xmath266-safe \" .    in order to ensure that everything that is done is @xmath266-safe , we will at some point remove all vertices of priority at least @xmath266 from the game by taking the restriction to vertices of lower priority : define the @xmath266-restriction of a parity game restrict@xmath302 . in words , the only vertices that remain in restrict@xmath303 are those from which @xmath19 can ensure that all the priorities in any resulting play are less than @xmath266 .",
    "we are now ready to introduce the generalized safe attractor .",
    "it takes as input a parity game @xmath3 , a number @xmath266 , a set of target vertices @xmath4 , a player @xmath19 , and an algorithm paralg@xmath287 .",
    "it is most useful to think of the context where paralg is nice with traps .",
    "@xmath65 @xmath66 @xmath67 @xmath304 @xmath305,\\lambda,\\sigma)$ ] @xmath306,\\sigma)$ ] @xmath69    at the general step of the `` while '' loop , we begin with a set @xmath307 of vertices which we want to reach in a @xmath266-safe way .",
    "the loop then calls the safe attractor algorithm .",
    "safeattr@xmath308 returns the largest collection of vertices @xmath2 from which @xmath19 has a strategy to force the token into @xmath307 such that the token only hits vertices of priority smaller than @xmath266 along the way .",
    "once the set @xmath2 has been found , we check if , given that @xmath40 avoids @xmath4 , player @xmath19 has any _ winning _ strategy given by paralg ( which is @xmath266-safe ) on the remaining set @xmath309 ; we add this to @xmath2 to get @xmath69 .",
    "each iteration either adds vertices to @xmath69 or terminates the loop . since @xmath310 can not increase indefinitely , genattr eventually halts .    for a vertex @xmath46 and a subset @xmath4",
    ", @xmath46 will be in genattr if and only if there is a @xmath19-strategy to move the token from @xmath46 towards @xmath4 such that , depending on @xmath60 s moves , _ either _ the token eventually reaches @xmath4 _ or _ the token reaches a vertex from which paralg provides a winning strategy for @xmath19 ; in both cases , all the vertices visited by the token have priority less than @xmath266 , except perhaps the ones in @xmath4 .",
    "as the name suggests , the generalized safe attractor is a generalization of the safe attractor . consider the case where paralg@xmath287 simply returns the empty set for every input . under this condition",
    ", we claim that genattr@xmath311 .",
    "later we will show that safeattr stabilizes its own output ; this immediately gives that , if paralg is always empty , a call to genattr will have at the end of the first  while \" loop @xmath69 equal to safeattr , and will subsequently terminate with this output .",
    "both the general case of the sequential safe attractor algorithm and the tda are analogous to the ones before , except the sequential safe attractor calls the generalized safe attractor .",
    "as before , if @xmath2 is a set of vertices that all have the same priority , then we write @xmath273 to denote that priority .",
    "@xmath274 @xmath275 @xmath276 @xmath312 @xmath278 @xmath242    [ alg3 ]    for any @xmath313 , @xmath19 has a strategy to ensure that , if the token ever reaches some @xmath281 , it hits only vertices of priority smaller than @xmath282 along the way and , if it never reaches @xmath4 , then @xmath19 wins .",
    "tda simply calls the sequential safe attractor .",
    "@xmath237 @xmath238 @xmath239 @xmath314 @xmath241 @xmath242    [ alg4 ]    as before , tda calls seqattr on progressively smaller sets of target vertices @xmath248 .",
    "one easily sees that the set @xmath242 output by tda@xmath299 is the sequential attractor of some final collection @xmath315 of target vertices .",
    "if @xmath19 follows the strategy given by the sequential attractor on @xmath242 , the resulting play will either be winning for @xmath19 , as guaranteed by the conditions on paralg , or reach @xmath131 infinitely often , and the largest priority will belong to @xmath19 and so the play will be winning for @xmath19 .",
    "we now outline the proof of theorem [ generaltda ] .",
    "we will prove three propositions from which theorem [ generaltda ] will follow immediately . note that , in the second statement below ( completeness ) , @xmath7 is the whole vertex set of the parity game .",
    "let paralg@xmath287 be an algorithm that takes as input a parity game @xmath3 and a player @xmath19 and returns a subset of the vertices of @xmath3 .",
    "assume paralg is nice with traps .    1 .   ( monotonicity ) :",
    "if @xmath220 is a @xmath60-trap in @xmath3 , then we have tda@xmath297,\\sigma,\\text{paralg } ) \\subseteq \\text{tda}(g,\\sigma,\\text{paralg})$ ] .",
    "completeness ) : if @xmath7 is good , then tda@xmath316 .",
    "( soundness ) : tda@xmath299 is good",
    ".    we will now build up the machinery to prove the above .",
    "we begin with some general lemmas that will be useful ; they are all reasonably simple to prove and we omit their proofs .",
    "the first of these notes that safeattr is equal to attr for @xmath266 large enough .",
    "@xmath317 if @xmath318 .",
    "the next lemma notes that the algorithms are stable when run on their own outputs .",
    "the second and third statements follow from the ones prior .",
    "let @xmath220 be a @xmath40 trap .    1 .   if @xmath319 , then @xmath320,\\lambda , s,\\sigma)\\ ] ] 2 .   if @xmath321 , then @xmath322,\\lambda , s,\\sigma,\\text{paralg})\\ ] ] 3 .",
    "if @xmath323 , then @xmath324,\\lambda , s,\\sigma,\\text{paralg})\\ ] ]    a similar statement holds for the tda . observe first that tda@xmath18 is a @xmath40 trap in @xmath3 with maximum vertex of parity @xmath19 .",
    ". then @xmath326,\\sigma,\\text{paralg}).\\ ] ]    as before , it is also true that @xmath327,\\sigma,\\text{paralg})$ ] where @xmath220 is any @xmath40 trap containing @xmath328 ; this follows easily from the characterization of the tda , but is more difficult to prove given only what we have established so far .",
    "we now prove monotonicity of safeattr for the inputs @xmath329 and sometimes for the graph @xmath3 :    if @xmath289 , @xmath288 , and @xmath220 is a @xmath40 trap with @xmath330 , then safeattr@xmath297,\\lambda_1,x_1,\\sigma ) \\subseteq \\text{safeattr}(g,\\lambda_2,x_2,\\sigma)$ ] .",
    "take @xmath331 to be the values of @xmath69 at the beginning of each `` while '' loop in the execution of safeattr@xmath297,\\lambda_1,x_1,\\sigma)$ ] ( with the final value repeating ) and take @xmath332 similarly from the execution of safeattr@xmath333 . then @xmath334 .",
    "note that , by definition of a trap , if @xmath335 then @xmath336}(v ) \\subseteq n_g(v)$ ] , and if @xmath337 then @xmath336}(v ) = n_g(v)$ ] .",
    "if @xmath338 then we have    @xmath339}(v ) \\cap c_i \\neq \\emptyset\\ } \\subseteq \\{v \\in v_\\sigma : p(v ) < \\lambda_2 \\wedge n_g(v ) \\cap c_i ' \\neq \\emptyset\\}\\ ] ] @xmath340}(v ) \\subseteq c_{i}\\ } \\subseteq \\{v \\in v_{\\overline\\sigma } : p(v)<\\lambda_2 \\wedge n_g(v ) \\subseteq c_i'\\}\\ ] ]    and so @xmath341 , and by induction this holds for all @xmath35 .",
    "we now simultaneously address three monotonicity properties for genattr : monotonicity of the output with respect to the inputs @xmath329 and also sometimes with respect to the graph @xmath3 .",
    "the next lemma is a weak monotonicity property for genattr , saying that one iteration of the ` while ' loop in the algorithm will be contained in the genattr of the stronger inputs ; combining this with the previous lemma will give monotonicity properties for genattr .",
    "assume @xmath289 and @xmath288 .",
    "assume @xmath220 is a @xmath40 trap in @xmath3 and @xmath330 .",
    "take @xmath342,\\lambda_1,x_1,\\sigma)\\ ] ] @xmath343,\\lambda_1,\\sigma)\\ ] ] @xmath344,\\sigma)\\ ] ] then @xmath345 .",
    "take @xmath346 to be the value of @xmath69 at the end of the execution of genattr@xmath347 . taking :    @xmath348 @xmath349,\\lambda_2,\\sigma)\\ ] ] @xmath350,\\sigma)\\ ] ] we have that @xmath351 and @xmath352 is empty .",
    "we get that @xmath353 by monotonicity of the safe attractor , and so we need only show that @xmath354 .",
    "assume , for sake of contradiction , that @xmath355 is not a subset of @xmath346 , and so in particular @xmath356 .    in the following",
    ", we refer to traps in induced subgraphs that are not necessarily subgames , i.e. they may have vertices without outgoing edges .",
    "the definition of trap remains unchanged .",
    "we claim that @xmath357 is a @xmath40 trap in @xmath358 $ ] .",
    "take @xmath359 .",
    "we know that @xmath355 is a @xmath40 trap in @xmath360 $ ] .",
    "then note that @xmath361,b,\\overline{\\sigma})$ ] , and so we get that @xmath362 is a @xmath40 trap in @xmath363 $ ] and so @xmath355 is a @xmath40 trap in @xmath363 $ ] . since the edges of @xmath364 $ ] are a subset of the edges of @xmath363 $ ]",
    ", we get that any @xmath40 vertex in @xmath357 has no edges leaving @xmath357 in the graph @xmath364 $ ] .",
    "given any @xmath19 vertex in @xmath357 , since @xmath365 and since @xmath366 , the @xmath19 vertex had no edges into @xmath367 in @xmath223 $ ] ( for otherwise it would be contained in @xmath367 ) and so the @xmath19 vertex must have some edge into @xmath357 and so we get that indeed @xmath357 is a @xmath40 trap in @xmath364 $ ] , and so also in @xmath368 $ ] ( since @xmath220 is a @xmath40-trap in @xmath7 ) .",
    "we have @xmath357 is a @xmath60-trap in @xmath368 $ ] with no vertices of priority at least @xmath266 ; any such structure must be a @xmath60-trap in @xmath358 $ ] .    because @xmath355 has no vertices of priority at least @xmath369 , we have @xmath370,s',\\sigma)$ ] , and so @xmath357 is a @xmath19-trap in @xmath371 $ ] . since we know paralg is nice with traps , we have that paralg@xmath372,\\sigma)=t^*$ ] .",
    "therefore , again since paralg is nice with traps , paralg@xmath373,\\sigma)$ ] is nonempty .",
    "finally , paralg@xmath373,\\sigma ) \\subseteq \\text{paralg}(g[v'],\\sigma)$ ] , but this contradicts the assumption that @xmath374 .",
    "therefore , we must have that @xmath375 .    if @xmath289 and @xmath288 and @xmath220 is a @xmath40 trap in @xmath3 with @xmath330 , then genattr@xmath297,\\lambda_1,x_1,\\sigma,\\text{paralg } ) \\subseteq \\text{genattr}(g,\\lambda_2,x_2,\\sigma,\\text{paralg})$ ] .",
    "take @xmath331 to be the values of @xmath69 at the beginning of each `` while '' loop in the execution of genattr@xmath297,\\lambda_1,x_1,\\sigma,\\text{paralg})$ ] ( with the final value repeating ) .",
    "take    @xmath376,\\lambda_2,c_i,\\sigma)\\ ] ] @xmath377,\\lambda_2,\\sigma)\\ ] ] @xmath378,\\sigma)\\ ] ]    we will proceed by induction on @xmath35 to show that @xmath379 . note this holds for @xmath257 since @xmath380 .",
    "then , for @xmath381 , we have @xmath382 and by the previous lemma and inductive hypothesis we get : @xmath383 @xmath384 @xmath385 completing the proof",
    ".    we will now proceed to show monotonicity of seqattr .",
    "while the original definition was slightly more natural , the following reformulation of seqattr will be more useful .",
    "we leave it to the reader to verify that the following reformulation of seqattr is equivalent to the original .",
    "it follows immediately from monotonicity and stability of genattr .",
    "if @xmath386 is a finite collection of integers and @xmath387 then , taking @xmath16 to be the priorities in @xmath386 of parity @xmath19 , the following algorithm has the same output as seqattr .",
    "@xmath275 @xmath388 @xmath389 @xmath390 @xmath391 @xmath392 @xmath242    [ alg3rev ]    intuitively , we simply run the genattr for every priority in @xmath16 , which just adds redundancy by the assumption @xmath393 : if ever in the original formulation of seqattr some call genattr@xmath394 were made , then in the above version some call will be made with the same parameter @xmath266 .",
    "we now show monotonicity properties for seqattr with respect to the input @xmath4 and also sometimes with respect to the graph @xmath3 :    if @xmath289 and @xmath220 is a @xmath39-trap in @xmath3 such that @xmath330 , then seqattr@xmath297,x_1,\\sigma,\\text{paralg } ) \\subseteq \\text{seqattr}(g , x_2,\\sigma,\\text{paralg})$ ]    take @xmath395 .",
    "take @xmath396 to be the values of @xmath397 respectively at the beginning of the @xmath35th iteration of the `` while '' loop in the execution of seqattr@xmath398,x_1,\\sigma,\\text{paralg})$ ] .",
    "take    @xmath399 @xmath400    similarly take @xmath401 for the execution of seqattr@xmath402 . since @xmath403 and @xmath404 and @xmath405 we get @xmath406 and @xmath407 for all @xmath35 .",
    "then @xmath408 since @xmath289 .",
    "we now proceed by induction to show @xmath338 .",
    "we have @xmath409 and @xmath410,\\lambda_i , s_i \\cup c_i,\\sigma,\\text{paralg } ) \\subseteq\\ ] ] @xmath411    we now present the monotonicity theorem for tda :    if @xmath220 is a @xmath60-trap in @xmath3 , then we have tda@xmath297,\\sigma,\\text{paralg } ) \\subseteq \\text{tda}(g,\\sigma,\\text{paralg})$ ] .",
    "let @xmath247 be the values of @xmath248 at the beginning of the `` while '' loop in the execution of @xmath412,\\sigma,\\text{paralg})$ ] .",
    "take @xmath413,t_i,\\sigma,\\text{paralg})$ ] .",
    "similarly define @xmath414 for tda@xmath299 .",
    "we proceed by induction to show @xmath415 .",
    "this holds for @xmath416 since @xmath417 .",
    "then , by monotonicity of seqattr , we get @xmath338 . to obtain @xmath262 and @xmath418 from @xmath419 , respectively ,",
    "any vertex in @xmath419 without an edge into @xmath420 is removed .",
    "the edges of @xmath3 are a superset of those of @xmath223 $ ] and @xmath421 is a superset of @xmath252 , so we get : @xmath422}(v ) \\cap c_i = \\emptyset\\ } = t_i \\setminus \\{v \\in t_i : n_{g[a]}(v ) \\cap c_i = \\emptyset\\ } \\subseteq\\ ] ] @xmath423      if @xmath7 is good for paralg with respect to @xmath19 and if @xmath424 and @xmath266 are such that @xmath425 , then taking @xmath426 we have @xmath427 and if @xmath428 then @xmath429 .",
    "we consider that by the terminating condition for the genattr algorithm , we must have @xmath430 note that @xmath431 ( since @xmath432 ) and so we get @xmath433 since @xmath434 , we also get by the terminating condition for genattr that @xmath435 , but , by assumption , since @xmath309 is a @xmath19 trap in @xmath3 , either @xmath436 ( in which case we are done ) or @xmath429 .    if @xmath7 is good for paralg with respect to @xmath19 , then seqattr@xmath437    taking @xmath438 to be the values of @xmath279 at the beginning of each while loop in the execution of seqattr@xmath439 , take @xmath440 @xmath441 then we have by the previous lemma @xmath442 . then , by induction , if @xmath443 , we have either @xmath444 or @xmath445 and so the seqattr will not terminate until @xmath446 .    if @xmath7 is good for paralg with respect to @xmath19 , then tda@xmath316 .",
    "the previous lemma immediately gives that the tda will terminate after the first iteration of the `` while '' loop and return @xmath7 , since seqattr will return the whole set of vertices .      if @xmath4 is a @xmath19-trap in @xmath3 and if @xmath447 then @xmath448 .",
    "note that safeattr@xmath449 and @xmath450 .    if @xmath4 is a @xmath19-trap in @xmath3 with largest vertex of priority @xmath451 and with paralg@xmath452,\\sigma ) = \\emptyset$ ] , then if @xmath447 we have @xmath453 .",
    "take @xmath331 to be the value of @xmath69 at the beginning of each `` while '' loop in the execution of genattr@xmath454 .",
    "take @xmath455 @xmath456,\\lambda,\\sigma)\\ ] ] @xmath378,\\sigma)\\ ] ] we proceed by induction on @xmath35 to show @xmath457 .",
    "this holds by assumption for @xmath458 . if this holds for @xmath252 , then @xmath459 .",
    "note that , because all vertices in @xmath4 have priority smaller than @xmath266 , @xmath460,x \\setminus v_i,\\overline{\\sigma})$ ] .",
    "in particular , we have that @xmath461 is a @xmath40-trap in @xmath72 $ ] .",
    "since paralg is nice with traps , this implies that paralg@xmath462,\\sigma ) = \\emptyset$ ] .",
    "since @xmath4 is a @xmath19-trap in @xmath3 and @xmath463 , we get that @xmath4 is a @xmath19-trap in @xmath464 $ ] . by definition , @xmath465 is the complement of a @xmath60 attractor , so @xmath465 is a @xmath60-trap in @xmath464 $ ] .",
    "since @xmath4 is a @xmath19-trap and @xmath465 is a @xmath60-trap , we get that @xmath466 is a @xmath19-trap in @xmath467 $ ] .",
    "since @xmath251 is a @xmath60-trap in @xmath467 $ ] and @xmath461 is a @xmath19-trap in @xmath467 $ ] , we have that @xmath468 is a @xmath60 trap in @xmath469 $ ] .",
    "therefore , since paralg is nice with traps , paralg@xmath470,\\sigma ) = \\emptyset$ ] . if @xmath468 were nonempty , then , since paralg is nice with traps and @xmath461 is a @xmath19-trap in @xmath467 $ ] , we would have paralg@xmath470,\\sigma ) \\neq \\emptyset$ ] , a contradiction . therefore",
    ", we must have @xmath471 .    finally , since @xmath472",
    ", we have that @xmath473 , as desired .",
    "if @xmath4 is a @xmath19-trap with largest vertex of priority @xmath266 , @xmath266 has parity @xmath40 , and paralg@xmath452,\\sigma ) = \\emptyset$ ] , then the largest vertices of @xmath4 are not contained in seqattr@xmath439 .",
    "take @xmath474 and @xmath438 to be the value of @xmath279 at the beginning of each `` while '' loop in the execution of seqattr@xmath439 .",
    "take @xmath475 @xmath476    if @xmath477 we have , by maximality of @xmath266 , that @xmath463 , and so by induction that @xmath478 . by the previous lemma we get @xmath479 .",
    "if @xmath480 , then we have @xmath481 and so by induction @xmath482 .",
    "therefore , no vertices of @xmath483 can be added by the call to genattr and so @xmath484 .",
    "tda@xmath299 returns a set that is good for @xmath19 with respect to paralg .",
    "take @xmath325 .",
    "then @xmath485,\\sigma,\\text{paralg})$ ] .",
    "we ve observed before that @xmath2 is a @xmath40 trap whose largest vertex has priority of parity @xmath19 , so we may assume without loss of generality that @xmath486 . by the previous lemma , there is no nonempty set @xmath4 that is a @xmath19-trap with largest vertex of priority @xmath40 so that paralg@xmath452,\\sigma)=\\emptyset)$ ] .",
    "this completes the proof of theorem [ generaltda ] .",
    "we now define the second trap - depth algorithm , tda@xmath18 , and prove theorem [ theorem_tda ]",
    ". we will define tda@xmath18 by recursively applying tda@xmath299 . in order to do so",
    ", we will need to know that tda@xmath299 is nice with traps whenever paralg is .    if paralg is nice with traps , then tda@xmath299 is nice with traps .    the same argument used in proving theorem [ intersecttrap ] applies to show that , for any @xmath19-trap @xmath5 , if tda@xmath487 is nonempty , then tda@xmath300,\\sigma,\\text{paralg})$ ] is nonempty .",
    "the rest of the properties of being nice with traps follow from theorem [ generaltda ] .",
    "we now define tda@xmath488 recursively .",
    "define tda@xmath489 to be the algorithm that always returns the empty set .",
    "note this is nice with traps .",
    "given tda@xmath490 , define tda@xmath491 by tda@xmath492 .",
    "inductively applying theorem [ generaltda ] now proves theorem [ theorem_tda ] .",
    "note that we had previously defined tda@xmath283 .",
    "recalling that @xmath493 and that safeattr stabilizes its own output , it is easy to see that these two definitions match",
    ".      let @xmath494 be an upperbound on the runtime of paralg@xmath287 for a graph @xmath3 on @xmath23 vertices and @xmath24 edges .",
    "then the runtime of tda@xmath299 on a graph on @xmath23 vertices and @xmath24 edges is at most @xmath495 .",
    "consider first the safe attractor algorithm .",
    "since each iteration of the `` while '' loop increases the size of @xmath69 or halts the algorithm , there will be at most @xmath496 loops .",
    "if implemented carefully ( in the same way that the regular attractor is implemented ) we may guarantee that each edge is only used a constant number of times and actually run the algorithm in @xmath497 time .",
    "next , consider the generalized safe attractor algorithm .",
    "each iteration of the `` while '' loop increases the size of @xmath69 or halts the algorithm . on top of calling paralg",
    ", the algorithm does @xmath498 work for each loop ( restrict@xmath303 can be computed in linear time ) . if the algorithm runs @xmath499 `` while '' loops , it does work at most @xmath500 .",
    "the sequential attractor algorithm has @xmath242 increasing every iteration or the algorithm halts .",
    "note that each time a call to generalized attractor causes the generalized attractor to go through a `` while '' loop , a new vertex is added to @xmath242 ,",
    "so the total number of such loops done throughout the calls to generalized attractor is @xmath23 , and so the total amount of work is at most @xmath501 .",
    "in tda we have @xmath248 decreasing on each iteration or the algorithm halts , and so there are at most @xmath23 calls to seqattr , and on top of these only @xmath498 work is done , and so we get @xmath502 .",
    "let @xmath503 denote the runtime of tda@xmath18 for a graph @xmath3 on @xmath23 vertices and @xmath24 edges .",
    "then @xmath504 and for @xmath505 we have @xmath506 .",
    "we have @xmath507 since this algorithm always returns the empty set .",
    "the same optimizations used in the computation of the attractor and the safe attractor may be used to get a runtime of @xmath498 in the case @xmath265 for the sequential attractor , that is for seqattr@xmath291 . in tda",
    "we have @xmath248 decreasing on each iteration or the algorithm halts , and so there are at most @xmath23 calls to seqattr@xmath291 , and on top of these only @xmath498 work is done , and so we get @xmath508 .    for @xmath509 by the previous lemma we have @xmath510 .",
    "this recurrence solves to @xmath511 , as desired .",
    "the theorems of the previous section show the promised characterization of tda ( theorem [ theorem_tda ] ) :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ tda@xmath18 returns the largest ( possibly empty ) set starting with which @xmath19 can guarantee a win in at most @xmath17 moves in the trap - depth game on @xmath3 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we have introduced trap - depth games ( where the moves consist of choosing subsets of the graph rather than vertices / edges ) and shown their close relationship with muller games .",
    "we have defined the trap - depth parameter and given algorithms for parity games for finding subsets of the winning regions whose runtime is bounded by an exponential in this trap - depth .",
    "writing @xmath512 , since the trap - depth of a parity game is at most @xmath513 , the algorithm runs in time @xmath514 .",
    "if one is only interested in the class of graphs with a bounded number of priorities , there are other options .",
    "the classical algorithm of zielonka also runs in time @xmath514 ( see @xcite ) , but there are better algorithms : jurdzinski s @xcite algorithm achieves @xmath515 , and the subexponential algorithm of @xcite achieves @xmath516 .",
    "of course , the class of graphs of bounded trap depth is much more general than the class of graphs with a bounded number of priorities .    by lemma  [ reducibility ] ,",
    "finding any nonempty subset of the winning region allows us to remove part of the graph to get a smaller parity game that needs to be solved ; thus , for example , parity games in which every subgame has bounded trap depth ( such as those with a bounded number of priorities ) may be completely solved in polynomial time , a generalization of the result that parity games with a bounded number of priorities may be solved in polynomial time .",
    "parity games are just one encoding of a class of muller games .",
    "one may ask if there are others for which the characterization of muller games we present is algorithmically useful .",
    "one possible encoding is called _ explicit muller games _ , where an enumeration of the sets winning for red , i.e. of the set @xmath1 , is explicitly given as input .",
    "there is a known polynomial time algorithm for solving explicit muller games @xcite , but we may hope to obtain another algorithm using the characterization . if one could efficiently answer the following question ,",
    "such an algorithm exists ( note in the following question @xmath517 are given explicitly ) :    given a muller game @xmath3 and an explicit list @xmath518 , is there some polynomial time algorithm that determines if every red - trap @xmath50 contains one of the @xmath519 as a blue - subtrap ?    to see that the above would allow us to solve the problem ,",
    "let an explicit muller game @xmath520 be given .",
    "we will first prune @xmath1 by removing any sets @xmath521 in which some vertex has no outgoing edges in @xmath522 $ ] ( these have no impact on the game ) . to determine",
    "if red has a nonempty winning region , we will find the collection @xmath279 of sets in @xmath1 from which red will win the trap - depth game in which blue goes first .",
    "we will iteratively update @xmath1 and @xmath279 .",
    "choose any minimal ( under inclusion ) set @xmath521 .",
    "for each such set @xmath523 we determine if @xmath522 $ ] contains any red - traps that do not contain as a blue - trap any set in @xmath524 .",
    "if @xmath522 $ ] has no such red - traps , then we add @xmath523 to @xmath279 . in either case",
    ", we remove @xmath523 from @xmath1 and iterate .",
    "it is easy to argue that if in the trap - depth game the set of vertices is @xmath4 and it is red s turn to move , then a blue - trap @xmath5 in @xmath72 $ ] is winning for red if and only if @xmath50 is in @xmath279 . to determine if red has a non - empty winning region , we need only check if one of the sets in @xmath279 is a blue - trap in @xmath3 .",
    "this work was partially supported by nsf grant dms-0648208 at the cornell reu , which are both gratefully acknowledged .",
    "andrey grinshpun is partially supported by the npsc .",
    "andrei tarfulea is partially supported by the nsf grfp .",
    "we warmly thank alex kruckman , james worthington and ben zax for many stimulating discussions on an early part of this work , as well as damian niwinski for his comments .",
    "we also thank the anonymous referee , without whose comments reading this paper would be much less pleasant ."
  ],
  "abstract_text": [
    "<S> muller games are played by two players moving a token along a graph ; the winner is determined by the set of vertices that occur infinitely often . </S>",
    "<S> the central algorithmic problem is to compute the winning regions for the players . </S>",
    "<S> different classes and representations of muller games lead to problems of varying computational complexity . </S>",
    "<S> one such class are parity games ; these are of particular significance in computational complexity , as they remain one of the few combinatorial problems known to be in np @xmath0 co - np but not known to be in p. we show that winning regions for a muller game can be determined from the alternating structure of its traps . to every muller game </S>",
    "<S> we then associate a natural number that we call its _ trap depth _ ; this parameter measures how complicated the trap structure is . </S>",
    "<S> we present algorithms for parity games that run in polynomial time for graphs of bounded trap depth , and in general run in time exponential in the trap depth . </S>"
  ]
}