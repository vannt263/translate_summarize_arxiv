{
  "article_text": [
    "dynamics of stockmarket oscillations is not yet completely understood .",
    "it is anyway clear that market price returns resemble the scaling laws characterizing physical systems dominated by the interaction of a large number of units . in @xcite",
    "it is shown that , since the details of the circumstances governing the expectations and decisions of all the individuals are unknown to the modeler , the behavior of a large number of heterogeneous agents may best be formalized using a probabilistic setting , taking into account that the properties of macro variables are not necessarily identical to those of the corresponding micro variables @xcite .    in our model",
    "we introduce only one kind of trader , since we want the features of the time serie of the market price ( of course a macro variable ) to derive from the collective behavior of the agents ( micro variable ) competing for the same goal and sharing the same resources . the well - known adage _",
    "time is money _ applies perfectly here : the way to success lies in picking the right price at the right moment .",
    "the book is the most suitable structure to take into account the joint effect of these two factors .",
    "the insertion of an order implies the storage of the desired price and orders are sorted according to their arrival time .",
    "every trader has a limited amount of money and a given propension towards investment .",
    "the simulation starts with the _ initial public offer _ ( * ipo * ) : all the shares belong to one agent , supposed to be the bank responsible of the new emission . during this time , lasting until the bank does not own any share more , traders are encouraged to buy : the buying list becomes longer and longer and agents get the shares at the ipo price , the price decided by the bank for the emission .",
    "some people may want to sell shares before the end of this phase , but the occurrence of such an event is unlikely , since they ask a price bigger than the bank ( this is the soul of speculation ) .",
    "the bank can not operate on the market when this transient is finished ; who owns shares want to sell them for a higher price and agents without shares want to buy them at a fair price .",
    "of course the meaning of _ fairness _ is very different for buyers and sellers and this price formation represents one of the key aspect of the model .",
    "every trader , when willing to buy , has to identify the price according to past trends , opinion of the media and indications coming from competitors .",
    "the price coming out in the order is a weighted sum of the previous .",
    "the quality of an investment has to take into account the involved time , too .",
    "that is why agents are also characterized by a threshold , a kind of critical age of the share : they do not want to own it for a longer time than what is justified by the money brought from the investment .",
    "all the simulations presented here have been performed considering @xmath0 traders trading just @xmath1 stock with @xmath2 shares on a common market .",
    "a detailed description of the data structure for the _ type_trader _ is given in appendix .",
    "here we comment only part of the field in that record .",
    "the algorithm is carried out in the following way : at each time step a trader is randomly selected and , according to the parameter _",
    "investment_inclination _ the decision whether he / she will trade or not is taken . in this way we model the difference between intraday speculators and people who do not like to perform too many operations .    through the parameter _ neighbours [ ]",
    "_ we model the herding behavior , since agents share some information with acquaintances . to the same aim",
    "we have introduced _ memory [ ] _ : the noise trader philosophy concerns with the analysis of past values of the market price looking for trends .",
    "these values are not constant , since not all the people have the same attitude to ask others for opinions and the amount of information they can consult about the stock varies from agent to agent , too .",
    "suppose now that the selected trader really wants to trade , namely he / she wants to sell ( buy ) some shares . in this case",
    "a new entry in the book list has to be created .",
    "orders are stored according to the type ( buy or sell ) , to the price and to the submission time . at every time step , after the trader s query , we also check the book state , looking for the occurrence of a transaction : it happens every time that the cheapest price among the sell list equals the most expensive offer in the buying list and this defines the market price in that moment .    when formulating the price @xmath3 for the order , every trader performs a weighted average over the following values :    * @xmath4 , the target price averaged over all the acquanintances of the given agent .",
    "* @xmath5 , the target price broadcasted by the media . *",
    "@xmath6 , the expected price due to the actual trend , formulated taking into account the trend over the past _ mem _ prices .    the value of @xmath5 is generated considering the last market price @xmath7 and comparing the current ratio between the number of buyers and the number of sellers in the book ( @xmath8 stands for book unbalance ) with the parameter @xmath9 ( unbalance of the book ) , in the following way : @xmath10 if @xmath11 , @xmath12 if @xmath13 , @xmath14 if @xmath15 .",
    "time & trad . & sh . &",
    "price & price & sh . & trad . & time + 11012 & 120 & 5 & 10912 & 10914 & 6 & 652 & 10802 + 10951 & 1 & 25 & 10910 & 10914 & 16 & 12 & 11115 + 11435 & 233 & 7 & 10909 & 10916 & 8 & 431 & 11613 + 10702 & 890 & 3 & 10906 & 10917 & 1 & 801 & 10211 + 11647 & 507 & 4 & 10905 & 10920 & 3 & 212 & 11765 +    to get the fair price with which entering the market , every trader subtracts a given quantity to @xmath3 , according to his / her _ expected_gain_. when querying an agents who is still waiting for the execution of a submitted order , he / she can also decide to change some parameter of it , considering the elapsed time and all the other information already discussed in this section .    in tab.[tab : esempiobook ] we give an example of the first five levels of the book .",
    "we can see that orders are divided according to the type , namely buy or sell , and ordered on the basis of price ( decreasing order for the buy side , increasing order for the sell side ) , time of arrival .",
    "therefore the first line of the book contains the highest buying price and the cheapest selling price .",
    "since the second value is bigger than the first , there is no chance for any transaction to occur .",
    "for more details we refer the reader to the appendix , where the pseudo_code for the algorithm is presented .",
    "the result of a typical simulation run is shown in fig.[fig : serie ] : we can clearly see the ipo phase lasting few hundreds of ticks , where the price remains constant because the bank offers the shares to the traders at a suggested value .",
    "after this transient , the pressure made from people without shares forces the price to raise . letting the time evolve ,",
    "one runs into a tranquil period , with a slowly oscillating price , since owners do not want to sell because they hope to get more money if the wait a little bit more and agents without shares want to buy at a lower price .",
    "this dynamical equilibrium is unstable and leads to a small burst whose effect is that the price increases to a more suitable value for owners .",
    "a rally is usually followed by a crash ( a kind of settlement ) , as reported in @xcite under the name of _ on - off intermittency _ , an aperiodic switching between static , or laminar , behavior and chaotic bursts of oscillations .",
    "on the other hand a rally usually follows a crash , what is happening in the last part of fig.[fig : serie ] .    in fig.[fig :",
    "volumi ] we have plotted the corresponding volumes of fig.[fig : serie ] .",
    "the correlation between the total amount of exchanged shares and the price variations is clear .",
    "it becomes particularly evident in the last part of the graph , where the big crash occurs : a lot of people would like to sell shares , but they can do that only subject to a cheapest request ; as the price starts to decrease some agents may sell as a consequence of their stop - loss constraints and this produces a further diminution of the market price , such that many of the buying orders can be performed .",
    "these new owners do not sell immedietely the shares and this helps to escape from the _ panic selling phase _ : the crash is finished and immediately followed by a rally period .",
    "as already mentioned , universal characteristics exhibited by financial prices comprise a distribution with fat tails ( events with a distance bigger than @xmath16 from the average return are not so uncommon as a gaussian distribution would forecast ) and a correlation in the volatility ( alternation between tranquil and tumultuous periods ) . in tab.[tab : hurst ] we report on the presence of a strong persistence in the volatility .",
    "this is done estimating the self - similarity parameter h @xcite for raw and absolute returns ( being the latters a measure of volatility ) . the behavior of our simulation is in total agreement with empirical results , as proved by h going from 0.52 to 0.85 . a random walk shows no significant increase of h when switching from raw returns to absolutes ones .",
    ".[tab : hurst ] hurst exponent of raw and absolute returns for different time series . [ cols=\"<,^,^\",options=\"header \" , ]     fat tails are detectable through the probability density function ( pdf ) of the returns . in fig.[fig : fattails ] we show the pdf of our simulated time series together with a gaussian distribution of returns having the same standard deviation . extreme events happen with a higher frequency in the simulation , giving raise to the typically observed alternation between tranquil period , rally days and crashes .",
    "we want now to discuss a problem found in evaluating the richness of traders .",
    "every agent can possess cash money and shares .",
    "the value of the former is obvious , but concerning the latter some problem arises : if one has 100 shares , which is the equivalent amount of richness , the actual market value or maybe the original buying price ? if the number of shares is small compared to the total volumes , then one can be almost surely able to sell them at the market price , but what happens if too many people want to do the same simultaneously ?",
    "this problem is similar to the taylor series , whose validity is limited to a small neighbourood of the central point .",
    "so , if we want to evaluate the richness of all the traders at a given time we have to cope with the following problem : which value should we give to each share ?    to illustrate it in more details , we can consider what happens if we evaluate the richness of a trader as given by the sum of the cash and the invested money , i.e. associating the original buying price to the shares .",
    "considering the invested money as real money we suppose ( without any reason ) that the trader is able to sell the shares exactly at the buying price . as a consequence of this assumption , the virtual richness increases and decreases together with the market price , with a small delay .",
    "we call therefore virtual this richness . but how can we conciliate the fact that the market is a closed one with such a variability of the richness ? the reason is the assumption about the value of the shares and we can easily prove that the virtual richness comes back to the starting value if and only if the market price comes back ( and remains constant a sufficiently long period of time ) to the ipo value in order to let all the people perform transactions at this market price . but evaluating the richness of a trader as the sum of cash plus number of shares time the ipo price we neglet all the dynamics of the market price . furthermore when we decide to stop the simulation we impose an artificial behavior to our simulated market without any equivalence with the real life .    to solve this evaluating problem we should provide a mechanism that allow all the traders to sell the shares to a special _ buy - back bank _ exactly at the ipo price .",
    "since the agents do not know when the end of the simulation will occur , they can not take into account this buy - back procedure and if the market price is above ( below ) the ipo value , they will loose ( gain ) money without any reason .",
    "we will address this problem in a future work , for the moment we just wanted to point out the difficulties arising when trying to evaluate the richness in a financial market context .",
    "we have simulated a stockmarket through the costruction of the book for buying and selling orders .",
    "our model is able to reproduce the two main characteristics of empirical data , namely correlated volatility and fat tails of the pdf of returns , with only one type of traders in competition with similar strategies , similar resources and similar whishes .",
    "they do not want to wait too much before they can have back the invested money plus a significant gain , they state clearly through the inserted orders which is the minimum gain they would like to get and up to which losses they can continue to play .",
    "furthermore they do not invest all the money they have at disposal , since they want to use it in the most appropriate and less risky way .",
    "these conditions have been implemented thanks to the strategy of price formation and the broadcasting of advertisements , mechanisms with which we provide both a local and a global coupling , responsible of the good agreement with empirical data .",
    "the key aspect here is the interplay between time and money , namely between the price formation and the insertion of the order .",
    ".... # define num_trader 1000   # define threshold 10000 # define num_max_neighbours 10 # define num_min_neighbours 1 # define gain_min 0.05 # define gain_max 0.15 # define loss_min 0.03 # define loss_max 0.10 # define investment_inclination_min 0.2   # define investment_inclination_max 0.5 # define num_stocks 5000   # define ipo_price 10000     # define minimal_resources 100000         # define total_zipf_resources 100000000     # define simulation_time 1000000    # define max_memory_length 50      # define book_unbalance 2 # define zipf1 0.2   # define zipf2 0.8 ....            struct type_trader {    unsigned long initial_resources ;      unsigned long total_resources ;     unsigned long invested_resources ;     double p_influence ;     unsigned int stocks ;     unsigned int neighbours[num_max_neighbours ] ;    unsigned int num_neighbours ;     unsigned int memory[max_memory_length ] ;    unsigned int memory_max ;     double personal_threshold ;    double investment_inclination ;    double liquidity_inclination ;     double expected_gain ;      double maximum_loss ;     unsigned int target_price ;    unsigned int stop_loss ;    char order_state ;         } trader[num_trader ] ; ....",
    "all the features of the traders are initialized randomly among the limits difined by the parameters .",
    "the resources are distributed according to the zipf s law .",
    "the meaning of the zipf s parameters is that the ` zipf1 ` of traders owns the ` zipf2 ` of the total resources . beside this , every trader is given ` minimal_resources ` so that his / her ` initial_resources ` is not zero .        ....",
    "ipo_trader = rand()*(numero_trader-1)/rand_max ; trader[ipo_trader].stocks = num_stocks ; saved_res = trader[ipo_trader].total_resources ; trader[ipo_trader].total_resources=0 ; trader[ipo_trader].invested_resources= num_stocks*ipo_price ; sell_order(0,ipo_trader , num_stocks , ipo_price ) ; ....                              .... operativity(unsigned int pos ) {    if ( trader[pos].order_state==0 )    { /*no pending orders*/      if ( trader[pos].stocks==0 )      { /*no shares owned*/        prob=(double)rand()/rand_max ;        if ( prob < trader[pos].investment_inclination )        {          price = price_formation(pos ) ;          trader[pos].target_price = price *           ( 1+trader[pos].expected_gain ) ;          trader[pos].stop_loss = price *           ( 1-trader[pos].maximum_loss ) ;          stocks=(trader[pos].liquidity_inclination *           trader[pos].total_resources)/price ;          buy_order(time , pos , stocks , price ) ;        }        }      else      { /*shares owned*/        if ( last_price < trader[pos].stop_loss )        { /*stop loss application*/          if ( news.rating==3 )          {            market_sell(pos ) ;          }          else if ( news.rating==1 )          {            if ( trader[pos].total_resources >              trader[pos].liquidity_inclination *               ( trader[pos].total_resources+                trader[pos].invested_resources ) )            {              average_buy(pos ) ;            }          }          else if ( news.rating==2 )          {            if ( trader[pos].total_resources >                trader[pos].liquidity_inclination *                ( trader[pos].total_resources+                 trader[pos].invested_resources ) )            {              average_buy(pos ) ;            }            else            {              market_sell(pos ) ;            }          }        }        else        { /*insert sell order*/          sell_order(time , pos ,           trader[pos].stocks ,           trader[pos].target_price ) ;        }      }    }    else    { /*pending order*/",
    "p1=search(sellers_book ) ;      if ( p1 )      { /*pending selling order*/        if ( last_price < trader[pos].stop_loss )        {          remove_sell_order(p1 ) ;        operativity(pos ) ;        }        else if ( time - p1->tick ) >        ( threshold / personal_threshold )         {          price = price_formation(pos ) ;          price*=(1+trader[pos].expected_gain ) ;          if ( price < trader[pos].target_price )          {            remove_sell_order(p1 ) ;            sell_order(time , pos ,            trader[pos].stocks , price ) ;          }        }      }      else      {        p1=search(buyers_book ) ;        if ( p1 )        { /*pending buying order*/          if ( time - p1->tick ) >          ( threshold / personal_threshold )          {            expense = p1->stocks*p1->price ;            price = p1->price ;            remove_buy_order(p1 ) ;            prob=(double)rand()/rand_max ;            if ( prob <             trader[pos].investment_inclination )            {              market_buy(pos , expense ) ;              trader[pos].target_price=               ( trader[pos].invested_resources/               trader[pos].stocks ) *               ( 1+trader[pos].expected_gain ) ;              trader[pos].stop_loss=               ( trader[pos].invested_resources/               trader[pos].stocks ) *               ( 1-trader[pos].maximum_loss ) ;             }             else             {                price=(1+trader[pos].expected _",
    "gain/2 ) ;                stocks = expense / price ;                buy_order(time , pos , stocks , price ) ;             }          }        }          else        {          printf(\"error !             no order in the books!\\n \" ) ;          exit(1 ) ;        }      }    } } ....    .... unsigned int price_formation ( unsigned int pos ) {    p_acq=0 ;    for ( ii=0;ii < trader[pos].num_neighbours;ii++ )    {      if ( trader[trader[pos].neighbours[ii ] ]         .target_price )      {          counter++ ;        p_acq+=trader[trader[pos].neighbours[ii ] ]          .target_price ;      }    }    p_acq/=counter ;    p_acq*=(1-trader[pos].expected_gain ) ;    counter=0 ;    p_tre=0 ;    for ( ii=0;ii < trader[pos].memory_max;ii++ )    {      if ( trader[pos].memory[ii ] )      {        p_tre+=trader[pos].memory[ii ] ;        counter++ ;      }    }    p_tre/=counter ;    p_bro = news.target_price *      ( 1-trader[pos].expected_gain ) ;       price = a1*p_acq+a2*p_tre+a3*p_bro ;    return(price ) ; } ....          the procedure ` spread_control ( ) ` has the purpose to check the book entries and compute the operations following a transaction , that is removing the entry in the book , updating the resources and the stocks owned by the trader , storing the last price and the volumes .",
    "evaluate_book ( ) ; if ( buyers / sellers ) > book_unbalance {    news.rating=1 ;    news.target_price=      last_price*(1+gain_max ) ; } else if ( sellers / buyers ) > book_unbalance {    news.rating=3 ;    news.target_price=      last_price*(1-gain_max ) ; } else {    news.rating=2 ; } ...."
  ],
  "abstract_text": [
    "<S> we propose a simulation of a trading activity based on the implementation of the book , the list where all the orders to buy and to sell a stock are recorded . </S>",
    "<S> traders who do not own shares want to buy and agents who own commodities want to sell them : the key factor here is of course the price . </S>",
    "<S> everyone wants to be able to reach a positive spread in order to make money . </S>",
    "<S> the main ingredients of our model are the price formation when entering an order and the broadcasting of advertisements coming from a global view of the book . </S>",
    "<S> the time series of the market price , defined everytime that a matching of two complementary orders occur , shows the well - known correlated volatility and fat tails of returns phenomena , as observed in empirical data .    </S>",
    "<S> evolutionary computation , econophysics , artificial financial market . </S>"
  ]
}