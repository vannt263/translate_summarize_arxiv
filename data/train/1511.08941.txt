{
  "article_text": [
    "mappings of mathematical entities onto points in n - dimensional space and their separation by planes has been of much interest to mathematicians [ 1 - 2 ] . to illustrate our concept ,",
    "let us first consider only two digit numbers : we will represent all two digit numbers as a point in 2d space following this scheme , the integers 37 will be represented as a point in two dimensional space : @xmath0 viz @xmath1 similarly the number @xmath2 will be represented as @xmath3 .",
    "notice we reverse the digits from left to right to right to left , we do this so that larger numbers will be represented as having coordinates of higher dimension . similarly the number 1729 will be represented as a point in 4-dimension space having coordinates @xmath4 .    in the figure below",
    "we have represented all the primes below 100 as points on a graph :        now all these primes can be separated by planes ( lines ) such that no two primes will lie on the same side of all planes see figure below :        we see that only 10 lines are sufficient to separate all the primes .",
    "we can use this information , the graph contains a lot of information , it indicates that every point representing a prime number is in a    unique position wrt to the 10 planes i.e. no two points are left unseparated by at least one plane .     and @xmath5 this information is stored as a `` orientation vector '' [ 3],[4 ] defined for each point ( the appendix contains the definitions of the terms used in this paper ) , the dimension of the orientation vector is equal to q , the number of planes present .",
    "so if there are two points p and q among all the planes that separate the ensemble of points then by definition @xmath6 implies that p and q are in the same region wrt all the planes .",
    "if @xmath7 this means p and q are separated by at least one plane .",
    "the orientation vector of all the points are stored , these are hamming vectors we will show that , using the ov s it is very easy to retrieve any prime number or determine if any given number is a prime number or not by comparing the ov s stored .",
    "suppose we wish to store all prime numbers which have n digits or below we convert ( map ) the number to a point in n dimensional space .",
    "suppose n=5 and we have numbers : @xmath8 and @xmath9 which are prime numbers , these are mapped to points which have coordinates@xmath10 equal to @xmath11 and @xmath12 resp .",
    "in a 5 dimensional space .",
    "we divide the task into to parts the storage task and the retrieval task as follows :    storage task :    \\1 .",
    "create a repository of prime numbers having less than ( say ) n digits , represented as points in n - dimension space .",
    "use an algorithm [ 4 ] , which finds the planes that separate all the points in the repository .",
    "( see appendix , for the definition of terms : `` orientation vector '' and `` position vector '' . )",
    "the algorithms finds the number of planes , q , and their coefficients which define each plane as well as the orientation vector of each point . we can also store the `` position vector '' ( see definition .",
    "the ov are obtained from the position vectors . )",
    "retrieval task    if you are given a n - digit number number r and you do not know whether it is composite or prime , you do the following :    \\1 .",
    "find the orientation vector of this point r , this task takes @xmath13 operations of multiplications and additions ,    \\2 .",
    "having obtained @xmath14 compare this with all the other ov s stored in the repository , this involves only bit comparisons . however",
    "if the ov s are sorted in `` dictionary '' order it does not take many bit comparisons . ) by performing these bit comparisions you will quickly find that prime number p , whose ov is the same as r i.e. @xmath6    \\3 .",
    "but yet you will not yet know if r is a prime or not , you only know that it is in the same `` quadrant '' location as point p. to ascertain that r is really a prime we need to find its position vector and check if @xmath15 . if so you will know that r is nothing but p and is a prime .",
    "( in fact , step 3 is not necessary , if you are storing the prime number p along with its orientation vector in the repository then all you need to check if r equals p.this is done if you use the orientation vector of everp prime as an identifier ( or i d ) and store the prime number in a repository , next to its orientation vector .",
    "so if the ov is known the prime number can be read .",
    "and you will soon discover by consulting the list of ov s , if r is the same as the stored p , if so , r is prime , if not r is composite .",
    "* additionally : * since the algorithm does not make use of any property of prime numbers or of integers in general , except for the fact that any n - digit integer can be represented as a point in n - dimension space . therefore the method can serve to be a storage and retrieval repository of any set of given integers even random integers .",
    "in practical cases these integers could represent data or information .",
    "thus we have an algorithm which serves as a very efficient storage and retrieval system , for digital data , which has the property that at any time new information can simply be added on without restarting , for future retrieval .",
    "\\1 . the method that we use to find the planes separating points in n- dimension space , does not require you to restart from the beginning when new points are added and require to be separated both from themselves and from the existing points .",
    "the algorithm permits you to continue from where you left off .",
    "if the dimension of space increases ( this will happen when we want to store primes involving more digits say @xmath16 ) , the algorithm permits you to do this after some initial adjustments you can again start from where you left off .",
    "we make an additional important point : the algorithm does not make use of any property of prime numbers or of integers in general , except for the fact that any n - digit integer can be represented as a point in n - dimension space .",
    "all the algorithm needs is that a set g containing @xmath17 points in n - dimension space be well defined , and each of their coordinates known before hand .",
    "the algorithm then proceeds to separate each of the points in g , by planes in n - dimensional space and find the equations of the @xmath18 planes that do so .",
    "therefore the set of points g , can represent any integers , ( not just primes ) , and even a given set of randomly chosen integers ,",
    "the only specification is that the set g be well defined .",
    "the method can be used to separate even real points ( whose coordinates may be non - rational ) .",
    "curiously , if the set g consists only of points whose coordinates are all rational , ( this will happen if they represent integers according to the scheme above ) , then matters can be so arranged that the @xmath18 planes which separate all the points , acting like boundaries , can never pass through any point p whose coordinates are all rational , ( see footnote 11 , just before appendix b ) . thus ensuring that points which represent integers will either be on one or the other side of such planes and",
    "will never lie on any one of the @xmath18 planes , no matter how many points ( representing integers ) you add on to g later on .",
    "the above scheme permits one to create an `` eternal repository '' of primes for all time , which can store and retrieve new primes as and when they are found and at the same time retaining the old .",
    "see the appendix for the proof and definitions .",
    "we have calculated the number of computations required to set up our prime number repository for all prime numbers having equal to or less than @xmath19digits is :    @xmath20 ( @xmath21 + @xmath22 mutiplications , and approx .",
    "an equal number of additions .    and to find if a particular number is a composite or prime , we need only to make bit comparisons with all the other @xmath17 hamming vectors stored in the data base which works out to be approx : @xmath23 bit comparisons . where @xmath24is the number of primes stored in the repository .",
    "a computer program based on the algorithm was written , it was tried out for separating random points in a cube of 15 dimensions .",
    "two thousand random points were generated in a unit cube of 15 dimensions , the algorithm separated each point by using 22 planes .",
    "details of these and some additional results involving 50,000 points in a 25 dimension cube , being separated by 27 planes can be seen in ref [ 5 ] .",
    "\\1 . william b. johnson and joram lindenstrauss :",
    "extensions of lipschitz mappings on to a hilbert space , contemporary mathematics , 26 , pp 189 - 206 ( 1984 )    \\2 .",
    "ralph p. boland and jorge urrutia : separating collection of points in euclidean spaces , information processing letters , vol 53 , no.4 , pp , 177 - 183 ( 1995 )    \\3 .",
    "k.eswaran:a system and method of classification etc .",
    "patents filed ipo no.(a ) 1256/che july 2006 and ( b ) 2669/che june 2015    \\4 .",
    "k.eswaran : a non - iterative method of separation of points by planes in n dimensions and its application , sent for publication :    http://www.arxiv.org/abs/1509.08472[www.arxiv.org/abs/1509.08472 ]    \\5 .",
    "k.eswaran : results of separation of points in high dimension space from a computer program based on a non - iterative algorithm .",
    "the author thanks the management of sreenidhi institute of science and technology for their sustained support .",
    "he proclaims his grateful thanks to his wife suhasini , and her ever willingness to be a sounding board on innumerable occasions and to listen to his monologues without which he does not think this work would have ever been done .",
    "in this appendix we give the necessary definitions and briefly prove the fundamental algorithm by which planes which separate a given set of points could be found .",
    "the more detailed proofs are available in k.eswaran ref .",
    "[ 4 ]    our task is to determine the equations of the planes that can separate the points in such a way that every point is separated from another by at least one plane .",
    "assumption : it is assumed that we have specified a ( defined ) normal direction , a point which lies on the positive side of the normal is said to lie on the positive side of the plane , on the other hand if the point lies on the other side it is said to lie on the negative side.this direction is easily found if the equation of the plane is known for example if @xmath25    is the equation to some @xmath26- dimensional plane then a point p whose coordinates are @xmath27 will be said to be on the positive side if @xmath28 and in the negative side if    @xmath29    each component of the orientation vector of a point p in x space orientation vector ( see definition below is defined by finding out if p is on the positive side or negative side of each plane .      *",
    "orientation vector * : suppose we have a point p in n - dimension space * ( also called x - space ) * and suppose we are given 3-planes .",
    "we define a orientation vector as a hamming vector whose components precisely specify on which side the point p lies with respect to the 3 planes .",
    "example : if the point p lies on the positive side of plane 1 , negative side of plane 2 and positive side of plane 3 , then we define the orientation vector associated with p as @xmath30 and define @xmath31 . similarly a point q which lies on the negative side of plane 1 , negative side of plane 2 and positive side of plane 3 will have an orientation vector @xmath32 .",
    "points , whose orientation vector differ from another by at least one one component can be said to be separated by at least one plane .",
    "* q space or hamming space : * we will also call the space spanned by the orientation vector as hamming space or q space .",
    "since each point p in x - space has an orientation ( hamming ) vector associated with it , we can imagine that all the points in x space are mapped to a point in hamming space . of course this",
    "mapping is many to one , but the point to notice is the following : let p be some point in x - space , then all points , r , in x space which are not separated from p by planes will all have the same orientation vector as p ie .",
    "@xmath33 and we describe this by saying : `` points p and r belong to the same ` quadrant ' '' this statement is certainly true for the `` images '' of p and r in q - space , but we will loosely use this terminology for the points in x - space and say p and r are in the same `` quadrant '' , what we really mean is that p and r are points in x - space and that they are not separated by planes ; sometimes we will use the term * neighbors * and say p and r are neighbors . the point to remember is that p and r will be neighbors if and only if @xmath33 . therefore if one wishes to find out if two points a and b are separated in x - space which contains planes , all one needs to do is to compare their orientation vectors : @xmath34 with @xmath35 .    * a saturated plane : * we consider a plane in @xmath26 dimension space to be `` saturated '' if it has already been constrained to pass through @xmath26 points and hence can not be adjusted to pass through a new point , the coefficients of such a plane are completely determinable .",
    "a plane in 3 dimension gets saturated if it is made to pass through three points .",
    "we will suppose we are given all the data containing @xmath24 points along with their coordinates in @xmath26 dimension space are available .",
    "step 1 : initially collect a small number of initial points numbering @xmath36 and choose a set of @xmath37 planes that separate each one of these @xmath36 points and put these planes in s. the coefficients defining the equations of these @xmath37 planes should be determined ( or randomly chosen but ensuring that they separate the @xmath36 ) , call @xmath38 and @xmath39 .",
    "store all orientation vectors of points in s in array v. in addition we need a set t which will contain points which can not become immediate members of s but are prospective members and will become members of s eventually . set",
    "t will contain points which are neighbours of a point which already is a member of s. to make things simple we will assume that at the start , all the @xmath37 planes are saturated .",
    "( we do not want to adjust any of these planes ) and @xmath36 s.t . @xmath40 and @xmath41",
    ". put counter = 0 .",
    "step 2 : if no more points in g go to step 7 , else : randomly choose a new point from g , which could be a candidate point to be put in s , from the remaining points not in s , go to step 3 .",
    "step 3 : check if this new point is in a new ` quadrant ' , this involves finding its orientation vector and comparing with those in s. if the point is in a new quadrant , put this point in s and store its orientation vector in v , put @xmath42 go to step 2 , if not , it means it has a neighbor in its quadrant .",
    "go to step 4 .",
    "step 4 : ( you will come here only if the current point has a neighbor in s. notation and procedure for this step : we keep count of the number of members of s which have neighbours .",
    "such points are called @xmath43 , its first neighbour will be called@xmath44 , if @xmath43 has a second neighbour this will be called @xmath45 and the third will be called @xmath46 )    put this new point in set t , @xmath47 define @xmath48 call the point with which this new point is a neighbour as @xmath43 . if the new point is the first neighbour call it @xmath44if @xmath44exists call it @xmath45and if @xmath45exists call it @xmath46 and if @xmath46 exists put back the new point in g and go to step 2 . calculate the mid point of the segment@xmath49 , if not already calculated , and call it @xmath50 , add the coordinates @xmath50 , in a `` list of midpoints '' .    if @xmath51 go to step 5 , if less than n , go to step 2 .",
    "step 5 : since @xmath51 , this means you have collected n points in t , each of which have to be separated from their neighbors . however we , first check if all the @xmath26 points collected in t are in different quadrants .",
    "there is a slight chance say @xmath44 and @xmath52 in t are in the same quadrant , if so , then mark one of them say @xmath52 as @xmath45 , if the latter does nt exist , else as @xmath46 ( if both @xmath45and @xmath46both exist there is no place for @xmath52put it back in g , restore the count of points in g as well as restore in either case@xmath53 , check similarly for other @xmath54 and then go to step 2 . ) , if there are @xmath18 planes there are @xmath55 quadrants , hence the chances of two points randomly chosen to be in the same quadrant is @xmath56 .",
    "we permit max .",
    "no of neighbors,3 , just to ensure that even in the freakiest conditions the algorithm comes to a halt successfully .",
    "of course the the other possibility is the presence of points of ` accumulation ' , however this does not happen when points represent integers . ]    now in this step we will separate the n pairs collected in t by introducing a new plane which passes through all the @xmath26 mid points , whose coordinates are available in `` list of midpoints '' in the array m : `` list of midpoints '' and determine the coefficients of the new plane , by solving the@xmath26 constraint eqs . to pass it through the @xmath26 midpoints ; call this plane as plane number @xmath57 and put @xmath58 , and include this new plane in s along with all the @xmath26 points labeled @xmath59 and their coordinates , put @xmath60 ,    step 6 : now check the neighbours of all the @xmath43 , @xmath61 if only @xmath45 exists then it gets promoted to first neighbour .",
    "but there is a slight complication after @xmath43 and @xmath62 separated @xmath45can be a neighbour either of @xmath43 or @xmath44 so if it is the former call @xmath63 as @xmath64 else call @xmath64 as @xmath65 and @xmath66 as @xmath64 the same kind of investigation needs to be done for @xmath67 because it can now belong to the old @xmath68 quadrant or belong to the new @xmath69 quadrant , in either case the @xmath70 gets promoted as second neighbour and it will be called @xmath45",
    ". calculate the new mid point @xmath50 for the just created segment @xmath49 and store .",
    "after finishing this task , the number , @xmath71 of second neighbours that were promoted as first neighbours will be known , after drawing the plane @xmath57 , then call @xmath72 .",
    "update v , the orientation vectors of points now stored in s wrt to this new plane ( their dimensions become @xmath57 ) ; clear the data in m : `` list of midpoints '' of all points t you have transfered to s and remove data , of these @xmath73 points that have been transfered to s , from set t ( most of the time @xmath74 ) and go to step 2 .",
    "step 7 : ( you will come here only if no more points are left in g @xmath75 and counter is not yet @xmath76 ) if counter = 0 , stop else introduce a new plane passing through the midpoints of segments collected so far , ( t will contain as many points as the value of counter ) , since counter @xmath77 , some of the coefficients of this plane can be randomly chosen ; ( take action like step 6 to check all these new points are in their own quadrants ) , update v , the orientation vectors of points now stored in s wrt to this new plane ( their dimensions become @xmath57 ) ; call this plane @xmath58 , counter = 0 , clear the data in m : `` list of midpoints '' then if now @xmath75 i.e. g is empty , stop ; else go back to step 2 .",
    "* at the end of section 6.2 , we mention that the case when @xmath78 and g is empty which is one of the possibilities in step 7 ; the situation can be dealt with in an easier manner .",
    "*    end of algorithm    the algorithm works swiftly most of the time , since in our case all the point are discrete and there are no limit points or ther is no `` accumulation points '' in g the algorithm will always come to a halt successfully .",
    "the general case when the input data is say prepared by another program , then certain conditions need to be met to ensure the correct halting of the algorithm .",
    "these are idscussed in the cted reference .",
    "the following crucial concepts will immediately clarify the steps of the whole algorithm : : in n dimension space , if we are given n line segements ;    @xmath79 ,    then a single plane passing through the mid points of each segment will separate the n points @xmath80 from the n points @xmath81 that is the @xmath82 and the @xmath54 will lie on opposite sides of the plane . *",
    "but this does not ensure that the @xmath82 are separate from each other and the @xmath54 are separate from each other . * in order to ensure this we have imposed the condition that each of the @xmath82 belong to set s and are * already separate from each other * and have all have different orientation vectors ( in the space of q planes which are in s ) , * similarly by imposing the condition that each @xmath83 , ( each of which belong to t ) , has only one neighbor in s * , ( for the moment ignore the second and third neighbours@xmath84 and @xmath85 ) we are making sure that each @xmath86 is separate from other @xmath54 though , each @xmath86 is not separate from its neighbor in s namely @xmath87 .",
    "thus each pair of points @xmath88 have the same orientation vector . now",
    "if the @xmath89)st plane is drawn then it will ensure that all the @xmath90 points i.e. the set of all the @xmath82 and the set of all the @xmath54 are not only separate but are separated from each other",
    ". we can then include plane @xmath57 and the @xmath26 points viz .",
    "the @xmath54 in s. this intuitive result is mathematically easily demonstrable : * *    * proof : * since we have included the @xmath89)st plane , all the orientation vectors have gained one more dimension and have @xmath57 dimensions , the last,@xmath91 st component of the orientation vector of point @xmath87 will differ from the last component of the orientation vector of its ex - neighbor @xmath92 because they are now on either sides of plane @xmath89 ) . thus proving that all the @xmath90 points are now separate**. qed * *    the rare cases of three points belonging to the same quadrant ( viz @xmath93 ) is permitted but not four , we do this only to avoid unecessary return of points to g , once randomly chosen from g. however , one can simplify the algorithm if one just returns the second point to g and then choose a new point at random .      at the start",
    "s only contains points which are separable from each other , because that is the way they have been selected . since @xmath39",
    "have been selected initially each of the orientation vectors of the points in s , are @xmath18 dimension vectors .",
    "they are all different .",
    "now till the time we come to step 5 we are just collecting points which are separable and putting them s or in case thay have a neighbor in s then we are putting the points in t. this can go on till there are n points in t and we arrive at step 5 .    at this point",
    "there are n points in t and n points in s. firstly , there can never be two points in s which are neighbors to a single point in t. this is because every point in s has a different orientation ( hamming ) vectors so they belong to different quadrants in hamming space and one point in t can not belong to two quadrants .",
    "there are now only two possibilities ( i ) each point in t has one distinct neighbor in s or ( ii ) there are two or three points in t which have the _ same _ neighbor in s. we will consider the first possibility ( i ) : since by choice , every point in t must have one neighbor in s , they all belong to different quadrants , since there are n points which can be separated by the @xmath57 st plane after implementing step 5",
    ". then in the new @xmath57 space all the points ( the old points in s and the n new points in t ) are all separable form one another and hence all the n points in t which awere first neighbours the @xmath44 s can now be included in s , we must add the @xmath57 st component to each orientation vector in s to make them into orientation vector wrt to the @xmath57 st plane .    now coming to the second possibility ,",
    "if there are two or three points in t which have the same neighbor in s then after introducing the new @xmath91 plane only one of the points in t namely the one which is the first neighbour of @xmath43say @xmath44can be transfered to s and the other points @xmath94 @xmath46need to be kept in t with one of the points @xmath43or @xmath44 as its neighbor and the newly calculated midpoint.(because the @xmath57 plane has separated the @xmath43and @xmath44 they are on opposite sides of plane @xmath57 , so we have to now determine on which sides @xmath94 @xmath46 are ; the seemingly complicated arguments are only to ensure that we make the right decision about @xmath94 @xmath46 ) .",
    "however , the situation ( ii ) is rare in high dimension n space , since we are choosing points in random , and can best be avoided by not choosing two points in t which are neighbors to the same point in s ( this means ejecting the second point from t and putting it back among @xmath24 in g , or by keeping it in t and use it , later , only after you have introduced a new plane or even after a few new planes . ) in brief , the situation ( ii ) can be avoided though it just causes difficulties in programming .",
    "so we see after step 5 and step 6 we will have an enhanced set s with more points and one more plane and all of which are separated by these @xmath57 planes .",
    "so we can call @xmath91 as @xmath18 and then re - do steps 2 to 6 till all points @xmath24 in g are exhausted",
    ". then s will contain all the points and all the planes which separate them .",
    "step 7 will happen in the end when all the points are exhausted but there are less than _ n _ points in t and these must be separated .",
    "* * the logic of step 7 is similar to step 6**. * *    * it may be mentioned here that step 7 can be completely avoided . *",
    "if we find that there are say less than n points in t. let us say r is a number such @xmath95 .",
    "all we have to do is choose r random points ( these should not have been in g ) each of which has as a neighbor in its quadrant , one of the points which was drawn from g but now in s. then put each of these r points along with its neighbor as a pair in t. since you have already @xmath96 number of pairs in t , with the addition of these r pairs , we have @xmath26 pairs . now since @xmath51 , we can choose the last plane separating all the @xmath26 pairs .",
    "so we see at the end of the algorithm s will contain all the points along with the equations of the @xmath18 planes that separate them , * * which are the needed outputs .",
    "* * qed * *    in the above algorithm it is assumed that every new plane does not ` split ' some other point ( pass through ) . however if this happens ( it is a very rare event ) , to some point , we will have to shift the ` mid points ' of the segments slightly to one side ( because to cut a segment into two parts it is not necessary that the plane passes exactly though its mid point ) so that the plane passes to one side of the offending point,[multiblock footnote omitted ] and then proceed with the algorithm .",
    "and you substitute the coord of point p in the above equations , obviously you will not get zeros on the rhs because we assume p is not on any of the planes and therefore they do not satisfy the equations .",
    "so if you substitute you will get .                              *",
    "the calculation of the hamming vector @xmath30 for a single point point p involves precisely @xmath113 multiplications , @xmath113 additions and q determinations of sign . * if there are @xmath24 points in the input sample g and finally after the running of the algorithm if we find that there are eventaually @xmath114 planes needed to separate all the @xmath24 points . then the necessary calculations for determining all the orienatation vectors of all the @xmath24 points.is precisly : * @xmath115 multiplications , @xmath115 additions and @xmath116 determinations of sign . *      * the calculations necessary to obtain the equations of all the @xmath114 planes is done in 2.6 * [ non - iter ] , * as well as the number of comparisions necessary to detemine if a new point ( which is randomly picked from g ) belongs to a new quadrant in s or to an old quadrant requires hamming vector comaprisions with all the ov s of points already in s. all this is done in 2.6 , opcit . *",
    "\\2 ) the equation to each plane ( say the jth plane ) will be determined at some stage in the algorithm only when it is requird in s for example to go through the n mid points of n pairs at some stage in the algorithm .",
    "this process needs a the solutionof @xmath26 linear equations to determine the @xmath117 coefficients of the @xmath118 plane . :",
    "this computation takes involves a gauss elimination process and involves @xmath120 multiplications.since there are eventaully @xmath114planesthe multiplications involved are @xmath121 and if by assumption @xmath122 , ( this is only true when for large dimension space ( @xmath123 ) ) we can get an estimate when n is large .",
    "the hamming vector is unique .",
    "if there are two points p and q in s then @xmath6 implies pand q are in the same quadrant if not they are in different quadrants .",
    "this property is used time and again in the algorithimic process to determine whether every new entrant qualifies to be in s or in t ( the set of temporary members ) .",
    "every time a new point enters s its hamming vector has to be computed and then compared with hamming vectors of all the existing points already in s , suppose there are at this stage n points in s and q planes .",
    "the hamming vector will be of dimension q thus there will be @xmath124 bit comparisions .",
    "of course all these comparisions are not necessary as stated in the paper ( we can quit the comparision early when we find a bit difference).eventually at one time or other , in the algoritmic process , the hamming vector of each point is compared with the hamming vector of all the other @xmath125 points leading to @xmath126 comparisions .",
    "note every time a new plane is introduced in s the dimension of the hamming vector of all the points in s increases by one , so it has to be updated .",
    "so the rhs of the equation of the new plane need to be capculated for each point in s. that is @xmath127 needs to be calculated for each n in s , thus there are @xmath128 multiplications to determine the @xmath57st bit for each of the n hamming vectors .      \\7 . after the algorithm runs its course all the coordinates of the points in sare unchanged and",
    "they are exactly the same as they had in g. s and g are mirror spaces . except that finally s contains @xmath114 planes in addition to the @xmath24 points .",
    "all the coefficients of the equations defining each of the @xmath114 planes are precisely calculated .",
    "but for our problem of primes which are having @xmath26 or less than @xmath26 digits , we need to estimate @xmath114 properly .",
    "now we need to estimate the number of planes required for separting an @xmath19digit integer by planes .",
    "we had already seen that all @xmath134digit integers can be separated by 20 planes ( these ar nothing but 10 parallel lines parallel to the x and y axis ) .",
    "so when we have @xmath19digit integers we can definitely separate it by using @xmath135 planes ( ie we would have 10 planes for each coordinate ) , this separates all the n - digit integers but the number of primes is far less than this .",
    "so we can consider @xmath135 as the upper bound for @xmath114 . and the estimate for the number of primes of n - digits is @xmath136 ( we use the formula from the prime number theorem which estimates the number of primes below @xmath137 as @xmath138 . )"
  ],
  "abstract_text": [
    "<S> we show that if you represent all primes with less than n - digits as points in n - dimensional space , then they can be stored and retrieved conveniently using n - dimensional geometry . </S>",
    "<S> also once you have calculated all the prime numbers less than n digits , it is very easy to find out if a given number having less than n - digits is or is not a prime . </S>",
    "<S> we do this by separating all the primes which are represented by points in n - dimension space by planes . </S>",
    "<S> it so turns out that the number of planes q , required to separate all the points represented by primes less than n - digit , are very few in number . </S>",
    "<S> thus we obtain a very efficient storage and retrieval system in n - dimensional space . </S>",
    "<S> in addition the storage and retrieval repository has the property that when new primes are added there is no need to start all over , we can begin where we last left off and add the new primes in the repository and add new planes that separate them as and when necessary . </S>",
    "<S> also we can arrange matters such that the repository can begin to accept larger primes which has more digits say n where n > n.    the algorithm does not make use of any property of prime numbers or of integers in general , except for the fact that any n - digit integer can be represented as a point in n - dimension space . therefore the method can serve to be a storage and retrieval repository of any set of given integers , in practical cases they can represent information . thus the algorithm can be used to devise a very efficient storage and retrieval system for large amounts of digital data . </S>"
  ]
}