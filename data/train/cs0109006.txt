{
  "article_text": [
    "logic programming has been conceived as a computational logic paradigm for problem solving and offers a number of advantages over conventional programming languages . in particular , it is a well - suited tool for declarative knowledge representation and common - sense reasoning @xcite , and possesses thus a high potential as a key technology to equip software agents with advanced reasoning capabilities in order to make those agents behave intelligently ( cf .",
    ", e.g. ,  @xcite ) .",
    "it has been realized , however , that further work is needed on extending the current methods and techniques to fully support the needs of agents . in a simple ( but , as for currently deployed agent systems , realistic ) setting , an agent s knowledge base , @xmath0 , may be modeled as a logic program , which the agent may evaluate to answer queries that arise . given various approaches to semantics ,",
    "the problem of evaluating a logic program is quite well - understood , and ( beside prolog ) provers for semantics with more sophisticated treatment of negation may be used .",
    "currently available provers include the systems ` deres `  @xcite , ` dlv`@xcite , ` smodels `  @xcite , and ` xsb `  @xcite .    an important aspect , however , is that an agent is situated in an environment which is subject to change .",
    "this requests the agent to adapt over time , and to adjust its decision making .",
    "an agent might be prompted to adjust its knowledge base @xmath0 after receiving new information in terms of an _ update _ @xmath1 , given by a clause or a set of clauses that need to be incorporated into @xmath0 . simply adding the rules of @xmath1 to @xmath0",
    "does not give a satisfactory solution in practice , even in simple cases .",
    "for example , if @xmath0 contains the rules @xmath2 and @xmath3 , and @xmath1 consists of the rule @xmath4 stating that @xmath5 is false , then the union @xmath6 is not consistent under predominant semantics such as the answer set semantics @xcite or the well - founded semantics @xcite .",
    "however , by attributing higher priority to the update @xmath7 , a result is intuitively expected which has a consistent semantics , where the emerging conflict between old and new information is resolved .    to address this problem , some approaches for updating logic programs with ( sets of ) rules have been proposed recently  @xcite . in this paper",
    ", we consider an approach which is based on a _ causal rejection principle_. according to this principle , a rule @xmath8 is only discarded providing there is a `` reason '' for doing so , in terms of another , more recent rule @xmath9 which contradicts @xmath8 .",
    "that is , if both @xmath8 and @xmath9 are applicable ( i.e. , their bodies are satisfied ) and have opposite heads , then only @xmath9 is applied while @xmath8 is discarded . in the example from above ,",
    "the rule @xmath10 in the current knowledge base @xmath0 ( whose body is true given rule @xmath3 ) is rejected by the new rule @xmath11 in the update ( whose body is also true ) , and thus in the updated knowledge base , @xmath8 is not applied .",
    "the causal rejection principle is not novel  in fact , it constitutes a major ingredient of the well - known dynamic logic programming approach @xcite .",
    "furthermore , it underlies , in slightly different forms , the related approaches of inheritance logic programs @xcite and ordered logic programs @xcite .",
    "we provide here a simple and rigorous realization of this principle , in terms of `` founded '' rejection : a rule @xmath8 may only be rejected by some other rule @xmath9 _ which itself is not rejected_. while this foundedness condition , as it appears , plays in effect no role in the particular semantics we consider , it can do so for more involved semantics based on causal rejection , such as the one by alferes _",
    "starting from a simple formalization of a semantics for updating logic programs based on causal rejection , which offers the advantage of a clear declarative characterization and of a syntactical realization at the same time , the main goal of this paper is to investigate properties of this semantics , as well as to analyze the relationship to other semantics for updating logic programs , in particular to dynamic logic programming . notice that , although uses and extensions of dynamic logic programming have been discussed ( cf .",
    "@xcite ) , its properties and relations to other approaches and related formalisms have been less explored so far ( but see  @xcite ) .      inspired by ideas in  @xcite",
    ", we consider a semantics for sequences @xmath12 of extended logic programs , in terms of a syntactic transformation to an _ update program _ , which is a single extended logic program in an extended language .",
    "the semantics properly generalizes the answer set semantics  @xcite of single logic programs . the readable syntactic representation of the semantical results  which is useful from a computational perspective  is complemented , as in  @xcite , by an elegant semantical characterizations in terms of a modified gelfond - lifschitz reduction , resulting from the usual construction by removal of rejected rules .",
    "the transformation we describe is similar to the one by alferes _",
    "et al . _ , but involves only a few types of rules and new atoms . for capturing the rejection principle , information about rule rejection",
    "is explicitly represented at the object level through rejection atoms ; this is similar to an implementation of the related inheritance logic program approach proposed by buccafurri _",
    "et al . _  .",
    "though not new in spirit , the approach we suggest offers a more accessible definition and is suitable for studying general properties of updates by causal rejection , providing insight in the mechanism of the rejection principle itself .",
    "the main contributions of this paper can be summarized as follows .",
    "\\(1 ) we extensively investigate , from different points of view , properties of update programs and answer set semantics for update sequences .",
    "we first analyze them from a belief revision perspective , and evaluate various ( sets of ) postulates for revision and iterated revision from the literature @xcite .",
    "to this end , we discuss possible interpretations of update programs as change operators for nonmonotonic logical theories . as it turns out",
    ", update programs ( and thus equivalent approaches ) do not satisfy many of the properties defined in the literature .",
    "this is partly explained by the nonmonotonicity of logic programs and the causal rejection principle embodied in the semantics , which strongly depends on the syntax of rules .",
    "furthermore , we consider properties from a nonmonotonic reasoning perspective , by naturally interpreting update programs as nonmonotonic consequence relations , and review postulates and principles which have been analyzed by kraus , lehmann , and magidor  , and makinson  .    finally , we present and discuss some further general properties relevant for update programs . among them",
    "is an _ iterativity property _ , which informally states equivalence of nesting @xmath13 and sequences @xmath14 of updates .",
    "a possible interpretation of this property is that an _ immediate update strategy _ , which incorporates new information immediately into the knowledge base , is equivalent to _ demand - driven evaluation _",
    ", where the actual knowledge base @xmath0 is built on demand of particular queries , and full information about @xmath0 s update history is known . as we shall see , the property does not hold in general , but for certain classes of programs .",
    "\\(2 ) as it appears , update answer sets  like related concepts based on causal rejection  do not respect minimality of change .",
    "we thus refine the semantics of update sequences and introduce _ minimal answer sets _ and _ strictly minimal answer sets_. informally , in minimal answer sets , the set of rules that need to be rejected is minimized .",
    "this means that a largest set of rules should be respected if an answer set is built ; in particular , if all rules can be satisfied , then no answer sets would be adopted , which request the rejection of any rule .",
    "the notion of strict minimality further refines minimality by enforcing that rejection of older rules should be preferred to rejection of newer rules , thus performing hierarchic minimization .",
    "the refined semantics come at the cost of higher computational complexity , and increase the complexity of update answer sets for propositional programs by one level , namely from the first to the second level in the polynomial hierarchy .",
    "this parallels similar results for the update semantics by sakama and inoue  , which employs a notion of minimality in the basic definition .",
    "\\(3 ) we conduct a comparison between update programs and alternative approaches for updating logic programs @xcite and related approaches @xcite .",
    "we find that for some of these formalisms , syntactic subclasses are semantically equivalent to update programs .",
    "thus , update programs provide a ( different ) characterization of these fragments , and by their simplicity , contribute to better understanding on the essential working of these formalisms on these fragments .",
    "furthermore , our results on properties of update answer set semantics carry over to the equivalent fragments , and establish also semantical results for these formalisms , which have not been analyzed much in this respect so far .",
    "finally , equivalent fragments of different formalisms are identified via update programs .",
    "first , we show that update programs are , on the language we consider , equivalent to inheritance logic programs .",
    "more precisely , our notion of an answer set for an update sequence @xmath12 coincides with the notion of an answer set for a corresponding inheritance program @xmath15 in the approach by buccafurri _",
    "_  , where @xmath15 results from @xmath16 by interpreting more recent updates in the sequence @xmath17 ( i.e. ,  programs with higher index ) as programs containing more specific information .",
    "thus , update programs ( and classes of dynamic logic programs ) may semantically be regarded as fragment of the inheritance framework of buccafurri _ et al .",
    "we then compare our update programs to revision programming by marek and truszczyski   and the related approach of leite and pereira  , which has been extended to sequences of programs in @xcite .",
    "it appears that the fragment of this formalism where programs merely use weak negation is , apart from extra conditions on sequences of more than two programs , semantically equivalent to update programs .",
    "furthermore , we give a thorough analysis of the dynamic logic programming approach by alferes _",
    "their notion of model of an update sequence @xmath16 , which we refer to as _ dynamic answer set _ , semantically imposes extra conditions compared to our update answer set .",
    "we give a precise characterization of the case in which the definitions are equivalent , using graph - theoretic concepts . from this characterization",
    ", we get syntactic conditions for classes of programs on which dynamic answer sets and update answer sets coincide .",
    "notice that the examples discussed in @xcite satisfy these conditions .",
    "furthermore , by this correspondence , some results for update principles and computational complexity derived for our update programs carry over to dynamic logic programs as well",
    ". further inspection , which we do not carry out here , suggests the same results beyond the corresponding fragments .    to the best of our knowledge , no investigation of approaches to updating logic programs from the perspectives of belief revision and",
    "nonmonotonic consequences relations has been carried out so far . in view of our results about the relationship between update programs and other approaches , in particular to inheritance logic programs and fragments of dynamic logic programming ,",
    "our investigations apply to these formalisms as well .",
    "the paper is organized as follows . after providing some necessary preliminaries in the next section ,",
    "we introduce in section  [ sec : update - progs ] update programs and answer sets for such programs , and establish some characterization results . in section  [ sec : properties ] , we embark on our study of general principles of update programs based on causal rejection from various perspectives . the refinements of answer sets to minimal and strictly minimal answer sets are considered in section  [ sec : refinements ] .",
    "section  [ sec : computation ] is devoted to computational issues of our approach .",
    "after an investigation of the computational complexity of update programs under the semantics introduced , we discuss an implementation of our approach based on the ` dlv `  logic programming tool  @xcite . in section  [",
    "sec : rel - work ] , relations to other and related approaches are investigated .",
    "the paper concludes with section  [ sec : conclusion ] , containing a short summary and a discussion of further work and open issues . some proofs and further results , which are omitted here for space reasons , can be found in @xcite .",
    "we deal with extended logic programs  @xcite , which consist of rules built over a set @xmath18 of propositional atoms where both default negation @xmath19 and strong negation @xmath20 is available .",
    "a _ literal _",
    ", @xmath21 , is either an atom @xmath22 ( a _ positive literal _ ) or a strongly negated atom @xmath23 ( a _ negative literal _ ) . for a literal @xmath21 , the _ complementary literal _ , @xmath24 , is @xmath25 if @xmath26 , and @xmath22 if @xmath27 , for some atom @xmath22 . for a set @xmath28 of literals , we define @xmath29 , and denote by @xmath30 the set @xmath31 of all literals over @xmath18 .",
    "a literal preceded @xmath19 is called a _",
    "weakly negated literal_.    a _ rule _ , @xmath8 , is an ordered pair @xmath32 where @xmath33 is a literal and @xmath34 is a finite set of literals or weakly negated literals .",
    "we also allow the case where @xmath33 may be absent .",
    "we call @xmath33 the _ head _ of @xmath8 , denoted @xmath35 , and @xmath34 the _ body _ of @xmath8 . for @xmath36",
    ", we define @xmath37 and @xmath38 .",
    "the elements of @xmath39 are referred to as the _ prerequisites _ of @xmath8 .",
    "we employ the usual conventions for writing rules like @xmath40 or @xmath41 as @xmath42 and @xmath43 , respectively . generally , rule @xmath8 with @xmath34 as above",
    "will simply be written as @xmath44 if @xmath8 has an empty head , then @xmath8 is a _ constraint _ ; if the body of @xmath8 is empty , then @xmath8 is a _ fact _ ;",
    "if @xmath45 ( i.e. ,  if @xmath8 contains no default negation ) , then @xmath8 is a _",
    "basic rule_. we denote by @xmath46 the set of all rules constructible using the literals in @xmath30 .    an _ extended logic program _",
    "( elp ) , @xmath47 , is a ( possibly infinite ) set of rules .",
    "if all rules in @xmath47 are basic , then @xmath47 is a _",
    "basic program_. usually , @xmath18 will simply be understood as the set of _ all _ atoms occurring in @xmath47 .",
    "an _ interpretation _",
    "@xmath48 is a set of literals which is _ consistent _ , i.e. ,  @xmath48 does not contain complementary literals @xmath22 and @xmath25 . a literal @xmath21 is _ true _ in @xmath48 ( symbolically @xmath49 ) iff @xmath50 , and _",
    "false _ otherwise",
    ". given a rule @xmath8 , the body @xmath34 of @xmath8 is true in @xmath48 , denote @xmath51 , iff ( i ) each @xmath52 is true in @xmath48 and ( ii ) each @xmath53 is false in @xmath48 .",
    "rule @xmath8 is true in @xmath48 , denoted @xmath54 , iff @xmath35 is true in @xmath48 whenever @xmath34 is true in @xmath48 . in particular ,",
    "a constraint @xmath8 is true in @xmath48 iff @xmath55 . for a program @xmath47",
    ", @xmath48 is a _ model _ of @xmath47 , denoted @xmath56 , if @xmath54 for all @xmath57 .",
    "let @xmath8 be a rule .",
    "then @xmath58 denotes the basic rule obtained from @xmath8 by deleting all weakly negated literals in the body of @xmath8 , i.e. ,  @xmath59 .",
    "furthermore , we say that rule @xmath8 is _ defeated _ by a set of literals @xmath28 if some literal in @xmath60 is true in @xmath28 , i.e. ,  if @xmath61 .",
    "as well , each literal in @xmath62 is said to _ defeat _ @xmath8 .",
    "the _ reduct _ , @xmath63 , of a program @xmath47 _ relative to _ a set @xmath28 of literals is defined by @xmath64 an interpretation @xmath48 is an _ answer set _ of a program @xmath47 iff it is a minimal model of @xmath65 . by @xmath66",
    "we denote the collection of all answer sets of @xmath47 . if @xmath67 , then @xmath47 is said to be _",
    "we regard a logic program @xmath47 as the _ epistemic state _ of an agent .",
    "the given semantics is used for assigning a _ belief set _ to any epistemic state @xmath47 as follows .",
    "let @xmath68 be an interpretation .",
    "define @xmath69 furthermore , for a class @xmath70 of interpretations , let @xmath71 .",
    "[ defn : belief - set ] for a logic program @xmath47 , the belief set , @xmath72 , of @xmath47 is given by @xmath73 .",
    "we write @xmath74 if @xmath75 , and for any program @xmath76 , we write @xmath77 if @xmath78 for all @xmath79",
    ". programs @xmath80 and @xmath81 are _ equivalent _ ( modulo @xmath18 ) , symbolically @xmath82 , iff @xmath83",
    ". it can be seen that if either @xmath80 or @xmath81 involves only finitely many atoms , or if @xmath18 is finite , then @xmath84 is equivalent to the condition that @xmath80 and @xmath81 have the same answer sets modulo @xmath18 .",
    "we will drop the subscript `` @xmath85 '' in @xmath86 , @xmath87 , and @xmath88 if no ambiguity can arise .",
    "belief sets enjoy the following natural properties :    for every logic program @xmath47 , we have that :    1 .",
    "@xmath89 ; 2 .",
    "@xmath90 ; 3 .",
    "@xmath91 .",
    "properties ( i ) and ( iii ) hold trivially .",
    "property ( ii ) can be seen as follows : @xmath92 follows directly from property ( i ) , and @xmath93 holds due to the fact that each answer set of @xmath47 is also an answer set of @xmath94 .",
    "clearly , the belief operator @xmath95 is nonmonotonic , i.e. , in general , @xmath96 does not imply @xmath97 .",
    "we introduce a framework to update logic programs based on a compilation technique to elps .",
    "the basic idea is the following . given a sequence @xmath17 of elps , each @xmath98",
    "is assumed to update the information expressed by the initial section @xmath99 .",
    "the sequence @xmath17 is translated into a single elp @xmath100 , respecting the successive update information , such that the answer sets of @xmath100 represent the answer sets of @xmath17 .",
    "the translation is realized by introducing new atoms @xmath101 which control the applicability of rules with respect to the update information .",
    "informally , @xmath102 states that rule @xmath8 is `` rejected '' , in case a more recent rule @xmath9 asserts a conflicting information .",
    "this conflict is resolved by enabling @xmath102 to block the applicability of @xmath8 , and so rule @xmath9 is given precedence over @xmath8 .",
    "in some sense , the proposed update mechanism can be seen as some form of an _ inheritance strategy _ , where more recent rules are viewed as `` more specific '' information , which have to be given preference in case of a conflict . in section  [ sec : inheritance ] , we will discuss the relationship between our update formalism and the inheritance framework introduced by buccafurri _",
    "the general method of expressing update sequences in terms of single programs has already been discussed by alferes _",
    "however , in that framework , applicability issues are realized in terms of newly introduced atoms referring to the derivability of _ atoms _ of the original programs , and not to the applicability of _ rules _ as in the present approach . a detailed comparison between our approach and the method of alferes _",
    "et al . _",
    "is given in section  [ sec : relations - dynlp ] .      by an _ update sequence _",
    ", @xmath16 , we understand a series @xmath103 of elps .",
    "we say that @xmath16 is an update sequence _ over @xmath18 _",
    "iff @xmath18 represents the set of atoms occurring in the rules of the constituting elements @xmath98 of @xmath16 @xmath104 .",
    "given an update sequence @xmath12 over @xmath18 , we assume a set @xmath105 extending @xmath18 by new , pairwise distinct atoms @xmath102 and @xmath106 , for each @xmath8 occurring in @xmath16 , each atom @xmath107 , and each @xmath108 , @xmath109 .",
    "we further assume an injective _ naming function _",
    "@xmath110 , which assigns to each rule @xmath8 in a program @xmath98 a distinguished name , @xmath111 , obeying the condition @xmath112 whenever @xmath113 . with a slight abuse of notation we shall identify @xmath8 with @xmath111 as usual . finally , for a literal @xmath21",
    ", we write @xmath114 to denote the result of replacing the atomic formula @xmath22 of @xmath21 by @xmath106 .",
    "[ def : update - program ] given an update sequence @xmath115 over a set of atoms @xmath18 , we define the update program @xmath116 over @xmath105 consisting of the following items :    1 .",
    "all constraints in @xmath98 , @xmath117 ; 2 .   for each @xmath118 ,",
    "@xmath117 : @xmath119 3 .",
    "for each @xmath118 , @xmath120 : @xmath121 4 .   for each literal @xmath21",
    "occurring in @xmath16 @xmath122 : @xmath123    informally , this program expresses layered derivability of a literal @xmath21 , beginning at the top layer @xmath124 downwards to the bottom layer @xmath80 .",
    "the rule @xmath8 at layer @xmath98 is only applicable if it is not refuted by a literal derived at a higher level that is incompatible with @xmath125 .",
    "inertia rules propagate a locally derived value for @xmath21 downwards to the first level , where the local value is made global .",
    "the transformation @xmath126 is modular in the sense that for @xmath127 it augments @xmath128 only with rules depending on @xmath129 .",
    "we remark that @xmath126 can obviously be slightly simplified , which is relevant for implementing our approach .",
    "all weakly negated literals @xmath130 in rules with heads @xmath131 can be removed : indeed , since @xmath102 can not be derived , each such atom evaluates to false in any answer set of @xmath126 .",
    "thus , no rule from @xmath124 is rejected in an answer set of @xmath126 , i.e. , all most recent rules are obeyed .",
    "the intended answer sets of an update sequence @xmath12 are defined in terms of the answer sets of @xmath126 .",
    "[ defn : upd - stable - model ] let @xmath115 be an update sequence over a set of atoms @xmath18 . then , @xmath132 is an _",
    "update answer set _ of @xmath16 iff @xmath133 for some answer set @xmath134 of @xmath135 .",
    "the collection of all update answer sets of @xmath16 is denoted by @xmath136 .    following the case of single programs ,",
    "an update sequence @xmath137 is regarded as the epistemic state of an agent , and the belief set @xmath138 is given by @xmath139 .",
    "the update sequence @xmath16 is said to be satisfiable iff @xmath140 , and @xmath141 iff @xmath142 ( @xmath143 some update sequence ) .",
    "general properties of the belief operator @xmath95 in the context of update sequences will be discussed in section  [ sec : properties ] .    for illustration of definition  [ defn : upd - stable - model ] ,",
    "consider the following example , adapted from @xcite .",
    "[ example : tv ] consider the update of @xmath80 by @xmath81 , where @xmath144 p_2 & = & \\big\\ { & \\ r_5 : \\",
    "\\neg \\emph{tv\\_on } { \\leftarrow}\\emph{power\\_failure } , \\quad r_6 : \\ \\emph{power\\_failure } { \\leftarrow}\\ \\big\\}. \\end{array}\\ ] ] the single answer set of @xmath145 is , as desired , @xmath146 since the only answer set of @xmath135 is given by @xmath147    if new information arrives in form of the program @xmath148 : @xmath149 then the update sequence @xmath14 has the answer set @xmath150 generated by the following answer set @xmath151 of @xmath152 : @xmath153      next , we discuss some properties of our approach .",
    "the first result guarantees that answer sets of @xmath16 are uniquely determined by the answer sets of @xmath126 .",
    "[ prop:1 - 1-corr ] let @xmath154 be an update sequence over a set of atoms @xmath18 , and let @xmath155 be answer sets of @xmath126 .",
    "then , @xmath156 only if @xmath157 .",
    "see appendix  [ app : proof - prop:1 - 1-corr ] .    in view of this result ,",
    "the following notation is well - defined .",
    "let @xmath16 be an update sequence over @xmath18 , and let @xmath28 be an answer set of @xmath16 .",
    "then , @xmath158 denotes the ( uniquely determined ) answer set of @xmath126 obeying @xmath159 .",
    "if an update sequence @xmath16 consists of a single program @xmath80 , the update answer sets of @xmath16 coincide with the regular answer sets of @xmath80 .",
    "let @xmath16 be an update sequence consisting of a single program @xmath80 , i.e. ,  @xmath160 .",
    "then , @xmath161 .",
    "this follows at once from the observation that the only difference between @xmath80 and @xmath126 is that each rule @xmath162 occurring in @xmath80 is replaced by the two rules @xmath163 and @xmath164 .",
    "since there are no rules in @xmath126 having head literal @xmath102 , it holds that , for each set @xmath28 of literals , @xmath8 is defeated by @xmath28 exactly if @xmath163 is defeated by @xmath28 .",
    "answer sets of update sequences can also be characterized in a purely declarative way . to this end , we introduce the concept of a _",
    "rejection set_. let us call two rules @xmath165 and @xmath166 _ conflicting _ iff @xmath167 . for an update sequence @xmath168 over a set of atoms",
    "@xmath18 and @xmath169 , based on the principle of founded rule rejection , we define the rejection set of @xmath28 by @xmath170 , where @xmath171 , and , for @xmath172 , @xmath173 that is , @xmath174 contains those rules from @xmath16 which are rejected on the basis of rules which are not rejected themselves .",
    "the next lemma ensures that the rejection set @xmath174 precisely matches the intended meaning of the control atoms @xmath101 .",
    "[ lemma : rejection - atoms ] let @xmath175 be an update sequence over a set of atoms @xmath18 , let @xmath28 be an answer set of @xmath16 , and let @xmath158 be the corresponding answer set of @xmath126 .",
    "then , @xmath176 iff @xmath177 .",
    "we show by induction on @xmath178 ( @xmath179 ) that @xmath180 iff @xmath177 , whenever @xmath181 .    induction base .",
    "assume @xmath182 .",
    "then the statement holds trivially because @xmath171 and @xmath183 for all @xmath184 .",
    "induction step .",
    "assume @xmath185 , and let the statement hold for all @xmath186 .",
    "we show the assertion for @xmath187 .",
    "consider some @xmath181 and suppose @xmath180 .",
    "we show @xmath177 . according to the definition of @xmath188",
    ", there is some @xmath189 , @xmath190 , such that @xmath191 , @xmath192 , and both @xmath8 and @xmath9 are not defeated by @xmath28 .",
    "the rule @xmath181 induces the rule @xmath193 , where @xmath194 . from the properties above",
    ", we have @xmath195 .",
    "now , since @xmath196 , in order to show @xmath177 it suffices to show that @xmath197 .",
    "this can be seen as follows .",
    "first of all , the rule @xmath198 induces the rule @xmath199 , where @xmath200 . since @xmath191",
    ", we actually have @xmath201 .",
    "now , given that @xmath202 , and since @xmath186 , by induction hypothesis we have @xmath203 .",
    "furthermore , @xmath204 implies @xmath205 . given that @xmath206 , we obtain @xmath207 . by observing that @xmath208 ( since @xmath186 ) , and given the inertia rules @xmath209 ( @xmath210 ) , we eventually obtain @xmath211 .",
    "this proves @xmath177 .",
    "conversely , assume @xmath177 .",
    "we show @xmath180 . by construction of the update program @xmath126 , the atom @xmath102",
    "can only be derived by means of the rule @xmath212 .",
    "so , it must hold that @xmath213 , @xmath214 , and @xmath215 .",
    "moreover , since @xmath214 , there must be some @xmath198 , @xmath186 , such that @xmath216 , @xmath217 , @xmath204 , and @xmath218 . by induction hypothesis",
    ", the latter fact implies @xmath219 .",
    "so , we have that there is some @xmath220 , @xmath186 , such that @xmath221 , @xmath192 , and both @xmath8 and @xmath9 are not defeated by @xmath28 .",
    "this means that @xmath222 .",
    "it turns out that update answer sets can be characterized in terms of a modified gelfond - lifschitz reduction , by taking the elements of the respective rejection sets into account . in what follows , for a given update sequence @xmath175 , we write @xmath223 to denote the set of all rules occurring in @xmath16 , i.e. ,  @xmath224 .",
    "[ theo : sequence - char-0 ] let @xmath225 be an update sequence over a set of atoms @xmath18 and @xmath226 a set of literals . then , @xmath28 is an answer set of @xmath16 iff @xmath28 is the minimal model of @xmath227 .",
    "see appendix  [ app : proof - theo : sequence - char-0 ] .",
    "update answer sets can also be described using a weaker notion of rejection sets . for @xmath175 over @xmath18 and @xmath228 ,",
    "let us define @xmath229 obviously , @xmath230 always holds .",
    "moreover , we get the following variant of theorem  [ theo : sequence - char-0 ] :    [ theo : sequence - char-0-alt ] let @xmath225 be an update sequence over a set of atoms @xmath18 and @xmath226 a set of literals . then , @xmath28 is an answer set of @xmath16 iff @xmath28 is a minimal model of @xmath231 .",
    "_ only - if part .",
    "_ suppose @xmath28 is an answer set of @xmath232 .",
    "since @xmath230 , it holds that @xmath233 .",
    "observe that for each @xmath234 there is some @xmath235 such that @xmath236 and @xmath237 .",
    "we use the following property : let @xmath134 be an answer set of some program @xmath47 , and let @xmath238 such that @xmath236 and @xmath237 .",
    "then , @xmath134 is an answer set of @xmath239 . by repeated applications of this property we get",
    "that @xmath28 is an answer set of @xmath240 .    _ if part .",
    "_ suppose that @xmath28 is a minimal model of @xmath231 , but there is some @xmath241 such that @xmath242 and @xmath243 .",
    "it follows that @xmath244 .",
    "define @xmath245 and let @xmath246 , where @xmath247 .",
    "then , @xmath248 .",
    "since @xmath243 , it follows that @xmath191 .",
    "furthermore , @xmath248 implies @xmath249 .",
    "therefore , it follows that @xmath250 , a contradiction .",
    "we obtain that @xmath28 is a model of @xmath227 . moreover , since @xmath251 , @xmath28 must be a minimal model of @xmath227 .",
    "we make use of this alternative version of @xmath252 in sections  [ sec : relations - revprog ] and [ sec : relations - dynlp ] .",
    "it is important to emphasize that in our approach , the update program @xmath253 is not the _ result _ of the update intended to be the new knowledge state of the agent , but it _ represents the semantic result _ of the information that a sequence of updates @xmath254 has occurred to a knowledge base @xmath80 . compiling the result of updates into a single logic program in the original language ( having the desired answer sets ) would mean losing history information about the update sequence . instead , the formalism results in a program over an extended set of atoms , which expresses at the object level meta - concepts determining applicability of rules and computation of those intended answer sets . in some sense , the result is therefore a declarative specification of how rules of the original logic program and of subsequent updates should be applied , expressed in the language of logic programs themselves",
    "in this section , we discuss several kinds of postulates which have been advocated in the literature on belief change and examine to what extent update sequences satisfy these principles .",
    "this issue has not been addressed extensively in previous work .",
    "we first consider update programs from the perspective of _ belief revision _ and assess the relevant postulates from this area .",
    "afterwards , we briefly analyze further properties , like viewing update programs as _ nonmonotonic consequence operators _ and other general principles .",
    "we remark that our analysis applies , in slightly adapted form , to dynamic logic programming as well ( cf .  section  [ sec : relations - dynlp ] ) .",
    "following grdenfors and rott  , two different approaches to belief revision can be distinguished : ( i ) _ immediate revision _",
    ", where the new information is simply added to the current stock of beliefs and the belief change is accomplished by the semantics of the underlying ( often , nonmonotonic ) logic ; and ( ii ) _ logic - constrained revision _ , where the new stock of beliefs is determined by a nontrivial operation which adds and retracts beliefs , respecting logical inference and some constraints .",
    "in the latter approach , it is assumed that beliefs are sentences from a given logical language @xmath255 , closed under the standard boolean connectives .",
    "belief set _ ,",
    "@xmath256 , is a subset of @xmath255 which is closed under a consequence operator @xmath257 of the underlying logic .",
    "belief base _ for @xmath256 is a subset @xmath258 such that @xmath259 .",
    "a belief base is a special case of _ epistemic state",
    "_ @xcite , which is a set of sentences @xmath260 representing an associated belief set @xmath256 in terms of a mapping @xmath95 such that @xmath261 , where @xmath260 need not necessarily have the same language as @xmath256 .    in",
    "what follows , we first introduce different classes of postulates , and then we examine them with respect to update sequences .",
    "one of the main aims of logic - constrained revision is to characterize suitable revision operators through postulates . in the agm approach ( after alchourrn , grdenfors , and makinson ) , three basic operations on a belief set @xmath256 are considered :    * _ expansion _",
    "@xmath262 , which is simply adding the new information @xmath263 to @xmath256 ; * _ revision _ @xmath264 , which is sensibly revising @xmath256 in the light of @xmath265 ( in particular , when @xmath256 contradicts @xmath265 ) ; and * _ contraction _",
    "@xmath266 , which is removing @xmath265 from @xmath256 .",
    "agm proposes a set of postulates , k@xmath2671k@xmath2678 , that any revision operator @xmath267 mapping a belief set @xmath268 and a sentence @xmath269 into the revised belief set @xmath264 should satisfy .",
    "if , following both darwiche and pearl   and brewka  , we assume that @xmath256 is represented by an epistemic state @xmath260 , then the postulates k@xmath2671k@xmath2678 can be reformulated as follows :    ( k1 ) : :    @xmath270 represents a belief set . ( k2 ) : :    @xmath271 .",
    "( k3 ) : :    @xmath272 .",
    "( k4 ) : :    @xmath273 implies    @xmath274 .",
    "( k5 ) : :    @xmath275 only if    @xmath265 is unsatisfiable .",
    "( k6 ) : :    @xmath276 implies    @xmath277 .",
    "( k7 ) : :    @xmath278 .",
    "( k8 ) : :    @xmath279 implies    @xmath280 .    here , @xmath281 and @xmath282 is the revision and expansion operation , respectively , applied to @xmath260 .",
    "informally , these postulates express that the new information should be reflected after the revision , and that the belief set should change as little as possible . as has been pointed out , this set of postulates is appropriate for new information about an _ unchanged world _ , but not for incorporation of a change to the actual world .",
    "such a mechanism is addressed by the next set of postulates , expressing _ update _ operations .      for update operators",
    "@xmath283 realizing a change @xmath265 to a belief base @xmath284 , katsuno and mendelzon   proposed a set of postulates , u@xmath2851u@xmath2858 , where both @xmath265 and @xmath284 are propositional sentences over a finitary language .",
    "for epistemic states @xmath260 , these postulates can be reformulated as follows .",
    "( u1 ) : :    @xmath286 .",
    "( u2 ) : :    @xmath287 implies    @xmath288 . ( u3 ) : :    if @xmath289 is consistent and    @xmath265 is satisfiable , then    @xmath290 is consistent . ( u4 ) : :    if @xmath291 and    @xmath292 , then    @xmath293 . (",
    "u5 ) : :    @xmath294 .",
    "( u6 ) : :    if @xmath295 and    @xmath296 , then    @xmath297 .",
    "( u7 ) : :    if @xmath289 is complete , then    @xmath298 . ,",
    "either    @xmath299 or @xmath300 . ]",
    "( u8 ) : :    @xmath301 .    here",
    ", conjunction and disjunction of epistemic states are presumed to be definable in the given language ( e.g. , in terms of intersection and union of associated sets of models , respectively ) .",
    "the most important differences between ( k1)(k8 ) and ( u1)(u8 ) are that revision should yield the same result as expansion @xmath302 , providing @xmath265 is compatible with @xmath260 , which is not desirable for update in general , cf .",
    "@xcite . on the other hand , ( u8 ) says that if @xmath260 can be decomposed into a disjunction of states ( e.g. , models ) , then each case can be updated separately and the overall result is formed by taking the disjunction of the emerging states .",
    "darwiche and pearl   have proposed postulates for iterated revision , which can be rephrased in our setting as follows ( we omit parentheses in sequences @xmath303 of revisions ) :    ( c1 ) : :    if @xmath304 , then    @xmath305 .",
    "( c2 ) : :    if @xmath306 , then    @xmath307 .",
    "( c3 ) : :    if @xmath308 , then    @xmath309 .",
    "( c4 ) : :    if @xmath310 , then    @xmath311 .",
    "( c5 ) : :    if @xmath312 and    @xmath313 , then    @xmath314 .",
    "( c6 ) : :    if @xmath315 and    @xmath316 , then    @xmath317 .",
    "another set of postulates for iterated revision , corresponding to a sequence @xmath260 of observations , has been formulated by lehmann  . here , each observation is a sentence which is assumed to be consistent ( i.e. , falsity is not observed ) , and the epistemic state @xmath260 has an associated belief set @xmath289 .",
    "lehmann s postulates read as follows , where @xmath318 denote sequences of observations and `` , '' stands for concatenation :    ( i1 ) : :    @xmath289 is a consistent belief set .",
    "( i2 ) : :    @xmath319 .",
    "( i3 ) : :    if @xmath320 , then    @xmath321 .",
    "( i4 ) : :    if @xmath287 , then    @xmath322 .",
    "( i5 ) : :    if @xmath323 then    @xmath324 .",
    "( i6 ) : :    if @xmath325 , then    @xmath326 .",
    "( i7 ) : :    @xmath327 .      in order to evaluate the different postulates , we need to adapt them for the setting of update programs .",
    "naturally , the epistemic state @xmath12 of an agent is subject to revision . however , the associated belief set @xmath138 @xmath328 does not belong to a logical language closed under boolean connectives .",
    "closing @xmath46 under conjunction does not cause much troubles , as the identification of finite logic programs with finite conjunctions of clauses permits that updates of a logic program @xmath47 by a program @xmath100 can be viewed as the update of @xmath47 with a single sentence from the underlying belief language .",
    "ambiguities arise , however , with the interpretation of expansion , as well as with the meaning of negation and disjunction of rules and programs , respectively .    depending on whether the particular structure of the epistemic state @xmath260 should be respected ,",
    "different definitions of expansion are imaginable in our framework . at the `` extensional '' level of sentences , represented by a program or sequence of programs @xmath16 ,",
    "@xmath329 is defined as @xmath330 . at the `` intensional '' level of sequences @xmath12",
    ", @xmath329 could be defined as @xmath331 .",
    "an intermediate approach would be defining @xmath332 .",
    "we adopt the extensional view here .",
    "note that , in general , adding @xmath100 to @xmath138 does not amount to the semantical intersection of @xmath100 and @xmath138 ( nor of @xmath223 and @xmath100 , respectively ) .    as for negation",
    ", we might interpret the condition @xmath333 ( or @xmath334 ) in ( k4 ) and ( k8 ) ) as satisfiability requirement for @xmath282 ( or @xmath335 , respectively ) .",
    "disjunction @xmath336 of rules or programs ( as epistemic states ) appears to be meaningful only at the semantical level .",
    "the union @xmath337 of the answer sets of programs @xmath80 and @xmath81 may be represented syntactically through a program @xmath148 , which in general requests an extended set of atoms .",
    "we thus do not consider the postulates involving the operator @xmath338 .    given these considerations , table  [ table : agm ] summarizes our interpretation of postulates ( k1)(k8 ) and ( u1)(u6 ) , and includes references whether the respective property holds or fails .",
    "we assume that @xmath339 are sequences of elps , and @xmath340 denote single elps .",
    "moreover , the notation @xmath341 is an abbreviation for the sequence @xmath342 if @xmath175 .",
    "demonstrations and counterexamples concerning these properties are given in appendix  [ app : agm - update ] , and can be easily adapted for dynamic logic programming too .",
    ".interpretation of postulates @xmath343k1@xmath344@xmath343k8@xmath344 and @xmath343u1@xmath344@xmath343u6@xmath344 . [ cols=\"^,<,^\",options=\"header \" , ]      rounding off our discussion on principles of update sequences ,",
    "we describe some additional general properties which , as we believe , updates and sequences of updates should satisfy .",
    "the given properties are not developed in a systematic manner , though , and they are not meant to represent an exhaustive list . unless stated otherwise , update programs enjoy these properties .    [",
    "prop : taut ] if the program @xmath76 contains only tautological rules ( i.e. ,  if @xmath76 contains only rules of the form @xmath345 ) , then @xmath346 .",
    "this property is violated , which is also the case e.g.  for dynamic logic programs .",
    "consider the programs @xmath347 , @xmath348 , and @xmath349 .",
    "then @xmath350 has the single answer set @xmath351 . by updating with @xmath148 , the interaction between @xmath80 and @xmath148 generates another answer set for @xmath14 , namely @xmath352 .",
    "note , however , that tautological rules in updates are , as we believe , rare in practical applications and can be eliminated easily .",
    "@xmath353 .",
    "this property states that the update of an initial empty knowledge base yields just the update itself .",
    "@xmath354 .",
    "updating program @xmath47 by itself has no effect .",
    "this property is in fact a special case of the following principle :    @xmath355 .",
    "the next three properties express conditions involving programs over disjoint alphabets .    if @xmath356 is the union of programs @xmath357 on disjoint alphabets @xmath358 and @xmath359 , then @xmath360 .",
    "if @xmath175 is an update sequence over @xmath18 , and @xmath361 and @xmath362 are programs defined over disjoint alphabets @xmath358 and @xmath359 , respectively , then @xmath363 .    in other words ,",
    "the update by non - interfering programs can be done in parallel , by merging the respective results .",
    "this property is not satisfied : consider the case @xmath364 , with @xmath365 and @xmath366 . assuming that the property holds , we would have @xmath367 , i.e. ,  @xmath47 holds in @xmath368 no matter what .",
    "this is quite obviously not the case .    if @xmath80 and @xmath81 are programs defined over disjoint alphabets , then @xmath369 .",
    "that is , the order of updates which do not interfere with each other is immaterial .",
    "this property is an immediate consequence of the following stronger property : suppose @xmath370 is a program such that there are no rules @xmath371 and @xmath372 with @xmath373 .",
    "then , @xmath374 .",
    "if @xmath96 , then @xmath375 .    updating with additional rules makes the previous update obsolete .",
    "this property is a somewhat stronger , syntactic variant of the postulate ( c1 ) from above , which fails . on the other hand ,",
    "it includes absorption as a special case .",
    "note that @xmath376 does in general _ not _ hold , which may be desired in some cases : omission of a rule @xmath8 in @xmath81 with respect to @xmath80 leaves the possibility to violate @xmath8 .",
    "as mentioned before , a sequence of updates @xmath12 can be viewed either from the point of view of `` immediate '' revision , or as `` logic - constrained '' revision .",
    "the following property , which deserves particular attention , expresses equivalence of these views ( the property is formulated for the case @xmath377 ) :    for any epistemic state @xmath80 and elps @xmath81 and @xmath148 over @xmath18 , it holds that @xmath378",
    ".    however , this property fails .",
    "informally , soundness of this property would mean that a sequence of three updates is a shorthand for iterated update of a single program , i.e. , the result of @xmath379 is viewed as a singleton sequence .",
    "stated another way , this property would mean that the definition for @xmath380 can be viewed as a shorthand for the nested case .",
    "vice versa , this property reads as possibility to forget an update once and for all , by incorporating it immediately into the current belief set .    for a concrete counterexample ,",
    "consider @xmath381 , @xmath382 ,   @xmath383 , and @xmath384 .",
    "the program @xmath385 has a unique answer set , in which @xmath5 is true . on the other hand , @xmath386 has no consistent answer set .",
    "informally , while the `` local '' inconsistency of @xmath81 is removed in @xmath380 by rejection of the rule @xmath387 via @xmath148 , a similar rejection in @xmath386 is blocked because of a renaming of the predicates in @xmath388 .",
    "the local inconsistency of @xmath81 is thus not eliminated .",
    "however , under certain conditions , which exclude such possibilities for local inconsistencies , the iterativity property holds , given by the following result :    [ theo : iterate ] let @xmath389 , @xmath390 be a sequence of programs over a set of atoms @xmath18 .",
    "suppose that for any conflicting rules @xmath391 , @xmath392 , one of the following conditions holds :    * there is some rule @xmath393 , @xmath394 , such that either @xmath395 and @xmath396 , or @xmath397 and @xmath398 ; * there are rules @xmath399 , @xmath400 , such that @xmath401 and @xmath402 , @xmath403 , and no rule @xmath404 exists with @xmath405 and @xmath406 or @xmath407 ; or * @xmath408 is unsatisfiable .",
    "then : @xmath409    the proof of this theorem is technically involving and is not presented here ; it can be found in  @xcite .",
    "observe that conditions  ( i)(iii ) of theorem  [ theo : iterate ] are simple syntactic criteria , which can be easily checked .    a weaker version of theorem  [ theo : iterate ] may be applied if updates should be incorporated instantaneously , by only considering condition  ( iii ) .",
    "this condition can be locally checked on each update , and is useful , e.g. ,  if @xmath388 has already been constructed . since , for any programs",
    "@xmath361 and @xmath362 , the update program @xmath410 does not have rules with opposite heads , we can conclude from theorem  [ theo : iterate ] that incorporating consecutive updates which obey assertion ( iii ) is equivalent to the update program for the sequence of updates .",
    "[ theo : nested - iterate ] let @xmath12 , @xmath411 , be an update sequence on a set of atoms @xmath18 .",
    "suppose that , for any conflicting rules @xmath391 , @xmath412 , the union @xmath413 of their bodies is unsatisfiable .",
    "then : @xmath414    in certain cases , the assertions in theorem  [ theo : iterate ] can be dropped .",
    "one such case is a repeated update , i.e. , @xmath415 ; see @xcite for more details .",
    "a property which update programs intuitively do not respect is _ minimality of change_. in general , it is desirable to incorporate a new set of rules @xmath81 into an existing program @xmath80 with as little change as possible .",
    "this , of course , requests us to specify how similarity ( or difference ) between programs is understood and , furthermore , how proximity of programs is measured . in particular , the question is whether similarity should be model - based , or syntactically defined .",
    "since the semantics of update programs depends on syntax , a pure model - based notion of similarity between logic programs seems less appealing for defining minimality of change . a natural approach for measuring the change which @xmath80 undergoes by an update with @xmath81 is by considering those rules in @xmath80 which are abandoned .",
    "this leads us to prefer an answer set @xmath416 of @xmath417 over another answer set @xmath418 if @xmath416 satisfies a larger set of rules from @xmath80 than @xmath418 .",
    "[ min2 ] [ def : minimal ] let @xmath154 be an update sequence .",
    "an answer set @xmath419 is _ minimal _ iff there is no @xmath420 such that @xmath421 .",
    "[ ex : minimal ] consider the sequence @xmath422 from example  [ example : tv ] .",
    "assume that the following additional update is received , describing that a tv can also be turned off : @xmath423 while @xmath422 has the single answer set @xmath424 , the new sequence @xmath425 has two answer sets : @xmath426 and , additionally , @xmath427 .",
    "both answer sets reject rule @xmath428 , but @xmath418 rejects @xmath429 , too .",
    "thus , @xmath416 is minimal and , corresponding to our intuition , should be preferred to @xmath418 .",
    "minimal answer sets put no further emphasis on the temporal order of updates .",
    "rules in more recent updates may be violated in order to satisfy rules from previous updates .",
    "eliminating this possibility leads us to the following notion :    [ def : strict ] let @xmath430 , for some update sequence @xmath12 .",
    "then , @xmath28 is _ preferred _ over @xmath134 iff some @xmath431 exists such that ( i ) @xmath432 , and ( ii )  @xmath433 , for all @xmath434 .",
    "an answer set @xmath28 of @xmath16 is _ strictly minimal _ , if no @xmath420 exists which is preferred over @xmath28 .",
    "[ ex : strict ] suppose in the previous example we had observed that the tv was off when the power returned , i.e. ,  replace @xmath148 in @xmath435 by : @xmath436 the modified update sequence @xmath437 yields the same answer sets as before : @xmath438 however , now both answer sets are minimal : we have @xmath439 and @xmath440 .",
    "thus , @xmath441 and @xmath442 are incomparable , and hence both @xmath416 and @xmath418 are minimal answer sets .",
    "since in @xmath416 the more recent rule of @xmath443 is violated , @xmath418 is the unique strictly minimal answer set .",
    "we denote by @xmath444 the set of all rules which are true in any minimal answer set of an update sequence @xmath16 .",
    "likewise , @xmath445 denotes the set of all rules which are true in all strictly minimal answer sets of @xmath16 .",
    "let us consider some further example stressing the difference between regular update answer sets , minimal answer sets , and strictly minimal answer sets .",
    "[ ex : concert ] an agent consulting different sources in search of a performance or a final rehearsal of a concert on a given weekend may be faced with the following situation .",
    "first , the agent is notified by one of the sources that there is no concert on friday : @xmath446 later on , a second source reports that it is neither aware of a final rehearsal on friday , nor of a concert on saturday : @xmath447 finally , the agent is assured that there is a final rehearsal or a concert on friday and that whenever there is a final rehearsal on friday , a concert on saturday or sunday follows : @xmath448 the update sequence @xmath449 yields three answer sets : @xmath450 the corresponding rejection sets are : @xmath451 thus , @xmath418 and @xmath452 are minimal answer sets , with @xmath452 being the single strictly minimal answer set of @xmath16 .    clearly , every strictly minimal answer set is minimal , but not vice versa .",
    "it is easily seen that for the case of update sequences involving only two update programs , i.e. ,  for update sequences of the form @xmath417 , the notions of strictly minimal answer sets and minimal answer sets coincide . as for the agm",
    "postulates , inspection shows that minimal and strictly minimal answer sets satisfy the same postulates as regular update answer sets , with the exception that ( k3 ) and ( k4 ) hold for the former ones .    concerning the implementation of minimal and strictly minimal answer sets , in section  [ app : implementation ]",
    "we will show how they can be characterized in terms of elps .",
    "in this section , we address the computational complexity of update programs .",
    "we assume that the reader is familiar with the basic concepts of complexity theory ; e.g. ,  @xcite and @xcite are good sources ( for complexity results in logic programming , cf .",
    "@xcite ) . in our analysis",
    ", we focus on the case of finite , propositional update sequences .",
    "we briefly recall the definitions of the complexity classes relevant in the following analysis .",
    "the class  consists of all decision problems which are solvable in polynomial time using a nondeterministic turing machine , and @xmath453 is the class of all decision problems solvable by a nondeterministic turing machine in polynomial time with access to an oracle for problems in @xmath454 ( @xmath453 is also written as @xmath455 ) .",
    "furthermore , @xmath456 refers to the class of problems whose complementary problems are in , and @xmath457 contains the complements of the problems in @xmath453 . and",
    "@xmath458 , are complementary ( or , @xmath459 and @xmath458 are complements of each other ) if it holds that @xmath48 is a yes - instance of @xmath459 exactly if @xmath48 is a no - instance of @xmath458 . ]",
    "all the mentioned classes belong to the _ polynomial hierarchy _ :  and  are at the first level of the hierarchy , and @xmath453 and @xmath457 are the second level . as well ,",
    "@xmath460 and @xmath461 .",
    "it is widely held that these inclusions are proper .",
    "it is clear that the complexity of normal logic programs , which resides at the first level of the polynomial hierarchy @xcite , is a lower bound for the complexity of update programs . for arbitrary updates ,",
    "the complexity does not increase , even if we consider a sequence of updates .",
    "[ theo : comp-1 ] given an update sequence @xmath175 over a set of atoms @xmath18 , then :    * determining whether @xmath16 has an answer set is @xmath454-complete ; * determining whether @xmath462 for some literal @xmath21 is @xmath456-complete .",
    "hardness holds in both cases for @xmath364 .",
    "the program @xmath463 can obviously be generated in polynomial time from @xmath175 .",
    "furthermore , deciding consistency of @xmath126 is in , and checking whether @xmath464 is in .",
    "this proves membership . -hardness and -hardness of the respective tasks",
    "is inherited from the complexity of normal logic programs @xcite .    under minimal updates ,",
    "the complexity of updates increases by one level in the polynomial hierarchy .",
    "this is no surprise , though , and parallels analogous results on update logic programs by sakama and inoue   as well as previous results on updating logical theories and iterated circumscription @xcite .",
    "[ theo : comp-2 ] given an update sequence @xmath175 over a set of atoms @xmath18 and some rule @xmath8 , the following two problems are @xmath457-complete :    * determining whether @xmath465 ; and * determining whether @xmath466 .",
    "hardness holds even if @xmath467 .",
    "we first show that the two tasks are in @xmath457 .",
    "we treat only task ( i ) ; the case of task ( ii ) is analogous . in order to show membership of ( i ) in @xmath457",
    ", we show that the complementary problem is in @xmath453 .",
    "to disprove @xmath465 , we can construct the update program @xmath468 in polynomial time from @xmath16 and guess an answer set @xmath469 of @xmath126 such that @xmath470 and where @xmath471 is a minimal answer set of @xmath16 ( recall that @xmath472 is minimal iff there is no @xmath473 such that @xmath474 ) . with",
    "the help of an @xmath454-oracle , the guess for @xmath158 can be verified in polynomial time .",
    "this concludes the proof that checking whether @xmath475 is in @xmath453 .",
    "hardness of both tasks is shown by a simple reduction from the @xmath457-hard irrelevance test in abduction from normal logic programs @xcite , which is the following problem : given a normal logic program @xmath47 , a set of atoms @xmath476 , a set of literals @xmath477 , and an atom @xmath478 , decide whether @xmath479 is not contained in any minimal brave explanation of @xmath477 , i.e. , decide whether @xmath480 holds for each minimal @xmath481 ( with respect to inclusion ) such that @xmath482 has some stable model @xmath28 with @xmath483 , for all @xmath484 .",
    "the reduction is defined as follows : for each @xmath485 , let @xmath486 and @xmath487 be fresh atoms , and consider the update sequence @xmath417 , where @xmath488 it can be shown that there is a one - to - one correspondence between the rejection sets @xmath174 of the minimal answer sets @xmath28 of @xmath16 and the minimal brave explanations @xmath260 for @xmath477 .",
    "in particular , the rule @xmath489 is in @xmath490 iff @xmath479 belongs to the corresponding minimal explanation @xmath260 .",
    "it follows that @xmath491 iff @xmath479 is not contained in any brave explanation for @xmath477 , which establishes @xmath457-hardness of ( i ) . since the notions of minimal and strictly minimal answer sets coincide for update sequences of length 2 , we have that @xmath492 .",
    "thus , @xmath457-hardness of ( ii ) holds as well .",
    "similar results hold in the approach of inoue and sakama  .",
    "furthermore , they imply that minimal and strictly minimal answer sets can be polynomially translated into disjunctive logic programming , which can serve as a basis for implementation purposes .",
    "the next section deals with some algorithmic issues .",
    "the notion of update sequence can be easily extended to the case where rules may contain variables . as usual , the semantics of a program @xmath47 containing variables is defined in terms of the semantics of its ground instances @xmath493 over the herbrand base .",
    "rules @xmath8 with variables @xmath494 are denoted @xmath495 , and rejection of @xmath8 is represented by a predicate @xmath496 ; further details , can be found in @xcite . in the rest of this section",
    ", we consider function - free update sequences @xmath16 .    since answer sets of ( first - order ) update sequences are defined by answer sets of ( first - order ) elps , it is relative straightforward to implement the current update approach .",
    "in fact , an implementation can be built on top of existing solvers for answer set semantics . in the present case",
    ", we implemented updates as a front - end for the logic programming tool ` dlv `  @xcite .",
    "the latter system is a state - of - the - art solver for _ disjunctive logic programs _ ( dlps ) under the answer set semantics .",
    "it allows for non - ground rules and calculates answer sets by performing a reduction to the stable model semantics .",
    "( another highly efficient logic programming implementation , realizing stable model semantics , is the system ` smodels `  @xcite , which would similarly fit as underlying reasoning engine .",
    "we chose ` dlv `  because of familiarity and its optimization techniques for grounding , as well as its expressiveness which would allow an integral solution to compute strict and strictly minimal answer sets , respectively . ) formally , dlps are defined as elps where disjunctions may appear in the head of rules ; the answer set semantics for dlps is due to gelfond and lifschitz  .",
    "the implemented tasks agree with the decision problems discussed in the previous section , i.e. ,  they comprise the following problems : ( i ) checking the existence of an answer set for a given update sequence , ( ii ) brave reasoning , and ( iii ) skeptical reasoning ; as well as the corresponding problems for minimal and strictly minimal answer sets .",
    "all of these tasks have been realized for first - order update sequences , employing the advanced grounding mechanism of ` dlv ` .    as regards the implementation for minimal and strictly minimal update answer sets , although in principle it is possible to express the corresponding reasoning tasks in terms of dlps ( which is a consequence of theorem  [ theo : comp-2 ] and well - known expressibility results for the disjunctive answer set semantics  @xcite ) , we chose instead to pursue a two - step evaluation approach for our purposes , remaining within the present non - disjunctive framework , and , at the same time , adhering more closer to the underlying intuitions . roughly speaking ,",
    "this two - step approach can be described as follows : first , all candidates for minimal ( strictly minimal ) answer sets are calculated , i.e. ,  all answer sets of the update program @xmath135 . afterwards , every candidate is tested for being minimal ( strictly minimal ) .    testing a candidate , @xmath28 , for minimality ( strict minimality )",
    "is performed by evaluating a test program , @xmath497 ( @xmath498 ) , consisting of the rules of @xmath135 and a set of additional rules .",
    "intuitively , the additional rules constrain the answer sets of @xmath497 ( @xmath498 ) to those answer sets of @xmath135 having a smaller set of rejected rules compared to the rules rejected by @xmath28 ( or to those answer sets of @xmath135 preferred over @xmath28 , respectively ) .",
    "hence , the candidate @xmath28 is minimal ( strictly minimal ) if the corresponding test program @xmath497 ( @xmath498 ) has no answer set . in the following subsections ,",
    "the implementation approach is described more formally .",
    "[ def : mintest - program ] let @xmath116 be a ( first - order ) update program and s an answer set of @xmath135 .",
    "let @xmath499 be a new nullary predicate symbol ( i.e. ,  propositional atom ) and , for each predicate symbol @xmath500 occurring in @xmath135 , let @xmath501 be a new predicate symbol of the same arity as @xmath500 .",
    "then , the minimality - test program with respect to @xmath28 , @xmath497 , consists of all rules and constraints of @xmath135 , together with the following items :    1 .",
    "[ minrule : greater ] for each predicate symbol @xmath500 occurring in @xmath135 : @xmath502 2 .",
    "[ minrule : less ] for each ground formula @xmath503 : @xmath504 3 .",
    "[ minrule : equal ] the constraint @xmath505    note that in the above definition , only the rules and facts of ( ii ) manifest the dependence of @xmath497 from @xmath28 .",
    "informally , the constraints ( i ) eliminate all answer sets with rejection sets which can not be subsets of @xmath506 , i.e. ,  which reject at least one rule not rejected in @xmath28 . in the remaining answer sets , if any , either @xmath499 is true , i.e. ,  at least one rule which is rejected in @xmath28 is not rejected in such a set , or @xmath499 is false , in which case their rejection sets equal @xmath506 , and thus these sets are eliminated by constraint  ( iii ) .",
    "actually , the following proposition holds :    @xmath507 \\textbf{input:}~\\textrm{a~sequence~of~elps}~{\\mbox{\\em\\bfseries p}}=(\\mathit{p_1\\textrm{{,\\ldots , } } p_n})\\textrm{.}\\\\ \\textbf{output:}~\\textrm{all~minimal~answer~sets~of}~{\\mbox{\\em\\bfseries p}}\\textrm{. } \\\\[1.5ex ] \\textbf{var}~cands : setofanswersets;\\\\ \\textbf{var}~minmodels : setofanswersets;\\\\ cands : = compute\\_answer\\_sets({\\mbox{\\em\\bfseries p}}_{{\\lhd}});\\\\ \\textbf{for}~\\textrm{all}~\\mathit{s } \\in cands~\\textbf{do}\\\\ \\hspace*{1cm}\\textbf{var}~counter : setofanswersets;\\\\ \\hspace*{1cm}counter : = compute\\_answer\\_sets({\\mbox{\\em\\bfseries p}}^{\\mathit{min}}_{\\mathit{s}});\\\\ \\hspace*{1cm}\\textbf{if}~(counter = \\emptyset)~\\textbf{then}\\\\ \\hspace*{2cm}minmodels : = minmodels \\cup \\{\\mathit{s}\\};\\\\ \\hspace*{1cm}\\textbf{fi}\\\\ \\textbf{rof}\\\\ \\textbf{return}~minmodels;\\\\ \\end{array}\\ ] ]    [ prop : min ] let @xmath28 be an answer set of @xmath135",
    ". then , @xmath28 is a minimal answer set of @xmath135 iff @xmath497 has no answer set .",
    "_ only - if part .",
    "_ suppose @xmath497 has an answer set @xmath508",
    ". then @xmath499 must be true in @xmath508 due to the constraint ( iii ) of definition  [ def : mintest - program ] .",
    "( ii ) of definition  [ def : mintest - program ] are the only ones in @xmath497 with head @xmath499 , there exists a ground term @xmath503 such that @xmath509 .",
    "moreover , no ground term @xmath510 can exist due to the constraints ( i ) of definition  [ def : mintest - program ] .",
    "( observe that @xmath511 implies @xmath512 ; hence , if @xmath513 , then the body of one of the constraints is true in @xmath508 . )",
    "this proves @xmath514 .    since the predicate symbols @xmath499 and @xmath501 do not occur in @xmath135 , and @xmath497 contains all rules and constraints of @xmath135 , results on the splitting of logic programs  @xcite imply that @xmath515 is an answer set of @xmath135 .",
    "given that @xmath516 , we obtain that @xmath28 is not minimal .",
    "_ if part .",
    "_ suppose @xmath28 is not minimal .",
    "then there exists an answer set @xmath517 of @xmath135 with @xmath518 .",
    "consider @xmath519 .",
    "it is easily verified that @xmath517 is an answer set of @xmath497 .",
    "this result allows us to calculate all minimal answer sets of @xmath135 using the straightforward algorithm depicted in figure [ fig : min - algorithm ] , which proceeds as follows : compute all answer sets of @xmath135 and check for every answer set @xmath28 if the corresponding minimality - test program @xmath497 has at least one answer set . if not , then add @xmath28 to the set of minimal answer sets of @xmath135 .",
    "[ def : stricttest - program ] let @xmath116 be a ( first - order ) update program and s an answer set of @xmath135 .",
    "let @xmath499 , @xmath520 ( @xmath109 ) , and @xmath521 ( @xmath522 ) be new nullary predicate symbols , and , for each predicate symbol @xmath500 occurring in @xmath135 , let @xmath501 be a new predicate symbol of the same arity as @xmath500 .",
    "then , the program @xmath498 consists of all rules and constraints of @xmath135 , together with the following items :    1 .",
    "[ strictrule : greater ] for each predicate @xmath500 occurring in @xmath135 , corresponding to @xmath118 : @xmath523 2 .",
    "[ strictrule : less ] for each ground term @xmath503 , corresponding to @xmath118 : @xmath524 3 .",
    "[ strictrule : level - equal ] for @xmath117 : @xmath525 4 .",
    "[ strictrule : equal ] the constraint @xmath526 and the fact @xmath527    again , program @xmath498 depends on @xmath28 only in virtue of item  ( ii ) .",
    "the constraints of item  ( i ) eliminate all answer sets @xmath508 which can not be preferred over @xmath28 because at some level @xmath108 they reject a rule not rejected in @xmath28 , and @xmath528 holds for @xmath529 ( expressed by @xmath530 ) . in the remaining answer sets , if there is any , @xmath499 is either true , or false .",
    "if @xmath499 is true in @xmath508 , then @xmath520 is true in @xmath508 for some level @xmath108 , i.e. ,  @xmath508 does not reject a rule of @xmath98 which is rejected in @xmath28 , and @xmath531 for @xmath529 . in this case",
    ", @xmath508 is preferred over @xmath28 .",
    "if , however , @xmath499 is false in @xmath508 , then @xmath532 , for @xmath533 , and @xmath508 is killed by the constraint of item  ( iv ) .    an equivalent result as for minimality - test programs holds for the above test programs as well .",
    "hence , the same algorithm using @xmath498 instead of @xmath497 can be used to compute all strictly minimal answer sets of @xmath135 .",
    "let @xmath28 be an answer set of @xmath135 .",
    "then , @xmath28 is a strictly minimal answer set of @xmath135 iff @xmath498 has no answer set .",
    "_ only - if part .",
    "_ suppose @xmath498 has an answer set @xmath508",
    ". then @xmath499 must be true in @xmath508 , due to constraint ( iv ) of definition  [ def : stricttest - program ] . since the rules of item ( iii ) of definition  [ def : stricttest - program ] are the only ones in @xmath498 with head @xmath499 , there exists some @xmath108 , @xmath117 , such that @xmath534 .",
    "this implies that the body of the corresponding rule of ( ii ) must be true in @xmath508 .",
    "hence , there exists a ground term @xmath535 , where @xmath118 and such that @xmath536 . moreover , except for the fact @xmath537 , the rules of ( iii ) are the only ones in @xmath498 with @xmath538 predicate symbols in their heads , so that @xmath530 implies @xmath539 and @xmath540 for @xmath529 if @xmath541 . from this , and the constraints of ( i ) , it follows that no ground term @xmath542 , @xmath543 , @xmath544 , can exist ( @xmath511 implies @xmath512 ; hence , having @xmath513 and @xmath545 , the body of one of the constraints is true in @xmath508 ) .",
    "it also follows that for every @xmath543 , @xmath529 , if @xmath546 , then @xmath513 ( otherwise the body of one of the rules of ( ii ) would be true in @xmath508 , implying @xmath547 , a contradiction ) .    summarizing , we have shown @xmath548 and @xmath549 , for @xmath529 .",
    "so , @xmath508 is preferred over @xmath28 .    since none of the predicate symbols @xmath499 , @xmath538 , and @xmath501 occurs in @xmath135 , and @xmath498 contains all rules and constraints of @xmath135 , by a similar argument as in the proof of theorem  [ prop : min ] ( i.e. ,  invoking splitting results from @xcite ) it follows that @xmath550 is an answer set of @xmath135 . given that @xmath551 , we obtain that @xmath517 is preferred over @xmath28 . consequently , @xmath28 is not a strictly minimal answer set .    _ if part .",
    "_ suppose @xmath28 is not a strictly minimal answer set .",
    "then there exists an answer set @xmath517 of @xmath135 which is preferred over @xmath28 .",
    "in particular , there exists some @xmath108 , @xmath117 , such that @xmath552 for @xmath529 and @xmath553 .",
    "consider @xmath554 it is easily verified that @xmath517 is an answer set of @xmath498 .",
    "in this section , we analyze the relations between the current update framework and other formalisms . first of all , we discuss the connection with inheritance programs by buccafurri _",
    "et al . _  , which has not been introduced as a formalism for updates but can be successfully interpreted as such , coming to an equivalence result with our update sequences over the common fragment .    in a second step ,",
    "we study the relation on the one hand to the approach of leite and pereira  , also modeling revision programming by marek and truszczyski  , on the other hand to dynamic logic programming  @xcite , which is close in spirit to the present update method , in the sense that update sequences are translated to standard logic programs .",
    "in particular , we describe the semantical differences between our update programs and dynamic programs , and identify a wide class of logic programs for which they yield the same results .",
    "then , we briefly discuss update approaches for logic programs based on preference handling  @xcite and abduction  @xcite .",
    "finally , we mention a method due to delgrande , schaub , and tompits   for handling preference information in the context of logic programs , which is also based on an encoding to elps .",
    "the update semantics we suggest resolves conflicts by assigning `` preference '' to the more recent information .",
    "as already pointed out earlier , this can also be interpreted as some form of inheritance mechanism , where the more recent information is considered as being more specific . in this section",
    ", we discuss this aspect in more detail . to wit , we consider the inheritance approach introduced by buccafurri _",
    "_   and we show that update sequences can equivalently be described in terms of inheritance programs .    in what follows",
    ", we briefly describe the basic layout of the inheritance approach by buccafurri _",
    "since that method has originally been specified for non - ground dlps , and we deal here only with non - disjunctive elps , we adapt some of the original definitions accordingly .",
    "a _ @xmath555-program _ ,",
    "@xmath15 , is a finite set @xmath556 of object identifiers @xmath557 @xmath104 and associated elps @xmath98 , together with a strict partial order `` @xmath558 '' between object identifiers ( pairs @xmath559 are called _",
    "objects_).-program '' ( as introduced by buccafurri _",
    "et al . _",
    ") is a bit of a misnomer , because `` dlp '' points to _ disjunctive _ logic programs ; however , we retained the original name for reference s sake . ] as well , we say that @xmath15 is a @xmath555-program _ over _ a set of atoms @xmath18 iff @xmath18 denotes the set of all atoms appearing in @xmath15 .",
    "informally , possible conflicts in determining properties of the objects are resolved in favor of rules which are _ more specific _ according to the hierarchy , in the sense that rule @xmath560",
    "is considered to represent more specific information than rule @xmath561 whenever @xmath562 holds ( @xmath563 and @xmath564 ) . in the following",
    ", @xmath565 denotes the multiset of all rules appearing in the programs of @xmath15 .",
    "consider some @xmath555-program @xmath15 over a set of atoms @xmath18 .",
    "let @xmath68 be an interpretation and let @xmath566 and @xmath567 be two conflicting rules , where @xmath568 .",
    "then , @xmath165 _ overrides @xmath166 in _",
    "@xmath48 iff ( i ) @xmath569 , ( ii ) @xmath570 is true in @xmath48 , and ( iii ) @xmath571 is true in @xmath48 .",
    "a rule @xmath572 is _ overridden in _",
    "@xmath48 iff there exists some @xmath573 which overrides @xmath8 in @xmath48 .",
    "an interpretation @xmath574 is a _ model _ of @xmath15 iff every rule in @xmath565 is either overridden or true in @xmath48 ; moreover , @xmath48 is _ minimal _ iff it is the least model of all these rules .",
    "the _ reduct _ , @xmath575 , of the @xmath555-program @xmath15 _ relative _ to @xmath48 results from @xmath565 by ( i ) deleting any rule @xmath572 which is either overridden in @xmath48 or defeated by @xmath48 ; and ( ii ) deleting all weakly negated literals in the bodies of the remaining rules of @xmath565 .",
    "then , @xmath48 is an _ answer set _ of @xmath15 iff it is a minimal model of @xmath575 .",
    "this concludes our brief review of the inheritance framework of  @xcite ; we continue with our correspondence result .",
    "[ theo : elp - upd - inh ] @xmath226 is an answer set of the update sequence @xmath12 over @xmath18 iff @xmath28 is an answer set of the @xmath555-program @xmath576 having inheritance order @xmath577 .",
    "we first note the following two properties , which can be verified in a straightforward way .",
    "let @xmath578 be some interpretation and @xmath572 . then",
    ":    * if @xmath579 , then @xmath8 is overridden in @xmath48 . *",
    "assume @xmath48 satisfies for any @xmath573 the condition that @xmath580 is true in @xmath48 whenever @xmath581 is true in @xmath48 .",
    "then , @xmath8 is overridden in @xmath48 only if @xmath579 .",
    "we proceed with the proof of the main result .",
    "suppose @xmath28 is an answer set of @xmath12 .",
    "we show @xmath28 is an answer set of @xmath576 with inheritance order @xmath577 .",
    "first , we show that @xmath28 is a model of @xmath582 .",
    "consider some @xmath583 .",
    "then , there is some rule @xmath584 such that @xmath585 and @xmath586 is neither overridden in @xmath28 nor defeated by @xmath28 .",
    "applying property  ( i ) , we get that @xmath587 .",
    "hence , @xmath588 since @xmath586 is not defeated by @xmath28 .",
    "thus , given that @xmath28 is an answer set of @xmath16 , theorem  [ theo : sequence - char-0 ] implies that @xmath585 is true in @xmath28 .",
    "it follows that @xmath28 is a model of @xmath582 .",
    "next , we show that there is no proper subset of @xmath28 which is also a model of @xmath582 .",
    "suppose there is such a set @xmath589 . since @xmath28 is an answer set of @xmath16 , property  ( ii ) can be applied , and we obtain @xmath583 whenever @xmath590 holds . as a consequence , @xmath591 is a model of @xmath590 , which contradicts the fact that @xmath28 is an answer set of @xmath16 .",
    "this concludes the proof that @xmath28 is an answer set of @xmath15 if @xmath28 is an answer set of @xmath16 .    for the converse direction ,",
    "assume @xmath28 is an answer set of @xmath15 .",
    "similar to the argumentation given above , property",
    "( ii ) implies that @xmath28 is a model of @xmath592 .",
    "as well , @xmath28 is a minimal model of @xmath592 , because otherwise property  ( i ) would yield a proper subset @xmath591 of @xmath28 being a model of @xmath582 , contradicting the fact that such a subset @xmath591 can not exist , because @xmath28 is an answer of @xmath15 .",
    "inheritance programs are also related to _ ordered logic programs _ , due to laenens _",
    "et al . _   and further analyzed by buccafurri _",
    "et al . _  .",
    "the difference between inheritance programs and ordered logic programs is that the latter ones have a built - in _ contradiction removal _ feature , which eliminates local inconsistencies in a given hierarchy of programs .",
    "thus , for linearly ordered programs @xmath593 where such inconsistencies do not occur , e.g. ,  if for any two conflicting rules in @xmath98 ( @xmath109 ) their bodies can not be simultaneously satisfied , the above equivalence result holds for ordered logic programs as well .      in the framework of marek and",
    "truszczyski  , a knowledge base is a collection of positive facts , and revision programs specify conditional insertions or removals of facts under a semantics very similar to the stable semantics . in discussing this approach ,",
    "leite and pereira   argued that the approach of revision programs is not adequate if more complex knowledge is represented in the form of logic programs , because revision programs compute only `` model - by - model updates '' , which do not capture the additional information encoded by logic programs .",
    "accordingly , they proposed an extended framework in which a suitable inertia principle for rules realizes the update independently of any specific model of the original program . in the following ,",
    "we briefly sketch their approach .    in a first step , leite and pereira",
    "define their approach for normal logic programs , and afterwards they extend it to handle programs with strong negation as well .",
    "furthermore , @xcite deals only with the situation where a given program is updated by a single program ; the general case involving an arbitrary number of updates is described in @xcite .",
    "we describe here the latter approach , but , for the sake of simplicity , only the case of normal logic programs .    following the method of revision programs  @xcite ,",
    "an update program in the sense of @xcite is a finite collection of rules of the form @xmath594 where @xmath595 are atoms ( @xmath596 ) .",
    "intuitively , rule  ( [ eq : revision:1 ] ) states that @xmath22 should be true given that @xmath597 are true and @xmath598 are false , and a similar meaning holds for rule  ( [ eq : revision:2 ] ) .",
    "rule  ( [ eq : revision:1 ] ) is called an _ in - rule _ , and rule  ( [ eq : revision:2 ] ) is an _ out - rule_. semantically , in - rule ( [ eq : revision:1 ] )",
    "is interpreted as the logic program rule @xmath599 whilst out - rule ( [ eq : revision:2 ] ) is interpreted as @xmath600    when speaking about update programs , in the following they are always identified with finite sets of rules of the above form .",
    "let us call a sequence @xmath175 of such programs an _ io - sequence _ ( for `` sequence of in- and out - rules '' ) .",
    "consider an io - sequence @xmath175 over @xmath18 , and let @xmath601 be a set of literals .",
    "leite   introduces the following notion of a rejection set ( for @xmath602 ) : @xmath603 then , @xmath604 is a _",
    "@xmath16-justified update at state j _",
    "( @xmath605 ) iff @xmath28 is an answer set of @xmath606 provided that each program @xmath607 , for @xmath608 , possesses an answer set .",
    ", @xmath607 has a consistent answer set .",
    "however , in our setting , answer sets are always consistent . ]",
    "it is easily seen that for @xmath175 and @xmath28 as above , @xmath28 is an answer set of @xmath609 iff it is an answer set of @xmath610 , where @xmath611 is the weak form of a rejection set , as defined in section  [ sec : props : char ] .",
    "hence , we can state the following proposition :    let @xmath175 be an io - sequence over @xmath18 and @xmath612 a set of literals .",
    "assume that each subsequence @xmath613 has an answer set , for @xmath605 .",
    "then , @xmath28 is an answer set of @xmath16 iff it is a @xmath16-justified update at state @xmath614 .    concerning the extended framework of leite and pereira in which rules of the form ( [ eq : revision:1 ] ) and ( [ eq : revision:2 ] ) may contain literals instead of plain atoms , only a weaker correspondence result holds . omitting further details",
    ", we just mention that in this case our framework corresponds to leite and pereira s providing update sequences contain only in - rules .",
    "alferes _ et al .",
    "_   introduced the concept of _ dynamic logic programs _ as a generalization of both the idea of updating interpretations through revision programs @xcite and of updating programs as defined by alferes and pereira   and by leite and pereira  .",
    "syntactically , dynamic logic programs are based on _ generalized logic programs _ ( glps ) , which allow default negation in the head of rules , but no strong negation whatsoever .    in dynamic logic programming ( dynlp in the following ) ,",
    "the models of a sequence of updates are defined as the stable models of the program resulting from a syntactic rewriting , similar to the transformation used in our approach .",
    "this is called a _",
    "dynamic update_. elements of the sequence are glps .    regarding the formalisms discussed in the previous subsection , in @xcite it is demonstrated that revision programs and dynamic updates are equivalent , provided that the original knowledge is _ extensional _",
    ", i.e. ,  the initial program contains only rules of the form @xmath615 or @xmath616 .",
    "our analysis of dynamic updates can be summarized as follows .",
    "first , basic definitions and semantical characterizations of dynamic update programs are given .",
    "afterwards , the relation between dynamic updates and updates according to definition  [ def : update - program ] is investigated .",
    "since the two approaches are defined over different languages , the comparison must include suitable translations to take this distinction into account . as a matter of fact , alferes _",
    "et al . _",
    "already discussed how elps can be handled within their framework ; likewise , we define a similar translation schema such that glps can be treated by our update method .",
    "as it turns out , there is a semantic difference between dynamic updates and updates according to definition  [ def : update - program ] .",
    "although any dynamic update is an update answer set in the sense of definition  [ def : update - program ] , the converse does not hold in general .",
    "intuitively , this can be explained by the fact that dynamic updates are more restrictive as regards to certain circularities in the given update information . on the other hand ,",
    "we provide sufficient conditions under which both approaches yield equivalent results .",
    "these conditions are formulated by means of suitable graph - theoretical concepts and effectively eliminate the possibility of such circular behavior as mentioned above .",
    "we also briefly discuss that dynamic logic programs do not eliminate all kinds of circularities .    in view of this equivalence over a wide class of logic programs ,",
    "the analysis of update principles we presented in section  [ sec : properties ] applies to dynamic logic programs as well .",
    "furthermore , similar complexity results for dynamic logic programs can be concluded , based on the constructions in section  [ subs : compl ] .",
    "given an update sequence @xmath617 of glps over @xmath18 , let @xmath618 be @xmath18 extended by new , pairwise distinct atoms @xmath619 , @xmath106 , @xmath620 , @xmath621 , @xmath622 , and @xmath623 , for each @xmath107 and each @xmath624 .",
    "the dynamic update program @xmath625 over @xmath618 is defined as the glp consisting of the following items :    1 .   for each @xmath118 , @xmath117 , with @xmath626 : @xmath627 2 .   for each atom @xmath22 occurring in @xmath16 and each @xmath624 : @xmath628 a_i^- & { \\leftarrow } & a_{p_i}^- ; \\hspace{3em } & { { { \\mathit{reject}}}(a_{i-1 } ) } & { \\leftarrow } &   a_{p_i}^- ; \\end{array}\\ ] ] @xmath629 3 .",
    "[ ini - state ] for each atom @xmath22 occurring in @xmath16 : @xmath630    one major difference can immediately be identified between our update programs and dynamic updates : in dynamic updates , the value of each atom is determined from the bottom level @xmath80 _ upwards _ towards @xmath124 ( in virtue of rules @xmath631 and @xmath632 for positive atoms , and the corresponding ones for dashed atoms ) , whilst update programs determine such values in a _",
    "downward _ fashion ( cf .",
    "rules @xmath633 and @xmath634 in definition  [ def : update - program ] ) .",
    "this difference is visually depicted in figure  [ fig : comparison ] .",
    "more importantly , the different evaluation strategy leads in effect to different semantics , which will be shown later on .    before we can properly define the semantics of dynamic updates , based on the transformation @xmath635 introduced above",
    ", we must emphasize that alferes _",
    "et al . _",
    "use a slightly non - standard concept of stable models . to wit ,",
    "weakly negated literals @xmath636 ( @xmath22 some atom ) are treated like ordinary propositional atoms , so that rules @xmath637 are effectively be viewed as _",
    "propositional horn formulas_. accordingly , an interpretation @xmath48 is in this context understood as a set consisting of atoms and weakly negated atoms such that for each atom @xmath22 it holds that @xmath638 iff @xmath639 . to distinguish such interpretations from interpretations in the usual sense , we call them _",
    "generalized interpretations_. as usual , a set @xmath284 , comprised of atoms and weakly negated atoms , is true in a generalized interpretation @xmath48 , symbolically @xmath640 , iff @xmath641 . towards defining stable models ,",
    "the following notation is required :    let @xmath18 be a set of atoms .",
    "then , @xmath642 denotes the set @xmath643 .",
    "furthermore , for @xmath644 , we set @xmath645 , and , for @xmath646 , we define @xmath647 if @xmath648 and @xmath649 if @xmath650 . for a program @xmath47 over @xmath18 , the deductive closure , @xmath651 ,",
    "is given by the set @xmath652 where @xmath47 is interpreted as a propositional horn theory and `` @xmath653 '' denotes classical derivability .",
    "usually , the subscript `` @xmath18 '' will be omitted from @xmath651 .",
    "a generalized interpretation @xmath28 is a stable model of a program @xmath47 iff @xmath654 .",
    "let @xmath175 be a sequence of glps over @xmath18 , and let @xmath48 be a generalized interpretation .",
    "_   introduce the following concepts : @xmath655    then , it holds that @xmath656 is a stable model of @xmath635 iff @xmath657 satisfies the following condition : @xmath658 the set @xmath28 is called a _",
    "dynamic stable model _ of @xmath16 .",
    "alferes _ et al .",
    "_   defined also an extension of their semantics to the three - valued case : let @xmath12 be a sequence of elps over @xmath18 .",
    "then , a consistent set @xmath132 is a _",
    "dynamic answer set _ of @xmath16 iff @xmath659 is a dynamic stable model of the sequence @xmath660 of glps . here",
    ", the rules in @xmath661 serve for emulating classical negation through weak negation .",
    "let us now define how glps are to be rewritten in order to constitute a valid input for update programs according to definition  [ def : update - program ] .",
    "for any rule @xmath8 , by @xmath662 we denote the rule which results from @xmath8 by replacing weak negation occurring in the head of @xmath8 by strong negation , i.e. ,   @xmath663 furthermore , for any glp @xmath47 , we define @xmath664 .",
    "[ def : glp - simulation ] let @xmath175 be a sequence of glps over @xmath18 .",
    "then , the update sequence @xmath665 is given by the sequence @xmath666 .",
    "notice that the part @xmath667 serves for making all answer sets complete .",
    "moreover , no strong negation occurs in rule bodies of @xmath668 .",
    "thus , application of a rule with @xmath25 in the head can never lead to the application of further rules ; it can only enable that rules with @xmath22 in their heads are overridden .",
    "as well , the rules in @xmath669 are not able to override any rule in @xmath670 .    [",
    "lem : dyn - implies - upd ] let @xmath12 be any sequence of glps over a set of atoms @xmath18 , and let @xmath671 be a dynamic stable model of @xmath16 .",
    "then , @xmath672 is an answer set of @xmath665 .    given a set @xmath673 such that @xmath674 we have to show that @xmath675 is an answer set of @xmath668 , i.e.",
    ",  @xmath134 is a minimal model of @xmath676 let us suppose this is not the case , i.e. ,  either the set @xmath134 is not a model of the resulting program , or there is a set @xmath677 such that @xmath678 is a model too .",
    "if @xmath134 is not a model of @xmath679 then there is a rule @xmath680 such that @xmath34 is satisfied by @xmath134 but @xmath681 .",
    "it follows from the construction of @xmath134 that such a rule @xmath8 can not be of the form @xmath682 , therefore @xmath683 must hold .",
    "let us call @xmath684 the rule in @xmath16 corresponding to @xmath8 .",
    "first of all , invoking theorem  [ theo : sequence - char-0-alt ] , we can observe that @xmath685 since the body of @xmath8 is true in @xmath134 , we have @xmath686 too , because of the construction of @xmath134 and given that @xmath687 . now ,",
    "if @xmath35 is a positive literal , @xmath681 entails @xmath688 , contradicting the assumption that @xmath28 is a dynamic stable model of @xmath16 . if , on the other hand , @xmath35 is a weakly negated atom @xmath636 , from the construction of @xmath134 we can deduct that @xmath636 is not in @xmath28 , contradicting the hypothesis as well .",
    "assume now that @xmath677 is a model of @xmath689 suppose @xmath678 and @xmath134 differ on the literal @xmath21 , i.e. ,  @xmath690 but @xmath691 .",
    "but this would mean , by construction of @xmath134 , that a set @xmath692 exists which is also a dynamic stable model of @xmath47 , thus contradicting the hypothesis .",
    "therefore , @xmath134 is an answer set of @xmath693 .",
    "[ theo : dyn - implies - upd ] let @xmath12 be a sequence of elps over @xmath18 .",
    "suppose @xmath169 is a dynamic answer set of @xmath16 .",
    "then , @xmath419 .",
    "let us denote classical negation in @xmath16 by @xmath694 , and rewrite @xmath28 accordingly , i.e. ,  @xmath695 .",
    "then , by combining the emulation of classical negation in @xmath16 through rules @xmath696 and @xmath697 ( @xmath698 ) , and the transformation @xmath699 , we obtain by theorem  [ lem : dyn - implies - upd ] that the set @xmath700 is an answer set of @xmath701 , where each @xmath694 is viewed as a propositional atom and @xmath76 contains for each atom @xmath698 the following rules : @xmath702 observe that @xmath703 implies @xmath704 , and @xmath705 implies @xmath706 .",
    "furthermore , atoms @xmath694 or @xmath22 are included in @xmath678 due to applications of rules @xmath707 , @xmath708 , which are not rejected .    by induction on @xmath108 ( @xmath709 )",
    "one can show that @xmath710 holds .",
    "it follows that @xmath28 is a minimal model of @xmath711 , i.e. ,  @xmath28 is an answer set of @xmath16 .",
    "theorems  [ lem : dyn - implies - upd ] and [ theo : dyn - implies - upd ] do not hold in the converse direction .",
    "this can be seen by the following example :    [ example : not_if_not ] consider programs @xmath80 , @xmath81 , and @xmath712 , where @xmath713 the sequence @xmath417 of glps has one dynamic stable model , @xmath714 , but @xmath665 has two answer sets , @xmath714 and @xmath715 .",
    "likewise , the sequence @xmath716 of elps has also @xmath714 as single dynamic stable model , but @xmath714 and @xmath715 are answer sets of  @xmath143 .",
    "intuitively , the syntactic mechanism responsible for the elimination of some stable models in dynamic updates is the renaming of weakly negated literals in the body of rules .",
    "this renaming ensures that weakly negated literals are not derived in a cyclic way , i.e. ,  the truth value of a weakly negated literal has to be supported by other information besides the literal itself .",
    "this , however , is in general not the case with the transformation for update programs based on definition  [ def : update - program ] . in the next section we present conditions under which both approaches yield equivalent results .",
    "as well , we illustrate that the approach of alferes _",
    "_   does not eliminate all kinds of cyclic informations .      in the sequel , we use and / or - graphs to identify classes of logic programs for which update answer sets and dynamic stable models coincide .",
    "moreover , we present a graph condition which holds precisely in case an update answer set does not correspond to a dynamic stable model . and / or - graphs are frequently employed to model problem reductions , and belong to the category of _ hypergraphs _ , i.e. ,  graphs where nodes are connected by _ hypernodes _ ( also called _ connectors _ ) , represented as a tuple of nodes .",
    "formally , an and / or - graph is a pair @xmath717 , where @xmath718 is a finite set of and - nodes or or - nodes , and @xmath719 is a set of connectors such that @xmath720 is a function , i.e. ,  for each @xmath721 there is at most one tuple @xmath722 such that @xmath723 .",
    "we call @xmath48 the _ input node _ and @xmath724 the _ output nodes _ of @xmath723 . as well , @xmath725 itself",
    "is referred to as a _",
    "@xmath726-connector_.    the concept of a path , as defined in ordinary graphs , can be generalized to and / or - graphs as follows .",
    "let @xmath727 , @xmath728 , be the connector for a node @xmath729 in @xmath730 .",
    "a tree @xmath731 is a _ path rooted at @xmath729 in @xmath730 _ if the following conditions hold :    * if @xmath732 , then @xmath733 ; * if @xmath734 and @xmath729 is an and - node , then @xmath735 , where @xmath736 are paths rooted at @xmath737 in @xmath730 ; and * if @xmath734 and @xmath729 is an or - node , then @xmath738 , for some @xmath739 , where @xmath740 is a path rooted at @xmath741 in @xmath730 .",
    "note that @xmath731 might be an infinite tree .",
    "furthermore , the _ graph associated with a path @xmath731 _ , @xmath742 , is the directed graph whose nodes are the nodes of @xmath730 occurring in @xmath731 and whose edges contain , for every node @xmath729 in the recursive definition of @xmath731 , @xmath743 if @xmath729 is an and - node , and @xmath744 if @xmath729 is an or - node .",
    "next , we will define how an and / or - graph can be assigned to an update sequence @xmath745 , and how such a graph can be reduced with respect to a set of literals @xmath28 .",
    "[ def : upd - graph ] let @xmath745 be a sequence of glps over @xmath18 .",
    "we associate with @xmath16 an and / or - graph , @xmath746 , in the following way :    * the set @xmath718 consists of and - nodes @xmath8 for every rule @xmath8 in @xmath16 , and or - nodes @xmath747 for every @xmath748 and every @xmath9 in @xmath16 ; * the set @xmath720 consists of @xmath749-connectors @xmath750 for every rule @xmath8 in @xmath16 of the form @xmath751 , @xmath752 , and of @xmath753-connectors @xmath754 for all rules @xmath755 in @xmath16 such that @xmath756 , where @xmath646 .",
    "[ def : red - graph ] let @xmath745 be a sequence of glps over @xmath18 and let @xmath671 be a generalized interpretation .",
    "the _ reduced and / or - graph of @xmath16 with respect to @xmath28 _ ,",
    "@xmath757 , is the graph resulting from @xmath758 by :    1 .",
    "[ red - graph : one ] removing all and - nodes @xmath8 and their connectors ( as well as removing @xmath8 from all connectors containing it as output node ) , if either @xmath759 or @xmath760 holds ; and 2 .",
    "replacing , for every atom @xmath22 , the connector of @xmath761 by the @xmath762-connector @xmath763 , if @xmath22 is associated with a @xmath762-connector after step  ( 1 ) and no @xmath759 exists such that @xmath764 .",
    "using the definitions above , we are able to state a simple graph condition expressing correspondence between update answer sets and dynamic stable models .    [ prop : graph - cond ] let @xmath745 be a sequence of glps over @xmath18 and let @xmath228 be an answer set of @xmath665 .",
    "then , the corresponding generalized interpretation @xmath765 is a dynamic stable model of @xmath16 iff , for every atom @xmath766 , one of the following conditions holds :    * for every rule @xmath8 in @xmath16 such that @xmath767 , @xmath768 .",
    "* there exists a path @xmath731 in @xmath769 , rooted at @xmath770 , such that @xmath742 is acyclic .",
    "see @xcite .",
    "the next theorem addresses the case of elps .",
    "[ theo : elp - graph - cond ] let @xmath745 be a sequence of elps over @xmath18 and let @xmath228 be an answer set of @xmath16 .",
    "furthermore , let @xmath771 and @xmath772 .",
    "then , @xmath28 is a dynamic answer set of @xmath16 iff , for every literal @xmath773 , one of the following conditions holds :    * for every rule @xmath8 in @xmath143 such that @xmath774 , @xmath768 .",
    "* there exists a path @xmath731 in @xmath775 rooted at @xmath776 , such that @xmath742 is acyclic .",
    "see @xcite .",
    "theorem  [ prop : graph - cond ] and theorem [ theo : elp - graph - cond ] allow us to identify classes of update programs for which update answer sets and dynamic stable models coincide .",
    "if , for example , a cyclic path rooted at @xmath761 depends on @xmath22 , then a reduction of the graph with respect to an answer set will break it open since an answer set either contains @xmath22 , or not . also , if the graph associated with an update sequence does not contain any cyclic paths rooted at weakly negated literals , then the second condition of theorem  [ prop : graph - cond ] is always fulfilled .",
    "let @xmath745 be a sequence of glps over @xmath18 .",
    "if every cyclic path rooted at @xmath761 in @xmath758 also contains node @xmath22 , then there is a one - to - one correspondence between answer sets of @xmath665 and dynamic stable models of @xmath16 . in particular",
    ", this holds if @xmath758 does not contain any cyclic path rooted at a @xmath761 node .",
    "this corollary can further be specialized to a condition which can be checked efficiently ( namely in @xmath777 time , where @xmath778 denotes the size of @xmath16 ) .    [",
    "coll : eff - graph - cond ] let @xmath779 be a sequence of glps over @xmath18 and let @xmath780 be the union of the graphs for all paths @xmath731 in @xmath758 .",
    "suppose that , for every node @xmath781 in @xmath782 , it holds that every cycle containing @xmath761 also contains @xmath22 .",
    "then , there is a one - to - one correspondence between answer sets of @xmath665 and dynamic stable models of @xmath16 .",
    "[ example : tv_glp ] consider the following sequence @xmath449 of glps , taken from  @xcite : @xmath783    there are only two @xmath761 nodes in @xmath782 with outgoing edges , namely @xmath784 and @xmath785 .",
    "both are connected with a single rule node : the former with @xmath786 , and the latter with @xmath428 , which is a terminal node .",
    "node @xmath786 has a single edge leading to @xmath787 , which is in turn connected with a single rule node , namely @xmath788 , a terminal node .",
    "thus , there does not exist a cycle in @xmath782 containing @xmath761 .",
    "hence , update answer sets of @xmath665 and dynamic stable models of @xmath16 coincide ( modulo the different language ) .",
    "in fact , @xmath16 has the single dynamic stable model @xmath789 which corresponds to the single update answer set of @xmath665 , given by : @xmath790    having dealt with aspects of equivalence between dynamic stable models and update answer sets , let us now discuss their differences . recalling the update sequence @xmath417 and @xmath716 from example  [ example : not_if_not ]",
    ", the single dynamic stable model @xmath714 of @xmath16 seems , in the sense of inertia , more intuitive than the answer set @xmath715 of @xmath791 because the tautological update information @xmath792 is quite irrelevant to the fact that it is raining , as given by @xmath793 so , in some sense , the semantics of alferes _",
    "_   eliminates unintended stable models , as it does not allow for cyclic derivations of negative information .",
    "however , the rewritten rule of @xmath794 differs in that it allows to conclude that it is not raining given that there is no information whether it is raining . in this sense",
    ", both answer sets @xmath714 and @xmath715 are , in principle , reasonable . observing that the more intuitive answer set of @xmath143 is minimal while the other is not , one can use the notion of minimality to filter out the unintended answer set .",
    "but , in general , there exist dynamic stable models such that the corresponding answer sets are not minimal ( or strictly minimal ) and vice versa .",
    "also , acyclic derivations of negative information do not always capture the intuition of inertia as shown by the following example :    [ example : nota_if_notb ] let us consider a slight modification of example [ example : not_if_not ] , where the knowledge base @xmath795 is updated by the information @xmath796 which , by the same intuition of inertia , is also irrelevant to the fact that it is now actually raining and thus cloudy .",
    "however , this yields two dynamic stable models @xmath797 corresponding to the answer sets @xmath798 of the rewritten elp , here , the intuitively preferred answer set is also a minimal answer set , while the other is not . ] , showing that also the mechanisms enacted in dynlp do not completely avoid cyclic derivations .    despite their differences , the general properties of program updates , as investigated in section  [ sec : properties ] , hold for dynamic logic programs also . by virtue of theorem  [ theo : elp - graph - cond ] and corollary",
    "[ coll : eff - graph - cond ] , one can easily verify that every counterexample for an invalid property belongs to a class where update answer sets and dynamic stable models coincide .",
    "as well , arguments similar to those used for the demonstrations of the valid properties of section  [ sec : properties ] can be found in order to show that these properties also hold for dynamic logic programs .",
    "the use of abduction for solving update problems in logic programming and databases goes back to @xcite .",
    "taking advantage of their framework of _ extended abduction _",
    "@xcite , inoue and sakama integrated three different types of updates into a single framework , namely _ view update _ , _ theory update _ , and _ inconsistency removal_. in particular , view update deals with the problem of changing _ extensional facts _ ( which do not occur in the heads of rules ) , whilst theory update covers the general case in which ( a set of ) rules should be incorporated into a knowledge base .",
    "we discuss the latter problem here .",
    "informally , for elps @xmath80 and @xmath81 , an update of @xmath80 by @xmath81 is a largest program @xmath100 such that @xmath799 holds and where @xmath100 is consistent ( i.e. ,  @xmath100 has a consistent answer set ) .",
    "this intuition is formally captured by reducing the problem of updating @xmath80 with @xmath81 to computing a minimal set of abducible rules @xmath800 such that @xmath801 is consistent . in technical terms of @xcite , the program @xmath802 is considered for abduction where the rules in @xmath803 are abducible , and the intended update",
    "is realized via a minimal _ anti - explanation _ for falsity , which removes abducible rules to restore consistency .    while this looks similar to our minimal updates",
    ", there is , however , a salient difference : abductive update does not respect _ causal rejection_. that is , a rule @xmath8 from @xmath804 may be rejected even if no rule @xmath9 in @xmath81 fires whose head contradicts the application of @xmath8 .",
    "for example , consider @xmath805 and @xmath806 . both @xmath80 and @xmath81 have consistent answer sets , but @xmath350 has no ( consistent ) answer set because no rule in @xmath80 is rejected and thus both rules must fire . on the other hand , in inoue and sakama s approach , one of the two rules in @xmath80",
    "will be removed .",
    "furthermore , inconsistency removal in a program @xmath47 occurs in this framework as special case of updating ( take , e.g. ,  @xmath365 and @xmath807 ) .    from a computational point of view , abductive updates are ",
    "due to inherent minimality criteria  harder than update programs ; in particular , some abductive reasoning problems are shown to be @xmath453-complete @xcite .",
    "zhang and foo   described an approach for updating logic programs based on their preference - handling framework for logic programs introduced in  @xcite .",
    "the general approach is rather involved and proceeds in two stages , roughly described as follows . for updating @xmath80 with @xmath81 , in the first stage , each answer set @xmath28 of @xmath80 is updated to a `` closest '' answer set @xmath134 of @xmath81 , where distance is measured in terms of the set of atoms for which @xmath28 and @xmath134 have different truth values , and closeness is set inclusion",
    "then , a maximal set of rules @xmath808 is chosen in such a way that @xmath809 has an answer set containing @xmath134 . in the second stage , @xmath148 is viewed as a prioritized logic program in which rules from @xmath81 have higher priority than rules from @xmath76 , and its answer sets are computed .",
    "the resulting answer sets are identified as the answer sets of the update of @xmath80 with @xmath81 .",
    "this approach is apparently different from our update framework .",
    "in fact , it is in the spirit of winslett s   _ possible models approach _ , where the models of a propositional theory are updated separately and which satisfies update postulate ( u8 ) .",
    "more specifically , the two stages in zhang and foo s approach respectively aim at removing contradictory rules from @xmath80 and resolving conflicts between the remaining rules of @xmath81 .",
    "however , like in inoue and sakama s approach , rules are not removed on the basis of causal rejection . in particular , on the example considered in  @xcite , both approaches yield the same result .",
    "the second stage of the procedure indicates a strong update flavor of the approach , since rules are unnecessarily abandoned .",
    "for example , the update of @xmath810 with @xmath811 results in @xmath81 , even though @xmath812 is consistent . since",
    ", in general , the result of an update is given by a set of programs , naive handling of sequences of updates consumes exponential space in general .",
    "since the underlying conflict - resolution strategy of many update formalisms , including the current one , is to associate , in some sense , `` higher preference '' to new pieces of information , as final installment of our discussion on related work , we briefly review the approach of delgrande _ et al . _ to preference handling in logic programming , which is also based on a transformational principle .    to begin with ,",
    "_ define an _ ordered logic program _ as an elp in which rules are named by unique terms and in which preferences among rules are given by a new set of atoms of the form @xmath813 , where @xmath814 and @xmath815 are names .",
    "thus , preferences among rules are encoded at the _ object - level_. an ordered logic program is transformed into a second , regular elp wherein the preferences are respected , in the sense that the answer sets obtained in the transformed theory correspond to the preferred answer sets of the original theory .",
    "the approach is sufficiently general to allow the specification of preferences among preferences , preferences holding in a particular context , and preferences holding by default .",
    "the encoding of ordered logic programs into standard elps is realized by means of dedicated atoms , which control the applicability of rules with respect to the intended order .",
    "more specifically , if rule @xmath8 has preference over rule @xmath9 , the control elements ensure that @xmath8 is considered before @xmath9 , in the sense that , for a given answer set @xmath28 , rule @xmath8 is known to be applied or defeated _ ahead of _ @xmath9 .",
    "this control mechanism is more strict than the rejection principle realized in definition  [ def : update - program ] .",
    "for instance , in the preference approach , it may happen that no answer set exists because the applicability of a higher - ranked rule depends on the applicability of a lower - ranked rule , effectively resulting in a circular situation which can not be resolved in a consistent manner .",
    "on the other hand , this is not necessarily the case in the current update framework , where newer rules may only be applicable given older pieces of information .",
    "so , in order to simulate updates within the framework of @xcite , under the proviso that newer information has preference over older information , it is necessary to relax the conditions which enable successive rule applications .",
    "in this paper , we considered a formalization of an approach to sequences of logic program updates based on a causal rejection principle for rules , which is inherent to other approaches as well .",
    "we provided , in the spirit of dynamic logic programming  @xcite , a definition of the semantics of sequences @xmath16 of elps in terms of a simple transformation to update programs , @xmath126 , which are ordinary elps , and described a declarative semantical characterization as well .",
    "then , as a main novel contribution , we investigated the properties of this approach and of similar ones from the perspective of belief revision and nonmonotonic reasoning , based on the given characterization .",
    "for this purpose , we considered different possibilities of interpreting update programs as theory change operators and abstract nonmonotonic consequence operators , respectively .",
    "our main findings on this aspect were that many of the postulates and principles from these areas are not satisfied by update programs .",
    "we then have introduced further properties , including an iterativity property , and evaluated them on update programs .    motivated by an apparent lack of minimality of change , we then considered refinements of the semantics in terms of minimal and strictly minimal answer sets , and discussed their complexity and implementation .",
    "furthermore , we compared the current proposal to other related approaches , and found that it is semantically equivalent to a fragment of inheritance logic programs as defined by buccafurri _",
    "moreover , our approach coincides on certain classes with dynamic logic programming , which has been introduced by alferes _",
    "_  . for the latter correspondence results , we provided exact characterizations in terms of graph - theoretical conditions . in view of these results ,",
    "our discussion on general principles of update sequences based on causal rejection applies for these formalisms as well .",
    "several issues remain for further work .",
    "an interesting point concerns the formulation of postulates for update operators on logic programs and , more generally , on nonmonotonic theories . as we have seen , several postulates from the area of logical theory change fail for update programs ( cf .",
    "@xcite for related observations on this topic ) .",
    "this may partly be explained by the nonmonotonicity of answer sets semantics , and by the dominant role of syntax for update embodied by causal rejection of rules . however , similar features are not exceptional in the context of logic programming . therefore , it would be interesting to consider further postulates and desiderata for updating logic programs besides the ones we analyzed here , as well as an agm style characterization of update operators compliant with them .",
    "this issue seems to be rather demanding , though , and we might speculate  without further evidence  that it will be difficult to find a general acceptable set of postulates which go beyond `` obvious '' properties .",
    "a natural issue for update logic programs is the inverse of addition , i.e. ,  retraction of rules from a logic program .",
    "dynamic logic programming evolved into lups  @xcite , which is a language for specifying update behavior in terms of conditional addition and retraction of sets of rules to a logic program .",
    "lups is generic , however , as in principle different approaches to updating logic programs could provide the underlying semantical basis for the single update steps . exploring properties of the general framework , as well as of particular instantiations , and reasoning about update programs describing the behavior of agents programmed in lups or in other similar languages is topic of ongoing research .    finally ,",
    "building real - life applications , like intelligent information agents whose rational component is modeled by a knowledge base , which is in turn maintained using update logic programs , is an interesting issue for further research .",
    "the integration of reasoning components into agent architectures amenable to logic programming methods , such as the one of the impact agent platform  @xcite , is an important next step in order to make the techniques available to agent developers .",
    "this is also part of our current research .",
    "the authors would like to thank the anonymous referees and michael gelfond for their comments , which helped improving the paper , as well as jos julio alferes , joo alexandre leite , and lus moniz pereira for their useful remarks and corrections .",
    "this work was supported by the austrian science fund ( fwf ) under grants p13871-inf and n  z29-inf .",
    "[ appendix ]",
    "consider the answer sets @xmath821 of @xmath126 and assume that @xmath822 .",
    "we show by induction on @xmath178 ( @xmath823 ) that @xmath824 and @xmath825 . from this , and given the relation @xmath826 ( by the assumption @xmath822 ) , it follows that @xmath157 .    induction base .",
    "assume @xmath182 .",
    "first of all , it is quite obvious that @xmath827 .",
    "consider now some @xmath828 . according to the construction of the transformation @xmath126 , the literal @xmath131",
    "can only be derived by some rule @xmath829 , where @xmath184 . since @xmath827",
    ", it follows that @xmath830 must be a member of both @xmath831 and @xmath832 . since @xmath833 and @xmath826",
    ", we have @xmath213 iff @xmath834 .",
    "thus , @xmath835 iff @xmath836 .",
    "this implies @xmath837 .",
    "induction step .",
    "assume @xmath838 , and let the assertions @xmath839 and @xmath840 hold for all @xmath186 .",
    "we show that they hold for @xmath187 as well .",
    "consider some atom @xmath102 where @xmath181 .",
    "given the transformation @xmath126 , the atom @xmath102 can only be derived by means of rule @xmath841 . since @xmath842 and @xmath826 , it holds that @xmath843 .",
    "hence , @xmath844 is in @xmath831 iff it is in @xmath832 . by induction hypothesis , @xmath845 iff @xmath846 .",
    "since we also have that @xmath213 iff @xmath834 , it follows that @xmath847 iff @xmath848 , and so @xmath825 .",
    "consider now some literal @xmath849 .",
    "this literal can only be derived by means of rule @xmath850 , or by a rule of the form @xmath851 , for some @xmath181 .",
    "if @xmath852 is derived by @xmath850 , it follows immediately from the induction hypothesis that @xmath853 iff @xmath854 .",
    "so assume now that the second case applies .",
    "since we already know that @xmath825 , and since @xmath843 , we have that @xmath855 lies in @xmath831 iff it lies in @xmath832 . again using the property that @xmath213 iff @xmath834 , we obtain that @xmath853 iff @xmath854 . combining the two cases , and",
    "since the literal @xmath131 was arbitrarily chosen , it follows that @xmath824 .",
    "let @xmath158 be the uniquely determined answer set of @xmath135 such that @xmath856 .",
    "consider some @xmath857 .",
    "we first assume that @xmath8 is a constraint .",
    "so , @xmath858 .",
    "since @xmath215 , @xmath842 , and @xmath859 , we have @xmath860 .",
    "hence , @xmath861 , since @xmath158 is an answer set of @xmath126 and @xmath862 .",
    "it follows that @xmath58 is true in @xmath28 .",
    "let us now consider the case when @xmath8 is not a constraint .",
    "then , there is some @xmath108 , @xmath109 , such that @xmath707 and @xmath863 .",
    "we must show that @xmath864 whenever @xmath213 . by construction of the update program @xmath126",
    ", @xmath8 induces some rule @xmath865 , where @xmath194 .",
    "we claim that @xmath866 is not defeated by @xmath158 .",
    "first of all , since @xmath215 , it follows that @xmath867 , as argued above .",
    "furthermore , since @xmath863 , lemma  [ lemma : rejection - atoms ] implies @xmath183 .",
    "this proves the claim .",
    "thus , @xmath868 . consequently , assuming @xmath213 , it holds that @xmath869 , since @xmath158 is an answer set of @xmath126 and @xmath859 .",
    "moreover , since @xmath870 contains the inertia rules @xmath871 ( @xmath872 ) and @xmath164 , it follows that @xmath873 . by observing that @xmath874",
    ", @xmath875 follows , which implies that @xmath58 is true in @xmath28 .",
    "this concludes the proof that @xmath28 is a model of @xmath227 .",
    "it remains to show that @xmath28 is a minimal model of @xmath227 .",
    "assume that @xmath589 is a model of @xmath227 .",
    "consider the set @xmath876 it is easy to show that @xmath877 is a model of @xmath870 .",
    "moreover , @xmath878 .",
    "we arrive at a contradiction , because @xmath158 is assumed to be an answer set of @xmath126 . as a consequence",
    ", @xmath28 must be a minimal model of @xmath227 .",
    "this concludes the proof that @xmath28 is a minimal model of @xmath227 whenever @xmath28 is an answer set of  @xmath16 .    _ if part .",
    "_ assume that @xmath28 is a minimal model of @xmath227 .",
    "define @xmath879 as follows : @xmath880 we show that @xmath517 is an answer set of @xmath135 . since @xmath881 , this will imply that @xmath28 is an answer set of @xmath16 .",
    "\\(i ) @xmath8 is a constraint .",
    "then , @xmath884 . otherwise , we would have @xmath213 and @xmath885 ( since @xmath886 , @xmath887 , and @xmath888 ) , violating the condition that @xmath28 is a model of @xmath227 .",
    "thus , @xmath58 is true in @xmath517 .",
    "\\(ii ) @xmath8 is a rule of form @xmath889 , where @xmath890 . since @xmath883 ,",
    "@xmath58 is not defeated by @xmath517 and @xmath891 . according to the definition of @xmath517",
    ", the latter condition implies that @xmath249 . since @xmath892",
    ", it holds that @xmath893 , so @xmath894 .",
    "assume @xmath895 . since @xmath886 and @xmath896 , we get @xmath217",
    ". moreover , since @xmath8 is not defeated by @xmath517 , the definition of @xmath517 implies that @xmath897 .",
    "this shows that @xmath58 is true in @xmath517 .",
    "\\(iii ) @xmath8 is a rule of form @xmath898 , where @xmath893 and @xmath890 .",
    "assume @xmath899 .",
    "hence , @xmath900 . by definition of @xmath517",
    ", this implies that there is some rule @xmath901 , @xmath902 , such that @xmath903 , @xmath904 , and @xmath905 is not defeated by @xmath28 .",
    "since @xmath906 , it follows immediately that @xmath907 , which in turn implies @xmath908 , by definition of @xmath517 , proving that @xmath58 is true in @xmath517 .",
    "\\(v ) @xmath8 is a rule of form @xmath164 .",
    "if @xmath909 , then there is some @xmath910 such that @xmath911 , @xmath912 , and @xmath9 is not defeated by @xmath28 .",
    "since @xmath28 is a model of @xmath592 , it follows that @xmath913 .",
    "thus , @xmath8 is true in @xmath517 .",
    "this concludes the proof that @xmath517 is a model of @xmath882 .",
    "we proceed by showing that @xmath517 is a minimal model of @xmath882 .",
    "suppose @xmath877 is a model of @xmath882 such that @xmath914 .",
    "we show that this implies @xmath915 , a contradiction .",
    "hence , @xmath517 must be minimal .",
    "let us first assume that @xmath916 , i.e. , @xmath877 is smaller on the literals in @xmath30 . then , for some @xmath917 , no rule @xmath918 with @xmath892 fires in @xmath877 , i.e. , @xmath919 .",
    "hence , by definition of @xmath517 and @xmath920 , there is no @xmath921 such that @xmath922 and @xmath217 .",
    "consequently , @xmath923 satisfies all rules in @xmath924 .",
    "this , however , contradicts the fact that @xmath28 is a minimal model of @xmath925 .",
    "it follows that @xmath926 holds .",
    "now consider any @xmath927 .",
    "then , there is a rule @xmath928 , @xmath929 , such that @xmath213 and @xmath8 is not defeated by @xmath28 . according to the definition of @xmath126 , and by lemma  [ lemma : rejection - atoms ] ,",
    "rule @xmath8 introduces a rule @xmath930 . since @xmath931 and @xmath932",
    ", it follows that @xmath933 , by the assumption that @xmath877 is a model of @xmath934 .",
    "moreover , since @xmath935 , the inertia rules @xmath936 ( @xmath937 ) imply @xmath938 .    finally , consider @xmath939 , where @xmath118 . by the definitions of @xmath174 and @xmath517",
    ", it follows that @xmath213 , @xmath215 , and @xmath940 . from the above considerations , @xmath940 implies @xmath941 .",
    "moreover , @xmath942 .",
    "so , @xmath943 . since @xmath877 is a model of @xmath882 , and given the fact that @xmath944 , we obtain @xmath945 .",
    "this concludes the proof that @xmath915 .",
    "this postulate states that no change occurs if the update is already entailed .",
    "this means that inconsistency is preserved under updates and contradictions can not be removed by updates .",
    "this is clearly not the case : updating @xmath950 with @xmath951 removes inconsistency . also for a consistent @xmath16 , update by a logically implied rule may lead to a change in semantics .",
    "consider , e.g. , @xmath952 and @xmath953 .",
    "then @xmath16 has the unique answer set @xmath954 , and @xmath955 .",
    "however , @xmath341 has , besides @xmath28 , another answer set @xmath956 .",
    "this property fails in general , if programs have infinite alphabets .",
    "this can be seen by the following example .",
    "let @xmath958 and @xmath959 , where @xmath960 it is easy to see that every answer set @xmath28 of @xmath80 must contain @xmath961 , and that either @xmath962 or @xmath963 ( but not both ) are contained in @xmath28 .",
    "therefore , @xmath964 holds .",
    "furthermore , @xmath965 is an answer set of @xmath138 . since @xmath966",
    ", it follows that @xmath134 is an answer set of @xmath967 .",
    "this implies @xmath968 , i.e. , @xmath969 does not contain all possible rules .    on the other hand , @xmath970 : since negation does not occur in rule heads of @xmath80 and @xmath81 , we have @xmath971 , and thus @xmath972 holds .",
    "however , @xmath973 clearly has no answer set , which implies @xmath974 .",
    "it follows that @xmath975 , which proves our claim .            the property is violated .",
    "consider @xmath980 , @xmath981 , @xmath982 and @xmath983 .",
    "as easily seen , the sequence @xmath350 has two answer sets , @xmath984 and @xmath985 . on the other hand , since @xmath986",
    ", @xmath28 can not be an answer set of @xmath987 ; in fact , @xmath134 is its unique answer set . since , e.g. ,  @xmath988 whilst @xmath989 , it follows that @xmath990 .",
    "this is violated , since contradictory rules in @xmath16 are not affected unless they are rejected by rules in @xmath47 .",
    "for instance , if @xmath16 consists of the single program @xmath991 , @xmath992 , then the update of @xmath16 by @xmath993 does not have an answer set .",
    "this expresses _ irrelevance of syntax _ which is clearly not satisfied , since rejection of rules depends on their syntactical form . for instances ,",
    "take @xmath997 , @xmath959 , and @xmath998 , where @xmath999 then clearly @xmath1000 and @xmath1001 , but the resulting updates have different answer sets : @xmath1002 is an answer set of @xmath350 but not of @xmath1003 .",
    "the property does not hold if both @xmath16 and @xmath100 ( or @xmath47 and @xmath100 ) have infinite alphabets , which follows from the example showing the failure of ( k3 ) ( set @xmath1005 , and exploit the relation @xmath1006 ) .",
    "consider @xmath1011 , and let @xmath1012 denote the atoms in @xmath143 .",
    "then , for every finite set of atoms @xmath1013 , there must exist some answer set @xmath1014 of @xmath143 such that @xmath28 and @xmath1014 coincide with respect to @xmath1015 .",
    "indeed , @xmath1016 must contain , for each interpretation @xmath477 which does not coincide with any answer set of @xmath143 with respect to @xmath1015 , the constraint @xmath1017 , where @xmath1018 and @xmath1019 , respectively .",
    "furthermore , all answer sets of @xmath1020 must coincide on the atoms in @xmath1021 .",
    "thus , assuming that either @xmath143 or @xmath100 has a finite alphabet , it follows that @xmath28 is an answer set of @xmath143 or @xmath100 . without loss of generality , we assume that @xmath28 is an answer set of @xmath143 .    hence , theorem  [ theo : sequence - char-0 ] implies that @xmath28 is a minimal model of @xmath1022 . since @xmath1023",
    ", we conclude that @xmath28 is also a minimal model of @xmath1024 .",
    "furthermore , for the update sequence @xmath1025 , it holds that @xmath1026 . indeed , @xmath1027 for all @xmath1028 , thus @xmath1029 and @xmath1030 .",
    "equivalence for the rules in @xmath16 can be shown by induction on the length of @xmath16 .",
    "hence , we obtain that @xmath28 is a minimal model of @xmath1031 . from theorem  [ theo : sequence - char-0 ] , we obtain that @xmath28 is an answer set of @xmath1032 . since @xmath1010",
    ", it follows @xmath1033 , a contradiction .",
    "this postulate fails .",
    "consider , e.g. ,  @xmath958 , @xmath959 , and @xmath1037 , where @xmath1038 then , @xmath1039 is the unique answer set of @xmath350 , and @xmath1040 is the unique answer set of @xmath1041 .",
    "moreover , it is easily verified that @xmath1042 , for any answer set @xmath28 of @xmath81 and any answer set @xmath134 of @xmath148 .",
    "hence , @xmath1043 and @xmath1044 .",
    "however , @xmath1045 .            adding rules which are implied after the previous update does not change the epistemic state .",
    "this is not satisfied : take , e.g. ,  @xmath1051 , @xmath1052 , and @xmath1053 .",
    "then @xmath1054 has two answer sets , while @xmath341 has a single answer set .",
    "the associated belief sets are thus different .",
    "this property is not satisfied . for a counterexample ,",
    "consider @xmath1058 , @xmath1059 , and @xmath1060 .",
    "then @xmath14 has two answer sets , @xmath1061 and @xmath1062 , whilst @xmath1041 possesses the single answer set @xmath1062 .",
    "implied rules can be added before the update .",
    "this property fails in general .",
    "for example , let @xmath160 , @xmath959 , and @xmath1037 , where @xmath1065 note that @xmath81 has a single answer set , @xmath1066 , and clearly @xmath1067 .",
    "however , @xmath1068 has among its answer sets @xmath1069 , and @xmath1070 .",
    "the property holds , however , providing @xmath100 contains a single rule .",
    "suppose @xmath1063 but @xmath1071 , for @xmath1072 .",
    "then , @xmath1073 for some answer set @xmath28 of @xmath1054 .",
    "this means , however , that @xmath28 is an answer set of @xmath341 ( as @xmath8 can not reject any rule in @xmath16 ) .",
    "thus , @xmath1074 .",
    "this property holds . by hypothesis",
    ", there exists some @xmath1075 such that @xmath1076 . by theorem  [ theo : sequence - char-0 ]",
    ", @xmath28 is a minimal model of @xmath1078 since @xmath1076 and @xmath1079 ( due to @xmath1075 ) , no rule @xmath1080 can be rejected by a rule @xmath8 of @xmath47 .",
    "also , @xmath9 can reject a rule @xmath905 in @xmath47 only if @xmath905 is rejected within @xmath47 .",
    "thus , @xmath1081 , and @xmath28 is a minimal model of @xmath1082 this means , by theorem  [ theo : sequence - char-0 ] , that @xmath28 is an answer set of @xmath1054 .",
    "this property fails as well , which can be seen by the counterexample for ( c5 ) , setting @xmath1093 .",
    "another counterexample for ( c6)which does not exploit minimization of answer sets  is @xmath1094 , @xmath1095 , and @xmath1089 .",
    "this property holds .",
    "suppose there is some @xmath419 such that @xmath1098 but @xmath1099 .",
    "let @xmath1100 .",
    "then , the following holds : for every rule @xmath8 in @xmath143 , @xmath1101 iff @xmath1102 .",
    "indeed , each @xmath114 ( @xmath109 ) is neither in @xmath1103 nor in @xmath174 . by theorem  [ theo : sequence - char-0 ]",
    ", @xmath28 is a minimal model of @xmath1104 .",
    "it follows that @xmath28 is a minimal model of @xmath1105 , which in turn implies , by using theorem  [ theo : sequence - char-0 ] again , that @xmath1106 .",
    "since @xmath1099 , we obtain @xmath1107 .",
    "the property fails : let @xmath1116 , @xmath1117 , and @xmath1118 .",
    "then , @xmath1119 is an answer set of @xmath1120 such that @xmath1121 .",
    "however , @xmath1122 has two answer sets , @xmath1123 and @xmath1124 , whilst @xmath1125 has the single answer set @xmath1126 .",
    "the property holds .",
    "let @xmath1131 and @xmath1132 .",
    "assume @xmath1133 and @xmath1134 , and consider some answer set @xmath28 of @xmath143 .",
    "then , @xmath1135 .",
    "moreover , @xmath158 is an answer set of @xmath1136 . since @xmath1133",
    ", it follows that for each rule @xmath1137 rejecting a rule @xmath8 from @xmath16 , there exists a rule @xmath1138 also rejecting @xmath8 .",
    "hence , no further rule in @xmath16 can be rejected using @xmath76 .",
    "let @xmath1139 .",
    "then , @xmath158 is an answer set of @xmath1140 , so @xmath28 is an answer set of @xmath1141 .",
    "since @xmath1142 , we obtain @xmath1143 .",
    "this proves the property .",
    "alferes , j.j . , & pereira , l.m .",
    "( 1997 ) . .",
    "dix , j. , pereira , l.m . , & przymusinski , t.c .",
    "( eds ) , _ selected papers from the iclp96 workshop on nonmonotonic extensions of logic programming @xmath343nmelp96@xmath344_. , vol .",
    "1216 . .",
    "alferes , j.j .",
    ", & pereira , l.m .",
    "( 2000 ) . .",
    "aciego , m.o . , de  guzmn , i.p . , brewka , g. , & pereira , l.m .",
    "( eds ) , _ proc .",
    "seventh europ .",
    "workshop on logic in artificial intelligence @xmath343jelia 2000@xmath344_. , vol .",
    "1919 . .",
    "alferes , j.j . , leite , j.a . ,",
    "pereira , l.m .",
    ", przymusinska , h. , & przymusinski , t.c .",
    "( 1998 ) . .",
    "cohn , a. , schubert , l. , & shapiro , c. ( eds ) , _ proc .",
    "sixth int .",
    "conf .  on principles of knowledge representation and reasoning @xmath343kr98@xmath344_. .",
    "alferes , j.j . , pereira , l.m . , przymusinska , h. , & przymusinski , t.c .",
    "( 1999 ) . .",
    "gelfond , m. , leone , n. , & pfeifer , g. ( eds ) , _ proc .",
    "fifth int .",
    "conf .  on logic programming and nonmonotonic reasoning @xmath343lpnmr99@xmath344_. , vol .",
    "1730 . .",
    "brewka , g. ( 2000 ) . .",
    "horn , w. ( ed ) , _ proc .",
    "fourteenth europ .",
    "conf .  on artificial intelligence",
    "@xmath343ecai 2000@xmath344_. .",
    "preliminary version presented at intl .",
    "workshop on nonmonotonic reasoning , breckenridge , 2000 .",
    "url : http://arxiv.org/abs/cs.ai/0003036 .",
    "cholewiski , p. , marek , v.w . , & truszczyski , m. ( 1996 ) . .",
    "carlucci aiello , l. , doyle , j. , & shapiro , s. ( eds ) _ proc .",
    "fifth int .",
    "conf .  on principles of knowledge representation and reasoning ( kr 96)_. .",
    "eiter , t. , leone , n. , mateis , c. , pfeifer , g. , & scarecello , f. ( 1997a ) . .",
    "dix , j. , furbach , u. , & nerode , a. ( eds ) , _ proc .",
    "fourth int .",
    "conf .  on logic programming and nonmonotonic reasoning @xmath343lpnmr97@xmath344_. , vol .",
    "1265 . .",
    "eiter , t. , fink , m. , sabbatini , g. , & tompits , h. ( 2000 ) . .",
    "aciego , m.o . ,",
    "de  guzmn , i.p . ,",
    "brewka , g. , & pereira , l.m .",
    "( eds ) , _ proc .",
    "seventh europ .",
    "workshop on logic in artificial intelligence @xmath343jelia 2000@xmath344_. , vol .",
    "1919 . .",
    "eiter , t. , leone , n. , mateis , c. , pfeifer , g. , & scarcello , f. ( 1998 ) .",
    "cohn , a. , schubert , l. , & shapiro , s. ( eds ) , _ proc .",
    "sixth int .",
    "conf .  on principles of knowledge representation and reasoning ( kr98)_. .",
    "inoue , k. ( 2000 ) . .",
    "lloyd , j.w . , dahl , v. , furbach , u. , kerber , m. , lau , k.k .",
    ", palmidessi , c. , pereira , l.m . ,",
    "sagiv , y. , & stuckey , p.j .",
    "( eds ) , _ proc .",
    "first int .",
    "conf .  on computational logic @xmath343cl 2000@xmath344_. , vol .",
    "1861 . .",
    "leite , j.a .",
    ", & pereira , l.m .",
    "( 1997 ) . .",
    "dix , j. , pereira , l.m . , & przymusinski , t.c .",
    "( eds ) , _ logic programming and knowledge representation , selected papers of the third int .",
    "workshop @xmath343lpkr97@xmath344_. , vol .",
    "rao , p. , sagonas , k.f . ,",
    "swift , t. , warren , d.s . , & freire , j. ( 1997 ) . .",
    "dix , j. , furbach , u. , & nerode , a. ( eds ) _ proc .",
    "fourth int .",
    "conf .  on logic programming and non - monotonic reasoning ( lpnmr97)_. , vol ."
  ],
  "abstract_text": [
    "<S> in this paper , we consider an approach to update nonmonotonic knowledge bases represented as extended logic programs under the answer set semantics . in this approach </S>",
    "<S> , new information is incorporated into the current knowledge base subject to a causal rejection principle , which enforces that , in case of conflicts between rules , more recent rules are preferred and older rules are overridden . </S>",
    "<S> such a rejection principle is also exploited in other approaches to update logic programs , notably in the method of dynamic logic programming , due to alferes _ </S>",
    "<S> et al . _    </S>",
    "<S> one of the central issues of this paper is a thorough analysis of various properties of the current approach , in order to get a better understanding of the inherent causal rejection principle . for this purpose , we review postulates and principles for update and revision operators which have been proposed in the area of theory change and nonmonotonic reasoning . </S>",
    "<S> moreover , some new properties for approaches to updating logic programs are considered as well . </S>",
    "<S> like related update approaches , the current semantics does not incorporate a notion of _ minimality of change _ , so we consider refinements of the semantics in this direction . as well , we investigate the relationship of our approach to others in more detail . in particular , we show that the current approach is semantically equivalent to inheritance programs , which have been independently defined by buccafurri _ </S>",
    "<S> et al . _ , and that it coincides with certain classes of dynamic logic programs , for which we provide characterizations in terms of graph conditions . in view of this analysis , </S>",
    "<S> most of our results about properties of the causal rejection principle apply to each of these approaches as well . </S>",
    "<S> finally , we also deal with computational issues . besides a discussion on the computational complexity of our approach </S>",
    "<S> , we outline how the update semantics and its refinements can be directly implemented on top of existing logic programming systems . in the present case </S>",
    "<S> , we implemented the update approach using the logic programming system ` dlv ` . </S>"
  ]
}