{
  "article_text": [
    "one of the frontiers in condensed matter systems is the realistic modeling of strongly - correlated materials .",
    "the combination of density functional theory ( dft ) , a workhorse for electronic structure calculations of weakly - correlated materials , with dynamical mean - field theory ( dmft ) @xcite , originally designed to handle strong correlations in simple models , has allowed insights into strongly - correlated compounds at a level of realism previously unobtainable .",
    "comparisons of momentum - resolved spectral functions , densities of states , and optics between theory and experiment are routine .",
    "lying at the core of this combined theory , named dft+dmft @xcite , is the solution of a generalized anderson impurity model . in the strongly - correlated regime ,",
    "the method of choice is the hybridization expansion continuous time quantum monte carlo ( ct - hyb)@xcite , a numerically exact algorithm capable of handling arbitrary local interactions on the impurity site , in particular , the full atomic coulomb potential needed to capture the @xmath0 and @xmath3 electron physics present in strongly - correlated materials .",
    "enhancements to the ct - hyb algorithm are important for bringing new physical regimes within the reach of current computational resources .    in the context of model hamiltonians ,",
    "ct - hyb is also commonly used as an impurity solver for cluster generalizations of dmft .",
    "@xcite ct - hyb is particularly useful in the strongly correlated case .",
    "@xcite     without lazy trace evaluation ) , the lazy trace evaluation ( sec .",
    "[ sec : lazy ] ) and the lazy skip lists ( sec .  [",
    "sec : lazyskiplista ] and sec .",
    "[ sec : lazyskiplistb ] ) , compared to a straightforward implementation ( sec .",
    "[ sec : symmetries ] ) as baseline . ]    here , we present optimizations based on skip lists@xcite and matrix bounds which result in a speedup of @xmath1 up to @xmath2 as compared to the straightforward implementation of ct - hyb ( see fig .  [",
    "fig : lnofespeedup ] ) .",
    "these speedups are obtained for two very different test cases where the materials contain correlated @xmath0 electrons . in the low - temperature and strongly - correlated regimes of interest ,",
    "the most computationally expensive step is the evaluation of the expectation value of a time - ordered sequence of ( possibly thousands of ) creation and annihilation operators acting on the impurity degrees of freedom , schematically notated as @xmath4 .",
    "when the complete basis of impurity states are inserted between each operator , the problem is transformed into ( the trace of ) a product of hundreds of matrices , called the impurity trace , which must be evaluated at each monte carlo step .",
    "our algorithm , which we dub `` lazy skip lists '' , optimizes the matrix product by combining the following two ideas .",
    "first , we take advantage of the fact that between subsequent monte carlo steps , the matrix product only changes by the insertion or removal of two operators , for example , @xmath5 in the case of insertion .",
    "we observe that the intermediate products @xmath6 and @xmath7 are unchanged .",
    "using skip lists , we efficiently store these intermediate products to minimize recomputation . historically , the expense of computing this matrix product led to optimizations , beginning with the left - right storage of intermediate products  @xcite .",
    "this algorithm was of order @xmath8 , where @xmath9 is the order in perturbation theory . in refs .   a faster binary - search - tree algorithm , scaling as @xmath10 was proposed .",
    "skip lists are statistically as efficient as binary trees ,  @xcite better match the structure of the impurity trace and are simpler to implement .",
    "second , we often can avoid performing the matrix product altogether by quickly rejecting proposed monte carlo moves via a `` lazy '' evaluation of the impurity trace .",
    "this implementation was first carried out in ref .   and",
    "already successfully used in ref .  .",
    "in normal monte carlo sampling , we compute an acceptance probability @xmath11 for a proposed move , then accept the move if @xmath12 , where @xmath13 is a number chosen randomly in @xmath14 $ ] . here , we do the opposite : we flip the metaphorical monte carlo coin to obtain @xmath13 first , then lazily refine bounds @xmath15 on the acceptance ratio until @xmath13 drops outside the bracketed interval .",
    "the bounding is fast , involving only scalar operations , and rapidly converges because the time - evolution operators in the time - ordered operator sequence often involve exponents which vary tremendously in magnitude .",
    "we begin by reviewing the ct - hyb algorithm in sec .",
    "[ sec : ctqmc ] , focusing on the aspects relevant to this work . in the next two sections ( sec .",
    "[ sec : skiplist ] and [ sec : lazy ] ) , we present independently the key algorithmic advancements , skip lists and lazy trace evalution , which are combined to form the final method in sec .  [",
    "sec : lazyskiplist ] .",
    "we benchmark our optimizations in sec .",
    "[ sec : results ] .",
    "the appendix explains how the trace can be bounded using matrix norms .",
    "in this section , we briefly summarize the key steps which generate the hybridization expansion formulation of impurity models .",
    "the goal is to quickly arrive at a description of the structure of the impurity trace imposed by the physics and to discuss what it implies for the monte carlo algorithm .",
    "a general impurity model consists of a local interacting system @xmath16 describing the impurity degrees of freedom , immersed in a non - interacting electronic bath : @xmath17 where @xmath18 is the bath dispersion and @xmath19 the amplitude for particles to hop from the impurity orbital @xmath20 to the bath orbital @xmath21 .",
    "the spin index is absorbed into the index @xmath20 .      in ct - hyb , we transform the partition function @xmath22 of the impurity model into a form amenable for monte carlo sampling ( described in detail in ref .  ) .",
    "one uses the interaction representation with the unperturbed hamiltonian the sum of the local and bath hamiltonians .",
    "the hybridization is the interaction term .",
    "then , we expand the resulting expression in powers of this hybridization term , giving @xmath23 where the integrand is @xmath24.\\end{gathered}\\ ] ] since the impurity and bath degrees of freedom are decoupled , the trace over the bath has been performed .",
    "the bath is contained in the determinant of a @xmath25 matrix @xmath26 with elements evaluated from the hybridization function @xmath27 whose matsubara definition is @xmath28 the average over the impurity @xmath29 in general can not be further decomposed .",
    "its evaluation requires converting the sequence of operators ( and intervening time - evolution operators ) into matrices in the basis of the impurity hilbert space @xmath30 .    the monte carlo sampling of eq .",
    "[ equ : partitionsum ] proceeds as follows : the integrands @xmath31 of the partition function sum define the weights of a distribution over the configuration space @xmath32 which is sampled with the metropolis - hastings algorithm . at each step ,",
    "a new configuration is proposed with probability @xmath33 and accepted with probability @xmath34 where @xmath31 and @xmath35 are the weights of the new and the old configuration respectively , and @xmath36 is the proposal probability of the inverse update .",
    "the bottleneck is that the weights @xmath31 , and the expensive impurity trace contained within , must be computed in order to decide whether to accept each new proposed configuration . in terms of computational effort ,",
    "if latexmath:[$n =    sitting at perturbation order @xmath9 , the impurity trace costs @xmath38 while the hybridization determinant costs @xmath39 ( which can be reduced to @xmath40 for local updates ) .",
    "the average expansion order @xmath41 , which is typically in the hundreds , is proportional to the inverse temperature @xmath42 , whereas the @xmath43 grows exponentially with the number of impurity orbitals ( @xmath44 for the @xmath0-shell ) .",
    "thus , except at very low temperatures , the calculation of the impurity trace is the bottleneck in these monte carlo simulations",
    ".    alluded to in the above discussion , the impurity trace contains a time - evolution operator between each creation and annihilation operator , which we denote by @xmath45 .",
    "we also write @xmath46 for the matrix representation of the creation and annihilation operator , where @xmath47 and @xmath48 index the states in @xmath30 . in this notation ,",
    "the impurity trace explicitly becomes an alternating matrix product : @xmath49 for simplicity , we have assumed that the imaginary times in eq .",
    "[ equ : weights ] are time - ordered as they appear .",
    "we can make a key simplification to the impurity trace using symmetries prior to developing computational algorithms @xcite .",
    "the local hamiltonian @xmath16 generally possesses abelian symmetries ( e.g. particle number , spin , momentum ) , which allow us to decompose the impurity hilbert space as a direct sum @xmath50 . here",
    ", @xmath51 enumerates the sectors of the hilbert space , each of which is characterized by a definite set of quantum numbers ( e.g. particle number , spin , momentum ) .    using these symmetries",
    "one defines a new basis for the creation - annihilation operators . a creation or annihilation operator , which we denote by a generalized index @xmath52 formed by combining its quantum numbers with the type of operator ( creation or annihilation ) , maps each sector @xmath51 either to 0 or uniquely to one other sector @xmath53 .",
    "this leads to block matrices @xmath54 which can be combined with a sector mapping function @xmath55  @xcite defined by @xmath56 .",
    "the time - evolution operator maps each sector onto itself .    in the sector basis ,",
    "the operator product in eq .  [ equ : operatorproduct ] becomes @xmath57 that maps a sector @xmath58 onto @xmath59 defined by the string @xmath60 .",
    "the impurity trace decomposes into a sum over sector traces , @xmath61 and only sectors @xmath58 which are not mapped on @xmath62 contribute . such mapping on @xmath62 generally occurs because of the pauli principle . in a typical 3@xmath0 impurity model with the full atomic coulomb interaction , the number of sectors is @xmath63 and the number of surviving strings ranges from 1 to @xmath64 .",
    "we first begin with a motivation for skip lists . then the skip list and the way it is used to store matrix sub - products is described .",
    "the final subsection explains how matrix multiplications can then be performed efficiently when operators are inserted or removed .      at each metropolis - hastings step , a matrix product needs to be computed to decide whether the proposed configuration is accepted or rejected .",
    "one possibility is to always calculate all the products from scratch .",
    "however , only two matrices are typically inserted or removed , so this strategy is not only expensive , but also highly redundant .    to avoid multiplying almost all the time the same matrices ,",
    "we may pair them off and store their product .",
    "this way almost every second multiplication is skipped when calculating the product of a proposed configuration . however",
    ", this is not yet optimal .",
    "one can store products of four , eight matrices etc .",
    "leading to a collection of sub - products that will allow us to minimize the number of redundant multiplications .",
    "this storage strategy may be represented as shown in fig .",
    "[ fig : balancedlist ] , where we omit the propagators for simplicity .     level stores the pair products , the @xmath65 their products and so on .",
    "lower panel : the matrix @xmath66 has been inserted in the matrix product of the top panel and the products with a bold red multiplication sign need to be calculated in order to obtain the total product . ]    the arrows store the sub - products of operators they span , including the operator they start from and excluding the operator they point to .    inserting now a matrix @xmath66 , some of the stored sub - products expire , as shown on the lower panel of fig .",
    "[ fig : balancedlist ] .",
    "these are the sub - products of arrows that span over the inserted matrix . to calculate the product of the proposed configuration , we begin with the arrow just above the inserted operator .",
    "this costs two multiplications , @xmath67 . moving up ,",
    "the next missing sub - product @xmath68 is calculated from the two sub - products below with one multiplication , and multiplying this sub - product with @xmath69 yields the total product . except at the first level ,",
    "this involves one matrix multiplication per level , as each arrow is the product of two arrows one level below . for 32 , 128 and 512 operators , a representation like that in fig .",
    "[ fig : balancedlist ] has 5 , 7 and 9 levels respectively , and the number of matrix multiplications is logarithmic in the number of operators in the product . however , this storage scheme works only if the expansion order is a power of two , and we have to find a strategy to maintain an equilibrated structure when inserting or removing matrices at random places .",
    "equilibrated means that a sub - product is ideally always the product of two sub - products one level below .    for simplicity",
    ", we ignore here the block structure of the operator matrices .",
    "their discussion is postponed to sec .",
    "[ sec : lazyskiplist ] .      in fig .",
    "[ fig : balancedlist ] , the heights of the vertical bars associated with the matrices organize the arrows , that is the sub - products .",
    "the original matrices are stored at level @xmath70 .",
    "there is an arrow starting and ending at the top end of each bar with level @xmath71 , except for the first bar on the right where no arrow ends .",
    "when inserting an operator , we are free to associate a bar to this operator at a height that we may choose .",
    "the choice of skip lists@xcite is to take a height @xmath72 that is determined randomly according to the distribution @xmath73 , that is , half of the bars are     and propagators @xmath74 .",
    "the arrows store the products they span over .",
    "the bold arrows in red and green show the path that is followed when a matrix is inserted at the place indicated by the red triangle .",
    "the products stored in the blue arrows are emptied if their tail coincides with that of the bold red arrows . ]    on average at least level one , a quarter at least level two , and so on .",
    "this keeps the skip list on average equilibrated .",
    "a typical arrangement is shown in fig .",
    "[ fig : skiplist ] . here",
    "we include the propagators , and an arrow stores the sub - product starting with the operator at its tail and ending with the propagator at its head .",
    "however , to include the first propagator @xmath74 appearing on the right , we need to store the product of @xmath74 with the identity matrix at the first bar . since the heights are chosen randomly , there is no guaranty that the height of that first bar exceeds all others as in fig .",
    "[ fig : balancedlist ] .",
    "hence we just assume that it is at a height that exceeds all others .    to calculate the product after insertion of one operator in this skip list , we can proceed as in fig .",
    "[ fig : balancedlist ] if the randomly chosen height of the associated bar is zero .",
    "this changes if the height is not zero .",
    "more importantly , two operators and sometimes more must be inserted or removed at once in monte - carlo simulations ,  @xcite whereas the product is needed at the end only .",
    "also , combinations of insertions and removals are sometimes necessary to make the sampling more efficient .",
    "hence , we need a flexible multiplication algorithm , which is discussed in the next section .      to calculate the new product after an arbitrary sequence of insertions and/or removals with a minimal number of matrix multiplications , we proceed in two steps .",
    "first the matrices are inserted and/or removed , one after the other . at each time",
    ", this invalidates some sub - products @xmath75 , stored in the blue arrows .",
    "these sub - products are thus emptied .",
    "once the new configuration is proposed , the product is calculated by filling up the emptied sub - products .",
    "when inserting an operator in the skip list , a sub - product expires if the operator lies between the head and the tail of the corresponding arrow , see fig .",
    "[ fig : skiplist ] . to identify all such arrows ,",
    "we follow the skip list insertion algorithm  @xcite and begin at the tail of the top arrow .",
    "this arrow necessarily spans over the operator to insert , and its sub - product is emptied . moving down the red arrow on the right in fig .",
    "[ fig : skiplist ] to the next lower blue arrow , we test if the operator to insert lies between the head and tail of this arrow . if yes , the sub - product is emptied , and the next lower blue arrow is tested . if not , the arrow is traversed and the process is repeated until we end up by emptying the sub - product at the blue arrow just above the place where the operator will be inserted .",
    "proceeding likewise for removal , all expired sub - products are emptied once the new configuration is proposed .    to fill up the emptied sub - products @xmath76",
    "once the insertions and/or removals are completed , we proceed recursively .",
    "the sub - product at an arrow @xmath77 can be calculated from the sub - products @xmath78 stored at the arrows @xmath79 just below . if all of these sub - products have not been emptied , they are multiplied while traversing the arrows @xmath80 and the result is stored at the arrow @xmath77 . if however one of the sub - products @xmath81 at an arrow @xmath82 is missing , we recursively calculate this sub - product from the sub - products below the arrow @xmath82 .",
    "this recursion stops at the latest at the bottom of the skip list , where the operators are multiplied with the propagators .",
    "the total product is obtained by starting the recursion at the top arrow .",
    "once the new product is calculated , we decide whether to accept or reject the proposed configuration . to recover the skip list in case of rejection , a backup is taken at the beginning of a trial step .",
    "in the regimes of interest ( moderate to low temperatures @xmath83  k , strong coulomb interaction @xmath84  ev ) , the probability of accepting a proposed move is low , generally lying below 10% and often below 1% .",
    "the pauli principle and time - evolution operators @xmath85 place strong constraints on the insertion / deletion of operators , causing the low acceptance probabilities . developing techniques to reject improbable moves with minimal computational effort",
    "is crucial .",
    "the pauli constraint is computationally neglegible , as it can quickly be determined by following the string of sector mappings @xmath86 and checking that not all strings are annihilated ( i.e. mapped to 0 ) . in contrast , the time - evolution operators are interspersed within the matrix product .",
    "proposed moves often drive transitions to high - energy sectors , where the exponentials @xmath85 strongly suppress the acceptance probability . here",
    ", we describe a `` lazy trace '' algorithm which leverages these exponentials to efficiently reject moves with low acceptance probability , largely avoiding a full evaluation of the impurity trace .",
    "$ ] . then , using sub - multiplicative matrix norms , we compute initial bounds @xmath87 on the acceptance probability .",
    "the bounds are refined until @xmath13 falls outside @xmath88 $ ] and the move can be definitively accepted or rejected . ]    the first component of the lazy trace algorithm  @xcite is fast bounding of the impurity trace in each symmetry sector .",
    "writing in shorthand eq .",
    "[ equ : sectortrace ] as @xmath89 , _ assume _ we can quickly compute bounds @xmath90 for each sector trace .",
    "this provides a maximum bound on the trace via the triangle inequality : @xmath91 using the expression for the acceptance probability @xmath11 ( eq .  [ equ : prob ] ) , and writing the weight of the old configuration as @xmath92 , we obtain an upper bound @xmath93 this bound can be refined as follows : take the sector @xmath94 with the largest @xmath95 and compute the exact sector trace @xmath96 . applying the reverse triangle inequality gives @xmath97 producing refined bounds @xmath98 this procedure can be continued , generating successively tighter bounds , until we obtain the exact trace .",
    "the sequence of bounds is likely to tighten most rapidly if we choose the sectors in decreasing order of @xmath95 .",
    "the second key idea is to flip the monte carlo coin first to obtain the acceptance threshold @xmath13 , before computing the above approximation to the acceptance probability .",
    "if @xmath99 , and it often is , we can reject the move outright . if @xmath100 we accept the move .",
    "if neither of these possibilities occur , we successively refine the bounds on @xmath11 until we can either accept or reject the move , as illustrated in fig .",
    "[ fig : bounding ] . in the following ,",
    "we describe the construction of the bounds @xmath95 .",
    "the basic equation is the formula @xmath101 proven in appendix  [ apdx : trace ] .",
    "here @xmath102 are matrices ( not necessarily square , although the entire product must be ) , @xmath103 is a sub - multiplicative matrix norm , and @xmath104 is a constant which depends on the specific matrix norm chosen and the dimension of the matrices . in the lazy trace algorithm , the spectral norm ( see appendix  [ apdx : trace ] ) is used . for rectangular matrices",
    "@xmath105 , the constant @xmath104 becomes the dimension of the smallest matrix within the product , @xmath106 .",
    "the spectral norm is unity for a creation or annihilation operator , and @xmath107 for time - evolution operator , where @xmath108 is the ground state energy of the sector @xmath109 and @xmath110 is the time spent in this sector .",
    "application to the trace of a single sector in eq .",
    "[ equ : sectortrace ] gives @xmath111 while extremely cheap to calculate , this bound precisely captures the vast variations in magnitude caused by exponentials in the time - evolution operators .",
    "the bounds for each sector @xmath95 decrease extremely rapidly ; in many cases , the initial @xmath112 is sufficient to reject a proposed move .",
    "when a move is accepted , the trace needs to be evaluated exactly , up to numerical accuracy , to be able to compute the acceptance probability of the next move .",
    "in this section , we begin by combining the algorithms presented in sec .  [",
    "sec : skiplist ] and sec .",
    "[ sec : lazy ] . in a second step ,",
    "we show how the bounds on the sector traces in sec .",
    "[ sec : lazy ] may be improved using this combined algorithm .",
    "when iteratively refining the bounds in the lazy trace evaluation , we only need the contribution to the trace of one sector @xmath58 at a time in eq .",
    "[ equ : sectortrace ] . to achieve this with the skip lists in sec .",
    "[ sec : skiplista ] , we begin by taking into account the block structure of the matrices .    the operators @xmath66 and the sub - products @xmath76 are stored in their block form as pairs @xmath113 and @xmath114 of mapped sectors and corresponding matrix blocks .",
    "similar to the total product which splits into strings in sec .",
    "[ sec : symmetries ] , this splits a sub - product @xmath115 into sub - strings @xmath116 .",
    "such a sub - string is stored in the matrix block @xmath117 together with the mapped sector @xmath118 .    to calculate one string in the total product , we only need one of the sub - strings of a given sub - product . when recursively updating the sub - products in the skip list as in sec .",
    "[ sec : skiplistb ] , we thus have to specify at each arrow @xmath77 the requested sub - string by a start sector @xmath119 . to select the entries in the block matrices @xmath81 ( stored in @xmath82 below @xmath77 ) which need to be multiplied to obtain the requested sub - string @xmath120 , one maps the start sector @xmath119 into @xmath121 using the sector mappings @xmath122 at the arrows @xmath82 , namely @xmath123 .",
    "the product is then stored in the matrix block @xmath117 at the arrow @xmath77 , together with the mapped sector @xmath124 . again , if a matrix block @xmath125 at an arrow @xmath82 is empty , we proceed recursively .    the combination of the skip lists and the lazy trace evaluation is now straightforward .",
    "first , expiring sub - strings are emptied when inserting and/or removing operators in the skip list , similar to sec .",
    "[ sec : skiplistb ] .",
    "once the new configuration has been proposed , we start the recursion at the top arrow of the skip list separately for each sector needed by the lazy trace evaluation .",
    "the bounds on the sector traces in eq .",
    "[ equ : simplesectornorm ] are calculated from the product of the norms of each propagator and operator individually .",
    "tighter bounds may be obtained by using the norms of stored sub - products . in fig .",
    "[ fig : balancedlist ] for example , the trace is bounded by @xmath126 after insertion of the matrix @xmath66 .",
    "such bounds for a given sector trace @xmath127 are obtained recursively , in a manner analog to the block - matrix product of the corresponding string .    calculating the spectral norm of a stored matrix block is expensive , so the frobenius norm is used here instead . while this norm is larger than the spectral norm , its numerical cost is small compared to a matrix multiplication .",
    "however , this means that this bound is not necessarily smaller than the one in sec .",
    "[ sec : lazy ] .",
    "other choices for the norms are discussed in appendix  [ apdx : trace ]",
    "in this section we benchmark the skip lists ( sec .  [",
    "sec : skiplist ] taking into account the block structure described in sec .  [",
    "sec : lazyskiplista ] ) , the lazy trace evaluation ( sec .",
    "[ sec : lazy ] ) and the lazy skip lists ( sec .",
    "[ sec : lazyskiplista ] and sec .",
    "[ sec : lazyskiplistb ] ) . to this end , we consider anderson impurity problems that appear in dft+dmft electronic structure calculation for thin film of lanio@xmath128 ( lno )  @xcite and fete bulk compound  @xcite , using experimental structure of ref .   and ref .  ,",
    "respectively    in both cases , the impurity is a d - shell system , and the associated hilbert space splits into 132 sectors .",
    "the slater parametrization of the coulomb interaction is used .",
    "the average expansion orders are @xmath129 for lno and @xmath130 for fete .",
    "the benchmarks are performed using two kinds of metropolis - hastings updates : i ) standard ones , and @xmath42 . ] with low acceptance ratio and ii ) efficient ones , and @xmath131 with given orbital and spin index @xmath20 are inserted between two consecutive operators with the same orbital and spin index @xmath20 , not taking into account the position of operators with other orbital and spin indices .",
    "both orderings @xmath132 and @xmath133 of the inserted operators lead to a finite trace .",
    "these updates are in principle ergodic and give the same results as the standard updates , however with less noise for fixed amount of cpu - time .",
    "the acceptance ratio is about 10 - 25 times higher . ]",
    "with acceptance ratio higher by a factor 10 to 25 .    ) as baseline.,title=\"fig : \" ] ) as baseline.,title=\"fig : \" ]    fig .",
    "[ fig : lnofespeedup ] shows the speedups of the different optimizations presented in this paper compared with , as a baseline , a straightforward implementation ( sec .",
    "[ sec : symmetries ] ) that takes the block structure into account .",
    "note the logarithmic scale .",
    "the skip lists alone accelerate the simulations for both test cases by a factor of about 20 .",
    "while the lazy trace evaluation gives a substantial speedup for lno , essentially no speedup is obtained for fete .",
    "this also shows in the performance of the combined algorithms , the lazy skip lists , which , with speedups of order 500 , perform much better for lno . the reasons for this difference between lno and fete will become clear below .",
    "[ fig : combo ] shows , in addition to the speedup , the reduction in matrix multiplications and the reduction in floating point operations . while combining different optimizations",
    "does not always result in an additional speedup , in our case the lazy trace evaluation and the skip lists work well together .",
    "the reduction in matrix multiplications for the lazy skip lists ( sec .",
    "[ sec : lazyskiplista ] ) is essentially the product of the reductions for the lazy trace evaluation and the skip lists separately . while the reduction in matrix multiplications for the lazy skip lists in sec .",
    "[ sec : lazyskiplistb ] is less evident to anticipate , there is always an additional speedup that comes from calculating the bounds using the norms of the stored sub - products in the skip list .",
    "note that speedups are smaller than expected from the reduction in matrix multiplications and floating point operations , in particular for the lazy skip lists of sec .",
    "[ sec : lazyskiplistb ] .",
    "this is due to the optimization overhead and to the fact that other parts than the local trace evaluation in the ct - hyb expansion , such as the evaluation of the determinants , are beginning to take a significant proportion of the total time .     of a sector @xmath51 in the partition function expansion ( top panel ) and",
    "frequency with which @xmath127 is calculated for a sector ( lower panel).,title=\"fig : \" ]   of a sector @xmath51 in the partition function expansion ( top panel ) and frequency with which @xmath127 is calculated for a sector ( lower panel).,title=\"fig : \" ]    to understand why most of the speedup comes from the lazy trace evaluation for lno while it comes from the skip list for fete , it is useful to consider the sector weights .",
    "we use standard updates . in fig .",
    "[ fig : statistics]a ) we show results for lno and in figs .  [ fig : statistics]b ) results for fete .",
    "note the logarithmic vertical scales .",
    "the top panels display the average weights @xmath134 of the various sectors in the partition function expansion .",
    "the lower panels of figs .",
    "[ fig : statistics]a ) and b ) show for each sector @xmath51 the frequency of @xmath135 evaluation .",
    "consider first the case of lno .",
    "in contrast to the baseline , it is clear in fig .",
    "[ fig : statistics]a ) that the sector frequencies for the lazy trace evaluation are largely proportional to the sector weights . only a few sectors with @xmath136 to @xmath137",
    "collect most of the weight , and this not only shows where the large reduction in matrix multiplications in fig .",
    "[ fig : combo]a ) comes from , but also why the reduction in floating point operations is even bigger .",
    "indeed , the sectors with @xmath136 to @xmath137 have generally smaller dimension than the ones with @xmath138 to @xmath139 which are not calculated most of time in the lazy trace evaluation .    given their negligible sector weights , it would also be possible in principle to just drop the sectors with @xmath140 to @xmath141 .",
    "however , the gain from this is small since these sectors have rather small dimension . dropping the sectors with @xmath138",
    "to @xmath139 involves more important approximations so one would need careful checks that the truncated sectors do not affect the results .",
    "the lazy trace evaluation avoids the calculation of these sectors most of time and there is no approximation involved .",
    "moving to the case of fete in fig .",
    "[ fig : statistics]b ) , one notices that the sector weights are more uniformly distributed .",
    "there are fewer sectors with extremely small weights .",
    "hence the lazy trace evaluation does not give a substantial speedup .",
    "the skip lists on the other hand still reduce the number of matrix multiplications .",
    "quantum monte carlo algorithms generally involve multiplications of large matrices . in the case of the strong - coupling based ct - hyb algorithm ,",
    "this is a limiting factor . when updates generate new configurations that have a large probability of being rejected , we have shown that an efficient way of speeding up the algorithm is to first choose the random number and then use matrix norms to bound the metropolis rejection / acceptation probability .",
    "this is called lazy trace evaluation .",
    "skip lists on the other - hand provide a way to store intermediate matrix products and avoid in all circumstances the recomputation of some of the matrix - products .",
    "the combination of both algorithms , lazy skip lists , provides a robust algorithm that guarantees large speedups when the trace evaluation takes a large fraction of the computing time .",
    "the speedup of the trace evaluation achieved with the lazy skip lists algorithm is such that parts of ct - hyb that usually take negligible time compared with the evaluation of the trace , for example measurements , calculation of determinants etc .",
    ", can now become the limiting factor .",
    "the tree structure introduced in ref .   transforms an @xmath8 to an @xmath142 problem where @xmath9 is the order in perturbation theory .",
    "this substantial gain in speed also applies to skip list .",
    "the multiplication algorithm where multiple insertions are done before products are recomputed , as presented in sec .",
    "[ sec : skiplistb ] and sec .",
    "[ sec : lazyskiplista ] , could be implemented in binary search trees@xcite as well .",
    "we find skip lists however easier to implement for at least two reasons : first they use simple probabilistic rebalancing rather than explicit rebalancing by tree rotations ; second , a linked list is more natural for a product of operators and propagators than a binary tree .",
    "for the same reasons , skip lists facilitate the exploration of new updates such as exchanging sub - sequences of operators . also , skip lists allow control of memory requirements by changing the probability @xmath11 to add a level to an inserted bar after an update .",
    "we have not discussed further improvements in speed that can be obtained by using the associative property of matrix multiplication to speedup the calculation of products of rectangular matrices , or many other possible optimizations that are dependent on computer architecture , such as caches , parallelism etc .",
    "it has also been proposed to use krylov space methods to calculate the trace .",
    "@xcite for large enough systems , this approach should be the most efficient one , but for cases of practical interest it might not be",
    ". there are optimizations for both the krylov and the matrix formulation .",
    "we first compare the two formulations without optimizations . to this end",
    "we consider the number of operations involved in applying both a creation / annihilation operator and a propagator to a state represented by a vector of dimension @xmath0 in a given symmetry sector . in the matrix formulation ,",
    "the expensive operation comes from the creation / annihilation operators and costs @xmath143 operations . in the krylov formulation ,",
    "the expensive operation is the application of a propagator to a state : it costs the number of operations @xmath144 involved in the application of the hamiltonian to a state , times the number of krylov steps @xmath47 .",
    "this scales like like @xmath145 . indeed , taking the product of @xmath0 and",
    "the number of terms in the second quantized hamiltonian @xmath146 is one way of estimating @xmath144 .",
    "another estimate , which is necessarily smaller , is obtained by actually counting the number of non - vanishing elements in the hamiltonian matrix ( of order @xmath0 ) .",
    "proceeding here with this last estimate for an @xmath3-shell system in a tetragonal environment , the sector with the biggest dimension has @xmath147 and @xmath148 .",
    "the relevant ratio to compare the two approaches in this specific case is thus @xmath149 .",
    "it was found in ref .   that @xmath47 can be small",
    ". however , highly optimized libraries are available when memory is accessed in a regular way , as in the matrix formulation , while the memory access is irregular in the krylov algorithm .",
    "hence we think that the matrix formulation without the optimizations discussed in this paper can be as fast as the krylov formulation , even for typical f - shell impurities .",
    "practical implementations must be compared to decide .",
    "for the general case , note that while the lazy trace idea can be applied to the krylov algorithm , it is less clear that one can implement skip list for this algorithm .",
    "hence , while the krylov algorithm needs to be repeated @xmath9 times for an order @xmath9 term in perturbation theory , the skip - list ( or binary tree  @xcite ) algorithm allows us to change that factor to @xmath150 .",
    "other optimizations of the krylov algorithm have been proposed recently  @xcite .",
    "some of the ideas developed here can be directly applied to other problems treated by monte carlo methods .",
    "for example the rejection method based on bounds ( see fig .  [",
    "fig : bounding ] ) can be applied to classical monte - carlo simulations for spins with long - range interactions :   take an ising spin system and consider a single spin - flip monte carlo update .",
    "the energy associated with this spin can be bounded by @xmath151}=s_{i}\\sum\\limits_{j\\le r}j_{i ,",
    "j}s_{j}\\pm s_{i}\\sum\\limits_{j > r}\\left\\vert j_{i , j}\\right\\vert .\\ ] ] the bounds can be refined by successively increasing the range @xmath152 .",
    "the sums over absolute values of exchange constants need to be calculated only once .",
    "similar problems are encountered in spin - ice models with dipolar interactions ,  @xcite ordered and/or random spins with both dipolar and rkky interactions .",
    "other schemes relying on different ideas also exist and may be faster .",
    "@xcite but this remains to be tested .",
    "speedups by factors in the hundreds that can be achieved with the lazy skip lists algorithm will bring new physical regimes in correlated electronic - structure calculations and cluster generalizations of dynamical mean - field theories within reach of computational power .",
    "applications of such methods extend as far as molecular biology .",
    "@xcite    we are grateful to m. boninsegni , a. del maestro , m. gingras , e. gull , h. ishizuka , r. melko , o. parcollet , m. troyer , p. werner , and especially to s. allen , d. snchal , and j. goulet for useful discussions . this work has been supported , by the natural sciences and engineering research council of canada ( nserc ) , by mrl grant dmr-11 - 21053 ( c.y . ) and kitp grant phy-11 - 25915 ( c.y . ) , by nsf grant dmr-0746395 ( k.h . ) and by the tier i canada research chair program ( a .- m.s.t . ) .",
    "the alps libraries  @xcite were used in the code .",
    "simulations were run on computers provided by cfi , mels , calcul qubec and compute canada .",
    "different matrix norms give different bounds for the magnitude of the trace of a matrix product .",
    "we consider here induced norms @xmath153 where @xmath154 , @xmath155 and @xmath156 with @xmath157 , and the frobenius norm @xmath158      for the induced norms , one obtains @xmath159 , where @xmath160 is the standard basis of @xmath161 , and hence @xmath162 this immediately generalizes to a product @xmath163 of rectangular matrices @xmath105 , since induced norms are sub - multiplicative . from the cyclicity of the trace ,",
    "the pre - factor in eq .",
    "[ equ : norm ] becomes @xmath164 , the minimal row or column dimension of all the matrices within the product .    for a propagator @xmath165 , written in the eigenbasis , one obtains @xmath166 , where @xmath108 is the smallest eigenvalue .",
    "these norms are hence well suited for the lazy trace evaluation in sec .",
    "[ sec : lazy ] . especially convenient is the spectral norm ( @xmath167 ) .",
    "this norm is one for annihilation or creation operators since @xmath168 by the pauli principle , and only the exponentials of the propagators enter into the bound given in equation ( [ equ : induced ] ) .      for the frobenius norm , cauchy - schwarz states @xmath169 and as the frobenius norm is sub - multiplicative @xmath170 where @xmath171 .",
    "the frobenius norm is numerically cheap , so equation ( [ equ : frobenius ] ) can be used for the lazy skip lists in sec .",
    "[ sec : lazyskiplistb ] .",
    "other numerically cheap choices are the induced norms with @xmath172 and @xmath173 .",
    "46ifxundefined [ 1 ] ifx#1 ifnum [ 1 ] # 1firstoftwo secondoftwo ifx [ 1 ] # 1firstoftwo secondoftwo `` `` # 1''''@noop [ 0]secondoftwosanitize@url [ 0 ]",
    " + 12$12  & 12#1212_12%12@startlink[1]@endlink[0]@bib@innerbibempty link:\\doibase    10.1103/revmodphys.68.13 [ * * ,   ( ) ] link:\\doibase 10.1103/revmodphys.78.865 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.84.054529 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.81.195107 [ * * ,   ( ) ] @noop ( ) ,   http://ezproxy.usherbrooke.ca/login?url=http://search.ebscohost.com/login.aspx?direct=true&db=a9h&an=7146039&lang=fr&site=ehost-live&scope=site [ * * ,   ( ) ] link:\\doibase 10.1080/00018730701619647 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.57.6884 [ * * ,   ( ) ] link:\\doibase    10.1103/physrevlett.97.076405 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.74.155107 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.75.155113 [ * * , ( ) ] link:\\doibase    10.1103/revmodphys.83.349 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevlett.87.186401 [ * * ,   ( ) ] link:\\doibase 10.1103/revmodphys.77.1027 [ * * ,   ( ) ] http://dx.doi.org/10.1063/1.2199446 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.76.104509 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.76.092503 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevlett.101.186403 [ * * ,   ( ) ] link:\\doibase    10.1103/physrevlett.107.126401 [ * * ,   ( ) ] link:\\doibase    10.1103/physrevb.84.165133 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevlett.104.226402 [ * * , ( ) ] link:\\doibase 10.1103/physrevb.84.075161 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevlett.108.216401 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.87.041101 [ * * ,   ( ) ] link:\\doibase 10.1038/srep00547 [ * * ,   ( ) ] link:\\doibase    10.1103/physrevb.76.235123 [ * * ,   ( ) ] \\doibase http://dx.doi.org/10.1063/1.3614019 [ * * ,   ( ) ] link:\\doibase 10.1145/78973.78977 [ * * , ( ) ] _ _ ,  @noop ph.d .",
    "thesis ,   ( ) ,   _ _ ,  @noop ph.d .",
    "thesis ,  , ( ) link:\\doibase    10.1038/ncomms3644 [ * * ( ) , 10.1038/ncomms3644 ] @noop ( ) ,   link:\\doibase    10.1103/physrevb.83.075125 [ * * ,   ( ) ] link:\\doibase    10.1103/physrevb.82.014110 [ * * ,   ( ) ] link:\\doibase    10.1103/physrevb.81.094115 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.80.235117 [ * * ,   ( ) ] http://stacks.iop.org/1742-5468/2014/i=6/a=p06012 [ * * ,   ( ) ] http://stacks.iop.org/0953-8984/16/i=43/a=r02 [ * * ,   ( ) ] @noop * * ,   ( ) link:\\doibase    10.1103/physrevlett.110.106402 [ * * ,   ( ) ] \\doibase    http://dx.doi.org/10.1016/j.jmmm.2006.10.304 [ * * ,   ( ) ] , @noop _ _ ,  vol ."
  ],
  "abstract_text": [
    "<S> the solution of a generalized impurity model lies at the heart of electronic structure calculations with dynamical mean - field theory ( dmft ) . in the strongly - correlated regime , </S>",
    "<S> the method of choice for solving the impurity model is the hybridization expansion continuous time quantum monte carlo ( ct - hyb ) . </S>",
    "<S> enhancements to the ct - hyb algorithm are critical for bringing new physical regimes within reach of current computational power . taking advantage of the fact that the bottleneck in the algorithm is a product of hundreds of matrices , we present optimizations based on the introduction and combination of two concepts of more general applicability : a ) skip lists and b ) fast rejection of proposed configurations based on matrix bounds . considering two very different test cases with @xmath0 electrons , </S>",
    "<S> we find speedups of @xmath1 up to @xmath2 compared to the direct evaluation of the matrix product . </S>",
    "<S> even larger speedups are likely with @xmath3 electron systems and with clusters of correlated atoms . </S>"
  ]
}