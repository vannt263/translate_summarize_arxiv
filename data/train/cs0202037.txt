{
  "article_text": [
    "enterprise databases often contain not only ordinary data , but also queries .",
    "examples are view definitions in the system catalog ; usage logs or workloads ; and stored procedures as in sql / psm or postgres @xcite .",
    "unfortunately , these queries are typically stored as long strings , which makes it hard to use standard sql to express _ meta - queries : _ queries about queries .",
    "meta - querying is an important activity in situations such as advanced database administration , database usage monitoring , and workload analysis .",
    "examples of meta - queries to a usage log are :    1 .   which queries in the log do the most joins ? 2 .   which queries in the log return an empty answer on the current instance of the database ? 3 .",
    "view expansion : replace , in each query in the log , each view name by its definition as given in the system catalog .",
    "4 .   given a list of new view definitions ( under the old names ) , which queries in the log give a different answer on the current instance under the new view definitions ?    query  1 is _ syntactical : _ it only queries the stored queries on the basis of their expressions .",
    "query  2 is _ semantical : _ its answer depends on the results of dynamically executing the stored queries .",
    "query  3 is again syntactical , but more so than query  1 in that it also performs syntactical transformations .",
    "query  4 is syntactical and semantical together .    to express meta - queries , database administrators and other advanced users typically resort to a programming language like perl , in combination with dynamic sql",
    ". it would be much nicer if they would not have to `` leave '' the database system and could express their meta - queries directly in interactive sql . indeed , already in 1993 , in his sigmod innovations award speech , jim gray urged the database community to lower the wall between data and programs . in the same vein ,",
    "the asilomar report puts the unification between programs and data high on the database research agenda @xcite .",
    "as queries are an important kind of program in the context of databases , support for meta - querying thus seems to be a step in the right direction towards understanding how we can unify programs and data in database systems .    in this paper , we present a practical meta - querying system based on the relational model . our main design goal was to use current dbms technology and only extend standard sql with specific meta - querying features where necessary .",
    "stored queries are represented as syntax trees in xml format .",
    "this representation provides a convenient basis for syntactical meta - querying .",
    "indeed , rather than reinventing the wheel and designing a new sublanguage for syntactical manipulation of stored queries , it allows us to use the standard xml transformation language xslt for this purpose .",
    "many syntactical meta - queries can then directly be expressed simply by allowing xslt function calls within sql expressions .",
    "this combination of sql and xslt gives us a basic level of expressive power , but for more complex syntactical meta - queries we need a bit more .",
    "to this end , we enrich the sql language with _ xml variables _ which come in addition to sql s standard range variables .",
    "xml variables range not over the rows of a table , but rather over the subelements of an xml tree .",
    "the range can be narrowed by an xpath expression .",
    "( xpath is the sublanguage of xslt used to locate subelements of xml documents . )",
    "xml variables thus allow us to go from an xml document to a set of xml documents .",
    "conversely , we also add _ xml aggregation _",
    "@xcite , which allows us to go from a set of xml documents to a single one .",
    "sql combined with xslt and enriched with xml variables and aggregation offers all the expressive power one needs for ad - hoc syntactical meta - querying . to allow for semantical meta - querying as well",
    ", it now suffices to add an _ evaluation function _ , taking the syntax tree of some query as input , and producing the table resulting from executing the query as output .",
    "we note that a similar evaluation feature was already present in the postgres system .",
    "what we obtain is _ meta - sql _ : a practical meta - query language .",
    "meta - sql has as advantage that it is _ not _ `` yet another query language '' : it is entirely compatible with modern sql implementations offered by contemporary extensible database systems .",
    "indeed , these systems already support calls to external functions from within sql expressions , which allows us to implement the xslt calls . furthermore",
    ", xml variables and the evaluation function can be implemented using _ set - valued _ external functions .",
    "as we will show , the powerful feature of `` lateral derived tables '' , part of the sql:1999 standard , turns out to be crucial to make this work .",
    "xml aggregation , finally , can be implemented as a user - defined aggregate function .",
    "we emphasize again that we are _ not _ proposing yet another database language .",
    "instead , our main design goal was to stick as closely as possible to standard sql .",
    "of course , a drastic alternative is to abandon the relational model altogether and move to , e.g. , an xml - xquery environment , where meta - querying does not pose any problem .",
    "however , given the widespread use of relational databases , a conservative approach such as ours remains important .",
    "this paper is further organized as follows . in section  2 , we combine sql with xslt . in section  3 ,",
    "we add xml variables . in section  4",
    ", we move on to semantical meta - querying . in section  5 , we describe how meta - sql can be implemented using extensible database technology . we give some experimental performance results of our prototype in section  6 . in section  7 , we conclude with a discussion of our approach .",
    "consider a standard relational database , except that in a table some columns can be marked to be of type `` xml '' . in any row of that table , the component corresponding to a column of type xml holds an xml document . at the present conceptual level",
    ", we do not yet care about how this is implemented .",
    "xslt @xcite is a widely used manipulation language for xml documents .",
    "an xslt program takes an xml document as input , and produces as output another xml document ( which could be in degenerate form , holding just a scalar value like a number or a string ) . using the xslt top - level parameter binding mechanism @xcite",
    ", programs can also take additional parameters as input .",
    "hence , to query databases containing xml , it seems natural to extend sql by allowing calls to xslt functions , in the same way as extensible database systems extend sql with calls to external functions .",
    "however , in these systems , external functions have to be precompiled and registered before they can be used . in meta - sql ,",
    "the programmer merely includes the source of the needed xslt functions and can then call them directly .",
    "let us see an example of all this , at the same time applying it to meta - querying .",
    "consider a simplified system catalog table , called ` views ` , containing view definitions .",
    "there is a column ` name ` of type string , holding the view name , and a column ` def ` of type xml , holding the syntax tree of the sql query defining the view , in xml format .",
    "for example , over a movies database , suppose we have a view ` dirratings ` defined as follows :    .... select director , avg(rating ) as avgrat from movies group by director ....    then table ` views ` would have a row with value for ` name ` equal to `` dirratings ` ' , and value for ` def ` equal to the following xml document :    .... < query > < select > < sel - item >    < column > director</column > < /sel - item > < sel - item >    < aggregate><avg/ >      < column - ref >        < column > rating</column >",
    "< /column - ref >    < /aggregate >    < alias > avgrat</alias > < /sel - item > < /select > < from > < table - ref >    < table > movies</table > < /table - ref > < /from > <",
    "group - by > < column - ref >    < column > director</column > < /column - ref > < /group - by > ....",
    "figure  [ xmltree ] shows the same document as a dom tree @xcite , which is perhaps clearer .    to achieve uniformity in the specific xml format for representing sql syntax trees",
    ", we must agree on some fixed bnf syntax for sql .",
    "a bnf grammar can be easily transformed into an xml dtd @xcite , which then specifies the xml format to use . in this paper",
    ", we use the bnf grammar given by date @xcite .",
    "the derived dtd is given in appendix  [ appdtd ] .",
    "now recall the first example meta - query from the introduction , but applied to our ` views ` table : `` which queries do the most joins ? '' for simplicity of exposition , let us identify the number of joins an sql query does with the number of table names occurring in it . to express this meta - query in meta - sql ,",
    "we write an auxiliary xslt function ` count_tables ` , followed by an obvious sql query calling this function :    .... function count_tables returns number begin < xsl : template match=\"/ \" >    < xsl : value - of      select=\"count(//table)\"/ > <",
    "/xsl : template > end    select name from views where count_tables(def ) = ( select max(count_tables(def ) )   from views ) ....    the first line declares the xslt function in meta - sql ; between ` begin ` and ` end ` one writes arbitrary xslt code .",
    "of course , in general , meta - sql allows multiple xslt functions to be declared and called in the sql query that follows the function declarations .    as a second example , suppose we are given a list ` removed ` of names of tables that are going to be removed , and we want to know which views will become invalid after this removal because they mention one of these table names . to express this meta - query in meta - sql , we write :    .... function mentions_table param tname string returns string begin < xsl : param name=\"tname\"/ > < xsl : template match=\"/ \" > < xsl : if    test=\"//table[string(.)=$tname ] \" > true < /xsl : if >",
    "< /xsl : template > end    select name from views , removed where mentions_table(def , removed.name )        = ' true ' ....    note that , using the xslt parameter mechanism already mentioned near the beginning of this section , function ` mentions_table ` takes an extra parameter ` tname ` ( of type string ) .",
    "accordingly , in the sql query , the function is called on two arguments : the xml input ` def ` , and the parameter ` removed.name ` .    as a final example , suppose we are given a second view definitions table ` views2 ` , and for every view name that is listed in both views tables , we want a new definition that equals the union of the first definition and the second definition .",
    "to express this meta - query in meta - sql , we write :    .... function unite param v2 xml returns xml begin < xsl : param name=\"v2\"/ > < xsl : template match=\"/ \" > < union >    < xsl : apply - templates/ >    < xsl : apply - templates select=\"$v2\"/ > < /union > < /xsl : template > < xsl : template match= \" * \" > < xsl : copy >    < xsl : apply - templates/ >",
    "< /xsl : copy > < /xsl : template > end    select name , unite(v.def , v2.def ) from views v , views2 v2 where v.name=v2.name ....    note that function ` unite ` outputs xml , and again takes an extra parameter ` v2 ` , now also of type xml .",
    "the simple combination sql + xslt is already quite useful , but its full potential is only realized when we add a language construct that allows us to extract the subelements of an xml document .",
    "for example , the simple meta - query    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ give all pairs @xmath0 , where @xmath1 is a view name and @xmath2 is a table name mentioned in the definition of view @xmath1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    is otherwise not expressible .",
    "we therefore add _ xml variables _ to sql : while the standard sql range variables range over the rows of a table , xml variables range over the subelements of an xml document . like range variables ,",
    "xml variables are bound in the from - clause , in a similar way variables are bound in oql @xcite and in xquery @xcite .",
    "more specifically , an xml variable @xmath3 is bound in a from - clause using a construct of the following form : @xmath4}\\ ] ] here ,    * @xmath5 is a previously bound xml variable or a column reference , or an xslt function call , of type xml ; and * @xmath6 is an xpath expression @xcite specifying which subelements of @xmath5 we want @xmath3 to range over .    a bound xml variable can appear in an sql expression anywhere a column reference can .",
    "for example , the meta - query quoted above can now be expressed as follows :    .... function string_value returns string begin end    select v.name , string_value(x ) from views v , x in v.def[//table ] ....    note that the body of function ` string_value ` is empty ; indeed , the empty xslt program does exactly what we want here , namely , to return the string value of an xml document ( in this case , a ` table ` subelement ) .    as another example",
    ", suppose we are given a log table ` log ` with stored queries ( in a column ` q ` ) , and we want to identify `` hot spots '' : subqueries that occur as a subquery in at least ten different queries . to express this meta - query , we write :    .... select s from log l , s in l.q[//query ] group by s having count(l.q ) > = 10 ....    [ [ xml - aggregation ] ] xml aggregation + + + + + + + + + + + + + + +    xml variables allow us to go from an xml document to a set of xml documents .",
    "conversely , we want to be able to go from a set of xml documents to a single one .",
    "thereto , we add a natural aggregate function on xml columns , called cmb ( for `` combine '' ) , also used by shanmugasundaram et al @xcite . just like the result of the standard aggregate function sum on a list of numbers",
    "@xmath7 is the sum @xmath8 , the result of cmb on a list of xml documents @xmath9 is the combined xml document @xmath10 @xmath10 so , the top - level element of @xmath11 is always labeled ` cmb ' , and has the documents @xmath9 as its subelements .",
    "as an example , suppose we are given a view definitions table ` views3 ` similar to ` views ` , except that the same view name may appear with multiple definitions .",
    "suppose we want to ask the following meta - query : for each view name , give the cartesian product of its definitions .",
    "thereto , we first write an easy xslt function ` cartprod ` ( see appendix  [ appxslt ] ) that transforms an input of the form @xmath11 into the document @xmath10 @xmath10 we then write :    .... select name , cartprod(cmb(def ) ) from views3 group by name ....    as another example , recall the third example meta - query from the introduction : view expansion in the log . to express this meta - query in meta - sql ,",
    "we first write two auxiliary xslt functions ( see appendix  [ appxslt ] ) :    * ` pair ` , taking a string parameter @xmath12 , and transforming an input document @xmath13 into the document @xmath10 @xmath10 * ` rewrite ` , taking an xml parameter @xmath14 of the form @xmath10 @xmath10 where @xmath15 ,  , @xmath16 are different strings and @xmath17 ,  , @xmath18 are arbitrary xml documents , and transforming an input query @xmath19 by replacing every occurrence of an element of the form @xmath10 @xmath10 by a copy of @xmath20 .",
    "we then write :    .... select    rewrite(l.q , ( select                    cmb(pair(def , name ) )                  from views ) ) from log l ....",
    "the language we have so far : sql combined with xslt , and enriched with xml variables and xml aggregation , gives us all the power we need for ad - hoc _ syntactical _ meta - querying .",
    "we now complete meta - sql so as to allow _ semantical _ meta - querying as well .    to this end",
    ", we add a function eval for dynamic evaluation of sql queries .",
    "eval takes an sql query ( more correctly , its syntax tree in xml format ) as input , and returns the table resulting from executing the query .",
    "a call to eval can appear in an sql expression anywhere a table reference can ; the resulting table can thus be ranged over by a standard range variable .",
    "as an example , suppose we are given a table ` customer ` with two attributes : ` custid ` of type string , and ` query ` of type xml .",
    "the table holds queries asked by customers to the catalogue of a store .",
    "every query returns a table with attributes ` item ` , ` price ` , and possibly others .",
    "the following meta - query shows for every customer the maximum price of items he requested :    .... select custid , max(t.price ) from customer c , eval(c.query ) t group by custid ....",
    "eval is all we need , provided we have enough information about the output scheme of the stored queries we are evaluating . for example , in the previous meta - query , we are only interested in the ` price ` attribute , and we know that every stored query evaluates to a table that indeed has a ` price ` column . but what if we are given an arbitrary collection of stored queries without information about their output schemes ? they could even all have different output schemes !    such a situation neatly fits the genre known as `` semistructured data '' @xcite : data that has a structure ( scheme ) , but we do not know it , and it can be irregular . since xml is the standard format for semistructured data , and",
    "since we already have xml variables in meta - sql , we can easily solve the problem with an untyped version of eval .",
    "this ueval function works just like eval , except that the table resulting from the dynamic evaluation of the query is presented as a set of xml documents .    more concretely ,",
    "suppose a particular stored query evaluates to a table with attributes @xmath21 .",
    "then every output row @xmath22 is represented as the xml document @xmath10 @xmath10 the resulting set of xml documents is ranged over by an xml variable rather than a standard range variable ; this is a new use we make of xml variables in the meta - sql language .    as a simple example , recall the second example meta - query from the introduction : `` which queries in the log return an empty answer ? '' to express this meta - query , we write :    .... select q from log l where not exists    ( select x from x in ueval(l.q ) ) ....    note that ` x ` is an xml variable , whereas ` t ` in the previous example is a standard sql range variable .",
    "the fourth example meta - query from the introduction ( query comparison after view expansion ) is equally easy to express , given that we already saw how to express view expansion in the previous section .",
    "in particular , note that we can apply eval and ueval not only to queries directly stored in the database , but also to queries coming from a syntactical meta - subquery ( such as view expansion ) .",
    "[ [ run - time - errors ] ] run - time errors + + + + + + + + + + + + + + +    both eval and ueval expect their input to be ( the xml syntax tree of ) a correct sql query .",
    "if that is not the case , we consider this to be a programming error , and a run - time exception will be raised .",
    "moreover an application of eval can still fail even if its argument is a correct sql query , namely , when the query result does not have the expected columns .    designing a meta - query language where dynamic evaluation of stored queries is statically typed so as to be safe from such run - time errors is possible @xcite , but leads to an overly restricted formalism . in the design of meta - sql ,",
    "we have opted to prefer flexibility and expressive power above static typing .",
    "meta - sql is entirely compatible with modern sql implementations offered by contemporary extensible database systems .",
    "extensible ( also called object - relational , or universal ) database systems @xcite support user - defined data types for the columns of tables , and allow user - defined functions on these types to be called within sql .",
    "extensibility is now part of the new sql:1999 standard , and the major commercial vendors are aggressively moving to support it .    in figure  [ architecture ]",
    "we illustrate the architecture of an implementation of meta - sql , explained in more detail in this section .",
    "[ [ implementing - xml - columns ] ] implementing xml columns + + + + + + + + + + + + + + + + + + + + + + + +    to support xml columns , it suffices to define a data type ` xml ' .",
    "we could derive this type from the built - in type clob ( character large object ) and store xml documents as texts , but we could also derive from blob ( binary large object ) and store xml documents as binary encodings of their dom tree structures .    [ [ implementing - xslt - calls ] ] implementing xslt calls + + + + + + + + + + + + + + + + + + + + + + +    starting from meta - sql source code , consisting of a number of xslt functions , followed by an sql query using these functions , the meta - sql compiler does the following automatically :    1 .   for each xslt function , we generate a wrapper function ( in an external programming language such as c or java ) that invokes an xslt processor , thus performing the required xslt transformation on the arguments , and returns the result . if necessary , this result is converted to an sql datatype like number or string .",
    "all wrapper functions are compiled and put together in an object library .",
    "every wrapper function is registered in the database system ( using sql:1999 create function statements ) .",
    "[ sqlstep ] with the functions in place , the final meta - sql query can now be executed literally by the database system .",
    "almost all available xslt processors provide an interface to various programming languages , and can be loaded together with the application that invokes them .",
    "hence , the compiled wrapper functions can be loaded into the database server together with the xslt processor functionality and executed as efficiently as possible .",
    "[ [ implementing - xml - variables ] ] implementing xml variables + + + + + + + + + + + + + + + + + + + + + + + + + +    now the first and the last step in the above plan become more involved : in the first step , we must generate an additional function ` extract ` ; in the last step , we must perform some rewriting on the sql query .",
    "we next explain this in a bit more detail .",
    "to support the xslt calls , we needed only _ single - valued _ external functions : they return as output only a single value , be it a string , a number , or an xml document . to support xml variables , however , we need a _ set - valued _ external function . specifically , the meta - sql system provides a function ` extract ` , which takes an xml document @xmath5 and an xpath expression @xmath6 as input , and which returns the set of all subelements of @xmath5 that satisfy @xmath6 .",
    "this set is returned as a one - column table with attribute name ` result ` .",
    "every xml variable binding , say , ` x in y[e ] ` , is now rewritten by the meta - sql compiler into a call ` extract(y,e ) ` .",
    "this call returns a table to which @xmath3 is again bound , but now @xmath3 has become a standard sql range variable over the single attribute ` result ` .",
    "for example , recall the first example of section  [ xmlvaragg ] :    .... select v.name , string_value(x ) from views v , x in v.def[//table ] ....    this query will be rewritten as follows :    .... select v.name , string_value(x.result ) from views v ,       table(extract(v.def,'//table ' ) ) x ....    the above from - clause contains two table expressions .",
    "note that the variable ranging over the first table expression , namely ` v ` , is directly used in the second table expression .",
    "this is an instance of what sql:1999 calls a `` lateral derived table '' @xcite .",
    "such lateral joins were not allowed in sql-92 ; we see that they are crucial here .",
    "we point out that they were present in oql from the outset @xcite .",
    "[ [ implementing - eval - and - ueval ] ] implementing eval and ueval + + + + + + + + + + + + + + + + + + + + + + + + + + +    the function ueval can , like extract , be realized as a set - valued external function .",
    "this evaluation function takes an sql syntax tree in xml as input ; unparses it ; sends the sql query to the database ; receives the answer rows ; transforms them into xml as explained in the previous section ; and returns the results .",
    "the xml variable ranging over the ueval result is handled in the same way as above .",
    "for example ,    .... select q from log l where not exists    ( select x from x in ueval(l.q ) ) ....    is compiled into    .... select q from log l where not exists    ( select x.result     from table(ueval(l.q ) ) x ) ....    the implementation of eval is a bit more complicated , because eval returns not a set of xml documents , but a normal sql table ranged over by a standard range variable . in this case",
    ", the meta - sql compiler first determines the specific attributes that are mentioned in connection with this range variable .",
    "a specific table - valued external function having this set of attributes as output scheme is then generated and registered in the database system .",
    "this evaluation function will actually not send its exact argument sql query to the database for evaluation , but rather its projection on the output scheme in question .",
    "for example , recall the first example of section  [ semquery ] :    .... select custid , max(t.price ) from customer c , eval(c.query ) t group by custid ....    to implement this query , the meta - sql system will generate an evaluation function , say , eval_1 , with output scheme ` ( price ) ` , and will rewrite the query to    .... select custid , max(t.price ) from customer c ,       table(eval_1(c.query ) ) t group by custid ....    here , @xmath23 , when called on any stored query @xmath19 , evaluates and returns the projection @xmath24 .    if the select - clause would have additionally included ` sum(t.qty ) ` , then the system would have generated a different evaluation function eval_2 with output scheme ` ( price , qty ) ` and according behavior .",
    "[ [ implementing - xml - aggregation ] ] implementing xml aggregation + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the xml aggregate function cmb introduced in section  [ xmlvaragg ] can be directly provided as a user - defined aggregate function .",
    "[ [ a - working - prototype ] ] a working prototype + + + + + + + + + + + + + + + + + + +    we have developed a prototype implementation on top of db2 udb @xcite , which we chose because it is freely available to university research and teaching .",
    "we implement the external xslt wrapper functions in java , in conjunction with the popular and free java - based xslt processor saxon @xcite .",
    "saxon also provides a convenient java - xml interface making the extract function very easy to write .",
    "a caveat in connection to the implementation of eval and ueval is that db2 udb currently does not allow sql calls inside external functions .",
    "we bypass this restriction by spawning a child process , which then makes a new connection to the database in order to evaluate the stored query .",
    "in this section we describe some performance experiments on our prototype implementation . unless stated otherwise , the results shown are averages of multiple executions of the test under discussion .    [ [ java - overhead ] ] java overhead + + + + + + + + + + + + +    our first test measures the overhead implied by calling external functions written in java . to that cause we created three simple single - valued external functions , ` cst ` , ` mul ` and ` cap ` , which respectively return a constant number , multiply a number with a constant , and transform the input string to capital letters .",
    "the following four queries were executed :    .... select * from t select cst(a ) , b from t select mul(a ) , b from t select a , cap(b ) from t ....    here , ` t ` consists of an integer column ` a ` and a character column ` b ` .",
    "the first query is executed to measure the time needed to select tuples from ` t ` without calling an external function .",
    "figure [ fig : javac ] shows the results for varying table sizes . as was to be expected , the running times of all functions grow linearly in the number of input tuples . since the time needed to execute the last three queries closely resembles that of the first , we may conclude that there is a minimal overhead involved with external functions programmed in java .    [ [ xslt - processor - overhead ] ] xslt processor overhead + + + + + + + + + + + + + + + + + + + + + + +    our prototype implements xslt functions by external wrapper functions calling the saxon xslt processor . to measure the startup cost of the xslt processor , we compared the meta - sql query    .... function xslt_cst returns number begin    < xsl : template match=\"/ \" >      40513    < /xsl : template > end    select xslt_cst(a ) from t ....    whose execution time is dominated by starting up the xslt processor , with the query    .... select cst(a ) from t ....    here , ` cst ` is single - valued external function which also returns the same constant on all inputs .",
    "table ` t ` consists of a single xml column , whose values are single - node trees .",
    "figure [ fig : xslt - test1 ] shows the results for varying table sizes .",
    "the xslt function running time is significantly larger than that of ` cst ` , and grows linearly in the number of input tuples , which indicates that there is a constant startup cost imposed by the xslt processor . as such",
    ", a meta - sql implementation would greatly benefit from more efficient xslt / xml processors .    a valid question to ask next",
    "is how the size of the input xml document affects the running time of an xslt function . to this",
    "cause we compared the following two queries :    .... select xslt_copy(a ) from t1 select copy(a ) from t1 ....    here , both ` xslt_copy ` and ` copy ` copy their input to the output .",
    "the only difference is that xslt function ` xslt_copy ` does so by xslt template matching whereas external function ` copy ` performs a true copy .",
    "table ` t1 ` consists of a single xml column ` a ` .",
    "figure [ fig : xslt - test2 ] shows the running times of these queries on tables with @xmath25 documents , for varying document sizes .",
    "both running times grow linearly when the number of nodes per tuple increases , as was to be expected . combined with the previous results",
    ", this indicates that calling a xslt function has a rather large start - up cost , but a relatively small execution cost .",
    "[ [ extract ] ] extract + + + + + + +    as described in the section [ sec : impl ] , xml variables are implemented by a set - valued external function called ` extract ` . to see how set - valued external functions compare with single valued functions",
    ", we created a single - valued function named ` scalar_extract ` , which evaluates the xpath expression ` / ` on its input , and executed the following three queries :    .... select x from t , x in b[// * ] select x from t1 , x in b[/ ]   select scalar_extract(b ) from t1 ....    here , ` t ` consists of an xml column ` b ` , which is populated by @xmath25 documents of @xmath26 nodes .",
    "table ` t1 ` contains the result of the first query .",
    "hence , the second and third query return the same output as the first ; here , the second query still uses an xml variable , whereas the third query makes a direct function call .",
    "the difference is that ` extract ` is called @xmath25 times in the first query , each time returning @xmath26 tuples , whereas in the second and third query ` extract ` and ` scalar_extract ` are called @xmath27 times , each call returning a single tuple .",
    "thus , this test compares the overheads involved with set - valued functions returning multiple tuples , set - valued functions returning a single tuple , and single - valued functions returning a single tuple .",
    "we timed the execution for varying @xmath26 , as shown in figure [ fig : extract - test1 ] . due to the large running times , the test was only timed once .",
    "we can safely conclude that returning multiple tuples from a set - valued function is not a problem .",
    "indeed , the running time of the first query is quite reasonable and increases linearly with @xmath26 ( although it appears constant in figure [ fig : extract - test1 ] due to the large running times of the other queries ) . in particular , it is multiple times faster than returning @xmath26 times a single tuple . as such",
    ", the implementation of xml variables in our approach performs very reasonably .",
    "since both ` extract ` and ` scalar_extract ` use the xslt processor to evaluate their xpath expressions and because the running time of the second query resembles that of the third , we can also conclude that the overhead of a set - valued external function is about the same as that of a single - valued one .    with the following two queries",
    ", we measure the overhead of an ` extract ` call versus the actual amount of work that needs to be done :    .... select x from t , x in b[// * ] select c from t , t2 ....    here , ` t ` is as before and ` t2 ` is the table with xml column ` c ` , containing the result of the first query on a single document in ` t ` . since all documents in",
    "` t ` are the same , both queries return the same result . by adding the time the xslt processor needs to evaluate the xpath expression ` // * ` @xmath25 times to the timing of the second query , we get an estimate of the time needed to calculate the result of the first query , without actually calling ` extract ` .",
    "as can be seen from figure [ fig : extract - test2 ] , the running time of both queries grow linearly in their input .",
    "however , the first query outperforms the second one when @xmath26 grows larger .",
    "hence , although ` extract ` has some startup overhead , it is efficient when applied to large documents .",
    "indeed , it even outperforms a setting in which the same amount of work needs to be done , but no call to a set - valued external function is made . combined with our previous results",
    ", this shows that xml variables are efficiently implementable .",
    "[ [ eval ] ] eval + + + +    remember from section [ sec : impl ] that ` eval ` and ` ueval ` are implemented as set - valued external functions which create a subprocess to execute their input query . in order to measure the overhead incurred by starting this process and communicating with it , we created tables ` t ` and ` t ` with integer column @xmath28 and xml column @xmath29 .",
    "every tuple in ` t ` contains in its @xmath29 column the following query in xml format :    .... select * from t1 ....    we then measured the time needed to execute the query    .... select a , e.a from t , eval(t.b ) as e ....    furthermore , with @xmath30 be the number of tuples in @xmath31 , we timed the execution of @xmath30 times the query    .... select * from t1 ....    ( in java , since ` eval ` uses java to execute its queries ) and added that to the time needed to compute the same result :    .... select t.a , t1.a from t , t1 ....    comparison of these two measurements gives a good indication of the overhead implied by ` eval ` .    as shown in figure [",
    "plot : eval ] , calling the ` eval ` function is six to seven times slower than preprocessing and joining , and grows linearly in the number of input tuples .",
    "[ [ conclusion ] ] conclusion + + + + + + + + + +    the experiments above indicate that our proposal for implementing meta - querying features _ on top of _ the database engine induces constant , predictable overheads , which is certainly good news .",
    "still , the running times are sometimes too high",
    ". therefore , more efficient xslt processors would certainly help .",
    "the ideal solution would be to incorporate xslt processing directly into the query processor , as has recently been suggested by moerkotte @xcite .",
    "it would also help if we could implement the eval and ueval functions entirely in a programmed sql language such as oracle s pl / sql , or sql / psm , in which case the overhead of calling a table function and starting a subprocess could be avoided .",
    "on the other hand , our current implementation method has the advantage that it is generally applicable without a need to change the internal query processor ( which is often not feasible ) .",
    "* other meta - query languages .",
    "* meta - sql is the first practical language for meta - querying . at the same time , however , it is firmly based on our past experience in designing formalisms for meta - querying . more specifically , two of us ( in collaboration with neven and van gucht ) have earlier introduced the _ reflective _ relational algebra @xcite and the _ meta _ relational algebra @xcite , two formal meta - query languages based on the relational algebra rather than on sql .",
    "the two formalisms differ in their approach : the reflective algebra is untyped , stores queries in so - called `` program relations '' , and uses the basic relational algebra operators for the syntactical manipulation ; in contrast , the meta algebra is statically typed and views stored queries as an abstract data type with specific operations for syntactical manipulation .",
    "meta - sql is the practical culmination of these two proposals , and stands in between the two approaches : like the meta algebra , it stores queries in an xml abstract data type , but like the reflective algebra , it is essentially untyped .",
    "every meta - query expressed in the reflective relational algebra , or in the meta relational algebra , can also be expressed in meta - sql .",
    "* schema querying . *",
    "starting with the seminal paper on hilog @xcite , the concept of _ schema querying _ has received considerable attention in the literature .",
    "clearly , schema querying is a special kind of meta - querying .",
    "for instance , schemasql @xcite augments sql with generic variables ranging over table names , rows , and column names .",
    "it is not difficult to simulate schemasql in meta - sql , using xml variables and ueval calls .",
    "of course , since schemasql is more specialized , it allows more opportunities for optimized implementation @xcite .    * commercial xml extensions . *",
    "all the major commercial ordbms vendors are providing xml extensions to their products , however , the emphasis there is mainly on publishing results of sql queries in xml format ( e.g. , @xcite ) , so that they can be further processed using the standard xml tools , including xslt .",
    "this combination of sql and xslt is clearly quite different in scope compared to the combination we have proposed in this paper .",
    "the other direction , where large xml documents are decomposed and stored in tabular format , has also been researched ( e.g. , @xcite ) and is getting into the commercial products .",
    "we also mention that several features of `` sql / xml '' @xcite such as the xml data type and the mapping of tables to xml values are similar to those found in this paper .",
    "moreover , an extract - like operator and functions operating on xml values ( albeit through xquery ) are listed among the future work .    * text extensions . *",
    "given that most database systems now support a text data type with better functions for text searching and editing than standard sql , one may wonder why we can not support meta - querying simply by representing the stored queries as text .",
    "the answer is that for many meta - queries the _ structure _ of the stored queries is important .",
    "for example , searching for the use of a certain view name in a query is more than a simple pattern search .",
    "using syntax trees and xslt makes structural querying very easy .",
    "* xml query languages . *",
    "although the focus of this paper has been on meta - querying as opposed to general xml querying , we still would like to conclude by pointing out that meta - sql , without eval , is not only a language for syntactical meta - querying , but can serve in general as a query language for databases containing xml documents in addition to ordinary relational data .",
    "its closeness to standard sql and object - relational processing is a major advantage . on the other hand",
    ", the treatment of xml documents as abstract data items seems less appropriate for `` pure '' xml databases , i.e. , huge xml documents .",
    "however , as already indicated above , there seems to be a strong trend in the database processing world to decompose such xml databases into relational data anyway .    [ [ acknowledgment ] ] acknowledgment",
    "+ + + + + + + + + + + + + +    we are indebted to frank neven and dirk van gucht for inspiring conversations .",
    "we also thank our students igor kalders , frank pilgrim , and jef vos for their help with the prototype implementation .",
    "10    s.  abiteboul , p.  buneman , and d.  suciu . .",
    "morgan kaufmann , 2000 .",
    "p.  bernstein et  al .",
    "the asilomar report on database research .",
    ", 27(4):7480 , 1998 .",
    "d.  chamberlin . .",
    "morgan kaufmann , 1998 .",
    "w.  chen , m.  kifer , and d.s .",
    "warren . : a foundation for higher - order logic programming .",
    ", 15(3):187230 , 1993 .",
    "s.  cluet .",
    "designing oql : allowing objects to be queried .",
    ", 23(5):279305 , 1998 .",
    "c.j . date . .",
    "addison - wesley , fourth edition , 1997 .",
    "a.  deutsch , m.f .",
    "fernandez , and d.  suciu .",
    "storing semistructured data with stored .",
    "_ sigmod 1999 _ , p  431442 .",
    "document object model ( dom ) level 2 core specification version 1.0 .",
    "w3c recommendation 13",
    "november 2000 . ` www.w3.org ` .",
    "a.   eisenberg , j.   melton .",
    "sql / xml and the sqlx informal group of companies .",
    "_ acm sigmod record _ 30 ( 3 ) 2001 .",
    "a.   eisenberg , j.   melton .",
    "sql / xml is making good progress . _",
    "acm sigmod record _ 31 ( 2 ) 2002 .",
    "fernandez , d.  suciu , and w.c .",
    "trading between relations and xml .",
    ", 33:723745 , 2000 .",
    "proceedings www9 .",
    "m.  kay . : the xslt processor . ` saxon.sourceforge.net ` .",
    "wrox press , 2001 .",
    "lakshmanan , f.  sadri , and i.n .",
    "subramanian . : a language for interoperability in relational multi - database systems .",
    "_ vldb 1996 _ , p  239250 .",
    "lakshmanan , f.  sadri , and i.n . subramanian . on efficiently implementing schemasql on an sql database system .",
    "_ vldb 1999 _ , p  471482 .",
    "j.  melton and a.  simon . .",
    "morgan kaufmann , 2001 .",
    "g.  moerkotte .",
    "incorporating xsl processing into database engines . _",
    "vldb 2002 _ , p  107 - 118 .",
    "f.  neven , j.  van  den bussche , d.  van  gucht , and g.  vossen . typed query languages for databases containing queries .",
    ", 24(7):569595 , 1999 .",
    "j.  shanmugasundaram , e.  shekita , et  al .",
    "efficiently publishing relational data as xml documents .",
    ", 10(23):133154 , 2001 .",
    "j.  shanmugasundaram , k.  tufte , c.  zhang , et  al .",
    "relational databases for querying xml documents : limitations and opportunities .",
    "_ vldb 1999 _ , p  302314 .",
    "m.  stonebraker and p.  brown . .",
    "morgan kaufmann , 1999 .",
    "m.  stonebraker et  al .",
    "extending a database system with procedures .",
    ", 12(3):350376 , 1987 .",
    "d.  tidwell . .",
    "oreilly & associates , 2001 .",
    "j.  van  den bussche , d.  van  gucht , and g.  vossen .",
    "reflective programming in the relational algebra .",
    ", 52(3):537549 , june 1996 .    extensible markup language ( xml ) 1.0 ( second edition ) .",
    "w3c recommendation 6 october 2000 . ` www.w3.org ` .",
    "path language ( xpath ) version 1.0 .",
    "w3c recommendation 16",
    "november 1999 . ` www.w3.org ` .    1.0 : an xml query language .",
    "w3c working draft 20 december 2001 . `",
    "www.w3.org ` .",
    "transformations ( xslt ) version 1.0 .",
    "w3c recommendation 16",
    "november 1999 . ` www.w3.org ` .",
    "the following is a reasonably complete dtd for syntax trees of sql-92 select - statements , with the exception of the various join operators .",
    "the dtd is derived from the grammar given by date @xcite .    ....",
    "< ! element query   ( ( select , from , where ?",
    ", group_by ? ,     having ? )   | ( union | except | intersect ) ) > <",
    "! element select   ( ( all | distinct ) ?",
    ",    ( wildcard | sel - item+ ) ) > < !",
    "element all empty > < !",
    "element distinct empty > < ! element wildcard empty > < ! element sel - item   ( ( column    | ( rangevar , ( column | wildcard ) ) )    | scalar    | aggregate )   , alias ? ) > < !",
    "element rangevar ( # pcdata ) > < !",
    "element column ( # pcdata ) > < !",
    "element column - ref   ( rangevar ? ,",
    "column ) > < !",
    "element scalar   ( alg - exp | concat - exp | column - ref   | aggregate | constant | query ) > < ! element aggregate   ( count - all   | ( ( avg | count | max | min | sum ) ,      ( all | distinct ) ? ,      ( alg - exp | concat - exp      | column - ref | constant      | query ) ) ) > < !",
    "element count - all empty > <",
    "! element avg empty > < !",
    "element count empty > < !",
    "element max empty > < !",
    "element min empty > < !",
    "element sum empty > < !",
    "element alg - exp   ( scalar , ( add | sub | mul | div ) ,    scalar ) > < ! element add empty > < !",
    "element sub empty > < !",
    "element mul empty > < !",
    "element div empty > < !",
    "element concat - exp   ( scalar , scalar ) > < !",
    "element constant ( # pcdata ) > < ! element from ( table - ref+ ) > <",
    "! element table - ref   ( ( table | query ) , alias ? ) > < !",
    "element alias ( # pcdata ) > < !",
    "element table ( # pcdata ) > < !",
    "element where ( cond - exp ) > < !",
    "element cond - exp   ( not ? , ( cond - test | and | or ) )",
    "element not empty > < !",
    "element cond - test   ( comparison | like | in   | match | all - or - any | exists   | unique | overlaps   | test - for - null ) > < !",
    "element and ( cond - exp , cond - exp+ ) >",
    "< ! element or ( cond - exp , cond - exp+ ) > < !",
    "element rowconstr   ( column - ref |",
    "scalar)+ > < !",
    "element comparison   ( rowconstr ,    ( eq | lt | let | gt | get | neq ) ,    rowconstr ) > < ! element eq empty > < ! element lt empty > <",
    "! element let empty > < !",
    "element gt empty > < !",
    "element get empty > < ! element neq empty > <",
    "! element like   ( ( column - ref | scalar ) ,    ( column - ref | scalar ) ,    ( column - ref | scalar ) ? ) > < ! element in   ( ( rowconstr , query )   | ( scalar , scalar+ ) ) > < !",
    "element partial empty > < !",
    "element full empty > < !",
    "element match    ( rowconstr , unique ? ,     ( partial|full ) ?",
    ", query ) > < !",
    "element all - or - any   ( rowconstr ,    ( eq | lt | let | gt | get | neq ) ,    ( all | any ) ? ,    query ) > < ! element any empty > < !",
    "element exists ( query ) > < !",
    "element unique ( query ) > < !",
    "element overlaps   ( scalar , scalar , scalar , scalar ) > < !",
    "element test - for - null ( rowconstr ) > < !",
    "element group - by ( column - ref+ ) > < ! element having ( cond - exp ) > < !",
    "element union ( query , all ? , query ) > < !",
    "element except   ( query , all ?",
    ", query ) > < !",
    "element intersect   ( query , all ? , query ) > ....",
    ".... function cartprod returns xml begin < xsl : template match=\"/ \" >   < query >    < select > < wildcard/ > < /select >    < from >",
    "< xsl : apply - templates            select=\"cmb/*\"/ >    < /from >   < /query > < /xsl : template > < xsl : template match=\" / cmb/ * \" >   < table - ref >     < xsl : copy - of select=\".\"/ >   < /table - ref >",
    "< /xsl : template > end    function pair param s string returns xml begin < xsl : param name=\"s\"/ > < xsl : template match=\"/ \" >   < pair >    < name >     < xsl : value - of select=\"$s\"/ >    < /name >    < xsl : copy - of select=\"*\"/ >   < /pair",
    "< /xsl : template > end    function rewrite param p xml returns xml begin < xsl : param name=\"p\"/ > < xsl : template match= \" * \" >   < xsl : copy >    < xsl : apply - templates/ >   < /xsl : copy > < /xsl : template > < xsl : template match=\"table \" >   < xsl : apply - templates select=\"$p \"                   mode=\"find \" >    < xsl : with - param name=\"search \"                   select=\"string(.)\"/ >    < xsl : with - param name=\"caller \" >     < xsl : copy - of select=\".\"/ >    < /xsl : with - param >",
    "< /xsl : apply - templates > < /xsl : template > < xsl : template match=\"/ \" mode=\"find \" >   < xsl : param name=\"search\"/ >   < xsl : param name=\"caller\"/ >   < xsl : param name=\"found \"    select=\"cmb / pair[name=$search]\"/ >   < xsl : choose >    < xsl : when test=\"$found \" >     < xsl : copy - of       select=\"$found / query\"/ >    < /xsl : when >    < xsl : otherwise >     < xsl : copy - of select=\"$caller\"/ >    < /xsl : otherwise >   < /xsl : choose > < /xsl : template > end ...."
  ],
  "abstract_text": [
    "<S> we describe a meta - querying system for databases containing queries in addition to ordinary data . in the context of such databases , </S>",
    "<S> a meta - query is a query about queries . </S>",
    "<S> representing stored queries in xml , and using the standard xml manipulation language xslt as a sublanguage , we show that just a few features need to be added to sql to turn it into a fully - fledged meta - query language . </S>",
    "<S> the good news is that these features can be directly supported by extensible database technology . </S>"
  ]
}