{
  "article_text": [
    "since sumer time  @xcite , and much later turing s machine tape  @xcite , read / write objects are certainly the most basic communication objects .",
    "such an object , usually called a _ register _ , provides its users ( processes ) with a write operation which defines the new value of the register , and a read operation which returns the value of the register .",
    "when considering sequential computing , registers are universal in the sense that they allow to solve any problem that can be solved  @xcite .",
    "[ [ register - in - message - passing - systems ] ] register in message - passing systems + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in a message - passing system , the computing entities communicate only by sending and receiving messages transmitted through a communication network . hence ,",
    "in such a system , a register is not a communication object given for free , but constitutes a communication abstraction which must be built with the help of the underlying communication network and the local memories of the processes .",
    "several types of registers can be defined according to which processes are allowed to read or write the register , and the quality ( semantics ) of the value returned by each read operation .",
    "we consider here registers which are single - writer multi - reader ( swmr ) , and atomic .",
    "atomicity means that ( a ) each read or write operation appears as if it had been executed instantaneously at a single point of the time line , between its start event and its end event , ( b ) no two operations appear at the same point of the time line , and ( c ) a read returns the value written by the closest preceding write operation ( or the initial value of the register if there is no preceding write )  @xcite .",
    "algorithms building multi - writer multi - reader ( mwmr ) atomic registers from single - writer single - reader ( swsr ) registers with a weaker semantics ( safe or regular registers ) have been introduced by l. lamport in  @xcite ( such algorithms are described in several papers and textbooks , e.g. ,  @xcite ) .",
    "many distributed algorithms have been proposed , which build a register on top of a message - passing system , be it failure - free or failure - prone . in the failure - prone case ,",
    "the addressed failure models are the process crash failure model , or the byzantine process failure model ( see , the textbooks  @xcite ) .",
    "the most famous of these algorithms was proposed by h. attiya , a. bar - noy , and d. dolev in  @xcite .",
    "this algorithm , which is usually called abd according to the names of its authors , considers an @xmath0-process asynchronous system in which up to @xmath1 processes may crash ( it is also shown in  @xcite that @xmath1 is an upper bound of the number of process crashes which can be tolerated ) .",
    "this simple and elegant algorithm , relies on ( a ) quorums  @xcite , and ( b ) a simple broadcast / reply communication pattern .",
    "abd uses this pattern once in a write operation , and twice in a read operation implementing an swmr register ( informal presentations of abd can be found in  @xcite ) .",
    "[ [ content - of - the - paper ] ] content of the paper + + + + + + + + + + + + + + + + + + + +    abd and its successors ( e.g. ,  @xcite ) associate an increasing sequence number with each value that is written .",
    "this allows to easily identify each written value .",
    "combined with the use of majority quorums , this value identification allows each read invocation to return a value that satisfies the atomicity property ( intuitively , a read always returns the `` last '' written value ) .",
    "hence , from a communication point of view , in addition to the number of messages needed to implement a read or a write operation , important issues are the number of different message types , and the size of the control information that each of them has to carry . as sequence numbers increase according to the number of write invocations , this number is not bounded , and the size of a message that carries a sequence number can become arbitrarily large .    a way to overcome this drawback",
    "consists in finding a modulo - based implementation of sequence numbers  @xcite , which can be used to implement read / write registers .",
    "considering this approach , one of the algorithms presented in  @xcite uses messages that carry control information whose size is upper bounded by @xmath3 bits ( where @xmath0 is the total number of processes ) . the algorithm presented in  @xcite reduced this size to @xmath4 bits .",
    "hence the natural question : `` _ how many bits of control information , a message has to carry , when one wants to implement an atomic read / write register ? _ '' .",
    "this is the question that gave rise to this paper , which shows that it is possible to implement an swmr atomic register with four types of message carrying no control information in addition to their type .",
    "hence , the result : _ messages carrying only two bits of control information are sufficient to implement an swmr atomic register in the presence of asynchrony and up to @xmath1 unexpected process crashes_. another important property of the proposed algorithm lies in its time complexity , namely , in a failure - free context and assuming a bound @xmath5 on message transfer delays , a write operation requires at most @xmath6 time units , and a read operation requires at most @xmath7 time units .    [ [ roadmap ] ] roadmap + + + + + + +    the paper is made up of  [ sec : conclusion ] sections . the computing model and the notion of an atomic register are presented in section  [ sec : model ] .",
    "the algorithm building an swmr atomic register , where messages carry only two bits of control information ( their type ) , in an asynchronous message - passing system prone to any minority of process crashes is presented in section  [ sec : algorithm ] .",
    "its proof appears in section  [ sec : proof ] .",
    "finally , section  [ sec : conclusion ] concludes the paper .",
    "[ [ processes ] ] processes + + + + + + + + +    the computing model is composed of a set of @xmath0 sequential processes denoted @xmath8 , ... , @xmath9 .",
    "each process is asynchronous which means that it proceeds at its own speed , which can be arbitrary and remains always unknown to the other processes .",
    "a process may halt prematurely ( crash failure ) , but executes correctly its local algorithm until it possibly crashes .",
    "the model parameter @xmath2 denotes the maximal number of processes that may crash in a run . a process that crashes in a run",
    "is said to be _",
    "faulty_. otherwise ,",
    "it is _ correct _ or _ non - faulty_. given a run , @xmath10 denotes the set of correct processes .",
    "[ [ communication ] ] communication + + + + + + + + + + + + +    each pair of processes communicate by sending and receiving messages through two uni - directional channels , one in each direction .",
    "hence , the communication network is a complete network : any process @xmath11 can directly send a message to any process @xmath12.a",
    "process @xmath11 invokes the operation `` @xmath13 type(@xmath14 ) @xmath15 @xmath12 '' to send to @xmath12 the message @xmath14 , whose type is type .",
    "the operation `` @xmath16 type ( ) @xmath17 @xmath12 '' allows @xmath11 to receive from @xmath12 a message whose type is type .",
    "each channel is reliable ( no loss , corruption , nor creation of messages ) , not necessarily first - in / first - out , and asynchronous ( while the transit time of each message is finite , there is no upper bound on message transit times ) .",
    "let us notice that , due to process and message asynchrony , no process can know if an other process crashed or is only very slow .",
    "[ [ notation ] ] notation + + + + + + + +    in the following , the previous computation model is denoted @xmath18 $ ] ( unconstrained @xmath10rash @xmath19synchronous @xmath20essage-@xmath21assing ) .",
    "[ [ definition ] ] definition + + + + + + + + + +    a _ concurrent object _ is an object that can be accessed by several processes ( possibly simultaneously ) .",
    "an swmr _ atomic _ register ( say @xmath22 ) is a concurrent object which provides exactly one process ( called the writer ) with an operation denoted @xmath23 , and all processes with an operation denoted @xmath24 .",
    "when the writer invokes @xmath25 it defines @xmath26 as being the new value of @xmath22 .",
    "an swmr atomic register is defined by the following set of properties  @xcite .",
    "* liveness .",
    "an invocation of an operation by a correct process terminates .",
    "* consistency ( safety ) .",
    "all the operations invoked by the processes , except possibly for each faulty process the last operation it invoked , appear as if they have been executed sequentially and this sequence of operations is such that : * * each read returns the value written by the closest write that precedes it ( or the initial value of @xmath22 if there is no preceding write ) , * * if an operation @xmath27 terminates before an operation @xmath28 starts , then @xmath27 appears before @xmath28 in the sequence .",
    "this set of properties states that , from an external observer point of view , the read / write register appears as if it is accessed sequentially by the processes , and this sequence ( a ) respects the real time access order , and ( ii ) belongs to the sequential specification of a register .",
    "more formal definitions can be found in  @xcite .",
    "( when considering any object defined by a sequential specification , atomicity is also called linearizability  @xcite , and it is then said that the object is _",
    "linearizable_. )    [ [ necessary - and - sufficient - condition ] ] necessary and sufficient condition",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the constraint @xmath29 is a necessary and sufficient condition to implement an atomic read / write register in @xmath18 $ ]  @xcite .",
    "hence , the corresponding constrained model is denoted @xmath30 $ ] .",
    "a distributed algorithm implementing an swmr atomic register in @xmath30 $ ] is described in figure  [ algo : two - bit - messages ] . as already indicated , this algorithm uses only four types of messages , denoted write0@xmath31 , write1@xmath31 , read@xmath31 , and proceed@xmath31 .",
    "the messages write0@xmath31 and write1@xmath31 carry a data value , while the messages read@xmath31 and proceed@xmath31 carry only their type .",
    "[ [ notation-1 ] ] notation + + + + + + + +    @xmath32 denotes the writer process , @xmath33 denotes the @xmath34 value written by @xmath32 , and @xmath35 is the initial value of the register @xmath22 that is built .    [ [ underlying - principles ] ] underlying principles + + + + + + + + + + + + + + + + + + + + +    the principle that underlies the algorithm is the following .",
    "first , each process ( a ) manages a local copy of the sequential history made up of the values written by the writer , and ( b ) forwards , once to each process , each new value it learns .",
    "then , in order that all processes obtain the same sequential history , and be able to read up to date values , each process @xmath11 follows rules to forward a value to another process @xmath12 , and manages accordingly appropriate local variables , which store sequence numbers",
    ".    * rule r1 .",
    "when , while it knows the first @xmath36 written values , and only them , @xmath11 receives the @xmath34 written value , it forwards it to all the processes that , from its point of view , know the first @xmath36 written values and no more . in this way , these processes will learn the @xmath34 written value ( if not yet done when they receive the corresponding message forwarded by @xmath11 ) .",
    "* rule r2 .",
    "the second forwarding rule is when @xmath11 receives the @xmath34 written value from a process @xmath12 , while it knows the first @xmath37 written values , where @xmath38 . in this case , @xmath11 sends the @xmath39 written value to @xmath12 , and only this value , in order @xmath12 increases its local sequential history with its next value ( if not yet done when it receives the message from @xmath11 ) .",
    "* rule r3 . to ensure a correct management of the local histories , and allow a process to help other processes in the construction of their local histories ( rules r1 and r2 ) , each process manages a sequence number - based local view of the progress of each other process ( as far as the construction of their local history is concerned ) .",
    "as we are about to see , translating these rules into an algorithm , provides us with a distributed algorithm where , while each process locally manages sequence numbers , the only control information carried by each message is its type , the number of different message types being very small ( namely @xmath40 , as already indicated ) '' implementation of sequence numbers carried by messages .",
    "this is because , from a control information point of view , each of the values in @xmath41 defines a distinct message type . ] .",
    "each process @xmath11 manages the following local data structures .",
    "* @xmath42 is the prefix sequence of the values already written , as known by @xmath11 ; @xmath42 is accessed with an array like - notation , and we have @xmath43=v_0 $ ] . as there is a single writer @xmath32 , @xmath44 represents the history of the values written so far . *",
    "@xmath45 $ ] is an array of sequence numbers ; @xmath46=\\alpha$ ] means that , to @xmath11 s knowledge , @xmath12 knows the prefix of @xmath44 until @xmath47 $ ] .",
    "hence , @xmath48 $ ] is the sequence number of the most recent value known by @xmath11 , and @xmath49 $ ] is the sequence number of the last value written ( by @xmath32 ) . *",
    "@xmath50 $ ] is an array of sequence numbers ; @xmath51=\\alpha$ ] means that , to @xmath11 s knowledge , @xmath12 answered @xmath52 of its read requests .",
    "* @xmath53 , @xmath54 and @xmath55 are auxiliary local variables , the scope of each being restricted to the algorithm implementing an operation , or the processing of a message , in which it occurs .",
    "as far as the messages write0@xmath31 and write1@xmath31 are concerned , the notation write@xmath56 is used for write0@xmath57 , and similarly , write@xmath58 is used for write1@xmath57 .",
    "when considering the two uni - directional channels connecting @xmath11 and @xmath12 , the algorithm , as we will see , requires ( a ) @xmath11 to send to @xmath12 the sequence of messages write@xmath59 , write0@xmath60 , write@xmath61 , ... , write@xmath62 , etc . , and ( b ) @xmath12 to send to @xmath11 the very same sequence of messages write@xmath59 , write0@xmath60 , write@xmath61 , ... , write@xmath62 , etc .",
    "moreover , the algorithm forces process @xmath11 to send to @xmath12 the message write@xmath62 , only when it has received from @xmath12 the message write@xmath63 . from the point of view of the write messages",
    ", these communication rules actually implement the _ alternating bit _",
    "protocol  @xcite , which ensures the following properties :    * property p1 : each of the two uni - directional channels connecting @xmath11 and @xmath12 allows at most one message write@xmath64 to bypass another message write@xmath64 , which , thanks to the single control bit carried by these messages allows the destination process ( e.g. , @xmath11 ) to process the messages write@xmath64 it receives from ( e.g. , @xmath12 ) in their sending order .",
    "* property p2 : @xmath11 and @xmath12 are synchronized in such a way that @xmath65 - w\\_sync_j[i]| \\leq 1 $ ] .",
    "this is the translation of property p1 in terms of the pair of local synchronization - related variables @xmath66 , w\\_sync_j[i]\\rangle$ ] .",
    "let us insist on the fact that this `` alternating bit '' message exchange pattern is only on the write messages .",
    "it imposes no constraint on the messages of the types read@xmath31 and proceed@xmath31 exchanged between @xmath11 and @xmath12 , which can come in between , at any place in the sequence of the write messages sent by a process @xmath11 to a process @xmath12 .",
    "this algorithm is described at lines  [ nc - swmr-01]-[nc - swmr-04 ] , executed by the writer @xmath32 , and line  [ nc - swmr-11]-[nc - swmr-18 ] , executed by any process .    [",
    "[ invocation - of - the - operation - sf - write ] ] invocation of the operation @xmath67 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when @xmath32 invokes @xmath68 ( we have then @xmath49=x-1 $ ] ) , it increases @xmath49 $ ] and writes @xmath33 at the tail of its local history variable ( line  [ nc - swmr-01 ] ) .",
    "this value is locally identified by its sequence number @xmath69 .",
    "then @xmath32 sends the message write@xmath70 , where @xmath71 , to each process @xmath12 that ( from its point of view ) knows all the previous write invocations , and only to these processes . according to the definition of @xmath72 $ ] , those are the processes @xmath12 such that @xmath73=wsn-1= w\\_sync_w[w]-1 $ ] ( line  [ nc - swmr-02 ] ) .",
    "let us notice that this ensures the requirement @xmath11 needs to satisfy when it sends a message in order to benefit from the properties provided by the alternating bit communication pattern .",
    "finally , @xmath32 waits until it knows that a quorum of at least @xmath74 processes knows the value @xmath33 is it writing .",
    "the fact that a process @xmath12 knows this @xmath34 value is captured by the predicate @xmath73=wsn(=x)$ ] ( line  [ nc - swmr-03 ] ) .    [",
    "[ reception - of - a - message - writebv - from - a - process - p_j ] ] reception of a message write@xmath75 from a process @xmath12 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when @xmath11 receives a message write@xmath75 from a process @xmath12 , it first waits until the waiting predicate of line  [ nc - swmr-11 ] is satisfied .",
    "this waiting statement is nothing else than the the reception part of the alternating bit algorithm , which guarantees that the messages write@xmath31 from @xmath12 are processed in their sending order .",
    "when , this waiting predicate is satisfied , all messages sent by @xmath12 before write@xmath75 have been received and processed by @xmath11 , and consequently the message write@xmath75 is the @xmath76 message sent by @xmath12 ( fifo order ) , where @xmath77 + 1 $ ] , which means that @xmath78=v$ ] ( line  [ nc - swmr-12 ] ) .",
    "when this occurs , @xmath11 learns that @xmath26 is the next value to be added to its local history if additionally we have @xmath48=wsn-1 $ ] . in this case",
    "( predicate of line  [ nc - swmr-13 ] ) , @xmath11 ( a ) adds @xmath26 at the tail of its history ( line  [ nc - swmr-14 ] ) , and ( b ) forwards the message write@xmath75 to the processes that , from its local point of view , know the first @xmath79 written values and no more ( line  [ nc - swmr-15 ] , forwarding rule r1 ) .    if @xmath80 $ ] , from @xmath11 s local point of view , the history known by @xmath12 is a strict prefix of its own history .",
    "consequently , @xmath11 sends to @xmath12 the message write@xmath81 , where @xmath82 and @xmath83 $ ] ( line  [ nc - swmr-16 ] applies the forwarding rule r2 in order to allow @xmath12 to catch up its lag , if not yet done when it will receive the message write@xmath81 sent by @xmath11 ) .",
    "finally , as @xmath12 sends to @xmath11 a single message per write operation , whatever the value of @xmath53 , @xmath11 updates @xmath46 $ ] ( line  [ nc - swmr-18 ] ) .",
    "[ [ remark ] ] remark + + + + + +    as far as the written values are concerned , the algorithm implementing the operation @xmath67 can be seen as a fault - tolerant `` synchronizer '' ( in the spirit of  @xcite ) , which ensures the mutual consistency of the local histories between any two neighbors with the help of an alternating bit algorithm executed by each pair of neighbors  @xcite .",
    "this algorithm is described at lines  [ nc - swmr-05]-[nc - swmr-10 ] executed by a reader @xmath11 , and lines  [ nc - swmr-19]-[nc - swmr-22 ] executed by any process .",
    "[ [ invocation - of - the - operation - sf - read ] ] invocation of the operation @xmath84 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the invoking process @xmath11 first increments its local read request sequence number @xmath85 $ ] and broadcasts its read request in a message read@xmath31 , which carries neither additional control information , nor a data value ( lines  [ nc - swmr-05]-[nc - swmr-06 ] ) . if @xmath11 crashes during this broadcast , the message read@xmath31 is received by an arbitrary subset of processes ( possibly empty ) .",
    "otherwise , @xmath11 waits until it knows that at least @xmath74 processes received its current request ( line  [ nc - swmr-07 ] ) .",
    "when this occurs , @xmath11 considers the sequence number of the last value in its history , namely @xmath86 $ ] ( line  [ nc - swmr-08 ] ) .",
    "this is the value it will return , namely @xmath87 $ ] ( line  [ nc - swmr-10 ] ) . but",
    "in order to ensure atomicity , before returning @xmath87 $ ] , @xmath11 waits until at least @xmath74 processes know this value ( and may be more ) . from @xmath11 s point of view , the corresponding waiting predicate translates in `` at least @xmath74 processes @xmath12 are such that @xmath46\\geq sn$ ] '' .    [",
    "[ reception - of - a - message - read - sent - by - a - process - p_j ] ] reception of a message read@xmath31 sent by a process @xmath12 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when a process @xmath11 receives a message read@xmath31 from a process @xmath12 ( hence , @xmath12 issued a read operation ) , it considers the most recent written value it knows ( the sequence number of this value is @xmath86 $ ] , line  [ nc - swmr-19 ] ) , and waits until it knows that @xmath12 knows this value , which is locally captured by the sequence number - based predicate @xmath46\\geq sn$ ] ( line  [ nc - swmr-20 ] ) .",
    "when this occurs , @xmath11 sends the message proceed@xmath31 to @xmath12 which is allowed to progress as far as @xmath11 is concerned .",
    "the control messages read@xmath31 and proceed@xmath31 ( whose sending is controlled by a predicate ) implement a synchronization which as far as @xmath11 is concerned forces the reader process @xmath12 to wait until it knows a `` fresh '' enough value , where `` freshness '' is locally defined by @xmath11 as the last value it was knowing when it received the message read@xmath31 from @xmath12 ( predicate of line  [ nc - swmr-20 ] ) .",
    "[ [ reception - of - a - message - proceed - sent - by - a - process - p_j ] ] reception of a message proceed@xmath31 sent by a process @xmath12 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when @xmath11 receives a message proceed@xmath31 from a process @xmath12 , it learns that its local history is as fresh as @xmath12 s history when @xmath12 received its message read@xmath31 .",
    "locally , this is captured by the incrementation of @xmath51 $ ] , namely @xmath12 answered all the read requests of @xmath11 until the @xmath88)^{\\mathit th}$ ] one .",
    "let us remind that @xmath89 is the set of correct processes , @xmath32 the writer , and @xmath33 the @xmath34 value written by @xmath32 .",
    "[ lemma - wsync - incrementation ] @xmath90 : @xmath46 $ ] increases by steps equal to @xmath91 .    as this lemma",
    "is used in all other lemmas , it will not be explicitly referenced .",
    "let us first observe that , due to the sending predicates of line  [ nc - swmr-02 ] ( for the writer ) , and lines  [ nc - swmr-15 ] and  [ nc - swmr-16 ] for any process @xmath11 , no process sends a message write@xmath64 to itself .    as far as @xmath48 $ ] is concerned , and according to the previous observation",
    ", we have the following .",
    "the writer increases @xmath49 $ ] only at line  [ nc - swmr-01 ] .",
    "any reader process @xmath11 increases @xmath48 $ ] at line  [ nc - swmr-14 ] , and due to line  [ nc - swmr-12 ] and the predicate of line  [ nc - swmr-13 ] , the increment is @xmath91 .",
    "let us now consider the case of @xmath46 $ ] when @xmath92 .",
    "an incrementation of such a local variable occurs only at line  [ nc - swmr-18 ] , where ( due to line  [ nc - swmr-12 ] ) we have @xmath77 + 1 $ ] , and the lemma follows .",
    "[ lemma - wsync - i - wrt - j ]",
    "@xmath93 \\geq w\\_sync_j[i]$ ] .",
    "let us first observe , that the predicate is initially true .",
    "then , a local variable @xmath94 $ ] is increased by @xmath91 , when @xmath12 receives a message write@xmath64 from @xmath11 ( lines  [ nc - swmr-12 ] and  [ nc - swmr-18 ] ) .",
    "process @xmath11 sent this message at line  [ nc - swmr-02 ] or  [ nc - swmr-16 ] if @xmath95 , and at lines  [ nc - swmr-15 ] or  [ nc - swmr-16 ] for any @xmath96 . if the sending of the message write@xmath97 by @xmath11 occurs at line  [ nc - swmr-02 ] or  [ nc - swmr-15 ] , @xmath11 increased @xmath48 $ ] at the previous line .",
    "if the sending occurs at line  [ nc - swmr-16 ] , @xmath48 $ ] was increased during a previous message reception .",
    "[ lemma - wsync - max ] @xmath98 : @xmath48=\\max \\{w\\_sync_i[j]\\}_{1\\leq j\\leq n}$ ]",
    ".    the lemma is trivially true for the writer process",
    "let us consider any other process @xmath11 , different from @xmath32 .",
    "the proof is by induction on the number of messages write@xmath64 received by @xmath11 .",
    "let @xmath99 be the predicate @xmath48=\\max \\{w\\_sync_i[j]\\}_{1\\leq j\\leq n}$ ] , where @xmath14 is the number of messages write@xmath64 processed by @xmath11 .",
    "the predicate @xmath100 is true .",
    "let us assume @xmath101 is true for any @xmath102 such that @xmath103 .",
    "let @xmath12 be the process that sends to @xmath11 the @xmath104 message write@xmath97 , and let @xmath48=x$ ] when @xmath11 starts processing this message .",
    "there are four cases to consider .",
    "* case 1 . when the message write@xmath64 from @xmath12 is processed by @xmath11",
    ", we have @xmath48 + 1=w\\_sync_i[j]+1 $ ] .",
    "as the predicate of line  [ nc - swmr-13 ] is satisfied when this message is processed , @xmath11 updates @xmath48 $ ] to the value @xmath105 at line  [ nc - swmr-14 ]",
    ". moreover , it also updates @xmath46 $ ] to the same value @xmath105 at line  [ nc - swmr-18 ] .",
    "as @xmath99 is true , it follows that @xmath106 is true after @xmath11 processed the message .",
    "* case 2 . when the message write@xmath64 from @xmath12 is processed by @xmath11 , we have @xmath46 + 1 < w\\_sync_i[i]=x$ ] . in this case",
    ", @xmath11 does not modify @xmath48 $ ] .",
    "it only updates @xmath46 $ ] to its next value ( line  [ nc - swmr-18 ] ) , which is smaller than @xmath107 . as @xmath99 is true , it follows that @xmath106 is true after @xmath11 processed the message . *",
    "when the message write@xmath64 from @xmath12 is processed by @xmath11 , we have @xmath46 + 1 = w\\_sync_i[i]=x$ ] . in this case , both the predicates of lines  [ nc - swmr-13 ] and  [ nc - swmr-16 ] are false .",
    "it follows that @xmath11 executes only the update of line  [ nc - swmr-18 ] , and we have then @xmath46 = w\\_sync_i[i]=x$ ] .",
    "as @xmath99 is true , @xmath106 is true after @xmath11 processed the message .",
    "* case 4 . when the message write@xmath64 from @xmath12 is processed by @xmath11 , we have @xmath46 + 1 > w\\_sync_i[i]+1 = x+1 $ ] . in this case , due to ( a ) @xmath46 \\leq   w\\_sync_i[i]$ ] ( induction assumption satisfied when the message write@xmath64 arrives at @xmath11 from @xmath12 ) , and ( b ) the fact that @xmath46 $ ] increases by step @xmath91 ( lemma  [ lemma - wsync - incrementation ] ) , we necessarily have @xmath48 + 1 \\geq w\\_sync_i[j]+1 $ ] , when the message is received . hence , we obtain @xmath46 + 1 > w\\_sync_i[i ] + 1 \\geq w\\_sync_i[j]+1 $ ] , a contradiction .",
    "it follows that this case can not occur .",
    "[ lemma - prefix - history ] @xmath98 : @xmath108 $ ] is a prefix of @xmath109 $ ] .",
    "the proof of this lemma rests on the properties p1 and p2 provided by the underlying `` alternating bit '' communication pattern imposed on the messages write@xmath64 exchanged by any pair of processes @xmath11 and @xmath12 .",
    "if follows from these properties ( obtained from the use of parity bits carried by every message write@xmath64 , and the associated wait statement of line  [ nc - swmr-11 ] ) that , @xmath11 sends to @xmath12 the message write@xmath110 , only after it knows that @xmath12 received write@xmath111 .",
    "moreover , it follows from the management of the local sequence numbers @xmath45 $ ] , that no process sends twice the same message write@xmath110 . finally , due to the predicate of line  [ nc - swmr-11 ] , two consecutive messages write@xmath112 and write@xmath113 sent by a process @xmath11 to a process @xmath12 are processed in their sending order .",
    "the lemma then follows from these properties , and the fact that , when at lines  [ nc - swmr-13]-[nc - swmr-14 ] a process @xmath11 assigns a value @xmath26 to @xmath114 $ ] , this value was carried by @xmath34 message write@xmath115 sent by some process @xmath12 , and is the value of @xmath116 $ ] .",
    "it follows that no two processes have different histories , from which we conclude that @xmath114= history_w[x]$ ] .",
    "[ lemma - eventual - history ] @xmath117 we have : + _ r1 : _",
    "@xmath118=w\\_sync_i[j]=x ) \\rightarrow p_i$ ] sent @xmath107 messages write@xmath64 to @xmath12 , + _ r2 : _",
    "@xmath118>w\\_sync_i[j]=x ) \\rightarrow p_i$ ] sent @xmath119 messages write@xmath64 to @xmath12 .",
    "both predicates are initially true ( @xmath48=w\\_sync_i[j]=0 $ ] and no message was previously sent by @xmath11 to @xmath12 ) .",
    "the variables involved in the premises of the predicates r1 and r2 can be modified in the execution of a write operation ( if @xmath11 is the writer ) , or when a message write@xmath64 arrives at process @xmath11 from process",
    "@xmath12 . let us suppose that r1 and r2 are true until the value @xmath107 , and let us show that they remain true for the value @xmath105 .    during the execution of a write operation ,",
    "if @xmath49=w\\_sync_w[j]=x$ ] , the local variable @xmath49 $ ] is incremented to @xmath105 , and the @xmath120 message write@xmath64 is sent by @xmath32 to @xmath12 ( lines  [ nc - swmr-01]-[nc - swmr-02 ] ) .",
    "r1 and r2 remain true .",
    "if @xmath49>w\\_sync_w[j]=x$ ] , the local variable @xmath49 $ ] is incremented at line  [ nc - swmr-01 ] , but no message is sent to @xmath12 at line  [ nc - swmr-02 ] , which falsifies neither r1 nor r2 . + when a process @xmath11 receives a message write@xmath64 from a process @xmath12 , there are also two cases , according to the values of @xmath48 $ ] and @xmath46 $ ] when @xmath11 starts processing the message at line  [ nc - swmr-12 ] .    * case 1 .",
    "@xmath48=w\\_sync_i[j]=x$ ] . in this case , the predicate of line  [ nc - swmr-13 ] is satisfied .",
    "it follows that both @xmath48 $ ] and @xmath46 $ ] are incremented to @xmath105 ( at line  [ nc - swmr-14 ] for @xmath48 $ ] and line  [ nc - swmr-18 ] for @xmath46 $ ] ) .",
    "moreover , when @xmath11 executes line  [ nc - swmr-15 ] we have @xmath48=w\\_sync_i[j]-1 $ ] , and consequently @xmath11 sends a message write@xmath64 to @xmath12 ( the fact this message is the @xmath39 follows from the induction assumption )",
    ". hence , r1 and r2 are true when @xmath11 terminates the processing of the message write@xmath64 received from @xmath12 .",
    "* case @xmath48>w\\_sync_i[j]=x$ ] . in this case ,",
    "@xmath46 $ ] is incremented to @xmath119 at line  [ nc - swmr-18 ] , while @xmath48 $ ] is not ( because the predicate of line  [ nc - swmr-13 ] is false ) .",
    "two sub - cases are considered according to the values of @xmath48 $ ] and @xmath46 $ ] . * * if @xmath48=x+1 $ ] ( this is the value @xmath46 $ ] will obtain at line  [ nc - swmr-18 ] ) , the predicate of line  [ nc - swmr-16 ] is false , and no message is sent to @xmath12 .",
    "r1 and r2 remains true , as , by the induction assumption , @xmath11 already sent @xmath105 messages write@xmath64 .",
    "* * if @xmath48>x+1 $ ] , the predicate of line  [ nc - swmr-16 ] is satisfied , and the @xmath121 message write@xmath64 is sent to @xmath12 at this line , maintaining satisfied the predicates r1 and r2 .",
    "[ lemma - i - j - sn ] @xmath122 , if @xmath48 = x$ ] , there is a finite time after which @xmath46\\geq x$ ] .",
    "let us first notice that , due to lemma  [ lemma - synchronizer ] , all write@xmath64 messages received by correct processes will eventually satisfy the predicate line  [ nc - swmr-11 ] and will be processed .",
    "the proof is by contradiction .",
    "let us assume that there exists some correct process @xmath12 such that @xmath46 $ ] stops increasing forever at some value @xmath123 .",
    "let us first notice that there is no message write@xmath64 in transit from @xmath12 to @xmath11 otherwise its reception by @xmath11 will entail the incrementation of @xmath46 $ ] from @xmath37 to @xmath124 , contradicting the assumption .",
    "so , let us consider the last message write@xmath64 sent by @xmath12 to @xmath11 and processed by @xmath11 .",
    "there are three cases to consider when this message is received by @xmath11 at line [ nc - swmr-11 ] .",
    "( let us remind that , due to to lemma [ lemma - wsync - max ] , @xmath48 \\geq w\\_sync_i[j]$ ] . )    * case 1 .",
    "@xmath48 = w\\_sync_i[j]=y-1<x-1 $ ] .",
    "the variables @xmath48 $ ] and @xmath46 $ ] are both incremented at lines  [ nc - swmr-14 ] and  [ nc - swmr-18 ] respectively to the value @xmath123 .",
    "as by assumption , @xmath48 $ ] will attain the value @xmath107 , it will be necessarily incremented in the future to reach @xmath107 . the next time @xmath48 $ ]",
    "is incremented , a message write@xmath64 is sent by @xmath11 to @xmath12 ( at line  [ nc - swmr-15 ] ) .",
    "due to lemma [ lemma - eventual - history ] , @xmath11 sent @xmath124 messages write@xmath64 to @xmath12 and eventually @xmath94 $ ] will be equal to @xmath124 .",
    "when the last of these messages arrives and is processed by @xmath12 , there are two cases .",
    "* * case @xmath125=y$ ] ( as @xmath11 sent @xmath124 messages write@xmath64 to @xmath12 , @xmath125 $ ] can not be smaller than @xmath37 ) . in this case ,",
    "@xmath125=y$ ] is increased , and a message write@xmath64 is necessarily sent by @xmath12 to @xmath11 ( line  [ nc - swmr-15 ] ) .",
    "this contradicts the assumption that the message we considered was the last message sent by @xmath12 to @xmath11 . *",
    "* case @xmath125\\geq y+1 $ ] . in this case , as @xmath11 sent previously @xmath37 messages to @xmath12 , we necessarily have @xmath94=y$ ] . in this case , the predicate of line  [ nc - swmr-13 ] is false , while the one of line  [ nc - swmr-16 ] is satisfied .",
    "hence , @xmath12 sends a message write@xmath64 to @xmath11 . a contradiction . * case 2 . @xmath48 = w\\_sync_i[j]+1=y < x$ ] . in this case , when @xmath11 receives the last message write@xmath64 from @xmath12 , the variable @xmath46 $ ] is incremented at line  [ nc - swmr-18 ] to the value @xmath123 .",
    "moreover , by the contradiction assumption , no more message write@xmath64 is sent by @xmath12 to @xmath11 .",
    "+ hence , we have now @xmath48 = w\\_sync_i[j]=y < x$ ] , and the variable @xmath48 $ ] will be incremented in the future to reach @xmath107 .",
    "a reasoning similar to the previous one shows that @xmath12 will send a message write@xmath64 to @xmath11 in the future , which contradicts the initial assumption .",
    "@xmath48 > w\\_sync_i[j]+1 $ ] .",
    "the reception by @xmath11 of the last message write@xmath64 from @xmath12 entails the incrementation of @xmath46 $ ] to its next value .",
    "however as @xmath48 > w\\_sync_i[j]$ ] remains true , a message write@xmath64 is sent by @xmath11 to @xmath12 at line  [ nc - swmr-16 ] .",
    "similarly to the previous cases , the reception of this message by @xmath12 will direct it to send another message write@xmath64 to @xmath11 , contradicting the initial assumption .    hence , @xmath46 $ ] can not stop increasing before reaching @xmath107 , which proves the lemma .",
    "[ lemma - synchronizer ] no correct process blocks forever at line  _ [ nc - swmr-11]_.    the fact that the waiting predicate of line  [ nc - swmr-11 ] is eventually satisfied follows from the following observations .    * as the network is reliable , all the messages that are sent are received . due to lines  [ nc - swmr-02 ] and  [ nc - swmr-15]-[nc - swmr-16 ] , this means that , for any @xmath107 , if write@xmath110 is received while @xmath14 = write@xmath111 has not , then @xmath14 will be eventually received . *",
    "the message exchange pattern involving any two messages write@xmath112 and write@xmath113 ( sent consecutively ) exchanged between each pair of processes is the `` alternating bit pattern '' , from which it follows that no two messages write@xmath97 ( with the same @xmath126 ) can be received consecutively .",
    "* it follows that the predicate of line  [ nc - swmr-11 ] is a simple re - ordering predicate for any pair of messages such that write@xmath127 was received before write@xmath111 . when this predicate is not satisfied for a message @xmath14 = write@xmath97 , this is because a message @xmath102 = write@xmath128 , will necessarily arrive and be processed before @xmath14 .",
    "after that , the predicate of line  [ nc - swmr-11 ] becomes true for @xmath14 .",
    "[ lemma - write - termination ] if the writer does not crash during a write operation , it terminates it .",
    "let us first notice that , due to lemma  [ lemma - synchronizer ] , the writer can not block forever at line  [ nc - swmr-11 ] .",
    "when it invokes a new write operation , the writer @xmath32 first increases the write sequence number @xmath49 $ ] to its next value @xmath53 ( line  [ nc - swmr-01 ] ) .",
    "if @xmath32 does not crash , it follows from lemma  [ lemma - i - j - sn ] that we eventually have @xmath48\\geq w\\_sync_w[i ] = wsn$ ] at each correct process @xmath11 .",
    "consequently , the writer can not block forever at line  [ nc - swmr-03 ] and the lemma follows .",
    "[ lemma - read - termination ] if a process does not crash during a read operation , it terminates it .",
    "let us first notice that , due to lemma  [ lemma - synchronizer ] , the reader can not block forever at line  [ nc - swmr-11 ] .    each time",
    "a process @xmath11 executes a read operation it broadcasts a message read@xmath31 to all the other processes ( line [ nc - swmr-06 ] ) .",
    "let us remind that its local variable @xmath129 $ ] counts the number of messages read@xmath31 it has broadcast , while @xmath130 $ ] counts the number of messages proceed@xmath31 it has received from @xmath12 ( line [ nc - swmr-22 ] ) in response to its read messages read@xmath31 .",
    "when the predicate of line  [ nc - swmr-07 ] becomes true at the reader @xmath11 , there are at least @xmath74 processes that answered the @xmath85 $ ] messages read@xmath31 it sent ( note that @xmath85 $ ] is incremented line [ nc - swmr-05 ] and @xmath11 does not send messages read@xmath31 to itself ) .",
    "we claim that each message read@xmath31 sent by @xmath11 to a correct process @xmath12 is eventually acknowledged by a a message proceed@xmath31 send by @xmath12 to @xmath11 .",
    "it follows from this claim and line  [ nc - swmr-22 ] executed by @xmath11 when it receives a message proceed@xmath31 , that the predicate of line  [ nc - swmr-07 ] is eventually satisfied , and consequently , @xmath11 can not block forever at line  [ nc - swmr-07 ] .",
    "proof of the claim .",
    "let us consider a correct process @xmath12 when it receives a message read@xmath31 from @xmath11 .",
    "it saves @xmath48 $ ] in @xmath55 and waits until @xmath94\\geq sn$ ] ( lines  [ nc - swmr-19]-[nc - swmr-20 ] ) . due to lemma",
    "[ lemma - i - j - sn ] , the predicate @xmath94\\geq sn$ ] eventually becomes true at @xmath12 .",
    "when this occurs , @xmath12 sends the message proceed@xmath31 to @xmath11 ( line  [ nc - swmr-21 ] ) , which proves the claim .",
    "let us now consider the wait statement at line  [ nc - swmr-09 ] , where @xmath55 is the value of @xmath48 $ ] when the wait statement of line  [ nc - swmr-07 ] terminates .",
    "let @xmath12 be a correct process .",
    "due to lemma  [ lemma - i - j - sn ] the predicate @xmath46 \\geq sn$ ] eventually holds . as this is true for any correct process @xmath12 , @xmath11 eventually exits the wait statement , which concludes the proof of the lemma .",
    "[ lemma - read - atomicity ] the register that is built is atomic .",
    "let @xmath131 $ ] be a read operation issued by a process @xmath11 which returns the value with sequence number @xmath107 ( i.e. , @xmath114 $ ] ) , and @xmath132 $ ] be the write operation which writes the value with sequence number @xmath37 ( i.e. , @xmath133 $ ] ) .",
    "the proof of the lemma is the consequence of the three following claims .",
    "* claim 1 .",
    "if @xmath131 $ ] terminates before @xmath132 $ ] starts , then @xmath134 .",
    "* claim 2 .",
    "if @xmath135 $ ] terminates before @xmath136 $ ] starts , then @xmath137 .",
    "* claim 3 .",
    "if @xmath131 $ ] terminates before @xmath138 $ ] starts , then @xmath137 .",
    "claim 1 states that no process can read from the future .",
    "claim 2 states that no process can read overwritten values .",
    "claim 3 states that there is no new / old read inversion  @xcite .",
    "+ proof of claim 1 .",
    "+ due to lemma  [ lemma - prefix - history ] , the value returned by @xmath131 $ ] is @xmath114= history_w[x]=v_x$ ] . as each write generate a greater sequence number , and @xmath32 has not yet invoked @xmath139 , we necessarily have @xmath38 .",
    "+ proof of claim 2 .",
    "+ it follows from lines  [ nc - swmr-01]-[nc - swmr-03 ] that when @xmath135 $ ] terminates , there is a quorum @xmath140 of at least @xmath74 processes @xmath11 such that @xmath73=x$ ] . on another side ,",
    "@xmath136 $ ] obtains messages proceed@xmath31 from a quorum @xmath141 at least @xmath74 processes ( lines  [ nc - swmr-22 ] and  [ nc - swmr-07 ] ) . as @xmath142 , @xmath143 , and @xmath144 , we have @xmath145 .",
    "let @xmath146 be a process of @xmath147 . as @xmath148=x$ ] , and @xmath149\\geq w\\_sync_w[k]$ ]",
    "( lemma  [ lemma - wsync - i - wrt - j ] ) , and @xmath135 $ ] is the last write before @xmath136 $ ] , we have @xmath149=x$ ] when @xmath136 $ ] starts .",
    "when @xmath146 received the message read@xmath31 from @xmath11 , we had @xmath149=x$ ] , and @xmath146 waited until @xmath150\\geq x$ ] ( line  [ nc - swmr-20 ] ) before sending the message proceed@xmath31 that allowed @xmath11 to progress in its waiting at line  [ nc - swmr-07 ] .",
    "as @xmath48 \\geq w\\_sync_k[i]$ ] ( lemma  [ lemma - wsync - i - wrt - j ] ) , it follows that we have @xmath48 \\geq x$ ] , when @xmath11 computes at line  [ nc - swmr-08 ] the sequence number @xmath55 of the value it will return at line  [ nc - swmr-10 ] ) .",
    "hence , the index @xmath151 computed by @xmath11 at line  [ nc - swmr-08 ] is such that @xmath152 \\geq x$ ] .",
    "+ proof of claim 3 .",
    "+ on one side , when @xmath131 $ ] stops waiting at line  [ nc - swmr-09 ] , there is a quorum @xmath153 of at least @xmath74 processes @xmath146 such that @xmath154 \\geq x$ ] ( predicate of line  [ nc - swmr-09 ] at @xmath11 ) . due to lemma  [ lemma - wsync - i - wrt - j ]",
    ", we have then @xmath149 \\geq x$ ] for any process @xmath146 of @xmath153 , when @xmath131 $ ] terminates .    on the other side , when @xmath138 $ ] stops waiting at line  [ nc - swmr-07 ] ( which defines the value it returns , namely , @xmath155 $ ] ) , there is a quorum @xmath156 of at least @xmath74 processes @xmath157 such that ( due to the waiting predicate of line  [ nc - swmr-20 ] ) @xmath158 \\geq sn(\\ell)$ ] , where @xmath159 is the value of @xmath160 $ ] when @xmath157 receives the message read@xmath31 from @xmath12 .",
    "as each of @xmath153 and @xmath156 contains at least @xmath74 processes , and there is a majority of correct processes , there is at least one correct process in their intersection , say @xmath161 .",
    "it follows that we have @xmath162 \\geq x$ ] when @xmath131 $ ] terminates , and @xmath163 \\geq sn(m)$ ] , where @xmath164 is the value of @xmath162 $ ] , when @xmath161 received the message read@xmath31 from @xmath12 .",
    "as @xmath162 $ ] never decreases , and @xmath161 receives the message read@xmath31 from @xmath12 after @xmath131 $ ] terminated , we necessarily have @xmath165 . hence , @xmath163 \\geq x$ ] , when @xmath161 sends proceed@xmath31 to @xmath12 . as ( lemma  [ lemma - wsync - i - wrt - j ] ) @xmath125 \\geq   w\\_sync_m[j]$ ]",
    ", it follows that the index @xmath55 computed by @xmath11 at line  [ nc - swmr-08 ] is such that @xmath166 .",
    "[ theorem - main ] the algorithm described in figure  _ [ algo : two - bit - messages ] _ implements an _ swmr _ atomic register in the system model @xmath167 $ ] .",
    "the theorem follows from lemma  [ lemma - write - termination ] and lemma  [ lemma - read - termination ] ( termination properties ) , and lemma  [ lemma - read - atomicity ] ( atomicity property ) .",
    "[ theorem - property ] the algorithm described in figure  _ [ algo : two - bit - messages ] _ uses only four types of messages , and those carry no additional control information .",
    "moreover , a read operation requires @xmath168 messages , and a write operation requires @xmath169 messages .",
    "the message content part of the theorem is trivial .",
    "a read generates @xmath0 messages read@xmath31 , and each of generates a message proceed@xmath31 .",
    "a write operation generates @xmath170 messages write@xmath97 from the writer to the other processes , and then each process forward once this message to each process .",
    "[ [ the - aim - and - the - paper ] ] the aim and the paper + + + + + + + + + + + + + + + + + + + + +    as indicated in the introduction , our aim was to investigate the following question : `` _ how many bits of control information messages have to carry to implement an atomic register in @xmath167 $ ] ? _ '' .",
    "as far as we know , all the previous works addressing this issue have reduced the size of control information with the use of a `` modulo @xmath0 '' implementation technique .",
    "table  [ table - comparaison ] presents three algorithms plus ours .",
    "these three algorithms are the unbounded version of the abd algorithm  @xcite , its bounded version , and the bounded algorithm due to h. attiya  @xcite .",
    "they all associate a sequence number with each written value , but differently from ours , the last two require each message to carry a `` modulo representative '' of a sequence number .    for each algorithm , the table considers the number of messages it uses to implement the write operation ( line 1 ) , the read operation ( line 2 ) , the number of control bits carried by messages ( line 3 ) , the size of local memory used by each process ( line 4 ) , the time complexity of the write operation ( line 5 ) , and the time complexity of the read operation ( line 6 ) , both in a failure - free context . for time",
    "complexity it is assumed that message transfer delays are bounded by @xmath5 , and local computations are instantaneous . the values appearing in the table for the bounded version of abd and attiya s algorithm are from  @xcite .",
    "the reader can see that the proposed algorithm is particularly efficient from a time complexity point of view , namely , it is as good as the unbounded version of abd .",
    ".a few algorithms implementing an swmr atomic register in @xmath167 $ ] [ cols=\"^,^,^,^,^,^ \" , ]     [ [ the - result - presented - in - the - paper ] ] the result presented in the paper + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as we have seen , our algorithm also uses sequence numbers , but those remain local .",
    "only four types of messages are used , which means that each implementation message carries only two bits of control information .",
    "moreover , only two message types carry a data value , the other two carry no data at all . hence , this paper answers a long lasting question : `` _ it is possible to implement an atomic register , despite asynchrony and crashes of a minority of processes , with messages whose control part is constant ? _ '' .",
    "the unbounded feature of the proposed algorithm ( when looking at the local memory size ) is due to the fact that the algorithm introduces a fault - tolerant version of a `` synchronizer '' suited to the implementation of an atomic register , which disseminates new values , each traveling between each pair of processes in both directions , in such a way that a strong synchronization is ensured between any pair of processes , independently from the other processes , ( namely , @xmath171 - w\\_sync_j[i]| \\leq 1 $ ] ) .",
    "this fault - tolerant synchronization is strong enough to allow sequence numbers to be eliminated from messages .",
    "unfortunately , it does not seem appropriate to allow a local modulo - based representation of sequence numbers at each process .",
    "in addition to its theoretical interest , and thanks to its time complexity , the proposed algorithm is also interesting from a practical point of view . due to the @xmath168 message cost of its read operation",
    ", it can benefit to read - dominated applications and , more generally , to any setting where the communication cost ( time and message size ) is the critical parameter , it has two possibilities . either send by return the last written value it knows , as done in abd - like algorithms . or wait until it knows that the sender has a value as up to date as it own value , and only then send it a signal , as done in our algorithm with the message proceed@xmath31 . ] .    [",
    "[ a - problem - that - remains - open ] ] a problem that remains open + + + + + + + + + + + + + + + + + + + + + + + + + + +    according to the previous discussion , a problem that still remains open is the following .",
    "is it possible to design an implementation where ( a ) a constant number of bits is sufficient to encode the control information carried by messages , and ( b ) the sequence numbers have a local modulo - based implementation ? we are inclined to think that this is not possible .",
    "this work has been partially supported by the french anr project displexity , which is devoted to computability and complexity in distributed computing , and the franco - german anr project discmat devoted to connections between mathematics and distributed computing .",
    "mostfaoui a. and raynal m. , time - efficient read / write register in crash - prone asynchronous message - passing systems .",
    "_ tech report 2031 _ , irisa , universit de rennes ( f ) , ( 2016 ) https://hal.inria.fr/hal-01256067              vitnyi p. m. b. and awerbuch b. , atomic shared register access by asynchronous hardware ( detailed abstract ) .",
    "27th annual symposium on foundations of computer science ( focs86 ) _ , ieee press , pp .",
    "233 - 243 ( 1986 )"
  ],
  "abstract_text": [
    "<S> atomic registers are certainly the most basic objects of computing science . </S>",
    "<S> their implementation on top of an @xmath0-process asynchronous message - passing system has received a lot of attention . </S>",
    "<S> it has been shown that @xmath1 ( where @xmath2 is the maximal number of processes that may crash ) is a necessary and sufficient requirement to build an atomic register on top of a crash - prone asynchronous message - passing system . </S>",
    "<S> considering such a context , this paper presents an algorithm which implements a single - writer multi - reader atomic register with four message types only , and where no message needs to carry control information in addition to its type . </S>",
    "<S> hence , two bits are sufficient to capture all the control information carried by all the implementation messages . </S>",
    "<S> moreover , the messages of two types need to carry a data value while the messages of the two other types carry no value at all . </S>",
    "<S> as far as we know , this algorithm is the first with such an optimality property on the size of control information carried by messages . </S>",
    "<S> it is also particularly efficient from a time complexity point of view . + * keywords * : asynchronous message - passing system , atomic read - write register , message type , process crash failure , sequence number , upper bound .     </S>",
    "<S> +   +   + </S>"
  ]
}