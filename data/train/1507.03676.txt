{
  "article_text": [
    "we teach a course _ logic for computing _ in a software engineering programme of studies . prior to this",
    ", students have received courses in calculus , algebra and introductory programming in java , plus a course called _ foundations of computing _ , which introduces polymorphic , higher - order functions and inductive types with the fundamental methods of induction and recursion in their various forms .",
    "_ foundations of computing _ makes emphasis on a mathematical approach to programming , specifically on correctness proofs . _ logic for computing _ , in turn , concerns itself essentially with the notion of _ formal _ proof .",
    "it follows from the foregoing that we should be very much interested in making explicit _ methods _ of proof . by this we mean both general strategies for developing and fully understanding solutions to problems , as well as manners of presenting the corresponding proofs which convey natural , concise and complete justifications of their design .",
    "now , as it turns out , we have observed that some methods that have arisen within what could be called the science of programming can be employed for obtaining or conveniently presenting mathematical results .",
    "this is to our mind a fact to be most welcome , for it exposes a unity of method between programming and mathematics that can not but bring about positive outcomes for both sides , at least in as much the learning and teaching aspects are concerned .    in this paper",
    "we present an example of the latter , concerning the presentation of the method of _ tableaux_. this is a proof procedure for both propositional and predicate logic dating back to @xcite and @xcite , and whose ultimate variant ( termed _ analytic _ tableaux ) has been introduced in @xcite .",
    "specifically , what we do is : ( 1 ) we derive the method as a set of equations to be used as rewriting rules from a straightforward specification , namely the one demanding the computation of the set of all models of the given set of formulas .",
    "( 2 ) we discuss the design of data structures for actually effecting and keeping trace of the execution of the method , which leads to the sorts of trees that are called `` the tableaux '' in textbooks . the first part yields a compact proof of the correctness of the method , much simpler than the ones in textbooks .",
    "the second part introduces the convenient and classical notation and establishes its correctness relating it to the set of equations originally given by a simple inductive argument . as a whole ,",
    "the process is one in which we repeatedly employ simple techniques of _ program derivation _ and _ separation of concerns _ to obtain a presentation and justification both modular and simpler of the method of tableaux .",
    "the rest of the paper consists of a general background section whose contents is assumed to be taught priorly to the study of tableaux . in section 3",
    "we present the derivation of the equational algorithm calculating the set of all models of given set of formula . in section 4",
    "we discuss the data structures for tracing the execution of the algorithm , leading to the usual presentations of tableaux , after which we finish up with a general discussion .",
    "the presentation is to be read basically as a concise course handout , with some explicit considerations of logical or didactic nature .",
    "* syntax . * it is enough to consider the set of connectives \\{@xmath0 , @xmath1}. then the set of formul  is defined as usual , starting out from a denumerable set @xmath2  of propositional letters ` p ` : @xmath3    we use _ signed _ formulae @xmath4 where @xmath5 , as the forms of assertion or judgement .",
    "* semantics .",
    "* interpretations belong in @xmath6@xmath7 .",
    "the _ semantic value _ of each formula is defined as follows  let @xmath8  be the set of formulae and ( @xmath9 ) and ( @xmath10 ) denote respectively boolean negation and conjunction :    @xmath11\\!]^{\\ _ } } } : : { \\ensuremath{a}}\\rightarrow { \\ensuremath{\\mathcal{i}}}\\rightarrow { \\ensuremath{\\mathsf{bool}}}$ ]    @xmath12{lll } { \\ensuremath{[\\ ! [ { \\texttt{p}}]\\!]^{i } } } & = & i\\,{\\texttt{p } } \\\\ { \\ensuremath{[\\ ! [ \\neg\\alpha]\\!]^{i } } } & = & { \\ensuremath{!}}\\,{\\ensuremath{[\\ ! [ \\alpha]\\!]^{i } } } \\\\ { \\ensuremath{[\\ ! [ \\alpha\\wedge\\beta]\\!]^{i } } } & = & { \\ensuremath{[\\ ! [ \\alpha]\\!]^{i}}}\\ { \\ensuremath{\\&\\&}}\\ { \\ensuremath{[\\ ! [ \\beta]\\!]^{i } } } \\end{array}$ ] .    using the former we now define _ truth _ of an assertion ( signed formula ) in an interpretation .",
    "call @xmath13 the boolean value corresponding to sign @xmath14 .",
    "then @xmath15\\!]^{i } } } = { \\ensuremath{\\hat{s}}}$ ] , which reads : @xmath16 is a _ model _ of @xmath17 , and also : @xmath16 _ satisfies _ @xmath18 or @xmath18 is _ valid in _ @xmath16",
    ". we shall consider _ finite _ sets @xmath19 of signed formulae and define models thereof ( i.e. @xmath20 ) as the interpretations satisfying every formula of @xmath19 .",
    "* truth in an interpretation .",
    "* it is generally interesting to develop a method for checking truth of signed formulae in an interpretation .",
    "if we start with the propositional letters , we get :    @xmath21    @xmath22\\!]^{i } } } = { \\ensuremath{\\hat{s } } } \\equiv^{\\mathrm{\\ ( semantic\\ function)}}$ ]    i`p ` = @xmath13 .    for the other cases we wish to obtain ( structurally ) recursive equations .",
    "as to negation , writing @xmath23 the sign opposite to @xmath14 , we obtain :    @xmath24    @xmath25\\!]^{i } } } = { \\ensuremath{\\hat{s } } } \\equiv^{\\mathrm{\\ ( semantic\\ function)}}$ ]    @xmath26\\!]^{i } } } = { \\ensuremath{\\hat{s } } } \\equiv^{\\mathrm{\\ ( negating\\ both\\ sides\\ to\\ isolate\\ { \\ensuremath{[\\ ! [ \\alpha]\\!]^{i}}})}}$ ]    @xmath27\\!]^{i } } } = \\ { \\ensuremath{!}}\\,{\\ensuremath{\\hat{s } } } \\equiv^{\\mathrm{\\ ( opposite\\ sign)}}$ ]    @xmath27\\!]^{i } } } = { \\ensuremath{\\hat{{\\ensuremath{\\overline{s } } } } } } \\equiv^{\\mathrm{\\ ( model\\ of\\ signed\\ formula)}}$ ]    @xmath28 .    finally , turning to conjunction :    @xmath29    @xmath30\\!]^{i } } } = { \\ensuremath{\\hat{s } } } \\equiv^{\\mathrm{\\ ( semantic\\ function)}}$ ]    @xmath31\\!]^{i}$ ]  @xmath10  @xmath32\\!]^{i}$ ] = @xmath13 ,    where we seem to get stuck .",
    "indeed , to rewrite the left hand side requires to consider the definition of ( @xmath10 ) and this is not uniform with respect to truth and falsity .",
    "therefore we are led to try instead distinguishing the cases of @xmath14 :    _ case _ :    @xmath33 @xmath34    @xmath31\\!]^{i}$ ]  @xmath10  @xmath32\\!]^{i}$ ] = _ true _",
    "@xmath35    @xmath31\\!]^{i}$]= _ true _",
    "@xmath36 from @xmath36 , the first being the conjunction in the object language , the second being the conjunction in the meta - language . likewise with @xmath37 and @xmath38 . ] @xmath32\\!]^{i}$ ] = _ true _",
    "@xmath39    @xmath40 @xmath36 @xmath41 .    _ case _ :    @xmath42 @xmath34    @xmath31\\!]^{i}$ ]  @xmath10  @xmath32\\!]^{i}$ ] = _ false _",
    "@xmath43    @xmath31\\!]^{i}$]= _ false _ @xmath38 @xmath32\\!]^{i}$ ] = _ false _",
    "@xmath39    @xmath44 @xmath38 @xmath45",
    ".    ultimately , we arrive at the following characterisation of the satisfaction relation :    @xmath46",
    "we now set ourselves the problem of computing _ all models _ of any given finite set @xmath19 of signed formulae .",
    "this is accomplished by the function    @xmath47    @xmath48 ,    where @xmath49  is the set of signed formulae , @xmath50 is the power set operator yielding the set of subsets of given set , and @xmath51 does the latter for the finite subsets .",
    "then any interpretation assigning _ true _ to ` p ` is a member of the answer set .",
    "we shall see later how to settle this issue in detail the general idea is to give a finite sufficient characterisation of infinite sets of interpretations . ] .",
    "now this straightforward definition presents the inconvenience that , as a method of computation , it obliges to construct all the interpretations and check each of them against the formulae  in @xmath19 .",
    "we are rather in the search of a syntactic procedure , i.e. one that applied exclusively to the formulae in @xmath19 ends up arriving at the desired set of models . let us then examine @xmath19 .    first of all , @xmath19 could be empty , which is indeed a plainly uninteresting case .",
    "indeed , every interpretation trivially satisfies the empty set of formulae and so the result in such case is @xmath6 .",
    "so let us assume @xmath52 .",
    "if this is the case , then we can pick any one of the formulae @xmath53 in @xmath19 and write the latter in the form @xmath54 , which means that @xmath55 and @xmath56 . given the former",
    ", we can now write :    @xmath57    @xmath58    @xmath59    @xmath60 .",
    "the only source of information in the latter expression is the analysis of the form of @xmath53 , and so we are led to an examination of cases , i.e. to considering :    @xmath61 ,    @xmath62 ,    @xmath63 .",
    "we can make profit of this analysis by using the results obtained at the end of the preceding section for checking the truth of signed formulae in a given interpretation .",
    "as it happens , the first case is a bit discouranging , for the satisfiability condition @xmath64 takes us to consider the value of ` p ` in the given interpretation , i.e. a semantic rather than a syntactic move .",
    "but it pays off to insist .",
    "negation gives the following : @xmath65    @xmath66    @xmath67    @xmath68    @xmath69 ,    where we have used @xmath70 instead of @xmath71 for set union .",
    "notice that it is indeed this operation and not the formerly used split @xmath72 which is to be employed in this case , for we do not now know whether the formula @xmath73 belongs or not to @xmath74 .",
    "the equation thus obtained , namely    @xmath75 ,    is very convenient , for it rewrites the desired set of all models into an expression in which the overall complexity of the formulae has been strictly decreased .",
    "the same works for conjunction , whose results with respect to satisfiability can be used by distinguishing the two cases of the sign affecting it :    @xmath76    @xmath77    @xmath78    @xmath79    @xmath80 .    on the other hand :    @xmath81    @xmath82    @xmath83    @xmath84    @xmath85    @xmath86    @xmath87 .    as a result",
    "we have so far obtained :    @xmath88    @xmath89    @xmath90 ,    where the case of a signed letter , i.e. a _ literal _ , could not be included . now taking a look at the preceding equations for @xmath91",
    ", we readily realize that the missing case is actually that of a set not containing any composite formulae , i.e. that of a set of literals .",
    "such is the base case of our recursion , since this proceeds by decreasing the size of the formulae of the set being treated and not the size of the set itself .",
    "therefore it is natural to wonder whether the solution of such base case could actually be just immediate .",
    "this is indeed the case , because there is a straightforward manner of converting a set @xmath19 of literals into the set of all its models .",
    "there are two cases :    @xmath92 : :    @xmath19 contains pairs of opposite literals .",
    "then it is    inconsistent and the set of its models is @xmath93 .",
    "@xmath92 : :    otherwise the models of @xmath19 are the interpretations    that coincide with @xmath19 at the letters mentioned in    it .    formally , call @xmath94 the set of all models of the set @xmath19 of literals .",
    "it is defined as follows :    @xmath95    notice that the alternative is decidable and that in the second case the result is sufficiently characterised by the set @xmath19 of literals and so we get a finite representation of it .",
    "we can then put together equations for actually computing @xmath91 :    @xmath89    @xmath90    @xmath88    @xmath96 if @xmath19 is a set of literals .",
    "we claim that @xmath91  captures the essence of the method of tableaux , and the derivation carried out above gives actually a quite simple proof of its correctness .",
    "nevertheless , its actual execution needs to employ some kind of data structure to record the successive transformations leading to the final result .",
    "that is what we turn now to examining .",
    "* list of lists . *",
    "if we ignored the second equation above we would be in presence of a tail - recursive algorithm , i.e. one whose execution could consist merely in successively rewriting the finite set of formulae at hand .",
    "we would then do simply with a list of formulae from which we would choose the next formula to be transformed .",
    "now , consideration of the second equation does not in principle introduce any dramatic modification of this situation : it is enough that each application of the equation produces a split of the list from which the formula @xmath97 is taken into two lists , each of it containing exactly one of the two formulae @xmath98 and @xmath99 in place of the original one , without any further change .",
    "we illustrate this by means of an example .",
    "suppose we consider @xmath100 $ ] , which we already make into a _ list _ of formulae ( as indicated by the use of the @xmath101 $ ] notation ) .",
    "then we may choose say the second formula to proceed , which leads us to employ @xmath91 s second equation splitting the original list into two , yielding @xmath102 , [ { \\textsf{t}}({\\texttt{p}}\\wedge\\neg{\\texttt{q } } ) , { \\textsf{f}}{\\texttt{q}}]$ ] .",
    "+ in the next step we may choose any one of the two occurrences of the only composite ( i.e. non - literal ) formula . say we take the left one .",
    "the equation to employ is @xmath91 s first , yielding @xmath103 , [ { \\textsf{t}}({\\texttt{p}}\\wedge\\neg{\\texttt{q } } ) , { \\textsf{f}}{\\texttt{q}}]$ ] .",
    "of course we may do the same with the right occurrence of the formula just considered , arriving at @xmath103 , [ { \\textsf{t}}{\\texttt{p } } , { \\textsf{t}}(\\neg{\\texttt{q } } ) , { \\textsf{f}}{\\texttt{q}}]$ ] .",
    "we now are left only with the two occurrences of @xmath104 to treat , which we must do in two steps using the third equation of @xmath91 .",
    "we write the final result at once : @xmath105 , [ { \\textsf{t}}{\\texttt{p } } , { \\textsf{f}}{\\texttt{q } } , { \\textsf{f}}{\\texttt{q}}]$ ] .",
    "clearly the first set of literals is unsatisfiable which , by the way , we could have noticed some steps earlier , thereby obtaining a less expensive development .",
    "the second set is just @xmath106 and characterizes all the models of the original @xmath19 .",
    "there seem to be three inconveniences as to this execution .",
    "the first is that we have treated one and the same formula twice , and that on two different occasions .",
    "one readily realizes that the issue is avoidable if the use of the branching equation corresponding to a false conjunction is always subsequent to the use of every other ( non - branching ) equation formerly applicable .",
    "the second inconvenience is that we have rewritten many a formula that was without change . and , finally , the execution is awkwardly traceable we have namely indicated the successive steps taken by means of narrative text interspersed in the successive rewritings .",
    "the latter is of importance when we consider executions by hand then a more formal and easily checkable notation would be most welcome by both students and teachers .",
    "we shall consider these two remaining issues in the next two subsections , beginning with the latter about an easily traceable notation .",
    "* tree of lists . * the straightforward manner of making executions like the former traceable and easily verifiable is just to record the application of each rule , including mention to the formula used .",
    "we should therefore begin by naming the equations of the algorithm , say @xmath107 , @xmath108 , @xmath109 and @xmath110 in the order in which they are written above .",
    "the procedure leads to the deployment of a tree structure whose nodes are lists of formulae as in the preceding section , and whose internal nodes ( not leaves ) are decorated by labels as explained presently :    1 .   to begin with",
    ", we have only one item , namely the original list of formula .",
    "this is of course a tree with only one terminal node ( leaf ) .",
    "2 .   at each step",
    "we choose a composite formula within a leaf ( call this leaf @xmath111 ) and apply the corresponding rule as already explained . as a result one or two",
    "new lists of formulae are obtained , which are linked to @xmath111 , becoming successors of @xmath111 in the tree . at the same time we label @xmath111 with the name of the equation and the formula used .",
    "the leaves of these trees coincide with the lists of formulae obtained by the procedure explained in the preceding paragraph we have only added a tree structure on top of them for tracing their computation",
    ". therefore , the set of models of the root of the tree obtains as the union of the sets of models of the leaves .",
    "formally , this much becomes clear after the consideration that the union of the sets of models of the leaves , and therefore the invariant just mentioned , are indeed preserved by each application of one equation as described above .",
    "therefore the correctness of the computation procedure using these trees follows by straightforward mathematical induction .",
    "the right formulation and proof of this result is left as exercise .",
    "notice that the preceding description amounts to inductively defining these trees as a family @xmath112 indexed by the finite sets @xmath19 in a manner such that the constructors stand in correspondence with the equations as named above , in the following manner : to internal nodes , constructors @xmath107 , @xmath108 and @xmath109 are associated , corresponding to the equation used in each case .",
    "the leaves are the as yet untreated nodes or those already formed by literals only . in either case",
    "we associate to the leaf the constructor @xmath110 .",
    "unfortunately , we must skip a detailed explanation for reasons of space .",
    "* tree of formulae . * the repetition of possibly large lists of formulae along the trees as introduced in the preceding section can be avoided , e.g. by employing the procedure described in @xcite .",
    "we describe these less expensive trees as follows .",
    "the general idea is to write at each node of the tree different from the root only the formulae originated by the use ( decomposition ) of another formula .",
    "the root of the tree will contain the originally given set ( list ) of formulae . with this information it is possible to compute the full trees of the preceding paragraph",
    "provided the used formulae are recorded at each step , i.e. at each node .",
    "therefore , the correctness of the present method with improved trees will follow from the correctness of the prior method .",
    "specifically , we define the improved trees as follows :    1 .",
    "each node will have associated an explicit set @xmath113 and an implicit set @xmath19 of formulae .",
    "@xmath113 is to be written down explicitly , whereas @xmath19 is to be computed when necessary .",
    "2 .   for the root of the tree , both @xmath113 and @xmath19 coincide with the originally given set of formulae .",
    "3 .   for the other nodes , @xmath113 will consist of one or two formulae . 4 .",
    "all internal ( i.e. non - leaf ) nodes will also have associated one formula , to be called the one _ used _ at the node .",
    "we now indicate how to extend the tree down from a leaf :    1 .",
    "a formula in @xmath19 is chosen and written down at the node as its used formula .",
    "2 .   then one proceeds according to the form of the chosen formula : 1 .   in case",
    "it is of the form @xmath114 then the tree is extended with _",
    "one _ child node . for this new node , @xmath115 .",
    "2 .   in case",
    "it is of the form @xmath116 then the tree is extended with _ two _ children nodes .",
    "one of them will have @xmath117 , whereas the other one will have @xmath118 .",
    "3 .   finally ,",
    "in case the chosen formula is of the form @xmath119 then the tree is extended with _",
    "one _ child node having @xmath120 .",
    "+ for every case of newly created node , the set @xmath19 is computed as follows : if @xmath121 is the implicit set of the parent node , then @xmath122 , where @xmath123 denotes deletion of a member in a set .",
    "now , to each improved tree @xmath124 with a non - leaf root which has associated explicit set @xmath113 and implicit set @xmath19 of formulae , as well as used formula @xmath53 , a full tree of type @xmath112 can be associated , whose constructor is the one corresponding to the form of @xmath53 , i.e. @xmath107 , @xmath108 or @xmath109 , and its children trees are the ones ( recursively ) corresponding to the children trees of @xmath124 .",
    "if otherwise @xmath124 is just a leaf , then its corresponding full tree is @xmath125 , where @xmath19 is the implicit set of formulae of the leaf in question .",
    "this correspondence gives already a method for using the improved trees in order to compute all the models of any given set of formulae .",
    "nevertheless , the following result makes such process easier : the implicit set at each leaf is the union of the explicit sets at the branch ending up at the leaf in question , minus those formulae that have been used on that branch .",
    "thereby one can determine when a branch is _ completed _ , which happens when the implicit set at the corresponding leaf is a set @xmath19 of literals .",
    "further , then @xmath94 is the corresponding set of models , and one can then compute the set of models of the whole tree ( i.e. of the originally given set of formulae ) by taking the union of the sets at each leaf , just as with the full trees .",
    "we have put forward a presentation of classical propositional tableaux elaborated by application of some principles that are noteworthy in program design .",
    "foremost among those principles is the one of _ separation of concerns _ :",
    "we have namely started by deriving from a straightforward specification an algorithm given as a set of recursive equations for computing all models of a finite set of formulae .",
    "the correctness of the algorithm is brought about hand - in - hand with its derivation by means of a basic inductive argument whose cases are each solved by calculational reasoning yielding identities between sets of interpretations that need not the usual `` ping - pong '' ( or direct - and - converse ) argument .",
    "thereafter we discussed the employment of data structures , mainly with regard to a manual execution of the algorithm .",
    "a requirement of natural traceability and verification led us to the trees of sets or lists of formulae presented in @xcite , the correctness of which is immediate after their derivation as traces of the employment of the original equations .",
    "a further improvement avoids repetition of unmodified formulae giving rise to the trees presented in @xcite , whose correctness is in turn guaranteed by showing that they carry the same information as the former trees .",
    "smullyan s classical presentation @xcite introduces instead the method as a proof procedure for establishing unsatisfiability of ( finite ) sets of ( signed ) formulae .",
    "the tableaux are given directly in the form of our improved trees of formulae .",
    "the proof of correctness is then as usual composed by two arguments , one of soundness and one of completeness , to the effect that unsatisfiable sets give rise to _ closed _ tableaux , i.e. one in which every branch contains a contradiction and thus has no model .",
    "the proof of soundness is by a quite direct tree induction , whereas the proof of completeness involves showing that an open _ completed _ branch , i.e. one in which every formula has been fully decomposed , is a hintikka set . besides",
    ", hintikka s lemma is proven , to the effect that every hintikka set has a model .    in our experience",
    ", the use of the method as in the classical presentation leads students to the realisation that they either prove the given set of formulae inconsistent or can compute every counter - example ( i.e. a sufficient characterisation thereof ) .",
    "subsequently they tend to ask why we can not establish such fact as a meta - theoretical result .",
    "our presentation does precisely that and the correctness of the method as a proof procedure follows as immediate corollary .",
    "the idea of computing all models of the given set of formula has led us to give an abstract formulation of the procedure .",
    "we then treat as a separate matter the question of the concrete trace of the manual execution of the method . as we have been able to check",
    ", this treatment provides the students with improved command over the method , i.e. they exercise a more sound domain over what they are doing and also over the various possible notations or manners of justification they can give thereof .",
    "it could be argued that smullyan s presentation and proof is scalable to infinite sets of formulae and first - order - logic , and therefore ask about such feature regarding our presentation .",
    "concerning infinite sets of formulae , the first thing to say is that the validity of our equations is certainly not affected .",
    "nevertheless , they can not of course be interpreted anymore as an algorithm . even if we assume as usual a principle of omniscience concerning the infinite sets , the method of choice of the formulae to be succesively decomposed by application of the equations is essential for getting the right result .",
    "but , as is the case also with the classical presentation , there exist method of orderly choice that guarantee ( under the ominiscience principle ) the computation of all models and thus the correctness of the method .",
    "generalisation to first - order logic , on the other hand , requires to abandon the idea of `` computing all models '' , replacing it by e.g. `` determining whether the set of formulae is or not ( un)satisfiable '' .",
    "we conclude that our presentation may contribute in a better way to the achievement of _ profficiency with understanding _ , which is our main learning objective .",
    "also it emphasizes design methodology , which we strive to do along and across the whole of the program of studies .",
    "it also could be argued that the method is tailored to just students of computing science or software engineering .",
    "we however believe that it can be taught also without much difficulty to mathematics or philosophy students and that the advantages we claim to obtain can also be appreciated in such cases .",
    "this , however , is yet to be checked out .",
    "finally , we should like to think of this work as one interpretation and case of the disclosing of the `` doing '' of mathematics as advocated by dijkstra @xcite .",
    "we have tried to avoid all gaps of both mathematical and motivational nature . to our mind , this case is yet another sample of the unity of structure and method that mathematics and programming share .",
    "exploiting such unity should be fruitful for improving understanding and thus better helping learning .    3 hintikka , k. j. j. _ form and content in quantification theory .",
    "_ acta philosophica fennica , 8 , 7 - 55 , 1955 .",
    "beth , e. w. _ the foundations of mathematics . _ north holland 1959 .",
    "smullyan r. m. _ first - order logic .",
    "_ dover , 1994 .",
    "an unabridged , corrected republication of the work first published by springer - verlag , new york , 1968 .",
    "ben - ari , m. _ mathematical logic for computer science .",
    "_ springer , 2012 .",
    "dijkstra , e. w. _ ewd 1059_. http://www.cs.utexas.edu/users/ewd/index10xx.html"
  ],
  "abstract_text": [
    "<S> we propose a presentation of classical propositional tableaux elaborated by application of methods that are noteworthy in program design , namely program derivation with separation of concerns . </S>",
    "<S> we start by deriving from a straightforward specification an algorithm given as a set of recursive equations for computing all models of a finite set of formulae . </S>",
    "<S> thereafter we discuss the employment of data structures , mainly with regard to an easily traceable manual execution of the algorithm . </S>",
    "<S> this leads to the kinds of trees given usually as constituting the tableaux . </S>",
    "<S> the whole development strives at avoiding gaps , both of logical and motivational nature . </S>"
  ]
}