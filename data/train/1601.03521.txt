{
  "article_text": [
    "the seriation problem , introduced by robinson @xcite for chronological dating , is a classic and well known sequencing problem , where the goal is to order a given set of objects in such a way that similar objects are ordered close to each other ( see e.g.  @xcite and references therein for details ) .",
    "this problem arises in many applications where objects are given through some information about their pairwise similarities ( or dissimilarities ) ( like in data about user ratings , images , sounds , etc . ) .",
    "the seriation problem can be formalized using a special class of matrices , namely robinson matrices .",
    "a symmetric matrix @xmath4 is a _ robinson similarity matrix _ if its entries are monotone nondecreasing in the rows and columns when moving toward the main diagonal , i.e. , if @xmath5 for all @xmath6 .",
    "given a set of @xmath7 objects to order and a symmetric matrix @xmath8 whose entries represent their pairwise similarities , the seriation problem asks to find a permutation  @xmath9 of @xmath10 $ ] so that the matrix @xmath11 , obtained by permuting both the rows and columns of @xmath12 simultaneously according to @xmath9 , is a robinson matrix .",
    "the matrix  @xmath12 is said to be a _",
    "robinsonian similarity matrix _ if such a permutation exists .",
    "the robinsonian structure is a strong property and , even though it might be desired in some problems , the data could be affected by noise , leading to the need to solve seriation in presence of error . finding a robinsonian matrix which is closest in the @xmath13-norm to a given similarity matrix is an np - hard problem  @xcite .",
    "we refer to  @xcite for an approximation algorithm and to  @xcite for approaches to this problem .",
    "nevertheless , robinsonian matrices play an important role also when data is affected by noise , as robinsonian recognition algorithms can be used as core subroutines to design efficient heuristics or approximation algorithms for solving seriation in presence of errors ( see , e.g. , @xcite ) . in this paper",
    "we consider the problem of recognizing whether a given @xmath0 matrix is robinsonian .    in the past years",
    ", different recognition algorithms for robinsonian matrices have been studied . the first polynomial algorithm to recognize robinsonian matrices",
    "was introduced by mirkin and rodin @xcite .",
    "it is based on the characterization of robinsonian matrices in terms of interval hypergraphs , and it uses the pq - tree algorithm of booth and leuker  @xcite as core subroutine , with an overall running time of @xmath14 .",
    "chepoi and fichet @xcite introduced later a simpler algorithm using a divide - and - conquer strategy applied to preprocessed data obtained by sorting the entries of @xmath12 , lowering the running time to @xmath15 . using the same sorting preprocessing , seston",
    "@xcite improved the complexity of the recognition algorithm to @xmath16 .",
    "recently , pra and fortin @xcite presented an optimal @xmath17 algorithm , using the algorithm from booth and leuker  @xcite to compute a first pq - tree which they update throughout the algorithm . while all these algorithms use the connection to interval graphs or hypergraphs , in our previous work @xcite we presented a recursive recognition algorithm exploiting a connection to unit interval graphs and with core subroutine lexicographic breadth - first search ( lex - bfs or lbfs ) , a special version of breadth - first search ( bfs ) introduced by rose and tarjan @xcite .",
    "the algorithm of @xcite is suitable for sparse matrices and it runs in @xmath18 time , where @xmath1 is the number of nonzero entries of @xmath12 and @xmath19 is the depth of the recursion tree computed by the algorithm , which is upper bounded by the number of distinct nonzero entries of @xmath12 .",
    "while all the above mentioned recognition algorithms are combinatorial , atkins et al .",
    "@xcite presented earlier a numerical spectral algorithm , based on reordering the entries of the second smallest eigenvector of the laplacian matrix associated to @xmath12 ( aka the fiedler vector ) .",
    "given its simplicity , this algorithm is used in some classification applications ( see , e.g. , @xcite ) as well as in spectral clustering ( see , e.g. , @xcite ) , and it runs in @xmath20 time , where @xmath21 is the complexity of computing ( approximately ) the eigenvalues of an @xmath0 symmetric matrix .",
    "note that the algorithms in @xcite , @xcite and @xcite also return all the possible robinson orderings of a given robinsonian matrix @xmath12 , which can be useful in some practical applications .    in this paper",
    "we introduce a new combinatorial recognition algorithm for robinsonian matrices . as a main ingredient",
    ", we define a new exploration algorithm for weighted graphs , named _ similarity - first search _ ( sfs ) , which is a generalization of the classical lex - bfs algorithm to weighted graphs .",
    "intuitively , the sfs algorithm explores vertices of a weighted graph in such a way that most similar vertices ( i.e. , corresponding to largest edge weights ) are visited first , while still respecting the priorities imposed by previously visited vertices . when applied to an unweighted graph ( or equivalently to a binary matrix ) , the sfs algorithm reduces to lex - bfs . as for lex - bfs",
    ", the sfs algorithm is entirely based on a unique simple task , namely partition refinement , a basic operation about sets which can be implemented efficiently ( see @xcite for details ) .",
    "we will use the sfs algorithm to define our new robinsonian recognition algorithm . specifically ,",
    "we introduce a multisweep algorithm , where each sweep uses the order returned by the previous sweep to break ties in the ( weighted ) graph search .",
    "our main result in this paper is that our multisweep algorithm can recognize after at most @xmath2 sweeps whether a given @xmath0 matrix @xmath12 is robinsonian .",
    "namely we will show that the last sweep is a robinson ordering of @xmath12 if and only if the matrix @xmath12 is robinsonian . assuming that the matrix @xmath12 is nonnegative and given as an adjacency list of an undirected weighted graph with @xmath1 nonzero entries , our algorithm runs in @xmath22 time .",
    "multisweep algorithms are well studied approaches to recognize classes of ( unweighted ) graphs ( see , e.g. ,  @xcite ) . in the literature there",
    "exist many results on multisweep algorithms based on lex - bfs and its variants .",
    "for example , cographs can be recognized in 2 sweeps  @xcite , unit interval graphs can be recognized in 3 sweeps  @xcite and interval graphs can be recognized in at most 5 sweeps  @xcite .",
    "very recently , dusart and habib @xcite introduced a multisweep algorithm to recognize in at most @xmath7 sweeps cocomparability graphs . for",
    "a more exhaustive list of multisweep algorithms please refer to @xcite .    as a graph is a unit interval graph if and only if its adjacency matrix is robinsonian @xcite , the 3-sweep recognition algorithm for unit interval graphs of corneil @xcite is in fact our main inspiration and motivation to develop a generalization of lex - bfs for weighted graphs .    to the best of our knowledge ,",
    "the present paper is the first work introducing and studying explicitely the properties of a multisweep search algorithm for weighted graphs .",
    "the only related idea that we could find is about replacing bfs with dijkstra s algorithm , which is only briefly mentioned in @xcite .",
    "the relevance of this work is twofold .",
    "first , we reduce the robinsonian recognition problem to an extremely simple and basic operation , namely to partition refinement . hence , even though from a theoretical point of view the algorithm is computationally slower than the optimal one presented in @xcite , its simplicity makes it easy to implement and thus hopefully will encourage the use and the study of robinsonian matrices in more practical problems .",
    "second , we introduce a new ( weighted ) graph search , which we believe is of independent interest and could potentially be used for the recognition of other structured matrices or just as basic operation in the broad field of ` similarity search ' . in addition , we introduce some new concepts extending analogous notions in graphs , like the notion of ` path avoiding a vertex ' and ` anchors ' of robinson orderings , which capture well the combinatorial structure of robinsonian matrices . as an example , we give combinatorial characterizations for the end points ( aka anchors ) of robinson orderings .      the paper is organized as follows .",
    "section  [ sec:2-preliminaries ] contains some preliminaries . in subsection  [ sec:2-basic facts ] we give basic facts about robinsonian matrices and robinson orderings and we introduce several concepts ( path avoiding a vertex , valid vertex , anchor ) playing a crucial role in the paper .",
    "subsection  [ sec:2-anchor characterization ] contains combinatorial characterizations for ( opposite ) anchors of robinsonian matrices .",
    "section [ sec:3-sfs algorithm ] is devoted to the sfs algorithm .",
    "first , we describe the algorithm in subsection  [ sec:3-description algorithm ] and we characterize sfs orderings in subsection [ sec:3-characterization sfs ] .",
    "then , in subsection [ sec:3-pal ] we introduce a fundamental lemma which we will use throughout the paper , named the ` path avoiding lemma ' .",
    "finally , in subsection [ sec:3-end points ] we introduce the notion of ` good sfs ordering ' and we show properties of end - vertices of ( good ) sfs orderings , namely that they are ( opposite ) anchors of robinsonian matrices .    in section [ sec:4-sfs+ algorithm ]",
    "we discuss the variant @xmath23 of the sfs algorithm , an extension of lex - bfs@xmath24 to weighted graphs , which differs from sfs in the way ties are broken the @xmath23 algorithm takes a given ordering as input which it uses to break ties . in subsection [ sec:4-good sfs and end points ]",
    "we show a basic property of the @xmath23 algorithm , namely that it ` flips ' the end points of the input ordering .",
    "then in subsection [ sec:4-similarity layers ] we introduce the ` similarity layers ' of a matrix , a strengthened version of bfs layers for unweighted graphs , which are useful for the correctness proof of the multisweep algorithm .",
    "we show in particular that the similarity layers enjoy some compatibility with robinson and @xmath23 orderings .    in section [ sec:5-the multisweep algorithm ]",
    "we present the multisweep algorithm to recognize robinsonian matrices and we prove its correctness . in subsection [ sec:5-description ]",
    "we describe the multisweep algorithm and show that it terminates in 3 sweeps when applied to a binary matrix , thus giving a new proof of the result of corneil @xcite for unit interval graphs . in subsection",
    "[ sec:5-three - good sfs ordering ] we study properties of ` 3-good sfs orderings ' , which are orderings obtained after three @xmath23 sweeps . in particular we show that they contain classes of robinson triples and that , after deleting their end points , they induce good sfs orderings , which will enable us to apply induction in the correctness proof .",
    "after that we have all the ingredients needed to conclude the correctness proof for the multisweep algorithm , we show in subsection [ sec:5-final proof ] that it can recognize in at most @xmath2 sweeps whether an @xmath0 matrix is robinsonian .",
    "furthermore , we present in subsection  [ sec:5-worst case instances ] a family of @xmath25 robinsonian matrices ( communicated to us by s. tanigawa ) for which the sfs",
    "multisweep algorithm requires exactly @xmath2 sweeps .",
    "finally , in section [ sec:6-complexity ] we discuss the complexity of the sfs algorithm , and we conclude with remarks and open questions in section [ sec:7-conclusions ] .",
    "in this section we introduce some notation and recall some basic properties and definitions for unit interval graphs and robinsonian matrices . in particular , we introduce the concepts of ` path avoiding a vertex ' and ` valid vertex ' and we give combinatorial characterizations for end points of robinson orderings ( also named ` anchors ' ) and for ` opposite anchors ' , which will play an important role in the rest of the paper .",
    "let @xmath9 be a linear order of @xmath26 $ ] .",
    "for two distinct elements @xmath27 $ ] , the notation @xmath28 means that @xmath29 appears before @xmath30 in @xmath9 and , for disjoint subsets @xmath31 , @xmath32 means that @xmath28 for all @xmath33 @xmath34 .",
    "the linear order  @xmath9 is a permutation of @xmath10 $ ] , which can be represented as a sequence @xmath35 with @xmath36 , and @xmath37 is the reverse linear order @xmath38 .",
    "an ordered partition @xmath39 of a ground set @xmath40 is an ordered collection of disjoint subsets of @xmath40 whose union is @xmath40 .    throughout , @xmath41 denotes the set of symmetric @xmath0 matrices .",
    "given @xmath42 and a subset @xmath43 $ ] , @xmath44=(a_{xy})_{x , y\\in s}$ ] is the principal submatrix of  @xmath12 indexed by  @xmath45 .",
    "a symmetric matrix @xmath42 is called a _ robinson similarity matrix _ if its entries are monotone nondecreasing in the rows and columns when moving towards the main diagonal , i.e. , if @xmath46 note that the diagonal entries of @xmath12 do not play a role in the above definition .",
    "if there exists a permutation @xmath9 of @xmath10 $ ] such that the matrix @xmath47 , obtained by permuting both the rows and columns of @xmath12 simultaneously according to @xmath9 , is a robinson matrix then @xmath12 is said to be a _",
    "robinsonian similarity _ and @xmath9 is called a _ robinson ordering _ of @xmath12 . in the literature",
    ", a distinction is made between robinson(ian ) similarities and robinson(ian ) dissimilarities .",
    "a symmetric matrix @xmath12 is called a _ robinson dissimilarity matrix _ if its entries are monotone nondecreasing in the rows and columns when moving away from the main diagonal .",
    "hence @xmath42 is a robinson(ian ) similarity precisely when @xmath48 is a robinson(ian ) dissimilarity and thus the properties extend directly from one class to the other one .",
    "for this reason , in this paper we will deal exclusively with robinson(ian ) similarities .",
    "hence , when speaking of a robinson(ian ) matrix , we mean a robinson(ian ) similarity matrix . furthermore , with @xmath49 denoting the all - ones matrix , it is clear that if @xmath12 is a robinson(ian ) matrix then @xmath50 is also a robinson(ian ) matrix for any scalar @xmath51 .",
    "hence , we may consider , without loss of generality , nonnegative similarities @xmath12 ( whose smallest entry is equal to 0 ) .    in order to fully understand robinsonian matrices and the motivation for our work , it is useful to briefly discuss the special class of binary robinsonian matrices .",
    "any symmetric matrix @xmath52 corresponds to a graph @xmath53,e)$ ] whose edges are the positions of the nonzero entries of @xmath12",
    ". then it is well known that @xmath12 is a robinsonian similarity if and only if @xmath54 is a unit interval graph @xcite .",
    "a graph @xmath53,e)$ ] is called a _",
    "unit interval graph _ if its vertices can be mapped to unit intervals",
    "@xmath55 of the real line such that two distinct vertices @xmath56 are adjacent in @xmath54 if and only if @xmath57 . there exist several equivalent characterizations for unit interval graphs .",
    "the following one highlights the analogy between unit interval graphs and robinson orderings .",
    "@xcite a graph @xmath58 is a unit interval graph if and only if there exists a linear ordering @xmath9 of @xmath40 such that , for all @xmath59 , @xmath60    it is clear that , for a binary matrix @xmath61 , condition  ( [ eq : robinson inequalities ] ) is equivalent to  ( [ eq:3-vertex condition ] ) .",
    "this equivalence and the fact that unit interval graphs can be recognized with a lex - bfs multisweep algorithm @xcite motivated us to find an extension of lex - bfs to weighted graphs and to use it to obtain a ( simple ) multisweep recognition algorithm for robinsonian matrices .    given the analogy with unit interval graphs , it will be convenient to view symmetric matrices as weighted graphs .",
    "namely , any nonnegative symmetric matrix @xmath42 corresponds to the weighted graph @xmath53,e)$ ] whose edges are the pairs @xmath62 with @xmath63 , with edge weights @xmath64 .",
    "again , the assumption of nonnegativity can be made without loss of generality and is for convenience only .",
    "accordingly we will often refer to the elements of @xmath26 $ ] indexing @xmath12 as vertices ( or nodes ) . for @xmath65",
    ", @xmath66 denotes the neighborhood of @xmath29 in @xmath54 .",
    "in what follows we will extend some graph concepts to the general setting of weighted graphs ( robinsonian matrices ) . throughout the paper",
    ", we will point out links between our results and some corresponding known results for lex - bfs applied to graphs and we will mostly refer to @xcite where more complete references about lex - bfs can be found .",
    "we now introduce some notions and simple facts about robinsonian matrices and orderings .",
    "consider a matrix @xmath61 .",
    "given distinct elements @xmath59 , the triple @xmath67 is said to be _ robinson _ if it satisfies ( [ eq : robinson inequalities ] ) , i.e. , if @xmath5 .",
    "given a set @xmath68 and @xmath69 , we say that @xmath29 is _ homogeneous _ with respect to  @xmath45 if @xmath70 for all @xmath71 ( extending the corresponding notion for graphs , see , e.g. ,  @xcite ) .",
    "the following is an easy necessary condition for the robinson property .",
    "[ thm : non - robinson property ] let @xmath42 be a robinsonian similarity .",
    "assume that there exists a robinson ordering @xmath9 such that @xmath72 .",
    "then @xmath73 for all @xmath74 $ ] .",
    "indeed , @xmath75 implies @xmath76 and thus @xmath77 , and @xmath78 implies @xmath79 and thus @xmath80 .",
    "we now make a simple observation on how three elements @xmath59 may appear in a robinson ordering @xmath9 of @xmath12 depending on their similarities .",
    "namely , if we have @xmath82 then , either @xmath30 comes before both @xmath29 and @xmath83 in @xmath9 , or @xmath30 comes after both @xmath29 and @xmath83 in @xmath9 . in other words ,",
    "if @xmath29 and @xmath83 are more similar to each other than to  @xmath30 , then @xmath30 can not be ordered between @xmath29 and @xmath83 in any robinson ordering @xmath9 . moreover , if @xmath84 then , either @xmath85 , or @xmath86 . in other words ,",
    "if  @xmath29 and  @xmath83 are more similar to @xmath30 than to each other , then @xmath30 must be ordered between @xmath29 and @xmath83 in any robinson ordering @xmath9 .",
    "this observation motivates the following notion of ` path avoiding a vertex ' , which will play a central role in our discussion .",
    "note that this notion is closely related to the notion of ` path missing a vertex ' for lex - bfs @xcite , although it is not equivalent to it when applied to a binary matrix .",
    "note also that in our setting the notion of path is defined for a matrix and a path is just a sequence of ( possibly repeated ) vertices .",
    "[ defpath ] given distinct elements @xmath87 , a _ path from @xmath29 to @xmath83 avoiding @xmath30 _ is a sequence @xmath88 of ( not necessarily distinct ) elements of @xmath40 where each triple @xmath89 is not robinson , i.e. , @xmath90 we let @xmath91 denote the length of the path @xmath92 ( i.e. , its number of elements ) .",
    "to @xmath83 avoiding @xmath30 : each continuous line indicates a value which is strictly larger than the minimum of the two adjacent dotted lines , title=\"fig : \" ] [ fig : path ]    the following simple but useful property holds .",
    "[ thm : path avoiding and robinson ordering ] let @xmath42 be a robinsonian matrix . if there exists a path from @xmath29 to @xmath83 avoiding @xmath30 , then @xmath30 can not lie between @xmath29 and @xmath83 in any robinson ordering @xmath9 of @xmath12 .",
    "let @xmath93 be a path from  @xmath29 to  @xmath83 avoiding  @xmath30 .",
    "then , by definition , we have @xmath94 , and thus  @xmath30 can not appear between @xmath95 and @xmath96 in any robinson ordering @xmath9 .",
    "hence @xmath30 can not lie between @xmath29 and @xmath83 in any robinson ordering @xmath9 .",
    "@xmath81    we now introduce the notion of ` valid vertex ' which we will use in throughout the section to characterize end points of robinson orderings .    [ defvalid ] given a matrix @xmath61 , an element @xmath97 is said to be _ valid _ if , for any distinct elements @xmath98 , there do not exist both a path from @xmath99 to @xmath83 avoiding @xmath100 and a path from @xmath100 to @xmath83 avoiding @xmath99 .",
    "observe that , if @xmath101 is a valid vertex of a matrix @xmath12 and @xmath102 is a subset containing @xmath83 , then @xmath83 is also a valid vertex of @xmath44 $ ] .",
    "it is easy to see that , for a @xmath103 matrix , the above definition of valid vertex coincides with the notion of valid vertex for lex - bfs @xcite .",
    "consider , for example , the following matrix ( already ordered in a robinson form ) : @xmath104 then the vertex @xmath19 is not valid . indeed , for the two vertices @xmath105 and @xmath106 , there exist a path from @xmath105 to @xmath19 avoiding @xmath106 and a path from @xmath106 to @xmath19 avoiding @xmath105 ; namely the path @xmath107 avoids @xmath106 and the path @xmath108 avoids @xmath105 ( see figure  [ fig : vertex not admissible ] ) .",
    "is not valid , title=\"fig : \" ]   is not valid , title=\"fig : \" ]      in this subsection we introduce the notion of ` ( opposite ) anchors ' of a robinsonian matrix and then we give characterizations in terms of valid vertices .",
    "the notion of anchor was used for unit interval graphs in @xcite ( where it refers to an end point of a linear order satisfying the 3-vertex condition  ( [ eq:3-vertex condition ] ) ) and it should not be confused with the notion of end - vertex used for interval graphs in @xcite ( where it refers to an end point of a lex - bfs ordering , see  @xcite for more details ) .    [ defanchor ] given a robinsonian similarity @xmath42 , a vertex @xmath109 $ ]",
    "is called an _ anchor _ of @xmath12 if there exists a robinson ordering @xmath9 of @xmath12 whose last vertex is @xmath105 .",
    "moreover , two distinct vertices @xmath110 are called _ opposite anchors _ of @xmath12 if there exists a robinson ordering @xmath9 of @xmath12 with @xmath105 as first vertex and @xmath111 as last vertex .",
    "hence , an anchor is an end point of a robinson ordering .",
    "clearly , every robinsonian matrix has at least one pair of opposite anchors .",
    "it is not difficult to see that every anchor must be valid .",
    "we now show that conversely every valid vertex is an anchor .",
    "this is the analogue of ( * ? ? ?",
    "* lemma 2 ) for lex - bfs over interval graphs .",
    "[ thm : anchor admissible ]",
    "let @xmath42 be a robinsonian matrix .",
    "then a vertex @xmath101 is an anchor of @xmath12 if and only if it is valid .",
    "( @xmath112 ) assume @xmath83 is an anchor of @xmath12 and let @xmath9 be a robinson ordering of @xmath12 with @xmath83 as last element .",
    "suppose for contradiction that , for some elements @xmath113 , there exist both a path @xmath92 from @xmath99 to @xmath83 avoiding @xmath100 and a path @xmath114 from @xmath100 to @xmath83 avoiding  @xmath99 .",
    "using lemma [ thm : path avoiding and robinson ordering ] and the path @xmath92 , we obtain that that @xmath100 lies before @xmath99 or after @xmath83 in @xmath9 , and using the path @xmath114 we obtain that @xmath99 lies before @xmath100 or after @xmath83 in  @xmath9 .",
    "as @xmath83 is the last element of @xmath9 , we must have @xmath115 in the first case and @xmath116 in the second case , which is impossible .",
    "( @xmath117 ) conversely , assume that @xmath83 is valid ; we show that @xmath83 is an anchor of @xmath12 .",
    "the proof is by induction on the size @xmath7 of the matrix @xmath12 .",
    "the result holds clearly when @xmath118 .",
    "so we now assume @xmath119 and that the result holds for any robinsonian matrix of order at most @xmath2 .",
    "we need to construct a robinson ordering @xmath120 of @xmath12 with @xmath83 as last vertex .",
    "for this we consider a robinson ordering @xmath9 of @xmath12 .",
    "we let @xmath29 denote its first element and @xmath30 denote its last element . if @xmath121 or @xmath122 , then we would be done .",
    "hence we may assume @xmath123 .",
    "for any @xmath124 , we denote by @xmath125 the path from @xmath100 to @xmath83 consisting of the sequence of vertices appearing consecutively between @xmath100 and @xmath83 in @xmath9 .",
    "we now define the following two sets : @xmath126 next we show their following properties , which will be useful to conclude the proof .    [ claim1 ] the following holds :    * for any @xmath127 , @xmath128 * if @xmath127 and @xmath129 , then @xmath130 . * any element @xmath131 is homogeneous with respect to @xmath132 , i.e. , @xmath133 for all @xmath134 .",
    "\\(i ) as @xmath135 , then @xmath136 . we show that equality holds .",
    "suppose not , i.e. , @xmath137 . then @xmath138 is a path from @xmath30 to @xmath83 avoiding @xmath100 .",
    "since @xmath139 , @xmath140 is a path from @xmath100 to @xmath83 avoiding @xmath30 , and thus the existence of the paths @xmath141 contradicts the assumption that @xmath83 is valid .",
    "hence we must have @xmath142 .",
    "\\(ii ) if @xmath139 then @xmath125 avoids @xmath30 and thus the subpath @xmath143 also avoids @xmath30 , which implies @xmath144 .",
    "\\(iii ) let @xmath130 denote the element of @xmath145 appearing first in the robinson ordering  @xmath9 .",
    "then , by ( ii ) , for any @xmath146 , @xmath147 and thus @xmath148 by definition of robinson ordering .",
    "hence , in order to show that @xmath100 is homogeneous with respect to @xmath132 , it suffices to show that @xmath149 ( as , using the robinson ordering property , this would in turn imply that @xmath133 for all @xmath134 ) .",
    "suppose for contradiction that there exists @xmath150 such that @xmath151 , and let @xmath100 denote the element of @xmath152 appearing last in @xmath9 with @xmath151 .",
    "then @xmath153 and the path @xmath154 avoids @xmath30 .",
    "since @xmath155 is a path from  @xmath99 to @xmath83 avoiding @xmath30 ( because @xmath130 ) , then the path @xmath156 ( obtained by concatenating @xmath154 and @xmath155 ) is a path from @xmath100 to @xmath83 avoiding @xmath30 .",
    "this implies that  @xmath100 and @xmath99 can not be consecutive in @xmath9 , as otherwise we would have @xmath139 , contradicting the fact that @xmath146 .",
    "hence , there exists @xmath157 such that @xmath158 . by the maximality assumption on @xmath100",
    ", it follows that @xmath159 .",
    "as @xmath83 is valid and @xmath156 is a path from @xmath100 to @xmath83 avoiding @xmath30 , it follows that no path from @xmath30 to @xmath83 can avoid @xmath100 .",
    "in particular , the path @xmath160 does not avoid  @xmath100 and thus it must be @xmath161 . recall that we assumed @xmath153 .",
    "as @xmath162 , combining the above inequalities with the inequalities coming from the robinson ordering @xmath9 , we obtain @xmath163 , which contradicts the equality @xmath159 .",
    "@xmath81    we now turn to the set of vertices coming after @xmath83 in @xmath9 .",
    "symmetrically with respect to @xmath83 , we can define the analogues of the sets @xmath164 defined in ( [ relbc ] ) , which we denote by  @xmath165 .",
    "for this replace @xmath9 by its reverse ordering @xmath37 and @xmath30 by @xmath29 ( the first element of @xmath9 and thus the last element of @xmath37 ) , i.e. , set @xmath166    to recap , we have that @xmath167 . recall that @xmath29 and @xmath30 are respectively the first and the last vertex in @xmath9 .",
    "note that it can not be that @xmath168 , as this would imply that @xmath169 and @xmath170 , and thus this would contradict the fact that @xmath83 is valid ( using the definition of the two sets @xmath145 and @xmath171 ) .",
    "therefore , we may assume ( without loss of generality ) that @xmath172 .",
    "let @xmath100 be the vertex of @xmath152 appearing last in the robinson ordering @xmath9 . by claim [ claim1 ] ( iii )",
    ", @xmath100 is homogeneous with respect to the set @xmath173 , i.e. , all entries @xmath174 take the same value for any @xmath175 .    consider the matrix @xmath44 $ ] , the principal submatrix of @xmath12 with rows and columns in @xmath45 .",
    "as @xmath176 and @xmath83 is valid ( also with respect to @xmath44 $ ] ) , we can conclude using the induction assumption that @xmath83 is an anchor of @xmath44 $ ] .",
    "hence , there exists a robinson ordering @xmath177 of @xmath44 $ ] admitting @xmath83 as last element .",
    "now , consider the linear order @xmath178,\\sigma)$ ] of @xmath40 obtained by concatenating first the order @xmath9 restricted to @xmath179 and second the linear order @xmath177 of @xmath45 .",
    "using the fact that every vertex in @xmath152 is homogeneous to all elements of @xmath45 , we can conclude that the new linear order @xmath120 is a robinson ordering of the matrix @xmath12 . as @xmath83 is the last element of @xmath120",
    ", this shows that @xmath83 is an anchor of @xmath12 and thus concludes the proof . @xmath81",
    "the above proof can be extended to characterize pairs of opposite anchors .",
    "[ thm : characterization opposite anchors ] let @xmath42 be a robinsonian matrix .",
    "two distinct vertices @xmath180 $ ] are opposite anchors of @xmath12 if and only if they are both valid and there does not exist a path from @xmath181 to @xmath182 avoiding any other vertex .",
    "( @xmath112 ) assume that @xmath181 and @xmath182 are opposite anchors .",
    "then they are both anchors and thus , in view of theorem [ thm : anchor admissible ] , they are both valid .",
    "let @xmath9 a robinson ordering starting with @xmath181 and ending with @xmath182 .",
    "suppose , for the sake of contradiction , that there exists a vertex @xmath29 and a path from @xmath181 to @xmath182 avoiding @xmath29 .",
    "then , by lemma  [ thm : path avoiding and robinson ordering ] , @xmath29 can not lie in @xmath9 between @xmath181 and @xmath182 , yielding a contradiction .",
    "( @xmath117 ) assume that @xmath181 and @xmath182 are valid and that there does not exist a path from @xmath181 to @xmath182 avoiding any other vertex .",
    "we show that they are opposite anchors .",
    "consider a robinson ordering @xmath9 of @xmath12 whose first element is @xmath181 and call @xmath30 its last element .",
    "if @xmath183 then we are done .",
    "hence , we may assume that @xmath184 .",
    "as in the proof of theorem [ thm : anchor admissible ] , for any @xmath185 , we denote by @xmath186 the path from @xmath100 to @xmath182 consisting of the sequence of vertices appearing consecutively between @xmath100 and @xmath182 in  @xmath9 .",
    "then , we can define the sets as in ( [ relbc ] ) in the proof of theorem [ thm : anchor admissible ] , where @xmath83 is replaced by @xmath182 , i.e. , : @xmath187 by assumption , @xmath188 , else @xmath189 would avoid @xmath30 , contradicting the nonexistence of a path from @xmath181 to @xmath182 avoiding any other vertex .",
    "therefore @xmath190 and thus @xmath172 .",
    "let @xmath191 .",
    "using the same reasoning as in the proof of theorem [ thm : anchor admissible ] , we can now conclude that one can find a robinson ordering @xmath177 of @xmath44 $ ] , where @xmath45 contains all the elements coming after the last element of @xmath152 in @xmath9 .",
    "the new linear order @xmath178,\\sigma)$ ] of @xmath40 obtained by concatenating first the order @xmath9 restricted to @xmath179 and second the linear order @xmath177 of @xmath45 is then a robinson ordering of @xmath12 whose first element is @xmath181 and whose last element is @xmath182 , which concludes the proof .",
    "in this section we introduce our new similarity - first search ( sfs ) algorithm .",
    "this algorithm will be applied to a ( nonnegative ) matrix @xmath42 and return a linear order of @xmath26 $ ] , called a _ sfs ordering _ of @xmath12 . as mentioned above , one can associate to @xmath12 a weighted graph @xmath53,e)$ ] , with edges the pairs @xmath62 such that @xmath63 and edge weights @xmath64 .",
    "the sfs algorithm can be thus seen as a search algorithm for weighted graphs .",
    "we first describe the algorithm in detail in subsection [ sec:3-description algorithm ] and provide a 3-point characterization of sfs orderings in subsection [ sec:3-characterization sfs ] .",
    "then in subsection [ sec:3-pal ] we discuss some properties of sfs orderings of robinsonian matrices .",
    "specifically , we introduce the fundamental ` path avoiding lemma ' ( lemma [ thm : pal ] ) which will be used repeatedly throughout the paper .",
    "in particular we use it in subsection [ sec:3-end points ] to show a fundamental property of sfs orderings , namely that the last element of the sfs ordering of a robinsonian matrix @xmath12 is an anchor of @xmath12 .",
    "the sfs algorithm is a generalization of lex - bfs for weighted graphs .",
    "as we will remark later , when applied to a  @xmath103 matrix , the sfs algorithm coincides with lex - bfs . roughly speaking ,",
    "the basic idea is to explore a weighted graph by visiting first vertices which are similar to each other ( i.e. , corresponding to an edge with largest weight ) but respecting the priorities imposed by previously visited vertices",
    ". the algorithm is based on the implementation of lex - bfs as a sequence of partition refinement steps as in @xcite .",
    "partition refinement is a simple technique introduced in @xcite to refine a given ordered partition @xmath39 of the ground set @xmath40 by a subset @xmath192 .",
    "it produces a new ordered partition of @xmath40 obtained by splitting each class @xmath193 of @xmath194 in two sets , the intersection @xmath195 and the difference @xmath196 .",
    "if one visualizes an ordered partition as a priority list , the idea behind partition refinement is to modify the classes of the ordered partition while respecting the priorities among the vertices .    in our new sfs algorithm",
    ", we basically operate a sequence of partition refinements . but instead of splitting into two subsets we will split into several subsets .",
    "specifically , given two ordered partitions @xmath194 and @xmath197 , the output will be a new ordered partition which , roughly speaking , is obtained by splitting each class of @xmath194 into its intersections with the classes of @xmath197 .",
    "the formal definition is as follows .",
    "[ def : refine ] let @xmath198 and @xmath199 be two ordered partitions of a set @xmath40 and a subset @xmath192 , respectively .",
    "_ refining @xmath194 by @xmath197 _ creates the new ordered partition of @xmath40 , denoted by _",
    "refine@xmath200 _ , obtained by replacing in @xmath194 each class @xmath193 by the ordered sequence of classes @xmath201 and keeping only nonempty classes .",
    "we will use this partition refinement operation in the case when the partition @xmath197 is obtained by partitioning for decreasing values the elements of the neighborhood @xmath202 of a given element @xmath203 , according to the following definition .",
    "[ def : layer partition ] consider a nonnegative matrix @xmath61 and an element @xmath204 $ ] .",
    "let @xmath205 be the distinct values taken by the entries @xmath206 of @xmath12 for @xmath207 : a_{py } > 0\\}$ ] and , for @xmath208 $ ] , set @xmath209 .",
    "then we define @xmath210 , which we call the _ similarity partition _ of @xmath202 with respect to  @xmath203 .",
    "we can now describe the sfs algorithm .",
    "the input is a nonnegative matrix @xmath42 and the output is an ordering @xmath177 of the set @xmath26 $ ] , that we call a _ sfs ordering _ of  @xmath12 . as in any general graph search algorithm",
    ", the central idea of the sfs algorithm is that , at each iteration , a special vertex ( called the _ pivot _ ) is chosen among the subset of unvisited vertices ( i.e. , the subset of vertices that have not been a pivot in prior iterations ) .",
    "such vertices are ordered in a queue which defines the priorities for visiting them .",
    "intuitively , the pivot is chosen as the most similar to the visited vertices , but respecting the visiting priorities imposed by previously visited vertices .",
    "[ alg : sfs ]    @xmath211 queue of unvisited vertices + : @xmath177    we now discuss in detail how the algorithm works . in the beginning , all vertices in @xmath40",
    "are unvisited , i.e. , the queue @xmath194 of unvisited vertices is initialized with the unique class @xmath40 .    at the iteration @xmath212 , we are given an element @xmath213 ( which is the pivot chosen at iteration @xmath214 ) and a queue @xmath215 , which is an ordered partition of the set of unvisited vertices .",
    "there are two main tasks to perform : the first task is to select the new pivot @xmath216 , and the second task is to update the queue @xmath217 in order to obtain the new queue @xmath218 .    the first task is carried out as follows . as in the standard lex - bfs ,",
    "we denote by  @xmath45 the _ slice _ induced by @xmath213 ( i.e. , the last visited vertex ) , which consists of the vertices among which to choose the next pivot @xmath216 .",
    "the slice @xmath45 coincides exactly with the first class @xmath219 of @xmath217 .",
    "we distinguish two cases depending on the size of the slice @xmath45 . if @xmath220 , then the new pivot @xmath221 is the unique element of the slice @xmath45 .",
    "if @xmath222 , we say that we have _ ties _ and , in the general version of the sfs algorithm , we break them arbitrarily .",
    "we will see in section [ sec:4-sfs+ algorithm ] a variant of sfs ( denoted by @xmath23 ) where such ties are broken using a linear order given as additional input to the algorithm .",
    "once the new pivot @xmath221 is chosen , we mark it as visited ( i.e. , we remove it from the queue @xmath217 ) and we set @xmath223 ( i.e. , we let @xmath221 appear at position @xmath212 in  @xmath177 ) .",
    "the second task is the update of the queue @xmath217 , which can be done as follows . intuitively , we update @xmath217 according to the similarities of @xmath221 with respect to the unvisited vertices and compatibly with the queue order . specifically , first we compute the similarity partition @xmath224 of the neighborhood @xmath225 of @xmath221 among the unvisited vertices ( see definition [ def : layer partition ] ) .",
    "second , we refine the ordered partition @xmath226 by the ordered partition @xmath227 ( see definition  [ def : refine ] ) .",
    "the resulting ordered partition is the ordered partition @xmath228 .",
    "note that if the matrix has only @xmath103 entries then the similarity partition @xmath227 has only one class , equal to the neighborhood of @xmath221 among the unvisited vertices .",
    "hence , the refinement procedure defined in definition [ def : refine ] simply reduces to the partition refinement operation defined in @xcite for lex - bfs .",
    "this is why lex - bfs is actually a special case of sfs for @xmath103 matrices .",
    "note also that , by construction , each class of the queue @xmath228 is an interval of @xmath177 ( i.e. , the elements of the class are consecutive in @xmath177 ) .",
    "furthermore , each of the visited vertices @xmath229 is homogeneous to every class of the queue @xmath228 .",
    "we show a simple example to illustrate how the algorithm works concretely .",
    "consider the following matrix : @xmath230 studied in @xcite ( we use also their original names for the vertices ) . in figure",
    "[ fig : sfs sweep ] are reported all the iterations of the sfs algorithm using as initial order of the vertices the reversal of the original labeling of the matrix . at each iteration ,",
    "the vertices in the blocks are the univisited vertices in the queue .      in this subsection",
    "we characterize the linear orders returned by the sfs algorithm in terms of a 3-point condition .",
    "this characterization applies to any ( not necessarily robinsonian ) matrix and it is the analogue of ( * ? ? ?",
    "* thm 3.1 ) for lex - bfs .",
    "[ thm : sfs ordering characterization ] given a matrix @xmath61 , an ordering @xmath177 of @xmath10 $ ] is a sfs ordering of @xmath12 if and only if the following condition holds : @xmath231 \\text { such that } a_{xz}>a_{xy } \\text { and } x < _ { \\sigma } y < _ { \\sigma } z,\\\\ \\text{there exists } u \\in [ n ] \\text { such that } u <",
    "_ { \\sigma } x \\text { and }   a_{uy}>a_{uz}. \\end{array}\\ ] ]    @xmath232 suppose @xmath177 is a sfs ordering of @xmath12 .",
    "assume @xmath233 and @xmath234 , but @xmath235 for each @xmath236 . assume first that @xmath237 for some @xmath236 and let @xmath99 be the first such vertex in @xmath177 .",
    "then @xmath238 for each @xmath239 , and thus @xmath240 are in the same class of the queue of unvisited vertices when @xmath99 is chosen as pivot .",
    "therefore , @xmath83 would be ordered before @xmath30 in @xmath177 when computing the similarity partition of @xmath241 , i.e. , we would have @xmath242 , a contradiction . hence , one has @xmath243 for each @xmath244 .",
    "this implies that @xmath240 are in the same class of the queue of unvisited vertices before @xmath29 is chosen as pivot .",
    "hence , when @xmath29 is chosen as pivot , as @xmath234 , when computing the similarity partition of @xmath245 we would get @xmath242 , which is again a contradiction .",
    "@xmath246 assume that the condition ( [ eq : sfs characterization ] ) of the theorem holds , but @xmath177 is not a sfs ordering .",
    "let @xmath105 denote the first vertex of @xmath177 .",
    "let @xmath247 be a sfs ordering of @xmath12 starting at @xmath105 with the largest possible initial overlap with @xmath177 .",
    "say , @xmath177 and @xmath247 share the same initial order @xmath248 and they differ at the next position .",
    "then we have that @xmath249 and @xmath250 with @xmath251 .    in the sfs ordering @xmath247 , the two elements @xmath240 do not lie in the slice of the pivot  @xmath252 . indeed ,",
    "if @xmath240 would lie in the slice of @xmath252 then one could select @xmath30 as the next pivot instead of @xmath83 , which would result in another sfs ordering @xmath253 starting at @xmath105 and with a larger overlap with @xmath177 than @xmath247 .",
    "hence , there exists @xmath254 such that @xmath255 . since @xmath256 then applying the condition ( [ eq : sfs characterization ] ) to @xmath177",
    ", we deduce that there exists @xmath257 such that @xmath258 .",
    "now , we have @xmath259 with @xmath258 .",
    "as @xmath260 is a sfs ordering , as we have just shown it must satisfy the condition ( [ eq : sfs characterization ] ) and thus there must exist an index @xmath261 such that @xmath262 . hence , starting from an index @xmath254 for which @xmath255 , we have shown the existence of another index @xmath263 for which @xmath262 .",
    "iterating this process , we reach a contradiction .",
    "we will use in some other proofs this same type of infinite chain argument , based on constructing an infinite chain of elements .",
    "@xmath81    one can easily show that if @xmath177 is a sfs ordering of @xmath12 and @xmath102 is a subset such that any element @xmath264 is homogeneous to  @xmath45 , then the restriction @xmath265 $ ] of @xmath177 to  @xmath45 is a sfs ordering of @xmath44 $ ] .",
    "note that , by construction , if we consider a generic slice @xmath45 encountered during the execution of the sfs algorithm returning  @xmath177 , then each vertex coming before @xmath45 in @xmath177 is homogeneous to @xmath45 .",
    "hence , a direct consequence of theorem  [ thm : sfs ordering characterization ] is that the restriction of @xmath177 to any slice @xmath45 encountered throughout the sfs algorithm returning @xmath177 is a sfs ordering of the submatrix @xmath44 $ ] .      in this subsection",
    "we discuss a fundamental lemma which we call the ` path avoiding lemma ' .",
    "it will play a crucial role throughout the paper and , in particular , for the characterization of anchors . differently from the analysis in the previous subsection , where we did not make any assumption on the structure of the matrix @xmath12 , the path avoiding lemma states some important properties of sfs orderings when the input matrix is robinsonian .    before stating this lemma",
    ", we need to investigate in more detail the refinement step in the sfs algorithm .",
    "an important operation in the refine task in algorithm [ alg : sfs ] is the splitting procedure of each class of the queue @xmath194 .",
    "the following notion of ` vertex splitting a pair of vertices ' is useful to understand it . consider an order @xmath266 and vertices @xmath233 , where @xmath267 is the pivot chosen at the @xmath212th iteration in algorithm [ alg : sfs ] .",
    "we say that @xmath29 _ splits _ @xmath30 and @xmath83 if @xmath29 is the first pivot for which @xmath30 and @xmath83 do not belong to the same class in the queue ordered partition @xmath268 . recall that  @xmath228 denotes the queue of unvisited nodes induced by pivot  @xmath221 , i.e. , at the end of iteration  @xmath212 ( after the refinement step ) . hence , saying that @xmath240 are split by @xmath29 means that @xmath240 belong to a common class @xmath269 of @xmath270 and that they belong to distinct classes @xmath271 of @xmath228 , where @xmath272 @xmath273 and @xmath274 comes before @xmath275 in @xmath228 .",
    "equivalently , @xmath267 splits @xmath30 and @xmath83 if @xmath276 and @xmath277 for all @xmath278 .",
    "then , we say that two vertices @xmath279 are _ split _ in @xmath177 if they are split by some vertex @xmath280 .",
    "when @xmath30 and @xmath83 are not split in @xmath177 , we say that they are _",
    "tied_. in this case , ties must be broken between @xmath30 and @xmath83 . in the sfs algorithm",
    "we assume that ties are broken arbitrarily .",
    "in section [ sec:4-sfs+ algorithm ] we will see the variation @xmath23 of sfs where ties are broken using a linear order @xmath247 given as input together with the matrix @xmath12 .",
    "the following lemma will be used as base case for proving the path avoiding lemma .",
    "[ thm : equality a_xz = a_xy ] assume that @xmath42 is a robinsonian matrix and let @xmath266 . assume that @xmath281 and that there exists a robinson ordering @xmath9 of @xmath12 such that @xmath72 .",
    "then @xmath30 and @xmath83 are not split in @xmath177 by any vertex @xmath282 .",
    "that is , @xmath277 for all @xmath283 .",
    "we first show that @xmath240 are not split by any vertex @xmath284 occurring before @xmath29 in @xmath177 .",
    "suppose , for contradiction , that @xmath240 are split by a vertex @xmath285 .",
    "hence , @xmath286 .",
    "this implies @xmath287 for , otherwise , @xmath288 would imply @xmath289 , a contradiction .",
    "hence we have @xmath290 and @xmath291 . because @xmath9 is a robinson ordering , we get @xmath292 and thus @xmath293",
    ". therefore , the quadruple @xmath294 satisfies the following properties ( a)-(d ) : ( a ) @xmath295 , ( b ) @xmath296 for some robinson ordering @xmath9 , ( c ) @xmath284 is the pivot splitting @xmath240 , and ( d ) @xmath297 call any quadruple satisfying ( a)-(d ) a _ bad quadruple_.    : @xmath294 and @xmath298 are bad quadruples ( the dotted lines indicate similarities that are strictly smaller than the continuous ones of the same thickness ) ]    we now show that if @xmath294 is a bad quadruple then there exists @xmath299 for which @xmath298 is also a bad quadruple .",
    "hence , iterating we will get a contradiction ( so we use here too an infinite chain argument ) .",
    "we now proceed to show the existence of @xmath299 for which @xmath298 is also a bad quadruple . since @xmath300 , the vertices @xmath301 are already split before @xmath284 becomes a pivot ; otherwise , if they would belong to the same class when @xmath284 is chosen as new pivot , then we would get @xmath302 .",
    "let @xmath303 the pivot splitting @xmath301 , i.e. , @xmath304 and @xmath305 .",
    "thus @xmath301 belong to the same class ( say ) @xmath306 when @xmath99 is chosen as new pivot at iteration @xmath212 , but in different classes of @xmath218 .",
    "since @xmath284 is the pivot splitting @xmath240 and @xmath299 , it follows that @xmath240 belong to the same class when @xmath99 is chosen as pivot , and thus @xmath307 .",
    "therefore @xmath99 is also the pivot splitting @xmath29 and @xmath83 and thus @xmath308 . in turn",
    "this implies that @xmath75 for , otherwise , @xmath79 would imply @xmath309 , a contradiction .",
    "therefore , @xmath310 and by definition of robinson ordering we have @xmath311 and , as @xmath312 , this implies that @xmath313 . summarizing , we have shown that the quadruple @xmath298 is bad since it satisfies the conditions ( a)-(d ) : ( a ) @xmath314 , ( b ) @xmath315 for the robinson ordering @xmath37 , ( c ) @xmath99 splits @xmath29 and @xmath83 , and ( d ) @xmath316 .",
    "thus we have shown that there can not exist a bad quadruple and therefore that @xmath240 are not split by any vertex @xmath284 appearing before @xmath29 in @xmath177 .",
    "we now conclude the proof of the lemma by showing that @xmath240 are also not split by @xmath29 . for this , we need to show that @xmath317 .",
    "suppose for contradiction that @xmath318 .",
    "as @xmath319 , it can only be that @xmath234 .",
    "let @xmath267 , i.e. , @xmath29 is the pivot chosen at iteration @xmath212 of algorithm [ alg : sfs ] . since we have just shown that @xmath240 are not split before @xmath29 , then at the iteration @xmath212 when @xmath29 is chosen as pivot , we would order @xmath242 as @xmath234 , which is a contradiction because @xmath320 by assumption .",
    "@xmath81    a first direct consequence of lemma [ thm : equality a_xz = a_xy ] is the following .",
    "[ thm : anchor simplicial sigma + base case pal ] let @xmath42 be a robinsonian matrix , let @xmath321 , and consider distinct elements @xmath87 such that @xmath233 .",
    "the following holds :    * @xmath322 . * if @xmath319 for some robinson ordering @xmath9 , then the path @xmath323 does not avoid @xmath30 .",
    "\\(i ) assume , for contradiction , that @xmath324 . pick a robinson ordering @xmath9 of @xmath12 such that @xmath325 .",
    "then we must have @xmath72 .",
    "indeed , if @xmath326 then we would have @xmath327 , and if @xmath328 we would have @xmath329 , leading in both cases to a contradiction . applying lemma [ thm : equality a_xz = a_xy ] , we conclude that @xmath330 , contradicting our assumption that @xmath331 .",
    "\\(ii ) if @xmath332 avoids @xmath30 then @xmath333 , where @xmath334 since @xmath319 .",
    "hence this contradicts lemma  [ thm : equality a_xz = a_xy ] .",
    "@xmath81    note that the above result is the analogue of the ` @xmath335-rule ' for chordal graphs in  ( * ? ? ?",
    "* thm 3.12 ) , which claims that , for any distinct @xmath59 such that @xmath233 while @xmath319 for some robinson ordering @xmath9 , the path @xmath332 does not avoid @xmath30 .",
    "the next lemma strengthens the result of corollary [ thm : anchor simplicial sigma + base case pal ] ( ii ) , by showing that there can not exist _ any _ path from @xmath29 to @xmath83 avoiding @xmath30 and appearing fully before @xmath83 in @xmath177 .",
    "we will refer to lemma  [ thm : pal ] below as the ` path avoiding lemma ' , also abbreviated as  ( pal ) for ease of reference in the rest of the paper .",
    "[ thm : pal ] assume @xmath61 is a robinsonian matrix and let @xmath266 .",
    "consider distinct elements @xmath87 such that @xmath233 .",
    "if @xmath319 for some robinson ordering @xmath9 , then there does not exist a path @xmath336 from @xmath29 to @xmath83 avoiding @xmath30 and such that @xmath337 .",
    "the proof is by induction on the length @xmath338 of the path @xmath92 .",
    "the base case is @xmath339 , i.e. , @xmath323 , which is settled by corollary [ thm : anchor simplicial sigma + base case pal ] .",
    "assume then , for contradiction , that there exists a path @xmath336 from @xmath29 to @xmath83 avoiding  @xmath30 with @xmath337 and @xmath340 , i.e. , @xmath341 . let us call a path @xmath114 _ short _ if it is shorter than @xmath92 , i.e. , if @xmath342 . by the induction assumption , we know that the following holds : @xmath343    set @xmath344 and @xmath345 .",
    "as @xmath92 avoids @xmath30 , the following relations hold : @xmath346.\\ ] ]    recall that since @xmath281 and @xmath72 , then in view of lemma [ thm : equality a_xz = a_xy ] we have @xmath330",
    ". furthermore , we know that @xmath347 by assumption . in order to conclude the proof , we use the following claim .    [ claim2 ] @xmath348 and @xmath349 for each @xmath350 $ ] .",
    "the proof is by induction on @xmath351 .",
    "for @xmath352 we have to show that @xmath353    we first show that @xmath354 .",
    "suppose this is not the case and @xmath355 .",
    "recall that in view of ( [ eq0 ] ) for @xmath352 we have @xmath356 and thus the path @xmath357 avoids @xmath30 .",
    "hence , since @xmath28 and @xmath30 can not appear between @xmath29 and @xmath358 in any robinson ordering in view of lemma [ thm : path avoiding and robinson ordering ] , it must also be that @xmath359 .",
    "we then have two possibilities , depending whether @xmath358 comes before or after @xmath83 in @xmath9 .",
    "a.   assume first that @xmath358 appears before @xmath83 in @xmath9 .",
    "then we have @xmath360 .",
    "we discuss where can @xmath358 appear in @xmath177 .",
    "if @xmath361 then we have @xmath362 , @xmath363 , and @xmath364 is a short path from @xmath358 to @xmath83 avoiding @xmath30 with @xmath365 , which contradicts  ( [ eqh ] ) .",
    "hence , @xmath366 in which case we have @xmath367 , @xmath368 , and @xmath357 is a short path from @xmath29 to @xmath358 avoiding  @xmath30 , which contradicts again ( [ eqh ] ) .",
    "b.   assume now that @xmath358 appears after @xmath83 in @xmath9 .",
    "then we have @xmath369 . by ( [ eq0 ] )",
    "applied to @xmath352 and using the robinson ordering @xmath9 , we have that @xmath370 .",
    "recall that @xmath70 . then @xmath371 . on the other hand , by the robinson property of @xmath9 , @xmath372 ,",
    "yielding a contradiction .",
    "therefore we have shown that @xmath354 .",
    "finally , we show that @xmath366 .",
    "suppose not , i.e. , @xmath361 .",
    "then we would have @xmath373 and , as just shown , @xmath374 , while @xmath364 is a short path from @xmath358 to @xmath83 avoiding @xmath30 with @xmath365 .",
    "this contradicts ( [ eqh ] ) and thus shows @xmath366 , which concludes the proof for the base case @xmath352 .",
    "assume now that @xmath375 and that @xmath376 and @xmath377 for all @xmath378 by induction .",
    "we show that also @xmath348 and @xmath349 .",
    "first we show @xmath348 .",
    "suppose , for the sake of contradiction , that @xmath379 .",
    "recall that in view of ( [ eq0 ] ) the path @xmath380 is a path from @xmath381 to @xmath83 avoiding @xmath30 with @xmath382 .",
    "hence , since @xmath383 in view of lemma [ thm : path avoiding and robinson ordering ] it must be also @xmath384 , because @xmath30 can not appear between @xmath83 and @xmath381 in any robinson ordering .",
    "we then have two possibilities to discuss , depending whether @xmath381 comes before or after @xmath83 in  @xmath9 .",
    "a.   assume that @xmath381 appears before @xmath83 in @xmath9 .",
    "then @xmath385 .",
    "first we claim that @xmath349 . indeed ,",
    "if by contradiction @xmath386 , then we would have : @xmath387 and @xmath388 , while @xmath389 is a short path from @xmath381 to @xmath83 avoiding @xmath30 with @xmath382 , contradicting ( [ eqh ] ) .",
    "+ hence , @xmath349 holds . recall that @xmath390 for @xmath391 $ ] by induction",
    "hence , for @xmath392 we have @xmath393 . to recap",
    ", we are therefore in the case @xmath394 and we have shown that @xmath395 .",
    "+ we thus have @xmath396 and @xmath397 .",
    "then , in view of lemma [ thm : equality a_xz = a_xy ] , one must have @xmath398 . from the robinson ordering we obtain @xmath399 and therefore we get the equality @xmath400 .",
    "analogously , because @xmath401 and @xmath402 , by lemma [ thm : equality a_xz = a_xy ] we obtain @xmath403 .",
    "hence , we have @xmath404 finally , using relation ( [ eq0 ] ) we get : @xmath405 in view of ( [ eq:2 ] ) , the right hand side in ( [ eq:3 ] ) is @xmath406 . on the other hand , as @xmath407 in the robinson ordering @xmath9 , then @xmath408 , which contradicts ( [ eq:3 ] ) .",
    "hence @xmath381 can not appear before @xmath83 in @xmath9 .",
    "b.   assume @xmath381 appears after @xmath83 in @xmath9",
    ". then @xmath409 .",
    "observe that the path @xmath410 is a short path from @xmath29 to @xmath83 with @xmath411 and thus it can not avoid @xmath30 , otherwise we would contradict ( [ eqh ] ) . since the path @xmath412 avoids @xmath30",
    "( as it is a subpath of @xmath92 ) , it follows that the path @xmath413 does not avoid @xmath30 .",
    "hence @xmath414 which , using the robinson ordering @xmath9 , in turn implies @xmath415 .",
    "then , using relation ( [ eq0 ] ) , we get : @xmath416 . now combining with @xmath417 ,",
    "we get @xmath418 which is a contradiction , since from the robinson ordering @xmath9 one must have @xmath419 .",
    "therefore we have shown also that @xmath381 can not appear after @xmath83 in @xmath9 .",
    "in summary we have shown that @xmath348 as desired .",
    "finally we now show that @xmath349 . indeed ,",
    "if @xmath386 then we would have : @xmath387 and @xmath420 , while @xmath421 is a short path from @xmath381 to @xmath83 avoiding @xmath30 with @xmath422 , which contradicts ( [ eqh ] ) .",
    "this concludes the proof of the claim .",
    "we can now conclude the proof of lemma [ thm : pal ] . by claim [ claim2 ]",
    "we have the following relations for any @xmath423 $ ] : @xmath424 and @xmath425 . by lemma  [ thm : equality a_xz = a_xy ]",
    ", this implies @xmath426 for all @xmath423 $ ] which , using the robinson ordering  @xmath9 , in turn implies @xmath427 .",
    "now , use relation ( [ eq0 ] ) for @xmath428 to get the inequality @xmath429 .",
    "recall that in view of lemma  [ thm : equality a_xz = a_xy ] , we have that @xmath330 .",
    "then as @xmath430 for all @xmath212 , the right hand side is equal to @xmath431 while , using the robinson ordering @xmath9 , the left hand side satisfies @xmath432 , which yields a contradiction .",
    "this concludes the proof of the lemma .      in this subsection",
    "we show some fundamental properties of sfs orderings , using the results in subsection [ sec:3-pal ] .",
    "first we show that if @xmath12 is robinsonian then the last vertex of a sfs ordering of  @xmath12 is an anchor of  @xmath12 .",
    "we will see later in corollary [ corsfsrobinson ] that conversely any anchor can be obtained as end - vertex of a sfs ordering .",
    "[ thm : last vertex of sfs is an anchor ] let a be a robinsonian matrix and let @xmath266 .",
    "then the last vertex of @xmath177 is an anchor of @xmath12 .",
    "let @xmath83 be the last vertex of @xmath177 ; we show that @xmath83 is an anchor of @xmath12 .",
    "in view of theorem [ thm : anchor admissible ] it suffices to show that @xmath83 is valid .",
    "suppose for contradiction that , for some @xmath433 , there exist a path @xmath92 from @xmath29 to @xmath83 avoiding @xmath30 and a path @xmath114 from @xmath30 to @xmath83 avoiding @xmath29 .",
    "we may assume without loss of generality that @xmath233 .",
    "moreover , let @xmath9 be a robinson ordering of @xmath12 such that @xmath434 .",
    "then , in view of lemma [ thm : path avoiding and robinson ordering ] , we must have @xmath123 , since @xmath30 must come either before or after both @xmath29 and @xmath83 ( because of the path @xmath92 ) and @xmath29 must come before or after both  @xmath30 and  @xmath83 ( because of the path @xmath114 ) . as @xmath83 is the last vertex , then @xmath435 and thus we get a contradiction with lemma  [ thm : pal ] ( pal ) .",
    "the above result is the analogue of ( * ? ? ?",
    "* thm 4.5 ) for lex - bfs applied to interval graphs .",
    "we now introduce the concept of ` good sfs ' .",
    "[ defgoodsfs ] we say that a sfs ordering @xmath177 of @xmath12 is good if @xmath177 starts with a vertex which is the end - vertex of some sfs ordering .    note that the analogous definition in @xcite for lex - bfs is stronger , as it requires the first vertex of each slice to be an end - vertex of the slice itself .",
    "however , in our discussion we do not need such a strong definition and the above notion of good sfs will suffice to show the overall correctness of the multisweep algorithm . in the case",
    "when @xmath12 is robinsonian , in view of theorem [ thm : last vertex of sfs is an anchor ] ( and corollary [ corsfsrobinson ] below ) , @xmath177 is a good sfs ordering precisely when it starts with an anchor of @xmath12 . for good sfs orderings we have the following stronger result for their end - vertices .",
    "[ thm : end points of good sfs are opposite anchor ] let @xmath436 be a robinsonian matrix and let @xmath177 be a good sfs ordering whose first vertex is @xmath105 and whose last vertex is @xmath111",
    ". then @xmath110 are opposite anchors of @xmath12 .    by assumption",
    ", @xmath177 is a good sfs ordering and thus its first vertex @xmath105 is an anchor of @xmath12 . in view of theorem [ thm : last vertex of sfs",
    "is an anchor ] , its last vertex @xmath111 is also an anchor of @xmath12 .",
    "suppose , for the sake of contradiction , that @xmath105 and @xmath111 are not opposite anchors of  @xmath12 .",
    "then , in view of theorem  [ thm : characterization opposite anchors ] , there exists a vertex  @xmath437 and a path  @xmath92 from  @xmath105 to  @xmath111 such that  @xmath92 avoids  @xmath29 .",
    "let @xmath9 be a robinson ordering of @xmath12 starting with @xmath105 ( which exists since @xmath105 is an anchor of @xmath12 ) .",
    "using lemma [ thm : path avoiding and robinson ordering ] applied to the path @xmath92 , we can conclude that  @xmath29 can not appear between @xmath105 and @xmath111 in any robinson ordering , and thus we must have @xmath438 .",
    "but then , using lemma [ thm : pal ] ( pal ) , there can not exist a path from  @xmath105 to  @xmath111 avoiding  @xmath29 and appearing before  @xmath111 in  @xmath177 , which contradicts the existence of  @xmath92 .",
    "in this section we introduce the @xmath23 algorithm . this is a variant of the standard sfs algorithm , and it is the analogue of the variant lex - bfs+ of lex - bfs introduced by simon @xcite in the study of multisweep algorithms for interval graphs ( although the multisweep algorithm itself in  @xcite is actually flawed , see @xcite for more details ) .",
    "the algorithm @xmath23 will be the main ingredient in our multisweep algorithm for the recognition of robinsonian matrices .",
    "it takes as input a matrix @xmath12 and a linear order @xmath177 , and it returns another linear order @xmath439 . after describing @xmath23",
    ", we will first present its main properties , most importantly the fact that the @xmath23 algorithm ` flips anchors ' when applied to a robinsonian matrix @xmath12 and a good sfs order @xmath177 : if @xmath177 starts at @xmath105 and ends at @xmath111 , then @xmath439 starts at @xmath111 and ends at @xmath105 .",
    "we will also introduce the useful concept of ` similarity layers ' of a matrix , which will play a crucial role in the correctness analysis of our multisweep sfs - based algorithm .",
    "consider again the sfs algorithm as described in algorithm [ alg : sfs ] in section [ sec:3-sfs algorithm ] .",
    "the first main task is selecting the new pivot . in case of ties ,",
    "as done at line [ alg : ties ] of algorithm [ alg : sfs ] , the ties are broken arbitrarily ( choosing any vertex in the slice @xmath45 ) .",
    "we now introduce a variant of @xmath440 , which we denote by @xmath441 .",
    "it takes as input a matrix @xmath61 and a linear order @xmath177 of @xmath40 , and it returns a new linear order  @xmath439 of  @xmath40 . in the @xmath23 algorithm ,",
    "the input linear order @xmath177 is used to break ties at line [ alg : ties ] in algorithm [ alg : sfs ] .",
    "specifically , among the vertices in the slice @xmath45 of the current iteration , we choose as new pivot the vertex appearing last in @xmath177 .",
    "notice that a @xmath23 ordering is still a sfs ordering and thus it satisfies all the properties discussed in section [ sec:3-sfs algorithm ] .",
    "if @xmath12 is a robinsonian matrix and the input linear order  @xmath177 is a sfs ordering , then the @xmath23 ordering @xmath439 has some important additional properties .",
    "in fact , since in the beginning of the sfs algorithm all the vertices are contained in the ` universal ' slice ( i.e. , the full ground set @xmath40 ) , the order @xmath439 starts with the last vertex of @xmath177 , which in view of lemma [ thm : last vertex of sfs is an anchor ] is an anchor of @xmath12 .",
    "therefore , in this case , @xmath439 is a good sfs ordering by construction .",
    "furthermore , in view of theorem [ thm : end points of good sfs are opposite anchor ] , when @xmath12 is robinsonian then the first and last vertices of @xmath439 are opposite anchors of @xmath12 . if the input linear order @xmath177 is a good sfs ordering , then we have an even stronger property : the end - vertices of  @xmath439 are the end - vertices of @xmath177 but in reversed order .",
    "we call this the ` anchors flipping property ' , which is shown in the next theorem",
    ". this property will be crucial in section [ sec:5-the multisweep algorithm ] when studying the properties of the multisweep algorithm .",
    "[ thm : flipping theorem ] let @xmath42 be a robinsonian similarity , let @xmath177 be a good sfs ordering of @xmath12 and @xmath442 .",
    "suppose that @xmath177 starts with @xmath105 and ends with @xmath111",
    ". then @xmath443 starts with @xmath111 and ends with @xmath105 .    by definition of the @xmath23 algorithm ,",
    "the returned order @xmath443 starts with the last vertex @xmath111 of @xmath177 .",
    "hence , we only have to show that @xmath105 appears last in @xmath443 .",
    "suppose , for the sake of contradiction , that @xmath105 is not last in @xmath443 and let instead @xmath30 be the vertex appearing last in @xmath443 .",
    "then we have @xmath444 and @xmath445 .",
    "this implies that @xmath30 and @xmath105 must be split in  @xmath443 .",
    "indeed , if @xmath30 and @xmath105 would be tied in @xmath443 then , as we use @xmath177 to break ties and as @xmath446 , the vertex @xmath30 would be placed before @xmath105 in  @xmath443 , a contradiction .",
    "let thus @xmath447 be the pivot splitting @xmath105 and @xmath30 in @xmath443 , so that @xmath448",
    ". then we have : @xmath449 hence the path @xmath450 avoids @xmath30 . as @xmath111 is the first vertex of @xmath439",
    ", we have : @xmath451 in view of theorem [ thm : end points of good sfs are opposite anchor ] applied to @xmath177 , we know that @xmath105 and @xmath111 are opposite anchors of @xmath12 . therefore , there exists a robinson ordering @xmath9 starting with @xmath105 and ending with  @xmath111 . in view of ( [ eq : path ] ) and using lemma [ thm : path avoiding and robinson ordering ] , @xmath30 can not appear between @xmath105 and @xmath29 in any robinson ordering and therefore we can conclude : @xmath452 consider now @xmath177 .",
    "we have that @xmath453 . where can @xmath29 appear in @xmath177 ?",
    "suppose @xmath302 .",
    "then we would have @xmath454 and @xmath455 , and in view of lemma  [ thm : pal ]  ( pal ) there can not exist a path from @xmath105 to @xmath29 avoiding @xmath30 and appearing before @xmath29 in @xmath177 , which is a contradiction as the path @xmath450 avoids @xmath30 in view of ( @xmath456 ) .",
    "hence , we must have : @xmath457 therefore , starting from the pair @xmath458 satisfying @xmath459 and @xmath460 , we have constructed a new pair @xmath461 satisfying @xmath462 and @xmath463 , with @xmath464 . iterating this construction",
    "we get an infinite sequence of such pairs , yielding a contradiction .",
    "( here too we have used an infinite chain argument.)@xmath81    the flipping property of anchors is the analogue of ( * ? ? ?",
    "* thm 4.6 ) for lex - bfs .",
    "an important consequence of this property is that , if the linear order @xmath177 given as input is a robinson ordering of @xmath12 , then @xmath465 is equal to @xmath466 , i.e. , the reversed order of  @xmath177 .",
    "[ thm : sfs+(a , pi ) and reversed robinson triple ] let @xmath467 be a robinsonian matrix and let @xmath468 be two sfs orderings of @xmath12 .",
    "the following holds :    1 .   if @xmath469 and @xmath470 then the triple @xmath67 is robinson .",
    "if @xmath247 is a robinson ordering of @xmath12 and @xmath471 , then @xmath472 .    _",
    "( i ) _ suppose for contradiction that the triple @xmath67 is not robinson",
    ". then we have @xmath82 , and thus the path @xmath332 avoids @xmath30 .",
    "let @xmath9 be a robinson ordering of @xmath12 with ( say ) @xmath325 .",
    "in view of lemma [ thm : path avoiding and robinson ordering ] , @xmath30 can not appear between @xmath29 and @xmath83 in any robinson ordering and therefore we have @xmath319 or @xmath473 .",
    "in both cases we get a contradiction with lemma [ thm : pal ] ( pal ) since @xmath474 and @xmath475 .    _",
    "( ii ) _ say @xmath247 starts at @xmath111 and ends at @xmath105",
    ". then @xmath177 starts at @xmath105 .",
    "assume that @xmath476 .",
    "let @xmath477 be the longest initial segment of @xmath177 whose reverse @xmath478 is the final segment of @xmath247 , with @xmath479 .",
    "let @xmath30 be the successor of @xmath480 in @xmath177 .",
    "then @xmath30 is not the predecessor of @xmath480 in @xmath247 ( by maximality of @xmath481 ) .",
    "let @xmath83 be the predecessor of @xmath480 in @xmath247",
    ". then @xmath482 and @xmath483 .",
    "hence , @xmath240 can not be tied in @xmath177 ( otherwise we would choose @xmath484 before @xmath30 in @xmath177 as @xmath485 ) .",
    "therefore , there must exist a vertex @xmath462 such that @xmath276 .",
    "hence , @xmath486 for some @xmath487 and thus @xmath488 .",
    "as @xmath247 is a robinson ordering this implies @xmath489 , a contradiction .",
    "@xmath81    in other words , in a multisweep algorithm applied to a robinsonian matrix , every triple of vertices appearing in reversed order in two distinct sweeps is robinson .",
    "moreover , once a given sweep is a robinson ordering , the next sweep will remain a robinson ordering ( precisely the reversed order ) . as direct application of lemma  [ thm : sfs+(a , pi ) and reversed robinson triple ] , we have the following characterization for robinsonian matrices .",
    "[ thm : corollary alternative robinson check ] let @xmath42 , let @xmath247 be a sfs ordering of @xmath12 and let @xmath490@xmath491 .",
    "assume that @xmath492 .",
    "then @xmath12 is robinsonian if and only if @xmath177 is robinson .",
    "we will see in section  [ sec:6-complexity ] how to exploit the above result to check if a given sfs ordering is a robinson ordering during a multisweep algorithm .",
    "furthermore , combining lemma [ thm : sfs+(a , pi ) and reversed robinson triple ] with theorem [ thm : last vertex of sfs is an anchor ] , we obtain the following characterization for anchors .    [ corsfsrobinson ] let @xmath61 be a robinsonian matrix .",
    "a vertex is an anchor of  @xmath12 if and only if it is the end - vertex of a sfs ordering of @xmath12 .      in this subsection",
    "we introduce the notion of ` similarity layer structure ' for a matrix @xmath61 and an element @xmath493 ( then called the _ root _ ) , which we will use later to analyze properties of the multisweep algorithm .",
    "specifically , we define the following collection @xmath494 of subsets of  @xmath40 , whose members are called the _ ( similarity ) layers of @xmath12 rooted at @xmath105 _ , where @xmath495 and the next layers @xmath496 are the subsets of @xmath40 defined recursively as follows : @xmath497    note that this notion of similarity layers can be seen as a refinement of the notion of bfs layers for graphs , which are obtained by layering the nodes according to their distance to the root .",
    "hence , the two concepts are similar but different . we first show that this layer structure defines a partition of @xmath40 when @xmath12 is a robinsonian matrix and the root @xmath105 is an anchor of @xmath12 .",
    "[ thm : layers structure ] assume that @xmath42 is a robinsonian matrix and that @xmath498 is an anchor of @xmath12 . consider the similarity layer structure @xmath499 of  @xmath12 rooted at  @xmath105 , as defined in ( [ eq : layers ] ) , where @xmath500 is the smallest index such that @xmath501 . the following holds :    1 .",
    "if @xmath502 with @xmath351 , then there exists a path @xmath92 from @xmath105 to @xmath30 avoiding @xmath83 .",
    "moreover , any path of the form @xmath503 , where @xmath504 for @xmath505 , avoids @xmath83 .",
    "2 .   @xmath506 .",
    "\\(i ) using the definition of the layers in ( [ eq : layers ] ) we obtain that @xmath507 and @xmath508 , @xmath509 which shows that the path @xmath510 avoids @xmath83 .",
    "\\(ii ) suppose @xmath511 , @xmath512 , but @xmath513 .",
    "consider an element @xmath514 .",
    "as @xmath515 ( since this set is empty ) there exist elements @xmath516 and @xmath517 such that @xmath518 .",
    "analogously , as @xmath519 there exist elements @xmath520 such that @xmath521 .",
    "iterating we find elements @xmath522 , @xmath523 for all @xmath351 such that @xmath524 for all @xmath212 . at some step one must find one of the previously selected elements @xmath525 , i.e. , @xmath526 for some @xmath527 .",
    "as @xmath105 is an anchor of @xmath12 , there exists a robinson ordering @xmath9 of @xmath12 starting at @xmath105 .",
    "we first claim that @xmath528 for all @xmath529 .",
    "this is clear if @xmath530 .",
    "otherwise , as @xmath522 and @xmath531 , it follows from ( i ) that there is a path from @xmath105 to @xmath532 avoiding @xmath533 , which in view of lemma [ thm : path avoiding and robinson ordering ] implies that @xmath534 .",
    "next we claim that @xmath535 .",
    "since @xmath536 and @xmath524 , then @xmath537 avoids @xmath525 and in view of lemma [ thm : path avoiding and robinson ordering ] it must be indeed @xmath535 . summarizing we have shown that @xmath538 for all @xmath212 , which contradicts the fact that two of the @xmath525 s should coincide .",
    "@xmath81    intuitively ,",
    "each layer @xmath539 will correspond to some slices of a sfs algorithm starting at @xmath105 . as we see below",
    ", there is some compatibility between the layer structure @xmath540 rooted at @xmath105 with any robinson ordering @xmath9 and any good sfs ordering @xmath177 starting at @xmath105 .",
    "[ thm : layers and sfs / robinson ordering ] assume @xmath42 is a robinsonian matrix and @xmath105 is an anchor of @xmath12 .",
    "let @xmath177 be a good sfs ordering of @xmath12 starting at @xmath105 and let @xmath9 be a robinson ordering of @xmath12 starting at @xmath105 .",
    "then the similarity layer structure @xmath541 of @xmath12 rooted at @xmath105 is compatible with both @xmath9 and @xmath177 .",
    "that is , @xmath542    let @xmath543 and @xmath544 with @xmath527 ; we show that @xmath325 and @xmath462 .",
    "this is clear if @xmath545 , i.e. , if @xmath546 .",
    "suppose now @xmath351 .",
    "then , by lemma [ thm : layers structure ] , there exists a path from @xmath105 to @xmath29 avoiding @xmath30 .",
    "this implies that @xmath547 , as @xmath30 can not appear between @xmath105 and @xmath29 in any robinson ordering in view of lemma [ thm : path avoiding and robinson ordering ] and since @xmath9 starts with @xmath105 .",
    "furthermore , if @xmath548 then we would get a contradiction with lemma  [ thm : pal ]  ( pal ) .",
    "hence @xmath549 holds , as desired .",
    "@xmath81    furthermore , the following inequalities hold among the entries of @xmath12 indexed by elements in different layers .",
    "[ thm : inequalities among layers ] assume @xmath42 is a robinsonian matrix and  @xmath105 is an anchor of  @xmath12 . let @xmath550 be the similarity layer structure of @xmath12 rooted at @xmath105 .",
    "for each @xmath551 and @xmath552 with @xmath553 the following inequalities hold : @xmath554 furthermore , if @xmath555 , then there exists @xmath556 such that @xmath312 .",
    "the inequalities @xmath557 follow from the definition of the layers in ( [ eq : layers ] ) .",
    "suppose now that @xmath558",
    ". then @xmath99 must appear between @xmath29 and @xmath30 in any robinson ordering @xmath9 , since @xmath559 implies @xmath560 and @xmath561 implies @xmath562 .",
    "but in view of lemma [ thm : layers and sfs / robinson ordering ] , if @xmath9 is a robinson ordering starting at @xmath105 then @xmath563 and @xmath564 , so we get a contradiction .",
    "@xmath81    as an application of lemma [ thm : inequalities among layers ] , it is easy to verify that if @xmath12 is the adjacency matrix of a connected graph @xmath54 , then each layer is a clique of @xmath54 .",
    "we now show a ` flipping property ' of the similarity layers with respect to a good sfs ordering @xmath177 starting at the root and the next sweep @xmath565 . namely we show that the orders of the layers are reversed beween @xmath177 and @xmath439 , i.e. , @xmath566 and @xmath567 for all @xmath527 .",
    "[ thm : flipping layers theorem ] let @xmath42 be a robinsonian  matrix and @xmath493 be an anchor of @xmath12 .",
    "let @xmath541 be the similarity layer structure of @xmath12 rooted at @xmath105 , let @xmath177 be a good sfs ordering of @xmath12 starting at @xmath105 and let @xmath565 . if @xmath543 , @xmath544 with @xmath568 then @xmath569 .",
    "let @xmath543 , @xmath544 with @xmath527 .",
    "assume for contradiction that @xmath463 .",
    "by lemma  [ thm : layers and sfs / robinson ordering ] , we know that @xmath570 is compatible with @xmath177 and thus @xmath462 . as @xmath463 and @xmath462 , we deduce that @xmath301 are not tied in @xmath443 .",
    "hence there exists @xmath571 such that @xmath572 .",
    "let @xmath573 denote the layer of @xmath570 containing @xmath574 .",
    "we claim that @xmath575 . indeed , if @xmath576 then @xmath577 are in the same layer and , by lemma [ thm : inequalities among layers ] , it must be @xmath578 which is impossible , because @xmath579 .",
    "assume now that @xmath580 .",
    "by lemma  [ thm : layers and sfs / robinson ordering ] , if @xmath9 is a robinson ordering starting at @xmath105 , then we would get @xmath581 , which implies @xmath582 , again a contradiction .",
    "therefore , we have @xmath583 with @xmath584 .",
    "recall that @xmath585 .",
    "hence , starting with the pair @xmath461 which satisfies @xmath543 , @xmath544 with @xmath527 and @xmath463 , we have constructed another pair @xmath586 satisfying @xmath587 , @xmath544 with @xmath588 and @xmath589 . as @xmath590 , iterating this construction we will reach a contradiction . @xmath81",
    "we now introduce our new sfs - based multisweep algorithm and we show that in at most @xmath2 sweeps it permits to recognize whether a given matrix of size @xmath7 is robinsonian .",
    "this is the main result of our paper , which we will prove in this section .",
    "first in subsection [ sec:5-description ] we will describe the algorithm and its main features . then",
    "in subsection [ sec:5-three - good sfs ordering ] we introduce the notion of ` 3-good sweep ' which plays a crucial role in the correctness proof and we investigate its properties . in subsection  [ sec:5-final proof ] we complete the proof of correctness of the multisweep algorithm .",
    "finally , in subsection  [ sec:5-worst case instances ] we present an infinite family of @xmath25 robinsonian matrices whose recognition needs exactly @xmath2 sweeps .",
    "our multisweep algorithm consists of computing successive sfs orderings of a given nonnegative matrix @xmath61 .",
    "the first sweep is @xmath440 , whose aim is to find an anchor of @xmath12 . each subsequent sweep is computed with the @xmath23 algorithm using the linear order returned by the preceding sweep to break ties .",
    "as it starts with the end - vertex of the preceding sweep which is an anchor of @xmath12 , each subsequent sweep is therefore a good sfs ordering of @xmath12 ( in the case when @xmath12 is robinsonian ) .",
    "the algorithm terminates either if a robinson ordering has been found ( in which case it certifies that @xmath12 is robinsonian ) , or if the @xmath591th sweep is not robinson ( in which case it certifies that @xmath12 is not robinsonian ) . the complete algorithm is reported below .",
    "[ alg : robinson_recognition ]    @xmath592 + : ` @xmath12 is not robinsonian '    as already mentioned earlier , the sfs algorithm applied to binary matrices reduces to lex - bfs . as a warm - up",
    "we now show that our sfs multisweep algorithm terminates in three sweeps to recognize whether a binary matrix @xmath12 is robinsonian . as",
    "a binary matrix @xmath12 is robinsonian if and only if the corresponding graph is a unit interval graph @xcite , this is coherent with the fact that one can recognize unit interval graphs in three sweeps of lex - bfs ( * ? ? ?",
    "* thm  9 ) .",
    "hence we have a new proof for this result , which has similarities but yet differs from the original proof in @xcite .    [ thm : our proof for 3sweep algorithm uig ] let @xmath54 be a connected graph and let @xmath12 be its adjacency matrix . consider the orders @xmath592 , @xmath593 and @xmath594 . then  @xmath54 is a unit interval graph ( i.e. , @xmath12 is robinsonian ) if and only if @xmath595 is a robinson ordering of @xmath12 .    clearly , if @xmath595 is robinson then @xmath12 is robinsonian .",
    "assume now that @xmath12 is robinsonian ; we show that @xmath595 is robinson .",
    "suppose , for contradiction , that there exists a triple @xmath596 which is not robinson , i.e. , @xmath597 .",
    "then the path @xmath332 avoids @xmath30 and thus , in view of lemma [ thm : pal ] ( pal ) , in any robinson ordering @xmath9 one can not have @xmath72 .",
    "we may assume without loss of generality that @xmath328 in some robinson ordering @xmath9 . because @xmath12 is a binary matrix , then @xmath598 , @xmath599 and thus @xmath600 .",
    "by construction , @xmath601 is a good sfs ordering of @xmath12 starting ( say ) at the anchor @xmath105 .",
    "let @xmath602 be the similarity layer structure of @xmath12 rooted at @xmath105 .",
    "by lemma  [ thm : layers and sfs / robinson ordering ] , we know that @xmath540 is compatible with @xmath601 , i.e. , @xmath603 . using theorem  [ thm : flipping layers theorem ] we obtain that @xmath604 moreover , using lemma [ thm : inequalities among layers ] and the fact that @xmath54 is connected , it is easy to see that each layer @xmath496 is a clique of @xmath54",
    ". hence , @xmath240 can not be in the same layer of @xmath570 , as @xmath605 .",
    "since @xmath606 , it follows that @xmath607 with @xmath608 and thus @xmath609 .",
    "say @xmath610 .",
    "one can not have @xmath611 since this would contradict @xmath612 . if @xmath613 then @xmath614 and thus @xmath615 by definition of the layers , contradicting the fact that @xmath598 , @xmath599 .",
    "hence one must have @xmath616 .",
    "then @xmath617 , @xmath544 , @xmath610 with @xmath618 and thus @xmath619 .",
    "now we get a contradiction with lemma [ thm : pal ] ( pal ) , as @xmath620 and the path @xmath332 avoids  @xmath30 .",
    "the proof of theorem  [ thm : our proof for 3sweep algorithm uig ] outlines a fundamental difference between unit interval graphs and robinsonian matrices . indeed , using lemma  [ thm : inequalities among layers ]",
    ", it is easy to see that , for @xmath103 robinsonian matrices , each layer  @xmath496 of the similarity layer structure @xmath570 rooted at an anchor @xmath105 is a clique of @xmath54 .",
    "this property in fact permits to bound by three the number of sweeps neded to recognize @xmath103 robinsonian matrices .",
    "however , for robinsonian matrices with at least three distinct values we do not have any analogous structural property for the vertices lying in a common layer , which explains why we might need @xmath2 sweeps in the worst case .",
    "we now formulate our main result , namely that the sfs multisweep algorithm terminates in at most @xmath2 steps to recognize whether an @xmath25 matrix is robinsonian .",
    "[ thm : final theorem ] let @xmath42 and let @xmath592 , @xmath621 for @xmath622 be the successive sweeps returned by algorithm [ alg : robinson_recognition ] .",
    "then @xmath12 is a robinsonian matrix if and only if @xmath623 is a robinson ordering of @xmath12",
    ".    we will give the full proof of theorem [ thm : final theorem ] in subsection [ sec:5-final proof ] below .",
    "what we need to show is that if @xmath12 is robinsonian then the order @xmath623 in algorithm [ alg : robinson_recognition ] is a robinson ordering of @xmath12 .",
    "we now give a rough sketch of the strategy which we will use to prove this result .",
    "the proof will use induction on the size @xmath7 of the matrix @xmath12 .    as was shown earlier , the sweep @xmath601 is a good sfs ordering of @xmath12 with end - vertices ( say ) @xmath105 and @xmath111 , and all subsequent sweeps have the same end - vertices ( flipping their order at each sweep ) in view of theorem [ thm : flipping theorem ] .",
    "a first key ingredient will be to show that if we delete both end - vertices @xmath105 and @xmath111 and set @xmath624 , then the induced order @xmath625 $ ] is a good sfs ordering of the principal submatrix @xmath44 $ ] .",
    "a second crucial ingredient will be to show that the induced order @xmath626 $ ] can be obtained with the multisweep algorithm applied to @xmath44 $ ] starting from @xmath625 $ ] .",
    "this will enable us to apply the induction assumption and to conclude that @xmath626 $ ] is a robinson ordering of @xmath44 $ ] .",
    "hence all triples @xmath67 in @xmath623 that are contained in @xmath624 are robinson .",
    "the last step is to show that all triples @xmath67 in @xmath623 that contain @xmath105 or @xmath111 are also robinson .    as we see in the above sketch",
    ", the sweep @xmath627 plays a special role .",
    "it is obtained by applying three sweeps of @xmath23 starting from the good sfs ordering @xmath601 .",
    "for this reason we call it a _",
    "3-good sfs ordering_. we introduce and investigate in detail this notion of ` 3-good sfs ordering ' in subsection [ sec:5-three - good sfs ordering ] below .",
    "consider a robinsonian matrix @xmath61 .",
    "recall that a sfs ordering @xmath247 of @xmath12 is said to be _ good _ if its first vertex is an anchor of @xmath12 ( see subsection [ sec:4-good sfs and end points ] ) .",
    "we now introduce the notion of 3-good sfs ordering .",
    "a linear order  @xmath247 is called a _ 3-good sfs ordering _ of @xmath12 if there exists a good sfs ordering @xmath253 of @xmath12 such that , if we set @xmath628 , then @xmath629 holds . in other words , a 3-good sfs ordering is obtained by performing three consecutive good sweeps .",
    "of course any 3-good sfs ordering is also a good sfs ordering .",
    "furthermore , if we consider algorithm [ alg : robinson_recognition ] , then any sweep @xmath630 with @xmath631 is a 3-good sfs ordering by construction .",
    "first we report the following flipping property of layers which follows as a direct application of theorem [ thm : flipping layers theorem ] .",
    "[ thm : flipping layers for 3-good sfs ] assume @xmath42 is a robinsonian matrix .",
    "let @xmath253 be a good sfs ordering of @xmath12 , @xmath628 and @xmath629 .",
    "let @xmath632 be the similarity layer structure of @xmath12 rooted at the first vertex of @xmath247 .",
    "if @xmath633 , @xmath544 with @xmath527 then @xmath634 .    we now show some important properties of 3-good sfs orderings , that we will use in the proof of correctness of the multisweep algorithm .",
    "first we show that some triples in a 3-good sfs ordering can be shown to be robinson .",
    "[ thm:3-good - sweep basic fact not - robinson triple ] assume @xmath42 is a robinsonian matrix .",
    "let @xmath247 be a 3-good sfs ordering starting at @xmath105 and ending at @xmath111 .",
    "let @xmath635 be the similarity layer structure of @xmath12 rooted at @xmath105 .",
    "then the following holds :    a.   if @xmath636 and @xmath67 is not robinson , then @xmath637 with @xmath638 .",
    "b.   every triple @xmath639 with @xmath640 is robinson . c.   every triple @xmath641 with @xmath640 is robinson .",
    "let @xmath253 be a good sfs order such that @xmath628 , @xmath629 .",
    "let @xmath642 denote the similarity layer structure of @xmath12 rooted at @xmath111 , which is compatible with @xmath643 .    _",
    "( i ) _ let @xmath644 such that @xmath645 do not all belong to the same layer of  @xmath570 and assume that @xmath67 is not robinson",
    ". then @xmath82 and the path @xmath332 avoids @xmath30 .",
    "let @xmath9 be a robinson ordering and assume , without loss of generality , that @xmath646 . then , since @xmath332 avoids @xmath30 , in view of lemma [ thm : path avoiding and robinson ordering ] @xmath30 can not appear between @xmath29 and @xmath83 in any robinson ordering .",
    "if @xmath30 appears after @xmath83 in @xmath9 then we have @xmath72 and @xmath636 , and we get a contradiction with lemma [ thm : pal ] ( pal ) as there can not exists a path from @xmath29 to @xmath83 avoiding @xmath30 .",
    "therefore @xmath647 and thus @xmath648 in view of lemma [ thm : layers and sfs / robinson ordering ] , @xmath645 do not belong to three distinct layers of @xmath540 ( since otherwise @xmath67 would be robinson ) .",
    "moreover , one can not have @xmath543 and @xmath649 with @xmath527 ( since this would imply @xmath650 , a contradiction ) .",
    "hence we must have @xmath651 and @xmath652 with @xmath527 .",
    "consider now @xmath643 ; applying corollary [ thm : flipping layers for 3-good sfs ] , we derive that @xmath653 moreover , we can not have that @xmath654 , since we would get a contradiction with lemma [ thm : pal ]  ( pal ) as @xmath655 and the path @xmath332 avoids @xmath30 .",
    "hence we have @xmath656 summarizing , the triple @xmath67 satisfies the properties : @xmath657 we will now show that the properties in ( [ eqxyz ] ) ( together with the inequality @xmath658 ) permit to find an element @xmath659 for which the triple @xmath660 again satisfies the properties of ( [ eqxyz ] ) , replacing @xmath29 by @xmath574 .",
    "then , iterating this construction leads to a contradiction .",
    "we now proceed to show the existence of such an element @xmath574 . as @xmath661 and @xmath640 , @xmath301",
    "are not tied in @xmath247 and thus there exists @xmath662 such that @xmath663 this implies @xmath664 ( recall lemma [ thm : inequalities among layers ] ) . moreover",
    ", the path @xmath665 avoids @xmath30 , since @xmath572 and @xmath666 by construction we have : @xmath667 we claim that @xmath668 indeed , if @xmath669 , then @xmath670 and thus @xmath671 , a contradiction . moreover , if @xmath672 then @xmath673 , which implies @xmath674 and thus the triple @xmath660 is not robinson .",
    "then @xmath675 and the path @xmath676 avoids @xmath30 .",
    "now , as @xmath677 and @xmath678 , we get a contradiction with lemma [ thm : pal ] ( pal ) .",
    "so we have shown that @xmath679    next we claim that @xmath680 . indeed , if @xmath681 then @xmath682 , which together with @xmath683 and the fact that the path @xmath665 avoids @xmath30 , contradicts lemma  [ thm : pal ] ( pal ) .",
    "hence we have shown that the triple @xmath660 satisfies  ( [ eqxyz ] ) , which concludes the proof of _ ( i)_.    _ ( ii ) _ follows directly from _ ( i ) _ , since any triple containing @xmath105 is not contained in a unique layer , and thus it must be robinson .    _",
    "assume for contradiction that @xmath641 is not robinson for some @xmath684 , i.e. , @xmath685 .",
    "then the path @xmath686 avoids @xmath30 .",
    "if @xmath9 is a robinson ordering ending at @xmath111 ( which exists since @xmath111 is an anchor ) then we must have @xmath687 because , in view of lemma [ thm : path avoiding and robinson ordering ] , @xmath30 can not appear between @xmath29 and @xmath111 in any robinson ordering .",
    "hence , @xmath688 .",
    "since @xmath643 is compatible with @xmath689 which is rooted at @xmath111 , we must have @xmath690 and moreover @xmath301 belong to distinct layers of @xmath689 .",
    "thus @xmath691 with @xmath608 which , in view of theorem [ thm : flipping layers theorem ] , implies @xmath692 , a contradiction .",
    "@xmath81    as a first direct application of lemma [ thm:3-good - sweep basic fact not - robinson triple](i ) , we can conclude that the multisweep algorithm terminates in at most four steps when applied to a matrix @xmath12 whose similarity layers rooted at the end - vertex of the first sweep @xmath693 all have cardinality at most 2 .    consider a 3-good sfs ordering @xmath247 of a robinsonian matrix @xmath12 with end - vertices @xmath105 and @xmath111 and",
    "consider the induced order @xmath694 $ ] of the submatrix @xmath44 $ ] indexed by the subset @xmath695 . in the next lemmas we show some properties of @xmath694 $ ] .",
    "first , we show that @xmath694 $ ] is a good sfs ordering of @xmath44 $ ] ( lemma [ thm:3-good - sweep without endpoints ] ) .",
    "second , we show that applying the @xmath23 algorithm to @xmath247 and then deleting @xmath105 and @xmath111 yields the same order as applying the @xmath23 algorithm to the induced order @xmath694 $ ] ( lemma [ thm:3-good - sweep and successive sweep ] ) .",
    "these properties will be used in the induction step for the proof of correctness of the multisweep algorithm in the next subsection .",
    "we start with showing a ` flipping property ' of the second smallest element of @xmath247 .",
    "[ thm:2-good - sweep and successive sweep ] assume @xmath42 is a robinsonian matrix .",
    "let @xmath253 be a good sfs ordering of @xmath12 , @xmath628 and @xmath629 .",
    "let @xmath105 be the first vertex of @xmath247 .",
    "then the successor @xmath696 of @xmath105 in @xmath247 is the predecessor of @xmath105 in @xmath643 .    as before",
    ", @xmath697 is the layer structure of @xmath12 rooted at  @xmath105 , which is compatible with @xmath247 .",
    "the slice of @xmath105 in @xmath247 is precisely the first layer @xmath698 in  @xmath699 . by definition , @xmath696 is the element of @xmath698 coming last in @xmath643 . by the flipping property in corollary [ thm : flipping layers for 3-good sfs ]",
    ", we know that the layer @xmath698 comes last but one in @xmath643 , just before the layer @xmath495 . then @xmath696 is the element of @xmath698 appearing last in @xmath643 , and thus it coincides with the predecessor of @xmath105 in @xmath643",
    ". @xmath81    [ thm:3-good - sweep without endpoints ] assume @xmath42 is a robinsonian matrix .",
    "let @xmath247 be a 3-good sfs ordering of @xmath12 with end - vertices @xmath105 and @xmath111 and set @xmath624 .",
    "then @xmath700 $ ] is a good sfs ordering of @xmath44 $ ] .",
    "say that @xmath105 is the first element of @xmath247 and that @xmath111 is its last element .",
    "let @xmath701 be the similarity layer structure rooted at @xmath105 , which is compatible with @xmath247 .",
    "first we show that @xmath694 $ ] is a sfs ordering of @xmath44 $ ] . for this",
    "consider elements @xmath702 such that @xmath234 .",
    "then @xmath67 is not robinson and thus @xmath703 with @xmath704 in view of lemma [ thm:3-good - sweep basic fact not - robinson triple ] . as @xmath247 is a sfs ordering , then in view of theorem [ thm : sfs ordering characterization ] there exists @xmath705 such that @xmath706 .",
    "we have @xmath707 ( since @xmath708 would imply @xmath277 ) and thus @xmath709 .",
    "this shows that @xmath694 $ ] is a sfs ordering of @xmath44 $ ] .",
    "finally  @xmath694 $ ] is good since , in view of lemma [ thm:2-good - sweep and successive sweep ] , it starts at @xmath696 , the successor of @xmath105 in  @xmath247 , which is an anchor of @xmath710 $ ] ( and thus also of @xmath44 $ ] ) using theorem  [ thm : last vertex of sfs is an anchor ] .",
    "[ thm:3-good - sweep and successive sweep ] assume @xmath42 is a robinsonian matrix .",
    "let @xmath247 be a 3-good sfs ordering with end - vertices @xmath105 and @xmath111 .",
    "let @xmath711 and @xmath712",
    ". then @xmath713={\\text{\\rm sfs}}_+(a[s ] , \\tau[s])$ ] .",
    "say @xmath111 is the first element of @xmath247 and @xmath105 be its last element .",
    "then @xmath105 is the first element of @xmath714 and @xmath111 is its last element ( theorem [ thm : flipping theorem ] ) . let consider the similarity layer structure @xmath715 of @xmath12 rooted at @xmath105 , which is compatible with  @xmath714 ( and thus we denote here by @xmath716 ) .",
    "set @xmath717 , \\tau[s])$ ] .",
    "let @xmath696 the predecessor of @xmath105 in @xmath247 . as @xmath714",
    "is clearly also a 3-good sfs ordering then , in view of lemma  [ thm:2-good - sweep and successive sweep ] , @xmath696 is the successor of @xmath105 in @xmath714 and thus both @xmath713 $ ] and @xmath177 start at @xmath696 .",
    "assume that @xmath177 and @xmath713 $ ] agree on their first @xmath203 elements @xmath718 , but not at the next @xmath719th element .",
    "that is , @xmath713 = ( a_1,\\ldots , a_p , x , \\ldots , y,\\ldots)$ ] , while @xmath720 , where @xmath301 are distinct elements .",
    "we distinguish three cases .",
    "assume first that @xmath301 are tied in @xmath714 ( and thus in @xmath177 too ) .",
    "then one must have @xmath721 ( to place @xmath29 before @xmath30 in @xmath722 $ ] ) and @xmath640 ( to place @xmath30 before @xmath29 in @xmath177 ) , a contradiction .",
    "assume now that @xmath301 are not tied in @xmath714 , but they are tied in @xmath177",
    ". then @xmath723 . hence ,",
    "since the similarity layer structure @xmath570 of @xmath12 is rooted at @xmath105 , then we have @xmath724 , @xmath725 for some @xmath726 .",
    "this implies @xmath727 ( by corollary [ thm : flipping layers for 3-good sfs ] ) and thus , since @xmath301 are tied in @xmath177 , one would place @xmath29 before @xmath30 in @xmath177 , a contradiction .",
    "assume finally that @xmath301 are not tied in @xmath714 and also not in @xmath177 .",
    "let @xmath728 be the pivot splitting @xmath29 and @xmath30 in @xmath177 so that @xmath729 , with @xmath730 .",
    "we claim that @xmath105 is the pivot splitting @xmath29 and @xmath30 in @xmath713 $ ] . for this , suppose that @xmath731 is the pivot splitting @xmath29 and  @xmath30 in @xmath713 $ ] for some @xmath732 , so that @xmath733 and @xmath734 .",
    "it is now easy to see that @xmath735 would imply @xmath736 , while @xmath527 would imply @xmath280 , a contradiction in both cases .",
    "hence , @xmath105 is the pivot splitting @xmath301 in @xmath713 $ ] and thus @xmath723 .",
    "then , as @xmath716 is the similarity layer structure of @xmath12 rooted at @xmath105 , @xmath29 and @xmath30 belong to distinct layers of  @xmath737 .",
    "moreover , @xmath738 and the triple @xmath739 is not robinson . as",
    "@xmath714 is a 3-good sfs ordering , we can apply lemma [ thm:3-good - sweep basic fact not - robinson triple ] and conclude that @xmath740 must belong to a common layer of @xmath540 , contradicting the fact that @xmath301 belong to distinct layers of  @xmath741 .",
    "we can finally put all ingredients together and show the correctness of our multisweep algorithm .",
    "we show the following result , which implies directly theorem  [ thm : final theorem ] .",
    "[ thm : good sweep converges in n-2 ] let @xmath42 be a robinsonian matrix , let @xmath742 be a good sfs ordering of @xmath12 and let @xmath743 for @xmath375 . then @xmath744 is a robinson ordering of  @xmath12 .",
    "the proof is by induction on the size @xmath7 of @xmath12 .",
    "for @xmath745 there is nothing to prove and for @xmath746 the result holds trivially . hence ,",
    "suppose @xmath747 .",
    "then , by the induction assumption , we know that the following holds : @xmath748 suppose @xmath742 starts with @xmath105 and ends with @xmath111 . by lemma [ thm : flipping theorem",
    "] , the end - vertices of any @xmath749 with @xmath375 are @xmath105 and @xmath111 ( flipped at every consecutive sweep ) . for any @xmath750",
    ", @xmath749 is a 3-good sfs ordering of @xmath12 .",
    "hence , setting @xmath624 , in view of lemma [ thm:3-good - sweep and successive sweep ] , we obtain that @xmath751 = { \\text{\\rm sfs}}_+(a[s],\\tau_i[s])$ ] for each @xmath750 .",
    "consider the order @xmath752 $ ] and the successive sweeps @xmath753,\\sigma_{i-1})$ ] ( @xmath754 ) returned by the multisweep algorithm applied to @xmath44 $ ] starting from @xmath601 .    as @xmath755 is a 3-good sfs ordering of @xmath12 , in view of lemma  [ thm:3-good - sweep without endpoints ] we know that @xmath601 is a good sfs ordering of @xmath44 $ ] .",
    "hence , using the induction assumption applied to @xmath44 $ ] and @xmath601 , we can conclude that the sweep @xmath756 ( returned by the multisweep algorithm applied to @xmath44 $ ] with @xmath601 as first sweep ) is a robinson ordering of @xmath44 $ ] .",
    "we now observe that equality @xmath757=\\sigma_i$ ] holds for all @xmath351 , using induction on @xmath351 .",
    "this is true for @xmath352 by the definition of @xmath601 .",
    "inductively , if @xmath757=\\sigma_i$ ] then @xmath758= { \\text{\\rm sfs}}_+(a[s],\\tau_{i+2}[s])= { \\text{\\rm sfs}}_+(a[s ] , \\sigma_i)=\\sigma_{i+1}$ ] .",
    "hence , we can conclude that @xmath759=\\sigma_{n-4}$ ] is a robinson ordering of @xmath44 $ ] .    finally , using with lemma [ thm:3-good - sweep basic fact not - robinson triple ]",
    ", we can conclude that all triples @xmath67 in @xmath744 that contain @xmath105 or @xmath111 are robinson .",
    "therefore we have shown that @xmath744 is a robinson ordering of @xmath12 , which concludes the proof .",
    "@xmath81    in other words , starting with a good sfs ordering of a robinsonian matrix  @xmath760 , after at most @xmath761 sweeps we find a robinson ordering of @xmath12 .",
    "finally , we can now prove theorem [ thm : final theorem ] , since the last vertex of the first sweep @xmath693 in algorithm [ alg : robinson_recognition ] is an anchor of @xmath12 ( theorem [ thm : last vertex of sfs is an anchor ] ) and thus the second sweep @xmath601 is a good sfs ordering .",
    "hence , if @xmath42 is a robinsonian matrix , in view of theorem [ thm : good sweep converges in n-2 ] , the multisweep algorithm returns a robinson ordering in at most @xmath761 sweeps starting from @xmath601 , and thus in at most @xmath2 sweeps counting also the initialization sweep @xmath693 .      we present a class of @xmath25 robinsonian matrices , communicated to us by s. tanigawa , for which the sfs multisweep algorithm ( algorithm  [ alg : robinson_recognition ] ) needs @xmath2 sweeps to terminate .",
    "[ def : worst matrix ] let @xmath762 be the robinson matrix defined as follows : @xmath763 we will refer to ( [ eqshift ] ) as the _ shifting property_.    we give below an example of such a matrix @xmath12 for @xmath764 :    @xmath765    note that the matrix @xmath12 in definition  [ def : worst matrix ] is robinson by construction , and therefore @xmath766 is a robinson ordering of  @xmath12 .",
    "we consider the following ordering @xmath767 which can easily be checked to be a sfs ordering of @xmath12 .",
    "we will consider the sfs multisweep algorithm ( algorithm  [ alg : robinson_recognition ] ) applied to the matrix  @xmath12 when taking the ordering @xmath693 as initial ordering .",
    "as we show below , the algorithm needs  @xmath2 sweeps to terminate .",
    "[ theoa ] let @xmath12 be as in definition  [ def : worst matrix ] , let @xmath768 and let @xmath769 for @xmath770 .",
    "then the smallest index @xmath771 for which @xmath772 is a robinson ordering of @xmath12 is @xmath773 .",
    "we first group properties of the matrix @xmath12 needed for the proof of theorem  [ theoa ] .",
    "the following relations hold for the matrix @xmath12 from definition  [ def : worst matrix ] : @xmath774    relations ( [ eqp1 ] ) and ( [ eqp4 ] ) hold for @xmath775 and we use the shifting property  ( [ eqshift ] ) to get the general case .",
    "analogously for relation ( [ eqp5 ] ) , since it holds for  @xmath776 .",
    "@xmath81    as key ingredient for proving theorem [ theoa ] we give the explicit description of the successive orderings @xmath777 returned by the multisweep algorithm .",
    "[ theosweep ] let @xmath12 be as in definition  [ def : worst matrix ] and let @xmath768 .",
    "then the successive orderings @xmath778 for @xmath779 , returned by the multisweep algorithm applied to the matrix @xmath12 , have the form @xmath780 for even order @xmath781 and the form @xmath782 for odd order @xmath783 .",
    "we show that the successive sweeps have the desired form using induction on the order of the sweep . in a first step ,",
    "let @xmath784 and assume that @xmath785 has the form ( [ eqeven ] ) , i.e. , @xmath786 we show that @xmath787 has the form ( [ eqodd ] ) , i.e. , @xmath788 first we claim that for any @xmath789 the @xmath771th pivot is @xmath790 , with corresponding ordered partition : @xmath791 recall from section  [ sec:3-description algorithm ] that , given a pivot @xmath792 at the current iteration of the sfs algorithm , we let  @xmath793 denote the queue of unvisited nodes induced by  @xmath792 . hence , the set @xmath794 represents the current slice , i.e. , the first block of @xmath793 , whose elements are not yet ordered .",
    "the claim is true for @xmath775 ( easy to see ) .",
    "assume this is true for @xmath795 , we show this also holds for @xmath796 .",
    "indeed the next pivot is @xmath796 ( the vertex in the slice @xmath797 appearing last in @xmath785 ) , which splits the vertex @xmath798 from the rest of the slice , leading to the new slice @xmath799 ( since @xmath800 by ( [ eqp1 ] ) ) .",
    "hence , the ordered partition becomes : @xmath801 hence , after the selection of the first @xmath802 pivots , the ordered partition is @xmath803 the next pivot is @xmath804 ( the vertex in the slice appearing last in @xmath785 ) . using ( [ eqp4 ] ) (",
    "applied to @xmath805 ) we know that @xmath806 , so that the ordered partition becomes @xmath807 the next pivot is @xmath808 . as @xmath809 ( using again ( [ eqp4 ] ) ,",
    "now applied to @xmath810 ) , the next ordered partition is @xmath811 iterating this process one can easily see that the ordering returned by the @xmath23 algorithm has indeed the form ( [ eqodd ] ) .    in a second step ,",
    "let @xmath812 and assume @xmath813 is as in ( [ eqodd ] ) ( after shifting indices ) , i.e. , @xmath814 we show that @xmath815 has the form ( [ eqeven ] ) , i.e. , that it is equal to @xmath816 first we claim that for @xmath795 the @xmath771th pivot is @xmath817 with ordered partition @xmath818 this is true for @xmath775 , because @xmath7 appears last in @xmath813 and @xmath819 .",
    "assume this is true for some @xmath820 , we show this also holds for @xmath796 .",
    "indeed the next pivot is @xmath798 .",
    "moreover , by ( [ eqp4 ] ) , @xmath821 .",
    "hence the new pivot @xmath798 splits the element @xmath822 from the rest of the slice , and the next ordered partition has the claimed form .",
    "hence , after @xmath481 steps , we have the following ordered partition : @xmath823 remains to show that the current slice @xmath824 gets reordered as @xmath37 in the next steps .",
    "the next pivot is @xmath825 . by ( [ eqp1 ] ) ( applied to @xmath805 ) , @xmath826 .",
    "hence the two elements @xmath804 and @xmath827 are split by @xmath825 but as we can not yet decide on their relative order they are both placed in the same block after the new slice in the queue of unvisited vertices .",
    "( note indeed that , e.g. , if @xmath828 , then @xmath829 . )",
    "so we get the ordered partition : @xmath830 the next pivot is @xmath831 . by ( [ eqp1 ] ) ( applied to @xmath810 ) , @xmath832 .",
    "hence @xmath831 splits @xmath808 from the rest of the slice and the next ordered partition is @xmath833 the next pivot is @xmath834 , which splits @xmath835 from the rest of the slice ( using again  ( [ eqp1 ] ) ) .",
    "moreover , by ( [ eqp5 ] ) ( applied to @xmath836 ) , @xmath837 and thus the two elements @xmath804 and @xmath827 get ordered with @xmath804 coming before  @xmath827 .",
    "so the ordered partition becomes @xmath838 iterating one can easily conclude that the final ordering returned by the @xmath23 algorithm indeed has the form ( [ eqeven ] )",
    ".    we can now prove theorem [ theoa ] .",
    "_ of theorem [ theoa ] .",
    "_ using lemma  [ theosweep ] , we find that @xmath839 for even @xmath7 and @xmath840 for odd @xmath7 .",
    "hence @xmath623 is a robinson ordering of  @xmath12 in both cases .",
    "furthermore , observe that @xmath841 if @xmath842 ( because  @xmath827 comes before @xmath802 in both @xmath813 and @xmath785 ) , and @xmath843 if @xmath844 ( because @xmath825 comes before @xmath827 in both @xmath845 and @xmath785 ) .",
    "therefore , @xmath846 can not be robinson orderings of @xmath12 in view of lemma  [ thm : sfs+(a , pi ) and reversed robinson triple ] .",
    "this implies that the first index @xmath771 for which  @xmath772 is robinson is indeed @xmath773 , which concludes the proof .",
    "it is important to remark that , for the class of matrices from definition  [ def : worst matrix ] , the fact that @xmath2 sweeps are required depends strongly on the choice of the initial ordering  @xmath693 from ( [ eq:0 ] ) .",
    "in this section we discuss the complexity of the sfs algorithm . throughout",
    "we assume that @xmath42 is a nonnegative symmetric matrix , given as adjacency list of an undirected weighted graph @xmath53,e)$ ] .",
    "so @xmath54 is the support graph of @xmath12 , whose edges are the pairs @xmath62 such that @xmath847 with edge weight @xmath64 , and @xmath848 is the neighborhood of @xmath65 .",
    "we assume that each vertex @xmath849 $ ] is linked to the list of vertex / weight pairs @xmath850 for its neighbors @xmath851 and we let @xmath1 denote the number of nonzero entries of @xmath12 .",
    "[ thm : complexity_sfs ] the sfs algorithm ( algorithm [ alg : sfs ] ) applied to an @xmath0 symmetric nonnegative matrix with @xmath1 nonzero entries runs in @xmath852 time .    as in @xcite for lex - bfs",
    ", we may assume that we are given an initial order  @xmath247 of @xmath40 and that the vertices and their neighborhoods are ordered according to @xmath247 ( in increasing order ) .",
    "this assumption is useful also for the discussion of the implementation of @xmath23 .    in order to run algorithm [ alg : sfs ]",
    ", we need to update the queue @xmath194 consisting of the unvisited vertices at each iteration .",
    "the update consists in computing the similarity partition @xmath853 with respect to the current pivot @xmath203 and then refining @xmath194 by @xmath853 .    to maintain the priority among the unvisited vertices , the queue @xmath854 is stored in a linked list , whose elements are the classes @xmath855",
    ". moreover each vertex has a pointer to the class @xmath193 containing it and a pointer to its position in the class , which are updated throughout the algorithm .",
    "this data structure permits constant time insertion and deletion of a vertex in @xmath194 .",
    "initially , the queue @xmath194 has only one class , namely the full set @xmath40 . at an iteration of algorithm [ alg : sfs ]",
    ", there are three main tasks to be performed : choose the next pivot , compute the similarity partition @xmath853 and refine the queue @xmath194 by @xmath853 .    1",
    ".   choose the new pivot @xmath856 .",
    "since in algorithm [ alg : sfs ] the choice of the new pivot is arbitrary in case of ties , we will choose the first vertex of the first block in @xmath194 .",
    "this operation can be done in constant time .",
    "we then remove @xmath203 from the queue @xmath194 of unvisited vertices and we update the queue @xmath194 by deleting @xmath203 from the class  @xmath219 .",
    "2 .   compute the similarity partition @xmath210 of the set @xmath857 with respect to @xmath856 ( as defined in definition [ def : layer partition ] ) . here",
    "@xmath858 denotes the set of unvisited vertices in the neighborhood @xmath202 of @xmath203 .",
    "first we order the vertices  @xmath30 in  @xmath857 for nonincreasing values of their similarities @xmath859 with respect to @xmath203 , which can be done in in @xmath860 time using a sorting algorithm .",
    "then we create the similarity partition @xmath210 simply by passing through the elements in @xmath857 in the order of nonincreasing similarities to @xmath203 which has just been found .",
    "this task can be done in @xmath861 time .",
    "finally we order the elements in each class @xmath862 ( increasingly ) according to @xmath247 , which can be done in @xmath860 .",
    "so we have constructed the ordered partition @xmath863 of @xmath864 as a linked list , where all classes of @xmath853 are ordered according to @xmath247 .",
    "to conclude , the overall complexity of this second task is bounded by @xmath860 .",
    "3 .   the last task is to refine @xmath865 by @xmath863 ( as defined in definition [ def : refine ] ) . in order to obtain the new queue of unvisited vertices we proceed as follows : starting from @xmath775 , for each class @xmath862 of @xmath197",
    ", we simply remove each vertex of @xmath862 from its corresponding class ( say ) @xmath193 in @xmath194 and we place it in a new class @xmath866 which we position immediately before @xmath193 in @xmath194 . since both @xmath862 and @xmath193 are ordered according to @xmath247 , the initial order @xmath247 in the new block @xmath866 is preserved . using the above described data structure , such tasks can be performed in @xmath867 . once a vertex is relocated in @xmath194 , its pointers to the corresponding block and position in @xmath194 are updated accordingly .",
    "hence this last task can be performed in time @xmath868 .    recall that at iteration @xmath212 we set @xmath856 .",
    "then the complexity at the @xmath212th iteration is @xmath869 .",
    "since we repeat the above three tasks for each vertex , then the overall complexity of algorithm [ alg : sfs ] is @xmath870 . @xmath81    using the same data structure as above",
    ", we can show that the sfs@xmath24 algorithm can be implemented in the same running time as the sfs algorithm .",
    "in fact , the only difference between the sfs algorithm and the @xmath23 algorithm lies in the tie - breaking rule . in the @xmath23 algorithm , in case of ties we choose as next pivot the vertex in the slice appearing last in the given order @xmath177 .",
    "recall we assumed @xmath40 to be initially ordered according to a given linear order  @xmath247 , which can be easily done in linear time in the size of the graph .",
    "then , we showed in the proof of theorem  [ thm : complexity_sfs ] that the initial order @xmath247 is always preserved in the classes of @xmath194 throughout the algorithm . therefore ,",
    "if we choose @xmath871 , then the first vertex in each slice @xmath45 is exactly the vertex of @xmath45 appearing last in @xmath177 .",
    "[ thm : complexity sfs_+ ] the @xmath23 algorithm    applied to an @xmath0 symmetric nonnegative matrix with @xmath1 nonzero entries runs in @xmath852 time .",
    "it follows directly from corollary [ thm : complexity sfs_+ ] that any sfs multisweep algorithm with @xmath481 sweeps can be implemented in @xmath872 . indeed the only additional tasks we need to do are the following : when we start a new @xmath23 sweep we need to reorder the vertices and their neighborhoods according to the reversal of the previous sweep , and we need to check if the current sweep @xmath630 is a robinson ordering , which can both be done in @xmath873 time .",
    "alternatively , one can check at each iteration @xmath622 if @xmath874 holds , which requires only @xmath875 time . then , if this is the case , in view of corollary  [ thm : corollary alternative robinson check ] we know that @xmath12 is robinsonian if and only @xmath630 is a robinson ordering .",
    "hence , one only needs to check once whether a given sweep is a robinson ordering , namely when it is the reversed of the previous one .",
    "another similar approach is inspired by the one used in  @xcite for their multisweep algorithm to recognize cocomparability graphs .",
    "specifically , every time we compute an sfs ordering @xmath630 with @xmath375 , we check if @xmath876 .",
    "if this is the case , then we stop ( because the algorithm will loop between @xmath877 and @xmath878 ) and we check whether @xmath630 is robinson .    in any case",
    ", as the multisweep algorithm ( algorithm [ alg : robinson_recognition ] ) needs @xmath879 sweeps , it runs in time @xmath880 .    as already mentioned in section [ sec:3-sfs algorithm ] , if the matrix has only @xmath103 entries , then there is no need to order the neighborhood @xmath202 of a given pivot @xmath203 , because the similarity partition @xmath881 has only one class , equal to @xmath202 .",
    "for this reason , in this case the sfs algorithm can be implemented in linear time @xmath882 .",
    "furthermore , as shown in theorem [ thm : our proof for 3sweep algorithm uig ] , three sweeps suffice in the multisweep algorithm to find a robinson ordering . therefore , if @xmath12 is a binary matrix , the multisweep algorithm in  algorithm [ alg : robinson_recognition ] has an overall running time of @xmath882 .",
    "this is coherent with the fact that in the  @xmath103 case sfs reduces to lex - bfs .    when the graph @xmath54 associated to the matrix @xmath12 is connected the complexity of sfs and @xmath23",
    "is @xmath883 . of course we may assume without loss of generality that we are in the connected case since we may deal with the connected components independently .",
    "indeed a matrix @xmath12 is robinsonian if and only if the submatrices @xmath884 $ ] are robinsonian for all connected components @xmath885 of @xmath54 , and robinson orderings of the connected components @xmath884 $ ] can be concatenated to give a robinson ordering of the full matrix @xmath12 .",
    "finally we observe that we may also exploit the potential sparsity induced by the _",
    "largest _ entries of @xmath12 . while @xmath54 is the graph",
    "whose edges are the pairs @xmath62 with entry @xmath847 ( where 0 is the smallest possible entry as @xmath12 is assumed to be nonnegative ) , we can also consider the graph @xmath886 whose edges are the pairs @xmath62 with entry @xmath887 , where @xmath888 is the largest possible entry of @xmath12 .",
    "let @xmath889 denote the neighborhood of a vertex @xmath203 in @xmath886 and let @xmath890 denote the number of entries with @xmath887 .",
    "we claim that the sfs ( @xmath23 ) algorithm can also be implemented in time @xmath891 .    for this",
    "we modify the definition of the similarity partition of a vertex @xmath203 , which is now a partition of @xmath889 ( so that the vertices @xmath892 have entry @xmath893 ) and the refinement of the queue @xmath194 by it : while we previously build the queue @xmath194 of unvisited vertices using a ` push - first ' strategy ( put the vertices with highest similarity first ) we now build the queue with a ` push - last ' strategy ( put the vertices with lowest similarity last ) .",
    "in this paper we have introduced the new search algorithm _ similarity - first search _ ( sfs ) and its variant @xmath23 , which are generalizations to weighted graphs of the classical lex - bfs algorithm and its variant lex - bfs@xmath24 . the algorithm is entirely based on the main task of partition refinement , it is conceptually simple and easy to implement .",
    "we have shown that a multisweep algorithm can be designed using sfs and @xmath23 , which permits to recognize if a symmetric @xmath0 matrix is robinsonian and if so to return a robinson ordering after at most @xmath2 sweeps .",
    "we believe that this recognition algorithm is substantially simpler than the other existing algorithms .",
    "moreover , to the best of our knowledge , this is the first work extending multisweep graph search algorithms to the setting of weighted graphs ( i.e. , matrices ) .",
    "our algorithm can also be used to recognize robinsonian dissimilarities . recall that a matrix @xmath894 is a _ robinson dissimilarity matrix _ if @xmath895 for all @xmath6 , and a _ robinsonian dissimilarity _ if its rows and columns can be simultaneously reordered to get a robinson dissimilarity matrix .",
    "clearly @xmath896 is a robinsonian dissimilarity matrix if and only if the matrix @xmath897 is a robinsonian similarity matrix .",
    "therefore , one can check whether @xmath896 is a robinsonian dissimilarity by applying the sfs - based multisweep algorithm to the matrix @xmath12 .",
    "alternatively one may also modify the sfs algorithm so that it can deal directly with dissimilarity matrices .",
    "say @xmath896 is a nonnegative dissimilarity matrix and @xmath54 is the corresponding weighted graph with edges the pairs @xmath62 with @xmath898 .",
    "then we can modify the sfs algorithm as follows .",
    "first , we now order the vertices in the neighborhood @xmath202 of a vertex @xmath203 for _ nondecreasing values _ of the dissimilarities @xmath899 ( instead of nonincreasing values of the similarities @xmath859 as was the case in sfs )",
    ". then we construct the ( dis)similarity partition @xmath853 of @xmath202 by grouping the vertices with the same dissimilarity to @xmath203 , in increasing values of the dissimilarities . finally , when refining the queue @xmath194 by @xmath853 , we apply a ` push - first ' strategy and place the vertices with lowest dissimilarity first . the resulting algorithm , which we name @xmath900 , standing for _ dissimilarity - search first _",
    ", has the same running time in @xmath901 .",
    "moreover , as explained above at the end of section [ sec:6-complexity ] , it can also be implemented in time @xmath891 , where @xmath890 denotes the number of entries of @xmath896 satisfying @xmath902 and @xmath903 denotes the largest entry of @xmath896 . using @xmath900 we can define the analogous multisweep algorithm for recognizing robinsonian dissimilarities in time @xmath904 ( or @xmath905 ) .    as we have seen in subsection",
    "[ sec:5-worst case instances ] , there exists a family of @xmath25 robinsonian matrices where @xmath2 sweeps are needed .",
    "it is an open question whether the multisweep algorithm can be modified in such a way that it would need only a constant number of sweeps , in which case it might become competitive with the optimal algorithm of @xcite . for this one would need to define another variant of sfs .",
    "a possible variant is when ties are broken using the sfs orderings returned by two previous sweeps ( instead of only one as in the @xmath23 variant ) .",
    "this approach has been succesfully applied to lex - bfs in @xcite for the recognition of interval graphs in five lex - bfs sweeps ; there the last sweep used is the variant lex - bfs@xmath906 , which breaks ties using the linear order returned by two previous sweeps .",
    "dusart and habib @xcite conjecture that a similar approach applies to recognize cocomparability graphs with a constant number of sweeps .",
    "investigating whether such an approach applies to robinsonian matrices will be the subject of future work .",
    "finally , it will be interesting to investigate whether the new sfs algorithm can be used to study other classes of structured matrices and in the general area of similarity search and clustering analysis .",
    "this work was supported by the marie curie initial training network",
    " mixed integer nonlinear optimization \" ( mino ) grant no .",
    ". we are grateful to the anonymous referees for their useful comments and to shinichi tanigawa for communicating to us the family of instances presented in subsection  [ sec:5-worst case instances ] , allowing us to include it in the paper .",
    "the second author also thanks michel habib for his useful comment about the complexity of the algorithm and mohammed el kebir for useful discussions .",
    "barnard , a.  pothen , and h.d .",
    "simon . a spectral algorithm for envelope reduction of sparse matrices . in _ proceedings of the 1993 acm / ieee conference on supercomputing _ , supercomputing 93 , pages 493502 , 1993 .",
    "lexicographic breadth first search - a survey . in j.",
    "hromkovi , m.  nagl , and b.  westfechtel , editors , _ graph - theoretic concepts in computer science _ , volume 3353 of _ lecture notes in computer science _ , pages 119 .",
    "springer berlin heidelberg , 2005 .",
    "p.  crescenzi , d.g .",
    "corneil , j.  dusart , and m.  habib .",
    "new trends for graph search .",
    "prima conference in shanghai , june 2013 .",
    "available at http://math.sjtu.edu.cn/conference/bannai/2013/data/20130629b/slides1.pdf .",
    "m.  laurent and m.  seminaroti . a lex - bfs - based recognition algorithm for robinsonian matrices . in _ algorithms and complexity : proceedings of the 9th international conference ciac 2015 _ , volume 9079 of _",
    "lecture notes in computer science _ , pages 325338 .",
    "springer - verlag , 2015 .",
    ". roberts . indifference graphs . in _",
    "proof techniques in graph theory : proceedings of the second ann arbor graph theory conference , f. harary , ed .",
    "_ , pages 139146 , new york , ny , 1969 . academic press .",
    "k.  simon . a new simple linear algorithm to recognize interval graphs . in h.  bieri and h.  noltemeier , editors ,",
    "_ computational geometry - methods , algorithms and applications _ , volume 553 of _ lecture notes in computer science _ , pages 289308 .",
    "springer berlin heidelberg , 1991 ."
  ],
  "abstract_text": [
    "<S> we present a new efficient combinatorial algorithm for recognizing if a given symmetric matrix is robinsonian , i.e. , if its rows and columns can be simultaneously reordered so that entries are monotone nondecreasing in rows and columns when moving toward the diagonal . as main ingredient </S>",
    "<S> we introduce a new algorithm , named similarity - first - search ( sfs ) , which extends lexicographic breadth - first search ( lex - bfs ) to weighted graphs and which we use in a multisweep algorithm to recognize robinsonian matrices . since robinsonian binary matrices correspond to unit interval graphs , our algorithm can be seen as a generalization to weighted graphs of the 3-sweep lex - bfs algorithm of corneil for recognizing unit interval graphs . </S>",
    "<S> this new recognition algorithm is extremely simple and it exploits new insight on the combinatorial structure of robinsonian matrices . for an @xmath0 nonnegative matrix with @xmath1 nonzero entries , it terminates in @xmath2 sfs sweeps , with overall running time @xmath3 .    </S>",
    "<S> * keywords : * _ robinson ( dis)similarity ; partition refinement ; seriation ; lex - bfs ; lbfs ; similarity search _ </S>"
  ]
}