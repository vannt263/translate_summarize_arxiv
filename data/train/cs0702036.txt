{
  "article_text": [
    "first - order temporal logic ( @xmath0 ) has been shown to be a powerful formalism for expressing sophisticated dynamic properties .",
    "unfortunately , this power also leads to strong intractability .",
    "recently , however , a fragment of @xmath0 , called _ monodic _ @xmath0 , has been investigated , both in terms of its theoretical  @xcite and practical  @xcite properties .",
    "essentially , monodicity allows for one free variable in every temporal formula .",
    "although clearly restrictive , this fragment has been shown to be useful in expressive description logics , infinite - state verification , and spatio - temporal logics  @xcite .",
    "we here develop a new temporal logic , combining decidable fragments of monodic @xmath0  @xcite with recent developments in xor temporal logics  @xcite , and apply this to the verification of parameterised systems .",
    "we use a communicating finite state machine model of computation , and can specify not only basic synchronous , parameterised systems with instantaneous broadcast communication  @xcite , but the powerful temporal language allows us also to specify asynchronously executing machines and more sophisticated communication properties , such as delayed delivery of messages .",
    "in addition , and in contrast to many other approaches  @xcite , not only safety , but also liveness and fairness properties , can be verified through automatic deductive verification .",
    "finally , in contrast to work on regular model checking  @xcite and constraint based verification using counting abstraction  @xcite , the logical approach is both complete and decidable .",
    "the verification of concurrent systems often comes down to the analysis of multiple finite - state automata , for example of the following form .        in describing such automata , both automata - theoretic and logical approaches may be used . while _ temporal logic",
    "_  @xcite provides a clear , concise and intuitive description of the system , automate - theoretic techniques such as _ model checking _",
    "@xcite have been shown to be more useful in practice .",
    "recently , however , a propositional , linear - time temporal logic with improved deductive properties has been introduced  @xcite , providing the possibility of practical deductive verification in the future .",
    "the essence of this approach is to provide an xor constraint between key propositions .",
    "these constraints state that exactly one proposition from a xor set can be true at any moment in time .",
    "thus , the automaton above can be described by the following clauses which are implicitly in the scope of a ` @xmath1 ' ( ` always in the future ' ) operator .",
    "@xmath2 here ` @xmath3 ' is a temporal operator denoting ` at the next moment ' and ` @xmath4 ' is a temporal operator which holds only at the initial moment in time .",
    "the inherent assumption that at any moment in time exactly one of @xmath5 , @xmath6 , @xmath7 or @xmath8 holds , is denoted by the following .",
    "@xmath9 with the complexity of the decision problem ( regarding @xmath5 , @xmath6 , etc ) being polynomial , then the properties of any finite collection of such automata can be tractably verified using this _ propositional _ xor temporal logic .    however , one might argue that this deductive approach , although elegant and concise , is still no better than a model checking approach , since it targets just _ finite _ collections of ( finite ) state machines .",
    "thus , this naturally leads to the question of whether the xor temporal approach can be extended to _ first - order temporal logics _ and , if so , whether a form of tractability still applies . in such an approach",
    ", we can consider _ infinite _ numbers of finite - state automata ( initially , all of the same structure ) .",
    "previously , we have shown that @xmath0 can be used to elegantly specify such a system , simply by assuming the argument to each predicate represents a particular automaton  @xcite .",
    "thus , in the following @xmath10 is true if automaton @xmath11 is in state @xmath5 : @xmath12 thus , @xmath0 can be used to specify and verify broadcast protocols between synchronous components  @xcite . in this paper",
    "we define a logic , , which allows us to not only to specify and verify systems of the above form , but also to specify and verify more sophisticated asynchronous systems , and to carry out verification with a reasonable complexity .    [ [ section ] ]",
    "first - order ( discrete , linear time ) temporal logic , @xmath0 , is an extension of classical first - order logic with operators that deal with a discrete and linear model of time ( isomorphic to the natural numbers , @xmath13 ) .    [ [ syntax . ] ] syntax .",
    "+ + + + + + +    the symbols used in @xmath0 are    * _ predicate symbols : _ @xmath14 each of which is of a fixed arity ( null - ary predicate symbols are _ propositions _ ) ; * _ variables : _ @xmath15 ; * _ constants : _ @xmath16 ; * _ boolean operators : _ @xmath17 , @xmath18 , @xmath19 , @xmath20 , @xmath21 , @xmath22 ( ` true ' ) , @xmath23 ( ` false ' ) ; * _ first - order quantifiers : _ @xmath24 ( ` for all ' ) and @xmath25 ( ` there exists ' ) ; and * _ temporal operators : _ @xmath1 ( ` always in the future ' ) , @xmath26 ( ` sometime in the future ' ) , @xmath3 ( ` at the next moment ' ) , @xmath27 ( until ) , @xmath28 ( weak until ) , and @xmath4 ( at the first moment in time ) .",
    "although the language contains constants , neither equality nor function symbols are allowed .",
    "the set of well - formed @xmath0-formulae is defined in the standard way  @xcite :    * booleans @xmath22 and @xmath23 are atomic @xmath0-formulae ; * if @xmath29 is an @xmath30-ary predicate symbol and @xmath31 , @xmath32 , are variables or constants , then @xmath33 is an atomic @xmath0-formula ; * if @xmath34 and @xmath35 are @xmath0-formulae , so are @xmath36 , @xmath37 , @xmath38 , @xmath39 , and @xmath40 ; * if @xmath34 is an @xmath0-formula and @xmath41 is a variable , then @xmath42 and @xmath43 are @xmath0-formulae ; * if @xmath34 and @xmath35 are @xmath0-formulae , then so are @xmath44 , @xmath45 , @xmath46 , @xmath47 , @xmath48 , and @xmath4 .    a _ literal _ is an atomic @xmath0-formula or its negation .",
    "[ [ semantics ] ] semantics , + + + + + + + + + +    intuitively , @xmath0formulae are interpreted in _ first - order temporal structures _ which are sequences @xmath49 of _ worlds _ , @xmath50 with truth values in different worlds being connected via temporal operators .",
    "more formally , for every moment of time @xmath51 , there is a corresponding _ first - order _ structure , @xmath52 , where every @xmath53 is a non - empty set such that whenever @xmath54 , @xmath55 , and @xmath56 is an interpretation of predicate and constant symbols over @xmath53 .",
    "we require that the interpretation of constants is _",
    "rigid_. thus , for every constant @xmath57 and all moments of time @xmath58 , we have @xmath59 .",
    "a _ ( variable ) assignment _ @xmath60 is a function from the set of individual variables to @xmath61 .",
    "we denote the set of all assignments by @xmath62 .",
    "the set of variable assignments @xmath63 corresponding to @xmath64 is a subset of the set of all assignments , @xmath65 ; clearly , @xmath66 if @xmath54",
    ".    the _ truth _ relation @xmath67 in a structure @xmath49 , is defined inductively on the construction of @xmath34 _ only for those assignments @xmath60 that satisfy the condition @xmath68_. see fig .  [",
    "fig : sem ] for details .",
    "@xmath69    @xmath49 is a _ model _ for a formula @xmath34 ( or @xmath34 is _ true _ in @xmath49 ) if , and only if , there exists an assignment @xmath60 in @xmath70 such that @xmath71 .",
    "a formula is _ satisfiable _ if , and only if , it has a model .",
    "a formula is _ valid _ if , and only if , it is true in any temporal structure @xmath49 under any assignment @xmath60 in @xmath70 .",
    "the models introduced above are known as _ models with expanding domains _ since @xmath72 .",
    "another important class of models consists of _ models with constant domains _ in which the class of first - order temporal structures , where @xmath0 formulae are interpreted , is restricted to structures @xmath73 , @xmath74 , such that @xmath75 for all @xmath76 .",
    "the notions of truth and validity are defined similarly to the expanding domain case .",
    "it is known  @xcite that satisfiability over expanding domains can be reduced to satisfiability over constant domains with only a polynomial increase in the size of formulae .",
    "the set of valid formulae of @xmath0 is not recursively enumerable .",
    "furthermore , it is known that even `` small '' fragments of @xmath0 , such as the _ two - variable monadic _ fragment ( where all predicates are unary ) , are not recursively enumerable  @xcite .",
    "however , the set of valid _ monodic _ formulae is known to be finitely axiomatisable  @xcite .",
    "an @xmath0-formula @xmath34 is called _ monodic _ if , and only if , any subformula of the form @xmath77 , where @xmath78 is one of @xmath3 , @xmath1 , @xmath26 ( or @xmath79 , where @xmath78 is one of @xmath27 , @xmath28 ) , contains at most one free variable .",
    "we note that the addition of either equality or function symbols to the monodic fragment generally leads to the loss of recursive enumerability  @xcite .",
    "thus , monodic @xmath0 is expressive , yet even small extensions lead to serious problems .",
    "further , even with its recursive enumerability , monodic @xmath0 is generally undecidable .",
    "to recover decidability , the easiest route is to restrict the first order part to some decidable fragment of first - order logic , such as the guarded , two - variable or monadic fragments .",
    "we here choose the latter , since monadic predicates fit well with our intended application to parameterised systems .",
    "recall that monadicity requires that all predicates have arity of at most ` 1 ' .",
    "thus , we use monadic , monodic @xmath0  @xcite .",
    "a practical approach to proving monodic temporal formulae is to use _ fine - grained temporal resolution _",
    "@xcite , which has been implemented in the theorem prover temp  @xcite . in the past",
    ", temp has been successfully applied to problems from several domains  @xcite , in particular , to examples specified in the temporal logics of knowledge ( the fusion of propositional linear - time temporal logic with multi - modal s5 )  @xcite . from this work",
    "it is clear that monodic first - order temporal logic is an important tool for specifying complex systems .",
    "however , it is also clear that the complexity , even of _ monadic _ monodic first - order temporal logic , makes this approach difficult to use for larger applications  @xcite .",
    "an additional restriction we make to the above logic involves implicit xor constraints over predicates .",
    "such restrictions were introduced into temporal logics in  @xcite , where the correspondence with bchi automata was described , and generalised in  @xcite . in both cases , the decision problem is of much better ( generally , polynomial ) complexity than that for the standard , unconstrained , logic . however , in these papers only _ propositional _ temporal logic was considered .",
    "we now add such an xor constraint to .",
    "the set of predicate symbols @xmath80 , is now partitioned into a set of xor - sets , @xmath81 , @xmath82 , @xmath83 , @xmath84 , with one _ non - xor _ set @xmath85 such that    1 .",
    "all @xmath86 are disjoint with each other , 2 .",
    "@xmath85 is disjoint with every @xmath86 , 3 .",
    "@xmath87  @xmath88 , and 4 .   for each @xmath86 ,",
    "exactly _ one _ predicate within @xmath86 is satisfied ( for any element of the domain ) at any moment in time .",
    "consider the formula @xmath89 where @xmath90 and @xmath91 .",
    "the above formula states that , for any element of the domain , a , then one of @xmath92 or @xmath93 must be satisfied and one of @xmath94 , @xmath95 or @xmath96 must be satisfied .      to simplify our description",
    ", we will define a _",
    "normal form _ into which formulae can be translated . in the following :    *",
    "@xmath97 denotes a conjunction of negated xor predicates from the set @xmath86 ; * @xmath98 denotes a disjunction of ( positive ) xor predicates from the set @xmath86 ; * @xmath99 denotes a conjunction of non - xor literals ; * @xmath100 denotes a disjunction of non - xor literals .",
    "a _ step _ clause is defined as follows : @xmath101 a _ monodic temporal problem in divided separated normal form ( dsnf ) _",
    "@xcite is a quadruple @xmath102 , where :    1 .   the universal part , @xmath103 , is a finite set of arbitrary closed first - order formulae ; 2 .",
    "the initial part , @xmath104 , is , again , a finite set of arbitrary closed first - order formulae ; 3 .",
    "the step part , @xmath105 , is a finite set of step clauses ; and 4 .",
    "the eventuality part , @xmath106 , is a finite set of eventuality clauses of the form @xmath107 , where @xmath108 is a unary literal .    in what follows",
    ", we will not distinguish between a finite set of formulae @xmath109 and the conjunction @xmath110 of formulae within the set . with each monodic temporal problem , we associate the formula @xmath111 now , when we talk about particular properties of a temporal problem ( e.g. , satisfiability , validity , logical consequences etc ) we mean properties of the associated formula .",
    "every monodic formula can be translated to the normal form in satisfiability preserving way using a renaming and unwinding technique which substitutes non - atomic subformulae and replaces temporal operators by their fixed point definitions as described , for example , in  @xcite .",
    "a step in this transformation is the following : we recursively rename each innermost open subformula @xmath112 , whose main connective is a temporal operator , by @xmath113 , where @xmath114 is a new unary predicate , and rename each innermost closed subformula @xmath115 , whose main connective is a temporal operator , by @xmath116 , where @xmath116 is a new propositional variable . while renaming introduces new , non - xor predicates and propositions , practical problems stemming from verification are nearly in the normal form , see section  [ sec : model ] .",
    "first - order temporal logics are notorious for being of a high complexity .",
    "even decidable sub - fragments of monodic first - order temporal logic can be too complex for practical use . for example , satisfiability of monodic monadic @xmath0 logic is known to be @xmath117-complete  @xcite . however , imposing xor restrictions we obtain better complexity bounds .",
    "[ th : complexity ] satisfiability of monodic monadic formulae ( in the normal form ) can be decided in @xmath118 time , where @xmath119 ,  , @xmath120 are cardinalities of the sets of xor predicates , and @xmath121 is the cardinality of the set of non - xor predicates .    before we sketch the proof of this result , we show how the xor restrictions influence the complexity of the satisfiability problem for monadic first - order ( non - temporal ) logic .",
    "[ lemma : fom ] satisfiability of monadic first - order formulae can be decided in @xmath122 , where @xmath30 is the length of the formula , and @xmath119 ,  , @xmath120 , @xmath121 are as in theorem  [ th : complexity ] .    as in @xcite , proposition 6.2.9 , the non - deterministic decision procedure first guesses a structure and then verifies that the structure is a model for the given formula .",
    "it was shown , @xcite , proposition 6.2.1 , exercise 6.2.3 , that if a monadic first - order formula has a model , it also has a model , whose domain is the set of all _ predicate colours_. a predicate colour , @xmath123 , is a set of unary literals such that for every predicate @xmath124 from the set of all predicates @xmath125 , either @xmath124 or @xmath126 belongs to @xmath123 .",
    "notice that under the conditions of the lemma , there are at most @xmath127 different predicate colours .",
    "hence , the structure to guess is of @xmath128 size",
    ".    it should be clear that one can evaluate a monadic formula of the size @xmath30 in a structure of the size @xmath129 in deterministic @xmath130 time .",
    "therefore , the overall complexity of the decision procedure is @xmath122 .    for simplicity of presentation",
    ", we assume the formula contains no propositions .",
    "satisfiability of a monodic @xmath0 formula is equivalent to a property of the _ behaviour graph _ for the formula , checkable in time polynomial in the product of the number of different predicate colours and the size of the graph , see  @xcite , theorem 5.15 . for unrestricted @xmath0 formulae ,",
    "the size of the behaviour graph is double exponential in the number of predicates .",
    "we estimate now the size of the behaviour graph and time needed for its construction for formulae .",
    "let @xmath131 be a set of predicate colours and @xmath132 be a map from the set of constants , @xmath133 , to @xmath131 .",
    "a couple @xmath134 is called a _",
    "colour scheme_. nodes of the behaviour graph are colour schemes . clearly , there are no more than @xmath135 different colour schemes .",
    "however , not every colour scheme is a node of the behaviour graph : a colour scheme @xmath136 is a node if , and only if , a monadic formula of first - order ( non - temporal ) logic , constructed from the given formula and the colour scheme itself , is satisfiable ( for details see  @xcite ) .",
    "a similar first - order monadic condition determines which nodes are connected with edges .",
    "it can be seen that the size of the formula is polynomial in both cases . by lemma  [ lemma : fom ] , satisfiability of monadic first - order formulae can be decided in deterministic @xmath137 time .",
    "overall , the behaviour graph , representing all possible models , for an formula can be constructed in @xmath138 time .",
    "in previous work , notably  @xcite a parameterised finite state machine based model , suitable for the specification and verification of protocols over arbitrary numbers of processes was defined .",
    "essentially , this uses a family of identical , and synchronously executing , finite state automata with a rudimentary form of communication : if one automaton makes a transition ( an action ) @xmath139 , then it is required that _ all _ other automata simultaneously make a complementary transition ( reaction ) @xmath140 .",
    "in @xcite we translated this automata model into monodic @xmath0 and used automated theorem proving in that logic to verify parameterised cache coherence protocols  @xcite .",
    "the model assumed not only synchronous behaviour of the communicating automata , but instantaneous broadcast .",
    "here we present a more general model suitable for specification of both synchronous and asynchronous systems ( protocols ) with ( possibly ) delayed broadcast and give its faithful translation into .",
    "this not only exhibits the power of the logic but , with the improved complexity results of the previous section , provides a route towards the practical verification of temporal properties of infinite state systems .",
    "we begin with a description of both the asynchronous model , and the delayed broadcast approach .",
    "[ def : protocol - simple ] a protocol , p is a tuple @xmath141 , where    * @xmath142 is a finite set of states ; * @xmath143 is a set of initial states ; * @xmath144 , where * * @xmath145 is a finite set of local actions ; * * @xmath146 is a finite set of broadcast actions , + i.e. `` send a message '' ; * * @xmath147 is the set of broadcast reactions , i.e. `` receive a message '' ; * @xmath148 is a transition relation that satisfies the following property @xmath149 i.e. , `` readiness to receive a message in any state '' .",
    "further , we define a notion of global machine , which is a set of @xmath30 finite automata , where @xmath30 is a parameter , each following the protocol and able to communicate with others via ( possibly delayed ) broadcast .",
    "to model asynchrony , we introduce a special automaton action , @xmath150 , meaning the automaton is not active and so its state does not change . at any moment",
    "an arbitrary group of automata may be idle and all non - idle automata perform their actions in accordance with the transition function @xmath151 ; different automata may perform different actions .",
    "[ def : glob_mach1 ] given a protocol , @xmath152 , the global machine @xmath153 of dimension _",
    "@xmath30 _ is the tuple @xmath154 , where    * @xmath155 * @xmath156 * @xmath157 is a transition relation that satisfies the following property @xmath158\\ , .",
    "\\end{array}\\ ] ] * @xmath159 is a communication environment , that is a set of possible sets of messages in transition .",
    "an element @xmath160 is said to be a global configuration of the machine .",
    "a run of a global machine @xmath153 is a possibly infinite sequence @xmath161 of global configurations of @xmath153 satisfying the properties ( 1)(6 ) listed below . in this formulation",
    "we assume @xmath162 and @xmath163 .",
    "1 .   @xmath164 + ( `` initially all automata are in initial states '' ) ; 2 .",
    "@xmath165 + ( `` initially there are no messages in transition '' ) ; 3 .   @xmath166 + ( `` an arbitrary part of the automata can fire '' ; 4 .",
    "@xmath167 + ( `` delivery to all participants is guaranteed '' ) ; 5 .",
    "@xmath168 $ ] ( `` one can receive only messages kept by the environment , or sent at the same moment of time '' )    in order to formulate further requirements we introduce the following notation :    @xmath169    @xmath170 @xmath171 then , the last requirement the run should satisfy is    1 .",
    "@xmath172    [ [ example - asynchronous - floodset - protocol . ] ] example : asynchronous floodset protocol .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we illustrate the use of the above model by presenting the specification of an asynchronous floodset protocol in our model .",
    "this is a variant of the _ floodset algorithm with alternative decision rule _ ( in terms of @xcite , p.105 ) designed for solution of the consensus problem .",
    "the setting is as follows .",
    "there are @xmath30 processes , each having an _ input bit _ and an _",
    "output bit_. the processes work asynchronously , run the same algorithm and use _ broadcast _ for communication .",
    "the broadcasted messages are guaranteed to be delivered , though possibly with arbitrary delays .",
    "( the process is described graphically in fig .",
    "[ fig : flood ] . )    , scaledwidth=40.0% ]    the goal of the algorithm is to eventually reach an agreement , i.e. to produce an output bit , which would be the same for all processes .",
    "it is required also that if all processes have the same input bit , that bit should be produced as an output bit .",
    "the asynchronous floodset protocol we consider here is adapted from @xcite .",
    "main differences with original protocol are :    * the original protocol was synchronous , while our variant is asynchronous ; * the original protocol assumed instantaneous message delivery , while we allow arbitrary delays in delivery ; and * although the original protocol was designed to work in the presence of crash ( or fail - stop ) failures , we assume , for simplicity , that there are no failures .    because of the absence of failures the protocol is very simple and unlike the original one does not require `` retransmission '' of any value",
    ". we will show later ( in section  [ sec : var ] ) how to include the case of crash failures in the specification ( and verification ) .",
    "thus , the asynchronous floodset protocol is defined , informally , as follows .",
    "* at the first round of computations , every process broadcasts its input bit .",
    "* at every round the ( tentative ) output bit is set to the minimum value ever seen so far .",
    "the correctness criterion for this protocol is that , eventually , the output bits of all processes will be the same .",
    "now we can specify the asynchronous floodset as a protocol @xmath173 , where @xmath174 ; @xmath175 ; @xmath176 with @xmath177 , @xmath178 , @xmath179 . the transition relation @xmath180 @xmath181 @xmath182 @xmath183 @xmath184 @xmath185 .",
    "given a protocol @xmath186 , we define its translation to as follows .    for each @xmath187 , introduce a monadic predicate symbol @xmath188 and for each @xmath189 introduce a monadic predicate symbol @xmath190 .",
    "for each @xmath191 we introduce also a propositional symbol @xmath192 .    intuitively , elements of the domain in the temporal representation will represent exemplars of finite automata , and the formula @xmath193 is intended to represent `` automaton x is in state @xmath194 '' .",
    "the formula @xmath195 is going to represent `` automaton @xmath41 performs action @xmath196 '' .",
    "proposition @xmath192 will denote the fact `` message @xmath196 is in transition '' ( i.e. it has been sent but not all participants have received it . )    because of intended meaning we define two xor - sets : @xmath197 and @xmath198 .",
    "all other predicates belong to the set of non - xor predicates .",
    "we define the temporal translation of @xmath199 , called @xmath200 , as a conjunction of the formulae in fig .",
    "[ fig : trans ] .",
    "note that , in order to define the temporal translation of requirement ( 6 ) above , ( on the dynamics of environment updates ) we introduce the unary predicate symbol @xmath201 for every @xmath202 .",
    "we now consider the correctness of the temporal translation .",
    "this translation of protocol @xmath203 is faithful in the following sense .",
    "[ prop : trans ] given a protocol , @xmath199 , and a global machine , @xmath153 , of dimension @xmath30 , then any temporal model @xmath204 of @xmath200 with the finite domain @xmath205 of size @xmath30 represents some run @xmath161 of @xmath153 as follows :    @xmath206 is @xmath207-th configuration of the run iff @xmath208 , @xmath209 and @xmath210    dually , for any run of @xmath153 there is a temporal model of @xmath200 with a domain of size @xmath30 representing this run .    by routine inspection of the definitions of runs , temporal models and the translation .",
    "the above model allows various modifications and corresponding version of proposition  [ prop : trans ] still holds .",
    "[ [ determinism . ] ] determinism .",
    "+ + + + + + + + + + + +    the basic model allows non - deterministic actions . to specify the case of deterministic actions only",
    ", one should replace the `` action effects '' axiom in fig .",
    "[ fig : trans ] by the following variant : @xmath211\\ ] ] for all @xmath212    [ [ explicit - bounds - on - delivery . ] ] explicit bounds on delivery .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    in the basic mode , no explicit bounds on delivery time are given .",
    "to introduce bounds one has to replace the `` guarantee of delivery '' axiom with the following one :    @xmath213\\ ] ] for all @xmath214 and some @xmath30 ( representing the maximal delay ) .",
    "[ [ finite - bounds - on - delivery . ] ] finite bounds on delivery . + + + + + + + + + + + + + + + + + + + + + + + + + +    one may replace the `` guarantee of delivery '' axiom with the following one    @xmath215\\ ] ] for all @xmath214 .",
    "[ [ crashes . ] ] crashes .",
    "+ + + + + + + +    one may replace the `` guarantee of delivery '' axiom by an axiom stating that only the messages sent by normal ( non - crashed ) participants will be delivered to all participants .",
    "( see  @xcite for examples of such specifications in a @xmath0 context . )",
    "[ [ guarded - actions . ] ] guarded actions .",
    "+ + + + + + + + + + + + + + + +    one can also extend the model with guarded actions , where action can be performed depending on global conditions in global configurations .    returning to the floodset protocol",
    ", one may consider a variation of the asynchronous protocol suitable for resolving the consensus problem in the presence of _ crash failures_. we can modify the above setting as follows .",
    "now , processes may fail and , from that point onward , such processes send no further messages .",
    "note , however , that the messages sent by a process _ in the moment of failure _ may be delivered to _ an arbitrary subset _ of the non - faulty processes .",
    "the goal of the algorithm also has to be modified , so only _ non - faulty _ processes are required to eventually reach an agreement .",
    "thus , the floodset protocol considered above is modified by adding the following rule :    * at every round ( later than the first ) , a process broadcasts any value _ the first time it sees it_.    now , in order to specify this protocol the variation of the model with crashes should be used .",
    "the above rule can be easily encoded in the model and we leave it as an exercise for the reader .",
    "an interesting point here is that the protocol is actually correct under the assumption that _ only finitely many processes may fail .",
    "_ this assumption is automatically satisfied in our automata model , but not in its temporal translation .",
    "instead , one may use the above _ finite bounds on delivery _ axiom to prove the correctness of this variation of the algorithm .",
    "now we have all the ingredients to perform the verification of parameterised protocols . given a protocol @xmath203 , we can translate it into a temporal formula @xmath200 .",
    "for the temporal representation , @xmath216 of a required correctness condition , we then check whether @xmath217 is valid temporal formula .",
    "if it is valid , then the protocol is correct for all possible values of the parameter ( sizes ) .",
    "correctness conditions can , of course , be described using any legal formula .",
    "for example , for the above floodset protocol(s ) we have a liveness condition to verify :    @xmath218    or , alternatively    @xmath219\\ ] ] in the case of a protocol working in presence of processor crashes .",
    "while space precludes describing many further conditions , we just note that , in  @xcite , we have demonstrated how this approach can be used to verify safety properties , i.e with @xmath220 . since we have the power of , but with decidability results",
    ", we can also automatically verify fairness formulae of the form @xmath221 .",
    "in the propositional case , the incorporation of xor constraints within temporal logics has been shown to be advantageous , not only because of the reduced complexity of the decision procedure ( essentially , polynomial rather than exponential ;  @xcite ) , but also because of the strong fit between the scenarios to be modelled ( for example , finite - state verification ) and the xor logic  @xcite ) .",
    "the xor constraints essentially allow us to select a set of names / propositions that must occur exclusively . in the case of verification for finite state automata",
    ", we typically consider the automaton states , or the input symbols , as being represented by such sets .",
    "modelling a scenario thus becomes a problem of engineering suitable ( combinations of ) xor sets .    in this paper",
    ", we have developed an xor version of @xmath0 , providing : its syntax and semantics ; conditions for decidability ; and detailed complexity of the decision procedure .",
    "as well as being an extension and combination of the work reported in both  @xcite and  @xcite , this work forms the basis for tractable temporal reasoning over infinite state problems . in order to motivate this further",
    ", we considered a general model concerning the verification of infinite numbers of identical processes .",
    "we provide an extension of the work in  @xcite and  @xcite , tackling liveness properties of infinite - state systems , verification of asynchronous infinite - state systems , and varieties of communication within infinite - state systems .",
    "in particular , we are able to capture some of the more complex aspects of _ asynchrony _ and _ communication _ , together with the verification of more sophisticated _ liveness",
    "_ and _ fairness _ properties .",
    "the work in  @xcite on basic temporal specification such as the above have indeed shown that deductive verification can here be attempted but is expensive  the incorporation of xor provides significant improvements in complexity .",
    "the properties of first - order temporal logics have been studied , for example , in  @xcite .",
    "proof methods for the monodic fragment of first order - temporal logics , based on resolution or tableaux have been proposed in  @xcite .",
    "model checking for parameterised and infinite state - systems is considered in  @xcite .",
    "formulae are translated into to a bchi transducer with regular accepting states .",
    "techniques from regular model checking are then used to search for models .",
    "this approach has been applied to several algorithms verifying safety properties and some liveness properties .",
    "* have theoretically non - primitive recursive upper bounds for decision procedures ( although they work well for small , interesting , examples )  in our case the upper bounds are definitely primitive - recursive ; * are not suitable ( or , have not been used ) for asynchronous systems with delayed broadcast  it is not clear how to adapt these methods for such systems ; and * typically lead to undecidable problems if applied to liveness properties .",
    "future work involves exploring further the framework described in this paper in particular the development of an implementation to prove properties of protocols in practice .",
    "further , we would like to see if we can extend the range of systems we can tackle beyond the monodic fragment .",
    "we also note that some of the variations we might desire to include in section  [ sec : var ] can lead to undecidable fragments .",
    "however , for some of these variations , we have correct although ( inevitably ) incomplete methods , see  @xcite .",
    "we wish to explore these boundaries further .",
    "10 p. a. abdulla , b. jonsson , m. nilsson , j. dorso , and m. saksena . .",
    "in _ proc .",
    "16th international conference on computer aided verification ( cav ) _ , volume 3114 of _ lncs _ , pages 348360 .",
    "springer , 2004 .",
    "a. artale , e. franconi , f. wolter , and m. zakharyaschev . a temporal description logic for reasoning over conceptual schemas and queries . in _ proc .",
    "european conference on logics in artificial intelligence ( jelia ) _ , volume 2424 of _ lncs _ , pages 98110 .",
    "springer , 2002 .",
    "j. brotherston , a. degtyarev , m. fisher , and a. lisitsa . .",
    "in _ proc . international conference on logic for programming , artificial intelligence , and reasoning ( lpar )",
    "_ , volume 2514 of _ lncs _ , pages 86101 .",
    "springer verlag , 2002 .",
    "d. gabelaia , r. kontchakov , a. kurucz , f. wolter , and m. zakharyaschev . on the computational complexity of spatio - temporal logics . in _ proc .",
    "16th international florida artificial intelligence research society conference ( flairs ) _ , pages 460464 . aaai press , 2003 .",
    "i. hodkinson , r. kontchakov , a. kurucz , f. wolter , and m. zakharyaschev . on the computational complexity of decidable fragments of first - order linear temporal logics . in _ proc .",
    "international symposium on temporal representation and reasoning ( time ) _ , pages 9198 .",
    "ieee cs press , 2003 ."
  ],
  "abstract_text": [
    "<S> in this paper we consider the specification and verification of infinite - state systems using temporal logic . </S>",
    "<S> in particular , we describe parameterised systems using a new variety of first - order temporal logic that is both powerful enough for this form of specification and tractable enough for practical deductive verification . </S>",
    "<S> importantly , the power of the temporal language allows us to describe ( and verify ) asynchronous systems , communication delays and more complex properties such as liveness and fairness properties . </S>",
    "<S> these aspects appear difficult for many other approaches to infinite - state verification . </S>"
  ]
}