{
  "article_text": [
    "_ instant messaging _",
    "( _ i m _ ) applications are very popular among smartphone users because of the level of convenience they provide in interpersonal communications .",
    "quite sophisticated i m applications are available today for the prominent smartphone platforms ( e.g. , android , ios , and windows phone , to name a few ) that allow users to exchange text and files in ( pseudo ) real time .",
    "in addition to legitimate uses , however , i m applications are increasingly being used to carry out illicit activities  @xcite .",
    "therefore , the forensic analysis of these applications has received considerable attention in the recent past .",
    "im - based evidence may indeed prove crucial in all those cases where an i m application has been used by the parties involved in a crime , i.e.  by a perpetrator to interact with its victims , or by criminals in the attempt to escape interception when they communicate .",
    "generally speaking , the forensic analysis of an i m application is based on the availability of various types of artifacts ( metadata and content of exchanged messages and files , log files , etc . )",
    "stored by that application on the local storage of smartphones . by locating , extracting , and analyzing such artifacts ,",
    "quite often it is possible to recover a significant amount of potential evidence  @xcite .",
    "this situation , however , is rapidly changing .",
    "the increasing awareness of the fact that i m communications may be intercepted when transiting over the infrastructure of the service provider , is stimulating the interest towards _ secure _ i m applications  @xcite .",
    "these application , unlike standard ones , provide suitable privacy - preserving and user security mechanisms , such as strong encryption for transmitted and locally - stored data , secure user authentication , plausible deniability , forward secrecy , and so on .",
    "secure i m applications pose new challenges to the forensic analyst , that has to deal with the issues posed by the privacy - preserving features of these applications .    among these applications ,",
    "one that is receiving increasing attention is _ chatsecure _",
    "@xcite , which is available both for android and ios .",
    "there are various reasons for its success : ( a ) it is open - source ( so it is possible to audit its code ) , ( b ) it provides message encryption , partner authentication , deniability and perfect forward secrecy thanks to the use of the _ off - the - record ( otr )",
    "_  @xcite messaging system ( which has gained an excellent reputation in the privacy - concerned user communities ) , ( c ) it encrypts locally stored data with _ sqlcipher _",
    "@xcite and _ iocipher _  @xcite , and ( d ) it has been ranked as one of the most secure i m applications by the _",
    "electronic frontiers foundation ( eff ) _  @xcite .    given these characteristics ,",
    "the interest on the forensic analysis of chatsecure is evident , since there is no publicly known way of decrypting otr - encrypted data once they are in transit over the network .",
    "thus , forensic analysis of the devices used to communicate with chatsecure may be the only option available to retrieve im - based evidence .    to the best of our knowledge , there is no published work addressing the forensic analysis of chatsecure on the android platform . in this paper",
    "we fill this gap by describing which artifacts chatsecure are stored in the local memory of the device , and how they can be decoded and correlated among them to infer information of potential investigative interest .",
    "the original contributions of this paper can be summarized as follows :    * we show that chatsecure stores locally copies of all the messages and files that are exchanged between the user and her contacts into two encrypted _ sqlite v.3 _",
    "@xcite databases ;",
    "* we analyze the encryption procedure used for these databases , and we develop and implement an algorithm able to decrypt them using the secret passphrase set by the user ; * we show how the passphrase can be retrieved from the volatile memory of an android device ; * we discuss the decoding and the interpretation of all the artifacts generated by chatsecure , and we show how they can be correlated to perform various forensic reconstructions , such as the chronology and contents of exchanged files and messages , the set of i m accounts used by the chatsecure user , as well as the list of contacts associated with each one of them ; * we show that it is not possible to recover the information deleted by chatsecure users because of the use of secure deletion techniques in sqlcipher and iocipher ; * we devise and use an experimental methodology , based on the use of emulated devices , that provides a very high degree of reproducibility of the results , and we validate the results it yields against those obtained from real smartphones .    the rest of the paper is organized as follows . in sec .  [",
    "related ] we review existing work , while in sec .  [ methodology ] we describe the methodology and the tools we use in our study .",
    "then , in sec .  [ chatsecure ] we discuss the forensic analysis of chatsecure and , in sec .",
    "[ conclusions ] , we conclude the paper .",
    "smartphone forensics has been widely studied in the recent literature , which mostly focuses on android and ios forensics  @xcite , given the pervasiveness of these platforms . as a result ,",
    "well known and widely accepted methodologies and techniques are available today that are able to properly deal with the extraction and analysis of evidence from smartphones . in this paper",
    "we leverage this vast body of work for extracting and analyzing the data generated by chatsecure during its usage .",
    "the importance of the forensic analysis of smartphone i m applications has been also acknowledged in the literature , where a significant number of papers on this topic has been published .",
    "@xcite discusses the forensic analysis of whatsapp messenger .",
    "@xcite focuses on the forensic analysis of three i m applications ( namely aim , yahoo !",
    "messenger , and google talk ) on the ios platform .",
    "@xcite presents the analysis of several i m applications on various smartphone platforms , aimed at identifying the encryption algorithms used by them .",
    "@xcite discusses the analysis of itunes backups for ios devices aimed at identifying the artifacts left by various social network applications .",
    "@xcite discusses the analysis of the data transmitted or stored locally by 20 popular android i m applications .",
    "none of these papers , however , covers the forensic analysis of chatsecure on android platforms , which is instead the focus of this paper .",
    "the closest work to ours is @xcite , that is focused on the ios platform .",
    "however , the results discussed there do not apply to android , given the significant differences existing between the android version and the ios version of chatsecure .",
    "the study described in this paper has been performed by carrying out a set of controlled experiments , each one referring to a specific usage scenario ( one - to - one communication , group communication , file exchange , etc . ) , during which typical user interactions have taken place . after each experiment ,",
    "the internal memory of the sending and receiving devices has been examined in order to identify , decode , and analyze the data generated by chatsecure in that experiment . in all the experiments , we run chatsecure v.  14.2.3 ( the last one available on google play at the moment of this writing ) .    the data generated by chatsecure are stored into an area of the internal device memory that is normally inaccessible to users ( see sec .",
    "[ artifacts ] ) . therefore",
    ", suitable methodologies and tools need to be adopted in order to access and acquire this area .",
    "tools like ufed  @xcite , xry  @xcite , and oxygen forensics detective  @xcite , among others , are able to perform this acquisition in a forensically - sound manner .",
    "however , this approach presents some limitations , namely :    * * limited generality * : to gain confidence into the generality of the results , a suitably large number of devices and android versions should be used for the experiments .",
    "the resulting high costs both in terms of purchase and of the time required to replicate the experiments on a large set of devices , however , practically limits the number of devices used for the experiments , thus potentially casting doubts on the generality of the results ; * * limited replicability * : a third party wanting to reproduce the results needs to use the same set of devices , operating systems versions , and forensic acquisition tools to repeat experiments this , however , may be problematic , both because of device availability and of the cost of the acquisition tools ; * * limited controllability * : smartphones are complex devices , running a multitude of applications and services , whose behavior and interactions are hard to characterize . as a consequence , it may be difficult not only to reproduce the exact conditions holding at the moment of each experiment , but also to exclude with certainty possible data cross - contaminations among different applications that use the same file system ( as in android ) .    to overcome the above limitations , in this work we carry out experiments using emulated mobile devices instead of physical ones .",
    "in particular , we use the _ android mobile device emulator _  @xcite to create various _ android virtual devices _ ( avds ) , that are emulated smartphones behaving exactly like real physical devices that can be customized with different hardware characteristics and android versions .",
    "the status of avds can be monitored by means of the _ android device monitor _",
    "@xcite ( adm ) .",
    "the use of emulated devices provides many advantages , and allows us to overcome the limitations discussed above .",
    "first , generality of results is benefited since it is simple and cost - effective to run experiments on a variety of different avds ( featuring different hardware and software combinations ) , and to quickly extract the contents of their internal memory .",
    "second , also replicability is greatly benefited , since a third - party can configure avds exactly as we did , thus reproducing the same conditions of our experiments . finally , also controllability is enhanced : the configuration of avds ( that include both hardware / software features , as well as a set of services and apps running in the background ) is under total control of the experimenter by means of the adm , thus allowing us ( as well as a third - party replicating our experiments ) to precisely determine the operational conditions holding on each avd at the moment of the experiment .    for our experiments",
    ", we use the three avds configurations shown in table  [ tab : avd ] below , that are characterized by different android versions , processor families , and volatile and persistent storage sizes .",
    "_ processor _ & _ ram _ ( mb ) & _ internal storage ( mb ) _ & _ android version _ + arm ( armeabi - v7a ) & 512 & 2047 & 4.4 ( api 19 ) + intel atom ( x86 ) & 1536 & 1024 & 5.1 ( api 22 ) + intel atom ( x86_64 ) & 1536 & 1024 & 6.0 ( api 23 ) +    to carry out our analysis , we run all the experiments on these avds and , at the end of each experiment , we extract the data generated by chatsecure using the _ pull _ functionality of the _ file explorer _ of the adm , that allows one to recursively extract entire folders , or individual files .",
    "alternatively , this task can be carried out using the _ android debug bridge _",
    "@xcite ( adb ) to pull data out from the avd using a command - line interface .",
    "in order to validate the results obtained with avds , we compare them against results obtained running experiments on a real device .",
    "more precisely , we run experiments on a samsung sm - g350 galaxy core plus smartphone running android 4.4.2 , and we use the _ cellebrite ufed4pc _ platform  @xcite to perform device memory extraction , and the ufed _ physical analyzer _  @xcite to decode its contents . in all the experiments we performed ,",
    "the results collected from this smartphone were identical to those obtained from the emulated devices we considered .",
    "in addition to the analysis of the persistent device memory , we also examine its volatile memory to verify whether encryption keys or secret passwords are stored there , and to identify and extract them . in particular , as discussed in sec .",
    "[ encryption ] , we use  @xcite to dump the contents of the volatile memory of the avds used in the experiments , and  @xcite to analyze these dumps .",
    "we perform memory analysis experiments only for the arm architecture ( row 1 of table  [ tab : avd ] ) since , at the moment of this writing , supports this architecture only .",
    "note that in order to work , requires the device to be rooted .",
    "for avds , however , this is not an issue , since they are pre - configured to allow root access to the user .",
    "we do not validate the memory analysis results against real devices , since requires an android kernel supporting dynamic module loading . to enable this functionality ,",
    "the kernel source must be reconfigured and recompiled . for a real smartphone ,",
    "the stock android kernel is not sufficient , as vendors typically customize it to suit the specific hardware configuration of the device .",
    "unfortunately , the kernel source for the samsung sm - g350 galaxy core plus smartphone we used for validation was not available to us , so we could not configure such a device to work with .",
    "finally , the source code of chatsecure ( which is freely available from @xcite ) has been examined to verify our hypothesis about its behavior , or to understand how to decode the data it generates .    for the sake of reproducibility of the experiments we discuss in this paper , in @xcite",
    "we describe how to concretely configure and use the various tools that we rely upon to create and run an avd , and to carry out the analysis of its persistent and volatile memory .",
    "chatsecure is an i m application that allows its users to communicate securely via their existing accounts on i m providers that use the xmpp  @xcite protocol ( e.g.  _ google talk _ or _ jabber _ ) .    to ensure privacy ,",
    "chatsecure provides end - to - end message encryption with otr and encrypts with _ sqlcipher _   and _ iocipher _  ) ] the sqlite databases it uses to store the information it generates .",
    "furthermore , it can provide user untraceability by means of the tor network  @xcite via the _ orbot _ application  @xcite .",
    "a chatsecure user may define several i m accounts ( corresponding to one or more i m providers ) , and use them at the same time to communicate with a set of _ buddies _",
    "( i.e. , other i m accounts ( s)he is in contact with ) .",
    "chatsecure provides the typical functionalities of all i m applications , namely : ( a ) contact management ( i.e. , inviting and removing contacts , accepting or denying invitations , etc . ) , ( b ) point - to - point communication , ( c ) group chats creation and participation , and ( d ) file transfer , as well as additional functionalities related to security management ( toggling otr encryption on and off , verification of the partner identity , etc . ) .    in this section",
    "we provide a detailed forensic analysis of chatsecure that is aimed at identifying all the relevant artifacts it generates , interpreting them , and using them to reconstruct the activities carried out by its users .    in particular , after describing a fictitious scenario to give an investigative context to the analysis techniques described in this paper , we describe the set of artifacts generated by chatsecure , and where they are stored on the memory of the device ( sec .",
    "[ artifacts ] ) .",
    "next , we illustrate how to reconstruct the set of chatsecure accounts utilized by the user ( sec",
    ".  [ accounts ] ) , as well as the set of the corresponding buddies ( sec .",
    "[ contacts ] ) .",
    "then , we move to the reconstruction of the chronology and contents of exchanged messages ( sec .",
    "[ chat - reconstruction ] ) and files ( sec .",
    "[ media ] ) .",
    "after that , we deal with the problem of decrypting the sqlite databases where chatsecure artifacts are stored ( sec .",
    "[ encryption ] ) by describing both a decryption algorithm we devised , and how the passphrase allowing decryption can be retrieved from the volatile memory of the device .",
    "finally , we conclude with sec .  [",
    "sec : deletion ] , where we report our findings concerning the deletion of the data generated by chatsecure , that show the impossibility of recovering them after they have been deleted .      to illustrate how the techniques discussed in this paper can be applied in the context of a digital investigation",
    ", we consider the fictitious investigative scenario reported below .",
    "we consider the case where chatsecure is found to be installed on a seized android smartphone , and we need to answer the following set of typical investigative questions ( for each one of them , we also indicate the section of the paper where we discuss how to obtain the corresponding answer ) :    1 .   how many distinct xmpp accounts did the user configure and use with chatsecure ?",
    "( sec .  [ accounts ] ) 2 .   who are the chatsecure contacts of the local user ?",
    "( sec .  [ contacts ] ) 3 .",
    "what messages have been exchanged with each one of the above contacts , and when did each communication occur ? ( sec .  [ chat - reconstruction ] ) 4 .   did the local user exchange",
    "any file with its contacts ?",
    "if so , when did these exchanges occur ? what is the content of the files that have been exchanged ?",
    "( sec .  [ media ] ) 5 .   how to decrypt chatsecure databases ?",
    "( sec .  [ encryption ] ) 6 .",
    "how to recover deleted data ? ( sec .  [ sec : deletion ] ) .      during its use , chatsecure stores several artifacts into various files and databases that are located into the _",
    "this folder is located into the _ /data",
    "/ data _ directory of the android file system ,   that contains the sub - folders shown in fig .",
    "[ folders ] .",
    "the data of forensic interest generated by chatsecure are the following ones :    * the _ main database _ , where chatsecure stores the information concerning the accounts used by the chatsecure , the list of the corresponding buddies , and local copies of the messages that have been exchanged .",
    "it consists in an sqlcipher - encrypted sqlite v.3 database , named _",
    "impsenc.db_ , which is stored in the _ databases _ folder and contains 21 different tables . as resulting from our findings ,",
    "only 11 out of these 21 tables contain information of forensic interest , namely tables _",
    "accounts _ , _ accountstatus _ , _ providers _ , _ providersettings _ , _ contacts _ , _ contactlist _ , _ presence _ , _ avatars _ , _ chats _ , _ messages _ , and _",
    "inmemorymessages_. the information stored in these tables , as well their structure , interpretation , and analysis , are discussed in secs .",
    "[ accounts][chat - reconstruction ] , where we show how to use the data they store to perform various forensic reconstructions .",
    "the analysis of these tables has been performed by inspecting the source code of chatsecure ,   and by performing a set of controlled experiments in order to validate our findings .",
    "it is worth pointing out that the user may opt for not using encryption ; this decision must be taken when chatsecure is started for the first time after installation , and can not be undone ( in this case the database is named _",
    "imps.db_ ) .",
    "* the _ encrypted virtual disk _ : in addition to exchanged messages , chatsecure stores locally also copies of the files that its user has exchanged with her contacts .",
    "to prevent unauthorized parties from accessing these files , chatsecure stores them into an encrypted virtual disk , which is implemented via iocipher .",
    "the analysis of this encrypted virtual disk is discussed in sec .",
    "[ media ] . *",
    "the _ stored secret file _ : chatsecure stores the information it needs to decrypt the main database and the virtual disk into a file , named _ info.guardianproject.cacheword.prefs.xml_ , which is located in folder _",
    "shared_prefs_. in sec .",
    "[ encryption ] we show how this information can be decoded and used to carry out the above decryption .    for the sake of completeness , we mention also files _ account.xml _",
    "( storing the information concerning the chatsecure account ) and _ info.guardianproject.otr.app.im_preferences.xml _ ( storing chatsecure settings and preferences ) , located in the _ shared_prefs _ folder .      as mentioned before , chatsecure allows its users to create various i m accounts , each one corresponding to a specific i m provider . from the investigative point of view",
    ", the information about all the active accounts is relevant for various reasons , including determining the identity of the providers to which additional sources of evidence ( e.g. , log files ) can be asked , and correlating evidence with that retrieved from the devices of other chatsecure users with whom the user has exchanged communications .    the information associated with each account ( name , credentials , etc .",
    ") are stored in the main database , where they are spread across four distinct tables ( namely , _ accounts _ , _ accountstatus _ , _ providers _ , and _ providersettings _ ) .",
    "the structure of these tables and the meaning of their fields are reported in tables  [ tab : accounts][tab : providersettings ] .",
    "tables _ accounts _ and _ accountstatus _ jointly store the information concerning the i m accounts created by the chatsecure user .",
    "in particular , _ accounts _ stores the properties of these accounts ( e.g. , the credentials for the authentication ) , while _ accountstatus _ stores the information concerning their _ status_. these two tables are linked together by means of the foreign key of table _ accountstatus _",
    "( i.e. , field _ account _ , see table  [ tab : accountstatus ] ) .",
    "_ name _ & _ role _ & _ type _ & _ meaning _",
    "+ _ i d & primary key & int & unique record identifier + name &  & text & name of the account as chosen by the user + provider & foreign key & int & value of the _ _",
    "i d _ field of the record , in table _ providers _ , corresponding to the provider of this i m account + username &  & text & username ( on the service provider ) for the account + pw &  & text & password ( on the service provider ) for the account + active &  & int & @xmath0 if the account is active , @xmath1 otherwise + locked &  & int & @xmath0 if the account is locked ( i.e. , it is not editable ) , @xmath1 otherwise + keep_signed_in &  & int & @xmath0 if chatsecure keeps the account logged in between executions , @xmath1 otherwise + last_login_state &  & int & either @xmath1 or @xmath0 +     _ name _ & _ role _ & _ type _ & _ meaning _ + _ i d & primary key & int & unique record identifier + account & foreign key & int & value of the _ _",
    "i d _ field of the record , in the _ accounts _ table , corresponding to the account this status information refers to + presencestatus &  & int & visibility of the account to its buddies .",
    "possible values are : @xmath1 ( offline ) , @xmath0 ( invisible ) , @xmath2 ( away ) , @xmath3 ( idle ) , @xmath4 ( do not disturb ) , and @xmath5 ( available ) + connstatus &  & int & status of the connection to the xmpp provider .",
    "possible values are : @xmath1 ( offline ) , @xmath0 ( connecting ) , @xmath2 ( suspended due to temporary network unavailability ) , and @xmath3 ( online ) +    tables _ providers _ and _ providersettings _ , instead , jointly store the information about the i m providers corresponding to the above i m accounts .",
    "in particular , the former table stores the information about these providers , while the latter one stores the settings of each provider ( one record per setting ) .",
    "these two tables are joined together by means of the foreign key of table _ providersettings _",
    "( i.e. , field _ provider _ , see table  [ tab : providersettings ] ) .     _ name _ & _ role _ & _ type _ & _ meaning _ + _ i d & primary key & int & unique record identifier + name &  & text & name of the i m provider ( e.g.  gtalk , aim , etc . ) + fullname &  & text & full name of the i m provider +     _ name _ & _ role _ & _ type _ & _ meaning _ + _ i d & primary key & int & unique record identifier + provider & foreign key & int & value of the _ _",
    "i d _ field of the record , in the _ providers _ table , corresponding to the i m provider this setting refers to + name &  & text & name of the setting + value &  & text & value of the setting +    to illustrate how to reconstruct the information concerning the chatsecure accounts , let us consider the scenario shown in fig .",
    "[ account - tables ] .",
    "this scenario features two distinct chatsecure accounts , named _",
    "chat.secure.user _ and _ test1chatsecure _ ( see the records stored in table _ accounts _ in fig .  [ account - tables ] ) . both these accounts are _ active _",
    "( i.e. , they are currently used ) , as indicated by the value @xmath0 stored in fields _ active _ , and are never logged out of the respective i m provider during a chatsecure session , as indicated by the value @xmath0 stored in fields _ keep_signed_in_.    to determine the i m provider associated with each account we need to join tables _",
    "accounts _ and _ providers_. the results of this operation show that user _ chat.secure.user _ is associated with i m provider no .  1 and that authenticates with it using username _ cs.test.user _ and password `` _ _ x - google - token  _ _ '' ( password shortened for readability purposes ) , while user _",
    "test1chatsecure _ is associated with i m provider no .  2 and authenticates with it using username _ test1chatsecure _ and password `` _ _ # t&st.p@sswd !",
    "note that the passwords used to authenticate with i m providers are stored in cleartext , and as such may be readily used to authenticate with the i m providers _ outside the chatsecure application _ once recovered from this database .    to determine the identity of the i m providers used by the various accounts we need to join tables _",
    "providers _ and _ providersettings_. the results of this operation indicate that provider no .",
    "1 corresponds to google s _ gtalk _ i m service ( see record no .  28 of table _ providersettings _ in fig .  [ account - tables ] ) , and that its account domain is _ gmail.com _",
    "( see record no .  29 of table _ providersettings _ ) . from this , we determine that the chatsecure user _ chat.secure.user _ corresponds to the gtalk user _",
    "cs.test.user@gmail.com_. furthermore , we also determine that provider no .  2 corresponds to the _ chatme _ i m service ( it uses the _ chatme.im _",
    "server ) , and that its account domain is _",
    "chatme.im_ , meaning that chatsecure user _ test1chatsecure _ corresponds to chatme user _",
    "test1chatsecure@chatme.im_.    finally , to determine the status of each account we need to join tables _ accounts _ and _ accountstatus_. from the results of this operation we determine that both users _ chat.secure.user _ and _ test1chatsecure _ are offline because of the unavailability of the network when the memory of the device was acquired ( see the values stored in fields _ presencestatus _ and _ connstatus _ in the records of table _ accountstatus _ ) .",
    "each chatsecure account is typically associated with a set of contacts , i.e. remote users with whom ( s)he can exchange messages and files .",
    "the evidentiary value of contact information is notorious , as it allows an investigator to determine who the user was in contact with .",
    "each one of the contacts is associated with its _ nickname _",
    "( i.e. , the name used by the chatsecure user to denote the buddy ) , its _ username _ ( that identifies the contact on the corresponding i m provider ) , and an optional _ avatar _ ( i.e. , a picture , chosen by the corresponding user , which is downloaded by chatsecure and displayed together with the nickname ) .    the information concerning user contacts is stored in the main database , and is spread across four distinct tables , namely _ contacts _ , _ avatars _ , _ presence _ , and _ contactslist _ , whose structure and meaning is reported in tables  [ tab : contacts][tab : contactlist ] .",
    "_ name _ & _ role _ & _ type _ & _ meaning _",
    "+ _ i d & primary key & int & unique identifier of the contact + username & secondary key & text & username of this contact on the corresponding i m provider + nickname &  & text & name displayed by chatsecure for this contact + provider & foreign key & int & value of field _ _",
    "i d _ of the record , in table _ providers _",
    ", this contact is an account of + account & foreign key & int & value of field _ _",
    "i d _ of the record , in table _ accounts _ , corresponding to the local chatsecure account this contact belongs to + contactlist & foreign key & int & value of field _ _",
    "i d _ of the record , in table _ contactlist _ , corresponding to the contact list this contact belongs to + type &  & int & contact type : @xmath1 ( normal ) , @xmath0 ( temporary , not in contacts but subscribed to receive updates ) , @xmath2 ( temporary group chat contact ) , @xmath3 ( blocked ) , @xmath4 ( hidden ) , @xmath5 ( pinned ) + subscriptionstatus &  & int & status update receipt from this contact : @xmath1 ( none ) , @xmath0 ( requested to subscribe ) , @xmath2 ( requested to unsubscribe ) + subscriptiontype &  & int & exchange of status updates with this contact : @xmath1 ( no interest in update ) , @xmath0 ( stop receiving updates ) , @xmath2 ( receive updates ) , @xmath3 ( contact wants updates from the user ) , @xmath4 ( mutual interest in receiving updates ) , @xmath5 ( pending invitations ) + otr &  & int & status of the otr encryption ; possible values are : @xmath1 ( off ) , @xmath0 ( on , do nt know who turned it on ) , @xmath2 ( on , enabled by the user ) , @xmath3 ( on , enabled by the contact ) +     _ name _ & _ role _ & _ type _ & _ meaning _ + _ i d & primary key & int & unique identifier of the record +    contact_id & foreign key & int & value of field _ _",
    "i d _ of the record , in table _ contacts _ table , corresponding to the contact this presence information refers to + client_type &  & int & type of the client ; possible values are : @xmath1 ( default ) , @xmath0 ( mobile ) , @xmath2 ( android ) + mode &  & int & presence status of the contact ; possible values are : @xmath1 ( offline ) , @xmath0 ( invisible ) , @xmath2 ( away ) , @xmath3 ( idle ) , @xmath4 ( do not disturb ) , and @xmath5 ( available ) + status &  & text & status message of the contact +     _ name _ & _ role _ & _ type _ & _ meaning _ + _ i d & primary key & int & unique avatar identifier + contact & foreign key & text & value of field _",
    "username _ of the record , in table _ contacts _ , this avatar belongs to + provider & foreign key & int & value of field _ _",
    "i d _ of the record , in table _ providers _ , corresponding to the provider this contact is user of + account & foreign key & int & value of field _ _",
    "i d _ of the record , in table _ accounts _ , corresponding to the account the contact owning this avatar is buddy of + hash &  & text & sha-1 hash of the picture used as avatar by this contact + data &  & blob & raw image data of the avatar +     _ name _ & _ role _ & _ type _ & _ meaning _ + _ i d & primary key & int & unique identifier of the record + name &  & text & display name of this contact list + account & foreign key & int & value of field _ _",
    "i d _ of the record , in table _ accounts _ , corresponding to the chatsecure account this list belongs to + provider & foreign key & int & value of field _ _",
    "i d _ of the record , in table _ providers table _ , corresponding to the provider of the chatsecure account this contact list belongs to +    in particular :    * tables _ contacts _ and _ presence _ store the information about the various contacts and on the corresponding status , respectively , and are linked together via the foreign key of table _ presence _",
    "( i.e. , field _ contact_id _ , see table  [ tab : presence ] ) ; * table _ avatars _ stores the information about the avatars of the various contacts and , as reported in table  [ tab : avatars ] , it is linked to various tables , namely _ contacts _ , _ providers _ , and _ accounts _ , via the corresponding foreign keys ; * table _ contactlist _ stores the information about how the contacts of the chatsecure users are organized into lists , and is linked to both tables _ accounts _ and _ provider _ ( to associate the list with the specific chatsecure user the list belongs to ) via the corresponding foreign keys ( see table  [ tab : contactlist ] ) .    to illustrate how to reconstruct the information about the contacts of a chatsecure user , let us consider the scenario shown in fig .  [ contact - tables ] , where 9 distinct contacts belonging to the two chatsecure accounts shown in fig .  [ account - tables ]",
    "( namely , _",
    "chat.secure.user _ and _ test1chatsecure _ ) are stored in table _",
    "contacts_.        from records no .",
    "@xmath6 and @xmath7 , we see that six contacts are associated with user account no .  1 ( _ chat.secure.user _ ) and provider no .  1 ( _ google gtalk _ ) , while the remaining three contacts ( corresponding to records no .",
    "@xmath8 , and @xmath9 ) are associated with user account no .  2 ( _ test1chatsecure _ ) and provider no .  2 ( _ chatme _ ) .",
    "furthermore , we also see that all these contacts are of the `` normal '' type ( field _ _ type__=@xmath1 ) , with the exception of contact no .  9 ( _ _ nickname__=`__grptest1 _ _ ' ) that is a temporary contact created purposely to denote a group chat ( _ _ type__=@xmath2 , see table  [ tab : contacts ] ) corresponding to the remote i m account _",
    "grptest1@conference.chatme.im_.    avatar pictures may have evidentiary value as well : they can be indeed used to link a chatsecure contact to the real identity of the person using it ( for instance , if the avatar displays the face of the user , or any location or item that can be uniquely associated with that person ) .    to determine the avatars associated with each contact",
    ", we join tables _",
    "contacts _ and _ avatars_. the results of this operation indicate that only contact no .  8 ( user _ test2chatsecure@chatme.im_ ) is associated with an avatar , whose picture is stored ( as a `` blob '' of bytes ) in field _",
    "data _ ; the avatar can be extracted from this field , and visualized using a standard image viewer .",
    "also the status information of a contact may have evidentiary value .",
    "for instance , the textual status message may provide information about the real identity of the contact , and also its presence status at the moment of the last update may provide information about the behaviour of that contact .    to determine the status of each contact , as reported by the last time this information was updated locally , we have to join tables _ contacts _ and _ presence_. from the results of this operation , we see that ( a ) group chat contacts ( i.e. , contact no .",
    "@xmath7 in our example scenario ) have no associated status , ( b ) the status all the other contacts is `` _ _ offline _ _ '' ( the value @xmath1 is stored in the corresponding _ mode _ field ) , with the exception of contact _test2chatsecure@chatme.im_ ( contact no .",
    "@xmath9 ) , whose status is instead `` _ _ available _ _ '' ( _ mode _ field contains @xmath5 ) . we also observe that none of these contacts is associated to a textual status message ( fields _ status _ are empty ) .    finally , also contact lists may be important from the evidentiary point of view , as they allow to link each contact to the corresponding chatsecure account used by the local user .",
    "to reconstruct the contact lists , we have to join tables _ contacts _ and _ contactlist_. from the results of this operation , we see that these contacts are organized in two distinct lists : the first one includes contacts no .",
    "@xmath6 and @xmath7 , and belongs to the chatsecure account no .  1 , while the second one includes the remaining contacts , and belongs to account no .  2 .",
    "in both cases , the name of the list is _",
    "contacts_.      reconstructing the time in which each message was sent or received ,",
    "the content of that message , and the communication partner , is of obvious investigative importance .",
    "each time a message is sent or received , chatsecure stores in the main database a record containing both its textual content and various metadata ( e.g. , the identifier of the corresponding buddy , and the date and time when the exchange occurred ) .",
    "this information is spread across two distinct tables of the main database , namely _",
    "messages _ and _ inmemorymessages _ , that have the same structure ,   that is described in table  [ tab : messages ] together with the interpretation of its fields .",
    "the reason for which two distinct tables are used is unclear ; however , the messages they contain do not overlap , so both of them needs to be analyzed to recover all the messages that have been exchanged .",
    "_ name _ & _ type _ & _ meaning _",
    "+ _ i d & int & unique identifier of the message + thread_id & int & identifier of the contact this message has been exchanged with + nickname & text & used for group chat messages only to indicate the nickname chosen by the local chatsecure user in that group chat ( empty for one - to - one messages ) + body & text & body of the message + date & int & the date this message has been sent or received ( 13-digits unix epoch format ) + type & int & type of the message : @xmath1 ( outgoing ) , @xmath0 ( incoming ) , @xmath2 ( presence became `` available '' ) , @xmath3 ( presence became `` away '' ) , @xmath4 ( presence became `` busy '' ) , @xmath5 ( presence became `` unavailable '' ) , @xmath10 ( message converted to a group chat ) , @xmath11 ( status message ) , @xmath9 ( message can not be sent now , will be sent later ) , @xmath7 ( otr is turned off ) , @xmath12 ( otr is turned on ) , @xmath13 ( otr turned on by the user ) , @xmath14 ( otr turned on by the communicating partner ) , @xmath15 ( incoming encrypted ) , @xmath16 ( incoming encrypted and verified ) , @xmath17 ( outgoing encrypted ) , @xmath18 ( outgoing encrypted and verified ) + err_code & int & error code ( @xmath1 = no error ) + err_msg & text & error message ( if any ) + is_muc & int & flag indicating whether it is a group chat message ( @xmath0 ) or not ( @xmath1 ) + is_delivered & int & flag indicating whether a `` delivered '' confirmation was received ( @xmath0 ) or not ( @xmath1 ) + mime_type & text & type of data exchanged ( null for text message , non - null for transferred files ( see sec .  [ media ] ) +    from the analysis of the meaning of the various fields ( and , in particular , of the possible values of field _ type _ ) , we see that chatsecure messages belong to two distinct categories , namely :    * _ notification messages _ , i.e.  messages that do not carry any user - generated content , but that instead carry updates about the status contact , such as changes of his / her status ( message types @xmath19 and @xmath5 ) , or of his / her otr encryption status ( message types @xmath20 and @xmath14 ) . * _ chat messages _ , that carry user - generated textual content .",
    "these messages correspond to records whose _ type _ fields stores values in the set @xmath21 ( see table  [ tab : messages ] ) to denote cleartext outgoing ( _ _ type__=@xmath1 ) or incoming ( _ _ type__=@xmath0 ) messages , encrypted incoming message sent by an unverified ( _ _ type__=@xmath15 ) or a verified ( _ _ type__=@xmath16 ) partner , and encrypted outgoing messages sent to an unverified ( _ _ type__=@xmath17 ) or verified ( _ _ type__=@xmath18 ) partner .",
    "the chronology of message exchanges can be reconstructed by means of the values stored in the _ date _ field , that store date and time of message transmission or receipt encoded as a 13-digits unix epoch format .",
    "this holds true both for notification and chat messages , so it is possible to reconstruct not only the chronology of messages exchanged by users , but also when a notification message arrived .    to illustrate how to reconstruct the chronology of exchanged messages and the corresponding contents ,",
    "let us consider the scenario depicted in fig .",
    "[ messages - tables ] that shows 10 exchanged messages , which are stored in tables",
    "_ messages _ ( 4 messages ) and _ inmemorymessages _ ( 6 messages ) .        from this figure",
    ", we see that the first record in table _ inmemorymessage _ , corresponds to an outgoing encrypted message ( _ _ type__=@xmath17 ) that was sent on oct .",
    "@xmath22 , 2015 at 9:32:35.617 a.m.  utc ( _ _ date__=`__1443691955617 _ _ ' ) to contact no .",
    "@xmath2 ( _ _ thread_id__=@xmath2 ) ( that corresponds to the contact whose nickname is _ second _ , see fig .",
    "[ contact - tables ] ) ; the message body was `` _",
    "_ message 1 _ _ '' , and has been successfully delivered to ( i.e. , visualized by ) its recipient ( _ _ is_delivered__=@xmath0 ) .",
    "the second record of _ inmemorymessages _ correspond instead to an incoming encrypted message ( _ _ type__=@xmath15 ) , that was received by the same user and carried as textual content the string `` _ _ message 2 _ _ '' on oct .",
    "@xmath22 , 2015 at 9:32:44.099 a.m.  utc ( _ _ date__=`__1443691964099 _ _ ' ) that has not been delivered ( i.e. , visualized ) by the chatsecure user .    finally , the first message of table _ messages _ ( whose body was `` _",
    "_ message no .",
    "17 _ _ '' ) , is an outgoing message sent to the same contact on oct .",
    "@xmath22 , 2015 at 05:46:20.850 a.m.  utc ( _ _ date__=`__1443678380850 _ _ ' ) , but whose transmission was delayed ( _ _ type__=@xmath9 ) and , as such , had not been successfully delivered to the recipient ( _ _ is_delivered__=@xmath1 ) .",
    "note that chatsecure stores in tables _",
    "messages _ and _ inmemorymessages _ the messages corresponding to all the local accounts , i.e.  _ chat.secure.user _ and _ test1chatsecure _ in our example ( see fig .",
    "[ account - tables ] ) . however , the identity of the local account @xmath23 corresponding to a given message can be easily determined by correlating the unique contact identifier @xmath24 stored in the _ thread_id _ field with the record of table _ contact _ storing @xmath24 in its _",
    "_ i d _ field ; the value of field _ account _ of that record will indicate the local account @xmath23 . in this way , in the examples above we could tell that messages have been exchanged between contact no .",
    "@xmath2 and account _ chat.secure.user_ , since this contact is associated with account no .",
    "@xmath0 ( see fig .  [ account - tables ] ) .",
    "table _ messages _ in fig .",
    "[ messages - tables ] also stores messages exchanged in group chats , corresponding to the last two records of table _ messages _ , as indicated by _",
    "is_muc=1_. from these records , we see that the corresponding messages have been sent to the group chat corresponding to the contact no .",
    "_ 9 _ of table _ contacts _ ( the chat room named _",
    "grptest@conference.chatme.im_ ) , and carried as textual content the strings `` _ _ group chat message no .  1 _ _ '' and `` _ _ group chat message no .  2 _ _ '' , respectively .    as a final observation",
    ", it is worth noticing that chatsecure stores messages in cleartext , even if they have been encrypted before transmission ( see the contents of field _ body _ of all the records in fig .",
    "[ messages - tables ] ) : this is indeed the case of all the records stored in table _ inmemorymessages _ , that correspond to encrypted messages that have been either sent ( _ _ type__=@xmath17 ) or received ( _ _ type__=@xmath15 ) .",
    "in addition to textual messages , chatsecure allows its users to exchange also files of any type ( at the moment of this writing , however , this functionality is available only for one - to - one communications and not for group chats ) . determining the chronology of these exchanges , and more importantly the contents of exchanged files , may be of crucial importance in many investigations .",
    "each time a file is exchanged , chatsecure creates a record that stores the same information described for chat messages , either in the _ messages _ or in the _ inmemorymessages _ of the main database .",
    "furthermore , it stores the content of the file into an iocipher encrypted virtual disk to keep it inaccessible to an authorized third - party . the file transfer mechanism used by chatsecure interfaces directly with its encrypted virtual disk , that is : ( a ) before being sent , files are stored on the virtual disk , from which they are fetched and sent across the network , and ( b ) received files are stored directly in the virtual disk .",
    "the message records corresponding to file transfers are identified looking at the contents of their _ mime_type _ and _ body _ fields . in particular , the former field stores the mime media type  @xcite of",
    "the transferred file , while the latter one stores the full path of the file in the encrypted virtual disk .",
    "iocipher implements the above virtual disk by using _",
    "libsqlfs _",
    "@xcite , a library that in turn implements a posix - style file system by means of an sqlcipher - encrypted sqlite database .",
    "this database is named _",
    "media.db_ , and includes only two tables , namely _",
    "meta_data _ ( storing various file metadata , such as identifier , path name , and timestamps ) , and _ value_data _ ( storing the actual file blocks ) , whose structure and interpretation is reported in tables  [ media : metadata ] and [ media : valuedata ] , respectively .",
    "_ name _ & _ type _ & _ meaning _ + type & text & type of the object : directory ( _ dir _ ) , file ( _ blob _ ) , symbolic link ( _ symlink _ ) + key & text & full path of the object in the libsqlfs file system + ctime , mtime , atime & int & file creation , last modification , and last access time , respectively ( 10-digits unix epoch format ) + size & int & file size ( in bytes ) + block_size & int & block size ( in bytes ) +     _ name _ & _ type _ & _ meaning _ + key & text & full path of the file in the libsqlfs file system , as stored in the corresponding _ meta_data _",
    "table + block_no & int & sequence number of the file block stored in this record + data_block & binary & data stored in the file block corresponding to this record +    to reconstruct the chronology and the contents of the files that have been exchanged , it is necessary to analyze and correlate the records stored both in the main database _",
    "impsenc.db _ and the _ media.db _ database implementing the encrypted virtual disk .    to illustrate how to perform this reconstruction ,",
    "let us consider fig .",
    "[ media - tables ] , that shows the records generated during the download of a file ( for the upload case , the situation is similar ) .",
    "first , it is necessary to identify the records of tables _ messages _ and _ inmemorymessages _ corresponding to file transfers by examining the values stored in the _ mime_type _ and _ body _ fields .",
    "[ media - tables ] shows the record corresponding to the transfer of a jpeg image ( _ mime_type=`image / jpeg ' _ ) which has been stored in the encrypted virtual disk into a file whose full path name is ` _ _ /2/download/58278 _ _ ' ( the ` _ _ vfs : _ _ ' prefix is not part of the path name , but only indicates the use of the android virtual file system to interface with the libsqlfs file system ) . from this record",
    ", we can also determine that it was an incoming encrypted file ( _ type=13 _ ) , received from contact no .",
    "_ 2 _ on oct .",
    "@xmath22 , 2015 at 09:34:43.731 a.m.  utc ( _ date=`1443692083731 ' _ ) .    after having identified the files that have been exchanged , it is possible to retrieve the corresponding data by examining the records stored in the tables of the _ media.db _ database .",
    "the starting point is table _",
    "meta_data _ , in which we search for a record whose _ key _ field stores the same path name stored in the _ body _ field of the corresponding _ inmemorymessages _ record , i.e.  ` _ _ /2/download/58278 _ _ ' . from this record , we can determine that the file of interest has a size of @xmath25 bytes , and is stored as a sequence of blocks of @xmath26 bytes each .    to retrieve these blocks , all the records of table _",
    "value_data _ whose _ key _ field stores the value ` _ _ /2/download/58278 _ _ ' must be retrieved , and then the content of their _ data_block _",
    "field must be extracted to be stored into a single file according to the corresponding sequence numbers .      as mentioned before , chatsecure relies on sqlcipher to encrypt , using the aes-256 algorithm , both the main database _",
    "impsenc.db_ , as well as the _ media.db _ database used by iocipher to implement the encrypted virtual disk .",
    "therefore it is necessary to decrypt them in order to analyze their contents .",
    "the encryption key used by sqlcipher is generated internally by chatsecure , and is never exposed to the user .",
    "this key is instead saved in the internal memory of the device so that it can be retrieved and used by chatsecure to decrypt the above databases .",
    "however , to make sure that an adversary can not decrypt these databases using the saved secret key , chatsecure uses the _ cacheword _",
    "@xcite library to encrypt it using a user - defined _ secret passphrase _ , and to store it into an xml file named _",
    "info.guardianproject.cacheword.prefs.xml _ located in the _ shared_prefs _ folder ( see fig .  [ folders ] ) . to decrypt the saved secret key",
    ", the passphrase set by the user needs to be re - entered each time chatsecure is started .    from the above discussion",
    "it follows that to decrypt the chatsecure databases three distinct problems must be solved , namely :    1 .   obtaining the _ secret passphrase _ chosen by the user ; 2 .   decrypting the _ secret key _ stored by cacheword ; 3 .   decrypting the databases using the secret key .    in the rest of this section , after describing the encryption scheme adopted by chatsecure ( sec .",
    "[ sec : encryption ] ) , we discuss how to decrypt the secret database encryption key ( sec .",
    "[ sec : decrypt - key ] ) and how to decrypt the databases using this key ( sec .",
    "[ sec : decrypt - db ] ) . finally , we show that the passphrase is stored in the volatile memory of the device from which it can be extracted and used in the decryption process ( sec .",
    "[ sec : extraction ] ) .      before discussing how the secret key can be decrypted ,",
    "it is necessary to illustrate the procedure used by chatsecure to generate , encode , and store it .",
    "this procedure has been reconstructed by analyzing the source code of chatsecure ( in particular , file _",
    "welcomeactivity.java_ ) and of cacheword ( in particular , files _",
    "passphrasesecrets.java _ and _ passphrasesecrectsimpl.java_ ) , and is reported in algorithm  [ alg : encryption ] below using pseudo - code , which is executed only when chatsecure is used for the first time .",
    "@xmath27 [ generate ] @xmath28 [ passphrase ] @xmath29 [ salt ] @xmath30 [ iv ] @xmath31 [ icount ] @xmath32 [ derived ] @xmath33[encrypt ] @xmath34 [ serialize ] @xmath35 [ save ]    as shown in algorithm  [ alg : encryption ] , a 256-bit key is generated first ( line  [ generate ] ) , and then the user is asked to provide a _ passphrase _ ( line  [ passphrase ] ) .",
    "starting from this passphrase , a 256-bit _ derivate key _ ) named _ passphrasekey _ in algorithm  [ alg : encryption ] ) is computed ( line  [ derived ] ) by means of the _ password - based key derivation function 2 ( pbkdf2 ) _  @xcite algorithm .",
    "this latter algorithm requires four distinct parameters , namely the passphrase and three additional values , namely a randomly - chosen 128-bit _ salt _ ( line  [ salt ] ) , a randomly - chosen 96-bit _ initialization vector ( iv ) _ , and a 32-bit integer _ iteration counter ( ic ) _ computed as function of the speed of the processor of the device .",
    "then , the derivate key _ passphrasekey _ is used to encrypt the secret key used for database encryption ( line  [ encrypt ] ) with aes-256 , and the result is stored in the _ encryptedsecretkey _ variable .",
    "finally , the values of _ ic _ , _ salt _ , and _ iv _ are concatenated with the base64 encoding of _ encryptedsecretkey _ , and are saved ( as a sequence of bytes ) into the _ info.guardianproject.cacheword.prefs.xml _ file .",
    "an example of the resulting _ serializedsecret _ is shown in fig .",
    "[ encryption - key ] , where it is highlighted using a square box drawn around it .    .",
    "]      to decrypt the chatsecure databases , the secret key used with sqlcipher must be known .",
    "given that this key is unknown to the user , it must be decrypted from the _ serializedsecret _ stored in the _ info.guardianproject.cacheword.prefs.xml _ file .    assuming that the user passphrase is known , this decryption can be carried out by means of algorithm  [ alg : decryption ] , that we devised starting from algorithm  [ alg : encryption ] .",
    "@xmath36 [ d - passphrase ] @xmath37 [ d - serialized ] @xmath38 [ d - icount ] @xmath39 [ d - salt ] @xmath40 [ d - iv ] @xmath41 [ d - encrypt ] @xmath42 [ d - derived ] @xmath43 [ d - decode ] @xmath44 [ decrypt ]    to decrypt the secret aes key from the _ serializedsecret _ , first the user - generated _ passphrase _ is obtained in some way ( either by the user or , as discussed in sec .",
    "[ sec : extraction ] , by extracting it from the volatile memory of the device ) .",
    "then , the _ serializedsecret _ is read from the _ info.guardianproject.cacheword.prefs.xml _ file ( line  [ d - serialized ] ) , and is subsequently decomposed into its constituent elements , namely _ ic _ , _ salt _ , _ iv _ , and _ encryptedsecretkey _ ( lines  [ d - icount][d - encrypt ] ) .",
    "the second parameter of function _ extractfromsequence _ indicates the offset ( expressed in bits ) from the beginning of the _ serializedsecret _ sequence where each element is stored ( and it is computed by considering the size of each component ) .    to decrypt _ encryptsecretkey _ , the derived key _ passphrasekey _ used to encrypt it ( see algorithm  [ alg : encryption ] , line  [ encrypt ] ) is computed first by means of the pbkdf2 function ( line  [ d - derived ] ) using the same values of _ salt _ , _ iv _ , and _ ic _ used to generate it in algorithm  [ alg : encryption ] ( line  [ d - derived ] ) , as well as the _ passphrase_.    then , to obtain the sqlcipher encryption key , we first base64-decode the value stored in _ encryptedsecretkey _ ( recall that in algorithm  [ alg : encryption ]",
    "this key is base64-encoded before being stored , see line  [ serialize ] ) .",
    "the result of this operation is stored in variable _ decodedsecretkey _",
    "( line  [ d - decode ] ) , which is finally decrypted to yield the sqlcipher key _ decryptedsecretkey _ ( line  [ decrypt ] ) .    as an example , the decryption of the _ serializedsecret _ shown in fig .",
    "[ encryption - key ] yields the sqlcipher key ` _ _ 62 9b 8d bf 3f 26 13 1b 2f b6 96 19 fd 4c f9 92 a1 d2 d0 12 96 b5 73 ba 34 59 fa ff 8a 12 cd 89 _ _ ' ( expressed as a sequence of bytes in hexadecimal encoding ) .    we have implemented the above decryption algorithm as an android app that exploits parts of the cacheword source code ( in particular , file _",
    "passphrasesecrectsimpl.java_ ) , which is freely available upon request .",
    "the choice of implementing it for android and not for another platform stems from the fact that the cacheword source code does not correctly compile outside the android development environment .      once the encryption key used with sqlcipher",
    "has been obtained by means of algorithm  [ alg : decryption ] , the chatsecure databases can be decrypted using any sqlite v.3 client that supports sqlcipher .    in fig .",
    "[ impsenc - decrypt ] we show how the main database _ impsenc.db _ can be decrypted on a linux system by means of the sqlcipher command line tool ( freely available from  @xcite ) .",
    "after launching the sqlcipher client , the encrypted database is opened first by means of the _",
    ".open impsenc.db_ command .",
    "then , it is decrypted by means of the _ pragma key = ",
    "x`key_bytes' ; _ command , where _ key_bytes _ denotes the hexadecimal encoding of the sequence of bytes corresponding to encryption key .",
    "the last _ .tables _ command shown in fig .",
    "[ impsenc - decrypt ] serves only to verify that decryption has been correctly performed , as in the case of a wrong key the pragma directive fails silently .    the decryption procedure for the _ media.db _ database is slightly different , as shown in fig .",
    "[ media - decrypt ] .        in particular , a textual key is used in place of the 256-bit sqlcipher key used for the _ impsenc.db _ database ( where the key was passed to the _ pragma key _ command as a hexadecimal sequence ) .",
    "this textual key is obtained by first converting the 256-bit sqlcipher key into a lower - case textual string ( by translating each hexadecimal digit into the corresponding ascii character ) , and then by truncating it to the leftmost 32 characters .",
    "after this key has been computed , the _ media.db _ is decrypted by means of the _ pragma key=``txt_key '' _ command ( where _ txt_key _ denotes it ) followed by the _ pragma cipher_page_size = 8192 ; _ command   for the page size for the encrypted database is a design choice of the libsqlfs library ( see function _",
    "sqlfs_t_init _ in the _ sqlfs.c _ file of the libsqlfs source tree ) . ]",
    "( that , instead , was not required for the _ impsenc.db _ database ) , as shown in fig .",
    "[ media - decrypt ] .      as discussed before ,",
    "algorithm  [ alg : decryption ] needs the user - defined passphrase to decrypt the sqlcipher encryption key , that must be gathered in order to proceed with database decryption and analysis .",
    "if the chatsecure user is unwilling to reveal the passphrase , this problem becomes hard to solve , since this passphrase is never stored on the persistent memory of the device , so it can not be retrieved from there .",
    "however , as discussed below , the passphrase persists in the volatile memory of the device after it has been inserted by the user when chatsecure is started .",
    "therefore , if the device is switched on and chatsecure is running , the passphrase can be located in the volatile memory , and can be extracted from there .    in this section ,",
    "we first discuss how we found out that the passphrase persists in volatile memory , and then we show how it can be identified and extracted from a dump of its contents .",
    "to verify whether the passphrase persists in the volatile memory of the chatsecure device , we performed experiments in which we started chatsecure , entered the passphrase , put the application in the background , waited a given amount of time during which the app was not used ; then , we extracted the contents of volatile memory of the chatsecure process , and searched it for the passphrase that was entered .",
    "experiments were organized in rounds , where each round included experiments in which we progressively increased the amount of time we waited before performing acquisition , up to a maximum of two hours .",
    "we ran different sets of rounds , each one corresponding to a different passphrase .",
    "memory extraction and analysis was carried out by using the methodology described in @xcite , using for extraction and for analysis .",
    "the results of our experiments can be summarized as follows :    1 .",
    "the passphrase was always found in the volatile memory of the chatsecure process , thus proving that it persists there for the entire execution of chatsecure ; 2 .",
    "the passphrase is stored as a null - terminated unicode utf16-le string ( an example is shown in fig .",
    "[ pass - in - memory ] for the passphrase _",
    "thisisthepassword2016 _ , which is highlighted by continuous - line box surrounding it ) ; 3 .",
    "the sequence of bytes encoding the passphrase is preceded by the 16-bytes signature _ 50 99 ab b2 00 00 00 00 1a 00 00 00 00 00 00 00 _ ( highlighted in fig .  [ pass - in - memory ] by a dotted - line box surrounding it ) ; 4 .   the passphrase and its signature",
    "appear twice in the memory space of the chatsecure process , as exemplified in fig .",
    "[ pass - in - memory ] .",
    "of course in real cases the passphrase is not known , so it can not be found in memory by simply searching for it , as we instead did in our experiments .",
    "we need therefore to define a method allowing us to identify an unknown passphrase stored in volatile memory",
    ".    a natural choice would be that of using the 16-bytes signature mentioned above as a landmark indicating the position of the passphrase .",
    "unfortunately , the results of our experiments indicate that this method yields a large number of false positives , since the above signature is present also for other utf16-le null - terminated strings .    however , we can leverage the fact that the passphrase appears _ twice _ in the volatile memory of the chatsecure process , each time preceded by the above 16-bytes signature , to prune all the candidate strings that do not occur twice in the above memory space ( they are clearly false positives ) . although we can not exclude that this procedure will filter out all the false positives , it is certainly able to greatly reduce their number .",
    "finally , after all the candidate passphrase have been extracted from the volatile memory region belonging to the chatsecure process , we can find the correct one by first running algorithm  [ alg : decryption ] for each one of them , and then by attempting to decrypt the chatsecure databases with the secret key it returns .",
    "it is worth noticing that the database decryption procedure can be implemented by using the sqlcipher api , thus making the above method fully automatable .",
    "the last issue we consider is concerned with the recovery of messages and files deleted by the chatsecure user .",
    "these deletions are performed by deleting the corresponding records from the _ impsenc.db _ and _ media.db _ databases .",
    "it is well - known that in sqlite databases deleted records are kept in the so - called _ unallocated cells _ ,",
    "i.e.  slack space stored in the file corresponding to the database , from which they can be recovered  @xcite .",
    "unfortunately this is not the case for chatsecure databases , since their records are deleted securely , i.e.  they are overwritten upon deletion . as a matter of fact , in sqlcipher ( that , as already discussed , is used both by chatsecure and iocipher to encrypt the _",
    "impsenc.db _ and the _ media.db _ databases , respectively ) , secure deletion is enabled by default , as reported in its official documentation  @xcite , that states :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` _ _ (  ) as of version 2.0.5 , sqlcipher now enables sqlite s pragma secure_delete = on option .",
    "this causes the freed pages to be zeroed out on delete to hinder recovery . as",
    "before , they remain encrypted .",
    "note that this does nt imply that the pages are removed from the database file , just that their content is wiped when they are marked free__. '' _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    to verify whether the above holds true in reality , we performed a set of experiments in which we deleted various messages and files from the above databases , and then we attempted to recover the corresponding records by means of specialized tools  @xcite . our analysis did not yield any result , thus indicating that secure deletion is actually working in the current version of chatsecure .",
    "we have therefore to conclude that the recovery of deleted messages and files is not possible .",
    "in this paper we have discussed the forensic analysis of chatsecure , a secure i m application that adopts strong encryption for transmitted and locally - stored data to ensure the privacy of its users .    in particular , we have shown that chatsecure stores local copies of both exchanged messages and files into two distinct databases , that are strongly encrypted by means of the sqlcipher library .",
    "although the encryption mechanisms used by chatsecure is rather complex , we have devised an algorithm able to decrypt these databases starting from the secret passphrase chosen by the user as the initial step of the encryption process .",
    "we have also shown how this passphrase can be identified and extracted from the volatile memory of the device , where it persists  after having been entered by the user  for the entire execution of chatsecure , thus allowing one to carry out decryption even if the passphrase is not revealed by the user .",
    "moreover , we have also shown how to analyze and correlate the data stored in the databases used by chatsecure to identify the i m accounts used by the user and his / her buddies to communicate , as well as to reconstruct the chronology and contents of the messages and files that have been exchanged among them .",
    "the study reported in this paper has been performed by means of a methodology that is based on the use of emulated devices and therefore provides a very high degree of reproducibility of the results .",
    "the accuracy of the method has been assessed by validating the results it yields against those obtained from real smartphones .",
    "we believe that this methodology represents also a significant contribution of this paper .",
    "41 natexlab#1#1 [ 1]`#1 ` [ 2]#2 [ 1]#1 [ 1]http://dx.doi.org/#1 [ ] [ 1]pmid:#1 [ ] [ 2]#2 . . . . . . .",
    "; ( ): . . . ; ( ): . . , , .",
    "; university of piemonte orientale ; . .",
    ". . in : , editor",
    "; volume   of _ _ ; . . . .",
    "; ( ): . . . . . . . . . . . . . . . . . . . .",
    ". . . , , ,",
    ": ; icuimc 12 ; .",
    "; united nations ; . .",
    ", , , , . .",
    "; : . ; . ."
  ],
  "abstract_text": [
    "<S> we present the forensic analysis of the artifacts generated on android smartphones by _ chatsecure _ , a _ secure _ instant messaging application that provides strong encryption for transmitted and locally - stored data to ensure the privacy of its users .    </S>",
    "<S> we show that chatsecure stores local copies of both exchanged messages and files into two distinct , aes-256 encrypted databases , and we devise a technique able to decrypt them when the secret passphrase , chosen by the user as the initial step of the encryption process , is known .    </S>",
    "<S> furthermore , we show how this passphrase can be identified and extracted from the volatile memory of the device , where it persists for the entire execution of chatsecure after having been entered by the user , thus allowing one to carry out decryption even if the passphrase is not revealed by the user .    </S>",
    "<S> finally , we discuss how to analyze and correlate the data stored in the databases used by chatsecure to identify the i m accounts used by the user and his / her buddies to communicate , as well as to reconstruct the chronology and contents of the messages and files that have been exchanged among them .    for our study </S>",
    "<S> we devise and use an experimental methodology , based on the use of emulated devices , that provides a very high degree of reproducibility of the results , and we validate the results it yields against those obtained from real smartphones .    forensic analysis of the chatsecure instant messaging application on android smartphones     + please , cite this paper as : + * cosimo anglano , massimo canonico , marco guazzone , + _ `` forensic analysis of the chatsecure instant messaging application on android smartphones , '' _ + digital investigation , volume 19 , december 2016 , pages 4459 . </S>",
    "<S> + doi:10.1016/j.diin.2016.10.001 + publisher : http://dx.doi.org/10.1016/j.diin.2016.10.001 *    mobile forensics , chatsecure , android , instant messaging , secure instant messaging </S>"
  ]
}