{
  "article_text": [
    "blind quantum computation ( bqc ) @xcite is a practical quantum information technique combining quantum cryptography and quantum computation .",
    "it is mainly used in the cases that one party has limited quantum computational resources , and delegates his quantum computation to the other party who can do it .",
    "for example , the quantum computer is so expensive for personal purchasing , however , the corporation or organization can purchase the quantum computer and make money by providing quantum computing services to individual customers . then there is a problem : the customers do not trust the corporation , and worry that his private data , result and even the quantum algorithm may be learned by the corporation .",
    "the problem can be solved using bqc protocol , by which the quantum computer can provide secure cloud services .",
    "bqc deals with the problem : one party with limited computational power delegates his computational task to another party , and can get the required result while his privacy ( the private data and result ) is secured during the whole process .",
    "this problem is firstly studied by childs @xcite , and then lots of bqc protocols have been proposed @xcite .",
    "there are also some development about the experiment of bqc @xcite . in current studies about bqc",
    ", the data is supposed to be provided by client , and the computational service is supposed to be provided by server , but the algorithm may be provided by client or server or be public .",
    "so , the researches of bqc protocols can be classified into three kinds .",
    "( 1 ) the algorithm is private and belongs to client .",
    "most of researches are of this kind @xcite ; ( 2 ) the algorithm is private and belongs to server , see ref.@xcite ; ( 3 ) the algorithm is public or at least agreed on by both server and client @xcite . no matter",
    "which party the algorithm belongs to , the owner of it should provide better algorithm to improve the efficiency .",
    "because the algorithm is an important information , the owner of it wishes to keep it private during the process of bqc .",
    "currently , the studies focus on the case that the private algorithm belongs to client or server @xcite",
    ". however , there exists an ordinary case in practice : the algorithm belongs to the third party , which intends to make money by providing the algorithm in a private way . in this case , the algorithm can be kept private while making money , so this mode can encourage the researchers to concentrate on the studies of algorithm and improve the algorithm .",
    "this paper considers bqc from the aspect that the data , algorithm and computational resources belong to three independent parties .",
    "the model of tripartite blind quantum computation ( tbqc ) is proposed , and the possible adversaries are analyzed , and then three properties such as correctness , blindness , verifiability are defined .",
    "then , based on broadbent - fitzsimons - kashefi protocol @xcite , a tbqc protocol is presented . finally , the other tbqc protocol is proposed based on universal quantum circuit ( uqc ) .",
    "the tbqc model involves three independent participants : client , server and third party , denoted as c , s , t , where c holds the data , s holds the quantum computational resources , and t holds the quantum algorithm .",
    "t has the ability of designing quantum algorithm , and prevents it from revealing during the interactive process of tbqc . in order to provide better quantum computing services ,",
    "s tries to provide more quantum computational resources or stronger universal quantum computer .",
    "c has limited quantum computational power and no efficient quantum algorithm , but he intends to compute on some private data with quantum computer .",
    "he hopes to accomplish the computational task by using t s quantum algorithm and s s quantum computational resources , and prevents his data and the required result from revealing during the computation .",
    "in the tbqc model , the three parties c , s , t play different roles in the computation .",
    "they interactively perform some local ( classical or quantum ) computation and communicate through classical or quantum channel , and finally finish a common computational task while the privacy is secured .",
    "the detailed interactive process is called tbqc protocol . here",
    "the tbqc protocol is denoted as @xmath1 , where two parameters @xmath2 must be given as the inputs .",
    "the symbol @xmath3 is the private data owned by c , and the symbol @xmath4 is a mapping @xmath5 , which represents a computational task . at the beginning of the protocol , c would inform t about the computational task @xmath6 , then t can design a quantum algorithm accordingly .",
    "the encoding of the algorithm is denoted as @xmath7 .",
    "given an input data @xmath8 , the output of the protocol @xmath9 can be described as @xmath10 .",
    "if @xmath11 , we say the protocol is correct .",
    "the definition of correctness is as follows .    *",
    "definition 1 ( correctness)*. a tripartite blind quantum computation protocol @xmath9 is correct if , given any input data @xmath8 and any required computational task @xmath5 , its outcome @xmath10 equals to @xmath12 when the three parties t , c and s follow the steps of the protocol honestly .      in tbqc model ,",
    "the privacy contains the data , algorithm and result .",
    "c must prevent his data and result from revealing , and t must prevent his algorithm from revealing . according to the different attacking targets , the adversarial model can be classified into three kinds : attacking the data , attacking the algorithm , and attacking the result .",
    "the attacker may be some one of the three parties or two of them .",
    "the outer hacker may also participate the attacking .",
    "however , the outer hacker can not obtain more information about the privacy than any one of the three parties .",
    "if the protocol can prevent inner attackers , then it can also prevent outer attackers .",
    "thus , when considering adversarial model , it is analyzed only the inner attack by the dishonest participants .    during the interaction of the protocol",
    ", t sends his quantum algorithm as messages in a private way , so the attackers or dishonest parties may take some measures to obtain some information about the algorithm . because the algorithm is private information that belongs to t , t must provide the algorithm in a private way , and then the other parties ( c or s ) can only use the algorithm , but can not obtain the algorithm during the computation .    similarly , in order to secure the data , c has to provide the data in a private way ( the most common way is encryption ) , and then the other parties can only use them in computation , but can not learn them .    attacking the result includes two aspects : ( 1 ) the passive adversaries do not disturb the execution of protocol , but snatch some information about the final result ; ( 2 ) the active adversaries maliciously disturb the execution of the protocol , and cause a wrong outcome .    in order to prevent the result from passive adversaries",
    ", it is required that the final result can only be decrypted by c in the protocol .",
    "the malicious disturbance may be caused by either the outer attackers or the inner participants .",
    "for instance , t provides an incorrect quantum algorithm , or s does not obey the protocol strictly . for this kind of active adversaries , when designing a tbqc protocol , a mechanism should be introduced to detect the destruction , so that c can judge the correctness of the final result .",
    "the disturbance may also be caused by outer attackers who break the communication channel .",
    "this kind of attack exists usually in all communication protocol , and will not be considered in this paper .",
    "besides , there exists another kind of adversaries : in order to attack the privacy of certain party , the other two parties may cooperate by sharing their information with each other .",
    "for example , s and t may cooperate in order to attack the data and result , which is the privacy of c. this kind of adversaries is called collusive attack .      because the data , the algorithm , and the result are private information , a secure tbqc protocol must prevent these information from revealing .",
    "this property is called blindness .",
    "its definition is as follow .    *",
    "definition 2 ( blindness)*. a tbqc protocol @xmath9 is blind if , given any input data @xmath8 and any required computational task @xmath13 , nothing about @xmath8 and the quantum algorithm @xmath7 of @xmath4 and the outcome @xmath10 is leaked . here",
    "the quantum algorithm @xmath7 is a series of instructions of quantum operators , and belongs to t ; the input @xmath8 and the outcome @xmath10 belong to c.    because the protocol may be disturbed by the attackers and does not executed as expected , c must judge the correctness of the final result .",
    "thus , a verifiable mechanism is required to check the final result .",
    "it is another property of tbqc protocol , and is called verifiability .    in the following ,",
    "the honestly executed tbqc protocol is denoted as @xmath9 , while the actually executed protocol is denoted as @xmath14 .",
    "so , the protocol @xmath14 may be different with ideal protocol @xmath9 , where there exists adversaries .",
    "it is worth to notice that , there exists some problems that are hard to solved , however , if given a result , it is easy to verify whether it is right or not .",
    "we take the prime factorization problem for example .",
    "it can be described simply as a mapping @xmath15 , where @xmath16 .",
    "if the protocol @xmath9 has not been disturbed , it outputs the result @xmath17 , where @xmath18 , otherwise , it outputs @xmath19 , where @xmath20 .",
    "obviously , the right result @xmath21 and the wrong one @xmath22 can be distinguished with certainty .",
    "after the tbqc protocol is executed with the input @xmath2 , the client can verify the output @xmath22 : if @xmath20 , then the protocol @xmath9 is not executed as expected , and the client rejects the result .",
    "it can be seen from the example that , for a class of problems such as np problems , the answers can be verified easily .",
    "then the tbqc protocol for computing them is verifiable .",
    "however , this kind of verifiability is not universal for all problems .",
    "so it is called weak verifiability here .",
    "the definition is as follow .    *",
    "definition 3 ( weak verifiability)*. we say a tbqc protocol @xmath9 is verifiable for a class @xmath23 of problems if , given any input data @xmath8 and any @xmath24 , the two outcomes @xmath10 and @xmath25 can be distinguished with probability more than @xmath26 .    for a tbqc protocol with weak verifiability , it is verifiable for a class of computational problems @xmath23 , but not verifiable for other problems . if a verifiable mechanism is added into the tbqc protocol , the verifiability becomes independent of the problems @xcite .",
    "we define this kind of verifiability as strong verifiability .    * definition 4 ( strong verifiability)*. we say a tbqc protocol @xmath9 is strong verifiable , if it is verifiable for all computational problems .",
    "ref.@xcite proposed a bqc protocol .",
    "we can modify it and get a tbqc protocol . in the protocol",
    ", some classical and quantum information should be transferred privately with other quantum cryptographic primitives . because the focus of this paper is tbqc protocol",
    ", we will not state how to secure the communication between them .    before the execution of tbqc protocol ,",
    "c should inform t about the computational task , then t designs a quantum algorithm accordingly .",
    "next , the first tbqc protocol is presented as follow .",
    "we adapt the same notations as ref.@xcite .",
    "protocol 1 : : 1 . c encrypts data : : :    for each input column @xmath27 corresponding    to c s data , ( 1 ) c randomly selects    @xmath28 , and    applies @xmath29 ; ( 2 ) c randomly selects    @xmath30 , and applies    @xmath31 .",
    "c sends the qubits to s in a secure    way .",
    "c sends all the @xmath32 and    @xmath33 to t in a secure way .",
    "t prepares qubits : : :    for each column @xmath34 , and each row    @xmath35 , t randomly selects    @xmath36 , and    produces single qubit    @xmath37 .",
    "t sends all    the qubits to s. 3 .",
    "s prepares brickwork state : : :    after receiving all qubits from c , s informs c. after receiving all    qubits from t and c , s produces some qubits    @xmath38 . using all    the received qubits and prepared qubits",
    ", s creates an entangled state    according to their indices , by applying controlled - z gates between the    qubits in order to create a brickwork state .",
    "t and s compute interactively : : :    for each column @xmath39 , and each row    @xmath35 , according to the algorithm designed by t ,    t and s carries out some interaction and measurement ( the details can    be seen in ref.@xcite ) .",
    "finally , t obtains some measured values    @xmath40 ( these values are unknown for s ) , and s can    obtain @xmath41 qubits , which is just the encrypted result that    is required by c. 5 .",
    "secure communication : : :    t sends all the measured values @xmath40 to c in a secure    way ; s sends the final @xmath41 qubits to c in a secure way .",
    "decryption : : :    after receiving the @xmath41 qubits and all the values    @xmath40 , c applies pauli operation    @xmath42 on all the    @xmath41 qubits , where the values of @xmath43    and @xmath44 can be calculated from the values    @xmath40 .",
    "protocol 1 is analyzed from the correctness and security ( blindness and verifiability ) in the following .",
    "* theorem 1 ( correctness)*. assume c , s and t follow the steps of protocol 1 , then the outcome is correct .",
    "_ proof_. this protocol is modified from the protocol in ref.@xcite .",
    "in fact , this modification changes only the way of interaction , but has not changed the computing process .",
    "obviously , if the participants t and s join together , protocol 1 would degenerate into the protocol in ref.@xcite .",
    "thus , the outcome of this protocol is also correct . @xmath45",
    "* theorem 2 ( blindness)*. protocol 1 is blind .",
    "_ proof_. the blindness of the protocol should be analyzed from the following three points .",
    "the former two points hold in the case that s and t would not cooperate .",
    "( 1 ) the data will not leak .",
    "c encrypts his data and sends the encrypted data and the key to s and t separately . if s and t do not cooperate , the data will not leak .",
    "( 2 ) the result will not leak .",
    "after the interaction of s and t , t owns only the decryption key , and s owns only the encrypted result . if they do not cooperate , the result will not leak .",
    "( 3 ) the algorithm will not leak . in the protocol , the algorithm is only used in the interaction of t and s. because the protocol in ref.@xcite does not reveal the algorithm , protocol 1 does not leak the algorithm . in conclusion , protocol 1 is blind.@xmath45    protocol 1 does not satisfy strong verifiability .",
    "it only satisfies weak verifiability , that means the obtained result can be verified for only a class of problems .    *",
    "theorem 3*. protocol 1 can not defeat collusive attack of s and t.    _ proof_. in the first step , c sends the encrypted data and the key to s and t separately ; so s and t can get the data if they cooperate . in the fourth step , s and t can get the encrypted result and the key separately ; so they can also get the result if they cooperate .",
    "thus , protocol 1 can not defeat collusive attack of s and t.@xmath45    in the next section , the second tbqc protocol is proposed , and it can defeat collusive attack .",
    "* definition 5 ( universal quantum circuit @xcite)*. fix @xmath46 and let @xmath47 be a collection of unitary transformations on @xmath48 qubits . a quantum circuit @xmath49 on @xmath50 qubits is universal for @xmath47 if , for each transformation @xmath51 , there is a string @xmath52 ( the encoding ) such that for all strings @xmath53 ( the data ) , @xmath54    according to the definition , we can propose a tbqc protocol based on uqc .",
    "the main idea is as follows : the data @xmath55 is provided by c , the encoding @xmath56 of the transformation @xmath51 is provided by t , and the uqc ( or quantum computer ) @xmath57 is provided by s. by using the encoding provided by t and the quantum circuit provided by s , c can finish the quantum information processing on his data @xmath55 , and obtain the result @xmath58 .    for a given computational task , t designs a quantum algorithm based on the quantum transformations in the set @xmath47 , that is finding a series of quantum transformations in @xmath47 , for example @xmath59 , such that performing these transformations in order can implement the given computational task .",
    "the encoding of the algorithm is the combination of the encodings of the series of quantum transformations @xmath60 , denoted as @xmath61 . using the uqc @xmath57 , the computation of the algorithm @xmath62 is carried out as follows : @xmath63 finally , the result @xmath64 is obtained .    from the above analysis",
    ", we can see that , based on uqc , the three parties t , c , s can finish some quantum information processing on any data when they cooperate together .",
    "however , their cooperation should be designed carefully , in order to protect the privacy of t and c. next , we design a secure way of cooperation , and get a tbqc protocol .    if the owner s of the uqc is treated as the distrusted third party , then the construction of tbqc protocol based on uqc is similar to designing a protocol for secure two - party quantum computation with distrusted third party .",
    "the distrusted third party may obey the protocol for secure two - party quantum computation , meanwhile , he collects some information about the privacy of t and c during the computation . in addition , he may also not obey the protocol and perform some incorrect computation .",
    "inspired by the protocol for secure two - party quantum computation in ref.@xcite , we design a tbqc protocol based on the above universal scheme of quantum computation .",
    "the construction of uqc and the universal quantum gates are public . according to the basic quantum transformations that are implemented by the uqc , t designs the quantum algorithm , which is a series of the basic quantum transformations . here",
    "we assume the set of quantum gates used in the construction of uqc is @xmath65 , which is the same as that in ref.@xcite .",
    "in the tbqc protocol , initially , c and t select the random numbers @xmath66 and @xmath67 as their initial keys , which are used to encrypt their privacy ( the data @xmath55 or the encoding of algorithm @xmath68 ) . then , c and t send the ciphertext of their privacy to s who carries out the computation of uqc on the ciphertext . at the same time ,",
    "c and t update their initial keys @xmath69 according to the order of different gates in the uqc ( suppose there are @xmath70 quantum gates ) , and finally obtain the final keys @xmath71 .",
    "s carries out the uqc on the encrypted data and the encrypted encoding , and obtains an encrypted result .    in order to explain the key point clearly , we express it using some identities .",
    "first of all , some notations are introduced as follows .",
    "suppose the data is represented by @xmath48 qubits , the encoding of the algorithm is a series of @xmath41-qubit string .",
    "the initial keys @xmath72 are four @xmath50-bit random numbers , and each of them can be regarded as two parts , where the first part has @xmath48 bits and the second part has @xmath41 bits .",
    "let the set of indices @xmath73 and @xmath74 .",
    "later we denote @xmath75 as the @xmath76-th bit of the @xmath50-bit random number @xmath77 , and denote @xmath78 , @xmath79 .",
    "then we have @xmath80 , @xmath81 , @xmath82 , @xmath83 . here",
    "the @xmath50-bit numbers @xmath77 and @xmath84 are randomly selected by c , and the @xmath50-bit numbers @xmath85 and @xmath86 are randomly selected by t. for a @xmath48-bit number @xmath87 ( @xmath88 ) and a unitary operator @xmath89 , denote @xmath90 . the key point can be expressed as follows : @xmath91 from the eq.([eq1 ] ) , we should find a uqc @xmath49 and a key - updating algorithm that satisfy the above equations .",
    "the key - updating algorithm depends on the uqc in this scheme .",
    "this kind of construction can be blind , since s can not obtain the data , the encoding , and the result , however , c can decrypt the encrypted result with the help of t while t can not obtain the result .",
    "the detail of the tbqc protocol is as follows . at the beginning",
    ", c has informed t about the computational task , and t has designed the algorithm , which is a series of @xmath41-qubit string ( suppose there are @xmath92 @xmath41-qubit strings : @xmath93 ) .",
    "the protocol should run @xmath92 times .",
    "when the protocol runs for the @xmath94-th time , the outcome of the @xmath95-th time and each @xmath61 is used as its input .",
    "protocol 2 : : 1 .",
    "encryption of the data : : :    according to the first part of the random numbers @xmath77    and @xmath84 , c performs the following encryption    transformation on the data @xmath55 :    @xmath96    and sends the ciphertext to t ; according to the first part of the    random numbers @xmath85 and",
    "@xmath86 , t encrypts    the ciphertext as follow :    @xmath97    and sends the new ciphertext to s ; 2 .",
    "encryption of the encoding : : :    according to the second part of the random numbers @xmath85    and @xmath86 , t performs the following encryption    transformation on the encoding @xmath68 of a basic    transformation :    @xmath98    and sends the ciphertext to c ; according to the second part of the    random numbers @xmath77 and @xmath84 , c encrypts    the ciphertext as follow :    @xmath99    and sends the new ciphertext to s ; 3 .",
    "computing through uqc : : :    for the encrypted data and encoding , s performs the uqc on them by    orderly carrying out each gate    @xmath100 of the    uqc .",
    "finally , the obtained result is still being encrypted .",
    "s sends    the encrypted result to t. ( there is an exception here : when    @xmath101 is performed on a wire @xmath102 ,    the wire @xmath76 must be transferred to c ; c picks random bits    @xmath103 and @xmath104 , and applies the operator    @xmath105 and sends the resulting    quantum state to t ; t picks random bits @xmath106 and    @xmath107 , and applies the operator    @xmath108 and sends the resulting    quantum state to s ; then s continues next quantum gate    @xmath109 . )",
    "key - updating : : :    c and t update their keys according to the gates and their order in    the uqc : suppose the @xmath110-th gate in the uqc is    @xmath111 , c and t update their keys according to the gate    @xmath111 , @xmath112 for a given uqc , the gates and their order are    deterministic , so the key - updating algorithm is a deterministic    algorithm . later we will present a detail description about the    key - updating algorithm for each gate    @xmath113 .",
    "decryption of the result : : :    after receiving the encrypted result ( denote it as    @xmath114 ) from s , t performs the following    decryption transformation according to his key    @xmath115 :    @xmath116    and sends it to c ; c decrypts it according to his key    @xmath117 :    @xmath118    and gets the result finally .",
    "especially , in ref.@xcite , a uqc for near - trivial transformations has been constructed .",
    "the near - trivial transformations are a class of basic transformations , and any unitary transformation can be decomposed into the product of a series of near - trivial transformations @xcite .",
    "then we can design a tbqc protocol based on the uqc for near - trivial transformations . in this protocol",
    ", t can design his quantum algorithm using a series of near - trivial transformations .",
    "though this uqc is formed by combining the gates selected from the set @xmath119 and generalized @xmath120s , it can be easily transformed into a new uqc consisting of the gates in @xmath65 .",
    "so we can always assume the uqc consists of the gates in @xmath65 .",
    "in key - updating algorithm , each step of updating in eq.([eq2 ] ) should satisfy the following identities ( ignoring an irrelevant global phase ) .",
    "for any single - qubit gate @xmath121 ( the gate @xmath0 is an exception ) applying on the @xmath76-th qubit , the keys @xmath122 and @xmath123 satisfy @xmath124 for the two - qubit gate @xmath125 applying on the @xmath76-th and @xmath126-th qubits , the keys @xmath122 and @xmath123 satisfy @xmath127    next , we introduce the key - updating algorithm for each different quantum gate @xmath113 .",
    "this algorithm here is similar to that in ref.@xcite except the two - qubit gate @xmath120 . to keep the consistence of the notations ,",
    "we restate the key - updating algorithm for the gates @xmath128 using our notations .",
    "* let @xmath129 be the pauli gate to be executed on wire @xmath102 .",
    "we have : @xmath130 where an irrelevant global phase factor is ignored .",
    "thus , c updates his key as follow : @xmath131 and t updates his key as follow : @xmath132 * let @xmath133 be the hadamard gate to be executed on wire @xmath102 .",
    "we have : @xmath134 where an irrelevant global phase factor is ignored .",
    "thus , c updates his key as follow : @xmath135 and t updates his key as follow : @xmath136 * let @xmath137 be the phase gate to be executed on wire @xmath102 . using the fact that @xmath138 ( up to an irrelevant phase factor ) , we have : @xmath139 thus , c updates his key as follow : @xmath140 and t updates his key as follow : @xmath141 * let @xmath125 be the controlled - not gate to be executed on wires @xmath142 .",
    "assume that @xmath76 is the control while @xmath126 is the target .",
    "the key - updating algorithm is different from that of ref.@xcite .",
    "the reason is as follow : the cnot gate is performed by the third party ( the server s ) , who possesses the two wires @xmath143 while computing , thus the cnot gate would not be performed nonlocally .",
    "using the fact that @xmath144 , we have : @xmath145 thus , c updates his key as follow : @xmath146 and t updates his key as follow : @xmath147 * let @xmath101 be executed on wire @xmath102 . in the protocol ,",
    "c and t apply quantum operators @xmath105 and @xmath108 , respectively . according to the deduction in ref.@xcite",
    ", we have : @xmath148 where an irrelevant global phase factor is ignored .",
    "because @xmath149 is known only by c and @xmath150 is known only by t , an and - box is called to compute two bits @xmath151 , such that @xmath152 .",
    "assume c obtains @xmath153 and t obtains @xmath154 after calling the and - box .",
    "thus , c updates his key as follow : @xmath155 and t updates his key as follow : @xmath156      protocol 2 is analyzed from the correctness and security ( blindness and verifiability ) in the following .",
    "* theorem 4 ( correctness)*. assume c , s and t follow the steps of protocol 2 , then the outcome is correct .    _",
    "proof_. according to the key - updating algorithm , if the three parties follow the steps of protocol 2 , s carries out the uqc @xmath57 , and outputs the @xmath50-qubit state @xmath157 where @xmath55 is the data owned by c , @xmath158 is the encoding owned by t , @xmath159 is the quantum transformation corresponding to the encoding @xmath160 .",
    "s sends the former @xmath48 qubits to t , then t performs decryption transformation and gets @xmath161 , and sends it to c. finally , c performs decryption transformation and gets the required result @xmath162 .",
    "thus , the outcome is correct.@xmath45    * theorem 5 ( blindness)*. protocol 2 is blind .    _",
    "proof_. in protocol 2 , c and t encrypt their privacy ( the data and encoding ) with quantum one - time pad before sending them , and their initial keys are selected locally by themselves .",
    "so no information about their initial keys is leaked . during the interaction of the protocol",
    ", they update their keys by locally performing a computing on their keys , except the execution of @xmath0 gate .",
    "whenever a @xmath0 gate is executed , the key - updating algorithm needs to call an and - box once .",
    "thus , whether their keys is leaked depends on the security of the and - box . given an ideal and - box ,",
    "the information of keys ( including every key that are obtained during the key - updating process ) can be kept secret perfectly .",
    "because the privacy is protected by the quantum one - time pad and the keys are not leaked , the privacy ( the data , encoding and result ) of c and t are protected perfectly .",
    "thus , protocol 2 is blind.@xmath45    similar to protocol 1 , protocol 2 does not satisfy strong verifiability .",
    "it only satisfies weak verifiability . how to transform it into a tbqc protocol with strong verifiability ?",
    "this problem will be discussed in the next section .",
    "* theorem 6*. protocol 2 can defeat collusive attack .    _",
    "proof_. in protocol 2 , all the privacy of t and c have been encrypted with quantum one - time pad when the protocol begins . during the whole process of computation ,",
    "the privacy are in the state of being encrypted , and the decryption key is unknown by the others .",
    "for example , in the final step , the privacy are in the state shown by eq.([eq3 ] ) , and the two decryption keys are @xmath163 and @xmath164 , respectively .",
    "it can be seen that , for each key , half information is owned by c , and the other half is owned by t , and neither of them can decrypt it alone . then ,",
    "if s and c cooperate , they can not attack the privacy of t. if s and t cooperate , they can not attack the privacy of c. thus , protocol 2 can defeat collusive attack.@xmath45",
    "both the tbqc protocols 1 and 2 satisfy the weak verifiability , that means the check of the result depends on the problem itself . how to design a tbqc protocol , such that it has strong verifiability ? for this problem ,",
    "a possible way is : firstly performing quantum authentication on the quantum data , and then performing tbqc protocol 2 .",
    "concretely , the tbqc protocol 2 can be improved using the technique proposed in ref.@xcite , where clifford - based quantum authentication code @xcite is used to authenticate the result .",
    "the details will be given in the future .    though the model presented here",
    "involves three participants , when two of them cooperate completely , it would degenerate to the bqc model that are usually studied .",
    "thus , the tbqc model can be regarded as an extension of bqc model .",
    "if c and t cooperate completely , it corresponds to the bqc model , where the client owns the data and algorithm and delegates his computational task to the server .",
    "if t and s cooperate completely , it corresponds to the bqc model , where the server provides the computational resources and algorithm , and the algorithm is private by the client , see ref.@xcite .",
    "if c and s cooperate completely , it corresponds to the bqc model , where one party has data and enough computational resources and the other party owns the algorithms , and the latter provides the algorithm to the former in a blind way .",
    "this case is worth for future research .",
    "this paper extends the bqc model , and proposes a tbqc model .",
    "the tbqc model is a special case of three - party secure computation , where the three parties play the different roles .",
    "this case exists widely and is worth to study . here",
    ", two concrete protocols are constructed .",
    "the first protocol can not defeat collusive attack .",
    "the second one is constructed based on uqc .",
    "it is proved that it is correct , blind , and can defeat collusive attack ."
  ],
  "abstract_text": [
    "<S> this paper proposes a model of tripartite blind quantum computation ( tbqc ) , in which three independent participants hold different resources and accomplish a computational task through cooperation . </S>",
    "<S> the three participants are called c , s , t separately , where c needs to compute on his private data , and t has the required quantum algorithm , and s provides sufficient quantum computational resources . </S>",
    "<S> then two concrete tbqc protocols are constructed . </S>",
    "<S> the first protocol is designed based on broadbent - fitzsimons - kashefi protocol , and it can not prevent from collusive attack of two participants . then based on universal quantum circuit , we present the second protocol which can prevent from collusive attack . in the latter protocol , for each appearance of @xmath0-gate in the circuit , one call to a classical and - box is required for privacy .    </S>",
    "<S> quantum cryptography , blind quantum computation , computing on encrypted data , universal quantum circuit , secure two - party computation </S>"
  ]
}