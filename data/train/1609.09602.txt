{
  "article_text": [
    "due to many recent technological advances in neuroscience , researchers ability to collect neural data has increased dramatically . with this",
    "comes a need for new methods to process and understand this data .",
    "one major question faced by researchers is to determine how the brain encodes spatial features of its environment through patterns of neural activity , as with place cell codes @xcite . in the recent paper @xcite , curto et al .",
    "phrase this question as , `` what can be inferred about the underlying stimulus space from neural activity alone ? '' to answer this question , curto et al . introduced the _ neural ring _ and a related _ neural ideal _ , algebraic objects that encode the full combinatorial data of a neural code .",
    "they further show that the neural ideal can be expressed in a _",
    "canonical form _ that directly translates to a minimal description of the receptive field structure intrinsic to the code .    in this article",
    "we describe a sagemath @xcite package that implements several algorithms to compute the neural ideal and its canonical form , featuring a new iterative algorithm which proves to be much more efficient than the original canonical form algorithm outlined by curto et al . in @xcite .",
    "this package also provides an algorithm to compute the primary decomposition of a pseudo - monomial ideal . accompanying these functions are others that calculate related objects , such as the grbner basis , grbner fan , universal grbner basis , and the neural ideal itself . in section [ background ]",
    "we give a short introduction to the algebraic geometry of neural codes .",
    "section [ iterative ] describes a new and improved algorithm to compute the canonical form of a neural ideal from a neural code .",
    "finally , section [ tutorial ] provides a tour of the functionality within our code , centered on the canonical form algorithm .",
    "in this section we give a brief introduction to the neural ring and the neural ideal of a neural code . a more thorough background , including necessary theorems and proofs ,",
    "can be found in @xcite .      a _ neural code _",
    "@xmath0 is a set of binary strings that represent neural activity .",
    "a ` @xmath1 ' represents a firing neuron , while a ` @xmath2 ' represents an idle neuron . for example",
    ", the presence of the word @xmath3 in a 4-neuron code would indicate an instance when neurons 1 , 3 , and 4 were firing but neuron 2 was not . given a neural code @xmath4 , the corresponding _ neural ideal _",
    "@xmath5 in the ring @xmath6 $ ] is defined by the following set of generators . for any @xmath7 ,",
    "consider the polynomial    @xmath8    notice that @xmath9 acts as a characteristic function for @xmath10 , since it satisfies @xmath11 and @xmath12 for any @xmath13 .",
    "the _ neural ideal _ @xmath14 $ ] associated to the neural code @xmath15 is the ideal generated by the polynomials @xmath16 with @xmath17 , that is , @xmath18      many systems of neurons react to stimuli which have a natural geographic association .",
    "one example is head direction cells in rats , where each neuron responds to a preferred range of angles ; these stimuli come from the 1-dimensional set of possible angles for the head .",
    "another example is place cells ( in rats ) , where each neuron is associated to a place field or region of the rat s 2-dimensional environment .",
    "in such a geographic setup , we would assume that if two neurons are observed to fire together , then the sets of stimuli for these neurons must overlap .",
    "the idea of a _ realization for a code _ formalizes these notions .",
    "suppose @xmath19 is a collection of open sets with each @xmath20 .",
    "here , @xmath21 represents the space of possible stimuli , and @xmath22 is the receptive field of the @xmath23 neuron , the set of stimuli which will cause that neuron to fire .",
    "we say that @xmath24 is a _ realization _ for a code @xmath15 , or that @xmath25 , if @xmath26    that is , @xmath15 represents the set of regions defined by @xmath24 .",
    "it turns out that by considering the ideal @xmath5 for the code @xmath15 , we can determine complete information about the interaction of the @xmath22 in any realization @xmath24 of @xmath15 .",
    "this is facilitated by the _",
    "canonical form _ of the neural ideal @xmath5 .",
    "a polynomial @xmath27 $ ] is a _ pseudo - monomial _ if @xmath28 has the form @xmath29 where @xmath30 .",
    "an ideal @xmath31 $ ] is a _ pseudo - monomial ideal _ if @xmath32 can be generated by a set of finitely many pseudo - monomials .",
    "let @xmath31 $ ] be an ideal , and @xmath33 a pseudo - monomial .",
    "then @xmath28 is a _ minimal pseudo - monomial _ of @xmath32 if there is no other pseudo - monomial @xmath34 with @xmath35 such that @xmath36 for some @xmath37 $ ] .",
    "the _ canonical form _ of a pseudo - monomial ideal @xmath32 , denoted @xmath38 , is the set of _ all _ minimal pseudo - monomials of @xmath32 .",
    "the set @xmath38 is unique for any given pseudo - monomial ideal @xmath32 and @xmath39 .",
    "it is important to note that even though @xmath38 is made up of minimal pseudo - monomials , it does not necessarily imply that @xmath38 is a minimal set of generators for @xmath32 .",
    "the neural ideal @xmath5 for a neural code @xmath15 is a pseudo - monomial ideal since @xmath40 and each of the @xmath16 s is a pseudo - monomial .",
    "the following theorem describes the set of relations on any realization @xmath24 of @xmath15 which @xmath38 provides .",
    "[ theorem : cf ] let @xmath41 be a neural code , and let @xmath42 be any collection of open sets in a stimulus space @xmath43 such that @xmath44 . given @xmath45 , let @xmath46 .",
    "then the _ canonical form _ of @xmath5 is : @xmath47    we call the above three ( disjoint ) sets of relations comprising @xmath48 the minimal type 1 , type 2 and type 3 relations , respectively .",
    "since the canonical form is unique , by theorem [ theorem : cf ] , any receptive field representation of the code @xmath49 satisfies the following relationships :    * @xmath50 implies @xmath51 , but all intersections @xmath52 where @xmath53 are non - empty .",
    "* @xmath54 implies @xmath55 , but no lower - order intersection is contained in @xmath56 and all the @xmath22s are needed for @xmath57 . *",
    "@xmath58 implies @xmath59 , but @xmath60 for any @xmath61 .",
    "in @xcite , the authors provided a first algorithm to obtain the canonical form via the primary decomposition of the neural ideal . here",
    "we present an alternative algorithm .",
    "rather than using the primary decomposition , this algorithm begins with the canonical form for a code consisting of a single codeword , and iterates by adding the remaining codewords one by one and adjusting the canonical form accordingly .",
    "we describe the process for adding in a new codeword in algorithm [ algo1 ] .    in summary ,",
    "each pseudo - monomial @xmath28 from @xmath48 for which @xmath62 is automatically in the new canonical form @xmath63 . for those pseudo - monomials @xmath64 with @xmath65",
    ", we consider the product of @xmath28 with all possible linear terms @xmath66 ( so this product will be @xmath2 when evaluated at @xmath67 ) as a possible candidate for @xmath48 ; but we remove any such products which are redundant . here , a redundant pseudo - monomial is one which is either a multiple of another already known to be in the canonical form , or which is a multiple of a boolean polynomial .    certainly , any polynomial @xmath28 output by this algorithm will have the property that @xmath68 for all @xmath69 . a proof that this algorithm outputs _ exactly _ @xmath70 is found in the appendix .",
    "we have developed sagemath code that computes the canonical form using this iterative algorithm ; see section [ tutorial ] for an in - depth tutorial of our package .",
    "we find that this iterative algorithm performs substantially better than the original algorithm from @xcite .",
    "we have also implemented our algorithm in matlab @xcite .",
    "table [ algo_runtimes ] displays some runtime statistics regarding our iterative canonical form algorithm .",
    "these runtime statistics were obtained by running our sagemath implementation on 100 randomly generated sets of codewords for each dimension @xmath71 .",
    "these computations were performed on sagemath 7.2 running on a macbook pro with a 2.8 ghz intel core i7 processor and 16 gb of memory .",
    "we performed a similar test for our implementation of the original canonical form algorithm in @xcite and on the matlab implementation of our iterative method .",
    "however , even in dimension @xmath72 the original algorithm performs poorly . in our tests",
    ", we found several codes for which the original algorithm took hundreds or even thousands of seconds to compute the canonical form .",
    "for example , the iterative algorithm takes 0.01 seconds to compute the canonical form of the code below , but the original method takes 1 hour and 8 minutes to perform the same computation .",
    "we also found several codes on dimension @xmath72 for which the original algorithm halted due to lack of memory .",
    "one such code is @xmath74 the iterative algorithm computes the canonical form of the previous code in @xmath75 seconds . in our matlab implementation",
    "we also found several examples in dimension @xmath76 for which the canonical form took thousands of seconds to be computed .",
    ".runtime statistics ( in seconds ) for the iterative cf algorithm in sagemath . [ cols=\"<,<,<,<,<,<\",options=\"header \" , ]     we found that , in general , the custom pseudo - monomial primary decomposition algorithm does not outperform the gianni - trager - zacharias algorithm .",
    "nevertheless , this procedure is implemented to be used in characteristic 0 .",
    "it also works in fields of large positive characteristic .",
    "but in small characteristic this procedure may not terminate .",
    "we also want to observe that the ` canonical ( ) ` method returns an ideal object whose generators are not factored and hence not easy to interpret in our context . in order to obtain the generators in the canonical form in factored form , we use ` factored_canonical ( ) ` :    .... sage : neuralcode.factored_canonical ( ) [ x2 * x1 , ( x1 + 1 ) * x0 , ( x2 + 1 ) * ( x1 + 1 ) , x2 * x0 ] ....    from this output we can easily read off the rf structure of the neural code .",
    "however , we also provide a different command that parses the output to explicitly describe the rf structure .",
    ".... sage : neuralcode.canonical_rf_structure ( ) intersection of u_['2 ' , ' 1 ' ] is empty x = union of u_['2 ' , ' 1 ' ] intersection of u_['0 ' ] is a subset of union of u_['1 ' ] intersection of u_['2 ' , ' 0 ' ] is empty ....    we can also compute the grbner basis and the grbner fan of the neural ideal .",
    "note that we could compute the neural ideal and use the built in ` groebner_basis ( ) ` method , but that approach will not impose the conditions of the boolean ring ( i.e. @xmath77 ) .",
    "our method uses the built - in ` groebner_basis ( ) ` command but also reduces modulo the boolean equations .    ....",
    "sage : neuralcode.groebner_basis ( ) ideal ( x0*x2 , x1 + x2 + 1 ) of multivariate polynomial ring in x0 , x1 , x2    over finite field of size 2 sage : neuralideal.groebner_basis ( ) [ x0*x2 , x1 + x2 + 1 , x2 ^ 2 + x2 ] ....    .... sage : neuralcode.groebner_fan ( ) [ ideal ( x1 + x2 + 1 , x0*x2 ) of multivariate polynomial ring in x0 , x1 , x2   over finite field of size 2 ] ....    a neural code is called _ convex _ if its codewords correspond to regions defined by an arrangement of convex open sets in euclidean space .",
    "convex codes have been observed experimentally in many brain areas . hence there has been increased interest in understanding what makes a neural code convex @xcite .",
    "it has also been observed that if a code is a simplicial complex then it is convex .",
    "one can check if a code is a simplicial complex with the command ` is_simplicial(codes ) ` :    .... sage : is_simplicial(['001','010','110 ' ] ) false sage : is_simplicial(['000','001','010','100','110','011','101','111 ' ] ) true   ....",
    "here , we show that the process described in algorithm [ algo1 ] gives @xmath63 from @xmath48 and @xmath67 . throughout , we use the following conventions and terminology : @xmath15 and @xmath78 are neural codes on the same number of neurons ; so , @xmath79 .",
    "a monomial @xmath80 is _ square - free _ if @xmath81 for all @xmath82 .",
    "a polynomial is _ square - free _ if it can be written as the sum of square - free monomials .",
    "for example : @xmath83 is square - free .",
    "there is a unique square - free representative of every equivalence class of @xmath6/\\langle x_i(1-x_i)\\rangle$ ] . for @xmath84",
    "$ ] , let @xmath85 denote this unique square - free representative of the equivalence class of @xmath86 in @xmath6/\\langle x_i(1-x_i ) \\rangle$ ] .",
    "then , for @xmath87 and @xmath88 , we define the set of _ reduced products _",
    "@xmath89 , j\\in [ s]\\}.\\ ] ] note that as pseudo - monomials are square - free , for each pair @xmath90 we have either @xmath91 or @xmath92 is a multiple of both @xmath93 and @xmath94 .",
    "we define the _ minimal reduced products _ as @xmath95      first , we show @xmath98 . for any @xmath99 , there is some @xmath100 and @xmath101 so @xmath102 . in particular , @xmath103 as @xmath86 is a multiple of @xmath93 , and @xmath104 as it is a multiple of @xmath94 .",
    "thus @xmath105 for all @xmath106 , so @xmath107 .",
    "suppose @xmath108 .",
    "then as @xmath109 , there is some @xmath110 so that @xmath111 , and likewise there is some @xmath112 so @xmath113 where @xmath114 are pseudo - monomials",
    ". thus @xmath86 is a multiple of @xmath92 and hence is a multiple of some element of @xmath115 . but as every element of @xmath115 is an element of @xmath116 , and @xmath117 , this means @xmath86 itself must actually be in @xmath115 .",
    "thus , @xmath118 .",
    "for the reverse containment , suppose @xmath119 ; by the above , @xmath120 it is thus the multiple of some @xmath121 .",
    "but we have shown that @xmath122 , which contains no multiples .",
    "so @xmath123 is in @xmath124 .      to show that the algorithm produces the correct canonical form",
    ", we apply lemma [ lem : cfalgorithm ] ; it suffices to show that the set @xmath128 is exactly @xmath129 .",
    "this requires that all products are considered , and that we remove exactly those which are multiples or other elements , or zeros .",
    "note that @xmath130\\}$ ] .    to see that all products are considered we will look at l and m separately .",
    "let @xmath131 .",
    "since @xmath132 , we know @xmath133 for at least one @xmath134 .",
    "so @xmath135 .",
    "any other product @xmath136 will either be @xmath2 , @xmath137 , or a multiple of @xmath137 , and hence will not appear in @xmath138 .",
    "thus , all products of linear terms with elements of @xmath139 are considered , and all multiples or zeros are removed .",
    "it is impossible for elements of @xmath139 to be multiples of one another , as @xmath140 .",
    "we also consider all products of elements of @xmath141 with the linear elements of @xmath142 . we discard them if their reduction would be 0 , or if they are a multiple of anything in @xmath139 .",
    "if neither holds , we add them to @xmath143 .",
    "so it only remains to show that no element of @xmath143 can be a multiple of any other element in @xmath143 , and no element of @xmath143 can be a multiple of anything in @xmath139 , and thus that we have removed all possible multiples .",
    "first , no element of @xmath143 may be a multiple of an element of @xmath139 , since if @xmath131 , @xmath144 , and @xmath145 for some pseudo - monomial @xmath146 , then @xmath147 .",
    "but this is impossible as @xmath148 are both in @xmath48 . now , suppose @xmath149 for @xmath150 and @xmath151 , and @xmath86 a pseudo - monomial .",
    "then as @xmath152 and @xmath153 , we have @xmath154 , and so @xmath155 . but this means @xmath156 and therefore @xmath157 , which is a contradiction .",
    "so no elements of @xmath143 may be multiples of one another .",
    "curto , c. , itskov , v. , veliz - cuba , a. , youngs , n. `` the neural ring : an algebraic tool for analyzing the intrinsic structure of neural codes . ''",
    "bulletin of mathematical biology , volume 75 , issue 9 , pp .",
    "1571 - 111 , 2013"
  ],
  "abstract_text": [
    "<S> a major area in neuroscience research is the study of how the brain processes spatial information . </S>",
    "<S> neurons in the brain represent external stimuli via neural codes . </S>",
    "<S> these codes often arise from stereotyped stimulus - response maps , associating to each neuron a convex receptive field . </S>",
    "<S> an important problem consists in determining what stimulus space features can be extracted directly from a neural code . </S>",
    "<S> the neural ideal is an algebraic object that encodes the full combinatorial data of a neural code . </S>",
    "<S> this ideal can be expressed in a canonical form that directly translates to a minimal description of the receptive field structure intrinsic to the code . in here </S>",
    "<S> , we describe a sagemath package that contains several algorithms related to the canonical form of a neural ideal . </S>"
  ]
}