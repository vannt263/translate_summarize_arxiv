{
  "article_text": [
    "classical planning assumes that agents have complete information about the world . for this reason",
    ", it is often labeled as unrealistic because agents operating in real - world environment often do not have complete information about their environment .",
    "two important questions arise when one wants to remove this assumption : _ how to reason about the knowledge of agents _ and _ what is a plan _ in the presence of incomplete information .",
    "the first question led to the development of several approaches to reasoning about effects of sensing ( or knowledge producing ) actions @xcite .",
    "the second question led to the notions of _ conditional plan _ and _ conformant plan _ whose execution is guaranteed to achieve the goal regardless of the values of unknown fluents in the initial situation .",
    "the former contains sensing actions and conditionals such as the well - known `` if - then - else '' or `` cases '' construct , while the latter is just a sequence of actions . in this paper",
    ", we refer to _ conditional planning _ and _ conformant planning _ as planning approaches that generate conditional plans and conformant plans , respectively .",
    "we use _ plan _ as a generic term for both conditional and conformant plan when the distinction between the two is not important .",
    "approaches to conditional planning can be characterized by the techniques employed in their search process or by the action formalism that supports their reasoning process .",
    "most of the early conditional planners implemented a partial - order planning algorithm @xcite and used situation calculus or strips as their underlying formalism in representing and reasoning about actions and their effects . among them , coplas @xcite , which is implemented in sicstus prolog , is a regression planner that uses a high - level action description language to represent and reason about effects of actions , including sensing actions ; and flux @xcite , a constraint logic programming based planner , is capable of generating and verifying conditional plans .",
    "another conditional planner based on a qbf theorem prover was developed in @xcite .",
    "some other planners , for example , sgp @xcite or pond @xcite , extended the planning graph algorithm @xcite to deal with sensing actions .",
    "the main difference between sgp and pond is that the former searches solutions within the planning graph , whereas the latter uses it as a means of computing the heuristic function .",
    "conformant planning @xcite is another approach to deal with incomplete information . in conformant",
    "setting , a solution is simply a sequence of actions that achieves the goal from every possible initial situation .",
    "a recent study @xcite shows that conformant planning based on model checking is computationally competitive with other approaches to conformant planning such as those based on heuristic search algorithms @xcite or those that extend graphplan @xcite .",
    "a detailed comparison in @xcite demonstrates that a logic programming based conformant planner is able to compete with other approaches to planning .",
    "the most important difference between conditional planners and conformant planners lies in the fact that conditional planners can deal with sensing actions whereas conformant planners can not .",
    "consequently , there are planning problems solvable by conditional planners but not by conformant planners .",
    "the following example demonstrates this issue .",
    "[ ex01 ] consider a security window with a lock that behaves as follows .",
    "the window can be in one of the three states _ opened , closed _ or _",
    "locked_. when the window is closed or opened , pushing it _ up _ or _ down",
    "_ will _ open _ or _ close _ it respectively . when the window is closed or locked , flipping the lock will lock or close it respectively .    now , consider a security robot that needs to make sure that the window is locked after 9 pm .",
    "suppose that the robot has been told that the window is not open ( but whether it is locked or closed is unknown ) .",
    "intuitively , the robot can achieve its goal by performing the following steps .",
    "first , ( 1 ) it checks the window to determine the window s status .",
    "if the window is closed , ( 2.a ) it locks the window ; otherwise ( i.e. , the window is already locked ) , simply ( 2.b ) it does nothing .    observe that no sequence of actions can achieve the goal from every possible initial situation . in other words ,",
    "_ there exists no conformant plan _ achieving the goal .    in this paper , we investigate the application of _ answer set programming _ ( see e.g. @xcite ) in conformant and conditional planning . to achieve our goal",
    ", we first define an approximation semantic for action theories with static causal laws and sensing actions based on the 0-approximation in @xcite .",
    "it is an alternative to the possible world semantics for reasoning about effects of actions in the presence of incomplete information and sensing actions @xcite .",
    "the basic idea of this approach is to _ approximate _ the set of possible world states by a set of fluent literals that is true in every possible world state .",
    "the main advantage of the approximation - based approach is its low complexity in reasoning and planning tasks ( * np*-complete ) comparing to those based on the possible world semantics @xmath0-complete @xcite .",
    "the trade - off for this low complexity is incompleteness . as we will demonstrate in our experiments ,",
    "this is not really an issue with the benchmarks in the literature .",
    "we prove that the entailment relationship for action theories based on this approximation is sound with respect to the possible world semantics for action theories with incomplete initial situation .",
    "we then show that the planning problem with respect to the newly developed approximation is * np*-complete .",
    "this facilitates the development of , an answer set programming based planner that is capable of generating both conditional and conformant plans .",
    "given a planning problem instance with incomplete information about the initial situation and sensing actions , we translate it into a logic program whose answer sets @xcite  which can be computed using existing answer set solvers ( e.g.  @xcite ,  @xcite , * dlv * @xcite , assat @xcite , nomore @xcite , etc . )",
    " correspond to conformant or conditional plans that satisfy the goal .",
    "we compare our planner against state - of - the - art planners .",
    "the results of our experiments show that conditional and conformant planning based on answer set programming can be competitive with other approaches . to the best of our knowledge , no answer set based conditional planner has been developed except a previous version of the planner presented in an earlier version of this paper @xcite .",
    "the paper is organized as follows .",
    "section [ preliminaries ] presents the basics of an action language with sensing actions and static causal laws , including its syntax and the 0-approximation , as well as the notions of conditional plans and queries .",
    "it also contains the complexity result of the conditional planning problem with respect to the 0-approximation .",
    "section [ planner ] describes a logic programming encoding of a conditional / conformant planner , called .",
    "section [ property ] discusses several properties of .",
    "section [ experiments ] experimentally compares  with some other state - of - the - art conformant / conditional planners .",
    "section [ conclusion ] discusses some desirable extensions of the current work .",
    "the proofs of theorems and propositions are given in appendices a and b. an example of encoding is given in appendix c.",
    "the representation language , @xmath2 , for our planner is an extension of the action language @xmath3 in @xcite .",
    "while @xmath3 extends the high - level action description language @xmath4 from @xcite by introducing two new types of propositions called _ knowledge producing proposition _ and the _ executability condition _ , @xmath2 extends @xmath3 by adding _",
    "static causal laws _ and allowing a sensing action to sense more than one fluent . loosely speaking",
    ", @xmath2 is a subset of the language @xmath5 in @xcite .",
    "nevertheless , like @xmath3 , @xmath5 considers sensing actions that sense only one fluent .",
    "the semantics given for @xmath2 in this paper is an approximation of the semantics of @xmath5 .",
    "the alphabet of an action theory in @xmath2 consists of a set of actions * a * and a set of fluents * f*. a _",
    "fluent literal _ ( or _ literal _ for short ) is either a fluent @xmath6 or its negation @xmath7 . @xmath8 and @xmath7 are said to be complementary . for a literal @xmath9 , by @xmath10 , we mean its complement .",
    "fluent formula _ is a propositional formula constructed from the set of literals using operators @xmath11 , @xmath12 , and/or @xmath13 . to describe an action theory ,",
    "propositions of the following forms are used : @xmath14 where @xmath15 is an action , @xmath9 is a literal , and @xmath16 are sets of literals denotes _",
    "true_. ] .",
    "the initial situation is described by a set of propositions ( [ init ] ) , called _ v - propositions_. ( [ init ] ) says that @xmath9 holds in the initial situation .",
    "a proposition of form ( [ exec ] ) is called _",
    "executability condition_. it says that @xmath17 is executable in any situation in which @xmath18 holds ( the precise meaning of _ hold _ will be given later ) .",
    "a proposition ( [ dynamic ] ) , called a _ dynamic causal law _ , represents a conditional effect of an action .",
    "it says that performing @xmath17 in a situation in which @xmath19 holds causes @xmath9 to hold in the successor situation . a proposition ( [ static ] ) , called a _ static causal law _ , states that @xmath9 holds in any situation in which @xmath20 holds .",
    "a _ knowledge proposition _ ( or _ k - proposition _ for short ) ( [ knowledge ] ) states that the values of literals in @xmath21 , sometimes referred to as _ sensed - literals _ , will be known after @xmath17 is executed . because the execution of @xmath17 will determine the truth value of at least one fluent , without loss of generality , we assume that @xmath21 contains at least two literals . furthermore",
    ", we require that if @xmath21 is not a set of two contrary literals @xmath8 and @xmath7 then the literals in @xmath21 are mutually exclusive , i.e. ,    1 .   for every pair of literals @xmath22 and @xmath23 in @xmath21 , @xmath24 , the theory contains the static causal law @xmath25 and 2 .   for every literal @xmath22 in @xmath21 ,",
    "the theory contains the static causal law @xmath26    for convenience , we use the abbreviation @xmath27 to denote the above set of static causal laws . apart from this",
    ", we will sometime write @xmath28 to stand for @xmath29    actions appearing in ( [ dynamic ] ) and ( [ knowledge ] ) are called non - sensing actions and sensing actions , respectively . in this paper , we assume that they are disjoint from each other .",
    "in addition , we also assume that each sensing action appears in at most one k - proposition .",
    "action theory _ is given by a pair @xmath30 where @xmath31 is a set of propositions ( [ exec])([knowledge ] ) and @xmath32 is a set of propositions ( [ init ] ) . @xmath31 and @xmath32 are called the _ domain description _ and _ initial situation _",
    ", respectively .",
    "a _ planning problem instance _ is a 3-tuple @xmath33 , where @xmath30 is an action theory and @xmath34 is a _ conjunction _ of fluent literals .",
    "it is worth mentioning that with a proper set of rules for checking the truth value of a fluent formula ( see e.g. @xcite ) , the framework and all results presented in this paper can be extended to allow @xmath34 to be an arbitrary fluent formula as well .",
    "[ ex04 ] the planning problem instance @xmath35 in example [ ex01 ] can be represented as follows .",
    "@xmath36 @xmath37 @xmath38    for an action theory @xmath39 , @xmath40 implies that literal @xmath9 holds in every situation .",
    "since @xmath9 is always true , queries about the truth value of @xmath9 ( or @xmath41 ) have a trivial answer and the theory can be simplified by removing all instances of @xmath9 in other propositions .",
    "furthermore , if the theory also contains a dynamic law of the form @xmath42 then the execution of @xmath17 in a state satisfying @xmath19 will result in an inconsistent state of the world .",
    "thus , the introduction of @xmath9 in the action theory is either redundant or erroneous .",
    "for this reason , without loss of generality , we will assume that action theories in this paper do not contain any static causal law ( [ static ] ) with @xmath43 .",
    "since an empty plan can always be used to achieve an empty goal , we will assume hereafter that planning problem instances considered in this paper have non - empty goals .      in the presence of incomplete information and sensing actions , we need to extend the notion of a plan from a sequence of actions so as to allow conditional statements such as * if - then - else * , * while - do * , or * case - endcase * ( see e.g. @xcite ) .",
    "notice that an if - then - else statement can be replaced by a case - endcase statement .",
    "besides , if we are only interested in plans with bounded length then whatever can be represented by a while - do statement with a non - empty body can also be represented by a set of case - endcase statements as well .",
    "therefore , in this paper , we limit ourselves to conditional plans with the case - endcase construct only .",
    "formally , we consider conditional plans defined as follows .",
    "we note that our notion of conditional plans in this paper is fairly similar to the ones introduced in @xcite .",
    "[ condplan ]    * @xmath44 $ ] is a conditional plan , denoting the empty plan , i.e. , the plan containing no action . *",
    "if @xmath17 is a non - sensing action and @xmath45 is a conditional plan then @xmath46 $ ] is a conditional plan . *",
    "if @xmath17 is a sensing action with proposition ( [ knowledge ] ) , where @xmath47 , and @xmath48 s are conditional plans then @xmath49 $ ] is a conditional plan . *",
    "nothing else is a conditional plan .    by this definition , clearly a sequence of actions is also a conditional plan .",
    "the execution of a conditional plan of the form @xmath46 $ ] , where @xmath17 is a non - sensing action and @xmath45 is another conditional plan , is done sequentially , i.e. , @xmath17 is executed first , followed by @xmath45 . to execute a conditional plan of the form @xmath49 $ ] , we first execute @xmath17 and then evaluate each @xmath50 with respect to our current knowledge . if one of the @xmath50 s , say @xmath51 , holds , we execute the corresponding sub - plan @xmath52 .",
    "observe that because fluent literals in @xmath21 are mutual exclusive , such @xmath51 uniquely exists .",
    "[ ex07 ] the following are conditional plans of the action theory in example [ ex04 ] : @xmath53 \\label{plan_1}\\ ] ] @xmath54 \\\\ closed & \\rightarrow & [ flip\\_lock ] \\\\ locked & \\rightarrow & [ ] \\end{array } \\right)\\ ] ] @xmath55 \\\\ closed & \\rightarrow & [ flip\\_lock;flip\\_lock;flip\\_lock ] \\\\ locked & \\rightarrow & [ ] \\end{array } \\right)\\ ] ] @xmath56 \\\\ closed & \\rightarrow & p_2 \\\\ locked & \\rightarrow & [ ] \\end{array } \\right)\\ ] ] among those , @xmath57 , @xmath58 and @xmath59 are conditional plans that achieve the goal @xmath60 and @xmath59 can achieve the goal because the first case `` the window is open '' _ can not _ happen ] .    in the rest of the paper , the terms `` plan '' and `` conditional plan '' will be used alternatively .",
    "a query posed to an @xmath2 action theory @xmath30 is of the form @xmath61 or @xmath62 where @xmath45 is a conditional plan and @xmath63 is a fluent formula .",
    "intuitively , the first ( resp .",
    "second ) query asks whether @xmath63 is true ( resp .",
    "known ) after the execution of @xmath45 from the initial situation .",
    "we now define an approximation semantics of @xmath2 , called 0-approximation , which extends the 0-approximation in @xcite to deal with static causal laws .",
    "it is defined by a transition function @xmath64 that maps actions and a - states into sets of a - states ( the meaning of a - states will follow ) . before providing the formal definition of the transition function ,",
    "we introduce some notations and terminology .    for a set of literals @xmath65",
    ", @xmath66 denotes the set @xmath67 .",
    "@xmath65 is said to be _ consistent _ if it does not contain two complementary literals . a literal @xmath9 ( resp .",
    "set of literals @xmath68 ) _ holds _ in a set of literals @xmath65 if @xmath69 ( resp .",
    "@xmath70 ) ; @xmath9 ( resp .",
    "@xmath68 ) _ possibly holds _ in @xmath65 if @xmath71 ( resp .",
    "@xmath72 ) .    given a consistent set of literals @xmath65 , the truth value of a formula @xmath63 , denoted by @xmath73 , is defined as follows . if @xmath74 for some literal @xmath9 then @xmath75 if @xmath69 ; @xmath76 if @xmath77 ; @xmath78 otherwise . if @xmath79 then @xmath75 if @xmath80 and @xmath81 ; @xmath76 if @xmath82 or @xmath83 ; @xmath78 otherwise .",
    "if @xmath84 then @xmath75 if @xmath80 or @xmath81 ; @xmath76 if @xmath82 and @xmath83 ; @xmath78 otherwise . if @xmath85 then @xmath75 if @xmath82 ; @xmath76 if @xmath80 ; @xmath78 otherwise .",
    "we say that @xmath63 is known to be true ( resp .",
    "false ) in @xmath65 and write @xmath86 ( resp .",
    "@xmath87 ) if @xmath75 ( resp .",
    "@xmath76 ) .",
    "when @xmath86 or @xmath88 we say that @xmath63 is _ known _ in @xmath65 ; otherwise , @xmath63 is _ unknown _ in @xmath65 .",
    "we will say that @xmath63 holds in @xmath65 if it is known to be true in @xmath65 .    a set of literals @xmath65 satisfies a static causal law ( [ static ] ) if either ( i ) @xmath20 does not hold in @xmath65 ; or ( ii ) @xmath9 holds in @xmath65 ( i.e. , @xmath20 holds in @xmath65 implies that @xmath9 holds in @xmath65 ) .",
    "by @xmath89 , we denote the smallest set of literals that includes @xmath65 and satisfies all static causal laws in @xmath90 .",
    "note that @xmath89 might be inconsistent but it is unique ( _ see _ lemma [ lm1 ] , appendix a ) .    an _ interpretation _",
    "@xmath91 of a domain description @xmath31 is a complete and consistent set of literals in @xmath31 , i.e. , for every fluent @xmath6 , ( i ) @xmath92 or @xmath93 ; and ( ii ) @xmath94 .    a _ state _",
    "@xmath95 is an interpretation satisfying all static causal laws in @xmath31 .",
    "an action @xmath17 is _ executable _ in @xmath95 if there exists an executability condition ( [ exec ] ) such that @xmath18 holds in @xmath95 . for a non - sensing action @xmath17 executable in @xmath95 ,",
    "let @xmath96 the set @xmath97 is often referred to as the _ direct effects _ of @xmath17 . when the agent has complete information about the world , the set of possible next states after the execution of @xmath17 in @xmath95 , denoted by @xmath98 , is defined as follows .",
    "[ possible next states , @xcite ] [ def_compl ] let @xmath90 be a domain description . for any state @xmath95 and non - sensing action @xmath17 executable in @xmath95 , @xmath99 .",
    "the intuitive meaning of this definition is that a literal @xmath9 holds in a possible next state @xmath100 of @xmath95 after @xmath17 is executed iff either ( i ) it is a direct effect of @xmath17 , i.e. , @xmath101 ( ii ) it holds by inertia , i.e. , @xmath102 , or ( iii ) it is an indirect effect of @xmath17 , i.e. , @xmath9 holds because of the operator @xmath103 .",
    "note that the @xmath104-function can be _ non - deterministic _ , i.e. , @xmath105 might contain more than one element .",
    "the following example illustrates this point .",
    "[ ex10 ] consider the following domain description @xmath106 let @xmath107 .",
    "clearly @xmath95 is a state since it satisfies all static laws in @xmath108 . executing @xmath17 in @xmath95 results in two possible next states @xmath109 in the first possible next state @xmath110",
    ", @xmath8 holds because it is a direct effect of @xmath17 , i.e. , @xmath111 ; @xmath112 and @xmath113 hold because of inertia ( @xmath114 ) ; and @xmath115 holds because it is an indirect effect of @xmath17 ( in particular , @xmath115 holds because of the static causal law @xmath116 ) .    likewise , we can explain why each literal in the second possible next state holds .",
    "[ consistent domains ] [ def_cons ] a domain description @xmath31 is _ consistent _ if for every state @xmath95 and action @xmath17 executable in @xmath95 , @xmath117 .    in the presence of incomplete information , an agent , however , does not always know exactly which state it is currently in . one possible way to deal with this problem is to represent the agent knowledge by a set of possible states ( a.k.a .",
    "belief state ) that are consistent with the agent s current knowledge and extend definition [ def_compl ] to define a mapping from pairs of actions and belief states into belief states as in @xcite .",
    "the main problem with this approach is its high complexity @xcite , even for the computation of what is true / false after the execution of one action .",
    "we address this problem by defining an approximation of the set of states in definition [ def_compl ] as follows .",
    "first , we relax the notion of a state in definition [ def_compl ] to be an approximate state defined as follows .",
    "[ approximate state ] a consistent set of literals @xmath118 is called an approximate state ( or _ a - state _ , for short ) if @xmath118 satisfies all static causal laws in @xmath31 .",
    "intuitively , @xmath118 represents the ( possibly incomplete ) current knowledge of the agent ,",
    "i.e. , it contains all fluent literals that are known to be true to the agent .",
    "when @xmath118 is a subset of some state @xmath95 , we say that it is _",
    "valid_. an action @xmath17 is _ executable _ in @xmath118 if there exists an executability condition ( [ exec ] ) in @xmath31 such that @xmath18 holds in @xmath118 .",
    "next , we define what are the possible next a - states after the execution of an action @xmath17 in a given a - state @xmath118 , provided that @xmath17 is executable in @xmath118 .",
    "consider the case that @xmath17 is a non - sensing action .",
    "let @xmath119 and @xmath120 where @xmath121 and for @xmath122 , @xmath123 intuitively , @xmath124 and @xmath125 denote what _ definitely holds _ and what _ may change _ in the next situation respectively .",
    "is used in the definition of @xmath124 to _ maximize _ what definitely holds in the next situation . ]",
    "specifically , @xmath126 means that @xmath9 holds in the next situation and @xmath127 means that @xmath9 is not in @xmath118 but possibly holds in the next situation .",
    "this implies that @xmath128 is an approximation of the set of literals that hold by inertia after the execution of @xmath17 in @xmath118 .",
    "taking into account the effects of the static causal laws , we have that the set of literals @xmath129 must hold in the next situation .",
    "this leads us to the following definition of the possible next a - states after a non - sensing action gets executed .",
    "[ 0-result function ] [ res ] for every a - state @xmath118 and non - sensing action @xmath17 executable in @xmath118 , let @xmath130 define    1 .",
    "@xmath131 if @xmath132 is consistent .",
    "@xmath133 if @xmath132 is inconsistent .",
    "the next examples illustrate this definition .",
    "[ ex13 ]    consider the domain description @xmath134 in example [ ex04 ] .",
    "let @xmath135 .",
    "we can easily check that @xmath118 is an a - state of @xmath136 .",
    "we have @xmath137 and @xmath138 because @xmath139 , and @xmath140 , by ( [ pc_a_k ] ) , we have @xmath141 note that @xmath142 because it is already in @xmath118 .",
    "it is easy to see that @xmath143 for all @xmath144 .",
    "hence , we have @xmath145 accordingly , we have @xmath146 @xmath147    [ ex14 ] for the domain description @xmath108 in example [ ex10 ] , we have @xmath148 @xmath149 as @xmath150 and @xmath151 , we have @xmath152 note that @xmath153 since @xmath7 does not hold in @xmath154 .",
    "we can check that @xmath155 for all @xmath144 .",
    "hence , we have @xmath156 as a result , we have @xmath157    the following proposition shows that when a non - sensing action is executed , the @xmath158-function is _ deterministic _ in the sense that it returns at most one possible next a - state ; furthermore , it is `` sound '' with respect to the @xmath159-function .",
    "[ prop - res - nonsense ] let @xmath31 be a consistent domain description . for any state @xmath95 , a - state @xmath160 , and non - sensing action @xmath17 executable in @xmath118 , there exists an a - state @xmath132 such that ( i ) @xmath161 , and ( ii ) @xmath132 is a subset of every state @xmath162 .",
    "_ see appendix a_.    we have specified what are the possible next a - states after a non - sensing action is performed .",
    "let us move to the case when a sensing action is executed .",
    "consider an a - state @xmath118 and a sensing action @xmath17 with k - proposition ( [ knowledge ] ) in @xmath31 .",
    "intuitively , after @xmath17 is executed , the agent will know the values of literals in @xmath21 .",
    "thus , the set of possible next a - states can be defined as follows .",
    "[ 0-result function ] [ res - sense ] for every a - state @xmath118 and sensing action @xmath17 with proposition ( [ knowledge ] ) such that @xmath17 is executable in @xmath118 , @xmath163    roughly speaking , executing @xmath17 will result in several possible next a - states , in each of which exactly one sensed - literal in @xmath21 holds . however , some of them might be inconsistent with what is currently known .",
    "for example , if the security robot in example [ ex01 ] knows that the window is not open then after it _ checks _ the window , it should not consider the case that the window is _ open _ because this is inconsistent with its current knowledge .",
    "thus , in defining the set of possible next a - states resulting from the execution of a sensing action , we need to exclude such inconsistent a - states .",
    "the following example illustrates this .",
    "[ ex16 ] consider again the domain description @xmath134 in example [ ex04 ] and an a - state @xmath164 .",
    "we have @xmath165 @xmath166 @xmath167 among those , @xmath168 is inconsistent .",
    "therefore , we have @xmath169    the next proposition shows that if a sensing action is performed in a valid a - state then the set of possible next a - states will contain at least one valid a - state .",
    "this corresponds to the fact that if the current knowledge of the world of the agent is consistent with the state of the world , it will remain consistent with the state of the world after the agent acquires additional knowledge through the execution of a sensing action .",
    "[ prop - res - sense ] let @xmath31 be a consistent domain description . for any a - state @xmath118 , and a sensing action @xmath17 executable in @xmath118 ,",
    "if @xmath118 is valid then @xmath170 contains at least one valid a - state .",
    "_ see appendix a_.    the transition function @xmath64 that maps actions and a - states into sets of a - states is defined as follows .",
    "[ transition function ] [ trans ] given a domain description @xmath31 , for any action @xmath17 and a - state @xmath118 ,    * if @xmath17 is not executable in @xmath118 then @xmath171 * otherwise , @xmath172    the transition function @xmath64 returns the set of possible next a - states after performing a single action in a given a - state .",
    "we now extend it to define the set of possible next a - states after the execution of a plan .",
    "the extended transition function , called @xmath173 , is given in the following definition .",
    "[ extended transition function ] [ d : weak : extend ] given a domain description @xmath31 , for any plan @xmath45 and a - state @xmath118 ,    * if @xmath174 $ ] then @xmath175 * if @xmath176 $ ] , where @xmath17 is a non - sensing action and @xmath177 is a sub - plan , then @xmath178 * if @xmath179 $ ] , where @xmath17 is a sensing action and @xmath48 s are sub - plans , then @xmath180    where , by convention , @xmath181 .    items ( 2 ) and ( 3 ) of the above definition deserve some elaboration .",
    "[ rem - nonsense ] during the execution of a plan @xmath45 , when a non - sensing action @xmath17 is encountered ( item 2 ) , by definitions [ res ] and [ trans ] , there are three possibilities : @xmath182 , @xmath183 , or @xmath184 for some a - state @xmath132 .",
    "if the first case occurs then the result of execution of @xmath45 in @xmath118 by the definition is also @xmath185 . in this case",
    ", we say that @xmath45 is not executable in @xmath118 ; otherwise , @xmath45 is _ executable _ in @xmath118 .",
    "if the second case occurs then by the definition , @xmath186 .",
    "one may notice that , by proposition [ prop - res - nonsense ] , this case takes place only if there exists no state @xmath95 such that @xmath187 ( i.e. , @xmath118 is invalid ) , or the domain is inconsistent .",
    "when @xmath184 , then the result of the execution of @xmath45 in @xmath118 is exactly as the result of the execution of the rest of @xmath45 in @xmath132 .",
    "[ rem - sense ] if @xmath179 $ ] , where @xmath17 is a sensing action and @xmath48 s are sub - plans ( item 3 ) , and @xmath188 then by definitions [ res - sense ] and [ trans ] , we know that @xmath189 may contain several a - states @xmath190 s .",
    "each @xmath190 corresponds to an a - state in which literal @xmath50 holds .",
    "therefore , we define @xmath191 to be the union of the sets of possible a - states that are the results of the execution of @xmath48 in @xmath190 .",
    "note that when we add @xmath50 to the current state @xmath118 to generate @xmath190 , we _ assume _ that @xmath50 holds . however , if later on , during the execution of the rest of @xmath45 , which is @xmath48 , we discover that @xmath192 , then our assumption about @xmath50 is not correct",
    ". therefore , such a @xmath190 contributes nothing to the set of possible a - states of @xmath193 . to see how this can happen ,",
    "consider the following domain description    @xmath194    and suppose that the set of fluents is @xmath195 .",
    "let us see what are the final possible a - states after the execution of plan @xmath196 $ ] in a - state @xmath197 as defined by the extended transition function .",
    "when @xmath17 is performed , we generate two possible next a - states @xmath198 , and @xmath199 . executing @xmath200 in @xmath201 results in no possible next a - state because @xmath202 is not consistent .",
    "this means that @xmath203 , and thus @xmath204,\\delta_2)$ ] , become @xmath205 .",
    "therefore , the set of possible final a - states is @xmath206,\\delta_1)= \\{\\{f , g , h \\}\\}$ ] .",
    "note that in this example , we did not notice that @xmath201 is inconsistent at the time the action @xmath17 was performed .",
    "rather , its inconsistency was only realized after the execution of @xmath200 . in other words ,",
    "our assumption that @xmath7 holds was not correct .",
    "similarly to the execution of a non - sensing action , when a sensing action @xmath17 is performed , by proposition [ prop - res - sense ] , @xmath183 only if the domain is inconsistent or @xmath118 is invalid .",
    "the above remarks imply that in some cases , for a plan @xmath45 and an a - state @xmath118 , @xmath191 may be empty .",
    "intuitively , this is because either @xmath118 is invalid or the domain is inconsistent .",
    "we will show that under reasonable assumptions about @xmath118 and the domain , this can not happen .",
    "[ consistent action theories ] an action theory @xmath30 is _ consistent _ if @xmath31 is consistent and its initial a - state , defined by @xmath207 , is valid .",
    "the next proposition says that the execution of an executable plan from a valid a - state of a consistent action theory will result in at least one valid a - state .",
    "[ prop - cons - action - theory ] let @xmath30 be a consistent action theory and let @xmath118 be its initial a - state . for every conditional plan @xmath45 , if @xmath208 then @xmath191 contains at least one valid a - state .    _ see appendix a_.    the above proposition implies that if the action theory @xmath30 is consistent and @xmath118 is its initial a - state then the execution of @xmath45 in @xmath118 will yield at least a valid trajectory , such that @xmath209 for @xmath210 ; a trajectory is valid if @xmath211 s are valid a - states .",
    "] , provided that @xmath45 is executable in @xmath118 .",
    "this is consistent with the fact that if the initial a - state is complete ( i.e. , if we have complete information ) then the execution of an executable plan in the initial a - state would return a valid trajectory . _ from now on , we only consider consistent action theories .",
    "_    we next define the entailment relationship between action theories and queries .",
    "[ entailment ] [ 0ent ] let @xmath30 be an action theory and @xmath118 be its initial a - state .",
    "for a plan @xmath45 and a fluent formula @xmath63 , we say that    * @xmath30 entails the query @xmath212 and write @xmath213 if @xmath214 and @xmath63 is true in every a - state in @xmath215 ; and * @xmath30 entails the query @xmath216 and write @xmath217 if @xmath214 and @xmath63 is known in every a - state in @xmath215 .",
    "[ ex19 ] for the action theory @xmath218 in example [ ex04 ] , we will show that @xmath219 where @xmath57 is given in example [ ex07 ] .",
    "let @xmath220 $ ] , @xmath221 $ ] and @xmath222 $ ] .",
    "it is easy to see that the initial a - state of @xmath218 is @xmath223 .",
    "it follows from example [ ex16 ] that @xmath224    on the other hand , we have @xmath225 and @xmath226    therefore , we have @xmath227    since @xmath228 is true in @xmath229 , we have ( [ ex04_plan_2 ] ) holds . on the other hand , because @xmath230 is false in @xmath229 , we have @xmath231 likewise , we can prove that @xmath232    [ solutions ] [ solutions ] a plan @xmath45 is called a _",
    "solution _ to a planning problem instance @xmath233 iff @xmath234 when @xmath45 is a solution to @xmath235 , we say that @xmath45 is a plan that _ achieves _ the goal @xmath34 .",
    "according to this definition , it is easy to see that plans @xmath57 , @xmath58 , and @xmath59 in example [ ex07 ] are solutions to @xmath35 in example [ ex04 ] .",
    "we will now discuss some properties of the 0-approximation . for a domain description @xmath31",
    ", we define the size of @xmath31 to be the sum of _ ( 1 ) _ the number of fluents ; _ ( 2 ) _ the number of actions ; and _ ( 3 ) _ the number of propositions in @xmath31 .",
    "the size of a planning problem instance @xmath233 is defined as the size of @xmath31 .",
    "the size of a plan @xmath45 , denoted by @xmath236 , is defined as follows .    1",
    ".   @xmath237 ) = 0 $ ] ; 2 .",
    "@xmath238 ) = 1 + size(p)$ ] if @xmath17 is a non - sensing action and @xmath45 is a plan ; and 3 .",
    "@xmath239 )   = 1 + \\sigma^n_{j=1 } ( 1 + size(p_j))$ ] if @xmath17 is a sensing action and @xmath48 s are plans .",
    "then , we have the following proposition .    [ prop - trans1 ] for a domain description @xmath31 , an action @xmath17 , and an a - state @xmath118",
    ", computing @xmath189 can be done in polynomial time in the size of @xmath31 .",
    "_ see appendix a. _    from this proposition , we have the following corollary .",
    "[ cor1 ] determining whether or not a plan @xmath45 is a solution of the planning problem instance @xmath240 from an a - state @xmath118 can be done in polynomial time in the size of @xmath45 and @xmath235 .",
    "the _ conditional planning problem _ is defined as follows .    * _ given : _ a planning problem instance @xmath233 of size @xmath241 and a polynomial @xmath242 ; * _ determine : _ whether there exists a conditional plan , whose size is bounded by @xmath243 , that achieves @xmath34 from @xmath32 ( with respect to definition [ solutions ] ) .",
    "[ t - pp ] the conditional planning problem is * np*-complete .",
    "_ see appendix a_.    the above theorem shows that planning using the 0-approximation has lower complexity than planning with respect to the full semantics . here , by the full semantics we mean the possible world semantics extended to domains with sensing actions .",
    "yet , the price one has to pay is the incompleteness of this approximation , i.e. , there are planning instances which have solutions with respect to the full semantics but do not have solutions with respect to the approximation .",
    "this can be seen in the following example .",
    "[ incomplete ] consider the planning problem instance @xmath244 with @xmath245 we can easily check that @xmath246 $ ] is a plan achieves @xmath8 from every initial situation ( with respect to the possible world semantics developed for @xmath2 in @xcite ) .",
    "however , @xmath45 is not a solution with respect to definition [ solutions ] , because @xmath247 .",
    "the above example highlights the main weakness of this approximation in that it does not allow for reasoning by cases for non - sensing actions or in the presence of disjunctive initial situation . in our experiments with the benchmarks",
    ", we observe that most of the benchmarks that our planner could not solve fall into the second category , i.e. , they require the capability of reasoning with disjunctive information about the initial state .",
    "given that we do not consider action theories with disjunctive initial state , this should not come as a surprise .",
    "this section describes an answer set programming based conditional planner , called . given a planning problem instance @xmath233 , we translate it into a logic program @xmath248 , where @xmath115 and @xmath249 are two input parameters whose meanings will become clear shortly , and then use an answer set solver ( e.g. ,  or ) to compute its answer sets .",
    "the answer sets of @xmath248 represent solutions to @xmath235 .",
    "our intuition behind this task rests on the observation that each plan @xmath45 ( definition [ condplan ] ) corresponds to a labeled plan tree @xmath250 defined as below .",
    "@xmath251    if @xmath45",
    "= [ ] then @xmath250 is a tree with a single node .    if @xmath252 $ ] , where @xmath17 is a non - sensing action",
    ", then @xmath250 is a tree with a single node and this node is labeled with @xmath17 .    if @xmath176 $ ] , where @xmath17 is a non - sensing action and @xmath177 is a non - empty plan , then @xmath250 is a tree whose root is labeled with @xmath17 and has only one subtree which is @xmath253 . furthermore , the link between @xmath17 and @xmath253 s root is labeled with an empty string .",
    "if @xmath179 $ ] , where @xmath17 is a sensing action that determines @xmath50 s , then @xmath250 is a tree whose root is labeled with @xmath17 and has @xmath241 subtrees @xmath254 . for each @xmath255 , the link from @xmath17 to the root of @xmath256",
    "is labeled with @xmath50 .",
    "observe that each trajectory of the plan @xmath45 corresponds to a path from the root to a leave of @xmath250 .",
    "as an example , figure [ tree ] depicts the labeled trees for plans @xmath257 , @xmath57 , @xmath58 and @xmath59 in example [ ex07 ] ( black nodes indicate that there exists an action occurring at those nodes , while white nodes indicate that there is no action occurring at those nodes ) .    for a plan @xmath45 , let @xmath258 be the number of leaves of @xmath250 and @xmath259 be the number of nodes along the longest path from the root to the leaves of @xmath250 .",
    "@xmath258 and @xmath259 will be called the _ width _ and _ height _ of @xmath250 respectively .",
    "suppose @xmath249 and @xmath115 are two integers that such that @xmath260 and @xmath261 .",
    "let us denote the leaves of @xmath250 by @xmath262 .",
    "we map each node @xmath263 of @xmath250 to a pair of integers @xmath264 = ( @xmath265,@xmath266 ) , where @xmath265 is the number of nodes along the path from the root to @xmath263 , and @xmath266 is defined in the following way .    * for each leaf @xmath267 of @xmath250 , @xmath268 is an arbitrary integer between @xmath269 and @xmath249 .",
    "furthermore , there exists a leaf @xmath270 with @xmath45-value of @xmath269 , i.e. , @xmath271 , and there exist no @xmath272 such that @xmath273 . * for each interior node @xmath263 of @xmath250 with children @xmath274 , @xmath275 .",
    "for instance , figure [ tree1 ] shows some possible mappings with @xmath276 and @xmath277 for the trees in figure [ tree ] .",
    "it is easy to see that if @xmath260 and @xmath261 then such a mapping always exists .",
    "furthermore , from the construction of @xmath250 , independently of how the leaves of @xmath250 are numbered , we have the following properties .    1 .   for every node @xmath263 , @xmath278 and @xmath279 .",
    "2 .   for a node @xmath263 ,",
    "all of its children have the same @xmath280-value .",
    "that is , if @xmath263 has @xmath281 children @xmath274 then @xmath282 for every @xmath283 .",
    "furthermore , the @xmath45-value of @xmath263 is the smallest one among the @xmath45-values of its children .",
    "the root of @xmath250 is always mapped to the pair @xmath284 .",
    "our encoding is based on the above mapping .",
    "we observe that a conditional plan @xmath45 can be represented on a grid @xmath285 where each node @xmath263 of @xmath250 is placed at the position @xmath286 relative to the leftmost top corner of the grid .",
    "this way , it is guaranteed that the root of @xmath250 is always placed at the leftmost top corner .",
    "figure [ grid ] depicts the @xmath287 grid representation of conditional plans @xmath288 and @xmath289 in figure [ tree1 ] . as it can be seen in figure [ grid ] , each path ( trajectory ) of the plan can end at an arbitrary time point .",
    "for example , the leftmost and rightmost trajectories of @xmath290 end at 2 , whereas the others end at 3 . on the other hand , to check if the plan is indeed a solution , we need to check the satisfaction of the goal at every leaf node of the plan , that is , at the end of each trajectory . in our encoding , this task is simplified by extending all the trajectories of the plan so that they have the same height @xmath291 and then checking the goal at the end of each extended trajectory ( see figure [ grid ] ) .",
    "note that an a - state associated with each node on the extended part of each trajectory in our encoding will be guaranteed to be the same as the one associated with the end node of the original trajectory .",
    "we now describe the program @xmath248 in the syntax of  ( for a concrete example , see appendix c ) . in @xmath248 , variables of sorts @xmath292 and @xmath293 correspond to rows and columns of the grid . instead of using the predicate @xmath294 ( _ see _ , e.g. , @xcite ) to denote that a literal @xmath295 holds at the time @xmath296 , we use the predicate @xmath297 to represent the fact that @xmath295 holds at node @xmath298 ( the time moment @xmath296 , the path number @xmath299 on the grid ) .    the program @xmath248 contains the following elements",
    ".    1 .   * constants .",
    "* there are two constants used in the program @xmath115 and @xmath249 which serve as the input parameters of the program . in addition",
    ", we have constants to denote fluents , literals and actions in the domain . due to the fact that  does not allow symbol @xmath300 , to represent a literal constant @xmath7",
    ", we will use @xmath301 .",
    "* predicates . *",
    "the program uses the following predicates .",
    "* @xmath302 is true if @xmath303 .",
    "* @xmath304 is true if @xmath305 .",
    "* @xmath306 is true if @xmath307 .",
    "* @xmath308 is true if @xmath309 is a fluent .",
    "* @xmath310 is true if @xmath295 is a literal .",
    "* @xmath311 is true if @xmath295 and @xmath312 are two complementary literals .",
    "* @xmath313 is true if @xmath295 is a sensed literal .",
    "* @xmath314 is true if @xmath315 is an action * @xmath297 is true if literal @xmath295 holds at @xmath298 .",
    "* @xmath316 is true if action @xmath315 is executable at @xmath298 .",
    "* @xmath317 is true if action @xmath315 occurs at @xmath298 .",
    "that means the node @xmath298 in @xmath250 is labeled with action @xmath315 .",
    "* @xmath318 is true if literal @xmath295 is an effect of a non - sensing action occurring at @xmath298 .",
    "* @xmath319 is true if literal @xmath295 may change at @xmath320 .",
    "* @xmath321 is true if the goal is satisfied at @xmath298 .",
    "* @xmath322 is true if there exists a branch from @xmath298 to @xmath323 labeled with @xmath324 in @xmath250 .",
    "for example , in the grid representation of @xmath288 ( figure [ grid ] ) , we have @xmath325 , @xmath326 , and @xmath327 .",
    "* @xmath328 is true if @xmath298 belongs to some extended trajectory of the plan .",
    "this allows us to know which paths are used in the construction of the plan and thus to be able to check if the plan satisfies the goal . as an example , for @xmath288 in figure [ grid ] , we have @xmath329 for @xmath330 , and @xmath331 and @xmath332 for @xmath333 .",
    "the goal satisfaction , hence , will be checked at nodes @xmath334 , @xmath335 , and @xmath336 .",
    "* variables . *",
    "the following variables are used in the program .",
    "* @xmath309 : a @xmath337 variable .",
    "* @xmath295 and @xmath312 : @xmath338 variables . * @xmath296 and @xmath339 : @xmath292 variables , in ranges @xmath340 and @xmath341 respectively , * @xmath324 , @xmath342 and @xmath343 : @xmath344 variables .",
    "* @xmath315 : an @xmath345 variable . *",
    "@xmath299 , @xmath346 , and @xmath347 : @xmath293 variables , in range @xmath348 .",
    "+ the domains of these variables are declared in  using the keyword # domain ( see appendix c for more details ) .",
    "observe that the type of each variable has to be declared accordingly if this feature of  is not used .",
    "* rules . *",
    "the program has the following facts to define variables of sort @xmath292 and @xmath293 : @xmath349 + for each action @xmath17 , fluent @xmath8 , or sensed - literal @xmath22 in the domain , @xmath248 contains the following facts respectively @xmath350 the remaining rules of @xmath248 are divided into three groups : ( i ) domain dependent rules ; ( ii ) goal representation and ( iii ) domain independent rules , which are given next .",
    "note that they are shown in a shortened form in which the following shortening conventions are used .",
    "* two contrary literal variables are written as @xmath295 and @xmath351 .",
    "* for a predicate symbol @xmath45 , and a set @xmath68 of literals or actions , we will write @xmath352 to denote the set of atoms @xmath353 . * for a literal constant @xmath9 , @xmath41 stands for @xmath301 ( resp",
    ". @xmath8 ) if @xmath354 ( resp .",
    "@xmath355 ) for some fluent @xmath8 .",
    "+ for example , the rule ( [ r_14 ] ) stands for the following rule @xmath356      * * rules encoding the initial situation . * for each v - proposition ( [ init ] ) in @xmath32 , @xmath248 contains the fact @xmath357 * * rules encoding actions executability conditions . * for each executability condition ( [ exec ] ) in @xmath31 , @xmath248 contains the rule @xmath358 * * rules for reasoning about the effect of non - sensing actions . * for each dynamic causal law ( [ dynamic ] ) in @xmath359 , we add to @xmath248 the following rules : @xmath360 here , @xmath17 is a non - sensing action .",
    "its execution changes the world according to the @xmath158-function .",
    "the first rule , when used along with ( [ r_9 ] ) , encodes what definitely holds as the effect of @xmath17 in the next a - state .",
    "the second rule , when used along with ( [ r_8 ] ) , describes what would potentially be changed by @xmath17 ( see the definitions of @xmath124 and @xmath125 in subsection [ approx ] ) .",
    "note that in the second rule , @xmath361 stands for @xmath362 , meaning that @xmath19 possibly holds at @xmath298 .",
    "these rules will be used in cooperation with ( [ r_10 ] ) , ( [ r_13 ] ) , and ( [ r_14 ] ) to define the next a - state after the execution of a non - sensing action . * * rules for reasoning about the effect of sensing actions . * for each k - proposition ( [ knowledge ] ) in @xmath31 , @xmath248 contains the following rules : @xmath363 the first rule assures that if a sensing action @xmath17 occurs at @xmath298 then there must be a branch from @xmath298 to @xmath320 .",
    "the second rule ensures that a new branch , corresponding to a new successor a - state , will be created for each literal sensed by the action .",
    "the last rule is a constraint that prevents @xmath17 from taking place if one of the literals sensed by the action is already known . with this rule ,",
    "the returned plan is guaranteed to be optimal in the sense that a sensing action should not occur if one of the literals sensed by the action already holds .",
    "observe that the semantics of @xmath364 does not prevent a sensing action to execute when some of its sensed - fluents is known .",
    "for this reason , some solutions to a planning problem instance might not be found using this encoding .",
    "however , as we will see later , the program will generate an `` equivalent '' plan to those solutions .",
    "subsection [ soundcomp ] will elaborate more on this issue . * * rules for reasoning about static causal laws .",
    "* for each static causal law ( [ static ] ) in @xmath31 , @xmath248 contains the rules @xmath365 rules in this group encode the equations ( [ sem - pc1])-([sem - pc3 ] ) and the operator @xmath366 .",
    "the following rules encode the goal and make sure that it is always achieved at the end of every possible branch created by the execution of the plan .",
    "@xmath367 the first rule says that the goal is satisfied at a node if all of its subgoals are satisfied at that node .",
    "the last rule guarantees that if a path @xmath299 is used in the construction of a plan then the goal must be satisfied at the end of this path , that is , at node @xmath368 .",
    "rule ( [ r_11_2 ] ) deserves some explanation .",
    "intuitively , the presence of @xmath369 and @xmath370 indicates that the a - state at the node @xmath298 is inconsistent .",
    "this means that no action should be generated at this node as inconsistent a - states will be removed by the extended transition function ( definition [ d : weak : extend ] ) . to achieve this effect , to represent that the a - state at @xmath298 is inconsistent ; ( ii ) adding @xmath371 in the body of rule ( [ r_22 ] ) to prevent action to occur at @xmath298 ; and ( iii ) modifying the rule ( [ r_12 ] ) accordingly . ]",
    ", we say that the `` goal '' has been achieved at @xmath298 .",
    "the inclusion of this rule might raise the question : is it possible for the program to generate a plan whose execution yields inconsistent a - states only .",
    "fortunately , due to proposition [ prop - cons - action - theory ] , this will not be the case for consistent action theories .",
    "* * rules encoding the effect of non - sensing actions .",
    "* rules ( [ r_3 ] )  ( [ r_4 ] ) specify what definitely holds and what could potentially be changed in the next a - state as the effect of a non - sensing action .",
    "the following rules encode the effect and frame axioms for non - sensing actions .",
    "@xmath372 when used in conjunction with ( [ r_3 ] )  ( [ r_4 ] ) , they define the @xmath158 function . *",
    "* inertial rules for sensing actions . *",
    "this group of rules encodes the fact that the execution of a sensing action does not change the world .",
    "however , there is one - to - one correspondence between the set of sensed literals and the set of possible next a - states after the execution of a sensing action .",
    "@xmath373 the first three rules make sure that there is no cycle in the plan that we are encoding .",
    "the next rule is to mark a node as used if there exists a branch in the plan that coming to that node .",
    "this allows us to know which paths on the grid are used in the construction of the plan and thus to be able to check if the plan satisfies the goal ( see rule ( [ r_12 ] ) ) .",
    "+ the last two rules , along with rule ( [ r_10 ] ) , encode the possible next a - state corresponding to the branch denoted by literal @xmath324 after a sensing action is performed in a state @xmath118 .",
    "they say that such a - state should contain @xmath324 ( rule ( [ r_20 ] ) ) and literals that hold in @xmath118 ( rule ( [ r_21 ] ) ) .",
    "+ note that because for each literal @xmath324 sensed by a sensing action @xmath17 , we create a corresponding branch ( rules ( [ r_5 ] ) and ( [ r_6 ] ) ) , the rules of this group guarantee that all possible next a - states after @xmath17 is performed are generated .",
    "* * rules for generating action occurrences . *",
    "@xmath374 the first rule enforces exactly one action to take place at a node that was used but the goal has not been achieved .",
    "the second one guarantees that only executable actions can occur . *",
    "* auxiliary rules .",
    "* @xmath375 the first four rules define literals and contrary literals .",
    "rule ( [ r_28 ] ) says that a newly created branch should outgo to a path number greater than the current path .",
    "the last two rules mark nodes that have been used .",
    "this section discusses some important properties of .",
    "we begin with how to extract a solution from an answer set returned by .",
    "then , we argue that  is sound and complete with respect to the 0-approximation semantics .",
    "we also show that  can be used as a conformant planner .",
    "finally , we present how to modify  to act as a reasoner .",
    "in some previous answer set based planners @xcite , reconstructing a plan from an answer set for a logic program encoding the planning problem instance is quite simple : we only need to collect the action occurrences in the model and then order them by the time they occur . in other words , if the answer set contains @xmath376 , @xmath377 , @xmath378 then the plan is @xmath379 . for @xmath248 ,",
    "the reconstruction process is not that simple because each answer set for @xmath248 represents a conditional plan which may contain conditionals in the form @xmath380 .",
    "the following procedure describes how to extract such a plan from an answer set .",
    "let @xmath233 be a planning problem instance and @xmath381 be an answer set for @xmath248 .",
    "for any pair of integers , @xmath382 , we define @xmath383 as follows : @xmath384 & \\textnormal{if }",
    "i = h + 1 \\textnormal { or } occ(a , i , k ) \\not \\in s     \\textnormal { for all } a    \\\\ a;p^k_{i+1}(s ) & \\textnormal{if } occ(a , i , k ) \\in s \\textnormal { and } \\\\     & a   \\textnormal { is a non - sensing action}\\\\ a;cases(\\{g_j \\rightarrow p_{i+1}^{k_j}(s)\\}^n_{j=1 } ) & \\textnormal{if } occ(a , i , k ) \\in s , \\\\ & a   \\textnormal { is a sensing action } ,   \\textnormal { and } \\\\ &",
    "br(g_j , i , k , k_j ) \\in s   \\textnormal { for } 1 \\le j \\le n \\end{array } \\right.\\ ] ] intuitively , @xmath383 is the conditional plan whose corresponding tree is rooted at node @xmath385 on the grid @xmath285 .",
    "@xmath386 is , therefore , a solution to @xmath235 .",
    "this is stated in theorem [ t1 ] in the next subsection .",
    "[ t1 ] let @xmath30 be a consistent action theory , @xmath233 be a planning problem instance and @xmath387 and @xmath388 be integers .",
    "if @xmath248 returns an answer set @xmath381 then @xmath386 is a solution to @xmath235 .",
    "_ see appendix b_.",
    "theorem [ t1 ] shows the soundness of @xmath248 . we will now turn our attention to the completeness of @xmath248 .",
    "observe that solutions generated by @xmath248 are optimal in the following sense    1 .",
    "actions do not occur once the goal is achieved or a possible next a - state does not exist ; and 2 .",
    "sensing actions do not occur if one of its sensed literals holds .",
    "the first property holds because of rule ( [ r_22 ] ) and the second property holds because of constraint ( [ r_7 ] ) .",
    "since the definition of a conditional plan in general does not rule out _ non - optimal _",
    "plans , obviously @xmath248 will not generate all possible solutions to @xmath235 .    for example , consider the planning problem instance @xmath389 in example [ ex04 ] .",
    "we have seen that plans @xmath57 ,",
    "@xmath58 , and @xmath59 in example [ ex07 ] are all solutions to @xmath389 .",
    "however , @xmath58 and @xmath59 are not optimal because they do not satisfy the above two properties .",
    "the above example shows that @xmath248 is not complete w.r.t .",
    "the 0-approximation in the sense that no one - to - one correspondence between its answer sets and solutions to @xmath235 exists .",
    "however , we will show next that it is complete in the sense that for each solution @xmath45 to @xmath235 , there exist two integers @xmath115 and @xmath249 such that @xmath248 will generate an answer set @xmath381 whose corresponding plan , @xmath386 , can be obtained from @xmath45 by applying the following transformation ( called the @xmath390 operation ) .",
    "[ reduct of a plan ] [ def_reduct ] let @xmath233 be a planning problem instance , @xmath45 be a plan and @xmath118 be an a - state such that @xmath391 .",
    "a reduct of @xmath45 with respect to @xmath118 , denoted by @xmath392 , is defined as follows .    * if @xmath174 $ ] or @xmath393 then @xmath394\\ ] ] * if @xmath176 $ ] , where @xmath17 is a non - sensing action and @xmath177 is a plan , then @xmath395 * if @xmath179 $ ] , where @xmath17 is a sensing action that senses @xmath396 , then @xmath397 where @xmath398 & \\textnormal { if } cl_{\\cald}(\\delta \\cup \\{g_j\\ } )      \\textnormal { is inconsistent } \\\\      \\reduct_{cl_{\\cald}(\\delta \\cup \\{g_j\\ } ) } ( p_j )       & \\textnormal { otherwise }    \\end{array } \\right.\\ ] ]    [ ex22 ] consider the planning problem instance @xmath389 in example [ ex04 ] and plans @xmath57 , @xmath58 , and @xmath59 in example [ ex07 ] .",
    "let @xmath399 .",
    "we will show that @xmath400 and @xmath401 because @xmath402 , @xmath230 , and @xmath228 do not hold in @xmath118 , we have @xmath403 where @xmath404 s are defined as in definition [ def_reduct ] .",
    "let @xmath405 it is easy to see that @xmath406 $ ] ( because @xmath407 is inconsistent ) and @xmath408 $ ] ( because the sub - plan corresponding to the branch `` locked '' in @xmath58 is empty ) .",
    "let us compute @xmath409 .",
    "we have @xmath410 because @xmath201 does not satisfy @xmath34 and @xmath411 , where @xmath412 we have @xmath413 as @xmath414 satisfies @xmath34 , we have @xmath415 $ ] .",
    "hence , @xmath416 .",
    "accordingly , we have @xmath417 , closed \\rightarrow [ flip\\_lock ] , locked \\rightarrow [ ] \\ } ) = p_2\\ ] ] that is , ( [ eq_reduct_1 ] ) holds .",
    "we now show that ( [ eq_reduct_2 ] ) holds .",
    "it is easy to see that @xmath418 , closed \\rightarrow \\reduct_{\\delta_{2}}(p_2 ) ,   locked \\rightarrow [ ] \\})\\ ] ] because @xmath230 holds in @xmath201 , we have @xmath419 thus , @xmath418 , closed \\rightarrow flip\\_lock ,   locked \\rightarrow [ ] \\ } ) = p_2\\ ] ] as a result , we have ( [ eq_reduct_2 ] ) holds .",
    "we have the following proposition .",
    "[ prop - reduct ] let @xmath233 be a planning problem instance and @xmath118 be its initial a - state .",
    "then , for every solution @xmath45 to @xmath235 , @xmath420 is unique and also a solution to @xmath235 .",
    "_ see appendix b_.    the following theorem shows the completeness of our planner with respect to the 0-approximation semantics .    [ t2 ] let @xmath233 be a planning problem instance , and @xmath45 be a solution to @xmath235 . then",
    ", there exist two integers @xmath115 and @xmath249 such that @xmath248 has an answer set @xmath381 and @xmath421 , where @xmath118 is the initial a - state of @xmath30 .",
    "_ see appendix b_.      since conformant planning deals only with incomplete information , it is easy to see that @xmath422 can be used to generate conformant plans for @xmath235 .",
    "let @xmath381 be an answer set for @xmath422 . recall that we assume that each sensing action senses at least two literals .",
    "hence , @xmath423 implies @xmath381 does not contain @xmath424 where @xmath17 is a sensing action because if otherwise rules ( [ r_6 ] ) and ( [ r_17 ] ) can not be satisfied .",
    "thus , @xmath386 is a sequence of non - sensing actions . by theorem [ t1 ] , we know that @xmath386 achieves the goal of @xmath235 from every possible initial a - state of the domain , which implies that @xmath425 is a conformant plan . in section [ experiments ] , we compare the performance of @xmath422 against some of the state - of - the - art conformant planners .",
    "it is easy to see that with minor changes ,  can be used to compute the consequences of a plan .",
    "this can be done as follows .",
    "given an action theory @xmath30 , for any integers @xmath426 , let @xmath427 be the set of rules : @xmath428 .",
    "intuitively , @xmath427 is the program obtained from @xmath248 by removing the rules for _ ( i ) _ generating the branches when sensing actions are executed ; _ ( ii ) _ checking the satisfaction of the goal ; _ ( iii ) _ representing the constraints on branches ; and _ ( iv ) _ generating action occurrences . for a plan @xmath45 , let @xmath250 be the corresponding tree for @xmath45 that is numbered according to the principles described in the previous section .",
    "we define @xmath429 to be the following set of atoms @xmath430 it is easy to see that the program @xmath431 has a unique answer set which corresponds to @xmath432 .",
    "this is detailed in the following proposition .",
    "let @xmath30 be an action theory , @xmath45 be a plan , @xmath63 be a fluent formula , @xmath250 be the plan tree for @xmath45 with a given numbering , and @xmath115 and @xmath249 be the height and width of @xmath250 respectively .",
    "let @xmath433 we have that    * @xmath434 has a unique answer set @xmath381 ; * @xmath435 if and only if * * there exists some @xmath255 , @xmath436 , @xmath437 ; and * * for every @xmath255 , @xmath436 and @xmath437 , @xmath63 is known to be true in @xmath438 .",
    "* @xmath439 if and only if * * there exists some @xmath255 , @xmath436 , @xmath437 ; and * * for every @xmath255 , @xmath436 and @xmath437 , @xmath63 is known in @xmath438 .    where @xmath440    the proof of this theorem is very similar to the proof of theorem [ t1 ] so",
    "we omit it for brevity .",
    "in this section , we evaluate  against other planners using planning benchmarks from the literature .",
    "we first briefly summarize the features of the systems that are used in our experiments .",
    "we then describe the benchmarks .",
    "finally , we present the experimental results .",
    "the planning systems that we compared with are the following .    * :  is a declarative , logic - based planning system built on top of the @xmath441 system ( + http://www.dbai.tuwien.ac.at/proj/dlv/ + ) .",
    "the input language @xmath442 is a logic - based planning language described in @xcite .",
    "the version we used for testing is available at + http://www.dbai.tuwien.ac.at/proj/dlv/k/ + .",
    "is capable of generating both concurrent and conformant plans .",
    "it , however , does not support sensing actions and can not generate conditional plans .",
    "*  ( conformant model based planner ) @xcite :   is a conformant planner developed by cimatti and roveri .",
    "a planning domain in cmbp is represented as a finite state automaton .",
    "bdd ( binary decision diagram ) techniques are employed to represent and search the automaton .",
    "allows nondeterministic domains with uncertainty in both the initial state and action effects .",
    "nevertheless , it does not have the capability of generating concurrent and conditional plans .",
    "the input language to  is  described in @xcite .",
    "the version used for testing was downloaded from + http://www.cs.washington.edu/research/jair/contents/v13.html + .",
    "* kacmbp @xcite : similarly to cmbp , kacmbp uses techniques from symbolic model checking to search in the belief space .",
    "however , in kacmbp , the search is guided by a heuristic function which is derived based on knowledge associated with a belief state .",
    "+ kacmbp is designated for sequential and conformant setting .",
    "it , however , does not support concurrent planning and conditional planning .",
    "the input language of kacmbp is smv .",
    "the system was downloaded from http://sra.itc.it / tools / mbp / aij04/. * conformant - ff ( cff ) @xcite : cff , to our best knowledge , is one of the current fastest conformant planners in most of the benchmark domains in the literature .",
    "it extends the classical ff planner @xcite to deal with uncertainty in the initial state .",
    "the basic idea is to represent a belief state @xmath95 just by the initial belief state ( which is described as a cnf formula ) together with the action sequence that leads to @xmath95 .",
    "in addition , the reasoning is done by checking the satisfiability of cnf formulae .",
    "+ the input language of cff is a subset of pddl with a minor change that allows the users to specify the initial state as a cnf formula .",
    "both sequential and and conformant planning are supported in cff .",
    "however , it does not support concurrent and conditional planning .",
    "* mbp @xcite : mbp is a previous version of cmbp .",
    "unlike cmbp which only deals with conformant planning , mbp supports conditional planning as well .",
    "the version used for testing was downloaded from http://sra.itc.it / tools / mbp/. *  ( sensory graph plan ) @xcite :  is a planner based on the planning graph algorithm proposed by blum and furst in @xcite .",
    "supports conditional effects , universal and existential quantification",
    ". it also handles uncertainty and sensing actions .  has the capability of generating both conformant and conditional plans , as well as concurrent plans",
    "nevertheless , static laws are not allowed in .",
    "the input syntax is  ( planning domain definition language ) .",
    "the version used for testing is 1.0h ( dated january 14th , 2000 ) , written in lisp , available at + http://www.cs.washington.edu/ai/sgp.html + .",
    "* pond @xcite : pond extends the planning graph algorithm @xcite to deal with sensing actions .",
    "conformant planning is also supported as a feature of pond .",
    "the input language is a subset of pddl .",
    "pond was downloaded from http://rakaposhi.eas.asu.edu / belief - search/.    table  [ tab : features ] summarizes the features of these planning systems .",
    "input language & & @xmath443 & & & & & & smv + sequential planning & yes & yes & yes & yes & no & yes & yes &",
    "yes + concurrent planning & no & yes & no & no & yes & no & no & no + conformant planning & yes & yes & yes & yes & yes & yes & yes & yes + conditional planning & yes & no & yes & no & yes & yes & no & no +      to test the performance of the planners , we prepared two test suites for conformant and conditional planning , separately . in our preparation , we attempt to encode the planning problem instances given to the systems in a uniform way ( in terms of the number of actions , fluents , and effects of actions ) . due to the differences in the representation languages of these systems , there are situations in which the encoding of the problems might be different for each system .",
    "we tested the systems on the following domains :    * * bomb in the toilet ( bt ) : * this set of problems was introduced in @xcite : `` it has been alarmed that there is a bomb in a lavatory .",
    "there are @xmath444 suspicious packages , one of which contains the bomb .",
    "the bomb can be defused if we dunk the package that contains the bomb into a toilet . ''",
    "experiments were made with @xmath445 , @xmath446 , @xmath447 , @xmath448 , and @xmath449 . * * bomb in the toilet with multiple toilets ( bmt ) : * this set of problems is similar to the * bt * problem but we have multiple toilets .",
    "there are five problems in this set , namely @xmath450 , @xmath451 , @xmath452 , @xmath453 , and @xmath454 , where the first parameter is the number of suspicious packages and the second parameter is the number of toilets . *",
    "* bomb in the toilet with clogging ( btc ) : * this set of problems is similar to bts but we assume that dunking a package clogs the toilet and flushing the toilet unclogs it .",
    "we know that in the beginning , the toilet is unclogged .",
    "we did experiments with @xmath455 and @xmath449 , where @xmath444 is the number of suspicious packages . *",
    "* bomb in the toilet with multiple toilets and clogging ( bmtc ) : * this set of problems is similar to btc but we have multiple toilets .",
    "we did experiments with five problems @xmath456 , @xmath457 , @xmath458 , @xmath459 , and + @xmath460 , where the first parameter is the number of suspicious packages and the second parameter is the number of toilets . *",
    "* bomb in the toilet with clogging and uncertainty in clogging ( btuc ) : * this set of problems is similar to btc except that we do not know whether the toilet is clogged or not in the beginning . * * bomb in the toilet with multiple toilets and uncertainty in clogging ( bmtuc ) : * this set of problems is similar to bmtc except that we do not know whether or not each toilet is clogged in the beginning . *",
    "* ring : * this set of problems is from @xcite . in this domain , one can move in a cyclic fashion ( either forward or backward ) around a @xmath241-room building to lock windows .",
    "each room has a window and the window can be locked only if it is closed .",
    "initially , the robot is in the first room and it does not know the state ( open , closed or locked ) of the windows .",
    "the goal is to have all windows locked .",
    "a possible conformant plan is to perform a sequence of actions _",
    "forward , close , lock _ repeatedly . in this domain",
    ", we tested with @xmath4612,4,6,8 , and 10 .",
    "* * domino ( dom ) : * this domain is very simple .",
    "we have @xmath241 dominos standing on a line in such a way that if one of them falls then the domino on its right also falls .",
    "there is a ball hanging close to the leftmost one . touching the ball causes the first domino to fall .",
    "initially , the states of dominos are unknown .",
    "the goal is to have the rightmost one to fall .",
    "the solution is obviously to touch the ball . in this domain , we tested with @xmath46110,20,50,100 , 1000 , and 10000 .",
    "the set of problems for testing includes :    * * bomb in the toilet with sensing actions ( bts ) : * this set of examples is taken from @xcite .",
    "they are variations of the btc problem that allow sensing actions to be used to determine the existence of a bomb in a specific package .",
    "there are @xmath444 packages and only one toilet .",
    "we can use one of the following methods to detect a bomb in a package : ( 1 ) use a metal detector ( action @xmath462 ) ; ( 2 ) use a trained dog to sniff the bomb ( action @xmath463 ) ; ( 3 ) use an x - ray machine ( action @xmath464 ) ; and , finally , ( 4 ) listen for the ticking of the bomb ( action @xmath465 ) . +",
    "this set of examples contains four subsets of problems , namely @xmath466 , + @xmath467 , @xmath468 , and @xmath469 respectively , where @xmath444 is the number of suspicious packages .",
    "these subsets differ from each other in which ones of the above methods are allowed to use .",
    "the first subset allows only one sensing action ( 1 ) ; the second one allows sensing actions ( 1)-(2 ) ; and so on .",
    "* * medical problem ( med ) : * this set of problems is from @xcite .",
    "a patient is sick and we want to find the right medication for her . using a wrong medication may be fatal . performing a throat culture will return either @xmath470 , @xmath471 , or @xmath472 , which determines the group of illness the patient is infected with . inspecting the color ( that can be performed only after the throat culture is done ) allows us to observe the color returned by a throat culture , depending on the illness of the patient . analyzing a blood sample tells us whether or not the patient has a high white cell count .",
    "this can be done only after a blood sample is taken .",
    "in addition , we know that in the beginning , the patient is not dead but infected .",
    "in addition , none of the tests have been done .",
    "+ there are five problems in this set , namely , @xmath473 , @xmath474 , @xmath475 .",
    "these problems are different from each other in how much we know about the illness of the patient in the beginning . * * sick domain ( sick ) : * this set of problems is similar to med .",
    "a patient is sick and we need to find a proper medication for her .",
    "there are @xmath241 kinds of illness that she may be infected with and each requiring a particular medication .",
    "performing throat culture can return a particular color . inspecting that color determine what kind of illness the patient has .",
    "initially , we do not know the exact illness that the patient is infected with . + the characteristic of this domain is that the length of the plan is fixed ( only 3 ) but the width of the plan may be large , depending on the number of illnesses .",
    "we did experiments with five problems in the domain , namely , @xmath476 , @xmath477 , ... ,",
    "@xmath478 . they differ from each other in the number of illnesses that the patient may have . *",
    "* ring ( rings ) * : this domain is a modification of the @xmath479 domain . in this modified version ,",
    "the agent can close a window only if it is open .",
    "it can lock a window only if it is closed .",
    "the agent can determine the status of a window by observing it ( sensing action @xmath480 ) .",
    "* * domino ( doms ) * : this is a variant of the @xmath481 domain in which some dominos may be glued to the table . unlike the original version of the @xmath481 domain , in this variant , when a domino falls , the next one falls only if it is not glued .",
    "the agent can do an action to unglue a glued domino .",
    "we introduce a new sensing action @xmath482 to determine whether a domino @xmath483 is glued or not .",
    "we ran our experiments on a 2.4 ghz cpu , 768 mb ram , dell machine , running slackware 10.0 operating system .",
    "we compared  with , , , cff and kacmbp on the conformant benchmarks and with , pond , and mbp on the conditional benchmarks .",
    "time limit was set to 30 minutes .",
    "the cmu common lisp version 19a was used to run  examples .",
    "we ran  examples on both  and . by convention , in what follows , we will use @xmath484 and @xmath485 to refer to the planner  when it was run on  and  respectively . sometimes , if the distinction between the two is not important , by  we mean both .",
    "the experimental results for conformant and conditional planning are shown in tables [ tab : conf ] and [ tab : cond ] respectively .",
    "times are in seconds .",
    "`` to / ab '' indicates that the corresponding planner does not return a solution within the time limit or stopped abnormally due to some reasons , for example , out of memory or segmentation fault .",
    "& pl & cmodels & smodels & & & & & cmbp + & 2 & 0.06 & 0.03 & 0.01 & 0.03 & 0.04 & 0.02 & 0.12 + _",
    "bt(4 ) _ & 4 & 0.04 & 0.06 & 0.03 & 0.03 & 0.27 & 0.04 & 0.12 + _",
    "bt(6 ) _ & 6 & 0.05 & 0.12 & 0.18 & 0.04 & 0.42 & 0.09 & 0.1 + _",
    "bt(8 ) _ & 8 & 0.10 & 0.33 & 1.47 & 0.10 & 1.04 & 0.10 & 0.11 + _",
    "bt(10 ) _ & 10 & 0.12 & 2.54 & 11.37 & 0.50 & 2.13 & 0.13 & 0.11 + & 2 & 0.04 & 0.04 & 0.01 & 0.03 & 0.07 & 0.02 & 0.07 + _",
    "bmt(4,2 ) _ & 4 & 0.05 & 0.09 & 0.03 & 0.04 & 0.28 & 0.03 & 0.12 + _",
    "bmt(6,2 ) _ & 6 & 0.11 & 0.23 & 0.19 & 0.05 & 0.29 & 0.07 & 0.10 + _",
    "bmt(8,4 ) _ & 8 & 0.41 & 4.70 & 1.70 & 0.11 & 3.14 & 0.09 & 0.11 + _",
    "bmt(10,4 ) _ & 10 & 0.51 & 152.45 & 12.18 & 0.53 & 5.90 & 0.12 & 0.14 + & 2 & 0.04 & 0.04 & 0.01 & 0.03 & 0.44 & 0.05 & 0.12 + _",
    "btc(4 ) _ & 7 & 0.04 & 0.12 & 0.33 & 0.04 & 21.62 & 0.06 & 0.10 + _",
    "btc(6 ) _ & 11 & 0.06 & 0.33 & to & 0.1 & to & 0.07 & 0.11 + _",
    "btc(8 ) _ & 15 & 0.11 & 0.53 & to & 0.79 & to & 0.07 & 0.13 + _",
    "btc(10 ) _ & 19 & 0.12 & 468.04 & to & 9.76 & to & 0.13 & 0.14 + & 2 & 0.06 & 0.06 & 0.01 & 0.03 & 0.18 & 0.05 & 0.12 + _",
    "bmtc(4,2 ) _ & 6 & 0.10 & 0.19 & 0.17 & 0.05 & 2.03 & 0.04 & 0.09 + _",
    "bmtc(6,2 ) _ & 10 & 0.14 & 0.63 & 20.02 & 0.24 & to & 0.07 & 0.12 + _",
    "bmtc(8,4 ) _ & 12 & 0.56 & 60.56 & to & to & to & 0.10 & 0.12 + _",
    "bmtc(10,4 ) _ & 16 & 1.44 & to & to & to & to & 0.13 & 0.17 + & 4 & 0.05 & 0.04 & 0.02 & 0.02 & 0.59 & 0.03 & 0.09 + _",
    "btuc(4 ) _ & 8 & 0.04 & 0.11 & 0.94 & 0.04 & to & 0.04 & 0.11 + _",
    "btuc(6 ) _ & 12 & 0.06 & 0.22 & 524.3 & 0.11 & to & 0.06 & 0.11 + _",
    "btuc(8 ) _ & 16 & 0.11 & 4.7 & to & 0.96 & to & 0.08 & 0.12 + _",
    "btuc(10 ) _ & 20 & 0.12 & to & to & 11.58 & to & 0.13 & 0.16 + & 4 & 0.06 & 0.07 & 0.03 & 0.03 & 16.11 & 0.06 & 0.11 + _",
    "bmtuc(4,2 ) _ & 8 & 0.10 & 0.23 & 0.24 & 0.07 & to & 0.09 & 0.14 + _",
    "bmtuc(6,2 ) _ & 12 & 0.14 & 19.88 & 1368.28 & 0.43 & to & 0.08 & 0.14 + _",
    "bmtuc(8,4 ) _ & 16 & 0.56 & to & to & to & to & 0.13 & 0.18 + _",
    "bmtuc(10,4 ) _ & 20 & 0.63 & to & to & to & to & 0.16 & 0.16 + & 5 & 0.12 & 0.47 & 0.201 & 0.04 & 0.14 & 0.05 & 0.00 + _",
    "ring(4 ) _ & 11 & 0.21 & 6.76 & 0.638 & 0.05 & 2.28 & 0.09 & 0.12 + _",
    "ring(6 ) _ & 17 & 31.73 & to & to & 0.40 & 77.10 & 0.20 & 0.13 + _",
    "ring(8 ) _ & 23&1246.58 & to & to & 832.73 & to & 0.74 & 0.18 + _",
    "ring(10 ) _ & 29 & to & to & to & to & to & 2.46 & 0.18 + & 1 & 0.11 & 0.08 & 0.03 & 0.04 & 2.24 & 0.05 & 0.13 + _",
    "dom(20 ) _ & 1 & 0.14 & 0.07 & 0.24 & 0.05 & 33.4 & 0.29 & 0.14 + _",
    "dom(50 ) _ & 1 & 0.47 & 0.40 & 1368.28 & 0.06 & 1315.98&4.44 & 1.34 + _",
    "dom(100 ) _ & 1 & 1.70 & 1.64 & to & 0.11 & to & to & 2.56 + _",
    "dom(500 ) _ & 1 & 31.28 & 32.52 & to & 2.16 & to & to & 29.10 + _",
    "dom(1000 ) _ & 1 & 121.91&129.96 & to & 9.83 & to & to & to +    in conformant setting ( table [ tab : conf ] ) , it is noticeable that @xmath486 behaves better than @xmath487 in all the conformant benchmark domains , especially in large problems .",
    "furthermore , cff and kacmbp are superior to all the other planners on most of the testing problems .",
    "especially , both of them scale up to larger instances very well , compared with the others .",
    "yet , it is interesting to observe that @xmath484 does not lose out a whole lot against these two planners in many problems . in the following",
    ", we will discuss the performance  in comparison with , , and .",
    "it can be seen that @xmath486 is competitive with  and outperforms  and  in most of problems .",
    "specifically , in the @xmath488 domain , @xmath486 took only 0.12 seconds to solve the last problem , while , , and  took 11.37 , 0.5 and 2.13 seconds respectively .",
    "@xmath487 however is slower than  and  in this domain .",
    "& length & width & cmodels & smodels & & & + & 2x2 & 0.166 & 0.088 & 0.11 & 0.188 & 0.047 + _",
    "bts1(4 ) _ & 4x4 & 0.808 & 1.697 & 0.22 & 0.189 & 0.048 + _",
    "bts1(6 ) _ & 6x6 & 5.959 & 83.245 & 2.44 & 0.233 & 0.055 + _",
    "bts1(8 ) _ & 8x8 & 25.284 & to & 24.24 & 0.346 & 0.076 + _",
    "bts1(10 ) _ & 10x10 & 85.476 & to & to & 0.918 & 0.384 + & 2x2 & 0.39 & 0.102 & 0.19 & 0.186 & 0.038 + _",
    "bts2(4 ) _ & 4x4 & 1.143 & 3.858 & 0.32 & 0.198 & 0.067 + _",
    "bts2(6 ) _ & 6x6 & 19.478 & 1515.288 & 3.23 & 0.253 & 2.163 + _",
    "bts2(8 ) _ & 8x8 & 245.902 & to & 25.5 & 0.452 & 109.867 + _",
    "bts2(10 ) _ & 10x10 & 345.498 & to & to & 1.627 & 178.823 + & 2x2 & 0.357 & 0.13 & 0.22 & 0.185 & 0.082 + _",
    "bts3(4 ) _ & 4x4 & 1.099 & 5.329 & 0.44 & 0.195 & 1.93 + _",
    "bts3(6 ) _ & 6x6 & 7.055 & to & 3.89 & 0.258 & 147.76 + _",
    "bts3(8 ) _ & 8x8 & 56.246 & to & 28.41 & 0.549 & ab + _",
    "bts3(10 ) _ & 10x10 & 248.171 & to & to & 2.675 & ab + & 2x2 & 0.236 & 0.149 & 0.26 & 0.194 & 0.098 + _",
    "bts4(4 ) _ & 4x4 & 1.696 & 3.556 & 0.64 & 0.191 & ab + _",
    "bts4(6 ) _ & 6x6 & 13.966 & 149.723 & 4.92 & 0.264 & ab + _",
    "bts4(8 ) _ & 8x8 & 115.28 & to & 30.34 & 0.708 & ab + _",
    "bts4(10 ) _ & 10x10 & 126.439 & to & to & 4.051 & ab + & 1x1 & 1.444 & 1.434 & 0.09 & 0.187 & 0.048 + _",
    "med(2 ) _ & 5x5 & 35.989 & 9.981 & 0.59 & 0.193 & 0.047 + _",
    "med(3 ) _ & 5x5 & 42.791 & 9.752 & 1.39 & 0.2 & 0.049 + _",
    "med(4 ) _ & 5x5 & 39.501 & 10.118 & 7.18 & 0.205 & 0.049 + _",
    "med(5 ) _ & 5x5 & 35.963 & 9.909 & 44.64 & ab & 0.05 + & 3x2 & 0.234 & 0.121 & 0.21 & 0.189 & 0.045 + _",
    "sick(4 ) _ & 3x4 & 0.901 & 0.797 & 10.29 & 0.19 & 0.048 + _",
    "sick(6 ) _ & 3x6 & 5.394 & 3.9 & to & 0.201 & 0.059 + _",
    "sick(8 ) _ & 3x8 & 17.18 & 14.025 & to & 0.221 & 0.129 + _",
    "sick(10 ) _ & 3x10 & 82.179 & 43.709 & to & 0.261 & 0.778 + & 3x3 & 0.768 & 0.14 & 0.67 & 0.198 & 0.045 + _",
    "rings(2 ) _ & 7x9 & 1386.299 & to & to & 0.206 & 0.057 + _",
    "rings(3 ) _ & 11x27 & to & to & to & 0.391 & 0.207 + _",
    "rings(4 ) _ & 15x64 & to & to & to & 3.054 & 3.168 + & 3x1 & 0.117 & 0.203 & 0.11 & 0.08 & 0.043 + _",
    "doms(2 ) _ & 5x4 & 0.306 & 0.325 & 48.82 & 0.183 & 0.048 + _",
    "doms(3 ) _ & 7x8 & 3.646 & 53.91 & to & 0.19 & 0.057 + _",
    "doms(4 ) _ & 9x16 & 87.639 & to & to & 0.248 & 0.101 + _",
    "doms(5 ) _ & 11x32 & to & to & to & 0.687 & 0.486 +    in the @xmath489 domain , @xmath487 is the worst .",
    "@xmath485 took more than two minutes to solve the largest problem in this domain , while  took only 0.53 seconds .",
    "@xmath486 , however , is competitive with  and outperforms both  and .    in the @xmath490 domain , although @xmath487 is better than  and , its performance is far from that of .",
    "the time for @xmath487 to solve the largest problem is nearly 8 minutes , while that for  is just 9.76 seconds .",
    "again , @xmath486 is the best .",
    "it took only 0.12 seconds to solve the same problem .",
    "the @xmath491 domain turns out to be hard for , , and .",
    "none of them were able to solve the @xmath459 within the time limit .",
    "although @xmath487 was able to solve this instance , it could not solve the last instance .",
    "@xmath486 on the contrary can solve these instances very quickly , less than two seconds for each problem .    in the @xmath492 and @xmath493 domains ,",
    "although not competitive with @xmath486 ,  outperforms both  and .",
    "for example ,  took less than 12 seconds to solve the largest instance in the @xmath492 domain , while @xmath487 , , and  indicated a timeout .",
    "@xmath487 is competitive with  and much better than .",
    "its performance is worse than  in these domains however .",
    "the @xmath479 domain is really hard for the planners except cff and kacmbp .",
    "cff and kacmbp took just a few minutes to solve the largest problem ; however , kacmbp seems to scale up better than cff on this domain .",
    "none of the other planners could solve the last problem . among the others ,",
    "is the best , followed by @xmath486",
    ".  took around 14 minutes to solve @xmath494 while @xmath486 took more than 20 minutes .",
    "@xmath485 is outperformed by both  and .    in the last domain , @xmath481 ,",
    "again ,  outperforms , , and .",
    "the solving time of  for the last problem is around 2 minutes , while that for  is just less than 10 seconds .  and",
    "were able to solve the first three instances of this domain only .",
    "it is worth noting here that the not - very - good performance of cff and kacmbp on this domain is because that this domain is in nature very rich in static causal laws , a feature that is not supported by cff and kacmbp .",
    "therefore , to encode the domain in cff and kacmbp , we had to compile away static causal laws .",
    "the performance of  in the conditional benchmarks is not as good as in the conformant benchmarks , compared with other testing planners . as can be seen in table [",
    "tab : cond ] , it was outperformed by both pond and mbp in the benchmarks , except in the last two problems of the @xmath495 domain or in the last three of the @xmath496 , where @xmath497 had a problem with segmentation fault or memory excess , or in @xmath498 problem where pond stopped abnormally .",
    "both pond and mbp did very good at testing domains .",
    "pond took just a few seconds to solve each instance in the testing domains .",
    "is also not competitive with  in small instances of the first five domains ( @xmath499-@xmath500 ) .",
    "however , when scaling up to larger problems , @xmath486 seems to be better than . in the last three domains ( @xmath501 , @xmath502 , and @xmath503 ) ,  is outperformed by both @xmath484 and @xmath485 .",
    "in this paper , we define an approximation for action theories with static causal laws and sensing actions . we prove that the newly developed approximation is sound with respect to the possible world semantics and is deterministic when non - sensing actions are executed .",
    "we also show that the approximation reduces the complexity of the conditional planning problem .",
    "we use the approximation to develop an answer set programming based conditional planner , called",
    ".  differs from previously developed model - based planners for domains with incomplete initial state ( e.g. @xcite ) in that it is capable of dealing with sensing actions and generating both conditional and conformant plans .",
    "we prove the correctness of  by showing that plans generated by  are solutions of the encoded planning problem instances .",
    "furthermore , we prove that  will generate a solution to @xmath235 if it has a solution with respect to the given approximation .",
    "we also discuss the use of  in reasoning about effects of conditional plans .",
    "we compare  with several planners .",
    "these results provide evidence for the usefulness of answer set planning in dealing with sensing actions and incomplete information .",
    "our experiments also show that there are situations in which   does not work as well as other state - of - the - art planners . in the future",
    ", we would like to investigate methods such as the use of domain knowledge to speed up the planning process ( see e.g. @xcite ) .",
    "we would like to thank michael gelfond for his valuable comments on an earlier draft of this paper .",
    "we would also like to thank the anonymous reviewers of this paper and an extended abstract of this paper , which appeared in @xcite , for their constructive comments and suggestions .",
    "the first two authors were partially supported by nsf grant eia-0220590 .",
    "this appendix contains the proofs for the propositions and theorems given in the paper . as stated , we assume that the body of each static law ( [ static ] ) is not an empty set and @xmath504 for every planning problem @xmath33 .",
    "we begin with a lemma about the operator @xmath366 that will be used in these proofs .",
    "we need the following definition . given a domain description @xmath31 , for a set of literals @xmath65 , let @xmath505 let @xmath506 and @xmath507 for @xmath122 . since , by the definition of @xmath508 , for any set of literals @xmath509 we have @xmath510 , the sequence @xmath511 is monotonic with respect to the set inclusion operation .",
    "in addition , @xmath512 is bounded by the set of fluent literals .",
    "thus , there exists @xmath513 such that @xmath514 .",
    "furthermore , @xmath515 is unique and satisfies all static causal laws in @xmath31 .",
    "[ lm1 ] for any set of literals @xmath65 , we have @xmath516 .    by induction",
    "we can easily show that @xmath517 for all @xmath122 .",
    "hence , we have @xmath518 furthermore , from the construction of @xmath519 , it follows that @xmath513 satisfies all static causal laws in @xmath31 .",
    "because of the minimality property of @xmath89 , we have @xmath520    accordingly , we have @xmath521    the following corollary follows immediately from the above lemma .    [ corol1 ] for two sets of literals @xmath522 , @xmath523 .    for an action @xmath17 and a state @xmath95 , let @xmath524 .",
    "we have the following lemma :    [ lm1b ] let @xmath17 be an action and @xmath525 be states .",
    "then , we have @xmath526    let @xmath527 and @xmath528 .",
    "as @xmath529 , it follows from corollary [ corol1 ] that to prove this lemma , it suffices to prove that @xmath530    it is easy to see that @xmath531 therefore , by corollary [ corol1 ] , we have @xmath532    proof done .      [ lm - prop - res - nonsense ] for every state @xmath533 , we have @xmath534    let @xmath65 denote @xmath535 .",
    "by corollary [ corol1 ] , since @xmath536 , we have @xmath537    we now show that , for every @xmath538 , @xmath539 by induction on @xmath540 .    * * base case : * @xmath541 .",
    "let @xmath9 be a literal in @xmath542 .",
    "we need to prove that @xmath543 .",
    "+ by the definition of @xmath508 , it follows that @xmath544 and , in addition , there exists a static causal law @xmath545 in @xmath31 such that @xmath546 by ( [ lm - sound1 - 2 ] ) , we have @xmath547 . by ( [ lm - sound1 - 2_1 ] )",
    ", we have @xmath548 .",
    "accordingly , we have @xmath549 . on the other hand , because @xmath550 , we have @xmath551 it follows from ( [ lm - sound1 - 3 ] ) that @xmath552 since @xmath553 . because of the completeness of @xmath100 , we have @xmath554 . on the other hand , by ( [ lm - sound1 - 0 ] )",
    ", we have @xmath555 . as a result , we have @xmath556 we now show that @xmath557 .",
    "suppose otherwise , that is , @xmath558 .",
    "this implies that @xmath559 . by ( [ lm - sound1 - 2_1 ] )",
    ", it follows that @xmath560 and this is a contradiction to ( [ lm - sound1 - 2 ] ) .",
    "thus , @xmath557 .",
    "+ on the other hand , we know that @xmath561 and thus we have @xmath562 . in addition , it is easy to see that @xmath563 .",
    "therefore , we have @xmath564 from ( [ lm - sound1 - 3_1 ] )  ( [ lm - sound1 - 5 ] ) , and by the definition of @xmath565 , we can conclude that @xmath543 .",
    "the base case is thus true . *",
    "* inductive step : * assume that ( [ lm - sound1 - 1 ] ) is true for all @xmath566 .",
    "we need to prove that it is true for @xmath567 .",
    "let @xmath9 be a literal in @xmath568 .",
    "we will show that @xmath569 .",
    "+ by the definition of @xmath508 , there exists a static causal law @xmath545 in @xmath31 such that @xmath570 because @xmath571 , we have @xmath572 . in addition , by ( [ lm - sound1 - 0 ] ) , @xmath573 is a subset of @xmath100 . a a result , we have @xmath574 it is easy to see that @xmath575 for if otherwise then , by the definition of @xmath508 , @xmath9 must be in @xmath576 , which is impossible . in other words",
    ", there exists @xmath577 such that @xmath578 but @xmath579 . by the inductive hypothesis",
    ", we have @xmath580 , which implies that @xmath581 because @xmath582 , we have @xmath583 . as a result , @xmath547 . on the other hand , since @xmath584 , it follows that @xmath549 .",
    "thus , we have @xmath585 from ( [ lm - sound1 - 8 ] )  ( [ lm - sound1 - 10 ] ) , and by the definition of @xmath586 , it follows that @xmath569 .",
    "so the inductive step is proven .",
    "as a result , it is always the case that ( [ lm - sound1 - 1 ] ) holds .",
    "hence , we have @xmath587 and thus , @xmath588 accordingly , by lemma ( [ lm1 ] ) and by the definition of @xmath125 , we have @xmath589 the lemma is thus true .",
    "we now prove proposition [ prop - res - nonsense ] .",
    "let @xmath590 let @xmath100 be some state in @xmath105 .",
    "such an @xmath100 exists because @xmath31 is consistent . by lemma [ lm1b ] and by definition [ def_compl ]",
    ", we have @xmath591 where @xmath592    to prove proposition [ prop - res - nonsense ] , it suffices to prove that @xmath593 . but first of all , let us prove , by induction , the following @xmath594 for every integer @xmath122 .    * * base case : * @xmath595",
    ". assume that @xmath596 .",
    "we need to show that @xmath548 .",
    "there are two possibilities for @xmath597 . *",
    "* _ @xmath126_. it is easy to see that @xmath548 because @xmath598 * * _ @xmath599 , @xmath600 , and @xmath601_. since @xmath187 , we have @xmath559 . because of the completeness of @xmath95 , it follows that @xmath602 .",
    "accordingly , we have @xmath603 on the other hand , because @xmath601 , @xmath602 , and @xmath604 , we have @xmath605 from ( [ lm - sound1ness-1 ] ) and ( [ lm - sound1ness-2 ] ) , it follows that @xmath71 .",
    "in addition , since @xmath601 , by lemma [ lm - prop - res - nonsense ] , we have @xmath606 .",
    "accordingly , we have @xmath607 . because @xmath100 is complete",
    ", we can conclude that @xmath548 . *",
    "* inductive step : * assume that ( [ lm - sound1ness-0 ] ) is true for all @xmath566 .",
    "we need to show that @xmath608 .",
    "let @xmath9 be a literal in @xmath609 . by the definition of @xmath609 ,",
    "there are two possibilities for @xmath9 : * * _ @xmath610_. clearly , in this case , we have @xmath548 . * * _ there exists a static causal law @xmath545 in @xmath31 such that @xmath611_. + by the inductive hypothesis , we have @xmath552 .",
    "hence , @xmath9 must hold in @xmath100 . + therefore , in both cases , we have @xmath548 .",
    "this implies that @xmath612 .    as a result , ( [ lm - sound1ness-0 ] ) always holds . by lemma [ lm1",
    "] , we have @xmath613 since @xmath100 is a state , @xmath132 is consistent .",
    "thus , by the definition of the @xmath158-function , we have @xmath614 furthermore , @xmath593 for every @xmath615 .",
    "the proposition is proven .",
    "since @xmath118 is valid , there exists a state @xmath95 such that @xmath160 .",
    "on the other hand , we assume that in every state of the world , exactly one literal in @xmath21 holds , there exists a literal @xmath616 such that @xmath22 holds in @xmath95 and for all @xmath617 , @xmath23 does not hold in @xmath95 .",
    "accordingly , we have @xmath618 . by corollary [ corol1 ]",
    ", we have @xmath619 .",
    "hence , @xmath132 is consistent . by the definition of the @xmath620function , we have @xmath621 . since @xmath622",
    ", @xmath132 is a valid a - state .",
    "the proposition is thus true .",
    "let us prove this proposition by using structural induction on @xmath45 .",
    "* _ @xmath174$]_. trivial . * _ @xmath176 $ ] , where @xmath177 is a conditional plan and @xmath17 is a non - sensing action_. + assume that proposition [ prop - cons - action - theory ] is true for @xmath177 .",
    "we need to prove that it is also true for @xmath45 .",
    "+ suppose @xmath208 .",
    "clearly we have @xmath188 .",
    "+ therefore , we have @xmath623 . on the other hand ,",
    "since @xmath118 is a valid a - state , it follows from proposition [ prop - res - nonsense ] that @xmath161 for some valid a - state @xmath132 . + as a result , we have @xmath624 contains at least one valid a - state . hence , @xmath208 contains at least one valid a - state . * _ @xmath179 $ ] , where a is a sensing action that senses @xmath625_. + assume that proposition [ prop - cons - action - theory ] is true for @xmath48 s .",
    "we need to prove that it is also true for @xmath45 .",
    "+ because @xmath208 , we have @xmath188 . by the definition of the @xmath64-function",
    ", we have @xmath623 . as @xmath118 is valid , by proposition",
    "[ prop - res - sense ] , @xmath170 contains at least one valid a - state @xmath132 .",
    "+ by the definition of the @xmath620function for sensing actions , we know that @xmath626 for some @xmath113 .",
    "this implies that @xmath51 holds in @xmath132 .",
    "+ by the inductive hypothesis , we have @xmath627 contains at least one valid a - state .",
    "+ by the definition of the @xmath173-function , we have @xmath628 .",
    "thus , @xmath629 contains at least one valid a - state .",
    "let @xmath241 denote the size of @xmath31 .",
    "because of lemma [ lm1 ] , we can conclude that for any set of literals @xmath65 , computing @xmath630 can be done in polynomial time in @xmath241 .",
    "observe that for a non - sensing action @xmath17 and an a - state @xmath118 , computing @xmath124 and @xmath125 can be done in polynomial time in @xmath241 .",
    "thus , computing @xmath189 can be done in polynomial time in @xmath241 .",
    "likewise , computing @xmath189 for a sensing action @xmath17 can also be done in polynomial time in @xmath241 .",
    "hence , proposition [ prop - trans1 ] holds .",
    "the proof is similar to the proof of theorem 3 in @xcite which states that the conditional planning problem with respect to the 0-approximation in @xcite is * np*-complete .",
    "membership follows from corollary [ cor1 ] .",
    "hardness follows from the fact that the approximation proposed in this paper coincides with the 0-approximation in @xcite , i.e , the conditional planning problem considered in this paper coincides with the planning problem with limited - sensing in @xcite which is * np*-complete . by the restriction principle , we conclude that the problem considered in this paper is also * np*-complete .",
    "this section contain proofs related to the correctness of @xmath631 . before we present the proofs ,",
    "let us introduce some notations that will be used throughout the rest of the appendix . given a program @xmath434 , by @xmath632 we mean the set of atoms in @xmath434 .",
    "if @xmath633 is a splitting set for @xmath434 and @xmath634 is a set of atoms then by @xmath635 and @xmath636 , we mean the bottom part of @xmath434 w.r.t . @xmath633 and the evaluation of the top part w.r.t .",
    "@xmath637 ( see @xcite for more information about these notions ) .",
    "[ l3 ]    * let @xmath434 be a logic program .",
    "suppose @xmath434 can be divided into two disjoint subprograms @xmath638 and @xmath639 , i.e. , @xmath640 and @xmath641 .",
    "then @xmath381 is an answer set for @xmath434 if and only if there exist two sets @xmath642 and @xmath643 of atoms such that @xmath644 and @xmath642 and @xmath643 are answer sets for @xmath638 and @xmath639 respectively . *",
    "the result in item 1 can be generalized to @xmath241 disjoint subprograms , where @xmath241 is an arbitrary integer .",
    "the first item can easily proved by using the splitting set @xmath645 .",
    "the second item immediately follows from this result .",
    "suppose we are given a planning problem instance @xmath233 and @xmath248 , where @xmath387 and @xmath388 are some integers , returns an answer set @xmath381 .",
    "the proof is primarily based on the splitting set and splitting sequence theorems described in @xcite .",
    "it is organized as follows .",
    "we first prove a lemma related to the closure of a set of literals ( lemma [ l2 ] ) . together with lemma [ l3 ] , this lemma is used to prove some properties of @xmath248 ( lemmas [ l4 ] , [ l51 ] & [ l52 ] ) . based on these results ,",
    "we prove the correctness of @xmath248 in implementing the @xmath64 and @xmath646 functions ( lemma [ l6 ] & lemma [ l7 ] ) . theorem [ t1 ] can be derived directly from lemma [ l7 ] .",
    "recall that we have made certain assumptions for action theories given to : _ ( a ) _ for every k - proposition @xmath647 , @xmath648 contains at least two elements ; and _ ( b ) _ for every static causal law @xmath649 , @xmath19 is not an empty set .",
    "the following lemma shows a code fragment that correctly encodes the closure of a set of literals .",
    "[ l2 ] let @xmath540 and @xmath113 be two integers greater than 0 , and @xmath270 be a 3-ary predicate .",
    "for any set @xmath65 of literals , the following program @xmath650 has the unique answer set @xmath651 .    by the definition of a model of a positive program , it is easy to see that the above program has the unique answer set @xmath652 ( see lemma [ lm1 ] ) .",
    "before showing some lemmas about the properties of @xmath248 , let us introduce some notions and definitions that will be used throughout the rest of this section .",
    "we first define some sets of atoms which will frequently be used in the proofs of lemmas [ l4 ]  [ l7 ] and theorem [ t1 ] .",
    "then we divide the program @xmath248 into small parts to simplify the proofs . in particular , @xmath248 is divided into two programs @xmath653 and @xmath654 .",
    "the former consists of normal logic program rules while the latter consists of constraints in @xmath248 .",
    "then we use the splitting set theorem to remove from @xmath653 auxiliary atoms such as @xmath655 , @xmath656 , @xmath657 , @xmath658 , etc .",
    "the resulting program , denoted by @xmath659 , consists of `` main '' atoms only .",
    "we then use the splitting sequence theorem to further split @xmath659 into a set of programs @xmath660 s .",
    "intuitively , each @xmath660 corresponds to a `` cut '' of @xmath659 at time point @xmath540 .",
    "finally , each @xmath660 is divided into disjoint subprograms @xmath661 s , each of which , intuitively , is a `` cut '' of @xmath660 at a specific path .    for @xmath662 and @xmath663 ,",
    "let @xmath664 be the set of all the atoms of the form @xmath665 , @xmath666 , @xmath667 , @xmath668 , @xmath669 , @xmath670 ( @xmath671 ) , @xmath672 , @xmath673 , i.e. , @xmath674 and let @xmath675 for a set of atoms @xmath676 and a set of predicate symbols @xmath483 , by @xmath677 we denote the set of atoms in @xmath634 whose predicate symbols are in @xmath483 and by @xmath678 , we mean @xmath679 .",
    "observe that @xmath248 can be divided into two parts ( 1 ) @xmath653 consisting of normal logic program rules , and ( 2 ) @xmath654 consisting of constraints . since @xmath381 is an answer set for @xmath248 returns @xmath381 as an answer set .",
    "] , @xmath381 is also an answer set for @xmath653 and does not violate any constraint in @xmath654 .",
    "let @xmath680 be the set of atoms in @xmath248 whose parameter list does not contain either the time or path variable .",
    "specifically , @xmath680 is the following set of atoms @xmath681 it is easy to see that @xmath680 is a splitting set for @xmath653 .",
    "furthermore , the bottom part @xmath682 is a positive program and has only one answer set @xmath683 .",
    "the partial evaluation of the top part of @xmath684 with respect to @xmath685 , @xmath686 is the following set of rules ( the condition for each rule follows that rule ; and , by default @xmath280 and @xmath45 are in ranges @xmath687 and @xmath688 unless otherwise specified ) : @xmath689 and @xmath654 is the following collection of constraints @xmath690 note that choice rules of the form @xmath691 have been translated into @xmath692 and @xmath693    by the splitting set theorem , there exists an answer set @xmath694 for @xmath659 such that @xmath695 .",
    "let @xmath696 be the set of atoms in @xmath659 whose time parameter is less than or equal to @xmath540 , i.e. , @xmath697 it is easy to see that the sequence @xmath698 is a splitting sequence for @xmath659 . by the splitting sequence theorem , since @xmath694 is an answer set for @xmath659 , there must be a sequence of sets of literals @xmath699 such that @xmath700 , and    * @xmath701 * @xmath702 is an answer set for @xmath703 * for every @xmath704 , @xmath705 is an answer set for @xmath706    given a set of atoms @xmath634 , consider rules of the following forms : @xmath707 then for each @xmath708 , @xmath660 can be divided into @xmath249 disjoint subprograms @xmath661 , @xmath663 , where @xmath661 is defined as follows @xmath709 let @xmath710 denote @xmath711 . from lemma",
    "[ l3 ] , it follows that @xmath710 is an answer set for @xmath661 .",
    "hence , we have @xmath712 due to this fact , from now on , we will use @xmath713 to refer to either @xmath714 , @xmath715 , @xmath716 , or @xmath717 .",
    "we have the following lemma    [ l4 ] for @xmath662 and @xmath663 ,    * if @xmath718 then @xmath381 does not contain any atoms of the forms @xmath669 , @xmath672 , @xmath719 ; * if @xmath720 and @xmath721 is consistent then @xmath722    * we will use induction on @xmath540 to prove this item . * * * base case : * @xmath723 . let @xmath113 be an integer such that @xmath724 .",
    "clearly we have @xmath725 . on the other hand , it is easy to see that ( by using the splitting set @xmath726 ) if @xmath725 then @xmath381 does not contain atoms of the forms @xmath727 , @xmath728 , and @xmath729 .",
    "thus , the base case is true . * * * inductive step : * assume that item 1 is true for @xmath730 , where @xmath731",
    ". we will prove that it is also true for @xmath732 .",
    "let @xmath113 be an integer such that @xmath733 .",
    "+ clearly , to prove item 1 we only need to prove that atoms of the forms @xmath734 , @xmath735 , @xmath736 do not belong to @xmath737 . consider the program @xmath738 ( see ( [ def_pi_i_k ] ) ) .",
    "we know that @xmath737 is an answer set for @xmath738 .",
    "+ because of rule ( [ r1_30 ] ) , we have @xmath739 . from ( [ r1_19 ] ) , it follows that @xmath740 for every pair @xmath741 such that @xmath742 .",
    "in addition , by the inductive hypothesis , we have that for any @xmath9 and @xmath22 , @xmath743 , @xmath744 , and @xmath745 are not in @xmath746 . as a result",
    ", rules ( [ r1_13])-([r1_21 ] ) do not exist in @xmath747 .",
    "if we split @xmath738 by the set @xmath748 then @xmath749 is the set of rules of the forms * * * ( [ r1_3 ] ) , ( [ r1_6 ] ) , ( [ r1_9])([r1_11 ] ) , ( [ r1_22 ] ) if @xmath750 * * * ( [ r1_10])([r1_11 ] ) if @xmath751 + it is not difficult to show that this program has the empty set as its only answer set ( recall that @xmath504 ) . from this , we can conclude the inductive step . * it is obvious because of the rules ( [ r0_11 ] ) , ( [ r0_11_2 ] ) and the constraint ( [ r0_12 ] ) .    [ l51 ] for @xmath752 and @xmath663 , if @xmath753 then @xmath17 is executable in @xmath713 and there is no @xmath754 such that @xmath755 .    from constraint ( [ r0_23 ] )",
    ", it follows that @xmath756 .",
    "notice only rules of the form ( [ r0_2 ] ) may have @xmath666 as its head .",
    "hence , there must be a proposition ( [ exec ] ) in @xmath31 such that @xmath18 holds in @xmath713 .",
    "this means @xmath17 is executable in @xmath713 .    if there exists @xmath754 such that @xmath755 then constraint ( [ r0_22_2 ] ) could not be satisfied .",
    "[ l52 ] for @xmath752 and @xmath663    * if @xmath753 and @xmath17 is a non - sensing action then * * @xmath757 iff @xmath758 * * @xmath759 iff @xmath760 * * @xmath761 * if @xmath753 and @xmath17 is a sensing action @xmath17 with occurring in a k - proposition of the form ( [ knowledge ] ) in @xmath31 and @xmath47 then there exist @xmath241 distinct integers @xmath762 greater than or equal to @xmath113 such that * * @xmath763 * * @xmath50 does not hold in @xmath713 , * * if @xmath764 then @xmath381 does not contain any atoms of the form @xmath765 * if @xmath766 for every action @xmath17 then * * @xmath767 * * @xmath768    let us split @xmath661 by the set @xmath769 . by the splitting set theorem , @xmath770 where @xmath771 is an answer set for @xmath772 and @xmath773 is an answer set for @xmath774 , which consists of the following rules @xmath775 from the splitting set theorem",
    ", it follows that @xmath776    * assume that @xmath753 and @xmath17 is a non - sensing action . by lemma [ l51 ] , we know that there exists no sensing action itself is not a sensing action . ]",
    "@xmath200 such that @xmath755 .",
    "this means that rules of form ( [ l5_r1_6 ] ) does not exist .",
    "therefore , @xmath638 can be rewritten to @xmath777 if we continue splitting the above program using @xmath778 then by lemma [ l2 ] , the bottom part has the only answer set @xmath779 and the evaluation of the top part has the only answer set @xmath780 due to the fact that @xmath771 does not contain any atoms of the form @xmath672 or @xmath673 , we therefore can conclude items ( a ) and ( b ) .",
    "+ we now show that @xmath781 .",
    "suppose otherwise , i.e. , there exists @xmath22 and @xmath782 such that @xmath783 .",
    "notice that only rule ( [ r0_22 ] ) with @xmath784 and @xmath785 has @xmath665 in its head .",
    "hence , its body must be satisfied by @xmath381 .",
    "that implies @xmath786 .",
    "+ on the other hand , since only rules of the form ( [ r0_6 ] ) with @xmath787 may have @xmath788 in its head , there exists a sensing action @xmath200 such that @xmath789 and in addition , @xmath790 . as the sets of non - sensing actions and sensing actions are disjoint from each other",
    ", we have @xmath754 . from lemma [ l51 ]",
    ", it follows that @xmath742 .",
    "+ accordingly , we have @xmath791 and @xmath742 .",
    "constraint ( [ r0_18 ] ) with @xmath784 , @xmath792 , and @xmath793 is thus violated .",
    "thus , item ( c ) holds .",
    "* assume that @xmath753 and @xmath17 is a sensing action occurring in a k - proposition of the form ( [ knowledge ] ) in @xmath31 with@xmath47 .",
    "+ in this case , since rules of the forms ( [ l5_r1_3 ] ) and ( [ l5_r1_4 ] ) do not exist , @xmath638 is the following set of rules @xmath794 by further splitting the above program using the set @xmath795 , we will see that the bottom part has the empty set as its only answer set ( recall that we are assuming that the body of each static law of the form ( [ static ] ) is not empty ) .",
    "therefore , the answer set for the above program is also the answer set for the following program and vice versa .",
    "@xmath796 thus , there exist @xmath241 integers @xmath797 ,",
    "@xmath474 , @xmath798 greater than or equal to @xmath113 such that @xmath799 it is easy to see that @xmath800 . in addition , by constraints of the form ( [ r0_17 ] ) , @xmath801 s must be distinct .",
    "thus , items ( a ) is true .",
    "+ item ( b ) can be drawn from constraints of the form ( [ r0_7 ] ) .",
    "+ assume @xmath764 .",
    "because of constraints of the form ( [ r0_18 ] ) , we have @xmath802 . from lemma [ l4 ]",
    ", it follows that @xmath381 does not contain any atoms of the form @xmath765 .",
    "item ( c ) is thus true .",
    "* @xmath766 for every action @xmath17 . in this case",
    ", @xmath638 is the following set of rules @xmath803 which has an empty set as its only answer set .",
    "items ( a)(b ) follow from this .",
    "the following lemma shows that @xmath248 correctly implements the transition function @xmath64 .",
    "[ l6 ] for @xmath752 and @xmath663    * if there exists a non - sensing action @xmath17 such that @xmath753 then @xmath804 * if there exists a sensing action @xmath17 occurring in a k - proposition of the form ( [ knowledge ] ) in @xmath31 with @xmath805 such that @xmath753 then there exist @xmath241 integers @xmath806 such that @xmath807 and for each @xmath255 , @xmath50 holds in @xmath808 ; * if @xmath766 for every action @xmath17 , @xmath809    * assume that there exists a non - sensing action @xmath17 such that @xmath810 . + observe that @xmath811 is a splitting set for @xmath812 .",
    "hence , by the splitting set theorem , @xmath813 , where @xmath814 is an answer set for @xmath815 and @xmath773 is an answer set for @xmath816 .",
    "+ notice that by lemma [ l52 ] , rules ( [ r1_20])([r1_21 ] ) for @xmath817 , @xmath818 do not exist .",
    "thus , @xmath638 is the following set of rules : @xmath819 also by lemma [ l52 ] , the conditions for the second and third rules can be written as @xmath820 and @xmath821 respectively .",
    "thus , by lemma [ l2 ] , @xmath638 has the unique answer set @xmath822 on the other hand , by lemma [ l51 ] , @xmath17 is executable in @xmath713 . from the definition of the @xmath823 and @xmath64 functions",
    ", it follows that @xmath824 * assume that there exists a sensing action @xmath17 with a k - proposition of the form ( [ knowledge ] ) and @xmath825 such that @xmath753 .",
    "+ by lemma [ l52 ] , for each @xmath826 , there exists @xmath827 such that @xmath828 .",
    "it is easy to see that @xmath829 is a splitting set for @xmath830 .",
    "considering cases @xmath831 and @xmath764 in turn and observe that @xmath832 if @xmath764 , we will see that in both cases @xmath833 is the following set of rules : @xmath834 by lemma [ l2 ] , the only answer set for the above program is @xmath835 on the other hand , by lemma [ l51 ] , @xmath17 is executable in @xmath713 and by lemma [ l52 ] , @xmath50 does not hold in @xmath713 .",
    "thus , according to the definition of the transition function , we have @xmath836 hence , we have @xmath837 @xmath838 and obviously , @xmath50 holds in @xmath808 .",
    "* assume that @xmath766 for every action @xmath17 .",
    "+ similar to the first case , @xmath839 is a splitting set for @xmath812 .",
    "@xmath840 is the following set of rules : @xmath841 + because that @xmath713 is an a - state ( lemma [ l4 ] ) , by lemma [ l2 ] the only answer set for this program is @xmath842 thus , we have @xmath843    the following lemma shows that @xmath248 correctly implements the extended transition function .    [ l7 ]",
    "we have    @xmath168 is the initial a - state for @xmath844 .    for every pair of integers @xmath845 , @xmath663 ,",
    "if @xmath786 then    @xmath846 is a conditional plan    furthermore , if @xmath713 is consistent then for every @xmath847 , @xmath393 .",
    "@xmath848 is a splitting set for @xmath849 .",
    "the bottom part , @xmath850 , consists of the following rules : @xmath851 by lemma [ l2 ] , the only answer set for the above program is @xmath852 where @xmath407 is the initial a - state of @xmath235 .",
    "thus , @xmath853 is the initial a - state of @xmath844 .",
    "we now prove item 2 by induction on parameter @xmath540 .",
    "* base case : * @xmath854 .",
    "let @xmath113 be an arbitrary integer between 1 and @xmath249 such that @xmath786 .",
    "clearly @xmath855 $ ] is a conditional plan .",
    "now suppose that @xmath713 is consistent .",
    "according to the definition of the extended transition function , we have @xmath856,\\delta_{i , k } ) = \\ { \\delta_{i , k } \\}\\ ] ] on the other hand , by lemma [ l4 ] , we have that @xmath857 .",
    "thus , item 2 is true for @xmath858 .",
    "* inductive step : * assume that item 2 is true for all @xmath859",
    ". we will show that it is true for @xmath860 .",
    "let @xmath113 be an integer between 1 and @xmath249 such that @xmath861 .",
    "consider three possibilities :    @xmath862 for some non - sensing action @xmath17 . by the definition of @xmath863",
    ", we have @xmath864 $ ] . in addition , by rule ( [ r0_30 ] ) we have @xmath865 @xmath866 .",
    "thus , according to the inductive hypothesis , @xmath867 is a conditional plan .",
    "accordingly , @xmath863 is also a conditional plan .",
    "now suppose that @xmath868 is consistent .",
    "consider two cases    * _ @xmath869 is consistent .",
    "_ we have @xmath870 , \\delta_{t , k } ) = \\hat \\phi(p^k_{t{+}1}(s),\\delta_{t{+}1,k})\\ ] ] ( by lemma [ l6 ] and by the definition of the extended transition function ) .",
    "+ on the other hand , according to the inductive hypothesis , for every @xmath118 in @xmath871 , @xmath393 . hence",
    ", the inductive step is proven . *",
    "_ @xmath869 is inconsistent .",
    "_ by lemma [ l6 ] , we have @xmath872 .",
    "thus , the inductive step is proven .",
    "@xmath862 for some sensing action @xmath17 with a k - proposition of the form ( [ knowledge ] ) and @xmath805 . by lemma",
    "[ l52 ] there exist exactly @xmath241 integers @xmath762 greater than @xmath113 such that @xmath873 for @xmath874 .",
    "this implies that @xmath875 ( see rules ( [ r0_19 ] ) and ( [ r0_30 ] ) ) .",
    "thus , by the definition of @xmath863 , we have @xmath876 $ ] . on the other hand , we know by the inductive hypothesis that @xmath877 is a conditional plan for @xmath874 . as a result ,",
    "@xmath863 is also a conditional plan .",
    "suppose @xmath713 is consistent .",
    "let @xmath878 .",
    "by lemma [ l6 ] , we have @xmath879 and @xmath50 holds in @xmath880 for every @xmath874 .",
    "hence , by the definition of @xmath173 , we have @xmath881 according to the inductive hypothesis , for every @xmath882 , where @xmath883 , we have @xmath393 .",
    "this implies that for every @xmath884 , we have @xmath393 .",
    "there is no action @xmath17 such that @xmath862 .",
    "according to the definition of @xmath885 , @xmath886 $ ] .",
    "hence , it is a conditional plan .",
    "it is easy to see that @xmath887 , which means that either @xmath868 is inconsistent or @xmath888 ( see rules ( [ r0_11 ] ) , ( [ r0_11_2 ] ) , and ( [ r0_22 ] ) ) .",
    "now suppose that @xmath868 is consistent .",
    "this implies that @xmath888 .",
    "we have @xmath889,\\delta_{t , k } ) = \\ { \\delta_{t , k}\\}\\ ] ] thus , the inductive step is proven .",
    "theorem [ t1 ] immediately follows from lemma [ l7 ] .",
    "first , we prove the following lemma .",
    "[ lm - reduct ] let @xmath890 be a planning problem instance , @xmath118 be an a - state and @xmath45 be a plan .",
    "if @xmath891 then @xmath892 .",
    "let us prove the lemma by structural induction on @xmath45 .",
    "* _ @xmath174$]_. + the proof is trivial since @xmath893 $ ] . *",
    "assume that _",
    "@xmath176 $ ] , where @xmath177 is a conditional plan and @xmath17 is a non - sensing action and the lemma is true for @xmath177_. + suppose @xmath891 .",
    "we need to show that @xmath892 .",
    "+ if @xmath393 then @xmath894,\\delta ) = \\ { \\delta \\ } \\models \\calg\\ ] ] + now consider the case that @xmath895 . + clearly , we have @xmath188 . therefore , @xmath184 for some @xmath132 . hence , by the definition of @xmath390 , we have @xmath896 thus , @xmath897 + on the other hand , we have @xmath898 + because @xmath891 , we have @xmath899 + by inductive hypothesis , we have @xmath900 + hence , @xmath901 * assume that _ @xmath902 $ ] , where a is a sensing action that senses @xmath625 , and the lemma for @xmath48s_. + suppose @xmath891 .",
    "we need to show that @xmath892 .",
    "+ if @xmath393 then @xmath894,\\delta ) = \\ { \\delta \\ } \\models \\calg\\ ] ] + now consider the case that @xmath895 .",
    "there are two possibilities . *",
    "* _ there exists @xmath51 such that @xmath903_. by the definition of @xmath390 , we have @xmath904 by the definition of the @xmath646-function , it is easy to see that @xmath905 since @xmath891 , we have @xmath906 . by the inductive hypothesis , we have @xmath907 hence , we have @xmath908 * * _ for every @xmath874 , @xmath909_. by the definition of @xmath390 , we have @xmath910 where @xmath398 & \\textnormal { if } cl_{\\cald}(\\delta \\cup \\{g_j\\ } )      \\textnormal { is inconsistent } \\\\      \\reduct_{cl_{\\cald}(\\delta \\cup \\{g_j\\ } ) } ( p_j )       & \\textnormal { otherwise }    \\end{array } \\right.\\ ] ] for every @xmath874 , let @xmath911",
    ". let @xmath912 .",
    "it is easy to see that @xmath913 because @xmath50 holds in @xmath190 but for every @xmath914 , @xmath51 does not hold in @xmath190 .",
    "+ because @xmath891 , we have @xmath915 for every @xmath883 .",
    "+ on the other hand , we have @xmath398 & \\textnormal { if } j \\not \\in j \\\\      \\reduct_{\\delta_j } ( p_j )       & \\textnormal { otherwise }    \\end{array } \\right.\\ ] ] thus , @xmath916 by the inductive hypothesis , for every @xmath883 , as @xmath917 , we have @xmath918 . as a result , we have @xmath908    we now prove proposition [ prop - reduct ] .",
    "let @xmath45 be a solution to @xmath235 . from the construction of @xmath390 ,",
    "it is easy to see that @xmath420 is unique .    by lemma [ lm - reduct ]",
    ", we have that @xmath919 .",
    "thus , @xmath420 is also a solution to @xmath235 .",
    "so , we can conclude the proposition .",
    "the idea of the proof is as follows .",
    "let @xmath177 be @xmath392 , where @xmath118 is the initial a - state of @xmath235 , and let @xmath253 be the labeled tree for @xmath177 numbered according to the principles described in section [ planner ] .",
    "let @xmath115 and @xmath249 denote the height and width of @xmath253 respectively . for @xmath662 , @xmath663 , we define @xmath713 to be the a - state at node @xmath385 in @xmath253 ] of @xmath253 if such a node exists and @xmath185 otherwise . based on @xmath253 and @xmath713",
    ", we construct the set @xmath921 of atoms that hold at node @xmath385 .",
    "then we prove that the union of these sets , denoted by @xmath922 , is an answer set for @xmath659 ( rules ( [ r0_1])-([r0_30 ] ) ) by showing that each @xmath921 is an answer set for a part of @xmath659 , denoted by @xmath923 .",
    "furthermore , a set @xmath924 can be constructed from @xmath922 in such a way that it is an answer set for @xmath653 .",
    "moreover , @xmath924 does not violate any constraints in @xmath925 ( rules ( [ r0_5])-([r0_23 ] ) ) .",
    "as such , it is an answer set for @xmath248 .",
    "moreover , @xmath926 .    given the numbered tree @xmath253 , by @xmath927 we mean the node labeled with @xmath17 and numbered with @xmath385 in @xmath253 ; by @xmath928 we mean the link , whose label is @xmath22 , between the nodes @xmath385 and @xmath929 in @xmath253 .    for @xmath662 , @xmath663 , we define the a - state @xmath713 as follows .    *",
    "if @xmath723 @xmath930 * if @xmath144 @xmath931    note that given @xmath385 , there exists at most one action @xmath17 such that @xmath932 , and furthermore , at most one pair @xmath741 such that @xmath933 .",
    "in addition , the conditions in equation ( [ delta_2 ] ) do not overlap each other .",
    "thus , @xmath713 is uniquely defined for @xmath662 and @xmath663 . in",
    "what follows , the undefined situation @xmath185 can sometimes be thought of as @xmath205 , depending the context in which it is used .",
    "let us construct the set @xmath921 of atoms based on @xmath713 as follows .",
    "1 .   @xmath934 2 .",
    "@xmath935 iif @xmath936 3 .",
    "@xmath937 iif there exists a proposition of the form ( [ exec ] ) s.t .",
    "@xmath938 4 .",
    "@xmath939 iif @xmath940 5 .",
    "@xmath941 iif @xmath928 for some @xmath942 6 .",
    "@xmath943 iif @xmath940 and @xmath944 for some non - sensing action @xmath17 7 .",
    "@xmath945 iif @xmath940 and @xmath760 for some non - sensing action @xmath17 8 .   for @xmath144 ,",
    "@xmath946 iif either 1 .",
    "@xmath947 ; or 2",
    ".   there exists @xmath741 s.t .",
    "@xmath948 9 .",
    "@xmath949 iff @xmath857 or @xmath713 is inconsistent 10 .",
    "nothing else in @xmath921    clearly , @xmath921 s are uniquely defined . furthermore , they are disjoint from each other .",
    "let @xmath950    [ lmb1 ] for @xmath752 and @xmath663 , let @xmath951 and let @xmath434 be the following program : @xmath952 then , @xmath953 is an answer set for @xmath434 .    given @xmath385 , there are three cases that may happen at node @xmath385 .",
    "* there exists a non - sensing action @xmath17 such that @xmath940 ; * there exists a sensing action @xmath17 such that @xmath940 ; * @xmath954 for every action @xmath17    let us consider each of those in turn .    *",
    "_ there exists a non - sensing action @xmath17 such that @xmath940 . _",
    "+ from the construction of @xmath921 , we know that @xmath955 and there is no @xmath754 such that @xmath956 .",
    "furthermore , due to the fact that @xmath773 does not contain any atom of the form @xmath669 , we have @xmath957 iff @xmath935 . that means @xmath957",
    "iff @xmath936 .",
    "+ hence , @xmath434 can be rewritten to : @xmath958 as have been seen in the proof of theorem [ t1 ] ( see the proof of lemma [ l52 ] , item 1 ) , the only answer set for this program is @xmath959 . * _ there exists a sensing action @xmath17 such that @xmath940 . _",
    "+ we have @xmath955 and there is no non - sensing action @xmath200 such that @xmath956 . as a result ,",
    "@xmath434 is @xmath960 it is easy that an answer set for @xmath434 is also an answer set for @xmath961 and vice versa . on the other hand",
    ", @xmath962 is an answer set for the latter program . as a result , @xmath773 is also an answer set for @xmath434 . * _",
    "@xmath954 for every action @xmath17 . _",
    "+ in this case , the first three rules of @xmath434 do not exist because @xmath963 for every @xmath17 .",
    "thus , @xmath434 consists of the last two rules only .",
    "it is easy to see that it has the empty set as its only answer set . on the other hand , from the construction of @xmath921",
    ", we have @xmath964 .",
    "accordingly , @xmath965 is an answer set for @xmath434 .",
    "the proof is done .",
    "[ lmb2 ] for @xmath662 , @xmath663 , @xmath921 is an answer set for @xmath966 , where @xmath966 is defined in the same way as @xmath967 except that we replace every occurrence of @xmath483 in equation ( [ def_pi_i_k ] ) by @xmath968 .",
    "let us consider in turn two cases @xmath541 and @xmath144 .",
    "it is easy to see that the only answer set for @xmath969 , where @xmath725 , is @xmath970 by using the splitting set @xmath971 ( see ( [ eq2 ] ) for the definition of @xmath664 ) and observe that the bottom part has the empty set as its only answer set and @xmath972 is the only answer set for the evaluation of the top part .",
    "we now prove that @xmath973 is an answer set for @xmath974 which consists of the rules of the forms ( [ r1_1])-([r1_11_2 ] ) , ( [ r1_22])-([r1_29 ] ) where @xmath975 and @xmath976 .",
    "if we use the set @xmath977 to split @xmath974 then @xmath978 is @xmath979    from the definition of @xmath973 , we can easily show that @xmath980 is an answer set for @xmath978 .",
    "furthermore , we have @xmath981    the evaluation of the top part , @xmath982 , is the following set of rules @xmath983 by lemma [ lmb1 ] , @xmath984 is an answer set for @xmath638 . as a result ,",
    "@xmath985 is an answer set for @xmath986 .",
    "@xmath704 .    using the splitting set @xmath987 to split @xmath988",
    ", we have that the bottom part @xmath989 consists of rules of the forms    @xmath251    ( [ r1_2 ] ) , ( [ r1_10])([r1_22 ] ) , and ( [ r1_30 ] ) if @xmath750    ( [ r1_10])([r1_21 ] ) , and ( [ r1_30 ] ) if @xmath751    we now prove that @xmath990 is an answer set for @xmath639 .",
    "let us further split @xmath639 by the set @xmath991 .",
    "then , the bottom part @xmath992 consists of rules of the forms ( [ r1_10 ] ) , ( [ r1_13])([r1_14 ] ) , ( [ r1_20])([r1_21 ] ) only .",
    "consider three cases    * _ there exists a non - sensing action @xmath17 such that @xmath993 . _",
    "+ from the construction of @xmath921 s , it is easy to see that there exists no @xmath741 such that @xmath994",
    ". thus , @xmath992 contains rules of the forms ( [ r1_10 ] ) , ( [ r1_13])([r1_14 ] ) only . on the other hand",
    ", we have @xmath995 @xmath996 hence , @xmath992 is the following collection of rules : @xmath997 by lemma [ l2 ] , it has the only answer set @xmath998 * @xmath999 .",
    "+ from the construction of @xmath1000 , such @xmath741 is unique and in addition @xmath790 .",
    "thus , @xmath992 is @xmath1001 or equivalently , @xmath1002 since if @xmath1003 then @xmath1004 . by lemma [ l2 ] , this program has the only answer set @xmath1005 hence , @xmath1006 is the only answer set for @xmath992 . * _",
    "@xmath1007 for every non - sensing action @xmath17 and @xmath1008 . _",
    "+ from the construction of @xmath921 s , it follows that @xmath1009 and @xmath1010 for every @xmath9 . hence , @xmath992 is the following set of rules @xmath1011 whose only answer set is @xmath1012    so , in all three cases , we have @xmath1006 is an answer set for @xmath992 .    hence , @xmath1013 is the following set of rules : @xmath1014 it is easy to see that @xmath1015 is an answer set for @xmath1016 .",
    "accordingly , we have @xmath1017 is an answer set for @xmath639 .",
    "@xmath1018 is thus the following set of rules : @xmath1019 by lemma [ lmb1 ] , @xmath953 is an answer set for @xmath1020 .    as a result ,",
    "@xmath1021 is an answer set for @xmath1022 .",
    "we have    * @xmath1023 is an answer set for @xmath1024 , where @xmath683 is defined in ( [ def_v ] ) .",
    "* @xmath1025    since @xmath921 is an answer set for @xmath1022 and @xmath1022 s are disjoint from each other , we have @xmath1026 is an answer set for @xmath1027 , where @xmath1027 is defined in the same way as @xmath660 except that every occurrence of @xmath483 in equations ( [ def_pi_1 ] ) and ( [ def_pi_i ] ) is replaced with @xmath968 . from the splitting sequence theorem",
    ", it follows that @xmath1028 is an answer set for @xmath659 .",
    "thus , @xmath924 is an answer set for @xmath653 .    on the other hand , it is not difficult to show that @xmath924 satisfies all constraints in @xmath653 based on the following observations .",
    "@xmath251    if @xmath939 for some sensing action @xmath17 which occurs in a k - proposition of the form ( [ knowledge ] ) then there exists @xmath22 in @xmath21 such that @xmath1029 .",
    "furthermore , for every @xmath1030 , @xmath23 does not in @xmath713 .",
    "the latter property holds because that @xmath177 does not contain an action that senses an already known - to - be - true literal .    if @xmath1031 then @xmath1032 .",
    "@xmath713 is either @xmath185 or an a - state .",
    "this means that @xmath1033 does not contain two atoms of the forms @xmath669 and @xmath1034 , where @xmath9 and @xmath1035 are contrary literals .",
    "no two branches come to the same node @xmath385 .    if @xmath1036 then @xmath1037 for any pair @xmath741 , @xmath1038 .",
    "if @xmath940 then @xmath17 must be executable in @xmath713 .",
    "accordingly , we have @xmath381 is an answer set for @xmath248 .",
    "immediate from the construction of @xmath921 .",
    "theorem [ t2 ] follows directly from this lemma .",
    "this appendix contains the encoding of the planning problem @xmath389 in example [ ex04 ] .",
    "the first subsection describes the input planning problem .",
    "the next subsection presents the corresponding logic program @xmath1039 .",
    "the last two subsections are the outputs of  and when this logic program is run with the parameters @xmath1040 and @xmath1041 .",
    ".... % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % usage :                                %      lparse -c h=<height > -c w=<width > | smodels % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % # domain fluent(f ) .",
    "# domain literal(l;l1 ) .",
    "# domain sense(g;g1;g2 ) . # domain time(t ) .",
    "# domain time1(t1 ) .",
    "# domain path(p;p1;p2 ) .",
    "# domain action(a ) .",
    "% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % action declarations % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % action(check ) .",
    "action(push_up ) .",
    "action(push_down ) .",
    "action(flip_lock ) .",
    "% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % fluent declarations % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % fluent(open ) .",
    "fluent(closed ) .",
    "fluent(locked ) .",
    "sense(open ) . sense(closed ) .",
    "sense(locked ) .",
    "% effects of non - sensing actions   e(closed , t+1,p ) : -          occ(push_down , t , p ) .",
    "pc(closed , t+1,p ) : -          occ(push_down , t , p ) .",
    "e(open , t+1,p ) : -          occ(push_up , t , p ) .",
    "pc(open , t+1,p ) : -          occ(push_up , t , p ) .",
    "e(locked , t+1,p ) : -          occ(flip_lock , t , p ) ,          holds(closed , t , p ) .",
    "pc(locked , t+1,p ) : -          occ(flip_lock , t , p ) ,          not holds(neg(closed),t , p ) .",
    "e(closed , t+1,p ) : -          occ(flip_lock , t , p ) ,          holds(locked , t , p ) .",
    "pc(closed , t+1,p ) : -          occ(flip_lock , t , p ) ,          not holds(neg(locked),t , p ) .",
    "% effects of sensing actions   : - occ(check , t , p ) ,          not br(open , t , p , p ) ,          not br(closed , t , p , p ) ,          not br(locked , t , p , p ) .",
    "1{br(open , t , p , x):new_br(p , x)}1 : -          occ(check , t , p ) .",
    "1{br(closed , t , p , x):new_br(p , x)}1 : -          occ(check , t , p ) . 1{br(locked , t , p , x):new_br(p , x)}1 : -          occ(check , t , p ) .",
    ": - occ(check , t , p ) ,          holds(open , t , p ) .",
    ": - occ(check , t , p ) ,          holds(closed , t , p ) .",
    ": - occ(check , t , p ) ,          holds(locked , t , p ) .",
    "pc(open , t+1,p ) : -          pc(neg(closed),t+1,p ) ,          not holds(open , t , p ) ,          not e(closed , t+1,p ) ,          not e(locked , t+1,p ) .",
    "pc(open , t+1,p ) : -          pc(neg(locked),t+1,p ) ,          not holds(open , t , p ) ,          not e(closed , t+1,p ) ,          not e(locked , t+1,p ) .",
    "pc(closed , t+1,p ) : -          pc(neg(open),t+1,p ) ,          not holds(closed , t , p ) ,          not e(open , t+1,p ) ,          not e(locked , t+1,p ) .",
    "pc(closed , t+1,p ) : -          pc(neg(locked),t+1,p ) ,          not holds(closed , t , p ) ,          not e(open , t+1,p ) ,          not e(locked , t+1,p ) .                    pc(locked , t+1,p ) : -          pc(neg(open),t+1,p ) ,          not holds(locked , t , p ) ,          not e(open , t+1,p ) ,          not e(closed , t+1,p ) .",
    "pc(locked , t+1,p ) : -          pc(neg(closed),t+1,p ) ,          not holds(locked , t , p ) ,          not e(open , t+1,p ) ,          not e(closed , t+1,p ) .",
    "% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % domain independent rules   % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % rules encoding the effects of non - sensing actions holds(l , t+1,p ) : -          e(l , t+1,p ) .",
    "smodels version 2.28 .",
    "reading ... done answer : 1 stable model :   br(open,1,1,2 ) occ(check,1,1 ) br(closed,1,1,1 )   br(locked,1,1,3 ) occ(flip_lock,2,1 )   true duration : 0.020 number of choice points : 2 number of wrong choices : 0 number of atoms : 313 number of rules : 893 number of picked atoms : 257 number of forced atoms : 31 number of truth assignments : 4052 size of searchspace ( removed ) : 12 ( 65 ) ....        cmodels cmodels version 3.01 reading ... done program is not tight .",
    "calling sat solver mchaff ... answer : 1   answer set : br(open,1,1,3 ) occ(check,1,1 ) br(closed,1,1,1 )   br(locked,1,1,2 ) occ(flip_lock,2,1 )   number of loop formulas 6 ....      , konczak , k. , and linke , t. 2002 .",
    "nomore : non - monotonic reasoning with logic programs . in _ proceedings of the 8th european workshop on logics in artificial intelligence 2002 _ , lnai 2424 .",
    "springer verlag .",
    ", mcilraith , s. , and son , t. 2000b . formulating diagnostic problem solving using an action language with narratives and sensing . in _ proceedings of the seventh international conference on principles of knowledge and representation and reasoning ( kr2000)_. 311322 .    , cimatti , a. , and roveri , m. 2001 .",
    "heuristic search + symbolic model checking = efficient conformant planning . in _ proceedings of the seventeenth international joint conference on artificial intelligence_. morgan kaufmann , 467472 .",
    "planning with incomplete information as heuristic search in belief space . in _",
    "proceedings 6th international conference on artificial intelligence planning and scheduling _ , s.  chien , s.  kambhampati , and c.  knoblock , eds .",
    "aaai press , 5261 .",
    "conformant planning via heuristic forward search : a new approach . in _ proceedings of the 14th international conference on automated planning and scheduling ( icaps-04 ) _ , s.  koenig , s.  zilberstein , and j.  koehler , eds .",
    "morgan kaufmann , whistler , canada , 355364 .              ,",
    "eiter , t. , faber , w. , gottlob , g. , koch , c. , leone , n. , mateis , c. , pfeifer , g. , and scarcello , f. 1997 .",
    "the dlv system : model generator and application frontends . in _ proceedings of the 12th workshop on logic programming_. 128137 .    ,",
    "nebel , b. , and koehler , j. 1997 .",
    "encoding planning problems in non - monotonic logic programs . in _ recent advances in ai planning , 4th european conference on planning , ecp97 , toulouse , france , september 24 - 26 , 1997 , proceedings_. springer , 169181 .                1996b .",
    "representing sensing actions : the middle ground revisited . in _ proceedings of the fifth international conference on principles of knowledge representation and reasoning ( kr96)_. morgan kaufmann publishers , 174185 .",
    "in _ proceedings of the 7th international conference on logic programming and nonmonotonic reasoning conference ( lpnmr04 ) _ , v.  lifschitz and i.  niemel , eds .",
    "springer verlag , lncs 2923 , 346350 .",
    "\\1999 . answer set planning . in _ proceedings of the 1999 international conference on logic programming_.",
    "massachusetts institute of technology , cambridge , ma , usa , 2337 .",
    "answer set programming and plan generation .",
    "_ 138 , _  1 - 2 , 3954 .        ,",
    "taylor , s. , and mendez , g. 1997 .",
    "adding knowledge to the action description language @xmath4 . in _ proceedings of the fourteenth national conference on artificial intelligence ( aaai97 )",
    "_ , aaai press . 454459",
    ".      \\1995 . a causal theory of ramifications and qualifications . in _ proceedings of the 14th international joint conference on artificial intelligence_. morgan kaufmann publishers , san mateo , ca , 19781984 .                          ,",
    "tu , p. , and baral , c. 2004 . .",
    "in _ proceedings of the 7th international conference on logic programming and nonmonotonic reasoning conference ( lpnmr04 ) _ , v.  lifschitz and i.  niemel , eds . vol .",
    "springer verlag , lncs 2923 , 261274 .",
    "2000a . the fluent calculus : a specification language for robots with sensors in nondeterministic , concurrent , and ramifying environments .",
    "cl-2000 - 01 , computational logic group , department of computer science , dresden university of technology .",
    "2000b . representing the knowledge of a robot . in _ proceedings of the seventh international conference on principles of knowledge and representation and reasoning ( kr2000)_. morgan kaufmann publishers , 109120 .    , anderson , c. , and smith , d. 1998 .",
    "extending graphplan to handle uncertainty and sensing actions . in",
    "_ proceedings of the fifteenth national conference on artificial intelligence conference ( aaai98)_. aaai press , 897904 ."
  ],
  "abstract_text": [
    "<S> we extend the 0-approximation of sensing actions and incomplete information in @xcite to action theories with static causal laws and prove its soundness with respect to the possible world semantics . </S>",
    "<S> we also show that the conditional planning problem with respect to this approximation is * np*-complete . </S>",
    "<S> we then present an answer set programming based conditional planner , called , that is capable of generating both conformant plans and conditional plans in the presence of sensing actions , incomplete information about the initial state , and static causal laws . </S>",
    "<S> we prove the correctness of our implementation and argue that our planner is sound and complete with respect to the proposed approximation . finally , we present experimental results comparing  to other planners .    </S>",
    "<S> reasoning about actions and changes , sensing actions , incomplete information , conformant planning , conditional planning , answer set programming </S>"
  ]
}