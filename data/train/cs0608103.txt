{
  "article_text": [
    "in this paper , we introduce and study logic programs whose clauses are built of generalized atoms expressing constraints on sets .",
    "we propose a generalization of normal logic programming to this extended setting .",
    "our generalization uses the assumption of the monotonicity of constraints and it employs the nondeterminism in deriving ways to satisfy constraints . in our approach the basic concepts , methods , semantics and results of normal logic programming",
    "generalize to the proposed context .",
    "our work provides a theoretical framework to a recent extension of logic programming with weight constraints ( also known as _ pseudo - boolean constraints _ ) @xcite , and to an earlier formalism of disjunctive logic programs with the semantics of possible models @xcite , but applies to a much broader class of programs .    in the 1990s",
    "researchers demonstrated that normal logic programming with the stable - model semantics is an effective knowledge representation formalism .",
    "it provides solutions to problems arising in such contexts as planning , reasoning about actions , diagnosis and abduction , product configuration , and modeling and reasoning about preferences .",
    "moreover , due to the emergence of fast methods to compute stable models @xcite , the importance of the formalism increased significantly as it became possible to use it not only as a modeling language but also as a practical computational tool .",
    "the contributions of @xcite provide a detailed discussion of the formalism and its applications .    in the last few years , researchers proposed extensions of the language of normal logic programming with means to model constraints involving _ aggregate _ operations on sets .",
    "@xcite proposed a formalism integrating logic programming with _",
    "weight constraints _ , known in the sat community as _ pseudo - boolean _ constraints , generalized the concept of stable models to this extended setting , and developed fast algorithms to compute them .",
    "@xcite , introduced a formalism allowing for more general aggregates .",
    "they extended to this new setting several semantics of normal logic programs , including the stable - model semantics and the well - founded semantics . a related recent work @xcite , incorporated aggregates into the formalism of _ disjunctive _ logic programs with the _ answer - set semantics_. yet another extension of normal logic programming has been proposed in @xcite as set - based constraints .",
    "such extensions are important as they simplify the task of modeling problem specifications , typically result in more direct and concise encodings , and often significantly improve the computational effectiveness of the formalism as a problem - solving tool .    our goal is to propose an abstract formalism of logic programs extended with means to model constraints on sets , preserving as much as possible analogies between our theory and _ normal _ logic programming .",
    "we introduce the notion of an _ abstract constraint _ and its linguistic counterpart  an _ abstract constraint atom_. we then use abstract constraint atoms as building blocks of program clauses in the same way propositional atoms form clauses of normal logic programs . for the most part ,",
    "we restrict our attention to _ monotone",
    "_ constraints , as monotonicity is essential for preserving the notion of a logic program as a computational device .",
    "we show that basic concepts , techniques , and results of normal logic programming have direct generalizations for the class of programs built of monotone abstract constraints .",
    "what distinguishes our work from other recent approaches to integrating logic programming with aggregates is that we allow constraint atoms in the heads of clauses , while formalisms proposed and studied in @xcite do not .    in many respects",
    "the theory we built in this paper mirrors closely an operator - based treatment of normal logic programs .",
    "there is , however , a basic difference .",
    "abstract constraint atoms are inherently nondeterministic .",
    "they can be viewed as shorthands for certain disjunctions and , in general , there are many ways to make an abstract constraint atom true .",
    "this nondeterminism has a consequence .",
    "the one - step provability operator , which generalizes the one - step provability operator of @xcite defined for normal programs , is no longer deterministic .",
    "it assigns to an interpretation @xmath0 a _ set _ @xmath1 of interpretations .",
    "each interpretation in the set @xmath1 is regarded as possible and equally likely outcome of applying the operator to @xmath0 .",
    "the nondeterministic one - step provability operator is a key tool in our work .",
    "it generalizes the one - step provability operator of @xcite . thanks to close parallels between these two concepts , we are able to reconstruct operator - based characterizations of models , supported models , and the concept of a _ bottom - up _ computation for programs with abstract constraints that generalize horn programs .",
    "we then extend to programs with abstract monotone constraints the definitions of the _ gelfond - lifschitz _ reduct and a stable model @xcite .",
    "we also distinguish and discuss the class of _ definite _ programs ( programs with clauses whose heads can be satisfied in one way only ) . for these programs",
    "the one - step provability operator becomes deterministic and the theory of normal logic programming extends to deterministic programs without _ any _ significant change . in particular , it follows that normal logic programming with all its major 2-valued semantics can be viewed as a special case of logic programming with monotone abstract constraints .",
    "in addition , we show that programs with abstract constraints provide a formal account of a class of logic programs with weight ( pseudo - boolean ) atoms introduced in @xcite .",
    "we call programs in the syntax proposed in that paper _ lparse programs_. @xcite defined for lparse programs the notion of a",
    "_ stable model _ and showed that lparse programs generalize normal logic programming with the stable - model semantics of gelfond and lifschitz @xcite .",
    "however , the notion of the reduct underlying the definition of a stable model given in @xcite is different from that proposed in @xcite and the precise nature of the relationship between normal logic programs and lparse programs was not clear .",
    "our work explicates this relationship .",
    "on one hand , the formalism of programs with abstract constraints parallels normal logic programming . in particular , major concepts , results and techniques in normal logic programming have counterparts in the setting of programs with abstract constraints . on the other hand , under some simple transformations",
    ", lparse programs can be viewed as a special case of programs with abstract constraints .",
    "thus , through this connection , the theory of normal logic programming can be lifted to the setting of lparse programs leading , in particular , to new characterizations of stable models of lparse programs .",
    "finally , we show that programs with monotone abstract constraints generalize the formalism of disjunctive logic programs with the semantics of _ possible _ models @xcite .",
    "in fact , as we point out , several ideas that are stated in abstract terms in our paper have their roots in @xcite .",
    "we consider a language determined by a fixed set @xmath2 of _ propositional atoms_. an _ abstract constraint _ is a collection @xmath3 ( if @xmath4 is a set , by @xmath5 we denote the family of all subsets of @xmath4 ) .",
    "we say that elements of @xmath6 _ satisfy _ the constraint @xmath6 or have the property @xmath6 .",
    "an _ abstract constraint atom _ ( or _ ac - atom _ , for short ) is an expression @xmath7 , where @xmath8 is _ finite _ and @xmath6 is an abstract constraint .",
    "ac - literal _ is an expression of the form @xmath7 or @xmath9 , where @xmath7 is an ac - atom .",
    "we call @xmath4 the _ atom set _ of an ac - literal @xmath10 of the form @xmath7 or @xmath9 and denote it by @xmath11",
    ".    an intended meaning of an ac - atom @xmath7 is to represent a requirement on subsets of @xmath4 that they must satisfy the constraint @xmath6 .",
    "formally , we interpret ac - atoms by means of propositional interpretations ( truth assignments ) , which we represent as subsets of @xmath2 : an atom @xmath12 is _ true _ in an interpretation @xmath13 if @xmath14 , otherwise , @xmath12 is _ false _ in @xmath0 .",
    "an interpretation @xmath15 _ satisfies _ an ac - atom @xmath7 , written @xmath16 , if @xmath17 ( that is , if the set of atoms in @xmath4 that are true in @xmath0 satisfies the constraint @xmath6 ) .",
    "otherwise , @xmath0 does not satisfy @xmath7 , written @xmath18 . in that case",
    ", we also say that @xmath0 satisfies the _ ac - literal _",
    "@xmath9 and write @xmath19 .",
    "an ac - atom @xmath7 is _ consistent _ if there is an interpretation @xmath0 such that @xmath16 or , equivalently , if @xmath6 contains at least one subset of @xmath4 .",
    "we will now illustrate these concepts with several examples of common constraints .",
    "* pseudo - boolean constraints*. these constraints are also known as _ weight constraints_. given a real number @xmath20 and a function @xmath21 , assigning to each atom in @xmath2 a real number ( its _ weight _ ) , a _",
    "pseudo - boolean _ constraint @xmath22 imposes a restriction that `` the total weight of atoms in a set is at least @xmath20 '' .",
    "formally , we set @xmath23 ( comparison relations @xmath24 , @xmath25 , @xmath26 give rise to other types of weight constraints ) . + * cardinality constraints*. they are pseudo - boolean constraints in which a bound @xmath20 is a non - negative integer and a weight of every atom is 1 . throughout the paper , we use cardinality constraints to illustrate concepts we study . to simplify the notation and to make it consistent with the notation used in @xcite",
    ", we write @xmath27 to denote an ac - atom @xmath7 , where @xmath28 and @xmath29 for every @xmath30 . +",
    "* product constraints .",
    "* they differ from weight constraints in that they restrict the product of individual weights of atoms in allowed sets , depending on the type of the comparison relation used . selecting the relation @xmath31 and assuming the same notation as before , we express product constraints as abstract constraints of the form @xmath32 . +",
    "* maximum constraints . * given a weight function @xmath21 on the set of atoms and a real bound @xmath20 , the maximum constraint restricts allowed sets of atoms to those with the maximum weight at least @xmath20 .",
    "formally , we express them as abstract constraints of the form @xmath33 ( or its variants , depending on the comparison relation ) . +",
    "* even- and odd - cardinality constraints . *",
    "they impose a parity requirement on the cardinality of allowed sets .",
    "formally , we express them as abstract constraints @xmath34 and @xmath35 .",
    "+ * containment constraints . *",
    "such constraints require that allowed sets contain some prespecified configurations ( subsets ) .",
    "we capture them by abstract constraints @xmath36 that consist of all subsets of @xmath2 that contain at least one set from a prespecified collection @xmath37 of finite subsets of @xmath2 .",
    "each of these constraints determines associated ac - atoms .",
    "let @xmath38 and let us consider a weight function @xmath21 such that for every integer @xmath39 , @xmath40 .",
    "the expression @xmath41 is an example of a pseudo - boolean constraint .",
    "if we denote it by @xmath42 , then @xmath43 is an example of a pseudo - boolean constraint atom .",
    "a set @xmath15 satisfies @xmath43 if and only if the total weight of atoms in @xmath44 is at least @xmath45 ( that is , if and only if @xmath0 contains @xmath46 , or @xmath47 together with at least one other atom ) .",
    "similarly , @xmath48 is an example of a maximum constraint and , if we denote it by @xmath49 , @xmath50 is a maximum constraint atom that enforces the restriction on sets of atoms to contain @xmath46 or @xmath51 .",
    "an abstract constraint atom @xmath52 ( @xmath53 stands for the even - cardinality constraint ) forces allowed sets of atoms to contain none or both of @xmath54 and @xmath55 .",
    "all these constraint atoms are consistent .",
    "an atom @xmath56 , where @xmath57 is an example of an inconsistent constraint atom .",
    "no selection of atoms from @xmath58 satisfies it and , consequently , it has no models .",
    "these examples demonstrate that abstract constraints and abstract constraint atoms express a broad range of common constraints . in this paper , we show that abstract constraint atoms can be combined into logic program clauses to represent even more complex constraints , and that much of the theory of normal logic programs generalizes to the extended setting .",
    "let @xmath59 be a class of abstract constraints over @xmath2 . by an _",
    "@xmath59-atom _ we mean an abstract constraint atom @xmath60 such that @xmath61 and @xmath8 .",
    "an @xmath59-_literal _ ( or simply , a _ literal _ , if the context is clear ) is an expression of the form @xmath60 or @xmath62 , where @xmath60 is an @xmath59-atom .",
    "an @xmath59-_clause _ is an expression @xmath63 where @xmath60 , @xmath64 and @xmath65 are @xmath59-atoms .",
    "an @xmath66-clause ( [ eq.r.1 ] ) is called a _ constraint clause",
    "_ if @xmath60 is not consistent .",
    "@xmath59-program _ is a finite collection of @xmath59-clauses - programs extends to the case when we admit infinite programs .",
    "however , additional means of proof , such as zorn lemma , may be required in some arguments ( for instance , in the argument for the existence of minimal models of @xmath59-programs ) . ] .",
    "if @xmath67 is a clause of the form ( [ eq.r.1 ] ) , @xmath60 is the _ head _ of @xmath67 , denoted by @xmath68 , and @xmath4 is the _",
    "head set _ of @xmath67 , denoted by @xmath69 .",
    "we also call the conjunction of literals @xmath70 , the _ body _ of @xmath67 and denote it by @xmath71 .",
    "occasionally , we use the same term to denote the _ set _ of all literals in the body of a clause . finally ,",
    "for an @xmath59-program @xmath72 , we define @xmath73 to be the union of sets @xmath69 , for @xmath74 .",
    "an interpretation @xmath75 _ satisfies _ a set ( conjunction ) @xmath76 of literals , if it satisfies every literal in @xmath76 .",
    "we say that @xmath0 _ satisfies _ an @xmath59-clause @xmath67 if @xmath0 satisfies the head of the clause whenever it satisfies the body of @xmath67 .",
    "finally , @xmath0 _ satisfies _ an @xmath59-program @xmath72 if it satisfies all clauses in @xmath72 .",
    "we write @xmath77 , @xmath78 and @xmath79 to denote these three types of the satisfaction relation .",
    "we will often write `` _ is a model of _ '' instead of `` satisfies '' .",
    "@xmath59-programs that have models are called _",
    "consistent_.    clauses of normal logic programs are typically regarded as computational devices : _ assuming that preconditions of a clause have been established , the clause provides a justification to establish ( compute ) its head_. crucial concepts behind formal accounts of that intuition are those of a horn program , the corresponding _ bottom - up _ computation , and a least herbrand model , which defines the _ result _ of the computation . computations and their results are well defined due to the _ monotone _ behavior of horn programs .",
    "to extend normal logic programming to the class of programs with abstract constraint atoms , one needs a generalization of the class of horn programs supporting an appropriate notion of a computation , with the results of computations playing the same role as that played by the least herbrand model . in order to accomplish that , it is not enough simply to disallow the negation operator in the bodies of @xmath59-clauses .",
    "it is also necessary to restrict the class of constraints to those that are _ monotone _ ( that is , intuitively , once true in an interpretation , they remain true in every superset of it ) . without that assumption , the monotonicity of normal horn programs does not generalize and there is no straightforward way to define the concept of a computation .",
    "( we refer to @xcite for a study of properties of monotone constraints . )",
    "formally , we say that an abstract constraint @xmath6 is _ monotone _ if for every @xmath80 , if @xmath81 and @xmath82 then @xmath83 ( in other words , monotone constraints are precisely upward - closed families of subsets of @xmath2 ) .",
    "an abstract constraint atom @xmath7 is monotone if its constraint @xmath6 is monotone .",
    "[ mono ] let @xmath6 be an abstract monotone constraint over @xmath2 , @xmath84 , and let @xmath85 be two interpretations . if @xmath86 and @xmath87 , then @xmath88 .",
    "we note that if all the individual weights used by a weight function are non - negative , the corresponding pseudo - boolean constraints are monotone .",
    "the maximum constraints are monotone for _ every _ weight function . on the other hand , we note that some common constraints , for instance , even- and odd - cardinality constraints @xmath53 and @xmath89 , are not monotone .    from now on we restrict our attention to constraints that are _",
    "monotone_. we will write a _ monotone _",
    "@xmath59-clause and a _ monotone _",
    "@xmath59-program to make it explicit that all constraints in @xmath59 are monotone",
    ".    an important consequence of the monotonicity assumption is that monotone @xmath59-programs without constraint clauses have models ( and so , also minimal models ) .",
    "[ model - exists ] let @xmath72 be a monotone @xmath59-program without constraint clauses .",
    "then the set @xmath2 of all atoms in the language is a model of @xmath72 .",
    "let @xmath90 .",
    "since the constraint @xmath68 is consistent , there is a set of atoms @xmath91 such that @xmath92 . by the monotonicity of constraints in @xmath59 , @xmath93 .",
    "thus , @xmath94 .",
    "another important consequence of the monotonicity assumption is that the concept of a horn program has an obvious direct generalization .",
    "a monotone @xmath59-program that contains no occurrences of the operator @xmath95 is a _ horn @xmath59-program_.",
    "horn @xmath59-programs defined in this way have many properties that generalize well - known properties of _ normal _ horn programs .",
    "we will state and prove several of them later in the paper .",
    "following a fundamental idea underlying normal logic programming , we assign to @xmath59-clauses a procedural interpretation , which views them as derivation clauses . in the discussion that follows",
    "we do not assume that constraints in @xmath59 are monotone .",
    "intuitively , if an @xmath59-clause @xmath67 has its body satisfied by some set of atoms @xmath0 , then @xmath67 provides _ support _ for deriving from @xmath0 any set of atoms @xmath97 such that    1 .",
    "@xmath97 consists of some atoms from the headset of @xmath67 ( @xmath67 provides _ no _ grounds for deriving atoms that do not appear in its headset ) 2 .",
    "@xmath97 satisfies the head of @xmath67 ( since @xmath67 `` fires '' , the constraint imposed by its head must hold ) .    clearly , the process of deriving @xmath97 from @xmath0 by means of @xmath67 is _ nondeterministic _ in the sense that , in general , there are several sets that are supported by @xmath67 and @xmath0 .",
    "this interpretation of @xmath59-clauses extends to @xmath59-programs . given an @xmath59-program @xmath72 and a set of atoms @xmath0 , each clause",
    "@xmath98 such that @xmath0 satisfies the body of @xmath67 provides a support for a subset of the head set of @xmath67 .",
    "the union , say @xmath97 , of such sets  each supported by _ some _ clause @xmath67 , with @xmath67 ranging over those clauses in @xmath72 whose body is satisfied by @xmath0  can be viewed as `` derived '' from @xmath0 by means of @xmath72 . in general , given @xmath72 and @xmath0 , there may be several such derived sets .",
    "thus , the notion of derivability associated with a program is nondeterministic , as in the case of individual clauses .",
    "we describe formally this intuition of derivability in terms of a nondeterministic one - step provability operator .",
    "before we give a precise definition , we note that by a _",
    "nondeterministic operator _ on a set @xmath99 we mean any function @xmath100 .",
    "one can view the set @xmath101 as the collection of all possible outcomes of applying @xmath102 to @xmath103 one of which , if @xmath104 , can be selected nondeterministically as the _ actual _ outcome of @xmath102 .",
    "we emphasize that we allow @xmath101 to be empty , that is , nondeterministic operators are , in general , _ partial _  for some elements of the domain they do not assign any possible outcomes .",
    "let @xmath59 be a class of constraints ( not necessarily monotone ) .",
    "let @xmath72 be an @xmath105-program and let @xmath75 .    1 .",
    "a clause @xmath90 is _",
    "@xmath0-applicable _ , if @xmath106 .",
    "we denote by @xmath107 the set of all @xmath0-applicable clauses in @xmath72 .",
    "a set @xmath97 is _ nondeterministically one - step provable _ from @xmath0 by means of @xmath72 , if @xmath108 and @xmath109 , for every clause @xmath67 in @xmath107 .",
    "the _ nondeterministic one - step provability operator _ @xmath110 , is a function from @xmath111 to @xmath112 such that for every @xmath91 , @xmath113 consists of all sets @xmath97 that are nondeterministically one - step provable from @xmath0 by means of @xmath72 .",
    "@xmath96    since an abstract constraint forming the head of an @xmath59-clause may be inconsistent , there exist programs @xmath72 and interpretations @xmath114 such that @xmath113 is empty .",
    "the concepts introduced above have especially elegant properties for _ monotone _ @xmath59-programs .",
    "first , to illustrate them , let us consider a simple example involving a program with cardinality constraints ( cf .",
    "section [ basic - concepts ] ) .",
    "the program discussed in this example is not a horn program .",
    "let @xmath72 be a program with cardinality constraints consisting of the following clauses :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath115 + @xmath116 + @xmath117 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we note that the cardinality atom in the head of the first clause is inconsistent .",
    "let us consider a set @xmath118 .",
    "since @xmath119 , @xmath120 is not @xmath0-applicable .",
    "similarly , @xmath121 and @xmath122 is not @xmath0-applicable , either . on the other hand , @xmath123 and so , @xmath124 is @xmath0-applicable .",
    "there are three subsets of @xmath125 that satisfy the constraint @xmath126 in the head of the clause @xmath124 : @xmath127 , @xmath128 and @xmath129 .",
    "thus , each of these sets is nondeterministically one - step provable from @xmath0 and , consequently , @xmath130    we also note that if @xmath131 and @xmath132 then @xmath122 is the only @xmath0-applicable clause in @xmath72 . for such sets @xmath0 , @xmath133 . on the other hand , if @xmath0 contains both @xmath134 and @xmath103 , then @xmath120 is @xmath0-applicable and since the head of @xmath120 is inconsistent , @xmath135 ( no set is nondeterministically one - step provable from such a set @xmath0 ) .",
    "@xmath96    the example shows , in particular , that it may be the case that @xmath136 . if , however , @xmath72 is a _ monotone _",
    "@xmath59-program without constraint clauses , then it is never the case .",
    "[ ok ] let @xmath72 be a monotone @xmath137-program without constraint clauses .",
    "for every @xmath75 , @xmath138 .",
    "in particular , @xmath139 .",
    "let us consider @xmath140 .",
    "then , @xmath141 .",
    "since @xmath68 is consistent , it follows by the monotonicity of constraints in @xmath59 that @xmath142 .",
    "thus , @xmath143 and , consequently , @xmath138 .",
    "the operator @xmath110 plays a fundamental role in our research .",
    "it allows us to formalize the procedural interpretation of @xmath59-clauses and identify several classes of models .",
    "our first result characterizes models of monotone @xmath59-programs .",
    "models of a normal logic program @xmath72 are prefixpoints of the one - step provability operator @xmath144 @xcite .",
    "this characterization lifts to the class of monotone @xmath59-programs , with the operator @xmath110 replacing @xmath144 .",
    "[ model ] let @xmath72 be a monotone @xmath59-program and let @xmath75 .",
    "the set @xmath0 is a model of @xmath72 if and only if there is @xmath145 such that @xmath146 .",
    "let @xmath0 be a model of @xmath72 and @xmath147 .",
    "let @xmath140 . since @xmath0 is a model of @xmath67 , @xmath92 .",
    "clearly , @xmath148 .",
    "thus , @xmath149 and , consequently , @xmath109 .",
    "it follows that @xmath145 .",
    "since @xmath146 , the assertion follows .",
    "conversely , let us assume that there is @xmath145 such that @xmath146 .",
    "let @xmath90 be a clause such that @xmath150 .",
    "since @xmath145 , @xmath109 .",
    "we recall that the constraint involved in @xmath68 is monotone ( as we consider only monotone constraints ) .",
    "thus , by proposition [ mono ] , @xmath92 , as well .",
    "it follows that @xmath0 is a model of every clause in @xmath72 and , consequently , of @xmath72 .",
    "for a set @xmath0 of atoms , we say that @xmath0-applicable clauses in an @xmath66-program @xmath72 provide _ support _ to atoms in the heads of these clauses . in general , a model @xmath0 of an @xmath59-program may contain elements that have no support in a program and @xmath0 itself ,",
    "that is , can not be derived from @xmath0 by means of clauses in the program .",
    "let @xmath72 be a program with cardinality constraints consisting of a single clause : @xmath151 where @xmath12 and @xmath152 are two different atoms .",
    "let @xmath153 . clearly , @xmath154 is a model of @xmath72 .",
    "however , @xmath154 has no support in @xmath72 and itself .",
    "indeed , @xmath155 and so , @xmath72 and @xmath154 do not provide support for any atom .",
    "similarly , another model of @xmath72 , the set @xmath156 , where @xmath157 is an atom different from @xmath12 and @xmath152 , has no support in @xmath72 and itself .",
    "we have @xmath158 and so , @xmath12 has support in @xmath72 and @xmath159 , but @xmath160 does not .",
    "finally , the set @xmath161 , which is also a model of @xmath72 , _ has support _ in @xmath72 and itself .",
    "indeed , @xmath162 and there is a way to derive @xmath163 from @xmath72 and @xmath163 .",
    "@xmath96    for @xmath0 to be a model of @xmath72 , @xmath0 must satisfy the heads of all applicable clauses . to this end",
    ", @xmath0 needs to contain some of the atoms appearing in the headsets of these clauses ( atoms with support in @xmath0 and @xmath72 ) and , possibly , also some atoms that do not have such support .",
    "models that contain _ only _ atoms with support form an important class of models generalizing the class of supported models for normal logic programs @xcite .",
    "[ supp ] let @xmath59 be a class of constraints ( not necessarily monotone ) and let @xmath72 be an @xmath59-program .",
    "a set of atoms @xmath0 is a _ supported model _ of @xmath72 if @xmath0 is a model of @xmath72 and @xmath164 .",
    "@xmath96    supported models have the following characterization generalizing a characterization of supported models of normal logic programs as fixpoints of the van emden - kowalski operator ( the characterizing condition is commonly used as a definition of a _ fixpoint _ of a nondeterministic operator ) .",
    "[ ch - sup ] let @xmath59 be a class of constraints ( not necessarily monotone ) .",
    "let @xmath72 be an @xmath59-program .",
    "a set @xmath15 is a supported model of @xmath72 if and only if @xmath165 .",
    "if @xmath0 is a supported model of @xmath72 then it is a model of @xmath72 ( by the definition ) .",
    "moreover , @xmath166 .",
    "thus , @xmath165 .",
    "conversely , if @xmath165 , then @xmath166 and @xmath167 , for every @xmath140 .",
    "thus , @xmath78 , for every @xmath140 .",
    "if @xmath168 , then @xmath169 and so , @xmath78 .",
    "thus , @xmath0 is a model of @xmath72 . since @xmath165 also implies @xmath166 , @xmath0 is a supported model of @xmath72 .    in section [ nlp - mca ]",
    "we show that the use of the term _ supported _ for the class of models defined in this section is not a misnomer ; supported models of @xmath59-programs generalize supported models of normal logic programs .",
    "for the concepts of the one - step provability and supported models we did not need a restriction to monotone constraints . to properly generalize the notion of a stable model , however , this restriction is essential .",
    "thus , from this point on , we will consider only monotone @xmath59-programs .",
    "first , we will study horn @xmath59-programs ( we recall that the notion of a horn @xmath59-program assumes that @xmath59 consists of monotone constraints only ) viewing them as representations of certain nondeterministic computational processes .",
    "we will later use the results of this section to extend to the class of @xmath59-programs the concept of a stable model .",
    "let @xmath72 be a horn @xmath59-program .",
    "@xmath72-computation _ is a sequence @xmath170 such that @xmath171 and , for every non - negative integer @xmath172 :    1 .",
    "@xmath173 , and 2 .",
    "@xmath174 .    given a computation @xmath175 ,",
    "we call @xmath176 the _ result _ of the computation @xmath177 and denote it by @xmath178 .  @xmath96    our stipulations that @xmath72-computations have length @xmath179 does not restrict the generality . since atom sets of ac - atoms are finite , if a clause is applicable with respect to the result of the computation , it is applicable at some step @xmath172 of the computation .",
    "consequently , like in the case of normal horn programs , all possible results of computations of arbitrary transfinite lengths can be reached in @xmath179 steps , even in the case of infinite programs .",
    "results of computations are supported models .",
    "[ head ] let @xmath72 be a horn @xmath59-program and let @xmath177 be a @xmath72-computation . then @xmath178 is a supported model of @xmath72 , that is , @xmath178 is a model of @xmath72 and @xmath180 .",
    "let @xmath175 .",
    "clearly @xmath181 .",
    "let @xmath172 be a non - negative integer .",
    "since @xmath182 , @xmath183 .",
    "since @xmath72 is a horn @xmath66-program , it follows that if @xmath90 , @xmath184 and @xmath185 , then @xmath186 .",
    "thus , since @xmath187 , we have @xmath188 by induction , @xmath189 .",
    "conversely , let us consider a clause @xmath90 . if @xmath190 then @xmath191 .",
    "let us then assume that @xmath192 . since @xmath67 has finitely many @xmath59-atoms in the body , and since each @xmath193-atom is of the form @xmath7 , where @xmath4 is _ finite _ , there is a non - negative integer @xmath194 such that @xmath195 . by the definition of a @xmath72-computation , @xmath196 .",
    "thus , @xmath197 and , since @xmath198 , @xmath199 ( by the monotonicity of @xmath68 ) .",
    "it follows that @xmath191 in the case when @xmath200 , as well .",
    "thus , @xmath178 is a model of @xmath72 . since @xmath178 is a model of @xmath72 and @xmath201",
    ", @xmath178 is a supported model of @xmath72 .",
    "we will now show that having a model ( being consistent ) is a necessary and sufficient condition for a horn @xmath59-program to have a computation . to this end",
    ", we will first introduce a certain class of computations .",
    "[ def - new ] let @xmath0 be a model of @xmath72 .",
    "a _ canonical @xmath72-computation with respect to @xmath0 _ is a sequence @xmath202 defined as follows :    1 .",
    "@xmath203 and , 2 .",
    "@xmath204 , for every @xmath205 .",
    "@xmath96    we observe that canonical computations involve no nondeterminism . at each stage",
    "there is exactly one way in which we can continue .",
    "this continuation is determined by the model @xmath0 .",
    "before we proceed further , we illustrate the concept of a canonical computation with a simple example .",
    "let us assume that @xmath206 and let us consider a horn program with cardinality constraints , say @xmath72 , consisting of the following clauses :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath207 + @xmath208 + @xmath209 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    let @xmath210 .",
    "it is easy to check that @xmath0 is a model of @xmath72 ( it also follows from proposition [ model - exists ] , as the constraint atoms in the heads of clauses in @xmath72 are consistent ) .",
    "we will now construct a canonical @xmath72-computation with respect to @xmath0 . by the definition @xmath211 .",
    "the only @xmath212-applicable clause in @xmath72 is @xmath122 . since @xmath213 , @xmath214 .",
    "the clauses @xmath122 and @xmath124 are @xmath215-applicable and @xmath120 is not . since @xmath216 and @xmath213 , @xmath217 .",
    "since @xmath122 and @xmath124 are the only @xmath218-applicable clauses in @xmath72 , it follows that @xmath219 , for @xmath220 .    by the definition , the union of all sets in the canonical computation",
    "is included in @xmath0 .",
    "our example demonstrates that canonical computations with respect to @xmath0 , in general , do not reconstruct all of @xmath0 .",
    "@xmath96    the use of the term @xmath72-computation in definition [ def - new ] is justified .",
    "the following theorem shows that the sequence @xmath221 is indeed a @xmath72-computation .",
    "[ comp ] let @xmath72 be a horn @xmath59-program and let @xmath75 be a model of @xmath72 .",
    "then the sequence @xmath221 is a @xmath72-computation .",
    "we need to show that the conditions ( 1 ) and ( 2 ) from the definition of a @xmath72-computation hold for the sequence @xmath221 .",
    "to prove ( 1 ) , we proceed by induction on @xmath172 .",
    "for @xmath222 , the condition ( 1 ) is , clearly , satisfied .",
    "let us assume that for some non - negative integer @xmath172 , @xmath223 holds",
    ". then @xmath224 it follows that @xmath225    to prove ( 2 ) , let us consider a non - negative integer @xmath172 . by the definition , @xmath226 .",
    "it remains to prove that @xmath227 .",
    "let @xmath228 .",
    "then @xmath229 and , since @xmath230 , @xmath231 .",
    "we recall that @xmath0 is a model of @xmath72 .",
    "thus , @xmath232 .",
    "it follows that @xmath233 and , consequently , @xmath234 . since @xmath235",
    ", it follows that @xmath236 .",
    "we now have the following corollary to theorems [ head ] and [ comp ] that characterizes horn @xmath59-programs that have computations .",
    "let @xmath72 be a horn @xmath59-program .",
    "then , @xmath72 has a model if and only if it has a @xmath72-computation . in particular",
    ", every horn @xmath59-program @xmath72 without constraint clauses possesses at least one @xmath72-computation .",
    "if @xmath0 is a model of @xmath72 then the canonical computation @xmath221 is a @xmath72-computation ( theorem [ comp ] ) .",
    "conversely , if @xmath72 has a @xmath72-computation @xmath177 , then @xmath178 is a model of @xmath72 ( theorem [ head ] ) .",
    "the second part of the assertion follows from the fact that horn @xmath59-programs without constraint clauses have models ( proposition [ model - exists ] ) .",
    "we use the concept of a computation to identify a certain class of models of horn @xmath59-programs .",
    "let @xmath72 be a horn @xmath59-program .",
    "we say that a set of atoms @xmath0 is a _",
    "derivable model _ of @xmath72 if there exists a @xmath72-computation @xmath177 such that @xmath237 .",
    "@xmath96    derivable models play in our theory a role analogous to that of the least model of a normal horn program .",
    "the basic analogy is that they are the results of bottom - up computations , as is the case for the least model of a normal horn program .",
    "theorems [ head ] and [ comp ] entail several properties of horn @xmath59-programs , their computations and models .",
    "we gather them in the following corollary .",
    "properties ( 1 ) and ( 3 ) - ( 6 ) generalize properties of the least model of a normal horn logic program .",
    "[ p.sum ] let @xmath72 be a horn @xmath59-program .",
    "then :    1 .",
    "if @xmath72 is consistent then @xmath72 has at least one derivable model .",
    "2 .   for every model @xmath0 of @xmath72",
    "there is a largest derivable model @xmath97 of @xmath72 such that @xmath146 .",
    "a model @xmath0 of @xmath72 is derivable if and only if @xmath238 .",
    "if @xmath72 contains no constraint clauses then @xmath72 has a largest derivable model .",
    "every minimal model of @xmath72 is derivable .",
    "every derivable model of @xmath72 is a supported model of @xmath72 .",
    "\\(1 ) since @xmath72 has a model , it has a @xmath72-computation ( theorem [ comp ] ) .",
    "the result of this computation is a model of @xmath72 ( theorem [ head ] ) . by the definition",
    ", this model is derivable .",
    "\\(2 ) let @xmath0 be a model of @xmath72 and let @xmath175 be the canonical @xmath72-computation for @xmath0 .",
    "then , @xmath178 is a derivable model of @xmath72 and @xmath239 .",
    "let @xmath240 be a @xmath72-computation such that @xmath241 . clearly , we have @xmath242 .",
    "let us consider an integer @xmath243 and let us assume that the inclusion @xmath244 holds . since @xmath241 , @xmath245 .",
    "thus , by the definition of a @xmath72-computation , @xmath246 since @xmath72 is a horn @xmath59-program and since we have @xmath247 , @xmath248 .",
    "thus , @xmath249 it follows now by induction that @xmath250 .",
    "thus , @xmath178 is the largest derivable model contained in @xmath0 .",
    "\\(3 ) let @xmath0 be a model of @xmath72 .",
    "the argument we used in ( 2 ) shows that the result of the canonical computation from @xmath72 with respect to @xmath0 is the greatest derivable model contained in @xmath0 . if @xmath0 is derivable , then @xmath251 .",
    "the converse implication follows by the definition .",
    "\\(4 ) the set @xmath2 is a model of @xmath72 .",
    "let @xmath252 be the result of the canonical @xmath72-computation for @xmath2 .",
    "clearly , @xmath252 is a derivable model of @xmath72 .",
    "we will show that every derivable model of @xmath72 is a subset of @xmath252 .",
    "let @xmath0 be a derivable model of @xmath72 . by ( 3 ) , @xmath0 is the result of a canonical computation for @xmath0 . since @xmath75",
    ", it follows by an induction argument that for every non - negative integer @xmath172 , @xmath253 ( we omit the details , as the argument is similar to that in the proof of ( 2 ) ) .",
    "consequently , @xmath254 .",
    "\\(5 ) this assertion follows directly from ( 2 ) .",
    "\\(6 ) this assertion follows directly from theorem [ head ] .    despite analogies with the least model of a normal horn program , derivable models are not , in general , minimal .",
    "for instance , a program with cardinality constraints consisting of a single clause @xmath255 has three derivable models : @xmath127 , @xmath256 and @xmath257 , only two of which are minimal .",
    "horn @xmath59-programs generalize horn normal logic programs ( see section [ nlp - mca ] for details . ) . for a horn @xmath59-programs without constraint clauses ,",
    "the canonical computation with respect to the set of all atoms is a counterpart to the bottom - up computation determined by a normal horn program .",
    "we will now use the results of the two previous sections to introduce and study the class of _ stable _ models of monotone @xmath59-programs .",
    "[ d - stable ] let @xmath72 be a monotone @xmath59-program and let @xmath75 .",
    "the _ reduct _ of @xmath72 with respect to @xmath0 , @xmath258 in symbols , is a horn @xmath193-program obtained from @xmath72 by ( 1 ) removing from @xmath72 every @xmath193-clause containing in the body a literal @xmath259 such that @xmath260 , and ( 2 ) removing all literals of the form @xmath259 from all the remaining clauses in @xmath72 .",
    "a set of atoms @xmath0 is a _",
    "stable _ model of @xmath72 if @xmath0 is a derivable model of the reduct @xmath258 .",
    "@xmath96    the following result is easy to show ( and so we omit its proof ) but useful .",
    "[ l.reduct ] let @xmath72 be a monotone @xmath59-program .",
    "if @xmath0 is a model of @xmath72 , then @xmath0 is a model of @xmath258 .",
    "@xmath96    [ ex - stab ] we illustrate the concept of stable models of monotone @xmath59-programs with examples underlining some aspects of their properties .",
    "the class @xmath193 we use in this example consists of _ all _ cardinality constraints which , we recall , are monotone ( section [ basic - concepts ] ) .    let @xmath72 be a program consisting of the following two clauses :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath261 + @xmath262 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we will now investigate properties of some sets with respect to this program . + ( 1 ) the set @xmath263 is not a model of our program @xmath72 .",
    "as we will see soon ( proposition [ m - stable ] ) , stable models are supported models and , consequently , also models .",
    "thus @xmath264 is not a stable model of @xmath72 .",
    "+ ( 2 ) the set @xmath265 is a model of @xmath72 . but @xmath159 is not a stable model of @xmath72 .",
    "indeed , let us compute @xmath266 .",
    "it consists of just one clause : @xmath262 .",
    "since @xmath159 is not a derivable model of @xmath266 ( it contains an atom not occurring in any head of the clause of @xmath266 ) , @xmath159 is not a stable model of @xmath72 + ( 3 ) the set @xmath267 is a stable model of @xmath72 .",
    "the reduct @xmath268 consists of two clauses :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath269 + @xmath262 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the sequence @xmath270 is a @xmath268-computation .",
    "thus , @xmath163 is a derivable model of @xmath268 and hence @xmath163 is a stable model of @xmath72 + ( 4 ) the set @xmath271 is a stable model of @xmath72 .",
    "the reduct @xmath272 consists of two clauses :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath269 + @xmath262 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the sequence @xmath273 is a @xmath272-computation .",
    "thus @xmath127 is a stable model of @xmath72 .    in our example @xmath274 .",
    "thus , in contrast to normal logic programs ( but not to lparse programs ) , stable models of abstract constraint programs can nest .",
    "that is , they do not satisfy the antichain ( minimality with respect to inclusion ) property .",
    "the program @xmath72 that we considered above has stable models .",
    "it is easy to construct examples of programs that have no stable models .",
    "for instance , a program consisting of just one clause : @xmath275 has models but no stable models .",
    "@xmath96    stable models of a monotone @xmath59-program @xmath72 are indeed models of @xmath72 .",
    "thus , the use of the term `` model '' in their name is justified .",
    "in fact , a stronger property holds : stable models of monotone @xmath59-programs are supported .",
    "this again generalizes a well - known property of normal logic programs .",
    "[ m - stable ] let @xmath72 be a monotone @xmath59-program .",
    "if @xmath75 is a stable model of @xmath72 then @xmath0 is a supported model of @xmath72 .",
    "first , let us observe that it follows directly from the corresponding definitions that @xmath276 .",
    "next , since the set @xmath0 is a derivable model of @xmath258 , @xmath0 is a supported model of @xmath258 ( corollary [ p.sum](6 ) ) .",
    "thus , by theorem [ ch - sup ] , @xmath277 and , consequently , @xmath278 .",
    "it follows that @xmath0 is a supported model of @xmath72 .    with the notion of a stable model in hand",
    ", we can strengthen theorem [ head ] .",
    "[ der - stb ] let @xmath72 be a horn @xmath59-program .",
    "a set of atoms @xmath75 is a derivable model of @xmath72 if and only if @xmath0 is a stable model of @xmath72 .",
    "the assertion is a direct consequence of the fact that for every horn @xmath59-program @xmath72 and for every set of atoms @xmath0 , @xmath279 .",
    "we will now prove yet another result that generalizes a property of stable models of normal logic programs ( cf .",
    "work on extending the semantics of stable models to logic programs with integrity constraints @xcite ) .",
    "[ prop.comp ] let @xmath72 and @xmath280 be two monotone @xmath59-programs .    1 .",
    "if @xmath0 is a stable model of @xmath72 and a model of @xmath280 then @xmath0 is a stable model of @xmath281 .",
    "if @xmath280 consists of constraint clauses and @xmath0 is a stable model of @xmath282 then @xmath0 is a stable model of @xmath72 .",
    "\\(1 ) since @xmath0 is a stable model of @xmath72 , @xmath0 is a derivable model of @xmath258 . by corollary [ p.sum](3 ) , @xmath0 is the result of the canonical @xmath258-computation with respect to @xmath0 . since @xmath0 is a model of @xmath282 , by lemma [ l.reduct ] @xmath0 is a model of @xmath283 .",
    "therefore , the canonical @xmath284-computation with respect to @xmath0 is well defined .",
    "its result is clearly contained in @xmath0 .",
    "on the other hand , it contains the result of the canonical @xmath258-computation with respect to @xmath0 , which is @xmath0 .",
    "therefore , the result of the canonical @xmath284-computation with respect to @xmath0 is @xmath0 .",
    "thus , @xmath0 is a derivable model of @xmath285 and a stable model of @xmath282 .",
    "\\(2 ) since @xmath0 is a stable model of @xmath282 , @xmath0 is the result of a @xmath286-computation , say @xmath177 .",
    "since @xmath280 consists of constraint clauses , @xmath177 is a @xmath258-computation ( constraint clauses , having inconsistent heads , do not participate in computations ) .",
    "thus , @xmath0 is also a result of a @xmath258-computation , that is , @xmath0 is a stable model of @xmath72 .",
    "the main goal of this paper is to propose a way to integrate abstract constraints into normal logic programming . in this section ,",
    "we show that our formalism of @xmath59-programs _ contains _ normal logic programming ( modulo a very simple encoding ) so that all major two - valued semantics are preserved .    to this end , let us consider an abstract constraint : @xmath287 we note that @xmath288 is identical with the pseudo - boolean constraint ( we introduced pseudo - boolean constraints in section [ basic - concepts ] ) : @xmath289 where @xmath21 is a weight function on @xmath2 such that @xmath29 , for every @xmath30 .",
    "clearly , the constraint @xmath288 is monotone .",
    "we will show that normal logic programs can be encoded as @xmath290-programs or , more generally , as monotone @xmath291-programs , for every class @xmath291 of monotone abstract constraints such that @xmath292 . in",
    "what follows , if @xmath30 , we will write @xmath293 for a @xmath290-atom @xmath294 .    we note that for every @xmath30 and every interpretation @xmath295 , @xmath296 if and only if @xmath297 . that is , a propositional atom @xmath298 is logically equivalent to an abstract constraint atom @xmath293 .",
    "this equivalence suggests an encoding of a normal logic program @xmath72 as @xmath290-program @xmath299 .",
    "namely , if r is a normal logic program clause @xmath300 we define @xmath301 to be a @xmath290-clause @xmath302 for a normal logic program @xmath72 , we define @xmath303 . by our earlier comments , @xmath299 is a _ monotone _",
    "@xmath193-program , for every class of monotone constraint atoms containing the constraint @xmath288 .",
    "we note that due to the equivalence of @xmath298 and @xmath293 , which we discussed above , for every interpretation @xmath75 we have @xmath304 ( here and in other places we use symbols such as @xmath71 , @xmath68 and @xmath305 also in the context of normal logic programs , and assume their standard meaning ) .",
    "our first result involves operators associated with programs .",
    "let @xmath72 be a normal logic program .",
    "we recall that the one - step provability operator @xmath144 @xcite is defined as follows : for every @xmath75 , @xmath306 we have the following basic property of the translation @xmath307 .    [ tptn ] let @xmath72 be a normal logic program . then for every @xmath308 , @xmath309",
    ".    we will write @xmath67 and @xmath310 for a pair of corresponding clauses in @xmath72 and @xmath299 .",
    "that is , if @xmath90 then @xmath311 is the counterpart of @xmath67 in @xmath299 .",
    "conversely , if @xmath312 , @xmath67 is the clause in @xmath72 such that @xmath313 .",
    "clearly , we have @xmath314 .    by the equivalence ( [ eq23c ] ) , a clause @xmath90 is @xmath0-applicable if and only if @xmath310 is @xmath0-applicable .",
    "thus , we have @xmath315 let @xmath316 and let @xmath317 .",
    "it follows that @xmath140 and @xmath318 . since @xmath319 , @xmath320",
    "thus , @xmath321 is one - step nondeterministically provable from @xmath0 and @xmath299 , that is , @xmath322 .",
    "next , let us consider @xmath323 . by the definition , @xmath324 .",
    "thus , by ( [ eq23z ] ) , we have @xmath325 .",
    "let us now consider @xmath318 .",
    "it follows that there is a clause @xmath140 such that @xmath326 . consequently , @xmath316 and @xmath319 . since @xmath323 , @xmath327",
    "thus , @xmath328 .",
    "it follows that @xmath329 and , consequently , @xmath309 .",
    "this result entails a proposition concerning horn programs .",
    "[ v.new ] let @xmath72 be a normal horn logic program .",
    "then @xmath0 is a least model of @xmath72 if and only if @xmath0 is a derivable model of @xmath299 .",
    "we first observe that the sequence @xmath330 is a @xmath299-computation ( one can show this by an easy inductive argument , using the relationship between @xmath144 and @xmath331 established by proposition [ tptn ] ) . since @xmath0 is the limit of the sequence @xmath332",
    ", @xmath0 is a derivable model of @xmath299 .",
    "conversely , if @xmath0 is a derivable model of @xmath299 , then @xmath0 is the result of a derivation @xmath333 from @xmath299 .",
    "thus , for every @xmath334 , @xmath335 . by proposition [ tptn ] , @xmath336 . since @xmath171 , it follows that for every @xmath334 , @xmath337 .",
    "consequently , @xmath338 and so , @xmath0 is the least model of @xmath72",
    ".    we can now prove the main result of this section demonstrating that the embedding @xmath307 preserves all the semantics considered in the paper .",
    "[ lp - mca ] let @xmath72 be a normal logic program and let @xmath0 be a set of atoms .",
    "then @xmath0 is a model ( supported model , stable model ) of @xmath72 if and only if @xmath0 is a model ( supported model , stable model ) of @xmath299 .",
    "it is well known that @xmath0 is a model of @xmath72 if and only if @xmath339 @xcite . by proposition [ tptn ] , the latter condition is equivalent to the condition that there is @xmath340 such that @xmath146 . by theorem [ model ]",
    ", this last condition is equivalent to @xmath0 being a model of @xmath299 .",
    "thus , @xmath0 is a model of @xmath72 if and only if @xmath0 is a model of @xmath299 .",
    "the proof for the case of supported models is essentially the same .",
    "it relies on the fact that @xmath0 is a supported model of @xmath72 if and only if @xmath341 @xcite and uses proposition [ tptn ] and theorem [ ch - sup ] .",
    "let us assume now that @xmath0 is a stable model of @xmath72 .",
    "it follows that @xmath0 is the least model of @xmath258 . by proposition [ v.new ]",
    ", @xmath0 is a derivable model of @xmath342^{pb}$ ] .",
    "it follows from the definitions of the reducts of normal logic programs and @xmath290-programs that @xmath342^{pb}= [ p^{pb}]^m$ ] .",
    "thus , @xmath0 is a stable model of @xmath299 .",
    "the converse implication can be proved in the same way .",
    "there are other ways to establish a connection between normal logic programs and programs with abstract constraints",
    ". we will now define a class of monotone @xmath59-programs , which offers a most direct extension of normal logic programming .",
    "[ ddet ] an @xmath59-atom @xmath7 is _ definite _ if @xmath4 is a minimal element in @xmath6 .",
    "an @xmath59-clause @xmath67 is _ definite _ if @xmath68 is a definite @xmath59-atom .",
    "an @xmath59-program is _ definite _ if every clause in @xmath72 is definite .",
    "@xmath96    we use the term definite following the logic programming tradition ( cf .",
    "@xcite , for instance ) , where it is used for clauses whose heads provide `` definite '' information ( as opposed to being disjunctions and so listing several possible alternatives ) .",
    "let @xmath59 consist of two monotone constraints , @xmath42 and @xmath49 where : @xmath343 and @xmath344 the constraint @xmath42 has two minimal elements : @xmath257 and @xmath345 .",
    "the constraint @xmath49 has just one minimal element : @xmath346 .",
    "these two monotone constraints generate the following three definite atoms : @xmath347 , @xmath348 , and @xmath349 .",
    "an @xmath59-program consisting of the following clauses is definite :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath350 + @xmath351 + @xmath352 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we note that some monotone constraints do not yield any definite constraint atoms .",
    "it happens when they have no finite minimal elements .",
    "a constraint @xmath6 consisting of all infinite subsets of @xmath2 offers a specific example .",
    "@xmath96    definite @xmath59-atoms have the following simple properties .    [ det ]",
    "let @xmath353 and let @xmath7 be a definite @xmath59-atom .",
    "then @xmath7 is consistent and , for every @xmath75 , @xmath354 if and only if @xmath355 .    if @xmath16 then @xmath17 .",
    "since @xmath7 is a definite @xmath59-atom , @xmath4 is a minimal element in @xmath6 .",
    "it follows that @xmath356 and so , @xmath357 .",
    "conversely , if @xmath357 then @xmath358 . since @xmath359 , @xmath17 .",
    "thus , @xmath16 .",
    "this argument proves the second part of the assertion . in particular",
    ", it follows that @xmath360 .",
    "thus , @xmath7 is consistent .",
    "the intuition behind the notion of a definite @xmath59-atom is now clear . given a definite @xmath59-program and an interpretation @xmath0 , there is always a way to satisfy the heads of all @xmath0-applicable clauses ( due to consistency of definite @xmath59-atoms ) .",
    "moreover , there is only _ one _ way to do so if we want only to use atoms appearing in the headsets of @xmath0-applicable clauses ( due the the second property from proposition [ det ] ) .",
    "thus , computing with definite @xmath66-programs does not involve nondeterminism .",
    "indeed , we have the following result .",
    "[ det1 ] let @xmath72 be a definite @xmath59-program .",
    "then , for every set of atoms @xmath0 , @xmath361 .",
    "let @xmath140 . since @xmath68 is a definite @xmath59-atom , then @xmath142 .",
    "we now observe that @xmath362 .",
    "thus , for every @xmath140 , @xmath363 . by the definition of the one - step nondeterministic provability , @xmath364 .",
    "thus , @xmath365 .",
    "next , let us consider @xmath145 . from the definition of @xmath113",
    ", it follows that @xmath366 . to prove the converse inclusion ,",
    "let @xmath140 .",
    "again by the definition of @xmath113 , we have that @xmath367 .",
    "since @xmath68 is a definite @xmath59-atom , proposition [ det ] implies that @xmath368 .",
    "thus , @xmath369 .",
    "it follows that @xmath370 and so , @xmath371 .",
    "thus , for a definite @xmath59-program @xmath72 , the operator @xmath110 is deterministic and , so , can be regarded as an operator with both the domain and codomain @xmath111 .",
    "we will write @xmath372 , to denote it",
    ". models , supported models and stable models of a definite monotone @xmath59-program ( for supported models we do not need the monotonicity assumption ) can be introduced in terms of the operator @xmath372 in _ exactly _ the same way the corresponding concepts are defined in normal logic programming . in particular , the algebraic treatment of logic programming developed in @xcite applies to definite @xmath59-programs and results in a natural and direct extension of normal logic programming .",
    "we note that this comment extends to 3- and 4-valued semantics of partial models , supported models and stable models ( including the kripke - kleene semantics and the well - founded semantics ) .",
    "we will explicitly mention just one result on definite monotone @xmath66-programs ( in fact , definite horn programs ) here , as it will be used later in the paper .",
    "[ horn - det ] let @xmath72 be a definite horn @xmath59-program .",
    "then @xmath72 has exactly one derivable model and this model is the least model of @xmath72 .",
    "since @xmath72 is definite , it contains no constraint clauses and so , it has a model ( proposition [ model - exists ] ) .",
    "thus , it has at least one @xmath72-computation .",
    "let @xmath373 and @xmath374 be two @xmath72-computations . by the definition , @xmath375 .",
    "let us assume that for some @xmath205 , @xmath376 . by the definition of @xmath72-computations , @xmath377 by the induction hypothesis , @xmath376 .",
    "thus , @xmath378 . since @xmath72 is definite , @xmath379 and so , @xmath380 .",
    "thus , both computations coincide and @xmath72 has exactly one @xmath72-computation and so , exactly one derivable model .",
    "since every model of @xmath72 contains a derivable model , it follows that the unique derivable model of @xmath72 is also a least model of @xmath72 .",
    "we will now investigate the relation between lparse programs @xcite and programs with monotone abstract constraints .",
    "we start by reviewing the syntax and the semantics of lparse programs .",
    "a _ weighted set of literals _ is a function @xmath381 , where @xmath382 is finite .",
    "we call @xmath4 the _ literal set _ of @xmath21 and denote it by @xmath383",
    ". the set of atoms that appear in literals in @xmath383 is the _ atom set _ of @xmath21 .",
    "we denote it by @xmath384",
    ". sometimes it will be convenient to write @xmath21 explicitly .",
    "to this end , we will write @xmath21 as @xmath385 where the domain of the function @xmath21 is @xmath386 , and @xmath387 , loosely following the lparse notation .",
    "thus , when the domain of @xmath21 is @xmath388 and @xmath389 , and @xmath390 , then we write @xmath21 as @xmath391 .    an _ lparse atom _ ( _ l - atom _ , for short )",
    "is an expression of the form @xmath392 , where @xmath21 is a weighted set of literals , and @xmath393 and @xmath394 are integers such that @xmath395 . by the _ literal set _ of an l - atom @xmath396 we mean @xmath383 and write @xmath397 to denote it ( in a similar way , we extend the definition and the notation of the atoms set to the case of l - atoms ) .",
    "we say that a set of atoms ( interpretation ) @xmath0 satisfies an l - atom @xmath392 if @xmath398 ( @xmath399 , in symbols ) .",
    "we note that it is easy to give an example of an inconsistent l - atom .",
    "for instance , @xmath400 is inconsistent",
    ". we will use @xmath401 to denote any inconsistent constraint ( it does not matter which , as all are equivalent to each other ) .    an _ lparse clause _ ( l - clause , for short ) is an expression @xmath67 of the form @xmath402 where @xmath10 and @xmath403 , @xmath404 , are l - atoms .",
    "we call @xmath10 the _ head _ of @xmath67 and @xmath405 the _ body _ of @xmath67 .",
    "we denote them by @xmath68 and @xmath71 , respectively .",
    "an _ lparse program _ is a finite set of l - clauses .",
    "we say that a set @xmath75 _ satisfies _ an l - clause @xmath67 if @xmath0 satisfies @xmath68 whenever it satisfies each l - atom in the body of @xmath67 .",
    "we say that @xmath0 satisfies an lparse program @xmath72 if @xmath0 satisfies each l - clause in @xmath72 .",
    "we write @xmath78 and @xmath79 in these cases , respectively .",
    "we note that lparse programs allow both negative literals and negative weights in l - atoms .",
    "however , in @xcite it is argued that negative weights can be expressed using negative literals and vice versa and , hence , one is inessential when the other is available .",
    "in fact , in  @xcite an l - atom with negative weights is treated simply as a shorthand for the corresponding constraint with non - negative weights .",
    "we follow this approach here and from now on consider only l - atoms @xmath392 , where @xmath21 assigns non - negative weights to literals .    before we continue , let us define @xmath406 to be a set of all pseudo - boolean constraints of the form @xmath407 , where @xmath393 is a non - negative integer and @xmath21 a weight function assigning to elements of @xmath2 non - negative integers ( cf .",
    "section [ basic - concepts ] ) . directly from the definition it follows that every constraint in @xmath408 is monotone .",
    "let us consider an l - atom @xmath409 which contains no negative literals ( and , as it is evident from the notation , no upper bound ) .",
    "in particular , @xmath410 .",
    "let @xmath411 be an extension of @xmath21 , which assigns @xmath412 to every atom @xmath413 .",
    "we observe that a set @xmath414 is a model of @xmath409 if and only if @xmath0 is a model of the @xmath415-atom @xmath60 , where @xmath416 and @xmath417 .",
    "therefore , we will regard such an l - atom @xmath409 as a @xmath415-atom or , speaking more formally ( but with some abuse of notation ) we will denote by @xmath409 the @xmath415-atom @xmath60 .    if @xmath418 and @xmath419 , then the corresponding @xmath415-atom is inconsistent ( it is one of many inconsistent @xmath406-atoms ) . as in the case of l - atoms , we will write @xmath401 to denote ( any ) inconsistent @xmath406-atom .",
    "this discussion suggests that lparse programs built of l - atoms without negative literals and upper bounds can be viewed as horn @xmath420-programs .",
    "we will exploit that relationship below in the definition of the reduct , and will subsequently extend it to all lparse programs .",
    "let @xmath72 be an lparse program and let @xmath75 .",
    "lparse - reduct _ of @xmath72 with respect to @xmath0 is a @xmath415-program obtained by :    1 .   eliminating from @xmath72 every clause @xmath67 such that @xmath421 , for at least one l - atom @xmath422 .",
    "2 .   replacing each remaining l - clause @xmath423 with @xmath415-clauses of the form @xmath424 where @xmath425 , @xmath426 is @xmath427 restricted to @xmath428 , and @xmath429    ( by our comments above , expressions of the form @xmath430 denote @xmath415-atoms ) . with some abuse of notation , we denote the reduct of @xmath72 with respect to @xmath0 by @xmath258 ( the type of the program , an lparse program or a @xmath415-program , determines which reduct we have in mind ) . by our comments",
    "above , @xmath258 can be regarded as a definite horn @xmath415-program .",
    "thus , @xmath258 has a least model , @xmath431 ( proposition [ horn - det ] ) .",
    "this model is the result of the canonical computation from @xmath258 with respect to @xmath0 .",
    "[ def - nss ] let @xmath72 be an lparse program .",
    "a set @xmath75 is an _ lparse - stable model _ of @xmath72 if @xmath432 and @xmath79 .",
    "@xmath96    we will now show that _ all _ lparse programs can be viewed as @xmath433-programs .",
    "this task involves two steps .",
    "first , we show how to translate lparse programs to @xmath95-free lparse programs so that lparse - stable models are preserved .",
    "second , we show that for @xmath95-free lparse programs the two definitions of stable models presented in the paper ( definitions [ d - stable ] and [ def - nss ] ) are equivalent .",
    "an lparse program @xmath72 can be translated to a @xmath95-free lparse program @xmath434 , as follows .",
    "we recall that by our earlier comments , we need to consider only lparse programs with no negative weights . for",
    "each negated literal @xmath435 appearing in @xmath72 , introduce a new propositional atom @xmath436 and an l - clause @xmath437 .",
    "then we replace each l - atom @xmath392 where the weighted set of literals @xmath21 is of the form  ( [ eq : latom ] ) with an l - atom @xmath438    it is straightforward to show that this transformation preserves lparse - stable models in the following sense .",
    "let @xmath72 be an lparse program , @xmath434 a @xmath95-free lparse program obtained by the translation above , and @xmath439 the set of new atoms introduced in the translation .",
    "then ,    * if @xmath0 is an lparse - stable model of @xmath72 then @xmath440 is a lparse - stable model of @xmath434 and * if @xmath97 is a lparse - stable model of @xmath434 then @xmath441 is an lparse - stable model of @xmath72 .",
    "@xmath96    now we show that @xmath95-free lparse programs can be translated to @xmath415-programs . to simplify the description of the encoding and",
    "make it uniform , we assume that all bounds are present .",
    "let @xmath67 be an l - clause @xmath442 we represent this l - clause by a _ pair _ of @xmath415-clauses , @xmath443 and @xmath444 that we define as @xmath445 and @xmath446 respectively .",
    "we recall that the symbol @xmath401 , appearing in the clause @xmath444 , stands for the inconsistent @xmath406-atom introduced above .",
    "now , given a @xmath95-free lparse program @xmath72 , we translate it into a @xmath408-program @xmath447    [ ca - mca ] let @xmath72 be a @xmath95-free lparse program .",
    "a set @xmath0 is an lparse - stable model of @xmath72 if and only if @xmath0 is a stable model of @xmath448 , as defined for @xmath415-programs .    in the proof",
    "we will use the notation : @xmath449    let us assume first that @xmath0 is an lparse - stable model of a @xmath95-free lparse program @xmath72 .",
    "we will show that @xmath0 is a stable model of the @xmath415-program @xmath448 , which in our terminology is equal to @xmath450 .    since @xmath0 is an lparse - stable model of @xmath72 ,",
    "it is a model of @xmath72 ( definition  [ def - nss ] ) .",
    "consequently , @xmath0 is a model of @xmath451 . by proposition [ prop.comp ] to complete this part of the proof , it suffices to show that @xmath0 is a stable model of the program @xmath452 . to this end , we note that the definitions of the respective reducts imply that a clause @xmath453 belongs to the lparse - reduct @xmath258 if and only if the reduct @xmath454 contains a clause @xmath455 such that @xmath456 and @xmath457 for all @xmath458 .    from this relationship",
    "it follows that the results of the canonical computations from @xmath258 and @xmath454 with respect to @xmath0 coincide ( we recall that both reducts are horn @xmath415-programs ) .",
    "since @xmath0 is the least model of @xmath258 , it is the result of the canonical computation from @xmath258 with respect to @xmath0 .",
    "thus , @xmath0 is also the result of the canonical computation from @xmath454 with respect to @xmath0 . in other words",
    ", @xmath0 is a derivable model of @xmath452 and , consequently , a stable model of @xmath452 .",
    "conversely , let us assume that @xmath0 is a stable model of @xmath459 .",
    "it follows that @xmath0 is a model of @xmath450 and , consequently , a model of @xmath72 .",
    "next , we note that since @xmath0 is a stable model of @xmath450 , it is a stable model of @xmath452 ( by proposition [ prop.comp ] ) .",
    "thus , it is a derivable model of its reduct @xmath454 and , therefore , it is also the result of the canonical computation from @xmath454 with respect to @xmath0 .",
    "our observation about the relationship between the reducts @xmath454 of and @xmath258 holds now , as well .",
    "consequently , @xmath0 is the result of the canonical computation from @xmath258 with respect to @xmath0 .",
    "thus , @xmath0 is a derivable model of @xmath258 .",
    "since @xmath258 is a definite horn @xmath415-program , it has only one derivable model  its least model .",
    "it follows that @xmath0 is the least model of @xmath258 and , consequently , an lparse - stable model of @xmath72 .",
    "theorem [ ca - mca ] shows that @xmath415-programs can express arbitrary @xmath95-free lparse programs with only linear growth in the size of the program .",
    "the converse relationship holds , too : @xmath95-free lparse programs can represent arbitrary @xmath415-programs without increasing the size of the representation .",
    "let @xmath67 be a @xmath415-clause @xmath460 we define @xmath461 as follows .",
    "if there is @xmath194 , @xmath404 , such that @xmath462 , we set @xmath463 ( in fact any tautology would do ) . otherwise , we set @xmath464 given a @xmath415-program @xmath72 , we define @xmath465 .    [ mca - ca ] let @xmath72 be a @xmath415-program .",
    "a set of atoms @xmath0 is a stable model of @xmath72 ( as defined for @xmath415-programs ) if and only if @xmath0 is an lparse - stable model of @xmath466 .",
    "first , we observe that @xmath72 and @xmath466 have the same models .",
    "next , similarly as before , we have that the lparse - reduct @xmath467^m$ ] contains a clause @xmath468 if and only if @xmath258 contains a clause of the form @xmath469 such that @xmath456 and @xmath457 for all @xmath458 .",
    "since in the clauses of the first type l - atoms @xmath470 are always true , as before , the results of the canonical computations from @xmath258 and @xmath467^m$ ] with respect to @xmath0 of @xmath72 coincide ( we recall that both reducts are horn @xmath415-programs ) . using this observation",
    "one can complete the proof by reasoning as in the previous proof .",
    "theorems [ ca - mca ] and [ mca - ca ] establish the equivalence of _",
    "@xmath95-free lparse _ programs and @xmath415-programs with respect to the stable model semantics .",
    "the translations @xmath471 and @xmath102 also preserve models .",
    "the equivalence between _ @xmath95-free lparse _ programs and @xmath415-programs extends to supported models under the following concept of supportedness for lparse - programs .",
    "let @xmath72 be a @xmath95-free lparse program .",
    "a set of atoms @xmath0 is a supported model of @xmath72 if @xmath0 is a model of @xmath72 and if for every atom @xmath472 there is an l - clause @xmath473 in @xmath72 such that @xmath474 and @xmath475 , @xmath404 .    indeed , we have the following two theorems ( we only sketch a proof of one of them ; the proof of the other one is similar ) .",
    "let @xmath72 be a @xmath95-free lparse program .",
    "a set @xmath0 is an lparse - supported model of @xmath72 if and only if @xmath0 is a supported model of @xmath448 , as defined for @xmath415-programs .",
    "let us denote @xmath476 .",
    "let @xmath0 be an lparse - supported model of @xmath72 .",
    "we will show that @xmath0 is a supported model of @xmath280 . by our earlier observations , @xmath72 and",
    "@xmath280 have the same models .",
    "thus , @xmath0 is a model of @xmath280 . to complete the argument",
    ", we need to show that @xmath477 .",
    "let @xmath472 .",
    "since @xmath0 is an lparse - supported model of @xmath72 , there is an l - clause @xmath90 such that @xmath478 , @xmath479 and @xmath475 for every @xmath194 , @xmath480 .",
    "it follows that @xmath481 and that @xmath482 . since @xmath483 , @xmath484",
    "thus , @xmath485 .",
    "it follows that @xmath486 and so @xmath0 is a supported model of @xmath280 .",
    "conversely , let us assume that @xmath0 is a supported model of @xmath280 .",
    "then @xmath0 is a model of @xmath280 and so @xmath0 is a model of @xmath72 , as well .",
    "let @xmath472 .",
    "it follows that @xmath485 .",
    "since each clause of the form @xmath444 ( @xmath90 ) is a constraint , there is an l - clause @xmath90 such that clause @xmath483 such that @xmath487 and @xmath488 .",
    "let @xmath478 .",
    "it follows that @xmath479 and that @xmath475 , @xmath404 .",
    "thus , @xmath0 is an lparse - supported model of @xmath72 .",
    "let @xmath72 be a @xmath415-program .",
    "a set of atoms @xmath0 is a stable model of @xmath72 ( as defined for @xmath415-programs ) if and only if @xmath0 is an lparse - stable model of @xmath466 .",
    "it follows from the results in this section that the translations @xmath471 and @xmath102 uniformly preserve basic semantics of @xmath95-free lparse and @xmath415-programs , and allow us to view @xmath95-free lparse programs as @xmath415-programs and _ vice versa_.    we also note that this equivalence demonstrates that lparse programs with the semantics of stable models as defined in @xcite can be viewed as a generalization of normal logic programming .",
    "it follows from theorems [ lp - mca ] and [ mca - ca ] that the encoding of normal logic programs as lparse programs , defined as the composition of the translation @xmath307 described in section [ nlp - mca ] ( we note that the constraint @xmath288 belongs to the class @xmath406 ) and the translation @xmath102 , preserves the semantics of models , supported models and stable models ( an alternative proof of this fact , restricted to the case of stable models was first given in @xcite and served as a motivation for the class of lparse programs and its stable - model semantics ) .",
    "this result is important , as it is not at all evident that the reduct used in @xcite , leads to fixpoints that generalize the semantics of stable models as defined in @xcite .",
    "given that the formalisms of @xmath95-free lparse and @xmath415-programs are equivalent , it is important to stress what differentiates them .",
    "the advantage of the formalism of @xmath95-free lparse programs is that it does not require the negation operator in the language .",
    "the strength of the formalism of @xmath415-programs lies in the fact that its syntax so closely resembles that of normal logic programs , and that the development of the theory of @xmath415-programs so closely follows that of the normal logic programming .",
    "@xcite introduced and investigated a semantics of _ possible models _ of disjunctive logic programs .",
    "it turns out that this semantics is different from the semantics proposed by minker @xcite and from that of gelfond and lifschitz @xcite . in this section",
    ", we will show that the formalism of monotone @xmath59-programs generalizes the semantics of possible models .",
    "for the purpose of our discussion , we will extend the use of the terms _ head _ , _ body _ , @xmath0-applicability , and notation @xmath258 , @xmath68 , @xmath71 to the case of disjunctive programs .",
    "@xcite let @xmath72 be a disjunctive logic program .",
    "a _ split _",
    "program for @xmath72 is any normal logic program that can be obtained by the following procedure .",
    "first , we select for each clause @xmath67 in @xmath72 , a set @xmath489 .",
    "next , we replace @xmath67 with clauses of the form @xmath490 , where @xmath491 , if @xmath492 , and with the ( constraint ) clause @xmath493 , if @xmath494 .    a set @xmath0 of atoms is a _",
    "possible _ model of @xmath72 if @xmath0 is a stable model ( in the sense of gelfond and lifschitz @xcite ) of a split program for @xmath72 .",
    "@xmath96    we point out that we allow for disjunctive clauses to have empty heads ( that is , we allow constraint clauses ) .",
    "we also allow that sets @xmath495 be empty .",
    "consequently , split programs may contain constraints even if the original program does not .",
    "let @xmath72 be the disjunctive program : @xmath496 then , the program @xmath280 : @xmath497 is an example of a split program for @xmath72 ( given by the following subsets of the sets of atoms in the heads of the clauses : @xmath127 , @xmath345 , @xmath498 and @xmath264 , respectively ) .",
    "moreover , since @xmath257 is a stable model of @xmath280 , @xmath257 is a possible model of @xmath72 .",
    "@xmath96    if @xmath0 is a model of a disjunctive program @xmath72 , by @xmath499 we denote the split program of @xmath72 determined by sets @xmath500 .",
    "we have the following simple characterization of possible models .",
    "[ pos - char ] let @xmath72 be a disjunctive program . a set of atoms @xmath0 is a possible model of @xmath72 if and only if @xmath0 is a stable model of the split program @xmath499 .",
    "if @xmath0 is a possible model of @xmath72 , then @xmath0 is a stable model of a split program of @xmath72 , say @xmath280 .",
    "let us assume that @xmath280 is determined by sets @xmath501 , where @xmath90 .    for every clause @xmath90 , if @xmath67 is @xmath0-applicable then all clauses it contributes to @xmath280 are @xmath0-applicable , too , as they have the same body as @xmath67 .",
    "since @xmath0 is a model of @xmath280 ( being a stable model of @xmath280 ) , we obtain that @xmath502 .",
    "thus , @xmath503 .    directly from the definition of @xmath499",
    "we obtain that @xmath0 is a model of @xmath499 .",
    "thus , @xmath0 is a model of @xmath504^m$ ] and , consequently , @xmath505^m)$ ] exists .",
    "moreover , it follows that @xmath505^m ) \\subseteq m$ ] ( indeed , all non - constraint clauses in @xmath499 have heads from @xmath0 ) .    since @xmath0 is a stable model of @xmath280 , @xmath506 .",
    "thus , it follows that @xmath507^m)$ ] and so , we obtain : @xmath508^m)\\subseteq { \\mathit{lm}}([s(p , m)]^m)\\subseteq m.\\ ] ] thus , @xmath505^m ) = m$ ] or , in other words , @xmath0 is a stable model of @xmath499 .",
    "the converse implication follows by the definition .",
    "let @xmath67 be a disjunctive logic program clause of the form : @xmath509 where all @xmath510 , @xmath511 and @xmath512 are atoms .",
    "we encode this clause as a program clause with cardinality atoms : @xmath513 ( if all @xmath510 and @xmath511 are distinct , the following translation could be used instead : @xmath514 . )",
    "we note that if @xmath515 , that is , the head of @xmath67 is empty , the rule @xmath516 has the constraint @xmath517 in the head , which is inconsistent . in this case",
    ", @xmath516 is a constraint clause .    for a disjunctive logic program @xmath72",
    ", we define @xmath518 ( @xmath519 in the subscript stands for `` cardinality atoms '' ) . since cardinality constraints are monotone , the concept of a stable model of the program @xmath520 is well defined .",
    "we have the following theorem .",
    "let @xmath72 be a disjunctive logic program .",
    "a set of atoms @xmath0 is a possible model of @xmath72 if and only if @xmath0 is a stable model of the program @xmath520 ( in the sense , we defined in this paper ) .",
    "we first note that @xmath504^m = s(p^m , m)$ ] .",
    "thus , by proposition [ pos - char ] , it follows that @xmath0 is a possible model of @xmath72 if and only if @xmath0 is a least model of @xmath521 .",
    "we also note that @xmath522^m=[p^m]^{ca}$ ] .",
    "thus , @xmath0 is a stable model of @xmath520 if and only if @xmath0 is a derivable model of @xmath342^{ca}$ ] .",
    "it follows that in order to prove the assertion it suffices to show that for every positive ( no negation in the bodies of clauses ) disjunctive program @xmath72 , @xmath0 is a least model of @xmath499 if and only if @xmath0 is a derivable model of @xmath520 .",
    "we will now prove this claim . to simplify notation ,",
    "we will write @xmath280 instead of @xmath520 .",
    "first , we note @xmath72 and @xmath280 have the same models .",
    "thus , each side of the equivalence implies that @xmath0 is a model of @xmath280 .",
    "in particular , it follows ( no matter which implication we are proving ) that @xmath280 has a canonical computation @xmath523 .",
    "next , we observe that for every @xmath357 , the definitions of @xmath280 and @xmath499 imply that @xmath524 in particular , since @xmath525 , for every @xmath334 , we have @xmath526 these identities imply that the result of the canonical @xmath280-computation for @xmath0 and the least model of @xmath499 coincide . consequently",
    ", @xmath0 is a derivable model of @xmath280 if and only if @xmath0 is a least model of @xmath499 as claimed .",
    "in the paper , we introduced and studied the formalism of @xmath193-programs .",
    "when all constraints in @xmath59 are monotone , this formalism offers an abstract framework for integrating constraints into logic programming .",
    "it exploits and builds on analogies with normal logic programming .",
    "most concepts and techniques for monotone @xmath59-programs are closely patterned after their counterparts developed there and so , normal logic programming can be viewed as a fragment of the theory of monotone @xmath59-programs .",
    "importantly , the same is the case for other nonmonotonic systems namely , the disjunctive logic programming with the possible - model semantics of @xcite , and for the formalism of logic programs with weight constraints @xcite . for these two formalisms , monotone @xmath59-programs help to explain the nature of their relationship with normal logic programming , hidden by their original definitions .    in this paper",
    ", we developed a sound foundation for the theory of monotone @xmath193-programs .",
    "recently , the theory of monotone @xmath59-programs was developed further .",
    "@xcite demonstrated that fages lemma @xcite , and the concepts of the program completion and a loop formula extend to the setting of monotone @xmath59-programs .",
    "the latter two properties allow one to reduce stable - model computation for programs with weight constraints to the problem of computing models of propositional theories extended with weight atoms ( referred to as _ pseudo - boolean _ constraints in the satisfiability community ) .",
    "@xcite exploited this reduction and developed an algorithm to compute stable models of programs with weight constraints by using off - the - shelf solvers of pseudo - boolean constraints such as those described in @xcite .",
    "there are strong analogies between the approach we propose and develop here and some of the _ techniques _ discussed in @xcite in the context of disjunctive programs with the semantics of possible models .",
    "one way to look at the results of our paper is that it extends the way @xcite handles nondeterminism , inherent in disjunctive logic programs , to the abstract setting of monotone @xmath59-programs . in particular",
    ", @xcite presents a computational procedure for disjunctive programs without negation , which can be shown to be closely related to our notion of a @xmath72-computation .",
    "that paper also introduces a nondeterministic provability operator , defined for _ positive _ disjunctive programs .",
    "three aspects differentiate our work from @xcite .",
    "most importantly , we study here a much broader class of programs than disjunctive ones .",
    "secondly , we define a provability operator on the class of _ all _ monotone @xmath59-programs and not just positive ones .",
    "finally , we consistently exploit properties of this operator , and align our approach with the standard operator - based development of normal logic programming @xcite .    the emergence of a nondeterministic one - step provability operator warrants additional comments .",
    "nondeterministic provability operators were considered before in the context of logic programming .",
    "we already noted that @xcite proposed a provability operator similar to the one we introduced here ( although only for the class of _ positive _ disjunctive programs ) .",
    "@xcite proposed another operator designed to capture a different computational process arising in the context of paraconsistent systems .",
    "finally , @xcite presented a characterization of answer sets of disjunctive logic programs in terms of yet another nondeterministic provability operator .",
    "however , the operator we proposed here exhibits the closest parallels with the van emden - kowalski operator and opens up a possibility of generalizing the approximation theory proposed in @xcite to the case of monotone @xmath59-programs .",
    "however , for that to happen , one will need techniques for handling nondeterministic operators on lattices , similar to those presented for the deterministic operators in @xcite .",
    "developing such techniques is an open problem .",
    "the authors wish to thank the anonymous reviewers for their detailed comments and suggestions , which helped improve the paper .",
    "the second author was supported by the academy of finland grant 211025 .",
    "the other two authors were supported by the nsf grants iis-0097278 and iis-0325063 .    , ramani , a. , markov , i. , and sakallah , k. 2002 . : a backtrack - search pseudo - boolean solver and optimizer . in _ proceedings of the 5th international symposium on theory and applications of satisfiability , ( sat-02)_. 346  353 .            ,",
    "faber , w. , leone , n. , and perri , s. declarative and computational properties of logic programs with aggregates . in _ proceedings of the 19th international joint conference on artificial intelligence ( ijcai-05 ) _",
    ", 406411 .      ,",
    "faber , w. , ielpa , g. , leone , n. , and pfeifer , g. 2003 .",
    "aggregate functions in disjunctive logic programming : semantics , complexity , and implementation in dlv . in _ proceedings of the 18th international joint conference on artificial intelligence ( ijcai-2003)_. morgan kaufmann , 847852 .    ,",
    "marek , v. , and truszczyski , m. 2000 .",
    "approximations , stable operators , well - founded fixpoints and applications in nonmonotonic reasoning . in _ logic - based artificial intelligence _ , j.  minker , ed .",
    "kluwer academic publishers , 127144 .      , pelov , n. , and bruynooghe , m. 2001 .",
    "ultimate well - founded and stable semantics for logic programs with aggregates . in _ logic programming , proceedings of the 2001 international conference on logic programming ( iclp-01)_. _ lncs 2237_. springer , 212226 .      , leone , n. , and pfeifer , g. 2004 .",
    "recursive aggregates in disjunctive logic programs : semantics and complexity . in _ proceedings of the 9th european conference on artificial intelligence ( jelia-04)_. _ lnai 3229_. springer , 200  212 .              , pfeifer , g. , faber , w. , eiter , t. , gottlob , g. , perri , s. , and scarcello , f. 2006 .",
    "the dlv system for knowledge representation and reasoning . .",
    "to appear , available at http://xxx.lanl.gov/abs/cs.ai/0211004 .",
    "local - search techniques in propositional logic extended with cardinality atoms . in _ proceedings of the 9th international conference on principles and practice of constraint programming ( cp-2003)_. _ lncs 2833_. springer , 495509 .    2005a .",
    "pbmodels - software to compute stable models by pseudoboolean solvers . in _ logic programming and nonmonotonic reasoning , proceedings of the 8th international conference ( lpnmr-05)_. _ lnai 3662_. springer , 410415 .        , niemel , and truszczyski , m. 2004 .",
    "characterizing stable models of logic programs with cardinality constraints .",
    "in _ logic programming and nonmonotonic reasoning , proceedings of the 7th international conference ( lpnmr-04 ) _ , _ lnai 2923_. springer , 154166 .",
    "smodels  an implementation of the stable model and well - founded semantics for normal logic programs . in _ logic programming and nonmonotonic reasoning , proceedings of the 4th international conference ( lpnmr-97)_. _ lnai 1265_. springer , 420429 .    , simons , p. , and soininen , t. 1999 .",
    "stable model semantics of weight constraint rules . in _ logic programming and nonmonotonic reasoning , proceedings of the 5th international conference ( lpnmr-99)_. _ lnai 1730_. springer , 317331 .      , denecker , m. , and bruynooghe , m. 2004 .",
    "partial stable models for logic programs with aggregates . in _ logic programming and nonmonotonic reasoning , proceedings of the 7th international conference ( lpnmr-04 ) _ , _ lnai 2923_. springer , 207219 .                ,",
    "pontelli , e. , and tu , p.h . 2006 .",
    "answer sets for logic programs with arbitrary abstract constraint atoms . in _ proceedings of the 21st national conference on artificial intelligence ( aaai-06)_. aaai press , 129134 ."
  ],
  "abstract_text": [
    "<S> we introduce and study logic programs whose clauses are built out of _ monotone constraint atoms_. we show that the operational concept of the one - step provability operator generalizes to programs with monotone constraint atoms , but the generalization involves nondeterminism . </S>",
    "<S> our main results demonstrate that our formalism is a common generalization of ( 1 ) normal logic programming with its semantics of models , supported models and stable models , ( 2 ) logic programming with weight atoms ( _ lparse _ programs ) with the semantics of stable models , as defined by niemel , simons and soininen , and ( 3 ) of disjunctive logic programming with the possible - model semantics of sakama and inoue . </S>",
    "<S> + to appear in _ theory and practice of logic programming _ ( tplp ) .    </S>",
    "<S> logic programs , stable models , constraints </S>"
  ]
}