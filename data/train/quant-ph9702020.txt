{
  "article_text": [
    "a quantum computer is a quantum system whose time evolution can be thought of as a computation , much in the same way as we think of the time evolution of a pocket calculator to be a computation .    for our pourposes it will suffice to model the quantum system as a `` black box '' and focus our attention on two discrete observables out of a complete set , which we shall call the input and output register .",
    "following the standard notation  @xcite , we shall indicate the computation of a function @xmath0 as @xmath1 the first ket describing the state of the input register and the second the state of the output register .",
    "kets are labelled according to the elements of @xmath2 and @xmath3 they represent .",
    "one of the most powerful features of quantum computation is _ quantum parallelism_. the superposition principle of quantum mechanics allows us to prepare the computer in a coherent superposition of a set @xmath4 of input states . after a single run ,",
    "all of the corresponding outputs @xmath5 appear in the final state , according to the time evolution @xmath6 unfortunately , this is no `` pay one , take n '' .",
    "in fact , the result is an entangled state of the input and output registers and there is no single measurement allowing us to extract from it all the computed values of @xmath5  @xcite .",
    "however , it may well be possible to distil from this final state some _ global property _ of the function , thus exploiting quantum parallelism .",
    "one of the most famous examples was presented by d.  deutsch , who showed that a single quantum computation may suffice to state whether a two  valued function of a two  valued variable is constant or not  @xcite .",
    "d.  deutsch and r.  jozsa later generalized this result  @xcite showing that the problem of classifying a given function @xmath7 as `` not constant '' or `` not balanced '' can be solved in polynomial time by means of a quantum computer ( the time required by a classical solution is exponential ) .",
    "also d.  r.  simon showed that the problem of determining if a function is invariant under a so  called xor mask , while it is classically intractable , admits an efficient quantum solution  @xcite .",
    "all of the algorithms cited above ( apart from the last , for which simon also considered a fully probabilistic generalization ) are characterized by a variable running time and zero error probability .",
    "they consist of a non  classical computation like  ( [ thestandardcomputation ] ) followed by a measurement of the final state of the computer , as a result of which either the correct answer is obtained or the relevant information is destroyed and an explicitly inconclusive result is returned . in the latter case one has to go through the whole procedure again , so that only an average running time for the algorithm can be estimated .",
    "global properties of functions that can be determined by such an algorithm are said to be computable by quantum parallelism ( qpc).this definition was put forward by jozsa  @xcite who also demonstrated that , at least in the case of two  valued functions , the qpc properties that can be determined by means of a single computation are an exponentially small fraction of all the possible global properties .    in this paper we tackle the general problem of stating whether a function @xmath8 is constant or not .    we show that for @xmath9 or @xmath10 this property is not qpc , meaning that any measurement following a computation like  ( [ thestandardcomputation ] ) has a finite probability of yielding a wrong result .",
    "we therefore investigate the power of quantum parallelism in a fully probabilistic setting . assuming that the ( classical ) computation of @xmath11 on @xmath12 randomly sampled points yields a constant value",
    ", we calculate the posterior probability that @xmath11 is actually constant .",
    "we then compute the analogous probability for a quantum algorithm requiring the same number of computations of @xmath11 .",
    "comparison of the two results shows that our quantum strategy allows making a better guess at the solution , its indications being more likely to be correct .",
    "we shall now briefly recall the classical example put forward by d.  deutsch  @xcite , before confronting the problem of its generalization .",
    "suppose we are given a function @xmath13 and we are interested to know whether @xmath11 is constant or not .",
    "of course there are only four such functions ( i.e. four instances of the problem ) , namely @xmath14    if all we can use is a classical computer , there is only one way to do the job : we must compute _ both _ @xmath15 and @xmath16 and compare them to check if they are equal . on the contrary , since in this simple case the property `` @xmath11 is constant '' is qpc , a quantum computer gives us a fair chance of finding the solution at the cost of the single computation @xmath17    after the computation , the calculator halts with its input and output registers in one of four possible states , corresponding to the four possible functions : @xmath18    since the above states are linearly dependent , they can not be distinguished with certainty .",
    "this means that no measurement can establish which function was actually computed , or , which is the same , it s impossible to extract from the final state _ both _ the values of @xmath15 and @xmath16 .",
    "however , we need only discriminate @xmath19 and @xmath20 , the final states yielded by the constant functions , from @xmath21 and @xmath22 . this can actually be done by measuring on the final state of the two registers an observable with the following non  degenerate eigenstates : @xmath23 these four states can be thought of as `` flags '' indicating the result of the computation and have been named according to their meaning .",
    "this becomes clearer as soon as we rewrite the final states  ( [ finalstates ] ) on the basis of the above eigenvectors : @xmath24    it is now evident that    1 .",
    "projection along the eigenvector @xmath25 can only take place if the state of the computer is either @xmath19 or @xmath20 , i.e. when @xmath11 is constant ; 2 .",
    "likewise , projection along the eigenvector @xmath26 can only occur if @xmath11 is not a constant function ; 3 .   regardless of the final state @xmath27 of the two registers after the computation ,",
    "the measurement can yield a @xmath28 state with probability @xmath29 ; 4 .",
    "state @xmath30 is orthogonal to the four final states listed above , and therefore it should show up only as a consequence of noise  induced errors .",
    "note that , according to the definition of the qpc class  @xcite , the quantum algorithm can either give us the correct answer or no answer at all : as long as everything works properly , we ll never get a wrong result .",
    "this comes in handy when we are asked to solve a decision  theoretic problem in which simply waiting has a much higher utility than taking a wrong action .",
    "in this case we can discard the fail results and base our decisions upon the meaningful answers , which we know to be correct .",
    "the straightforward generalization of deutsch s example would go as follows .",
    "given a function @xmath31 and assuming we can perform the non  classical computation @xmath32 we are asked to devise an observable @xmath33 on the joint state of the two registers such that , after a single measurement of @xmath33 , we can either    1 .",
    "obtain a reliable indication that function @xmath11 is constant ; 2 .",
    "obtain an equally reliable indication that @xmath11 is not constant , or finally 3 .",
    "get an explicitly inconclusive result .",
    "let @xmath34 be the hilbert space of the joint states of the input and output registers .",
    "if @xmath35 is the basis of @xmath34 formed by the ( non  degenerate ) eigenstates of @xmath33 , all that is needed would be the existence of two disjoint subsets @xmath36 such that    1 .",
    "all the final states obtained from the computation of constant ( non  constant ) functions have a non  zero projection along @xmath37 ( along @xmath38 ) ; 2 .",
    "the final states corresponding to non  constant ( constant ) functions are orthogonal to @xmath37 ( to @xmath38 ) .",
    "these two requirements are evidently fulfilled in the case of deutsch s example , as can be easily seen by taking @xmath39 and @xmath40 ( for further details see  @xcite ) .",
    "however , as soon as the domain and range of the function @xmath11 grow larger , requirements _ i. _ and _ ii . _ become incompatible .",
    "what happens is that whenever @xmath9 or  @xmath10 the computation of constant functions yields final states that are linearly dependent upon those obtainable from non  constant functions .",
    "this clearly forbids the existence of @xmath37 , since the final states coming from non  constant functions can not be orthogonal to @xmath37 .",
    "in other words , the global property `` @xmath11 is constant '' is no longer qpc in the general case . note that , as demonstrated by jozsa  @xcite , this result is independent of the particular superposition used as the input state for the non  classical computation  ( [ thecomputation ] ) .",
    "the fact that the investigated property of @xmath11 is not qpc compels us to work in a fully probabilistic setting in order to cope with the possibility of wrong results . preserving the general structure of the algorithm",
    "as outlined at the beginning of the preceding section , we note that we can still devise an observable @xmath41 such that any `` '' ket has a large projection along a subset @xmath42 of the eigenstates of @xmath41 ; for example , we can arrange for @xmath43 to be the very space spanned by the `` constant '' vectors .",
    "the problem is now that since `` non  constant '' kets generally have a non  zero projection along @xmath42 , measuring @xmath41 no longer ensures a clear  cut distinction between constant and non  constant functions .",
    "however , since `` non  constant '' final states do have some component along the orthocomplement of @xmath42 , measuring @xmath41 still gives some ( probabilistic ) information about the computed function @xmath11 .",
    "we are left with two asymmetrical possibilities ( actually , as we shall see , a more convienient choice for @xmath42 also makes an explicitly inconclusive result possible ) :    1 .   measuring @xmath41 yields an eigenvalue associated to the orthocomplement of @xmath43 in @xmath34 . since this can only happen",
    "if the computed function @xmath11 is _ not _ constant , this is an exact solution to the problem .",
    "2 .   measuring @xmath41 projects the final state of the two registers onto a state in @xmath42 .",
    "if the computed function were constant , this would be the only possibility ; unfortunately , as seen above , other functions may also yield the same result .",
    "we have therefore obtained only a probabilistic indication about @xmath11 being constant .",
    "it is now clear that the generalized algorithm is essentially similar to a classical probabilistic algorithm , in that its results are not necessarily correct .",
    "nevertheless , as we shall see in the following sections , the posterior probability of the function actually being constant after a result of type _ b. _ is obtained turns out to be much larger for our quantum algorithm than for the classical `` sampling '' strategy ( see section  [ evaluation ] ) .    in the rest of this section",
    "we shall deal with the choice of the observable , which constitutes the core of the algorithm .",
    "we would now like to introduce a correspondence between the hilbert space @xmath34 of the two registers of the computer and the space @xmath44 of complex matrices with @xmath45 rows and @xmath46 columns .",
    "let @xmath47 be the computational basis of @xmath34 , the first ket referring to the state of the input register and the second to that of the output register : @xmath48 we define the isomorphism @xmath49 by identifying @xmath50 with the @xmath51 matrix whose elements are @xmath52_{i , j}= \\delta_{m , i}\\delta_{n , j}.\\ ] ] the isomorphism @xmath53 , which maps the elements of @xmath47 onto the canonical basis of @xmath54 , is then extended by linearity to the whole @xmath34 .",
    "since the final state of the computer after the computation of function @xmath11 is @xmath55 the entries of the corresponding matrix @xmath56 turn out to be @xmath57 , so that @xmath58 somehow resembles the graph of @xmath11 drawn with the `` @xmath59 '' axis along the rows and the `` @xmath60 '' axis pointing down . instead of @xmath61 for the upper left element of matrix @xmath58 . ]",
    "it is easy to check that the scalar product @xmath62 in @xmath54  is preserved by @xmath53 , i.e.  @xmath63 for any two vectors @xmath64 , @xmath65 of @xmath34 ( we write @xmath66 for the scalar product in @xmath34 . )",
    "we shall now construct the observable @xmath41 as specified at the beginning of this section .",
    "an observable in @xmath67 is identified by its @xmath68 eigenstates that form an orthogonal basis , or , using the isomorphism @xmath53 , by @xmath68 orthogonal matrices in @xmath54 .",
    "we propose to take the @xmath68 two  parameter matrices @xmath69 with @xmath70 and @xmath71 whose entries are defined by @xmath72    we shall call the above matrices _ fourier transform matrices _ ( ftm ) .",
    "we recall that given a matrix @xmath73 , its two dimensional discrete fourier transform @xmath74 is defined as @xmath75 therefore the components of @xmath76 on the ftm basis are the entries of its discrete fourier transform @xmath77 .    we still have to decide which eigenvectors are to be taken as an indication of the function  @xmath11 being constant .",
    "in other words we have fixed the basis @xmath78 but have yet to choose the subset @xmath79 .",
    "we take @xmath80 as composed by the @xmath81 matrices @xmath82 , with @xmath83 .",
    "it is easy to check that @xmath84 spans the subspace of @xmath54  generated by the set of the @xmath45 matrices @xmath85 corresponding to the constant functions .",
    "we have not included @xmath86 in @xmath87 because the projection probability of the computer s final state on @xmath86 is the same for all functions : @xmath88 therefore @xmath86 has the same role that state @xmath89 had in deutsch s example . in the following",
    "we shall put @xmath90 and we shall speak equivalently of the matrix @xmath86 in @xmath54  or of the state @xmath89 in @xmath67 .    likewise , since @xmath91 for all @xmath92 and every matrix @xmath58 , subset @xmath93 plays the role of the @xmath30 state in deutsch s example ( section  [ theexample ] ) .    the remaining ftm matrices constitute set @xmath38 : @xmath94 note that we did not put a prime on @xmath38 , since it does satisfy both conditions _ i. _ and _ ii . _",
    "listed in section  [ impossibility ] .",
    "this accounts for the lack of symmetry we pointed out at the beginning of section  [ generalization ] .",
    "suppose we run the quantum algorithm @xmath12 times on the same function @xmath11 and we always get an indication that @xmath11 is constant ( a projection onto @xmath42 ) .",
    "we need to gauge the reliability of this result , which we can do by computing the posterior probability @xmath95 ( @xmath96 for short ) that the function really is constant .",
    "this quantity can also be used to compare the efficiency of the quantum algorithm against a conventional classical solution , since what we are looking for is a procedure giving the lowest probability of error in change for the same computational effort .    to evaluate ( [ prob ] ) we use bayes theorem , that is @xmath97 where by @xmath98 we mean the joint probability that @xmath11 is constant _ and _ that @xmath12 runs of the algorithm yield a `` constant '' outcome , corresponding to the final state being projected along @xmath87 . by the product rule ,",
    "this can be expressed as @xmath99 assuming a uniform probability distribution on all the possible functions , we have @xmath100 .",
    "regardless of the computed function @xmath11 , fail results have a @xmath101 probability of showing up ( see equation  [ prfail ] ) .",
    "this leads to @xmath102 . as a consequence  ( [ qnum ] ) becomes @xmath103    the denominator of  ( [ bayes ] )",
    "can be expanded over all the @xmath104 possible functions of type  ( [ f ] ) : @xmath105 since we assumed the input functions to be uniformly distributed , we have @xmath106 the @xmath12 runs of the quantum algorithm are stochastically independent and that implies that the likelihoods @xmath107 appearing in  ( [ total ] ) are simply given by @xmath108 ^k,\\ ] ] where with @xmath109 we mean the likelihood of a single run , the probability of a projection onto @xmath80 when the function is @xmath11 .",
    "so we can concentrate only on @xmath109 , which , with the help of the sum rule , can be expressed as @xmath110 here @xmath111 stays for event `` after the measure the computer s final state projects itself onto the subspace of all constant functions '' , @xmath112 for the projection onto the matrix @xmath113 , which represents the @xmath114-th constant function and is defined as @xmath115 , and fail for the projection onto @xmath116 .",
    "we have used the fact that , thanks to the orthogonality relations , events @xmath117 are mutually exclusive and so are @xmath80 and fail and that @xmath118 and @xmath119 .    as we have seen in  ( [ prfail ] ) , @xmath120 . on the other hand @xmath121 where @xmath122 is the matrix related through isomorphism @xmath123 to the computer s final state when the function is @xmath11 ( note that most of the elements of @xmath58 are zero , since @xmath124 ) .",
    "let us now compute explicitly the trace that appears in the r.h.s .  of  ( [ ter ] ) : @xmath125 equation ( [ ter ] ) then becomes @xmath126    equation ( [ trace ] ) contains the sum of the elements appearing in the @xmath127-th row of matrix ( [ af ] ) . since matrix @xmath58 has a sole one in any column , this sum is equivalent to the number of ones in the @xmath114-th row of @xmath58 .",
    "this gives us an idea for a smart classification of all the possible functions appearing in  ( [ total ] ) : we associate with every function an @xmath128uple @xmath129 , where @xmath130 is the number of rows of its corresponding matrix @xmath58 with @xmath131 ones and @xmath132 zeroes .",
    "doing so we can replace the sum over @xmath133 appearing in ( [ total ] ) by a sum over the @xmath128uples @xmath129 , with conditions @xmath134 condition  ( [ one ] ) expresses the requirement that the total number of ones in matrix @xmath58 is @xmath46 ( or , since each column contains a sole one , that @xmath58 has @xmath46 columns ) , while  ( [ two ] ) is equivalent to the condition that @xmath58 has @xmath45 rows . in the following",
    ", we shall indicate with @xmath135 the set of the @xmath128uples @xmath129 that satisfy equations  ( [ zero])([two ] ) .",
    "note that , since every @xmath128uple corresponds to more than one function , when summing over the @xmath128uples we must use the right combinatorial factors .",
    "these , for a fixed @xmath128uple @xmath129 , are given by : @xmath136 the first term corresponding to column permutations and the second to row permutations .",
    "we can now use equation  ( [ finalpr ] ) together with this way of classifying the functions to evaluate the total likelihood @xmath137 that appears as the first term in equation  ( [ key ] ) .",
    "if @xmath138 stands for a function corresponding to the @xmath128uple @xmath129,@xmath139 consequently  ( [ totlik ] ) becomes@xmath140 and  ( [ indip ] ) becomes in turn @xmath141 ^k\\text{.}\\ ] ]    now we can sum over all the possible @xmath128uples with conditions  ( [ zero])([two ] ) and with the combinatorial factors  ( [ comb ] ) , obtaining the expression of equation  ( [ total ] ) in the quantum case:@xmath142 ^kc_{j_0,j_1,\\ldots , j_n}\\ ] ] ( n.b .",
    "we have used the fact that @xmath143 , since we suppose a prior uniform probability distribution on all the functions ) .",
    "finally , using also equation  ( [ num ] ) we can express the posterior probability  ( [ bayes ] ) in the quantum case as @xmath144^k c_{j_0,j_1,\\ldots , j_n}}\\text{.}\\ ] ]    in the following section we will derive the corresponding expression for the classical case .",
    "there exists at least one obvious classical probabilistic algorithm that can be used to spot constant functions .",
    "we can simply compute the value of @xmath145 on @xmath12 randomly chosen points of its domain and decide that @xmath11 is constant if its restriction to the sampled points is .",
    "this procedure , which we shall call the `` sampling algorithm '' , evidently constitutes the best possible classical strategy to solve the problem , since it uses up all the information we can gain on @xmath11 by @xmath12 classical computations .    in order to allow a direct comparison with the quantum algorithm",
    ", we have to find out what the posterior probabilities @xmath146 are in this case .",
    "starting again from bayes theorem , we can express the numerator of equation  ( [ bayes ] ) as @xmath147 that by  ( [ unif ] ) is equal to @xmath148 ( note that in the classical case @xmath149 , since no fail results exist ) .",
    "we must now evaluate the denominator of bayes formula , namely equation  ( [ total ] ) .",
    "choosing the @xmath12 inputs at random actually turns out to be inessential as long as the functions are uniformly distributed : sampling the first @xmath12 points @xmath150 is just as good .",
    "let us therefore divide all the possible functions into two classes .",
    "the first is made up by those for which at least the first @xmath12 values are constant ; they are @xmath151 .",
    "all the other functions belong to the second class . as a consequence , the likelihoods that appear in the r.h.s . of ( [ total ] )",
    "are simply given by@xmath152 putting this expression in ( [ total ] ) , and recalling ( [ unif ] ) , we can rewrite  ( [ bayes ] ) as @xmath153    this result is to be compared with equation  ( [ quantum ] ) , which gives the corresponding posterior probability after @xmath12 runs of the quantum algorithm . in order to do so , formula  ( [ quantum ] )",
    "must evidently be evaluated by means of a ( classical ! ) computer . before listing the numerical results , however , we are going to discuss two special cases that can be solved analytically in the limit of large @xmath46 .",
    "we shall now analyse the behaviour of our generalized quantum algorithm in the worst possible case , that is when the computed function has maximum probability of being mistaken for a constant function , even if it is not .",
    "this occurs quite naturally for a matrix of the following kind : @xmath154 { \\overbrace {          \\begin{array}[c]{cccccc }                  1 & 1 & 1 & \\ldots & 1 & 0 \\\\                  0 & 0 & 0 & \\ldots & 0 & 1 \\\\                  0 & 0 & 0 & \\ldots & 0 & 0 \\\\                  \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\                  0 & 0 & 0 & \\ldots & 0 & 0           \\end{array } } ^{n } }   \\hspace{1 mm } \\right ) \\right\\}\\scriptstyle{m}\\ ] ] representing a function @xmath155 that is constant on its whole domain but for one point .",
    "the resulting probability of error is given by the squared modulus of the projection of @xmath156 on the space spanned by the set @xmath157 of the matrices associated to constant functions   is so large that the probability of a fail result is negligible .",
    "] , that is @xmath158 therefore @xmath159 tends to one in the limit of large @xmath46 . here again , in order to compensate for this we have to run the quantum algorithm several times , say @xmath12 ( classically , we would have to sample more and more points ) .",
    "if we want to keep the probability of being `` cheated '' by an almost  constant function @xmath155 as low as a given value @xmath160 , we evidently have to choose @xmath12 so that @xmath161 , that is @xmath162    as we would expect , @xmath12 does tend to infinity in the limit of large @xmath46 , meaning that exploring an even larger domain requires an infinite number of computations .",
    "it is nevertheless interesting to study the ratio @xmath163 of the number of runs to the number of elements in the domain . in the limit of large @xmath46",
    ", this becomes @xmath164 which is a constant independent on @xmath46 .",
    "therefore , if we are required to perform the computation with a worst case error probability @xmath160 , we have to run our quantum computer a number of times which , in the limit of large @xmath46 , is a definite fraction @xmath165 of @xmath46 .",
    "equation  ( [ worstcaseerrorprobability ] ) can in this case be inverted to obtain @xmath160 as a function of @xmath165 , yielding @xmath166 .",
    "coming now to the classical case , sampling a fraction @xmath165 of the points in the domain ( which requires @xmath167 computations ) entails having a probability @xmath168 of mistaking @xmath155 for @xmath169 .",
    "in figure  [ worstcasefigure ] we plotted the worst case probability of error against @xmath165 for both the quantum and the classical algorithm in the limit of large @xmath46 . in the quantum case",
    "@xmath160 decreases more rapidly and stays well below the classical probability of error as long as @xmath165 is not too close to @xmath170 ( remember that the `` sampling '' algorithm is no longer probabilistic if we compute our function over its entire domain ! ) .",
    "looking now at the best case , we find that there is again a single class of functions which is easily dealt with by both algorithms , that is one  to  one functions or permutations of the points in the domain ( this obviously requires @xmath46 to be equal to @xmath45 ) .    using the classical sampling algorithm",
    ", one can evidently be sure to distinguish an invertible function from a constant one with only two computations , since the former does not assume any value in its range more than once .    in the quantum case ,",
    "permutations are associated with matrices having exactly one `` 1 '' in each row and in each column .",
    "such matrices turn out to be orthogonal to @xmath87 .",
    "therefore , a measurement of the final state yielded by a permutation can either result in a fail or in projection along @xmath38 , which indicates that the function is not constant .",
    "now fails can only be obtained with probability @xmath171 , which luckily vanishes as @xmath46 grows larger .",
    "we conclude that , in the limit of large @xmath46 , the quantum algorithm is practically guaranteed to spot a one  to  one function at first sight , after a single computation , thus doubling the efficiency of the classical algorithm .    by the way",
    ", we note that if we only had to tell constant functions from permutations  if our practical problem did nt require us to deal with non ",
    "invertible , non  constant functions  we would be back to the original situation of deutsch s example .",
    "we can now see what was so special about the four functions considered by deutsch in his original example ( see equation  [ thefourfunctions ] ) .",
    "when both the domain and the range consist of two points only all non  constant functions turn out to be one  to  one , so that all ambiguity is removed .",
    "we are including , in figures  [ fig8x2lin ] through  [ fig24x24log ] , some comparative graphics of the posterior probabilities @xmath146 expressed by equations  ( [ bayes2 ] ) and  ( [ quantum ] ) versus the number @xmath12 of successful computations effected ( by successful computation we mean all computations barring fail results ) .",
    "as our previous analysis suggested , the quantum algorithm turns out to be far more efficient than the classical `` sampling '' algorithm for small values of @xmath172 .",
    "we emphasize that this result is entirely dependent upon the use of quantum parallelism .",
    "this highly non  classical feature of quantum computation apparently allows a quicker exploration of the domain of function @xmath11 , even in the case that the investigated property is _ not _ qpc .",
    "the posterior probability @xmath173 we used for our numerical calculations is conditoned to a sequence of @xmath12 `` constant results '' of the quantum algorithm .",
    "we have overlooked the possibility of obtaining one or more fail outcomes .",
    "this is particularly significant when @xmath174 ( figures  [ fig8x2lin ] and  [ fig16x2log ] ) , because in such cases a fail result has a @xmath29 probability to show up .",
    "this means that in order to obtain @xmath12 projections of the final state of the computer along @xmath42 one must expect to run the quantum computer @xmath175 times .",
    "nervertheless , as the graphics show , the quantum strategy always turns out to be convenient , at least for small values of @xmath172 .",
    "we finally note that as @xmath46 and @xmath45 grow larger ( see for instance figure  [ fig24x24log ] ) the resulting posterior probabilities turn out to be so low that both the quantum and the classical algorithm are virtually useless .",
    "this entirely depends on our assumption of an uniform distribution over functions @xmath11 , which is probably eccessively penalizing . in real ",
    "world situations , we can expect the quantum algorithm to be useful in any situation in which the `` sampling '' algorithm is successfully employed at the present day .",
    "we are grateful to c.  m.  becchi for posing the question which led to this work .",
    "we acknowledge the interest of g.  castagnoli and the collaboration with elsag  bailey ; we also thank a.  ekert and c.  macchiavello for interesting discussion .",
    "special thanks to e.  beltrametti for continuous help and advice .",
    "2 a.  ekert , r.  jozsa : quantum computation and shor s factoring algorithm , _ reviews of modern physics _ * 68 * , 733754 ( 1996 ) r.  jozsa : characterizing classes of functions computable by quantum parallelism , _ proc .",
    "lond . _ a ( 1991 ) * 435 * , 563574 d.  deutsch : quantum theory , the church  turing principle and the universal quantum computer , _ proc .",
    "lond . _ a * 400 * , 97117 ( 1985 ) d.  deutsch , r.  jozsa : rapid solution of problems by quantum computation , _ proc .",
    "a ( 1992 ) * 439 * , 553558 d.  r.  simon : on the power of quantum computation , _ proceedings of the 35th annual ieee symposium on the foundations of computer science _ , 1994 , 116123"
  ],
  "abstract_text": [
    "<S> quantum parallelism is the main feature of quantum computation . in  1985 </S>",
    "<S> d.  deutsch showed that a single quantum computation may be sufficient to state whether a two  valued function of a two  valued variable is constant or not . </S>",
    "<S> though the generalized problem with unconstrained domain and range size admits no deterministic quantum solution , a fully probabilistic quantum algorithm is presented in which quantum parallelism is harnessed to achieve a quicker exploration of the domain with respect to the classical `` sampling '' strategy . </S>"
  ]
}