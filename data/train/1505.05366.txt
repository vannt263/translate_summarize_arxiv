{
  "article_text": [
    "research in knowledge representation ( kr ) faces two major problems .",
    "first of all , a large variety of different languages for representing knowledge - each of them useful for particular types of problems - has been produced .",
    "there are many situations where the integration of the knowledge represented in diverse formalisms is crucial , and principled ways of achieving this integration are needed .",
    "secondly , most of the tools providing reasoning services for kr languages were developed for offline usage : given a knowledge base ( kb ) computation is one - shot , triggered by a user , through a specific query or a request to compute , say , an answer set .",
    "this is the right thing for specific types of applications where a specific answer to a particular problem instance is needed at a particular point in time .",
    "however , there are different kinds of applications where a reasoning system is continuously online and receives information about a particular system it observes .",
    "consider an assisted living scenario where people in need of support live in an apartment equipped with various sensors , e.g.,smoke detectors , cameras , and body sensors measuring relevant body functions ( e.g.,pulse , blood pressure ) .",
    "a reasoning system continuously receives sensor information .",
    "the task is to detect emergencies ( health problems , forgotten medication , overheating stove , ... ) and cause adequate reactions ( e.g.,turning off the electricity , calling the ambulance , ringing an alarm ) .",
    "the system is continuously online and has to process a continuous stream of information rather than a fixed kb .",
    "this poses new challenges on kr formalisms .",
    "most importantly , the available information continuously grows .",
    "this obviously can not go on forever as the kb needs to be kept in a manageable size .",
    "we thus need principled ways of forgetting / disregarding information . in the literature",
    "one often finds sliding window techniques  @xcite where information is kept for a specific , predefined period of time and forgotten if it falls out of this time window .",
    "we believe this approach is far too inflexible .",
    "what is needed is a dynamic , situation dependent way of determining whether information needs to be kept or can be given up .",
    "ideally we would like our online kr system to guarantee specific response times ; although it may be very difficult to come up with such guarantees , it is certainly necessary to find means to identify and focus on relevant parts of the available information . moreover , although the definition of the semantics of the underlying kr formalism remains essential , we also need to impose procedural aspects reflecting the necessary modifications of the kb .",
    "this leads to a new , additional focus on _ runs _ of the system , rather than single evaluations .",
    "nonmonotonic multi - context systems ( mcss ) @xcite were explicitly developed to handle the integration problem . in a nutshell ,",
    "an mcs consists of reasoning units - called contexts for historical reasons @xcite - where each unit can be connected with other units via so - called bridge rules .",
    "the collection of bridge rules associated with a context specifies additional beliefs the context is willing to accept depending on what is believed by connected contexts .",
    "the semantics of the mcs is then defined in terms of equilibria . intuitively , an equilibrium is a collection of belief sets , one for each context , which fit together in the sense that the beliefs of each context adequately take into account what the other contexts believe .",
    "the original framework was aimed at modeling the flow of information among contexts , consequently the addition of information to a context was the only possible operation on kbs . to capture more general forms of operations mcss were later generalized to so called managed mcss ( mmcss ) @xcite .",
    "the main goal of this paper is to demonstrate that this additional functionality makes managed mcss particularly well - suited as a basis for handling the mentioned problems of online reasoning systems as well .",
    "the main reason is that the operations on the knowledge bases allow us to control things like kb size , handling of inconsistent observations , focus of attention , and even whether a particular context should be idle for some time .",
    "however , to turn mmcss into a reactive online formalism we first need to extend the framework to accommodate observations .",
    "we will do so by generalizing bridge rules so that they have access not only to belief sets of other contexts , but also to sensor data .",
    "this allows systems to become _ reactive _ , that is , to take information about a dynamically changing world into account and to modify themselves to keep system performance up .",
    "the rest of the paper is organized as follows .",
    "we first give the necessary background on mmcss .",
    "we then extend the framework to make it suitable for dynamic environments , in particular we show how observations can be accommodated , and we define the notion of a run of an mcs based on a sequence of observations .",
    "the subsequent sections address the following issues : handling time and the frame problem ; dynamic control of kb size ; focus of attention ; control of computation ( idle contexts ) .",
    "we finally discuss the complexity of some important decision problems .",
    "we now give the necessary background on managed mcss @xcite which provides the basis for our paper .",
    "we present a slightly simplified variant of mmcss here as this allows us to better highlight the issues relevant for this paper .",
    "however , if needed it is rather straightforward ( albeit technically somewhat involved ) to extend all our results to the full version of mmcss .",
    "more specifically we make two restrictions : 1 ) we assume all contexts have a single logic rather than a logic suite as in @xcite ; 2 ) we assume that management functions are deterministic .",
    "in addition we will slightly rearrange the components of an mmcs which makes them easier to use for our purposes .",
    "in particular , we will keep bridge rules and knowledge bases separate from their associated contexts .",
    "the latter will change dynamically during updates , as we will see later , and it is thus convenient to keep them separate .",
    "bridge rules will be separated due to technical reasons ( i.e.,better presentation of the later introduced notion of a run ) .",
    "an mmcs builds on an abstract notion of a _ logic _",
    "@xmath0 as a triple @xmath1 , where @xmath2 is the set of admissible knowledge bases ( kbs ) of @xmath0 , which are sets of kb - elements ( `` formulas '' ) ; @xmath3 is the set of possible belief sets , whose elements are beliefs ; and @xmath4 is a function describing the semantics of @xmath0 by assigning to each kb a set of acceptable belief sets .",
    "a context is of the form @xmath5 where    * @xmath0 is a logic , * @xmath6 is a set of operations , * @xmath7 is a management function .    for an indexed context",
    "@xmath8 we will write @xmath9 , @xmath10 , and @xmath11 to denote its components .",
    "[ def : br ] let @xmath12 be a tuple of contexts .",
    "a bridge rule for @xmath8 over @xmath13 ( @xmath14 ) is of the form @xmath15 such that @xmath16 and every @xmath17 ( @xmath18 ) is an atom of form @xmath19 , where @xmath20 , and @xmath21 is a belief for @xmath22 , i.e.,@xmath23 for some @xmath24 .    for a bridge rule @xmath25 ,",
    "the operation @xmath26 is the _ head _ of @xmath25 , while @xmath27 is the _ body _ of @xmath25 .",
    "[ def : mcs ] a _ managed multi - context system ( mmcs ) _",
    "@xmath28 is a triple consisting of    1 .",
    "a tuple of contexts @xmath29 , 2 .",
    "a tuple @xmath30 , where each @xmath31 is a set of bridge rules for @xmath8 over @xmath13 , 3 .   a tuple of kbs @xmath32 such that @xmath33 .    a belief state @xmath34 for @xmath35 consists of belief sets @xmath36 , @xmath37",
    "given a bridge rule @xmath25 , an atom @xmath38 is satisfied by @xmath39 if @xmath40 and a negated atom @xmath41 is satisfied by @xmath39 if @xmath42 .",
    "a literal is an atom or a negated atom .",
    "we say that @xmath25 is applicable wrt .",
    "@xmath39 , denoted by @xmath43 , if every literal @xmath44 is satisfied by @xmath39 .",
    "we use @xmath45 to denote the heads of all applicable bridge rules of context @xmath8 wrt .",
    "@xmath39 .",
    "the semantics of an mmcs @xmath35 is then defined in terms of equilibria , where an _ equilibrium _ is a belief state @xmath34 satisfying the following condition : the belief set chosen for each context must be acceptable for the kbs obtained by applying the management function to the heads of applicable bridge rules and the kb associated with the context . more formally , for all contexts @xmath46 : let @xmath47 be the belief set chosen for @xmath8 .",
    "then @xmath39 is an equilibrium if , for @xmath14 , @xmath48 management functions allow us to model all sorts of modifications of a context s kb and thus make mmcss a powerful tool for describing the influence contexts can have on each other .",
    "to make an mmcs @xmath35 suitable for reactive reasoning in dynamic environments , we have to accomplish two tasks :    1 .",
    "we must provide means for the mcs to obtain information provided by sensors , and 2 .",
    "we have to formally describe the behavior of the mcs over time .",
    "let us first show how sensors can be modeled abstractly .",
    "we assume that a sensor @xmath49 is a device which is able to provide new information in a given language @xmath50 specific to the sensor . from an abstract point of view",
    ", we can identify a sensor with its observation language and a current sensor reading , that is , @xmath51 where @xmath52 . given a tuple of sensors @xmath53",
    ", an observation @xmath54 for @xmath49 ( @xmath49-observation for short ) consists of a sensor reading for each sensor , that is , @xmath55 where for @xmath56 , @xmath57 .",
    "each context must have access to its relevant sensors .",
    "contexts already have means to obtain information from outside , namely the bridge rules .",
    "this suggests that the simplest way to integrate sensors is via an extension of the bridge rules : we will assume that bridge rules in their bodies can not only refer to contexts , but also to sensors .    a reactive multi - context system ( rmcs ) over sensors",
    "@xmath53 is a tuple @xmath58 , as in def .",
    "[ def : mcs ] except that the atoms @xmath17 ( @xmath18 ) of bridge rules in @xmath59 for context @xmath8 of form  ( [ bridgerule ] ) can either be a _ context atom _ of form @xmath60 as in def .",
    "[ def : br ] , or a _ sensor atom _ of form @xmath61 , where @xmath62 is an index determining a sensor ( @xmath63 ) and @xmath64 is a piece of sensor data .",
    "the applicability of bridge rules now also depends on an observation :    let @xmath49 be a tuple of sensors and @xmath55 a @xmath49-observation .",
    "a sensor atom @xmath61 is _ satisfied _ by @xmath54 if @xmath65 ; a literal @xmath66 is _ satisfied _ by @xmath54 if @xmath67 .",
    "let @xmath58 be an rmcs with sensors @xmath49 and @xmath39 a belief state for @xmath35 .",
    "a bridge rule @xmath25 in @xmath59 is _ applicable _ wrt . @xmath39 and @xmath54 ,",
    "symbolically @xmath68 , if every context literal in @xmath69 is satisfied by @xmath39 and every sensor literal in @xmath69 is satisfied by @xmath54 .    instead of @xmath70 we use @xmath71 to define an equilibrium of an rmcs in a similar way as for an mmcs :",
    "let @xmath58 be an rmcs with sensors @xmath49 and @xmath54 a @xmath49-observation . a belief state @xmath72 for @xmath35 is an equilibrium of @xmath35 under @xmath54 if , for @xmath14 , @xmath73    let @xmath58 be an rmcs with sensors @xmath49 , @xmath54 a @xmath49-observation , and @xmath72 an equilibrium of @xmath35 under @xmath54 .",
    "the tuple of kbs generated by @xmath39 is defined as @xmath74 .",
    "the pair @xmath75 is called full equilibrium of @xmath35 under @xmath54 .",
    "we now introduce the notion of a run of an rmcs induced by a sequence of observations :    let @xmath58 be an rmcs with sensors @xmath49 and @xmath76 a sequence of @xmath49-observations .",
    "a run of @xmath35 induced by @xmath77 is a sequence of pairs @xmath78 such that    * @xmath79 is a full equilibrium of @xmath35 under @xmath80 , * for @xmath81 with @xmath82 , @xmath81 is a full equilibrium of @xmath83 under @xmath84 .    to illustrate the notion of a run ,",
    "let s discuss a simple example .",
    "we want to model a clock which allows other contexts to add time stamps to sensor information they receive .",
    "we consider two options .",
    "we will first show how a clock can be realized which generates time internally by increasing a counter whenever a new equilibrium is computed .",
    "we later discuss a clock based on a sensor having access to  objective \" time . in both cases we use integers as time stamps .",
    "[ ex : clock ] consider a context @xmath22 whose kbs ( and belief sets ) are of the form @xmath85 for some integer @xmath86 .",
    "let @xmath87 .",
    "assume the single bridge rule of the context is @xmath88 , which intuitively says time should be incremented whenever an equilibrium is computed .",
    "the management function is thus defined as @xmath89 for each @xmath86 .",
    "since the computation of the ( full ) equilibrium is independent of any other contexts and observations , the context just increments its current time whenever a new equilibrium is computed .",
    "each run of an rmcs with context @xmath22 will thus contain for @xmath22 the sequence of belief sets @xmath90 , @xmath91 , @xmath92 .",
    "the example illustrates that the system may evolve over time even if there is no observation made at all .",
    "it is illustrative to compare this with a context @xmath93 which is like the one we discussed except for the bridge rules which now are the instances of the schema @xmath94 the management function correspondingly becomes @xmath95 for all @xmath86 .",
    "note that in this case no equilibrium exists !",
    "the reason for this is that by replacing @xmath96 with @xmath97 the precondition for the rule sanctioning this operation goes away .",
    "special care thus needs to be taken when defining the operations .    in the rest of the paper we will often use an alternative approach where  objective \" time is entered into the system by a particular sensor @xmath98 . in this case each update of the system makes time available to each context via the current sensor reading of @xmath98 .    in example",
    "[ ex : clock ] we already used a bridge rule schema , that is , a bridge rule where some of the parts are described by parameters ( denoted by uppercase letters ) .",
    "we admit such schemata to allow for more compact representations .",
    "a bridge rule schema is just a convenient abbreviation for the set of its ground instances .",
    "the ground instances are obtained by replacing parameters by adequate ground terms .",
    "we will admit parameters for integers representing time , but also for formulas and even contexts . in most cases",
    "it will be clear from the discussion what the ground instances are , in other cases we will define them explicitly .",
    "we will also admit some kind of basic arithmetic in the bridge rules and assume the operations to be handled by grounding , as is usual , say , in answer set programming .",
    "for instance , the bridge rule schema @xmath99 which we will use to handle the frame problem in the next section has ground instances @xmath100 , @xmath101 , etc .",
    "although in principle parameters for integers lead to an infinite set of ground instances , in our applications only ground instances up to the current time ( or current time plus a small constant , see sect .",
    "[ sec : control ] ) are needed , so the instantiations of time points remain finite .    in the upcoming sections we describe different generic modeling techniques for rmcss . for concrete applications ,",
    "these techniques can be refined and tailored towards the specific needs of the problem domain at hand . to demonstrate this aspect",
    ", we provide a more specific example from an assisted living application .",
    "[ ex : bob1 ] although bob suffers from dementia , he is able to live in his own apartment as it is equipped with an assisted living system that we model by means of an rmcs . assume bob starts to prepare his meal .",
    "he leaves the kitchen to go to the bathroom .",
    "after that , he forgets he has been cooking , goes to bed and falls asleep .",
    "the rmcs should be able to recognize a potential emergency based on the data of different sensors in the flat that monitor , e.g.,the state of the kitchen equipment and track bob s position .",
    "our rmcs @xmath35 has three contexts @xmath102 and sensors @xmath103 .",
    "@xmath104 is the kitchen equipment context that monitors bob s stove .",
    "its formulas and beliefs are atoms from @xmath105 representing the stove s power status ( on / off ) and a qualitative value for its temperature ( cold / hot ) .",
    "the logic @xmath106 of @xmath104 has a very simple semantics @xmath107 in which every knowledge base @xmath108 has only one accepted belief set coinciding with the formulas of @xmath108 , i.e.,@xmath109 .",
    "the bridge rules for @xmath104 over @xmath13 are @xmath110 that react to switching the stove on or off , registered by sensor @xmath111 , respectively read numerical temperature values from sensor @xmath112 and classify the temperature value as cold or hot .",
    "the management function @xmath113 @xmath114 ensures that the stove is considered on when it is switched on or when it is not being switched off and already considered on in the old knowledge base @xmath108 .",
    "otherwise , the kb constructed by the management function contains the atom @xmath115 .",
    "context @xmath116 keeps track of bob s position .",
    "the language of sensor @xmath117 is given by @xmath118 and non - empty sensor readings of @xmath117 signal when bob has changed rooms .",
    "the semantics of @xmath116 is also @xmath107 and its bridge rules are given by the schema @xmath119 the management function writes bob s new position into the kb whenever he changes rooms and keeps the previous position , otherwise .",
    "@xmath120 is the context for detecting emergencies .",
    "it is implemented as an answer - set program , hence the acceptable belief sets of @xmath121 are the answer sets of its kbs .",
    "the bridge rules of @xmath122 do not refer to sensor data but query other contexts : @xmath123 the answer - set program @xmath124 is given by the rule @xmath125 the management function of @xmath122 that adds information from the bridge rules temporarily as input facts to the context s kb is given by @xmath126 @xmath127 consider the sequence @xmath128 of @xmath49-observations with @xmath129 for @xmath130 , @xmath131 , @xmath132 , @xmath133 , @xmath134 , @xmath135 , and @xmath136 for all other @xmath137 .",
    "then , @xmath138 is a full equilibrium of @xmath35 under @xmath139 , where @xmath140 and @xmath141 equals @xmath142 except for the last component which is @xmath143 .",
    "moreover , @xmath144 is a run of @xmath35 induced by @xmath77 , where @xmath145",
    "in this section we discuss how to model an rmcs where possibly inconsistent sensor data can be integrated into a context @xmath146 . to this end , we add a time tag to the sensor information and base our treatment of time on the second option discussed in the last section , that is , we assume a specific time sensor @xmath98 that yields a reading @xmath147 of the actual time of the form @xmath148 where @xmath86 is an integer .",
    "let @xmath149 be the sensors which provide relevant information for @xmath146 in addition to @xmath98 .",
    "then @xmath146 will have bridge rules of the form @xmath150 where the operation @xmath151 is meant to add new , time tagged information to the context .",
    "we assume the readings of a single sensor at a particular time point to be consistent . however , it is a common problem that the readings of different sensors may be inconsistent with each other wrt.some context - dependent notion of inconsistency . to handle this",
    "we foresee a management function @xmath152 that operates based on a total preference ranking of the available sensors .",
    "the third argument of the @xmath151 operation provides information about the source of sensor information and thus a way of imposing preferences on the information to be added . without loss of generality",
    "assume @xmath153 , that is , sensor @xmath154 has highest priority .",
    "now let @xmath155 be the set of add - operations in the heads of bridge rules active in belief state @xmath39 .",
    "we define @xmath156 and for @xmath157 we let @xmath158 @xmath159 finally , we define @xmath160 .",
    "this shows how the management function can solve conflicts among inconsistent sensor readings based on preferences among the sensors .",
    "of course , many more strategies of integrating inconsistent sensor data can be thought of which we are not going to discuss in the paper .",
    "please also note that the bridge rules do not necessarily have to pass on sensor information as is to the context .",
    "they may as well provide the context with some abstraction of the actual readings .",
    "for instance , the sensor temperature information @xmath161 may be transformed into qualitative information by a rule schema like @xmath162    we next present a way to address the frame problem using bridge rules when sensors are not guaranteed to provide complete information about the state of the environment in each step . in this case",
    "we want to assume , at least for some of the atoms or literals observed at time @xmath163 which we call persistent , that they also hold at time @xmath164 .",
    "assume @xmath165 is some persistent observable property .",
    "persistence of @xmath165 is achieved by the following bridge rule schema : @xmath166    please note that in order to avoid non - existence of equilibria as discussed at the end of sect .",
    "[ sec : rmcs ] the use of this rule schema for the frame problem presupposes that information about @xmath165 valid at time @xmath163 remains available and is not deleted by any other bridge rule .",
    "to illustrate our approach we discuss in this section a context @xmath167 which can be used for emergency detection in dynamic environments .",
    "assume there are @xmath168 potential emergencies @xmath169 we want the context to handle .",
    "the role of @xmath167 is to check , based on the observations made , whether one or more of the emergencies @xmath170 are suspected or confirmed .",
    "based on information about potential emergencies @xmath167 adjusts the time span observations are kept .",
    "this is the basis for intelligent forgetting based on dynamic windows .",
    "we do not make any assumption about how @xmath167 works internally apart from the following :    * @xmath167 may signal that emergency @xmath170 is suspected ( @xmath171 ) or confirmed ( @xmath172 ) . * @xmath167 has information about default , respectively actual window sizes for different observations ( @xmath173 , @xmath174 ) , and * about the number of time steps observations are relevant for particular emergencies ( @xmath175 )",
    ".    given facts of the form mentioned above , here is a possible collection of bridge rules for the task . the operation @xmath176 sets the window size to a new value , deleting the old one .",
    "to signal an alarm , information is added to the context kb via the operation @xmath177 .",
    "xxxxx = xxxxxxxxxxxxx = xxi = @xmath178 @xmath179 @xmath180 + @xmath181 @xmath179 @xmath182 + @xmath183 @xmath179 @xmath184    finally , we have to make sure deletions of observations are performed in accordance with the determined window sizes : @xmath185    the management function just performs additions and deletions on the context kb . since additions always are tagged with the current time , whereas deletions always refer to an earlier time , there can never be a conflict .",
    "we have so far described a form of focusing where a time window is extended based on a specific suspected event .",
    "the next example shows a different form of focusing where specific information is generated and kept only during there is a potential danger in a particular room .",
    "[ ex : bob2 ] continuing example  [ ex : bob1 ] we show how context @xmath122 can focus on specific rooms if there is a potential emergency . for the kitchen there is a threat if the stove is on , and it then becomes important to track whether someone is in the kitchen .",
    "assume @xmath122 has a potential belief @xmath186 expressing the stove is @xmath187 since @xmath164 .",
    "focusing on the kitchen can be modeled by following the asp - rule in @xmath122 s kb : @xmath188 in addition we will need a bridge rule , which keeps track whether bob is absent from a room in case that room is in the current focus : @xmath189 as well as a bridge rule to forget the absence in a room if it is no longer necessary . there",
    "the delall operator removes all occurrences of absence with respect to a given room @xmath190 from the kb of the context . @xmath191 with those modifications it is possible to generate an alert if bob was too long away from the kitchen although the stove is active .",
    "in this section we show how it is possible - at least to some extent - to control the effort spent on the computation of particular contexts .",
    "we introduce a specific control context @xmath192 which decides whether a context it controls should be idle for some time .",
    "an idle context just buffers sensor data it receives , but does not use the data for any other computations .",
    "let s illustrate this continuing the discussion of sect .",
    "[ sec : forget ] .",
    "assume there are @xmath193 different contexts for detecting potential emergencies as described earlier .",
    "the rmcs we are going to discuss is built on an architecture where each detector context @xmath8 , @xmath56 is connected via bridge rules with the control context .",
    "@xmath192 receives information about suspected emergencies and decides , based on this information , whether it is safe to let a context be idle for some time .",
    "we now address the question what it means for a detector context to be idle .",
    "a detector context @xmath8 receives relevant observations to reason whether an emergency is suspected or confirmed . in case @xmath8",
    "is idle , we can not simply forget about new sensor information as it may become relevant later on , but we can buffer it so that it does not have an effect on the computation of a belief set , besides the fact that a buffered information shows up as an additional atom in the belief set which does not appear anywhere in the context s background knowledge .    to achieve this we have to modify @xmath8 s original bridge rules by adding , to the body of each rule , the context literal @xmath194 .",
    "this means that the bridge rules behave exactly as before whenever the control context does not decide to let @xmath8 be idle .    for the case where @xmath8 is idle ,",
    "i.e. where the belief set of @xmath192 contains @xmath195 , we just make sure that observations are buffered .",
    "this means that for each rule of the form @xmath196 in the original set of bridge rules we add @xmath197 the operation @xmath198 just adds the atom @xmath199 to the context ( we assume here that the language of the context contains constructs of this form ) . as mentioned above , this information is not used anywhere in the rest of the context s kb , it just sits there for later use .",
    "the only missing piece is a bridge rule bringing back information from the buffer when the context is no longer idle .",
    "this can be done using the bridge rule @xmath200 .",
    "whenever the management function has to execute this operation , it takes all information out of the buffer , checks whether it is still within the relevant time window , and if this is the case adds it to the kb , handling potential inconsistencies the way discussed in sect .",
    "[ sec : data ] .",
    "the control context uses formulas of the form @xmath201 to express context @xmath202 is idle until time @xmath86 .",
    "we intend here to give a proof of concept , not a sophisticated control method . for this reason",
    "we simply assume the control context lets a detector context be idle for a specific constant time span @xmath203 whenever the detector does not suspect an emergency .",
    "this is achieved by the following bridge rule schemata :    xxx = xxxxxxxxxxxxxxxxxx = xx = @xmath204 @xmath179 @xmath205 + @xmath206 @xmath179 @xmath207 + @xmath208    provided information of the form @xmath201 is kept until the actual time is @xmath209 , the last 2 conditions in the second rule schema guarantee that after being idle for period @xmath203 the context must check at least once whether some emergency is suspected . to avoid a context staying idle forever",
    ", we assume the management function deletes information of this form whenever @xmath86 is smaller than the current time minus 1 .",
    "one more rule schema to make sure information about idle contexts is available in the form used by detector contexts : @xmath210",
    "we want to analyze the complexity of queries on runs of rmcss .",
    "for simplicity we do not consider parametrized bridge rules here , and assume that all knowledge bases in rmcss are finite and all management functions can be evaluated in polynomial time .",
    "[ def : compldecprob ] the problem @xmath211 , respectively @xmath212 , is deciding whether for a given rmcs @xmath35 with sensors @xmath49 , a context @xmath8 of @xmath35 , a belief @xmath213 for @xmath8 , and a finite sequence of @xmath49-observations @xmath77 it holds that @xmath214 for some @xmath215 ( @xmath216 ) for some run , respectively all runs , @xmath217 of @xmath35 induced by @xmath77 .",
    "as the complexity of an rmcs depends on that of its individual contexts we introduce the notion of _ context complexity _ along the lines of eiter _",
    "et al . _",
    "@xcite . to do so",
    ", we need to focus on relevant parts of belief sets by means of projection . intuitively , among all beliefs , we only need to consider belief @xmath213 that we want to query and beliefs that contribute to the application of bridge rules for deciding @xmath211 and @xmath212 . given @xmath35 , @xmath49 , @xmath8 , and @xmath213 as in definition  [ def : compldecprob ] ,",
    "the _ set of relevant beliefs _ for a context @xmath146 of @xmath35 is given by @xmath218 .",
    "a _ projected belief state _ for @xmath35 and @xmath219 is a tuple @xmath220 where @xmath221 is a belief state for @xmath35 .",
    "the _ context complexity _ of @xmath146 in @xmath35 wrt.@xmath219 for a fixed @xmath49-observation @xmath54 is the complexity of deciding whether for a given projected belief state @xmath39 for @xmath35 and @xmath219 , there is some belief state @xmath222 for @xmath35 with @xmath223 and @xmath224 for all @xmath225 .",
    "the system s context complexity @xmath226 is a ( smallest ) upper bound for the context complexity classes of its contexts .",
    "our complexity results are summarized in table  [ tab : complexity ] .",
    "@xmath227    membership for @xmath211 : a non - deterministic turing machine can guess a projected belief state @xmath215 for all @xmath168 observations in @xmath77 in polynomial time .",
    "then , iteratively for each of the consecutive observations @xmath228 , first the context problem can be solved polynomially or using an oracle ( the guess of @xmath229 and the oracle guess can be combined which explains that we stay on the same complexity level for higher context complexity ) . if the answer is yes , @xmath229 is a projected equilibrium .",
    "we can check whether @xmath214 , compute the updated knowledge bases and continue the iteration until reaching the last observation .",
    "the argument is similar for the co - problem of @xmath212 .",
    "hardness : holds by a reduction from deciding equilibrium existence for an mcs when @xmath226 is polynomial and by a reduction from the context complexity problem for the other results .",
    "note that @xmath211 and @xmath212 are undecidable if we allow for infinite observations .",
    "the reason is that rmcss are expressive enough ( even with very simple context logics ) to simulate a turing machine such that deciding @xmath211 or @xmath212 for infinite runs solves the halting problem .",
    "in this paper we introduced reactive mcss , an extension of managed mcss for online reasoning , and showed how they allow us to handle typical problems arising in this area . although we restricted our discussion to deterministic management functions , two sources of non - determinism can be spotted by the attentive reader .",
    "on the one hand , we allow for semantics that return multiple belief sets for the same knowledge base , and , on the other hand , non - determinism can be introduced through bridge rules .",
    "the simplest example is guessing via positive support cycles , e.g.,using bridge rules like @xmath230 that allow ( under the standard interpretation of @xmath151 ) for belief sets with and without formula  @xmath231 .",
    "multiple equilibria may lead to an exponential number of runs . in practice ,",
    "non - determinism will have to be restricted .",
    "a simple yet practical solution is to focus on a single run , disregarding alternative equilibria .",
    "here , one might ask which is the best full equilibrium to proceed with . in this respect",
    ", it makes sense to differentiate between non - deterministic contexts and non - determinism due to bridge rules . in the first case ,",
    "it is reasonable to adopt the point of view of the answer - set programming ( asp ) paradigm , i.e.,the knowledge bases of a context can be seen as an encoding of a problem such that the resulting belief sets correspond to the problem solutions .",
    "hence , as every belief set is a solution it does not matter which one to choose .",
    "thus , if the problem to be solved is an optimisation problem that has better and worse solutions , this could be handled by choosing a context formalism able to express preferences so that the semantics only returns sufficiently good solutions .",
    "for preferences between equilibria that depend on the belief sets of multiple contexts , one can not rely on intra - context preference resolution . here , we refer the reader to preference functions as proposed by ellmauthaler  @xcite .",
    "one might also adopt language constructs for expressing preferences in asp such as optimization statements  @xcite or weak constraints  @xcite .",
    "essentially , these assign a quality measure to an equilibrium . with such additional quality measures at hand",
    ", the best equilibrium can be chosen for the run .    as to related work",
    ", there is quite some literature on mcss by now , for an overview see @xcite .",
    "recently an interesting approach to belief change in mcss has been proposed  @xcite .",
    "other related work concerns stream reasoning in asp  @xcite and in databases : a continuous version of sparql  @xcite exists , and logical considerations about continuous query languages  @xcite were investigated .",
    "kowalski s logic - based framework for computing  @xcite is an approach which utilizes first order logic and concepts of the situation- and event - calculus in response to observations .",
    "updates on knowledge - bases , based upon the outcome of a given semantics where also facilitated for other formalisms , like logic programming in general .",
    "there the iterative approaches of epi  @xcite and evolp  @xcite are the most prominent .",
    "note that none of these related approaches combines a solution to both knowledge integration and online reasoning , as we do .",
    "jos  jlio alferes , antonio brogi , joo  alexandre leite , and lus  moniz pereira , ` evolving logic programs ' , in _",
    "8th european conference on logics in artificial intelligence ( jelia 2002 ) _ , eds . ,",
    "sergio flesca , sergio greco , nicola leone , and giovambattista ianni , volume 2424 of _ lecture notes in computer science _ , pp .",
    "springer , ( september 2002 ) .",
    "chitta baral , jorge lobo , and goce trajcevski , ` formal characterizations of active databases : part ii ' , in _",
    "5th international conference on deductive and object - oriented databases ( dood 1997 ) _ , eds .",
    ", franois bry , raghu ramakrishnan , and kotagiri ramamohanarao , volume 1341 of _ lecture notes in computer science _ , pp . 247264 .",
    "springer , ( 1997 ) .",
    "g.  brewka , t.  eiter , and m.  fink , ` nonmonotonic multi - context systems : a flexible approach for integrating heterogeneous knowledge sources ' , in _ logic programming , knowledge representation , and nonmonotonic reasoning _ , 233258 ,",
    "springer , ( 2011 ) .",
    "gerhard brewka , stefan ellmauthaler , and jrg phrer , ` multi - context systems for reactive reasoning in dynamic environments ' , in _",
    "21st european conference on artificial intelligence ( ecai 2014 ) _ , ( 2014 ) . to appear .",
    "f.  buccafurri , n.  leone , and p.  rullo , ` strong and weak constraints in disjunctive datalog . ' , in _",
    "4th international conference on logic programming and nonmonotonic reasoning ( lpnmr 1997 ) _ , pp . 217 , ( 1997 ) .",
    "thomas eiter , michael fink , guiliana sabbatini , and hans tompits , ` a framework for declarative update specifications in logic programs ' , in _ proceedings of the 17th international joint conference on artificial intelligence ( ijcai 2001 ) _ , ed .",
    ", bernhard nebel , pp .",
    "morgan kaufmann , ( 2001 ) .",
    "s.  ellmauthaler , ` generalizing multi - context systems for reactive stream reasoning applications ' , in _ proceedings of the 2013 imperial college computing student workshop ( iccsw 2013 ) _ , pp .",
    "1724 , ( 2013 ) .",
    "m.  gebser , t.  grote , r.  kaminski , p.  obermeier , o.  sabuncu , and t.  schaub , ` stream reasoning with answer set programming : preliminary report ' , in _ proceedings of the 13th international conference on the principles of knowledge representation and reasoning ( kr 2012 ) _ , ( 2012 ) .",
    "y.  wang , z.  zhuang , and k.  wang , ` belief change in nonmonotonic multi - context systems ' , in _",
    "12th international conference on logic programming and nonmonotonic reasoning ( lpnmr 2013 ) _ , pp .",
    "543555 , ( 2013 ) ."
  ],
  "abstract_text": [
    "<S> we show in this paper how managed multi - context systems ( mmcss ) can be turned into a reactive formalism suitable for continuous reasoning in dynamic environments . </S>",
    "<S> we extend mmcss with ( abstract ) sensors and define the notion of a run of the extended systems . </S>",
    "<S> we then show how typical problems arising in online reasoning can be addressed : handling potentially inconsistent sensor input , modeling intelligent forms of forgetting , selective integration of knowledge , and controlling the reasoning effort spent by contexts , like setting contexts to an idle mode . </S>",
    "<S> we also investigate the complexity of some important related decision problems and discuss different design choices which are given to the knowledge engineer . </S>"
  ]
}