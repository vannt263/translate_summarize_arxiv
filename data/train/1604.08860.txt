{
  "article_text": [
    "we focus on algorithms solving the online string matching problem , which consists in reporting all , and only the occurrence positions of a pattern @xmath0 in a text @xmath1 ( _ online _ meaning that no pre - processing of the text is allowed ) .",
    "as one of the oldest problems addressed in computer science , it has been extensively studied .",
    "we refer to @xcite for a comprehensive list and an evaluation of all the pattern matching algorithms developed so far . by the authors count",
    ", more than 80 algorithms have already been proposed , among which more than a half were published during the last ten years .",
    "this fact sounds quite paradoxical , since the morris - pratt algorithm , which is optimal in terms of worst case analysis , dates back to 1970 .",
    "a possible explanation is that there is wide gap between the worst case complexity of algorithms and their computation times on real data .",
    "for instance , there are pattern matching algorithms with non - linear worst case complexities , which perform much better than morris - pratt on english texts .",
    "basically , the average case analysis is way more suited to assess the relevance of a pattern matching algorithm from a practical point of view .",
    "the average case analysis of some pattern matching algorithms , notably boyer - moore - horspool and knuth - morris - pratt , has already been carried out from various points of view @xcite .",
    "we provide here a general method for studying the limit average behavior of a pattern algorithm over iid texts .",
    "more precisely , following @xcite , we consider the limit expectation of the ratio of the text length to the number of text accesses performed by an algorithm for searching a pattern @xmath0 in iid texts .",
    "this limit expectation is called the asymptotic speed of the algorithm with regard to @xmath0 under the iid model .",
    "the computation of the asymptotic speed is based on @xmath0-matching machines which are automata - like structures able to simulate the behavior of a pattern matching algorithm while searching the pattern @xmath0 .",
    "the underlying idea is the same as in @xcite and can be seen as a generalization of the string matching automaton @xcite .    in the companion paper ,",
    "g. didier provided a theoretical analysis of the asymptotic speed of pattern matching algorithms over iid texts @xcite .",
    "in particular , he showed that , for a given pattern @xmath0 , the greatest asymptotic speed among a large class of pattern matching algorithms , is achieved by a @xmath0-matching machine in which the states are essentially subsets of positions of @xmath0 .",
    "such machines are called _ strategies _ below .",
    "we provide here a brute force algorithm computing the _ fastest _ strategy for a given pattern @xmath0 and the frequencies of an iid model .",
    "the algorithm is based on an original structure associated to the pattern @xmath0 and called its position lattice , which gives a full representation of the overlap relations between the subsets of positions of @xmath0 .",
    "since the brute force algorithm can not be applied on patterns of length greater than @xmath2 , because of its ( very high ) time - complexity , we propose a polynomial _",
    "@xmath3-heuristic _ , in which the polynomial order @xmath3 may be chosen by the user .",
    "the fastest and @xmath3-heuristic approaches are finally compared with 9 several pre - existing pattern matching algorithms :    * from a theoretical point of view , by computing their limit expected speeds with regard to various patterns and iid models , * from a practical point of view , by computing their average speeds over two sources ( an english text and a dna sequence ) .    in both cases , the fastest and @xmath3-heuristic ( with @xmath3 large enough )",
    "approaches outperform the pre - existing algorithms .    the software and the data used to perform the tests are available at https://github.com/gilles-didier/matchines.git .",
    "the rest of the paper is organized as follows .",
    "section [ secnotation ] presents the notations and recalls some concepts and results from @xcite .",
    "it is followed by two sections which introduce the central objects of this work : the strategies and the position lattice of a pattern .",
    "in particular , we provide an algorithm computing the position lattice of a given pattern .",
    "section [ secbrute ] shows how to use the position lattice of a pattern to obtain the fastest strategy with regard to this pattern and an iid model . in section [ secheuristic ] ,",
    "we provide a polynomial heuristic allowing to compute fast strategies .",
    "section [ secevaluation ] presents the results of various comparisons between 9 pre - existing pattern matching algorithms , the @xmath3-heuristic and , each time it is possible , the fastest strategy .",
    "the results are discussed in the last section .",
    "for all finite sets @xmath4 , @xmath5 is the power set of @xmath4 and @xmath6 is its cardinal .",
    "an _ alphabet _ is a finite set @xmath7 of elements called _ letters _ or _ symbols_.    a _ word _ , a _ text _ or a _ pattern _ on @xmath7 is a finite sequence of symbols of @xmath7 .",
    "we put @xmath8 for the length of a word @xmath9 .",
    "words are indexed from @xmath10 , i.e. @xmath11 . we write @xmath12}$ ] for the subword of @xmath9 starting at its position @xmath13 and ending at its position @xmath14 , i.e. @xmath12 } = v_{i}v_{i+1}\\ldots v_{j}$ ] .",
    "the _ concatenate _ of two words @xmath15 and @xmath9 is the word @xmath16 .    for any length @xmath17 , we note @xmath18 the set of words of length @xmath19 on @xmath7 , and @xmath20 , the set of finite words on @xmath7 , i.e. @xmath21 .    unless otherwise specified , all the texts and patterns considered below are on a fixed alphabet @xmath7 .    a _ pattern matching algorithm _ takes a pattern @xmath0 and a text @xmath1 as inputs an reports all , and only the occurrence positions of @xmath0 in @xmath1 . for all patterns",
    "@xmath0 , we say that two pattern matching algorithms are _",
    "@xmath0-equivalent _ if , for all texts @xmath1 , they access exactly the same positions of @xmath1 on the input @xmath22 .      for all patterns @xmath0 ,",
    "a _ @xmath0-matching machine _",
    "is @xmath23-uple @xmath24 where    * @xmath25 is a finite set of states , * @xmath26 is the initial state , * @xmath27 is the subset of pre - match states , * @xmath28 is the next - position - to - check function , which is such that for all @xmath29 , @xmath30 , * @xmath31 is the transition state function , * @xmath32 is the shift function .    by convention , the set of states of a matching machine always contains a _ sink state _",
    "@xmath33 , which is such that , for all symbols @xmath34 , @xmath35 and @xmath36 .",
    "the _ order _ @xmath37 of a matching machine @xmath38 is defined as @xmath39 .",
    "the @xmath0-matching machines carry the same information as the _ deterministic arithmetic automatons _ defined in @xcite .",
    "the generic algorithm takes a @xmath0-matching machine and a text @xmath1 as inputs and outputs positions of @xmath1 ( algorithm [ algogen ] )",
    ".    0.2 cm @xmath40 0.3 cm    each component of a @xmath0-matching machine makes sense in regard to the way it is used by the generic algorithm .",
    "the pre - match states in @xmath41 are those which lead to report an occurrence of the pattern at the current position , if the next - position - to - check of the pattern matches the corresponding position in the text ( line [ litestga ] of algorithm [ algogen ] ) .",
    "the condition @xmath30 for all @xmath29 in the definition of @xmath0-matching machines , is technical and used in @xcite .",
    "a @xmath0-matching machine @xmath42 is _ valid _ if , for all texts @xmath1 , the execution of the generic algorithm on the input @xmath43 outputs all , and only the occurrence positions of @xmath0 in @xmath1 .",
    "since one has to check all the positions of the pattern @xmath0 before concluding that it occurs somewhere in a text , the order of a valid @xmath0-matching machine is at least @xmath44 .",
    "we claim that for all the pattern matching algorithms developed so far and all patterns @xmath0 , there exists a @xmath0-matching machine @xmath42 which is such that , for all texts @xmath1 , the generic algorithm and the pattern matching algorithm access exactly the same positions of @xmath1 on the inputs @xmath43 and @xmath45 respectively @xcite . for instance , figure [ figmatchinebas ] displays a @xmath46-matching machine which accesses the same positions as the naive algorithm while searching @xmath46 .",
    "we present here a transformation on matching machines which split their states according to the text positions read from the current position during an execution of the generic algorithm .",
    "the main point of this transformation is that the average complexity of matching machines such obtained may then be computed through algebraic methods ( sections [ secmodels ] and [ secspeed ] ) .    for all @xmath47 , @xmath48 is the set of subsets @xmath49 of @xmath50 verifying that , for all @xmath51 , there exists at most one pair in @xmath49 with @xmath13 as first entry . for all @xmath52",
    ", we put @xmath53 for the set comprising all the first entries of the pairs in @xmath49 , namely    ( h)=\\{i x(i , x ) h}.    for all @xmath54 and @xmath52 , the _ @xmath55-shifted _ of @xmath49 is    \\{(u - k , y ) ( u , y ) h u k } ,    i.e. the subset of @xmath48 obtained by subtracting @xmath55 from the first entries of the pairs in @xmath49 and by keeping only the pairs with non - negative first entries .",
    "the _ full memory expansion _ of a @xmath0-matching machine @xmath56 is the @xmath0-matching machine @xmath57 obtained by removing the unreachable states of @xmath58 , defined as :    * @xmath59 * @xmath60 * @xmath61 * @xmath62 * @xmath63 * ((q , h ) , x ) = \\ { + ll ( ( q , x ) , ) & + & + ( ( q , x ) , ) & + .    by construction , at all iterations of the generic algorithm on the input @xmath64 , if the current state and position are @xmath65 and @xmath66 , respectively , then the positions of @xmath67 are exactly the positions of @xmath1 greater than @xmath66 accessed so far ( the second entries of the corresponding elements of @xmath49 give the symbols read ) .    for all texts @xmath1 ,",
    "the generic algorithm access the same positions of @xmath1 on the inputs @xmath43 and @xmath64 @xcite .",
    "let us remark that the full memory expansion of the full memory expansion of a matching machine is equal to its full memory expansion ( up to a state isomorphism ) .",
    "a @xmath0-matching machine @xmath42 is _ standard _ if each state @xmath68 of @xmath42 appears in a unique pair / state of its full memory expansion , or , equivalently , if it is equal to its full memory expansion .",
    "for instance the @xmath46-matching machine of figure [ figmatchinebas ] is not standard . since the matching machine of figure [ figmatchineext ] is a full memory expansion , it is standard . for all states @xmath68 of a standard matching machine @xmath42",
    ", we put @xmath69 for the second entry of the unique pair / state of @xmath57 in which @xmath68 appears .",
    "we implemented a basic algorithm computing the full - memory expansion @xmath70 of a @xmath0-matching machine @xmath71 in @xmath72 time .",
    "we have @xmath73 but the size of @xmath74 may vary a lot with regard to the matching machine / algorithm considered .",
    "a @xmath0-matching machine @xmath42 is _ compact _ if it contains no state @xmath68 which always leads to the same state .",
    "formally , @xmath56 is compact if there is no @xmath75 such that one of the following assertions holds :    1 .",
    "there exists a symbol @xmath76 with @xmath77 and @xmath78 for all symbols @xmath79 ; 2 .   for all symbols @xmath76 and @xmath80",
    ", we have both @xmath81 and @xmath82 .",
    "basically , a non - compact machine performs useless text accesses . in @xcite",
    ", it is shown that any @xmath0-matching machine can be turned into a compact ( and faster ) machine .",
    "an _ independent identically distributed ( iid ) _ model ( aka _ bernoulli _ model ) is fully specified by a probability distribution @xmath83 on the alphabet ( i.e. @xmath84 is the probability of the symbol @xmath76 in the model ) .",
    "such a model will be simply referred to as `` @xmath83 '' below .",
    "under @xmath83 , the probability of a text @xmath1 is    _ (",
    "i=0 ^ -1 ( t_i ) .",
    "a _ markov _ model @xmath85 over a given set of states @xmath86 is a @xmath87-uple @xmath88 , where @xmath89 is a probability distribution on @xmath86 ( the initial distribution ) and @xmath90 associates a pair of states @xmath91 with the probability for @xmath68 to be followed by @xmath92 ( the transition probability ) . under a markov model @xmath93 ,",
    "the probability of a sequence @xmath94 of states is    _",
    "m(s ) = _ m(s_0 ) _",
    "i=0 ^ -1 _ m(s_i , s_i+1 ) .",
    "[ theoiid ] let @xmath56 be a @xmath0-matching machine .",
    "if a text @xmath1 follows an iid model and @xmath42 is standard then the sequence of states parsed by the generic algorithm on the input @xmath43 follows a markov model @xmath88 .    whatever the text model and the machine , the sequence of states always starts with @xmath95 with probability @xmath96 .",
    "we have @xmath97 and @xmath98 for all @xmath99 .",
    "the probability @xmath100 that the state @xmath92 follows the state @xmath68 during an execution of the generic algorithm , is equal to :    * @xmath96 , if there exists a symbol @xmath76 such that @xmath101 and @xmath102 , i.e. if the relative position @xmath103 was already checked with @xmath76 occurring at it , * @xmath104 , otherwise ,    independently of the previous states .",
    "let @xmath105 be a text model and @xmath106 be an algorithm .",
    "@xmath0-asymptotic speed _ of @xmath106 under @xmath105 is the limit expectation , under @xmath105 , of the ratio of the text length to the number of text accesses performed by @xmath106 @xcite .",
    "namely , by putting @xmath107 for the number of text accesses performed by @xmath106 to parse @xmath1 and @xmath108 for the probability of @xmath1 with regard to @xmath105 , the asymptotic speed of @xmath106 under @xmath105 is    _ ( ) = _",
    "n_t^n p_(t ) .",
    "the asymptotic speed @xmath109 of a @xmath0-matching machines @xmath42 is that the generic algorithm with @xmath42 as first input . from theorem 5 of @xcite ,",
    "the asymptotic speed of a standard @xmath0-matching machine @xmath110 under an iid model @xmath83 exists and is given by    [ eqasympfreq ] _ ( ) = _ q _",
    "qe(q ) ,    where @xmath111 are the limit frequencies of the states of the markov model associated to @xmath112 and @xmath83 in theorem [ theoiid ] , and    e(q ) = \\ {    ll ( q , x ) & + _ x ( q , x)_x &    .    computing the asymptotic speed of a pattern matching algorithm , with regard to a pattern @xmath0 and an iid model @xmath83 is performed by following the stages below .    1 .   we get a @xmath0-matching machine @xmath42 which simulates the behavior of the algorithm while looking for @xmath0 ( figure [ figmatchinebas ] ) .",
    "the transformation of the 9 algorithms presented in section [ secevaluation ] ( and a few others , see our github repository ) into @xmath0-matching machines , given @xmath0 , has been implemented .",
    "we obtain the full - memory expansion @xmath57 of @xmath42 ( figure [ figmatchineext ] , section [ secfull ] ) .",
    "we compute the limit frequencies of the markov model associated to @xmath57 and @xmath83 in theorem [ theoiid ] .",
    "this mainly needs to solve a system of linear equations of dimension @xmath113 .",
    "we finally obtain the asymptotic speed of the algorithm from these limit frequencies , @xmath83 and @xmath57 by using equation [ eqasympfreq ] .",
    "the most time - consuming stage is the computation of the limit frequencies , which has @xmath114 time complexity , where @xmath113 , the number of states of the full memory expansion , is smaller than @xmath115 .",
    "for all sets @xmath116 and @xmath117 , we define the @xmath55-left - shifted of @xmath118 as    ( , k)\\{i - ki i k}.    a _",
    "@xmath119 is a @xmath0-matching machine such that    * @xmath120 and @xmath121 , * @xmath122 , * @xmath123 , * @xmath124 is such that for all @xmath125 , @xmath126 and @xmath127 , * @xmath128 is such that for all states @xmath129 and all symbols @xmath76 , + ( s , x)=\\ { + ll\\{k1w_(s)-k = x ( s)k w_j = w_j+k j(s , k ) } & s , + \\{k0w_(s)-k = x ( s)k w_j = w_j+k j(s , k ) } & + . * @xmath31 is such that for all @xmath125 and all symbols @xmath76 , + ( s , x ) = ( s\\{(s)},(s , x ) ) .",
    "figure [ figstrategies ] shows two @xmath46-strategies which differ notably in the next - position - to - check of state @xmath130 .",
    "a @xmath0-strategy is a standard , compact , valid and non - redundant @xmath0-matching machine .    by construction",
    ", a @xmath0-strategy is standard , compact and non - redundant .",
    "the validity of a @xmath0-strategy follows from theorem 1 of @xcite .",
    "[ propoptim ] there is a @xmath0-strategy which achieves the greatest asymptotic speed among all the @xmath0-matching machines of order @xmath44 .",
    "the corollary 2 of @xcite implies that there exists a @xmath0-matching machine which achieves the greatest asymptotic speed among those of order @xmath44 and which is    1 .",
    "standard , 2 .",
    "compact , 3 .",
    "valid , 4 .",
    "in which all the states are relevant ( i.e. such that they may lead to a match without any positive shift @xcite ) , 5 .",
    "such that there is no pair of states @xmath131 with @xmath132 and @xmath133 .",
    "let us verify that a @xmath0-matching machine @xmath38 of order @xmath44 satisfying the properties above is ( isomorphic to ) a @xmath0-strategy .",
    "since it verifies in particular the properties 4 and 5 , its set of states @xmath25 is in bijection with a subset of @xmath134 .",
    "let us identify all states @xmath68 of @xmath86 with @xmath135 , its corresponding element of @xmath134 .",
    "since @xmath42 is standard , compact and of order @xmath44 , we do not have @xmath136 . moreover , since @xmath42 is standard , we have @xmath137 for all @xmath125 .",
    "last , by construction , if    ( s , x)>\\ {    ll\\{k1w_(s)-k = x ( s)k w_j = w_j+k j(s , k ) } & s , + \\{k0w_(s)-k = x ( s)k w_j = w_j+k j(s , k ) } &    .",
    "then @xmath42 is not valid , and if    ( s , x)<\\ {    ll\\{k1w_(s)-k = x ( s)k w_j = w_j+k j(s , k ) } & q , + \\{k0w_(s)-k = x ( s)k w_j = w_j+k j(s , k ) } &    .",
    "then @xmath138 is not relevant .",
    "the position lattice of a pattern @xmath0 is the 3-uple @xmath139}}=({q^{[w ] } } , ( { \\delta^{[w]}_{s}})_{s\\in{q^{[w ] } } } , ( { \\gamma^{[w]}_{s}})_{s\\in{q^{[w]}}})$ ] where , by putting @xmath140 for @xmath141 ,    * @xmath142}}= { { \\mathcal{p}(\\{0 , \\ldots , { \\lvertw\\rvert}-1\\})}\\setminus\\{\\{0 , \\ldots , { \\lvertw\\rvert}-1\\}\\}}$ ] , i.e. the set made of all the subsets of positions of @xmath0 but @xmath143 , * for all @xmath144}}$ ] , @xmath145}_{{s}}}$ ] is a map from @xmath146 to @xmath147 , * for all @xmath144}}$ ] , @xmath148}_{{s}}}$ ] is a map from @xmath146 to @xmath142}}$ ] ,    where , for all @xmath144}}$ ] , all @xmath149 and all @xmath34 , we have    ^[w]_s(i , x)=\\ {    ll\\{k1w_(s)-k = x ( s)k w_j = w_j+k j(s , k ) } & = -1 , + \\{k0w_(s)-k = x ( s)k w_j = w_j+k j(s , k ) } &    .    and    ^[w]_s(i , x ) = ( s\\{i},^[w]_s(i , x ) ) .    in particular , if @xmath150 and @xmath151 then we have @xmath145}_{{s}}}(i , x ) = 0 $ ] and @xmath148}_{{s}}}(i , x ) = { s}\\cup\\{i\\}$ ]",
    ".    let us remark that , since @xmath152 for all @xmath144}}$ ] , we have , for all @xmath149 and all @xmath34 , @xmath153 , thus @xmath145}_{{s}}}(i , x)\\leq{\\lvertw\\rvert}$ ] which is consistent with the definition of @xmath145}_{{s}}}$ ] .",
    "the edges of @xmath139}}$ ] are the pairs @xmath154}_{{s}}}(i , x))$ ] for all @xmath144}}$ ] , all @xmath149 and all @xmath34 ( see figure [ figlattice ] ) .    [ remsizelattice ] the position lattice of @xmath0 contains @xmath155 states and @xmath156 edges .",
    "[ remcomp ] let @xmath129 be a state of @xmath142}}$ ] , @xmath13 and @xmath14 be two positions in @xmath140 such that @xmath157 and @xmath76 and @xmath80 be two symbols of @xmath7 .",
    "we have    ^[w]_^[w]_s(i , x)(j-^[w]_s(i , x ) , y)+^[w]_s(i , x ) = ^[w]_^[w]_s(j , y)(i-^[w]_s(j , y ) , x)+^[w]_s(j , y )    ^[w]_^[w]_s(i , x)(j-^[w]_s(i , x ) , y ) = ^[w]_^[w]_s(j , y)(i-^[w]_s(j , y ) , x ) .    by considering the particular case where @xmath158 , we get    ^[w]_s\\ { i } ( j , y ) = ^[w]_^[w]_s(j , y)(i-^[w]_s(j , y ) , w_i)+^[w]_s(j , y )    ^[w]_s\\ { i } ( j , y ) = ^[w]_^[w]_s(j , y)(i-^[w]_s(j , y ) , w_i )",
    ".    let @xmath159 be the table indexed on @xmath160 and in which , for all positions @xmath13 of @xmath0 and all symbols @xmath76 of @xmath7 , the entry @xmath161}$ ] is defined as    _ w[i , x ] = \\ {    ll\\{ji w_j = x } & \\{ji w_j = x } , + &    .",
    "for instance , the table @xmath162 is @xmath163    [ lemmalattice ] let @xmath129 be a state of @xmath142}}$ ] , @xmath13 a position in @xmath140 and @xmath76 a symbol of @xmath7 .    1 .   if @xmath158 then * if @xmath164 then @xmath148}_{{s}}}(i , x ) = \\{0,\\ldots,{\\mathrm{b}}-1\\}$ ] and @xmath145}_{{s}}}(i , x ) = { \\lvertw\\rvert}-{\\mathrm{b}}$ ] , where @xmath165 is the length of the longest proper suffix of @xmath0 which is a prefix of @xmath0 ; * otherwise @xmath148}_{{s}}}(i , x ) = { s}\\cup\\{i\\}$ ] and @xmath145}_{{s}}}(i , x ) = 0 $ ] .",
    "if @xmath166 , 1 .   if @xmath167 then + ^[w]_(i , x ) = \\ { + ll \\{_w[i , x ] } & _ w[i , x ] , + & + + .",
    "+ ^[w]_(i , x ) = \\ { + ll i-_w[i , x ] & _ w[i , x ] , + i+1 & + + .",
    "if @xmath168 then for all @xmath169 , we have + ^[w]_s(i , x ) = ^[w]_^[w]_s(i , x)(-^[w]_s(i , x ) , w _ ) , + ^[w]_s(i , x ) = ^[w]_^[w]_s(i , x)(-^[w]_s(i , x ) , w _ ) + ^[w]_s(i , x ) .    the only case which does not immediately follow from the definition of @xmath139}}$ ] , is when @xmath166 and @xmath168 which is given by remark [ remcomp ] .",
    "the relation @xmath170 on @xmath142}}$ ] is defined as follows .",
    "for all sets @xmath129 and @xmath171 in @xmath142}}$ ] , we have @xmath172 if one of the following properties holds :    * @xmath173 , * @xmath174 , @xmath175 and @xmath176 , where @xmath177 is the symmetric difference of @xmath129 and @xmath171 , * @xmath178 .",
    "the relation @xmath170 defines a total order on @xmath142}}$ ] .",
    "we write ``  @xmath179  '' for ``  @xmath172 and @xmath175  '' .",
    "[ lemmaorder ] let @xmath129 be a state of @xmath142}}$ ] with @xmath180 , @xmath13 a position in @xmath140 and @xmath76 a symbol of @xmath7 . if @xmath166 then @xmath148}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x){\\mathop{\\prec}}{s}$ ] .    under the assumption that @xmath180",
    ", we have @xmath181 . by construction , the fact that @xmath166 implies that @xmath145}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x)>0 $ ] .    if we have @xmath182}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x)\\ ] ] then @xmath183}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x)\\rvert}<{\\lvert{s}\\rvert}$ ] , thus @xmath148}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x){\\mathop{\\prec}}{s}$ ] .",
    "otherwise , we have @xmath183}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x)\\rvert}={\\lvert{s}\\rvert}$ ] but since necessarily @xmath184}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x)\\leq \\min { \\lvert{s}\\rvert}-{\\gamma^{[w]}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x)<\\min { \\lvert{s}\\rvert},\\ ] ] we get again @xmath148}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x){\\mathop{\\prec}}{s}$ ] .",
    "@xmath185 length of the longest proper suffix of @xmath0 which is also a prefix    algorithm [ algolatt ] computes the position lattice of the pattern @xmath0 in @xmath186 time by using the same amount of memory .",
    "let us first show that algorithm [ algolatt ] determines the shifts and the transitions of the state @xmath129 before those of the state @xmath171 if and only if @xmath179 . the loop at lines [ liloopsa]-[liloopea ] computes the shifts and the transitions of @xmath187 .",
    "next , the loop at lines [ liloopsb]-[liloopeb ] computes the shifts and the transitions of the singletons from @xmath130 to @xmath188 .",
    "the last loop ( lines [ liloopsc]-[liloopec ] ) determines the shifts and the transitions of the states corresponding to the subsets of increasing cardinals @xmath189 from @xmath87 to @xmath44 . inside the last loop ,",
    "the way in which the next subset @xmath171 is computed from the current subset @xmath129 , both of cardinal @xmath189 , ensures that @xmath179 ( lines [ liloopscla]-[liloopec ] ) .    for all iterations @xmath13 of the loop at lines [ liloopsa]-[liloopea ] and all symbols @xmath76",
    ", we have @xmath190={\\mathrm{prec}_{w}[i , x]}$ ] at the beginning of the inner loop ( line [ liloopsai ] ) . from lemma [ lemmalattice ] ( cases 1 and 2a ) ,",
    "the transitions @xmath148}_{\\emptyset}}(i , x)$ ] and the shifts @xmath145}_{\\emptyset}}(i , x)$ ] for all positions @xmath13 of @xmath0 and all symbols @xmath76 , are correctly computed at the end of the loop .",
    "the loop at lines [ liloopsb]-[liloopeb ] computes the shifts and the transitions from the singleton states .",
    "for all pairs of positions @xmath191 and all symbols @xmath76 , determining @xmath148}_{\\ { i \\}}}(j , x)$ ] and @xmath145}_{\\ { i \\}}}(j , x)$ ] is performed by distinguishing between two cases .    * if @xmath192 , then @xmath148}_{\\emptyset}}(j , x){\\mathop{\\prec}}\\{i\\}$ ] and its shifts and transitions were already computed .",
    "formula of remark [ remcomp ] gives us those of @xmath193 ( lines [ liloopsbla]-[liloopsblb ] ) .",
    "* if @xmath194 , we distinguish between two subcases according to the symbol @xmath76 considered .",
    "if @xmath195 then the shift and the transition state are given in lemma [ lemmalattice ] - case 1 .",
    "otherwise , we remark that , since @xmath145}_{\\ { i \\}}}(j , x)$ ] is positive , we have that @xmath145}_{\\ { i \\}}}(j , x ) = \\min\\{k\\geq 1{\\mid}w_{j - k } = x \\mbox { if } j\\geq k \\mbox { and } w_{i - k } = w_{i}\\}$ ] .",
    "this implies that @xmath145}_{\\ { i \\}}}(j , x ) = { \\gamma^{[w]}_{{\\delta^{[w]}_{\\emptyset}}(i-1,w_{i})}}(j , x)$ ] .",
    "we have @xmath148}_{\\emptyset}}(i-1,w_{i}){\\mathop{\\prec}}{s}$ ] , thus both the shifts and the transitions of the state @xmath148}_{\\emptyset}}(i-1,w_{i})$ ] are computed before @xmath129 ( lines [ liloopsblc]-[liloopeb ] ) .",
    "the last loop , lines [ liloopsc]-[liloopec ] , computes the shifts and the transitions of the states corresponding to the subsets of cardinals @xmath87 to @xmath196 .",
    "for all states @xmath129 with @xmath197 , all positions @xmath149 and all symbols @xmath166 , the corresponding shift and transition @xmath145}_{{s}}}(i , x)$ ] and @xmath148}_{{s}}}(i , x)$ ] are computed from the shifts and transitions of the state @xmath148}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x)$ ] following lemma [ lemmalattice ] - cases 2b ( in algorithm [ algolatt ] , we put @xmath171 for @xmath198 ) .",
    "lemma [ lemmaorder ] ensures that @xmath148}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x){\\mathop{\\prec}}{s}$ ] , thus that the shifts and transitions of @xmath148}_{{{s}\\setminus{\\{\\max{s}\\}}}}}(i , x)$ ] are computed before those of @xmath129 . for all states",
    "@xmath129 with @xmath197 , all positions @xmath149 , the shift and transition @xmath145}_{{s}}}(i , w_{i})$ ] and @xmath148}_{{s}}}(i , w_{i})$ ] are given in lemma [ lemmalattice ] - case 1 .",
    "the time complexity is @xmath199 ( loop lines [ liloopsc]-[liloopec ] ) , i.e. @xmath186 .",
    "we do not use more memory than needed to store the lattice , which is , from remark [ remsizelattice ] , @xmath186 .",
    "determining the fastest @xmath0-strategy , which , from proposition [ propoptim ] , has the greatest asymptotic speed among all the @xmath0-matching machines of order @xmath44 , may be performed by computing the asymptotic speed of all the @xmath0-strategies and by returning the fastest one .    in order to enumerate all the @xmath0-strategies ,",
    "let us remark that they are all contained in the position lattice of @xmath0 in the sense that :    * the set of states of a @xmath0-strategy is included in that of the position lattice ; * all the @xmath0-strategies @xmath38 verify @xmath200}_{{s}}}({\\boldsymbol\\alpha}({s}),x)$ ] and @xmath201}_{{s}}}({\\boldsymbol\\alpha}({s}),x)$ ] for all @xmath125 and all symbols @xmath76 .",
    "reciprocally , to any map @xmath202 from @xmath142}}$ ] to @xmath203 such that @xmath204 for all states @xmath205}}$ ] , there corresponds the unique @xmath0-strategy @xmath119 for which the next - position - to - check function @xmath206 coincides with @xmath202 on @xmath25 .",
    "finally , our brute force algorithm    1 .   takes as input a pattern @xmath0 and an iid model @xmath83 , 2 .",
    "computes the position lattice of @xmath0 , 3",
    ".   enumerates all the maps @xmath202 such that @xmath204 for all states @xmath205}}$ ] , 4 .   for each @xmath202 , gets the corresponding @xmath0-strategy by keeping only the states of @xmath142}}$ ] reachable from @xmath187 , with the next - position - to - check function @xmath202 , 5 .",
    "computes the asymptotic speed of all the @xmath0-strategies under @xmath83 , 6 .",
    "returns the @xmath0-strategy with the greatest speed .",
    "the time complexity of the brute force algorithm is    o((_k=1 ^ -1 ( -k)^)2 ^ 3 ) ,    where the first factor stands for the number of functions @xmath202 and the second one for the computation of the asymptotic speed of a @xmath0-strategy , which needs to solve a linear system of size equal to the number of states , which is @xmath207 .",
    "its memory space complexity is @xmath208 , i.e. what is needed to store the position lattice of @xmath0 .    under its current implementation ,",
    "the brute force determination of the fastest @xmath0-strategy is unfeasible for patterns of length greater than @xmath2 .",
    "there are two points which make the complexity of the brute force algorithm given in section [ secbrute ] that high :    1 .   the size of the position lattice , which is exponential with the length of the pattern , 2 .   determining the fastest strategy in the position lattice , which needs a time exponential with its size .",
    "our heuristic is based on two independent stages , each one aiming to overcome one of these two points .",
    "both of them start from the general idea that , since , for any current position of the text , the probability that no mismatch occurs until the @xmath209 text access decreases geometrically with @xmath19 , the first relative positions accessed by a strategy ( or more generally by a pattern algorithm ) are those which have the greatest influence on its asymptotic speed .",
    "a sufficient condition for a sublattice @xmath210}}$ ] to contain a @xmath0-strategy is that , for all @xmath211 , there exists at least a position @xmath149 with @xmath148}_{{s}}}(i , x)\\in{{\\mathcal{u}}}$ ] for all @xmath34 .",
    "a sublattice @xmath212 verifying this condition will be said to be @xmath213 .",
    "figure [ figsublattice ] displays four complete sublattices extracted from the position lattice of @xmath46 ( figure [ figlattice ] ) .",
    "let us introduce some additional notations here .",
    "for all sets @xmath4 of positions , the _ prefix _ of @xmath4 is defined as @xmath214 and its _ rest _ is @xmath215    for all positive integers @xmath19 , the @xmath19-sets sublattice of @xmath0 is the sublattice @xmath212 of @xmath142}}$ ] which contains all and only the subsets of @xmath142}}$ ] with a rest containing less than @xmath19 positions , i.e. the subsets of the form @xmath216 with @xmath217 and @xmath218 .    by construction , the @xmath19-sets sublattice of @xmath0 is complete .",
    "it contains @xmath219 states and @xmath220 transitions .",
    "we adapted algorithm [ algolatt ] to compute the @xmath19-sets sublattice of @xmath0 in @xmath220 time with the same amount of memory space .",
    "we are now interested in a fast way for finding an efficient @xmath0-strategy in a given complete sublattice .    for all integers @xmath189 and all states @xmath129 of a sublattice @xmath212 ,",
    "the @xmath189-shift expectation of @xmath129 is defined as the greatest shift expectation one could possibly get in @xmath189 steps in @xmath212 by starting from @xmath129 , conditioned on starting from @xmath129 , while parsing a text following an iid model @xmath83 .",
    "namely , the @xmath189-shift expectation is computed following the recursive formula :    * @xmath221}[{s } ] } = 0 $ ] , * for all @xmath222 , @xmath223}[{s } ] } = \\max_{i\\in{\\mathrm{tr}({s})}}\\sum_{x\\in{\\mathcal{a}}}{\\pi}(x)\\left({\\gamma^{[w]}_{{s}}}(i , x)+{\\mathrm{es}_{\\ell-1}^{[w]}[{\\delta^{[w]}_{{s}}}(i , x)]}\\right)\\ ] ]    where @xmath224}_{{s}}}(i , x)\\in{{\\mathcal{u}}}\\mbox { for all } x\\in{\\mathcal{a}}\\}$ ] .    the @xmath189-shift expectation of a complete sublattice @xmath212 is well defined and can be computed in @xmath225 time , where @xmath226 is the number of transitions of the sublattice @xmath212 and by using @xmath227 memory space .",
    "we finally extract a @xmath0-strategy from @xmath212 by setting the next - position - to - check of all states @xmath211 to    _ i(s)_x(^[w]_s(i , x)+_-1^[w][^[w]_s(i , x ) ] ) .",
    "the @xmath3-heuristic combines the two approaches above in order to compute a @xmath0-strategy in a time polynomial with the length of the pattern .",
    "being given an order @xmath228 , we start by computing the @xmath3-sets sublattice of @xmath0 , thus in @xmath229 time . in order to select a @xmath0-strategy from the @xmath3-sets sublattice , we next compute the @xmath230-shift expectation of all its states and extract a @xmath0-strategy as described just above .",
    "this computation is performed in @xmath231 time , since the number of transition of the sublattice is @xmath229 , by using @xmath232 memory space .",
    "let us remark that the order @xmath189 of the @xmath189-shift expectation does not have , _ a priori _ , to be strongly related to the order @xmath3 of the @xmath3-sets sublattice on which it is computed . by experimenting various situations",
    ", we observed that considering an order greater than @xmath233 generally does not improve much the performances , whereas the strategies obtained from @xmath189-expectations with @xmath189 smaller than @xmath3 may be significantly slower .",
    "the @xmath3-heuristic returns a @xmath0-strategy in @xmath231 time by using @xmath232 memory space .",
    "we insist on the fact that the @xmath3-heuristic generally does not return the fastest strategy , even if @xmath234 .",
    "however , we will see in the next section that it performs quite well in practice .",
    "we shall compare the approaches introduced in sections [ secbrute ] and [ secheuristic ] with selected pattern matching algorithms .",
    "the comparison is performed , first , from a theoretical point of view , by computing their asymptotic speeds under iid models , and second , in practical situations , by measuring their average speed over real data .",
    "the _ average speed _ with regard to a pattern @xmath0 , of an algorithm or a matching machine on a text @xmath1 is the ratio of @xmath235 to the number of text accesses performed by the algorithm to search @xmath0 in @xmath1 .",
    "we are also interested in to what extent taking into account the frequencies of the letters of an iid model or a text , for determining the fastest and the @xmath3-heuristic strategies , actually improves their asymptotic or their average speeds . to this purpose",
    ", we compute the fastest and the @xmath3-heuristic strategies from the uniform iid model .",
    "next , we test their efficiency in terms of asymptotic speed under a non - uniform iid model and in terms of average speeds on data with non - uniform frequencies of letters .      more than forty years of research have already led to the development of dozens algorithms .",
    "we selected the @xmath236 ones below for our evaluation :    1 .",
    "naive @xcite , 2 .",
    "morris - pratt @xcite , 3 .",
    "knuth - morris - pratt @xcite , 4 .",
    "quicksearch @xcite , 5 .",
    "boyer - moore - horspool @xcite , 6 .",
    "tvsbs @xcite , a``right - to - left '' algorithm in which shifts are given by a bad - character rule @xcite taking into account the two letters at distances @xmath44 and @xmath237 from the current position of the text , 7 .",
    "ebom @xcite , a version of the backward oracle matching algorithm @xcite which also uses a `` bad two - characters '' rule , 8 .",
    "hashq @xcite , which implements the boyer - moore algorithm on blocks of length @xmath68 by using efficient hashing techniques @xcite ( our tests are performed with @xmath238 ) , 9 .",
    "fjs @xcite , which combines the ideas of knuth - morris - pratt @xcite and sunday @xcite algorithms .",
    "algorithms 1 to 5 are classics .",
    "the last four ones were chosen for being known to be efficient on short patterns and small alphabets @xcite , a situation in which the determination of the fastest strategy is feasible .",
    "let us remark that the order of the @xmath0-matching machine associated to tvsbs is equal to @xmath237 , thus greater than that of the fastest strategy that we compute .",
    "the transformation into matching machines was implemented for a few other pattern matching approaches , for instance the sa algorithm ( the baeza - yates - gonnet algorithm ) based on bitwise operations @xcite , or the string - matching automaton @xcite .",
    "since the asymptotic and average speeds of these two algorithms are exactly @xmath96 , whatever the pattern , the model and the text , there is no point in displaying them .",
    "we shall evaluate :    * the pre - existing pattern matching algorithms presented in section [ secalgostd ] , * the @xmath96- @xmath87- and @xmath239-heuristics and * the fastest strategy ( each time it is possible ) .",
    "the asymptotic speeds are computed for texts and patterns on the binary alphabet @xmath240 .",
    "table [ tabtheo5 ] displays the asymptotic speeds for all the patterns of length @xmath2 on iid texts drawn from the uniform distribution .",
    "as expected , the strategy computed with the brute force algorithm ( last column ) is actually the fastest , but the speeds of the @xmath96-,@xmath87- and @xmath239-heuristics are very close .",
    "the pre - existing algorithms are outperformed by all our approaches ( even by the @xmath96-heuristic ) for all the patterns .",
    "we observe that the naive , morris - pratt and knuth - morris - pratt algorithms have asymptotic speeds always smaller than @xmath96 .",
    "one can not expect them to be faster since , by construction , they access all the positions of a text at least once . in the following",
    ", we will not display their speeds , nor that of quicksearch , for they are always smaller than at least one of the other pre - existing algorithms . the full tables can easily be re - computed by using our software .",
    "table [ tabtheo1 ] displays the asymptotic speeds with regard to the same patterns as table [ tabtheo5 ] , but under the iid model @xmath241 .",
    "this table shows the asymptotic speeds of the @xmath3-heuristics and the fastest strategies computed with regard to an uniform iid model ( the columns starting with `` unif . '' ) .",
    "the strategies such obtained are not optimized according to the letter probabilities of the model .",
    "they may be used as general purpose approaches , while the strategies obtained from the model probabilities will be called _ adapted _ below .",
    "overall , our methods are faster than the pre - existing algorithms , with a few exceptions : horspool is faster than the @xmath96-heuristic for two patterns ending with the rare letter @xmath242 : @xmath243 and @xmath244 . and ebom is faster than the @xmath96-heuristic for searching @xmath245 . the @xmath3-heuristics and",
    "the fastest strategies computed with regard to an uniform iid model have asymptotic speeds smaller than their counterparts obtained from the actual probabilities of the text model ( here highly unbalanced ) .",
    "nevertheless , the uniform approaches still perform quite well , notably better than the pre - existing algorithms , except for the uniform @xmath96-heuristic and the same patterns as above .    considering longer patterns",
    "leads to similar observations .",
    "table [ tabtheo10 ] shows the asymptotic speeds obtained for random patterns of length @xmath246 .",
    "the @xmath239-heuristic outperforms all the others approaches ( the fastest strategy can not be computed for this length ) .",
    "the ( uniform ) @xmath96-heuristic is slower than algorithms such ebom or hashq .",
    "but both the uniform @xmath87- and @xmath239-heuristic overall perform better than the pre - existing algorithms , though they are slightly slower for a few patterns .",
    "our data benchmark consists in the _ wigglesworthia glossinidia _ genome , known for its bias in nucleotide composition ( @xmath247 of @xmath248 ) , and the bible in english from @xcite .",
    "table [ tabpracti4 ] displays the average speeds of patterns randomly picked from the data .",
    "let us remark that we are now dealing with real texts , which are not iid .",
    "in particular , the fastest strategy could possibly be outperformed ( this is not observed on the benchmark data ) .",
    "the @xmath87- and @xmath239-heuristics , uniform and adapted , are faster than the pre - existing algorithms for all the patterns , whereas the @xmath96-heuristic is sometimes slightly outperformed by horspool .",
    "horspool is almost as fast as our approaches on the bible while being sometimes significantly outperformed on the _ wigglesworthia glossinidia _ genome .",
    "the average speeds are overall greater on the bible than on the dna sequence . in both cases",
    ", we do not observe a wide performance gap between the uniform and the adapted approaches , though our benchmark data are far from following an uniform iid model .",
    "let us remark that the @xmath87- and @xmath239-heuristics have almost the same performances both in the uniform and the adapted cases .",
    "table [ tabpracti30 ] shows the averages speeds with regard to patterns of length @xmath249 .",
    "the average speeds on the bible are about twice those on the _ wigglesworthia glossinidia _ genome .",
    "one actually expects the speed to be greater in average on texts with large alphabets , since the less likely the match between two symbols , the greater the shift expectation per iteration . again",
    "the @xmath239-heuristic , uniform or adapted , outperforms the pre - existing algorithms .",
    "the speeds of the @xmath239-heuristic and of the @xmath87-heuristic differ in a greater amount than with patterns of length @xmath2 for the _ wigglesworthia glossinidia _ genome , and , to a smaller extent , for the bible .",
    "in practical situations and though they do not take into account the letter frequencies , the uniform @xmath3-heuristics and the uniform fastest strategy perform generally almost as well as their adapted counterparts .",
    "the greatest difference observed is for the patterns of length @xmath249 on the _ wigglesworthia glossinidia _",
    "genome ( table [ tabpracti30 ] ) and is relatively small .",
    "we do observe a notable amount of difference for the quite extreme case of the asymptotic speed under the iid model @xmath241 .",
    "but even for these frequencies , the uniform approaches show greater asymptotic speeds than any of the selected pre - existing algorithms .",
    "the @xmath239-heuristic has very good results whatever the pattern or the text .",
    "there is no situation for which the performances of the @xmath87-heuristic are far from the best . on the contrary",
    ", the performance ranking of the pre - existing algorithms depends heavily on the patterns and on the texts or the model .",
    "for instance , horspool may perform very well , even almost optimally , for some patterns and texts or models while its speed may completely plummet in other situations .",
    "the question of selecting the most efficient order of @xmath3-heuristic still deserves further investigations .",
    "a basic answer could be `` the greater , the better '' but we should take into consideration that an higher order of heuristic comes with an increased computational cost .",
    "after some experiments , we observed that the asymptotic speed the @xmath3-heuristic tends to stop improving beyond a certain rank .",
    "for instance , the difference in average speed between the @xmath87- and @xmath239-heuristics for patterns of length @xmath2 , both on the genome and on the bible , probably does not justify the computational cost of the @xmath239-heuristic , while it is worth to use the @xmath239-heuristic rather than the @xmath87-heuristic for searching patterns of length @xmath249 in the bible ( not that much for the _ wigglesworthia glossinidia _ genome ) .",
    "the best trade - off for the order of the @xmath3-heuristic depends on the pattern ( notably its length ) and on the text features ( in particular the alphabet size and the letter frequencies ) .",
    "it is certainly possible to obtain efficient heuristic with a lower computational cost than for the @xmath3-heuristic . since in standard situation ,",
    "the length of the text is much greater than that of the pattern , there is no real reason for considering only pattern matching algorithms with linear pre - processings of the pattern . in the extreme case where the texts are arbitrarily long with regard to the patterns ,",
    "any pre - processing , i.e. whatever its computation time , would be beneficial as soon as it improves the overall speed .",
    "gilles didier provided the initial idea , led the software development and wrote all the manuscript but the section _",
    "evaluation_. laurent tichit collaborated on the software development , ran the tests and wrote the section _",
    "evaluation_. both authors read , edited and approved the final manuscript .                                        t.  marschall and s.  rahmann .",
    "robabilistic arithmetic automata and their application to pattern matching statistics . in p.",
    "ferragina and g.  m. landau , editors , _ combinatorial pattern matching _ , volume 5029 of _ lecture notes in computer science _ , pages 95106 .",
    "springer berlin heidelberg , 2008 .",
    "t.  marschall and s.  rahmann .",
    "xact analysis of horspool s and sunday s pattern matching algorithms with probabilistic arithmetic automata . in a .-",
    "dediu , h.  fernau , and c.  martn - vide , editors , _ language and automata theory and applications _ ,",
    "volume 6031 of _ lecture notes in computer science _ , pages 439450 .",
    "springer berlin heidelberg , 2010 .",
    "m.  rgnier and w.  szpankowski .",
    "omplexity of sequential pattern matching algorithms . in m.",
    "luby , j.  d. rolim , and m.  serna , editors , _ randomization and approximation techniques in computer science _ ,",
    "volume 1518 of _ lecture notes in computer science _ ,",
    "pages 187199 .",
    "springer berlin heidelberg , 1998 ."
  ],
  "abstract_text": [
    "<S> given a pattern @xmath0 and a text @xmath1 , the speed of a pattern matching algorithm over @xmath1 with regard to @xmath0 , is the ratio of the length of @xmath1 to the number of text accesses performed to search @xmath0 into @xmath1 . </S>",
    "<S> we first propose a general method for computing the limit of the expected speed of pattern matching algorithms , with regard to @xmath0 , over iid texts . </S>",
    "<S> next , we show how to determine the greatest speed which can be achieved among a large class of algorithms , altogether with an algorithm running this speed . </S>",
    "<S> since the complexity of this determination makes it impossible to deal with patterns of length greater than 4 , we propose a polynomial heuristic . finally , </S>",
    "<S> our approaches are compared with 9 pre - existing pattern matching algorithms from both a theoretical and a practical point of view , i.e. both in terms of limit expected speed on iid texts , and in terms of observed average speed on real data . in all cases , the pre - existing algorithms are outperformed . </S>"
  ]
}