{
  "article_text": [
    "automorphic forms and their hecke eigenvalues are of tremendous importance in number theory . these eigenvalues carry a lot of interesting arithmetic information , such as the number of points on elliptic curves or traces of frobenius in galois representations .",
    "one of the most successful methods for computing automorphic forms for  @xmath0 over number fields uses the jacquet - langlands correspondence .",
    "this result transfers the problem to a quaternion algebra , in which it is often easier to solve .",
    "this approach has its roots in the theory of brandt matrices and has been successfully used by dembl - donnelly and greenberg - voight  @xcite to compute hecke eigenvalues of hilbert modular forms . in both methods , a crucial step is to test whether an ideal is principal and to produce a generator in this case : this is the _ principal ideal problem _ that we are considering in this paper .",
    "the principal ideal problem naturally splits into two cases : definite and indefinite algebras . in the definite case , dembl and",
    "donnelly described an algorithm and kirschmer and voight proved that this algorithm runs in polynomial time when the base field is _ fixed _ , so we focus on the remaining indefinite case . in that case , testing whether an ideal is principal reduces to the same problem over the base field by eichler s theorem ( theorem  [ thmeichlerclass ] ) , but finding a generator is difficult .",
    "kirschmer and voight  @xcite provide an algorithm that improves on naive enumeration , without analysing its complexity .    in this paper , we present a probabilistic algorithm using a factor base and an auxiliary data structure to solve the principal ideal problem .",
    "our algorithm is inspired by buchmann s algorithm  @xcite for computing the class group of a number field .",
    "however , it is not easy to adapt this technique to quaternion algebras .",
    "indeed , the set of right ideals of an order does not form a group under multiplication . in fact , for most pairs of ideals , multiplication is not well - defined .",
    "we are able to salvage the factor base technique in the case of indefinite quaternion algebras by algorithmically realizing the strong approximation property ( theorem  [ thmstrongapprox ] ) .",
    "the main point is that if every ideal were two - sided , buchmann s method would work unchanged .",
    "our algorithm is divided in two parts . because the algebra is indefinite",
    ", every ideal is equivalent to an `` almost two - sided '' ideal : a local algorithm ( algorithm  [ preduce ] ) makes this equivalence effective .",
    "the global algorithm ( algorithm  [ greduce ] ) uses a factor base : by linear algebra it cancels out the valuations of the _ norm _ of the ideal and then corrects the ideal locally at every prime to make it two - sided .",
    "we implemented our algorithm as in magma .",
    "it performs well in practice , compared to the built - in magma function implementing kirschmer and voight s algorithm .",
    "the paper is organized as follows .",
    "we first recall basic properties of quaternion algebras , eichler s theorems and bruhat - tits trees in section  [ secrappels ] .",
    "we then proceed to algorithms in section  [ secalgos ] . in section  [ secred",
    "] , we define local and global reduction structures and algorithm  [ isprincipal ] , solving the principal ideal problem . in section  [ secstruct ] ,",
    "algorithm  [ gbuild ] constructs the needed local and global reduction structures : the first one uses units constructed from commutative suborders , and the second one is inspired by buchmann s algorithm . in section  [ seccr ] , we introduce a compact representation for quaternions to prevent coefficient explosion in the previous algorithms .",
    "section  [ seccomplexity ] provides a complexity analysis of our algorithms : assuming suitable heuristics , we prove a subexponential running time .",
    "section  [ secex ] presents examples .",
    "when  @xmath1 is a group and  @xmath2 is a subset , we write  @xmath3 for the subgroup generated by  @xmath4 .",
    "when the group  @xmath1 acts on a set  @xmath5 , we say that  @xmath4 acts transitively on  @xmath5 if  @xmath3 does .",
    "good references for this section and the next one are  @xcite ,  @xcite and  @xcite .",
    "let  @xmath6 be a number field with ring of integers  @xmath7 and discriminant  @xmath8 .",
    "we write  @xmath9 for the norm .",
    "let  @xmath10 be a prime of  @xmath7 .",
    "we write  @xmath11 for the  @xmath10-adic completion of  @xmath6 , we let @xmath12 be the @xmath10-adic valuation and we write  @xmath13 for the residue field  @xmath14 . when  @xmath4 is a set of primes of  @xmath7 , we write  @xmath15 the ring of  @xmath4-integers in  @xmath6 .",
    "let  @xmath16 be a quaternion algebra over  @xmath6 with reduced norm  @xmath17 .",
    "let  @xmath18 be a place of  @xmath6 . the place  @xmath18 is _ split _ or  _ ramified _ according to whether  @xmath19 or not .",
    "the _ reduced discriminant  @xmath20 _ of  @xmath16 is the product of the ramified primes and its _ absolute discriminant _ is the integer  @xmath21 .",
    "let  @xmath22 be a maximal order in  @xmath16 .",
    "we write  @xmath23 for the group  @xmath24 . a _ lattice _  @xmath25 is a finitely generated  @xmath7-submodule such that  @xmath26 .",
    "right order _",
    "@xmath27 of  @xmath28 is the set  @xmath29 and the _ left order  @xmath30 _ is defined analogously .",
    "right @xmath22-ideal _ is a lattice  @xmath28 such that  @xmath31 .",
    "the ideal  @xmath28 is _ integral _ if  @xmath32 and  @xmath28 is _ two - sided _",
    "if  @xmath33 .",
    "the inverse  @xmath34 of  @xmath28 is  @xmath35 .",
    "if  @xmath36 are lattices such that  @xmath37 , we define their product  @xmath38 to be the lattice generated by the set  @xmath39 . if  @xmath28 is an  @xmath22-ideal we have  @xmath40 and  @xmath41 .",
    "the _ reduced norm  @xmath42 _ of an @xmath22-ideal  @xmath28 is the  @xmath7-module generated by the reduced norms of elements in  @xmath28 .",
    "the reduced norm of ideals is multiplicative . for a right  @xmath22-ideal  @xmath28",
    "we define  @xmath43 and for an element  @xmath44 we set  @xmath45 .",
    "let  @xmath10 be a prime of  @xmath7 .",
    "there exists a unique two - sided  @xmath22-ideal  @xmath46 such that every two - sided @xmath22-ideal having reduced norm a power of  @xmath10 is a power of  @xmath46 .",
    "we have  @xmath47 if  @xmath10 splits in  @xmath16 and  @xmath48 if  @xmath10 ramifies in  @xmath16 : such an ideal  @xmath46 is called a prime of  @xmath22 , and every two - sided @xmath22-ideal is a product of primes of  @xmath22 .",
    "the set of right  @xmath22-ideals is equipped with an action of the group of two - sided  @xmath22-ideals by multiplication on the right and an action of the group  @xmath49 by multiplication on the left .",
    "two right  @xmath22-ideals  @xmath36 are _ equivalent _ if there exists  @xmath44 such that  @xmath50 , that is if they lie in the same orbit modulo  @xmath49 .",
    "the set of equivalence classes of right  @xmath22-ideals is written  @xmath51 .",
    "an ideal is  _ principal _ if it is equivalent to the unit ideal  @xmath22 .",
    "if  @xmath4 is a set of primes of  @xmath7 , the  _ @xmath4-order _ associated with  @xmath22 is the ring  @xmath52 and the group of  _ @xmath4-units _ ( relative to  @xmath22 ) in  @xmath16 is  @xmath53 .",
    "a quaternion algebra  @xmath16 satisfies the _ eichler condition _ or is  _ indefinite _ if there exists an infinite place of the base field  @xmath6 at which  @xmath16 is split .",
    "indefinite algebras satisfy the following properties .",
    "[ thmstrongapprox ] let  @xmath22 be a maximal order in a quaternion algebra  @xmath16 over a number field  @xmath6 , satisfying the eichler condition .",
    "let  @xmath10 be a prime of  @xmath7 that splits in  @xmath16 and  @xmath54 a positive integer .",
    "then the map @xmath55 is surjective .",
    "[ thmeichlernorm ] let  @xmath22 be a maximal order in a quaternion algebra  @xmath16 over a number field  @xmath6 satisfying the eichler condition .",
    "let  @xmath4 be a finite set of primes of  @xmath7 .",
    "let  @xmath56 be the set of  @xmath4-units that are positive at every real place of  @xmath6 that ramifies in  @xmath16 .",
    "then the reduced norm @xmath57 is surjective .",
    "[ thmeichlerclass ] let  @xmath22 be a maximal order in a quaternion algebra  @xmath16 over a number field  @xmath6 satisfying the eichler condition .",
    "let  @xmath58 be the ray class group with modulus the product of the real places of  @xmath6 that ramify in  @xmath16 .",
    "then the reduced norm induces a bijection @xmath59    in other words , two right  @xmath22-ideals are equivalent if and only if the classes of their norm in  @xmath58 are equal . note",
    "that since  @xmath51 is not a group , this map is only a bijection of _",
    "sets_.      the standard reference for this section is  @xcite .",
    "let  @xmath6 be a field with a discrete valuation  @xmath18 .",
    "let  @xmath60 be its valuation ring ,  @xmath61 a uniformizer and  @xmath62 the residue field . an _",
    "@xmath60-lattice in  @xmath63 _ is an  @xmath60-submodule of rank  @xmath64 in  @xmath63 .",
    "we define the _ bruhat - tits tree  @xmath65 _ , which we write  @xmath66 when  @xmath6 is the @xmath10-adic completion of a number field .",
    "the set of vertices of  @xmath65 is the set of homothety classes of @xmath60-lattices in  @xmath63 .",
    "let  @xmath67 be two such @xmath60-lattices .",
    "there exists an ordered  @xmath60-basis  @xmath68 of  @xmath69 and integers  @xmath70 such that  @xmath71 is an @xmath60-basis of  @xmath72 .",
    "the integer  @xmath73 depends only on the homothety classes of  @xmath67 and is called their _ distance_. by definition , there is an edge in the tree  @xmath65 between every pair of vertices at distance  @xmath74 .",
    "the graph  @xmath65 is an infinite tree .",
    "if  @xmath75 are two vertices , the unique path of minimum length between  @xmath76 and  @xmath77 is called the _ segment _  @xmath78 and the distance  @xmath79 equals the length of the segment  @xmath78 .",
    "the set of vertices at distance  @xmath74 from a given vertex is in natural bijection with  @xmath80 .",
    "the group  @xmath81 acts on the tree and preserves the distance , and this action factors through  @xmath82 and is transitive on the set of vertices .",
    "the stabilizer of the vertex  @xmath83 corresponding to the @xmath60-lattice  @xmath84 is  @xmath85 and the stabilizer of any vertex is a conjugate of this group .",
    "the group  @xmath86 acts transitively on the set of vertices at a fixed distance from  @xmath83 . for every  @xmath87",
    ", the smith normal form shows that  @xmath88 .",
    "the tree is illustrated in figure  [ figtree ] where we label some vertices  @xmath76 with a matrix  @xmath89 such that  @xmath90 .",
    "( -0.3,-0.2 ) node[draw = none , scale=0.9 ] @xmath91 ; ( -0.3,-0.8 ) node[draw = none , scale=0.9 ] @xmath92 ; ( -0.6,-1.22 ) node[draw = none , scale=0.9 ] @xmath93 ; ( 0.11,-1.53 ) node[draw = none , scale=0.9 ] @xmath94 ; ( 0.11,-1.93 ) node[draw = none , scale=0.9 ] @xmath95 ; ( 0.8,-1.22 ) node[draw = none , scale=0.9 ] @xmath96 ;    ( -0.5,0.6 ) node[draw = none , scale=0.9 ] @xmath97 ; ( -0.68,1.1 ) node[draw = none , scale=0.9 ] @xmath98 ; ( -1.28,0.1 ) node[draw = none , scale=0.9 ] @xmath99 ;    ( 0.55,0.6 ) node[draw = none , scale=0.9 ] @xmath100 ; ( 1.28,0.1 ) node[draw = none , scale=0.9 ] @xmath101 ; ( 0.7,1.1 ) node[draw = none , scale=0.9 ] @xmath102 ; node[solid ] child[solid ] foreach in 1,2,3 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 ;    [ thmbtt ] let  @xmath75 be two vertices of the tree  @xmath65 with  @xmath103 .",
    "then the action of the group  @xmath104 on the vertices of  @xmath65 has exactly two orbits  @xmath105 and  @xmath106 .",
    "the connection between the bruhat - tits tree and ideals is the following : a right @xmath107-ideal is always principal , generated by an element of",
    "such an ideal is two - sided if and only if it is generated by an element of  @xmath85 .",
    "so there is a  @xmath81-equivariant bijection between set of the vertices of the bruhat - tits tree and the quotient of the set of right  @xmath107-ideals modulo the action of the group of two - sided @xmath107-ideals .",
    "we want to adapt the classical subexponential algorithms for computing the class group of a number field due to hafner and mccurley  @xcite in the quadratic case and buchmann  @xcite in the general case to indefinite quaternion algebras by using a factor base : a fixed finite set of primes of  @xmath7 . to simplify the notations , we set  @xmath108 .",
    "[ deffb ] the _ factor base _ for  @xmath16 is a finite set  @xmath109 of primes of  @xmath7 that generates the group  @xmath58 .",
    "we say that a fractional ideal  @xmath110 of  @xmath6 is  _ @xmath109-smooth _ or simply _ smooth _ if it is a product of the primes in  @xmath109 .",
    "let  @xmath28 be a right  @xmath22-ideal  @xmath28 .",
    "when  @xmath28 is integral , we say that  @xmath28 is _ smooth _ if its reduced norm is .",
    "when  @xmath28 is arbitrary , it is _ smooth _ if it can be written  @xmath111 with  @xmath110 a smooth fractional ideal of  @xmath6 and @xmath112 an integral smooth right @xmath22-ideal .",
    "equivalently , the ideal  @xmath28 is smooth if and only if  @xmath113 for all  @xmath114 .",
    "an element  @xmath115 is _ smooth _ if the ideal  @xmath116 is smooth , or equivalently if  @xmath117 with  @xmath118 .",
    "we equip  @xmath119 and  @xmath120 with the usual positive definite quadratic form  @xmath77 given by the sum of the squares of the absolute values of the coefficients , and we equip the hamiltonian quaternion algebra  @xmath121 with the positive definite quadratic form  @xmath122 . for each infinite place of  @xmath6 represented by a complex embedding  @xmath123",
    ", we fix an isomorphism  @xmath124 extending  @xmath123 , where  @xmath125 is one of  @xmath119 , @xmath120 or  @xmath121 .",
    "this defines a positive definite quadratic form  @xmath126 by setting  @xmath127\\cdot q(\\sigma'(x))$ ] for all  @xmath128 , giving covolume  @xmath129 to the lattice  @xmath22 .",
    "we represent a lattice in  @xmath16 by a @xmath7-pseudobasis ( see  @xcite ) . when  @xmath69 is a lattice in  @xmath16 , we can enumerate its elements by increasing value of  @xmath130 with the kannan  fincke  pohst algorithm  @xcite .",
    "we represent this enumeration with a routine  ` nextelement ` that outputs a new element of  @xmath69 every time we call  ` nextelement`(@xmath69 ) , ordering them by increasing value of  @xmath130 .      in this section",
    ", we describe the reduction structures and the corresponding reduction algorithms .",
    "we start with the local reduction , which is an effective version of the fact that every integral right  @xmath22-ideal of norm  @xmath131 is equivalent to the two - sided ideal  @xmath132 ( theorem  [ thmeichlerclass ] ) .",
    "we perform this reduction by making algorithmic the reduction theory of  @xmath133 on the bruhat - tits tree  @xmath66 ( section  [ secbtt ] ) .",
    "the point is that this reduction needs only a small number of units : this leads to the definition of the @xmath10-reduction structure .",
    "let  @xmath10 be a prime that splits in  @xmath16 , let  @xmath134 and let  @xmath83 be the fixed point of  @xmath135 in the bruhat - tits tree  @xmath66 .",
    "a _ @xmath10-reduction structure _ is given by the following data :    1 .",
    "the left order  @xmath136 of an integral right @xmath22-ideal of norm  @xmath10 , and the fixed point  @xmath137 of  @xmath138 in  @xmath66 ; 2 .   for each  @xmath139 and for each  @xmath140 at distance  @xmath74 from  @xmath141 , an element  @xmath142 such that  @xmath143 .",
    "such a structure exists by strong approximation ( theorem  [ thmstrongapprox ] ) .",
    "note that if  @xmath28 is an integral right  @xmath22-ideal of norm  @xmath10 such that  @xmath144 , we have  @xmath145 for some  @xmath44 , and  @xmath146 .",
    "we represent the points at distance  @xmath74 from  @xmath141 by elements of  @xmath147 and we compute the action on these points via explicit splitting maps  @xmath148 .",
    "this structure provides everything we need to perform reduction in the bruhat - tits tree .",
    "the following algorithm corresponds to the standard reduction procedure ( theorem  [ thmbtt ] ) , which is illustrated in figure  [ figred ] .",
    "the idea is to use successive `` rotations '' ( elements in  @xmath133 having a fixed point in the tree ) around the adjacent vertices  @xmath83 and @xmath137 to send an arbitrary vertex to one of the vertices  @xmath141 : every rotation around a vertex decreases the distance to the other one .    to realize this procedure , we need to perform the following subtask : given a right @xmath22-ideal  @xmath28 , find  @xmath149 such that  @xmath150 .",
    "a simple idea is to let  @xmath151 and to draw elements  @xmath152 uniformly at random until  @xmath153 . to obtain a deterministic algorithm",
    ", we can adapt euclid s algorithm in the matrix ring  @xmath154 with  @xmath155 .",
    "this is done in  @xcite , except that the base ring  @xmath156 is assumed to be a domain .",
    "we adapt the argument to our case .",
    "first note that we have a well - defined  @xmath10-adic valuation  @xmath157 in the ring  @xmath156 .",
    "let  @xmath158 .",
    "we have  @xmath159 whenever  @xmath160 , and  @xmath161 if and only if  @xmath162 .",
    "if  @xmath163 , there is a euclidean division taking the following simple form : if  @xmath161 then  @xmath164 , and otherwise  @xmath165 . in every case",
    "we have written  @xmath166 with  @xmath167 or  @xmath168 . adapting this in the matrix ring leads to the following euclidean division algorithm , where for convenience we write  @xmath169 .",
    "the idea is to work with  @xmath170 in smith normal form , and if  @xmath170 is a diagonal matrix , dividing by  @xmath170 is almost the same as dividing by the diagonal coefficients .",
    "the difference is that we have to ensure that  @xmath171 unless  @xmath172 .",
    "[ divmat ]    two matrices  @xmath173 with  @xmath174 , where  @xmath175 .",
    "two matrices  @xmath176 such that  @xmath177 , and  ( @xmath172 or  @xmath178 ) .",
    "let  @xmath179 be the smith form of  @xmath170 with  @xmath180 and  @xmath181 @xmath182 let  @xmath183 be the hermite form of  @xmath184 with  @xmath185 and  @xmath186 @xmath187 , @xmath188[stepcompletediv ] @xmath189 , @xmath190 @xmath191 , @xmath192 @xmath193 , @xmath194 @xmath195 , @xmath194 @xmath196 , @xmath197    subalgorithm  [ divmat ] is correct .",
    "by case - by - case analysis , we have  @xmath198 , and either  @xmath172 ( step  [ stepcompletediv ] ) or  @xmath171 and  @xmath199 . let  @xmath200 and  @xmath201 be the matrices returned by the algorithm .",
    "we have  @xmath202 .",
    "since  @xmath203 and  @xmath204 have determinant  @xmath74 , we have  @xmath172 if and only if  @xmath205 , and  @xmath206 , proving the correctness of the algorithm .",
    "[ gcdmat ]    two matrices  @xmath173 with  @xmath174 , where  @xmath175 .",
    "a matrix  @xmath207 such that  @xmath208 .",
    "@xmath209 ` dividematrix`(@xmath170 , @xmath210 ) @xmath170 ` gcdmatrix`(@xmath60 , @xmath170)[steprec ]    subalgorithm  [ gcdmat ] is correct .    in step  [ steprec ]",
    "we have  @xmath171 by the properties of subalgorithm  [ divmat ] , so the recursive call to  ` gcdmatrix ` is valid .",
    "the rest of the proof is the same as with the usual euclidean algorithm .",
    "[ locgene ]    an integral right  @xmath22-ideal  @xmath28 and a prime  @xmath10 , for some maximal order  @xmath22 .",
    "an element  @xmath149 such that  @xmath145 .",
    "@xmath211 an @xmath212-reduced  @xmath213-basis of  @xmath28",
    "@xmath214 @xmath215 @xmath216 images of  @xmath217 in  @xmath154 @xmath218[stepinit ] @xmath219 ` gcdmatrix`(@xmath207 , @xmath220 ) let  @xmath221 be such that  @xmath222[stepsolve ] @xmath223    subalgorithm  [ locgene ] is correct .    by definition of the norm of an ideal ,",
    "we have  @xmath224 .",
    "because of the choice of  @xmath156 , at step  [ stepinit ] we have  @xmath225 , so the calls to ` gcdmatrix ` are valid . by the properties of subalgorithm  [ gcdmat ] , at step  [ stepsolve ] we have  @xmath226 so the integers  @xmath227 exist",
    ". now let  @xmath228 be the output of the algorithm , so that  @xmath229 , hence  @xmath230 .",
    "let  @xmath231 . by reduction modulo",
    "@xmath232 there exists  @xmath233 and  @xmath234 such that  @xmath235 , proving the result .",
    "now we can present the local reduction algorithm .",
    "[ preduce ]    an integral right @xmath22-ideal @xmath28 , a prime @xmath10 and a @xmath10-reduction structure .",
    "an integer  @xmath236 , an element  @xmath237 and an integral  @xmath22-ideal  @xmath112 such that  @xmath238 and  @xmath239 .",
    "@xmath240 largest integer such that  @xmath241 , @xmath242[stepts ] @xmath243 @xmath244 , @xmath245 @xmath246 ` localgenerator`(@xmath28 , @xmath10 ) @xmath247 @xmath248 point at distance  @xmath74 from  @xmath141 in the segment  @xmath249 @xmath250 where  @xmath142 is such that  @xmath251[stepmul ]  @xmath252  @xmath253 , @xmath254 , @xmath255  [ stepdivide ] @xmath256 @xmath257    in step  [ stepts ] , we have  @xmath258 where  @xmath259 is the two - sided @xmath22-ideal generated by  @xmath28 .",
    "we can compute  @xmath259 as follows : if  @xmath260 is a  @xmath213-basis of  @xmath22 and  @xmath217 is a  @xmath213-basis of  @xmath28 , then  @xmath261 .",
    "( 0,0 ) node[draw = none , above , minimum size=20pt]@xmath83 ; ( 0,-1 ) node[draw = none , below , minimum size=20pt]@xmath137 ; ( 180:2 ) node[draw = none]@xmath77 ; ( 210:1.15 ) node[draw = none]@xmath89 ; ( 165:1 ) arc ( 165:255:1 ) ; ( -67:2.15 ) node[draw = none]@xmath262 ; ( -1.9,-1.7 ) node[draw = none]@xmath263 ; ( -1.9,-1.95 ) node[draw = none]@xmath264 ; node[scale=1.7 ] child[dotted ] node[solid , scale=1.7 ] child[solid ] node child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child[dotted ] node[solid ] child[dotted ] node[solid ] child[solid ] node[solid ] child[densely dotted ] foreach in 1,2 child[dotted ] node[solid , scale=1.7 ] child[densely dotted ] foreach in 1,2 child[solid ] node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child node child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child[dashed ] node[solid ] child[solid ] node[solid ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child[dashed ] node[solid ] child[solid ] node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child[dashed ] node[solid ] child[densely dashed ] node[solid , scale=1.7 ] child[densely dotted ] foreach in 1,2 child[solid ] node child[densely dotted ] foreach in 1,2 ;    ( 0,0 ) node[draw = none , above , minimum size=20pt]@xmath83 ; ( 0,-1 ) node[draw = none , below , minimum size=20pt]@xmath137 ; ( -68:2.15 ) node[draw = none]@xmath77 ; ( 39:1.6 ) node[draw = none]@xmath262 ; ( -33:1 ) node[draw = none]@xmath89 ; ( 0.6,-1.2 ) arc ( -35:75:0.7 ) ; ( -1.9,-1.7 ) node[draw = none]@xmath263 ; ( -1.9,-1.95 ) node[draw = none]@xmath252 ; node[scale=1.7 ] child[dotted ] node[solid , scale=1.7 ] child[solid ] node[solid ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child[dashed ] node[solid ] child[dashed ] node[solid ] child[solid ] node[solid ] child[densely dotted ] foreach in 1,2 child[densely dashed ] node[solid , scale=1.7 ] child[densely dotted ] foreach in 1,2 child[solid ] node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child[dotted ] node[solid ] child[solid ] node child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child[dotted ] node[solid , scale=1.7 ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child node child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 ;    ( 0,0 )",
    "node[draw = none , above , minimum size=20pt]@xmath83 ; ( 0,-1 ) node[draw = none , below , minimum size=20pt]@xmath137 ; ( 39:1.6 ) node[draw = none]@xmath77 ; ( -115:1.35 ) node[draw = none]@xmath262 ; ( -75:1 ) arc ( -75:15:1 ) ; ( -30:1.15 ) node[draw = none]@xmath89 ; ( -1.9,-1.7 ) node[draw = none]@xmath265 ; ( -1.9,-1.95 ) node[draw = none]@xmath264 ; node[scale=1.7 ] child[dotted ] node[solid , scale=1.7 ] child[dotted ] node[solid , scale=1.7 ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child[solid ] node child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child[dashed ] node[solid ] child[solid ] node[solid ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child[dashed ] node[solid , scale=1.7 ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child node child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 ;    ( 0,0 ) node[draw = none , above , minimum size=20pt]@xmath83 ; ( 0,-1 ) node[draw = none , below , minimum size=20pt]@xmath137 ; ( -112:1.85 ) node[draw = none]@xmath77 ; ( 215:1 ) node[draw = none]@xmath89 ; ( -0.6,-1.2 ) arc ( 215:105:0.7 ) ; ( -1.9,-1.7 ) node[draw = none]@xmath265 ; ( -1.9,-1.95 ) node[draw = none]@xmath252 ; node[scale=1.7 ] child[dotted ] node[solid , scale=1.7 ] child[dashed ] node[solid , scale=1.7 ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child[solid ] node child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child node child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 child node child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[solid ] foreach in 1,2 node[solid ] child[densely dotted ] foreach in 1,2 ;    [ proppreduce ] subalgorithm  [ preduce ] is correct .",
    "since  @xmath54 decreases by  @xmath64 every two iterations and is positive by the loop condition , the algorithm terminates .",
    "we now prove that the output is correct .",
    "first , the distance  @xmath266 decreases by  @xmath74 during each execution of the loop : before step  [ stepmul ] , we have  @xmath267 since  @xmath76 is at distance  @xmath74 from  @xmath141 on the segment  @xmath249 .",
    "we claim that before or after a complete execution of the loop , we have  @xmath268 ( see figure  [ figred ] ) .",
    "the claim is true before the first iteration : we have  @xmath269 so  @xmath270 .",
    "we only need to prove that the equality  @xmath268 is preserved when  @xmath252 . in that case",
    ", @xmath137 is in the segment  @xmath271 because of the previous iteration , so that  @xmath272 .",
    "we now prove that before or after a complete execution of the loop , the @xmath22-ideal  @xmath112 is integral and  @xmath273 .",
    "this property clearly holds before the first iteration . before step  [ stepdivide ] , after two iterations  @xmath264 and  @xmath252 , @xmath112 and  @xmath77 have been multiplied by an element  @xmath274 such that  @xmath275 and  @xmath276 , so  @xmath277 is divisible by  @xmath10 .",
    "step  [ stepdivide ] hence preserves integrality and updates  @xmath54 according to the valuation of  @xmath278 .",
    "we now prove the proposition .",
    "the element  @xmath279 is a product of elements of  @xmath135 and  @xmath280 so  @xmath279 is a  @xmath10-unit with  @xmath281 .",
    "we have just proved that  @xmath112 is integral , and by step  [ stepdivide ] the value of  @xmath236 is such that  @xmath238 . because of the loop condition , after the algorithm terminates we have  @xmath282 .",
    "we now explain how to perform global reduction .",
    "we use linear algebra to control the valuations of a smooth ideal and then perform local reduction at every prime to get an `` almost two - sided ideal '' .",
    "the first step is similar to its commutative analogue : we need sufficiently many `` relations '' ( smooth elements in  @xmath49 ) so that the quotient of the factor base by the norms of the relations is the ray class group  @xmath58 .",
    "this leads to the definition of a g - reduction structure .",
    "[ defgred ] a _ g - reduction structure _ is given by the following data :    1 .   a  @xmath10-reduction structure for each  @xmath283 that splits in  @xmath16 ; 2 .   [ defgred2 ] a finite set of elements  @xmath284 and a map  @xmath285 that is a lift of an isomorphism  @xmath286 and such that  @xmath287 .",
    "the following algorithm performs global reduction . in order to avoid explosion of the size of the ideal in the local reduction ,",
    "we extract the two - sided part , allowing us to reduce all exponents modulo  @xmath64 .",
    "the remaining part stays small and gets @xmath10-reduced , while the two - sided part is only multiplied by powers of primes .",
    "[ greduce ]    a smooth integral right @xmath22-ideal  @xmath28 and a g - reduction structure .",
    "an integral ideal @xmath112 , an element  @xmath237 and a two - sided ideal @xmath259 such that  @xmath288 and  @xmath28 is principal if and only if  @xmath289 and  @xmath290 .",
    "@xmath291 @xmath292 where  @xmath110 is seen as an element of  @xmath58 let  @xmath293 be such that  @xmath294 where  @xmath295 .",
    "@xmath296 , @xmath297 @xmath298[stepgmul ] @xmath299 two - sided ideal generated by  @xmath112 @xmath300 [ stepgts ] @xmath301 [ stepgloop ] @xmath302 ` preduce`(@xmath303 ) @xmath304 , @xmath305 @xmath306    [ propgreduce ] subalgorithm  [ greduce ] is correct .    since step  [ stepgts ] and ` preduce ` preserve integrality ( proposition  [ proppreduce ] ) , the output  @xmath112 is integral .",
    "the relation  @xmath288 is clear by tracking the multiplications . if the output is such that  @xmath289 and  @xmath290 , then  @xmath307 is principal .",
    "conversely , if  @xmath28 is principal , then  @xmath308 is trivial in the class group  @xmath58 so  @xmath309 .",
    "after step  [ stepgmul ] , we have  @xmath310 . after step  [ stepgts ] , we have multiplied  @xmath112 by a two - sided ideal ,",
    "so  @xmath311 is even for all primes  @xmath10 splitting in  @xmath16 . since  @xmath112 is not divisible by a two - sided ideal , @xmath278 is not divisible by primes that ramify in  @xmath16 .",
    "we obtain  @xmath289 at the end of the loop by the properties of  ` preduce ` so  @xmath312 . since  @xmath259 is two - sided , it is entirely determined by its norm so  @xmath290 .",
    "finally , we reduce the general case to the smooth case by the noncommutative analogue of standard randomizing techniques . we generate a random smooth @xmath22-ideal by the following procedure , to which we refer as ` randomleftideal`(@xmath22 ) . for each  @xmath283 , pick a nonnegative integer  @xmath54 .",
    "let  @xmath313 be a splitting map .",
    "let  @xmath314 be a random upper - triangular matrix with zero determinant and compute  @xmath315 .",
    "finally , return  @xmath316 .",
    "choose the exponents  @xmath54 such that  @xmath317 .",
    "it not clear at the moment what the best distribution for the exponents is .",
    "a simpler idea would be to use random products  @xmath318 . in our experience",
    ", this leads to poorly randomized ideals .",
    "this is clear in the case  @xmath319 : the randomized ideals are simply integer multiples of  @xmath22 .",
    "[ isprincipal ]    an integral right @xmath22-ideal  @xmath28 and a g - reduction structure .",
    "an integral ideal @xmath112 , an element  @xmath237 and a two - sided ideal @xmath259 such that  @xmath320 and  @xmath28 is principal if and only if  @xmath289 and  @xmath290 . @xmath321 ` randomleftideal`(@xmath22 ) @xmath322 ` nextelement`(@xmath323 )  @xmath324 is not smooth   * fail *  [ stepsmooth ] @xmath325 ` greduce`(@xmath324 ) @xmath326    by proposition  [ propgreduce ] , if algorithm  [ isprincipal ] does not return fail , its output is correct . in practice , we repeat algorithm  [ isprincipal ] until it returns the result .",
    "now we explain how to build the previous reduction structures .",
    "the local reduction structure needs units in  @xmath22 . in general",
    "it is difficult to compute the whole unit group  @xmath327 : for instance in the fuchsian case , the minimal number of generators is at least  @xmath328 ( this follows from the theory of signatures of fuchsian groups  ( * ? ? ?",
    "* section 4.3 ) and a volume formula  ( * ? ? ? * theorem 11.1.1 ) ) , which makes it hopeless to find a subexponential method .",
    "however , we can find some units in  @xmath22 by considering commutative suborders and computing generators of their unit group with buchmann s algorithm .",
    "heuristically , these units are sufficiently random for our purpose . this strategy",
    "is implemented by the following algorithms .",
    "[ p1search ]    a maximal order  @xmath22 and a prime  @xmath10 .",
    "a set of elements  @xmath329 acting transitively on  @xmath147 .",
    "@xmath330 @xmath322 ` nextelement`(@xmath22)[stepnexteltp1s ] @xmath331 [ stepposrk ] @xmath332 [ stepunits ] @xmath333 a set of generators of @xmath334 @xmath5    in step  [ stepunits ] , we can compute the unit group  @xmath334 with the algorithms of klners and pauli  @xcite . note that we actually do not need the full group  @xmath334 : a subgroup of finite index is sufficient .",
    "[ propp1search ] subalgorithm  [ p1search ] is correct .    by strong approximation ( theorem  [ thmstrongapprox ] )",
    ", the group  @xmath327 acts transitively on  @xmath147 .",
    "this group is finitely generated , so after finitely many iterations we will have enumerated a set of generators and the algorithm will terminate . by the loop condition ,",
    "the output is correct .",
    "[ pbuild ]    a maximal order  @xmath22 and a prime  @xmath10 . a @xmath10-reduction structure . @xmath335 an integral right @xmath22-ideal of norm  @xmath10 @xmath336 @xmath337 ` p1search`(@xmath338 ) from  @xmath5 , for each  @xmath76 at distance  @xmath74 from  @xmath83 compute an element  @xmath339 such that  @xmath340 @xmath337 ` p1search`(@xmath341)[stepo1p1search ] from  @xmath5 , for each  @xmath76 at distance  @xmath74 from  @xmath137 compute an element  @xmath342 such that  @xmath343 the @xmath10-reduction structure    let  @xmath344 be such that  @xmath345 and let  @xmath346 .",
    "then  @xmath347 so  @xmath348 .",
    "this allows us to construct many elements in  @xmath280 before step  [ stepo1p1search ] .",
    "if we have sufficiently many such units , which often happens in practice , they will act transitively on the points  @xmath349 at distance  @xmath74 from  @xmath137 . in this case , in step  [ stepo1p1search ] we will only need to find one element  @xmath342 such that  @xmath350 .",
    "we build the global reduction structure in a way similar to the commutative case : we look for small relations in smooth ideals .",
    "in addition , we get a good starting point thanks to the inclusion  @xmath351 : the units  @xmath352 provide all the relations up to a  @xmath64-elementary abelian group .",
    "[ gbuild ]    a maximal order  @xmath22 and a factor base  @xmath109 . a g - reduction structure . `",
    "pbuild`(@xmath338)[steppbuild ] @xmath337 integral generators of  @xmath352[stepsunits ] @xmath335 integral @xmath22-ideal of norm  @xmath10[stepidnormp ] [ loop1 ] @xmath322 ` nextelement`(@xmath28)[stepnextgb1 ] @xmath353 [ loop2 ] @xmath322 ` nextelement`(@xmath22)[stepnextgb2 ]  @xmath354 is smooth  @xmath353   the g - reduction structure    the various calls to  ` pbuild ` in step  [ steppbuild ] are not completely independent : we can keep the elements in  @xmath327 from one call for other ones .",
    "[ propgbuild ] algorithm  [ gbuild ] is correct .",
    "let  @xmath28 be the ideal in step  [ stepidnormp ] .",
    "there exists a smooth ideal  @xmath112 equivalent to  @xmath28 , let  @xmath44 be such that  @xmath355 .",
    "then  @xmath356 , so  @xmath357 is smooth",
    ". it will be enumerated at some point , so the loop starting at step  [ loop1 ] terminates .",
    "since  @xmath109 generates the class group  @xmath58 , by eichler s theorem ( theorem  [ thmeichlerclass ] ) we have  @xmath358 , so there exists a finite set of  @xmath109-smooth elements  @xmath359 such that  @xmath360 .",
    "we will enumerate this set at some point , so the loop starting at step  [ loop2 ] terminates .",
    "so algorithm  [ gbuild ] terminates , and by proposition  [ propp1search ] and step  [ loop2 ] it returns a correct g - reduction structure .",
    "we have restricted to maximal orders to simplify the exposition , but this restriction can be weakened as follows .",
    "let  @xmath22 be an arbitrary order , and let  @xmath4 be the set of primes  @xmath10 of  @xmath7 such that  @xmath22 is not @xmath10-maximal .",
    "the set @xmath4 is finite , so we can choose a factor basis disjoint from  @xmath4 .",
    "then our algorithms work unchanged for right @xmath22-ideals except one point : theorem  [ thmeichlerclass ] characterizing principal ideals might no longer hold . if we restrict to eichler orders , that is intersections of two maximal orders , theorem  [ thmeichlerclass ] still holds .",
    "otherwise we need to find the suitable class group and change definition  [ defgred ] [ defgred2 ] accordingly .      in the previous algorithms ,",
    "the cost of elementary operations is important .",
    "representing units as linear combinations of a basis of  @xmath22 could be catastrophic : the classical example of real quadratic fields suggests that fundamental units in commutative orders , such as those produced by subalgorithm  [ p1search ] , can have exponential size .",
    "this problem is classically circumvented by representing units in _ compact form _ : a product of small  @xmath4-units with possibly large exponents .",
    "the problem is reduced to computing efficiently with those compact representations .",
    "a natural notion of compact representation in  @xmath22 would be to take ordered products of @xmath4-units in  @xmath22 but we do not know how to compute efficiently with such a general representation .",
    "instead we use a more restricted notion : we group the units belonging to a common commutative suborder , in which we can compute efficiently .",
    "this leads to the following definition .",
    "a _ compact representation _ in  @xmath22 is :    1 .",
    "an element  @xmath361 , or 2 .",
    "[ typetwo ] a product  @xmath362 where the exponents are signed integers , the elements  @xmath363 all lie in a single ring  @xmath364 containing  @xmath7 and such that  @xmath365 , together with a  @xmath213-basis of the integral closure of  @xmath156 and a factorization of its conductor , or 3 .   an ordered product of compact representations .    a product  @xmath366 as in  [ typetwo ]",
    "will be called a _ representation of type  [ typetwo]_.    we describe the algorithms for representations of type  [ typetwo ] , and they naturally extend by multiplicativity to arbitrary compact representations .",
    "we first explain the algorithm for local evaluation of compact representations .",
    "since the product represents a unit , we can replace it with a product of local units , avoiding loss of precision despite the large exponents .",
    "[ evalcr ]    a representation  @xmath367 of type  [ typetwo ] , an ideal  @xmath368 .",
    "an element  @xmath369 such that  @xmath370 .",
    "@xmath371 field of fractions of  @xmath156 @xmath372 conductor of  @xmath156 inside  @xmath373 @xmath374 factorization of  @xmath375 @xmath376 reduction map onto  @xmath377 @xmath378 uniformizer in  @xmath379 ,",
    "@xmath380 @xmath381 @xmath382 element in  @xmath373 such that  @xmath383 @xmath384    [ propevalcr ] subalgorithm  [ evalcr ] is correct .",
    "first , we claim that for all  @xmath385 , we have  @xmath386 .",
    "since  @xmath387 , we have  @xmath388 so  @xmath389 . since  @xmath390 is integral at  @xmath379 , we can apply  @xmath391 to it and the claim follows .",
    "this implies that the output  @xmath384 of the algorithm satisfies  @xmath392 .",
    "in particular , we have  @xmath393 so  @xmath394 . since  @xmath395 we get  @xmath396 .",
    "the relation  @xmath397 shows that  @xmath370 .",
    "we can now explain how to multiply an ideal by a compact representation . to know an ideal",
    ", it suffices to know it up to large enough precision : we reduce the problem to local evaluation .",
    "[ mulcr ]    a representation  @xmath367 of type  [ typetwo ] , an integral right  @xmath22-ideal  @xmath28 .",
    "the ideal  @xmath398 .",
    "@xmath291 @xmath382 ` evalcr`(@xmath399 ) @xmath400    [ propmulcr ] subalgorithm  [ mulcr ] is correct .    by proposition  [ propevalcr ] , we have  @xmath370 so  @xmath401 , which gives  @xmath402 .",
    "since  @xmath403 , we have  @xmath404 , so  @xmath405 and finally  @xmath406 . therefore the output of the algorithm is correct .",
    "we perform a complete complexity analysis of our algorithms , assuming suitable heuristics . to simplify the notations , we set  @xmath407 . in every complexity estimate ,",
    "the degree of the base field  @xmath6 is fixed .",
    "when we mention a complexity of the form  @xmath408 , we always implicitly mean  @xmath408 times a polynomial in the size of the input .",
    "we fix a parameter  @xmath409 .",
    "we will analyse our algorithm using the general paradigm that with a factor base of subexponential size , elements have a subexponential probability of being smooth . however , recall from definition  [ deffb ] that the factor base  @xmath109 is assumed to generate the ray class group  @xmath58 , so we need the following heuristic .",
    "[ heurfb ] there exists a constant  @xmath410 such that for every quaternion algebra  @xmath16 with absolute discriminant  @xmath411 , the set of primes having norm less than  @xmath412 generate the class group  @xmath58 .",
    "this heuristic is a theorem under the generalized riemann hypothesis  @xcite . by minkowski s bound ,",
    "heuristic  [ heurfb ] is also true unconditionnally with the restriction that  @xmath413 . from now on ,",
    "we assume heuristic  [ heurfb ] and we assume that the factor base  @xmath109 is the set of primes having norm less than  @xmath412 .",
    "note that this implies the bound  @xmath414 .",
    "we start by analysing the complexity of elementary operations : subalgorithm  [ locgene ] and the algorithms of section  [ seccr ] .",
    "[ lemcompllocgene ] subalgorithm  [ locgene ] terminates in time polynomial in the size of the input .",
    "subalgorithm  [ divmat ] ( ` dividematrix ` ) is made of a constant number of elementary operations , so it is polynomial . in subalgorithm  [ gcdmat ]",
    "( ` gcdmatrix ` ) with  @xmath415 , since the valuation of the determinant decreases at every recursive call , there are at most  @xmath416 such calls .",
    "when subalgorithm  [ locgene ] ( ` localgenerator ` ) calls subalgorithm  [ gcdmat ] , we have  @xmath417 by lattice reduction .",
    "so the algorithm is polynomial in the size of the input .",
    "[ lemcomplcr ] given the factorization of  @xmath110 , subalgorithm  [ evalcr ] terminates in time polynomial in the size of the input .",
    "given the factorization of  @xmath42 , subalgorithm  [ evalcr ] terminates in time polynomial in the size of the input .    in subalgorithm  [ evalcr ] ,",
    "the number of iterations of the loop is polynomial in the size of the input .",
    "the only operations that could possibly not be polynomial in the size of the input are the computation of  @xmath373 and the factorization of  @xmath418 , but  @xmath373 and the factorization of  @xmath419 are contained in the compact representation , and the factorization of  @xmath110 is assumed to be given .",
    "so the algorithm is polynomial in the size of its input . since the hnf of the output can be computed in polynomial time  @xcite , subalgorithm  [ evalcr ] is also polynomial .",
    "the restriction on the factorization is not a problem in our application : every ideal on which we call these algorithms is smooth .",
    "since our algorithms use their commutative counterparts , we have to make assumptions on the algorithms used to compute commutative unit groups .",
    "[ heurfastunits ] there is an explicit algorithm that , given a number field  @xmath420 with discriminant  @xmath421 , an order  @xmath156 in  @xmath420 and a bound  @xmath422 , computes a set  @xmath423 of integral generators for the  @xmath4-unit group of  @xmath424 , where  @xmath4 is the set of primes of norm less than  @xmath425 , and generators for the unit group  @xmath334 expressed as products of elements in  @xmath423 , in expected time  @xmath426 .",
    "this is a strong hypothesis .",
    "however , under the generalized riemann hypothesis it is a theorem for quadratic number fields  @xcite and experience has shown that it is not an unreasonable assumption , as well as with number fields of much larger degree .",
    "e.g. the class group and unit group of @xmath427/(t^{90}-t^2 - 1)$ ] , @xmath428 can be computed in a few hours ( karim belabas , personal communication ) . ] .    since the reduction algorithms depend on the structures that are given as input , we analyse the algorithms building the reduction structures before the reduction algorithms .",
    "we start with subalgorithm  [ p1search ] , for which we need some heuristic assumptions .",
    "[ heurunits ] in subalgorithm  [ p1search ] , we assume the following .",
    "a.   [ heurunits1 ] if  @xmath6 is totally real , a positive proportion of  @xmath354 satisfies the condition of step  [ stepposrk ] that  @xmath429 has positive relative unit rank .",
    "b.   [ heurunits2 ] the images in  @xmath430 of the units produced at step  [ stepunits ] are uniformly distributed in the image of  @xmath327 in  @xmath430 .",
    "[ propcomplp1search ] assuming heuristics  [ heurfastunits ] and  [ heurunits ] , the expected running time of subalgorithm  [ p1search ] is at most  @xmath408 .",
    "we first prove that the expected number of iterations of the loop is  @xmath431 .",
    "if @xmath6 is not totally real , the relative unit rank condition is always satisfied , so by heuristic  [ heurunits ]  ( [ heurunits1 ] ) a positive proportion of the iterations of the loop produce a unit . by strong approximation",
    ", the image of  @xmath327 in  @xmath430 contains  @xmath432 , and the index is at most  @xmath64 . by heuristic  [ heurunits ]  ( [ heurunits2 ] ) , with probability",
    "at least  @xmath433 the image of the unit produced at step  [ stepunits ] is in  @xmath432 , and the corresponding images are equidistributed in  @xmath432 . by  @xcite",
    ", the probability that two random elements of  @xmath432 generate this group is bounded below by a constant .",
    "therefore , after an expected number of iterations  @xmath431 , the image of  @xmath5 generates  @xmath432 and hence acts transitively on  @xmath147 .",
    "each computation of a unit group in step  [ stepunits ] takes expected time  @xmath408 by heuristic  [ heurfastunits ] since the discriminant of  @xmath434 $ ] is  @xmath435 .",
    "the units are stored in compact representation and we use subalgorithm  [ evalcr ] ( ` evalcr ` ) to compute the action on  @xmath147 , so by lemma  [ lemcomplcr ] this takes total time  @xmath408 .    [ heursmoothdist ] let  @xmath436 be the group of  @xmath109-units in  @xmath7 that are positive at every real place ramified in  @xmath16 . in algorithm  [ gbuild ] , we assume the following .",
    "a.   [ heursmoothdist1 ] there exists a constant  @xmath437 such that the elements  @xmath354 produced in steps  [ stepnextgb1 ] and  [ stepnextgb2 ] are smooth with probability at least  @xmath438 .",
    "b.   [ heursmoothdist2 ] the norms of the smooth elements produced in step  [ stepnextgb2 ] are equidistributed in  @xmath439 .    by comparison with the case of integers  (",
    "* equation ( 1.16 ) and section 1.3 ) , @xmath440 could be a reasonable value .",
    "[ thmcomplgbuild ] assume heuristics  [ heurfastunits ] ,  [ heurunits ] , [ heurfb ] and  [ heursmoothdist ] .",
    "then , given a maximal order  @xmath22 in an indefinite quaternion algebra  @xmath16 , algorithm  [ gbuild ] ( ` gbuild ` ) terminates in expected time  @xmath408 .    there are  @xmath441 calls to subalgorithm  [ p1search ] ( ` p1search ` ) . by proposition  [ propcomplp1search",
    "] , these calls take total time  @xmath408 .",
    "the computation of the group  @xmath352 takes time  @xmath442 by heuristic  [ heurfastunits ] . by heuristic  [ heursmoothdist ]  ( [ heursmoothdist1 ] ) ,",
    "the expected number of iterations in the loop starting at step  [ loop1 ] is at most  @xmath408 for each  @xmath283 , so the total expected number of iterations of this loop is at most  @xmath443 .",
    "we study the loop starting at step  [ loop2 ] .",
    "after step  [ stepsunits ] , we have  @xmath444 .",
    "let  @xmath445 be the group  @xmath439 .",
    "there is an exact sequence @xmath446 so that the loop terminates if and only if the image of  @xmath447 generates the group  @xmath445 .",
    "we have  @xmath448 , so by heuristic  [ heursmoothdist ]  ( [ heursmoothdist2 ] ) this happens after we find an expected number of  @xmath449 smooth elements . by heuristic  [ heursmoothdist ]  ( [ heursmoothdist1 ] ) , the total expected",
    "number of iterations of this loop is at most  @xmath443 .",
    "checking the loop condition  @xmath450 amounts to linear algebra , so it also takes time  @xmath408 .",
    "this proves the theorem .",
    "assume heuristics  [ heurfastunits ] ,  [ heurunits ] , [ heurfb ] and  [ heursmoothdist ] .",
    "then , given the g - reduction structure computed by algorithm  [ gbuild ] and a smooth integral right @xmath22-ideal  @xmath28 , algorithm  [ greduce ] ( ` greduce ` ) terminates in expected time  @xmath408 .",
    "first , since by theorem  [ thmcomplgbuild ] , algorithm  [ gbuild ] terminates in expected time  @xmath408 so in particular the expected size of its output is also at most  @xmath408 . in subalgorithm  [ greduce ] ( ` greduce ` ) , the first part is linear algebra so it takes time  @xmath408 . by lemma  [ lemcomplcr ] ,",
    "all the elementary operations can be performed in time polynomial in the size of their input .",
    "we analyse the calls to subalgorithm  [ preduce ] ( ` preduce ` ) . in this subalgorithm ,",
    "the variable  @xmath54 decreases by  @xmath64 every two iterations and the initial value of  @xmath54 is bounded by  @xmath311 , so the algorithm terminates after at most  @xmath311 iterations by the loop condition .",
    "so the total number of iterations in the calls to subalgorithm  [ preduce ] is bounded by  @xmath451 by step  [ stepgmul ] of subalgorithm  [ greduce ] , where  @xmath452 .",
    "but  @xmath453 is polynomial in the size of the input and  @xmath454 is polynomial in the size of the g - reduction structure , which is  @xmath408 .",
    "this proves the theorem .    finally , for a general integral",
    "right @xmath22-ideal , repeated attempts with algorithm  [ isprincipal ] ( ` isprincipal ` ) takes total expected time  @xmath408 if we assume the following heuristic .",
    "[ heursmoothen ] there exists a constant  @xmath455 such that in step  [ stepsmooth ] of algorithm  [ isprincipal ] , the element  @xmath354 is smooth with probability at least  @xmath456 .    again",
    ", by comparison with the case of integers  @xcite , @xmath457 could be a reasonable value .",
    "we have implemented the above algorithms in the computer algebra system magma  @xcite . in this section ,",
    "we demonstrate how our algorithms work and perform in practice .",
    "every computation was performed on a @xmath458  ghz intel xeon e5420 processor with magma v2.20 - 5 from the plafrim experimental testbed .",
    "let  @xmath16 be the quaternion algebra over  @xmath459 generated by two elements  @xmath460 such that  @xmath461 , @xmath462 and  @xmath463 .",
    "the algebra  @xmath16 is ramified at  @xmath64 and  @xmath464 and unramified at every other place : @xmath16 is indefinite and our method applies .",
    "let  @xmath22 be the maximal order  @xmath465 where  @xmath466 .",
    "we construct a reduction structure with algorithm  [ gbuild ] ( ` gbuild ` ) and factor base  @xmath467 .",
    "let  @xmath468 where  @xmath469 , so that  @xmath470 .",
    "we use algorithm  [ isprincipal ] ( ` isprincipal ` ) to compute a generator of  @xmath28 .",
    "it finds an element  @xmath471 such that  @xmath472 , so that  @xmath324 is smooth .",
    "the linear algebra phase in subalgorithm  [ greduce ] ( ` greduce ` ) computes  @xmath473 having norm  @xmath474 and  @xmath475 .",
    "we obtain  @xmath476 with  @xmath477 and  @xmath478 before the local reduction .",
    "we reduce the ideal  @xmath112 at  @xmath479 . in subalgorithm  [ preduce ] ( ` preduce ` ) , at the first iteration we have  @xmath480 so  @xmath481 . in the second iteration we have  @xmath482 :",
    "the element  @xmath279 has norm  @xmath74 and  @xmath483 . after multiplying every element",
    ", we obtain the output  @xmath484 and  @xmath485 has norm  @xmath486 : @xmath354 is a generator of the ideal  @xmath28 .",
    "let  @xmath6 be the complex cubic field of discriminant  @xmath487 , which is generated by an element  @xmath488 such that  @xmath489 . let  @xmath16 be the quaternion algebra over  @xmath6 generated by two elements  @xmath460 such that  @xmath490 ,  @xmath491 and  @xmath463 .",
    "the algebra  @xmath16 is ramified at the real place of  @xmath6 and the discriminant  @xmath20 has norm  @xmath492 .",
    "all the maximal orders in  @xmath16 are conjugate and we compute one of them with magma .",
    "algorithm  [ gbuild ] ( ` gbuild ` ) constructs the reduction structure in  @xmath493 seconds .",
    "we then compute the  @xmath494 primes of  @xmath6 coprime to  @xmath20 and having norm less than  @xmath495 .",
    "for every such prime  @xmath10 , we construct a random integral right @xmath22-ideal  @xmath28 with norm  @xmath10 .",
    "since  @xmath58 is trivial , they are all principal .",
    "we apply algorithm  [ isprincipal ] ( ` isprincipal ` ) to compute a generator of each of these ideals .",
    "this computation takes  @xmath496 seconds per ideal on average with a maximum of  @xmath497 seconds . as a comparison ,",
    "we compute generators for the same ideals with the function provided by magma .",
    "this computation takes  @xmath493  hours per ideal on average with a maximum of  @xmath498h , and  @xmath492 of the  @xmath499 ideals take less that  @xmath500  seconds .",
    "when the base field is totally real and the algebra is ramified at every real place except one , there is an algorithm of voight  @xcite for computing the unit group of an order . in  @xcite , dembl and voight",
    "mention but do not describe an unpublished algorithm using this computation to speedup ideal principalization .",
    "this algorithm is provided in magma and improves on the algorithm of  @xcite .",
    "let  @xmath6 be the real cubic field of discriminant  @xmath501 , which is generated by an element  @xmath488 such that  @xmath502 .",
    "let  @xmath16 be the quaternion algebra over  @xmath6 generated by two elements  @xmath460 such that  @xmath503 ,  @xmath504 and  @xmath463 .",
    "the algebra  @xmath16 is ramified at two of the three real places of  @xmath6 and no finite place .",
    "we compute a maximal order in  @xmath16 and then construct the reduction structure in  @xmath505 seconds .",
    "we produce a random integral ideal of norm  @xmath10 for each prime  @xmath10 having norm less than  @xmath495 and compute a generator for each of them with our algorithm .",
    "the computation takes  @xmath506  seconds per ideal on average with a maximum of  @xmath507  seconds .",
    "with magma we compute the unit group  @xmath327 in  @xmath508  minutes and then compute generators for the same ideals with the units - assisted algorithm  @xcite provided by magma .",
    "the computation takes  @xmath74 hour per ideal on average with a maximum of  @xmath509h , and  @xmath510 of the  @xmath499 ideals take less that  @xmath511  seconds .",
    "magma tends to return smaller generators than our algorithm .",
    "magma is fast whenever there exists a small generator and our algorithm is faster when this is not the case .          in order to understand the practical behaviour of the algorithms",
    ", we conduct the following experiment .",
    "we draw algebras  @xmath16 and ideals  @xmath28 at random . in every random test case ,",
    "we compute our reduction structure with algorithm  [ gbuild ] ( ` gbuild ` ) , and we compute a generator of the ideal  @xmath28 with algorithm  [ isprincipal ] ( ` isprincipal ` ) .",
    "we also compute a generator of  @xmath28 with the function provided by magma . in every case",
    ", we interrupt any algorithm that takes more than  @xmath512 seconds to terminate .",
    "the result of  @xmath513 such test cases is plotted in figure  [ timings ] : the discriminant  @xmath411 and the time are both in logarithmic scale , and each plot  @xmath514 is such that  @xmath515 is the average of the running time of the algorithm over the discriminants  @xmath516 $ ] . we do not plot the running time when more than  @xmath517 of the executions were interrupted , since the corresponding value is no longer meaningful .",
    "i would like to thank karim belabas and andreas enge for helpful discussions and careful reading of early versions of this paper .",
    "i also want to thank an anonymous referee many comments and corrections and for suggesting a deterministic algorithm for computing a local generator and pierre lezowski for explaining to me euclidean algorithms over matrix rings ."
  ],
  "abstract_text": [
    "<S> deciding whether an ideal of a number field is principal and finding a generator is a fundamental problem with many applications in computational number theory . for indefinite quaternion algebras </S>",
    "<S> , the decision problem reduces to that in the underlying number field . finding a generator is hard , and we present a heuristically subexponential algorithm .    </S>",
    "<S> * keywords * : quaternion algebra , principal ideal algorithm , factor base , bruhat - tits tree . </S>"
  ]
}