{
  "article_text": [
    "by _ imperative programming _ we will understand the writing of code in which the state of the computation is directly tested and explicitly manipulated by assignment statements . as a programming paradigm , imperative programming should be compared with functional and logic programming .",
    "compared to these latter paradigms , imperative programming is in an unsatisfactory state .",
    "at least as a first approximation , a definition in functional or logic programming is both a specification and is executable . in",
    "imperative programming proving that a function body meets its specification is such a challenge that it is not considered part of a programmer s task .",
    "another difference , probably related , is that functional and logic programming have an elegant mathematical semantics in which the behaviour of an executable definition is characterized as a fixpoint of the transformation associated with the definition .",
    "c is the programming language _ par excellence _ for imperative programming .",
    "but in c one can fake functional programming to a certain extent by doing as much as possible with function definitions , function calls , and function parameters . in this paper",
    "we will be concerned with what may be called _ hard - core _ imperative code : code in the form of the body of a procedure ( void function in c ) that contains no global variables and that interacts only with its environment by reading , testing , and modifying the actual parameters in the call .",
    "these parameters , together with any local variables that may be present , comprise the state that is changed by assignment statements .",
    "surprisingly perhaps , hard - core imperative code does not exclude function or procedure calls .",
    "in imperative programming verification is a serious problem .",
    "the problem is more serious than in functional or logic programming because there the executable code can itself be the definition of the function or predicate to be executed .",
    "of course this ideal is rarely reached completely .",
    "but it is a clear ideal for the programmer to strive after . in imperative programming",
    "such an ideal does not exist . here",
    "correctness has to be proved independently of the code .",
    "although a powerful verification method was developed by floyd and by hoare , the experience is that it is hard to produce a correctness proof for _ existing _ code .",
    "dijkstra observed @xcite that code has to be _",
    "designed for _ correctness proof .",
    "he did not make this suggestion more concrete than to call for the _ parallel development of proof and code_.    this paper is a contribution to the parallel development of proof and code for imperative programming .",
    "it takes the form of a new language , called _ matrix code _ , in which programs take the form of a matrix of which the elements are binary relations among data states .",
    "matrix code is distinguished by a development process that begins with a null code matrix , progresses with small , obvious steps , and ends with a matrix that is of a special form that is trivially translatable to a conventional language like java or c. the result of the translation has the same behaviour as the one determined by the mathematical semantics of the code matrix . therefore the latter can be said to be executable . as every stage in the development process is partially correct with respect to the specification ( the correctness of the initial null code matrix is _ very _ partial ) .",
    "matrix code comes close to the ideal in which the code is itself a proof of partial correctness .",
    "matrix code comes with an abstract machine , which we call a _ dual - state machine _",
    "the dsm has easily identifiable special cases that are trivially translatable to conventional languages like c or java .",
    "[ [ plan - of - the - paper ] ] plan of the paper + + + + + + + + + + + + + + + + +    because we derive dsms from finite - state machines we first review conventional automata theory and regular expressions .",
    "the step to dsms is made by exploiting the fact that formal languages are mathematically similar to binary relations and that both are best regarded as interpretations of regular expressions .",
    "accordingly , in section  [ sec : prelim ] we establish our notation and terminology for formal languages , binary relations , and regular expressions .",
    "in section  [ sec : fsm ] we present the main definitions concerning fsms .",
    "this presentation is necessary because of slight , yet essential variations in the usual definitions .",
    "one such variation is that the transition is given as a matrix . in section  [ sec : dsm ] dual - state machines are introduced as a close variant of fsms .",
    "the versatility of dsms is demonstrated by examples including an fsm , a turing machine , and dsms that translate to c programs for generating prime numbers and for merging files . as the latter type of dsm is the motivation for the entire enterprise we devote section  [ sec : mc ] to it .    in section",
    "[ sec : floyd ] we adapt the verification method of floyd and hoare to matrix code . in section  [ sec : sys ] we solve as example problem the generation of prime numbers in the systematic manner that is specific to matrix code .",
    "this is the same problem as one of those treated by dijkstra in @xcite , so that matrix code can be compared with structured programming . although the derivation method for the prime - number algorithm is original , the computations of the resulting code are the same as those of the conventionally produced version .",
    "but matrix code is not only valuable as a method for developing proof and code in parallel , but , as we show in the derivation of the merging algorithm in section  [ sec : expressiveness ] , it is valuable also for finding algorithms that are more efficient than those obtained in the conventional manner .",
    "the final two sections draw conclusions and survey related work in widely scattered areas of computer science .",
    "the dual - state machines to be introduced in this paper are a variant of the classical finite - state machines .",
    "just as finite - state machines define formal languages , dual - state machines define binary relations .",
    "the similarity between the two types of machine has to do with the similarity between formal languages and binary relations .",
    "one of the ways this similarity manifests itself is the fact that formal languages and binary relations have a natural notation in common : regular expressions .      given a set @xmath0 , we denote the set of finite sequences of its elements as @xmath1 .",
    "we often think of @xmath0 as an `` alphabet '' , of its elements as `` symbols '' , of the sequences of symbols as `` words '' , and of sets of words as a ( formal ) `` language '' .",
    "@xmath1 includes the empty word , the sequence of length 0 , which is denoted @xmath2 .",
    "the null language is the empty set .",
    "this is not to be confused with the unit language , which contains the empty word as its only word .",
    "the concatenation of words @xmath3 and @xmath4 is denoted @xmath5 .",
    "we have @xmath6 for all words @xmath7 .",
    "concatenation of words is extended elementwise to concatenation of languages : @xmath8 concatenation of a language @xmath9 with itself gives rise to the powers of @xmath9 : @xmath10 is the unit language and @xmath11 for all @xmath12 .",
    "the closure @xmath13 of @xmath9 is defined as @xmath14 .",
    "the partial order @xmath15 on formal languages is defined to be set inclusion among the subsets of @xmath1 .",
    "a binary relation on a set @xmath16 is a subset of the cartesian product @xmath17 .",
    "if @xmath18 is in a binary relation , then we say that @xmath19 is an _ input _ ; @xmath20 is a corresponding _ output _ of the relation .",
    "the null relation is the empty subset of @xmath17 .",
    "the identity relation @xmath21 on @xmath16 is @xmath22 .",
    "the union @xmath23 of binary relations @xmath24 and @xmath25 is defined to be their union as subsets of @xmath17 .",
    "the composition @xmath26 of binary relations @xmath24 and @xmath25 is @xmath27 .",
    "powers of a relation @xmath28 are defined by @xmath29 for @xmath30 and @xmath31 for @xmath32 .",
    "we write @xmath33 for @xmath34 .",
    "the partial order @xmath15 on binary relations is defined to be set inclusion among the subsets of @xmath35 .",
    "the syntax of regular expressions @xcite over a given set of constants is defined as follows .    1 .   the constants , @xmath36 , and @xmath37 are regular expressions .",
    "2 .   if @xmath38 and @xmath39 are regular expressions then so are @xmath40 and @xmath41 .",
    "+ @xmath42 and @xmath43 are shorthand for @xmath44 @xmath45 is @xmath36 and @xmath46 is @xmath37 .",
    "if @xmath47 is a finite set of regular expressions and @xmath38 is a regular expression , then @xmath48 is defined as @xmath36 if @xmath49 and @xmath50 .",
    "if @xmath38 is a regular expression , then so is its closure @xmath51 .    in practice a different syntax",
    "is used for regular expressions .",
    "we see ef for @xmath41 , e|f for @xmath52 , e ? for @xmath53 , and e+ for @xmath54 .",
    "the syntax of regular expressions has several semantics : algebras of which the elements and operations can serve as interpretations of regular expressions . here",
    "these algebras are formal languages and binary relations and serve as semantics for regular expressions .",
    "the way we intend these algebras to be semantics for regular expressions is shown in figure  [ fig : resem ] .    [ cols=\"^,^,^,^,^,^ \" , ]     each pair of successive lines gives the result of running emerge and mmerge on the same pair of input streams .",
    "the lengths of the streams are not listed separately , as they are equal to the number of calls to putl and putr shown in the table .",
    "a merge function needs to make at least one call to getl ( getr ) for every element of the left ( right ) input stream .",
    "it can be seen that mmerge remains close to this minimum , while emerge does not .",
    "this example is notable in that matrix code yields an unfamiliar , test - optimal algorithm by _",
    "default_. structured programming tends to reduce the number of control states .",
    "matrix code lacks this bias : in its use it is natural to introduce control states as needed to serve as memory for test outcomes .",
    "we organize related work in the form of seven ways to discover matrix code : flowcharts , automata theory , abstract state machines , augmented transition networks , logic programming , tail - recursion optimization , and recursive program schemes .",
    "[ [ flowcharts ] ] flowcharts + + + + + + + + + +    the following comment has been made on matrix code : `` _ _ although it reeks of flowcharts , the proposal has some merit__. '' the comment has some merit : flowcharts are indeed closely related to matrix code .",
    "flowcharts were widely used as an informal programming notation from the early 1950s to 1970 .",
    "floyd @xcite showed how assertions and verification conditions can prove a flowchart partially correct .",
    "hoare @xcite introduced the notation of triples for the verification conditions and cast floyd s method in the form of inference rules for control structures such as + `       while ... do ...     ` and `       if ... then ... else ... `    dijkstra observed that verifying assertions are difficult to find for existing code , so that an attempt at verification is a costly undertaking with an uncertain outcome .",
    "he argued @xcite that code and correctness should be `` developed in parallel '' .",
    "the proposal seems to have found no response , if only for the lack of specifics in the proposal .",
    "given the fact that dijkstra s proposal was considered unrealistically utopian , and still is , it is interesting to read what seems to be the first treatise @xcite on programming in the modern sense , published in 1946 . here",
    "programs are expressed in the form of _ flow diagrams_. at first sight one might think that these are flowcharts under another name .",
    "this is not the case : flow diagrams consist of executable code integrated with assertions , with the understanding that a consistent flow diagram proves the correctness of the computations performed by it .",
    "the imperative part of a flow diagram was translated to machine code ( this was before the appearance of assemblers ) .",
    "i found no indication in @xcite that it was even contemplated to split off the imperative part of the flow diagram .",
    "thus we see that what was a vague proposal @xcite , and regarded as unrealistically utopian in 1970 , was fully worked out in 1946 and may have become a practical reality in 1951 when the ias machine became operational .    by the time flowcharts appeared",
    ", the proof part of flow diagrams had been dropped . and apparently forgotten , for floyd s discovery was published in 1967 and universally acknowledged as such .",
    "floyd s format is rather different , and , in our opinion , preferable to the flow diagrams of @xcite .",
    "matrix code can be regarded as a simplification of floyd s flowchart annotated with assertions , a simplification made possible by the use of binary relations that provide a common generalization of statements and tests .",
    "apt and schaerf unify statements and tests in their nondeterministic control structures @xcite .",
    "[ [ automata - theory ] ] automata theory + + + + + + + + + + + + + + +    dsms can be regarded as a realization of dana scott s idea @xcite to put an end to the proliferation of new variations of fsm by replacing them by programs defined to run on suitably defined computers .",
    "dsms are very different from the programs proposed by scott .",
    "scott s programs are unlike fsms ; dsms closely resemble fsms .",
    "paradoxically , dsms , in the form of matrix code , are of practical use ; scott s programs are not .    [",
    "[ abstract - state - machines ] ] abstract state machines + + + + + + + + + + + + + + + + + + + + + + +    dsms can be obtained as a drastic simplification of asms @xcite where evolving algebras are replaced by binary relations over data states and formulas of logic are replaced by guards .",
    "one might think that guards are a special case of the formulas of the asms .",
    "there is however a fundamental difference : regarded as logic formulas , guards have free variables ; the formulas of asms do not .",
    "[ [ augmented - transition - networks ] ] augmented transition networks + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in spite of scott s plea @xcite , variants of fsm continued to appear .",
    "of special interest in this context are _ labeled transition systems _ which are used to model and verify reactive systems @xcite . here",
    "the set of states is often infinite and there is typically no halt state .",
    "such systems are specified by rules of the form @xmath55 to indicate the possibility of a transition from state @xmath56 to state @xmath57 accompanied by action @xmath0 .",
    "mathematically the rules are viewed as a ternary relation containing triples consisting of @xmath56 , @xmath0 , and @xmath57 .",
    "this is of course unobjectionable , but the alternative view of the rules as constituting a matrix indexed by states , containing in this instance @xmath0 as element indexed by @xmath56 and @xmath57 has the advantage of connecting the theory to that of semilinear programming in the sense of parker @xcite .",
    "another variant of fsm are the _ augmented transition networks _ used in linguistics @xcite .",
    "the modification of flowcharts by means of binary relations was introduced in @xcite .",
    "these can be viewed as augmented transition networks with binary relations as labels on the transition arrows .",
    "[ [ logic - programming ] ] logic programming + + + + + + + + + + + + + + + + +    the property that a code matrix is both a set of logical formulas and an executable program is reminiscent of logic programming , especially its aspect of separating logic from control @xcite .",
    "a special form of logic program corresponding to imperative programs was investigated in @xcite .",
    "[ [ recursive - program - schemes ] ] recursive program schemes + + + + + + + + + + + + + + + + + + + + + + + + +    de bakker and de roever @xcite modeled programming constructs such as if - then - else and while - do . for both guards and assignments they used binary relations among what we call data states .    [",
    "[ tail - recursion - optimization ] ] tail - recursion optimization + + + + + + + + + + + + + + + + + + + + + + + + + + +    an attractive way of deriving efficient imperative code is to use a recursive definition of the function to be computed as starting point .",
    "these can sometimes be transformed to a form in which there is a single recursive call and where this call occurs as the last statement of the function .",
    "a further transformation replaces this call by the more efficient goto statement .",
    "the result is similar to the result of translating a code matrix to executable code .",
    "the definition of the function can then be used to obtain an assertion verifying the transformed program .",
    "this is used in logic programming @xcite .",
    "in this paper we write programs as matrices with binary relations as elements .",
    "these matrices can be regarded as transformations in a generalized vector space , where vectors have assertions about data states as elements .",
    "computations of the programs are characterized by powers of the matrix and verified assertions show up as generalized eigenvectors of the matrix .",
    "such results may be dismissed as frivolous theorizing .",
    "it seems to us that they are related to the following practical benefits .",
    "our motivation was to address the fact that imperative programming is in an unsatisfactory state compared to functional and logic programming . in the latter paradigms ,",
    "implementation is , or is close to , specification .",
    "in imperative programming the relation between implementation and specification is the verification problem , a problem considered too hard for the practising programmer .",
    "we proposed matrix code as an imperative programming language where the same construct can be read as logical formula and can serve as basis for a routine translation to java , ` c ` , or ` c++ ` .",
    "matrix code is only applicable to small algorithms .",
    "take it as a warning sign when it no longer fits on the back of an envelope .",
    "yet it can play a useful role in large programs .",
    "even the largest software system is ultimately subdivided into functions or methods .",
    "software engineering wisdom is unanimous in declaring any function that is not small as a `` code smell '' and hence a candidate for refactoring .",
    "everyone of these many small functions is a candidate for derivation by matrix code .",
    "experience so far suggests that it is possible to develop algorithms incrementally by small , obvious steps from the specification . in this paper",
    "we go through such steps for an algorithm to fill a table with prime numbers using the method of trial division .",
    "whether or not this success is an exceptional case , it seems certain that progress has been made in the direction of the old dream according to which the production of verified code is facilitated by developing proof and code in parallel .",
    "thanks to paul mcjones and mantis cheng for their help .",
    "i am grateful to the reviewers for ppdp 2012 and to the ones for _ science of computer programming _ for their careful reading and for their suggestions for improvement .",
    "this research benefited from facilities provided by the university of victoria and by the natural science and engineering research council of canada .",
    "goldstine and j. von neumann .",
    "planning and coding of problems for an electronic computing instrument .",
    "part ii , volume 1 , 1946 . reprinted in : _ john von neumann : collected works _",
    ", pages 80  151 , volume v. a.h .",
    "taub , editor .",
    "pergamon press , 1963 ."
  ],
  "abstract_text": [
    "<S> matrix code gives imperative programming a mathematical semantics and heuristic power comparable in quality to functional and logic programming . </S>",
    "<S> a program in matrix code is developed incrementally from a specification in pre / post - condition form . </S>",
    "<S> the computations of a code matrix are characterized by powers of the matrix when it is interpreted as a transformation in a space of vectors of logical conditions . </S>",
    "<S> correctness of a code matrix is expressed in terms of a fixpoint of the transformation . </S>",
    "<S> the abstract machine for matrix code is the dual - state machine , which we present as a variant of the classical finite - state machine . </S>"
  ]
}