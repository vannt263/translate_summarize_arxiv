{
  "article_text": [
    "a robotic system s decision making is well known to be in need of some hard decision making at times .",
    "a most popular example is asimov s laws @xcite , which demonstrate the difficulties to apply logic by robots in practice .",
    "a shortened version of these laws is `` 1 .",
    "a robot may not allow a human being to come to harm .",
    "2 . a robot must obey the orders given to it by human beings except if the order causes harm to humans .",
    "3 . a robot must protect its own existence as long as such protection does not cause harm to humans . ''",
    "assuming these , what would happen to the robot s decision making if a human commands a robot to kill someone , but at the same time threatens to kill himself if the robot does not obey ?",
    "in this example the human introduces a contradiction into the logic of the robot . to avoid this",
    "the robot may have a complex rule base to provide it with legal and ethical principles and can be equipped by a meta law which says that `` the robot should not allow itself to be dictated by communicated conditions which make its logic contradictory '' . in this example one could say that in legal terms the suicide will remain the sole `` responsibility '' of the threatening person who commands the robot .",
    "the problem is not only the imperfection of asimov s robotic laws or that an agent programmer can make mistakes .",
    "logical consistency checks are also needed when the robot s perception - based beliefs are wrong .",
    "the agent can be programmed to re - examine whether its beliefs may need to be changed as were mistakenly believed to be true or false .",
    "this is not unlike enabling the agent to think like poirot , miss marple or sherlock holmes when they are reassessing their initial beliefs or impressions .",
    "but there are simpler cases : a robot may decide that the book it sees on the table can not be tom s as that one is in his home . in this paper",
    "we address the problem of how a robot can quickly and efficiently resolve inconsistencies in order to make the right decisions .",
    "the ability of making fast decisions about logical consistency , and the robot s ability to detect when inconsistency occurs , is an important problem for the future of robotics .",
    "it is also of particular importance for logic - based robot control systems , e.g. , @xcite .",
    "a typical logic - based robotic system usually contains a belief set , which provides the basis of reasoning for a robot s behaviour  @xcite .",
    "an inconsistent belief set could lead to a wrong plan causing an unexpected result , e.g. , an unmanned vehicle can hit an obstacle , instead of avoiding it , if it mistakenly believes that any route of avoidance could cause more damage , due to , for instance , mis - perception of the environment .",
    "its mis perception could perhaps be corrected if it had been able to combine environmental prior knowledge with current sensing .    in a rapidly changing environment",
    "bayesian methods can be used to identify and track movements of objects and establish functional relationships , e.g. , @xcite . when faced with balanced probabilities for two hypothetical and competing relationships in the robot s environment",
    ", it may need to make a decision based on the application of logic using prior knowledge .",
    "discovery of logical inconsistency in geometrical and physical relationships in an environmental model should prompt a robotic agent to revise its perception model of the world .",
    "for instance belief - desire - intention ( bdi ) agents should carry out consistency checks in their reasoning cycle in languages such as @xmath0 , @xmath1 and @xmath2 @xcite . in these systems",
    "the agent programmer should program logical consistency checks and handling of inconsistencies at design stage of the software .    to topic of fast consistency checking by robots",
    "has also implications for legal certification of robots .",
    "as we humans formulate social and legal behaviour rules in terms of logical implications , the process is likely to be similar for robots and the problem of consistent decisions by robots is an important generic capability .",
    "future legal frameworks for certification of robots need to take into account verifiable decision making by robots .",
    "consistency checks on a set of logic rules in propositional logic is a textbook problem and has been extended to various types of logic systems in terms of validity , consistency and satisfiability .",
    "for instance @xcite provides an authoritative account of the history of logical consistency checking in a propositional logic .",
    "relevant methods and algorithms have long been investigated for database systems and rule - based expert systems , e.g. , @xcite , but none has been specifically designed for robotics .",
    "query language 4ql  @xcite and boolean networks ( bn )  @xcite are very similar to our modelling formalism _",
    "boolean evolution systems_. the former allows a variable to have four values : @xmath3 , @xmath4 , @xmath5 and @xmath6 .",
    "the algorithm that computes the unique well - supported model in  @xcite can be adapted to check consistency , but it can only deal with one initial evaluation of variables at a time .",
    "bn was developed for modelling gene regulatory networks in biology .",
    "in bn , a boolean variable can only take either @xmath3 or @xmath4 , while in our formalism , a variable can be initialised as @xmath5 .",
    "research on bdi reasoning cycles focuses on runtime detection and resolution of conflicting goals , such as  @xcite .",
    "no work has been conducted on complex reasoning process , which will be required by autonomous and intelligent robots .    for realtime robotic systems it is important to increase solver efficiency to be able to deal with large search spaces with complex reasoning process for both offline and online application .",
    "in this respect , the use of binary decision diagram ( bdd ) is very effective by compressing search space through generating a unique and succinct representation of a boolean formula .",
    "bdd has been widely adopted for model checking  @xcite , and applied successfully to verification of large systems . in this paper",
    "we adopt the bdd based symbolic model checking approach  @xcite to robotics . to our best knowledge",
    ", nothing has been reported on its application on consistency and stability checking of decisions by robots .    in this paper",
    "we propose a fast method for discovery of inconsistency in a set of logic rules and statements on relationships in a current world model , past actions , planned actions and behaviour rules of a robotic agent .",
    "we do not address the problem of how to resolve logical inconsistency , mainly because we hold the view that , to eliminate inconsistencies , a robot can efficiently improve its world model by non - logic based techniques .",
    "such techniques can include gathering more perception data , active vision , using alternative action plans or analyzing and deriving spatial temporal models using probabilities .",
    "if a single new perception predicate or predicate derived by logic rules of the robot contradicts its otherwise consistent world model , then the robot may apply a set of logic rules to derive a correction of its belief in terms of the predicate .",
    "what to derive and analyse for consistency is however a broad topic and lies outside of the scope of this paper . here",
    "we focus on fast discovery of inconsistencies which is fundamental for safe operations of autonomous robots . with time it should be a key technical part in the process of legal certification of future autonomous robots .",
    "our contribution builds on and develops our past efficient state space generation and parallel computation  @xcite methods further .",
    "we have previously developed various state space reduction techniques for symbolic model checking via bdds , such as symmetry reduction  @xcite and abstraction  @xcite .",
    "the preliminary results of our techniques have been published in  @xcite . in this paper",
    "we elucidate the setting for which our techniques are designed and demonstrate their way of using it in robotics .",
    "we also extend the techniques to deal with a different semantics and develop a new technique to extract counterexamples efficiently when the system is inconsistent or unstable .",
    "the counterexamples are useful for system developers to correct robotic reasoning systems ; they can provide guidance on how to improve the reasoning process of robots .",
    "we study the efficiency of the agent s ability to examine the consistency of its beliefs and logic rules and , if inconsistency occurs , generate counterexamples to the rules which can then be used by the robot to resolve inconsistency .",
    "our technique can be used both by robot programmers at software design stage and by robots when reasoning . in the former case",
    ", system developers can check the logical consistency of reasoning cycles in agent programs at design stage . for each inconsistent check",
    ", a counterexample can be produced to help developers understand the source of inconsistency and correct the program . in the latter case ,",
    "consistency checks are carried out by the robots themselves in realtime and counterexamples are examined to improve reasoning , e.g. , bringing in more sensor data to eliminate ambiguity or bring about alternative decisions about future actions .    in section",
    "[ sec : system ] we introduce the problem in a robotic framework and its characteristics . in section  [ boolevul ] boolean evolution systems are formally represented . in section  [ sec : modelling ] , we translate boolean evolution systems into _ transition systems _ which are now widely used in the control systems literature @xcite , which provides the basis of verification . note that in this paper we abstract robotic behaviour to propositional logic to be able to cope with computational complexity of consistency checking .",
    "section  [ sec : mc ] contains our results on stability of boolean evolution systems in terms of ctl and ltl formulae .",
    "an important result states that stability checking can be reduced to a reachability problem which only asks for one fixpoint computation .",
    "similarly , consistency checking can be also converted into simple fixpoint computation .",
    "section  [ sec : case ] presents a case study in a home robotics scenario , which demonstrates the use of uncertain sensory and communication information and a set of rules to satisfy . in section  [ sec : exp ] , performance comparison between ctl formulae based solutions and the reachability based algorithms is highlighted and implemented in the symbolic model checker mcmas  @xcite .",
    "we discuss stability checking under an alternative semantics of evolution in section  [ sec : interleaving ] .",
    "we conclude the paper in section  [ sec : concl ] .",
    "our predicates - based knowledge representation of a robot , which is derived from sensing events , remembering the past as well as from prediction of a future environment , is schematically depicted in fig .",
    "[ robpreds ] . for new sensory predicates",
    "we assume that the robot is able to identify which are uncertain in a probabilistic sense .",
    "the following specific problems are to be addressed :    1 .",
    "assuming inconsistency occurs , identify which uncertain new sensing predicates in @xmath7 can be made certain within rules @xmath8 based on physical models . 2 .",
    "the agent considers a set @xmath9 of actions as its options . for each action",
    "@xmath10 in @xmath11 it simulates a physical model over a time horizon and abstracts a set of events @xmath12 for its future consequences .",
    "it checks if @xmath13 and its behaviour rules @xmath14 are consistent based on 1 ) and 2 ) .",
    "the set @xmath15 of feasible actions @xmath10 in @xmath11 , which are consistent with @xmath14 , are used by the robot to make a final choice of an action using non - logic based evaluations ( for instance using planning ) .      in fig .",
    "[ robpreds ] the diamonds indicate the procedural locations of logical consistency checks , based on predicates and sets of rules ( logical implications ) .",
    "[ h!t ! ]",
    "it can however happen that some of the probabilistic sensing of events remain unresolved based on physical models and associated rules : let @xmath16 denote the set of undecided perceptions .",
    "the robotic agent needs to check for each of its possible actions what would happen if various combinations of its uncertain perceptions in @xmath17 were true or false . in safety critical situations",
    "a robot can not take any action , which could lead to it breaking its rules in some combination of truth values in @xmath17 .",
    "checking this can require complex consistency checking to be done while the robot interacts with its environment , hence the efficient methods proposed in this paper are key to timely decisions by a robot .",
    "this paper is not committed to any particular type of software architecture .",
    "we assume that propositional logic using a predicate system , which can admit arguments but is equivalent to propositional logic ( for decidability properties ) , is used in the robotic software .",
    "we also assume that the robot perceives and creates predicates about environmental events and about its actions periodically within a _ reasoning cycle _ performed at an approximately fixed rate per second .    at a given reasoning cycle of the robotic agent , indexed with time @xmath18 , the agent holds a set of predicates @xmath19 in its memory , possibly some of these with negation signs .",
    "this means that the predicates in @xmath20 split into two disjoint sets as @xmath21 consisting of ones assigned value @xmath3 while the rest the boolean value @xmath4 .",
    "such an assignment of boolean values in @xmath20 is called a valuation of the boolean variables in @xmath20 and denoted by @xmath22 .",
    "the agent also has a set of rules at time @xmath18 denoted by @xmath23 .",
    "the rule set @xmath24 may contain more variables than @xmath20 .",
    "those not in @xmath20 are unknown to the agent and its logic reasoning is then interested in the problem of satisfiability of all the logic rules by suitable assignments to the unknown variables . in the following",
    "we will drop the time index @xmath18 as we will be interested in the consistency of logic rules at any time , in view of some boolean evaluations .",
    "the terms `` variable '' and `` predicate '' will be used interchangeably .",
    "our primary problem is that the robotic agent has limited time for logical derivations , when quick response is required , and it needs to assess the following :    * are its current evaluations and its rule base consistent in the sense that unknown variables can take on values to satisfy all the rules ? * having answered the previous question negatively , can it modify some of its own boolean evaluations so that its set of predicates becomes consistent with its set of rules ?",
    "testing consistency of a set of evaluations can be achieved by checking satisfiability of the conjunction of the evaluations and the rule set , and obtaining consistent values for unknown variables can be done by starting to apply the rules until the boolean evaluation becomes stable , i.e. the logical value of no variable changes any more .",
    "however , it can be inefficient to use this method as the number of evaluations may increase exponentially with the number of variables .      by analogy to previous definitions  @xcite of agentspeak - like architectures for belief - desrie - intention type of robotic agents , we define our reasoning system by a tuple : @xmath25 where :    * @xmath26 is the set of all predicates .",
    "* @xmath27 is the total atomic belief set .",
    "the current belief base at time @xmath18 is defined as @xmath28 . at time",
    "@xmath18 beliefs that are added , deleted or modified are considered _ events _ and are included in the set @xmath29 , which is called the _ event set_. events can be either _ internal _ or _ external _ depending on whether they are generated from an internal action , in which case are referred to as `` mental notes '' , or an external input , in which case are called `` percepts '' . * @xmath30 is a set of implication rules .",
    "* @xmath31 is the set of executable plans or _",
    "plans library_. current applicable plans at time @xmath18 are part of the subset @xmath32 , this set is also named the _ desire set_. a set @xmath33 of intentions is also defined , which contains plans that the agent is committed to execute .",
    "* @xmath34 is a set of all available actions .",
    "actions can be either _ internal _ , when they modify the belief base or generate internal events , or _",
    ", when they are linked to external functions that operate in the environment .",
    "agentspeak - like languages , including lisa ( limited instruction set architecture ) @xcite , can be fully defined and implemented by listing the following characteristics :    * _ initial beliefs_. + the initial beliefs and goals @xmath35 are a set of literals that are automatically copied into the _ belief base _ @xmath36 ( that is the set of current beliefs ) when the agent mind is first run . *",
    "_ initial actions_. + the initial actions @xmath37 are a set of actions that are executed when the agent mind is first run",
    ". the actions are generally goals that activate specific plans . *",
    "_ logic rules_. + a set of logic based implication rules @xmath38 describes _ theoretical _ reasoning about physics and about behaviour rules to redefine the robot s current knowledge about the world and influence its decision on what action to take . *",
    "_ executable plans_. + a set of _ executable plans _ or _ plan library _ @xmath39 .",
    "each plan @xmath40 is described in the form : @xmath41 where @xmath42 is a _ triggering predicate _ obtained by consistency in @xmath43 and possible valuation for the best choice of @xmath44 from @xmath45 .",
    "next the @xmath42 allows the plan to be retrieved from the plan library whenever it becomes true ; @xmath46 is called the _ context _ , which allows the agent to check the state of the world , described by the current belief set @xmath36 , before applying a particular plan ; the @xmath47 form a list of actions to be executed .",
    "the above list of steps are cyclically repeated to run the reasoning process of a robotic agent .",
    "a binary - decision - diagram ( bdd ) @xcite is a succinct representation of a set of boolean evaluations and , motivated by this , we examine the possibility of applying symbolic model checking via bdds to verify consistency and stability .",
    "this way , we avoid the combinatorial explosion of evaluations .",
    "we will show that bdd based model checking is very efficient for this task to be carried out in realtime , while the agent needs to give quick responses to its environment .",
    "as agent perception processes are often prone to errors in a physical world due to sensor issues or to unfavourable environmental conditions , this is an important problem of robotic systems .",
    "we present a formal definition of the consistency checking problems in the next section .    a boolean evolution system @xmath48 is composed of a set of boolean variables @xmath49 and a set of evolution rules @xmath50 defined over @xmath51 .",
    "a rule @xmath52 is of the form @xmath53 , where @xmath54 is the guard , i.e. , a boolean formula over @xmath51 , and @xmath55 is an assignment that assigns @xmath3 ( `` 1 '' ) or @xmath4 ( `` 0 '' ) to a boolean variable @xmath56 . for simplicity",
    ", we write a rule of the form @xmath57 as @xmath58 , and write @xmath59 as @xmath60",
    ". we also group rules with the same guard into one .",
    "for example , two rules @xmath61 and @xmath62 can be written as @xmath63 .    in practice",
    ", the set @xmath51 is usually partitioned into 2 subsets : @xmath64 and @xmath65 , where variables in the former are initialized to either @xmath3 or @xmath4 , and variables in the latter initialized to @xmath5 .",
    "accordingly , the guard of a rule can be evaluated to @xmath3 , @xmath4 and @xmath5 .",
    "the last case can occur when the guard contains a variable in @xmath65 .    to model a predicates - based knowledge representation and reasoning system in fig .",
    "[ robpreds ] by a bes , we translate each predicate in @xmath36 , action in @xmath11 and future event in @xmath12 into a boolean variable and each reasoning rule in @xmath66 into a boolean formula . in particular ,",
    "the uncertain sensing predicates in @xmath67 and future events in @xmath12 are placed in @xmath65 , and those in @xmath68 and actions in @xmath11 are placed in @xmath64 .",
    "let @xmath69 be a valuation of the boolean variables , and @xmath70 the value of variable @xmath71 in @xmath69 .",
    "we say that a rule @xmath72 is _ enabled _ if its guard @xmath54 is evaluated to @xmath3 on @xmath69 .",
    "the new valuation , after applying the evolution rules to @xmath69 , is defined by _",
    "synchronous evolution semantics _ as follows .",
    "let @xmath73 be the set of rules that are enabled .",
    "the new valuation @xmath74 is the result of simultaneously applying all rules in @xmath75 to @xmath69 .",
    "that is , every value of @xmath71 in @xmath74 is defined as follows .",
    "@xmath76    the evolution from @xmath69 to @xmath74 is written as @xmath77 .",
    "we assume that for each valuation , there exists a non - empty set of enabled rules .",
    "a boolean evolution system is _ stable _ if from any valuation and applying the rules recursively , it eventually reaches a valuation @xmath69 where no other valuation can be obtained , i.e. , @xmath78 .",
    "we say that @xmath69 is a _",
    "stable _ valuation , written as @xmath79 .",
    "whether stability happens is decidable by the agent : it requires that two consecutive steps in the evolution have identical valuations .",
    "[ def : incon ] three problems might occur during evolution of a bes :    1 .",
    "two enabled rules try to update the same boolean variable with opposite values at some time ; 2 .",
    "a variable in @xmath64 is updated to the opposite value of its initial value at some time .",
    "a variable in @xmath65 is updated to the opposite value at some time after its value has been determined are initially set to @xmath5 , which can be overwritten using the evolution rules . ] .",
    "if any of these problem happens , we say that the system is _",
    "inconsistent_. otherwise , the system is _",
    "consistent_.    these problems should be identified when robotic software is programmed .",
    "for instance belief - desire - intention rational agent implementations apply the logic rules in each reasoning cycle in @xmath0 , @xmath1 and @xmath2 @xcite .",
    "within one reasoning cycle , where the input to the variables in @xmath64 is kept constant .",
    "this justifies the second and third problems in definition  [ def : incon ] .",
    "* example 1 .",
    "* @xmath80    this example demonstrates the inconsistency under synchronous semantics . for the initial valuation @xmath81 ,",
    "both the first and second rules are enabled , which makes @xmath82 and @xmath83 . in the next evolution iteration ,",
    "the second rule sets @xmath84 to @xmath3 , while the third one sets @xmath84 to @xmath4 .",
    "[ example1-cex ] illustrates the evaluation in these evolution iterations .",
    "the following result can be used to provide a simple algorithm to solve problem ( 1 ) of the agent .    [",
    "theorem : simple ] let @xmath69 be a boolean evaluations of variables in the rule set @xmath85 . then the following hold .",
    "if the boolean evolution system is not stable then @xmath69 and @xmath85 are inconsistent which the agent can detect from the same evaluation reoccurring during the boolean evolution .    if the evolution is not stable , then during the transition steps between a recurrence of the same evaluation , some evaluations must be different as otherwise the evolution would be stable with the evaluation that occurred at two consecutive identical evaluations .",
    "as an evaluation reoccurs , this means that some variable values in that evaluation are changed between the two identical occurrences of valuations .",
    "let @xmath86 be such a variable .",
    "the logic rules applied , which led to the recurrence of the evaluation , have in fact forced @xmath86 at least once to change to its opposite value and later change back .",
    "this means that the rule set @xmath85 for the initial evaluation is inconsistent with the rules , i.e. @xmath85 is not satisfiable by any evaluation which is consistent with the initial evaluation @xmath69 .",
    "theorem  [ theorem : simple ] shows that stability is guaranteed in consistent systems . for certain systems , however , the inconsistency conditions in definition  [ def : incon ] are considered unnecessarily strict in that the initial value of _ known _ variables may not be obtained directly from the environment .",
    "hence , these values can sometimes be incorrect . to alleviate this problem ,",
    "the second and third inconsistency condition in definition  [ def : incon ] can be relaxed . using this principle",
    ", we say that the second and the third conditions are _ solvable _ if the system eventually reaches a stable state by ignoring these two conditions . this principle makes consistency and stability checking not straightforward any more : some rules can correct the evaluations of some predicates .",
    "* example 2 .",
    "*    @xmath87    this example shows a consistent and stable system , where @xmath88 and @xmath89 .",
    "we use a sequence of ` @xmath90 ' , ` @xmath91 ' and ` @xmath92 ' to represent states .",
    "for example , the initial state ` @xmath93 ' represents @xmath94 .    * for valuation @xmath95 , the evolution is @xmath96 . * for valuation @xmath97 , we have @xmath98 .",
    "in this section , we describe how to enable model checking to deal with boolean evolution systems .",
    "first , we introduce _ transition systems _ , which are a mathematical formalism that forms the basis of model checking .",
    "second , we present an example of encoding a boolean evolution system under the semantics of transition systems using an input language of a model checker .      model checking is usually performed on transition systems . here",
    "we present the definition of transition systems and the translation of a boolean evolution system into a transition system .",
    "a transition system @xmath99 is a tuple @xmath100 , @xmath101 such that    * @xmath102 is a finite set of states ; * @xmath103 is a set of initial states ; * @xmath104 is the transition relation ; * @xmath105 is a set of atomic propositions ; * @xmath106 is a labelling function mapping states to the set of atomic propositions @xmath105 .",
    "we denote the set of atomic propositions valid in state @xmath107 by @xmath108 .",
    "let @xmath109 be a set of states .",
    "the function @xmath110 computes the successor states of @xmath111 under @xmath112 .",
    "formally , @xmath113    given a boolean evolution system @xmath114 with @xmath115 unknown variables , i.e. , @xmath116 and @xmath117 known variables , i.e. , @xmath118 , let @xmath119 @xmath120 @xmath121 , where @xmath122 is an atomic proposition representing that a variable @xmath123 is @xmath3 , @xmath124 representing that @xmath125 is @xmath4 , and @xmath126 representing that an unknown variable @xmath127 has value @xmath5 . a transition system ( ts ) @xmath99",
    "can be generated from @xmath128 as follows .    1",
    ".   @xmath102 is composed of all @xmath129 valuation of @xmath51 .",
    "@xmath130 is composed of @xmath131 valuations , where variables in @xmath64 can take either @xmath3 or @xmath4 , and variables in @xmath65 take @xmath5 .",
    "3 .   a transition @xmath132 iff @xmath133 . in the presence of",
    "inconsistent update of some boolean variables , the successor valuation is chosen randomly , which results in multiple successor states .",
    "for example , consider a valuation @xmath107 from where a boolean variable @xmath86 can be updated to @xmath3 by rule @xmath134 and @xmath4 by rule @xmath135 . in the transition system",
    ", @xmath107 has two successor states , i.e , valuation : one state contains @xmath97 and the other contains @xmath95 .",
    "if there are @xmath136 boolean variables that are updated inconsistently in @xmath107 , then @xmath107 has @xmath137 successor states .",
    "@xmath138 is defined such that for each variable @xmath139 , @xmath140 iff @xmath125 is evaluated as @xmath3 , @xmath141 iff @xmath125 is evaluated as @xmath4 , and for each variable @xmath127 , @xmath142 iff @xmath143 is evaluated to @xmath3 .",
    "note that all possible input values of variables in @xmath65 are captured by @xmath130 , i.e. , each possible valuation of @xmath65 is encoded into an initial state in @xmath130 .",
    "the set of states and the transition relation in a transition system can be illustrated as a direct graph , where a transition @xmath144 is represented by an arrow from @xmath145 to @xmath146 .",
    "[ example1-lts ] shows the directed graph for example 1 in section  [ sec : system ] .",
    "a boolean evolution system can be written as a program in the input language of a symbolic model checker , such as nusmv  @xcite .",
    "the program is then parsed by the model checker to build a transition system . in this section ,",
    "we show how to model a boolean evolution system by an ispl ( interpreted system programming language ) @xcite program , inspired by the interpreted system semantics @xcite , and the corresponding transition system can be generated by the model checker mcmas @xcite .",
    "we use example 1 to illustrate how to construct an ispl program from the boolean evolution system @xmath147 .",
    "an ispl program contains a set of agents , a set of atomic propositions , an expression representing the initial states and a set of logic formulas representing the specification of the system .",
    "the structure of the program is as follows :    .... agent 1 ... end agent ... agent n ... end agent evaluation ... end evaluation initstates ...",
    "end initstates formulae ... end formulae ....    where atomic propositions are defined in the section `` evaluation '' and the initial states defined in `` initstates '' .",
    "each agent is composed of a set of _ program variables _ , a set of _ actions _ that the agent can execute , a _ protocol _ and an _ evolution function_. each agent has a set of local states that are encoded by its program variables : each valuation of the variables is a local state .",
    "its protocol defines a set of enabled actions for each local state , and its evolution function specifies the transition relation among its local states .",
    "the structure of an agent @xmath148 is below :    .... agent m    vars : ... end vars    actions = { ... } ;    protocol : ... end protocol    evolution : ... end evolution end agent ....    to encode a bes into an ispl program , we only need one agent , and this agent has only one action , which is enabled in every local state . in the rest of this section , we give details of the construction of the ispl program .",
    "the definition of actions and protocol is omitted as they do not affect the translation of the bes .    1 .",
    "as explained before , we do not directly list all states in the state space @xmath102 of the corresponding transition system . instead , we define program variables to match variables in @xmath128 . each variable in @xmath64 is translated into a boolean variable in ispl and each variable in @xmath65 into an enumerated variable with three values @xmath149 , @xmath150 and @xmath151 .",
    "the corresponding ispl code for example 1 is as follows .",
    "+ .... vars :    a : boolean ;    b : { true , false , unknown } ;    c : { true , false , unknown } ; end vars ....",
    "each evolution rule is translated into a guarded transition `` @xmath84 ` if ` @xmath54 '' in ispl , where guard @xmath54 is a boolean expression over variables , and @xmath84 is a set of assignments .",
    "indeed , the semantics of a guarded transition matches exactly that of an evolution rule .",
    "the rules in example 1 are translated into the ispl code below .",
    "+ .... evolution :    b = false if a = true ;            c = true if a = true ;    b = false if c = false ; end evolution ....",
    "3 .   as each variable in @xmath65 in @xmath128 is initialized to _",
    "unknown _ , we need to specify this in the initial state section @xmath152 in an ispl program .",
    "the following code is generated for example 1 .",
    "+ .... initstates    m.b = unknown and m.c = unknown ;   end initstates .... + note that ` m ` is the name of the agent , which encapsulates the variables and transitions , and ` m.x ` refers to the variable ` x ` in ` m ` .",
    "an atomic proposition in ispl is of the form `` @xmath153 ` if ` @xmath54 '' , where @xmath153 is the name of the atomic proposition , and @xmath54 is a boolean expression that defines the set of states @xmath153 holds .",
    "that is , @xmath153 holds in any state whose corresponding valuation satisfies @xmath54 .",
    "the ispl code for example 1 is below .",
    "+ .... evaluation    a_true if m.a = true ;    a_false if m.a = false ;    b_true if m.b = true ;    b_false if m.b = false ;    b_unknown if m.b = unknown ;    c_true",
    "if m.c = true ;    c_false if m.c = false ;    c_unknown if m.c = unknown ; end evaluation ....    the above construction steps suggests that a compiler can be produced without difficulties to automatically generated ispl code from a given boolean evolution system .",
    "although we have shown the possibility of coding a boolean evolution system in ispl , we would like to emphasize that compilers for other symbolic model checkers can also be constructed when necessary .",
    "for example , the semantics of the input language of nusmv is similar to that of ispl in this setting as we do not use the capability of specifying actions and protocols in ispl .",
    "computation tree logic ( ctl ) @xcite and linear time temporal logic ( ltl ) @xcite are the most popular logics adopted in verification of transition systems to specify properties that a system under investigation may possess .",
    "ctl is a branching time logic , which considers all possibilities of future behaviour , while ltl only deals with one possible future behaviour at a time . in this section",
    ", we use ctl to formulate stability and inconsistency checks due to the efficient implementation of ctl model checking .",
    "but we also discuss the application of ltl when possible .",
    "ltl can be specified by the following grammar @xcite : @xmath154    ctl on the other hand is given by the extended grammar @xcite : @xmath155    both ctl and ltl are defined over paths in a transition system . given a transition system @xmath156 , a path @xmath157 is a ( finite or infinite ) sequence of states such that for each pair of adjacent states , there exists a transition in the system , i.e. , @xmath158 for all @xmath159 and @xmath160 for all @xmath161 .",
    "we denote the @xmath162-th state in the path @xmath163 , i.e. , @xmath164 , by @xmath165 .",
    "the satisfaction of ctl and ltl in @xmath99 is defined as follows .",
    "[ ctl_sat ] given a transition system @xmath166 and a state @xmath167 , the satisfaction for a ctl formula @xmath168 at state @xmath107 in @xmath169 , denoted by @xmath170 , is recursively defined as follows .    *",
    "@xmath171 iff @xmath172 ; * @xmath173 iff it is not the case that @xmath174 ; * @xmath175 iff @xmath176 and @xmath177 ; * @xmath178 iff there exists a path @xmath163 starting at @xmath107 such that @xmath179 . *",
    "@xmath180 iff there exists a path @xmath163 starting at @xmath107 such that @xmath181 for all @xmath182 ; * @xmath183 iff there exists a path @xmath163 starting at @xmath107 such that for some @xmath182 , @xmath184 ; * @xmath185 iff there exists a path @xmath163 starting at @xmath107 such that for some @xmath182 , @xmath186 and @xmath187 for all @xmath188 ; * @xmath189 iff for all paths @xmath163 starting at @xmath107 , we have @xmath179 . *",
    "@xmath190 iff for all paths @xmath163 starting at @xmath107 , we have @xmath181 for all @xmath182 ; * @xmath191 iff for all paths @xmath163 starting at @xmath107 , there exists @xmath182 such that @xmath184 ; * @xmath192 iff for all paths @xmath163 starting at @xmath107 , there exists @xmath182 such that @xmath186 and @xmath187 for all @xmath188 ;    [ ltl_sat ] given a transition system @xmath166 and a state @xmath167 , the satisfaction for a ltl formula @xmath168 at state @xmath107 in @xmath169 , denoted @xmath170 , is recursively defined as follows .    * @xmath171 iff @xmath172 ; * @xmath173 iff it is not the case that @xmath174 ; * @xmath175 iff @xmath176 and @xmath177 ; * @xmath193 iff for all paths @xmath163 starting at @xmath107 , we have @xmath179 . *",
    "@xmath194 iff for all paths @xmath163 starting at @xmath107 , we have @xmath181 for all @xmath182 ; * @xmath195 iff for all paths @xmath163 starting at @xmath107 , there exists @xmath182 such that @xmath184 ;",
    "* @xmath196 iff for all paths @xmath163 starting at @xmath107 , there exists @xmath182 such that @xmath186 and @xmath187 for all @xmath188 ;    when we verify whether a ctl / ltl formula @xmath168 holds on a model , we check if this formula is satisfied by all initial states , denoted by @xmath197 . in particular",
    ", when we say that an ltl @xmath168 holds in the model , every path from every initial state has to satisfy @xmath168 .",
    "more details of ctl and ltl , as well as the difference between them , can be found in  @xcite .",
    "[ thm : incons ] the first category of inconsistency can be checked by the following ctl formula @xmath198    if a system is inconsistent due to the first case , then there must exist a state that has two successor states such that a variable is evaluated to _ true _ in one successor state , and to _ false _ in the other .",
    "the ctl formula @xmath199 captures this scenario for variable @xmath125 .",
    "the negation @xmath200 excludes the occurrence of inconsistency caused by @xmath125 .",
    "operator @xmath201 guarantees that inconsistency does not occur in any states .",
    "note that it is not necessary to consider a case like @xmath202 for an _ unknown _ variable because it can not be assigned to @xmath5 during evolution .",
    "if the above formulae are evaluated to true , then the boolean evolution system is consistent .",
    "note that this category of inconsistency can not be checked by an ltl formula because ltl can only specify linear properties .",
    "however , a small modification would make ltl work again on checking consistency .",
    "lemma  [ thm : incons ] searches for occurrences of inconsistency by checking if two opposite values of a variable can be reached from one state .",
    "the following theorem focuses on looking for such a state to perform consistency checks .",
    "[ thm : incons1 ] checking the first category of inconsistency can be transformed into a reachability problem as follows .    1 .   for each pair of rules @xmath203 and @xmath204 ,",
    "check if @xmath205 and @xmath206 assign opposite values to the same boolean variable .",
    "if the answer is yes and @xmath207 , then we add a new atomic proposition @xmath208 that holds in states satisfying @xmath209 .",
    "2 .   let @xmath210 be the set of all newly added propositions in the previous step .",
    "the first category of inconsistency can be identified by the ctl formula @xmath211 or the ltl formula @xmath212    the system is consistent if formula  [ eqn : incons1_ctl ] or [ eqn : incons1_ltl ] is true .",
    "if a state satisfies a proposition @xmath213 , which is constructed as @xmath214 , then both guards @xmath215 and @xmath216 are satisfied in the state .",
    "thus , the corresponding rules @xmath217 and @xmath218 are enabled in the state .",
    "as these two rules set opposite values to a variable , inconsistency occurs in this state if it is reachable from an initial state .",
    "@xmath219 captures all states where inconsistency could happen , and @xmath220 and @xmath221 examine if any of these states can be reached from an initial state .",
    "note that @xmath222 and @xmath223 .",
    "although the second and the third cases are not needed in the relaxed inconsistency conditions , we still present the temporal logic properties for checking them .",
    "the second category of inconsistency can be checked by the following ctl formula @xmath224 or ltl formula @xmath225    if this case occurs , then there must exist a state @xmath107 that has a successor state @xmath226 such that a variable is evaluated to @xmath3 in @xmath107 and @xmath4 in @xmath226 , or @xmath4 in @xmath107 and @xmath3 in @xmath226 . the ctl formulas @xmath227 and @xmath228 ( @xmath229 ) capture this scenario for variable @xmath125 . the ltl formulas @xmath230 and @xmath231 have the same effect . the negation @xmath200 excludes the occurrence of inconsistency caused by @xmath125",
    ". operator @xmath201 ( or @xmath232 ) guarantees that inconsistency does not occur in any states .",
    "the third category of inconsistency can be checked in the same way over the _ unknown _ variables .",
    "[ thm : stability ] the stability problem can be checked by the following ctl formula @xmath233    or ltl formula @xmath234    if the above ltl or ctl formula is evaluated to true , then the boolean evolution system is stable .    in a stable system",
    ", every path leads to a stable state , where no _ unknown _ variable will change its value any more . therefore ,",
    "one of three cases @xmath235 , @xmath236 or @xmath237 for _ unknown _ variable @xmath125 holds in the stable state .",
    "the last case means that the _ unknown _ variable remains @xmath5 during the evolution .",
    "the _ known _ variables can not take value _",
    "unknown_. thus , we do not need to consider them being @xmath5 in the ltl formula .",
    "the operator @xmath221 specifies that this stable state will be reached eventually .",
    "the ctl formula can be reasoned in a similar way .      although theorem  [ thm : incons1 ] provides a simpler ctl / ltl formula than lemma  [ thm : incons ] , in practice , it can be improved further . in order to check if the formula @xmath238 is satisfied in a transition system @xmath156 by symbolic model checking , we need to compute the set of states satisfying the formula @xmath238 using a fixed - point computation .",
    "let @xmath239 represent the set of states satisfying @xmath168 .",
    "the fixed - point computation begins with a set @xmath240 and computes a sequence of sets such that @xmath241 until @xmath242 .",
    "the detailed algorithm is presented in algorithm  [ algo : ef ] .",
    "algorithm  [ algo : ef ] could be time - consuming for a large system .",
    "fortunately , we can utilise a characteristic of model checking to avoid the problem of checking @xmath220 .",
    "a model checker generates only reachable states , which can be reached from initial states , and perform model checking algorithms on the reachable states . to identify inconsistency ,",
    "showing the existence of a reachable state with two conflict successor states is sufficient .",
    "as model checkers only work on reachable states , the existence of a bad state can be converted into non - emptiness of the set of states satisfying @xmath210 defined in theorem  [ thm : incons1 ] , returned by a model checker .",
    "therefore , the fixed - point computation for @xmath220 can be avoided .",
    "indeed , checking existence of bad states can be integrated into the process of generation of reachable state space .",
    "once a bad state is found , the process can be aborted to give fast feedback to the programmer .    for a large system ,",
    "the ctl formula specified in lemma  [ thm : stability ] involves a large number of conjunction clauses @xmath243 or @xmath244 and each @xmath201 requires a computational expensive fixed - point computation , as @xmath245 .",
    "therefore , model checking this formula could be time consuming .",
    "the following theorem tells us that stability checking can be reduced to a reachability problem , which only asks for one fixed - point computation .",
    "[ thm : reachability ] stability in a consistent system @xmath246 can be checked in the following three steps .    1 .",
    "find the set @xmath55 of states that only have self - loop transitions , i.e. , @xmath247 ; 2 .",
    "find the set @xmath248 of states that can reach states in @xmath55 ; 3 .",
    "check if @xmath249 .",
    "if the answer is yes , then the system is stable if it is consistent .    from the definition of stability ,",
    "we know that a stable valuation corresponds to a state that only has self - loops , and vice versa . in a consistent system",
    ", a state can not enter a non - stable loop if it can reach a stable state .",
    "otherwise , there exists a state that has two successor states , which contradicts the assumption that the system is consistent .",
    "step 3 checks if there exists an initial state that can not reach a stable state .",
    "the existence of such a state means that the system contains a non - stable loop .      for instance",
    "the cudd library  @xcite can be used to manipulate bdds in mcmas .",
    "the first step can be implemented using the function `` cudd_xeqy '' in cudd , which constructs a bdd for the function @xmath250 for two sets of bdd variables @xmath153 and @xmath251 . when applied to the transition relation in the system",
    ", this function simply enforces that the successor state of a state @xmath107 is @xmath107 itself , i.e. , a self - loop",
    ". the second step can be achieved by the classic model checking algorithm for @xmath220 .",
    "the third step is done by checking if @xmath252 is a zero bdd , which means that the result from the set subtraction @xmath252 is empty .",
    "therefore , this algorithm runs more efficiently than model checking the long formula in lemma  [ thm : stability ] . in practice",
    ", this stability check can be combined with consistency checks . during the generation of the reachable state space",
    ", we check if the system is consistent using theorem  [ thm : incons1 ] .",
    "if the generation is not aborted due to the occurrence of inconsistent states , then a stability check is executed .",
    "a common question asked after a formula is model checked is whether a witness execution or counterexample can be generated to facilitate deep understanding of why the formula holds or does not hold in the system . in our situation",
    ", it is natural to ask the model checker to return all evolution traces that lead to inconsistency or instability .",
    "we will show how to compute traces in mcmas for inconsistency first and for instability afterwards .",
    "it is usually good in practice to generate the shortest traces for counterexamples / witness executions in order to decrease the difficulty of understanding them . to achieve this for our setting",
    ", we utilize the approach of construction of state space in mcmas . starting from the set of initial states @xmath130",
    ", mcmas can compute the state space in the following manner  @xcite .    in this algorithm , @xmath102 is the set of reachable states and @xmath253 , initialised as @xmath130 , is the set of states that their successor states need to be computed , which is done by the function @xmath254 . in each iteration",
    ", we compute the successors @xmath255 of @xmath253 , and remove from @xmath255 the states that have been processed before by @xmath256 .",
    "this iteration continues until no new states can be added to @xmath102 , i.e. , @xmath257 .",
    "we modify the state space generation algorithm to store every intermediate @xmath253 : in each iteration @xmath162 , we change @xmath253 to @xmath258 .",
    "the modified algorithm is shown in algorithm  [ algo : modified ] .",
    "[ algo : modified ]    [ thm : cex ] a shortest trace leading to an inconsistent state by enabling the rules @xmath259 and @xmath260 , can be achieved in the following steps .    1 .",
    "starting from @xmath261 , we test each @xmath258 to search for the smallest index @xmath136 such that @xmath262 .",
    "2 .   we pick up an arbitrary state @xmath263 from @xmath264 and compute its predecessor @xmath265 in @xmath266 by using the reversed transition relation @xmath267 such that @xmath268 .",
    "if @xmath263 has multiple predecessors , then we pick up an arbitrary one to be @xmath265 . in the same way",
    ", we compute a predecessor of @xmath265 in @xmath269 .",
    "this process continues until we find a state @xmath270 in @xmath271 , which is @xmath130 .    to find the shortest counterexamples for unstable loops , we need to identify all such loops first , and for each loop , we test each @xmath258 from @xmath261 if it contains a state in the loop , i.e. , if @xmath272 , where @xmath273 is the set of states in the loop .",
    "next we apply the second step in theorem  [ thm : cex ] to generate the shortest trace .",
    "now we focus on how to find all unstable loops efficiently .",
    "[ lem : scc ] given a consistent system , none of the unstable loops interfere with each other .",
    "if the conjunction of two loops is not empty , then there exists a state such that it has two outgoing transitions , one in each loop .",
    "hence , this state leads to the occurrence of inconsistency .    due to lemma",
    "[ lem : scc ] , finding unstable loops is equivalent to finding non - trivial strongly connected components ( sccs ) when the system is consistent .",
    "there are several scc identification algorithms in the literature working on bdd representation of state spaces  @xcite .",
    "the more efficient one was reported in  @xcite .",
    "but before we apply these algorithms , we could remove states that can not reach any unstable loops from the state space in order to speed up the computation .",
    "those states are identified as @xmath248 in the second step of stability checking in theorem  [ thm : stability ] .",
    "in this section we illustrate the use of our consistency and stability checking techniques on an example scenario which could occur to a household robot .",
    "the robot with arms observes an object rolling across a table .",
    "it needs to decide whether to stop it or allow it to drop off from the table .",
    "the object can be a glass or a light effect",
    ". it would be unwise to stop the object if it is the latter case .",
    "the robot may resort to more accurate sensors to decide how to react .",
    "the model is formalized in a boolean evolution system based on the perception structure in fig .",
    "[ rescyc ] .    1",
    ".   feasible sensing possibilities ( @xmath36 ) are : * @xmath274 : object o rolls across table * @xmath275 : senses that object o is rolling across table * @xmath276 : sensed o but there is no real object o * @xmath277 : derived that light effect moving across table , there was no real object o sensed + in @xmath36 , the uncertain sensing events ( @xmath278 ) are @xmath275 and @xmath277 .",
    "action possibilities ( @xmath11 ) are : * @xmath279 : stop rolling object by arm * @xmath280 : remain idle 3 .",
    "future events predicted ( @xmath12 ) are : * @xmath281 : object o falls * @xmath282 : object o breaks * @xmath283 : object o is useless * @xmath284 : handling of object o * @xmath285 : the robot has made the correct observation * @xmath286 : the robot chooses the correct action 4 .   naive physics rules ( @xmath8 ) are : * @xmath287 : the object will fall if not stopped * @xmath288 : if the object falls it will break * @xmath289 : if object is stopped it will not fall * @xmath290 : if object will not fall then it will not break 5 .",
    "general rules - values and moral consequences rules ( @xmath14 ) are : * @xmath291 * @xmath292 * @xmath293 * @xmath294 * @xmath295 * @xmath296    the robot starts with a simple but fast reasoning cycle by considering each action individually using observation only . the criteria for choosing the correct action is to guarantee the following goals .",
    "* @xmath297 * @xmath298 * @xmath299    when only one of events @xmath274 and @xmath276 is true , the robot can make its decision easily .",
    "however , it is difficult to do so when both events are true .",
    "the reasoning process is as follows .    1",
    ".   _ evaluation of action choice 1 _ : goals + @xmath280 + this choice results that @xmath286 becomes false .",
    "evaluation of action choice 2 _ : goals + @xmath279 + this results inconsistency in the reasoning process as shown in fig .",
    "[ fig - example ] , which demonstrates the evolution of the value of @xmath300 .    to resolve the inconsistency",
    ", the robot needs to acquire information from more sensors , which would instantiate the two sensing events @xmath275 and @xmath277 in @xmath278 with two extra physical rules .    *",
    "@xmath301 * @xmath302    if these two sensing events do not become true simultaneously , then the robot can make the correct decision .",
    "our consistency and stability checking techniques of this kind can be used in both offline and online modes . in the online mode ,",
    "counterexamples are used to assist the system to acquire more information , i.e. , fixing the uncertain sensing events , or adjusting the possible actions that can be take , in order to solve inconsistency or instability problems in a consistency resolution cycle .",
    "our case study demonstrates an application of the online mode .",
    "[ rescyc ] illustrates the consistency resolution cycle that can be implemented in agent programs .    in the offline mode",
    ", users can apply the techniques to their rule - based reasoning system to check consistency and stability .",
    "if a problem is found , users can revise their system using generated counterexamples as a guidance .",
    "for example , if we add the following extra general rules in the case study ,    * @xmath303 * @xmath304    the robot could be trapped in a circular reasoning process when @xmath274 is true land @xmath276 is false because @xmath305 and @xmath306 this circular reasoning process can be captured by our stability check .",
    "we have integrated the algorithms in theorem  [ thm : incons1 ] and  [ thm : reachability ] into the model checker mcmas  @xcite .",
    "the implementation slightly deviated from theorem  [ thm : incons1 ] in order to maximize the utility of the internal encoding of the transition relation in mcmas . instead of finding all pair of conflicting rules",
    ", we built a single bdd for each variable @xmath307 .",
    "we first collect all rules @xmath308 that set @xmath307 to @xmath3 , and all rules @xmath309 that set @xmath307 to @xmath4 .",
    "second , we generate a bdd @xmath310 representing @xmath311 if the bdd is not empty , then there exists a pair of conflicting rules that might be enabled simultaneously . searching for a bad state",
    "is done by testing the conjunction of @xmath310 and @xmath102 , the set of reachable states .    to demonstrate their performance , we applied them to the following example , where @xmath312 and @xmath313 . in the experiment , we fixed @xmath314 to 32 , and generated a series of models by replicating the group of variables @xmath315 . in the largest model ,",
    "this group has ten copies , i.e. , @xmath136 ranges from @xmath91 to @xmath316 , which means the total number of variables is @xmath317 .",
    "each variable in @xmath64 requires one bdd variable to encode , as one bdd variable can represent two values 0 and 1 , perfectly matching boolean values @xmath4 and @xmath3 .",
    "each variable in @xmath65 needs two bdd variables because it has three values .",
    "therefore , the total number of bdd variables in the largest model is 383 .",
    "* example .",
    "* +    @xmath318    @xmath319    the experimental results are listed in table  [ table - exp ] . for each model",
    ", we present the number of variables and corresponding bdd variables in parentheses , as well as the number of reachable states . the time ( in second ) spent on checking consistency and stability via the ctl formulae  [ eqn : incons ] and  [ eqn : ctl ]",
    "are shown in the two columns in the middle , and the time for the direct algorithms in theorem  [ thm : incons1 ] and  [ thm : reachability ] are given in the last two columns .",
    "the results clearly demonstrates the huge advantage of using our stability checking algorithm .",
    "the performance of our consistency checking algorithm is also excellent , given the fact that the ctl formula  [ eqn : incons ] is quite efficient already .",
    "note that the time spent on building bdd @xmath310 for each variable is shown to be below 1ms in the penultimate column of the table .",
    ".[table - exp ] experimental results .",
    "[ cols=\"^ , > , > , > , > , > \" , ]",
    "although synchronous semantics have been applied broadly in practice , a differently semantics , _ interleaving semantics _ , still finds its usefulness in case of limited processing power .",
    "interleaving means that only one enabled rule , which is usually chosen randomly , is processed at a time .",
    "the new valuation @xmath74 under interleaving semantics is the result of applying a rule @xmath320 in @xmath75 to @xmath69 .",
    "the rule @xmath320 is chosen non - deterministically .",
    "that is , every new value of @xmath71 in @xmath74 is defined as follows .",
    "@xmath321    under the relaxed inconsistency conditions ,",
    "a system is guaranteed to be consistent , if at any given time , only one rule is processed .",
    "therefore , the first inconsistent condition is not satisfied any more .",
    "however , the interleaving semantics possesses different characteristics during stability checking .",
    "a stable system under the synchronous semantics may become unstable .",
    "let us re - examine example 2 using the interleaving semantics .",
    "we can construct a path that visits unstable states as follows . for valuation @xmath97",
    ", we have @xmath322 . the infinite loop @xmath323 makes the system unstable .",
    "however , the infinite loop is quite special in that the rule @xmath324 is enabled infinitely often in state @xmath325 , which is the beginning of the unstable loop . in practice , such infinite loops rarely happen because of randomness of choice .",
    "once this rule is executed , the unstable loop is interrupted , and the system becomes stable .",
    "this observation leads to the introduction of fairness into stability checking .",
    "fairness  @xcite has been studied and applied to many temporal logic - based verification , including both ctl and ltl .",
    "various types of fairness constraints have been brought up . among them ,",
    "the most popular ones are _ unconditional _ , _ strong _ and _ weak _ fairness . in this section ,",
    "_ strong _ fairness is sufficient to exclude the above unrealistic / unfair paths .",
    "strong fairness under interleaving semantics requires that , in every infinite path , an evolution rule has to be executed infinitely often if it is enabled infinitely often . for transition systems ,",
    "strong fairness is composed of a set of fairness constraints , written as @xmath326 where each constraints @xmath327 specifies that if @xmath328 occurs infinitely often , then @xmath329 has to occurs infinitely often as well .",
    "strong fairness rules out unrealistic evolution paths , where some enabled rules are consistently ignored .",
    "therefore , it allows more systems evaluated as stable .",
    "for example 2 , we only need one fairness constraint : @xmath330 this example suggests that the generation of a fairness constraint from a rule can be straightforward , which can be achieved by following the syntactic form of the rule",
    ".    however , strong fairness still can not prevent some stable system under synchronous semantics from being unstable .",
    "the following example demonstrates an unstable system under strong fairness . in this example , @xmath88 and @xmath331    * example 3 .",
    "* @xmath332    for the initial valuation @xmath97 , we have @xmath333 .",
    "the unstable loop @xmath334 can not be broken because the only rule that can break it , i.e. , @xmath335 is disabled in state @xmath336 .    enforcing strong fairness in the verification of ctl formulas",
    "can be transformed into finding strongly connected components ( sccs ) , which in turn can be implemented using graphic algorithms  @xcite .",
    "as we do not consider inconsistency for the interleaving semantics , the stability can be checked by ltl model checkers , such as spin  @xcite and nusmv .",
    "the verification of an ltl formula @xmath337 under strong fairness can be achieved directly by checking a combined ltl formula @xmath338 where @xmath339 is of the form of formula ( [ eqn : fair ] ) . for stability checking the @xmath337 is taken as in  ( [ eqn : ltl ] ) .",
    "note that the algorithm in theorem  [ thm : reachability ] does not work here because multiple successor states do not mean inconsistency any more .",
    "spin uses explicit model checking techniquesfor the verification .",
    "it requires that every initial valuation has to be enumerated explicitly , which is very inefficient .",
    "nusmv adopts the method in  @xcite to check ltl formulae symbolically via bdds , which can be more efficient for our purpose .",
    "now the question is how we identify rules that need to be guaranteed for execution by strong fairness .",
    "human guidance on the selection of rules would be ideal . when it is not available , we need to find a solution to allow automatic selection .",
    "a simple method is to put all rules under the protection of fairness .",
    "this solution does not request the modification of an existing model checker .",
    "however , it only works for a small rule set",
    ". a large number of rules would render @xmath339 a large ltl formula containing equal number of constraints as the number of rules .",
    "an alternative solution utilises a sequence of verification to search for a fair unstable loop .",
    "starting with no fairness constraints , we check formula  ( [ eqn : ltl ] ) solely on the converted transition system .",
    "if the result is @xmath4 , which means the system may be unstable , then we ask the model checker to generate a counterexample , i.e. an unstable loop .",
    "we examine each state in the loop to look for enabled rules that are never executed in the loop .",
    "if no such rule is found , then the system is unstable under strong fairness .",
    "otherwise , we put the unfairly treated rules into @xmath339 and re - start the verification .",
    "this process is carried out iteratively until the system is proven to be stable or unstable under strong fairness .",
    "although the idea of this solution is not complex , its implementation requires to build an extension of a model checker , e.g. , nusmv , which is not a trivial task .",
    "further , its performance would be degraded when the number of iterations increases .",
    "this paper has solved the problem of efficiency for logical consistency checks of robots by adopting symbolic model checking based on binary decision diagrams .",
    "in addition to specifying stability and consistency as ctl and ltl formulas , also efficient symbolic algorithms have been applied to speed up consistency and stability checking .",
    "timely decision making by robots can be vital in many safety critical applications .",
    "the most basic task they need to check is the consistency of their assumptions and their rules .",
    "speed of computation hence affects quality and safety of robots . as a first step towards application of our approach ,",
    "we have embedded it within the framework lisa  @xcite for reasoning of robots .",
    "further direct use of the techniques is in rule - based reasoning systems before they are deployed on robots .",
    "the counter - examples , which can generated by the techniques presented , can demonstrate the reasons for possible violation , which can help software developers revising their designs .",
    "sometimes it can be time - consuming to modify the design of a complex system , possibly the violation is tolerable or is very rare during run - time . in these cases",
    "counter - examples can be used as a guide to correct the reasoning of a robot while in action .",
    "future work in this research area can target the implementation of our approach in practical programming  @xcite , and to aid finding solutions to making inconsistent / unstable systems consistent and stable .",
    "based on the results an iterative design process can be defined to enable a programmer to control an agent s decision making .",
    "our plans are also to integrate consistency checks in lisa  @xcite into the control code of unmanned aerial vehicles ( uavs ) and unmanned ground vehicles ( ugvs ) for practical application .",
    "this work was supported by the epsrc project ep / j011894/2 .",
    "s.  maghsoudi , i.  watson , epistemic logic and planning , in : proceedings of knowledge - based intelligent information and engineering systems ( kes04 ) , vol .",
    "3214 of lecture notes in computer science , springer , 2004 , pp . 3645 .",
    "m.  shanahan , m.  witkowski , high - level robot control through logic , in : proceedings of intelligent agents vii agent theories architectures and languages , vol .",
    "1986 of lecture notes in computer science , springer , 2001 , pp . 104121 .",
    "m.  singh , d.r.parhi , s.bhowmik , s.k.kashyap , intelligent controller for mobile robot : fuzzy logic approach , in : proceedings of international association for computer methods and advances in geomechanics ( iacmag08 ) , 2008 , pp .",
    "17551762 .    c.  r. torres , j.  m. abe , g.  lambert - torres , j.  i. d.  s. filho , h.  g. martins , autonomous mobile robot emmy iii , in : proceedings of new advances in intelligent decision technologies , vol .",
    "199 of studies in computational intelligence , springer , 2009 , pp",
    ". 317327 .",
    "l.  mihaylova , a.  carmi , f.  septier , a.  gning , s.  k. pang , s.  j. godsill , overview of bayesian sequential monte carlo methods for group and extended object tracking , digital signal processing 25 ( 2014 ) 116 .",
    "v.  morreale , s.  bonura , g.  francaviglia , m.  puccio , f.  centineo , g.  cammarata , m.  cossentino , s.  gaglio , practionist : a framework for developing bdi agent systems , in : proceedings of the 7th woa 2006 workshop , from objects to agents , vol .",
    "204 of ceur workshop proceedings , ceur-ws.org , 2006 , pp .",
    "187194 .",
    "a.  cimatti , e.  m. clarke , e.  giunchiglia , f.  giunchiglia , m.  pistore , m.  roveri , r.  sebastiani , a.  tacchella , nusmv 2 : an opensource tool for symbolic model checking , in : proceedings of cav 2002 , vol .",
    "2404 of lecture notes in computer science , springer , 2002 , pp . 359364 ."
  ],
  "abstract_text": [
    "<S> most autonomous robotic agents use logic inference to keep themselves to safe and permitted behaviour . given a set of rules , </S>",
    "<S> it is important that the robot is able to establish the consistency between its rules , its perception - based beliefs , its planned actions and their consequences . </S>",
    "<S> this paper investigates how a robotic agent can use model checking to examine the consistency of its rules , beliefs and actions . a rule set is modelled by a boolean evolution system with synchronous semantics , which can be translated into a labelled transition system ( lts ) . </S>",
    "<S> it is proven that stability and consistency can be formulated as computation tree logic ( ctl ) and linear temporal logic ( ltl ) properties . </S>",
    "<S> two new algorithms are presented to perform realtime consistency and stability checks respectively . </S>",
    "<S> their implementation provides us a computational tool , which can form the basis of efficient consistency checks on - board robots . </S>"
  ]
}