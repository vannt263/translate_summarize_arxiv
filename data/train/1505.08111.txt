{
  "article_text": [
    "let @xmath0 be a numerical semigroup , that is , a cofinite submonoid of @xmath1 , where @xmath2 stands for the set of nonnegative integers .",
    "an integer @xmath3 is said to be the _ frobenius number _ of @xmath0 ( respectively , a _ pseudo - frobenius number _ of @xmath0 ) if @xmath4 and @xmath5 , for all @xmath6 ( respectively , for all @xmath7 ) .    given a positive integer @xmath8 , there exist numerical semigroups whose frobenius number is @xmath8 .",
    "one example of such a semigroup is the semigroup @xmath9 containing @xmath10 and all the integers greater than @xmath8",
    ". there are several algorithms to compute all the numerical semigroups with a given frobenius number ( the fastest we know is based on @xcite ) .",
    "we denote by @xmath11 the frobenius number of @xmath0 and by @xmath12 the set of pseudo - frobenius numbers of @xmath0 .",
    "the cardinality of @xmath12 is said to be the _ type _ of @xmath0 and is denoted by @xmath13 .",
    "a positive integer that does not belong to @xmath0 is said to be a _ gap _ of @xmath0 and an element of @xmath0 that is not greater than @xmath14 is said to be a _ small element _ of @xmath0 . to denote the set @xmath15 of gaps of @xmath0 we use @xmath16 and to denote the set of small elements of @xmath0 we use @xmath17 .",
    "since a set of gaps must contain the divisors of all its members and a set of small elements must contain all multiples of its members ( up to its maximum ) , it is clear that there are sets of positive integers that can not be the set of gaps or the set of small elements of a numerical semigroup .",
    "the set of gaps , as well as the set of small elements , completely determines the semigroup .",
    "observe that when some elements or some gaps are known , others may be forced .",
    "for instance , a gap forces all its divisors to be gaps .",
    "let @xmath18 be a positive integer and let @xmath19 be a set of positive integers .",
    "denote by @xmath20 the set of numerical semigroups whose set of pseudo - frobenius numbers is @xmath21 .",
    "when @xmath22 , @xmath20 may clearly be empty .",
    "moreover , when non - empty , it is finite .",
    "in fact , @xmath20 consists of semigroups whose frobenius numbers is the maximum of @xmath21 .",
    "some questions arise naturally . among them",
    ", we can consider the following .",
    "[ quest : existence ] find conditions on the set @xmath21  that ensure that @xmath23 .",
    "[ quest : compute_all ] find an algorithm to compute @xmath20 .",
    "both questions have been solved for the case that the set @xmath21  consists of a single element ( which must be the frobenius number of a numerical semigroup ; symmetric numerical semigroups ) or when @xmath21  consists on an even positive integer @xmath8 and @xmath24 ( pseudo - symmetric numerical semigroups ) , see @xcite .",
    "moreover , question  [ quest : existence ] was solved by robles - prez and rosales  @xcite in the case where @xmath21  consists of @xmath25 elements ( not necessarily of the form @xmath26 ) .",
    "the set @xmath20 can be computed by filtering those semigroups that have @xmath21  as set of pseudo - frobenius numbers , from the numerical semigroups whose frobenius number is the maximum of @xmath21  ( cf .",
    "example  [ example : first ] ) .",
    "due , in part , to the possibly huge number of semigroups with a given frobenius number , this is a rather slow procedure and we consider it far from being a satisfactory answer to question  [ quest : compute_all ] .",
    "irreducible numerical semigroups with odd frobenius number correspond with symmetric numerical semigroups , and those with even frobenius number with pseudo - symmetric ( see for instance ( * ? ? ?",
    "* chapter 3 ) ) .",
    "bresinsky proved in @xcite that symmetric numerical semigroups with embedding dimension four have minimal presentations of cardinality 5 or 3 ( complete intersections ) .",
    "symmetry of a numerical semigroup @xmath0 translates to having @xmath27 as set of pseudo - frobenius numbers .",
    "later komeda , @xcite , was able to prove the same result for pseudo - symmetric numerical semigroups ( though he used different terminology for this property ; in this setting 3 does not occur since pseudo - symmetric are never complete intersections ) .",
    "a numerical semigroup @xmath0 is pseudo - symmetric if its set of pseudo - frobenius numbers is @xmath28",
    ". it should be interesting to see the relationship with the type and the cardinality of a minimal presentation , and thus having tools to find semigroups with given sets of pseudo - frobenius numbers becomes helpful .",
    "watanabe and his students nari and numata are making some progress in the study of this relationship .",
    "we present two different procedures to determine the set of all numerical semigroups with a given set of pseudo - frobenius numbers .",
    "one exploits the idea of irreducible numerical semigroup . from each irreducible numerical semigroup",
    "we start removing minimal generators with certain properties to build a tree whose leafs are the semigroups we are looking for .",
    "the other approach is based on determining the elements and gaps of any numerical semigroup with the given set of pseudo - frobenius numbers , obtaining in this way a list of `` free '' integers .",
    "we then construct a binary tree in which branches correspond to assuming that these integers are either gaps or elements .",
    "we start this work with some generalities and basic or well known results and connections with the ` gap `  @xcite package ` numericalsgps `  @xcite ( sections  [ sec : generalities ] and  [ sec : connections_numericalsgps ] ) .",
    "then we describe a procedure to compute forced integers ( sections  [ sec : preliminary_forced_ints ] and  [ sec : computing_forced_ints ] ) . as computing forced integers",
    "is fast and leads frequently to the conclusion that there exists no semigroup fulfilling the condition of having the given set as set of pseudo - frobenius numbers , this approach benefits from the work done in the preceding sections .",
    "the following section of the paper is devoted to the above - mentioned approach of constructing a tree with nodes lists of integers , which turns out to be faster most of the times than the one based on irreducible numerical semigroups .",
    "nevertheless , besides being useful to compare results , the method using irreducible numerical semigroups is of theoretical importance so we decided to keep it , and it is given in appendix  [ sec : computing_arbitrary_type ] .",
    "the next section describes an algorithm that ( increasing the number of attempts , if necessary ) returns one numerical semigroup with the given set of pseudo - frobenius numbers , when such a semigroup exists .",
    "although it may be necessary to increase the number of attempts , usually does not require the computation of all the semigroups fulfilling the condition and is reasonably fast in practice ( section  [ sec : random ] ) .",
    "we give pseudo - code for the various algorithms that are used in the approach of lists of free integers .",
    "the pseudo - code given has an immediate translation to the language , which is the programming language we used to implement these algorithms .",
    "we observe that it is a high level programming language .",
    "note that we take advantage of the existence of the package for computing with numerical semigroups .",
    "the names used for the functions described here are slightly different from the ones used in the package , since there longer names are required to be accurate with the variable names policy in .",
    "essentially , it will be a matter of adding a suffix to the names used for the package .",
    "many examples are given throughout the paper , some to illustrate the methods proposed , while others are included to motivate the options followed .",
    "in some of the examples we show the output obtained in a session . these usually correspond to examples that are not suitable to a full computation just using a pencil and some paper ; furthermore , indicative running times , as given by , are shown ( mainly in section  [ sec : running_times ] ) .",
    "a new version of the package , including implementations of the algorithms developed in the present work , is released at the same time this work is made public .",
    "the implementations can be checked ( the software in question is open source ; see the links in the references ) and can be used for testing examples .",
    "throughout the paper we will consider often a set @xmath29 of positive integers",
    ". we will usually require it to be ordered , that is , we will assume that @xmath30 . for convenience , we write @xmath31 in this case .",
    "we denote by the maximum of @xmath21  and by @xmath32  the cardinality of @xmath21 .",
    "note that if @xmath33 , then @xmath34 and @xmath35 .",
    "we say that an integer @xmath36 is a _",
    "gap forced by _",
    "@xmath21  or a @xmath21-_forced gap _ if @xmath36 is a gap of all the numerical semigroups having @xmath21  as set of pseudo - frobenius numbers .",
    "in particular , if there is no semigroup with @xmath21  as set of pseudo - frobenius numbers , then every nonnegative integer is a gap forced by @xmath21 .",
    "we use the notation @xmath37 to denote the set of @xmath21-forced gaps . in symbols : @xmath38 .    in a similar way",
    ", we say that an integer @xmath36 is an _ element forced by _",
    "@xmath21  or a @xmath21-_forced element _ if @xmath36 is an element of all semigroups in @xmath20 .",
    "we use the notation @xmath39 to denote the set of ( small ) @xmath21-forced elements . in symbols : @xmath40 .",
    "note also that if @xmath41 , then @xmath42 .",
    "the union of the @xmath21-forced gaps and @xmath21-forced elements is designated by @xmath21-_forced integers_.    the following is a simple , but crucial observation .",
    "[ prop : intersection_gaps_elements ] @xmath23 if and only if @xmath43 .    if @xmath44 , then all nonnegative integers are at the same time gaps and elements forced by @xmath21 .",
    "conversely , assume that @xmath23 and let @xmath33",
    ". then @xmath45 .",
    "frequently the prefix @xmath21  is understood and we will abbreviate by saying just _ forced gap _ , _ forced element _ or _",
    "forced integer_.    let @xmath46 and @xmath47 be , respectively , sets of forced gaps and forced elements .",
    "the elements @xmath48 that do not belong to @xmath49 are said to be _ free integers for _ @xmath50 . when the pair @xmath50 is understood , we simply call _ free integer _ to a free integer for @xmath50 .      the partial order @xmath51 induced by the numerical semigroup @xmath0 on the integers is defined as follows : @xmath52 if and only if @xmath53 .",
    "the following result is well known and will be used several times throughout this paper .",
    "( * ? ? ? * lemma  2.19)[lemma : maximals ] let @xmath0 be a numerical semigroup .",
    "then    a.   @xmath54 , b.   @xmath55 .",
    "it is well known that the type of a numerical semigroup @xmath0 is upper bounded by the least positive element belonging to @xmath0 , which is known as the _ multiplicity _ of @xmath0 and it is denoted by @xmath56 .",
    "* corollary  2.23)[lemma : type_multiplicity ] let @xmath0 be a numerical semigroup",
    ". then @xmath57 .",
    "the maximality of the pseudo - frobenius numbers of @xmath0 with respect to @xmath51 means that they are incomparable with respect to this ordering .",
    "in particular , the difference of any two distinct pseudo - frobenius numbers does not belong to @xmath0 , that is , @xmath58 this is the underlying idea of the next result .",
    "[ lemma : pseudo - comb - pseudo ] let @xmath0 be a numerical semigroup and suppose that @xmath59 , with @xmath22 .",
    "let @xmath60 and @xmath61 with @xmath62",
    ". then @xmath63 .",
    "assume that @xmath64 for some @xmath65 .",
    "we proceed by induction on @xmath66 . the case @xmath67 is given by ( [ eq : differences ] ) .",
    "assume that the result holds for @xmath68 and let us prove it for @xmath66 .",
    "if @xmath69 , then @xmath70 by definition of pseudo - frobenius number .",
    "it follows that @xmath71 , contradicting the induction hypothesis .",
    "[ rem : type_multiplicity ] lemma  [ lemma : type_multiplicity ] implies that @xmath72 .",
    "hence @xmath73 .",
    "as the pseudo - frobenius numbers of @xmath0 are gaps of @xmath0 and any positive divisor of a gap must be a gap also , we conclude that the set of divisors of @xmath74 consists entirely of gaps of @xmath0 .",
    "consider the set @xmath75 and denote by @xmath76 the set of its divisors ( as we are only considering positive divisors , in what follows we will not include this adjective ) .",
    "if @xmath0 is a numerical semigroup such that @xmath77 , we deduce that @xmath78 .",
    "we have proved the following result for the case where there is a numerical semigroup @xmath0 such that @xmath77 .",
    "if no such semigroup exists , then @xmath79 and the result trivially holds .",
    "[ cor : starting_forced_gaps ] let @xmath80 be a set of positive integers",
    ". then @xmath81 .",
    "we use the terminology _ starting forced gap for _ @xmath21  to designate any element of @xmath76 , since @xmath76 is the set we start with when we are looking for forced gaps . in subsection",
    "[ subsec : forced_gaps_pseudo_code ] we provide pseudo - code for a function to compute starting forced gaps .",
    "let @xmath22 be an integer and let @xmath82 be a set of positive integers .",
    "[ lemma : naive_condition ] let @xmath0 be a numerical semigroup such that @xmath77 .",
    "let @xmath83 and @xmath84 with @xmath62 .",
    "then there exists @xmath85 such that @xmath86 .",
    "lemma  [ lemma : pseudo - comb - pseudo ] assures that @xmath87 .",
    "the conclusion follows from lemma  [ lemma : maximals ] .    by choosing @xmath88 in the above result",
    ", there exists @xmath89 such that @xmath90 and @xmath91 .",
    "( note that @xmath92 would imply @xmath93 , which is impossible . )",
    "but then @xmath94 , since @xmath95 for all @xmath96 . we have thus proved the following corollary .",
    "[ cor : naive_condition_g1 ] let @xmath0 be a numerical semigroup such that @xmath77 .",
    "then @xmath97 .",
    "the computational cost of testing the condition @xmath97 obtained in corollary  [ cor : naive_condition_g1 ] is negligible and should be made before calling any procedure to compute @xmath20 , avoiding in many cases an extra effort that would lead to the empty set .",
    "other conditions of low computational cost would also be useful . since @xmath94",
    ", one could be tempted to ask whether replacing @xmath98 by @xmath99 one must have @xmath100 ( since @xmath101 consists of gaps ) .",
    "the following example serves to rule out this one that seems to be a natural attempt .",
    "let @xmath102 .",
    "one can check easily that @xmath103 .",
    "for @xmath104 , we have @xmath105 .",
    "later , in subsection  [ subsec : condition_based_on_forced_integers ] , we give an extra condition , which is based on forced integers .",
    "when developing the present algorithms we had one implementation in mind . as already referred , it was to be made in the programming language , benefiting also of the package .",
    "in fact the implementation accompanied the development of the algorithms , with mutual benefits .    to understand the paper no previous familiarity with is assumed .",
    "we give some examples to get the familiarity needed to fully understand the pseudo - code .",
    "many of the terms used for the pseudo - code presented are borrowed from the programming language , which is a high level one .",
    "the terms _ union , length , difference _ are used with the meaning they have in , which is clear .    like what is done in , for an unary function that applied to an argument",
    "@xmath106 returns an expression @xmath107 , we write @xmath108 this shorthand for writing a function is used in our pseudo - code .",
    "next we briefly explain the meaning of some of the terms used . for a not so brief explanation , complete definitions and plenty of examples ,",
    "s manual should be consulted .",
    "here @xmath109 is a list ( of integers or of numerical semigroups ) and @xmath110 is an unary function ( that applies to the objects in @xmath109 ) .",
    "* @xmath111 returns a new list @xmath112 of the same length as @xmath109 such that @xmath113 = func(list[i])$ ] . *",
    "@xmath114 returns a new list that contains those elements of @xmath109 for which @xmath110 returns _ true_.",
    "the order of the elements in the result is the same as the order of the corresponding elements of this list .",
    "* one can use @xmath115 ( which is a synonym of @xmath116 ( `` strictly sorted list '' ) ) to get a list that is duplicate free and sorted ( for some order ) .",
    "* @xmath117 adds the element @xmath118 to the set @xmath109 . *",
    "@xmath119 returns the first element of @xmath109 for which the unary function @xmath110 returns _",
    "true_. if func returns false for all elements of list , then @xmath120 returns _ fail_. * @xmath121 tests whether @xmath110 returns _ true _ for all elements in @xmath109 . * @xmath122 tests whether @xmath110 returns _ true _ for at least one element in @xmath109 . *",
    "@xmath123 detects if the argument is an interval of integers .",
    "we also use the following abbreviations .",
    "let @xmath124 be a list of integers and @xmath125 a list of positive integers .",
    "* ` posint(x ) ` , an abbreviation of ` filtered(x , isposint ) ` , returns the positive integers of @xmath124 . * ` divisors(p ) ` , an abbreviation of ` union(list(p , divisorsint ) ) ` , returns the divisors of the elements of @xmath125 : it first computes the lists of divisors for each element in ` p ` , and then takes the union of all of them .",
    "the package also influences our pseudo - code . in some cases we use directly the names of the available functions , but in some cases we use shorthands , which are intended to turn the pseudo - code more readable .",
    "one of the functions we use is , which , for a given set @xmath124 of positive integers returns _ true _ in case there exists a numerical semigroup @xmath0 such that @xmath126 , and returns _ false _ otherwise .    the functions to produce numerical semigroups used here are , which is used when generators are given , and , which , for an input @xmath124 , returns a numerical semigroup whose set of gaps is @xmath124 , when such a semigroup exists .    as a shorthand for @xmath127 , which gives the elements of the numerical semigroup @xmath0 that are nor greater than @xmath14 , we use simply , which agrees with the notation already introduced .",
    "` closure(elts , frob ) ` is a shorthand for    ` numericalsemigroup(union(elts,[frob+1 .. frob+minimum(elts ) ] ) ) `    which gives the least numerical semigroup containing the set @xmath128 of positive integers and having the largest possible frobenius number not greater than @xmath129 .",
    "note that the minimum of @xmath128 is greater than or equal to the multiplicity of the semigroup .",
    "therefore , the union considered ensures that the semigroup contains all integers that are greater than the number @xmath129 given ( aiming to be an upper bound for the frobenius number of the semigroup constructed , although in cases where the elements @xmath128 define a numerical semigroup , it may have smaller frobenius number ) .",
    "as in , comments start with the character @xmath130 .    as an example on how we will present function / algorithms in this manuscript , we write the function .",
    "+   + ( ( , [ + 1 .. + ( ( ) ) ] ) ) ;    the following example is just a session that is intended to illustrate how to compute the set @xmath20 by filtering those semigroups that have @xmath21  as set of pseudo - frobenius numbers , from the numerical semigroups whose frobenius number is the maximum of @xmath21 .",
    "this process was mentioned in the introduction .    throughout the examples",
    ", we use a simple way provided by to give a rough idea of the time spent : ` time ` is a global variable that stores the time in milliseconds the last command took .",
    "[ example : first ] we illustrate how to compute the set of numerical semigroups having @xmath131 as set of pseudo - frobenius numbers .",
    "double semicolon in inhibits the output .    .... gap > pf : = [ 19,29 ] ; ; gap > nsf29 : = numericalsemigroupswithfrobeniusnumber(29);;time ; 31372 gap > length(nsf29 ) ; 34903 gap > nspf1929 : = filtered(nsf29 , s - > pseudofrobeniusofnumericalsemigroup(s ) = pf ) ; ; gap > time ; 2540 gap > set(nspf1929,minimalgeneratingsystem ) ;                           [ [ 3 , 22 , 32 ] , [ 6 , 9 , 16 , 26 ] , [ 7 , 9 , 17 ] , [ 8 , 9 , 14 ] , [ 8 , 9 , 15 , 22 , 28 ] ,   [ 9 , 12 , 13 , 14 ] , [ 9 , 12 , 13 , 15 , 23 ] , [ 9 , 12 , 14 , 16 , 22 ] ,   [ 9 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 9 , 13 , 14 , 17 , 21 , 24 , 25 ] ,   [ 9 , 13 , 15 , 17 , 21 , 23 , 25 ] , [ 9 , 14 , 16 , 17 , 21 , 22 , 24 ] ,   [ 9 , 15 , 16 , 17 , 21 , 22 , 23 , 28 ] ] ....    prior to the obtention of the procedures that are the object of study of the present paper , we got the necessary insight through detailed analysis of many examples with @xmath21  consisting of small numbers ( less than @xmath132 , say ) .",
    "example  [ example : first ] illustrates that this can be easily done by using the package . when @xmath21  consists of small numbers the time spent is acceptable .",
    "the implementation of our algorithm ( available in version  0.99 of the package ) is much faster .",
    "it is even faster than just filtering among the numerical semigroups with a given set of pseudo - frobenius numbers .",
    "[ example : second ] to illustrate , we continue the session started in example  [ example : first ] .",
    ".... gap > new : = numericalsemigroupswithpseudofrobeniusnumbers(pf);;time ; 29 gap > set(new , minimalgeneratingsystem)=set(nspf1929,minimalgeneratingsystem ) ; true ....",
    "visualization of images obtained by using the  @xcite package have also helped us to improve our understanding of the problem and to get the necessary intuition .    the production of figure  [ fig : pfs_19_29 ] takes less than two minutes in our laptop ( using and packages ) . taking into account that there are @xmath133 numerical semigroups with frobenius number @xmath132",
    ", one can consider the performance of the implementations satisfactory . in order to explain the meaning of the colors used in this picture to highlight some integers , we anticipate the results shown in example  [ example : forced_picture ] .",
    "for @xmath134 , we have that @xmath135 consists of forced gaps and that @xmath136 consists of forced elements . to the elements in each of these sets , as well as the ones in the sets of minimal generators ,",
    "is assigned one color ( _ red _ corresponds to pseudo - frobenius numbers , _ blue _ to minimal generators , _ green _ to elements , _ cyan _ to forced gaps , and _ magenta _ to forced elements ; in a black and white visualization of this manuscript this will correspond with different gray tonalities ) . for integers that belong to more that one set ,",
    "gradient colors are assigned .",
    ".[fig : pfs_19_29 ] ]",
    "in this section we give pseudo - code for several functions implementing results given in section  [ sec : generalities ] and some others needed later in section  [ sec : computing_forced_ints ] .",
    "once more , @xmath80 is a fixed set @xmath137 of positive integers ; @xmath138  stands for @xmath139 and @xmath32  stands for  @xmath18 .",
    "the function  [ func : startingforcedgaps ] returns the integers considered in subsection  [ subsec : starting_forced_gaps ] , which we called starting forced gaps .",
    "recall ( corollary  [ cor : starting_forced_gaps ] ) that these have to be gaps of all the numerical semigroups having @xmath21  as set of pseudo - frobenius numbers .",
    "the justifications for lines  [ line : type_multiplicity ] and  [ line : pseudo - comb - pseudo ] are given by remark  [ rem : type_multiplicity ] and lemma  [ lemma : pseudo - comb - pseudo ] , respectively .",
    "line  [ line : exclusion ] is justified by lemma  [ lemma : maximals](ii ) : when it is detected a gap that had to be an element ( forced by exclusion ) , there exists a contradiction and the function returns .",
    "this proves the following proposition .",
    "[ prop : correction_startingforcedgaps ] let be the output of the function [ func : startingforcedgaps ] for the input @xmath21 . if is not , then it consists of gaps of any numerical semigroup @xmath33 .",
    "+ [ line : type_multiplicity ] @xmath140,\\pf)$ ] ; + @xmath141 , i\\to \\smallelements(\\closure(\\{\\pf[1],\\pf[2],\\ldots,\\pf[i]\\},\\pf[i+1])))$ ] _ diffs _ : = @xmath142 [ line : pseudo - comb - pseudo ] @xmath143    [ line : exclusion ] @xmath144 ;    [ example : starting_forced_gaps ] let @xmath145 .",
    "one can easily check that the set of starting forced gaps is @xmath146 .",
    "the corresponding session :    .... gap > pf : = [ 16,29 ] ; ; gap > g : = startingforcedgapsforpseudofrobenius(pf ) ;        [ 1 , 2 , 4 , 8 , 13 , 16 , 29 ] ....    the function [ func : furtherforcedgaps ] is used to determine forced gaps when some gaps and some elements of a numerical semigroup are known .",
    "the justification for the fact that the output of [ func : furtherforcedgaps ] consists of gaps ( unless there is an element that also had to be a gap , in which case it returns _ fail _ ) is the following : if @xmath147 and @xmath148 are elements of a semigroup then @xmath149 belongs to the semigroup . in particular ,",
    "if @xmath148 is an element and @xmath8 is a gap , then @xmath147 is either negative or a gap .",
    "this proves the following proposition .",
    "[ prop : correction_furtherforcedgaps ] let be the output of the function [ func : furtherforcedgaps ] for the input @xmath150 , with and consisting of @xmath21-forced gaps and @xmath21-forced elements , respectively .",
    "if is , then @xmath41 . otherwise , consists of gaps of any numerical semigroup @xmath33 .",
    "+   + @xmath151 [ line : conflicts_gaps ]      we use two ways to get new forced elements .",
    "one of these ways makes use of lemma  [ lemma : maximals](ii ) .",
    "we refer to the elements obtained in this way as _ elements forced by exclusion_. another way makes use of the following lemma , which tells us that small gaps force elements that are close to the maximum of @xmath21 .",
    "sometimes we refer to them by using the more suggestive terminology _ big forced elements_.    [ lemma : big_elts ] let @xmath152 be the multiplicity of a numerical semigroup @xmath0 and let @xmath153 be an integer such that @xmath154 . then either @xmath155 or @xmath156 .",
    "it suffices to observe that , as @xmath157 , one has that @xmath158 , and consequently @xmath159 .",
    "the result follows immediately from the definition of pseudo - frobenius numbers .",
    "+ @xmath160 ; + [ line : big_elts ] @xmath161",
    "@xmath162 [ line : excl_elts_if ] @xmath163 , \\union(\\fg,\\union(\\fe , ee)))$ ] [ line : excl_elts_only_if ] @xmath164 [ line : conflicts_elts ]    we observe that in the function it is used that @xmath21  is precisely the set of pseudo - frobenius numbers ; otherwise there is no guarantee that the output consists of forced elements .",
    "let us now prove the correctness of this function .",
    "justification for the the result produced by the cycle starting in line  [ line : excl_elts_if ] is given by the direct implication of lemma  [ lemma : maximals](ii ) .",
    "for the cycle starting in line  [ line : excl_elts_only_if ] is given by the reverse implication of the same lemma .",
    "( the integers known to be forced gaps are assumed to be gaps . )",
    "justification for line  [ line : big_elts ] follows from lemma  [ lemma : big_elts ] , since the @xmath152 appearing there is smaller than or equal to the multiplicity .",
    "we have then the following proposition .",
    "[ prop : correction_furtherforcedelements ] let be the output of the function [ func : furtherforcedelements ] for the input @xmath150 , with and consisting of @xmath21-forced gaps and @xmath21-forced elements , respectively . if is `` fail '' , then @xmath41 .",
    "otherwise , consists of elements of any numerical semigroup @xmath33 .",
    "when searching for forced integers , one should pay attention to the existence of possible contradictions .",
    "let @xmath165 . taking divisors and the difference @xmath166 , one immediately sees that the set of starting forced gaps contains @xmath167 .",
    "but then @xmath168 appears as a forced gap and as a ( big ) forced element .",
    "this is a contradiction which shows that @xmath169 can not be the set of pseudo - frobenius numbers of a numerical semigroup .    according to proposition  [ prop : intersection_gaps_elements ] ,",
    "the only that we need to take into account is that the set of forced gaps is disjoint from the set of forced elements .    at the end of the functions ( line  [ line : conflicts_gaps ] in function [ func : furtherforcedgaps ] , and line  [ line : conflicts_elts ] in function [ func : furtherforcedelements ] )",
    ", possible contradictions are detected .",
    "let @xmath29 be a set of positive integers .",
    "the aim of this section is to give a procedure to compute some elements of @xmath37 and @xmath39 .",
    "we start with a subsection that contains a procedure that makes use of the functions given in section  [ sec : preliminary_forced_ints ] , which implement some well - known facts recalled in section  [ sec : generalities ] .",
    "we then devote a subsection to what we call admissible integers .",
    "this will yield another procedure ( in subsection  [ subsec : procedure_forced_integers ] ) , which , at the cost of increasing the execution time , may find more forced integers .",
    "the main algorithm of the present paper ( algorithm  [ alg : numericalsemigroupswithpseudofrobeniusnumbers ] ) would work as well by using only the quick version .",
    "our experiments led us to consider the option of using the slower version once , and then use the quick version inside a recursive function that is called by the main algorithm .",
    "@xmath170 ; + @xmath171 ; + @xmath172 $ ] ;    the correctness of algorithm  [ alg : simpleforcedintegers ] ( ) follows from propositions  [ prop : correction_furtherforcedgaps ] and  [ prop : correction_furtherforcedelements ] which state the correction of the functions considered in section  [ sec : preliminary_forced_ints ] .",
    "[ th : correction_quick_forced_integers ] algorithm  [ alg : simpleforcedintegers ] correctly produces the claimed output .    note that the forced elements returned by algorithm  [ alg : simpleforcedintegers ] ( the list in the second component ) are obtained by applying the function closure to some set .",
    "therefore we observe the following .",
    "[ rem : forced_elts_are_small_elts_qv ] the second component of the list returned by algorithm  [ alg : simpleforcedintegers ] is the set of small elements of a numerical semigroup .",
    "[ example : all_forced ] let us see how the works for @xmath145 .",
    "we already know ( example  [ example : starting_forced_gaps ] ) that the set of starting forced gaps is @xmath173 .",
    "let us now make a call to with input @xmath174 $ ]",
    ".    the first passage in line  [ line : simple_further_gaps ] does not produce any new integer .",
    "the first passage in line  [ line : simple_further_elts ] produces @xmath175 as current forced elements .",
    "observe that @xmath176 is forced by exclusion ( note that @xmath177 ; also , @xmath178 and @xmath179 is a forced gap ) ; @xmath180 is also forced by exclusion ( note that @xmath181 and @xmath182 is a forced gap ) .",
    "also , @xmath183 is forced by exclusion , but for now we do not need to worry with the multiples of @xmath176 , because these will appear when taking the closure .",
    "the second passage in line  [ line : simple_further_gaps ] produces @xmath184 as current forced gaps . to check it ,",
    "observe that @xmath185 , @xmath186 , @xmath187 , etc .",
    "are forced gaps .",
    "but then , @xmath188 and @xmath168 are ( forced to be ) gaps .",
    "no further forced elements appear .",
    "in fact , the union of the sets of forced gaps and of forced elements is @xmath189 .",
    "therefore , all positive integers less than @xmath132 are forced .",
    "one can check that the closure of the set of forced elements does not produce new forced elements , thus it is the set of small elements of a numerical semigroup .",
    "also , one can check that no forced gap outside @xmath190 is a pseudo - frobenius number , thus one may conclude that there exists exactly one numerical semigroup @xmath0 such that @xmath191 .",
    "this example illustrates that more than one passage through the _ repeat - until _ loop of the algorithm may be needed .",
    "[ example : forced_picture ] in this example we present a session , now for @xmath192 .",
    ".... gap > pf : = [ 19,29 ] ; ;                              gap > sfg : = startingforcedgapsforpseudofrobenius(pf ) ; [ 1 , 2 , 5 , 10 , 19 , 29 ] gap > simpleforcedintegersforpseudofrobenius(sfg,[],pf ) ; [ [ 1 , 2 , 4 , 5 , 10 , 11 , 19 , 20 , 29 ] , [ 0 , 9 , 18 , 24 , 25 , 27 , 28 , 30 ] ] ....    recall that the names used in our package are longer than the ones used in this manuscript , so for instance , ` simpleforcedintegersforpseudofrobenius ` is the name we have used in our package for algorithm  [ alg : simpleforcedintegers ] .",
    "this example is related to figure  [ fig : pfs_19_29 ] , where forced integers are highlighted .",
    "[ ex : forced_ints_for_tree ] let us now apply the algorithm to @xmath193 .",
    "again , we will use to help us in doing the calculations ( which can be easily confirmed by hand ) .    .... gap > pf : = [ 15 , 20 , 27 , 35 ] ;",
    "; gap > sfg : = startingforcedgapsforpseudofrobenius(pf ) ;                      [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 12 , 15 , 20 , 27 , 35 ] ....    we immediately get that @xmath194 consists of forced big elements .",
    "and one can observe that @xmath195 and @xmath196 are forced by exclusion .",
    "this leads to the obtention of @xmath197 as forced gap .",
    "no other forced elements are obtained , which agrees with the following continuation of the session :    .... gap > simpleforcedintegersforpseudofrobenius(sfg,[],pf ) ; [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 12 , 15 , 16 , 20 , 27 , 35 ] ,     [ 0 , 19 , 23 , 25 , 26 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] ] ....      let @xmath46 and @xmath47 respectively be sets of @xmath21-forced gaps and @xmath21-forced elements , and let @xmath198 be a free integer for @xmath50 .",
    "we say that @xmath198 is _",
    "admissible for _ @xmath50 if algorithm  [ alg : simpleforcedintegers ] when applied to @xmath199 does not return _",
    "fail_. otherwise , we say that @xmath198 is _ non - admissible for _ @xmath50 .",
    "thus , @xmath198 is non - admissible implies that @xmath198 can not be an element of any semigroup in @xmath20 and therefore is a gap of all semigroups in @xmath20 , that is , is a forced gap .",
    "[ lemma : admissible_ints ] let @xmath46 and @xmath47 be sets of forced gaps and forced elements , respectively .",
    "let @xmath198 be free for @xmath50 .",
    "if @xmath198 is non - admissible for @xmath50 , then @xmath198 is a @xmath21-forced gap .",
    "observe that a semigroup generated by admissible elements for some pair @xmath50 consists of admissible elements for @xmath50 .    the function [ func : nonadmissible ] , with input a pair of sets of forced gaps and forced elements , returns non - admissible integers , which , by lemma  [ lemma : admissible_ints ] , are new forced gaps .",
    "this function is called by algorithm  [ alg : forcedintegers ] , a not so quick procedure to compute forced integers .",
    "[ prop : correction_nonadmissible ] let be the output of the function [ func : nonadmissible ] for the input @xmath150 , with and consisting of @xmath21-forced gaps and @xmath21-forced elements , respectively .",
    "then is a set of integers that are non - admissible for @xmath150 .",
    "+ @xmath200 @xmath201 , \\union(\\fg,\\fe))$ ] ; + @xmath202 , admissible)$ ] ;    [ example : non_admissible ] let @xmath203 .",
    ".... gap > pf : = [ 11 , 22 , 23 , 25 ] ; ; gap > sfg : = startingforcedgapsforpseudofrobenius(pf ) ;                      [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 11 , 12 , 14 , 22 , 23 , 25 ] ....    by using the function one obtains the following .    .... gap",
    "> simpleforcedintegersforpseudofrobenius(sfg,[],pf ) ; [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 11 , 12 , 14 , 22 , 23 , 25 ] ,     [ 0 , 18 , 19 , 20 , 21 , 24 , 26 ] ] ....    that @xmath204 consists of forced gaps and that the set @xmath205 can easily be confirmed by hand .",
    "let us now check that @xmath206 is non - admissible .",
    "if it was an element of a semigroup @xmath207 , then @xmath208 and @xmath209 would be gaps of @xmath0 .",
    "but then @xmath210 is a big element , @xmath211 is forced by exclusion ( note that @xmath212 , @xmath213 and @xmath214 are gaps ) and @xmath215 is forced by exclusion too ( @xmath216 , @xmath217 are gaps and @xmath218 ) .",
    "this is not possible , since @xmath219 is a gap .",
    "therefore @xmath206 is non - admissible .",
    "algorithm  [ alg : forcedintegers ] is our procedure to compute forced integers that produces the best result in terms of the number of forced integers encountered .",
    "besides algorithm  [ alg : simpleforcedintegers ] , it makes use of the function [ func : nonadmissible ] .",
    "[ rem : forced_elts_are_small_elts ] it is a consequence of remark  [ rem : forced_elts_are_small_elts_qv ] that the second component of the list returned by algorithm  [ alg : forcedintegers ] is the set of small elements of a numerical semigroup .",
    "@xmath220)$ ] @xmath221,fints[2])$ ] @xmath222)$ ] @xmath223),fints[2])$ ] ;    the correctness of algorithm  [ alg : forcedintegers ] follows from proposition  [ prop : correction_nonadmissible ] and theorem  [ th : correction_quick_forced_integers ] .",
    "[ th : correction_forced_integers ] algorithm  [ alg : forcedintegers ] correctly produces the claimed output .      algorithm  [ alg : simpleforcedintegers ] can be used as a quick way to compute forced integers . in fact , when called with the starting forced gaps and the empty set of elements , can be seen as a quick version of algorithm  [ alg : forcedintegers ] .",
    "we use    ` forcedintegers_qv(\\mathsf{pf } ) `    as a shorthand for    ` simpleforcedintegers((\\mathsf{pf } ) , [  ] ) `    in the following example we use the names for the functions in the current implementation .",
    "this example is meant to illustrate the difference between applying the quick and the normal version of the algorithm .",
    ".... gap > pf : = [ 103 , 110 , 112 , 137 , 160 , 178 , 185 ] ; ;                gap > fq : = forcedintegersforpseudofrobenius_qv(pf);;time ;         25 gap > fn : = forcedintegersforpseudofrobenius(pf);;time ;            262 gap > length(fq[1]);length(fn[1]);length(fq[2]);length(fn[2 ] ) ;     50 51 29 31 ....    we have used the internal names in the package ` forcedintegersforpseudofrobenius_qv ` and ` forcedintegersforpseudofrobenius `  for and , respectively .    table  [ fig : execution_time_forced_integers ] collects some information concerning some execution times ( as given by ) and the number of forced gaps and of forced elements both using algorithm  [ alg : simpleforcedintegers ] ( identified as qv ( which stands for _ quick version _ ) ) and algorithm  [ alg : forcedintegers ] ( identified as nv ( which stands for _ normal version _ ) ) .",
    "we observe that the execution times when using the quick version remain relatively small , even when the frobenius number is large .",
    ".execution times for computing forced integers.[fig : execution_time_forced_integers ] [ cols= \" < , < , < , < , < , < , < \" , ]",
    "sometimes one may just be interested in obtaining one numerical semigroup with @xmath21  as set of pseudo - frobenius numbers .",
    "algorithm  [ alg : numericalsemigroupswithpseudofrobeniusnumbers ] may be too slow ( it gives much information that will not be used ) .",
    "one could adapt the algorithm to stop once it encounters the first semigroup , but the information had to be transmitted recursively and one would end up with a slow algorithm .",
    "next we propose an alternative ( algorithm  [ alg : randomnumericalsemigroupwithpseudofrobeniusnumbers ] ) , the first part of which is similar to the initial part of algorithm  [ alg : numericalsemigroupswithpseudofrobeniusnumbers ] .",
    "the main difference is in the usage of the function instead of the function , both available in the package . for the second part , instead of calling the recursive function",
    ", it tries to gess a path that leads to a leaf . starts choosing at random a free integer @xmath198 and tests its non admissibility ( by checking whether returns when called with @xmath198 as if it was forced ) . if one does not conclude that @xmath198 is non admissible , it is assumed to be a forced integer",
    "there is an option that is part of the implementation to give a bound for the maximum number of attempts the function does .",
    "its usage is ilustrated in examples  [ example : random1 ] and  [ example : random2 ] .",
    "@xmath224 @xmath225,\\union(f\\_ints))$ ]    it may happen that no semigroup has the given set as set of pseudo - frobenius elements , and thus the output will simply be .",
    "[ example : random1 ] we look for a random numerical semigroup with @xmath226 .",
    "the first execution of the function yields :    .... gap > pf : = [ 100 , 453 , 537 , 543 ] ; ; gap > ns : = randomnumericalsemigroupwithpseudofrobeniusnumbers(pf);;time ;   minimalgeneratingsystem(ns ) ; 2440 [ 66 , 94 , 106 , 126 , 166 , 184 , 194 , 206 , 209 , 216 , 224 , 230 , 235 , 246 , 256 , 263 ,   267 , 284 , 295 , 309 , 363 , 374 , 379 , 385 , 391 , 413 ] ....    while if we execute it a second time we get another semigroup with the desired set of pseudo - frobenius numbers ( clearly , the reader might obtain different outputs ) :    .... gap > pf : = [ 100 , 453 , 537 , 543 ] ; ; gap > ns : = randomnumericalsemigroupwithpseudofrobeniusnumbers(pf);;time ;   minimalgeneratingsystem(ns ) ; 7302 [ 94 , 106 , 123 , 134 , 162 , 178 , 184 , 194 , 204 , 206 , 222 , 223 , 234 , 235 , 238 , 248 ,   251 , 262 , 263 , 266 , 270 , 276 , 279 , 283 , 293 , 304 ,   313 , 336 , 348 , 367 , 383 , 415 ] ....    [ example : random2 ] if one of the free integers can neither be a gap nor an element , no semigroup exists .",
    ".... gap > pf : = [ 30 , 104 , 118 , 147 , 197 , 292 , 298 , 315 , 333 , 384 , 408 ] ; ; gap > ns : = randomnumericalsemigroupwithpseudofrobeniusnumbers (         >   rec(pseudo_frobenius : = pf , max_attempts : = 100));time ;          fail 22 ....",
    "we present here an alternative way to compute the set of numerical semigroups with a given set of pseudo - frobenius numbers . in general",
    ", this procedure is slower than the presented above , though we have not been able to characterize when this happens .",
    "we include it the manuscript since it was the initial implementation and was used to test the other one .",
    "a numerical semigroup is _ irreducible _ if it can not be expressed as the intersection of two numerical semigroups properly containing it .",
    "it turns out that a numerical semigroup @xmath0 is irreducible if and only if either @xmath227 or @xmath228 ( see ( * ? ? ?",
    "* chapter 3 ) ) .",
    "irreducible numerical semigroups can be also characterized as those maximal ( with respect to set inclusion ) numerical semigroups in the set of all numerical semigroups with given frobenius number .",
    "the maximality of irreducible numerical semigroups in the set of all numerical semigroups with given frobenius number implies that every numerical semigroup is contained in an irreducible numerical with its same frobenius number .",
    "actually , we can say more .",
    "let us show that @xmath235 .",
    "assume to the contrary that this is not the case , and consequently @xmath246 .",
    "then as all the elements in @xmath247 are greater than @xmath24 , and @xmath248 , there must be an element @xmath240 and @xmath249 such that @xmath250 .",
    "but this is impossible , since all elements in @xmath12 are incomparable with respect to @xmath51 ( lemma  [ lemma : maximals ] ) .",
    "if @xmath251 is not irreducible , then as irreducible numerical semigroups are maximal in the set of numerical semigroups with fixed frobenius number , there exists @xmath229 with @xmath252 and containing @xmath251 ; whence fulfilling the desired conditions .        1 .",
    "@xmath256 irreducible , 2 .",
    "@xmath257 for all @xmath258 , 3 .",
    "@xmath259 , 4 .   for every @xmath260",
    ", @xmath261 is a minimal generator of @xmath262 such that @xmath263 for some @xmath264 , 5 .   for every @xmath260 and @xmath265 with @xmath266 ,",
    "there exists @xmath267 such that @xmath268 .",
    "let @xmath229 be as in lemma  [ lemma : puedo - cubrir - f2 ] .",
    "construct a chain joining @xmath0 and @xmath229 by setting @xmath269 and @xmath270 , with @xmath271 .",
    "then @xmath262 is a numerical semigroup , and @xmath261 is a minimal generator of @xmath262 and a pseudo - frobenius number for @xmath272 ( ( * ? ? ?",
    "* lemma 4.35 ) ) . since the complement @xmath273 is finite , for some @xmath66 , @xmath274 .        given a candidate set @xmath21  of pseudo - frobenius numbers with maximum element @xmath8 ,",
    "we can use the above procedure to construct from the set of all irreducible numerical semigroups with frobenius number @xmath8 , the set of all numerical semigroups having @xmath21  as a set its pseudo - frobenius numbers . in order to compute the set of all irreducible numerical semigroups with frobenius number @xmath8 we use implementation of the procedure presented in @xcite that is already part of @xcite .",
    "we have slightly modified the algorithm in @xcite to compute the set of irreducible numerical semigroups containing a given set of integers , and these integers are the first component of ( @xmath21 ) . for every irreducible element in the list",
    "we then remove those minimal generators fulfilling condition ( 4 ) in proposition [ prop : chain ] .",
    "we add to our list of semigroups the semigroups obtained in the preceding step for which condition ( 5 ) holds , and then we proceed recursively .        since we have modified the function `",
    "irreduciblenumericalsemigroupswithfrobeniusnumber ` to output only those irreducible numerical semigroups containing @xmath289 , we obtain only two irreducible numerical semigroups : @xmath290 and @xmath291 .    for @xmath292",
    "the only minimal generator that fulfills the conditions in proposition [ prop : chain ] is @xmath188 .",
    "if we remove @xmath188 from @xmath292 , we obtain @xmath293 , which already has the desired set of pseudo - frobenius number .    as for @xmath294 , again @xmath188 is the only minimal generator fulfilling the conditions in proposition [ prop : chain ] , and we obtain @xmath295 .",
    "this semigroup has pseudo - frobenius number set equal to @xmath80 , and so , as with @xmath296 we do not need to look for new minimal generators to remove ."
  ],
  "abstract_text": [
    "<S> the pseudo - frobenius numbers of a numerical semigroup are those gaps of the numerical semigroup that are maximal for the partial order induced by the semigroup </S>",
    "<S> . we present a procedure to detect if a given set of integers is the set of pseudo - frobenius numbers of a numerical semigroup and , if so , to compute the set of all numerical semigroups having this set as set of pseudo - frobenius numbers . </S>"
  ]
}