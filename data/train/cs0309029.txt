{
  "article_text": [
    "instrumentation is a technique whereby existing code is modified in order to observe or modify its behaviour .",
    "it has a lot of different applications , such as profiling , coverage analysis and cache simulations .",
    "one of its most interesting features is however the ability to perform automatic debugging , or at least assist in debugging complex programs .",
    "after all , instrumentation code can intervene in the execution at any point and examine the current state , record it , compare it to previously recorded information and even modify it .",
    "debugging challenges that are extremely suitable for analysis through instrumentation include data race detection  @xcite and memory management checking  @xcite .",
    "these are typically problems that are very hard to solve manually .",
    "however , since they can be described perfectly using a set of rules ( e.g.  the memory must be allocated before it is accessed , or no two threads must write to the same memory location without synchronising ) , they are perfect candidates for automatic verification .",
    "instrumentation provides the necessary means to insert this verification code with little effort on the side of the developer .",
    "the instrumentation can occcur at different stages of the compilation or execution process . when performed prior to the execution , the instrumentation results in changes in the object code on disk , which makes them a property of a program or library .",
    "this is called static instrumentation .",
    "if the addition of instrumentation code is postponed until the program is loaded in memory , it becomes a property of an execution . in this case , we call it dynamic instrumentation .    examples of stages where static instrumentation can be performed are directly in the source code  @xcite , in the assembler output of the compiler  @xcite , in the compiled objects or programs ( e.g.  eel  @xcite , atom  @xcite , alto  @xcite ) .",
    "the big advantage of static instrumentation is that it must be done only once , after which one can perform several executions without having to reinstrument the code every time .",
    "this means that the cost of instrumenting the code can be relatively high without making such a tool practically unusable .",
    "the larges disadvantage of static instrumentation is that it requires a complex analysis of the target application to detect all possible execution paths , which is not always possible .",
    "additionally , the user of a static instrumentation tool must know which libraries are loaded at run time by programs he wants to observe , so that he can provide instrumented versions of those .",
    "finally , every time a new type of instrumentation is desired , the application and its libraries must be reinstrumented .",
    "most of the negative points of static instrumentation are solved in its dynamic counterpart . in this case , the instrumentation is not performed in advance , but gradually at run time as more code is executed . since the instrumentation can continue while the program is running , no prior analysis of all possible execution paths is required .",
    "it obviously does mean that the instrumentation must be redone every time the program is executed .",
    "this is somewhat offset by having to instrument only the part of the application and its libraries that is covered by a particular execution though .",
    "one can even apply dynamic optimization techniques  @xcite to further reduce this overhead .    when using dynamic instrumentation , the code on disk is never modified .",
    "this means that a single uninstrumented copy of an application and its libraries suffices when using this technique , no matter how many different types of instrumentation one wants to perform .",
    "another consequence is that the code even does not have to exist on disk .",
    "indeed , since the original code is read from memory and can be instrumented just before it is executed , even dynamically loaded and generated code pose no problems .",
    "however , when the program starts modifying this code , the detection and handling of these modifications is not possible using current instrumentation techniques .    yet",
    ", being able to instrument self - modifying code becomes increasingly interesting as run time systems that exhibit such behaviour gain more and more popularity .",
    "examples include java virtual machines , the .net environment and emulators with embedded just - in - time compilers in general .",
    "these environments often employ dynamic optimizing compilers which continuously change the code in memory , mainly for performance reasons .",
    "instrumenting the programs running in such an environment is often very easy .",
    "after all , the dynamic compiler or interpreter that processes said programs can do the necessary instrumentation most of the time . on the other hand ,",
    "observing the interaction of the environments themselves with the applications on top and with the underlying operating system is much more difficult .",
    "nevertheless , this ability is of paramount importance when analysing the total workload of a system and debugging and enhancing these virtual machines .    even when starting from a system that can already instrument code on the fly , supporting self - modifying code is a quite complex undertaking .",
    "first of all , the original program code must not be changed by the instrumentor , since otherwise the program s own modifications may conflict with these changes later on .",
    "secondly , the instrumentor must be able to detect changes performed by the program before the modified code is executed , so that it can reinstrument this code in a timely manner .",
    "finally , the reinstrumentation itself must take into account that an instruction may be changed using multiple write operations , so it could be invalid at certain points in time .    in this paper",
    "we propose a novel technique that can be used to dynamically instrument self - modifying code with an acceptable overhead .",
    "we do this by using the hardware page protection facilities of the processor to mark pages that contain code which has been instrumented as read - only . when the program later on attempts to modify instrumented code , we catch the resulting protection faults which enables us to detect those changes and act accordingly . the described method has been experimentally evaluated using the _ diota _ ( dynamic instrumentation , optimization and transformation of applications  @xcite ) framework on the linux / x86 platform by instrumenting a number of javagrande  @xcite benchmarks running in the sun 1.4.0 java virtual machine .",
    "the paper now proceeds with an overview of dynamic instrumentation in general and _ diota _ in particular .",
    "next , we show how the detection of modified code is performed and how to reinstrument this code .",
    "we then present some experimental results of our implementation of the described techniques and wrap up with the conclusions and our future plans .",
    "dynamic instrumentation can be be done in two ways .",
    "one way is modifying the existing code , e.g.  by replacing instructions with jumps to routines which contain both instrumentation code and the replaced instruction  @xcite .",
    "this technique is not very usable on systems with variable - length instructions however , as the jump may require more space than the single instruction one wants to replace .",
    "if the program later on transfers control to the second instruction that has been replaced , it will end up in the middle of this jump instruction .",
    "the technique also wreaks havoc in cases of data - in - code or code - in - data , as modifying the code will cause modifications to the data as well .",
    "the other approach is copying the original code into a separate memory block ( this is often called _ cloning _ ) and adding instrumentation code to this copy  @xcite .",
    "this requires special handling of control - flow instructions with absolute target addresses , since these addresses must be relocated to the instrumented version of the code . on the positive side ,",
    "data accesses still occur correctly without any special handling , even in data - in - code situations .",
    "the reason is that when the code is executed in the clone , only the program counter ( pc ) has a different value in an instrumented execution compared to a normal one .",
    "this means that when a program uses non - pc - relative addressing modes for data access , these addresses still refer to the original , unmodified copy of the program or data .",
    "pc - relative data accesses can be handled at instrumentation time , as the instrumentor always knows the address of the instruction it is currently instrumenting .",
    "this way , it can replace pc - relative memory accesses with absolute memory accesses based on the value the pc would have at that time in a uninstrumented execution .",
    "_ diota _ uses the cloning technique together with a cache that keeps track of already translated instruction blocks .",
    "it is implemented as a shared library and thus resides in the same address space as the program it instruments . by making use of the ld_preload environment variable under linux",
    ", the dynamic linker ( ld.so ) can be forced to load this library , even though an application is not explicitly linked to it .",
    "the init routines of all shared libraries are executed before the program itself is started , providing _",
    "diota _ an opportunity to get in control .",
    "as shown in figure [ fig : diota_operation ] , the instrumentation of a program is performed gradually .",
    "first , the instructions at the start of the program are analysed and then copied , along with the desired instrumentation code , to the _ clone _ ( a block of memory reserved at startup time , also residing in the program s address space ) . during this process ,",
    "direct jumps and calls are followed to their destination .",
    "the instrumentation stops when an instruction is encountered of which the destination address can not be determined unequivocally , such as an indirect jump .    at this point ,",
    "a _ trampoline _ is inserted in the clone .",
    "this is a small piece of code which will pass the actual target address to _ diota _ every time the corresponding original instruction would be executed .",
    "for example , in case of a jump with the target address stored in a register , the trampoline will pass the value of that specific register to _ diota _ every time it is executed .",
    "diota _ is entered via such a trampoline , it will check whether the code at the passed address has already been instrumented . if that is not the case ,",
    "it is instrumented at that point .",
    "next , the instrumented version is executed .",
    "figure [ fig : translationtable ] shows how _ diota _ keeps track of which instructions it has already instrumented and where the instrumented version can be found . a marker consisting of illegal opcodes",
    "is placed after every block of instrumented code ( aligned to a 4-byte boundary ) , followed by the translation table .",
    "such a translation table starts with two 32 bit addresses : the start of the block in the original code and its counterpart in the clone .",
    "next , pairs of 8 bit offsets between two successive instructions in the respective blocks are stored , with an escape code to handle cases where the offset is larger than 255 bytes ( this can occur because we follow direct calls and jumps to their destination ) .",
    "in addition to those tables , an avl tree is constructed .",
    "the keys of its elements are the start and stop addresses of the blocks of original code that have been instrumented .",
    "the values are the start addresses of the translation tables of the corresponding instrumented versions .",
    "every instruction is instrumented at most once , so the keys never overlap .",
    "this means that finding the instrumented version of an instruction boils down to first searching for its address in the avl tree and if found , walking the appropriate translation table . to speed up this process ,",
    "a small hash table is used which keeps the results of the latest queries .",
    "a very useful property of this system is that it also works in reverse : given the address of an instrumented instruction , it is trivial to find the address of corresponding original instruction .",
    "first , the illegal opcodes marker is sought starting from the queried address and next the table is walked just like before until the appropriate pair is found .",
    "this ability of doing two - way translations is indispensable for the self - modifying code support and proper exception handling .",
    "since the execution is followed as it progresses , code - in - data and code loaded or generated at run time can be handled without any problems .",
    "when a trampoline passes an address to _ diota _ of code it has not yet instrumented , it will simply instrument it at that time .",
    "it is irrelevant where this code is located , when it appeared in memory and whether or not it doubles as data    _ diota _ has several modes of operation , each of which can be used separately , but most can be combined as well . through the use of so - called backends ,",
    "the different instrumentation modes can be activated and the instrumentation parameters can be modified .",
    "these backends are shared libraries that link against _ diota _ and which can ask to intercept calls to arbitrary dynamically linked routines based on name or address , to have a handler called whenever a memory access occurs , when a basic block completes or when a system call is performed ( both before and after the system call , with the ability to modify its parameters or return value ) .",
    "several backends can be used at the same time .",
    "other features of the _ diota _ framework include the ability to handle most extensions to the 80x86 isa ( such as mmx , 3dnow ! and sse ) and an extensible and modular design that allows easy implementation of additional backends and support for newly introduced instructions .",
    "this paper describes the support for instrumenting self - modifying code in _",
    "diota_. for other technical details about _ diota _ we refer to @xcite .",
    "an aspect that is of paramount importance to the way we handle self - modifying code , is the handling of exceptions ( also called signals under linux ) .",
    "the next section will describe in more detail how we handle the self - modifying code , but since it is based on marking the pages containing code that has been instrumented as read - only , it is clear that every attempt to modify such code will cause a protection fault ( or _ segmentation fault _ ) exception .    these exceptions and those caused by other operations must be properly distinguished , in order to make sure that the program still receives signals which are part of the normal program execution while not noticing the other ones .",
    "this is especially important since the java virtual machine that we used to evaluate our implementation uses signals for inter - thread communication .",
    "when a program starts up , each signal gets a default handler from the operating system .",
    "if a program wants to do something different when it receives a certain signal , it can install a signal handler by performing a system call .",
    "this system call gets the signal number and the address of the new handler as arguments .",
    "since we want to instrument these user - installed handlers , we have to intercept these system calls .",
    "this can be achieved by registering a system call analyser routine with _",
    "diota_. this instructs _ diota _ to insert a call to this routine after every system call in the instrumented version of the program .",
    "if such a system call successfully installed a new signal handler , the analyser records this handler and then installs a _ diota _",
    "handler instead .",
    "next , when a signal is raised , _ diota _",
    "s handler is activated .",
    "one of the arguments passed to a signal handler contains the contents of all processor registers at the time the signal occurred , including those of the instruction pointer register .",
    "since the program must not be able to notice it is being instrumented by looking at at that value , it is translated from a clone address to an original program address using the translation tables described previously .",
    "finally , the handler is executed under control of _ diota _ like any other code fragment .",
    "once the execution arrives at the sig_return or sig_rt_return system call that ends this signal s execution , _ diota _ replaces the instruction pointer in the signal context again .",
    "if the code at that address is not yet instrumented , the instruction pointer value in the context is replaced with the address of a trampoline which will transfer control back to _ diota _ when returning from the signal s execution .",
    "otherwise , the clone address corresponding to the already instrumented version is used .",
    "dynamically generated and loaded code can already be handled by a number of existing instrumentors  @xcite .",
    "the extra difficulty of handling self - modifying code is that the instrumentation engine must be able to detect modifications to the code , so that it can reinstrument the new code .",
    "even the reinstrumenting itself is not trivial , since a program may modify an instruction by performing two write operations , which means the intermediate result could be invalid .",
    "there are two possible approaches for dealing with code changes .",
    "one is to detect the changes as they are made , the other is to check whether code has been modified every time it is executed . given the fact that in general code is modified far less than it is executed , the first approach was chosen .",
    "the hardware page protection facilities of the processor are used to detect the changes made page .",
    "once a page contains code that has been instrumented , it will be write - protected .",
    "the consequence is that any attempt to modify such code will result in a segmentation fault .",
    "an exception handler installed by _",
    "diota _ will intercept these signals and take the appropriate action .",
    "since segmentation faults must always be caught when using our technique to support self - modifying code , _ diota _ installs a dummy handler at startup time and whenever a program installs the default system handler for this signal ( which simply terminates the process if such a signal is raised ) , or when it tries to ignore it . apart from that , no changes to the exception handling support of _ diota _ have been made , as shown in figure [ fig : exceptions ] .",
    "whenever a protection fault occurs due to the program trying to modify some previously instrumented code , a naive implementation could unprotect the relevant page , perform the required changes to the instrumented code inside the signal handler , reprotect the page and continue the program at the next instruction .",
    "there are several problems with this approach however :    * on a cisc architecture , most instructions can access memory , so decoding the instruction that caused the protection fault ( to perform the change that caused the segmentation fault in the handler ) can be quite complex . *",
    "it is possible that an instruction is modified by means of more than one memory write operation . trying to reinstrument after the first write operation may result in encountering an invalid instruction .",
    "* in the context of a jit - compiler , generally more than one write operation occurs to a particular page .",
    "an example is when a page was already partially filled with code which was then executed and thus instrumented , after which new code is generated and placed on that page as well .",
    "a better way is to make a copy of the accessed page , then mark it writable again and let the program resume its execution . this way , it can perform the changes it wanted to do itself . after a while",
    ", the instrumentor can compare the contents of the unprotected page and the the buffered copy to find the changes .",
    "so the question then becomes : when is this page checked for changes , how long will it be kept unprotected and how many pages will be kept unprotected at the same time .",
    "all parameters are important for performance , since keeping pages unprotected and checking them for changes requires both processing and memory resources .",
    "the when - factor is also important for correctness , as the modifications must be incorporated in the clone code before it is executed again .    on architectures with a weakly consistent memory model ( such as the sparc and powerpc )",
    ", the program must make its code changes permanent by using an instruction that synchronizes the instruction caches of all processors with the current memory contents .",
    "these instructions can be intercepted by the instrumentation engine and trigger a comparison of the current contents of a page with the previously buffered contents . on other architectures",
    ", heuristics have be used depending on the target application that one wants to instrument to get acceptable performance .",
    "for example , when using the sun jvm 1.4.0 running on a 80x86 machine under linux , we compare the previously buffered contents of a page to the current contents whenever the thread that caused the protection fault does one of the following :    * it performs a kill system call .",
    "this means the modifier thread is sending a signal to another thread , which may indicate that it has finished modifying the code and that it tells the other thread that it can continue .",
    "* it executes a ret or other instruction that requires a lookup to find the appropriate instrumentation code .",
    "this is due to the fact that sometimes the modifying and executing threads synchronise using a spinlock .",
    "the assumption here is that before the modifying thread clears the spinlock , it will return from the modification routine , thus triggering a flush .",
    "although this method is by no means a guarantee for correct behaviour in the general case , in our experience it always performs correctly in the context of instrumenting code generated by the sun jvm 1.4.0 .",
    "the unprotected page is protected again when it has been checked n successive times without any changes having been made to it , or when another page has to be unprotected due to a protection fault .",
    "note that this optimisation only really pays off in combination with only checking the page contents in the thread that caused the initial protection fault .",
    "the reason is that this ensures that the checking limit is not reached prematurely .",
    "otherwise , the page is protected again too soon and a lot of extra page faults occur , nullifying any potential gains .    finally , it is possible to vary the number of pages that are being kept unprotected at the same time .",
    "possible strategies are keeping just one page unprotected for the whole program in order to minimize resources spent on buffering and comparing contents , keeping one page unprotected per thread , or keeping several pages unprotected per thread to reduce the amount of protection faults .",
    "which strategy performs best depends on the cost of a page fault and the time necessary to do a page compare .",
    "different code fragments in the clone are often interconnected by direct jumps .",
    "for example , when  while instrumenting  we arrive at an instruction which was already instrumented before , we generate a direct jump to this previously instrumented version instead of instrumenting that code again .",
    "this not only improves efficiency , but it also makes the instrumentation of modified code much easier , since there is only one location in the clone we have to adapt in case of a code modification .    because of these direct jump interconnections , merely generating an instrumented version of the modified code at a different location in the clone is not enough .",
    "even if every lookup for the instrumented version of the code in that fragment returns one of the new addresses in the clone , the old code is still reachable via de direct jumps from other fragments . removing the direct jumps and replacing them with lookups results in a severe slowdown .",
    "another solution would be keeping track of to which other fragments each fragment refers and adapting the direct jumps in case of changes .",
    "this requires a lot of bookkeeping however , and changing one fragment may result in a cascade effect , requiring a lot of additional changes elsewhere in the clone . for these reasons , we opted for the following three - part strategy .    the optimal way to handle the modifications ,",
    "is to reinstrument the code in - place .",
    "this means that the previously instrumented version of the instructions in the clone are simply replaced by the new ones .",
    "this only works if the new code has the same length as ( or is shorter than ) the old code however , which is not always the case .    a second way to handle modifications",
    "can be applied when the instrumented version of the previous instruction at that location was larger than the size of an immediate jump . in this case , it is possible to overwrite the previous instrumented version with a jump to the new version . at the end of this new code , another jump can transfer control back to rest of the original instrumentation code .",
    "finally , if there is not enough room for an immediate jump , the last resort is filling the room originally occupied by the instrumented code with breakpoints .",
    "the instrumented version of the new code will simply be placed somewhere else in the code .",
    "whenever the program then arrives at such a breakpoint , _ diota _",
    "s exception handler is entered .",
    "this exception handler has access to the address where the breakpoint exception occurred , so it can use the translation table at the end of the block to look up the corresponding original program address .",
    "next , it can lookup where the latest instrumented version of the code at that address is located and transfer control there .",
    "[ cols= \" < , > , > , > , > , > , > \" , ]      we evaluated the described techniques by implementing them in the _ diota _ framework .",
    "the performance and correctness were verified using a number of tests from the javagrande  @xcite benchmark , running under the sun jvm 1.4.0 on a machine with two intel celeron processors clocked at 500mhz .",
    "the operating system was redhat linux 7.3 with version 2.4.19 of the linux kernel .",
    "several practical implementation issues were encountered . the stock kernel that comes with redhat linux 7.3 , which is based on version 2.4.9 of the linux kernel , contains a number of flaws in the exception handling that cause it to lock up or reboot at random times when a lot of page protection exceptions occur .",
    "another problem is that threads in general only have limited stack space and although _ diota _ does not require very much , the exception frames together with _",
    "s overhead were sometimes large enough to overflow the default stacks reserved by the instrumented programs .",
    "therefore , at the start of the main program and at the start of every thread , we now instruct the kernel to execute signal handlers on an alternate stack .",
    "_ diota _ s instrumentation engine is not re - entrant and as such is protected by locks . since",
    "a thread can send a signal to another thread at any time , another problem we experienced was that sometimes a thread got a signal while it held the instrumentation lock .",
    "if the triggered signal handler was not yet instrumented at that point , _ diota _ deadlocked when it tried to instrument this handler .",
    "disabling all signals before acquiring a lock and re - enabling them afterwards solved this problem .",
    "the problem with only parts of instructions being modified , which happens considerably more often than replacing whole instructions , was solved by adding a routine that finds the start of the instruction in which a certain address lies and starting the reinstrumentation from that address .",
    "most modifications we observed were changes to the target addresses of direct calls .",
    "the heuristics regarding only checking for changes in the thread that caused the initial unprotection of the page , reduced the slowdown caused by the instrumentation by 43% relative to a strategy where pages are checked for changes every time a system call occurs and every time a lookup is performed , regardless of the involved threads .",
    "the limit on the number of checks done before a page is protected again ( with n set between 3 and 5 ) provided an additional speed increase of 22% .",
    "a large part of the overhead stems from the fact that the elf binary format ( which is used by all modern linux applications ) permits code and data to be on the same page .",
    "the result is that once a code fragment on such a page has been instrumented , a lot of page faults occur and unnecessary comparisons have to be performed whenever such data is modified afterwards .",
    "a possible solution is not marking pages belonging to the elf binary and the standard libraries loaded at startup time as read - only , but this could compromise the correctness of the described technique .",
    "however , it could be done if execution speed is of great concern and if one is certain that no such code will be modified during the execution .",
    "table [ tab : jvg ] shows the measured timings when running a number of tests from sections 2 and 3 of the sequential part of the javagrande benchmark v2.0  @xcite , all using the sizea input set .",
    "the first column shows the name of the test program .",
    "the second and third columns show the used cpu time ( as measured by the time command line program , expressed in seconds ) of an uninstrumented resp .",
    "instrumented execution , while the fourth column shows the resulting slowdown factor .",
    "the fifth column contains the the amount of protection faults divided by the uninstrumented execution time , so it is an indication of the degree in which the program writes to pages that contain already executed code . the last column shows the number of lookups per second of uninstrumented execution time , where a lookup equals a trip to _ diota _ via a trampoline to get the address of the instrumented code at the queried target address .",
    "the results have been sorted on the slowdown factor .",
    "regression analysis shows us that the overhead due to the lookups is nine times higher than that caused by the protection faults ( and page compares , which are directly correlated with the number of protection faults , since every page is compared n times after is unprotected due to a fault ) .",
    "this means that the page protection technique has a quite low overhead and that most of the overhead can be attributed to the overhead of keeping the program under control .",
    "the cause for the high cost of the lookups comes from the fact that the lookup table must be locked before it can be consulted , since it is shared among all threads .",
    "as mentioned before , we have to disable all signals before acquiring a lock since otherwise a deadlock might occur .",
    "disabling and restoring signals is an extremely expensive operation under linux , as both operations require a system call .",
    "we have verified this by instrumenting a program that does not use use any signals nor self - modifying code using two different versions of _ diota _ : one which does disable signals before acquiring a lock and one which does not .",
    "the first version is four times slower than the second one .",
    "we have described a method which can be used to successfully instrument an important class of programs that use self - modifying code , specifically java programs run in an environment that uses a jit - compiler .",
    "the technique uses the hardware page protection mechanism present in the processor to detect modifications made to already instrumented code .",
    "additionally , a number of optimisations have already been implemented to reduce the overhead , both by limiting the number of protection faults that occurs and the number of comparisons that must to be performed .    in the near future",
    ", a number of extra optimisations will be implemented , such as keeping more than one page unprotected at a time and the possibility to specify code regions that will not be modified , thus avoiding page protection faults caused by data and code being located on the same page .",
    "additionally , we are also adapting the _ diota _ framework in such a way that every thread gets its own clone and lookup table .",
    "this will greatly reduce the need for locking and disabling / restoring signals , which should also result in a significant speedup for the programs that perform a large number of lookups .",
    "derek bruening , evelyn duesterwald , and saman amarasinghe .",
    "design and implementation of a dynamic optimization framework for windows . in _ proceedings of the 4th acm workshop on feedback - directed and dynamic optimization ( fddo-4 ) _ , austin , texas , december 2001 .",
    "s.  eggers , d.  keppel , e.  koldinger , and h.  levy .",
    "techniques for efficient inline tracing on a shared - memory multiprocessor . in _",
    "sigmetrics conference on measurement and modeling of computer systems _ , volume  8 , may 1990 .",
    "barton  p. miller , mark  d. callaghan , jonathan  m. cargille , jeffrey  k. hollingsworth , r.  bruce irvin , karen  l. karavanic , krishna kunchithapadam , and tia newhall . .",
    "28(11):3744 , november 1995 .",
    "special issue on performance evaluation tools for parallel and distributed computer systems .",
    "jonas maebe , michiel ronsse , and koen de  bosschere . : dynamic instrumentation , optimization and transformation of applications . in _ compendium of workshops and tutorials , held in conjunction with pact02",
    ": international conference on parallel architectures and compilation techniques _ , charlottesville , virginia , usa , september 2002 .",
    "michiel ronsse and koen de  bosschere .",
    "jiti : a robust just in time instrumentation technique .",
    "volume  29 of _ series computer architecture news _ , chapter proceedings of workshop on binary translation - 2000 , pages 4354 .",
    "acm press , march 2001 .",
    "k.  scott , n.  kumar , s.  velusamy , b.  childers , j.  w. davidson , and m.  l. soffa .",
    "retargetable and reconfigurable software dynamic translation . in",
    "_ proceedings of the international symposium on code generation and optimization 2003 _ , san francisco , california , march 2003 ."
  ],
  "abstract_text": [
    "<S> adding small code snippets at key points to existing code fragments is called instrumentation . </S>",
    "<S> it is an established technique to debug certain otherwise hard to solve faults , such as memory management issues and data races . </S>",
    "<S> dynamic instrumentation can already be used to analyse code which is loaded or even generated at run time . with the advent of environments such as the java virtual machine with optimizing just - in - time compilers , </S>",
    "<S> a new obstacle arises : self - modifying code . in order to instrument this kind of code correctly </S>",
    "<S> , one must be able to detect modifications and adapt the instrumentation code accordingly , preferably without incurring a high penalty speedwise . in this paper </S>",
    "<S> we propose an innovative technique that uses the hardware page protection mechanism of modern processors to detect such modifications . </S>",
    "<S> we also show how an instrumentor can adapt the instrumented version depending on the kind of modificiations as well as an experimental evaluation of said techniques .     </S>",
    "<S> elis , ghent university , sint - pietersnieuwstraat 41 , 9000 gent , belgium    @ifundefined </S>"
  ]
}