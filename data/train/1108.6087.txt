{
  "article_text": [
    "autonomous unmanned aerial or ground vehicles , which function as systems of networked mobile robots , will play important roles in future military and commercial applications .",
    "the communications for such systems will typically be over wireless links and may require that the robots form an ad hoc network and communicate on a peer - to - peer basis  @xcite . in this scenario , the total amount of traffic generated in sending information across the network will depend both on the information flows to be transmitted , as well as the topology of the network .",
    "the latter consideration is because of the need for intermediate nodes to relay information between a source and destination .",
    "thus , the _ aggregate data traffic _ , which includes all of the data transmissions from sources and relays will generally be much larger than the total traffic flow from the sources . in this paper",
    ", we focus on data traffic only and do not consider the impact of control traffic , and thus use the term _ aggregate traffic _ in place of aggregate data traffic from here on .",
    "since the robots are mobile , the aggregate traffic can be reduced by reconfiguring the network topology to move some of the communicating robots closer together .",
    "we consider networks in which the network connectivity must be maintained at all times , and any movement scheme must take this into account . in addition , the mobile robots may have finite energy that limit the extent of their movement or may be otherwise constrained in their movement because of their other duties , such as sensing .",
    "thus , we consider the problem of optimizing the network topology to minimize the aggregate traffic in a network to support a given set of data flows , under constraints on the amount of movement possible at each mobile robot . in the case that the mobile robots do not have any energy constraints and the shape of the final network topology ( a graph consisting of sets of edges and vertices , but not the assignment of robots to vertices ) is already defined , this problem falls in the class of resource allocation problems known as quadratic assignment problems  @xcite .",
    "unfortunately , even for this simpler subclass of problems , the problem is np - hard , and thus there are no known solutions that run in polynomial time .",
    "there are many previous papers on formation control of mobile robots .",
    "for instance  @xcite considers centralized solutions to reconfigure the physical topology of a group of networked mobile robots to achieve a desired final topology while avoiding obstacles and collision . in  @xcite ,",
    "a decentralized topology control approach is presented , but network connectivity is not considered . in  @xcite , a decentralized topology control approach is developed to achieve a desired physical network formation while maintaining network connectivity , given that the network is already in the desired network topology . in  @xcite",
    ", new approaches are developed to reconfigure a network topology from an arbitrary initial connected graph to a specified desired tree topology , when there are no constraints on the amount of movement of the nodes .",
    "the fundamental idea of the approach in  @xcite is that robots that are not in the desired topology are `` routed '' through the network topology to transform the network while maintaining connectivity . in  @xcite ,",
    "all nodes are considered identical , and prefix labelling and routing techniques ( cf .",
    "@xcite ) are used to assign labels and routes .    in this paper , we consider problems where the initial topology is given , but the final topology must be chosen to minimize the aggregate traffic in the network , under constraints on the amount of movement of the robots .",
    "we consider the scenario in which the initial and final network topologies are trees . in our optimization algorithms , we use the amount of movement required for topology reconfiguration with a prefix routing approach , so that network connectivity is ensured at all times .",
    "we find exact and greedy algorithms to minimize the aggregate traffic .",
    "the performance of the algorithms are evaluated and compared using simulations .",
    "we consider a system of mobile robots that communicate over wireless links with limited communication distance .",
    "it is convenient to represent the induced network topology as a simple graph @xmath0 , where vertices @xmath1 represent the robots , and an edge @xmath2 between vertices @xmath3 and @xmath4 indicates that @xmath3 and @xmath4 can communicate over a wireless link .",
    "let @xmath5 be the set of data flows , where @xmath6 denote the amount of traffic from source @xmath3 to destination @xmath4 and @xmath7 denotes the cartesian product of @xmath8 with itself .",
    "then the aggregate traffic over network topology @xmath8 is @xmath9 where the distance function @xmath10 is the number of edges in the shortest path between vertices @xmath3 and @xmath4 in @xmath8 .",
    "the initial network topology is assumed to be a tree and is labeled @xmath11 .    in order to facilitate our later algorithms , a root node is chosen in @xmath12 , and prefix labeling is applied starting at the root to give a prefix tree , or _",
    "trie_. the distance between nodes in the trie can be simply determined by its prefix label .",
    "we first find the largest prefix that is common to the labels of both nodes .",
    "this is the prefix label of a common parent of both node in the tree .",
    "then the shortest path between two nodes is up to the common parent and then back down to the other node .",
    "hence the total distance is sum of the distance from each of them to their common parent .",
    "let @xmath13 denote the prefix label assigned to node @xmath3 .",
    "let @xmath14 denote the length of the prefix label of node @xmath3 , and @xmath15 denote the maximum length prefix in common to the prefix labels of nodes @xmath3 and @xmath4 .",
    "then @xmath16 + [ { \\ensuremath{\\operatorname{l}}}(\\lambda_{v } ) - { \\ensuremath{\\operatorname{l}}}(\\lambda_{u},\\lambda_{v})].\\ ] ]    as can be seen from , the larger the distance between two nodes that share a data flow , the greater the aggregate traffic in the network , since the same message will be relayed at every intermediate node between them . to minimize the aggregate traffic in the absence of any energy constraints ,",
    "then any final connected graph topology @xmath17 is possible .",
    "let @xmath18 be the connectivity function , which takes on the value 1 when the final topology is connected and 0 otherwise .",
    "then we wish to find @xmath19 that satisfies @xmath20    now , if we constrain that each node has limited energy , then some final graph topologies may no longer be possible .",
    "moreover , the constraint that the network be connected at all times will also limit which final topologies are possible in this scenario .",
    "for instance , if a node is to move up the tree , then all of its children must have sufficient energy to at least move up to connect with that node s parent .",
    "let @xmath21 denote the number of vertices in the graph that each node may move before its energy budget is expended , and let @xmath22 .",
    "let @xmath23 be a feasibility function , which takes on the value 1 when the final topology is feasible under the energy constraint and 0 otherwise .",
    "then the aggregate traffic minimization under the energy and network connectivity constraints can be formulated as : @xmath24 we determine @xmath25 based on transforming the topology using the prefix - routing approach described in the next section .",
    "[ fig : initial_1 ]   [ fig : desired_1 ]     before addressing techniques to solve , we describe how the network topology control method of  @xcite can be utilized in this application , in which nodes are not identical . in this section",
    ", we assume that both the initial topology @xmath12 and the final topology @xmath17 are known .",
    "we begin by choosing a node in the initial topology to serve as the root of the tree . in this paper , we assume that the root is chosen at random . as an alternative , the root may also be chosen according to some criteria ; the design of root - selection algorithms is outside the scope of this paper . as mentioned in , the root then assigns unique prefix labels to each of its children , which assign unique prefix labels to their children , etc .",
    ", until the entire tree has prefix labels . in prefix labels ,",
    "the label of a vertex s parent node is a prefix of that node s label .",
    "the initial tree topology @xmath11 becomes a prefix tree , or _",
    "the prefix label assigned to each node serves as its network address .",
    "we explain the prefix - routing approach to network topology control using the example topologies shown in .",
    "node  a has been selected to be the root .",
    "prefix labels are then assigned to all nodes in the initial network starting from a root , as shown in . after prefix label assignment",
    "is done for the initial network tree , each node sends a message including its own prefix label and identity to the root .",
    "after the root obtains all messages from each node , it will have a knowledge of the initial network graph .",
    "the root will then label all the nodes in the desired network tree with the prefix label assigned to the same node in the initial tree .",
    "the desired network tree after label assignment is completed is shown in  .",
    "[ fig : initial_2 ]   [ fig : desired_2 ]     the root searches for nodes that need to move between the initial and final topologies , starting from the top to the bottom of the tree , in a breadth - first manner .",
    "the nodes that must move are those whose prefix label does not correspond to the position where it is located in the desired tree .",
    "the label for a node should always be of the form @xmath26 where @xmath27 denote the prefix label of parent s children , @xmath28 is the concatenate operator , and @xmath29 is the unique suffix .",
    "nodes that do not have the correct prefix label must move from their position in the initial topology , and hence are called _ moving nodes_. nodes that have the correct prefix label and that have not been previously assigned to be a moving node ( see more below ) are _ nonmoving nodes_.    for the example network , all of the nodes that are one edge away from the root have the correct prefix label and thus are nonmoving nodes .",
    "next , the root considers all nodes that are two edges away ( it s children s descendants ) .",
    "as shown in , the node with label @xmath30 has a correct prefix label , but the node with label @xmath31 does not have a correct prefix label .",
    "thus , node @xmath31 will be a moving node .",
    "if a parent moves , it will cause network connectivity to break for its children , so all of the descendants of a moving node must also be moving nodes .",
    "for instance , since @xmath31 is a moving node , its child @xmath32 must also be a moving node .",
    "so , even though @xmath32 initially has a prefix label that matches its parent in , it is still a moving node .    for each moving node ,",
    "the root records two labels : ( 1 ) its    anchor - node label    is the label of the non - moving node that will be the moving node s destination , and ( 2 ) its    desired label    is the new label of the moving node upon an arrival at the destination in the desired topology .",
    "when the root has already considered all nodes in the desired tree , the root will send a message * m.dest * including both labels to each moving node .",
    "a moving node then first move to the node whose prefix label is the anchor - node label .",
    "when a moving node arrives at a non - moving node , the non - moving node first looks for the moving node s anchor - node label to see if it match its prefix label . if it does , it will serve as the anchor node for that moving node , and it then uses the desired label of that moving node to forward the moving node to the right position in the desired graph .",
    "the moving node will be relabeled to match the desired label once it reaches its final position , which will make its prefix label correspond to its position in the desired network topology .",
    "the desired label of a moving node can be simply determined from its parent in the desired topology as given in  .",
    "if its parent is a moving node , its parent must already be assigned the desired label by the root , and the moving node s desired label is determined from the desired label of its parent . if its parent is a nonmoving node , the desired label is determined from its parent prefix label .",
    "when the moving nodes 011 and 0111 receive a message * m.dest * from the root including both the anchor - node and desired labels , it will move through the initial network toward anchor node 02 by using maximum prefix matching logic .",
    "when a moving node 011 and 0111 are able to connect to the anchor node 02 , anchor node 02 will look at their anchor labels to check if 02 is their anchor node .",
    "once node 02 determines that it is the anchor node for 011 and 0111 , node 02 will check the desired label of both of the nodes .",
    "the desired labels are 022 and 0221 , respectively , and 02 will use these labels to forward nodes 011 and 0111 to the right positions in the desired topology . after both nodes arrive at the desired position , their labels will be changed to the desired labels , which will make their prefix labels correspond to their position in the desired network topology .",
    "consider now how nodes should be move from their positions in the initial topology to their positions in the desired topology without breaking network connectivity . generally ,",
    "if there are multiple moving nodes in the initial topology , whenever they receive a message from a root , they can start moving simultaneously .",
    "however , a moving node that is not a leaf node has to wait for its descendants to move up to it before it can start moving . otherwise , the node s descendants will be disconnected from the network . for example , consider again nodes 011 and 0111 in .",
    "node 011 can not move first , since that would break network connectivity to node 0111 ; in general , a parent node can not move  all of its children must move first to make it a leaf node . thus , node 0111 first has to move up to node 011 until it is able to connect to node 01 .",
    "then both nodes 011 and 0111 can continue moving up to the root , passing by node 01 , until they are able to connect with node 02 .",
    "once node 011 connects with 02 ( at the time it reaches the root ) , it will be immediately relabeled as 022 to make the label of the node 011 conform the prefix tree . then node 0111 will move toward the node 02 until it is able to connect to node 011 which is already relabeled as 022 .",
    "finally , the node 0111 will be relabeled as 0221 to achieve the desired topology that has all the node s label conform the prefix tree .",
    "an example of this method is shown in  , and the pseudocode of a label assignment algorithm for a root is given in algorithm 1 .",
    "[ fig : trans_1 ]   [ fig : trans_2 ]   [ fig : trans_3 ]   [ fig : trans_4 ]   [ fig : trans_5 ]     p8 cm     +    @xmath33= @xmath34 = * false * @xmath35 @xmath36 @xmath37     +",
    "in this section , we present techniques to solve under the additional constraint that the network topology is reconfigured around a root node , as described in .",
    "the root controls the network topology and wishes to select a final topology that minimizes the aggregate traffic , under the energy constraints that limit each node s movement .",
    "the distance that a node must move to transition from the initial to the final topology is @xmath38 where @xmath4 is the moving node and @xmath39 is the anchor node of @xmath4 .",
    "for instance in the example of , node @xmath40 must move to within one hop of its new parent , which is @xmath41 or @xmath42 .",
    "thus , node @xmath40 moves up to the root , at which point it is within one hop of @xmath42 and can thus be relabeled @xmath43 to achieve the desired position by only moving two hops .    with the additional constraint that the topology reconfiguration occurs around the root and using the constraints on the amount of movement of a node , the optimization problem can be formulated as @xmath44    before presenting algorithms to solve this problem , we first consider the necessary scope of the search by evaluating which nodes may need be moved between @xmath12 and @xmath17 .",
    "we partition the nodes in to _ active nodes _ , which have a data flow to or from other nodes , and _ passive nodes _ , which do not have a data flow to or from other nodes .",
    "note that passive nodes may still act as relays for other nodes data flows . to conserve energy ,",
    "it is best to not move passive nodes unless it is required to allow active nodes to move . to decide",
    "which node should be repositioned , we first considered those active nodes that have enough energy to move at least one hop .",
    "such nodes are the initial members of the _ active moving node set _ , @xmath45",
    ". however , the initial members of @xmath45 may not all be free to move because network connectivity must be maintained , and under our prefix topology reconfiguration approach , a node can not move while it still has children .",
    "thus , for a node to remain in @xmath45 , all of it descendants must have sufficient energy to reach that node and hence be able to establish communication with that node s parent .",
    "hence all descendants of a node in @xmath45 must be able to move a number of hops given by @xmath46 where @xmath47 denote the descendant of node @xmath4 belonging to @xmath45 .",
    "any of the descendants of a moving node @xmath4 must have enough energy to move up at least on hop to properly connect to the parent node of @xmath4 to maintain the network connectivity .",
    "nodes in @xmath45 that do not have any children are free to move as far as their energy constraint allows .",
    "the nodes in @xmath45 whose descendants maximum possible movements @xmath48 do not satisfy   are removed from @xmath45 because they can not be moved .",
    "furthermore , any passive nodes that are children of nodes that remain in @xmath45 may be moved and are put in another set called the _ passive moving node set _ , @xmath49 .",
    "this node classification algorithm is formalized in algorithm 2 .",
    "p8 cm     +     +    after the root finds @xmath45  and @xmath49 , a subgraph @xmath50 is formed by removing all vertices in @xmath45  and @xmath49 , along with all associated edges .",
    "all the nodes from both sets can move and will become descendants of at least one node in @xmath51 according to the optimal or greedy algorithms described below .      for a root to achieve an optimal achievable topology , it essentially has to consider all possible tree topologies and select the final topology based on the achievable tree that gives the minimum aggregate data traffic . in this section ,",
    "we provide details about how the the optimal solution can be found , subject to the constraint that the topology is reorganized around a pre - selected root .",
    "we use the branch - and - bound technique to limit the complexity of this combinatorial search .",
    "as described above , the root first obtains the active and passive moving node sets using algorithm 2 , as well as the subgraph @xmath51 of non - moving nodes .",
    "a brute - force solution is for the root to consider all nodes in the active moving node set and to evaluate the aggregate data for all achievable tree topologies @xmath8 such that @xmath52 .",
    "this can be done by finding all permutations of the nodes in @xmath45  and then for each permutation , each node from this permutation is attached in order one by one from the first to the last to a tree in every possible way .",
    "the order of the placement is important because the nodes in @xmath45  can attach not only to the nodes in @xmath51 but also to other nodes in @xmath45that have already been placed .",
    "after the nodes in @xmath45  are placed , the nodes that need to move in @xmath49  are then repositioned to the places that are closest to their original positions .    the complexity of the brute - force combinatorial search can be reduced by applying the branch - and - bound method  @xcite .",
    "the idea in branch - and - bound is that all partial and complete solutions are represented by nodes on a tree , in which a leaf of this tree indicates a complete solution .",
    "the search for the best solution starts from the root of the tree . at each search node , the algorithm tries to determine if a branch can be pruned , which is possible if the lower bound on the aggregate traffic is greater than the upper bound for the aggregate traffic in some other branch , as such branches can never yield the optimum solution .",
    "the search is performed until all the nodes in the tree are examined or pruned .    in this paper",
    ", we use a simple approach to branch - and - bound based on a depth - first tree search across node assignments , one permutation at a time . for convenience of description , we index the levels of the tree , where the root is defined to be at level -1 .",
    "the children of the root are at level 0 and represent all possible permutations of @xmath45 . at level  1",
    "are all possible locations for the first node in the permutation of @xmath45 . at level  @xmath53",
    "are all possible locations for the @xmath53th node in the permutation of @xmath45  given all the previous locations of nodes @xmath54 , which are determined by the @xmath53th node s parent .",
    "the leaves represent a complete solution @xmath55 for a particular permutation of @xmath45 .",
    "the search proceeds in depth - first fashion , first by selecting one permutation and then by trying one allocation of all nodes . at each node",
    "the minimum aggregate traffic can be lower bounded by the aggregate traffic from the nodes that have already been assigned positions plus the sum of the remaining data flows .",
    "once the depth - first search has reached a leaf node , we have one possible solution to the minimum aggregate traffic , and we use this as an upper bound on the best minimum aggregate traffic over all nodes . then as we proceed down other branches , we eliminate a branch whenever the lower bound for that branch exceeds the upper bound on the optimal solution , which is given by the best solution found so far . whenever the search reaches a leaf of the tree , the aggregate traffic will be checked and compared with the best solution found . if this value is better than the best solution , it will then be recorded as a new best feasible complete solution and this complete solution @xmath55 will also be recorded as the best possible solution found .",
    "the optimal solution is found when all nodes have been considered or pruned . because our branch - and - bound approach uses depth - first search , it is most easily implemented using recursion , and we omit the detailed algorithm here .",
    "to give an idea of the working of this algorithm , we give a nonrecursive form of the algorithm for an active moving node set with three nodes in algorithm  3 .",
    "p8 cm     +    @xmath56,v } +    f_{\\mathbf{v , p}[j ] } \\right)$ ]    @xmath57 = @xmath58 = ( @xmath45 )     +    after an optimal solution or optimal topology is obtained by using branch - and - bound method , in order to obtain the complete desired topology @xmath19 , the passive moving nodes have to be attached to the optimal topology @xmath8 that gives the minimum aggregate traffic .",
    "each passive moving node is attached to the optimal topology obtained from the branch - and - bound method in such a way that the amount of movement of the passive moving nodes is minimized , @xmath59 this can be done in a simple iterative process , which is summarized in algorithm  4 .",
    "p8 cm     +    @xmath60     +      even with the use of branch - and - bound to reduce the number of solutions that must be evaluated , the complexity of finding the optimal solution can still be very high .",
    "this motivates us to consider a strategy that can find a suboptimal solution to the optimization problem but with much lower complexity .",
    "greedy algorithms are strategies to address optimization problems built under the premise that a globally optimal , or at least a good solution , can be found by making a series of locally optimal choices  @xcite . the greedy method is applied to find a solution to after a root has been determined and the root obtains the active and passive moving node sets by using algorithm 2 .",
    "the idea is to build an achievable tree with low aggregate traffic , starting from a subgraph @xmath51 of non - moving nodes .",
    "the greedy algorithm is performed iteratively .",
    "before the first step the working graph @xmath8 is set equal to @xmath51 . at each iterative step , every node that has not yet been assigned a position in the working graph is evaluated . for each such node , the achievable locations are found for it that minimize the aggregate traffic , by exhaustive search .",
    "the node and its location that achieves the minimum aggregate traffic can be formalized mathematically in the solution to @xmath61 the greedy algorithm is summarized in algorithm  5 .",
    "p8 cm     +    @xmath8 = @xmath51     +    after the active nodes are assigned positions , the root then assigns the positions of each node in the passive moving node set , using algorithm  4 .",
    "in this section , we briefly analyze the complexity of the optimization algorithms given in .",
    "the complexity of the algorithms is important because it gives a guideline as to how useful these algorithms will be when applied to large networks with large active moving sets .",
    "the worst case running time for the optimal algorithm occurs under the following conditions :    * all of the nodes except the root are active moving nodes , * all of the nodes have a very large maximum possible hop , @xmath48 , such that they can be moved to any part of the graph , and * the value of each solution found from the solution tree is monotonically decreasing .",
    "the last condition requires that the entire solution tree has to be traversed .",
    "let @xmath53 denote the number of nodes in @xmath62 .",
    "then the worst case running time for the optimal algorithm is @xmath63 hence @xmath64 .",
    "thus , although the optimal algorithm could be used to obtain the graph topology to achieve the minimum aggregate traffic , this algorithm has high complexity when the size of the active moving set becomes large .",
    "the worst case running time for the greedy algorithm also occurs when all the nodes except the root are active moving nodes and is given by @xmath65 it is easy to show that @xmath66 , and the greedy algorithm has polynomial - time complexity .",
    "thus , the greedy algorithm has a much lower complexity for large networks than the optimal algorithm ; however , it is not guaranteed to find the optimal solution .",
    "in this section , we evaluate and compare the performance of both the greedy and exact algorithms to minimize aggregate traffic for small networks of 3 to 15 nodes . for each size network , we distribute a total flow of 1  mbps randomly among all possible source - destination pairs according to a uniform distribution .",
    "a total of 50 different flow allocations are used to generate our numerical results . for each flow allocation",
    ", an initial tree topology is randomly selected from among the possible trees for the network .",
    "finally , for each topology and data flow , the maximum possible hop @xmath48 at each node is selected randomly according to a uniform random variable ranging from 0 to a specified @xmath67 .",
    "we repeat the same experiments for different values of @xmath67 .",
    "we report results for @xmath67 values of 1 , 3 , and 10 hops . for the optimal algorithm ,",
    "we report results for network sizes up to 7 nodes . beyond that , the complexity of the optimal algorithm required too much running time .",
    "the average aggregate traffic achieved by the optimal and greedy algorithms is shown in as a function of the network size .",
    "also shown is the initial aggregate traffic before optimization .",
    "it can be observed that when the network size is small , the greedy and optimal algorithms provide similar performance , since there are a limited number of possible candidate topologies to be considered .",
    "a root does not have many options to reposition its own children in @xmath11 , and the nodes in the small network are already close to each other .",
    "thus , little reduction in aggregate traffic is possible .",
    "as the network size grows larger , the amount of energy at each node that is available for repositioning plays an important role in the final aggregate traffic , especially for the optimal algorithm . for instance , for a network with seven nodes , if @xmath68 , the minimum aggregate traffic is approximately 2 .",
    "if @xmath69 , the minimum aggregate traffic is approximately 1.6 .",
    "thus , the optimal algorithm is able to leverage the additional degrees of freedom to better reconfigure the network . on the other hand",
    ", large @xmath67 also translates into more feasible network topologies , which can slow the execution of the optimization algorithm .",
    "the greedy algorithm does gain from increasing the amount of allowed movement , but not as dramatically as the optimal algorithm .",
    "the performance of both algorithms can potentially be improved by considering the best aggregate traffic that can be achieved for multiple choices of the tree s root .",
    "we fix the network to consist of five nodes , and we choose the flows and topologies randomly as before . for each topology",
    ", we select multiple roots at random and choose the root that results in the minimum aggregate traffic .",
    "the results are averaged over all generated random topologies with different flow allocations .",
    "the results are shown in   for different values of @xmath67 as a function of the number of roots considered .",
    "it can be observed that the selection of the root affects the minimum aggregate traffic that can be achieved .",
    "the more roots that are considered , the lower the minimized aggregate data traffic for both the greedy and optimal algorithms . similarly , the higher @xmath70 , the lower minimized aggregate traffic since there will be more candidate solutions .",
    "the selection of a root matters since each node in the network may have different limited amount of movement .",
    "if each node in the network has an unlimited amount of movement , the network topology can be transformed to any network topology using the method given in  , no matter which node is selected to be a root . however , some node that is selected to be a root in @xmath11 may lead to more achievable network topologies than when others are selected as the root .",
    "hence the root selection is one of an important issue for the future work .",
    "in this paper , we developed algorithms to reconfigure the network topology of a systems of mobile robots to minimize the aggregate traffic in the network , under a constraint on the amount of energy available for movement by each robot .",
    "we also constrain our network to maintain network connectivity at all times , and so we develop our optimization algorithms under a framework in which the robots are routed through the network in such a way that network connectivity is maintained .",
    "we developed optimal and greedy algorithms to minimize the aggregate traffic under the specified constraints , and we provide complexity and performance comparisons .",
    "the results show that although both algorithms can decrease the aggregate traffic , the greedy algorithm does not achieve performance close to that of the optimal algorithm . on the other hand ,",
    "the greedy algorithm has only polynomial complexity , versus factorial - squared complexity for the optimal algorithm .",
    "the results also show that the performance of both algorithms improve with the amount of energy available for node movement and with the number of different roots for which the aggregate traffic is evaluated .",
    "h.  tanner and a.  kumar , `` towards decentralization of multi - robot navigation functions , '' in _ robotics and automation , 2005 .",
    "icra 2005 .",
    "proceedings of the 2005 ieee international conference on _ , apr .",
    "2005 , pp . 41324137 .",
    "a.  de  gennaro , m.c . ;  jadbabaie , `` formation control for a cooperative multi - agent system using decentralized navigation functions , '' in _ american control conference , 2006 _ , minneapolis , mn , jun .",
    "2006 , p. 6 pp .",
    "z.  kan , a.  p. dani , j.  m. shea , and w.  e. dixon , `` ensuring network connectivity via navigation function based decentralized formation control , '' submitted to _",
    "ieee trans .",
    "automatic control _ , january 2011 .",
    "z.  kan , s.  subramanian , j.  m. shea , and w.  e. dixon , `` ensuring network connectivity during formation control using a decentralized navigation function , '' in _ proc .",
    "ieee military commun .",
    "_ , san jose , california , nov .",
    "2010 , pp . 531536 .",
    "l.  navaravong , j.  m. shea , and w.  dixon , `` physical- and network - topology control for systems of mobile robots , '' in _ proc .",
    ". conf . _ , 2011 , pp .",
    "16 , accepted for publication .",
    "[ online ] .",
    "available : http://wireless.ece.ufl.edu/jshea/pubs/bom_milcom2011.pdf        j.  j. garcia - luna - aceves and d.  sampath , `` scalable integrated routing using prefix labels and distributed hash tables for manets , '' in _ proc .",
    "ieee mass 2009 : the 6th ieee international conference on mobile ad hoc and sensor systems _ , macau sar , p.r.c .",
    ", oct . 2009 ."
  ],
  "abstract_text": [
    "<S> systems of networked mobile robots , such as unmanned aerial or ground vehicles , will play important roles in future military and commercial applications . </S>",
    "<S> the communications for such systems will typically be over wireless links and may require that the robots form an ad hoc network and communicate on a peer - to - peer basis . in this paper , we consider the problem of optimizing the network topology to minimize the total traffic in a network required to support a given set of data flows under constraints on the amount of movement possible at each mobile robot . in this paper </S>",
    "<S> , we consider a subclass of this problem in which the initial and final topologies are trees , and the movement restrictions are given in terms of the number of edges in the graph that must be traversed . </S>",
    "<S> we develop algorithms to optimize the network topology while maintaining network connectivity during the topology reconfiguration process . </S>",
    "<S> our topology reconfiguration algorithm uses the concept of prefix labelling and routing to move nodes through the network while maintaining network connectivity . </S>",
    "<S> we develop two algorithms to determine the final network topology : an optimal , but computationally complex algorithm , and a greedy suboptimal algorithm that has much lower complexity . </S>",
    "<S> we present simulation results to compare the performance of these algorithm . </S>"
  ]
}