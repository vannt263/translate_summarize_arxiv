{
  "article_text": [
    "following spectacular advances made over the last years , the satsolving technology has many successful applications nowadays  there is a wide range of problems being solved by reducing them to sat . very often solving based on reduction to satis more efficient than using a problem - specific solution .",
    "therefore , satsolvers are already considered to be a _",
    "swiss army knife _ for solving many hard cspand np - complete problems and in many areas including software and hardware verification , model checking , termination analysis , planning , scheduling , cryptanalysis , electronic design automation , etc . @xcite .",
    "typically , translations into satare performed by specialized , problem - specific tools .",
    "however , using a general - purpose system capable of reducing a wide range of problems to satcan simplify this task , make it less error prone , and make this approach more easily accessible and more widely accepted .",
    "there are already a number of approaches for solving combinatorial and related problems by general - purpose systems that reduce problems to underlying theories and domains ( instead of developing special purpose algorithms and implementations ) .",
    "a common motivation is that it is much easier to develop a problem specification for a general system than a new , special - purpose solver .",
    "the general problem solving systems include libraries for general purpose programming languages , but also modelling and programming languages built on top of specific solvers @xcite .",
    "most modelling languages are highly descriptive and have specific language constructs for certain sorts of constraints .",
    "specific constraints are translated to underlying theories by specific reduction techniques .",
    "some modelling systems use satas the target problem @xcite and some of them focus on solving np - complete problems by reduction to sat@xcite .",
    "in this paper we present a novel approach for solving problems by reducing them to sat .",
    "the approach can be seen also as a general - purpose constraint programming system ( for finite domains ) .",
    "the approach consists of a new specification / modelling language ursa(from _ uniform reduction to sat _ ) and an associated interpreter .",
    "in contrast to other modelling languages , the proposed language combines features of declarative and imperative programming paradigms .",
    "what makes the language declarative is not how the constraints are expressed , but only the fact that a procedure for finding solutions does not need to be explicitly given . on the other hand , the system has features of imperative languages and may be seen as an extension of the imperative programming paradigm , similarly as some constraint programming systems are extensions of logic programming paradigm .",
    "in contrast to other modelling languages , in the proposed specification language loops are represented in the imperative way ( not by , generally more powerful , recursion ) , destructive updates are allowed , there is support for constraints involving bitwise operators and operators for arithmetic modulo @xmath0 .",
    "there are problems for which , thanks to these features , the modelling process is simpler and specifications are more readable and easier to maintain than for other languages and constraint systems . however , of course , the presented system does not aim to replace other constraint systems and languages , but rather to provide a new alternative with some distinctive features .",
    "the used uniform approach enables a simple syntax and semantics of the ursalanguage , a simple , uniform reduction to satand , consequently , a simple architecture of the whole system .",
    "this enables a straightforward implementation of the proposed system and a rather straightforward verification of its correctness .",
    "this is very important because , although it is often easier for a declarative program than for a corresponding imperative program to verify that it meets a given specification , this still does not lead to a high confidence if the constraint solving system itself can not be trusted .",
    "the presented approach is accompanied with an open - source implementation , publicly available on the internet .",
    "a limited experimental comparison suggest that the system ( combined with state - of - the - art satsolvers ) yields good performance , competitive to other modern approaches .    [ [ overview - of - the - paper . ] ] overview of the paper .",
    "+ + + + + + + + + + + + + + + + + + + + + +    in section [ sec : background ] we give relevant definitions ; in section [ sec : representation ] we provide motivation and basic ideas of the proposed approach . in section [ sec : ursa_language ] we describe the specification language ursa , in section [ sec : ursa_semantics ] its semantics , in section [ sec : ursa_interpreter ] the corresponding interpreter , and in section [ sec : pragmatics ] pragmatics of the language . in section [ sec : related_work ] we discuss related techniques , languages and tools . in section [ sec : future_work ] we discuss directions for future work and in section [ sec : conclusions ] we draw final conclusions .",
    "in this section we give a brief account of the satand cspproblems and related notions .",
    "[ [ propositional - logic . ] ] propositional logic .",
    "+ + + + + + + + + + + + + + + + + + + +    we assume standard notions of propositional logic : _ literal _ , _ clause _ , _ propositional formula _ , _ conjunctive normal form _ ( cnf ) , _ valuation _ ( or _ assignment _ ) , _ interpretation _ , _ model _ , _ satisfiable formula _ , etc .",
    "we denote by @xmath1 and @xmath2 the boolean constants _ true _ and _ false _ and the logical connectives by @xmath3 ( _ negation _ ) , @xmath4 ( _ conjunction _ ) , @xmath5 ( _ disjunction _ ) , @xmath6 ( _ exclusive disjunction _ ) , @xmath7 ( _ implication _ ) , @xmath8 ( _ equivalence _ ) .",
    "two formulae @xmath9 and @xmath10 are said to be _ equivalent _ if @xmath9 and @xmath10 have the same truth value in any valuation .",
    "two formulae @xmath9 and @xmath10 are said to be _ weakly equivalent _ ( or _ equisatisfiable _ ) if whenever @xmath9 is satisfiable then @xmath10 is satisfiable and vice versa .    [",
    "[ constraint - satisfaction - problem . ] ] constraint satisfaction problem .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a constraint satisfaction problem ( csp ) is defined as a triple @xmath11 , where @xmath12 is a finite set of variables @xmath13 , @xmath14 , @xmath15 , @xmath16 , @xmath17 is a set of domains @xmath18 , @xmath19 , @xmath15 , @xmath20 for these variables , and @xmath21 is a set of constraints @xmath22 , @xmath23 , @xmath15 , @xmath24 . in a finite - domain csp ,",
    "all sets from @xmath17 are finite .",
    "constraints from @xmath21 may define combinations of values assigned to variables that are _ allowed _ or that are _",
    "prohibited_. a problem instance is satisfiable if there is an assignment to variables such that all constraints are satisfied .",
    "such assignment is called a _ solution_.",
    "a constraint optimization problem is a cspin which the goal is to find a solution maximizing ( or minimizing ) a given _ objective function _ over all allowed values of the given variables .",
    "[ [ satproblem - and - satsolvers . ] ] satproblem and satsolvers .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    satis the problem of deciding if a given propositional formula in cnfis satisfiable , i.e. , if there is any assignment to variables such that all clauses are true .",
    "obviously , satis a special case of csp , with all variables ranging over the domain @xmath25 and with constraints given as clauses .",
    "satwas the first problem shown to be np - complete @xcite , and it still holds a central position in the field of computational complexity .",
    "stochastic satsolvers can not prove the input instance to be unsatisfiable , but may find a solution ( i.e. , a satisfying variable assignment ) for huge satisfiable instances quickly . on the other hand , for a given satinstance , a complete satsolver always finds a satisfying variable assignment or shows that there is no such assignment .",
    "most of the state - of - the - art complete satsolvers are cdcl ( conflict - driven , clause - learning ) based extensions of the davis - putnam - logemann - loveland algorithm ( dpll ) @xcite . in recent years , a tremendous advance has been made in satsolving technology @xcite .",
    "these improvements involve both high - level and low - level algorithmic techniques .",
    "the advances in satsolving make possible deciding satisfiability of some industrial satproblems with tens of thousands of variables and millions of clauses .",
    "there are two basic components of the presented approach :    @xmath26    problem specification : a problem is specified by a test ( expressed in an imperative form ) that given values of relevant variables are indeed a solution to the problem .",
    "problem solving : all relevant variables of the problem are represented by finite vectors of propositional formulae ( corresponding to vectors of bits and to binary representation , in case of numerical values ) ; the specification is symbolically executed over such representation and the assertion that given values make a solution is transformed to an instance of the satproblem and passed to a satsolver . if the formula is satisfiable , its model is transformed back to variables describing the problem , giving a solution to the problem .",
    "let us consider problems of the following general form : _ find ( if it exists ) a set of values @xmath27 such that given constraints are met _",
    "( variations of this form include : only checking if such values exists , and finding all values that meet the given conditions ) .",
    "a problem of this form can be specified by a test that checks if a given set @xmath27 meets the given constraints ( with one assertion that combines all the constraints ) .",
    "the test can be formulated in a language designed in the style of imperative programming languages and such a test is often easy to formulate .",
    "[ ex : trivial ] let us consider a trivial problem : if @xmath28 equals @xmath29 , find a value for @xmath30 such that @xmath28 equals @xmath31 .",
    "a simple check in an imperative form can be specified for this problem  if a value of @xmath30 is given in advance , one could easily check whether it is a solution of the problem .",
    "indeed , one would assign @xmath29 to @xmath28 and finally check whether @xmath28 equals @xmath31 .",
    "such test can be written in the form of an imperative c - like code ( where assert(b ) checks whether b is true ) as follows :    .... v = u+1 ; assert(v==2 ) ; ....    the example above is trivial , but specifications may involve more variables and more complex operations , including conditional operations and loops , as illustrated by the following example .    the most popular way of generating pseudorandom numbers is based on linear congruential generators .",
    "a generator is defined by a recurrence relation of the form :    @xmath32    and @xmath33 is the _ seed _ value ( @xmath34 ) .",
    "one example of such relation is :    @xmath35    it is trivial to compute elements of this sequence .",
    "the check that @xmath36 is indeed equal to the given value if the seed is equal to @xmath37 can be simply written in the form of an imperative c - like code as follows ( assuming that numbers are represented by @xmath38 bits ) :    .... nx = nseed ; for(ni=1;ni<=100;ni++ )    nx = nx*1664525 + 1013904223 ; assert(nx==3998113695 ) ; ....    however , the following problem , realistic in simulation and testing tasks , is a non - trivial programming problem ( unless problem - specific , algebraic knowledge is used ) : given , for example , the value @xmath36 compute @xmath33 .",
    "still , the very same test shown above can serve as a specification of this problem .",
    "this example illustrates one large family of problems that can be simply specified using the proposed approach  problems that are naturally expressed in terms of imperative computations and that involve destructive assignments .",
    "such problems are often difficult to express using other languages and systems . for the above specification , since in constraint programming systems the destructive assignment is not allowed , in most specification languages one would have to introduce variables for all elements of the sequence from @xmath33 to @xmath36 and the constraints between any succeeding two . also , other systems typically do not support modular arithmetic constraints and integers of arbitrary length .",
    "note that the specifications given above also cover the information on what variables are unknown and have to be determined so that the constraints are satisfied  those are variables that appear within commands before they were defined .",
    "so , the above code is a full and precise specification of the problem , up to the domains of the variables . for boolean variables ,",
    "the domain is @xmath39 , while for numerical variables a common domain interval ( e.g. , @xmath40 $ ] ) can be assumed and additional domain restrictions can be given within the specification .",
    "the described imperative tests form problem specifications and they can be used as a starting point in problem solving .",
    "let us first describe a straightforward , naive approach .",
    "assume that there is a problem specification ( in the form of an imperative test ) and assume there is a common domain for all unknowns ( except boolean unknowns ) , for example , the interval @xmath40 $ ] ( for a given @xmath41 ) .",
    "then , for all admissible values for all unknowns , the specification can be executed .",
    "all sets of values satisfying the constraints should be returned as solutions .",
    "if there are @xmath42 unknown numerical variables and @xmath43 unknown boolean variables , then the search space would be of the size @xmath44 .",
    "let us consider the specification given in example [ ex : trivial ] .",
    "if the domain for @xmath30 and @xmath28 is the interval @xmath45 $ ] , the specification should be executed four times and only the value @xmath46 assigned to @xmath30 leads to the constraint met , so it is the only solution of the problem .",
    "obviously , the above naive and brute - force approach based on systematic enumeration of all possible input values is complete ( for finding all solutions ) , but extremely inefficient .",
    "it can be turned to a much more efficient version that takes into account given relationships between variables in order to reduce the search space .",
    "the basic idea is to represent all unknowns abstractly , in a symbolic form , as vectors of propositional formulae .",
    "then , all steps in the specification can be performed using this abstracted form ( i.e. , can be symbolically executed ) .",
    "finally , the assertion would generate a propositional formula for which a satisfying valuation is to be found .",
    "if there are @xmath42 unknown numerical variables and @xmath43 unknown boolean variables , then the number of possible valuations would be @xmath44 ( if the interval @xmath40 $ ] is assumed as the domain for numerical values ) .",
    "of course , instead of a brute - force search over this set of valuations , a satsolver should be used ( and it will typically perform many cut - offs and search over just a part of the whole search space ) .",
    "representation of numerical variables by propositional formulae corresponds to their binary representation .",
    "each formula corresponds to one bit of the binary representation .",
    "if the range of a numerical variable is @xmath40 $ ] , then it is represented by a vector of @xmath41 propositional formulae . if a bit of the number is known to be @xmath46 , then the corresponding formula is @xmath1 , and if a bit of the number is known to be @xmath47 , then the corresponding formula is @xmath2 .",
    "for instance , for @xmath48 , @xmath46 is represented by @xmath49 $ ] ( where the last position corresponds to the least significant bit ) .",
    "if a bit of the number is not known , then it is represented by a propositional variable , or , if it depends on some conditions , by a propositional formula .",
    "we will discuss only representations of unsigned integers , but representations of signed integers can be treated in full analogy ( moreover , floating point numbers can also be modelled in an analogous way ) .",
    "boolean variables are represented by unary vectors of propositional formulae .",
    "results of arithmetic and bitwise logical operations over numbers represented by vectors of formulae can be again represented by propositional formulae in terms of formulae occurring in the input arguments .",
    "if the numbers are treated as unsigned , all arithmetic operations are performed modulo @xmath0 .",
    "for instance , if @xmath30 is represented by @xmath50 $ ] and @xmath28 is represented by @xmath51 $ ] , then @xmath52 ( modulo @xmath53 ) is represented by @xmath54 $ ] .",
    "relational operations over numbers ( @xmath55 , @xmath56 , @xmath57 , @xmath58 , @xmath59 , @xmath60 , etc . ) and logical operations and relations over boolean values can also be represented .",
    "for instance , if @xmath30 is represented by @xmath50 $ ] and @xmath28 is represented by @xmath51 $ ] , then @xmath61 is represented by the unary vector @xmath62 $ ] .",
    "note that representations of all standard arithmetic , boolean , and relational operations produce polynomial size formulae .",
    "if a problem specification is executed over the variables represented by vectors of propositional variables and using the corresponding interpretation of involved operations , then the assertion of the specification generates a propositional formula . any satisfying valuation ( if it exists ) for that formula would yield ( ground ) values for numerical and boolean unknowns that meet the specification , i.e. , a solution to the problem .",
    "let us again consider example [ ex : trivial ] .",
    "if ` u ` is represented by @xmath50 $ ] ( and ` 1 ` is represented by @xmath49 $ ] ) , then , by the condition ` v = u+1 ` , ` v ` is represented by @xmath63 $ ] , i.e. , after simplification , by @xmath64 $ ] . from the assertion ` v==2 ` , it follows that @xmath64 $ ] should be equivalent to @xmath65 $ ] . in other words ,",
    "the formula @xmath66 should be checked for satisfiability .",
    "it is satisfiable , and in its only model @xmath67 maps to @xmath2 and @xmath68 maps to @xmath1 .",
    "hence , the representation for a required value of ` u ` is @xmath49 $ ] , i.e. , ` u ` equals 1 .      a system based on the ideas presented above , could be used not only for combinatorial problems , but for a very wide range of problems  it can be used for computing @xmath69 such that @xmath70 , given @xmath71 and a computable function @xmath72 with a finite domain and a finite range ( i.e. , for computing inverse of @xmath72 ) .",
    "a definition of @xmath72 in an imperative form can serve as a specification of the problem in verbatim .",
    "having such a specification of the function @xmath72 is a weak and realistic assumption as it is easy to make such specification for many interesting problems , including np - problems @xcite .",
    "if @xmath72 is a function such that @xmath73 when @xmath69 is a witness for some instance of an np - problem , @xmath72 can serve as a specification for this problem and the required answer is _ yes _ if and only if there is @xmath69 such that @xmath73 .    concerning the type of numbers involved",
    ", the approach can be applied for any finite representation of signed or unsigned , integer or floating point numbers .    in the proposed approach , all computations ( over integers )",
    "are performed modulo @xmath0 . in the case of non - modular constraints , the base can be set to a sufficiently large value .",
    "the approach ( in the presented form ) can not be used for computing @xmath69 such that @xmath70 , for arbitrary computable function @xmath72 .",
    "the first limitation is a finite representation of variables .",
    "the second is that conditional commands in the specification could involve only conditions with ground values at the time when the condition is evaluated . however",
    ", this restriction is not relevant for many ( or most of ) interesting problems .",
    "overall , the domain of the proposed approach covers all problems with boolean and numerical unknowns , over boolean parameters and numerical parameters with finite domains , that can be stated in the specification language that makes the part of the approach .",
    "in this section we describe the language ursathat serves as a specification language in the spirit of the approach presented above .",
    "a description of the syntax of the ursalanguage is given , in ebnf representation , in table [ tab : ursasyntax ] ( @xmath74num var@xmath75 denotes the syntactical class of numerical variables , @xmath74num expr@xmath75 denotes the syntactical class of numerical expressions , @xmath74bool expr@xmath75 denotes the syntactical class of boolean expressions , etc ) .",
    "an ursaprogram is a sequence of statements ( and procedure definitions ) .",
    "there are two types of variables  numerical , with identifiers starting with ` n ` and boolean , with identifiers starting with ` b ` .",
    "the same convention holds for identifiers of arrays .",
    "variables are not declared , but introduced dynamically .",
    "there are functions ( ` bool2num ` and ` num2bool ` ) for converting boolean values to numerical values and vice versa , and the ` sgn ` function corresponding to signum function .",
    "arithmetic , bitwise , relational and compound assignment operators , applied over arithmetic variables / expressions , are written in the c - style .",
    "for example , bitwise conjunction over numerical variables ` n1 ` and ` n2 ` is written ` n1 & n2 ` , bitwise left shift of ` n1 ` for ` n2 ` is written ` n1 < < n2 ` , and ` n1 + = n2 ` is equivalent to ` n1 = n1+n2 ` .",
    "logical operators , applied over boolean variables / expressions , are written in the c - style , with additional operator ` ^^ ` for logical exclusive disjunction , in the spirit of other c logical operators .",
    "there are also compound assignment operators for logical operators , such as ` & & = ` ( added for symmetry and convenience , although they do not exist in c ) .",
    "the operator ite is the conditional operator : ite(b , n1,n2 ) equals n1 if b is true , and equals n2 otherwise .",
    "there are no user - defined functions , but only user - defined procedures .",
    ".ebnf description of ursalanguage [ cols=\"<,^,<\",options=\"header \" , ]     the above result do nt include the systems that translate problem specifications to satand which are the systems closest to ursa . namely , these systems translate inputs to sat(so it can be considered that they share the solving mechanism ) , but they use different satsolvers",
    ". a fair comparison would be thus to use these systems only as translators to satand then use the same satsolver ( for instance , clasp ) for finding all models of the generated satformulae .",
    "it is interesting to consider size of generated formulae and solving times ( of course , smaller formulae does not necessarily lead to shorter solving times ) .",
    "fzntini was used with flatzinc specifications obtained from the minizinc specification used by g12/fd ( with integers encoded with 5 bits ) and with flatzinc specifications obtained from a minizinc specification made in the style of the direct encoding , we will denote them by 1 and 2 .",
    "sugar was used only with a specification that employs the order encoding .",
    "ursawas used with the specifications ` queens-1 ` ( with integers encoded with 5 bits ) , ` queens-2 ` ( with the number of bits equal the instance dimension ) , and ` queens-3 ` , ( with integers encoded with 4 bits ) .",
    "table [ table : sugar_ursa ] presents the obtained experimental results .",
    "all recorded times were obtained for the `` quiet '' mode of the satsolver ( without printing the models ) .",
    "times for generating formulae were negligible ( compared to the solving phase ) for all systems , so we do nt report them here .",
    "for related specifications , ursa s ` queens-1 ` gave much smaller formulae ( probably thanks to techniques mentioned in section [ subsec : translation_to_sat ] ) and somewhat better performance than fzntini 1 , which suggests that fzntini does not benefit much from information about the global structure of the problem .",
    "the formulae generated by sugar were significantly smaller than in the above two cases , and led to much better solving efficiency .",
    "however , it was outperformed by the remaining entrants .",
    "the ursa s specifications ` queens-2 ` and ` queens-3 ` gave similar results .",
    "the specification ` queens-3 ` produced formulae with the smallest number of clauses .",
    "fzntini 2 produced formulae with the smallest number of variables .",
    "the best results in terms of the solving times were obtained also by fzntini 2 . it can be concluded that ursacan produce , with suitable problem specifications , propositional formulae comparable in size and in solving times with formulae produced by related state - of - the - art systems .",
    "+ variables & 3012 & 3825 & 4735 & 5742 & 6846 & 8047 & 9345 + clauses & 9128 & 11628 & 14460 & 17567 & 21000 & 24713 & 28770 + all solutions & 0.15 & 0.79 & 3.20 & 14.53 & 111.78 & @xmath57600 & @xmath57600 +   + variables & 841 & 1052 & 1286 & 1560 & 1819 & 2139 & 2468 + clauses & 3352 & 4217 & 5179 & 6295 & 7390 & 8712 & 10089 + all solutions & 0.08 & 0.53 & 2.83 & 17.60 & 98.04 & @xmath57600 & @xmath57600 +   + variables & 220 & 284 & 356 & 436 & 524 & 620 & 724 + clauses & 1138 & 1653 & 2253 & 3012 & 3924 & 5003 & 6263 + all solutions & 0.02 & 0.06 & 0.31 & 1.58 & 9.59 & 68.07 & 411.15 +   + variables & 542 & 739 & 978 & 1263 & 1598 & 1987 & 2434 + clauses & 3319 & 5008 & 7280 & 10258 & 14077 & 18884 & 24838 + all solutions & 0.01 & 0.04 & 0.12 & 0.70 & 4.01 & 23.17 & 138.55 +   + variables & 176 & 225 & 280 & 341 & 408 & 481 & 560 + clauses & 800 & 1110 & 1490 & 1947 & 2488 & 3120 & 3850 + all solutions & 0.01 & 0.03 & 0.12 & 0.69 & 3.82 & 21.09 & 136.45 +   + variables & 128 & 162 & 200 & 242 & 288 & 338 & 392 + clauses & 872 & 1236 & 1690 & 2244 & 2908 & 3692 & 4606 + all solutions & 0.01 & 0.02 & 0.07 & 0.33 & 1.52 & 8.39 & 52.12 +    [ [ additional - experiments . ] ] additional experiments",
    ". + + + + + + + + + + + + + + + + + + + + + + +    in additional experiments , only the systems that performed the best on the queens problem were considered ( with only one constraint logic programming system kept ) : b - prolog , clasp , fzntini , g12/fd , and ursa .",
    "the following problems were considered ( for all problems all solutions were sought ) :",
    "-12 pt**golomb ruler:**the problem ( actually , one of its variation ) is as follows , given a value @xmath76 check if there are @xmath77 numbers @xmath78 , @xmath79 , @xmath15 , @xmath80 such that @xmath81 and all the @xmath82 differences @xmath83 , @xmath84 are distinct ( problem 6 at csplib ) .",
    "the experiments were performed for @xmath85 , with the largest @xmath76 that make the problem unsatisfiable and with the smallest @xmath76 that make the problem satisfiable .    -12",
    "pt**magic square:**a magic square of order @xmath86 is a @xmath87 matrix containing the numbers from @xmath47 to @xmath88 , with each row , column and main diagonal equal the same sum .",
    "the problem is to find all magic squares of order @xmath86 ( problem 19 at csplib ) .",
    "the experiments were performed for @xmath89 and @xmath90 .",
    "-12 pt**linear recurrence relations:**linear homogeneous recurrence relations of degree @xmath42 are of the form : @xmath91 for @xmath92 .",
    "given @xmath93 ,  , @xmath94 and @xmath41 , @xmath95 can be simply calculated , but finding explicit formula for @xmath96 requires solving a nonlinear characteristic equation of degree @xmath42 , which is not always possible .",
    "so , the following problem is nontrivial : given @xmath93 , @xmath15 , @xmath97 and @xmath95 , find @xmath98 .",
    "for the experiment , we used the relation @xmath99 , @xmath100 .",
    "we generated instances with the ( only ) solution @xmath101 and the systems were required to seek all possible values for @xmath102 .",
    "additional constraints ( used explicitly or implicitly ) for all considered systems ) were @xmath103 and @xmath104 , for @xmath105 .",
    "ursaand fzntini were used with 32 bit length for numerical values .",
    "-12 pt**non - linear recurrence relations:**in non - linear homogenous recurrence relations of degree k , the link between @xmath106 and @xmath107 , @xmath108 , @xmath15 , @xmath95 , is not necessarily linear . for the experiment we used the relation @xmath109 , @xmath100 .",
    "we generated instances with the ( only ) solution @xmath101 and the systems were required to seek all possible values for @xmath102 .",
    "additional constraints ( used explicitly of implicitly ) for all considered systems ) were @xmath110 and @xmath104 , for @xmath105 . for all problem instances ,",
    "the size of all relevant values @xmath96 were smaller than @xmath111 .",
    "ursaand fzntini were used with 32 bit length for numerical values .",
    "the ursawas used with the following specification for the golomb ruler problem ( for the instance @xmath112 , @xmath113 ) :    .... nm=7 ; nl=25 ; brulerendpoints = num2bool(nruler & nruler > > nl & 1 ) ;    nmarks=2 ; bdistancediff = true ; for(ni=1 ; ni<=nl-1 ; ni++ ) {    nmarks + = ( nruler > >",
    "ni ) & 1 ;    n = ( nruler & ( nruler < < ni ) ) ;    bdistancediff & & = ( n & ( n-1))==0 ; }    assert_all(brulerendpoints & & nmarks==nm & & bdistancediff ) ; ....    the above specification employs a binary representation of the ruler ( ` nruler ` ) where each bit set denotes a mark .",
    "the value ` nruler & nruler > > nl & 1 ` equals ` 1 ` if and only if the first and ` nl`th bit are set ( as the ruler endpoints ) .",
    "the value ` nmarks ` counts the bits set ( e.g. , the marks ) and it should equal ` nm ` . if the ruler ` nruler ` is a golomb ruler , then whenever it is shifted left ( for values ` 1 ` , @xmath15 , ` nl-1 ` ) and bitwise conjunction is performed with the original ruler giving the value `",
    "n ` , there will be at most one bit set in ` n ` ( since all the differences between the marks are distinct ) .",
    "there is at most one bit set in ` n ` if and only if the value ` n & ( n-1 ) ` equals 0 .",
    "this specification , employing a single loop , illustrate the expressive power of bitwise operations supported in the ursalanguage .",
    "for the magic square problem , ursawas used with the following specification :    .... ndim=4 ; nn = ndim*ndim ; bcorrectsum = ( 2*nsum*ndim = = nn*(nn-1 ) ) ;    bdomain = true ; bdistinct = true ; for(ni=0;ni < ndim;ni++ ) {    for(nj=0;nj < ndim;nj++ ) {      bdomain & & = ( nt[ni][nj]<nn ) ;      for(nk=0;nk < ndim;nk++ )        for(nl=0;nl <",
    "ndim;nl++ )          bdistinct & & = ( ( ni==nk & & nj==nl ) || nt[ni][nj]!=nt[nk][nl ] ) ;    } }    bsum = true ; nsum1=0 ; nsum2=0 ; for(ni=0;ni < ndim;ni++ ) {    nsum1 + = nt[ni][ni ] ;    nsum2 + = nt[ni][ndim - ni-1 ] ;    nsum3=0 ;    nsum4=0 ;    for(nj=0;nj <",
    "ndim;nj++ ) {      nsum3 + = nt[ni][nj ] ;      nsum4 + = nt[nj][ni ] ;    }    bsum & & = ( nsum3==nsum ) ;    bsum & & = ( nsum4==nsum ) ; } bsum & & = ( nsum1==nsum ) ; bsum & & = ( nsum2==nsum ) ;    assert_all(bcorrectsum & & bdomain & & bdistinct & & bsum ) ; ....    for the linear recursive relation , ursawas used with the following specification ( the specification for the non - recursive relations is analogous ) :    .... n   = 30 ; ny = 20603361 ;    n1=1 ; n2=1 ; n3=nx ;    for(ni=4 ; ni",
    "< = n ; ni++ ) {    ntmp = n1+n2+n3 ;    n1=n2 ;    n2=n3 ;    n3=ntmp ;    bdomain & & = ( n3<=ny ) ; }    assert_all(bdomain & & n3==ny ) ; ....    table [ table : additional_experiments ] shows experimental results ( with translation times included ) .",
    "fzntini was used with clasp as an underlying solver ( the built - in solver gave poorer results ) .",
    "the number of variables and clauses generated by ursawere , in these benchmarks , smaller than for fzntini .",
    "for lparse / clasp , the translation time was significant , and some of the poor results for some benchmarks are due to large domains ( while the system works with relations rather than functions ) . for recurrence relations ,",
    "g12/fd reported model inconsistency when it approached its limit for integers , while b - prolog just failed to find a solution for larger instances .",
    "overall , on this set of benchmarks , ursagave better results than clasp and fzntini and on some benchmarks outperformed all other tools .",
    "+ 5/10 & 0.01 & 5.36 & 0.20 & 0.06 & 0.01 + 6/16 & 0.01 & 44.68 & 1.16 & 0.08 & 0.02 + 7/24 & 0.01 & 350.11 & 9.53 & 0.10 & 0.10 + 8/33 & 0.08 & @xmath57600 & 111.90 & 0.24 & 0.69 + 9/43 & 0.69 & @xmath57600 & @xmath57600 & 1.18 & 4.89 + 10/54 & 5.34 & @xmath57600 & @xmath57600 & 7.84 & 35.55 + 11/71 & 105.54 & @xmath57600 & @xmath57600 & 93.2 & 571.90 + 5/11 & 0.01 & 6.33 & 0.32 & 0.07 & 0.01 + 6/17 & 0.01 & 57.40 & 1.43 & 0.08 & 0.01 + 7/25 & 0.01 & 429.98 & 14.15 & 0.10 & 0.13 + 8/34 & 0.09 & @xmath57600 & 106.26 & 0.26 & 0.87 + 9/44 & 0.78 & @xmath57600 & @xmath57600 & 1.27 & 5.87 + 10/55 & 6.86 & @xmath57600 & @xmath57600 & 6.44 & 37.28 + 11/72 & 115.81 & @xmath57600 & @xmath57600 & 125.50 & 450.41 +   + 3 & 0.01 & 0.05 & 0.04 & 0.01 & 0.01 + 4 & 4.74 & 462.21 & @xmath57600 & 10.26 & 93.01 +   + 4 & 0.00 & 0.01 & 0.01 & 0.01 & 0.00 + 5 & 0.00 & 0.06 & 0.01 & 0.02 & 0.00 + 6 & 0.00 & 1.18 & 0.01 & 0.02 & 0.01 + 7 & 0.00 & 25.49 & 0.01 & 0.02 & 0.01 + @xmath15 & & & & & + 28 & 43.83 & @xmath57600 & 0.17 & 143.54 & 0.31 + 29 & 84.92 & @xmath57600 & 0.68 & incons & 0.33 + 30 & 158.78 & @xmath57600 & 1.02 & incons & 0.47 +   + 4 & 0.00 & 0.00 & 0.01 & 0.01 & 0.00 + 5 & 0.00 & 0.01 & 0.01 & 0.01 & 0.02 + 6 & 0.00 & 0.42 & 0.22 & 0.02 & 0.05 + 7 & 0.00 & 126.05 & 0.36 & 0.02 & 0.08 + 8 & 0.00 & @xmath57600 & 0.51 & 0.02 & 0.13 + 9 & fail & @xmath57600 & 0.76 & 0.02 & 0.28 + 10 & fail & @xmath57600 & 0.88 & 0.03 & 0.53 + 11 & fail & @xmath57600 & 0.97 & incons & 0.77 +    [ [ discussion . ] ] discussion .",
    "+ + + + + + + + + + +    the described limited experiments can not give definite conclusions or ranking of the considered systems , as discussed above .",
    "in particular , one may raise the following concerns , that can be confronted with the following arguments :    @xmath26    _ ursawas used with a good problem specifications , and there may be specifications for other systems that lead to better efficiency .",
    "_ however , almost all specifications were taken from the system distributions , given there to illustrate the modelling and solving power of the systems . also ,",
    "the problem specifications used for ursaare also probably not the best possible , but are rather straightforward , as specifications for other systems . in addition , in contrast to ursa , other modelling systems typically aim at liberating the user of thinking of details of internal representations and are free to perform internal reformulations of the input problem . making specifications in ursamay be somewhat more demanding than for some other systems , but gives to the user a fuller control of problem representation .    _ some specifications used for ursaare related to the direct encoding ( known to be efficient , for example , for the queens problem ) , while this is not the case with other systems .",
    "_ what is suitable for sat - based systems is not necessarily suitable for other systems .",
    "for instance , g12/fd gives significantly poorer results with the specification of the queens problem based on the direct encoding , than with the one used in the experiment .",
    "this is not surprising , because systems that are not based on satdoes not necessarily handle efficiently large numbers of boolean variables and constraints ( in contrast to satsolvers ) and lessons from the satworld ( e.g. , that for some sort of problems , some encoding scheme is the most efficient ) can not be _ a priori _ applied to other solving paradigms .    _",
    "ursauses bit - wise logical operators , while other systems do not ( as they do nt have support for them ) .",
    "_ bit - wise logical operators make one of advantages of ursa , while in the same time , some other systems use their good weapons ( e.g. , global constraints such as all - different ) .    in summary ,",
    "the presented experiments suggest that the ursasystem ( although it is not primarily a cspsolver but a general system for reducing problems to sat ) is competitive to the state - of - the - art , both academic and industrial , modelling systems  even if they can encode high - level structural information about the input problem and even if they involve specialized underlying solvers ( such as support for global constraints like all - different ) . a wider and deeper comparison between these ( and some other ) constraint solvers ( not sharing input language ) and with different encodings of considered problems , would give a better overall picture but is out of scope of this paper .",
    "the current system ( with the presented semantics and the corresponding implementation ) uses one way ( binary representation ) for representing ( unsigned ) integers but ( as shown in the given examples ) , it still enables using different encoding styles in specifications . for further convenience ,",
    "we are planning to natively support other representations for integers , so the user could choose among several encodings",
    ". also , signed integers and floating point numbers could be supported .",
    "the language ursa(and the interpreter ) can be extended by new language constructs ( e.g. , by division ) .",
    "a new form of the ` assert ` can be added , such that it propagates intermediate solutions to subsequent commands of the same sort .",
    "support for global constraints can also be developed , but primarily only as a , , syntactic sugar   the user could express global constraints more easily , but internally they would be expanded as if they were expressed using loops ( i.e. , as in the current version of the system ) .",
    "alternative forms of support for global constraints would require substantial changes in the sat - reduction mechanism .    on the lower algorithmic and implementation level",
    ", we are planning to further improve the current version of transformation to cnf .    in the current version ,",
    "ground integers are represented by built - in fixed - precision integers , which is typically sufficient .",
    "however , in order to match symbolic integers , ground integers should be represented by arbitrary ( but fixed ) length integers and we are planning to implement that .",
    "concerning the underlying satsolvers , currently only two complete satsolvers are used .",
    "we are planning to integrate additional solvers , since some solvers are better suited to some sorts of input instances , as the satcompetitions show . within this direction of work",
    ", we will also analyze performance of stochastic solvers within ursa .",
    "in addition , we are exploring potentials of using non - cnf satsolvers @xcite within ursa , which avoids the need for transformation to cnf@xcite . choosing among available solvers",
    "can be automated by using machine learning techniques for analysis of the generated satinstances ( or even input specifications ) @xcite . for solving optimization problems , instead of the existing naive implementation",
    ", we are planning to implement more advanced approaches and to explore the use of maxsat and pseudo - boolean solvers @xcite .    on the theoretical side ,",
    "the full operational semantics outlined in this paper can be formally defined and it could be proved that solutions produced by the ursasystem indeed meet the specifications and if there are no produced solutions , then the specifications is inconsistent . along with the formal verification ( i.e. , verification within a proof assistant ) of the satsolver argosatused @xcite , that would provide a formal correctness proof of the ursasystem ( which would make it , probably , the first _ trusted _ constraint solver ) .    in the presented version of ursa , reducing to satis tightly integrated ( and defined by the semantics of the system ) in the program execution phase .",
    "an alternative would be as follows : during the program execution phase , a first - order formula is generated and only before the solving phase it is translated to a propositional formula .",
    "moreover , the generated formula would not need to be translated to a propositional formula , but could be tested for satisfiability by using smt(satisfiability modulo theory ) solvers ( e.g. , for linear arithmetic , equality theory , alldifferent theory etc . ) @xcite . in particular , symbolic computations employed by the ursasystem are closely related to the theory of bit - vector arithmetic and to decision procedures for this theory based on `` bit - blasting '' @xcite . since solvers for this theory typically cover all the operators used in ursa , the theory of bit - vector arithmetic can be used as an underlying theory ( instead of propositional logic ) and any solver for bit - vectors arithmetic can be used as a solving engine . generally , the reduction could be adaptable to smtsolvers available  if some solver is available , then its power can be used , otherwise all generated constraints are exported to propositional logic .",
    "this would make the approach more powerful and such development is the subject of our current work  the system ursa major will be able to reduce constraints not only to satbut to different smttheories .",
    "that system will be a general constraint solver and also a high - level front - end to the low level smt - lib interchange format , and , further , to all smtsolvers that supports it .",
    "reduction to the theory of bit - vector arithmetic is firstly explored in this context @xcite and it shows that reducing to bit - vector arithmetic does not necessarily lead to more efficient solving process than reducing to sat(and the same holds for other smttheories ) .    with the increased power of the presented system ( by using both satand smtsolvers ) , we are planning to further consider a wide range of combinatorial , np - complete problems , and potential one - way functions and also to apply the ursasystem to real - world problems ( e.g. , the ones that are already being solved by translating them to sat ) .",
    "some applications in synthesis of programs are already the subject of our current work .    for the sake of easier practical usability of the ursasystem",
    ", we are planning to develop a support for integration of ursawith popular imperative languages ( c , c++ , java ) .",
    "in this paper we described a novel approach for uniform representation and solving of a wide class of problems by reducing them to sat .",
    "the approach relies on :    @xmath26    a novel specification language that combines features of imperative and declarative languages  a problem is specified by a test , expressed in an imperative form , that some values indeed make a solution to the problem ;    symbolic computations over unknowns represented by ( finite ) vectors of propositional formulae .",
    "the approach is general and elegant , with precisely defined syntax and induced ( by the concept of symbolic execution ) semantics of the specification language .",
    "this enables straightforward implementation of the system and it works as a `` clear box '' . the proposed language is a novel mixture of imperative and declarative paradigms , leading to a new programming paradigm . thanks to the language s declarative aspects  the problem is described by what makes a solution and not by describing how to find it  using the system does not require human expertise on the specific problem being solved . on the other hand ,",
    "specifications are written in imperative form and this gives the following advantages compared to other modelling languages ( all of them are declarative ) :    @xmath26    problem specifications can involve destructive assignments , which is not possible in declarative languages and this can be essential for many sorts of problems ( e.g. , from software verification ) ;    modelling problems that naturally involve loops ( and nested loops ) is simple and the translation is straightforward ;    for users familiar with imperative programming paradigm , it should be trivial to acquire the specification language ursa(since there are no specific commands or flow - controls aimed at constraint solving ) ;    the user has a fuller control of internal representation of the problem , so can influence the efficiency of the solving phase .",
    "a specification can be taken , almost as - is , from and to languages such as c ( within c , such code would check if some given concrete values are indeed a solution of the problem ) .    the system can smoothly extend imperative languages like c / c++ or java , ( as constraint programming extends logic programming ) .",
    "the system can be verified to be correct in a straightforward manner .",
    "in addition , the system ursa , in contrast to most of ( or all ) other modelling systems , supports bit - wise logical operators and constraints involving modular arithmetic ( for the base of the form @xmath0 ) , which is essential for many applications , and can also enable efficient problem representation and problem solving .",
    "the proposed approach can be used for solving all problems with boolean and numerical unknowns , over boolean parameters and numerical parameters with finite domains that can be stated in the specification language ( e.g. , the domain of the system is precisely determined by expressiveness of its specification language ) .",
    "the search for required solutions of the given problem is performed by modern satsolvers that implement very efficient techniques not directly applicable to other domains .",
    "while satis already used for solving a wide range of various problems , the proposed system makes these reductions much easier and can replace a range of problem - specific tools for translating problems to sat .",
    "the tool ursacan be used not only as a powerful general problem solver ( for finite domains ) , but also as a tool for generating satbenchmarks ( both satisfiable and unsatisfiable ) .    concerning weaknesses , ursais not suitable for problems where knowledge of the domain and problem structure",
    "are critical and can be efficiently tackled only by specialized solvers , and this holds for reduction to satgenerally . due to its nature , by interfacing ursawith standard specification languages like xcsp or minizinc , most of the ursamodelling features and power would be lost ( e.g. , bit - wise logical operators and destructive updates ) , while global constraints supported by these languages would be translated in an inefficient way . therefore , it makes no much sense to enable conversion from these standard languages to ursaand this makes ursaa bit isolated system in the world of constraint solvers or related systems .    in this paper we do not propose :",
    "@xmath26    a new sat - encoding technique  rather , the ursaspecification language can be used for different encoding styles ;    a technique for transforming a satformula to conjunctive normal form  this step is not a part of the core of the ursalanguage and is not covered by its semantics , so any approach ( meeting the simple specification ) can be used ; the current technique seem to work well in practice , while it can still be a subject of improvements .",
    "a satsolver  rather , ursacan use any satsolver ( that can generate all models for satisfiable input formulae ) ; moreover , having several satsolver would be beneficial , since some solvers are better suited to some sorts of problems .    in this paper",
    "we also described the system ursathat implements the proposed approach and provided some experimental results and comparison with related systems .",
    "they suggest that , although ursais not primarily a cspsolver ( but a general system for reducing problems to sat ) , the system is , concerning efficiency , competitive to state - of - the - art academic and industrial csptools .",
    "ursais also competitive to other system that translate problem specifications to sat .",
    "in contrast to most of other constraint solvers , the system ursais open - source and publicly available on the internet .    for future work",
    ", we are planning to extend the system so it can use not only complete satsolvers , but also stochastic satsolvers , non - cnf solvers , and smtsolvers .",
    "we will also work on formal ( machine - checkable by a proof assistant ) verification of the system ( i.e. , show that the ursasystem always gives correct results ) and on extensions of the system relevant for practical applications .",
    "this work was partially supported by the serbian ministry of science grant 174021 and by snf grant scopes iz73z0_127979/1 .",
    "the author is grateful to dejan jovanovi whose ideas on overloading c++ operators influenced development of the system presented in this paper ; to filip mari for valuable discussions on the presented system and for using portions of his code for shared expressions ; to milan eum for portions of his code for performing operations over vectors of propositional formulae ; to ralph - johan back and to the anonymous reviewers for very detailed and useful comments on a previous version of this paper .",
    "josep argelich , alba cabiscol , ins lynce , and felip many .",
    "regular encodings from max - csp into partial max - sat . in _",
    "ismvl 2009 , 39th international symposium on multiple - valued logic _ , pages 196202 .",
    "ieee computer society , 2009 .",
    "clark barrett , roberto sebastiani , sanjit  a. seshia , and cesare tinelli .",
    ", chapter  26 , pages 825885 . in armin",
    "biere , marijn heule , hans van maaren , and toby walsh , editors , _ handbook of satisfiability _ , pages 7597 @xcite , 2009 .",
    "miquel bofill , josep suy , and mateu villaret .",
    "a system for solving constraint satisfaction problems with smt . in _ theory and applications of satisfiability testing - sat 2010 _ , lncs 6175 , pages 300305 .",
    "springer , 2010 .",
    "angelo brillout , daniel kroening , and thomas wahl .",
    "mixed abstractions for floating - point arithmetic . in _ proceedings of 9th international conference on formal methods in computer - aided design , fmcad 2009 _ , pages 6976 .",
    "ieee , 2009 .",
    "tristan denmat , arnaud gotlieb , and mireille ducass . an abstract interpretation based combinator for modelling while loops in constraint programming . in _",
    "cp07 : proceedings of the 13th international conference on principles and practice of constraint programming _ , lncs 4741 .",
    "springer , 2007 .",
    "carsten fuhs , jrgen giesl , aart middeldorp , peter schneider - kamp , ren thiemann , and harald zankl . sat solving for termination analysis with polynomial interpretations . in _ theory and",
    "applications of satisfiability testing - sat 2007 _ , lncs 4501 , pages 340354 .",
    "springer , 2007 .",
    "holger  h. hoos",
    ". sat - encodings , search space structure , and local search performance . in _ proceedings of the sixteenth international joint conference on artificial intelligence ,",
    "ijcai 99 _ , pages 296303 .",
    "morgan kaufmann , 1999 .",
    "ali  sinan kksal , viktor kuncak , and philippe suter .",
    "scala to the power of z3 : integrating smt and programming . in _",
    "23rd international conference on automated deduction  cade-23 _ , lncs 6803 , pages 400406 .",
    "springer , 2011 .",
    "ilya mironov and lintao zhang .",
    "applications of sat solvers to cryptanalysis of hash functions . in _ theory and",
    "applications of satisfiability testing - sat 2006 _ , lncs 4121 , pages 102115 .",
    "springer , 2006 .",
    "david  g. mitchell and eugenia ternovska .",
    "a framework for representing and solving np search problems . in _ national conference on artificial intelligence ",
    "aaai 2005 _ , pages 430435 . aaai press / the mit press , 2005 .",
    "matthew  w. moskewicz , conor  f. madigan , ying zhao , lintao zhang , and sharad malik .",
    "chaff : engineering an efficient sat solver . in _",
    "dac 01 : proceedings of the 38th conference on design automation _ , pages 530535 .",
    "acm press , 2001 .",
    "nicholas nethercote , peter  j. stuckey , ralph becket , sebastian brand , gregory  j. duck , and guido tack .",
    "minizinc : towards a standard cp modelling language . in _ principles and practice of constraint programming ",
    "cp 2007 _ , lncs 4741 , pages 529543 .",
    "springer , 2007 .",
    "mladen nikoli , filip mari , and predrag janii .",
    "instance - based selection of policies for sat solvers . in _ theory and",
    "applications of satisfiability testing - sat 2009 _ , lncs 5584 , pages 326340 .",
    "springer , 2009 .",
    "nikolay pelov and eugenia ternovska .",
    "reducing inductive definitions to propositional satisfiability . in _ international conference on logic programming  iclp 2005 _ , lncs 3668 , pages 221234 .",
    "springer , 2005 .",
    "peter  j. stuckey , maria j.  garca de  la banda , michael  j. maher , kim marriott , john  k. slaney , zoltan somogyi , mark wallace , and toby walsh .",
    "the g12 project : mapping solver independent models to efficient solutions . in _ principles and practice of constraint programming - cp 2005 _ , lncs 3709 , pages 1316 .",
    "springer , 2005 .              g.  s. tseitin . on the complexity of derivations in propositional calculus .",
    "in _ studies in constructive mathematics and mathematical logic ( part ii ) _ , pages 115125",
    ". consultants bureau , 1968 .",
    "( also in _ the automation of reasoning _ , springer - verlag , 1983 . ) .",
    "hantao zhang , dapeng li , and haiou shen . a sat based scheduler for tournament schedules . in _",
    "the seventh international conference on theory and applications of satisfiability testing - sat 2004 _ , 2004 .",
    "online proceedings ."
  ],
  "abstract_text": [
    "<S> there are a huge number of problems , from various areas , being solved by reducing them to sat . however , for many applications , translation into satis performed by specialized , problem - specific tools . in this paper </S>",
    "<S> we describe a new system for uniform solving of a wide class of problems by reducing them to sat . </S>",
    "<S> the system uses a new specification language ursathat combines imperative and declarative programming paradigms . </S>",
    "<S> the reduction to satis defined precisely by the semantics of the specification language . </S>",
    "<S> the domain of the approach is wide ( e.g. , many np - complete problems can be simply specified and then solved by the system ) and there are problems easily solvable by the proposed system , while they can be hardly solved by using other programming languages or constraint programming systems . </S>",
    "<S> so , the system can be seen not only as a tool for solving problems by reducing them to sat , but also as a general - purpose constraint solving system ( for finite domains ) . in this paper </S>",
    "<S> , we also describe an open - source implementation of the described approach . </S>",
    "<S> the performed experiments suggest that the system is competitive to state - of - the - art related modelling systems . </S>"
  ]
}