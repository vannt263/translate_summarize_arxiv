{
  "article_text": [
    "the evolutionary history of families of natural languages is a major topic of research in historical linguistics .",
    "it is also of interest to archaeologists , human geneticists , and physical anthropologists . in this paper",
    "we show how this work can benefit from the use of computational methods of logic programming .",
    "our starting point here is the mathematical model of evolution of natural languages introduced in @xcite and @xcite .",
    "as proposed in @xcite , we describe the evolution of languages in a declarative formalism and generate conjectures about the evolution of indo - european languages using an answer set programming system . instead of the system , employed in earlier experiments , we make use of the new system , which leads in this case to much better computation times . our main conceptual contribution is extending the definition of a phylogenetic network from @xcite by explicit temporal information about extinct languages  by estimates of the dates",
    "when those languages could be spoken .",
    "computationally , to accommodate this enhancement we divide the work between two systems : and the constraint logic programming system @xmath0ps@xmath1 ( http://www-icparc.doc.ic.ac.uk/eclipse/ ) .",
    "it was observed long ago ( see , for instance , @xcite ) that if linguistic communities do not remain in effective contact as their languages diverge then the evolutionary history of their language family can be modeled as a phylogeny  a tree whose edges represent genetic relationships between languages . of a given time",
    "is descended from a language @xmath2 of an earlier time if and only if @xmath2 developed into @xmath3 by means of an unbroken sequence of instances of native - language acquisition by children . ]",
    "[ fig : phylogeny - small](a )    @xmath4 \\mbox{(a ) } & \\mbox{(b ) } \\end{array}$ ]    shows the extant languages @xmath5 , @xmath6 , @xmath7 , @xmath8 , along with the common ancestor @xmath9 of @xmath5 and @xmath6 , the common ancestor @xmath10 of @xmath7 and @xmath8 , and the common ancestor @xmath11 ( for  root \" ) of  @xmath9 and  @xmath10 .",
    "the time line to the right of the tree shows that the ancestors of @xmath5 and @xmath6 diverged around 300 ce , the ancestors of @xmath7 and @xmath8 diverged around 800 ce , and the ancestors of @xmath9 and @xmath10 diverged around 1000 bce .",
    "sometimes languages inherit their characteristics from their ancestors , and sometimes they trade them with other languages when two linguistic communities are in contact with each other . the directed graph in fig .  [",
    "fig : phylogeny - small](b ) , obtained from the tree in fig .",
    "[ fig : phylogeny - small](a ) by inserting two vertices and adding a bidirectional edge , shows that the ancestor @xmath12 of @xmath6 , spoken around 1400 ce , was in contact with the ancestor @xmath13 of @xmath8 .",
    "this idea has led nakhleh , ringe and warnow  @xcite to the definition of a phylogenetic network , which extends the definition of a phylogeny by allowing lateral edges , such as the edge connecting @xmath12 with @xmath13 .",
    "the modification of their mathematical model proposed below takes into account the fact that two languages can not be in contact unless they are spoken at the same time . geometrically speaking",
    ", every lateral edge has to be horizontal .",
    "for instance , in fig .",
    "[ fig : phylogeny - small](a ) there can be no contact between an ancestor of  @xmath9 and a descendant of  @xmath10 , although such contacts are not prohibited in the definition of a phylogenetic network .",
    "to express the idea of a chronologically possible network in a precise form , we introduce  temporal networks \"",
    "networks with a `` date '' assigned to each vertex .",
    "dates monotonically increase along every branch of the phylogeny , and the dates assigned to the ends of a lateral edge are equal to each other .",
    "once dates are assigned to the vertices of a phylogeny , we can talk not only about the languages that are represented by the vertices , but also about the  intermediate \" languages spoken by members of a linguistic community at various times . in the example above we would represent the language spoken by the ancestors of the linguistic community @xmath5 at time @xmath14 by the pair @xmath15 , where @xmath16 .",
    "this pair can be visualized as the point at level @xmath14 on the edge leading to @xmath5 . in our idealized representation",
    ", @xmath14 ranges over real numbers , so that the set of such pairs is infinite .",
    "language @xmath12 in fig .",
    "[ fig : phylogeny - small](b ) can be denoted by @xmath17 , and @xmath13 can be written as @xmath18 .",
    "the characteristics of a language that it could inherit from ancestors or trade with other languages are called ( qualitative ) characters .",
    "a phylogeny describes every leaf of the tree in terms of the values , or `` states , '' of the characters .",
    "for instance , zeroes and ones next to @xmath5 , @xmath6 , @xmath7 and @xmath8 in fig .",
    "[ fig : phylogeny - small](a ) represent the states of a 2-valued character .",
    "they can indicate , for example , that a certain meaning is expressed by cognates in languages @xmath5 and @xmath7 ( cognation class 0 ) , and that it is also expressed by cognates in languages @xmath6 and @xmath8 ( cognation class 1 ) .",
    "the main definition in this paper ( similar to definition 12.1.3 from @xcite ) is that of a `` perfect '' temporal network . a perfect network explains how every state of every qualitative character could evolve from its original occurrence in a single language in the process of inheriting characteristics along the tree edges and trading characteristics along the lateral edges of the network .",
    "for instance , fig .",
    "[ fig : phylogeny - small](b ) extends the phylogeny in fig .",
    "[ fig : phylogeny - small](a ) to a perfect network by labeling the internal vertices of the graph .",
    "indeed , consider the subgraph of fig .",
    "[ fig : phylogeny - small](b ) induced by the set @xmath19 of the vertices that are labeled 0 .",
    "this subgraph is a tree with the root  @xmath11 ; this fact shows that state 0 has evolved in this network from its original occurrence in @xmath11 .",
    "similarly , the subgraph of fig .",
    "[ fig : phylogeny - small](b ) induced by the set @xmath20 of the vertices labeled 1 contains a tree with the root @xmath12 , and also a tree with the root @xmath13 .",
    "this means that state 1 could evolve from its original occurrence in language @xmath12 ( or in an ancestor of @xmath12 that is younger than  @xmath9 ) .",
    "alternatively , state 1 could evolve from its original occurrence in language @xmath13 , or in an ancestor of @xmath13 that is younger than  @xmath10 .",
    "the computational problem that we are interested in is the problem of reconstructing the temporal network representing the evolution of a language family , such as indo - european languages .",
    "this problem can be divided into two parts : generating a `` near - perfect '' phylogeny , and then generating a small set of additional horizontal edges that turn the phylogeny into a perfect network .",
    "( in a plausible conjecture about the evolution of languages the number of lateral edges has to be small : inheriting characteristics of a language from its ancestors is far more probable than acquiring them through borrowing , unless the dataset includes a large proportion of words that are highly likely to be borrowed . ) the first part  generating phylogenies  has been the subject of extensive research ; applying answer set programming to this problem is discussed in @xcite . in this paper",
    "we address the second part of the problem  turning a phylogeny into a perfect network .    as to the dates assigned to the vertices of the phylogeny",
    ", we assume that they are known approximately .",
    "for instance , about the graph from fig .",
    "[ fig : phylogeny - small](a ) we may only know that language @xmath9 was spoken between 100 bce and 500 ce , and that language @xmath10 was spoken between 600 ce and 1100 ce . since these two intervals do not overlap , we can conclude from these assumptions , just as in the case of the specific dates assigned to @xmath9 and @xmath10 in fig .  [",
    "fig : phylogeny - small](a ) , that a contact between an ancestor of @xmath9 and a descendant of @xmath10 would be impossible .",
    "if , however , the given temporal intervals for @xmath9 and @xmath10 were wider then such a conclusion might not be warranted , and a contact between an ancestor of @xmath9 and a descendant of @xmath10 might become an acceptable conjecture .",
    "our method allows us to turn a phylogeny , along with temporal intervals assigned to its vertices , into a perfect network by adding a small number of lateral edges , or to determine that this is impossible .    in this paper , after describing the problem mathematically in section  [ sec : phylogeny - pblm - description ] , we show how it can be solved using ideas of answer set programming and constraint logic programming ( section  [ sec : computing ] ) , and then apply our approach to the problem of reconstructing the evolutionary history of indo - european languages ( section  [ sec : ie ] ) .",
    "in this section we show how the problem of computing perfect temporal phylogenetic networks built on a given temporal phylogeny can be described as a graph problem .",
    "recall that a _ rooted tree _ is a digraph with a vertex of in - degree 0 , called the _ root _",
    ", such that every vertex different from the root has in - degree 1 and is reachable from the root . in a rooted tree , a vertex of out - degree 0",
    "is called a _ leaf_.      a _ phylogeny _ is a finite rooted tree @xmath21 along with two finite sets @xmath22 and @xmath23 and a function @xmath24 from @xmath25 to @xmath23 , where @xmath26 is the set of leaves of the tree .",
    "the elements of @xmath22 are usually positive integers ( `` indices '' ) that represent , intuitively , qualitative characters , and elements of @xmath23 are possible states of these characters .",
    "the function @xmath24 `` labels '' every leaf @xmath27the extant or most recently spoken language in one of the branches  by mapping every index @xmath28 to the state @xmath29 of the corresponding character in that language .    for instance , fig .  [",
    "fig : phylogeny - small](a ) is a phylogeny with @xmath30 and @xmath31 .",
    "[ fig : phylogeny - t2](a ) is a phylogeny with @xmath32 and @xmath31 ; state @xmath29 is represented by the @xmath28-th member of the tuple labeling leaf @xmath27 .",
    "@xmath33 \\mbox{(a ) } & \\mbox{(b ) } \\end{array}$ ]    a _ temporal phylogeny _ is a phylogeny along with a function @xmath34 from vertices of the phylogeny to real numbers such that for every edge @xmath35 of the phylogeny @xmath36 . intuitively , @xmath37 is the time when language @xmath27 was spoken .",
    "we will graphically represent the values of @xmath34 by placing a vertical time line to the right of the tree , as in fig .",
    "[ fig : phylogeny - small](a ) and fig .",
    "[ fig : phylogeny - t2](a ) .",
    "as discussed in the introduction , a contact between two linguistic communities can be represented by a horizontal edge added to a pictorial representation of a temporal phylogeny .",
    "the two endpoints of the edge are simultaneous `` events '' in the histories of these communities .",
    "an event can be represented by a pair @xmath38 , where @xmath27 is a vertex of the phylogeny and @xmath14 is a real number .    to make this idea precise ,",
    "consider a temporal phylogeny @xmath39 ; let @xmath40 be the set of its vertices , @xmath11 its root , and @xmath34 its time function .",
    "for every @xmath41 , let @xmath42 be the parent of @xmath27 .",
    "event _ is any pair @xmath38 such that @xmath43 and @xmath14 is a real number satisfying the inequalities ( ( v))<t(v ) .",
    "events @xmath38 and @xmath44 are _ concurrent _ if @xmath45 .",
    "contact _ is a set consisting of two different concurrent events .",
    "any finite set @xmath7 of contacts defines a _ ( temporal phylogenetic ) network_a digraph obtained from @xmath39 by inserting the elements @xmath38 of the contacts from @xmath7 as intermediate vertices and then adding every contact in @xmath7 as a bidirectional edge .",
    "we will discuss now a simple case that is particularly important for applications , defined as follows .",
    "we say that a set @xmath7 of contacts is _ simple _ if    * for every event @xmath38 that belongs to a contact from @xmath7 , @xmath46 , and * for every vertex @xmath27 of @xmath39 there exists at most one number @xmath14 such that @xmath38 belongs to some contact from @xmath7 .",
    "the first condition expresses that the second inequality in ( [ ineq ] ) holds as a strict inequality , so that for every event @xmath38 that belongs to a contact from @xmath7 ( ( v))<t < ( v ) .",
    "in other words , it says that the endpoints of all lateral edges are different from the vertices of @xmath39 ; each of them subdivides an edge of @xmath39 into two edges .",
    "the second condition says that the endpoints of the lateral edges do not subdivide any of the edges of @xmath39 into more than two parts .",
    "it is clear , for instance , that the set consisting of the single contact \\{b1400,d1400 } in fig .",
    "[ fig : phylogeny - small ] and the set consisting of the single contact @xmath47 in fig .",
    "[ fig : phylogeny - t2 ] are simple .    if @xmath7 is simple then the corresponding network can be described as follows .",
    "the set of its vertices is the union of the set @xmath40 of vertices of @xmath39 with the union @xmath48 of the contacts from @xmath7 .",
    "its set @xmath49 of edges is obtained from the set @xmath9 of edges of @xmath39 in two steps .",
    "first , for every event @xmath38 in @xmath48 we replace the edge @xmath50 from @xmath9 by its `` two halves''the edges @xmath51 second , for every contact @xmath52 in @xmath53 we add a `` bidirectional lateral edge''the pair of edges @xmath54      about a simple set @xmath7 of contacts ( and about the corresponding network @xmath55 ) we say that it is _ perfect _ if there exists a function @xmath56 such that    1 .   for every leaf @xmath27 of @xmath39 and every @xmath57 , @xmath58",
    "; 2 .   for every @xmath57 and every @xmath59",
    ", if the set @xmath60 is nonempty then the digraph @xmath61 has a subgraph with the set @xmath62 of vertices that is a rooted tree .",
    "the first condition expresses that the function @xmath63 extends @xmath24 from leaves to all ancestral languages of the network .",
    "the second condition expresses that every state @xmath64 of every character @xmath28 could evolve from its original occurrence in some `` root '' language .",
    "for instance , fig .",
    "[ fig : phylogeny - small](b ) shows a perfect network obtained from the phylogeny of fig .",
    "[ fig : phylogeny - small](a ) by adding one contact , along with labels representing the values of  @xmath63 .",
    "similarly , fig .",
    "[ fig : phylogeny - t2](b ) shows a perfect network obtained from the phylogeny of fig .",
    "[ fig : phylogeny - t2](a ) along with the values of the corresponding function @xmath63 . in the last example , state 0 of the first character and state 1 of the second character have evolved from the root of the given phylogeny ; state 1 of the first character has evolved from the common ancestor of @xmath6 and @xmath7 ; the state 0 of the second character could evolve from @xmath65 or from @xmath66 .",
    "( each of these two possibilities corresponds to a subgraph with the vertices @xmath6 , @xmath8 , @xmath65 , @xmath66 that is a rooted tree . )",
    "we are interested in the problem of turning a temporal phylogeny into a perfect temporal network by adding a small number of contacts .",
    "for instance , given the phylogeny in fig .",
    "[ fig : phylogeny - small](a ) , the single contact ( [ c - example ] ) is a possible answer .",
    "it is clear that the information included in a temporal phylogeny is not sufficient for determining the exact dates of the contacts that turn it into a perfect network .",
    "for instance , if we shift contact ( [ c - example ] ) up or down by a few hundred years and replace it , say , by @xmath67 then the new conjecture about the past of the languages @xmath68 will not be distinguishable from  ( [ c - example ] ) .    to make this idea precise ,",
    "let us select for each @xmath43 a new symbol @xmath69 , and define the _ summary _ of a simple set @xmath7 of contacts to be the result of replacing each element @xmath38 of every contact in @xmath7 with @xmath69 .",
    "thus summaries consist of 2-element subsets of the set @xmath70 for instance , the summary of the set of contacts of fig .",
    "[ fig : phylogeny - small](b ) is @xmath71 . for the set of contacts of fig .",
    "[ fig : phylogeny - t2](b ) , the summary is the same .",
    "intuitively , @xmath69 is a language intermediate between @xmath42 and @xmath27 that was spoken at some unspecified time between @xmath72 and @xmath37",
    ".    an _ ipstn problem _",
    "( for `` increment to perfect simple temporal network '' ) is defined by a phylogeny @xmath73 and a function @xmath74 from the vertices of the phylogeny to open intervals .",
    "( in other words , for every @xmath75 , @xmath76 is a real number or @xmath77 , and @xmath78 is a real number or @xmath79 , such that @xmath80 . )",
    "a _ solution _ to the problem is a set of 2-element subsets of @xmath81 that is the summary of a perfect simple set of contacts for a temporal phylogeny @xmath82 such that , for all @xmath75 , _ ( v ) < ( v ) < _ ( v ) .",
    "thus a solution is a summary , rather than a set of contacts itself . on the other hand ,",
    "as discussed in the introduction , an ipstn problem includes a set of conditions on a time function , rather than a specific temporal phylogeny .    given an ipstn problem @xmath83 and a nonnegative integer @xmath84 , we want to find the solutions @xmath2 to @xmath83 such that the cardinality of @xmath2 is at most @xmath84 .",
    "our approach to computing solutions is based on their characterization in terms of `` admissible sets . ''",
    "whether or not a set @xmath2 is admissible for an ipstn problem @xmath83 is completely determined by the phylogeny of @xmath83 ; this property does not depend on the time intervals @xmath85 .",
    "the problem of computing admissible sets lends itself well to the use of answer set programming in the spirit of @xcite .",
    "proposition  [ prop : quasi ] below shows , on the other hand , that solutions to @xmath83 can be described as the admissible sets for which a certain system of equations and inequalities has a solution .",
    "this additional condition is easy to verify , for each admissible set , using a constraint programming system .",
    "consider a phylogeny @xmath73 with a root @xmath11 , and a set @xmath2 of 2-element subsets of @xmath81 . by @xmath86",
    "we denote the union of all elements of @xmath2 . by @xmath87",
    "we denote the set obtained from @xmath9 by replacing , for every @xmath88 , the edge @xmath50 with @xmath89 and adding , for every element @xmath90 of @xmath2 , the edges @xmath91    we say that @xmath2 is _ admissible _ if there exists a function @xmath92 such that    1 .   for every leaf @xmath27 of the phylogeny and every @xmath57 , @xmath58 ; 2 .   for every @xmath57 and every @xmath59 ,",
    "if the set @xmath93 is nonempty then the digraph @xmath94 has a subgraph with the set @xmath62 of vertices that is a rooted tree .    in the following proposition , @xmath83 is an ipstn problem defined by a phylogeny @xmath73 with a root @xmath11 and a function @xmath95 .",
    "[ prop : quasi ] a set @xmath2 of 2-element subsets of @xmath81 is a solution to @xmath83 iff    1 .",
    "@xmath2 is admissible , and 2 .",
    "there exists a real - valued function @xmath34 on @xmath96 such that 1 .   for every @xmath75 , @xmath97 2 .   for every @xmath43 , @xmath98 3 .   for every element @xmath69 of @xmath86 ,",
    "@xmath99 4 .   for every element @xmath90 of @xmath2 , @xmath100    * proof*@xmath101_left - to - right .",
    "_ assume that @xmath2 is a solution to @xmath83 , so that there exist a real - valued function @xmath34 on @xmath40 satisfying ( [ time ] ) and a perfect simple set @xmath7 of contacts for the temporal phylogeny @xmath82 such that @xmath2 is the summary of @xmath7 .",
    "the function from @xmath48 to @xmath86 that maps every event @xmath38 to @xmath69 is a 11 correspondence between the two sets .",
    "if we agree to identify every event @xmath38 with its image @xmath69 under this correspondence then @xmath49 becomes identical to @xmath87 , and the conditions on @xmath63 in the definition of a perfect set of contacts turn into the conditions on @xmath63 in the definition of an admissible set . consequently ( i ) follows from the fact that @xmath7 is perfect . to prove ( ii ) ,",
    "extend @xmath34 from @xmath40 to @xmath96 : @xmath102 part  ( a ) follows from  ( [ time ] ) ; part  ( b ) follows from the definition of a temporal phylogeny ; part  ( c ) follows from  ( [ ineq1 ] ) ; part  ( d ) follows from the definition of a contact .",
    "_ right - to - left .",
    "_ assume that @xmath2 satisfies conditions ( i ) and ( ii ) .",
    "consider the temporal phylogeny @xmath39 that consists of the given phylogeny @xmath73 and the function @xmath34 restricted to @xmath40 . by",
    "( a ) , @xmath39 satisfies  ( [ time ] ) .",
    "let @xmath7 be the set obtained from @xmath2 by replacing each symbol @xmath69 in every element of @xmath2 with the event @xmath38 where @xmath103 . from  ( d )",
    "we conclude that the elements of @xmath7 are contacts ; by  ( c ) , @xmath7 is simple .",
    "it is clear that @xmath2 is the summary of @xmath7 . the same reasoning as in the first half of the proof shows that , in view of  ( i ) , @xmath7 is perfect .",
    "the idea of answer set programming is to represent a given computational problem as a logic program whose answer sets ( stable models ) @xcite correspond to solutions .",
    "systems that compute answer sets for a logic program are called answer set solvers .",
    "system with its front - end   is one of the most widely used answer set solvers today .",
    "the system is another answer set solver , and it uses as its front - end also .",
    "this newer system does not have its own search engine ; it is essentially a compiler that translates the problem of computing answer sets into a propositional satisfiability problem ( or into a series of propositional satisfiability problems ) , and invokes a sat solver , such as zchaff , chaff / zchaff.php . ] to perform search .",
    "unlike prolog systems , which expect from the user a program and a query , an answer set solver starts computing given a program only .",
    "for instance , we can give the input program    ....",
    "r(x ) : - p(x ) .",
    "r(x ) : - q(x ) . ....    and it will produce the output    .... stable model : r(0 ) r(1 ) q(1 ) p(0 ) ....    the set of all ground queries to which prolog would respond yes .",
    "given the program    ....",
    "q(1-x ) : - p(x ) , not q(x ) . ....    responds    .... answer : 1 stable model : q(1 ) p(1 ) p(0 )   answer : 2 stable model : q(0 ) p(1 )",
    "p(0 )   ....",
    "this output means , intuitively , that the program can be understood in two ways : either q(0 ) is false and q(1 ) is true , or the other way around . for this program ( and for other programs with several answer sets ) there is no simple relationship between the behavior of prolog and the behavior of answer set solvers .",
    "a prolog program can be viewed as a collection of definitions of predicates .",
    "in addition to such `` defining '' rules , programs often include rules of two other kinds `` choice rules '' and `` constraints . '' for example ,    .... { p , q , r , s}. ....    is a choice rule .",
    "its answer sets are arbitrary subsets of @xmath104 . intuitively , this rule says : for each of the atoms p , q , r , s , choose arbitrarily whether to include it in the answer set .",
    "a choice rule may include restrictions on the cardinality of the answer set .",
    "for instance , the answer sets of    .... 2 { p , q , r , s } 3 .",
    "....    are the subsets @xmath104 whose cardinality is at least 2 and at most 3 .",
    "a constraint is , syntactically , a rule with the empty head .",
    "the effect of adding a constraint to a program is to make the collection of its answer sets smaller  to remove the answer sets that `` violate '' the constraint .",
    "for instance , by adding the constraint    .... : - p , not q. ....    to a program we remove its answer sets that include p and do not include q.    a detailed description of the input language of can be found in the online manual ( http://www.tcs.hut.fi/software/smodels/lparse.ps.gz ) .",
    "an lparse program for generating admissible sets is shown in fig .",
    "[ fig : lparse ] .    .... # domain vertex(u;v ) .",
    "# domain character(i ) .",
    "# domain state(s ) .",
    "{ x(uu , vv ) : vertex(uu;vv ) : uu ! = r : vv ! =",
    "r : uu < vv } k.    xx(u , v ) : - x(u , v ) , u < v. xx(v , u ) : - x(u , v ) , u < v.    v_x(u ) : - xx(u , v )",
    ".    % definition of admissibility , part ( i )    g(v , i , s ) : - f(v , i , s ) .",
    "1 { g(v , i , ss ) : state(ss ) } 1 : - e(v , u )",
    ". 1 { g(pre(v),i , ss ) : state(ss ) } 1 : - v_x(v ) .",
    "% definition of admissibility , part ( ii )    { root(v ,",
    "i , s ) } : - g(v , i , s ) .",
    "{ root(pre(v),i , s ) } : - g(pre(v),i , s ) .",
    ": - root(u , i , s ) , root(v , i , s ) , u < v. : - root(u , i , s ) , root(pre(v),i , s ) .",
    ": - root(pre(u),i , s ) , root(pre(v),i , s ) , u < v.    reachable(v , i , s ) : - root(v , i , s ) .",
    "reachable(pre(v),i , s ) : - root(pre(v),i , s ) .",
    "reachable(pre(v),i , s ) : - e(u , v ) , g(pre(v),i , s ) , reachable(u , i , s ) .",
    "reachable(v , i , s ) : - v_x(v ) , g(v , i , s ) , reachable(pre(v),i , s ) .",
    "reachable(v , i , s ) : - e(u , v ) , not v_x(v ) , g(v , i , s ) , reachable(u , i , s ) .",
    "reachable(pre(u),i , s ) : - xx(u , v ) , g(pre(u),i , s ) , reachable(pre(v),i , s ) .",
    ": - g(v , i , s ) , not reachable(v , i , s ) .",
    ": - g(pre(v),i , s ) , not reachable(pre(v),i , s ) .",
    "....    table  [ table : explanation ] shows the correspondence between the symbols used in the program and the notation introduced in sections  [ sec : phylogeny - pblm - description ] ,  [ ssec : admissible ] and  [ ssec : generating ] . by pre(v ) is suggested by the distinction between a `` proto '' language and its `` pre - proto '' stage in historical linguistics .",
    "the term `` proto - germanic , '' for instance , represents a language that was about to split up into germanic languages , each spoken by a different speech community ; the speech of the ancestors of the proto - germanic generation , slowly changing all the time , is referred to as pre - proto - germanic . ]",
    "the program should be combined with the definition of the domain predicates vertex , e , character , state , f describing the given phylogeny .",
    "the first three lines of the program tell that u and v range over vertices , i ranges over characters , and s over states .",
    "the vertices of the phylogeny are assumed to be integers , and the expression in the program is understood accordingly .",
    "the verification of condition ( ii ) from the definition of an admissible set is based on the fact that ( ii ) can be equivalently stated as follows : for every @xmath57 and every @xmath59 , if the set @xmath62 is nonempty then there is a vertex @xmath105 such all elements of @xmath62 are reachable from @xmath106 in @xmath62 ( * ? ? ?",
    "* proposition  1 ) .",
    ".explanation of the symbols used in fig .",
    "[ fig : lparse ] . [ cols=\"<,<\",options=\"header \" , ]      the three 3-edge solutions listed in section  [ ssec : results ] are identical to the solutions that are marked as `` feasible '' in ( * ? ? ?",
    "* table  3 ) .",
    "that table shows the 16 sets of lateral edges generated by mippn , the software tool designed for solving the minimum increment to perfect phylogenetic network problem .",
    "it is different from the computational problem that we solve here using logic programming tools in that its input does not include any chronological or geographical information .",
    "the 16 sets of contacts produced by mippn were scrutinized by a specialist in the history of indo - european languages , who has determined that most of them are not plausible from the point of view of historical linguistics .",
    "then the remaining 3 sets were declared feasible .",
    "the logic programming approach , on the other hand , allowed us to express the necessary expert knowledge about chronological and geographical constraints in formal notation , and to give this information to the program as part of input , along with the phylogeny .",
    "all `` implausible '' solutions were weeded out in this case by without human intervention .    in the experiments described in @xcite , chronological and geographical information was not part of the input either . but those experiments were similar to the work described in this paper in that search , in both cases ,",
    "was performed using answer set solvers : smodels in @xcite , and cmodels with zchaff in this project .",
    "the difference in the computational efficiency between the two engines turned out to be significant .",
    "with the new tools available , we did not have to employ the `` divide - and - conquer '' strategy described in ( * ? ? ?",
    "* section  6 ) .",
    "the time needed to compute the 3-edge solutions went down from over 150 hours to around 40 minutes . for comparison ,",
    "the computation time of mippn in the same application was around 8 hours ( * ? ? ?",
    "* section  5.3 ) .",
    "the mathematical model of the evolutionary history of natural languages proposed in @xcite enriched the traditional `` evolutionary tree '' model by allowing languages in different branches of the tree to trade their characteristics .",
    "in that theory , phylogenetic networks take place of trees . in this paper",
    "we discussed a further enhancement of the phylogenetic network model , which incorporates a real - valued function assigning times to the vertices of the network and prohibits a contact between two languages if it is chronologically impossible .",
    "the use of the time function allows us to reduce the number of networks that are mathematically `` perfect '' but do not represent historically plausible conjectures .    computing perfect temporal networks",
    "can be accomplished by a combination of an answer set programming `` generator '' with a constraint logic programming `` filter . ''",
    "an alternative approach to combining computational methods developed in these two subareas of logic programming is discussed in @xcite .    in application to the problem of computing perfect networks for a phylogeny of indo - european languages ,",
    "the use of cmodels with zchaff has improved the computation time by two orders of magnitude in comparison with the use of smodels in earlier experiments .",
    "we are grateful to michael gelfond and the anonymous referees for useful suggestions .",
    "vladimir lifschitz was partially supported by the national science foundation under grant iis-0412907 .",
    "don ringe was supported by the national science foundation under grant itr-0321911 .",
    "esra erdem was supported in part by the austrian science fund under project p16536-n04 ; part of this work was done while she visited the university of toronto , which was made possible by hector levesque and ray reiter ."
  ],
  "abstract_text": [
    "<S> the concept of a temporal phylogenetic network is a mathematical model of evolution of a family of natural languages . </S>",
    "<S> it takes into account the fact that languages can trade their characteristics with each other when linguistic communities are in contact , and also that a contact is only possible when the languages are spoken at the same time . </S>",
    "<S> we show how computational methods of answer set programming and constraint logic programming can be used to generate plausible conjectures about contacts between prehistoric linguistic communities , and illustrate our approach by applying it to the evolutionary history of indo - european languages .    </S>",
    "<S> phylogenetics , historical linguistics , indo - european languages , answer set programming , constraint logic programming </S>"
  ]
}