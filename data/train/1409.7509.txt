{
  "article_text": [
    "a research direction of interest in computer science is the application of _ alias analysis _ in verification and optimization of programs .",
    "one of the challenges along this line of research has been the undecidability of determining whether two expressions in a program _ may _ reference the same object .",
    "a rich suite of approaches aiming at providing a satisfactory balance between scalability and precision has already been developed in this regard .",
    "examples include : ( i ) intra - procedural frameworks  @xcite that handle isolated functions only , and their inter - procedural counterparts  @xcite that consider the interactions between function calls ; ( ii ) type - based techniques  @xcite ; ( iii ) flow - based techniques  @xcite that establish aliases depending on the control - flow information of a procedure ; ( iv ) context-(in)sensitive approaches  @xcite that depend on whether the calling context of a function is taken into account or not ; ( v ) field-(in)sensitive approaches  @xcite that depend on whether the individual fields of objects in a program are traced or not .",
    "more details on such classifications can be found in  @xcite , for instance .",
    "for a comprehensive survey on alias analyses for object - oriented programs , corresponding issues and remaining open problems , we refer the interested reader to the works in  @xcite .    of particular interest for the work in this paper",
    "is the untyped , flow - sensitive , field sensitive , inter - procedural and context - sensitive calculus for _ may aliasing _ , introduced in  @xcite .",
    "the aforementioned calculus covers most of the aspects of a modern object - oriented language , namely : object creation and deletion , conditionals , assignments , loops and ( possibly recursive ) function calls .",
    "the approach in  @xcite abstracts the aliasing information in terms of explicit access paths  @xcite referred to as _ alias expressions_. consider , for an example , the code @xmath1 the corresponding execution causes @xmath2 to become aliased to @xmath3 , with a possibly infinite number of occurrences of the field @xmath4 .",
    "the set of associated alias expressions can be equivalently written as : @xmath5 \\mid k \\geq 0\\}.\\ ] ] the sources of imprecision introduced by the calculus in  @xcite are limited to ignoring tests in conditionals , and to `` cutting at length @xmath6 '' , for the case of possibly infinite alias relation as in  ( [ eq : intor - ex ] ) .",
    "intuitively , the cutting technique considers sequences longer than a given length @xmath6 as aliased to all expressions .",
    "there is a huge literature on heap analysis for aliasing  @xcite , but hardly any paper that presents a calculus as in  @xcite allowing the derivation of alias relations as the result of applying various instructions of a programming language .",
    "our focus is two folded .",
    "first , we want extend the framework in  @xcite to the setting of unbounded program executions such as infinite loops and recursive calls . in accordance ,",
    "the goal is to provide a way to shift from `` finite '' to `` infinite behaviours '' .",
    "this can be achieved in a rather straightforward manner , by redefining the construct @xmath7 in  @xcite according to the informal semantics : `` execute @xmath8 repeatedly any number of times , including zero '' .",
    "however , developing a corresponding mechanism for reasoning on `` may aliasing '' in a finite number of steps is not trivial .",
    "the key observation that paves the way to a possible ( finite state - based ) modeling in a non - concurrent setting is that the alias expressions corresponding to loops and recursive calls grow in a regular fashion .",
    "hence , they are finitely representable , as it is easy to see in  ( [ eq : intor - ex ] ) , for instance .",
    "such regularities can not be exploited in concurrent contexts , due to the `` non - determinism '' of process interaction .",
    "a similar technique exploiting regular behaviour of ( non - concurrent ) programs , in order to reason on `` may aliasing '' , was previously introduced in  @xcite . in short",
    ", the results in  @xcite utilize abstract representations of programs in terms of finite pushdown systems , for which infinite execution paths have a regular structure ( or are `` lasso shaped '' )  @xcite . then",
    ", in the style of abstract interpretation  @xcite , the collecting semantics is applied over the ( finite state ) pushdown systems to obtain the alias analysis itself . in short , the main difference with the results in  @xcite consists in how the abstract memory addresses corresponding to pointer variables are represented . in  @xcite these range over a finite set of natural numbers . in this paper",
    "we consider alias expressions build according to the calculus in  @xcite .",
    "the work in  @xcite also proposes an implementation of pushdown systems in the @xmath0-framework  @xcite .",
    "the latter is an executable semantic framework based on rewriting logic ( rl )  @xcite , and has successfully been used for defining programming languages and corresponding formal analysis tools .",
    "moreover , @xmath0 definitions have a direct implementation in @xmath0-maude  @xcite .",
    "we agree that it could be worth presenting our analysis as an abstract interpretation ( ai )  @xcite .",
    "a modelling exploiting the machinery of ai ( based on abstract domains , abstraction and concretization functions , galois connections , fixed - points , _ _ e__tc . ) is an interesting , but different research topic per se .",
    "our second interest w.r.t . may aliasing is its integration in scoop  @xcite  a simple object oriented programming model for concurrency ; thus an operational based approach on handling the alias calculus is more appropriate .",
    "the basis of a rl - based framework for the design and analysis of the scoop model was recently set in  @xcite .",
    "the reference implementation of scoop is eiffel  @xcite .",
    "the integration of alias analysis belongs to a more ambitious goal , namely , the construction of a rl - based toolbox for the analysis of scoop programs ( examples include a deadlock detector and a type checker ) .",
    "[ [ our - contribution . ] ] our contribution .",
    "+ + + + + + + + + + + + + + + + +    by drawing inspiration from , and building on top of the results in  @xcite , in this paper we propose :    * an extension of the ( finite ) alias calculus in  @xcite to the setting of unbounded program executions , and a sound over - approximation technique based on `` regular alias expressions '' , for non - concurrent settings ; * a rl - based specification of the extended calculus ; * an algorithm that always terminates and provides a sound over - approximation of `` may aliasing '' by exploiting a notion of regular ( finitely representable ) aliases , for non - concurrent settings .",
    "moreover , we analyze the integration , implementation and further applications of the alias calculus in scoop .    [ [ paper - structure . ] ] paper structure .",
    "+ + + + + + + + + + + + + + + +     the paper is organized as follows . in section",
    "[ sec : alias - calc ] we introduce the extension of the alias calculus in  @xcite to unbounded executions . in section",
    "[ sec : implem - k ] we provide the rl - based executable specification of the calculus in the @xmath0 semantic framework .",
    "the implementation in scoop , and further applications are discussed in section  [ sec : alias - scoop ] . in section  [ sec : conclusions ] we draw the conclusions and provide pointers to future work .",
    "in this section we define an extension of the calculus in  @xcite , to unbounded program executions .",
    "moreover , based on the idea behind the _ pumping lemma for regular languages _",
    "@xcite , we devise a corresponding sound over - approximation of `` may aliasing '' in terms of regular expressions , applicable in sequential contexts .",
    "this paves the way to developing an algorithm for the aliasing problem , as presented in section  [ sec : implem - k ] , in the formal setting of the @xmath0 semantic framework  @xcite .",
    "[ [ preliminaries . ] ] * preliminaries .",
    "* + + + + + + + + + + + + + + + +    we proceed by briefly recalling the notion of _ alias relation _ and a series of associated notations and basic operations , as introduced in  @xcite .",
    "we call an _ expression _ a ( possibly infinite ) path of shape @xmath9 , where @xmath2 is a local variable , class attribute or _",
    "current _ , and @xmath10 are attributes . here , _",
    "current _ , also known as _ this _ or _ self _ , stands for the current object . for an arbitrary alias expression @xmath11",
    ", it holds that @xmath12 .",
    "let @xmath13 represent the set of all expressions of a program .",
    "alias relation _ is a symmetric and irreflexive binary relation over @xmath14 .",
    "given an alias relation @xmath15 and an expression @xmath11 , we define @xmath16 \\in r\\}\\ ] ] denoting the set consisting of all elements in @xmath15 which are aliased to @xmath11 , plus @xmath11 itself .",
    "let @xmath2 be an expression ; we write @xmath17 to represent @xmath15 without the pairs with one element of shape @xmath18 .",
    "we say that an alias relation is _ dot complete _ whenever for any @xmath19 and @xmath20 it holds that if @xmath21 $ ] and @xmath22 $ ] are alias pairs , then @xmath23 $ ] is an alias pair and , moreover , if @xmath20 is in the domain of @xmath24 , then @xmath25 $ ] is an alias pair . by the `` domain of @xmath24 '' we refer to a method or a field in the class corresponding to the object referred by the expression associated to @xmath24 .",
    "for instance , given a class node with a field @xmath4 of type node , and a node object @xmath2 , we say that @xmath4 is in the domain of @xmath26 . for the sake of brevity , we write _ dot - complete_@xmath27 for the closure under dot - completeness of a relation @xmath15 .    the notation @xmath28 $ ] represents the relation @xmath15 augmented with pairs @xmath29 $ ] and made dot complete , where @xmath30 is an element of @xmath31 .",
    "we further introduce an extension of the alias calculus in  @xcite to infinite alias relations corresponding to unbounded executions such as infinite loops or recursive calls . the main difference in our approach",
    "is reflected by the definition of loops , which now complies to the usual fixed - point denotational semantics .",
    "the alias calculus is defined by a set of axioms `` describing '' how the execution a program affects the aliasing between expressions . as in  @xcite",
    ", the calculus ignores tests in conditionals and loops .",
    "the _ program instructions _ are defined as follows : @xmath32 in short , we write @xmath33 to represent the alias information obtained by executing @xmath8 when starting with the initial alias relation @xmath15 .",
    "the axiom for sequential composition is defined in the obvious way : @xmath34    conditionals are handled by considering the union of the alias pairs resulted from the execution of the instructions corresponding to each of the two branches , when starting with the same initial relation : @xmath35    as previously mentioned , we define @xmath36 according to its informal semantics : `` execute @xmath8 repeatedly any number of times , including zero '' .",
    "the corresponding rule is : @xmath37 where @xmath38 stands for the union of alias relations , as above . this way , our calculus is extended to infinite alias relations .",
    "this is the main difference with the approach in  @xcite that proposes a `` cutting '' technique restricting the model to a maximum length @xmath6 . in  @xcite ,",
    "sequences longer than @xmath6 are considered as aliased to all expressions .",
    "orthogonally , for sequential settings , we provide finite representations of infinite alias relations based on over - approximating regular expressions , as we shall see in section  [ sec : sound - over - approx ] .",
    "both the creation and the deletion of an object @xmath2 eliminate from the current alias relation all the pairs having one element prefixed by @xmath2 : @xmath39    the ( qualified ) function calls comply to their initial definitions in  @xcite : @xmath40){\\textnormal{\\,\\guillemotright\\,}}\\mid f \\mid\\\\ r { \\textnormal{\\,\\guillemotright\\,}}(x.{\\textnormal{\\bf call}\\,f(l ) } ) & = & x.((x'.r ) { \\textnormal{\\,\\guillemotright\\,}}{\\textnormal{\\bf call}\\,f(x'.l ) } ) .",
    "\\end{array}\\ ] ] here @xmath41 and @xmath42 stand for the formal argument list and the body of @xmath43 , respectively , whereas @xmath44 $ ] is the relation @xmath15 in which every element of the list @xmath45 is replaced by its counterpart in @xmath31 .",
    "intuitively , the negative variable @xmath46 is meant to transpose the context of the qualified call to the context of the caller .",
    "note that `` @xmath47 '' ( _ i.e. _ , the constructor for alias expressions ) is generalized to distribute over lists and relations : @xmath48 = [ x.a , x.b , \\ldots]$ ] .",
    "for an example , consider a class @xmath49 in an oo - language , and an associated procedure @xmath43 that assigns a local variable @xmath30 , defined as : @xmath50 .",
    "then , for instance , the aliasing for @xmath51 computes as follows : @xmath52\\ } ) .",
    "\\end{array}\\ ] ]    recursive function calls can lead to infinite alias relations . in sequential settings , as for the case of loops , the mechanism exploiting sound regular over - approximations in order to derive finite representations of such relations is presented in the subsequent sections .",
    "the axiom for assignment is as well in accordance with its original counterpart in  @xcite : @xmath53\\\\ & & { \\textnormal{\\bf then~ } } ( r_{1 } - t)[t\\,=\\,(r_1 \\slash s \\,-\\,t ) ] - ot   { \\textnormal{\\bf~end}}\\\\ \\end{array}\\ ] ] where @xmath54 is a fresh variable ( that stands for `` old @xmath24 '' ) .",
    "intuitively , the aliasing information w.r.t .",
    "the initial value of @xmath24 is `` saved '' by associating @xmath24 and @xmath54 in @xmath15 and closing the new relation under dot - completeness , in @xmath55 .",
    "then , the initial @xmath24 is `` forgotten '' by computing @xmath56 and the new aliasing information is added in a consistent way .",
    "namely , we add all pairs @xmath57 , where @xmath58 ranges over @xmath59 representing all expressions already aliased with @xmath60 in @xmath55 , including @xmath60 itself , but without @xmath24 . recall that alias relations are not reflexive , thus by eliminating @xmath24 we make sure we do not include pairs of shape @xmath61 $ ] . then , we consider again the closure under dot - completeness and forget the aliasing information w.r.t .",
    "the initial value of @xmath24 , by removing @xmath54 .",
    "it is worth discussing the reason behind _ not _ considering transitive alias relations .",
    "assume the following program : @xmath62 based on the equations  ( [ eq : def - then - else ] ) and  ( [ eq : def - assign ] ) handling conditionals and assignments , respectively , the calculus correctly identifies the alias set : @xmath63 , [ y , z]\\}$ ] . including @xmath64 $ ] would be semantically equivalent to the execution of the two branches in the conditional at the same time , which is not what we want .",
    "[ rm : unfolding ] in a sequential setting , the challenge of computing the alias information in the context of ( infinite ) loops and recursive calls reduces to evaluating their corresponding `` unfoldings '' , captured by expressions of shape @xmath65 with @xmath66 ranging over naturals plus infinity , r an ( initial ) alias relation ( @xmath67 ) , and @xmath8 a _ basic control block _ defined by : @xmath68 the value @xmath69 refers to the alias relation obtained by recursively executing the control block @xmath8 , and it is calculated in the expected way : @xmath70 consider again the code in  ( [ eq : code - loop - end ] ) : @xmath71 its execution generates the alias relation @xmath72 including an infinite number of pairs of shape : @xmath73,\\ , [ x , y.next.next],\\ , [ x , y.next.next.next ] \\ldots~~.\\ ] ] a similar reasoning does not hold for concurrent applications , where process interaction is not `` regular '' .    in what follows",
    "we provide a way to compute finite representations of infinite alias relations in sequential settings .",
    "the key observation is that alias expressions corresponding to unbounded program executions grow in a regular fashion .",
    "see , for instance , the aliases in  ( [ eq : inf - rel - next ] ) , which are pairs of type @xmath74 $ ] .",
    "regular expressions are defined similarly to the regular languages over an alphabet .",
    "we say that an expression is _ regular _ if it is a local variable , class attribute or _",
    "current_. moreover , the concatenation @xmath75 of two regular expressions @xmath76 and @xmath77 is also regular . given a regular alias expression @xmath11 , the expression @xmath78 is also regular ; here @xmath79 denotes the kleene star  @xcite .",
    "we call an alias relation _ regular _ if it consists of pairs of regular expressions .",
    "[ lm : sequential - regularity ] assume @xmath8 a program built according to the rules in  ( [ eq : bnf - control - struct ] ) .",
    "then , in a sequential setting , the relation @xmath80 is regular .",
    "the result follows by induction on the structure of @xmath8 .",
    "we refer to appendix  [ sec : reg - expr ] for the detailed proof .    inspired by the idea behind the _ pumping lemma for regular languages _",
    "@xcite , we define a _",
    "lasso _ property for alias relations , which identifies the repetitive patterns within the structure of the corresponding alias expressions .",
    "the intuition is that such patterns will occur for an infinite number of times due to the execution of loops or recursive function calls .",
    "then , we supply sound over - approximations of `` lasso '' relations , based on regular alias expressions . in the context of alias relations ,",
    "we say that the lasso property is satisfied by @xmath15 and @xmath81 whenever the following two conditions hold : ( 1 ) @xmath15 behaves like a _ lasso base _ of @xmath81 .",
    "namely , all the pairs",
    "@xmath82 \\in r$ ] are used to generate elements @xmath83 \\in r'$ ] , by repeating tails of prefixes of @xmath76 and @xmath77 , respectively , and ( 2 ) @xmath81 is a _ lasso extension _ of @xmath15 .",
    "namely , all the pairs in @xmath81 are generated from elements of @xmath15 by repeating tails of their prefixes .",
    "for example , if @xmath76 above is an expression of shape @xmath84 , then @xmath85 can be @xmath86 if we consider the tail @xmath30 of the prefix @xmath87 , or @xmath88 if we take the tail @xmath89 of the prefix @xmath90 .",
    "formally , consider @xmath15 and @xmath81 two alias relations , and @xmath91 and @xmath92 a set of ( possibly empty ) expressions , for @xmath93 .",
    "then : @xmath94 \\in r \\textnormal{~~iff~~ } [ x_1 y_1 y_1 z_1 , x_2 y_2 y_2 z_2 ] \\in r').\\ ] ] for the simplicity of notation we sometimes omit the dot - separators between expressions .",
    "for instance , we write @xmath95 in lieu of @xmath90 .    assuming a lasso over @xmath15 and @xmath81 , we compute a relation consisting of regular expressions over - approximating @xmath15 and @xmath81 as : @xmath96 \\,\\mid\\\\ & & \\,\\,\\ , [ x_1 y_1 z_1 , x_2 y_2 z_2 ] \\in r\\,\\land\\\\ & & \\,\\,\\ , [ x_1 y_1 y_1 z_1 , x_2 y_2 y_2 z_2 ] \\in r'\\ }   \\end{array}\\ ] ] where @xmath91 and @xmath92 are possibly empty expressions , for @xmath93 . as previously indicated , the over - approximation is sound w.r.t . the repeated application of a basic control block as in  ( [ eq : bnf - basic - struct ] ) , in the way that it does not introduce any false negatives :    [ lm : reg - expr ] consider @xmath15 and @xmath81 two alias relations , and @xmath8 a basic control block in a sequential setting .",
    "if @xmath97 and @xmath98 , then the following holds for all @xmath99 : @xmath100    the reasoning is by induction on @xmath101 .",
    "the base case follows immediately , whereas the induction step is proved by `` reductio ad absurdum '' . a detailed proof is included in appendix  [ sec : soundness ] .",
    "in this section we provide the specification of a rl - based mechanism collecting the alias information in the @xmath0 semantic framework  @xcite . we choose @xmath0 more as a notational convention to enable compact and modular definitions . in reality",
    ", the @xmath0-rules in this section are implemented in maude , as rewriting theories , on top of the formalization of scoop  @xcite ( we refer to section  [ sec : alias - scoop ] for more details on our approach ) .    in short ,",
    "our strategy is to start with a program built on top of the control structures in  ( [ eq : bnf - control - struct ] ) , then to apply the corresponding @xmath0-rules in order to get the `` may aliasing '' information in a designated @xmath0-cell ( @xmath102 ) . independently of the setting (",
    "sequential or concurrent ) one can exploit this approach in order to evaluate the aliases of a given finite length @xmath6 .",
    "we also show that for sequential contexts , the application of the @xmath0-rules is finite and the aliases in the final configuration soundly over - approximate the ( infinite ) `` may alias '' relations of the calculus .    * brief overview of @xmath0 .",
    "*    @xmath0  @xcite is an executable semantic framework based on rewriting logic  @xcite .",
    "it is suitable for defining ( concurrent ) languages and corresponding formal analysis tools , with straightforward implementation in @xmath0-maude  @xcite .",
    "@xmath0-definitions make use of the so - called _ cells _ , which are labelled and can be nested , and ( rewriting ) _ rules _ describing the intended ( operational ) semantics .    a _ cell _ is denoted by @xmath103}}}}$ ] , where [ name ] stands for the _ name of the cell_. a construction @xmath104 stands for an _ empty cell _ named n. we use `` pattern matching '' and write @xmath105 for a cell with content @xmath106 at the top , followed by an arbitrary content ( @xmath107 ) .",
    "orthogonally , we can utilize cells of shape @xmath108 and @xmath109 , defined in the obvious way .    of particular interest",
    "is @xmath110  the _ continuation cell _ , or the _ @xmath111-cell _ , holding the stack of program instructions ( associated to one processor ) , in the context of a programming language formalization .",
    "we write @xmath112 for a set of instructions to be `` executed '' , starting with instruction @xmath113 , followed by @xmath114 .",
    "the associative operation @xmath115 is the instruction sequencing .",
    "a @xmath0-rewrite rule @xmath116 reads as : if cell @xmath117 has @xmath106 at the top and cell @xmath118 contains value @xmath119 , then @xmath106 is replaced by @xmath119 in @xmath117 and @xmath119 is added at the end of the cell @xmath120 .",
    "the content of @xmath118 remains unchanged .    in short ,  ( [ eq : def - k - rew - rule - ex ] )",
    "is written in a @xmath0-like syntax as : @xmath121    we further provide the details behind the @xmath0-specification of the alias calculus . as expected , the @xmath111-cell retains the instruction stack of the object - oriented program .",
    "we utilize cells @xmath122 to enclose the current alias information , and the so - called _ back - tracking cells _ @xmath123 enabling the sound computation of aliases for the case of and , in non - concurrent contexts , for loops and ( possibly recursive ) function calls . as a convention",
    ", we mark with ( @xmath124 ) the rules that are sound only for non - concurrent applications , based on lemma  [ lm : reg - expr ] . due to space limitations , in what follows",
    "we introduce only the @xmath0-rules for handling assignments and loops .",
    "the entire specification is included in appendix  [ sec : calculus - complete - spec ] .",
    "as expected , the assignment rule simply restores the current alias relation according to its axiom in  ( [ eq : def - assign ] ) , and removes the assignment instruction from the top of the @xmath111-cell :    @xmath125 - ot$ & \\\\ \\end{tabular } } { \\small \\begin{tabular}{r@{}c@{}l } $ \\langle\\,\\,$ & $ t { \\,:\\!=\\,}s$ & $ \\,\\,\\ldots\\rangle_{\\textnormal{k}}$\\\\ \\cline{2 - 2 } & $ .$ & \\\\",
    "\\end{tabular } } \\,\\,\\,\\,\\ , \\textnormal{with~ } r_{1 } = r[ot = t]\\ ] ]    for @xmath7 , we utilize a meta - construction @xmath126 simulating the unfolding corresponding to  ( [ eq : def - loop ] ) , and a back - tracking stack @xmath127 collecting the alias information obtained after each execution of @xmath8 .",
    "moreover , the @xmath0-implementation exploits the result in lemma  [ lm : reg - expr ] .",
    "whenever a `` lasso '' is reached , the infinite rewriting is prevented by resuming the infinite application of @xmath8 in terms of a sound over - approximating alias relation .",
    "the @xmath0-rules are as follows .",
    "first , the aforementioned unfolding is performed , and the alias relation before @xmath8 is stored in the back - tracking cell as @xmath128 :    @xmath129    if the alias relation @xmath81 obtained after the successful execution of @xmath8 ( marked by @xmath130 at the top of the continuation ) is not a lasso of the aliasing @xmath15 before @xmath8 ( previously stored in @xmath131 ) then @xmath8 is constrained to a new execution by becoming the top of the @xmath111-cell , and @xmath81 is memorized for back - tracking :    @xmath132    last , if a lasso is reached after the execution of @xmath8 , then the current aliasing is soundly replaced by a `` regular '' over - approximation @xmath133 , the corresponding back - tracking information is removed from @xmath131 and the * loop * instruction is eliminated from the @xmath111-cell :    @xmath134    in a non - concurrent setting , the machinery orchestrating the @xmath0-rules introduced in this section , and thoroughly discussed in appendix  [ sec : calculus - complete - spec ] , implements an algorithm that always terminates and provides a sound over - approximation of `` may aliasing '' .    [",
    "th : dec - proc ] consider @xmath8 a program built on top of the control structures in  ( [ eq : bnf - control - struct ] ) , that executes in a sequential setting .",
    "then , the application of the corresponding @xmath0-rules when starting with @xmath8 and an empty alias relation , is a finite rewriting of shape @xmath135 with @xmath15 a sound over - approximation of the aliasing information corresponding to the execution of @xmath8 .",
    "the key observation is that , due to the execution of loops and/or recursive calls , expressions can infinitely grow in a _ regular _ fashion .",
    "hence , a lasso is always reached .",
    "consequently , the control structure generating the infinite behaviour is removed from the @xmath111-cell , according to the associated @xmath0-specification for loops and/or recursive calls .",
    "this guarantees termination . moreover ,",
    "recall that the regular expressions replacing the current alias information are a sound over - approximation , according to lemma  [ lm : reg - expr ] .",
    "observe that the @xmath136-based machinery can simulate precisely the `` cutting at length l '' technique in  @xcite .",
    "it suffices to disable the rules ( @xmath124 ) and stop the rewriting after l steps .",
    "the naturalness of applying the resulted aliasing framework is illustrated in the example in appendix  [ sec : example - k - machinery ] , for the case of two mutually recursive functions .",
    "in this section we provide a brief overview on the integration and applicability of the alias calculus in scoop  @xcite  a simple object - oriented programming model for concurrency .",
    "two main characteristics make scoop simple : 1 ) just one keyword programmers have to learn and use in order to enable concurrent executions , namely , _ separate _ and 2 ) the burden of orchestrating concurrent executions",
    "is handled within the model , therefore reducing the risk of correctness issues .    in short ,",
    "the key idea of scoop is to associate to each object a processor , or _ handler _ ( that can be a cpu , or it can also be implemented in software , as a process or thread ) . assume a processor @xmath8 that performs a call @xmath137 on an object @xmath138 . if @xmath138 is declared as `` separate '' , then @xmath8 sends a request for executing @xmath139 to @xmath140  the handler of @xmath138 ( note that @xmath8 and @xmath140 can coincide ) .",
    "meanwhile , @xmath8 can continue .",
    "processors communicate via _",
    "the maude semantics of scoop in  @xcite is defined over tuples of shape @xmath141 where , @xmath142 denotes a processor ( for @xmath143 ) , @xmath144 is the call stack of @xmath142 and @xmath145 is the _ state _ of the system .",
    "states hold the information about the _ heap _ ( which is a mapping of references to objects ) and the _ store _ ( which includes formal arguments , local variables , _",
    "etc_. ) .    the assignment instruction , for instance",
    ", is formally specified as the transition rule : @xmath146 where , intuitively , `` eval@xmath147 '' evaluates @xmath60 and puts the result on channel @xmath20 , `` wait@xmath148 '' enables processor @xmath8 to use the evaluation result , `` write@xmath149 '' sets the value of @xmath24 to @xmath150 , @xmath151 is a call stack , and @xmath152 is a typing environment  @xcite containing the class hierarchy of a program and all the type definitions .      for a case study , one can download the scoop formalization at : + https://dl.dropboxusercontent.com/u/1356725/scoop.zip + and run the command + ` > maude scoop.maude .. \\examples\\aliasing - linked_list.maude ` + corresponding to the code in  ( [ eq : code - loop - end ] ) : @xmath156 the console outputs the aliased expressions for a rewriting of depth @xmath157 which include , as expected , pairs of shape @xmath158 $ ] . (",
    "the over - approximating mechanism for sequential settings is still to be implemented . )",
    "as can be observed based on the code in ` aliasing - linked_list.maude ` , in order to implement our applications in maude , we use intermediate ( still intuitive ) representations .",
    "for instance , the class structure defining a node in a simple linked list , with filed _ next _ is declared as :    .... class ' node      create { ' make }      ( attribute { ' any } ' next : [ ? , .",
    ", ' node ] ; )     [ ... ] end ; ....",
    "where ` ' next : [ ? , . , '",
    "node ] ` stands for an object of type node , that is handled by the current processor ( ` . ` ) and that can be void ( ` ? ` ) , and ` ' make ` plays the role of a constructor . the intermediate representation of the instruction block in  ( [ eq : code - loop - end ] ) is :    .... assign ( ' x , ' y ) ; until false loop ( assign ( ' x , ' x . '",
    "next(nil ) ) ; ) end ; ....",
    "we include in appendix  [ app : maude - aliasing ] the whole class structure corresponding to  ( [ eq : code - loop - end ] ) , together with ( the relevant parts of ) the console output . for a detailed description of scoop and its maude formalization",
    "we refer the interested reader to the work in  @xcite .",
    "apart from providing an alias analysis tool , the alias calculus can be exploited in order to build an abstract semantics of scoop .",
    "for example , an abstraction of the assignment rule  ( [ eq : k - assign ] ) would omit the evaluation of the right - hand side of the assignment @xmath159 and the associated message passing between channels : @xmath160 where @xmath161 - ot   \\end{array}\\ ] ] with @xmath15 and @xmath55 as in  ( [ eq : k - assign ] ) .",
    "this way one derives a simplified , reduced semantics of scoop , more appropriate for model checking , for instance ; the current scoop formalization in maude is often too large for this purpose .",
    "a survey on abstracting techniques on top of maude executable semantics is provided in  @xcite .",
    "furthermore , the aliasing information could be used for the so - called `` deadlocking '' problem , where two or more executing threads are each waiting for the other to finish . in the context of scoop , this is equivalent to identifying whether a set of processors reserve each other circularly ( _ i.e. _ , there is a coffman deadlock ) .",
    "this situation might occur , for instance , in a dinning philosophers scenario , where both philosophers and forks are objects residing on their own processors .",
    "the difficulty of identifying such deadlocks stems from the fact that scoop processors are known from object references , which _ may be aliased_.",
    "in this paper we provide an extension of the alias calculus in  @xcite from finite alias relations to infinite ones corresponding to loops and recursive calls . moreover , we devise an associated executable specification in the @xmath0 semantic framework  @xcite . in theorem",
    "[ th : dec - proc ] we show that the rl - based machinery implements an algorithm that always terminates with a sound over - approximation of `` may aliasing '' , in non - concurrent settings .",
    "this is achieved based on the sound ( finitely representable ) over - approximation of ( `` lasso shaped '' ) alias expressions in terms of regular expressions , as in lemma  [ lm : reg - expr ] .",
    "we also discuss the integration and applicability of the alias calculus on top of the maude formalization of scoop  @xcite .    an immediate direction for future work is to identify interesting ( industrial ) case studies to be analyzed using the framework developed in this paper .",
    "we are also interested in devising heuristics comparing the efficiency and the precision ( _ e.g. _ , the number of false positives introduced by the alias approximations ) between our approach and other aliasing techniques . in this respect",
    ", we anticipate that the rewriting modulo associativity , together with the pattern matching capabilities of maude will accelerate the identification of the `` lasso '' properties and the corresponding over - approximating regular alias expressions .",
    "this could eventually provide an effective reasoning apparatus for the `` may aliasing '' problem .",
    "another research direction is to derive alias - based abstractions for analyzing concurrent programs .",
    "we foresee possible connections with the work in  @xcite on _ concurrent kleene algebra _ formalizing choice , iteration , sequential and concurrent composition of programs .",
    "the corresponding definitions exploit abstractions of programs in terms of traces of events that can depend on each other .",
    "thus , obvious challenges in this respect include : ( i ) defining notions of dependence for all the program constructs in this paper , ( ii ) relating the concurrent kleene operators to the semantics of the scoop concurrency model and ( iii ) checking whether fixed - points approximating the aliasing information can be identified via fixed - point theorems .",
    "furthermore , it would be worth investigating whether the graph - based model of alias relations introduced in  @xcite can be exploited in order to derive finite @xmath0 specifications of the extended alias calculus . in case of a positive answer",
    ", the general aim is to study whether this type of representation increases the speed of the reasoning mechanism , and why not  its accuracy . with the same purpose ,",
    "we refer to a possible integration with the technique in  @xcite that handles point - to graphs via a stack - based algorithm for fixed - point computations .",
    "we are also interested to what extent an abstract semantics based on aliases for scoop can be exploited for building more efficient analysis tools such as deadlock detectors , for instance . a survey on similar techniques that abstract away from possibly irrelevant information w.r.t .",
    "the problem under consideration is provided in  @xcite .",
    "[ [ acknowledgements ] ] acknowledgements + + + + + + + + + + + + + + + +     we are grateful for valuable comments to mriuca asvoae , alexander kogtenkov , jos meseguer , bertrand meyer , benjamin morandi and sergey velder .",
    "the research leading to these results has received funding from the european research council under the european union s seventh framework programme ( fp7/2007 - 2013 ) / erc grant agreement no .",
    "291389 .    10    e.  albert , p.  arenas , s.  genaim , and g.  puebla",
    ". field - sensitive value analysis by field - insensitive analysis . in _ proceedings of the 2nd world congress on formal methods",
    "_ , fm 09 , pages 370386 , berlin , heidelberg , 2009 .",
    "springer - verlag .    i.  m. asavoae .",
    "abstract semantics for alias analysis in k. , 304:97110 , 2014 .",
    "a.  bouajjani , j.  esparza , and o.  maler .",
    "reachability analysis of pushdown automata : application to model - checking . in _",
    "concur _ , pages 135150 , 1997 .",
    "m.  burke , p.  carini , j .- d .",
    "choi , and m.  hind .",
    "flow - insensitive interprocedural alias analysis in the presence of pointers . in k.",
    "pingali , u.  banerjee , d.  gelernter , a.  nicolau , and d.  padua , editors , _ languages and compilers for parallel computing _",
    ", volume 892 of _ lecture notes in computer science _ , pages 234250 . springer berlin heidelberg , 1995",
    ".    d.  r. chase , m.  n. wegman , and f.  k. zadeck .",
    "analysis of pointers and structures . in",
    "_ pldi _ , pages 296310 , 1990 .",
    "choi , m.  burke , and p.  carini .",
    "efficient flow - sensitive interprocedural computation of pointer - induced aliases and side effects . in _ proceedings of the 20th acm sigplan - sigact symposium on principles of programming languages _ , popl 93 , pages 232245 , new york , ny , usa , 1993 .",
    "p.  cousot and r.  cousot .",
    "abstract interpretation and application to logic programs .",
    ", 13(2&3):103179 , 1992 .",
    "a.  diwan , k.  s. mckinley , and j.  e.  b. moss .",
    "type - based alias analysis .",
    ", 33(5):106117 , may 1998 .",
    "m.  emami , r.  ghiya , and l.  j. hendren .",
    "context - sensitive interprocedural points - to analysis in the presence of function pointers . in _ proceedings of the acm sigplan 1994 conference on programming language design and implementation",
    "_ , pldi 94 , pages 242256 , new york , ny , usa , 1994 .",
    "m.  hind .",
    "pointer analysis : havent we solved this problem yet ?",
    "in _ paste _ , pages 5461 , 2001 .",
    "m.  hind , m.  burke , p.  carini , and j .- d .",
    "interprocedural pointer alias analysis .",
    ", 21(4):848894 , july 1999 .    c.  a.  r. hoare , b.  mller , g.  struth , and i.  wehrman",
    ". concurrent kleene algebra . in _",
    "concur 2009 - concurrency theory , 20th international conference , concur 2009 , bologna , italy , september 1 - 4 , 2009 .",
    "proceedings _ , pages 399414 , 2009 .    s.  c. kleene .",
    "representation of events in nerve nets and finite automata . in c.",
    "shannon and j.  mccarthy , editors , _ automata studies _ , pages 341 .",
    "princeton university press , princeton , nj , 1956 .",
    "a.  kogtenkov , b.  meyer , and s.  velder .",
    "alias and change calculi , applied to frame inference .",
    ", abs/1307.3189 , 2013 .",
    "w.  landi .",
    "undecidability of static analysis . , 1(4):323337 , dec .",
    "w.  landi and b.  g. ryder .",
    "pointer - induced aliasing : a problem classification . in _ proceedings of the 18th acm sigplan - sigact symposium on principles of programming languages _ , popl 91 , pages 93103 , new york , ny , usa , 1991 .",
    "j.  r. larus and p.  n. hilfinger .",
    "detecting conflicts between structure accesses . in _ pldi _ , pages 2134 , 1988 .",
    "j.  meseguer and g.  rosu .",
    "the rewriting logic semantics project : a progress report . in",
    "_ fundamentals of computation theory - 18th international symposium , fct 2011 , oslo , norway , august 22 - 25 , 2011 . proceedings _ , pages 137 , 2011 .",
    "b.  meyer . .",
    "prentice - hall , 1991 .",
    "a.  min .",
    "field - sensitive value analysis of embedded c programs with union types and pointer arithmetics . in _ proceedings of the 2006 acm sigplan / sigbed conference on language , compilers , and tool support for embedded systems _ , lctes 06 , pages 5463 , new york , ny , usa , 2006 .",
    "b.  morandi , m.  schill , s.  nanz , and b.  meyer .",
    "prototyping a concurrency model . in _ acsd _ , pages 170179 , 2013 .",
    "e.  m. myers . a precise inter - procedural data flow algorithm . in _ proceedings of the 8th acm sigplan - sigact symposium on principles of programming languages _ , popl 81 , pages 219230 , new york , ny , usa , 1981 .",
    "nienaltowski . .",
    "eth , 2007 .",
    "m.  o. rabin and d.  scott .",
    "finite automata and their decision problems . , 3(2):114125 , apr .",
    "v.  robert and x.  leroy . a formally - verified alias analysis .",
    "cpp _ , pages 1126 , 2012 .",
    "g.  rosu and t.  f. serbanuta .",
    "k overview and simple case study . in _ proceedings of international k workshop ( k11 )",
    "_ , entcs .",
    "elsevier , 2013 .",
    "serbanuta and g.  rosu .",
    "k - maude : a rewriting based tool for semantics of programming languages . in _ wrla _ ,",
    "pages 104122 , 2010 .",
    "m.  sridharan , s.  chandra , j.  dolby , s.  j. fink , and e.  yahav .",
    "alias analysis for object - oriented programs . in _ aliasing in object - oriented programming _ , pages 196232 .",
    "r.  p. wilson and m.  s. lam .",
    "efficient context - sensitive pointer analysis for c programs . in _ proceedings of the acm sigplan 1995 conference on programming language design and implementation _ , pldi 95 , pages 112 , new york , ny , usa , 1995 .",
    "in this section we provide the proof of lemma  [ lm : sequential - regularity ] ; we proceed by demonstrating a series of intermediate results .",
    "[ rm : op - preserve - reg ] we first observe that the operations @xmath162 , @xmath163 , dot - completeness and @xmath164 $ ] introduced in section  [ sec : alias - calc ] preserve the regularity of an alias relation @xmath15 .",
    "then , we define a notion of _ finite execution _ control blocks : @xmath165 where @xmath43 stands for a non - recursive function .",
    "it is easy to see that the execution of control blocks as in  ( [ eq : bnf - basic - struct - finite ] ) preserve the regularity of alias relations as well .",
    "[ lm : reg - fin - exec ] for all regular alias relations @xmath15 and @xmath8 a finite - execution control block , in a sequential setting , it holds that @xmath166 is also regular .",
    "the proof follows immediately , by induction on the structure of @xmath8 and remark  [ rm : op - preserve - reg ] .",
    "base cases are : @xmath167 , @xmath168 and @xmath169 . for function calls ,",
    "the result is a consequence of their corresponding unfolding , based on the definitions in  ( [ eq : def - qualified - call ] ) .",
    "[ rm : rec - calls - loop ] w.r.t . may aliasing , recursive calls can be handled via loops .",
    "consider , for instance the recursive function @xmath170 where @xmath171 and @xmath172 are instruction blocks built as in  ( [ eq : bnf - control - struct ] ) .",
    "it is intuitive to see that computing the may aliases resulted from the execution of @xmath173 reduces executing unfoldings of shape : @xmath174    moreover , unbounded program executions also preserve regularity .",
    "[ lm : reg - infin - exec ] for all regular alias relations @xmath15 and @xmath8 a control block that can execute unboundedly , in a sequential setting , it holds that @xmath166 is also regular .",
    "the proof follows by induction on the number of nested loops in @xmath8 and remark  [ rm : rec - calls - loop ] .",
    "then , the result in lemma  [ lm : sequential - regularity ] follows immediately by lemma  [ lm : reg - fin - exec ] and lemma  [ lm : reg - infin - exec ] .",
    "in what follows we provide the proof of lemma  [ lm : reg - expr ] : + _ consider @xmath15 and @xmath81 two alias relations , and @xmath8 a basic control block . if @xmath97 and @xmath98 , then the following holds for all @xmath175 : @xmath100 _    we proceed by induction on @xmath101 .",
    "* _ base case _ : @xmath176 . by hypothesis",
    "it holds that @xmath98 .",
    "hence , according to the definition of @xmath177 in  ( [ eq : def - lasso ] ) , there exists a one - to - one correspondence of the shape @xmath178 \\in r \\textnormal{~~iff~~ } [ x_1 y_1 y_1 z_1 , x_2 y_2 y_2 z_2 ] \\in r'\\ ] ] between the elements of @xmath15 and @xmath81 , respectively .",
    "+ consequently , by the definition of @xmath179 in  ( [ eq : def - reg ] ) , it is easy to see that @xmath180 * _ induction step . _ fix a natural number @xmath101 and suppose that @xmath181 for all @xmath182 .",
    "we want to prove that  ( [ eq : ind - step ] ) holds also for @xmath183 .",
    "+ we continue by `` reductio ad absurdum '' .",
    "consider @xmath184 and assume that @xmath185 clearly , the execution of @xmath8 when starting with @xmath186 identifies an alias pair which is not in @xmath133 .",
    "given that @xmath8 is a basic control block as in  ( [ eq : bnf - basic - struct ] ) , and based on the corresponding definitions in  ( [ eq : def - seq - comp])([eq : def - assign ] ) , it is not difficult to observe that the regular structure of the alias information can only be broken via a new added pair @xmath57 associated to an assignment @xmath169 within @xmath8 .",
    "+ let @xmath187 $ ] , where @xmath49 is a context built according to  ( [ eq : bnf - basic - struct ] ) , and @xmath169 is the upper - most assignment instruction in the syntactic tree associated to @xmath8 , that introduces a pair @xmath188 $ ] which is not in @xmath133 .",
    "assume that @xmath189 is the intermediate alias relation obtained by reducing @xmath190 $ ] according to the equations  ( [ eq : def - seq - comp])([eq : def - assign ] ) , before the application of the assignment axiom corresponding to @xmath191 .",
    "note that @xmath169 was executed at least once before , as @xmath175 , and observe that @xmath192 .",
    "hence , we identify two situations in the context of the aforementioned execution : ( a ) either all the newly added pairs corresponding to the assignment @xmath169 complied to the regular structure , or ( b ) each new pair @xmath193 $ ] that did not fit the regular pattern was later removed via a subsequent instruction `` @xmath194 '' or `` @xmath195 '' within @xmath8 , with @xmath31 a prefix of @xmath196 or @xmath58 .",
    "+ if the case ( a ) above was satisfied , then , based on the definition of dot - completeness , a pair @xmath197 - ot,\\ ] ] where @xmath198\\ ] ] can not break the regular pattern of the alias expressions either . for the case",
    "( b ) above , all the `` non - well - behaved '' new pairs will be again removed via a subsequent `` @xmath194 '' or `` @xmath195 '' within @xmath8 .",
    "+ therefore , the assumption in  ( [ eq : red - absurdum ] ) is false , so it holds that : @xmath199",
    "in this section we provide the full specification of the alias calculus in @xmath0 .",
    "recall that , as a convention , we mark with ( @xmath124 ) the rules that are sound only for non - concurrent contexts , based on lemma  [ lm : reg - expr ] .",
    "the following @xmath0-rules are straightforward , based on the axioms  ( [ eq : def - seq - comp])([eq : def - assign ] ) in section  [ sec : ext - inf - expr ] .",
    "namely , the rule implementing an instruction @xmath200 simply forces the sequential execution of @xmath8 and @xmath140 by positioning @xmath201 at the top of the continuation cell :    @xmath202    handling @xmath167 and @xmath168 complies to the associated definitions .",
    "namely , it updates the current alias relation by removing all the pairs having ( at least ) one element with @xmath2 as prefix .",
    "in addition , it also pops the corresponding instruction from the continuation stack :    @xmath203    the assignment rule restores the current alias relation according to its axiom in  ( [ eq : def - assign ] ) , and removes the assignment instruction from the top of the @xmath111-cell :    @xmath204 - ot$ & \\\\ \\end{tabular } } { \\small \\begin{tabular}{r@{}c@{}l } $ \\langle\\,\\,$ & $ t { \\,:\\!=\\,}s$ & $ \\,\\,\\ldots\\rangle_{\\textnormal{k}}$\\\\ \\cline{2 - 2 } & $ .$ & \\\\",
    "\\end{tabular } } \\,\\,\\,\\,\\ , \\textnormal{with~ } r_{1 } = r[ot = t]\\ ] ]    the @xmath0-implementation of a @xmath205 statement is more sophisticated , as it instruments a stack - based mechanism enabling the computation of the union of alias relations @xmath206 in three steps .",
    "first , we define the @xmath0-rule : @xmath207 saving at the top of the back - tracking stack @xmath208 the initial alias relation @xmath15 to be modified by both @xmath8 and @xmath140 , via two cells @xmath209 and @xmath210 , respectively .",
    "note that the original instruction in the @xmath111-cell is replaced by a meta - construction marking the end of the executions corresponding to the * then * and * else * branches with @xmath211 and @xmath212 , respectively .",
    "second , whenever the successful execution of @xmath8 ( signaled by @xmath211 ) at the top of the @xmath111-cell ) builds an alias relation @xmath81 , the execution of @xmath140 starting with the original relation @xmath15 is forced by replacing @xmath81 with @xmath15 in @xmath213 , and by positioning @xmath214 at the top of the @xmath111-cell .",
    "the new alias information after @xmath8 , denoted by @xmath215 , is updated in the back - tracking cell :    @xmath216    eventually , if the successful execution of @xmath140 ( marked by @xmath212 at the top of @xmath217 ) produces an alias relation @xmath218 , then the final alias information becomes @xmath219 , where @xmath81 is the aliasing after @xmath8 , stored as showed in  ( [ appeq : k - end - then ] ) .",
    "the corresponding back - tracking information is removed from @xmath208 , and the next program instruction is enabled in the @xmath111-cell :    @xmath220    for @xmath7 , we utilize a meta - construction @xmath126 simulating the set union in  ( [ eq : def - loop ] ) , and a back - tracking stack @xmath127 collecting the alias information obtained after each execution of @xmath8 .",
    "moreover , the @xmath0-implementation exploits the result in lemma  [ lm : reg - expr ] . whenever a `` lasso '' is reached , the infinite rewriting is prevented by resuming the infinite application of @xmath8 in terms of a sound over - approximating alias relation .",
    "the @xmath0-rules are as follows .",
    "first , the aforementioned unfolding is performed , and the alias relation before @xmath8 is stored in the back - tracking cell as @xmath128 :    @xmath221    if the alias relation @xmath81 obtained after the successful execution of @xmath8 ( marked by @xmath130 at the top of the continuation ) is not a lasso of the aliasing @xmath15 before @xmath8 ( previously stored in @xmath131 ) then @xmath8 is constrained to a new execution by becoming the top of the @xmath111-cell , and @xmath81 is memorized for back - tracking :    @xmath222    last , if a lasso is reached after the execution of @xmath8 , then the current aliasing is soundly replaced by a `` regular '' over - approximation @xmath133 , the corresponding back - tracking information is removed from @xmath131 and the * loop * instruction is eliminated from the @xmath111-cell :    @xmath223    for handling function calls such as @xmath224 we use a meta - construction @xmath225 . here",
    "@xmath42 stands for the body of @xmath43 and @xmath226 marks the end of the corresponding execution .",
    "moreover , a stack @xmath227 is utilized in order to store the alias information before each ( possibly recursive ) call of @xmath43 , with the purpose of identifying the lassos generated by the ( possibly repeated ) execution of @xmath43 . in order to guarantee a sound implementation of ( mutually ) recursive calls ,",
    "both @xmath226 and @xmath227 are parameterized by @xmath43  the name of the function .",
    "an example illustrating this reasoning mechanism is provided in appendix  [ sec : example - k - machinery ] .",
    "the first @xmath0 rule for handling function calls matches the associated axiom in  ( [ eq : def - qualified - call ] ) : the alias information is set to @xmath228 $ ] , whereas the next instructions to be executed are given by @xmath42 .",
    "note that the original aliasing is retained in the ( initially empty ) back - tracking cell via @xmath229 .",
    "@xmath230 $ & \\\\",
    "\\end{tabular } } { \\small \\begin{tabular}{r@{}c@{}l } $ \\langle\\,\\,$ & $ { \\textnormal{\\bf call}\\,f(l)}$ & $ \\,\\,\\ldots\\rangle_{\\textnormal{k}}$\\\\ \\cline{2 - 2 } & $ \\mid f \\mid { \\,\\,\\fbox{f}\\,\\,}$ & \\\\ \\end{tabular } } { \\small \\begin{tabular}{r@{}c@{}l } $ \\langle\\,\\,$ & $ .$ & $ \\,\\,\\rangle_{\\textnormal{bkt - cf}}$\\\\ \\cline{2 - 2 } & $ { \\small \\langle\\,\\ , r \\,\\,\\rangle_{\\textnormal{al - o}}}$ & \\\\ \\end{tabular } } \\ ] ]    [ apprem : formal - vs - actual ] observe that the back - tracking cell does not need to be parameterized by the actual argument list @xmath231 of @xmath43 .",
    "each such argument is anyways replaced in the current alias relation @xmath15 by its counterpart in the formal argument list of @xmath43 .",
    "in short : @xmath15 becomes @xmath232 $ ] .",
    "a successful execution of @xmath224 is distinguished by the occurrence of @xmath226 at the top of the continuation stack .",
    "if this is the case , then the corresponding back - tracking alias information is removed from @xmath227 and the next program instruction ( if any ) is enabled at the top of the @xmath111-cell :    @xmath233    recursive calls are treated by means of two @xmath0-rules .",
    "note that a recursive context is identified whenever the current program instruction is of shape @xmath224 and the associated back - tracking structure is not empty , _",
    "i.e. _ , rule  ( [ appeq : k - call - first ] ) was previously applied . then",
    ", if the recursive call of @xmath43 when starting with @xmath15 produces a lasso @xmath81 , the execution of @xmath234 is stopped by soundly over - approximating the alias information with @xmath133 , according to lemma  [ lm : reg - expr ] , and by removing @xmath224 from the @xmath111-cell :    @xmath235    if a lasso is not reached , then the body of @xmath43 is executed once more , and the current aliasing is pushed to the back - tracking cell :    @xmath236    qualified calls @xmath237 are handled by two @xmath0-rules as follows .",
    "first , based on the definition in  ( [ eq : def - qualified - call ] ) , the `` negative variable '' @xmath46 transposing the context of the call to to the context of the caller is distributed to the elements of the initial alias relation @xmath15 , and to @xmath231  the argument list of @xmath43 . moreover ,",
    "a meta - construction @xmath238 is utilized in order to mark the end of the qualified call in the continuation cell , similarly to the rule  ( [ appeq : k - call - first ] ) .",
    "the caller is stored in a back - tracking stack @xmath239 also parameterized by @xmath43 ",
    "the name of the function .",
    "the current instruction in the @xmath111-cell becomes @xmath240 , as expected :    @xmath241    second , when the successful termination of the qualified call is signaled by @xmath238 at the top of the @xmath111-cell , the corresponding stored caller is distributed to the current alias relation and removed from the back - tracking cell .",
    "the next instruction in the continuation cell is released by eliminating the top @xmath238 :    @xmath242",
    "for an example , in this section we show how the @xmath0-machinery developed in section  [ sec : implem - k ] can be used in order to extract the alias information for the case of two mutually recursive functions defined as : @xmath243 we assume that @xmath2 is an object of a class with two fields @xmath20 and @xmath244 , respectively .",
    "we consider a sequential setting .",
    "the associated reasoning in @xmath0 is depicted in the figure below .",
    "the whole procedure starts with an empty alias relation @xmath67 , and @xmath245 in the continuation stack .",
    "then , the corresponding @xmath0 rules ( for handling assignments and function calls ) are applied in the natural way .",
    "a lasso is reached after two calls of @xmath173 that , consequently , determine two calls of @xmath247  identified by @xmath248 in the @xmath111-cell .",
    "this triggers the application of rule  ( [ appeq : k - call - lasso ] ) enabling the `` regular '' over - approximation as in lemma  [ lm : reg - expr ] .    our example also illustrates the importance of isolating the back - traced alias information in cells of shape @xmath249 parameterized by the ( possibly recursive ) function @xmath43 . more explicitly , rule  ( [ appeq : k - call - lasso ] ) is soundly applied by identifying the aforementioned lasso based on : the current alias relation @xmath250 , the recursive call @xmath234 at the top of the continuation , and the back - traced aliasing @xmath251 associated to the previous executions of @xmath234 .    as introduced in  ( [ eq : def - lasso ] )",
    ", an alias relation @xmath81 is a lasso of a relation @xmath15 whenever there is a one - to - one correspondence between their elements as follows : @xmath178 \\in r \\textnormal{~~iff~~ } [ x_1 y_1 y_1 z_1 , x_2 y_2 y_2 z_2 ] \\in r'.\\ ] ] the current alias relation @xmath252,\\ , [ x.a , x.a.b.a.b.a],\\ , [ x.b , x.a.b.a.b.b]\\},\\ ] ] before applying rule  ( [ appeq : k - call - lasso ] ) , is a lasso of @xmath253,\\ , [ x.a , x.a.b.a],\\ , [ x.b , x.a.b.b]\\}.\\ ] ] the aforementioned one - to - one correspondence is summarized in the following table : @xmath254 \\in r_2 $ & { ~iff~ } & $ [ x_1 y_1 y_1 z_1 , x_2",
    "y_2 y_2 z_2 ] \\in r_4 $ & $ x_1 $ & $ y_1 $ & $ z_1 $ & $ x_2 $ & $ y_2 $ & $ z_2$\\\\ \\hline $ [ x , x.a.b ] \\in r_2 $ & { ~iff~ } & $ [ x , x.a.b.a.b ] \\in r_4 $ & $ x$ & $ \\varepsilon$ & $ \\varepsilon$ & $ x$ & $ a.b$ & $ \\varepsilon$\\\\ \\hline $ [ x.a , x.a.b.a ] \\in r_2 $ & { ~iff~ } & $ [ x.a , x.a.b.a.b.a ] \\in r_4 $ & $ x$ & $ \\varepsilon$ & $ a$ & $ x$ & $ a.b$ & $ a$\\\\ \\hline $ [ x.b , x.a.b.b ] \\in r_2 $ & { ~iff~ } & $ [ x.b , x.a.b.a.b.b ] \\in r_4 $ & $ x$ & $ \\varepsilon$ & $ b$ & $ x$ & $ a.b$ & $ b$ \\end{tabular}\\ ] ] here @xmath255 stands for the _ empty alias expression_.    moreover , according to rule  ( [ appeq : k - call - lasso ] ) , the lasso shaped by @xmath256 and @xmath250 also causes the ( otherwise infinite ) recursive calls to stop , as @xmath224 is eliminated from the top of the @xmath111-cell .",
    "hence , the rewriting process finishes with a sound over - approximation @xmath257 replacing the current alias relation ( cf .",
    "lemma  [ lm : reg - expr ] ) , defined precisely as in  ( [ eq : ex - mut - rec - alias ] ) .",
    "@xmath258 \\multicolumn{2}{c}{$\\downarrow$~(\\ref{appeq : k - call - first})}\\\\[1.5ex ] $ { \\small \\langle\\,\\ , r \\,\\,\\rangle_{\\textnormal{\\textnormal{al}}}}$ & $ { \\small \\langle\\,\\ , x { \\,:\\!=\\,}x.a;\\ , { \\textnormal{\\bf call}\\,g(x ) } { \\,\\,\\fbox{f}\\,\\ , } \\,\\,\\rangle_{\\textnormal{\\textnormal{k}}}}$\\\\ $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cf}}}}$ & $ { \\small \\langle\\,\\ , .",
    "\\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cg}}}}$ \\\\[1.5ex ] \\multicolumn{2}{c}{$\\downarrow$~(\\ref{appeq : k - assign})}\\\\[1.5ex ] $ { \\small \\langle\\,\\ , r_1 \\,\\,\\rangle_{\\textnormal{\\textnormal{al}}}}$ & $ { \\small \\langle\\,\\ , { \\textnormal{\\bf call}\\,g(x ) } { \\,\\,\\fbox{f}\\,\\ , } \\,\\,\\rangle_{\\textnormal{\\textnormal{k}}}}$\\\\ $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cf}}}}$ & $ { \\small \\langle\\,\\ , .",
    "\\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cg}}}}$\\\\ \\multicolumn{2}{c}{where $ r_1 = \\{[x , x.a],\\ , [ x.a , x.a.a],\\ , [ x.b , x.a.b]\\}$ } \\\\[1.5ex ] \\multicolumn{2}{c}{$\\downarrow$~(\\ref{appeq : k - call - not - lasso})}\\\\[1.5ex ] $ { \\small \\langle\\,\\ , r_1 \\,\\,\\rangle_{\\textnormal{\\textnormal{al}}}}$ & $ { \\small \\langle\\,\\ , x { \\,:\\!=\\,}x.b;\\ , { \\textnormal{\\bf call}\\,f(x ) } { \\,\\,\\fbox{g}\\,\\ , } { \\,\\,\\fbox{f}\\,\\ , } \\,\\,\\rangle_{\\textnormal{\\textnormal{k}}}}$\\\\ $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cf}}}}$ & $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_1 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cg}}}}$ \\\\[1.5ex ] \\multicolumn{2}{c}{$\\downarrow$~(\\ref{appeq : k - assign})}\\\\[1.5ex ] $ { \\small \\langle\\,\\ , r_2 \\,\\,\\rangle_{\\textnormal{\\textnormal{al}}}}$ & $ { \\small \\langle\\,\\ , { \\textnormal{\\bf call}\\,f(x ) } { \\,\\,\\fbox{g}\\,\\ , } { \\,\\,\\fbox{f}\\,\\ , } \\,\\,\\rangle_{\\textnormal{\\textnormal{k}}}}$\\\\ $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cf}}}}$ & $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_1 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cg}}}}$\\\\ \\multicolumn{2}{c}{where $ r_2 = \\{[x , x.a.b],\\ , [ x.a , x.a.b.a],\\ , [ x.b , x.a.b.b]\\}$ } \\\\[1.5ex ] \\multicolumn{2}{c}{$\\downarrow$~(\\ref{appeq : k - call - not - lasso})}\\\\[1.5ex ] $ { \\small \\langle\\,\\ , r_2 \\,\\,\\rangle_{\\textnormal{\\textnormal{al}}}}$ & $ { \\small \\langle\\,\\ ,   x { \\,:\\!=\\,}x.a;\\,{\\textnormal{\\bf call}\\,g(x ) } { \\,\\,\\fbox{f}\\,\\ , } { \\,\\,\\fbox{g}\\,\\ , } { \\,\\,\\fbox{f}\\,\\ , } \\,\\,\\rangle_{\\textnormal{\\textnormal{k}}}}$\\\\ $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_2 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o}}}}\\,\\ , { \\small \\langle\\,\\ , r \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cf}}}}$ & $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_1 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cg}}}}$ \\\\[1.5ex ] \\multicolumn{2}{c}{$\\downarrow$~(\\ref{appeq : k - assign})}\\\\[1.5ex ] $ { \\small \\langle\\,\\ , r_3 \\,\\,\\rangle_{\\textnormal{\\textnormal{al}}}}$ & $ { \\small \\langle\\,\\ ,   { \\textnormal{\\bf call}\\,g(x ) } { \\,\\,\\fbox{f}\\,\\ , } { \\,\\,\\fbox{g}\\,\\ , } { \\,\\,\\fbox{f}\\,\\ , } \\,\\,\\rangle_{\\textnormal{\\textnormal{k}}}}$\\\\ $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_2 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o}}}}\\,\\ , { \\small \\langle\\,\\ , r \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cf}}}}$ & $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_1 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cg}}}}$\\\\ \\multicolumn{2}{c}{where $ r_3 = \\{[x , x.a.b.a],\\ , [ x.a , x.a.b.a.a],\\ , [ x.b , x.a.b.a.b]\\}$ } \\\\[1.5ex ] \\multicolumn{2}{c}{$\\downarrow$~(\\ref{appeq : k - call - not - lasso})}\\\\[1.5ex ] $ { \\small \\langle\\,\\ , r_3 \\,\\,\\rangle_{\\textnormal{\\textnormal{al}}}}$ & $ { \\small \\langle\\,\\ ,   x{\\,:\\!=\\,}x.b;\\,{\\textnormal{\\bf call}\\,f(x ) } { \\,\\,\\fbox{g}\\,\\ , } { \\,\\,\\fbox{f}\\,\\ , } { \\,\\,\\fbox{g}\\,\\ , } { \\,\\,\\fbox{f}\\,\\ , } \\,\\,\\rangle_{\\textnormal{\\textnormal{k}}}}$\\\\ $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_2 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o}}}}\\,\\ , { \\small \\langle\\,\\ , r \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cf}}}}$ & $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_3 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o}}}}\\,\\ { \\small \\langle\\,\\ , r_1 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cg}}}}$ \\\\[1.5ex ] \\multicolumn{2}{c}{$\\downarrow$~(\\ref{appeq : k - assign})}\\\\[1.5ex ] $ { \\small \\langle\\,\\ , r_4 \\,\\,\\rangle_{\\textnormal{\\textnormal{al}}}}$ & $ { \\small \\langle\\,\\ ,   { \\textnormal{\\bf call}\\,f(x ) } { \\,\\,\\fbox{g}\\,\\ , } { \\,\\,\\fbox{f}\\,\\ , } { \\,\\,\\fbox{g}\\,\\ , } { \\,\\,\\fbox{f}\\,\\ , } \\,\\,\\rangle_{\\textnormal{\\textnormal{k}}}}$\\\\ $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_2 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o}}}}\\,\\ , { \\small \\langle\\,\\ , r \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cf}}}}$ & $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_3 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o}}}}\\,\\ { \\small \\langle\\,\\ , r_1 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cg}}}}$\\\\ \\multicolumn{2}{c}{where $ r_4 = \\{[x , x.a.b.a.b],\\ , [ x.a , x.a.b.a.b.a],\\ , [ x.b , x.a.b.a.b.b]\\}$ } \\\\[1.5ex ] \\multicolumn{2}{c}{$\\downarrow$~(\\ref{appeq : k - call - lasso})}\\\\[1.5ex ] $ { \\small \\langle\\,\\ , reg(r_2 , r_4 ) \\,\\,\\rangle_{\\textnormal{\\textnormal{al}}}}$ & $ { \\small \\langle\\,\\ ,   { \\,\\,\\fbox{g}\\,\\ , } { \\,\\,\\fbox{f}\\,\\ , } { \\,\\,\\fbox{g}\\,\\ , } { \\,\\,\\fbox{f}\\,\\ , } \\,\\,\\rangle_{\\textnormal{\\textnormal{k}}}}$\\\\ $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_2 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o}}}}\\,\\ , { \\small \\langle\\,\\ , r \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cf}}}}$ & $ { \\small \\langle\\,\\ , { \\small \\langle\\,\\ , r_3 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o}}}}\\,\\ { \\small \\langle\\,\\ , r_1 \\,\\,\\rangle_{\\textnormal{\\textnormal{al - o } } } } \\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cg}}}}$\\\\ \\\\[1.5ex ] \\multicolumn{2}{c}{$\\downarrow$~(*)(\\ref{appeq : k - call - exit})}\\\\[1.5ex ] \\multicolumn{2}{c } { $ { \\small \\langle\\,\\ , \\{[x , x.(a.b)^*],\\,[x.a , x.(a.b)^*.a],\\ , [ x.b , x.(a.b)^*.b ]   \\ } \\,\\,\\rangle_{\\textnormal{\\textnormal{al } } } } { \\small \\langle\\,\\ , .",
    "\\,\\,\\rangle_{\\textnormal{\\textnormal{k } } } } { \\small \\langle\\,\\ , .",
    "\\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cf } } } } { \\small \\langle\\,\\ , .",
    "\\,\\,\\rangle_{\\textnormal{\\textnormal{bkt - cg}}}}$ } \\end{tabular}\\ ] ]",
    "the intermediate class - based representation ( in ` aliasing - linked_list.maude ` ) corresponding to the example @xmath259 is given as :    .... ( class ' linked_list_test       create   { ' make }      (          procedure { ' any } ' make ( nil )               require true               local                   (   ' x : [ ? , . , '",
    "node ] ;   ' y : [ ? , . , '",
    "node ] ;   )              do                  (                   assign ( ' x , ' y ) ;                  until false loop ( assign ( ' x , ' x . '",
    "next(nil ) ) ; ) end ;                  )                 ensure true                 rescue nil             end ;      )           invariant   true   end ) ;      as can be seen from the code above , the syntax enables expressing eiffel - like properties of classes by using assertions s.a .",
    "preconditions ( introduced by the keyword ` require ` ) , postconditions ( through the keyword ` ensure ` ) and class invariants .",
    "observe that the flag for performing the alias analysis is switched to `` on '' . in ` ' linked_list_test ` , two local variables @xmath2 and @xmath30 of type ` node ` are declared as running on the current processor ( ` . ` ) , _ i.e. _ , they are not _ separate_. the instruction ` assign('x , ' y ) ` , for instance , corresponds to the assignment @xmath260 .",
    "the class defining a ` node ` structure ( in a linked list ) simply consists of a ( non - separate ) field ` ' next ` of type ` node ` .          ....",
    "\\||||||||||||||||||/                     --- welcome to maude ---                       /||||||||||||||||||\\              maude 2.6 built : mar 31 2011 23:36:02              copyright 1997 - 2010 sri international [ ... ] = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = rewrite [ 100 ] in system :   [ ... ] { 0}proc(1 ) : : until false loop    assign('x , ' x . ' next(nil ) ) ; end ; [ ... ] , 100 , aliasing - on ( { [ ' x ; ' y . ' next . ' next . ' next . '",
    "next .      ' next . ' next . ' next . ' next . ' next . ' next . ' next . ' next .      ' next . ' next . ' next . ' next . ' next . ' next . ' next . ' next .      ' next . ' next . ' next . ' next . ' next . ' next . ' next . ' next .      ' next . ' next . ' next . ' next . ' next . ' next . ' next . ' next .      ' next . ' next . ' next . ' next . ' next . '",
    "next ] } u   { [ ' x . '",
    "next ; ' y . ' next . ' next . ' next . ' next . ' next . ' next .       ' next . ' next . ' next . ' next . ' next . ' next . ' next . ' next .      ' next . ' next .   ' next . ' next . ' next . ' next . ' next . '",
    "next .       ' next . ' next . ' next . ' next . ' next . ' next . ' next . ' next .      ' next . ' next . ' next . ' next . ' next . ' next . ' next . ' next .      ' next . ' next . ' next . ' next . ' next ] } ) [ ... ] state    [ ... ]    heap [ ... ]    store [ ... ] end ....    in short , after @xmath157 rewriting steps , the current processor ` { 0}proc(1 ) ` has the execution corresponding to @xmath261 on top of its instruction stack , and the aliasing information contains ( the dot - complete closure of ) the relation @xmath262\\}$ ] .",
    "moreover , the output displays the contents of the current system state , by providing information on the _ heap _ and _ store _ , as formalized in  @xcite ."
  ],
  "abstract_text": [
    "<S> alias analysis has been an interesting research topic in verification and optimization of programs . </S>",
    "<S> the undecidability of determining whether two expressions in a program may reference to the same object is the main source of the challenges raised in alias analysis . in this paper </S>",
    "<S> we propose an extension of a previously introduced alias calculus based on program expressions , to the setting of unbounded program executions such as infinite loops and recursive calls . </S>",
    "<S> moreover , we devise a corresponding executable specification in the @xmath0-framework . </S>",
    "<S> an important property of our extension is that , in a non - concurrent setting , the corresponding alias expressions can be over - approximated in terms of a notion of regular expressions . </S>",
    "<S> this further enables us to show that the associated @xmath0-machinery implements an algorithm that always stops and provides a sound over - approximation of the `` may aliasing '' information , where soundness stands for the lack of false negatives . as a case study </S>",
    "<S> , we analyze the integration and further applications of the alias calculus in scoop . </S>",
    "<S> the latter is an object - oriented programming model for concurrency , recently formalized in maude ; @xmath0 definitions can be compiled into maude for execution . </S>"
  ]
}