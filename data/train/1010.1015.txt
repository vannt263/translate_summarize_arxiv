{
  "article_text": [
    "many topics within astronomy require data gathered at the limits of detection of current telescopes .",
    "one such limit is that of the lowest detectable photon flux given the noise floor of the optics and camera .",
    "this limit determines the level below which faint objects , ( _ e.g. _ , galaxies , nebulae , and stars ) , can not be detected via single exposures .",
    "consequently , increasing the signal - to - noise ratio ( snr ) of such image data is a critical data - processing step . combining multiple brief images , _",
    "i.e. _ , _ _ coaddition _ _ , can alleviate this problem by increasing the dynamic range and getting better control over the point spread function ( psf ) .",
    "coaddition has successfully been used to increase snr for the study of many topics in astronomy including gravitational lensing , the nature of dark matter , and the formation of the large structure of the universe .",
    "for example , it was used to produce the hubble deep field @xcite .",
    "while image coaddition is a fairly straightforward process , it can be costly when performed on a large dataset , as is often the case with astronomical data ( _ e.g. _ , tens of terabytes for recent surveys , tens of petabytes for future surveys . ) .",
    "seemingly simple routines such as coaddition can therefore be a time- and data - intensive procedure .",
    "consequently , distributing the workload in parallel is often necessary to reduce time - to - solution .",
    "we wanted a parallelization strategy that minimized development time , was highly scalable , and which was able to leverage increasingly prevelant service - based resource delivery models , often referred to as _",
    "cloud computing_. the mapreduce framework ( google 2004)offers a simplified programming model for data - intensive tasks , and has been shown to achieve extreme scalability .",
    "we focus on yahoo s popular open - source mapreduce implementation called hadoop ( hadoop 2007 ) .",
    "the advantage of using hadoop is that it can be deployed on local commodity hardware but is also available via cloud resource providers ( an example of the _ platform as a service _ cloud computing archetype , or _ paas _ ) .",
    "consequently , one can seamlessly transition one s application between small- and large - scale parallelization and from running locally to running in the computational cloud .",
    "this paper discusses image coaddition in the cloud using hadoop from the perspective of the _ sloan digital sky survey _ ( sdss ) with foreseeable applications to next generation sky surveys such as the _ large synoptic survey telescope _ ( lsst ) .    in section [ secbackgroundwork ]",
    ", we present background and existing applications related to the work presented in this paper . in section [ secmapreduce ] , we describe cloud computing , mapreduce , and hadoop . in section [ secimplementingimagecoadditionmapreduce ] ,",
    "we describe how we adapted image coaddition to the mapreduce framework and present experimental results of various optimization techniques .",
    "finally , in sections [ secconclusions ] and [ secfuturework ] , we discuss final conclusions of this paper and describe the directions in which we intend to advance this work in the future .",
    "image coaddition is a well - established process .",
    "consequently , many variants have been implemented in the past .",
    "examples include _ swarp _",
    "@xcite , the sdss coadds of stripe 82 @xcite , and _ montage _ @xcite which runs on _ teragrid _ @xcite .",
    "swarp does support parallel coaddition ; it is primarily intended for use on desktop computing environments and its parallelism is therefore in the form of multi - threaded processing .",
    "parallel processing on a far more massive scale is required for existing and future datasets .",
    "fermilab produced a coadded dataset from the sdss database ( the same database we processed in this research ) , but that project is now complete and does not necessarily represent a general - purpose tool that can be extended and reused .",
    "montage most closely related to our work but there are notable differences .",
    "montage is implemented using mpi ( message passing interface ) , the standard library for message - passing parallelization on distributed - memory platforms .",
    "mapreduce is a higher - level approach that offers potential savings in development time provided one s application can be projected well onto the mapreduce paradigm .",
    "hadoop in particular ( in congruence with google s original mapreduce implementation ) was also designed to achieve high scalability on cheap commodity hardware rather requiring parallel machines with high - performance network and storage .",
    "_ image coaddition _",
    "( often known simply as _ stacking _ ) is a method of image - processing wherein multiple overlapping images are combined into a single image ( see figs .",
    "[ imagecoaddition ] and [ stackingexample ] ) .",
    "the process is shown in algorithm [ algcoadd ] .",
    "first , a set of relevant images is selected from a larger database . to be selected",
    ", an image must be in a specified bandpass filter ( line 6 ) and must overlap a predefined bounding box ( line 9 ) .",
    "the images are projected to a common coordinate system ( line 10 ) , adjusted to a common point spread function ( psf ) ( line 10 ) , and finally stacked to produce a single consistent image ( line 18 ) .",
    "\\{@xmath0 : one set of images , @xmath1 : one query } \\{@xmath2 : a single stacked , mosaiced image , @xmath3 : @xmath4 per - pixel coverage map } @xmath5 empty @xmath6 @xmath1 filter @xmath7 @xmath1 bounds @xmath8 @xmath9 filter @xmath10 @xmath9 bounds @xmath11 intersection of @xmath12 and @xmath13 @xmath14 projection of @xmath9 to @xmath15 add @xmath16 to @xmath17 @xmath18 initialized image from @xmath1 @xmath19 initialized depth - map accumulate @xmath16 illumination into @xmath2 accumulate @xmath16 coverage into @xmath3      much of modern astronomy is conducted in the form of large sky surveys in which a specific telescope and camera pair are used to produce a consistent database of images .",
    "one recent and ongoing example is the _ sloan digital sky survey _ ( sdss )",
    "which has thus far produced seventy terabytes of data @xcite .",
    "the next generation survey is the _ large synoptic survey telescope _ ( lsst ) which will produce sixty petabytes of data over its ten year lifetime starting this decade .",
    "these datasets are large enough that they can not be processed on desktop computers .",
    "rather , large clusters of computers are required .    in this paper",
    "we consider the sdss database .",
    "the sdss camera has 30 ccds arranged in a 5x6 grid representing five bandpass filters and six abutting strips of sky ( see fig . [ sloancamera ] ) .",
    "images are captured by drift - scan such that the camera remains fixed during an integration session and the sky moves across the field of view .",
    "the ccd read - out rate is slowed down dramatically ( as compared to a typical rapid - capture ccd ) so as to shift pixel charge from one row of the ccd to the next in precisely side - real time . in this way , images are captured without trails yet without moving the telescope .",
    "the resulting integration time per point on the sky is consequently determined by the arc subtended by a ccd s length along the right ascension axis relative to the sky ( 54.1s ) .",
    "we ran our experiments on a hadoop - configured cluster .",
    "this cluster is funded by the nsf _ cluster exploratory _ grant ( clue ) and is maintained by google and ibm . at the time of this research , the cluster consisted of approximately 400 quad - core nodes ( more nodes were added later ) , each node divided evenly between mapper and reducer slots ( described in section [ secmapreduce ] ) .",
    "thus , there were approximately 800 mapper and reducer slots each .",
    "it should be noted that other people working on unrelated projects also have access to this cluster for research purposes and due to the unpredictability of their usage at any given time , the cluster s load could vary dramatically .",
    "this situation introduced wide variances into our timing experiments .    ]    for our experiments we used the stripe 82 dataset from the sdss - i ( 2000 - 2005)and sdss - ii ( 2005 - 2008 ) surveys .",
    "since this dataset was captured near the equatorial plane ( @xmath20 declination ) , the images world coordinate system mappings are minimally distorted relative to images captured at higher and lower declinations .",
    "stripe 82 spans right ascension between @xmath21 and @xmath22 ( stripe 82 only operated in the fall ) and has a coverage of about 75 visits ( see fig .",
    "[ sdssstripe82racoverage ] ) .",
    "stripe 82 contains about 1,000,000 images in about twenty terabytes . from this database",
    "we defined a three degree long window in right ascension in the most deeply covered region ( @xmath23 to @xmath24 , see fig .",
    "[ sdssstripe82racoverage ] ) and produced the corresponding subset for our experiments , approximately 100,000 images comprising 250gbs of gzip - compressed data ( about 600gbs uncompressed ) .",
    "using a subset permits us to perform our experiments much more rapidly .",
    "note that the subset maintains the full depth of the original dataset by being confined to all images within a given spatial bounds .",
    "a more naive method of generating a subset , perhaps by randomly selecting a fraction of the original dataset , would have yielded shallower coadds and any experiments would therefore have offered weaker insight into how the system s performance might scale up to the full dataset .",
    "we ran the hadoop coadd system described in this paper on two different queries : one representing a lower - bound on the query sky - bounds we expect to be requested when conducting actual research ( approximately @xmath25 square ) and the other representing the corresponding upper - bound ( approximately @xmath26 square ) .",
    "thus , the two resulting running times demonstrate expected best and worst performance under real - world conditions .",
    "in addition to the two queries that represent our primary experiments , we also briefly considered other queries of identical size but at different locations within the subset s sky - bounds in order to determine the degree to which performance might depend on the specific query .",
    "most notably the larger query might cover either three or four sdss strips ( camera columns ) depending on its precise position along the declination axis .",
    "such a difference could conceivably have an effect on the performance of the system since it affects the degree to which our prefiltering mechanism ( see section [ subsubsecprefiltering ] ) can eliminate sdss strips ( a filter pass of @xmath27 strips in one case and @xmath28 strips in the other ) , thereby imposing a subsequent variation in the number of false positives which must be considered by mapreduce .",
    "furthermore , due to the general variability of the database , two queries of identical size but located in different locations will almost certainly have some variation in their overall coverage , _",
    "i.e. _ , in the number of fits images that ultimately contribute to the coadd",
    ". the results of these experiments have suggested that variation in performance resulting from the factors described here is minimal .",
    "the final running time of the overall hadoop job is virtually unaffected by the choice of query location .",
    "without loss of generality , we will therefore dispense with any consideration of such variation for the remainder of the paper .",
    "_ mapreduce _ is a programming model and an associated implementation for parallel data processing @xcite . _",
    "@xcite is the open - source implementation of mapreduce .",
    "mapreduce has a few primary motivations underlying its design .",
    "first , the overarching goal is to achieve _ data locality _ , _ i.e. _ , to move the computation to the data rather than move the data to the computation .",
    "specifically , hadoop attempts to dispatch each task in the distributed computation to the node that holds the data to process .. another goal of the mapreduce design is to present a simplified framework for describing a data - processing pipeline such that most general applications can be described within that framework .",
    "finally , mapreduce is designed to scale to clusters with thousands of machines . at this scale , failures are the norm rather than the exception .",
    "it thus includes machinery to hide compute - node failures from the user program by managing multiple replicas of all data blocks , automatically restarting tasks that fail , and optionally starting multiple redundant tasks to reduce restart overhead when failures occur .",
    "mapreduce consists of two sequential stages in which units of computation called _ mappers _ and _ reducers _ process the initial and an intermediate representation of the input data respectively . while these two stages occur sequentially ( mappers first ) , data - processing can be highly parallel _ within _ each of these two stages . in the _ map _ stage ,",
    "a large input dataset is broken into smaller pieces and distributed to numerous independent mapper objects .",
    "each map processes its input data , in effect performing a transformation of that data to an intermediate representation .",
    "following the map stage , the full set of intermediate map outputs is further distributed to the _ reduce _ stage .",
    "this distribution process is basically a massive distributed sort of the mapper outputs , followed by assignment of the outputs to the reducers for subsequent processing .",
    "following the mapper and intermediate shuffle stages , the reducers perform a second transformation , the output of which is the output of the entire mapreduce process .",
    "mapreduce may be followed by a final merge stage which groups the numerous reducer outputs into a single result , but this last step is generally a simple concatenation and is therefore not considered an integral step in the overall mapreduce process . while mapreduce can be performed in more complex ways such as running multiple sequential map stages before the final reduce stage ( each map stage s outputs feeding the inputs of the next map stage ) , in this paper we concentrate on the simpler case of a single map stage followed by a single reduce stage .",
    "the implementation of mapreduce used in this paper is hadoop .",
    "hadoop is implemented in java and , in addition to the general mapreduce framework , incorporates the necessary additional components to build a full mapreduce system , _",
    "i.e. _ , a distributed file system ( hdfs ) , a job scheduler , etc .",
    "to adapt a general algorithm to mapreduce we must define two functions , the _ mapper _ and the _ reducer_. we have adapted image coaddition to mapreduce in the most direct manner possible ( see algorithms [ algmap ] and [ algreduce ] ) .",
    "this straightforward implementation suffices to demonstrate the key benefits for the mapreduce framework as a building block for astronomy image - processing pipelines .",
    "fig [ imagecoadditioninmapreduce ] illustrates the overall process .",
    "each call to the map function processes a single input image .",
    "the image is checked against the query parameters for inclusion in the coadd .",
    "if it passes this test ( overlap of the query bounds and designation as the correct bandpass filter ) it is then projected to the coadd s coordinate system and the projected bitmap is passed to the reducer . after all images have been excluded or projected , the reducer then accumulates all of the projected bitmaps into a final coadded image .",
    "\\{*init * : @xmath1 : one query , * key * : unused , * value * : @xmath9 : one image } \\{*key * : @xmath1 , * value * : @xmath16 : a single image projected to @xmath29 bounds } @xmath8 @xmath9 filter @xmath10 @xmath9 bounds @xmath6 @xmath1 filter @xmath7 @xmath1 bounds @xmath11 intersection of @xmath12 and @xmath13 @xmath14 projection of @xmath9 to @xmath15    \\{*key * : @xmath1 , * value * : @xmath17 : a set of images projected to @xmath29 bounds } \\{*key * : unused , * value * : unused } @xmath2 : a single stacked , mosaiced image @xmath3 : a coverage map corresponding to @xmath2 @xmath18 initialized image from @xmath1 @xmath19 initialized depth - map accumulate @xmath16 illumination into @xmath2 accumulate @xmath16 coverage into @xmath3 write @xmath2 and @xmath3 to fits files    algorithm [ algreduce ] shows that we use a single reducer to perform the summation of the projected intersection bitmaps for a given query , _",
    "i.e. _ , while mappers are parallel over input images , reducers are parallel over queries .",
    "the overall process can readily be extended to process multiple queries at once .",
    "in such cases , the mapper considers the input image against each query and produces a projected bitmap for each query .",
    "the bitmaps are then sent to distinct reducers , each of which performs the summation for a particular query .",
    "note that the projection and interpolation of the input images into the coadd s coordinate system dominates the computational cost , _",
    "i.e. _ , the summation step of the stacking process in the reducer is a comparatively simple operation .",
    "furthermore , in our future work we intend to significantly increase the complexity of the mapper operation through the incorporation of more sophisticated coordinate - system projection ( warping ) and psf - matching algorithms whereas the reducer s task of pixel summation will remain relatively unaffected .",
    "therefore , the reducer s serial nature does not hinder the overall running time .",
    "finally , it should be noted that while the reducer acts in serial on a per query basis , it can act in parallel across queries if a single job processes multiple queries against the overall dataset ( see fig . [ imagecoadditioninmapreduce ] ) . while the output of the reducer is formally a key / value pair our system does not emit the final coadd through this mechanism .",
    "rather , the coadd is written directly to disk as a side effect of the mapreduce process .",
    "the naive method described in this section summarizes the most straightforward adaptation of image coaddition to mapreduce .",
    "however , it suffers from two inefficiencies .",
    "first , the naive method processes every image once every execution .",
    "second , finding the location of millions of small individual files during processing dominates the runtime . in the next section , we address these problems and describe optimizations to solve them .        of the 100,000 fits files in our experimental dataset , only a small number will ultimately contribute to any one query s coadd . if we can exclude some of the irrelevant files from consideration before running mapreduce we may improve the overall job s performance .",
    "therefore , one of the most straightforward ways to improve efficiency is to filter the input and not process the entire dataset .",
    "filtering can be accomplished by considering the dataset s directory structure and file name convention and subsequently building a partially exclusive _ glob _ pattern ( similar to a regular expression ) when specifying the input file set for mapreduce .",
    "our prefilter works in two ways .",
    "[ sloancamera ] shows a schematic of the sdss camera which contains an array of 30 independent ccds .",
    "these 30 ccds are divided into five rows corresponding to five filters and six columns corresponding to six parallel nonoverlapping strips of the sky . in the stripe",
    "82 dataset , these six strips correspond to parallel strips in declination .",
    "any individual fits file in the dataset corresponds to an image captured by one of these 30 ccds .",
    "since a query explicitly indicates a coadd of a specified bandpass , we can immediately reduce our input dataset by a factor of five by eliminating from consideration those fits files captured in one of the four other bandpass filters .",
    "furthermore , the dataset is structured in such a way that is relatively straightforward to filter by ccd column , _",
    "i.e. _ , by spatial location along the declination axis ( see fig . [ prefiltering ] ) .",
    "we perform this secondary filter by determining which of the six columns the query s sky - bounds overlap . for a very small query we might therefore achieve a further six - fold reduction in the input dataset , although for larger queries this reduction is usually on the order of 1.5 at best ( elimination of two of the six total columns ) .",
    "the following diagram shows how the sdss stripe 82 database is organized . as an example , let us assume we wish to construct a filter which accepts strips 2 , 3 , and 4 , and bandpass g. one possible glob in the example shown is redundant and could be replaced with a *. ] would be _ /sdssdb_root/*/*/corr/[234]/fpc-*-[g][234]-*.fit_. the diagram below , of the directory hierarchy of the sdss database , illustrates how this glob pattern can be used to exclude the unnecessary files when building the input set for mapreduce .    1 .",
    "sdssdb_root * 5902 @xmath30 _ sdss stripe 82 run i d _ * * 40 @xmath30 _ rerun i d _ * * * corr @xmath30 _ constant directory name ( correlated images ) _ 1 .   1 @xmath30 _ strip ( camera column 1 - 6 ) _ * * * * fpc-005902-u1-0690.fit @xmath30 _ fits file _ * * * * fpc-005902-g1-0690.fit * * * * fpc-005902-u1-0691.fit * * * * fpc-005902-g1-0691.fit 2 .   2 * * * * fpc-005902-u2-0690.fit * * * * fpc-005902-g2-0690.fit * * * * fpc-005902-u2-0691.fit * * * * fpc-005902-g2-0691.fit 3 .   3 4 .   4 5 .   5 6 .   6    )",
    ", we can exclude those strips which do not overlap the query bounds .",
    "this figure shows the spatial layout of a set of fits files as produced by the camera , arranged into six long strips .",
    "since the query bounds ( inset rectangle ) only overlaps columns two , three , and four , we can exclude columns one , five and six ( indicated with x ) .",
    "however , the filter suffers from false positives ( indicated with fp ) .",
    "those images will be detected and discarded in the mappers.[prefiltering ] ]    we ran our experiments on two query sizes .",
    "table [ runningtimes ] ( second row ) and fig .",
    "[ plot2c ] ( first bar in each set ) show the results of our first round of experiments with the larger query s results in the left column of the table and left plot group .",
    "note that the spatial filter occurs on only one spatial axis , not two as would be required for a perfect filter . given a column that passes the prefilter ,",
    "all fits files in the dataset that were captured in that column will be considered by the mappers .",
    "this is unfortunate since many of those fits files will still not overlap the query bounds in right ascension .",
    "they will be detected via their empty intersections and be discarded by the mappers , but these false positives represent wasted effort .",
    "we discuss this inefficiency and methods for handling it in section [ subsubsecusingsql ] , but first we investigate where the prefiltered method focused its time .",
    "lrr raw fits input , not prefiltered & 315.0 & 194.0 + raw fits input , prefiltered & 42.0 & 25.9 + unstructured sequence file input & 9.2 & 4.2 + structured sequence file input , prefiltered & 4.0 & 2.7 + sql @xmath31 unstructured sequence file input & 7.8 & 3.5 + sql @xmath31 structured sequence file input & 4.1 & 2.2 +    fig .",
    "[ plot3fitsonly ] shows a breakdown of the prefiltered job s overall running time for the larger query into the salient stages .",
    "the last bar represents the total running time , 42 minutes , the same measurement indicated in the first bar of fig .",
    "[ plot2c ] . a call to _ main ( ) _",
    "involves a preliminary setup stage in the _ driver _",
    "followed by a single call _",
    "runjob ( ) _ which encapsulates the mapreduce process .",
    "thus , the bar in the fourth region is the sum of the bars in the first and third regions .",
    "likewise , the call to _ runjob ( ) _ runs the _ mapreduce _ process and has been further broken down into the components shown in the second region .",
    "thus , the bar in the third region is the sum of the bars in the second region .",
    "we observe that the dominating step of the overall process is _ construct file splits_. this indicates that the hadoop coadd process spent most of its time locating the fits files on hdfs and preparing them as input to the mappers .",
    "the cost associated with this step results from a set of serial remote procedure calls ( rpcs ) between the client and the cluster .",
    "the actual image - processing computations are represented only in the two shortest bars labeled _ mapper done _ and _ reducer done _ indicating that hadoop spent a small proportion of its total time on the the fundamental task .",
    "this observation suggests that there is substantial inefficiency in the associated method , namely in the rpcs involved .",
    "the next section describes one method for alleviating this problem .",
    "we never explicitly measured the performance without prefiltering but an estimate is easy to calculate . given that the running times with prefiltering for our two experimental query sizes were 26 and 42 minutes respectively and given that the running time was dominated by the serial rpc bottleneck and given that the prefilter reduced the number of input files by a factor of 7.5 ( about 13,000 files out of the 100,000 total passed the prefilter ) , we can estimate that without prefiltering , the process would have taken approximately 194 and 315 minutes respectively ( table [ runningtimes ] , first row ) .",
    "this estimate assumes a linear relationship between the number of files to be found on hdfs and the required time , which is justified given that the number of rpcs is constant per file and the amount of time required per rpc is constant .",
    "while hadoop is designed to process very large datasets , it performs better on a dataset of a given size if the total number of files is relatively small . in other words ,",
    "given two datasets of identical data with one dataset stored in a large number of small files and the other stored in a small number of large files , hadoop will generally perform better on the latter dataset . while there are multiple contributing factors to this variation in behavior ,",
    "one significant factor is the number of remote procedure calls ( rpcs ) required in order to initialize the mapreduce job , as illustrated in the previous section . for each file",
    "stored on hdfs , the client machine must perform multiple rpcs to the hdfs namenode to locate the file and notify the mapreduce initialization routines of its location .",
    "this stage of the job is performed in serial and suffers primarily from network latency .",
    "for example , in our experimental database we processed 100,000 files .",
    "each file had to be independently located on hdfs prior to running the mapreduce job and this location was performed serially over set of 100,000 files .",
    "consequently , this step alone could take nearly five hours on our setup . even in the prefiltered method described above",
    ", this step still took about 30 minutes ( see fig .",
    "[ plot3fitsonly ] ) .",
    "the above is a well - known limitation of the hadoop system @xcite and hadoop includes an api and a set of data structures specifically targeted at alleviating it .",
    "the relevant structure is a _ sequence file_. a sequence file contains an arbitrary number of key / value pairs where a key is used to indicate ( and locate ) a specific file and the value is the file in question . in this way , individual files can be retrieved from a sequence file in a random - access fashion . in effect , a sequence file is a concatenation of smaller files bundled with an index .",
    "we use sequence files by grouping many individual fits files into a single sequence file , indexed simply by the fits filename itself .",
    "thus , we can retrieve a specific fits file rapidly while simultaneously reducing the number of actual files on disk from the number of fits files to the number of resulting sequence files . as a first strategy , we randomly grouped fits files into sequence files ( thus producing _ unstructured _ sequence files ) , as illustrated in fig .",
    "[ sequencefiles ] ( top ) .",
    "table [ runningtimes ] and fig .",
    "[ plot2c ] show the results of using this approach in row three of the table and bar two of each plot group .",
    "as the results show , this approach improved upon the prefiltered method ( described above ) by a factor of five and theoretically improved upon the most naive approach by a factor of approximately 38 .",
    "it should be noted that we never implemented the most naive method and so have no running times for it .",
    "consequently , the prefiltered method as applied directly to the fits database should be taken as the baseline for performance comparisons .",
    "note that unstructured sequence files outperform prefiltering of the direct fits file dataset by a factor of five .",
    "table [ runningtimes ] and fig .",
    "[ plot2c ] illustrate this fact .",
    "what is interesting is that this five - fold improvement occurs _",
    "despite _ the fact that in the prefiltered case we actually reduced the input of 100,000 fits files down to about 13,000 files while in the sequence file case we could not perform any prefiltering . in the unstructured sequence file case , many more fits files were processed relative to the prefiltered fits file case . despite this inefficiency on part of the sequence file method",
    ", it still significantly outperforms the prefiltering method due to its vast reduction in the number of actual files on disk , _",
    "i.e. _ , the conversion of the input representation from a set of fits files to a set of sequence files .      fits files can be assigned to sequence files in any way the programmer chooses . in the previous section",
    ", we considered the worst case performance by using an unstructured sequence file database .",
    "the resulting sequence file database could not be pruned in any meaningful fashion at runtime , _",
    "e.g. _ , the prefiltering mechanism described in section [ subsubsecprefiltering ] , and therefore had to be fully read and processed during a mapreduce job . results of using such a sequence file database were presented in the previous section .    ) onto the sequence file database , _",
    "i.e. _ , there is one sequence file for each ccd on the camera .",
    "fits files are assigned accordingly and thus a given sequence file contains fits files of only one bandpass and from only one column of the camera.[sequencefiles ] ]    however , it is also worth considering a more rationally motivated sequence file structure since doing so might permit pruning , _",
    "i.e. _ , filtering as demonstrated above .",
    "we refer once again to fig .",
    "[ sloancamera ] which shows the sdss camera s ccd layout .",
    "this time , we use the sdss camera s ccd arrangement not to define a prefiltering method on fits files , but rather to impose a corresponding structure on the sequence file database .",
    "we define 30 distinct sequence file types , one corresponding to each ccd of the camera ( see figs .",
    "[ sloancamera ] and [ sequencefiles ] ) .",
    "thus , a given sequence file contains only fits files originating from one of the original 30 ccds .",
    "if the sequence files are named in a way which reflects the glob filter described previously , we can then filter entire sequence files in the same way that we previously prefiltered fits files .",
    "this method of filtering permits us to eliminate entire sequence files from consideration prior to mapreduce on the basis of bandpass or column coverage of the query .",
    "we anticipated a corresponding improvement in performance resulting from the reduction of wasted effort spent considering irrelevant fits files in the mappers .",
    "table [ runningtimes ] ( row four ) and fig .",
    "[ plot2c ] ( third bar in each set ) show the results of using structured sequence files and prefiltering in concert . we observe a further reduction in running time over unstructured sequence files by a factor of two on the larger query .",
    "the savings in computation relative to unstructured sequence files resulted from the elimination of much wasted effort in the mapper stage considering and discarding fits files either whose bandpass did not match the query or whose sky - bounds did not overlap the query bounds .",
    "both prefiltering methods suffer from false positives resulting from the fact that the spatial filter occurs on only one spatial axis .",
    "likewise , the non - prefiltered method performs no prefiltering at all .",
    "therefore , in all three methods , effort is still being wasted considering irrelevant fits files .",
    "the prefiltering methods processed 13,000 fits files in the mappers while the non - prefiltered method processed the entire dataset of 100,000 fits files .",
    "however , the number of fits files that actually contributed to the final coadd was only 3885 . in the next section",
    "we describe how we used a sql database and query prior to running mapreduce to eliminate this problem .",
    "all three methods described previously ( prefiltered fits files , unstructured sequence files , and prefiltered structured sequence files ) process irrelevant fits files in the mappers . toward the goal of alleviating this inefficiency",
    ", we devised a new method of prefiltering .",
    "this method consists of building a sql database of the fits files outside of hdfs and outside of hadoop in general .",
    "the actual image data is not stored in the sql database  only the bandpass filter and sky - bounds of each fits file are stored , along with the necessary hdfs file reference data necessary to locate the fits file within the sequence file database , _",
    "i.e. _ , its assigned sequence file and its offset within the sequence file . running a job using this method consists of first performing a sql query to retrieve the subset of fits files that are relevant to the user s query , and from the sql result constructing a set of hdfs _ _ file splits _ _ to specify the associated fits files within the sequence file database ( see fig .",
    "[ sqlcoadd ] ) .",
    "the full set of file splits then comprises the input to mapreduce .    )",
    ". please see the text for a comparison of how the performance is affected by this option.[sqlcoadd ] ]    the consequence of using sql to determine the relevant fits files and sending only those fits files to mapreduce is that this method does not suffer from false positives as described above .",
    "thus , the mappers waste no time considering ( and discarding ) irrevelant fits files since every fits file received by a mapper is guaranteed to contribute to the final coadd .",
    "the intention is clearly to reduce the mapper running time as a result .",
    "table [ numfitsprocessed ] shows the number of fits files read as input to mapreduce for each of the six experimental methods .",
    "note that prefiltering is imperfect , _ i.e. _ , it suffers from false positives and accepts fits files which are ultimately irrelevant to the coaddition task .",
    "however , the sql methods only process the relevant files .",
    "lrr raw fits input , not prefiltered & 100058 & 100058 + raw fits input , prefiltered & 13415 & 6714 + unstructured sequence file input & 100058 & 100058 + structured sequence file input , prefiltered & 13335 & 6674 + sql @xmath31 unstructured sequence file input & 3885 & 465 + sql @xmath31 structured sequence file input & 3885 & 465 +    fig .",
    "[ plot4 ] shows the results of the new method .",
    "we have removed the prefiltered fits method from the plot ( shown in fig .",
    "[ plot2c ] ) so that we may concentrate our attention on the faster methods , namely , the two sequence file methods previously described ( the first two bars shown in fig . [ plot4 ] ) , and two new methods , one each for performing sql against the unstructured sequence file database ( the third bar ) and for performing sql against the structured sequence file database ( the fourth bar ) .",
    "several patterns are observed in the plot .",
    "first , note that it is only meaningful to compare sql vs. nonsql for a given sequence file database , either structured or unstructured .",
    "thus , the appropriate comparisons to make are between bars one and three or between bars two and four .",
    "we observe that in such comparisons , the sql method does successfully outperform the nonsql method in most cases , but to a lower degree than we hoped for when we implemented it , _",
    "i.e. _ , bar three shows only a small improvement over bar one and bar four shows virtually no improvement over bar two .",
    "let us consider the results indicated by bars two and four for the larger query .",
    "the noteworthy observation is that while sql shows some benefit , that benefit is lower than originally anticipated given the 3.5x difference in mapper input records ( fits files ) , 13335 vs. 3885 .",
    "13335 is the number of fits files read in by the prefiltered sequence file method ( of which 3885 were relevant and the rest discarded ) while 3885 is the number of fits files read in by the sql method ( all of which were relevant ) .",
    "therefore , we can conclude that in this case the cost of considering and discarding numerous irrelevant fits files was negligible and likewise that the additional complexity imposed by supporting and using an external sql database offers no benefit .",
    "let us consider the results indicated by bars one and three for the larger query .",
    "again , we note little improvement in performance given the variance of the confidence intervals .",
    "this is surprising given the dramatic difference in mapper input records , a full 26 fold difference .",
    "the first bar represents non - prefiltered unstructured sequence files , thus 100,058 input records while the third bar represents a sql method , thus 3885 input records .",
    "the conclusion is similar in this case , that the cost of discarding irrelevant files is low .",
    "we might then ask : why is there a two - fold difference in performance between the two sql methods considering that they both processed exactly the same amount of data ? to answer this question we must investigate not merely the number of mapper input records but the number of _ mapper objects _ launched by hadoop . these two values are rarely equal because a mapper can be reused to process multiple input records . in the sql - unstructured - sequence - file method",
    ", the 3885 input fits files were processed by 1714 mapper objects ( about two fits files each ) while in the sql - structured - sequence - file method , 338 mapper objects were used ( about eleven fits files each ) .",
    "this discrepancy is due to the way we assign fits files to each mapper object . for each mapper object",
    ", we assign fits files in the same hdfs block . due to the replication of blocks across hdfs",
    ", copies of each block will be stored on multiple hosts .",
    "when possible , hadoop will schedule mapper objects to run on one of the hosts where that mapper s input blocks are located so that the files can be efficiently accessed from local disks .",
    "clearly , this approach generates a variable number of mapper objects depending on the structure of the input sequence file . in the case of unstructured sequence files ,",
    "the fits files relevant to a given query are scattered throughout the sequence file database whereas in the case of structured sequence files , the relevant fits files are more tightly packed .",
    "thus , greater data locality is achieved in the assignment of fits files to mappers in the structured case and fewer mapper objects are required . to complete our understanding of the difference in running times",
    "we must further consider the maximum number of mapper objects that the cluster can sustain simultaneously . since",
    "a mapper represents a conceptual unit of computation , it corresponds to  or directly relies upon  a processor core in order to operate .",
    "therefore , the number of simultaneously sustainable mapper objects for a hadoop job is limited by the number of cores available on the entire cluster . in our case , this value is about 800 .",
    "we can now see one fundamental problem with the unstructured case : not all of the 1714 mappers could run simultaneously ; some could not begin processing until after others had completed their own processing .",
    "this limitation was not true in the case of structured sequence files where only 338 slots were required and they could all run simultaneously .",
    "however , one might actually predict superior performance from the unstructured case for the simple fact that it benefits from 800x parallelism while the structured case only benefits from 338x parallelism .",
    "we theorize that the explanation for why such behavior was not observed lies in the nonnegligible startup cost of launching a mapper object , _",
    "i.e. _ , there is a genuine benefit in reusing mappers and there must be some tipping point in this tradeoff where the benefit of additional parallelism is outweighed by the cost of creating mappers for brief computational needs .",
    "this work presented our implementation and evaluation of image coaddition within the mapreduce data - processing framework using hadoop .",
    "we investigated five possible methods of implementation with the latter methods designed to improve upon the earlier methods .",
    "our first round of experiments processed a dataset containing 100,000 individual fits files . despite the use of a prefiltering mechanism to decrease the input size , this method yielded poor performance due to the job initialization costs . to decrease the initialization time we must process a dataset consisting of fewer actual files , but obviously without altering the underlying data .",
    "this goal is achieved through the use of sequence files which group individual files together .",
    "sequence files are offered through the hadoop api for precisely this purpose .",
    "our next round of experiments considered sequence files which were grouped in an unstructured manner and which therefore could not be prefiltered . despite this weakness",
    "relative to the first method , the use of unstructured sequence files still yielded a five - fold improvement in performance .",
    "we then ran experiments on sequence files which were grouped in ways that reflected the same prefiltering mechanism used earlier .",
    "the sequence files themselves could then be prefiltered .",
    "this method yielded another two - fold improvement in performance ( ten - fold over the original method ) .",
    "the first three methods described all suffered from an inefficiency whereby irrelevant fits files were considered and discarded in the mapper stage . toward the goal of alleviating this inefficiency we devised our fourth and fifth methods , which used a sql query prior to mapreduce to identify the relevant fits files .",
    "those fits files were then retrieved from the two previously described sequence file databases to run mapreduce . when applied to the unstructured sequence file database ,",
    "this sql method yielded minimal improvement in performance .",
    "the lack of structure of the sequence files prevented the efficient reuse of mapper objects .",
    "however , when the sql method was used in conjunction with the structured sequence file database , the mappers were reused more efficiently and good performance was achieved , although it should be noted that the sql method still did not significantly outperform the nonsql method in which bandpass filter and one - dimensional spatial prefiltering was used . in the case of the smaller query",
    "there was some advantage however .",
    "it should be noted that while sql showed little improvement over prefiltering in our current experiments , we anticipate that sql should show significant advantage on larger datasets .",
    "in such a case , prefiltering would be more adversely affected by the false - positive problem , _",
    "i.e. _ , more irrelevant fits files would pass the prefilter to be considered and discarded by the mappers .",
    "there ought to be a dataset size above which this wasted effort begins to show measurable degradation in performance . on the other hand",
    ", the sql method should show comparatively more gradual decrease in performance as the dataset grows since it only processes the relevant fits files to begin with .",
    "this prediction is admittedly speculative as we have not yet conducted the necessary experiment .",
    "the use of hadoop shows great promise for processing massive astronomical datasets . on a 400-node cluster",
    "we were able to process 100,000 files ( 300 million pixels ) in three minutes using two different methods , one with sql and one without .",
    "this is a marked improvement over other systems such as montage , which processes approximately 40 million pixels in 32 minutes @xcite .",
    "even if one considers only the fits files that were relevant to a query ( 3885 files , or 12 million pixels ) , when the three minute running time is scaled by ten to compare to montage s 32 minutes we get 120 million pixels , still a marked improvement over 40 million .",
    "our current work represents merely the early stages of our research into the use of hadoop for image coaddition .",
    "areas of future work include :    * conversion of the mapper and reducer code to c++ and incorporation of our existing c++ library of image - processing routines which are capable of performing much more sophisticated coaddition algorthms . * the addition of time - bounds to the query parameters so that coadds may be generated only within a specified window of time",
    ". this behavior will enable the investigation of time - variable phenomena such as variable stars and moving objects , _",
    "e.g. _ , asteroids . *",
    "the addition of subsequent pipeline stages to process the resulting coadds , such as the detection and tracking of moving and variable objects . * the development of new parallel machine - learning algorithms for anomaly detection and classification .    ultimately , we intend to develop our system into a full - fledged data - reduction pipeline for petabyte astronomical datasets as will be produced by next - generation sky surveys such as lsst .",
    "this work is funded by the nsf cluster exploratory ( clue ) grant ( iis-0844580 ) and nasa grant 08-aisr08 - 0081 .",
    "the clue cluster is funded through the clue grand and maintained by ibm and google .",
    "we thank them for their continued support .",
    "we further wish to thank both the lsst group in the astronomy department and the database research group in the computer science department at the university of washington .",
    "all members of both groups contributed greatly through feedback , suggestions and draft revisions .",
    "szalay , a. s. , connolly , a. j. and szokoly , g. p. simultaneous multicolor detection of faint galaxies in the hubble deep field . _ the astronomical journal _ , jan 1999 .",
    "dean , j. and ghemawat , s. mapreduce : simplified data processing on large clusters . in _",
    "osdi04 : sixth symposium on operating system design and implementation _ , dec 2004 .",
    "apache hadoop , open source mapreduce implementation , http://hadoop.apache.org/. section 1 , par 1 : topics within astronomy require data gathered at the limits of detection of telescopes .",
    "ref not found yet .",
    "bertin , e. et al .",
    "2002 : the terapix pipeline , asp conference series , vol . 281 , 2002 d.a .",
    "bohlender , d. durand , and t.h .",
    "handley , eds .",
    "bertin , e. , swarp , http://www.astromatic.net/software/swarp .",
    "sdss dr7 http://www.sdss.org/dr7/start/aboutdr7.html montage , http://montage.ipac.caltech.edu / docs/. berriman , b. and good , j. , building image mosaics with the montage image mosaic engine , greater ipac technology symposium , 2009 .",
    "teragrid , https://www.teragrid.org/. white , t. _ hadoop the definitive guide_. oreilly media inc .",
    "2009 , p. 103"
  ],
  "abstract_text": [
    "<S> in the coming decade , astronomical surveys of the sky will generate tens of terabytes of images and detect hundreds of millions of sources every night . </S>",
    "<S> the study of these sources will involve computation challenges such as anomaly detection and classification , and moving object tracking . </S>",
    "<S> since such studies benefit from the highest quality data , methods such as image coaddition , _ </S>",
    "<S> i.e. _ , astrometric registration , stacking , and mosaicing , will be a critical preprocessing step prior to scientific investigation . with a requirement that these images be analyzed on a nightly basis to identify moving sources such as potentially hazardous asteroids or transient objects such as supernovae , these data streams present many computational challenges . </S>",
    "<S> given the quantity of data involved , the computational load of these problems can only be addressed by distributing the workload over a large number of nodes . however , the high data throughput demanded by these applications may present scalability challenges for certain storage architectures . </S>",
    "<S> one scalable data - processing method that has emerged in recent years is mapreduce , and in this paper we focus on its popular open - source implementation called _ hadoop_. in the hadoop framework , the data is partitioned among storage attached directly to worker nodes , and the processing workload is scheduled in parallel on the nodes that contain the required input data . </S>",
    "<S> a further motivation for using hadoop is that it allows us to exploit cloud computing resources , _ </S>",
    "<S> i.e. _ , platforms where hadoop is offered as a service . </S>",
    "<S> we report on our experience implementing a scalable image - processing pipeline for the sdss imaging database using hadoop . </S>",
    "<S> this multi - terabyte imaging dataset provides a good testbed for algorithm development since its scope and structure approximate future surveys . </S>",
    "<S> first , we describe mapreduce and how we adapted image coaddition to the mapreduce framework . </S>",
    "<S> then we describe a number of optimizations to our basic approach and report experimental results comparing their performance . </S>"
  ]
}