{
  "article_text": [
    "convolutional neural networks ( cnns ) have been extensively used in different image and video processing applications @xcite . even though cnns have remarkable performance , they are computationally intensive",
    ". there have been different proposals for accelerating cnns using gpus ( @xcite ) , fpgas ( @xcite ) and asics . among these platforms , gpus are the main platform for accelerating convolutional neural network due to their high performance and ease of use .",
    "+ there are two classes of gpus : server - class and mobile - class .",
    "server - class gpus have more computational capabilities and consume a considerable amount of energy .",
    "these gpus are used in cloud - based computing for training cnns and processing computations which are offloaded to a cloud from mobile devices .",
    "accelerating cnns on server - class gpus is very well studied .",
    "nowadays , many applications rely on cloud computing to take advantage of machine learning techniques with cnns . however , cloud computing is not always the best solution for several reasons .",
    "first , using a wireless media for transferring data to a cloud requires a considerable amount of energy .",
    "second , sometimes it is not possible to offload computations to a cloud in locations with weak signal reception . finally , due to privacy concerns , using remote processing infrastructures is not always a solution .",
    "+ unlike server gpus , mobile gpus have limited hardware resources and they are designed to work within restricted power budgets . in this paper , we have used renderscript for accelerating cnns on mobile gpus .",
    "renderscript is a framework for utilizing heterogeneous computing on android phones . during execution",
    ", the runtime engine distributes the computation on available processing elements such as cpu cores and gpu .",
    "+ in this paper , we propose a solution for utilizing renderscript features to implement cnns efficiently on android devices .",
    "moreover , we will explain that the design parameters which yield the minimum execution time vary between different platforms and layers of a cnn .",
    "subsequently , we implement and optimize squeezenet @xcite on three different mobile devices and find the optimal design parameters for each . + the approach we propose in this paper can be used for accelerating any cnn efficiently .",
    "having an execution time of less than a quarter of a second and an energy consumption of half a joule , the proposed algorithm makes it feasible to locally use cnns on mobile devices .",
    "convolutional neural networks ( cnns ) have millions of parameters , which are obtained during a training procedure . in this work ,",
    "we focus on the acceleration of the forward path using mobile gpus .",
    "+ each cnn has multiple convolutional layers .",
    "each layer uses 3d kernels for feature extraction .",
    "the result of multiple feature extractions are added together to create output feature maps .",
    "the convolution operation for two filter banks that each of them has three kernels is shown in figure ( [ fig : conv ] ) .",
    "the number of input feature maps , output feature maps , and the output size are @xmath0 , @xmath1 , and @xmath2 , respectively .",
    "+ one kernel has dimension @xmath3 , and a layer has @xmath4 of these kernels .",
    "each pixel in an output feature map is the sum of a convolutions between inputs and the respective kernels . to generate adjacent pixels in an output feature map",
    ", the kernel bank is slid across the spacial dimension by stride @xmath5 .",
    "the convolution operation is shown in figure ( [ fig : conv_code ] ) .",
    "+ in this paper , we use squeezenet @xcite as a use case .",
    "squeezenet has four different types of layers : convolutional , pooling , softmax , and fire .",
    "the first three layers are commonly used in many cnn architectures .",
    "fire layers are unique to squeezenet and consist of three convolutional layers : one squeeze layer and two expand layers .",
    "more than 90% of the execution time in cnns is spent in convolutional layers .",
    "+ squeezenet has eight fire layers and two convolutional layers .",
    "the input to the very first layer is a 224 x 224 rgb image .",
    "convolutional and fire layers are used to extract features from the input image . the last layer is a classifier with a thousand output nodes , each of which is a prediction for the different image categories .",
    "a sequential implementation of the convolution operation is shown in figure ( [ fig : conv_code ] ) .",
    "loops # 2 to # 6 perform a 3d convolution ( both input and kernel are 3d data structures ) .",
    "loop # 1 , repeats the 3d convolution for different kernels in order to compute different layers of the output . recall that each layer of the output is the result of a 3d convolution of the input with a distinct filter bank . in figure ( [ fig : conv_code ] ) , s ( stride ) is the number of pixels that a kernal slides during each step of the convolution .",
    "+ the convolution operation takes a major part of the execution time in cnns . in this section",
    ", we propose an approach for accelerating the convolution using renderscript on mobile devices .",
    "@xmath6      , and @xmath7 are computed using equations ( [ eq : w ] ) , ( [ eq : h ] ) , and ( [ eq : m ] ) , respectively.,width=264 ]    output of each convolution layer is a 3d matrix which includes @xmath8 elements ( equation ( [ eq : numoutputelems ] ) ) . computing these elements is a perfectly parallel workload . in theory , it is possible to assign one thread per element and execute all these threads concurrently . to implement this in renderscript , it is required to define an allocation with dimensions matching the size of the output matrix .",
    "successively , for each element of that allocation , it is required to compute the result of a dot product between the corresponding window of the input and a specific kernel .",
    "this dot product is performed using the pseudo code shown in figure ( [ fig : code1 ] ) .",
    "notice that this code has to be executed for every element of the output allocation . in each allocation",
    ", every thread has an index @xmath9 .",
    "for the aforementioned output allocation @xmath10 $ ] . in each thread",
    ", index @xmath9 is used to determine values of @xmath11 , @xmath12 , and @xmath7 as it is shown in equations ( [ eq : w ] ) , ( [ eq : h ] ) , and ( [ eq : m ] ) respectively .",
    "the value of @xmath13 in each thread is unique .",
    "these parameters help a thread to work on a distinct part of inputs and generate a specific element in the output matrix .",
    "@xmath14 @xmath15 @xmath16          renderscript offers various vector math functions that interpret their input arguments as a representation of vectors .",
    "currently , the maximum supported length for these vectors is four .",
    "these built - in functions can be efficiently mapped on supported gpus .",
    "a prototype of the vectorized dot function is shown in figure ( [ fig : dot ] ) . in this case , inputs are two vectors , each of which includes four floating point numbers .",
    "the function performs a dot operation between the two vectors and returns the result as a floating point number .",
    "+ we use the vectorized dot function for further acceleration of the convolution . to do so",
    ", it is required to change the implementation offered in the pseudo code of figure ( [ fig : code1 ] ) .",
    "as previously discussed , this code computes the dot product between a certain window of the input and a kernel .",
    "this process is performed in parallel for all elements of the output allocation",
    ". however , the process itself is sequential ( three nested loops in figure ( [ fig : code1 ] ) ) . in the following subsections , we explain how to accelerate it using the vectorized dot function offered in renderscript .      by default , both input and convolution kernels are stored in either row or column major order .",
    "therefore , elements stored in the vicinity of each other are either the next element from the same row ( column ) or the first element of the next row ( column ) . if we represent each element using @xmath17 , then in a row major fashion , data is stored in the following format : + @xmath18 to utilize the vectorized dot product , we need to make small vectors with a length of four .",
    "hence , it is required to change the previous data representation to the one shown in equation ( [ eq : vectorized ] ) .",
    "a 3d representation of this transform is shown in figure ( [ fig : reshape ] ) .",
    "@xmath19          when the data is reordered , it is sufficient to read them as vectors with a length of four , perform a vectorized dot product , and accumulate the result .",
    "this is implemented in the pseudo code shown in figure ( [ fig : vectorized_code ] ) .",
    "the function reads four floating point numbers from the input vector .",
    "the function has two inputs , the first input is the pointer to the memory location from which elements should be read and the next input is the base address .",
    "+ using this function , we read four different values from four consecutive layers and process them at the same time . in each iteration of the outermost loop ,",
    "four different layers are processed .",
    "this reduces the total number of iterations by a factor of four when compared to the pseudo code in figure ( [ fig : code1 ] ) ) .    ) .",
    "function ` rsgetelement_float4 ` reads a vector from memory and ` dot ` performs a vectorized dot product.,width=264 ]          as we explained in section ( [ data reordering ] ) , in order to use vectorized operations , it is required to change the order of elements in the input and convolution kernels . changing the order in convolution kernels can be performed offline .",
    "they can be reordered once , reshaped , and rewritten in a new model file .",
    "however , reordering the input is complicated . in convolutional neural networks ,",
    "the output of each layer is the input to the next layer .",
    "therefore , it is required to reorder the output of the previous layer before each convolution . this process is time and energy consuming . in this section",
    ", we will explain how to generate the output in a vectorized form to avoid overheads of data reordering .",
    "+ as we explained in section ( [ sec : paracompute ] ) , each thread has a unique index @xmath9 .",
    "we offered equations ( [ eq : w ] ) , ( [ eq : h ] ) , and ( [ eq : m ] ) for computing @xmath11 , @xmath12 , and @xmath7 , respectively .",
    "these parameters determine the location of the output element that thread @xmath9 generates .",
    "therefore , in order to generate the output of the convolution in a reordered format , it is required to change these parameters .",
    "for example , the result of computations in the second thread ( @xmath20 ) is stored in the second location of the output memory . after reordering ,",
    "however , the second element of the output array should be @xmath21 .",
    "this is illustrated in figure ( [ fig : data_reshape2 ] ) .",
    "+ to create the output in the reordered format , it is required to generate indexes for stacks of four layers , instead of a single layer ( figure ( [ fig : data_reshape2 ] ) ) .",
    "hence , we start indexing the second row when we have indexed all first rows of all four layers . therefore , @xmath11 and @xmath12 can be computed using equations ( [ eq : w_new ] ) and ( [ eq : h_new ] ) , respectively . for computing the value of @xmath7 ( layer index ) ,",
    "it is required to see which stack and layer a particular output belongs to ( figures ( [ fig : reshape ] ) and figure ( [ fig : data_reshape2 ] ) ) .",
    "equation ( [ eq : m_new ] ) computes the value of @xmath7 .",
    "@xmath22 @xmath23 @xmath24    ) using zero overhead vectorization approach.,width=264 ]    using equations ( [ eq : w_new ] ) , ( [ eq : h_new ] ) , and ( [ eq : m_new ] ) , it is possible to generate the output in the reordered format . such an output can be directly used as the input to the next layer without additional processing overhead .",
    "the pseudo code in figure ( [ fig : fullvec ] ) shows the final implementation .          there is a trade - off between the number of threads and the amount of code that should be executed in each thread .",
    "decreasing the number of threads increases the amount of code per thread ( i.e. , each thread has to compute multiple elements of output instead of one ) . increasing the number of threads beyond some hardware limit",
    "will not improve the execution time since there is not sufficient resources for parallel execution of all of these threads .",
    "in addition , when a thread is responsible for generating more than one output value , it is possible to decrease memory access by data reusability .",
    "therefore , in this problem , defining the highest possible number of threads is not the optimal solution . in the experimental results we show that the shortest execution time does not belong to the finest thread granularity ( highest number of threads ) . + in order to find the optimal thread granularity , we have implemented convolution kernels with dynamic thread granularities . in this paper , we use the keyword ` conv_g ` for referring to them .",
    "where , ` g ` is the number of output elements that threads compute sequentially .",
    "for example , kernel ` conv_4 ` computes four elements sequentially . for smaller values of ` g ` thread granularity is finer ( larger number of threads that each of them has a smaller task ) . in figure ( [ fig : fullvec ] ) the value of ` g ` is 1 and figure ( [ fig : fullvecgra ] ) shows the implementation for ` g = 2 ` . when ` g ` is larger than one , the input values are loaded to thread memory once , but are used ` g ` times .",
    "moreover , when the value of ` g ` is larger than one , a thread has to compute the value of an element @xmath25 for more than one output layers .",
    "for example , when ` g = 2 ` , the same thread that computes the value of element @xmath25 in layer 0 , has to compute the value of element @xmath25 in layer @xmath26 .",
    "however , as we described , output layers are generated in the form of vectors of length four .",
    "therefore , when changing the thread granularity , it is important to make sure that @xmath26 is divisible by four .",
    "there are two types of pooling functions in squeezenet : max pooling and average pooling .",
    "as their names explain , the former finds the maximum and the latter computes the average of numbers in a given window .",
    "we have used vectorized function ` fmax ` and ` sum ` for renderscript based implementation of these functions .",
    "implementations are analogous to convolution layers .",
    "the execution time of the softmax function is negligible ; hence , a gpu based implementation of this function is not required .",
    "+ in this section we explained the approach used for renderscript based implementation of squeezenet . for simplicity",
    ", we skipped a considerable amount of details .",
    "for further study , please refer to the project repository available on our github page .",
    "[ tbl : optimalgra ]        [ tbl : platforms ]    we have used three different mobile devices for evaluating the proposed renderscript based parallel algorithm .",
    "the specifications of these phones are shown in table ( [ tbl : platforms ] ) .",
    "these phones are equipped with three major qualcomm snapdragon socs .",
    "+ in order to increase the precision , all experiments of this section have been repeated 10 times , the average is computed and reported . during the experiments the phone s background processes were stopped , placed in airplane mode , and fully - dimmed their screen brightness . in this section , we present the results of executing the proposed algorithm on these phones and perform some analysis .",
    "+ we have accelerated squeezenet@xcite using the proposed approach .",
    "squeezenet has two normal convolutional layers and nine fire layers .",
    "each fire layer has three convolutional layers : two squeeze layers and one expand layer .",
    "we use ` fn sqn ` and ` fn exn ` notations to refer to squeeze and expand layers , respectively .      as we explained in section (",
    "[ sec : optimizing thread granularity ] ) , for each convolutional layer in squeezenet , there is a finite set of valid values for ` g ` .",
    "the result of implementation of squeezenet for different values of this set is shown in figure ( [ fig : geffect ] ) . + as figure ( [ fig : geffect ] ) illustrates , having the finest thread granularity ( ` g = 1 ` ) is not the optimal solution for any layer . by increasing the value of ` g ` , data reusability increases , thereby reducing the execution time .",
    "however , after some threshold , any further increase of the value of ` g ` exacerbates the execution time .",
    "notice that implementations based on very large values of ` g ` do not use the available parallel resources efficiently .",
    "+ thread granularity plays an important role in determining the execution time . in table",
    "( [ tbl : granularity ] ) we show the execution time of squeezenet for three different smart phones",
    ". for all of these phones , using optimal thread granularity drastically decreases the execution time . even on modern platforms , such as galaxy s7 ,",
    "optimal thread granularity can yield a speedup of 2.52x compared to a pessimal thread granularity .",
    "+ finally , the optimal solution for thread granularity for some layers of squeezenet are shown in table ( [ tbl : optimalgra ] ) .",
    "for some layers , such as f2 ex1 , f3 ex1 , and f4 ex1 , the optimal solution is identical for different platforms .",
    "however , the optimal thread granularity varies based on the convolution layer specifications and the target hardware .",
    "[ tbl : finalresults ]    renderscript offers two modes for imprecise computing for applications that do not need a strict implementation of ieee 754 . these modes are called relaxed and imprecise floating point computation .",
    "the relaxed floating point mode enables flush to zero for denormalized numbers and round toward zero .",
    "the imprecise computing mode enables everything in the relaxed computing .",
    "in addition , in this mode operations resulting in -0.0 can return + 0.0 and operations on inf and nan are undefined .",
    "+ using imprecise computing accelerates the execution time since some optimizations are only available for computation with relax / imprecise precisions .",
    "notice that relaxed and imprecise are gpu modes and using these modes does not have any effect on the cpu side .",
    "+ we have implemented squeezenet with both relaxed and imprecise precisions .",
    "subsequently , we have tested the implementation on the first 10000 samples of ilsvrc 2012 validation dataset @xcite .",
    "for all these samples , the prediction results are identical to the original predictions of squeezenet .",
    "therefore , using either of these modes does not change the classification accuracy .",
    "+ table ( [ tbl : finalresults ] ) includes the execution time of different convolutional layers of squeezenet .",
    "execution time was measured on three different phones . for each platform , the first row shows execution times for sequential execution .",
    "second row includes times for parallel execution , and the third row shows execution times for imprecise parallel implementation .",
    "the units of all execution times is in milliseconds",
    ". + table ( [ tbl : speedup ] ) shows total execution time ( all layers including pooling and softmax ) of sequential and parallel implementation of squeezenet . in precise computing mode , processing each image takes between 388.36 ( ms ) on nexus 6p to 588.29 ( ms ) on nexus 5 . as table ( [ tbl :",
    "speedup ] ) shows , the parallel algorithm is drastically faster than the sequential implementation of squeezenet on each platform . in precise processing mode ,",
    "the proposed parallel algorithm is at least 28.24x ( galaxy s7 ) and at most 74.68x ( nexus 5 ) faster than the sequential equivalent .",
    "+ as we explained , using imprecise computing does not have any impact on the accuracy of squeezenet . however",
    ", using imprecise computing decreases the execution time drastically by using simd optimization of gpus . on galaxy s7 ,",
    "the imprecise parallel algorithm is 2.11x faster than the precise parallel implementation . on nexus 5 and nexus 6p ,",
    "imprecise parallel algorithms are 4.16x and 3x faster than precise parallel implementation , respectively .",
    "using imprecise computing , the total execution time of squeezenet varies between 129.21 millisecond ( nexus 6p ) to 207.1 millisecond ( galaxy s7 ) .",
    "the speedup of imprecise implementation of proposed parallel algorithm is 59.54x ( galaxy s7 ) , 133.89x ( nexus 6p ) , and 310.74x ( nexus 5 ) compared to the basic sequential implementation .",
    "+ speedup factors which are shown in table ( [ tbl : speedup ] ) demonstrate that efficient use of mobile gpus can decrease the execution time of neural networks drastically and make it possible to locally utilize cnns on mobile devices .",
    "[ tbl : speedup ]      trepn profiler is an application made by qualcomm for performance monitoring of applications on mobile devices .",
    "trepn especially performs well on mobile devices with snapdragon processors .",
    "we have used android intents to call trepn for automated performance monitoring of parallel and sequential implementation of squeezenet . in all experiments ,",
    "mobile devices have been in the airplane mode and screen brightness is set to minimum .",
    "moreover , in all experiments background processes of different applications have been stopped .",
    "+ table ( [ tbl : power ] ) shows the result of performance monitoring using trepn profiler .",
    "baseline indicates the power consumption of the system in the idle state .",
    "for example , for nexus 6p the base power consumption is 1480.97 milliwatts .",
    "differential power shows the required power for running an algorithm . on galaxy s7 and nexus 6p the required power for parallel algorithm is more than a sequential algorithm , since the parallel implementation requires more active cores simultaneously .",
    "however , in nexus 5 , the required power in parallel is less than sequential .",
    "there are two reasons for this low power consumption .",
    "first , maximum clock frequency of the gpu in nexus 5 is 200 mhz less than the two other platforms .",
    "second , nexus 5 is equipped with an older snapdragon chipset which has a lower performance . for a task such as running squeezenet the difference in performance is not considerable .",
    "however , in applications with intense process requirement such as games , the two other platforms outperform nexus 5 .",
    "+ the main performance indicator is energy consumption .",
    "sequential algorithms might have a better power consumption , but since the execution time is longer than parallel algorithms , the total energy consumption is much larger . in the third column of table ( [ tbl : power ] ) total energy consumptions for both sequential and parallel algorithms are computed . using the parallel algorithm ,",
    "the required energy for processing a single image on different platforms varies between 0.106 to 0.569 joules .",
    "in this paper we proposed a solution for accelerating cnns on mobile gpus . using this approach",
    "we have accelerated squeezenet and ran it on three different mobile devices with different chipsets .",
    "experimental results on different platforms show that the proposed algorithm achieves a speedup of at least 59.54x and at most 310.74x .",
    "in addition , the energy consumption of the proposed parallel algorithm is at least 29.88x and at most 249.47x less than the energy consumption of the sequential algorithm . offering an execution time of less than a quarter of a second and around half a joule energy consumption ,",
    "the proposed algorithm makes it feasible to use cnns on mobile devices .",
    "the authors would like to thank nvidia corporation for donating gpus which were used in this research ."
  ],
  "abstract_text": [
    "<S> convolutional neural networks ( cnns ) exhibit remarkable performance in various machine learning tasks . as sensor - equipped internet of things ( iot ) devices permeate into every aspect of modern life , it is increasingly important to run cnn inference , a computationally intensive application , on resource constrained devices . </S>",
    "<S> we present a technique for fast and energy - efficient cnn inference on mobile soc platforms , which are projected to be a major player in the iot space . we propose techniques for efficient parallelization of cnn inference targeting mobile gpus , and explore the underlying tradeoffs . </S>",
    "<S> experiments with running squeezenet on three different mobile devices confirm the effectiveness of our approach . for further study </S>",
    "<S> , please refer to the project repository available on our github page : https://github.com/mtmd/mobile_convnet . </S>"
  ]
}