{
  "article_text": [
    "while network virtualization enables a flexible resource sharing , opening the infrastructure for automated virtual network ( vnet ) embeddings or service deployments may introduce new kinds of security threats .",
    "for example , by virtualizing its network infrastructure ( e.g. , the links in the aggregation or backbone network , or the computational or storage resources at the points - of - presence ) , an internet service provider ( isp ) may lose control over how its network is used .",
    "even if the isp manages the allocation and migration of vnet slices and services itself and only provides a very rudimentary interface to interact with customers ( e.g. , service or content providers ) , an attacker may infer information about the network topology ( and state ) by generating vnet requests .",
    "this paper builds upon the model introduced in  @xcite and studies complexity of the _ topology extraction problem _ : how many vnet requests are required to infer the full topology of the infrastructure network ? while algorithms for trees and cactus graphs with request complexity @xmath0 and a lower bound for general graphs of @xmath1 have been shown in  @xcite , graph classes between these extremes have not been studied .    *",
    "* this paper presents a general framework to solve the topology extraction problem .",
    "we first describe necessary and sufficient conditions which facilitate the `` greedy '' exploration of the substrate topology ( the _ host graph _",
    "@xmath2 ) by iteratively extending the requested vnet graph ( the _ guest graph _",
    "@xmath3 ) .",
    "our framework then exploits these conditions to construct an ordered ( request ) _ dictionary _ defined over so - called _ graph motifs_. we show how to apply the framework to different graph families , discuss the implications on the request complexity , and also report on a small simulation study on realistic topologies .",
    "these empirical results show that many scenarios can indeed be captured with a small dictionary , and small motifs are sufficient to infer if not the entire , then at least a significant fraction of the topology .",
    "this section presents our model and discusses how it compares to related work .    * model . *",
    "the vnet embedding based topology extraction problem has been introduced in  @xcite .",
    "the formal setting consists of two entities : a _ customer _ ( the `` adversary '' ) that issues virtual network ( vnet ) requests and a _ provider _ that performs the access control and the embedding of vnets .",
    "we model the virtual network requests as simple , undirected graphs @xmath4 ( the _ guest graph _ ) where @xmath5 denotes the virtual nodes and @xmath6 denotes the virtual edges connecting nodes in @xmath5 .",
    "similarly , the infrastructure network is given as an undirected graph @xmath7 ( the so - called _ host graph _ or _ substrate _ ) as well , where @xmath5 denotes the set of substrate nodes , @xmath6 is the set of substrate links , and @xmath8 is a capacity function describing the available resources on a given node or edge . without loss of generality , we assume that @xmath2 is connected and that there are no parallel edges or self - loops neither in vnet requests nor in the substrate .    in this paper",
    "we assume that besides the resource demands , the vnet requests do not impose any mapping restrictions , i.e. , a virtual node can be mapped to _ any _ substrate node , and we assume that a virtual link connecting two substrate nodes can be mapped to an entire ( but single ) _ path _ on the substrate as long as the demanded capacity is available .",
    "these assumptions are typical for virtual networks  @xcite .",
    "a virtual link which is mapped to more than one substrate link however can entail certain costs at the _ relay nodes _ , the substrate nodes which do not constitute endpoints of the virtual link and merely serve for forwarding .",
    "we model these costs with a parameter @xmath9 ( per link ) .",
    "moreover , we also allow multiple virtual nodes to be mapped to the same substrate node if the node capacity allows it ; we assume that if two virtual nodes are mapped to the same substrate node , the cost of a virtual link between them is zero .",
    "[ def : embedding ] an _ embedding _ of a graph @xmath10 to a graph @xmath11 is a mapping @xmath12 where every node of @xmath13 is mapped to exactly one node of @xmath14 , and every edge of @xmath13 is mapped to a path of @xmath14 .",
    "that is , @xmath15 consists of a node @xmath16 and an edge mapping @xmath17 , where @xmath18 denotes the set of paths .",
    "we will refer to the set of virtual nodes embedded on a node @xmath19 by @xmath20 ; similarly , @xmath21 describes the set of virtual links passing through @xmath22 and @xmath23 describes the virtual links passing through @xmath19 with @xmath24 serving as a relay node .",
    "to be valid , the embedding @xmath15 has to fulfill the following properties : ( @xmath25 ) each node @xmath26 is mapped to exactly one node @xmath19 ( but given sufficient capacities , @xmath24 can host multiple nodes from @xmath27 ) .",
    "( @xmath28 ) links are mapped consistently , i.e. , for two nodes",
    "@xmath29 , if @xmath30 then @xmath31 is mapped to a single ( possibly empty and undirected ) path in @xmath14 connecting nodes @xmath32 and @xmath33",
    ". a link @xmath31 can not be split into multiple paths .",
    "( @xmath34 ) the capacities of substrate nodes are not exceeded : @xmath35 : @xmath36 .",
    "( @xmath37 ) the capacities in @xmath38 are respected as well , i.e. , @xmath39 : @xmath40 .",
    "if there exists such a valid embedding mapping @xmath15 , we say that graph @xmath13 can be embedded in @xmath14 , denoted by @xmath41 .",
    "hence , @xmath42 denotes the vnet _",
    "embedding relation_.    the provider has a flexible choice where to embed a vnet as long as a valid mapping is chosen .",
    "in order to design topology discovery algorithms , we exploit the following property of the embedding relation .",
    "[ lemma : poset ] the embedding relation @xmath42 applied to any family @xmath43 of undirected graphs ( short : @xmath44 ) , forms a partially ordered set ( a _ poset _ ) . [ proof in appendix ]    we are interested in algorithms that `` guess '' the target topology @xmath2 ( the host graph ) among the set @xmath45 of possible substrate topologies . concretely , we assume that given a vnet request @xmath3 ( a guest graph ) , the substrate provider always responds with _ an honest ( binary ) reply _ @xmath46 informing the customer whether the requested vnet @xmath3 is embeddedable on the substrate @xmath2 . based on this reply , the attacker may then decide to ask the provider to embed the corresponding vnet @xmath3 on @xmath2 , or it may not embed it and continue asking for other vnets .",
    "let @xmath47 be an algorithm asking a series of requests @xmath48 to reveal @xmath2 .",
    "the _ request complexity _ to infer the topology is measured in the number of requests @xmath49 ( in the worst case ) until @xmath47 issues a request @xmath50 which is isomorphic to @xmath2 and _ terminates _",
    "( i.e. , @xmath47 knows that @xmath51 and does not issue further requests ) .",
    "+ * related work .",
    "* embedding vnets is an intensively studied problem and there exists a large body of literature ( e.g. ,  @xcite ) , also on distributed computing approaches  @xcite and online algorithms  @xcite .",
    "our work is orthogonal to this line of literature in the sense that we assume that an ( arbitrary and not necessarily resource - optimal ) embedding algorithm is _",
    "given_. instead , we focus on the question of how the feedback obtained through these algorithms can be exploited , and we study the implications on the information which can be obtained about a provider s infrastructure .",
    "our work studies a new kind of topology inference problem .",
    "traditionally , much graph discovery research has been conducted in the context of today s complex networks such as the internet which have fascinated scientists for many years , and there exists a wealth of results on the topic . the classic instrument to discover internet topologies is _ traceroute _",
    "@xcite , but the tool has several problems which makes the problem challenging .",
    "one complication of traceroute stems from the fact that routers may appear as stars ( i.e. , anonymous nodes ) , which renders the accurate characterization of internet topologies difficult  @xcite .",
    "_ network tomography _ is another important field of topology discovery . in network tomography",
    ", topologies are explored using pairwise end - to - end measurements , without the cooperation of nodes along these paths .",
    "this approach is quite flexible and applicable in various contexts , e.g. , in social networks .",
    "for a good discussion of this approach as well as results for a routing model along shortest and second shortest paths see  @xcite . for example",
    ",  @xcite shows that for sparse random graphs , a relatively small number of cooperating participants is sufficient to discover a network fairly well .",
    "both the traceroute and the network tomography problems differ from our virtual network topology discovery problem in that the exploration there is inherently _ path - based _ while we can ask for entire virtual graphs .",
    "the paper closest to ours is  @xcite .",
    "it introduces the topology extraction model studied in this paper , and presents an asymptotically optimal algorithm for the cactus graph family ( request complexity @xmath52 ) , as well as a general algorithm ( based on spanning trees ) with request complexity @xmath53 .",
    "the algorithms for tree and cactus graphs presented in  @xcite can be extended to a framework for the discovery of more general graph classes .",
    "it is based on the idea of growing sequences of subgraphs from nodes discovered so far .",
    "intuitively , in order to describe the `` knitting '' of a given part of a graph , it is often sufficient to use a small set of graph _ motifs _ , without specifying all the details of how many substrate nodes are required to realize the motif .",
    "we start this section with the introduction of motifs and their composition and expansion",
    ". then we present the dictionary concept , which structures motif sequences in a way that enables the efficient host graph discovery with algorithm  @xmath54 .",
    "subsequently , we give some examples and finally provide the formal analysis of the request complexity .      in order to define the motif set of a graph family @xmath45",
    ", we need the concept of _ chain ( graph ) @xmath55 _ : @xmath55 is just a graph @xmath56 consisting of two nodes and a single link .",
    "as its edge represents a virtual link that may be embedded along entire path in the substrate network , it is called a _",
    "chain_.    given a graph family @xmath45 , the set of motifs of @xmath45 is defined constructively : if any member of @xmath57 has an edge cut of size one , the _ chain @xmath55 _ is a motif for @xmath45 .",
    "all remaining motifs are at least 2-connected ( i.e. , any pair of nodes in a motif is connected by at least two vertex - disjoint paths ) .",
    "these motifs can be derived by the at least 2-connected components of any @xmath57 by repeatedly removing all nodes with degree smaller or equal than two from @xmath2 ( such nodes do not contribute to the knitting ) and merging the incident edges , as long as all remaining cycles do not contain parallel edges .",
    "only one instance of isomorphic motifs is kept .",
    "note that the set of motifs of @xmath45 can also be computed by iteratively by removing all low - degree nodes and subsequently determine the graphs connecting nodes constituting a vertex - cut of size one for each member @xmath58 .",
    "in other words , the motif set @xmath59 of a graph family @xmath45 is a set of non - isomorphic minimal ( in terms of number of nodes ) graphs that are required to construct each member @xmath57 by taking a motif and either replacing edges with two edges connected by a node or gluing together components several times .",
    "more formally , a graph family containing all elements of @xmath45 can be constructed by applying the following rules repeatedly .",
    "[ def : motif_rules ] ( 1 ) create a new graph consisting of a motif @xmath60 ( _ new motif rule _ ) . ( 2 ) given a graph created by these rules , replace an edge @xmath61 of @xmath2 by a new node and two new edges connecting the incident nodes of @xmath61 to the new node ( _ insert node rule _ ) .",
    "( 3 ) given two graphs created by these rules , attach them to each other such that they share exactly one node ( _ merge rule _ ) .",
    "being the inverse operations of the ones to determine the motif set , these rules are sufficient to compose all graphs in @xmath45 : if @xmath59 includes all motifs of @xmath45 , it also includes all 2-connected components of @xmath2 , according to definition  [ def : motif - app ] .",
    "these motifs can be glued together using the _ merge rule _ , and eventually the low - degree nodes can be added using the _ insert node rule_. therefore , we have the following lemma .",
    "[ lemma : equiv ] given the motifs @xmath59 of a graph family @xmath45 , the repeated application of the rules in definition  [ def : motif_rules ] allows us to construct each member @xmath57 .",
    "however , note that it may also be possible to use these rules to construct graphs that are _ not _ part of the family .",
    "the following lemma shows that when degree - two nodes are added to a motif @xmath62 to form a graph @xmath3 , all network elements ( substrate nodes and links ) are _ used _ when embedding @xmath62 in @xmath3 ( i.e. , @xmath63 ) .",
    "[ lem : nodesload - app ] let @xmath64 be an arbitrary two - connected motif , and let @xmath3 be a graph obtained by applying the _ insert node rule _",
    "( rule @xmath65 of definition  [ def : motif_rules ] ) to motif @xmath62 .",
    "then , an embedding @xmath63 involves all nodes and edges in @xmath3 : at least @xmath66 resources are used on all nodes and edges .",
    "let @xmath67 . clearly , if there exists @xmath68 such that @xmath69 , then @xmath70 s capacity is used fully",
    "otherwise , @xmath70 was added by rule  @xmath65 .",
    "let @xmath71 be the two nodes of @xmath3 between which rule  @xmath65 was applied , and hence @xmath72 must be a motif edge .",
    "observe that for these nodes degrees it holds that @xmath73 and @xmath74 since rule  @xmath65 never modifies the degree of the old nodes in the host graph @xmath3 .",
    "since links are of unit capacity , each substrate link can only be used once : at @xmath75 at most @xmath76 edge - disjoint paths can originate , which yields a contradiction to the degree bound , and the relaying node @xmath70 has a load of @xmath66 .",
    "@xmath77    lemma  [ lem : nodesload - app ] implies that no additional nodes can be inserted to an existing embedding .",
    "in other words , a motif constitutes a `` minimal reservation pattern '' .",
    "as we will see , our algorithm will exploit this invariant that motifs cover the entire graph knitting , and adds simple nodes ( of degree 2 ) only in a later phase .    [ cor : embeditself - app ] let @xmath78 and let @xmath3 be a graph obtained by applying rule  @xmath65 of definition  [ def : motif_rules ] to motif @xmath62 .",
    "then , no additional node can be embedded on @xmath3 after embedding @xmath63 .",
    "next , we want to _ combine _ motifs explore larger `` knittings '' of graphs",
    ". each motif pair is glued together at a single node _ or edge _ ( `` attachment point '' ) : we need to be able to conceptually join to motifs at edges as well because the corresponding edge of the motif can be expanded by the _ insert node rule _ to create a node where the motifs can be joined .",
    "a _ motif sequence _ @xmath79 is a list @xmath80 where @xmath81 and where @xmath82 is glued together at exactly one node with @xmath83 ( i.e. , @xmath82 is `` attached '' to a node of motif @xmath83 ) : the notation @xmath84 specifies the selected attachment points @xmath85 and @xmath86 .",
    "if the attachment points are irrelevant , we use the notation @xmath87 and @xmath88 denotes an arbitrary sequence consisting of @xmath89 instances of @xmath82 .",
    "if @xmath79 can be decomposed into @xmath90 , where @xmath91 and @xmath92 are ( possibly empty ) motif sequences as well , then @xmath91 and @xmath92 are called _ subsequences _ of @xmath79 , denoted by  @xmath93 .    in the following",
    ", we will sometimes use the _ kleene star _",
    "notation @xmath94 to denote a sequence of ( zero or more ) elements of @xmath95 attached to each other .",
    "one has to be careful when arguing about the embedding of motif sequences , as illustrated in figure  [ fig : counterexab - app ] which shows a counter example for @xmath96 .",
    "this means that we typically can not just incrementally add motif occurrences to discover a certain substructure .",
    "this is the motivation for introducing the concept of a _ dictionary _ which imposes an order on motif sequences and their attachment points .      in a nutshell ,",
    "a dictionary is a _ directed acyclic graph ( dag ) _ defined over all possible motifs @xmath59 . and imposes an order ( poset relationship @xmath42 ) on problematic motif sequences which need to be embedded one before the other ( e.g. , the composition depicted in figure [ fig : counterexab - app ] ) . to distinguish them from sequences , dictionary entries are called _",
    "words_.    a _ dictionary _ @xmath97 is a directed acyclic graph ( dag ) over a set of motif sequences @xmath98 together with their attachment points . in the context of the dictionary , we will call a motif sequence _",
    "word_. the links @xmath99 represent the poset embedding relationship @xmath42 .",
    "concretely , the dag has a single root @xmath100 , namely the chain graph @xmath55 ( with two attachment points ) . in general , the _ attachment points _ of each vertex @xmath101 describing a word @xmath8 define how @xmath8 can be connected to other words . the directed edges @xmath102 represent the transitively reduced embedding poset relation with the chain @xmath55 context : @xmath103 is embeddable in @xmath104 and there is no other word @xmath105 such that @xmath106 , @xmath107 and @xmath108 holds .",
    "( the chains before and after the words are added to ensure that attachment points are `` used '' : there is no edge between two isomorphic words with different attachment point pairs . )",
    "we require that the dictionary be _ robust to composition _ : for any node @xmath70 , let @xmath109 denote the `` reachable '' set of words in the graph and @xmath110 all other words .",
    "we require that @xmath111 , where the transitive closure operator @xmath112 denotes an arbitrary sequence ( including the empty sequence ) of elements in @xmath95 ( according to their attachment points ) .",
    "see figure  [ fig : dictionary ] for an example .",
    "informally , the robustness requirement means that the word represented by @xmath70 can not be embedded in any sequence of `` smaller '' words , unless a subsequence of this sequence is in the dictionary as well . as an example , in a dictionary containing motifs @xmath13 and @xmath14 from figure  [ fig : counterexab - app ] would contain vertices @xmath13 , @xmath14 and also @xmath113 , and a path from @xmath13 to @xmath113 .    a ) , cycle @xmath114 , diamond @xmath115 , complete bipartite graph @xmath116 and complete graph @xmath117 .",
    "the attachment point pair of each word is black , the other nodes and edges of the words are grey .",
    "the edges of the dictionary are locally labeled , which is used in @xmath54 later .",
    "b ) a graph that can be constructed from the dictionary words.,title=\"fig : \" ]   b ) , cycle @xmath114 , diamond @xmath115 , complete bipartite graph @xmath116 and complete graph @xmath117 .",
    "the attachment point pair of each word is black , the other nodes and edges of the words are grey .",
    "the edges of the dictionary are locally labeled , which is used in @xmath54 later .",
    "b ) a graph that can be constructed from the dictionary words.,title=\"fig : \" ]    in the following , we use the notation @xmath118 to denote the set of `` maximal '' vertices with respect to their embeddability into @xmath79 : @xmath119 , where @xmath120 denotes the set of outgoing neighbors of @xmath70 .",
    "furthermore , we say that a dictionary @xmath115 _ covers _ a motif sequence @xmath79 iff @xmath79 can be formed by concatenating dictionary words ( henceforth denoted by @xmath121 ) at the specified attachment points .",
    "more generally , a dictionary covers a graph , if it can be formed by merging sequences of @xmath122 .",
    "let us now derive some properties of the dictionary which are crucial for a proper substrate topology discovery .",
    "first we consider maximal dictionary words which can serve as embedding `` anchors '' in our algorithm .",
    "[ lemma : dico - property - app ] let @xmath115 be a dictionary covering a sequence @xmath79 of motifs , and let @xmath123 .",
    "then @xmath25 constitutes a subsequence of @xmath79 , i.e. , @xmath79 can be decomposed to @xmath124 , and @xmath79 contains no words of order at most @xmath25 , i.e. , @xmath125 .    by contradiction",
    "assume @xmath126 and @xmath25 is not a subsequence of @xmath79 ( written @xmath127 ) . since @xmath115 _ covers _",
    "@xmath79 we have @xmath128 by definition . since @xmath115 is a dictionary and @xmath129 we know that @xmath130 .",
    "thus , @xmath131 : @xmath79 has a subsequence of at least one word in @xmath132 .",
    "thus there exists @xmath133 such that @xmath134 . if @xmath135 this implies @xmath136 which contradicts our assumption .",
    "otherwise it means that @xmath137 such that @xmath138 , which contradicts the definition of @xmath139 and thus it must hold that @xmath140 .",
    "@xmath77    the following corollary is a direct consequence of the definition of @xmath126 and lemma  [ lemma : dico - property - app ] : since for a motif sequence @xmath79 with @xmath141 , all the subsequences of @xmath79 that contain no @xmath25 are in @xmath142 . as we will see , the corollary is useful to identify the motif words composing a graph sequence , from the most complex words to the least complex ones .",
    "[ cor : recursive - app ] let @xmath115 be a dictionary covering a motif sequence @xmath79 , and let @xmath143",
    ". then @xmath79 can be decomposed as a sequence @xmath144 with @xmath145 .",
    "this corollary can be applied recursively to describe a motif sequence as a sequence of dictionary entries .",
    "note that a dictionary always exists .",
    "[ lem : dicoexistence ] there exists a dictionary @xmath146 that covers all member graphs @xmath2 of a motif graph family @xmath45 with @xmath147 vertices . [ proof in appendix ]      with these concepts in mind , we are ready to describe our generalized graph discovery algorithm called @xmath54 ( cf  algorithm  [ alg : motifrec - app ] ) .",
    "basically , @xmath54 always grows a request graph @xmath148 until it is isomorphic to @xmath2 ( the graph to be discovered ) .",
    "this graph growing is performed according to the dictionary , i.e. , we try to embed new motifs in the order imposed by the dictionary dag .",
    "@xmath54 is based on the observation that it is very costly to discover additional edges between nodes in a 2-connected component : essentially , finding a single such edge requires testing all possibilities , which is quadratic in the component size .",
    "thus , it is crucial to first explore the basic `` knitting '' of the topology , i.e. , the minors which are at least 2-connected ( the _ motifs _ ) . in other words ,",
    "we maintain the invariant that there are never two nodes @xmath149 which are not @xmath89-connected in the currently requested graph @xmath150 while they are @xmath89-connected in @xmath2 ; no path relevant for the connectivity is overlooked and needs to be found later .",
    "nodes and edges which are not contributing to the connectivity need not be explored at this stage yet , as they can be efficiently added later .",
    "concretely , these additional nodes can then be discovered by ( 1 ) using an _ edge expansion _ ( where additional degree two nodes are added along a motif edge ) , and by ( 2 ) adding `` chains '' @xmath55 to the nodes ( a virtual link @xmath55 constitutes an edge cut of size one and can again be expanded to entire chain of nodes using _ edge expansion _ ) .",
    "let us specify the _",
    "topological order _ in which algorithm",
    "@xmath54 discovers the dictionary words .",
    "first , for each node @xmath70 in @xmath98 , we define an order on its outgoing edges @xmath151 .",
    "this order is sometimes referred to as a `` port labeling '' , and each path from the dictionary root ( the chain @xmath55 ) to a node in @xmath98 can be represented as the sequence of port labels at each traversed node @xmath152 , where @xmath153 corresponds to a port number in @xmath55 .",
    "we can simply use the lexicographic order on integers , @xmath154 : @xmath155 , to associate each vertex with its minimal sequence , and sort vertices of @xmath98 according to their embedding order .",
    "let @xmath100 be the _",
    "function associating each vertex with its position in this sorting : @xmath156 ( i.e. , @xmath100 is the topological ordering of @xmath115 ) .",
    "the fact that subsequences can be defined recursively using a dictionary ( lemma  [ lemma : dico - property - app ] and corollary  [ cor : recursive - app ] ) is exploited by algorithm  @xmath54 . concretely",
    ", we apply corollary  [ cor : recursive - app ] to gradually identify the words composing a graph sequence , from the most complex words to the least complex ones .",
    "this is achieved by traversing the dictionary depth - first , starting from the root @xmath55 up to a maximal node : algorithm  @xmath54 tests the nodes of @xmath120 in increasing port order as defined above . as a shorthand , the word @xmath157 with @xmath158",
    "is written as @xmath159 $ ] ; similarly @xmath159<d[j]$ ] holds if @xmath160)<r(d[j])$ ] , a notation that will get useful to translate the fact that @xmath161 $ ] will be detected before @xmath159 $ ] by algorithm  @xmath54 . as a consequence ,",
    "the word of a sequence @xmath79 that gets matched first is uniquely identified : it is @xmath162 \\mapsto s)=$ ] @xmath163 : @xmath25 denotes the maximal word in @xmath79 .",
    "@xmath54 distinguishes whether the subsequences next to a word @xmath101 are empty ( @xmath164 ) or chains ( @xmath55 ) , and we will refer to the subsequence before @xmath70 by @xmath165 and to the subsequence after @xmath70 by @xmath166 . concretely , while recursively exploring a sequence between two already discovered parts @xmath167 and @xmath168 we check whether the maximal word @xmath70 is directly next to @xmath167 ( i.e. , @xmath169 ) or @xmath168 or both ( @xmath164 ) , or whether @xmath70 is somewhere in the middle . in the latter case , we add a chain ( @xmath55 ) to be able to find the greatest possible word in a next step .",
    "@xmath54 uses tuples of the form @xmath170 where @xmath171 and @xmath172 , i.e. , @xmath159 $ ] denotes the maximal word in @xmath115 , @xmath173 is the number of consecutive occurrences of the corresponding word , and @xmath165 and @xmath166 represent the words before and after @xmath159 $ ] .",
    "these tuples are lexicographically ordered by the total order relation @xmath174 on the set of possible @xmath170 tuples defined as follows : let @xmath175 and @xmath176 two such tuples",
    ". then @xmath177 iff @xmath178 or @xmath179 or @xmath180 or @xmath181 .    with these definition",
    "we can prove that algorithm  @xmath54 is correct .",
    "[ thm : main - app ] given a dictionary for @xmath45 , algorithm  @xmath54 correctly discovers any @xmath58 .",
    "we first prove that the claim is true if @xmath2 forms a motif sequence ( without edge expansion ) .",
    "subsequently , we study the case where the motif sequence is expanded by rule  2 , and finally tackle the general composition case .",
    "* discovery of motif sequences : * due to lemma  [ lemma : dico - property - app ] it holds that for @xmath8 chosen when line 1 of @xmath182 is executed for the first time , @xmath79 is partitioned into three subsequences @xmath183 , @xmath8 and @xmath184 .",
    "subsequently @xmath182 is executed on each of the subsequences @xmath185 recursively if @xmath186 , i.e. , if the subsequences are not empty . thus @xmath182 computes a decomposition as described in corollary  [ cor : recursive - app ] recursively .",
    "as each of the words used in the decomposition is a subsequence of @xmath79 and @xmath182 does not stop until no more words can be added to any subsequence , it holds that all nodes of @xmath79 will be discovered eventually . in other words , @xmath187 is defined for all @xmath188 .    as a next step",
    "we assume @xmath189 to be the sequence of words obtained by @xmath54 to derive a contradiction . since @xmath190 is the output of algorithm  @xmath54 and",
    "is hence embeddable in @xmath2 : @xmath191 , there exists a valid embedding mapping @xmath15 . given @xmath192 , we denote by @xmath193 the set of pairs @xmath194 for which @xmath195 . now assume that @xmath79 and @xmath196 do not lead to the same resource reservations `` @xmath197 '' .",
    "hence there are some inconsistencies between the substrate and the output of algorithm  @xmath54 : @xmath198 . with each of these `` conflict '' edges , one can associate the corresponding word @xmath199 ( resp .",
    "@xmath200 ) in @xmath79 ( resp .",
    "@xmath196 ) .",
    "if a given conflict edge spans multiple words , we only consider the words with the highest index as defined by @xmath54 .",
    "we also define @xmath201 ( resp .",
    "@xmath202 ) ) . since @xmath196 and @xmath79 are by definition not isomorphic , @xmath203 .",
    "let @xmath204 be the index of the greatest word embeddable on the substrate containing an inconsistency , and @xmath205 be the index of the corresponding word detected by @xmath54 .",
    "( @xmath25 ) assume @xmath206 : a lower order motif was erroneously detected .",
    "let @xmath207 ( and @xmath208 ) be the set of dictionary entries that are detected before ( after ) @xmath161 $ ] ( if any ) in @xmath79 by @xmath54 .",
    "observe that the words in @xmath207 were perfectly detected by @xmath54 , otherwise we are in case  ( @xmath28 ) .",
    "we can decompose @xmath79 as an alternating sequence of words of @xmath207 and other words using corollary  [ cor : recursive - app ] : @xmath209 with @xmath210 and attachment points @xmath211 and @xmath212 .",
    "as the words in @xmath207 are the same in @xmath196 , we can write @xmath213 ( using corollary  [ cor : recursive - app ] as well ) .    let @xmath214 be the sequence among @xmath215 that contains our misdetected word @xmath161 $ ] , and @xmath216 the corresponding sequence in @xmath196 .",
    "observe that @xmath217 since the words @xmath218 cut the sequences of @xmath79 and @xmath196 into subsequences @xmath219 that are embeddable .",
    "observe that @xmath161 \\mapsto    t$ ] since @xmath214 contains it .",
    "note that in the execution of @xmath182 when @xmath220 $ ] was detected the higher indexed words had been detected correctly by @xmath54 in previous executions of this subroutine .",
    "hence , @xmath167 and @xmath168 can not contain any words leading to edges in @xmath221 .",
    "thus @xmath222 which contradicts line @xmath223 of @xmath182 .",
    "( @xmath28 ) now assume @xmath224 : a higher order motif was erroneously detected . using the same decomposition as step ( @xmath25 ) ,",
    "we define @xmath225 as the set of words perfectly detected , and therefore decompose @xmath79 and @xmath196 as sequences @xmath226 and @xmath227 with @xmath228 and the property that each @xmath229 .",
    "let @xmath216 be the sequence among @xmath230 that contains our misdetected word @xmath220 $ ] , and @xmath214 the corresponding sequence in @xmath79 .",
    "since @xmath220 \\prec t'$ ] , @xmath220 \\mapsto t'$ ] .",
    "thus , since @xmath217 , we deduce @xmath220\\mapsto t$ ] which is a contradiction with @xmath205 and corollary  [ cor : recursive - app ] .",
    "the same arguments can be applied recursively to show that conflicts in @xmath231 of smaller indices can not exist either .",
    "* expanded motif sequences . * as a next step , we consider graphs that have been extended by applying node insertions ( rule 2 ) to motif sequences , so called _ expanded _ motif sequences : we prove that if @xmath2 is an expanded motif sequence @xmath79 , then algorithm  @xmath54 correctly discovers @xmath79 . given an expanded motif sequence @xmath79 , replacing all two degree nodes with an edge connecting their neighbors unless a cycle of length three would be destroyed , leads to a unique pure motif sequence @xmath214 , @xmath232 . for the corresponding embedding mapping",
    "@xmath15 it holds that @xmath233 is exactly the set @xmath234 of removed nodes .",
    "applying @xmath182 to an expanded motif sequence discovers this pure motif sequence @xmath214 by using the nodes in @xmath234 as relay nodes . all nodes in @xmath234",
    "are then discovered in @xmath235 where the reverse operation node insertion is carried out as often as possible .",
    "it follows that each node in @xmath79 is either discovered in @xmath182 if it occurs in a motif or in @xmath235 otherwise .    * combining expanded sequences . *",
    "finally , it remains to combine the expanded sequences .",
    "clearly , since motifs describe all parts of the graph which are at least 2-connected , the graph remaining after collapsing motifs can not contain any cycles : it is a tree .",
    "however , on this graph @xmath54 behaves like @xmath236 , but instead of attaching chains , entire sequences are attached to different nodes . along the unique sequence paths between two nodes ,",
    "@xmath54 fixes the largest words first , and the claim follows by the same arguments as used in the proofs for tree and cactus graphs .",
    "@xmath77    @xmath237  /*current request graph*/ ,   @xmath238  /*set of unexplored nodes*/ choose @xmath239 , @xmath240 * if * ( @xmath241 ) * then * @xmath242 , add all nodes of @xmath214 to @xmath243 , * for all * @xmath244 * do * _ edgeexpansion_(@xmath61 ) * else * remove @xmath70 from @xmath243    _ find_motif_sequence_(@xmath245 )    find maximal @xmath246 s.t .",
    "@xmath247)^j~{\\textsc{af}}~(t_>)$ ] [ line : potenz ] @xmath248 where @xmath249   / * issue requests * / * if * ( @xmath250 ) * then return * @xmath251 * if * ( @xmath252 ) * then * @xmath253)^j~{\\textsc{af}}~t_>)$ ] * if * ( @xmath254 ) * then * @xmath255)^j , t_>)$ ] * return * @xmath256)^j~{\\textsc{af}}$ ]    _ edge_expansion_(@xmath61 )    let @xmath149 be the endpoints of edge @xmath61 , remove @xmath61 from @xmath150 find maximal @xmath173 s.t . @xmath257   / * issue requests * / @xmath258 , add newly discovered nodes to @xmath243      the focus of @xmath54 is on generality rather than performance , and indeed , the resulting request complexities can often be high .",
    "however , as we will see , there are interesting graph classes which can be solved efficiently .",
    "let us start with a general complexity analysis .",
    "the requests issued by @xmath54 are constructed in line 1 of @xmath259 and in line 2 of @xmath260 .",
    "we will show that the request complexity of the latter is linear in the number of edges of the host graph while the request complexity of @xmath259 depends on the structure of the dictionary .",
    "essentially , an efficient implementation of line 1 of @xmath261 in @xmath54 can be seen as the depth - first exploration of the dictionary @xmath115 starting from the chain @xmath55 .",
    "more precisely , at a dictionary word @xmath70 requests are issued to see if one of the outgoing neighbors of @xmath70 could be embedded at the position of @xmath70 .",
    "as soon as one of the replies is positive , we follow the corresponding edge and continue recursively from there , until no outgoing neighbors can be embedded .",
    "thus , the number of requests issued before we reach a vertex @xmath70 can be determined easily .",
    "recall that @xmath54 tests vertices of a dictionary @xmath115 according to a fixed port labeling scheme . for any @xmath101 ,",
    "let @xmath262 be the set of paths from @xmath55 to @xmath70 ( each path including @xmath55 and @xmath70 ) . in the worst case , discovering @xmath70 costs @xmath263 .",
    "[ lem : weight ] the request complexity of line 1 of @xmath264 to find the maximal @xmath246 such that  @xmath265)^j~{\\textsc{af}}~(t _ > ) \\mapsto h$ ] where @xmath249 and @xmath150 is the current request graph is @xmath266 .    to reach a word",
    "@xmath267 $ ] in @xmath98 with depth - first traversal there is exactly one path between the chain @xmath55 and @xmath70 . @xmath54",
    "issues a request for at most all the outgoing neighbors of the nodes this path .",
    "after @xmath70 has been found , the highest @xmath173 where @xmath268 has to be determined . to this end , another @xmath269 requests are necessary .",
    "thus the maximum of @xmath270 over all word @xmath101 determines the request complexity .",
    "when additional nodes are discovered by a positive reply to an embedding request , then the request complexity between this and the last previous positive reply can be amortized among the newly discovered nodes .",
    "let @xmath271 denote the number of nodes in the motif sequence of the node @xmath70 in the dictionary .",
    "[ thm : runtime ] the request complexity of algorithm  @xmath54 is at most @xmath272 , where @xmath273 denotes the number of edges of the inferred graph @xmath58 , and @xmath274 is the maximal ratio between the cost of discovering a word @xmath70 in @xmath115 and @xmath271 , i.e. , @xmath275",
    ".    each time line  [ line : potenz ] of @xmath276 is called , either at least one new node is found or no other node can be embedded between the current sequences ( one request is necessary for the latter result ) . if one or more new nodes are discovered , the request complexity can be amortized by the number of nodes found : if @xmath70 is the maximal word found in line 1 of @xmath276 then it is responsible for at most @xmath277 requests due to lemma  [ lem : weight ] .",
    "if it occurs more than once at this position , only one additional request is necessary to discover even more nodes ( plus one superfluous request if no more occurrences of @xmath70 can be embedded there ) . amortizing the request number over the number of discovered nodes results in @xmath274 requests .",
    "all other requests are due to @xmath278 where additional nodes are placed along edges .",
    "clearly , these costs can be amortized by the number of edges in @xmath2 : for each edge @xmath279 , at most two embedding requests are performed ( including a `` superfluous '' request which is needed for termination when no additional nodes can be added ) .",
    "@xmath77      let us consider concrete examples to provide some intuition for theorem  [ thm : main - app ] and theorem  [ thm : runtime ] .",
    "the execution of @xmath54 for the graph in figure  [ fig : dictionary].b ) , is illustrated in figure  [ fig : motiftree ] .",
    "the squares and the edges between them depict the motif composition , the shaded squares belong to the motif sequence @xmath280 discovered in the first execution of @xmath276 ( chains , cycles , diamonds , and the complete bipartite graph over two times three nodes are denoted by @xmath55 , @xmath114 , @xmath115 and @xmath14 respectively ) .",
    "subsequently , the found edges are expanded before calling @xmath276 another four times to find @xmath114 and three times @xmath55 . ]    a fundamental graph class are _",
    "trees_. since , the tree does not contain any 2-connected structures , it can be described by a single motif : the chain @xmath55 . indeed , if @xmath54 is executed with a dictionary consisting in the singleton motif set @xmath281 , it is equivalent to a recursive version of @xmath236 from  @xcite and seeks to compute maximal paths . for the cactus graph",
    ", we have two motifs , the request complexity is the same as for the algorithm described in  @xcite .",
    "trees can be described by one motif ( the chain @xmath55 ) , and cactus graphs by two motifs ( the chain @xmath55 and the cycle @xmath114 ) .",
    "the request complexity of @xmath54 on trees and cactus graphs is @xmath0 .",
    "we present the arguments for cactus graphs only , as trees constitute a subset of the cactus family .",
    "the absence of diamond graph minors implies that a cactus graph does not contain two closed faces which share a link .",
    "thus , there can exist at most two different ( not even disjoint ) paths between any node pair , and the corresponding motif subgraph forms a _ cycle _ @xmath114 ( or a triangle ) .",
    "since the cycle has only one attachment point pair , @xmath274 of @xmath115 is constant .",
    "consequently , a linear request complexity follows directly from theorem  [ thm : runtime ] due to the planarity of cactus graphs ( i.e. , @xmath282 ) .",
    "@xmath77    an example where the dictionary is efficient although the connectivity of the topology can be high are",
    "_ block graphs_. a block graph is an undirected graph in which every bi - connected component ( a _ block _ ) is a clique .",
    "a _ generalized block graph _ is a block graph where the edges of the cliques can contain additional nodes . in other words , in the terminology of our framework , the motifs of generalized block graphs are _",
    "cliques_. for instance , cactus graphs are generalized block graphs where the maximal clique size is three .",
    "generalized block graphs can be described by the motif set of cliques .",
    "the request complexity of @xmath54 on generalized block graphs is @xmath283 , where @xmath273 denotes the number of edges in the host graph .",
    "the framework dictionary for generalized block graphs consists of the set of cliques , as a clique with @xmath89 nodes can not be embedded on sequences of cliques with less than @xmath89 nodes .",
    "as there are three attachment point pairs for each complete graph with four or more nodes , @xmath54 can be applied using a dictionary that contains three entries for each motif with more than three nodes ( @xmath284 ) .",
    "thus , the @xmath285 dictionary entry has @xmath286 nodes for @xmath287 and @xmath288 ) < 3(i+2)$ ] and @xmath274 of @xmath115 is hence in @xmath289 .",
    "consequently the complexity for generalized block graphs is @xmath283 due to theorem  [ thm : runtime ] .",
    "@xmath77    on the other hand , theorem  [ thm : runtime ] also states that highly connected graphs may require @xmath1 requests , even if the dictionary is small . in the next section",
    ", we will study whether this happens in `` real world graphs '' .",
    "a ) when run on different internet and power grid topologies . a ) number of nodes in different autonomous systems ( as ) .",
    "we computed the set of motifs of these graphs as described in definition  [ def : motif - app ] and counted the number of nodes that : ( i ) belong to a tree structure at the fringe of the network , ( ii ) have degree 2 and belong to two - connected motifs , and finally ( iii ) are part of the largest motif .",
    "b ) the fraction of nodes that can be discovered with 12-motif dictionary represented in figure c ) .",
    "d ) an example network where tree nodes are colored yellow , line - nodes are green , attachment point nodes are red and the remaining nodes blue.,title=\"fig:\",scaledwidth=42.0% ] b ) c ) when run on different internet and power grid topologies . a ) number of nodes in different autonomous systems ( as ) .",
    "we computed the set of motifs of these graphs as described in definition  [ def : motif - app ] and counted the number of nodes that : ( i ) belong to a tree structure at the fringe of the network , ( ii ) have degree 2 and belong to two - connected motifs , and finally ( iii ) are part of the largest motif .",
    "b ) the fraction of nodes that can be discovered with 12-motif dictionary represented in figure c ) .",
    "d ) an example network where tree nodes are colored yellow , line - nodes are green , attachment point nodes are red and the remaining nodes blue.,title=\"fig:\",scaledwidth=40.0% ] d )",
    "to complement our theoretical results and to validate our framework on realistic graphs , we dissected the _",
    "isp topologies _ provided by the rocketfuel mapping engine . in addition , we also dissected the topology of a european electricity distribution grid ( ` grid ` on the legends ) . figure  [ fig : exp ]",
    "a ) provides some statistics about the aforementioned topologies .",
    "since @xmath54 discovers both tree and degree 2 nodes in linear time , this figure shows that most of each topology can be discovered quickly .",
    "the inspected topologies are composed of a large bi - connected component ( the largest motif ) , and some other small and simple motifs .",
    "figure  [ fig : exp ]  b ) represents the fraction of each topology that can be discovered by @xmath54 using only a 12-motifs dictionary ( see  figure  [ fig : exp ]  c ) ) . interestingly , this small dictionary is efficient on @xmath290 different topologies , and contains motifs that are mostly symmetrical .",
    "this might stem from the man - engineered origin of the targeted topologies .",
    "finally , figure  [ fig : exp ] d ) provides an example of such a topology .",
    "10    h.  acharya and m.  gouda . on the hardness of topology inference . in _ proc .",
    "icdcn _ , pages 251262 , 2011 .",
    "a.  anandkumar , a.  hassidim , and j.  kelner .",
    "topology discovery of sparse random graphs with few participants . in _ proc",
    ". sigmetrics _ , 2011 .",
    "n.  bansal , k .- w .",
    "lee , v.  nagarajan , and m.  zafer .",
    "minimum congestion mapping in a cloud . in _ proc .",
    "30th podc _ , pages 267276 , 2011 .",
    "b.  cheswick , h.  burch , and s.  branigan .",
    "mapping and visualizing the internet . in _ proc .",
    "usenix annual technical conference ( atec ) _ , 2000 .",
    "m.  k. chowdhury and r.  boutaba .",
    "a survey of network virtualization . , 54(5 ) , 2010 .",
    "g.  even , m.  medina , g.  schaffrath , and s.  schmid .",
    "competitive and deterministic embeddings of virtual networks . in _ proc .",
    "icdcn _ , 2012",
    ".    j.  fan and m.  h. ammar .",
    "dynamic topology configuration in service overlay networks : a study of reconfiguration policies . in _ proc .",
    "ieee infocom _ , 2006 .",
    "i.  houidi , w.  louati , and d.  zeghlache . a distributed virtual network mapping algorithm . in _ proc .",
    ", 2008 .",
    "j.  lischka and h.  karl . a virtual network mapping algorithm based on subgraph isomorphism detection . in _ proc .",
    "acm sigcomm visa _ ,",
    "y.  a. pignolet , g.  tredan , and s.  schmid . in _ proc .",
    "pignolet , g.  tredan , and s.  schmid . in _",
    "ieee infocom _ , 2013 .",
    "g.  schaffrath , s.  schmid , and a.  feldmann . optimizing long - lived cloudnets with migrations . in _ proc .",
    "ieee / acm ucc _",
    ", 2012 .",
    "b.  yao , r.  viswanathan , f.  chang , and d.  waddington .",
    "topology inference in the presence of anonymous routers . in _ proc .",
    "ieee infocom _ ,",
    "pages 353363 , 2003 .",
    "s.  zhang , z.  qian , j.  wu , and s.  lu . an opportunistic resource sharing and topology - aware mapping framework for virtual networks . in _ proc .",
    "ieee infocom _ , 2012 .",
    "* lemma  [ lemma : poset ] . * _ the embedding relation @xmath42 applied to any family @xmath43 of undirected graphs ( short : @xmath44 ) , forms a partially ordered set ( a _ poset _ ) . _",
    "a poset structure @xmath291 over a set @xmath79 requires that @xmath292 is a ( _ reflexive _ , _ transitive _ , and _ antisymmetric _ ) order which may or may not be partial . to show that @xmath44 , the embedding order defined over a given set of graphs @xmath43 , is a poset , we examine the three properties in turn .      _ transitive _ @xmath295 and @xmath296 implies @xmath297 : let @xmath298 denote the embedding function for @xmath299 and let @xmath300 denote the embedding function for @xmath296 , which must exist by our assumptions .",
    "we will show that then also a valid embedding function @xmath15 exists to map @xmath13 to @xmath55 . regarding the node mapping ,",
    "we define @xmath301 as @xmath302 , i.e. , the result of first mapping the nodes according to @xmath303 and subsequently according to @xmath304 .",
    "we first show that @xmath301 is a valid mapping from @xmath13 to @xmath55 as well .",
    "first , @xmath305 , @xmath32 maps @xmath306 to a single node in @xmath307 , fulfilling the first condition of the embedding ( see definition  [ def : embedding ] ) . ignoring relay capacities ( which is studied together with the conditions on the links below ) , condition  ( @xmath28 ) of definition  [ def : embedding ]",
    "is also fulfilled since the mapping @xmath303 ensures that no node in @xmath308 exceeds its capacity , and can hence safely be mapped to @xmath307 .",
    "let us now turn our attention to the links .",
    "we use the following mapping @xmath309 for the edges . note that @xmath310 maps a single link @xmath61 to an entire ( but possibly empty ) path in @xmath14 and @xmath311 then maps the corresponding links @xmath312 in @xmath14 to a walk in @xmath55 .",
    "we can transform any of these walks into paths by removing cycles ; this can only lower the resource costs . since @xmath310 maps to a subset of @xmath38 only and since @xmath311 can embed all edges of @xmath14 , all link capacities are respected up to relay costs .",
    "however , note also that by the mapping @xmath298 and for relay costs @xmath313 , each node @xmath19 can either not be used at all , be fully used as a single endpoint of a link @xmath314 , or serve as a relay for one or more links . since both end - nodes and relay nodes are mapped to separate nodes in @xmath55 , capacities are respected as well",
    ". conditions  ( @xmath34 ) and ( @xmath37 ) hold as well .",
    "_ antisymmetric _ @xmath295 and @xmath315 implies @xmath316 , i.e. , @xmath13 and @xmath14 are isomorphic and have the same weights : first observe that if the two networks differ in size , i.e. , @xmath317 or @xmath318 , then they can not be embedded to each other : w.l.o.g .",
    ", assume @xmath319 , then since nodes of @xmath27 of can not be split into multiple nodes of @xmath308 ( cf definition  [ def : embedding ] ) , there exists a node @xmath26 to which no node from @xmath308 is mapped .",
    "this however implies that node @xmath320 must have available capacities to host also @xmath306 , contradicting our assumption that nodes can not be split in the embedding .",
    "similarly , if @xmath318 , we can obtain a contradiction with the single path argument .",
    "thus , not only the total number of nodes and links in @xmath13 and @xmath14 must be equivalent but also the total amount of node and link resources .",
    "so consider a valid embedding @xmath298 for @xmath295 and a valid embedding @xmath300 for @xmath321 , and assume @xmath322 and @xmath323 .",
    "it holds that @xmath298 and @xmath300 define an isomorphism between @xmath13 and @xmath14 : clearly , since @xmath322 , @xmath298 and @xmath300 define a permutation on the vertices .",
    "w.l.o.g . , consider any link @xmath324 . then",
    ", also @xmath325 : @xmath326 would violate the node capacity constraints in @xmath14 , and @xmath327 requires @xmath328 .",
    "@xmath77      we present a procedure to construct such a dictionary @xmath115 . let @xmath329 be the set of all motifs with @xmath147 nodes of the graph family @xmath45 . for each motif @xmath330 with @xmath331 possible attachment point pairs ( up to isomorphisms ) , we add @xmath331 dictionary words to @xmath98 , one for each attachment point pair .",
    "the resulting set is denoted by @xmath332 . for each sequence of @xmath333 with at most @xmath147 nodes , we add another word to @xmath98 ( with the un - used attachment points of the first and the last subword ) .",
    "there is an edge @xmath334 if the transitive reduction of the embedding relation with context includes an edge between two words .",
    "we now prove that @xmath115 is a dictionary , i.e. , it is robust to composition",
    ". let @xmath335 .",
    "observe that @xmath132 contains all compositions of words with at most @xmath147 nodes in which @xmath25 can be embedded .",
    "consequently , no matter which sequences are in @xmath142 it holds that @xmath336 can not be embedded in a sequences in @xmath337 the robustness condition is satisfied .",
    "since @xmath2 has @xmath147 vertices , and since @xmath115 contains all possible motifs of at most @xmath147 vertices , @xmath115 covers @xmath2 .",
    "@xmath77    note that the proof of lemma  [ lem : dicoexistence ] only addresses the composition robustness for sequences of up to @xmath147 nodes .",
    "however , it is clear that @xmath338 .",
    "( note that it is always possible to determine the number of nodes @xmath147 by binary search using @xmath339 requests . )"
  ],
  "abstract_text": [
    "<S> the network virtualization paradigm envisions an internet where arbitrary virtual networks ( vnets ) can be specified and embedded over a shared substrate ( e.g. , the physical infrastructure ) . as vnets </S>",
    "<S> can be requested at short notice and for a desired time period only , the paradigm enables a flexible service deployment and an efficient resource utilization .    </S>",
    "<S> this paper investigates the security implications of such an architecture . </S>",
    "<S> we consider a simple model where an attacker seeks to extract secret information about the substrate topology , by issuing repeated vnet embedding requests . </S>",
    "<S> we present a general framework that exploits basic properties of the vnet embedding relation to infer the entire topology . </S>",
    "<S> our framework is based on a graph motif dictionary applicable for various graph classes . </S>",
    "<S> we provide upper bounds on the _ request complexity _ , the number of requests needed by the attacker to succeed . </S>",
    "<S> moreover , we present some experiments on existing networks to evaluate this dictionary - based approach . </S>"
  ]
}