{
  "article_text": [
    "modelling of atomic motions in terms of classical newtonian equations is usually called molecular dynamics ( md ) .",
    "such modelling is considered useful in many areas of material research , chemistry , molecular biology , with various justifications for the applied approximations . in most applications large ensembles of atoms",
    "are treated using specialized software . in this paper",
    "we describe an alternative approach and describe methods which can be useful in design and exploration of new interactions , or simply in education .",
    "while the large systems require optimization of the computations and often possibility of parallel computation , the presented md models are supposed to be of the size up to tenths or possibly hundreds of particles .",
    "we show that for such relatively small systems of model atoms the computations can be carried out inside the systems matlab or octave .",
    "these systems should be relatively well known , but we give detailed references and small presentation of features relevant for this work in the appendix [ appendixa ] ,    it is generally well known that matlab and related systems have interpreted programming languages and this can make execution of large programs rather slow . on the other hand , they have the ability to perform mathematical operations on complicated structured objects in one single statement using ordinary mathematical notation .",
    "this property is essential for our approach .",
    "a simple md simulation code with pair potentials can be written in about 30 statements .",
    "these can be complemented by another set of routines of a comparable size ( about 20 to 30 statements ) for quite powerful real time visualizations .",
    "see appendix [ appendixa ] for some special aspects in matlab language .",
    "the system matlab and its open source relative gnu octave have emerged as `` matrix laboratory '' , i.e. a system for working with matrices . in their latest versions",
    "they have been extended to handle not only matrices and vectors , but also multidimensional arrays .",
    "the systems are based on the use of an internal programming language .",
    "the coding is made easier by an internal on - line manual system , which explains in detail the various built in functions .",
    "the disadvantage of computing with matlab is that the language is interpreted and not compiled , thus not efficient in large scale calculations . on the other hand ,",
    "the internal operations are based on optimized fortran and c libraries and thus perform very well and very efficiently .",
    "most of the statements about matlab are valid to octave , except the graphical cabilities .",
    "matlab has a very advanced graphical system , its counterpart in octave has long been slightly different and much simpler , but in the latest versions it is attempted to become very compatible .    for exploratory work and small projects",
    "the fact that the programs are interpreted and not compiled is of a great advantage .",
    "codes can be quickly adapted to any new required tasks and tested in matter of seconds , since no compilation and linking cycles are required .",
    "the codes discussed in this paper and additional material are available for download @xcite .",
    "generally , molecular dynamics refers to classical mechanics modeling of atomic systems where the atoms are represented by mass points interacting with their surroundings , including the other atoms , by forces which can be represented by potentials , schematically , for each atom there is a newton equation @xmath0 in many cases the coupled second order equations are solved using the well known verlet algorithm .",
    "this is a special difference scheme for solving newton - type equations @xmath1 using the following difference scheme @xmath2 we illustrate the use by the code for one particle moving in attractive coulomb potential , with the possibility of changing it to the so called soft coulomb , where the 1/r form is modified .",
    "such code is very popular for teaching demonstrations , but in our context it is useful to test the accuracy and stability of the solutions in this very simple case .",
    "the code ( we leave out the simple input and definition statements ) is here in line 6 we see that the vector rt representing @xmath3 is assigned the latest known 0.95 cm position and the accelerations vector is evaluated according to @xmath4 line 7 implements the verlet algorithm as given above in eq .",
    "[ verlet_algorithm ] .",
    "this line of code with only occasional small modifications is used in all the discussed applications . note that this operation is performed on a vector .",
    "later , when we consider more than one particle , the symbol r can represent a `` vector of vectors '' , then this line will become similar notation is available in 0.95 cm the new versions of fortran .",
    "the simple code for this classical central force problem is very illustrative and useful for exploring the stability and precission of the numerical method . when the parameter a is zero , we have the coulomb - kepler problem and the motion is periodic along an ellipse . if the a is different from zero , the motion is generally not periodic and we get a rosette - like motion .",
    "this elementary example is included because the codes in this paper use the same verlet implementation .",
    "the two - body forces considered here are forces between mass points , so that the potential energies can only be functions of the distances between the particles , perhaps with addition of global forces of the environment on each particle , but we shall limit this discussion to the pair forces only , a global force is analogue to the first example of planetary motion above .",
    "the total potential energy is given by @xmath5 and the force on each particle is obtained by gradient operation @xmath6 the symbol @xmath7 denotes the @xmath8 element of the matrix obtained by applying function @xmath9 on the matrix @xmath10 .",
    "we will generalize this notation to any type of objects , e.g. @xmath11 denotes the @xmath12 element of the corresponding 3-index array . without the indices , the discussed symbol represents the whole matrix or array .",
    "we shall now show in detail how solutions of eq .",
    "[ two_body_grads ] can be implemented in very short codes in matlab .    for one - dimensional world , to generate an object holding all the distances @xmath13",
    ", we can proceed as follows .",
    "we can aim at a matrix d with elements @xmath14 .",
    "in traditional programming such a construction would require two loops . in matlab",
    "this can be done in one statement .",
    "provided that the positions are in a vector @xmath15 in mathematical notation this means 0.95 cm @xmath16            \\begin{array}{cccccc }            \\left [              \\ \\",
    "x_{1 } \\right . &                  x_{2 }          &                  x_{3 }          &                ...              &            \\left .",
    "x_{n } \\ \\   \\right ] \\\\            \\ \\ & \\ \\ &   \\ \\ & \\ \\ \\\\            \\ \\ & \\ \\ &   \\ \\ & \\ \\ \\\\            \\ \\ & \\ \\ &   \\ \\ & \\ \\ \\\\            \\ \\ & \\ \\ &   \\ \\ & \\ \\ \\\\            \\ \\ & \\ \\ &   \\ \\ & \\ \\             \\end{array }       \\ \\ \\ -   \\ \\ \\                        \\left [                      \\begin{array}{c }                      x_{1 } \\\\                      x_{2 } \\\\                      x_{3 } \\\\                      .",
    "\\\\                      .",
    "x_{n }                      \\end{array }                      \\right ]            \\begin{array}{cccccc }            \\left [              \\ \\    1 \\right . &                  1          &                  1          &                  ...              &            \\left .",
    "\\right ] \\\\            \\ \\ & \\ \\ &   \\ \\ & \\ \\ \\\\            \\ \\ & \\ \\ &   \\ \\ & \\ \\ \\\\            \\ \\ & \\ \\ &   \\ \\ & \\ \\ \\\\            \\ \\ & \\ \\ &   \\ \\ & \\ \\ \\\\            \\ \\ & \\ \\ &   \\ \\ & \\ \\",
    "\\end{array }            \\label{vectors_distances}\\ ] ] and the following matrix operation @xmath17 - \\left [ \\begin{array}{c c c c c } x_{1 } & x_{1 } & x_{1 } & \\cdots & x_{1 }",
    "\\\\ x_{2 } & x_{2 } & x_{2 } & \\cdots & x_{2 } \\\\",
    "x_{3 } & x_{3 } & x_{3 } & \\cdots & x_{3 } \\\\",
    "\\vdots            & \\vdots            & \\vdots            & \\ddots & \\vdots            \\\\ x_{\\!n } & x_{\\!n } & x_{\\!n } & \\cdots & x_{\\!n }   \\end{array}\\right ] \\label{doublets_dist}\\ ] ] results in the matrix of all scalar distances whose elements are the distances @xmath18 the diagonal of the matrix d is clearly zero , and that could cause some problems in inversions and similar operations . besides , the forces `` on itself '' are not considered , so that there should be a mechanism of keeping the diagonal out of the calculations . the simple mechanism in matlab is to use `` not '' operation on the unity matrix , given by the built - in function eye(n ) the matrix un is @xmath19 matrix with one 0.95 cm everywhere except on diagonal , obtained by in matlab there are two types of multiplication : the mathematical product of matrices    .... a * b ....    and the element by element , @xmath20 , appearing in code as    ....",
    "a.*b ....    it should be rather clear that this can be used as a decomposition by projection operators into a part which has zeros on the diagonal and the diagonal part itself :    .... c= un . * a   + u . *",
    "a ;   c= ( ~u ) . * a + u.*a ; c= ~eye(n).*a + eye(n).*a ....    in the above code",
    ", the three assignments perform the same operation , assigning the matrix a to c , but the first term in the assignment is always the non - diagonal part .",
    "0.95 cm this decomposition can be used in various combinations , as we shall see below .",
    "the code for our molecular dynamics engine has only one disadvantage : for speed it is necessary to write the function for the force explicitly , but in principle it could be specified by a call to function script .",
    "here we shall use the explicit form .",
    "the whole code for the time development of the system of particles , i.e. the whole molecular dynamics engine in this approach is note that the above is not a pseudocode , but actual code .",
    "0.95 cm the fifth line is a shorthand notation for starting the solution . the verlet method must be started by assigning the starting time values of positions and the volues at the first time step .",
    "otherwise , the first 5 lines effectively declare the variables .",
    "the 3-index array of positions storing the whole simulation is r - for all times , the value of x and y ( and z in 3-dimensional case ) are the present positions , evaluated in previous step , are equivalently written as 0.1 cm i.e. specifying the whole definition range gives the object itself .",
    "0.95 cm we have chosen to present the case of particles moving in 2-dimensional space . the 3-dimensional version of this code is obtained by only adding relevant analogues for z , dz and changing the value 2 to 3 in all the ` zeros(2 , .... ) ` statements .",
    "it is naturally possible to write the code so that it includes both two and three - dimensional versions , but we present here the more transparent explicit form used in the listing .",
    "the actual loop over the time mesh is shown in lines 7 - 17 .",
    "line 8 assigns the present time values .",
    "the matrices ` dx ` and ` dy ` are discussed above , they hold the components of the distances between the particles .",
    "we use multidimensional arrays to perform all the operations , therefore there is a new complexity element .",
    "since the operations on the forces components are evaluated in one statement , line 14 , the ` dr ` is duplicated into the appropriately dimensioned ` rr(1:2,1:n,1:n ) `    for the understanding of the more compact code which we shall use further on we reformulate the code in the above example .",
    "first we repeat the relevant part to be changed and below we see the more compact code .",
    "this way of coding is now applicable for both two - dimensional and three - dimensional physical space .",
    "first the instantaneous array of vectors is assigned to r ( replacing x and y )",
    ". then the vector multiplications are replaced by constructions explained in the appendix .    ....",
    "r(:,:)=r(:,:,m ) ;      9 .",
    "dr = r(:,:,ones(1,n ) ) - permute ( r(:,:,ones(1,n ) ) , [ 1,3,2 ] ) ; 10 . 11 .",
    "rr(1,:,:)=sqrt ( sum(dr.^2,1 ) ) + ~umat ;   % ~umat avoids div . by zero 12 .",
    "1 ] , : , : ) ; 13 .      14 .",
    "forces =   ( -a*a*exp(-a*rr ) + b*b*exp(-b*rr ) ) . *",
    "rr ) ; 15 .",
    "f(:,:)=sum(forces.*umat,3 ) ; 16 .",
    "r(:,:,m+1)= 2*r(:,:,m)- r(:,:,m-1 ) + f / m * ( t(m)-t(m-1 ) ) ^2 ;    17 .",
    "end ....    the operation permute is a generalization of the transpose operation , where the permutation of indices is specified by the second variable of the operation , i.e. if ` a = ones(n , n ) ` , both of the following calls    ....   permute ( a , [ 2,1 ] ) -transpose(a )   permute ( a , [ 1,2 ] ) -a ....    would return zero 0.95 cm matrices .    in the last code",
    "there is still too much calculation going on .",
    "it can be simplified by having the forces predefined the calculation might become faster for very large number of particles but the code in the previous listing is more understandable .",
    "0.95 cm for small numbers of particles the first formulation might even perform faster in some cases , simply because the code is shorter .      in this part",
    "we reformulate the two - body problem in order to generalize to the n - body case .",
    "the total energy is a sum over the pairs @xmath21 which can be rewritten as , ( provided that @xmath22 which is always satisfied ) @xmath23 and the condition @xmath24 is automatically reflected by the properties of the interactions .",
    "the force on @xmath25-th particle is obtained by @xmath26 in evaluating each of the contributions in the sum @xmath27 we must realize that ( note that this is the simplest notation , already including symmetry ) @xmath28 due to the properties of the @xmath29-symbols this can be written as @xmath30 where @xmath31 represents the unit vector in the direction @xmath32 and the terms after summation will become @xmath33 and  @xmath34 .",
    "since the index m appears at different positions , after the summations are performed , the two terms will correspond to two different positions of the matrix . for simplification of the notation we will just consider the notation  @xmath35 for the x , y , z components of the unit vectors and consider now just the x - components",
    "@xmath36 ; the whole matrix will be then denoted by @xmath37 .",
    "thus @xmath38    \\label{x - part - of - gradient}\\ ] ] we observe that the right hand side of the last eq .",
    "[ x - part - of - gradient ] is in the form of matrix product , in the first term we use the fact that @xmath39 _ { jm}\\ ] ] since @xmath40 and the two terms can be brought to the same form as the second , @xmath41   \\right)_{{\\ensuremath{\\operatorname{mm } } } }   \\label{two - body - term - reduced}\\ ] ] i.e. the matrix product of matrix x and the derivative matrix , not element - wise product encountered before .",
    "the matrix notation conveniently denotes the result , but it is not needed for the practical evaluation ( it takes @xmath42 times longer time ) .",
    "the element - wise product of the two matrices ( the second transposed ) and summation over the second index will perform the same operation . in matlab notation ,    .... a= b*c ;                  % a matrix n x",
    "n    vec(k ) = a(k , k )   vec = sum ( b . *",
    "c. ' , 2 ) ;      ....    the reduction to a vector shown in eq .",
    "[ two - body - term - reduced ] can be seen as a general rule which will be useful below , in the three - body case .",
    "this formulation is already implemented in the listings in section [ matlab_2body ] .",
    "consider now a system of n mass points whose interactions are described by both pairwise distance dependent forces and additional three - body forces with dependence on the angles between the `` bonds '' to the neighboring points , a situation usually found in molecular dynamics .",
    "the two - body part of the forces can be treated as above . to evaluate quantities related to triplets of objects , as e.g. angles between vectors connecting the particles ( known as bond angles ) , a set of all pairs",
    "would be first computed , then a loop would run over that set , effectively including a triple or even four - fold loop , depending on algorithms chosen .",
    "all further evaluations of various functions of distances and bond - angles would involve writing efficient loops for manipulations , evaluations and summations of energies and forces , and solving the differential equations for the coupled system .",
    "here we discuss the extension of the approach discussed above to cover also the three - body case . we show the methods on the example of stillinger and weber three - body potentials .",
    "we show that also for this case the operations can be programmed in matlab in simple scalar - like notation and from the point of view of efficiency , the mathematical operations on matrices , or even multidimensional arrays , can be performed with speeds comparable to compiled and optimized code .",
    "a typical three - body potential is the stillinger and weber potential defined ( additional details not important for the present discussion can be found in the original reference ) as @xmath43 and the force on each particle is still obtained by gradient operation @xmath44 exactly as in eq .",
    "[ two_body_grads ] , but now the simple evaluation resulting in sum of forces from the individual neighbours can not be used as in the second part of eq .",
    "[ two_body_grads ] .",
    "the @xmath45 part contributes to the forces as described in the previous section .",
    "the new three body part is by stillinger and weber chosen as @xmath46 where @xmath47 is the angle between @xmath48 and @xmath49 @xmath50 at the position of the @xmath51-th particle .",
    "we also introduce here the notation for the unit vectors @xmath31 in direction of the distance vectors @xmath52 .",
    "the functions @xmath53 are chosen by stillinger and weber as @xmath54 where the functions @xmath55 mainly play a role of cut - off functions .",
    "we see that the most important feature of three - body part are the angles between the lines connecting the pairs of particles .",
    "this is the element which is going to be investigated in detail in the following section .    for later use",
    "we denote @xmath56 a notation useful in discussion of the evaluation of the forces below .",
    "note that in this part we have followed to high degree the notation used by the authors in the original paper .",
    "below we shall use our notation with stress on the pair - separability of this interaction , as discussed below .",
    "the main feature is the rather simple rewriting by the secongd part of eq . [ stillinger_theta ] .      in eq .",
    "[ doublets_dist ] we have introduced the fast way to compute and represent the distances between all particles - and in the following used both the scalar distances and their vector versions .",
    "these quantities have two indices and are thus conveniently treated as matrices , or @xmath57 objects .",
    "when we wished to keep all the space components in the same object , we ended with @xmath58 array objects . for three body interactions the potential terms @xmath59 of eq .",
    "[ stillinger_v_ijk ] are at the outset @xmath60 array objects .    to start we imagine a simplified term : instead of eq .",
    "[ stillinger_h_func ] ( which we have already rewritten according to a more transparent notation of eq .",
    "[ stillinger_theta ] ) @xmath61 we first consider only the first two terms in the product @xmath62 the objects with indices @xmath63 which would represent the @xmath55 and @xmath64 can be built from the matrices d as shown schematically in figure [ r_ij*r_ik ] .",
    "this corresponds to the first cube in figure [ r_ij*r_ik ] , and it is going to be multiplied by a similar object obtained by permuting the indices as shown schematically in this listing :    .... d3=zeros(n , n , n ) ; d3 ( : , : , : )   =   d2 ( : , : , ones(n,1 ) ) ; g1=gfun(d3 ) ; g2=gfun (   permute ( d3 , [ 1 3 2 ]   ) ; v3=   g1   . *   g2 ; ....    where the two matrices are multiplied element - wise . 0.95 cm      the total energy is sum over the triplets @xmath65 but now the energies inside of the triplet must be specified .",
    "since @xmath66 @xmath67 with most reasonable interaction forms , @xmath68 where the first index specifies the `` vertex of the ordered triplet '' , in the specific case discussed , the atom where the bond angle is measured . for such cases the summation can run over all individual cases and results in @xmath69 where now only factor 1/2 comes from the fact @xmath70 ,",
    "i.e. the vertex @xmath51 is the same but the remaining pair @xmath71 ) can be counted twice .",
    "the evaluation of the forces is in principle identical , but can become quite different for cases where different degrees of simplification are possible .    for the sw case , the interactions can be described as pair - separable . for a given @xmath72",
    "one has the form @xmath73 clearly , this form of interaction can be built as a three - index array , produced by element - wise multiplications of arrays constructed by duplication of matrices .",
    "consider first a simpler form , where we keep just the funcions of distances , @xmath74 the total energy three - index array @xmath75 =     { \\cal r}\\left [ \\left ( g ( r)\\right),(\\ast , \\ast , n ) \\right ]          \\cdot \\ast          { \\cal r}\\left [ \\left(g ( r)\\right ) , ( \\ast , n,\\ast ) \\right]\\ ] ] the notation is schematic , and shows  that the total array @xmath76 be constructed as a product of two three index arrays each of which originates from replication of the original matrices .",
    "we introduce a symbol @xmath77 $ ] to denote the replication of matrix @xmath78 along the dimension which contains the number , while the dimensions marked by asterix appear once .",
    "construction of the two arrays is shown in figure [ r_ij*r_ik ] .",
    "we have also used the operator @xmath79 for element - wise multiplication of two arrays of the same dimensions in analogy with the matlab notation .",
    "the importance of this is that also the gradient operations on such object will be obtained by operations on the original matrices , i.e. as @xmath80 .",
    "these are in form identical to the @xmath81 and so will be the @xmath82 .",
    "these gradients thus need to be calculated only for the @xmath57 matrix and replicated .",
    "schematically we can write , following the above notation , @xmath83_{ijk } &   =   &      \\",
    "\\   { \\cal r}\\left [ \\left(\\nabla_m   g ( r)\\right),(\\ast , \\ast , n ) \\right ]   \\cdot \\ast      { \\cal r}\\left [ \\left(g ( r)\\right ) , ( \\ast , n,\\ast ) \\right ]   \\nonumber \\\\     &   \\    & + \\       { \\cal r}\\left [ \\left ( g ( r)\\right),(\\ast , \\ast , n ) \\right ]       \\cdot \\ast             { \\cal r}\\left [ \\left(\\nabla_m g ( r)\\right ) , ( \\ast , n,\\ast ) \\right ] \\end{aligned}\\ ] ] rewriting of these relations in the matlab notation will immediately produce the desired code .",
    "there will be a summation over two indices to produce the vector of forces from the three - index arrays .",
    "the evaluation of the gradients of the full sw - interaction follows in a straightforward manner the rules of chain derivative .",
    "the details and illustration of the evaluation of the gradient of the cosine is given in the appendix .",
    "implementing the result shown in the appendix , we can also there apply the discussed fact that the term consists of pair - separable terms .",
    "thus all the operations can be also there performed on matrices of distances and duplicated to the necessary three - index objects in precisely the same way as shown above for the distance functions .",
    "the only difference is that these are now euclidian three dimensional vectors in addition to the particle - index dimensions .",
    "thus the three - body forces can be constructed in a very similar way as the two - body forces .",
    "the computation is longer only due to the duplication of the matrices and element - wise products of the resulting matrices .",
    "the evaluation of the functional dependence does not change , since also here the computations are performed on matrices .      the computations above can also be based on symmetry analysis . for a 3-body potential ,",
    "each unique interacting triplet of particles has six different permutations contributing thus a total of six forces per index ( particle ) . since the stillinger - weber potential -formula @xmath84 , defined in eq .",
    "[ stillinger_v_ijk ] - exhibits symmetry over the permutation of the second and third indices , i.e. @xmath85 , so that forces on the @xmath86 partilce satisfy @xmath87 where the parenthesis denotes the particle coordinate of the gradient @xmath88 relations in eq .",
    "[ force1 ] demonstrate the symmetry of the problem and show that only three unique elements of the force array need to be computed for each particle in each triplet , as discussed also in other applications @xcite , @xcite .",
    "potential formula exhibits also the following antisymmetry due to the triplet s geometrical configuration ; @xmath89 which can also be written as @xmath90 .",
    "thus only two unique forces per particle per unique triplet are to be evaluated .",
    "evaluation of analytical derivatives ( gradients ) of the 3-body term of the given potential with respect to the third index ( along the fourth dimension ) , gives the array , which is denoted @xmath91 , holding the following six unique ( two on each particle ) force elements per triplet : @xmath92 those six unique force elements per triplet are what is needed to generate all the other elements by symmetry and antisymmetry exploitation .",
    "transposing dimensions corresponding to the second and third indices of particles in @xmath91 array yields a new array @xmath93 , holding the other six force elements per triplet @xmath94 the third array @xmath95 holding the last six force elements per triplet ( cf .",
    "[ anti_symmetry_forces ] ) @xmath96 is computed by the antisymmetry relation : @xmath97 finally the total force on @xmath51-particle is a double sum over neighbors in triplets , i.e. @xmath98 this will be done in array form by addition of arrays @xmath95 , @xmath99 ` [ 1 3 2 4]`-permuted and @xmath100 ` [ 1 4 3 2]`-permuted ( the permutation of array dimensions is done to place the particle @xmath51 in the same position , see appendix ) . the resulting 4-index array and then summing over the third and fourth index of results in @xmath101 array of the forces .",
    "similar considerations and constructions can be done for the three - index arrays and their gradients in the case of tersoff - type potentials in section [ tersoffformula ] below , but there the symmetry and antisymmetry occur at two different stages of construction of the forces .      in this section",
    "we have shown how one can use matlab functionality for evaluation of three body potentials and forces for three - body interactions .",
    "the operations on three - index arrays of the type discussed are `` expensive '' in computer time but rather straightforward in terms of programming .",
    "the use of symmetries and more efficient build - up as discussed in sections [ sw - evaluation ] and [ cof ] makes the computations much faster , but is much more error - prone . here",
    "it can be useful to use a simple trick , formulate the computations first in a slow but easier programmed full - object version , even perhaps with the kronnecker - deltas shown in eq .",
    "[ unit_vectors_e_gradient ] implemented and explicitely summed , and then gradually introduce the more efficient computations in further versions .",
    "this offers possibilities for code development which are difficult to match in simplicity in other approaches .",
    "however , this approach offers even more benefits when investigating more complex interactions , as the tersoff type discussed in the following section .",
    "a more complex many - body potentials quite extensively used are the tersoff type potentials .",
    "they are constructed in a slightly different way , but the techniques discussed in previous section can be used with some modifications also here .",
    "the many body character is introduced via a pair interaction , but the parameters of the interaction depend on the positions of the neigbours and the same bond angles for triplets formed by the pair and a neighbour atom .",
    "we first follow the formulation usually found in literature and later translate this to our notation . considering a morse - like potential ,",
    "the energy can be written as a sum of cite energies as follows : @xmath102 where @xmath103 but where @xmath104 , i.e. their value is dependent on all the other particles , in practice on those which are in the neighborhood , as assured by the cut - off function .",
    "the function @xmath105 is an aproperiate cutoff function , while @xmath106 and @xmath107 are refered to as repulsive and attractive pair potentials respectively .",
    "the two potential functions of the pair - wise interactions are : @xmath108 the many - particle character in tersoff s formula is introduced by the following : @xmath109 @xmath110 @xmath111 @xmath112 where @xmath113 is the angle between the @xmath114 and @xmath115 as defined above , and the set of parameters for carbon is given in @xcite . in our work",
    "we used a fermi - type cutoff function which has proven continuity and smoothness ( infinitely differentiable ) at any point , @xmath116 where @xmath117 , and it is defined and parametrized in correspondence to that introduced by tersoff @xcite , which has a different functional form but a very similar shape .",
    "note that the same cut - off limits the pair interaction and the influence on the pair by the neighbors , the same @xmath118 appears both in eq .",
    "[ tersoff_c ] and eq .",
    "[ tersoff_e ] .    to apply methods discussed in the previous section",
    ", we realize that the gradient operation can work on the various parts of the functional dependence . for simplicity , we omit the cut - off function in this discussion .",
    "the force on each particle @xmath25 is calculated by applying the the gradient @xmath119 where we now re - write the above eqs .",
    "[ tersoff_a ] to [ tersoff_fff ] in a more transparent notation @xmath120 or @xmath121 where @xmath122 applying the gradient , @xmath123 \\right )   \\label{sums_q_tersoff}\\ ] ] we recognize that the first term  @xmath124  is simply a two - body case discussed before .",
    "the really multi - body term is @xmath125 = \\nabla_m \\left [ \\begin{array}{l }       v_a ( r_{ij } ) b \\left ( \\sum_k g(r_{{\\ensuremath{\\operatorname{ij } } } } ) g(r_{{\\ensuremath{\\operatorname{ik } } } } ) d \\left (       { { \\mathbf e}}_{ij } \\cdot { { \\mathbf e}}_{ik }   \\right ) \\right )     \\end{array } \\right ]   \\label{the_tersoff_difference}\\ ] ] the evaluation of the elements of matrices @xmath126 and @xmath127 as well as the function @xmath128 can be done in a straightforward way : construct the distance matrix as in eq [ doublets_dist ] , the unit vectors , and then construct the three - index array @xmath129 as in eq .",
    "[ stillinger_theta ] , in matlab notation 0.2 cm     ` z = sum(q,3 ) ;   `    produces the matrix ` z ` .",
    "0.95 cm we can treat all of the terms as before , except the term @xmath130 but we recognize that there is only one new typ of object , @xmath131 but the @xmath132 has exactly the same form as the whole three - body contribution eq .",
    "[ sw_v_ijk_defs ] in the sw case and thus can be evaluated and reduced to a matrix in the same way as in the sw case .",
    "the difference is that it must be combined with the other terms above . in spite of its complicated formal nature",
    "the tersoff - type potentials still contain only quantities including triplets of particles and the construction of the code is only a slightly more complex modification of the method outlined in section [ sw_arrays ] .",
    "the discussed method , implementing multidimensional arrays along with their pre - defined operations , has proven to be a useful alternative to the standard loops aggregations in the vector - based matlab - like languages .",
    "it enables fast and powerful memory manipulations for interactive or exploratory work .",
    "in contrast to explicit loop programming it opens for speed - up and efficiency comparable to well optimized compiled arithmetic expressions in the framework of an interpreted code .",
    "speed improvement is a main result of vectorized coding to which any numerical algorithm is very sensitive .",
    "vectorization is known as performing operations on data stored as vectors , matlab stores matrices and arrays by columns in contiguous locations in the memory , and allows thus the use of vectorization on those objects .",
    "the elements of arrays can be selectively accessed in a vectorized fashion using so called logical indices .",
    "mutidimensional logical arrays , as logical indices , have proven to be efficient and their use has resulted in a speed gain . finally , the practicality , simplicity and generality of such a method to program empirical formulae for molecular dynamics purposes , make it effective to perform simulations on relatively small systems , up to 140 particles in a personal machine of 1 gb ram , for tersoff s potential , a bigger system when using stillinger - weber potential , and up to 1000 particles if only a pair interactions are used .",
    "the described methodology can be applied both to investigation of aspects of molecular dynamics and to educational purposes .",
    "finally , programming in this method results in very short codes which are easily used and modified in interactive sessions .",
    "* _ matrix(array ) entering _ * the lines starting with ` > > ` are user input , the rest is matlab response . if input is ended by semicolon , no output follows .    .... > >   a=   [   1 4 5 2.5 7 ]      a      1.0000     4.0000     5.0000",
    "2.5000     7.0000 > >   b= [   1 ; 4 ; 2.5 ]   b =      1.0000      4.0000      2.5000 >",
    "[   0 1 ;   1   0 ] c =       0      1       1      0 > > d= [ 1 4 3 5 2         3 7 6.6 2 2 ] d =      1.0000     4.0000     3.0000     5.0000     2.0000      3.0000     7.0000     6.6000     2.0000     2.0000 ....    the last example , matrix ` d ` shows multi - line possibility , the previous is a more compact matrix input .    * _ accessing matrix(array ) elements : basic indexing _ *    assume ` a ` is a random 6 by 6 matrix ` a = rand(6,6 ) `    [ cols= \" < , < , < \" , ]     * _ matrix(array ) size , length and number of dimensions : _ *    the size of an array can be determined by the ` size ( ) ` command as :    .... [ nrows , ncols , npages , .... ] = size(a ) ....    where    .... nrows = size(a,1 ) ,      ncols = size(a,2 ) ,      npages = size(a,3 )    ....    this function is of much importance when aiming elements - wise operations as it is the key for arrays size matching .",
    "the ` ndims(a ) ` function reports how many dimensions the array ` a ` has . trailing singleton dimensions",
    "are ignored but singleton dimensions occurring before non - singleton dimensions are not .",
    "this means that    .... a=5 ;    c = a(1,1 ) ;   b = zeros(5,5 ) ; b(5,5,1)=4 ; ....    are valid expressions , even though they seemingly have non matching number of indices , but it is essential that the extra dimensions are `` singletons '' , i.e. the extra dimensions have length one .    an interesting construction : one can construct matrices and arrays expanding the singleton dimensions .    .... a=5 ;    b = a([1 1],[1 1 1 1 ] ) b =       5      5      5      5       5      5      5      5 ....    the ` length ( ) ` command gives the number of elements in the longest dimension , and is equivalent to ` max(size ( ) ) ` .",
    "it is also used with a row or a column vector .    * _ matrix(array ) replication : _ *    one can use the matlab built - in script repmat , to replicate a matrix by the command : ` repmat(a,[m n ] ) ` , which replicates the matrix ` a ( : , : ) ` m - times in the first dimension ( rows ) , and n - times in the second dimension ( columns ) .",
    "this is a block matrix construction , the block corresponding to the original matrix a is repeated in a m @xmath133 n `` supermatrix '' .",
    "the operation repmat is not a built - in but it is a script which means a slow execution .",
    "an alternative efficient way to achieve the same replication is by :    ` a([1:size(a,1)]'*ones(1,m),[1:size(a,2)]'*ones(1,n ) ) ` which is an application of basic indexing techniques .    in this work",
    "we can use another aspect of ` repmat ( ) ` script , for building multidimensional arrays from matrices . given a matrix a",
    ", its elements can be accessed by ` a ( : , : ) ` , but that is equivalent to ` a(:,:,1 ) ` , but also ` a(:,:,1,1 ) ` , this is referred to as `` trailing singleton dimensions '' . using this",
    ", one can replicate the trailing dimensions . from an n@xmath133n matrix",
    "we can construct a three - index n@xmath133n@xmath133n array by ` b = repmat(a,[1,1,n ] ) ; `  in the text we discuss a more efficient equivalent ` b = a(:,:,ones(1,n ) ) `    * _ transpose and its generalization permute : _ *    for a matrix ( 2d array ) non - conjugate transpose is given by ` transpose(a ) ` and it is equivalent to a standard matrix operation ` a. ' ` .",
    "the normal hermite type conjugation is denoted by ` a ' ` and has an equivalent function ` ctranspose(a ) ` .",
    "the ` a.'`-notation is somewhat surprising , since the dot usually denotes element - wise counterpart of the undotted operator ( as e.g. ` a.^2 ` , or ` a .",
    "* b ` etc ) .",
    "the generalizations of transpose - function to multi - dimensional arrays are given as ` permute(a , order ) ` and ` ipermute(a , order ) ` where order means an array of reordered indeces . when order is [ 1 2 3 4 ] for 4-index array , it means identity .    `",
    "transpose(a ) ` and ` permute(a,[2 1 ] ) ` give the same results as ( ` a. ' ` ) .",
    "the two permute - functions are related as shown in the example    `       h = permute(g,[3,1,2 ] ) , g = ipermute(h,[3,1,2 ] )   `    if ` size(g ) ` is e.g. ` 3 4 2 ` then ` size(h ) ` is ` 2 3 4 `    clearly , the inverse permute is introduced for convenience , the same result could be achieved by using the permute with appropriate order of dimensions .    * _ logical array addressing and predefined functions : _ *    for a given matrix or array ` g ` the function ` logical(g ) ` returns an equal size array where there are logical ones ( true ) in elements which were nonzero and logical zeros ( false ) where the original array had zeros .",
    "thus    ` lg = logical(g ) ` and ` lg = g>0 ` both return the same matrix of logical ones and zeros .",
    "the extreme usefulness of these functions is that when we write    ` g(lg)= 1   ./",
    "g(lg ) ` the calculation will be performed only for the logically true addresses , thus no division by zero will happen . or , we can `` shrink '' a range of values ; for example all values below a threshold can be given the threshold value and all values above a chosen top value can be given the top value .",
    "as an example , we take a matrix which should be modified by replacing all values smaller than 2 by 2 and all larger than 5 by 5 .",
    "this can be done by the following commands    `       b = a ;    b(a>5 ) = a(a>5)*0 + 5 ;    b(a<2 ) = a(a<2)*0 + 2   `    the original matrix and the resulting one are 0.0 cm 0.95 cm there are also available functions analogous to ` ones ( ) ` and ` zeros ( ) ` . as an example , ` false(5,2,2 ) ` returns the same logical array as ` zeros(5,2,2)>0 ` and ` true(5,2,2 ) ` is the same as e.g. ` logical(ones(5,2,2 ) ) `    the use of logical addressing can shorten some large array manipulations and calculations , but also consumes some processing time .",
    "one can test the gains and losses by filling a large array and doing the element - wise operations on the whole array and the logically addressed part of the array .    in this example",
    "we show the array of ten million numbers , where only 100 are nonzero .    ....",
    "n =   10000000 ; octave >   tic ;   c = zeros(n,1 ) ;   c(100:200)=1 ;   d = exp(c ) ;   toc       elapsed time is 0.601 seconds .",
    "octave > tic;c = zeros(n,1);c(100:200)=1 ;     d(c>0)=exp(c(c>0));toc       elapsed time is 0.394 seconds . ....    in the second line",
    "we have calculated only the nonzero cases using the discussed logical addressing .",
    "we observe that there is a certain small gain in time , but far under the factor @xmath134 expected from the number of calculations .",
    "it should also be mentioned that the return times are not reproduceable , they depend on the over all state of the computer memory .",
    "* _ array preallocation : + _ * matlabs matrix variables dynamically augment rows and columns and the matrix is automatically resized . internally , the matrix data memory must be reallocated with larger size .",
    "if a matrix is resized repeatedly like within a for loop , this overhead becomes noticeable .",
    "when a loop is of a must demand , as the inevitable time - loop in md programs , frequent reallocations are avoided by preallocating the array with one of the ` zeros ( ) ` , ` ones ( ) ` , ` rand ( ) ` , ` true ( ) ` and ` false ( ) ` commands .    * _ vectorization of matlab s computation and logical addressing : _ * vectorized computations which mean replacing parallel operations , i.e. , simultaneous execution of those operations in loops , with vector operations , improves the speed often ten - fold . for that purpose ,",
    "most standard functions in matlab are vectorized , i.e. , they operate on an array as if the function was applied individually to every element .",
    "logical addressing operations are also vectorized , the use of logical addressing may lead to vectorized computations only for elements where the indices are true , thus reducing execution time , in some cases substantially .",
    "let a , b and c mark three atoms , the b - atom is at the vertex of the angle @xmath135 ; + define the following quantities : + @xmath136 ;   @xmath137 ; @xmath138 ;    gradient with respect to the end @xmath139 @xmath140\\ ] ] gradient with respect to the end @xmath141 @xmath142\\ ] ] gradient with respect to point b : @xmath143   - \\frac{1}{r_{ba}}\\bigg [ { { \\mathbf e}}_{bc } -{{\\mathbf e}}_{ba } \\cos \\theta_{abc } \\bigg]\\ ] ] the gradients satisfy the following relation @xmath144 which simply confirms the fact that moving the vertex point @xmath145 by a vector @xmath146 is the same as moving each of the end points @xmath141 and @xmath139 simultaneously by the vector @xmath147 . *",
    "derivation : *            frank  h. stillinger and thomas  a. weber .",
    "computer simulation of local order in condensed phases of silicon .",
    ", 31(8):52625271 , apr 1985 .",
    "j.  tersoff .",
    "empirical interatomic potential for carbon , with applications to amorphous carbon .",
    ", 61(25):28792882 , dec 1988 .",
    "j.  v. sumanth , david  r. swanson , and hong jiang . a symmetric transformation for 3-body potential molecular dynamics using force - decomposition in a heterogeneous distributed environment . in",
    "ics 07 : proceedings of the 21st annual international conference on supercomputing _ , pages 105115 , new york , ny , usa , 2007 ."
  ],
  "abstract_text": [
    "<S> molecular dynamics is usually performed using specialized software packages . </S>",
    "<S> we present methods to perform exploratory studies of various aspects of molecular dynamics using matlab . </S>",
    "<S> such methods are not suitable for large scale applications , but they can be used for developement and testing of new types of interactions and other aspects of the simulations , or simply for illustration of the principles for instruction and education purposes . </S>",
    "<S> one advantage of matlab is the integrated visualization environment . </S>",
    "<S> we also present in detail exploration of forces obtained from 3-body potentials in molecular dynamics in this framework . </S>",
    "<S> the methods are based on use of matrices and multidimensional arrays for which matlab has a set of both linear algebra based as well as element - wise operations . </S>",
    "<S> the numerical computations are based on these operations on the array objects rather than on the traditional loop - based approach to arrays . </S>",
    "<S> the discussed approach has a straightforward implementation for pair potentials . </S>",
    "<S> applications to three - body interactions are the main aspect of this work , but extension to any general form of n - body interactions is also discussed . </S>",
    "<S> the methods discussed can be also applied without any change using the latest versions of the package gnu octave as a replacement for matlab . </S>",
    "<S> the code examples are listed in some detail , a full package of the matlab and octave codes is available for download . </S>"
  ]
}