{
  "article_text": [
    "markov chains ( mcs ) and markov decision processes ( mdps ) are widely used to study systems that exhibit both , probabilistic and nondeterministic choices .",
    "properties of these systems are often specified by temporal logic formulas , such as the branching time logic pctl  @xcite , the linear time logic pltl  @xcite , or their combination pctl *  @xcite . while model checking is tractable for pctl  @xcite , it is more expensive for pltl : pspace - complete for markov chains and 2exptime - complete for mdps  @xcite .    in classical model checking ,",
    "one checks whether a model @xmath0 satisfies an ltl formula @xmath1 by first constructing a nondeterministic bchiautomaton @xmath2  @xcite , which recognises the models of its negation @xmath3 .",
    "the model checking problem then reduces to an emptiness test for the product @xmath4 . the translation to bchiautomata may result in an exponential blow - up compared to the length of @xmath1",
    "however , this translation is mostly very efficient in practice , and highly optimised off - the - shelf tools like ltl3ba  @xcite or spot  @xcite are available .    the quantitative analysis of a probabilistic model @xmath0 against an ltl specification @xmath1 is more involved . to compute the maximal probability @xmath5 that @xmath1 is satisfied in @xmath0 , the classic automata - based approach includes the determinisation of an intermediate bchiautomaton @xmath6 .",
    "if such a deterministic automaton @xmath7 is constructed for @xmath6 , then determining the probability @xmath5 reduces to solving an equation system for markov chains , and a linear programming problem for mdps  @xcite , both in the product @xmath8 .",
    "such a determinisation step usually exploits a variant of safra s  @xcite determinisation construction , such as the techniques presented in  @xcite .",
    "kupferman , piterman , and vardi point out in @xcite that `` safra s determinization construction has been notoriously resistant to efficient implementations . '' even though analysing long ltl formulas would surely be useful as they allow for the description of more complex requirements on a system s behaviour , model checkers that employ determinisation to support ltl , such as liquor  @xcite or prism  @xcite , might fail to verify such properties .    in this paper",
    "we argue that applying the safra determinisation step in full generality is only required in some cases , while simpler subset and breakpoint constructions often suffice .",
    "moreover , where full determinisation is required , it can be replaced by a combination of the simpler constructions , and it suffices to apply it locally on a small share of the places .",
    "a subset construction is known to be sufficient to determinise finite automata , but it fails for bchiautomata .",
    "our first idea is to construct an under- and an over - approximation starting from the subset construction .",
    "that is , we construct two ( deterministic ) subset automata @xmath9 and @xmath10 such that @xmath11 where @xmath12 denotes the language defined by the automaton @xmath6 for @xmath1 .",
    "the subset automata @xmath9 and @xmath10 are the same automaton @xmath13 except for their accepting conditions .",
    "we build a product markov chain with the subset automata .",
    "we establish the useful property that the probability @xmath5 equals the probability of reaching some _ accepting _ bottom strongly connected components ( sccs ) in this product : for each bottom scc @xmath14 in the product , we can first use the accepting conditions in @xmath9 or @xmath10 to determine whether @xmath14 is accepting or rejecting , respectively .",
    "the challenge remains when the test is inconclusive . in this case , we first refine @xmath14 using a breakpoint construction .",
    "finally , if the breakpoint construction fails as well , we have two options : we can either perform a rabin - based determinisation for the part of the model where it is required , thus avoiding to construct the larger complete rabin product .",
    "alternatively , a refined multi - breakpoint construction is used .",
    "an important consequence is that we no longer need to implement a safra - style determinisation procedure : subset and breakpoint constructions are enough .",
    "from a theoretical point of view , this reduces the cost of the automata transformations involved from @xmath15 to @xmath16 for generalised bchiautomata with @xmath17 states and @xmath18 accepting sets . from a practical point of view , the easy symbolic encoding admitted by subset and breakpoint constructions is of equal value .",
    "we discuss that ( and how ) the framework can be adapted to mdps  with the same complexity  by analysing the end components @xcite .",
    "we have implemented our approach  both explicit and symbolic versions  in our iscasmctool  @xcite , which we applied on various markov chain and mdp case studies .",
    "our experimental results confirm that our new algorithm outperforms the rabin - based approach in most of the properties considered .",
    "however , there are some cases in which the rabin determinisation approach performs better when compared to the multi - breakpoint construction : the construction of a single rabin automaton suffices to decide a given connected component , while the breakpoint construction may require several iterations .",
    "our experiments also show that our prototype can compete with mature tools like prism .",
    "to keep the presentation clear , the detailed proofs are provided in the appendix .",
    "nondeterministic bchiautomata are used to represent @xmath19-regular languages @xmath20 over a finite alphabet @xmath21 . in this paper , we use automata with trace - based acceptance mechanisms .",
    "we denote by @xmath22}$ ] the set @xmath23 and by @xmath24 the successor of @xmath25 in @xmath22}$ ] .",
    "i.e. , @xmath26 if @xmath27 and @xmath28 if @xmath29",
    ".    [ def : nondetbuechiaut ] a _ nondeterministic generalised bchiautomaton _ ( ngba ) is a quintuple @xmath30 , consisting of    * a finite alphabet @xmath21 of input letters , * a finite set @xmath31 of states with a non - empty subset @xmath32 of initial states , * a set @xmath33 of transitions from states through input letters to successor states , and * a family @xmath34}\\,\\}}$ ] of accepting ( final ) sets .",
    "nondeterministic bchiautomata are interpreted over infinite sequences @xmath35 of input letters .",
    "an infinite sequence @xmath36 of states of @xmath37 is called a _ run _ of @xmath37 on an input word @xmath38 if @xmath39 and , for each @xmath40 , @xmath41 .",
    "we denote by @xmath42 the set of all runs @xmath43 on @xmath38 . for a run @xmath44 , we denote with @xmath45 the _ transitions of @xmath43_. we sometimes denote a run @xmath43 by the associated states , that is , @xmath46 where @xmath47 for each @xmath40 and we call a finite prefix @xmath48 of @xmath43 a _ pre - run_. a run @xmath43 of a ngba is _ accepting _ if its transitions @xmath49 contain infinitely many transitions from all final sets , i.e. , for each @xmath50}$ ] , @xmath51 , where @xmath52 .",
    "a word @xmath35 is _ accepted _ by @xmath37 if @xmath37 has an accepting run on @xmath38 , and the set @xmath53 of words accepted by @xmath37 is called its _ language_.    right40 mm -4 mm    ( -1.5,1.3 ) rectangle ( 1.5,0.2 ) ;    ( ba ) at ( 0,0 ) @xmath54 ; ( bax ) at ( @xmath55 ) @xmath56 ; ( bay ) at ( @xmath57 ) @xmath58 ; ( baz ) at ( @xmath59 ) @xmath60 ;    ( @xmath61 ) to node ( bax.north ) ; ( bax ) to node [ right , near end ] @xmath62 ( bay ) ; ( bay ) to[bend left=30 ] node [ left ] @xmath63 ( bax ) ; ( bax ) to node [ left , near end ] @xmath64 ( baz ) ; ( baz ) to[bend right=30 ] node [ right ] @xmath65 ( bax ) ;    figure  [ fig : examplebuechi ] shows an example of bchiautomaton .",
    "the number @xmath25 after the label as in the transition @xmath66 , when present , indicates that the transition belongs to the accepting set @xmath67 , i.e. , @xmath66 belongs to @xmath68 .",
    "the language generated by @xmath54 is a subset of @xmath69 and a word @xmath38 is accepted if each @xmath70 ( and @xmath63 ) is eventually followed by a @xmath63 ( by a @xmath70 , respectively ) .",
    "we call the automaton @xmath37 a _ nondeterministic bchiautomaton _ ( nba ) whenever @xmath71 and we denote it by @xmath72 . for technical convenience",
    "we also allow for finite runs @xmath48 with @xmath73 . in other words , a run may end with @xmath74 if action @xmath75 is not enabled from @xmath74 .",
    "naturally , no finite run satisfies the accepting condition , thus it is not accepting and has no influence on the language of an automaton .    to simplify the notation ,",
    "the transition set @xmath76 can also be seen as a function @xmath77 assigning to each pair @xmath78 the set of successors according to @xmath76 , i.e. , @xmath79 .",
    "we extend @xmath76 to sets of states in the usual way , i.e. , by defining @xmath80 .",
    "[ def : nondetparityaut ] a _ ( transition - labelled ) nondeterministic parity automaton _ ( npa ) with @xmath18 priorities is a quintuple @xmath81 where @xmath21 , @xmath31 , @xmath82 , and @xmath76 are as in definition  [ def : nondetbuechiaut ] and a function @xmath83}}$ ] from transitions to a finite set @xmath22}$ ] of priorities .",
    "a run @xmath36 of a npa is _ accepting _ if the lowest priority that occurs infinitely often is even , that is if @xmath84 is even .",
    "[ def : nondetrabinaut ] a _ ( transition - labelled ) nondeterministic rabin automaton _ ( nra ) with @xmath18 accepting pairs is a quintuple @xmath85 where @xmath21 , @xmath31 , @xmath82 , and @xmath76 are as in definition  [ def : nondetbuechiaut ] and @xmath86},\\ { { \\mathrm{a}}}_{i } , { { \\mathrm{r}}}_{i } \\subseteq { { \\mathrm{t}}}\\,\\}}$ ] is a finite family of rabin pairs .",
    "( for convenience , we sometimes use other finite sets of indices rather than @xmath22}$ ] . )    a run @xmath43 of a nra is accepting if there exists @xmath87}$ ] such that @xmath88 and @xmath89 .",
    "an automaton @xmath90 , where @xmath91 is the acceptance condition ( parity , rabin , bchi , or generalised bchi ) , is called _ deterministic _ if , for each @xmath78 , @xmath92 , and @xmath93 for some @xmath94 . for notational convenience ,",
    "we denote a deterministic automaton @xmath7 by the tuple @xmath95 and @xmath96 is the partial function , which is defined at @xmath97 if , and only if , @xmath98 is enabled at @xmath99 . for a given deterministic automaton @xmath100 ,",
    "we denote by @xmath101 the otherwise similar automaton with initial state @xmath102 .",
    "similarly , for a ngba @xmath37 , we denote by @xmath103 the ngba with @xmath104 as set of initial states .",
    "[ def : semidetaut ] we call a ngba @xmath105 @xmath106 a _ semi - deterministic bchiautomaton _ ( sdba ) if the set of states @xmath31 can be partitioned into two sets @xmath107 and @xmath108 , where @xmath107 is the set of states @xmath37 is initially in and @xmath108 is the set of finally reached states @xmath37 is eventually always in , such that    @xmath109 is singleton , and    the set of transitions can be partitioned into three sets : transitions @xmath110 that are taken initially , transit transitions @xmath111 , and transitions @xmath112 the automaton takes after a transit transition has been used , such that @xmath113 and @xmath114 are partial functions , i.e. , for each @xmath115 , @xmath116 for each @xmath117 and @xmath118 for each @xmath119 .",
    "ngbas can be translated to deterministic rabin automata ( dras ) using the following construction from  @xcite .",
    "we first define the structure that captures the acceptance mechanism of our deterministic rabin automaton .",
    "we call a tree @xmath120 an _ ordered tree _",
    "if it satisfies the following constraints :    * each element @xmath121 is called a _",
    "node_. the empty sequence @xmath122 is called the _ root_. * if a node @xmath123 is in @xmath124 , then @xmath125 is also in @xmath124 ; @xmath126 is called the _ predecessor _ of @xmath127 , denoted by @xmath128 ; @xmath129 is undefined . *",
    "if a node @xmath130 is in @xmath124 , then , for each @xmath131 , @xmath132 is also in @xmath124 ; @xmath126 is called an _ older sibling _ of @xmath127 and @xmath127 a _ younger sibling _ of @xmath126 ; the set of older siblings of @xmath127 is denoted by @xmath133 .",
    "ordered trees are therefore non - empty sets of nodes that are closed under predecessors and older siblings .",
    "let @xmath30 be a ngba .",
    "a _ generalised history tree _ ( ght ) @xmath102 over @xmath31 for @xmath18 accepting sets is a triple @xmath134 , where    * @xmath124 is an ordered tree , * @xmath135 is a labelling function such that * * @xmath136 holds for all @xmath121 , @xmath137 , * * the intersection of the labels of two siblings is disjoint , i.e. , for each @xmath121 and each @xmath138 , @xmath139 , and * * the union of the labels of all siblings is _ strictly _ contained in the label of their predecessor , i.e. , for each @xmath121 there exists @xmath140 such that for each @xmath141 , @xmath142 implies @xmath143 , * @xmath144}$ ] is a function that labels every node with a number from @xmath22}$ ] .    for a ght @xmath134 , @xmath145 is the history tree introduced in  @xcite .",
    "ghts are enriched by the second labelling function , @xmath146 , which is used to relate nodes in the tree with a particular accepting set .",
    "intuitively , @xmath147 denotes the _ active _ index of the accepting transitions , i.e. , @xmath148 .",
    "the construction separates the transition mechanism from the acceptance condition .",
    "a ght contains the set of currently reached states in its root .",
    "we therefore denote @xmath149 for a given ght @xmath134 by @xmath150 .",
    "as it helps to understand the correctness of our breakpoint construction , we recall how to determinise a ngba .",
    "[ def : determinisation ] given a ngba @xmath30 with @xmath151 states and @xmath18 accepting sets , we construct an equivalent dra @xmath152 , denoted by @xmath153 , as follows .",
    "* @xmath154 is the set of generalised history trees over @xmath31 .",
    "* @xmath155 is the generalised history tree @xmath156 .",
    "* for each tree @xmath157 and @xmath115 with @xmath158 ,",
    "the transition @xmath159 is the result of the following sequence of steps : for each node @xmath160 , let @xmath161 be @xmath162 ; 1 .",
    "_ raw update of @xmath163 .",
    "_ [ item : determinisation : rawupdate ] for each node @xmath160 , set @xmath164 .",
    "sprouting new children .",
    "_ [ item : determinisation : newchildren ] for each node @xmath160 with @xmath63 children and @xmath165 , create a new child @xmath166 with @xmath167 and @xmath168 .",
    "stealing of labels . _",
    "[ item : determinisation : stealing ] for each node @xmath127 and each @xmath169 , @xmath99 is removed from the labels of all younger siblings of @xmath127 and all of their descendants .",
    "accepting and removing .",
    "_ [ item : determinisation : accepting ] for each node @xmath127 whose label is equal to the union of the labels of its children , remove all descendants of @xmath127 from the tree , and restrict the domain of @xmath163 and @xmath146 accordingly .",
    "update @xmath147 with @xmath170 .",
    "+ the transition is in @xmath171 for all nodes @xmath127 for which this applies .",
    "5 .   _ removing nodes . _",
    "[ item : determinisation : removing ] remove all nodes with empty labels .",
    "( the resulting tree @xmath172 may no longer be ordered . )",
    "@xmath163 and @xmath146 are updated by restricting their domain .",
    "6 .   _ renaming and rejecting .",
    "_ [ item : determinisation : rejecting ] to repair the orderedness , we denote by @xmath173 the number of ( still existing ) older siblings of @xmath127 , and map @xmath174 to @xmath175 , denoted @xmath176 .",
    "we update a triple @xmath177 from the previous step to @xmath178 .",
    "+ for each @xmath179 and each @xmath180 with @xmath181 , the transition is in @xmath182 . + the sets @xmath183 and @xmath184 are constructed according to above steps  [ item : determinisation : accepting ] and  [ item : determinisation : rejecting ] .",
    "* @xmath185 is the set of nodes that occur in some ordered tree of size @xmath17 ( the number of nodes ) .",
    "right36 mm -5 mm    figure  [ fig : exampledeterm ] shows the dra @xmath186 corresponding to the ngba @xmath54 in figure  [ fig : examplebuechi ] .",
    "each rounded box is a tree and each node contains the node identifier and the associated @xmath163- and @xmath146-labels , respectively .",
    "@xmath187 contains the double arrow transitions while @xmath188 contains the remaining transitions ; @xmath189 and @xmath190 are empty .",
    "a _ distribution _ @xmath191 over a set @xmath192 is a function @xmath193 $ ] such that @xmath194 .",
    "a _ markov chain ( mc ) _ is a tuple @xmath195 , where @xmath196 is a finite set of states , @xmath197 is a _ labelling function _ , @xmath198 is the _ initial distribution _ , and",
    "@xmath199 $ ] is a _ probabilistic transition matrix _ satisfying @xmath200 for all @xmath201 .",
    "a state @xmath202 is called _ absorbing _ if @xmath203 .",
    "we write @xmath204 for @xmath205 .",
    "right32 mm -6 mm    ( -1.5,1.75 ) rectangle ( 1.5,0.15 ) ;    \\(mc ) at ( 0,0 ) @xmath206 ; ( mcatr ) at ( @xmath207 ) ; ( mca ) at ( @xmath208 ) @xmath64 ; ( mcc ) at ( @xmath209 ) @xmath63 ; ( mcb ) at ( @xmath210 ) @xmath70 ;    ( @xmath211 ) to node ( mca.north ) ; ( mca ) ",
    "( mcatr )  node [ below , near end ]  @xmath212 ( mcc ) ; ( mcatr ) to node [ below , near end ] @xmath213   ( mcb ) ; ( mcc ) to[bend left=30 ] node [ above , near end ] @xmath214 ( mca ) ; ( mcb ) to[bend right=30 ] node [ above , near end ] @xmath214 ( mca ) ;    a _ maximal path _ of @xmath0 is an infinite sequence @xmath215 satisfying @xmath216 for all @xmath40 , or a finite one if the last state is absorbing .",
    "we denote by @xmath217 the set of all maximal paths of @xmath0 .",
    "an infinite path @xmath215 defines the word @xmath218 with @xmath219 , @xmath40 .",
    "given a finite sequence @xmath220 , the _ cylinder _ of @xmath221 , denoted by @xmath222 , is the set of maximal paths starting with prefix @xmath221 .",
    "we define the probability of the cylinder set by @xmath223 . for a given mc @xmath0",
    ", @xmath224 can be uniquely extended to a probability measure over the @xmath98-algebra generated by all cylinder sets .    in this paper",
    "we are interested in @xmath19-regular properties @xmath225 and the probability @xmath226 for some measurable set @xmath227 .",
    "further , we define @xmath228 for an automaton @xmath37 .",
    "we write @xmath229 to denote the probability function when assuming that @xmath202 is the initial state .",
    "moreover , we omit the superscript @xmath0 whenever it is clear from the context .",
    "we follow the standard way of computing this probability in the product of @xmath0 and a deterministic automaton for @xmath227 .    given a mc @xmath195 and a deterministic automaton @xmath230 , the _ product markov chain _ is defined by @xmath231 where    * @xmath232 ; * @xmath233 if @xmath234 , @xmath235 otherwise ; and * @xmath236 equals @xmath237 if @xmath238 , and is @xmath235 otherwise .",
    "we denote by @xmath239 the _ projection _ on @xmath7 of the given @xmath240 , i.e. , @xmath241 , and by @xmath242 its extension to a set of transitions @xmath243 , i.e. , @xmath244 .",
    "as we have accepting transitions on the edges of the automata , we propose product markov chains with accepting conditions on their edges .    given a mc @xmath0 and a deterministic automaton @xmath7 with accepting set @xmath91 , the product automaton is @xmath245 where    * if @xmath246 , then @xmath247 where @xmath248 for each @xmath87}$ ] ( generalised bchimarkov chain , gmc ) ; * if @xmath249 , then @xmath250 where @xmath251 and @xmath252 for each @xmath87}$ ] ( rabin markov chain , rmc ) ; and * if @xmath253}$ ] , then @xmath254}$ ] where @xmath255 for each @xmath256 ( parity markov chain , pmc ) .    thus , rmc , pmc , and gmc are markov chains extended with the corresponding accepting conditions .",
    "we remark that the labelling of the initial states of the markov chain is taken into account in the definition of @xmath257 .",
    "[ def : scc ] a _ bottom strongly connected component _ ( bscc )",
    "@xmath258 is an scc in the underlying digraph @xmath259 of a mc @xmath0 , where all edges with source in @xmath14 have only successors in @xmath14 ( i.e. , for each @xmath260 , @xmath261 implies @xmath262 ) .",
    "we assume that a ( bottom ) scc does not contain any absorbing state .",
    "given an scc @xmath14 , we denote by @xmath263 the transitions of @xmath0 in @xmath14 , i.e. , @xmath264 .",
    "we fix an input mc @xmath0 and a ngba @xmath30 as a specification .",
    "further , let @xmath265 be the deterministic rabin automaton ( dra ) constructed for @xmath37 ( cf .",
    "@xcite ) , and let @xmath266 be the product rmc .",
    "we consider the problem of computing @xmath267 , i.e. , the probability that a run of @xmath0 is accepted by @xmath37 .",
    "we first recall the classical approach for computing @xmath268 , see  @xcite for details .",
    "it is well known  @xcite that the computation of @xmath268 reduces to the computation of the probabilistic reachability in the product rmc @xmath8 with @xmath265 .",
    "we first introduce the notion of accepting sccs :    [ def : acceptingsccofrmc ] given a mc @xmath0 and the dra @xmath265 , let @xmath14 be a bottom scc of the product rmc @xmath8 .",
    "we say that @xmath14 is accepting if there exists an index @xmath87}$ ] such that @xmath269 and @xmath270 ; we call each @xmath271 an _ accepting state_. moreover , we call the union of all accepting bsccs the _ accepting region_.    essentially , since a bscc is an ergodic set , once a path enters an accepting bscc @xmath14 , with probability @xmath214 it will take transitions from @xmath183 infinitely often ; since @xmath183 is finite , at least one transition from @xmath183 is taken infinitely often .",
    "now we have the following reduction :    [ thm : biancoa95 ] given a mc @xmath0 and a bchiautomaton @xmath37 , consider @xmath265 .",
    "let @xmath272 be the accepting region and let @xmath273 denote the set of paths containing a state of @xmath274 .",
    "then , @xmath275 .",
    "when all bottom sccs are evaluated , the evaluation of the rabin mc is simple : we abstract all accepting bottom sccs to an absorbing goal state and perform a reachability analysis , which can be solved in polynomial time  @xcite .",
    "thus , the outline of the traditional probabilistic model checking approach for ltl specifications is as follows :    1 .",
    "translate the ngba @xmath37 into an equivalent dra @xmath265 ; 2 .",
    "build ( the reachable fragment of ) the product automaton @xmath8 ; 3 .   for each bscc @xmath14 , check whether @xmath14 is accepting .",
    "let @xmath274 be the union of these accepting sccs ; 4 .",
    "infer the probability @xmath276 .",
    "the construction of the deterministic rabin automaton used in the classical approach is often the bottleneck of the approach , as one exploits some variant of the approach proposed by safra  @xcite , which is rather involved .",
    "the lazy determinisation technique we suggest in this paper follows a different approach .",
    "we first transform the high - level specification ( e.g. , given in the prismlanguage  @xcite ) into its mdp or mc semantics .",
    "we then employ some tool ( e.g. , ltl3ba",
    "@xcite or spot  @xcite ) to construct a bchiautomaton equivalent to the ltl specification .",
    "this nondeterministic automaton is used to obtain the deterministic bchiover- and under - approximation subset automata @xmath9 and @xmath10 , as described in subsection  [ subset ] .",
    "the languages recognised by these two deterministic bchiautomata are such that @xmath277 .",
    "we build the product of these subset automata with the model mdp or mc ( cf .",
    "lemma  [ lem : productsubsetisomorphicquotientmc ] ) .",
    "we then compute the maximal end components or bottom strongly connected components . according to lemma  [",
    "lem : subset ] , we try to decide these components of the product by using the acceptance conditions @xmath278 and @xmath279 of @xmath9 and @xmath10 , respectively .    for each of those components",
    "where over- and under - approximation do not agree ( and which we therefore can not decide ) , we employ the breakpoint construction ( cf .",
    "corollary  [ cor : breakpoint ] ) , involving the deterministic rabin over- and under - approximation breakpoint automata @xmath280 and @xmath281 , such that @xmath282 . for this",
    ", we take one state of the component under consideration and start the breakpoint construction with this state as initial state .",
    "this way , we obtain a product of a breakpoint automaton with parts of the model .",
    "if the resulting product contains an accepting component ( using the under - approximation ) , then the original component must be accepting , and if the resulting product contains a rejecting component ( using the over - approximation ) , then the original component must be rejecting .",
    "the remaining undecided components are decided either by using a safra - based construction , restricted to the undecided component , or only by using @xmath280 , where we start from possibly different states of the subset product component under consideration ; this approach always decides the remaining components , and we call it the multi - breakpoint construction .    for the model states that are part of an accepting component , or from which no accepting component is reachable ,",
    "the probability to fulfil the specification is now already known to be @xmath214 or @xmath235 , respectively . to obtain the remaining state probabilities ,",
    "we construct and solve a linear programming ( lp ) problem ( or a linear equation system when we start with mcs ) .",
    "note that , even in case the multi - breakpoint ( or safra - based ) procedure is necessary in some places , our method is usually still more efficient than direct rabin determinisation , for instance based on some variation of  @xcite .",
    "the reason for this is twofold .",
    "first , when starting the determinisation procedure from a component rather than from the initial state of the model , the number of states in the rabin product will be smaller , and second , we only need the multi - breakpoint determinisation to decide mecs or bottom sccs , such that the computation of transient probabilities can still be done in the smaller subset product .    the following optimisations can be used to speed up the model checking algorithm .",
    "* we can compute the graph decomposition on the fly .",
    "thus , we first compute one component , then decide it , compute the next component , etc . *",
    "if we have shown a state @xmath283 of the subset product to be accepting and @xmath284 , then @xmath285 is accepting .",
    "* we can treat all states , from which we find that we can reach an accepting component with probability 1 , as accepting .",
    "+ note that , if such a state is part of a mec , this expands to the complete mec , and if the state is initial , we can already terminate the algorithm . *",
    "subset and breakpoint products can be effectively represented using bdds  @xcite .    in the remainder of this section ,",
    "we detail the proposed approach : we first introduce the theoretical background , and then present the incremental evaluation of the bottom sccs .      in order to be able to apply our lazy approach , we exploit a number of acceptance equivalences in the rmc . given the dra @xmath265 and a state @xmath102 of @xmath7 , we denote by @xmath150 the label of the root node @xmath286 of the labelled ordered tree associated to @xmath102 ( cf .",
    "@xcite ) .",
    "[ thm : only_reach ] given a ngba @xmath37 and @xmath265 , let @xmath102 be an arbitrary state of @xmath7 .",
    "then , a word is accepted by @xmath287 if , and only if , it is accepted by @xmath288 .",
    "intuitively , a word @xmath38 is accepted by @xmath287 if there is an accepting sequence @xmath289 with @xmath290 and @xmath291 for each @xmath40 ; since each @xmath292 is the set of states reached from @xmath293 via @xmath294 , then in @xmath295 there is a sequence of states @xmath296 such that each @xmath297 is reached from some @xmath298 via @xmath294 ; such a sequence is accepting as well by the way @xmath153 is constructed .",
    "a similar argument applies for the other direction .",
    "the formal proof is a mild generalisation of the correctness proof of the dra construction  @xcite .",
    "theorem  [ thm : only_reach ] provides an immediate corollary .    [ cor : same ] given a ngba @xmath37 , a mc @xmath0 , and the dra @xmath265 ,    a path @xmath43 in @xmath8 that starts from a state @xmath299 is accepted if , and only if , the word it defines is accepted by @xmath288 ; and    if @xmath300 , then the probabilities of acceptance from a state @xmath299 and a state @xmath301 are equal , i.e. , @xmath302 .",
    "this property allows us to work on quotients _ and _ to swap between states with the same reachability set .",
    "if we ignore the accepting conditions , we have a product mc , and we can consider the quotient of such a product mc as follows .    given a mc @xmath0 and a dra @xmath265 , the _ quotient mc _ @xmath303 $ ] of @xmath304 is the mc @xmath305 , [ { l } ] , [ { \\mu_{0 } } ] , [ { { \\mathrm{p}}}])$ ] where    * @xmath306 = { \\{\\ , ( m,[d ] ) \\mid ( m , d ) \\in { m}\\times { q},\\ [ d ] = { \\{\\ , d ' \\in { q}\\mid { \\mathsf{rchd}}(d ' ) = { \\mathsf{rchd}}(d ) \\,\\ } } \\,\\}}$ ] , * @xmath307(m,[d ] ) = { l}(m , d)$ ] , * @xmath308(m,[d ] ) = { \\mu_{0}}(m , d)$ ] , and * @xmath309\\big((m,[d ] ) , ( m',[d'])\\big ) = { { \\mathrm{p}}}\\big((m , d),(m',d')\\big)$ ] .",
    "by abuse of notation , we define @xmath310= ( m,[d])$ ] and @xmath311 = { \\{\\ , [ s ] \\mid s \\in c \\,\\}}$ ] .",
    "it is easy to see that , for each @xmath312 , @xmath313 $ ] holds and that @xmath309 $ ] is well defined : for @xmath314 $ ] , @xmath315)\\big ) = { { \\mathrm{p}}}\\big((m , d),(m',d')\\big ) = { { \\mathrm{p}}}\\big((m , d_{2 } ) , ( m ' , [ d'])\\big)$ ] holds .",
    "[ thm : bottom_component ] for a mc @xmath0 and dra @xmath265 , it holds that    1 .",
    "if @xmath14 is a bottom scc of @xmath304 then @xmath316 $ ] is a bottom scc of @xmath303 $ ] , 2 .",
    "if @xmath317 is a bottom scc of @xmath303 $ ] , then there is a bottom scc @xmath14 of @xmath304 with @xmath318 $ ] .",
    "together with definition  [ def : acceptingsccofrmc ] and theorem  [ thm : only_reach ] , theorem  [ thm : bottom_component ] provides :    [ cor : quotients ] let @xmath14 be a bottom scc of @xmath303 $ ] .",
    "then , either all states @xmath319 of @xmath8 with @xmath320 \\in { \\mathtt{s}}$ ] are accepting , or all states @xmath319 of @xmath8 with @xmath320 \\in { \\mathtt{s}}$ ] are rejecting .",
    "once all bottom sccs are evaluated , we only need to perform a standard probabilistic reachability analysis on the quotient mc .",
    "to evaluate each bottom scc of the rmc , we use three techniques : the first one is based on evaluating the subset construction directly .",
    "we get two deterministic ngbas that provide over- and under - approximations .",
    "if this fails , we refine the corresponding bottom scc by a breakpoint construction .",
    "only if both fail , a precise construction follows .      for a given ngba @xmath30 , a simple way to over- and under - approximate its language by a subset construction is as follows .",
    "we build two ngbas @xmath321 and @xmath322 , differing only for the accepting condition , where    * @xmath323 , * @xmath324 for each @xmath87}$ ] , and * @xmath325 for each @xmath87}$ ] .",
    "right30 mm -5 mm    ( -1.3,1.5 ) rectangle ( 1.5,0.15 ) ;    ( suba ) at ( 0,0 ) @xmath326 ; ( subx ) at ( @xmath327 ) @xmath328 ; ( subyz ) at ( @xmath329 ) @xmath330 ;    ( @xmath331 ) to node ( subx.north ) ; ( subx ) to node[above , near end ] @xmath64 ( subyz ) ; ( subyz ) to[bend right=30 ] node[above , very near end ] @xmath332 ( subx ) ; ( subyz ) to[bend left=30 ] node[below , very near end ] @xmath63 ( subx ) ;    essentially , @xmath10 and @xmath9 are the subset automata that we use to over- and under - approximate the accepting conditions , respectively .",
    "figure  [ fig : examplesubset ] shows the reachable fragment of the subset construction for the ngba @xmath54 depicted in figure  [ fig : examplebuechi ] .",
    "the final sets of the two subset automata are @xmath333 and @xmath334 for @xmath10 and @xmath335 for @xmath9 .",
    "the following lemma holds :    [ lem : inclusions1 ] @xmath336}^{u } ) \\subseteq { \\mathcal{l}}({\\mathcal{a}}_{d } ) \\subseteq { \\mathcal{l}}({\\mathcal{s}}_{[d]}^{o})$ ] .",
    "the proof is easy as , in each @xmath278 and @xmath279 , the accepting transitions are over- and under - approximated . with this lemma , we are able to identify some accepting and rejecting bottom sccs in the product .",
    "we remark that @xmath10 and @xmath9 differ only in their accepting conditions .",
    "thus , the corresponding gmcs @xmath337 and @xmath338 also differ only for their accepting conditions .",
    "if we ignore the accepting conditions , we have the following result :    [ lem : productsubsetisomorphicquotientmc ] let @xmath0 be a mc , @xmath37 a ngba , @xmath265 , and @xmath9 as defined above ; let @xmath13 be @xmath9 without the accepting conditions .",
    "then , @xmath339 and @xmath303 $ ] are isomorphic .",
    "the proof is rather easy ",
    "it is based on the isomorphism identifying a state @xmath340 of @xmath339 with the state @xmath341)$ ] of @xmath303 $ ] such that @xmath342 .",
    "considering the accepting conditions , we can classify some bottom sccs .",
    "[ lem : subset ] let @xmath0 be a mc and @xmath37 a ngba .",
    "let @xmath10 and @xmath9 be as defined above .",
    "let @xmath14 be a bottom scc of @xmath337 .",
    "then ,    * @xmath14 is accepting if @xmath343 holds for all @xmath87}$ ] ; * @xmath14 is rejecting if @xmath344 holds for some @xmath87}$ ] .",
    "right34 mm -8.5 mm    ( -1.7,2 ) rectangle ( 1.7,0.15 ) ;    ( mba ) at ( 0,0 ) @xmath345 ; ( mbaa ) at ( @xmath346 ) @xmath347 ; ( mbac ) at ( @xmath348 ) @xmath349 ; ( mbab ) at ( @xmath350 ) @xmath351 ; ( mbaatr ) at ( @xmath352 ) ;    ( @xmath353 ) to ( mbaa.north ) ; ( mbaa )  ( mbaatr )  node [ below , near end ]  @xmath212 ( mbac ) ; ( mbaatr ) to node [ below , near end ] @xmath213   ( mbab ) ; ( mbac ) to[bend left=30 ] node [ above , very near end ] @xmath214   ( mbaa ) ; ( mbab ) to[bend right=30 ] node [ above , very near end ]  @xmath214 ( mbaa ) ;    the above result directly follows by lemma  [ lem : inclusions1 ] .",
    "figure  [ fig : examplemctimessubset ] shows the product of the mc @xmath206 depicted in figure  [ fig : examplemc ] and the subset automaton @xmath326 in figure  [ fig : examplesubset ] .",
    "it is easy to check that the only bottom scc is neither accepting nor rejecting .    for the bottom sccs , for which we can not conclude whether they are accepting or rejecting",
    ", we continue with the breakpoint construction .      for a given ngba @xmath30 ,",
    "we denote with @xmath354}\\,\\}}$ ] the breakpoint set , where    @xmath104 intuitively refers to the set of currently reached states @xmath149 in the root @xmath286 of an extended history tree @xmath134 ;    @xmath25 refers to the index @xmath355 of the root ; and    @xmath356 is the union of the @xmath163-labels of the children of the root .",
    "that is , @xmath357 , also denoted by @xmath358 , where @xmath359 represents the nodes of @xmath124 that are children of @xmath286 , i.e. , @xmath360 is an abstraction of the tree @xmath177 .",
    "we build two dras @xmath361 and @xmath362 , called the _ breakpoint automata _ , as follows .    from the breakpoint state @xmath360 ,",
    "let @xmath363 and @xmath364 .",
    "then an accepting transition with letter @xmath98 reaches @xmath365 if @xmath366 .",
    "this corresponds to the equivalence from step  [ item : determinisation : accepting ] that determines acceptance .",
    "( note that step  [ item : determinisation : stealing ] does not affect the union of the children s labels . ) since step  [ item : determinisation : accepting ] removes all children , this is represented by using @xmath367 as label of the child @xmath235 .",
    "formally , @xmath368",
    "right43 mm -12 mm    ( -1.95,0.15 ) rectangle ( 2.15,2.4 ) ;    ( brka ) at ( 0,0 ) @xmath369 ; ( brk - x-2-o ) at ( @xmath370 ) @xmath371 ; ( brk - yz-1-y ) at ( @xmath372 ) @xmath373 ; ( brk - x-1-o ) at ( @xmath374 ) @xmath375 ; ( brk - yz-2-o ) at ( @xmath376 ) @xmath377 ;    ( @xmath378 ) to node ( brk-x-1-o.north ) ; ( @xmath379 ) to node[above ] @xmath64 ( @xmath380 ) ; ( @xmath381 ) to node[below ] @xmath63 ( @xmath382 ) ;    ( brk - yz-2-o ) to node[left ] @xmath70 ( brk - x-1-o ) ;    ( @xmath383 ) to node[below ] @xmath64 ( @xmath384 ) ; ( @xmath385 ) to node[above ] @xmath70 ( @xmath386 ) ;    ( brk - yz-1-y ) to node[right ] @xmath63 ( brk - x-2-o ) ;    figure  [ fig : examplebreakpoint ] shows the reachable fragment of the breakpoint construction for the ngba @xmath54 depicted in figure  [ fig : examplebuechi ] .",
    "the double arrow transitions are in @xmath187 while the remaining transitions are in @xmath188 .",
    "[ theo : inclusions ] the following inclusions hold : @xmath387}^{u } ) \\subseteq { \\mathcal{l}}({\\mathcal{bp}}_{\\langle d \\rangle}^{u } ) \\subseteq { \\mathcal{l}}({\\mathcal{a}}_{d } ) \\subseteq { \\mathcal{l}}({\\mathcal{bp}}_{\\langle d \\rangle}^{o } ) , { \\mathcal{l}}({\\mathcal{s}}_{[d]}^{o})\\text{.}\\ ] ]    we remark that the breakpoint construction can be refined further such that it is finer than @xmath336}^{o})$ ] . however we leave it as future work to avoid heavy technical preparations . exploiting the above theorem",
    ", the following becomes clear .",
    "[ cor : breakpoint ] let @xmath14 be a bottom scc of the quotient mc .",
    "let @xmath388 be an arbitrary state of @xmath14 .",
    "moreover , let @xmath281 , @xmath280 be the breakpoint automata .",
    "then ,    * @xmath14 is accepting if there exists a bottom scc @xmath317 in @xmath389 with @xmath390 $ ] , which is accepting ( i.e. , @xmath317 contains some transition in @xmath187 ) .",
    "* @xmath14 is rejecting if there exists a bottom scc @xmath317 in @xmath391 with @xmath390 $ ] , which is rejecting ( i.e. , @xmath317 contains no transition in @xmath187 , but some transition in @xmath188 ) .    right55 mm -5 mm    ( -2.7,0.15 ) rectangle ( 2.8,2.5 ) ;    ( mbrka ) at ( 0,0 ) @xmath392 ; ( mbrk - x-2-o ) at ( @xmath393 ) @xmath394 ; ( mbrk - yz-1-y ) at ( @xmath395 ) @xmath396 ; ( mbrk - x-1-o ) at ( @xmath397 ) @xmath398 ; ( mbrk - yz-2-o ) at ( @xmath399 ) @xmath400 ;    ( @xmath401 ) to node ( mbrk-x-1-o.north ) ;    ( @xmath402 ) to node[above , very near end ] @xmath403 ( @xmath404 ) ; ( @xmath405 ) to node[below , very near end ] @xmath212 ( @xmath406 ) ;    ( mbrk - yz-2-o ) to node[left , very near end ] @xmath213 ( mbrk - x-1-o ) ;    ( @xmath407 ) to node[below , very near end ] @xmath214 ( @xmath408 ) ; ( @xmath409 ) to node[above , very near end ] @xmath213 ( @xmath410 ) ;    ( mbrk - yz-1-y ) to node[right , very near end ] @xmath212 ( mbrk - x-2-o ) ;    note that the products @xmath389 and @xmath391 are the same rmcs except for their accepting conditions .",
    "figure  [ fig : examplemctimesbrkpnt ] shows the product of the mc @xmath206 depicted in figure  [ fig : examplemc ] and the breakpoint automaton @xmath411 in figure  [ fig : examplebreakpoint ] .",
    "it is easy to see that the only bottom scc is accepting .",
    "together with corollary  [ cor : quotients ] , lemma  [ lem : subset ] and corollary  [ cor : breakpoint ] immediately provide the following result , which justifies the incremental evaluations of the bottom sccs .",
    "given a mc @xmath0 , a ngba @xmath37 , and @xmath265 , if @xmath310 $ ] is a state in a bottom scc of the quotient mc and @xmath412 = [ d']$ ] , then    * @xmath413 if @xmath414)}^{{\\mathcal{m}}{\\otimes}{\\mathcal{s}}_{[d']}^{u}}({\\mathcal{b } } ) > 0 $ ] or @xmath415 , and * @xmath416 if @xmath414)}^{{\\mathcal{m}}{\\otimes}{\\mathcal{s}}_{[d']}^{o}}({\\mathcal{b } } ) < 1 $ ] or @xmath417 .    in case",
    "there are remaining bottom sccs , for which we can not conclude whether they are accepting or rejecting , we continue with a multi - breakpoint construction that is language - equivalent to the rabin construction .      the multi - breakpoint construction we propose to decide the remaining bottom sccs makes use of a combination of the subset and breakpoint constructions we have seen in the previous steps , but with different accepting conditions : for the subset automaton @xmath418 , we use the accepting condition @xmath419 , i.e. , the automaton accepts no words ; for the breakpoint automaton @xmath420 , we consider @xmath421 .",
    "note that the bchiacceptance condition @xmath421 is trivially equivalent to the rabin acceptance condition @xmath422 , so @xmath423 is essentially @xmath280 .",
    "we remark that in general the languages accepted by @xmath13 and @xmath423 are different from @xmath424 : @xmath425 by construction while @xmath426 , as shown in theorem  [ theo : inclusions ] . to generate an automaton accepting the same language of @xmath37",
    ", we construct a _ semi - deterministic _ automaton @xmath427 by merging @xmath13 and @xmath423 as follows : @xmath428 , @xmath429 , @xmath430 , and @xmath431 , where @xmath432 .",
    "the equivalence between the languages accepted by @xmath37 and @xmath433 will be established in section  [ ssec : languageequivalencesemidet ] , more precisely by proposition  [ pro : buechilangequalsemidetlang ] , but we point it out here as it is used in the proof of theorem [ thm : acceptanceofsubsetautomaton ] .    for @xmath265 ,",
    "it is known by lemma  [ lem : productsubsetisomorphicquotientmc ] that @xmath339 and @xmath304 are strictly related , so we can define the accepting scc of @xmath339 by means of the accepting states of @xmath304 .",
    "[ def : acceptingsccofsubset ] given a mc @xmath0 and a ngba @xmath37 , for @xmath434 and @xmath265 , we say that a bottom scc @xmath14 of @xmath339 is accepting if , and only if , there exists a state @xmath435 in an accepting bottom scc @xmath317 of @xmath304 such that @xmath436 .",
    "note that corollary  [ cor : same ] ensures that the accepting sccs of @xmath339 are well defined .",
    "[ thm : acceptanceofsubsetautomaton ] given a mc @xmath0 and a ngba @xmath37 , for @xmath437 and @xmath434 , the following facts are equivalent :    1 .",
    "@xmath14 is an accepting bottom scc of @xmath339 ; 2 .   there exist @xmath438 and @xmath439 such that @xmath440 belongs to an accepting scc of @xmath441 for some @xmath50}$ ] ; 3",
    ".   there exist @xmath438 and @xmath442 such that @xmath443 reaches with probability @xmath214 an accepting scc of @xmath444 .",
    "theorem  [ thm : acceptanceofsubsetautomaton ] provides a practical way to check whether an scc @xmath14 of @xmath339 is accepting : it is enough to check whether some state @xmath340 of @xmath14 has @xmath445 for some @xmath440 in the accepting region of @xmath446 , or whether , for a state @xmath442 , @xmath447 reaches with probability @xmath214 the accepting region .",
    "we remark that , by construction of @xmath433 , if we change the initial state of @xmath433 to @xmath448i.e .",
    ", if we consider @xmath449then the run can only visit breakpoint states ; i.e. , it is actually a run of @xmath450 .",
    "based on the theorem [ thm : biancoa95 ] , the classical approach for evaluating mcs for ltl specifications is sketched as follows :    1 .",
    "translate the ngba @xmath37 into an equivalent dpa @xmath451 ; 2 .",
    "build ( the reachable fragment of ) the product automaton @xmath452 ; 3 .   for each bottom scc @xmath14 , check whether @xmath14 is accepting .",
    "let @xmath274 be the union of these accepting sccs ; 4 .",
    "abstract all accepting bottom sccs to an absorbing goal state and perform a reachability analysis to infer @xmath453 , which can be solved in polynomial time  @xcite .",
    "the classical approach is to construct a deterministic rabin automaton in step  1 and thus to evaluate rabin acceptance conditions in step  3  @xcite .",
    "the size of such deterministic rabin automaton is @xmath454 where @xmath17 and @xmath18 are the number of states and accepting sets of @xmath37 , respectively , and @xmath202 the number of states of @xmath0 .",
    "-1 mm    by using the isomorphism between the product mc @xmath339 of @xmath0 and @xmath434 and the quotient mc @xmath455 $ ] , in lemma  [ lem : productsubsetisomorphicquotientmc ] we have established that it is enough to check whether each scc of @xmath339 is accepting .",
    "then , computing the probability @xmath268 simply reduces to computing the probability of reaching the accepting sccs in @xmath339 .",
    "the latter step is analogous to the classical one , so let us focus on the former .",
    "the corresponding pseudocode makes use of the procedures @xmath456 and @xmath457 , computing the accepting sccs of @xmath339 and whether the scc @xmath14 is accepting , respectively .",
    "the procedure @xmath456 is the same as the one depicted in figure  [ fig : computeacceptingscc ] and works as follows :    we build the subset automaton @xmath13 and its product with the mc @xmath0 , @xmath339 ;    we compute the sccs of @xmath339 ;    for each scc @xmath14 , we decide whether it is accepting and we collect into @xmath458 all accepting sccs . by corollary  [ cor : same ]",
    ", we have that @xmath458 contains all states of @xmath339 corresponding to the accepting states of @xmath459 .    note that we just need to work with the reachable fragment of @xmath13 and of @xmath339 , since the unreachable parts do not contribute to the evaluation of @xmath268 .",
    "regarding the procedure @xmath457 , we first verify whether @xmath14 is accepting via over- and under - approximating acceptance conditions on the subset construction itself .",
    "this technique is in not complete ; if @xmath14 has not been decided , we proceed with over- and under - approximating acceptance conditions on the breakpoint construction .",
    "if @xmath14 is still not decided , we finally fall back to the original rabin construction , but only on the states of  @xmath14 .    in this work",
    "we prove that it is sufficient to use subset and breakpoint constructions for identifying accepting sccs .",
    "the new construction avoids the rabin ( or parity ) determinisation of the bchiautomaton completely and gives an improved complexity .",
    "the pseudocode of our semi - deterministic construction is the one depicted in figure  [ fig : computeacceptingscc ] : deciding the accepting sccs of @xmath339 is based on breakpoint automata @xmath423 with bchiacceptance conditions ; the method is conclusive , but different initial states might have to be considered .",
    "the evaluation of the probability of reaching such accepting sccs requires only @xmath339 .",
    "the algorithm we propose is rather simple , but its correctness is much more involved and we devote the next section to show that our novel approach is correct . the correctness is based on the equivalence of the given ngba @xmath37 and a semi - deterministic bchiautomaton whose initial part is generated via subset construction while for the final part the breakpoint construction is used .",
    "the transit transitions between these two parts connect each subset state @xmath460 to each possible breakpoint state @xmath461 having @xmath462 . as theorem  [ thm : acceptanceofsubsetautomaton ]",
    "will show , an scc of @xmath339 is accepting if and only if by performing one of such transit transitions we land directly inside an accepting scc of @xmath463 . alternatively , by the same theorem , an scc of @xmath339 is accepting if and only if by performing one of such transit transitions we land to a state @xmath447 that reaches accepting sccs of @xmath463 with probability @xmath214 .",
    "note that such sccs may be unreachable from the usual initial state of @xmath463 , so this does not contradict the fact that the usual breakpoint construction is not enough to decide whether @xmath464 for a given word @xmath465 .",
    "in this section we show that the semi - determinisation construction is correct .",
    "this result is achieved in several steps .",
    "we first describe how a ngba @xmath37 can be converted into a semi - deterministic bchiautomaton @xmath433 via subset and breakpoint constructions ; then we show that @xmath37 and @xmath433 recognise the same language ; next , we consider the parity determinisation @xmath100 of @xmath433 and we show that again the recognised language is preserved ; finally , we relate the accepting sccs of @xmath339 with the accepting sccs of @xmath446 and of @xmath463 , where @xmath434 and @xmath466 .",
    "we conclude the section with the complexity analysis of the semi - determinisation construction .",
    "the first step for proving the correctness of our semi - determinisation construction is the generation of a semi - deterministic automaton corresponding to the given @xmath37 , by using the subset and breakpoint constructions .",
    "[ def : semi - determinisation ] given a ngba @xmath37 , consider the subset and bchibreakpoint automata @xmath467 and @xmath468 , respectively .",
    "the _ semi - determinisation _ of @xmath37 is the bchiautomaton @xmath469 where @xmath428 is the set of states , @xmath429 is the initial state , @xmath430 is the transition relation , @xmath431 is the accepting set , and @xmath470 is defined as @xmath432 .",
    "thus , the semi - deterministic automaton @xmath471 consists of two deterministic parts : an initial part with the states @xmath472 , where the automaton follows the subset construction , and a final part with the states @xmath473 , where the automaton follows the breakpoint construction . within a run of an automaton",
    ", there is only ( or : at most ) a single step that is not following this deterministic pattern : the transition taken from @xmath470 from the initial to the final part . by construction , it is clear that the resulting automaton is semi - deterministic .",
    "( -5.2,0.4 ) rectangle ( 5.75,3.5 ) ;    ( sd ) at ( 0,0 ) ; ( suba ) at ( @xmath474 ) subset construction ; ( subac ) at ( @xmath475 ) ; ( subx ) at ( @xmath476 ) @xmath328 ; ( subyz ) at ( @xmath477 ) @xmath478 ;    ( @xmath479 ) to node ( @xmath480 ) ; ( subx ) to node[above ] @xmath64 ( subyz ) ; ( subyz ) to[bend left=30 ] node[below ] @xmath70 ( subx ) ; ( subyz ) to[bend right=30 ] node[above ] @xmath63 ( subx ) ;    ( brka ) at ( @xmath481 ) breakpoint construction ; ( brkac ) at ( @xmath482 ) ; ( brk - x - o-2 ) at ( @xmath483 ) @xmath371 ; ( brk - x - o-1 ) at ( @xmath484 ) @xmath375 ; ( brk - yz - o-2 ) at ( @xmath485 ) @xmath377 ; ( brk - yz - y-1 ) at ( @xmath486 ) @xmath373 ;    ( brk - yz - z-1 ) at ( @xmath487 ) @xmath488 ; ( brk - y - o-2 ) at ( @xmath489 ) @xmath490 ;    ( brk - x - o-2 ) to[bend left=15 ] node @xmath64 ( brk - yz - o-2 ) ; ( brk - yz - o-2 ) to[bend left=15 ] node @xmath63 ( brk - x - o-2 ) ;    ( brk - yz - o-2 ) to node @xmath70 ( brk - x - o-1 ) ;    ( brk - x - o-1 ) to[bend left=15 ] node @xmath64 ( brk - yz - y-1 ) ; ( brk - yz - y-1 ) to[bend left=15 ] node @xmath70 ( brk - x - o-1 ) ;    ( brk - yz - y-1 ) to node @xmath63 ( brk - x - o-2 ) ;    ( brk - y - o-2 ) to node[above ] @xmath63 ( brk - x - o-2 ) ; ( brk - yz - z-1 ) to[bend left=15 ] node @xmath70 ( brk - x - o-2 ) ; ( brk - yz - z-1 ) to node @xmath63 ( brk - x - o-1 ) ;    ( subyz ) to[bend left=15 ] node @xmath70 ( brk - x - o-1 ) ; ( subyz ) to[bend right=15 ] node @xmath70 ( brk - x - o-2 ) ; ( subyz ) to[bend left=30 ] node @xmath63 ( brk - x - o-1 ) ; ( subyz ) to[bend right=30 ] node @xmath63 ( brk - x - o-2 ) ; ( subx ) .. controls ( @xmath491 ) and ( @xmath492 ) .. node @xmath64 ( brk - yz - o-2 ) ; ( subx ) .. controls ( @xmath493 ) and ( @xmath494 ) .. node[near end ] @xmath64 ( brk - y - o-2 ) ; ( subx ) .. controls ( @xmath495 ) and ( @xmath496 ) .. node[near end ] @xmath64 ( brk - yz - z-1 ) ; ( subx ) .. controls ( @xmath497 ) and ( @xmath498 ) .. node[above , near start ] @xmath64 ( brk - yz - y-1 ) ;    figure  [ fig : examplesemidet ] shows the semi - determinisation of the bchiautomaton @xmath54 in figure  [ fig : examplebuechi ] .",
    "the left hand side is the initial part , obtained via the subset construction ; the right hand side is a fragment of the final part , generated via the breakpoint construction .",
    "we remark that the breakpoint construction has 38 states ( of which only 12 states are reachable via transit transitions ) while we have depicted only 6 of them .",
    "double arrows are transitions belonging to @xmath431 while dotted arrows are ( some of ) the transit transitions in @xmath470 .      given a sdba @xmath499 with @xmath500 and @xmath501",
    ", we can construct a dpa @xmath502 ( where @xmath367 represents the function with an empty domain ) as follows .",
    "let @xmath503 be the completion of @xmath504 that maps every element of @xmath505 not in the domain of @xmath504 to a fresh symbol @xmath506 .",
    "for the components @xmath507 and @xmath508 , we use according definitions .    a state in @xmath154",
    "is a pair @xmath509 , consisting of the state @xmath510 reached through the extended initial transitions @xmath507 and a bijection @xmath511 } \\to r$ ] for a set @xmath512 with @xmath513 .",
    "the transition @xmath514 is defined as follows :    * update of subset part : @xmath515 ; * updating breakpoint states : let @xmath516 } \\to r'$ ] be a surjection with @xmath517 defined as @xmath518 for each @xmath519}$ ] ; * minimal acceptance number : let @xmath64 be the minimal integer such that @xmath520 is an accepting transition if such an integer exists , and @xmath521 otherwise ; * removing duplicate breakpoint states : let @xmath522 } \\to r'$ ] be obtained from @xmath523 by replacing , for every @xmath524}$ ] such that @xmath525 and @xmath526 , @xmath527 by @xmath506 ; * minimal rejecting number : let @xmath102 be the minimal integer with @xmath528 if such an integer exists , and @xmath529 otherwise ; * removing blanks : let @xmath530 } \\to r''$ ] be a bijection with @xmath531 where @xmath532 ; @xmath533 is obtained from @xmath534 by removing the @xmath506 signs while preserving the order , that is , if @xmath535 , @xmath536 , and @xmath537 , then @xmath538 ; * restoring transit transitions : @xmath539 } \\to s$ ] is a bijection with @xmath540 for all @xmath541 , @xmath542 , and @xmath543 ; and * transition priority : the priority of this transition @xmath544 is @xmath545 if @xmath546 and @xmath547 if @xmath548 .",
    "note that in the above definition , for @xmath549 the assignment of numbers @xmath550 with @xmath551 to elements of @xmath552 is arbitrary as long as @xmath549 is a bijection .",
    "we denote by @xmath553 the dpa @xmath100 constructed as above from @xmath433 .    given a ngba @xmath37 , we write @xmath451 to denote the automaton @xmath554 and for a state @xmath555 of @xmath100",
    ", we denote by @xmath150 the states reached in @xmath102 , i.e. , @xmath556 .",
    "the parity automaton follows the initial subset part of the semi - deterministic automaton in the part @xmath510 of a state @xmath509 .",
    "it simulates the final breakpoint part via the function @xmath557 that stores the nondeterministic choice of where to start in the breakpoint part by assigning them to the entries @xmath558 while preserving the previous choices .",
    "( -2.55,0.25 ) rectangle ( 11,4.5 ) ;    \\(p ) at ( 0,0 ) ; ( pl ) at ( @xmath559 ) @xmath560 ; ( blank ) at ( @xmath561 ) @xmath562 ; ( xo ) at ( @xmath563 ) @xmath564 ; ( yz1 ) at ( @xmath565 ) @xmath566 ; ( x2 ) at ( @xmath567 ) @xmath568 ; ( yz4 ) at ( @xmath569 ) @xmath570 ; ( x3 ) at ( @xmath571 ) @xmath572 ;    ( blank ) edge[loop above ] node @xmath573 ( blank ) ; ( blank ) to[in=30 , out=60 , distance=5 mm ] node @xmath574 ( blank ) ; ( blank ) edge[loop right , distance=5 mm ] node @xmath575 ( blank ) ;    ( @xmath576 ) to node ( @xmath577 ) ; ( xo ) to node[left ] @xmath573 ( yz1 ) ; ( xo ) to[bend left=15 ] node[above ] @xmath574 ( blank ) ; ( xo ) to[bend right=15 ] node[above ] @xmath575 ( blank ) ;    ( yz1 ) to[bend left=15 ] node[right ]  @xmath578 ( x2 ) ; ( yz1 ) to[bend right=15 ] node[above , near start ] @xmath62 ( blank ) ;    ( x2 ) to[bend left=15 ] node[below ] @xmath573   ( yz1 ) ; ( x2 ) to[bend right=15 ] node[left ] @xmath579 ( blank ) ; ( x2 ) to[bend right=30 ] node[right ] @xmath580 ( blank ) ;    ( yz1 ) to node[below ]  @xmath581 ( x3 ) ;    ( x3 ) to[bend left=15 ] node[above ]  @xmath573 ( yz4 ) ; ( x3 ) .. controls ( @xmath582 ) and ( @xmath583 ) .. node[left , near start ] @xmath62 ( blank ) ;    ( yz4 ) to[bend left=15 ] node[below ] @xmath584   ( x3 ) ; ( yz4 ) to node[above ] @xmath65   ( x2 ) ; ( yz4 ) .. controls ( @xmath585 ) and ( @xmath586 ) .. node[below , near start ] @xmath62 ( blank ) ;    ( table ) at ( 7.5,2.5 )    [ cols=\"^,^,^,^,^\",options=\"header \" , ]     ;    figure  [ fig : exampleparity ] shows the parity automaton @xmath560 obtained by applying the above determinisation to the semi - deterministic automaton @xmath587 depicted in figure  [ fig : examplesemidet ] .",
    "function @xmath588 is completely arbitrary since functions @xmath523 , @xmath534 , and @xmath533 are all the empty function , so let us detail how to obtain the transition from @xmath589 to @xmath590 via action @xmath70 .",
    "table  [ tab : exampleparityfunctions ] shows the functions @xmath523 , @xmath534 , @xmath533 , and @xmath549 we compute and whether @xmath591 is accepting ( i.e. , @xmath592 ) .",
    "as we can see , for the transition from @xmath589 to @xmath590 via action @xmath70 we have that both @xmath64 and @xmath102 have value @xmath593 since @xmath594 and @xmath595 , so the resulting transition has priority @xmath596 as @xmath546 . instead , for the transition from @xmath590 to @xmath589 via action @xmath64 , we have that both @xmath64 and @xmath102 have value @xmath597 since there is no accepting transition and no blank in @xmath598 , so the resulting transition has priority @xmath599 .",
    "note that in @xmath600 only positions @xmath214 and @xmath593 are determined by @xmath601 ; the remaining positions are again arbitrary and having @xmath602 is the result of a deliberate choice . in fact , a different choice would just make the resulting parity automaton larger than @xmath560 while accepting the same language .",
    "consider a word @xmath603 and the associated run @xmath43 : if @xmath604 , then the corresponding run of @xmath560 has @xmath605 as limiting minimum priority since @xmath606 means that there exists @xmath40 such that either @xmath607 , or @xmath608 and @xmath609 , or @xmath610 and @xmath611 , thus the state @xmath562 is reached via the transition @xmath612 .",
    "since @xmath562 enables only self - loops each one with priority @xmath605 , this is also the minimum priority appearing infinitely often . now",
    ", suppose that @xmath613 .",
    "this means that either @xmath614 , or @xmath615 ; in the former case , the automaton repeatedly switches between states @xmath590 and @xmath566 , and in the latter case between states @xmath616 and @xmath570 . in both cases ,",
    "it is immediate to see that the minimum priority appearing infinitely often is @xmath617 that is odd , thus @xmath618 is rejected .",
    "the semi - deterministic construction we presented in definition  [ def : semi - determinisation ] preserves the accepted language , that is , a ngba @xmath37 and the resulting semi - deterministic automaton @xmath471 accept the same language ; moreover , the language accepted by @xmath471 starting from a state @xmath619 depends only on @xmath104 , the subset component .",
    "[ pro : buechilangequalsemidetlang ] given a ngba @xmath37 , let @xmath433 be constructed as above .",
    "then , @xmath620 .",
    "[ pro : semidetlanguageignorebandi ] given a ngba @xmath37 and two states @xmath621 @xmath622 of @xmath471 , @xmath623 .",
    "similarly , for a given ngba @xmath37 , also @xmath437 and the corresponding parity automaton @xmath624 are language equivalent , thus @xmath625 .",
    "[ pro : semidetlangeqparitylang ] given a sdba @xmath433 and @xmath624 , @xmath626 holds .    given a semi - deterministic bchiautomaton @xmath433 , @xmath624 , and a state @xmath509 of @xmath100",
    ", we remark that for @xmath40 we have @xmath627 .",
    "since @xmath433 is semi - deterministic , by definition  [ def : semidetaut ] the reachable fragment of @xmath628 is a deterministic automaton so we can consider the product @xmath629 that is a mc extended with accepting conditions . in particular , the accepting sccs of @xmath452 and @xmath446 are strictly related by the function @xmath557 of states @xmath630 and the smallest priority occurring in the considered scc . in the following ,",
    "we say that @xmath631 ( or @xmath632 ) is accepting if the probability to eventually being trapped into an accepting scc is @xmath214 .",
    "[ lem : parityofsccandacceptingsccofsemidet ] given a sdba @xmath433 and @xmath624 , if @xmath632 forms an scc where the smallest priority of the transitions in the scc is @xmath547 , then @xmath633 is accepting .",
    "it is known by lemma  [ lem : productsubsetisomorphicquotientmc ] that @xmath339 and @xmath459 are strictly related , so we can define the accepting scc of @xmath339 by means of the accepting states of @xmath459 .",
    "[ def : acceptingsccofsubsetapp ] given a mc @xmath0 and a ngba @xmath37 , for @xmath434 and @xmath451 , we say that a bottom scc @xmath14 of @xmath339 is accepting if , and only if , there exists a state @xmath634 in an accepting bottom scc @xmath317 of @xmath459 such that @xmath635 .",
    "note that corollary  [ cor : same ] ensures that the accepting sccs of @xmath339 are well defined .",
    "[ thm : acceptanceofsubsetautomatonapp ] given a mc @xmath0 and a ngba @xmath37 , for @xmath437 and @xmath434 , the following facts are equivalent :    1 .",
    "@xmath14 is an accepting bottom scc of @xmath339 ; 2 .   there exist @xmath438 and @xmath439 such that @xmath440 belongs to an accepting scc of @xmath441 for some @xmath50}$ ] ; 3",
    ".   there exist @xmath438 and @xmath442 such that @xmath443 reaches with probability @xmath214 an accepting scc of @xmath444 .",
    "theorem  [ thm : acceptanceofsubsetautomatonapp ] provides a practical way to check whether an scc @xmath14 of @xmath339 is accepting : it is enough to check whether some state @xmath340 of @xmath14 has @xmath445 for some @xmath440 in the accepting region of @xmath446 , or whether , for a state @xmath442 , @xmath447 reaches with probability @xmath214 the accepting region .",
    "we remark that , by construction of @xmath433 , if we change the initial state of @xmath433 to @xmath448i.e .",
    ", if we consider @xmath449then the run can only visit breakpoint states ; i.e. , it is actually a run of @xmath450 .",
    "[ thm : probabilityviasubsetonlymc ] given a mc @xmath0 and a bchiautomaton @xmath37 , consider @xmath434 and @xmath339 with accepting sccs according to definition  [ def : acceptingsccofsubset ] .",
    "let @xmath274 be the accepting region and let @xmath273 denote the set of paths containing a state of @xmath274 .",
    "then , @xmath636 .",
    "the complexity of the procedure @xmath456 in figure  [ fig : computeacceptingscc ] is @xmath637 , where @xmath17 is the number of states of the bchiautomaton @xmath37 , @xmath18 the number of accepting sets in @xmath638 , and @xmath202 the number of states of the mc @xmath0 .",
    "note that the actual runtime can be improved by caching the positive results of @xmath457 : if @xmath14 is accepting with witness @xmath639 with @xmath442 and @xmath438 , and we have to compute @xmath640 , we can first verify whether there exists @xmath641 such that @xmath642 ; if this is the case , we can immediately return a positive answer without constructing the bchibreakpoint automaton .",
    "the lazy determinisation approach proposed in this paper extends to markov decision processes ( mdps ) after minor adaptation ; markov chains have mainly been used for ease of notation . while the details of the extension to mdps have been moved to appendix  [ app : mdp ]",
    ", we give here an outline of the adaptation with a focus on the differences and particularities that need to be taken into consideration when we are dealing with mdps .",
    "an mdp is a tuple @xmath643 where @xmath196 , @xmath644 , and @xmath198 are as for markov chains , @xmath645 is a finite set of actions , and @xmath646 is the transition probability function where @xmath647 is the set of distributions over @xmath196 .",
    "the nondeterministic choices are resolved by a scheduler @xmath648 that chooses the next action to be executed depending on a finite path .",
    "like for markov chains , the principal technique to analyse mdps against a specification @xmath1 is to construct a deterministic rabin automaton @xmath7 , build the product @xmath8 , and analyse it .",
    "this product will be referred to as a _ rabin mdp _ ( rmdp ) . according to  @xcite , for a rmdp",
    ", it suffices to consider memoryless deterministic schedulers of the form @xmath649 , where @xmath31 is the set of states of @xmath7 . given a ngba specification @xmath6 , we are interested in @xmath650 . in particular , one can use finite memory schedulers on @xmath0 .",
    "( schedulers that control @xmath0 can be used to control @xmath8 for all deterministic automata @xmath7 . )",
    "the superscript @xmath0 is omitted when it is clear from the context .",
    "we remark that the infimum can be treated accordingly , as @xmath651 .    as theorem  [ thm : only_reach ]",
    "operates on the word level , corollary [ cor : same ] immediately extends to mdps . under the corresponding equivalence relation",
    "we obtain a _",
    "quotient mdp_. from here , it is clear that we can use the estimation of the word languages provided in theorem  [ theo : inclusions ] to estimate @xmath652 .",
    "[ cor : mdpestimate ] given an mdp @xmath0 and a ngba @xmath37 , let @xmath202 be a state of @xmath0 and @xmath653 be states of @xmath265 with @xmath412=[d']$ ] .",
    "then @xmath654)}^{{\\upsilon}}({\\mathcal{s}}^{u}_{[d ] } )      \\leq      \\sup_{{\\upsilon}}{\\mathfrak{p}}_{(m,\\langle d \\rangle)}^{{\\upsilon}}({\\mathcal{bp}}^{u}_{\\langle d \\rangle } )      \\leq      \\sup_{{\\upsilon}}{\\mathfrak{p}}_{(m , d)}^{{\\upsilon}}({\\mathcal{a}}_{d } )      =                                                        \\sup_{{\\upsilon}}{\\mathfrak{p}}_{(m , d')}^{{\\upsilon}}({\\mathcal{a}}_{d ' } )          \\leq      \\sup_{{\\upsilon}}{\\mathfrak{p}}_{(m,\\langle d \\rangle)}^{{\\upsilon}}({\\mathcal{bp}}^{o}_{\\langle d \\rangle } ) ,      \\",
    "\\sup_{{\\upsilon}}{\\mathfrak{p}}_{(m,[d])}^{{\\upsilon}}({\\mathcal{s}}^{o}_{[d]})$ ] holds .    in the standard evaluation of rmdp",
    ", the _ end components _ of the product @xmath8 play a role comparable to the one played by bottom sccs in mcs .",
    "an end component ( ec ) is simply a sub - mdp , which is closed in the sense that there exists a memoryless scheduler @xmath648 such that the induced markov chain is a bottom scc .",
    "if there is a scheduler that additionally guarantees that a run that contains all possible transitions infinitely often is accepting , then the ec is _",
    "thus , one can stay in the ec and traverse all of its transitions ( that the scheduler allows ) infinitely often , where acceptance is defined as for bsccs in mcs .",
    "[ thm : acceptanceofsubsetautomatonec ] given an mdp @xmath0 and a ngba @xmath37 , for @xmath265 , @xmath437 , and @xmath434 , if @xmath655 is an accepting ec of @xmath656 , then    @xmath657 $ ] is an ec of @xmath658 and    @xmath659 is an accepting ec of @xmath660 .",
    "@xmath661 contains a state @xmath662 with @xmath663 $ ] and @xmath664 .",
    "note that , since each ec @xmath655 of @xmath8 is either accepting or rejecting , finding an accepting ec @xmath659 of @xmath446 allows us to derive that @xmath655 is accepting as well .    for rmdps",
    ", it suffices to analyse maximal end components ( mec ) .",
    "we define a mec as accepting if it contains an accepting ec .",
    "mecs are easy to construct and , for each accepting pair , they are easy to evaluate : it suffices to remove the rejecting transitions , repeat the construction of mecs on the remainder , and check if there is any that contains an accepting transition .",
    "once accepting mecs are determined , their states are assigned a winning probability of @xmath214 , and evaluating the complete mdp reduces to a maximal reachability analysis , which reduces to solving an lp problem .",
    "it can therefore be solved in polynomial  time .",
    "these two theorems allow us to use a layered approach of lazy determinisation for mdps , which is rather similar to the one described for markov chains .",
    "we start with the quotient mdp , and consider an arbitrary mec @xmath655 . by using the accepting conditions of the subset automata @xmath9 and @xmath10",
    ", we check whether @xmath655 is accepting or rejecting , respectively .",
    "if this test is inconclusive , we first refine @xmath655 by a breakpoint construction , and finally by a multi - breakpoint construction .",
    "we remark that , as for markov chains , the breakpoint and multi - breakpoint constructions can be considered as oracles : when we have identified the accepting mecs , a plain reachability analysis is performed on the quotient mdp .",
    "theorem  [ thm : acceptanceofsubsetautomatonec ] makes clear what needs to be calculated in order to classify an ec  and thus a mec  as accepting , while corollary  [ cor : mdpestimate ] allows for applying this observation in the quantitative analysis of an mdp , and also to smoothly combine this style of reasoning with the lazy approach .",
    "this completes the picture of  @xcite for the quantitative analysis of mdps , which is technically the same as their analysis of concurrent probabilistic programs  @xcite .    in general",
    ", it is possible to compute @xmath665 instead of @xmath650 , and then use @xmath666 . for computing the infimum , we would have to invert the terms : an ec is rejecting , if it is not accepting , and a mec is rejecting , if it contains a rejecting ec .",
    "this detour has a principle computational disadvantage : a witness that an ec is rejecting is more involved than a witness that it is accepting , as it requires to try all combinations of subsets ( see below ) .",
    "we have not implemented this detour . however",
    ", this approach may be worthwhile trying when @xmath2 appears to be better suited for analysis . this could , e.g. , be the case , when @xmath2 is deterministic , or when @xmath667 is significantly smaller than @xmath6 .",
    "given that the construction of @xmath6 and @xmath2 are cheap in practice , it might be worth computing both .",
    "it is worthwhile to point out that , in principle , the qualitative analysis from  @xcite could replace theorem  [ thm : acceptanceofsubsetautomatonec ] when using this detour .",
    "this would imply accepting the computational drawbacks and losing the choice between the two automata to start with .",
    "the techniques from section 4.2 of  @xcite also do not directly allow for analysing mecs only , and some further work would have to be invested to allow for focussing on rejecting mecs , and to facilitate it when using the detour through @xmath2 .",
    "as said before , from a theoretical point of view , to compute @xmath650 it is enough to consider the maximal end components of @xmath668 instead of the bottom sccs as in the markov chain case and then compute the maximal probability to reach the accepting mecs . from the practical point of view ,",
    "the algorithms @xmath669 and @xmath670 shown in figure  [ fig : computeacceptingscc ] can be easily adapted to mdps as follows : in @xmath669 , at line 4 @xmath671 is replaced by @xmath672 that computes the mecs of the product between the mdp @xmath0 and the subset automaton @xmath13 ; in @xmath673 , line 1 has to be replaced by a loop on all @xmath674 since checking the acceptance from a single state of the mec @xmath655 does not suffice .",
    "however , if @xmath283 is known to be not accepting , we can exclude all states that can not avoid reaching @xmath283 , thus the breakpoint construction can be performed on a reduced number of states .",
    "( -8.2,4.6 ) rectangle ( 8.4,0 ) ; ( mdp ) at ( -6,3 )    @xmath0 + @xmath675    ; ( mdpc ) at ( @xmath676 ) ; ( mdp_b ) at ( @xmath677 ) @xmath70 ; ( mdp_c ) at ( @xmath678 ) @xmath63 ; ( mdp_a ) at ( @xmath679 ) @xmath64 ;    ( @xmath680 ) to ( mdp_b.north ) ; ( mdp_b ) to node[above , very near end ] @xmath214 ( mdp_c ) ; ( mdp_c ) to node[above , very near end ] @xmath214 ( mdp_a ) ; ( mdp_a ) to node[below , very near end ] @xmath214 ( mdp_b ) ; ( mdp_a ) edge [ loop right , distance=7 mm ] node [ below , very near end ] @xmath214 ( mdp_a ) ;    ( baut ) at ( -0.25,3 ) @xmath37 ; ( bautc ) at ( @xmath681 ) ; ( baut_x ) at ( @xmath682 ) @xmath56 ; ( baut_y ) at ( @xmath683 ) @xmath58 ;    ( @xmath684 ) to ( baut_x.north ) ; ( baut_x ) to node @xmath64 ( baut_y ) ; ( baut_x ) edge [ loop left , distance=7 mm ] node [ left ] @xmath64 ( baut_x ) ; ( baut_x ) to[in=30 , out=60 , distance=7 mm ] node[right ] @xmath70 ( baut_x ) ; ( baut_x ) to[in=-50 , out=-20 , distance=7 mm ] node[right ] @xmath63 ( baut_x ) ; ( baut_y ) edge [ loop right , distance=7 mm , double ] node [ right ] @xmath64 ( baut_y ) ;    ( mdpss ) at ( 5.5,3 ) @xmath339 ; ( mdpssc ) at ( @xmath685 ) ; ( mdpss_b ) at ( @xmath686 ) @xmath687 ; ( mdpss_c ) at ( @xmath688 ) @xmath689 ; ( mdpss_a ) at ( @xmath690 ) @xmath691 ;    ( @xmath692 ) to ( mdpss_b.north ) ; ( mdpss_b ) to[above , very near end ] node @xmath214 ( mdpss_c ) ; ( mdpss_c ) to[above , very near end ] node @xmath214 ( mdpss_a ) ; ( mdpss_a ) to[below , very near end ] node @xmath214 ( mdpss_b ) ; ( mdpss_a ) edge [ loop above , distance=7 mm ] node [ right , very near end ] @xmath214 ( mdpss_a ) ;    ( mdpbp ) at ( -1,-0.2 ) ; ( mdpbpl ) at ( @xmath693 ) @xmath463 ; ( mdpbpc ) at ( @xmath694 ) ;    ( mdpbp_b_x _ ) at ( @xmath695 ) @xmath398 ; ( mdpbp_c_x _ ) at ( @xmath696 ) @xmath697 ; ( mdpbp_a_xy _ ) at ( @xmath698 ) @xmath699 ; ( mdpbp_a_xy_y ) at ( @xmath700 ) @xmath701 ; ( mdpbp_a_y _ ) at ( @xmath702 ) @xmath703 ; ( mdpbp_a_x _ ) at ( @xmath704 ) @xmath705 ;    ( mdpbp_b_x _ ) to node[above , very near end ] @xmath214 ( mdpbp_c_x _ ) ; ( mdpbp_c_x _ ) to node[above , very near end ] @xmath214 ( mdpbp_a_xy _ ) ; ( mdpbp_a_xy _ ) to node[above , very near end ] @xmath214 ( mdpbp_a_xy_y ) ; ( mdpbp_a_xy _ ) .. controls ( @xmath706 ) and ( @xmath707 ) .. node [ below , very near end ] @xmath214 ( mdpbp_b_x _ ) ; ( mdpbp_a_xy_y ) edge [ loop above , distance=7 mm ] node [ right , very near end ] @xmath214 ( mdpbp_a_xy_y ) ; ( mdpbp_a_xy_y ) .. controls ( @xmath708 ) and ( @xmath709 ) .. ( @xmath710 ) ; ( @xmath710 ) .. controls ( @xmath711 ) and ( @xmath712 ) .. node [ below , very near end ] @xmath214 ( mdpbp_b_x _ ) ; ( mdpbp_a_x _ ) to[bend right=10 ] node[above , very near end ] @xmath214 ( mdpbp_b_x _ ) ; ( mdpbp_a_x _ ) to[bend left=10 ] node[right , very near end ] @xmath214 ( mdpbp_a_xy _ ) ; ( mdpbp_a_y _ ) edge [ loop above , distance=7mm , double ] node [ right , very near end ] @xmath214 ( mdpbp_a_y _ ) ;    for mdps , differently from the subset and breakpoint construction , for the multi - breakpoint case testing only one @xmath713 in general is not sufficient ; consider the mdp @xmath0 and the ngba @xmath37 depicted in figure  [ fig : examplemdps ] .",
    "we first consider the product mdp @xmath339 , containing one mec .",
    "we first try to decide whether it is accepting by considering the state @xmath714 .",
    "the only nonempty subset of @xmath328 is the set itself , thus we look for accepting mecs in @xmath715 .",
    "it is clear that from @xmath716 no accepting mecs can be reached .",
    "in contrast to the mc setting , we can not conclude that the original mec is not accepting .",
    "instead , we remove @xmath714 from the set of states to consider , as well as @xmath717 , from which we can not avoid reaching @xmath714 .",
    "the state left to try is @xmath718 , where we have two transitions available .",
    "indeed , in @xmath463 the singleton mec @xmath719 is accepting .",
    "thus the mec of @xmath339 is accepting , though only one of its states@xmath720allows us to conclude this , and we need to select the correct subset , @xmath721 , to start with .      right30 mm    ( -1,0 ) rectangle ( 1,1 ) ;    \\(m ) at ( 0,0 ) @xmath206 ; ( m0 ) at ( @xmath764 ) @xmath765 ; ( m1 ) at ( @xmath766 ) @xmath767 ;    ( @xmath768 ) to node ( m0.north ) ; ( m0 ) to[bend left=15 ] node[above , very near end ] @xmath214 ( m1 ) ; ( m1 ) to[bend left=15 ] node[below , very near end ] @xmath214 ( m0 ) ; ( m1 ) edge[loop below , distance=7 mm ] node[left]@xmath214 ( m1 ) ;    in this section , we give more details on how we evaluate mdps .",
    "let @xmath643 be an mdp .",
    "figure  [ fig : examplemdp ] shows an example of an mdp ; the labels of the states are in superscript and we omit the actions of the transitions .",
    "we recall the computation of the probability @xmath652 where @xmath769 is a deterministic scheduler , based on  ( * ? ? ?",
    "* lemma 10.125 ) but adapted to the accepting condition on transitions instead of on states .",
    "let @xmath770 denote the deterministic rabin automaton for @xmath6 .      as for mc , we have to define products of mdp with deterministic automata .",
    "we first define the product mdp and then the product automata and finally the quotient mdp .",
    "given an mdp @xmath643 and a deterministic automaton @xmath230 , the product mdp is defined by @xmath771 where    * @xmath772 ; * @xmath773 if @xmath234 , and @xmath235 otherwise ; and * @xmath774 equals @xmath775 if @xmath238 , and is @xmath235 otherwise .",
    "we recall that @xmath776 means @xmath777 and we define @xmath778 to be the projection on @xmath7 of the given @xmath779 , i.e. , @xmath780 .",
    "( -4,-0.25 ) rectangle ( 4.75,4 ) ; ( b ) at ( -2.5,0 ) @xmath54 ; ( ms ) at ( 2.5,0 ) @xmath345 ;    ( b0 ) at ( @xmath781 ) @xmath782 ; ( b1 ) at ( @xmath783 ) @xmath784 ; ( @xmath785 ) to node ( b0 ) ; ( b0 ) edge[loop above , distance=7 mm ] node[above ] @xmath786 ( b0 ) ; ( b0 ) to node[above ] @xmath64 ( b1 ) ; ( b1 ) edge[loop above , double , distance=7 mm ] node[above ] @xmath64 ( b1 ) ; ( b1 ) edge[loop right , distance=7 mm ] node[above ] @xmath787 ( b1 ) ;    ( p0 ) at ( @xmath788 ) @xmath789 ; ( mec ) at ( @xmath790 ) ; ( p1 ) at ( @xmath791 ) @xmath792 ; ( p2 ) at ( @xmath793 ) @xmath794 ;    ( p0 ) to[bend left=15 ] node[above , near end ] @xmath214 ( p1 ) ; ( p1 ) to[bend left=15 ] node[right , near end ] @xmath214 ( p2 ) ; ( p1 ) edge[loop above , distance=7 mm ] node[right , near end ] @xmath214 ( p1 ) ; ( p2 ) to[bend left=15 ] node[left , near end ] @xmath214 ( p1 ) ;    figure  [ fig : examplemdptimessubset ] shows in the left hand side a bchiautomaton whose language contains all words from @xmath795 where @xmath64 occurs infinitely often ; the labels @xmath786 and @xmath787 are shortcuts for all labels in @xmath21 and in @xmath796 , respectively .",
    "this means , for instance , that if @xmath797 , then @xmath782 has two transitions with label @xmath64 and @xmath70 , respectively , to @xmath782 itself .",
    "the right hand side of figure  [ fig : examplemdptimessubset ] shows the product mdp between @xmath206 in figure  [ fig : examplemdp ] and the subset construction @xmath326 of @xmath54 .",
    "the dashed box encloses a maximal end component we will formally define later ; intuitively , a maximal end component is the mdp counterpart of a bottom scc of a markov chain .    given an mdp @xmath643 and a deterministic automaton @xmath230 , the product automaton is defined by @xmath245 where    * if @xmath798}\\,\\}}$ ] , then @xmath799}\\,\\}}$ ] where @xmath800 and @xmath801 ( rabin markov decision process , rmdp ) ; * if @xmath253}$ ] , then @xmath254}$ ] where @xmath802 for each @xmath776 ( parity markov decision process , pmdp ) ; or * if @xmath803}\\,\\}}$ ] , then @xmath804}\\,\\}}$ ] where @xmath805 ( generalised bchimarkov decision process , gmdp ) .    given an mdp @xmath0 and a dra @xmath265 , the _ quotient mdp _ @xmath303 $ ] is the mdp @xmath305 , [ { l } ] , { \\mathit{act } } , [ { \\mu_{0 } } ] , [ { { \\mathrm{p}}}])$ ] where    * @xmath306 = { \\{\\ , ( m,[d ] ) \\mid ( m , d ) \\in { m}\\times { q},\\ [ d ] = { \\{\\ , d ' \\in { q}\\mid { \\mathsf{rchd}}(d ' ) = { \\mathsf{rchd}}(d ) \\,\\ } } \\,\\}}$ ] , * @xmath307(m,[d ] ) = { l}(m , d)$ ] , * @xmath308(m,[d ] ) = { \\mu_{0}}(m , d)$ ] , and * @xmath309\\big((m,[d ] ) , a , ( m',[d'])\\big ) = { { \\mathrm{p}}}\\big((m , d ) , a , ( m',d')\\big)$ ] .    as for the quotient mc , the quotient mdp is again well defined : it is immediate to see that @xmath313 $ ] and that for each @xmath314 $ ] and each @xmath806 , it holds @xmath807)\\big ) = { { \\mathrm{p}}}\\big((m , d ) , a , ( m ' , d')\\big ) = { { \\mathrm{p}}}\\big((m , d_{2 } ) , a , ( m ' , [ d'])\\big)$ ] .      for the reader s convenience , we recall the reduction of @xmath808 to probabilistic reachability in the rmdp @xmath8 .    first , we introduce some concept and corresponding notation , starting with the concept of maximal end component ( mec ) that is the mdp counterpart of the scc for a mc ; the formal definition is not so immediate as we have to take care of the role of the actions .    given an mdp @xmath643 ,    a sub - mdp is a pair @xmath809 such that @xmath810 and @xmath811 satisfying :    @xmath812 for each @xmath813 where @xmath814 denotes the enabled actions of @xmath815 , and    @xmath816 and @xmath817 implies @xmath818 .",
    "an _ end component _ of @xmath0 is a sub - mdp @xmath809 such that the digraph induced by @xmath809 is strongly connected .",
    "an end component @xmath819 is a _",
    "maximal end component _ ( mec ) if it is not contained in some other end component @xmath820 with @xmath821 and @xmath822 for all @xmath816 .    as for sccs",
    ", we define the transitions @xmath823 of the mec @xmath819 of the mdp @xmath0 as @xmath824 .",
    "given an mdp @xmath0 and a dra @xmath265 , let @xmath655 be a mec of the product rmdp @xmath8 .",
    "we say that @xmath655 is accepting if there exists an index @xmath87}$ ] such that @xmath825 and @xmath826 .",
    "note that theorem  [ thm : bottom_component ] and corollary  [ cor : quotients ] extend easily to the mecs of the quotient mdp and to accepting mecs of the product automaton , respectively .",
    "we now describe how to simplify the identification of the accepting mecs . given an mdp @xmath0 ,",
    "we first define a sub - mdp restricting to a subset of transitions @xmath827 .",
    "let @xmath828 denote the sub - mdp with transition space @xmath829 .",
    "moreover , let @xmath830 be the completion of the set @xmath829 , i.e. , @xmath831 .    with these notations , we recall that the computation of the probability @xmath832 can be reduced to a reachability probability :    * for a rabin pair @xmath833 , define @xmath834 such that @xmath835 if there exists a mec @xmath819 in @xmath836 such that @xmath837 and @xmath838 . in this case",
    "we say @xmath202 is accepting with respect to @xmath833 .",
    "note that if @xmath202 is accepting , then all states in @xmath839 are accepting as well , thus @xmath840 .",
    "* let @xmath841 } } u_{({{\\mathrm{a}}}_{i } , { { \\mathrm{r}}}_{i})}$ ] be the accepting region and @xmath265 . then , @xmath842 reduces to a probabilistic reachability : @xmath843    obviously , if a mec @xmath809 contains a state @xmath844 from the accepting region , then the probability of accepting the language of @xmath6 is the same for all of them , so it does not matter the particular state @xmath845 we reach when we enter @xmath809 .",
    "as argued in the body of the paper , the likelihood @xmath846 does not depend on @xmath102 itself , but only on @xmath412 $ ] .",
    "together with the observations from corollary  [ cor : mdpestimate ] , we can therefore follow the principle layered approach . as for markov chains",
    ", we can use the results from the previous layers to avoid parts of the construction .",
    "the incremental evaluation is described in details as follows .",
    "construct the quotient mdp @xmath337 ( which is the same as @xmath338 except the accepting conditions ) .",
    "for each mec @xmath655 , evaluate as follows :    1 .",
    "similar to lemma  [ lem : subset ] for markov chains , @xmath655 is accepting if @xmath655 contains some accepting transition @xmath847 with @xmath848 for each @xmath87}$ ] ; @xmath655 is rejecting if @xmath655 does not contain transitions @xmath847 with @xmath849 for some @xmath87}$ ] .",
    "2 .   if we could neither establish that @xmath655 is accepting nor that @xmath655 is rejecting , we refine @xmath655 by a breakpoint construction ( only for this mec ) .",
    "let @xmath850 , @xmath851 denote the breakpoint automata for @xmath655 ( again , the difference is only reflected by the accepting conditions ) .",
    "+ these rmdps are to be read as the mdps that exist if one expands the mdp restricted to @xmath655 .",
    "let @xmath661 be an arbitrary mec in the resulting breakpoint automata ; we recall that the rabin pairs for @xmath281 and @xmath280 are @xmath852 and @xmath853 , respectively .",
    "@xmath661 is accepting if @xmath661 contains some accepting transition @xmath847 with @xmath854 , i.e. , it is accepted by @xmath280 .",
    "otherwise , @xmath855 is for sure rejecting if it is rejected by @xmath281 , i.e. , there exists @xmath856 with @xmath857 .",
    "4 .   if @xmath655 remains inconclusive , we finally evaluate the mecs of @xmath8 .",
    "for this , we follow a similar procedure as for the breakpoints . in particular",
    ", it suffices to refine the mecs individually .    after the above procedure",
    ", we make accepting mecs in the quotient mdp absorbing , whereas non - accepting mecs are untouched .",
    "we remark that a mec can not be accepting if it contains a state @xmath858 such that @xmath859 has been established by a previous estimation . as a final step ,",
    "a probabilistic reachability analysis  through solving a linear programming problem  is needed for the evaluation .",
    "note that this can always be performed on the quotient mdp .",
    "( -3,0 ) rectangle ( 3,3 ) ;    ( mr ) at ( 0,0 ) @xmath860 ;    ( p0 ) at ( @xmath861 ) @xmath862 ; ( p0t0 ) at ( @xmath863 ) @xmath864 ; at ( @xmath865 ) ; ( p0 ) edge[loop above , distance=7 mm ] node[right , very near end ] @xmath214 ( p0 ) ;    ( @xmath866 ) to node ( p0.south ) ;    ( p1 ) at ( @xmath867 ) @xmath868 ; ( p1t0 ) at ( @xmath869 ) @xmath870 ;    ( mec ) at ( @xmath871 ) ; ( p2 ) at ( @xmath872 ) @xmath873 ; ( p2t0 ) at ( @xmath874 ) @xmath870 ;    ( p3 ) at ( @xmath875 ) @xmath876 ; ( p3t0 ) at ( @xmath877 ) @xmath870 ; ( p3t1 ) at ( @xmath878 ) @xmath879 ; ( p3t0 ) to node ( p3t1 ) ;    ( p0 ) to node[above , near end ] @xmath214 ( p1 ) ;    ( p1 ) to node[above , near end ] @xmath214 ( p2 ) ;    ( p2 ) to[bend left=15 ] node[above , near end ] @xmath214 ( p3 ) ;    ( p3 ) to[bend left=15 ] node[below , near end ] @xmath214 ( p2 ) ;    figure  [ fig : examplemdptimesrabin ] shows the product automaton of @xmath206 and @xmath880 , i.e. , the rmdp obtained with the dra corresponding to @xmath54 depicted in figure  [ fig : examplemdptimessubset ] .",
    "this example is particularly interesting since it remarks that finding a rejecting mec is inconclusive .",
    "in fact , consider the mec enclosed in the left hand dashed box of the product automaton .",
    "this mec is rejecting but we can not conclude that the language of the product automaton is empty since there is another scheduler that eventually leaves such mec reaching the right hand mec that is indeed accepting , since it contains an accepting transition , depicted with the double arrow .",
    "we have implemented our approach in our iscasmctool  @xcite in both explicit and bdd - based symbolic versions .",
    "we use ltl formulas to specify properties , and apply spot  @xcite to translate them to ngbas .",
    "our experimental results suggest that our technique provides a practical approach for checking ltl properties for probabilistic systems .",
    "a web interface to iscasmccan be found at http://iscasmc.ios.ac.cn/. for our experiments , we used a 3.6 ghz intel core i7 - 4790 with 16 gb 1600 mhz ddr3 ram .",
    "we consider a model  @xcite of a distributed file server system used by google in the prismmodel version of  @xcite .",
    "this model is a continuous - time markov chain , but we can apply our methods on its embedded ( discrete time ) mc .    [ width=60 mm , height=50 mm , title=    average runtimes ( google file server )    ] table[meta = label ] x y label 5 6.55 prism 6 6.6 prism 7 9.74 prism 8 3.96 prism 9 9.75 prism 10 12.99 prism 11 15.87 prism 12 28.07 prism 13 10.19 prism 14 28.25 prism 15 40.74 prism 16 52.08 prism 17 54.92 prism 18 64.53 prism 19 76.59 prism 20 79.71 prism 21 115.09 prism 22 93.9 prism 23 107.1 prism 24 140.73 prism 25 150.28 prism 26 133.26 prism 27 174.03 prism 28 170.21 prism 29 164.62 prism 30 193.98 prism ; table[meta = label ] x y label 5 1.64 iscasmc 6 7.64 iscasmc 7 1.64 iscasmc 8 1.77 iscasmc 9 1.84 iscasmc 10 1.88 iscasmc 11 1.86 iscasmc 12 5.05 iscasmc 13 1.99 iscasmc 14 2.13 iscasmc 15 2.12 iscasmc 16 2.04 iscasmc 17 2.68 iscasmc 18 2.32 iscasmc 19 6.36 iscasmc 20 8.21 iscasmc 21 2.54 iscasmc 22 2.94 iscasmc 23 6.34 iscasmc 24 8.76 iscasmc 25 10.3 iscasmc 26 4.95 iscasmc 27 8.29 iscasmc 28 11.67 iscasmc 29 9.11 iscasmc 30 12.54 iscasmc ;       [ width=60 mm , height=50 mm , title=    average runtimes ( mutual exclusion )    ] table[meta = label ] x y label 5 11.51 prism 6 18.28 prism 7 27.07 prism 8 25.22 prism 9 22.84 prism 10 26.2 prism 11 26.22 prism 12 34.28 prism 13 33.26 prism 14 41.3 prism 15 50.48 prism 16 65.57 prism 17 86.71 prism 18 86.62 prism 19 86.42 prism 20 84.3 prism 21 108.63 prism 22 102.33 prism 23 153.44 prism 24 134.03 prism 25 175.07 prism 26 128.92 prism 27 180.07 prism 28 160.48 prism 29 182.4 prism 30 190.28 prism ; table[meta = label ] x y label 5 2.19 iscasmc 6 6.1 iscasmc 7 9.74 iscasmc 8 8.12 iscasmc 9 2.6 iscasmc 10 5.37 iscasmc 11 5.9 iscasmc 12 13.08 iscasmc 13 6.99 iscasmc 14 3.66 iscasmc 15 8.15 iscasmc 16 11.58 iscasmc 17 8.67 iscasmc 18 13.9 iscasmc 19 19.4 iscasmc 20 12.35 iscasmc 21 9.9 iscasmc 22 21.16 iscasmc 23 25.68 iscasmc 24 11.3 iscasmc 25 15.51 iscasmc 26 22.15 iscasmc 27 27.05 iscasmc 28 22.3 iscasmc 29 22.93 iscasmc 30 34.51 iscasmc ;       at ( 0,0 ) ; at ( 0,-0.5 ) ; at ( 0,-2 ) ;    to estimate the scalability of our approach , we have applied it on increasingly larger formulas . for this , we have applied spotto generate 100 random formulas for each formula size from 2 to 30 based on the atomic propositions of  @xcite . on these formulas we have then applied our model checker as well as prism .",
    "we used a timeout of 5 minutes and represent model checking runs which timed out as if they were performed in 5 minutes . in the left part of figure  [ fig : random ]",
    "we plot the averages of the different runs for both tools ( blue `` @xmath722 '' for prismand red `` @xmath723 '' for iscasmc ) . as shown , iscasmcis very close to prismfor smaller formula sizes and its relative performance improves for larger ones .",
    "unfortunately , we were not able to compare our approach with rabinizer  3  @xcite , because the tool failed in the considered random formulas , such that we could not produce a plot .",
    "the problem seems to be caused by a preprocessing step on the formula before translating it to an automaton .",
    "next , we consider a mutual exclusion protocol  @xcite ( with four processes ) which is an mdp . again , we consider random formulas of given lengths .",
    "as seen in the right part of figure  [ fig : random ] , the general picture is similar to the previous case .    as a second case study",
    ", we consider a set of properties analysed previously in  @xcite .",
    "as there , we aborted tool runs when they took more than 30 minutes or needed more than 4 gb of ram .",
    "the comparison with the results from  @xcite can not be completely accurate : unfortunately , their implementation is not available on request to the authors , and for their results they did not state the exact speed of the machine used . by comparing",
    "the runtimes stated for prismin  @xcite with the corresponding runtimes we obtained on our machine , we estimate that our machine is faster than theirs by about a factor of 1.6 .",
    "thus , we have included the values from  @xcite divided by 1.6 to take into account the estimated effect of the machine .    in table",
    "[ tab : mutual ] we provide the results obtained . here ,",
    "`` property '' and `` n '' are as in  @xcite and depict the property and the size of the model under consideration .",
    "we report the total runtime in seconds ( `` time '' ) for the explicit - state ( `` bp expl . '' ) and the bdd - based symbolic ( `` bp bdd '' ) implementations of the multi - breakpoint construction , as well as the explicit and symbolic ( `` rb expl . '' , `` rb bdd '' ) of the rabin - based implementation . in both bp and rb cases ,",
    "we first apply the subset and breakpoint steps .",
    "we also include the runtimes of prism(``prism '' ) and of the tool used in  @xcite ( `` scaled  @xcite '' ) developed for a subclass of ltl formulas and its generalisation to full ltl  @xcite implemented in rabinizer  3  @xcite ( `` rabinizer  3 '' , for which we thank the authors for providing the source code ) .",
    "we mark the best running times ( obtained by rounding the actual times ) with bold font .",
    "the runtime of our new approaches is almost always better than the running time of other methods . in many cases ,",
    "the multi - breakpoint approach performs better than new the rabin - based approach ( restricted to the single undecided end component ) , but not always . broadly speaking",
    ", this can happen when the breakpoint construction has to consider many subsets as starting points for one end component , while the rabin determinisation does not lead to a significant overhead compared to the breakpoint construction .",
    "( e.g. , when the history trees have at most three or four nodes . ) thus , both methods are of value .",
    "both of them are faster than the specialised algorithm of  @xcite and rabinizer  3 .",
    "we assume that one reason for this is that this method is not based on the evaluation of end components in the subset product , and also its implementation might not involve some of the optimisations we apply . in most cases ,",
    "the explicit - state implementation is faster than the bdd - based approach , which is , however , more memory - efficient .",
    "ldddddd & + & & & & & & + ( r2pt)1 - 1 ( lr)2 - 7 @xmath724 & * 2 * & * 2 * & * 2 * & * 2 * & 6 & 25 + @xmath725 & * 2 * & 3 & * 2 * & 3 & 23 & 121 + @xmath726 & * 3 * & 4 & * 3 * & 4 & 95 & 686 + @xmath727 & * 4 * & 5 & * 4 * & 5 & & + @xmath728 & * 7 * & 8 & * 7 * & 8 & & + @xmath729 & * 7 * & 9 & * 7 * & 9 & & + @xmath730 & * 1 * & * 1 * & * 1 * & * 1 * & 2 & * 1 * + @xmath731 & * 1 * & * 1 * & * 1 * & * 1 * & 48 & * 1 * + @xmath732 & 2 & * 1 * & * 1 * & * 1 * & & 2 + @xmath733 & * 1 * & * 1 * & * 1 * & 2 & & 14 + @xmath734 & * 1 * & * 1 * & * 1 * & * 1 * & & 177 + @xmath735 & * 2 * & * 2 * & * 2 * & * 2 * & & + @xmath736 & * 1 * & * 1 * & * 1 * & 2 & 2 & * 1 * + @xmath737 & * 1 * & * 1 * & 2 & 3 & 233 & * 1 * + @xmath738 & * 1 * & * 1 * & 2 & 3 & & 2 + @xmath739 & * 1 * & 2 & * 1 * & 2 & & 14 + @xmath740 & * 2 * & * 2 * & * 2 * & 4 & & 180 + @xmath741 & * 3 * & * 3 * & * 3 * & 6 & & +    as third case study , we consider a model  @xcite of two clusters of @xmath742 workstations each , so that the two clusters are connected by a backbone",
    ". each of the workstations may fail with a given rate , as may the backbone . though this case study is a continuous - time markov chain , we focused on time - unbounded properties , such that we could use discrete - time markov chains to analyse them .",
    "we give the results in table  [ tab : cluster ] , where the meaning of the columns is as for the mutual exclusion case in table  [ tab : mutual ] .",
    "as before , we mark the best ( rounded ) running times with bold font .",
    "the properties @xmath743 are probabilities of the event of component failures with respect to the order ( first @xmath18 failures on left before right ) while @xmath744 and @xmath745 describe the long - run number of workstations functional . as clearly shown from the results in the table , iscasmcoutperforms prismand rabinizer  3all cases , in particular for large pltl formulas .",
    "it is worthwhile to analyse in details the three properties and how they have been checked : for the @xmath743 case , the subset construction suffices and returns a ( rounded ) probability value of @xmath746 ; for @xmath744 , the breakpoint construction is enough to determine that the property holds with probability @xmath235 .",
    "this explains why the bp and rb columns are essentially the same ( we remark that the reported times are the rounded actual runtimes ) .",
    "property @xmath745 , instead , requires to use the multi - breakpoint or the safra - based construction to complete the model checking analysis and obtaining a probability value of @xmath214 .",
    "lcdddd & & + & & & & & + ( r2pt)1 - 2 ( lr)3 - 6 & 10 & * 1 * & 2 & 56 & 360 + & 11 & * 1 * & 4 & 56 & 359 + & 12 & * 2 * & 7 & 56 & 360 + & 13 & * 3 * & 14 & 57 & 361 + & 14 & * 4 * & 29 & 56 & 363 + & 15 & * 6 * & 71 & 59 & 364 + & 10 & * 1 * & 2 & & + & 11 & * 2 * & 4 & & + & 12 & * 2 * & 7 & & + & 13 & * 3 * & 14 & & + & 14 & * 4 * & 31 & & + & 15 & * 6 * & 72 & & + & 10 & * 1 * & 2 & & + & 11 & * 2 * & 4 & & + & 12 & * 2 * & 7 & & + & 13 & * 3 * & 14 & & + & 14 & * 4 * & 30 & & + & 15 & * 7 * & 69 & & +    finally , as fourth case study , we consider a self - stabilising protocol originally proposed by israeli and jalfon @xcite ; as our prismmodel , we consider the one adopted in @xcite .",
    "the model is parametric in the number @xmath17 of participants . for this case study , we analyse three instances of the pltl formula @xmath747\\ ] ] providing a statement about the number of tokens still existing during the executing of the self - stabilising algorithm . in table",
    "[ tab : ij ] we provide performance comparisms for @xmath748 .",
    "iscasmcwas able to decide all properties by the subset criterion , such that applying breakpoint , multi - breakpoint , or safra determinisation was not necessary .",
    "therefore , we only provide two entries for the iscasmcexplicit ( `` iscasmcexpl . '' ) and symbolic ( `` iscasmcbdd '' ) implementation . from the results ,",
    "it is clear that the explicit version of iscasmc , by using the subset criterion , outperforms both prismand rabinizer  3 ; if we consider the symbolic version , iscasmcbdd is always faster than rabinizer  3and only in one case ( @xmath749 , @xmath750 ) it is slower than prism . by analysing the causes that made prismfail in all cases for @xmath751 and @xmath752",
    ", we find that the construction of the dra for the given formula took too long or too much memory , such that prismfailed before even starting to construct the product of the model and the rabin automaton .",
    "it is interesting to observe , together with the runtimes for the mutual exclusion protocol shown in table  [ tab : mutual ] and the runtimes for the workstation cluster shown in table  [ tab : cluster ] , how rabinizer  3performs much better on formulas involving mainly the nested @xmath753 operators than the @xmath754 operator .",
    "this seems to be caused by the master - slave automata construction underlying rabinizer  3(cf .",
    "@xcite ) : given an ltl formula @xmath1 , let @xmath755 , ",
    ", @xmath756 be ltl formulas such that for each @xmath757 , @xmath758 is a sub - formula of @xmath1 , occurring in the scope of an @xmath759 temporal operator .",
    "for instance , for @xmath760 , examples of such formulas are @xmath761 , @xmath762 and @xmath763 .",
    "checking whether a subformula @xmath758 finally holds , i.e. , it occurs in the scope of @xmath759 , is delegated to a slave automaton , while the remaining tasks are directly managed by the master automaton . for the formula @xmath1 ,",
    "three slaves are created , one for each formula @xmath758 .",
    "this means that a formula like @xmath744 and @xmath745 can be split among multiple slaves , while a formula like @xmath743 is essentially managed by a single automaton , thus taking no advantage from the master - slave construction",
    ".    10    t.  babiak , m.  kretnsk , v.  rehk , and j.  strejcek .",
    "to bchi automata translation : fast and more deterministic . in _",
    "volume 7214 of _ lncs _ , pages 95109 , 2012 .    c.  baier , e.  m. hahn , b.  r. haverkort , h.  hermanns , and j .-",
    "model checking for performability .",
    ", 23(4):751795 , 2013 .    c.  baier and j .- p .",
    "mit press , 2008 .",
    "j.  barnat , l.  brim , i.  cern , m.  ceska , and j.  tumova . :",
    "multi - core ltl model checker for probabilistic systems . in _",
    "qest _ , pages 7778 , 2008 .",
    "m.  benedikt , r.  lenhardt , and j.  worrell .",
    "model checking of interval markov chains . in _",
    "tacas _ , pages 3246 , 2013 .",
    "a.  bianco and l.  de  alfaro .",
    "model checking of probabalistic and nondeterministic systems . in _",
    "volume 1026 of _ lncs _ , pages 499513 , 1995 .",
    "k.  chatterjee , a.  gaiser , and j.  kretnsk .",
    "automata with generalized rabin pairs for probabilistic model checking and ltl synthesis . in _ cav",
    "_ , volume 8044 of _ lncs _ , pages 559575 , 2013 .",
    "f.  ciesinski and c.  baier . : a tool for qualitative and quantitative linear time analysis of reactive systems . in _",
    "qest _ , pages 131132 , 2006 .",
    "e.  m. clarke , m.  fujita , and x.  zhao .",
    "multi - terminal binary decision diagrams and hybrid decision diagrams . in _ representations of discrete functions _ , pages 93108 . 1996 .",
    "l.  cloth and b.  r. haverkort .",
    "model checking for survivability . in _ qest _ , pages 145154 , 2005 .    c.  courcoubetis and m.  yannakakis .",
    "the complexity of probabilistic verification .",
    ", 42(4):857907 , 1995 .",
    "l.  de  alfaro . .",
    "phd thesis , stanford university , 1997 .",
    "l.  de  alfaro , m.  kwiatkowska , g.  norman , d.  parker , and r.  segala .",
    "symbolic model checking of probabilistic processes using mtbdds and the kronecker representation . in _ tacas _ ,",
    "volume 1785 of _ lncs _ , pages 395410 , 2000 .",
    "a.  duret - lutz .",
    "translation improvements in spot . in _ vecos _ , pages 7283 , 2011 .",
    "j.  esparza and j.  kretnsk . from ltl to deterministic automata : a safraless compositional approach . in _ cav",
    "_ , volume 8559 of _ lncs _ , pages 192208 , 2014 .",
    "r.  gentilini , c.  piazza , and a.  policriti . computing strongly connected components in a linear number of symbolic steps . in _ soda _ ,",
    "pages 573582 , 2003 .",
    "e.  m. hahn , y.  li , s.  schewe , a.  turrini , and l.  zhang .",
    "iscasmc : a web - based probabilistic model checker . in _ fm 2014 _ ,",
    "volume 8442 of _ lncs _ , pages 312317 , 2014 .",
    "h.  hansson and b.  jonsson . a logic for reasoning about time and reliability .",
    ", 6(5):512535 , 1994 .",
    "b.  r. haverkort , h.  hermanns , and j .-",
    "katoen . on the use of model checking techniques for dependability evaluation . in _ srds _ , pages 228237 , 2000 .",
    "a.  israeli and m.  jalfon .",
    "token management schemes and random walks yield self - stabilizating mutual exclusion . in _ podc _ , pages 119131 .",
    "acm , 1990 .",
    "d.  khler and t.  wilke .",
    "complementation , disambiguation , and determinization of bchi automata unified . in _ proceedings of the 35th international colloquium on automata , languages and programming , part i ( icalp 2008 ) , 613 july , reykjavik , iceland _ , volume 5125 of _ lncs _ , pages 724735 .",
    "springer , 2008 .",
    "z.  komrkov and j.  kretnsk .",
    "rabinizer 3 : safraless translation of ltl to small deterministic automata . in _ atva _ , volume 8837 of _ lncs _ , pages 235241 , 2014 .",
    "o.  kupferman , n.  piterman , and m.  vardi .",
    "safraless compositional synthesis . in _ cav",
    "_ , volume 4144 of _ lncs _ , pages 3144 , 2006 .",
    "m.  kwiatkowska , g.  norman , and d.  parker . 4.0 : verification of probabilistic real - time systems . in _ cav",
    "_ , volume 6806 of _ lncs _ , pages 585591 , 2011 .",
    "m.  kwiatkowska , g.  norman , and d.  parker .",
    "probabilistic verification of herman s self - stabilisation algorithm .",
    ", 24(4):661670 , 2012 .    c.  y. lee .",
    "representation of switching circuits by binary - decision programs .",
    ", 38(4):985999 , 1959 .",
    "a.  morgenstern , k.  schneider , and s.  lamberti .",
    "generating deterministic @xmath19-automata for most ltl formulas by the breakpoint construction . in _ mbmv _ , pages 119128 , 2008 .",
    "d.  e. muller and p.  e. schupp . simulating alternating tree automata by nondeterministic automata : new results and new proofs of the theorems of rabin , mcnaughton and safra . , 141(1 - 2):69107 , 1995 .",
    "n.  piterman . from nondeterministic bchi and streett automata to deterministic parity automata . , 3(3:5 ) , 2007 .",
    "a.  pnueli and l.  d. zuck .",
    "verification of multiprocess probabilistic protocols .",
    "1(1):5372 , 1986 .    s.  safra . on the complexity of @xmath19-automata . in _",
    "focs _ , pages 319327 , 1988 .",
    "s.  schewe .",
    "tighter bounds for the determinisation of bchi automata . in _ fossacs _ ,",
    "volume 5504 of _ lncs _ , pages 167181 , 2009 .",
    "s.  schewe and t.  varghese .",
    "tight bounds for the determinisation and complementation of generalised bchi automata . in _ atva _ , volume 7561 of _ lncs _ , pages 4256 , 2012 .",
    "m.  y. vardi and p.  wolper .",
    "an automata - theoretic approach to automatic program verification ( preliminary report ) . in _ lics _ , pages 332344 , 1986 .",
    "binary decision diagrams ( bdds )  @xcite are a well - known mechanism to represent binary functions @xmath881 ( where @xmath882 is the boolean set and @xmath883 means @xmath884 ) by using a specific form of directed acyclic graphs . given a ngba @xmath37 ,",
    "we describe first how @xmath37 can be represented symbolically . by taking @xmath885",
    ", we can construct the indicator bdds @xmath886 for any set @xmath887 , such that @xmath888 if , and only if , @xmath442 .",
    "we can represent multiple states of the subset automaton by building a disjunction over their indicator functions .",
    "this is then used to encode states of subset automata @xmath10 and @xmath9 ( which are subsets of the states @xmath31 of @xmath37 ) .",
    "we encode the transition relation by introducing additional variables @xmath21 representing the transition labels and a copy @xmath889 of @xmath31 as successor variables . for this",
    ", we construct a function @xmath890 where @xmath891 if , and only if , @xmath892 .",
    "the construction for the breakpoint automata is similar ; for instance , denoted by @xmath22}$ ] the set of variables encoding @xmath22}$ ] , the states can be represented by using functions from @xmath893 } } \\times { \\mathbb{b}}^{{q}}$ ] to @xmath882 .",
    "this idea resembles  @xcite , but there additional variables are introduced to enumerate states of subset ( or breakpoint ) automata . for our purposes",
    "this is not needed .",
    "the construction of the single - breakpoint and multi - breakpoint automata is almost identical in terms of their bdd representations . according to  @xcite , rabin automata",
    "are not well suited to be be constructed using bdds directly .",
    "it is however possible to construct them in an explicit way and convert them to a symbolic representation afterwards . for this , we assign a number to each of the explicit states of the rabin automaton .",
    "afterwards , we can refer to the state using bdd variables encoding this number .",
    "we emphasise that we can still compute rabin automata on - the - fly when using the bdd - based approach , so as to avoid having to construct parts of the rabin automaton which are not needed in the product with the mc or mdp .",
    "it might happen that in the symbolic computation of the reachable states of the product we note that a certain state of the rabin automaton is required . in this case",
    ", we compute this successor state in the explicit representation of the automaton , assign to it a new number , encode this number using bdds and then use this bdd as part of the reachable states .",
    "mdps can be represented similarly . to represent exact transition probabilities",
    ", one can involve multi - terminal bdds ( mtbdds )  @xcite .",
    "if they are not required , bdds are sufficient .",
    "products of symbolic model and automata can then be computed using ( mt)bdd operations , allowing for effective symbolic analyses . to compute the ( bottom ) sccs , we employ a slight variantion of  @xcite . for mdps , we then employ a symbolic variant of the classical algorithm  @xcite to obtain the set of mecs from the set of sccs .",
    "the acceptance of an scc / mec can be decided by a few bdd operations .",
    "to establish theorem  [ thm : only_reach ] , we show inclusion in both directions .",
    "the proof is the same as the correctness proof for the determinisation construction in @xcite , but the claim is different , and the proof is therefore included for completeness .",
    "the difference in the claim is that @xmath894 is shown for @xmath134 with a singleton set @xmath895 that contains only the root and @xmath896 .",
    "the proof , however , does not use either of these properties .        for an @xmath19-word @xmath38 and @xmath898 ,",
    "we denote with @xmath899 the word @xmath900 .",
    "we denote with @xmath901 for a finite word @xmath902 that there is , for all @xmath903 a sequence @xmath904 with @xmath905 and @xmath906 for all @xmath907 . if one of these transitions is guaranteed to be in @xmath908 , we write @xmath909 .      for an input word @xmath35 ,",
    "let @xmath916 be the run of the dra @xmath7 on @xmath38 .",
    "a node @xmath127 in the history tree @xmath917 is called _ stable _ if @xmath918 and _ accepting _ if it is accepting in the transition @xmath919 .",
    "* @xmath127 is stable for all @xmath923 with @xmath924 , and * the chain @xmath922 contains exactly those indices @xmath925 such that @xmath926 is accepting ; this implies that @xmath146 is updated exactly at these indices .        exploiting knig s lemma ,",
    "this provides us with the existence of a run that visits all accepting sets @xmath929 of @xmath288 infinitely often .",
    "( note that the value of @xmath146 is circulating in the successive sequences of the run . )",
    "this run is accepting , and @xmath38 therefore belongs to the language of @xmath288 .",
    "let @xmath931 and @xmath932 be the run of @xmath288 on the input word @xmath38 ; let @xmath933 be the run of @xmath287 on @xmath38 .",
    "we then define the related sequence of host nodes @xmath934 .",
    "let @xmath163 be the shortest length @xmath935 of these nodes of the trees @xmath926 hosting @xmath936 that occurs infinitely many times .",
    "we follow the run and see that the initial sequence of length @xmath163 of the nodes in @xmath913 eventually stabilises .",
    "let @xmath922 be an infinite ascending chain of indices such that the length @xmath937 of the @xmath25-th node is not smaller than @xmath163 for all @xmath924 , and equal to @xmath938 for all indices @xmath939 in this chain .",
    "this implies that @xmath940 , @xmath941 , @xmath942 ,  is a descending chain when the single nodes @xmath943 are compared by lexicographic order .",
    "as the domain is finite , almost all elements of the descending chain are equal , say @xmath944 . in particular , @xmath945 is eventually always stable .",
    "let us assume for contradicting that this stable prefix @xmath945 is accepting only finitely many times .",
    "we choose an index @xmath550 from the chain @xmath946 such that @xmath945 is stable for all @xmath898 .",
    "( note that @xmath945 is the host of @xmath936 for @xmath926 , and @xmath947 holds for all @xmath898 . )    as @xmath43 is accepting , there is a smallest index @xmath948 such that @xmath949 .",
    "now , as @xmath945 is not accepting , @xmath936 must henceforth be in the label of a child of @xmath945 , which contradicts the assumption that infinitely many nodes in @xmath913 have length  @xmath950 .              1 .",
    "if there is a path from @xmath299 to @xmath951 in @xmath304 , then there is a path from @xmath310 $ ] to @xmath952 $ ] in @xmath303 $ ] ; and 2 .",
    "if there is a path from @xmath310 $ ] to @xmath952 $ ] in @xmath303 $ ] and @xmath299 is reachable in @xmath304 , then there is a path from @xmath299 to some @xmath953 with @xmath954 in @xmath304 .        to show ( 1 )",
    ", we have to run through the properties of a bottom scc .",
    "first , all states in @xmath316 $ ] are reachable and connected by lemma  [ lem : paths ] .",
    "it remains to show that no state @xmath952 \\notin [ { \\mathtt{s}}]$ ] is the successor of any state in the quotient mc .",
    "let us assume for contradiction that there is a state @xmath956 such that @xmath952 $ ] is the successor of @xmath957 $ ] by lemma  [ lem : paths ] , this implies that there is a state @xmath953 with @xmath958 reachable from @xmath299 . as @xmath14 is a bottom scc , @xmath959 holds , and @xmath952 = [ ( m',d '' ) ] \\in [ { \\mathtt{s}}]$ ] follows , which is a contradiction .    to show ( 2 ) , let us start with the set @xmath960 \\in { \\mathtt{s}}\\,\\}}$ ] .",
    "@xmath961 = { \\mathtt{s}}$ ] follows from the point ( 2 ) of lemma  [ lem : paths ] , and @xmath962 is closed under successors : assuming by contradiction that this is not the case provides a @xmath963 with successor @xmath964 .",
    "( note that the reachability of @xmath299 implies the reachability of @xmath951 . ) but this implies that @xmath952 $ ] is a successor of @xmath310 $ ] , and by construction of @xmath962 , @xmath952 \\in { \\mathtt{s}}$ ] .",
    "for the bottom scc @xmath14 , the construction of @xmath962 then implies @xmath965 , which is a contradiction .",
    "as @xmath962 is closed under successors , it contains some bottom scc , and we select @xmath317 to be such a bottom scc .",
    "we have shown that @xmath966 $ ] is a bottom scc in the quotient mc in the first half of this proof .",
    "consequently , @xmath966 $ ] is a bottom scc that is contained in @xmath14 , and hence @xmath966 = { \\mathtt{s}}$ ] holds .      in this appendix , we show theorem  [ theo : inclusions ] , that is , the inclusions @xmath336}^{u } ) \\subseteq { \\mathcal{l}}({\\mathcal{bp}}_{\\langle d \\rangle}^{u } ) \\subseteq { \\mathcal{l}}({\\mathcal{a}}_{d } ) \\subseteq { \\mathcal{l}}({\\mathcal{bp}}_{\\langle d \\rangle}^{o } ) , { \\mathcal{l}}({\\mathcal{s}}_{[d]}^{o})$ ] . the subset automata @xmath9 , @xmath10 , and the breakpoint automata @xmath280 , @xmath281 are defined in section  [ subset ] .",
    "let us assume for contradiction that @xmath38 is an infinite word such that the run @xmath43 of @xmath970}^{u}$ ] on @xmath38 is accepting , while the run @xmath971 of @xmath972 on @xmath38 is rejecting .",
    "then there is a position @xmath973 such that the following statements hold :      it is easy to see that , by construction , @xmath979 holds for all @xmath980 . as @xmath43 is accepting",
    ", there is a position @xmath977 such that , for all @xmath981 and all @xmath982 , @xmath983 implies @xmath984 .",
    "( otherwise @xmath929 would not be accepting in @xmath970}^{u}$ ] . )",
    "but then , transition @xmath17 in @xmath975 is accepting , which is a contradiction .",
    "hold for all @xmath980 , and that if @xmath990 is accepting , then @xmath991 is accepting with accepting pair with index @xmath286 . as the root can not be rejecting , this implies that @xmath971 is accepting , too .",
    "hold for all @xmath980 , and that if @xmath991 is accepting with accepting pair with index @xmath286 ( recall that the root can not be rejecting ) , then @xmath990 is accepting . if @xmath991 is accepting , but not with index @xmath286 , then the node with position @xmath235 in the history is eventually always stable ( note that , whenever @xmath235 is not stable , no other node than @xmath286 is ) say from position @xmath973 onwards .",
    "but then @xmath994 can not be empty for any @xmath977 , thus @xmath995 .",
    "recall that @xmath7 is obtained by determinisation of the ngba @xmath37 , i.e. , @xmath265 .",
    "let @xmath43 be the run of a word @xmath38 that is rejected by @xmath970}^{o}$ ] , and @xmath550 an index such that @xmath49 contains only finitely many transitions in @xmath929 .",
    "then there is a position @xmath980 such that no transition in @xmath929 may occur from @xmath17 onwards .",
    "but then there is no @xmath997 for which a position @xmath998 is reachable such that @xmath999 is in the set @xmath929 of the ngba @xmath37 .",
    "thus no run of @xmath37 on @xmath38 can have more than @xmath17 transitions from @xmath929 , hence @xmath1000})$ ] and the claim follows with since @xmath1001 } ) = { \\mathcal{l}}({\\mathcal{a}}_{d})$ ] by theorem  [ thm : only_reach ] , thus @xmath1002 .",
    "let @xmath1012 be the ascending chain of breakpoints .",
    "that is , the chain that contains exactly the positions @xmath1013 such that @xmath1014 for some @xmath1015 and @xmath1016}$ ] that are reached after some accepting transition has been performed .",
    "* @xmath1018 is included in the tree , * it is an initial sequence of a run of @xmath37 , * @xmath1019 , and * for all indices @xmath1020 ( with @xmath1021 ) from the chain of breakpoints there has to be a @xmath1022 accepting transition @xmath1023 for some @xmath1024 .    as usual with the breakpoint construction",
    ", it is easy to show that there exists a run @xmath1025 for all @xmath1026 and @xmath1019 .",
    "thus , we are left with an infinite and finitely branching tree .",
    "invoking knig s lemma , this tree contains an infinite path , which is an accepting run of @xmath37 by construction .",
    "let @xmath46 be a run of @xmath37 on an @xmath19-word @xmath1029 .",
    "for this run @xmath43 , we denote by @xmath1030 $ ] the set of runs on @xmath38 with the same initial sequence @xmath1031 , i.e. , @xmath1030 = { \\{\\ , { \\rho } ' \\in { \\mathop{\\mathrm{run}}}(\\alpha ) \\mid { \\rho}_{n } \\trianglelefteq { \\rho } ' \\,\\}}$ ] .",
    "moreover , let @xmath1032 be the sequence @xmath1033 where @xmath1034.\\ { \\rho}'(i ) = q \\,\\}}$ ] for all @xmath1010 .",
    "essentially , the sets @xmath1035 are the sets from a subset construction that starts with the singleton @xmath1036 at position @xmath17 .",
    "note that @xmath1037 is indeed a singleton since it is the last state of @xmath1038 .      essentially , @xmath1042 are initially the pairs from a breakpoint construction ( relative to the accepting set @xmath1043 ) that starts with @xmath1044 at position @xmath17 , but does not reset when a breakpoint is met . in this case",
    ", the sequence continues with sets @xmath1045 for all positions @xmath202 from the breakpoint onwards : @xmath1045 implies @xmath1046 , and thus @xmath1047 .",
    "note that , for each @xmath1048}$ ] and each @xmath980 , we have the following relations between the widths : @xmath1056 and @xmath1057 .",
    "in fact , by definition of @xmath1058 , we have that @xmath1059 , and similarly for @xmath1057 . since @xmath1052 holds for each @xmath1048}$ ] and",
    "@xmath1049 , it is immediate to derive @xmath1060 .",
    "since the widths are monotone , we can therefore define the width of a run as the limit of the width of its positions , i.e. , we define @xmath1061 and @xmath1062 .",
    "we are now ready to prove lemma  [ lem : buechilangsubseteqsemidetlang ] :    let @xmath46 be an accepting run of @xmath37 . we first show that @xmath1063 holds for each @xmath1048}$ ] . for doing this , we select an @xmath980 such that @xmath1064 holds .",
    "note that such an @xmath17 exists due to the monotonicity of @xmath1065 in @xmath17 and the fact that @xmath1065 has @xmath235 as lower bound .",
    "moreover , @xmath1066 holds for each @xmath997 .    for a given @xmath146 , we can now choose an arbitrary @xmath1067 such that @xmath1068 .",
    "( as @xmath43 is accepting , arbitrarily large such @xmath1069 exists . )",
    "we have @xmath1070 and @xmath1071 .",
    "now , @xmath1068 implies @xmath1072 , which together with @xmath1073 provides @xmath1074 .",
    "a simple inductive argument thus implies @xmath1075 for all @xmath1076 , and thus @xmath1077 .",
    "together with @xmath1078 , this provides @xmath1079 . as @xmath1069 can be chosen arbitrarily large , this implies @xmath1080 .    with this observation",
    ", we can construct an accepting run of @xmath471 as follows .",
    "we start with an initial sequence @xmath1081 in @xmath107 where by definition @xmath1082 . note that this sequence is well defined and deterministic ; moreover , for each @xmath1083 , @xmath1084 holds . since @xmath1085",
    ", we have that @xmath1086 , thus @xmath1087 and we use such transition to extend the sequence @xmath1081 to @xmath1088 where @xmath1089 .",
    "again , @xmath1090 . note that the choice of using the accepting set @xmath68 is arbitrary .",
    "the remainder of the run , @xmath1091 is well defined , as this second part is again deterministic , and still @xmath1084 for each @xmath1092 . since @xmath1084 for each @xmath1010 , the deterministic automaton in the second part does not block .",
    "moreover , @xmath1051 holds by a simple inductive argument .",
    "let @xmath1098 .",
    "a simple inductive argument provides that @xmath1099 holds for all @xmath1095 .",
    "thus , there is a @xmath1095 with @xmath1100 .",
    "but since @xmath1101 , we have that @xmath1102 , which contradicts @xmath1103 .",
    "let us assume for contradiction that @xmath1106 is the accepting run of @xmath1107 while @xmath1108 is the rejecting run of @xmath1109 on an input word @xmath618 .",
    "note that @xmath1110 since @xmath1111 ; similarly , @xmath1112 and @xmath1113 as well as @xmath1114 and @xmath1115 .",
    "we can first establish with a simple inductive argument that @xmath1116 for all @xmath1117 ( and that @xmath1109 has a run on @xmath38 ) .",
    "in fact , for @xmath1118 , we have already noted that @xmath1119 ; suppose that @xmath1116 ; by construction of @xmath471 , it follows that @xmath1120 .",
    "since @xmath43 is accepting , @xmath1121 for each @xmath1117 and this implies that @xmath1122 , i.e. , @xmath1109 has a run on @xmath38 .",
    "as @xmath971 is rejecting , there exists an @xmath980 such that , for each @xmath1123 , we have that @xmath1124 , otherwise @xmath971 would be accepting ; note that since we have that @xmath1122 , this implies that @xmath1125 . by definition of @xmath114",
    ", it follows that @xmath1126 and @xmath1127 , thus for each @xmath1123 we have @xmath1128 .",
    "as @xmath43 is accepting , transitions from @xmath1097 are taken infinitely often , thus the indices @xmath50}$ ] are visited cyclically . in particular , since @xmath1129}$ ] , this implies that there exists an @xmath1130 such that @xmath1131 , as effect of the transition @xmath1132 .",
    "however , since @xmath971 is rejecting by assumption , we know that @xmath1133 . moreover    1 .   by definition of @xmath433 ,",
    "the breakpoints sets are reset to @xmath367 after an accepting transition .",
    "2 .   for non - accepting transitions ,",
    "the breakpoint construction is monotonic in the sense that for each @xmath1134 , @xmath1135 , @xmath1136 , @xmath550 , and @xmath98 such that @xmath1137 and @xmath1138 , it follows that @xmath1139 is defined and , for @xmath1140 , we have @xmath1141 .",
    "3 .   as @xmath971 is rejecting , its breakpoint sets are never reset after position @xmath17 ( and remain to be @xmath1142 ) .    from 1.)-3 . ) , it follows by induction that @xmath1143 , thus @xmath1144 for each @xmath1145 .",
    "this , however , implies due to the definition of @xmath1097 that in @xmath43 no further accepting transitions follow , thus @xmath1146 .",
    "this implies that @xmath43 is rejecting , contradicting the initial assumption .      as for proposition",
    "[ pro : buechilangequalsemidetlang ] , we split the proof of proposition  [ pro : semidetlangeqparitylang ] into two lemmas , stating that for each @xmath1147 , @xmath1148 and @xmath1149 hold , respectively . as notation , for states @xmath1150 , @xmath1151 , and @xmath1152 , we write @xmath1153 if @xmath1154 , and @xmath1155 if there exists @xmath1156 with @xmath1157 .",
    "[ lem : prerun ] given a semi - deterministic bchiautomaton @xmath433 and @xmath624 , for each @xmath1158 , each @xmath1159 with @xmath1153 , and each input word @xmath38 , there is a pre - run @xmath1160 of @xmath1161 if , and only if , there is a pre - run @xmath1162 of @xmath1163 with @xmath1164 .",
    "let @xmath1166 be an accepting run of @xmath1163 on a word @xmath38 with dominating priority @xmath547 ; let @xmath1167 be a natural number such that @xmath1168 holds for all @xmath1123 ; and let @xmath1169 for all @xmath1123 .    by lemma  [ lem : prerun ]",
    ", there is a pre - run @xmath1170 with @xmath1171 of @xmath1161 .",
    "the observation that no priority less than @xmath547 occurs from the @xmath17-th transition onwards in @xmath43 provides with the construction of @xmath100 that this pre - run can be continued to a unique run @xmath1172 with @xmath1173 for all @xmath1123 .",
    "further , for all @xmath1123 with @xmath1174 , we have @xmath1175 . as there are infinitely many such @xmath163 , @xmath971 is accepting .",
    "let @xmath1177 with @xmath1178 be an accepting run of @xmath1161 on an input word @xmath618 .",
    "then there is a minimal @xmath980 such that @xmath1179and thus @xmath1180 for all @xmath1123 and @xmath1181 for all @xmath1182 .    by a simple inductive argument",
    "we can show that @xmath1163 has a run @xmath1183 on @xmath38 , such that @xmath1184 for all @xmath1123 .",
    "moreover , there is a descending chain @xmath1185 of indices such that @xmath1186 .",
    "this chain stabilises at some point to @xmath1187 .",
    "consequently , we have that @xmath1188 is even _ or _ no smaller than @xmath547 for all @xmath1189 .",
    "( assuming that the priority is an odd number less than @xmath547 would imply that there is a @xmath506 sign in @xmath534 at a position less than or equal to @xmath64 , which would contradict that the index has stabilised . ) for all positions @xmath1189 with @xmath1190 , @xmath1188 is an even number less than or equal to @xmath547 .",
    "the smallest priority occurring infinitely often in the transitions of @xmath43 is therefore an even number less than or equal to @xmath547 .      to prove the lemma",
    ", we first note that no transition of any run of the product ( which is an scc ) can see a priority smaller than @xmath547 .",
    "thus , for all such runs @xmath1191 , the sequence @xmath1192 is a run , and a transition like @xmath1193 is accepting if , and only if , the priority is minimum and even ; more precisely , we have that @xmath1194 .",
    "@xmath1197 : :    let @xmath14 be an accepting bottom scc of    @xmath339 , @xmath43    be a run of @xmath339 trapped    into @xmath14 , and @xmath38 be the    associated word . by definition  [ def : acceptingsccofsubset ] , it follows    that there exists an scc @xmath317 of    @xmath1198 $ ] that is isomorphic    to @xmath14 containing only accepting states , where    @xmath451 . by a simple    inductive argument",
    ", we can show that the run @xmath971 of    @xmath452 on    @xmath38 satisfies    @xmath1199 $ ] for each    @xmath40 and that @xmath971 is trapped    into an @xmath962 of    @xmath452 with    @xmath961 \\subseteq { \\mathtt{s}}'$ ] as well .",
    "since    @xmath317 is accepting , by corollary  [ cor : quotients ]    @xmath962 contains only accepting states as well ;    this means that there exists @xmath40 such that    @xmath1200 and a    transition @xmath1201 such    that @xmath1202 is even    and minimum , say @xmath547 . by    lemma  [ lem : parityofsccandacceptingsccofsemidet ]",
    "it follows that    @xmath1203 forms an scc    that is accepting . by construction of @xmath100 ,    @xmath1204 and    @xmath1205 where    @xmath1206 and @xmath1207 , thus we    have @xmath1208 and    @xmath1207 such that    @xmath1209 belongs to an    accepting scc of    @xmath1210 ,    as required .",
    "@xmath1211 : :    let @xmath14 be a bottom scc of    @xmath339 such that there exist    @xmath438 and @xmath439    such that @xmath1212 belongs to an accepting    scc @xmath317 of    @xmath1213    for some @xmath50}$ ] . since    @xmath317 is accepting , by construction of    @xmath100 ,    proposition  [ pro : semidetlangeqparitylang ] , and    lemma  [ lem : parityofsccandacceptingsccofsemidet ] , it follows that there    exists @xmath557 and integer @xmath64 such that    @xmath1204 and    @xmath1214 is    accepting .",
    "if @xmath1215 is already in an accepting scc    @xmath962 of    @xmath1214 , then by    definition of accepting scc for    @xmath339 , by    theorem  [ thm : bottom_component ] and corollary  [ cor : quotients ] we have    that @xmath1216 $ ] is accepting as    well .",
    "since    @xmath1214 is    accepting , let @xmath38 one of the accepted words and    @xmath43 the resulting run starting from    @xmath1215 ; eventually @xmath43 is trapped    into an accepting scc @xmath962 with    @xmath961 = { \\mathtt{s}}$ ] .",
    "let    @xmath40 such    @xmath1217 and    @xmath1218 is even and    minimum , say @xmath547 .",
    "this implies by construction of    @xmath100 that    @xmath1219 where    @xmath1220 for    some @xmath1221 .",
    "since    @xmath1222 and    @xmath962 is accepting , by    corollary  [ cor : quotients ] it follows that all states in    @xmath962 are accepting , thus by    definition  [ def : acceptingsccofsubsetapp ] , @xmath14    is accepting as well .",
    "@xmath1223 : :    this equivalence follows directly from a combination of the proofs of    propositions  [ pro : buechilangequalsemidetlang ] and    proposition  [ pro : semidetlangeqparitylang ] ; in particular , the proof of    lemma  [ lem : buechilangsubseteqsemidetlang ] ( stating that    @xmath1224 )    provides the singleton @xmath1225 needed for the    implication @xmath1226 ."
  ],
  "abstract_text": [
    "<S> the bottleneck in the quantitative analysis of markov chains and markov decision processes against specifications given in ltl or as some form of nondeterministic bchiautomata is the inclusion of a determinisation step of the automaton under consideration . in this paper , we show that full determinisation can be avoided : subset and breakpoint constructions suffice . we have implemented our approach  both explicit and symbolic versions  in a prototype tool . </S>",
    "<S> our experiments show that our prototype can compete with mature tools like prism . </S>"
  ]
}