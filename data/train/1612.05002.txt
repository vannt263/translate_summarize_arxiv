{
  "article_text": [
    "this paper is a continuation of work that two of the co - authors did jointly with ji admek @xcite . in that paper we studied generic versions of minimisation and determinisation algorithms in the context of coalgebras , especially in kleisli categories .",
    "here we are studying a novel type of transition system , so - called conditional transition systems , and show how they fit into this framework .",
    "this example is interesting for several reasons : first , it gives a non - trivial case study in coalgebra which demonstrates the generality of the approach .",
    "second , it studies coalgebras in the category of partially ordered sets , respectively in kleisli categories over this base category .",
    "we use the birkhoff duality for distributive lattices to show equivalence of two kleisli categories over two monads : the reader monad and the so - called lattice monad .",
    "this result can be of interest , independently of the coalgebraic theory .",
    "third , we introduce a notion of upgrade into coalgebraic modelling .    the theory of coalgebras @xcite allows uniform modelling and reasoning for a variety of state - based systems .",
    "for instance , ( non)deterministic finite automata and weighted automata are the classical examples often studied in this context ( see @xcite for more examples ) .",
    "furthermore , coalgebraic modelling comes with the benefit of offering generic algorithms , capturing the core of algorithms that are similar across different types of automata .",
    "in particular , through the final chain - based reasoning one can compute quotients on automata up to a chosen notion of behavioural equivalence ( such as strong bisimilarity or trace equivalence ) . a conditional transition system ( cts )",
    "@xcite is an extension of labelled transition system that is well suited to model software product lines @xcite , an emergent topic of research in the field of software engineering .",
    "in contrast to the commonly used featured transition systems @xcite , ctss are not primarily concerned with the individual features of a software product , but mainly with the individual versions that may arise from the given feature combinations . in ctss",
    "@xcite transitions are labelled with elements of a partially ordered set of conditions @xmath1 , which can be viewed as products in the terminology of software product lines .",
    "this gives us a compact representation which merges the transition systems for many different products into one single structure .",
    "a transition labelled @xmath2 can only be taken by instances of product @xmath3 . furthermore ,",
    "with @xmath4 we denote that  during execution ",
    "product @xmath3 can be upgraded to @xmath5 .",
    "intuitively ctss evolve in two steps : first , a condition @xmath6 is chosen at a given state ; second , a transition is fired which is guarded by the chosen condition .",
    "over the course of the run of a cts , it can perform an operation called _ upgrade _ in which the system changes from a greater condition @xmath3 to a smaller condition @xmath7 .",
    "this in turn activates additional transitions that may be taken in future steps . in @xcite ,",
    "ctss were defined without upgrades , i.e. , @xmath8 is equality .",
    "cts have ` monotonous ' upgrading in the sense that one can only go down on the hierarchy of conditions , but not up . as a consequence",
    ", cts have a special notion of bisimulation consisting of a family of traditional bisimulations @xmath9 ( one for each condition @xmath6 ) such that @xmath10 , whenever @xmath11 .",
    "roughly , two states are behaviourally equivalent under a condition @xmath3 if and only if they are bisimilar ( in the traditional sense ) for every upgrade @xmath11 . an interesting fact about a cts is that there exists an equivalent model , called _ lattice transition system _ ( lats ) , which allows for a more compact representation of a cts using the lattice of downward closed subsets of @xmath12 ( see @xcite for more details ) .",
    "in essence , this can be viewed as a lifting of the well - known birkhoff s representation theorem to the case of transition systems .",
    "this paper aims at characterising cts and lats coalgebraically . to this end , we define two monads , the reader monad and the lattice monad , which allow for modelling cts and lats respectively  provided a matching functor is chosen  in their corresponding kleisli categories .",
    "we will show that these two categories are equivalent ( in the categorical sense ) .",
    "our next aim is to characterise conditional bisimilarity using the notion of behavioural equivalence , a concept stemming from the theory of coalgebras",
    ". roughly , two states of a system ( modelled as a coalgebra ) are _ behaviourally equivalent _ if and only if they are mapped to a common point by a coalgebra homomorphism . in this",
    "regard , capturing the right notion of behavioural equivalence ( conditional bisimilarity in our case ) depends on choosing the right choice of functor modelling ctss .",
    "the usual powerset functor @xmath13 proves to be a viable choice for cts without any upgrades , but we will provide a counterexample that shows this functor does not yielding conditional bisimulation in the presence of upgrades .",
    "however , for a slight adaptation of the powerset functor , i.e. , allowing @xmath14 for a set of states @xmath15 , behavioural equivalence indeed captures conditional bisimilarity .",
    "to conclude , we show that the minimisation algorithm based on the final chain construction plus factorisations @xcite is applicable to the category under investigation and specify how it can be applied to cts .",
    "cts without upgrades have already been considered in @xcite , but applicability to cts with upgrades is novel .",
    "we presuppose basic knowledge of category theory , including the notions of objects , arrows , functors and monads .",
    "the primary objects of interest in this work are coalgebras , which we use to model conditional transition systems .",
    "let @xmath16 be an endofunctor on a category @xmath17",
    ". then an _",
    "@xmath18-coalgebra _ is a pair @xmath19 , where @xmath15 is an object of @xmath17 and @xmath20 is an arrow in @xmath21 .",
    "@xmath18-coalgebra homomorphism _ between two coalgebras @xmath19 and @xmath22 is an arrow @xmath23 in @xmath21 such that @xmath24 .",
    "it is well known that the collections of @xmath18-coalgebras and @xmath18-coalgebra homomorphisms form a category . in the sequel",
    ", we drop the prefix ` @xmath18- ' whenever it is clear from the context .    in the theory of coalgebras ,",
    "traditional bisimulation @xcite is captured in more than one way , namely : coalgebraic bisimulation , via an arrow into any coalgebra ( so - called cocongruences ) , via the arrow into the final object of the coalgebra category ( if that exists ) , called final coalgebra , and a related approach that minimises the coalgebra via factorisation ( see section  [ sec : computing - beheq ] ) .",
    "we will first fix the notion of behavioural equivalence used in this paper . note that since we work in categories different from @xmath25 , we use a concretisation functor .",
    "let @xmath18 be an endofunctor on a concrete category @xmath21 with a faithful functor @xmath26 to the category of sets @xmath27 .",
    "then , two states @xmath28 and @xmath29 of a coalgebra @xmath19 are _ behaviourally equivalent _ if there exists a coalgebra homomorphism @xmath23 such that @xmath30 .    in the sequel",
    ", our base category @xmath21 will be the well - known category of partially ordered sets denoted as @xmath0 .",
    "formally , the objects of @xmath0 are pairs @xmath31 , where @xmath15 is a set and @xmath32 is a partial order on @xmath15 . its arrows @xmath33 are all the order preserving functions from @xmath15 to @xmath34 .",
    "note that @xmath0 is concrete over @xmath27 as evident by the forgetful functor @xmath35 defined as : @xmath36 , for any object @xmath31 , and @xmath37 , for any arrow @xmath33 .",
    "next , we generalise the well - known reader monad to the category @xmath0 .",
    "let @xmath1 be a finite partially ordered set .",
    "then , for an object @xmath31 and an arrow @xmath38 in @xmath0 , we fix : @xmath39 where @xmath40 if and only if @xmath41 for all @xmath6 .",
    "furthermore , the unit @xmath42 is given as @xmath43 .",
    "lastly , the multiplication @xmath44 is defined as @xmath45 , for any @xmath46 .",
    "the reader monad @xmath47 is a monad on @xmath0 .",
    "since order preservation is closed under function composition , it is clear that @xmath48 is well - defined for an arrow @xmath38 in @xmath0 . and",
    "the unit @xmath49 is a constant function , so clearly it is order preserving .",
    "furthermore , for the multiplication , let @xmath50 and @xmath51 . then , @xmath52 , showing that @xmath53 is also order preserving .",
    "the rest of the proof obligations , namely that @xmath54 are actually natural transformations and that the unit and associative laws hold are standard , just like the well - known reader monad on @xmath25 .",
    "next , we recall the kleisli category over the concrete category @xmath0 .",
    "let @xmath55 be a monad on @xmath0 where @xmath56 is the unit and @xmath57 the multiplication .",
    "then its kleisli category @xmath58 consists of partially ordered sets as objects ( i.e. the objects of @xmath0 ) and an arrow @xmath59 is an order - preserving function @xmath60 .",
    "the identity arrow in @xmath58 is given by @xmath61 and the composition of two arrows @xmath23 , @xmath62 in @xmath58 is given by @xmath63 .",
    "kleisli categories are concrete categories themselves as evident by the concretisation functor @xmath64 on objects and @xmath65 on arrows @xmath66 . for the remainder of the paper we will not make explicit the usage of the concretisation functor , but identify objects with their concretisation when necessary .",
    "intuitively , kleisli categories help in distinguishing between the visible effects of transitions in a system and those that can be characterised as side - effects instead .",
    "effects of a transition that are intended to be observable when determining behavioural equivalence are encoded in a functor @xmath18 on the kleisli category , whereas the side effects are encoded via a monad @xmath67 .",
    "this is motivated by the previous works in @xcite , where kleisli categories ( on @xmath25 rather than @xmath0 ) are used to obtain ( trace ) language equivalence as behavioural equivalence instead of bisimulation .",
    "one way of obtaining endofunctors on a kleisli category is to lift an endofunctor from the base category @xmath0 . given a functor @xmath68 , one can define a @xmath58-functor @xmath69 using a distributive law @xmath70 by defining @xmath71 on objects and on arrows @xmath33  which are functions @xmath72  as @xmath73 .",
    "the distributive law is required , because @xmath74 is of the type @xmath75 and as such is not an arrow in the kleisli category .",
    "a distributive law @xmath76 tranforms such a function into a valid kleisli arrow ( for more details , see @xcite ) .      here",
    "we recall the definitions of a cts , an lats , and conditional bisimilarity from @xcite .",
    "a _ conditional transition system _ is a quadruple @xmath77 consisting of a set of states @xmath15 , a set of actions @xmath78 , a finite set of conditions @xmath12 , and a transition function @xmath79 that maps every pair @xmath80 to a monotone function of type @xmath81 .",
    "we write @xmath82 , whenever @xmath83 . in case @xmath84 , we omit the action label from a transition .    intuitively , a cts evolves as follows : in the beginning , a version of the system @xmath2 is chosen and the cts gets instantiated to the version @xmath3 as the traditional labelled transition system that has a transition @xmath85 if and only if the cts has a transition @xmath82 . at any point of the execution of this labelled transition system , an upgrade may be performed , i.e. , a new version @xmath7 of the system may be chosen .",
    "the system remains in the state reached up to that point and additional transitions get activated , since now all transitions @xmath86 give rise to a transition @xmath85 .",
    "note that due to the monotonicity of the transition function @xmath38 in a cts , an upgrade will always retain all previous transitions , but may add additional transitions .",
    "symbolically , if @xmath87 and @xmath11 then @xmath88 .",
    "let @xmath77 be a cts .",
    "let @xmath89 ( for every @xmath6 ) denote the labelled transition system induced upon choosing the condition @xmath3 .",
    "a _ conditional bisimulation _ on the given cts @xmath77 is a family of relations @xmath90 satisfying :    * each @xmath91 is a traditional bisimulation relation on the labelled transition system @xmath92 ; * for every @xmath93 we have @xmath94 .    for @xmath95",
    "we say that @xmath96 if there exists a conditional bisimulation such that @xmath97 .",
    "consider a cts @xmath98 as depicted below , where @xmath99 and @xmath100 with @xmath7 .",
    "note that the above behavioural description can be easily represented by a transition function .",
    "for instance , the equation @xmath101 specifies that the system under the condition @xmath3 not only moves nondeterministically from the state @xmath102 to @xmath103 or @xmath104 , but it can also upgrade to the condition @xmath5 .",
    "consider the labelled transition systems @xmath92 and @xmath105 as depicted above in the left and right , respectively .",
    "notice that the states @xmath102 and @xmath106 are bisimilar in both the instantiations with the relations @xmath91 and @xmath107 depicted as dotted lines .",
    "however , we find that @xmath102 and @xmath106 are not conditionally bisimilar because @xmath108 , but @xmath109 and there is no other conditional bisimulation relating @xmath110 .",
    "moreover , the states @xmath103 and @xmath111 in the instantiation @xmath5 can never be related by any bisimulation relation .",
    "next , we recall an equivalent , but more compact representation of a cts which we call lattice transition system ( lats ) .",
    "in @xcite we showed that behavioural equivalence checks can be performed more efficiently in the lattice setting , by encoding lattice elements into binary decision diagrams .",
    "a _ lattice transition system _ ( lats ) over a finite distributive lattice @xmath112 is a quadruple @xmath113 consisting of a set of states @xmath15 , a set of actions @xmath78 , and a transition function @xmath114 .",
    "recall birkhoff s representation theorem : a finite distributive lattice @xmath112 ( with join @xmath115 and meet @xmath116 ) is isomorphic to the lattice of downwards - closed sets of join - irreducible elements of @xmath112 ordered by inclusion .",
    "a lattice element @xmath117 in a finite lattice @xmath112 is _ join - irreducible _ if and only if , for any @xmath118 , if @xmath119 then @xmath120 .",
    "thus , on one hand , each finite distributive lattice can be transformed into a dual partially ordered set by taking its join irreducible elements and their order in @xmath112 . on the other hand ,",
    "each partially ordered set @xmath12 can be transformed into its dual lattice by taking the downwards - closed subsets of @xmath12 and ordering them by inclusion .",
    "going from @xmath112 to the isomorphic @xmath121 , each lattice element @xmath122 is mapped to the set of all irreducible elements that are smaller than @xmath117 , i.e. @xmath123 .",
    "furthermore there is a correspondence between monotone functions from @xmath12 to @xmath124 and lattice homomorphisms from @xmath125 to @xmath126 .",
    "a cts @xmath77 corresponds to an lats @xmath127 where @xmath128 and @xmath129 with @xmath130 for @xmath131 , @xmath132 .",
    "consequently , an lats evolves just like a cts . at a state , a product , i.e.",
    ", a join - irreducible element @xmath133 is chosen and all the transitions that carry a label greater then @xmath117 remain active , whereas all other transitions are deactivated . at any point of the execution , an upgrade to a smaller join - irreducible element @xmath134",
    "may be performed , activating additional transitions accordingly .",
    "cts and lats can be transformed into one another by going from the lattice to its dual partial order and vice - versa ( see section  [ sec : latmon ] ) .",
    "a benefit of lats over cts is that now bisimilarity can be stated in more familiar terms .",
    "in addition , this view is also helpful in computing the largest conditional bisimilarity via matrix multiplication ( see @xcite for more details ) .",
    "let @xmath113 be an lats and let @xmath135 denote the set of all join - irreducible elements of @xmath112 .",
    "a function @xmath136 is a _ lattice bisimulation _ if and only if the following transfer properties are satisfied .    1 .   for all @xmath137 @xmath132 , @xmath138 whenever @xmath139 and @xmath140",
    ", there exists @xmath141 such that @xmath142 and @xmath143 .",
    "2 .   symmetric to ( i ) with the roles of @xmath102 and @xmath103 interchanged .    here",
    ", we write @xmath144 , whenever @xmath145 .    in @xcite",
    ", we proved that two states @xmath131 are conditionally bisimilar under condition @xmath3 if and only if they are related by a lattice bisimulation @xmath146 with @xmath147 .",
    "as mentioned in the introduction , we will model lats as a coalgebra in the kleisli category of a monad .",
    "one could try to simply use the lattice monad , i.e. , @xmath148 , however , this would not be equivalent to the reader monad . given a monotone function @xmath149 , one would like to define a corresponding mapping @xmath150 with @xmath151 and @xmath152 .",
    "however , this does not result in a bijection , since some arrows @xmath153 do not represent a monotone function @xmath154 .",
    "hence we start by imposing restrictions on mappings @xmath155 and defining a suitable endofunctor in our base category @xmath0 .",
    "[ def : t - funktor ] let @xmath156 be a complete lattice satisfying the _ join - infinite distributive _ law : @xmath157 for an ordered set @xmath31 , let @xmath158 , where @xmath159 is the set of all those functions @xmath160 satisfying the following restrictions :    1 .",
    "[ def : t - funk-1 ] @xmath161 2 .",
    "[ def : t - funk-2 ] for any @xmath131 , we have @xmath162 .",
    "3 .   [ def : t - funk-3 ] for any join - irreducible element @xmath163 , we have @xmath164    furthermore , for any two functions @xmath165 we let @xmath166",
    "lastly , for an order preserving function @xmath167 , we fix @xmath168    it should be noted that conditions  [ def : t - funk-1 ] and [ def : t - funk-2 ] in the above definition are redundant in the case of finite distributive lattices in the following sense . given a finite distributive lattice @xmath156 , an order preserving function @xmath169 satisfying condition  [ def : t - funk-3 ] also satisfies condition  [ def : t - funk-1 ] . moreover , condition  [ def : t - funk-3 ] and order preservation imply condition  [ def : t - funk-2 ] in case of finite lattices . for",
    ", we note @xmath170 . here , @xmath171 whose existence is guaranteed by condition  [ def : t - funk-3 ] .    for",
    ", we first note that the inequality @xmath172 ( for any @xmath131 ) is equivalent to demanding that the function @xmath173 is order preserving .",
    "it is obvious that condition  [ def : t - funk-2 ] implies @xmath173 is order preserving , simply let @xmath174 . on the other hand ,",
    "if @xmath173 is order preserving , then from @xmath175 and @xmath176 it follows that @xmath177 and @xmath178 .",
    "therefore , @xmath179    on the other hand , the inequality @xmath180 follows from condition  [ def : t - funk-3 ] _ in the finite case _ because then @xmath181    lastly , condition  [ def : t - funk-3 ] is required to rule out the cases when @xmath15 has an infinite descending chain @xmath182 such that @xmath183 ( for all @xmath184 ) .",
    "this is in - turn necessary to construct a corresponding function @xmath185 for a given @xmath186 such that @xmath187 , ( for every @xmath163 ) .",
    "next we prove that @xmath67 is well - defined .",
    "henceforth , we omit the index from the ordering relation , whenever it is clear from the context .",
    "every function in @xmath188 is order preserving .",
    "let @xmath189 , for some @xmath131 .",
    "then , @xmath190 thus , @xmath191 , i.e. , @xmath192 .    if @xmath193 is order preserving and @xmath186 then @xmath194 .",
    "we need to show that @xmath195 satisfies the three conditions of definition  [ def : t - funktor ] . for condition  [ def : t - funk-1 ]",
    ", we find @xmath196 .",
    "for condition  [ def : t - funk-2 ] , let @xmath197 .",
    "we need to show that @xmath198 . by expanding the right hand side",
    ", we get @xmath199 for condition  [ def : t - funk-3 ] , let @xmath163 .",
    "then , there is a minimal element @xmath200 satisfying @xmath201 . clearly , @xmath202 .",
    "now let @xmath203 .",
    "then , @xmath204 .",
    "i.e. , @xmath205 and @xmath206 , for some @xmath207 .",
    "but by condition  [ def : t - funk-3 ] , we get @xmath208 . and",
    "by order preservation of @xmath38 we get @xmath209 ; thus , @xmath210 .",
    "if @xmath33 is order preserving , then so is @xmath211 .",
    "let @xmath33 be an order preserving function .",
    "then , we want to prove that @xmath212 is also order preserving .",
    "let @xmath213 , for some @xmath214 .",
    "then , we have @xmath215 , for any @xmath207 .",
    "thus , we have @xmath216 hence , @xmath211 is order preserving .",
    "now we prove that @xmath67 is actually a functor .",
    "the mapping @xmath67 as in definition  [ def : t - funktor ] is an endofunctor .",
    "we start by showing the preservation of identities : @xmath217 to show that @xmath67 respects concatenation of arrows , we derive : @xmath218 now we will prove that the sets over which the supremum is taken are identical , making the suprema themselves identical .    * if @xmath219 , then let @xmath220 , then automatically @xmath221 and additionally @xmath222 . * if @xmath221 and @xmath223 then @xmath224 due to monotonicity of @xmath38 .",
    "next , we define a unit and a multiplication associated with our functor @xmath67 , which in turn give rise to the _ lattice _ monad .",
    "[ def : um - lmon ] define two families of maps @xmath225 and @xmath226 : @xmath227    in the remainder , we show that the families of functions @xmath56 and @xmath57 are well - defined resulting in natural transformations between the functors @xmath228 and @xmath229 , respectively .",
    "the corresponding lemmas are stated below and the proofs can be found in appendix  [ sec : proofs ] .",
    "[ lem : eta - nattrans ] the family @xmath61 defined in definition  [ def : um - lmon ] is a natural transformation .",
    "[ lem : mu - nattrans ] the family @xmath230 defined in definition  [ def : um - lmon ] is a natural transformation .    now that @xmath56 and @xmath57 are well - defined natural transformations",
    ", we investigate whether the so - called _ unit _ and _ associative _ law of a monad hold or not , again the proofs are in appendix  [ sec : proofs ] .    [",
    "lem : mu - ass - law ] the associative law holds for @xmath57 , i.e. @xmath231 .    [ lem : mu - nu - unit ] the unit law holds , i.e. , @xmath232 .    next we state the main result of this section .",
    "the tuple @xmath55 is a monad on @xmath0 .",
    "in this section , using the famous birkhoff s representation theorem , we show that the kleisli categories of the lattice monad and the reader monad are actually isomorphic . throughout this section ,",
    "we fix @xmath12 as the finite ordered set and @xmath156 is the set of all downward closed subsets of @xmath12 . recall that every downward closed subset of @xmath12 can be represented by a principal ideal of @xmath156 . as a result , in the sequel , we do not distinguish between the elements of @xmath156 and @xmath12 .",
    "we start out by defining natural transformations @xmath233 and @xmath234 .",
    "subsequently , we will show that the lattice monad and the reader monad are equivalent in the sense that , for any object @xmath31 in @xmath0 , we have @xmath235 .",
    "lastly , we will show that the induced kleisli categories are isomorphic as well .",
    "[ def : transformers ] define two families of arrows @xmath236 and @xmath237 ( for each ordered set @xmath15 ) in the following way : @xmath238    for an object in @xmath0 , the induced functions @xmath239 and @xmath240 are arrows in @xmath241 .",
    "let @xmath31 be an ordered set . to show that @xmath242 is order preserving , let @xmath243 , for some @xmath244 .",
    "i.e. , @xmath245 for all @xmath207 ( remember the reversal of orders in the lattice monad @xmath67 ) . since @xmath245 for all @xmath207",
    ", it must hold @xmath246 and to show that @xmath247 is order preserving , @xmath248 . now if @xmath249 ( which is always true ) , then @xmath250 implies @xmath251 , thus , @xmath252 for all @xmath102 and , due to the reversal of the order in @xmath67 , @xmath253 .",
    "next , we show that the functions @xmath242 and @xmath247 ( for an ordered set @xmath31 ) are well defined .",
    "the next lemma proves this fact .",
    "let @xmath31 be an ordered set .    1 .",
    "if @xmath186 , then @xmath254 , i.e. , @xmath255 is order preserving . 2 .",
    "if @xmath256 , then @xmath257 .    for ( 1 ) , let @xmath258 . then , we need to show that @xmath259 , which follows directly from the fact that @xmath260 holds .    for ( 2 ) ,",
    "let @xmath256 .",
    "then , we distinguish the following cases :    condition  [ def : t - funk-1 ] : :    using the fact that @xmath256    is a total function , we get    @xmath261 condtion  [ def : t - funk-2 ] : :    let @xmath131 . then , using distributivity we find    @xmath262    furthermore ,    @xmath263    next , we show that    @xmath264    to complete the proof for this case . the direction    ` @xmath265 ' is obvious because    @xmath266 . for the other    direction ,",
    "let @xmath267 and    @xmath268 .",
    "then , using order preservation of    @xmath269 we find    @xmath270 .",
    "likewise , @xmath271 .",
    "condition  [ def : t - funk-3 ] : :    let @xmath3 be a join irreducible element and let    @xmath272 .",
    "then , we find that    @xmath273 .    now suppose @xmath274 , for    some @xmath275 .",
    "then ,    @xmath276 .",
    "since @xmath3 is join - irreducible , we get    @xmath277 as required .    to show that @xmath239 and @xmath278 are isomorphisms between the two kleisli categories",
    ", we will proceed to show that they are each other s inverses .",
    "the transformations @xmath239 and @xmath278 are each other s inverses .",
    "let @xmath31 be an ordered set .",
    "then we distinguish the following cases .    * to show @xmath279 , for @xmath186 .",
    "expanding @xmath280 we get @xmath281 now , if @xmath282 , then @xmath283 and thus @xmath284 . if , on the other hand , @xmath284 holds , then there is a @xmath285 such that @xmath286 and @xmath175 . since @xmath173 is order preserving",
    ", it follows that @xmath287 . * to show @xmath288 , for @xmath289 . expanding @xmath290 we get @xmath291 clearly , @xmath292 .",
    "if , on the other hand , @xmath293 , i.e. @xmath294 , let @xmath295 . then , @xmath296 holds . since @xmath3 is a join - irreducible element , we find @xmath297 and @xmath298 , for some @xmath5 .",
    "lastly , order preservation of @xmath269 and transitivity of @xmath299 together yields @xmath267 .    henceforth , throughout this section , for an order preserving function @xmath300 , we write @xmath48 to denote the image of @xmath38 under the reader monad , i.e. , @xmath301 , for any @xmath256 .",
    "the family @xmath239 given in definition  [ def : transformers ] is a natural transformation .",
    "given an order preserving function @xmath33 , we need to show @xmath302 , for any @xmath186 and @xmath6 .",
    "@xmath303 in the last step we used monotonicity of @xmath38 .",
    "on the other hand we have : @xmath304 we will now show that both the expressions are equal .",
    "* let @xmath305 , i.e. @xmath102 be chosen such that @xmath306 . then , @xmath307 and therefore @xmath308 .",
    "so , in particular , @xmath309 .",
    "* let @xmath310 . since @xmath3 is join - irreducible , there must be a @xmath104 such that @xmath311 and @xmath312 , i.e. @xmath313 .    the family @xmath240 given in definition  [ def : transformers ] is a natural transformation .",
    "let @xmath314 , @xmath315 , @xmath33 .",
    "we compute : @xmath316 as well as : @xmath317 we will now show that @xmath318 , and therefore that their suprema are identical , too .    * let @xmath267 and @xmath205 , then , due to monotonicity of @xmath38 , @xmath319 . *",
    "let @xmath320 .",
    "we define @xmath321 and observe that @xmath322 .",
    "now we want to show that the units are isomorphic as well .",
    "let @xmath31 be an ordered set .",
    "then , the following properties hold .    1 .   for all @xmath131 we have @xmath323[alpham1nu ]",
    "2 .   for all @xmath207 , @xmath2 we have @xmath324.[alphaeta ]    for ( 1 ) , we derive @xmath325 for ( 2 ) , we find @xmath326 .    in order to prove that the respective multiplications of our monads are isomorphic",
    ", we will investigate commutativity of two diagrams ( drawn below in lemma  [ multiso1 ] and lemma  [ multiso2 ] , the proofs can be found in appendix  [ sec : proofs ] ) that basically describe the translation process from one multiplication to the other and vice versa .",
    "this is later used to prove that the corresponding kleisli categories are isomorphic .",
    "[ multiso1 ]    the following diagram commutes for all @xmath327 :        [ multiso2 ]    the following diagram commutes for all @xmath328 :        using the equivalence of the lattice and the reader monads , we can establish an equivalence between the corresponding kleisli categories as well .",
    "[ thm : lmon - tmon - equiv ] the categories @xmath58 and @xmath329 are isomorphic via the mapping @xmath330 defined as @xmath331 , for every @xmath332 in @xmath333 and @xmath334 , for every @xmath335 in @xmath329 .",
    "we have already shown that @xmath336 and @xmath337 , so we only have to prove that @xmath338 and @xmath339 are functors .    *",
    "we show that @xmath338 is a functor . *",
    "* @xmath338 preserves identities .",
    "let @xmath340 then we can compute @xmath341 * * @xmath338 respects concatenation .",
    "let @xmath23 , @xmath342 , we compute : @xmath343 * we show that @xmath339 is a functor .",
    "* * @xmath339 preserves identities .",
    "let @xmath344 then we can compute @xmath345 * * @xmath339 respects concatenation .",
    "let @xmath23 , @xmath342 , we compute : @xmath346    when proving the equivalence of the reader monad and the lattice monad , the duality between complete finite distributive lattices and partially ordered sets plays an important role , namely when defining the isomorphisms @xmath239 and @xmath278 .",
    "considering there is a similar duality between complete distributive lattices ( not necessarily finite ) and clopen downsets on priestley spaces ",
    "i.e. spaces of partially ordered sets with a topology that makes them totally order disconnected  one might wonder why we restrict to the finite variant .    to make a similar duality result work for the infinite case , we would need to restrict the lattices with additional assumptions , because not all bounded distributive lattices are isomorphic to a lattice of downsets of a partial order .",
    "this holds if additionally the jid and its dual hold and some notion of atomicity holds for the irreducibles in the lattice @xcite .",
    "this however would make the definition of the lattice monad more complicated .",
    "recall that once a condition is fixed by a cts then it behaves like a traditional transition system ( until another upgrade ) .",
    "thus , it is natural to consider the the power set functor to model the set of next - possible states when the upgrade order is discrete . in this section ,",
    "we investigate the finite version of the well known power set functor .",
    "this way of modelling cts adapts the approach in @xcite , where the set of actions @xmath78 was fixed to be singleton .",
    "in addition , through a counterexample , we will illustrate why behavioural equivalence in the coalgebras for this branching type functor does not characterise the conditional bisimilarity in the presence of upgrades , i.e. , when @xmath8 is not a discrete order .",
    "[ def : p - funk ] the functor @xmath13 on @xmath0 is defined according to :    * on objects @xmath31 we have @xmath347 , so @xmath348 is the set of all finite subsets of @xmath15 , ordered by inverse inclusion .",
    "* let @xmath349 , then @xmath350 is defined as @xmath351 , so @xmath352 is the image of @xmath353 under @xmath38 .",
    "it is easy to see that @xmath13 is an endofunctor on @xmath0 ( the proof is similar to the power set functor on @xmath25 ) . now in order to lift @xmath13 to @xmath329 , we need to find a distributive law @xmath354 .",
    "this lifting then allows to define cts in @xmath329 .",
    "consider the following family of mapping @xmath355 ( for every ordered set @xmath31 ) : @xmath356 .    as expected , we obtain the following result .",
    "the mapping @xmath76 defined above is a distributive law .",
    "first , we show that @xmath76 is a natural transformation .",
    "let @xmath357 and @xmath2 .",
    "@xmath358\\mid c\\in s\\}\\}\\\\          = & \\{f(x)\\mid x\\in\\{c({\\varphi})\\mid c\\in s\\}\\}\\\\          = & \\{f(x)\\mid x\\in\\lambda_x(s)({\\varphi})\\ }          = \\mathcal p(f)(\\lambda_x(s)({\\varphi}))=\\mathcal p(f)^\\phi(\\lambda_x(s))({\\varphi } ) .",
    "\\end{aligned}\\ ] ] second , we show that the pentagonal law holds for @xmath76 , i.e. , for all @xmath359 , @xmath2 we have @xmath360 .",
    "we compute : @xmath361\\mid c'\\in s\\}\\}\\\\          = & \\{c({\\varphi})\\mid c\\in\\lambda_{x^\\phi}(s)({\\varphi})\\}\\\\          = & \\lambda_{x^\\phi}(\\lambda_{x^\\phi}(s))({\\varphi})({\\varphi } )          = \\zeta_{\\mathcal p(x)}(\\lambda_{x^\\phi}(\\lambda_{x^\\phi}(s)))({\\varphi } ) .",
    "\\end{aligned}\\ ] ] lastly , we show that the triangular law holds for @xmath76 , i.e. , for all @xmath362 and @xmath2 we have @xmath363 .",
    "note @xmath364 .",
    "@xmath365\\mid x\\in s\\}\\}=s .",
    "\\end{aligned}\\ ] ]    now to model cts with action labels ( the case when @xmath366 ) we use a a distributive law between the functor @xmath367 and @xmath368 .",
    "the following result is a straightforward exercise in currying ; however , we present it for the sake of completeness .",
    "we define the distributive law @xmath369 according to @xmath370    the above mapping @xmath371 results in a distributive law .    to see that @xmath371 is a natural transformation , let @xmath2 , @xmath132 and @xmath372 .",
    "then @xmath373 for the pentagonal law , we find @xmath374 and @xmath375",
    "lastly , for the triangular law , we derive @xmath376    as a result , a given cts @xmath377 with @xmath8 as equality can be seen as a coalgebra @xmath378 in @xmath333 where @xmath32 is equality .",
    "next , we prove that behavioural equivalence for coalgebras in @xmath333 characterises conditional bisimilarity between the states of a system .",
    "given a cts @xmath379 over a discretely ordered set of conditions @xmath12 , two states @xmath95 are bisimilar if and only if there exists a coalgebra homomorphism @xmath380 such that @xmath381 .",
    "* given coalgebra homomorphism @xmath382 , we define the family of relations @xmath91 ( for each @xmath6 ) as : @xmath383 .",
    "next , we show that @xmath91 satisfy the transfer property of a bisimulation relation",
    ". let @xmath384 and @xmath82 .",
    "then @xmath385 i.e. , there exists a @xmath386 such that @xmath387 , i.e. , @xmath388 .",
    "therefore , the family @xmath389 is a conditional bisimulation . * given a family of bisimulation relations @xmath389 , we define the equivalence classes @xmath390_{\\varphi}=\\{y\\in x\\mid ( x , y)\\in                    r_{\\varphi}\\}$ ] and set @xmath391_{\\varphi}\\mid x\\in                    x,{\\varphi}\\in\\phi\\}$ ] with @xmath392 equality .",
    "now let @xmath393 as @xmath394_{\\varphi}$ ] and define a coalgebra @xmath395 as @xmath396_{\\varphi})(a)({\\varphi } ) = \\{[y]_{\\varphi}\\mid \\exists_{x',y'}\\ x'\\in [ x]_{\\varphi}\\land y'\\in[y]_{\\varphi}\\ \\land x ' \\xrightarrow{a,{\\varphi } } y'\\}.\\ ] ] clearly , @xmath38 and @xmath397 are order preserving since @xmath12 is discretely ordered .",
    "lastly , to show that @xmath38 is a coalgebra homomorphism , it suffices to show that @xmath398_{\\varphi})(a)({\\varphi})=\\{[y]_{\\varphi}\\mid x\\xrightarrow{a,{\\varphi}}y\\}$ ] , for any @xmath399 .",
    "the direction ` @xmath400 ' is obvious , so consider @xmath401_{\\varphi}\\in \\beta([x]_{\\varphi})(a)({\\varphi})$ ] .",
    "then , we find some @xmath402 such that @xmath403_{\\varphi}\\land y'\\in[y]_{\\varphi}\\ \\land x ' \\xrightarrow{a,{\\varphi } } y'$ ] . now using the transfer property of bisimulation",
    ", we find some @xmath404 such that @xmath405 and @xmath406_{\\varphi}$ ] , i.e. , @xmath390_{\\varphi}\\xrightarrow{a,{\\varphi } } [ y]_{\\varphi}$ ] .",
    "next , through an example , we show that the previous correspondence between conditional bisimilarity and behavioural equivalence fails to hold when @xmath12 is non - discretely ordered .",
    "it is the following extra property which fails to hold : if @xmath407 then @xmath408 , for any @xmath409 . as a result",
    ", we conclude that @xmath13 is not the ` right ' functor to model ctss with upgrades .",
    "consider the set of conditions @xmath410 , where @xmath411 and @xmath412 .",
    "since the set @xmath78 is singleton , we omit the corresponding argument in the sequel .",
    "consider the cts @xmath413 as depicted below in the left with @xmath99 .",
    "for instance @xmath414 , @xmath415 , the remaining cases can be inferred from the drawing .",
    "note that @xmath102 and @xmath106 are not bisimilar under @xmath3 because @xmath102 can do a step to @xmath103 without upgrading .",
    "this step can only be matched by a step from @xmath106 to @xmath416 .",
    "now , from @xmath103 , after an upgrade to @xmath5 , a step can be executed ; whereas , from @xmath416 no steps are possible after an upgrade to @xmath5 .",
    "nevertheless , there is a coalgebra homomorphism that maps @xmath102 and @xmath106 to the same element for both @xmath3 and @xmath5 .",
    "consider the coalgebra @xmath397 , depicted above in the right , defined over the set @xmath417 with the order @xmath418 , @xmath419 .",
    "define an arrow @xmath420 : @xmath421 by inspection we note that @xmath38 is a coalgebra homomorphism . the interesting combination to verify are the tuples @xmath422 , and @xmath423 ; while for the remaining tuples the two sides of the equation @xmath24 would result in an empty set .",
    "for instance , @xmath424 and @xmath425 .",
    "moreover , it is easy to check that @xmath38 is order preserving . thus , the coalgebra homomorphism @xmath38 maps @xmath102 and @xmath106 to the same element for all elements in @xmath12 , even though the two states @xmath102 and @xmath106 are not conditionally bisimilar .",
    "in the previous section , we argued that the functor @xmath13 is not fit to model cts with a non - discrete order , since the behavioural equivalence does not coincide with conditional bisimulation .",
    "the reason can intuitively be understood as follows : using the functor @xmath13 , the version of the system is hidden as a side effect and therefore not considered in the behavioural equivalence  after all this is the purpose of modelling using a kleisli category . however , while the versions can be seen as side effects in the absence of upgrades , this is no longer true when a cts can perform an upgrade .",
    "upgrades are monotone by nature , so in order to perform an upgrade , one must be aware of the current version of the system .",
    "alternatively , one can observe , that in the characterisation via the conditional bisimulation game , an upgrade must be answered by an upgrade to the same system ( see @xcite ) .",
    "consequently , a functor that is fit to model cts with upgrades has to carry information regarding the current version the system is operated under . to this end , we define the functor @xmath18 in the sequel to allow for a transition from a state not only to a set of states , but a set of states with corresponding next versions .",
    "we work in a category @xmath329 and define the cts functor directly on this category .",
    "[ def : f - funk - up ] consider the following mapping @xmath426 defined as follows :    objects : :    @xmath427 , for an object    @xmath15 in @xmath0 ; arrows : :    @xmath428 ,    for an arrow @xmath429 in    @xmath333 with    @xmath430 and    @xmath132 .",
    "the above mapping @xmath18 is a functor .    to prove that @xmath18 preserves identities ,",
    "let @xmath31 be an ordered set and let @xmath431 .",
    "then , @xmath432 .    for the preservation of function compositions ,",
    "let @xmath193 and @xmath433 be two arrows in @xmath333 .",
    "then , we find @xmath434    now a cts @xmath435 over a finite set of states @xmath15 ( that is ordered trivially ) , a finite set of actions @xmath78 , and a set of conditions @xmath12 is modelled by the following arrow in @xmath333:@xmath436 as can be observed above , @xmath437 is just a pure arrow , so the definition of @xmath239 must account for the filtering for the next states . the modelling can be understood as follows : given a state @xmath102 , an action @xmath438 and a current version @xmath3 , we consider all possible upgrades @xmath411 that could be performed and collect all states @xmath106 that can be reached under @xmath5 .",
    "we then collect all those pairs of follow - up state and upgraded product .",
    "note that not doing an upgrade , but continuing with the current version @xmath3 is permissible as well .",
    "we now prove the main result of this section ; namely that behavioural equivalence coincides with conditional bisimulation .",
    "let @xmath439 in @xmath333 be a cts where @xmath32 is equality .",
    "then , two states @xmath131 are conditionally bisimilar under @xmath2 ( @xmath96 ) if and only if there exists a coalgebra homomorphism @xmath440 ( for some @xmath441 ) in @xmath333 such that @xmath442 .",
    "define a family of relations @xmath91 ( for each @xmath6 ) as follows : @xmath443 if and only if there _ exists _ a coalgebra homomorphism @xmath440 in @xmath333 such that @xmath442 .",
    "we first show that each @xmath91 satisfies the transfer property of a traditional bisimulation relation .",
    "let @xmath444 and @xmath445 . then , by the construction of @xmath91 we have some coalgebra homomorphism @xmath440 in @xmath333 with @xmath446 .",
    "thus , @xmath447 .",
    "then @xmath448 i.e. , there is some @xmath449 such that @xmath450 .",
    "therefore , @xmath451 and @xmath452 .",
    "hence , @xmath453 .",
    "next , we need to show that if @xmath454 then @xmath455 . so let @xmath456 and @xmath457 . then , by the construction of @xmath458 we have some coalgebra homomorphism @xmath440 in @xmath333 such that @xmath459 .",
    "thus , for any @xmath132 , we have @xmath460 note that @xmath461 since @xmath462 .",
    "thus , @xmath463 , i.e. , @xmath464 . now to show that @xmath465 we construct a new coalgebra which witnesses this .",
    "define an equivalence relation @xmath466 on the set @xmath467 as follows : @xmath468 , for all @xmath132 .",
    "in addition , consider the following constructions :    * the elements of the quotient set @xmath469 are ordered trivially .",
    "* define a function @xmath470 in @xmath333 as follows : @xmath471_\\equiv$ ] .",
    "we abbreviate an element @xmath472_\\equiv\\in ( y\\times\\phi)/\\equiv$ ] as @xmath401_{\\varphi}$ ] . *",
    "define a function @xmath473 as follows : @xmath474_{\\varphi})({\\varphi}')(a)=          \\begin{cases }            \\{([y']_{{\\varphi}''},{\\varphi } '' ) \\mid ( y',{\\varphi}'')\\in\\beta(y)({\\varphi}')(a)\\ } , & \\mbox{if } { \\varphi}={\\varphi } ' \\\\",
    "\\emptyset , & \\mbox{otherwise}.          \\end{cases}\\ ] ]    clearly , if @xmath475 then @xmath476 .",
    "so , in particular , we have @xmath477 .",
    "thus , it remains to show that @xmath478 is a coalgebra homomorphism , i.e. , the equation @xmath479 in @xmath333 holds . to this end , we derive @xmath480_{{\\varphi}'},{\\varphi } ' ) \\mid ( y',{\\varphi}')\\in\\beta((f(x))({\\varphi}))(a)\\}\\\\      = & \\ \\{([y']_{{\\varphi}'},{\\varphi } ' ) \\mid ( y',{\\varphi}')\\in ( ff\\circ\\alpha)(x)({\\varphi})(a)\\}\\\\      = & \\ \\{([f(x')]_{{\\varphi}'},{\\varphi } ' ) \\mid ( x',{\\varphi}')\\in \\alpha(x)({\\varphi})(a)\\}\\\\      = & \\ fg ( \\alpha(x)({\\varphi}))(a ) .",
    "\\end{aligned}\\ ] ] let @xmath91 ( for @xmath2 ) be a family of largest bisimulation relations on the given cts such that @xmath408 , whenever @xmath481 . since the largest bisimulation relation is an equivalence relation on the set of states , we can define the following function @xmath482 in @xmath333 : @xmath394_{\\varphi}$ ] , where @xmath390_{\\varphi}$ ] is the equivalence class of @xmath102 under @xmath91 and @xmath483_{\\varphi}\\mid { \\varphi}\\in \\phi\\}$ ] is ordered trivially .",
    "next , define the function @xmath484 as : @xmath485_{\\bar{\\varphi}})({\\varphi}')(a)=\\big\\{([x']_{{\\varphi } '' } , & { \\varphi}'')\\mid { \\varphi}''\\leq_{\\phi } { \\varphi } ' \\ \\land \\\\    & \\exists_{{\\varphi}}\\ { \\varphi}\\leq_\\phi { \\varphi } ' \\land [ x]_{\\varphi}= [ x]_{\\bar { \\varphi } } \\land \\exists_{y , y'}\\ y \\xrightarrow { a,{\\varphi } '' } y ' \\land x r_{{\\varphi } } y\\land x ' r_{{\\varphi } '' } y'\\big\\}.\\end{aligned}\\ ] ] first we show that @xmath397 is well defined .",
    "let @xmath486_{{\\varphi}_1}=[x_2]_{{\\varphi}_2}$ ] .",
    "then , we need to show that @xmath487_{{\\varphi}_1})({\\varphi}')(a)=\\beta([x_2]_{{\\varphi}_2})({\\varphi}')(a)$ ] .",
    "let @xmath488_{{\\varphi}''},{\\varphi}'')\\in \\beta([x_1]_{{\\varphi}_1})({\\varphi}')(a)$ ] .",
    "then , @xmath489 and there are @xmath490 such that @xmath258 , @xmath486_{{\\varphi}}= [ x_1]_{{\\varphi}_1}$ ] , @xmath491 , @xmath492 , and @xmath493 .",
    "clearly , @xmath486_{\\varphi}=[x_1]_{{\\varphi}_1}=[x_2]_{{\\varphi}_2}$ ] .",
    "thus , @xmath488_{{\\varphi}''},{\\varphi}'')\\in \\beta([x_1]_{{\\varphi}_1})({\\varphi}')(a)$ ] .",
    "likewise , the other direction can be proved ; thus , @xmath397 is well defined .    to show that @xmath397 is order preserving",
    ", it suffices to check that it is order preserving in the second argument .",
    "so let @xmath494 and let @xmath488_{{\\varphi}''},{\\varphi}'')\\in\\beta ( [ x]_{\\bar{\\varphi}})({\\varphi}_1)(a)$ ] .",
    "then , by construction of @xmath397 we find @xmath495 , @xmath496 , @xmath390_{\\varphi}=[x]_{\\bar { \\varphi}}$ ] , @xmath497 , @xmath384 , and @xmath498 , for some @xmath499 . and transitivity of @xmath8 gives @xmath500 and @xmath501 .",
    "thus , @xmath488_{{\\varphi}''},{\\varphi}'')\\in\\beta ( [ x]_{\\bar{\\varphi}})({\\varphi}_2)(a)$ ] . clearly , @xmath502 since @xmath408 .",
    "thus , @xmath38 is order preserving .",
    "next , it remains to show that @xmath503 , for any @xmath504 .",
    "i.e. , it is sufficient to show that @xmath398_{\\varphi})({\\varphi})(a)=\\{([x']_{{\\varphi}'},{\\varphi } ' ) \\mid { \\varphi}'\\leq_\\phi { \\varphi}\\land x \\xrightarrow{a,{\\varphi } ' } x'\\}$ ] .",
    "the inclusion from right to left is trivial .",
    "so consider @xmath488_{{\\varphi}''},{\\varphi}'')\\in\\beta ( [ x]_{\\bar{\\varphi}})(\\bar { \\varphi})(a)$ ] .",
    "then , we find @xmath505 and some @xmath499 such that @xmath506 , @xmath390_{{\\varphi}}=[x]_{\\bar { \\varphi}}$ ] , @xmath491 , @xmath507 , and @xmath508 .",
    "clearly , @xmath509 ( since @xmath505 ) and @xmath390_{{\\varphi}}=[x]_{\\bar { \\varphi}}$ ] ; thus , @xmath510 . and by transfer property of bisimulation we find some @xmath404 such that @xmath511 and @xmath512 .",
    "lastly , by transitivity of @xmath513 we conclude that @xmath514_{{\\varphi}''}=[x']_{{\\varphi}''}$ ] .",
    "so @xmath18 indeed offers a way of modelling cts in the presence of upgrades .",
    "note , however , that @xmath18-coalgebras exist that are not cts themselves , as a consequence the above result is limited to systems modelled as described before .",
    "in this section , we concentrate on algorithms to obtain a minimal cts from a given cts up to conditional bisimilarity . we first recall ( briefly ) the final chain algorithm for minimisation from @xcite to compute behavioural equivalence .",
    "in addition , we will show that the algorithm ( @xcite ) is to the power set functor @xmath13 , as well as the functor @xmath18 ( definition  [ def : f - funk - up ] ) .",
    "below we recall the necessary definitions from @xcite ( for a more detailed presentation , see @xcite ) .",
    "let @xmath515 be a subcategory of @xmath21 and let @xmath15 be an object of @xmath21 .",
    "then , an _ @xmath515-reflection _ for @xmath15 is a @xmath21-arrow @xmath516 into some object @xmath517 of @xmath515 such that the following universal property is satisfied : for any @xmath21-arrow @xmath193 into some object @xmath34 of @xmath515 , there exists a _ unique _",
    "@xmath515-arrow @xmath518 ( called @xmath519-reflection of @xmath38 ) such that @xmath520 .",
    "moreover , @xmath515 is a _ reflective _ subcategory of @xmath21 if each object of @xmath21 has an @xmath515-reflection .    for our purpose ,",
    "we need to show that @xmath0 is a reflective subcategory of @xmath329 . to this end",
    ", we first note that an arrow @xmath300 in @xmath0 can be interpreted as a ` pure ' arrow @xmath521 in @xmath329 , simply by letting @xmath522 , for all @xmath2 . clearly , the pure arrow @xmath523 is order preserving just because @xmath38 is .",
    "thus , @xmath0 is a subcategory of @xmath333 . due to the kleisli adjunction",
    "it is well - known that @xmath0 is a coreflective subcategory of @xmath329 .",
    "here we show that it is reflective as well .",
    "[ thm : pos - ref ] the category @xmath0 is a reflective subcategory of @xmath329 .    for an object @xmath31 in @xmath333 , we define its @xmath0-reflection @xmath524 as @xmath525 .",
    "the set @xmath526 is ordered as follows : @xmath527 .",
    "now for an arrow @xmath300 in @xmath333 , we need to find its @xmath519-reflection @xmath528 .",
    "so let @xmath529 , for any @xmath207 and @xmath2 . to show that @xmath530 is order preserving , let @xmath531 and @xmath258 .",
    "then , we find @xmath532 and @xmath533 since @xmath38 is an arrow in @xmath333 .",
    "thus , @xmath534 .",
    "moreover , for any @xmath535 we have @xmath536 now assume an order preserving function @xmath537 such that @xmath538 .",
    "then , for any @xmath535 we find that @xmath539 .",
    "thus , @xmath540 .    following @xcite , a reflective subcategory that has an @xmath541-factorisation structure gives rise to a pseudo - factorisation structure in the base category , which in turn can be used to compute behavioural equivalence , provided the functor meets some conditions .",
    "let @xmath542 and @xmath543 be any two classes of morphisms in a category @xmath544 . then the tuple @xmath541 is called a _ factorisation structure _ for @xmath544 if    * the classes @xmath542 and @xmath543 are closed under composition with isomorphisms ; * every arrow @xmath38 of @xmath515 has a factorisation @xmath545 , where @xmath546 and @xmath547 ; * _ unique diagonal property _ : for all arrows @xmath548 , @xmath547 , and @xmath546 , if @xmath549 , then there exists a unique arrow @xmath550 such that @xmath551 and @xmath552",
    ".    given a reflective subcategory @xmath515 of @xmath21 with its reflection @xmath519 that has an @xmath553-factorisation structure .",
    "then , the category @xmath21 has a so - called @xmath541-_pseudo _ factorisation structure since every @xmath21-arrow @xmath23 into some object @xmath34 of @xmath515 can be factored as @xmath554 where @xmath555 ( for @xmath556 ) is the decomposition of the @xmath519-reflection of @xmath38 . for such pseudo - factorisations",
    ", we do not necessarily have a diagonal arrow , but one can show that such an arrow exists whenever @xmath478 is in @xmath544 .",
    "[ def : fact - poset ] we define a _ factorisation structure for @xmath0 _ in the following way :    * an order - preserving function @xmath33 is in @xmath557 if and only if @xmath23  is surjective  in  @xmath25 , and @xmath392 is the smallest order satisfying @xmath558 whenever @xmath559 . in other words ,",
    "@xmath560 ( for @xmath197 ) if and only if there are @xmath561 such that @xmath562 , @xmath563 and @xmath564 for all @xmath565 $ ] .",
    "* an order - preserving function @xmath33 is in @xmath543 if and only if @xmath23 is injective in @xmath25 .",
    "the tuple @xmath541 from definition  [ def : fact - poset ] is a factorisation structure for @xmath0 .",
    "the class @xmath542 and @xmath543 is closed under composition with isomorphisms is standard . for instance , an isomorphism ( order preserving bijection ) composed with an order preserving surjection ( injection ) is again an order preserving surjection ( injection ) .",
    "* an arrow @xmath33 can be factorised into an arrow @xmath566 and an arrow @xmath567 just like in @xmath25 .",
    "here , @xmath568 is the smallest order which makes the function @xmath569 an order preserving , i.e. , @xmath570 if and only if there are @xmath571 such that @xmath572 , and @xmath573 , for all @xmath565 $ ] .",
    "the relation @xmath568 is reflexive because @xmath569 is surjective and @xmath568 is transitive by construction .",
    "lastly , antisymmetry of @xmath568 follows directly from @xmath392 . * the unique diagnal property holds .",
    "let @xmath574 , @xmath575 , @xmath576 , and @xmath577 such that @xmath578 there exists a unique diagonal arrow @xmath579 such that @xmath580 and @xmath581 .",
    "since any such diagonal arrow would also be a diagonal arrow in @xmath25 , uniqueness is clear , we only need to show the existence of diagonal arrow .",
    "define a function @xmath582 .",
    "since @xmath569 is surjective , @xmath550 is well - defined .",
    "now , we show that @xmath550 is order preserving .",
    "let @xmath583 , for some @xmath584 . then there are @xmath585 such that @xmath586 .",
    "we know that , since @xmath478 is order - preserving , @xmath587 and want to show that for all @xmath588 we have @xmath589 . assume , on the contrary , that @xmath590 for any @xmath591 , then @xmath592 , because @xmath593 is injective . then , @xmath594 , but this is a contradiction , because @xmath595 .",
    "so , we can conclude : @xmath596 .",
    "now that we have seen that there is a factorisation structure in @xmath0 and that it can be lifted to @xmath329 , we want to make explicit what it means to factorise in @xmath329 .",
    "recall @xmath597 from theorem  [ thm : pos - ref ] and consider the following data :    * an arrow @xmath393 given in @xmath333 with the set @xmath598 . * the function @xmath599 defined as @xmath600 , for every @xmath601 . *",
    "the relation @xmath602 is the smallest order such that @xmath603 is order preserving . * the function @xmath604 defined as @xmath605 , for every @xmath606 .",
    "then , @xmath607 is a pseudo - factorisation of @xmath38 .",
    "given an arrow @xmath300 in @xmath333 .",
    "then , recall from the proof of theorem  [ thm : pos - ref ] , we have @xmath608 and a unique order preserving function @xmath609 such that @xmath610 . now factorising @xmath530 in @xmath0 we get the decomposition @xmath555 with the functions @xmath611 and @xmath612 defined in the obvious way .",
    "note that the order @xmath613 is the smallest order which makes @xmath569 order preserving .",
    "then , interpreting these functions as pure arrows we get @xmath614 .",
    "thus , @xmath615 .",
    "we now recall the algorithm from @xcite in its entirety .",
    "[ algo : minimisation ] let @xmath21 be a category with a final object @xmath616 and let @xmath515 be a complete and reflective subcategory of @xmath21 that has an @xmath541-factorisation structure where all arrows in @xmath542 are epimorphism and for all objects @xmath15 there is only a set of @xmath542 morphisms with domain @xmath15 .",
    "furthermore , let @xmath617 be an endofunctor on @xmath21 preserving @xmath515 and @xmath543 .",
    "given a @xmath617-coalgebra @xmath618 we can then compute the minimisation of @xmath617 in the following way :    1 .",
    "let @xmath619 be the unique arrow into the final object .",
    "2 .   given a @xmath620 , pseudo - factorise @xmath621 , where @xmath622 , @xmath623 , @xmath624 .",
    "3 .   compute @xmath625 .",
    "4 .   the algorithm terminates if there exists an isomorphism @xmath591 such that @xmath626 and yields @xmath627 as its output .",
    "the dashed arrows in the diagram above are obtained by diagonalisation .    whenever the algorithm terminates we have a coalgebra homomorphism @xmath627 from @xmath239 to @xmath628 . the algorithm s output @xmath627 characterises behavioural equivalence in the following way : two states @xmath102 and @xmath103 are behaviourally equivalent if and only if @xmath629 . for instance , the functor @xmath13 ( cf .",
    "definition  [ def : p - funk ] ) preserves both the reflective subcategory @xmath0 and the class of order preserving injective functions @xmath543 . as a result",
    ", the above algorithm can be used to compute greatest conditional bisimilarity for systems without upgrades .",
    "the functor @xmath13 ( cf .",
    "definition  [ def : p - funk ] ) preserves @xmath0 and @xmath543 .    to show that @xmath13 preserves @xmath0 ,",
    "let @xmath300 be an arrow in @xmath0 .",
    "then , we need to show that @xmath630 is a pure arrow .",
    "so let @xmath631 and @xmath409 .",
    "then @xmath632",
    "lastly , to show that @xmath13 preserves @xmath543 , let @xmath633 be an order preserving injection . from above , we find @xmath634 is an arrow in @xmath0 .",
    "let @xmath635 .",
    "then , we find @xmath636 and injectivity of @xmath593 gives @xmath637 .",
    "thus , @xmath634 is also injective .",
    "the next two lemmas show that the algorithm from @xcite is applicable to compute the greatest conditional bisimilarity for the systems as @xmath18-coalgebras .",
    "the functor @xmath18 ( cf . definition  [ def : f - funk - up ] ) preserves @xmath0 and @xmath543 .",
    "let @xmath638 be an arrow in @xmath0 .",
    "then we need to show that @xmath639 is a pure arrow .",
    "so let @xmath640 and @xmath409 , then @xmath641    to show that @xmath18 preserves @xmath543 , as well , let @xmath593 be an order preserving injection . as shown above",
    ", @xmath642 is an arrow in @xmath0 . to show that @xmath642 is injective , let @xmath643 be given . if @xmath644 , then for all @xmath2 and @xmath132 , @xmath645 .",
    "thus , we compute @xmath646 i.e. , for all @xmath647 , there must exist a @xmath648 such that @xmath649 .",
    "since @xmath593 is injective , it follows @xmath650 and therefore @xmath651 , and , analogously @xmath652 .",
    "thus , @xmath653 for all @xmath438 , i.e. @xmath654 .",
    "hence , @xmath642 is indeed injective .",
    "the concretisation functor @xmath655 for @xmath329 preserves monos .",
    "given a mono @xmath656 in @xmath329 and two functions @xmath657 .",
    "then @xmath658",
    "thus we can conclude that the algorithm from @xcite is applicable , using the pseudo - factorisation structure we have derived .",
    "we now discuss a small example for the application of the minimisation algorithm from @xcite using this pseudo - factorisation structure on @xmath329 for the functor @xmath18 .",
    "let @xmath99 , @xmath84 and @xmath100 , with @xmath7 .",
    "let @xmath659 be the coalgebra modelling the cts depicted below .",
    "let @xmath99 , @xmath84 and @xmath100 , with @xmath7 .        to compute the behavioural equivalence , we start by taking the unique morphism @xmath619 into the final object of @xmath329 that is @xmath660 . at the @xmath591^th^ iteration , we obtain @xmath661 via the pseudo - factorisation of @xmath662 and then we build @xmath663 .",
    "these iterations are shown in the following tables .",
    "note that each table represents both , @xmath664 and @xmath661 , because the pseudo - factorisation just yields simple injections as monomorphisms , so @xmath664 and @xmath661 in each step only differ by their codomain .    [ cols=\"^,^,^,^,^,^,^\",options=\"header \" , ]     in the tables for @xmath665 and @xmath666 we have used colours to code the entries , because the full notation for the entries would be too large to fit in the tables .    the co - domains @xmath667 , and @xmath668 of @xmath669 , and @xmath670 ( resp . )",
    "are given below ( note that the colours in @xmath671 and @xmath668 indicate the colours in the tables above ) : @xmath672 each ordered by inclusion . by contrast , the codomain @xmath673 of @xmath664 is defined as @xmath674 , @xmath675 for @xmath676 .    by comparing the columns for each state we can determine which states are bisimilar .",
    "the partitions are divided as follows ( where @xmath677 denote the entries at the @xmath591^th^ iteration ) : @xmath678 to obtain the greatest conditional bisimulation from @xmath679 ( or @xmath670 ) , we need to compare individual entries of each table , we can identify the greatest bisimulation as @xmath680 , where ( written as equivalence classes ) @xmath681    additionally it is possible to derive the minimal coalgebra that was identified using the minimisation algorithm , which is of the form @xmath682 where @xmath683 is the arrow witnessing termination of the algorithm .",
    "the minimisation has the following form :        note that if there was no order on @xmath12 , @xmath102 and @xmath106 would be found equivalent under @xmath3 , because without upgrading , @xmath102 and @xmath106 behave the same for @xmath3 : both can do exactly one step , reaching either of @xmath684 or @xmath111 , respectively , but in none of these states and additional steps are possible in the product @xmath3 .",
    "one can observe that both @xmath102 and @xmath106 get mapped under @xmath5 to the red state ( second from bottom of the diagram ) , but under @xmath3 , the state @xmath102 gets mapped to the blue state ( top state in the diagram ) , whereas @xmath106 gets mapped to the black state ( right - most state in the diagram ) .",
    "since we have seen that @xmath58 and @xmath329 are isomorphic , we want to characterize factorisation in @xmath58 .",
    "we can factorise an arrow by converting it to a @xmath329-arrow and factorising that arrow , then translating back to @xmath58 . since we have already seen that factorising in @xmath329 basically means to exclude all states from the codomain of the arrow that are not in the image of any pair of states and alphabet symbol , this boils down to finding out when a state in a @xmath58-arrow will be identified as redundant in @xmath329 .",
    "so let @xmath685 be a @xmath58-arrow , then @xmath686 is a function @xmath687 .",
    "an element @xmath315 will occur in the image of @xmath686 in case there is an irreducible element @xmath688 such that @xmath103 is the smallest element of @xmath34 such that @xmath689 .",
    "this is true if @xmath690 .",
    "so by factorising an arrow in @xmath58 we eliminate all states such that @xmath691 for all @xmath207 .",
    "we have seen that the kleisli categories for the lattice monad and the reader monad are equivalent , providing an analogue to the birkhoff duality between lattices and partially ordered sets .",
    "this duality also reflects the duality between conditional transition systems ( cts ) and lattice transition systems ( lats ) .",
    "we have investigated two different functors , @xmath13 and @xmath18 , which can be used to model cts without upgrades and general cts , respectively , in such a way that behavioural equivalence is conditional bisimulation .",
    "though all cts with upgrades could be modelled using just @xmath13 as well , behavioural equivalence would then not coincide with conditional bisimulation . when considering upgrades , the individual products can not be considered purely a side effect and",
    "can instead be observed , which leads to the requirement of making the products explicit in a way .",
    "the kleisli category for the reader monad has a pseudo - factorisation structure that makes it possible to use a result from @xcite to compute the greatest conditional bisimulation using a final chain - based algorithm for the functors @xmath13 and @xmath18 .",
    "our work obviously stands in the tradition of the work in @xcite and @xcite . in a broader sense , the modelling technique of using kleisli categories to obtain",
    "the `` right '' notion of behavioural equivalence goes back to previous work in @xcite , where non - deterministic branching of nfa was masked by the use of a kleisli category ( over @xmath25 in this case ) to obtain language equivalence as behavioural equivalence rather than bisimulation .",
    "modelling new types of systems and behaviours coalgebraically is an ongoing field of research , as evident by recent work for instance by bonchi et al . on decorated traces @xcite , hermanns et al .",
    "on probabilistic bisimulation @xcite or latella et al .",
    "on labelled state - to - function transition systems @xcite .",
    "system models that can handle various products derived from a common base are of particular interest in the field of software product lines . featured transition systems are conceptually the closest to cts and can in fact be simulated by cts in a rather straight - forward way . due to the upgrading aspect of cts ,",
    "the same does not hold the other way around .",
    "similar systems to cts have been studied for instance by cordy et al .",
    "@xcite and kupferman @xcite .",
    "fts in particular have been an active field of study in the past years , with various similar , yet not identical definitions being conceived in various lines of work .",
    "classen et al .",
    "@xcite , as well as atlee et al .",
    "@xcite and cordy et al .",
    "@xcite have worked , among many others , on fts and the accompanying feature diagrams .    in the future ,",
    "we want to characterise cts via operational semantics and an appropiate logic .",
    "furthermore , we are interested in analysing different properties of cts rather than bisimulation , in particular we are interested in a notion of weak bisimilarity . from a modelling perspective , incorporating updates that deactivate certain transitions is a convenient feature we want to incorporate without sacrificing the algorithmic properties of cts , using prorities on transitions",
    ".    abh@xmath69212    j.  admek , f.  bonchi , m.  hlsbusch , b.  knig , s.  milius , and a.  silva . a coalgebraic perspective on minimization and determinization . in _ proc .",
    "of fossacs _ , lncs 7213 , pages 5873 .",
    "springer , 2012 .",
    "j.  m. atlee , u.  fahrenberg , and a.  legay .",
    "measuring behaviour interactions between product - line features . in _ proc .",
    "of formalise 15 _ , pages 2025 , piscataway , nj , usa , 2015 . ieee press .",
    "f.  bonchi , m.  bonsangue , g.  caltais , j.  rutten , and a.  silva . a coalgebraic view on decorated traces .",
    ", 26(7):12341268 , 2016 .",
    "h.  beohar , b.  knig , s.  kpper , and a.  silva .",
    "conditional transition systems : a model for software product lines with upgrades .",
    "submitted , available from ` http://www.ti.inf.uni-due.de/fileadmin/public/koenig/cts.pdf ` , october 2016 .",
    "m.  cordy , a.  classen , p.  heymans , a.  legay , and p .- y . schobbens . model checking adaptive software with featured transition systems . in _",
    "assurances for self - adaptive systems _ , volume 7740 of _ lncs _ , pages 129 .",
    "springer , 2013 .",
    "m.  cordy , a.  classen , g.  perrouin , p .- y .",
    "schobbens , p.  heymans , and a.  legay .",
    "simulation - based abstractions for software product - line model checking . in _ proc . of icse 12 _ , pages 672682 .",
    "ieee , 2012 .",
    "a.  classen , m.  cordy , p .- y .",
    "schobbens , p.  heymans , a.  legay , and j .- f . raskin . featured transition systems : foundations for verifying variability - intensive systems and their application to ltl model checking .",
    ", 39(8):10691089 , august 2013 .",
    "a.  classen , p.  heymans , p .- y .",
    "schobbens , a.  legay , and j .- f .",
    "model checking lots of systems : efficient verification of temporal properties in software product lines . in _ proc .",
    "of icse10 _ , pages 335344 , ny , usa , 2010 .",
    "p.  clements and l.  m. northrop . .",
    "addison - wesley longman publishing co. , inc . ,",
    "boston , ma , usa , 2001 .",
    "davey and h.a .",
    "priestley . .",
    "cambridge univ .",
    "press , 2002 .",
    "i.  hasuo , b.  jacobs , and a.  sokolova .",
    "generic trace semantics via coinduction .",
    ", 3(4:11):136 , 2007 .",
    "h.  hermanns , j.  krcl , and j.  kretnsk .",
    "probabilistic bisimulation : naturally on distributions .",
    ", abs/1404.5084 , 2014 .",
    "b.  knig and s.  kpper .",
    "generic partition refinement algorithms for coalgebras and an instantiation to weighted automata . in _ proc . of tcs",
    "14 _ , ifip aict , pages 311325 .",
    "springer , 2014 .",
    "o.  kupferman and y.  lustig .",
    "latticed simulation relations and games .",
    ", 21(02):167189 , 2010 .",
    "d.  latella , m.  massink , and e.p .",
    "de  vink .",
    "bisimulation of labelled state - to - function transition systems coalgebraically .",
    ", 11(4 ) , 2015 .",
    "philip  s. mulry .",
    ", pages 304319 .",
    "springer berlin heidelberg , berlin , heidelberg , 1994 .",
    "d.  park .",
    "concurrency and automata on infinite sequences . in p.",
    "deussen , editor , _ theoretical computer science _ ,",
    "volume 104 of _ lncs _ , pages 167183 .",
    "springer , 1981 .",
    "j.  power and d.  turi . a coalgebraic foundation for linear time semantics . in m.  hofmann , d.  pavlovi , and g.  rosolini , editors , _ proc . 8@xmath693 ctcs conf . _ , volume  29 of _ electronic notes in theoretical computer science_. elsevier , 1999 .    j.j.m.m .",
    "universal coalgebra : a theory of systems . , 249:380 , 2000 .",
    "in our previous work on conditional transition systems , where we did not consider cts and lats from a coalgebraic perspective , we also presented a fixed point algorithm to compute the greatest lattice bisimulation for an lats .",
    "the procedure works as follows :    [ algo : matrixmultiplication ] let @xmath694 be a finite lats over the finite distributive lattice @xmath695 , i.e. , the sets @xmath15 , and @xmath78 are finite .",
    "we define a series of lattice - valued relations @xmath696 .",
    "fix @xmath697 as @xmath698 for all @xmath95 . then , compute @xmath699 for all @xmath700 until @xmath701 for an @xmath702 . @xmath703 and @xmath704 are defined according to : @xmath705",
    "lastly , return @xmath706 as the greatest bisimulation .",
    "it can be shown that for two states @xmath707 @xmath96 iff @xmath708 .",
    "as explained before , cts and lats are dual models and can be translated directly into one another . using the functor @xmath18 combined with the lattice monad ,",
    "we have shown how to define lats coalgebraically .",
    "however , the final chain algorithm does not exactly replicate the fixed - point algorithm described above . instead of @xmath709 matrices over @xmath112 ,",
    "the final chain algorithm yields  before factorisation ",
    "@xmath710 matrices over @xmath112 , when translated via @xmath278 .",
    "factorisation may shrink the second dimension , but it usually is not equal to @xmath15 . we will now show that there is still a strong correspondence between the final chain algorithm and the fixed point computation : both algorithms separate pairs of states at the same point in the computation and both algorithms terminate at the same time .    let a cts @xmath20 over a finite set of states @xmath15 and a finite ordered set of conditions @xmath12 be given .",
    "moreover , consider the dual lats @xmath711 . then algorithms  [ algo : matrixmultiplication ] and  [ algo : minimisation ] terminate after the same number of iterations .    due to the special nature of the factorisation in algorithm  [ algo : minimisation ]",
    ", we will always argue using @xmath712 instead of @xmath713 .",
    "we will first show that algorithm  [ algo : minimisation ] separates two states in iteration @xmath714 if and only if algorithm  [ algo : matrixmultiplication ] does , as well . for that purpose we define the matrices @xmath715note that per definition of @xmath18 , this set is always downwards - closed for @xmath716 , and due to the @xmath717 codomain being the final object , it is also downwards - closed for @xmath718 .",
    "we can now prove that @xmath719 for all @xmath714 , proving the first claim , that two states can only get separated in both algorithms at the same time .",
    "we prove this via induction .",
    "* let @xmath718 . per definition ,",
    "@xmath720 for all @xmath95 and due to @xmath717 being the unique arrow into the final object , is must also hold that @xmath721 for all @xmath95 .",
    "* assume we have shown the claim for all @xmath722 .",
    "* we will now show that the claim also holds for @xmath723 .",
    "for this we show mutual inclusion . * * let @xmath724 for any @xmath2 , @xmath95 .",
    "then @xmath725 and  by definition of @xmath703  for all @xmath132 , @xmath411 , @xmath726 exists @xmath727 such that @xmath728 and  by definition of @xmath704  vice versa .",
    "the induction allows us to find @xmath729 and for all @xmath132 , @xmath411 , @xmath726 there exists a @xmath727 such that @xmath730 ( and vice versa ) .",
    "therefore we can compute : @xmath731 thus , @xmath732 . * * let @xmath732 , i.e. @xmath733 for all @xmath132 , @xmath411 .",
    "thus , by definition of @xmath734 , @xmath735 therefore for all @xmath411 , @xmath132 , @xmath736 , there must exist a @xmath737 such that @xmath730 and vice versa . using the induction hypothesis we can therefore find , that @xmath411 , @xmath132 , @xmath736",
    ", there must exist a @xmath737 such that @xmath738 , proving @xmath739 and vice versa , proving @xmath740 .",
    "thus , @xmath724 .",
    "so we have seen that both algorithms separate pairs of states in the same iteration .",
    "however , it still has to be shown that when no pairs of states are separated anymore , algorithm  [ algo : matrixmultiplication ] terminates .",
    "per definition , algorithm  [ algo : minimisation ] terminates at that point , as well , so algorithm  [ algo : minimisation ] can mimic algorithm  [ algo : matrixmultiplication ] .",
    "so , let @xmath741 be such that @xmath742 , and thus @xmath743 , i.e. algorithm  [ algo : matrixmultiplication ] has terminated .",
    "further , let @xmath707 be given , such that @xmath744 , i.e. for all @xmath132 , @xmath745",
    ". then @xmath746 and analogously @xmath747we know that @xmath745 , therefore , for @xmath748 there must exist a @xmath749 such that @xmath750 .",
    "since @xmath742 , it must then also hold that @xmath751 .",
    "thus we can conclude @xmath752 .",
    "thus , algorithm  [ algo : minimisation ] terminates in step @xmath753 as well .",
    "here we give proofs for all lemmas and propositions of which we have omitted the proofs in the article .",
    "we first show that @xmath754 , for any ordered set @xmath15 .",
    "condition  [ def : t - funk-1 ] follows directly @xmath755 . and",
    "for condition  [ def : t - funk-2 ] , let @xmath756 .",
    "then we find @xmath757",
    "lastly , for condition  [ def : t - funk-3 ] , given a join - irreducible element @xmath163 , we have @xmath758 .",
    "moreover , if @xmath759 , then clearly we have @xmath760 .",
    "we also need to show that @xmath61 is an arrow in @xmath241 . for that purpose let @xmath760 and an arbitrary @xmath761 be given , then @xmath762 due to the reversal of orders in @xmath763 , this actually means @xmath764 , so @xmath61 is order preserving .",
    "first we show that for any @xmath766 , we have @xmath767 .",
    "to see that condition  [ def : t - funktor ] holds , we expand @xmath768 and derive : @xmath769 for condition  [ def : t - funktor ] , the direction @xmath770 is straightforward because @xmath771 whenever @xmath772 , for any @xmath186 . for the other direction , we first note by applying jid law twice that @xmath773 it is sufficient to show that for any @xmath774 we have @xmath775 so , let @xmath774",
    ". then we derive @xmath776",
    "lastly for condition  [ def : t - funktor ] , let @xmath122 be a join - irreducible element . since @xmath766 , there is a minimal @xmath777 such that @xmath778 .",
    "i.e. , for any @xmath779 with @xmath780 we have @xmath781 , for all @xmath207 .",
    "moreover , there is a minimal @xmath782 , such that @xmath783 , since @xmath784 .",
    "then , we find @xmath785 , i.e. , @xmath786 .",
    "now let @xmath207 such that @xmath787 .",
    "thus , it remains to show that @xmath788 . to see this , we first observe that @xmath789 . and since @xmath117 is join - irreducible we find @xmath790 , for some @xmath791 .",
    "clearly , @xmath792 , ( since @xmath793 ) and @xmath780 .",
    "thus , by minimality of @xmath200 , we find @xmath208 ; hence , @xmath794 . we further need to show that @xmath230 is an arrow in @xmath241 . for that purpose let @xmath795 and any @xmath207 be given and compute @xmath796 because of the reversal of order : if @xmath795 , then @xmath797 for all @xmath798 . now , again because of the reversal of orders , it follows that @xmath799 , so @xmath230 is order preserving .",
    "now it remains to show that the @xmath230 satisfies the naturality square .",
    "let @xmath766 and @xmath315 .",
    "then , we find @xmath800 furthermore , @xmath801 suppose there are @xmath802 such that @xmath803 .",
    "thus , @xmath804 .",
    "i.e. , @xmath805 .",
    "thus , @xmath806 .",
    "the other direction is straightforward , take @xmath807 .",
    "let @xmath207 and @xmath808 .",
    "we first compute @xmath809 ( below @xmath810 ) : @xmath811 furthermore , we compute @xmath812 as follows : @xmath813 now , we observe that @xmath814 , for any @xmath173 satisfying @xmath815 ( for any @xmath275 ) .",
    "thus , @xmath816 . for the other direction , take @xmath817 ; thus , @xmath818 .",
    "let @xmath821 , @xmath2 .",
    "we compute : @xmath822 as well as @xmath823 it is sufficient to show that the following conditions are logically equivalent ( for every @xmath824 ) : @xmath825 fix @xmath826 .",
    "thus , @xmath827 .",
    "assume @xmath828 . since @xmath3 is join - irreducible , we find that @xmath829 , for some @xmath830 such that @xmath831 .",
    "let @xmath832 .",
    "then , @xmath833 moreover , from above , we have @xmath834 and @xmath831 , i.e. , @xmath835 .",
    "thus , from transitivity of @xmath299 we obtain @xmath836 .",
    "* assume @xmath841 .",
    "since @xmath3 is join - irreducible we find some @xmath842 , @xmath315 , and @xmath843 such that @xmath844 , @xmath845 , @xmath298 , @xmath297 and @xmath312 . clearly ,",
    "using order preservation of @xmath846 , and transitivity of @xmath299 , we get @xmath847 .",
    "+ moreover , @xmath848 since @xmath844 .",
    "thus , @xmath849 .",
    "since @xmath3 is join - irreducible , we find some @xmath850 such that @xmath851 and @xmath852 . and",
    "using order preservation of @xmath853 and transitivity we get @xmath854 . + now using the above facts @xmath855 , @xmath856 , and @xmath854 , we find the desired inequality : @xmath857 . *",
    "assume @xmath858 , then @xmath859 .",
    "let @xmath860 , then @xmath861 per definition .",
    "let @xmath862 , then @xmath863 .",
    "further define @xmath864 , then obviously we have @xmath865 and per definition @xmath866 .",
    "we now only have left to prove that with these definitions , @xmath867 is true .",
    "we compute : @xmath868 since @xmath859 and @xmath869 hold ; therefore , we get @xmath870"
  ],
  "abstract_text": [
    "<S> we consider conditional transition systems , that allow to model software product lines with upgrades , in a coalgebraic setting . </S>",
    "<S> we show that , by using birkhoff s duality for distributive lattices , we obtain two equivalent kleisli categories in which these coalgebras live : kleisli categories based on the reader and on the so - called lattice monad over @xmath0 . </S>",
    "<S> we study two different functors describing the branching type of the coalgebra and investigate the resulting behavioural equivalence . </S>",
    "<S> furthermore we show how an existing algorithm for coalgebra minimisation can be instantiated to derive behavioural equivalences in this setting . </S>"
  ]
}