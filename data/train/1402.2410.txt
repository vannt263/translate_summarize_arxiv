{
  "article_text": [
    "the success of sat technology in practical applications is largely driven by _ incremental solving_. sat solvers based on conflict - driven clause learning ( cdcl )  @xcite gather information about a formula in terms of learned clauses .",
    "when solving a sequence of closely related formulae , it is beneficial to keep clauses learned from one formula in the course of solving the next formulae in the sequence .",
    "the logic of quantified boolean formulae ( qbf ) extends propositional logic by universal and existential quantification of variables .",
    "qbf potentially allows for more succinct encodings of pspace - complete problems than sat .",
    "motivated by the success of incremental sat solving , we consider the problem of incrementally solving a sequence of syntactically related qbfs in prenex conjunctive normal form ( pcnf ) . building on search - based qbf solving with clause and cube learning ( qcdcl )  @xcite",
    ", we present an approach to incremental qbf solving , which we implemented in our solver .",
    "different from many incremental sat and qbf  @xcite solvers , allows to add clauses to and delete clauses from the input pcnf in a stack - based way by _",
    "push _ and _ pop _ operations . a related stack - based framework was implemented in the sat solver  @xcite . a solver api with _",
    "push _ and _ pop _ increases the usability from the perspective of a user .",
    "moreover , we present an optimization based on this stack - based framework which reduces the size of the learned clauses .",
    "incremental qbf solving was introduced for qbf - based bounded model checking ( bmc ) of partial designs  @xcite .",
    "this approach , like ours , relies on selector variables and assumptions to support the deletion of clauses from the current input pcnf  @xcite .",
    "the quantifier prefixes of the incrementally solved pcnfs resulting from the bmc encodings are modified only at the left or right end .",
    "in contrast to that , we consider incremental solving of _ arbitrary _ sequences of pcnfs . for the soundness",
    "it is crucial to determine which of the learned clauses and cubes can be kept across different runs of an incremental qbf solver .",
    "we aim at a general presentation of incremental qbf solving and illustrate problems related to clause and cube learning .",
    "our approach is _ application - independent _ and applicable to qbf encodings of _ arbitrary _ problems .",
    "we report on experiments with constructed benchmarks .",
    "in addition to experiments with qbf - based conformant planning using  @xcite , our results illustrate the potential benefits of incremental qbf solving in application domains like synthesis  @xcite , formal verification  @xcite , testing  @xcite , planning  @xcite , and model enumeration  @xcite , for example .",
    "we introduce terminology related to qbf and search - based qbf solving necessary to present a general view on incremental solving .    for a propositional variable @xmath0 , @xmath1 or @xmath2",
    "is a _ literal _ , where @xmath3 denotes the variable of @xmath4 .",
    "a _ clause _ ( _ cube _ ) is a disjunction ( conjunction ) of literals .",
    "a _ constraint _ is a clause or a cube .",
    "the empty constraint @xmath5 does not contain any literals . a clause ( cube ) @xmath6 is _ tautological _ ( _ contradictory _ ) if @xmath7 and @xmath8 .",
    "a propositional formula is in _ conjunctive ( disjunctive ) normal form _ if it consists of a conjunction ( disjunction ) of clauses ( cubes ) , called cnf ( dnf ) . for simplicity ,",
    "we regard cnfs and dnfs as sets of clauses and cubes , respectively .    a quantified boolean formula ( qbf ) @xmath9 is in _ prenex cnf ( pcnf ) _ if it consists of a quantifier - free cnf @xmath10 and a _ quantifier prefix _ @xmath11 with @xmath12 where @xmath13 are _ quantifiers _ and @xmath14 are _ blocks _",
    "( i.e.  sets ) of variables such that @xmath15 and @xmath16 for @xmath17 , and @xmath18 .",
    "the blocks in the quantifier prefix are _ linearly ordered _ such that @xmath19 if @xmath20 . the linear ordering is extended to variables and literals : @xmath21 if @xmath22 , @xmath23 and @xmath24 , and @xmath25 if @xmath26 for literals @xmath4 and @xmath27 .",
    "we consider only _ closed _ pcnfs , where every variable which occurs in the cnf is quantified in the prefix , and vice versa .",
    "a variable @xmath28 is _ universal _ , written as @xmath29 , if @xmath30 and _ existential _ , written as @xmath31 , if @xmath32 .",
    "a literal @xmath4 is universal if @xmath33 and existential if @xmath34 , written as @xmath35 and @xmath36 , respectively .",
    "an _ assignment _ is a mapping from variables to the truth values _ true _ and _ false_. an assignment @xmath37 is represented as a set of literals @xmath38 such that , for @xmath39 , if @xmath40 is assigned to false ( true ) then @xmath41 ( @xmath42 ) .",
    "pcnf @xmath43 under an assignment @xmath37 _ is denoted by @xmath44 $ ] and is obtained from @xmath43 as follows : for @xmath39 , if @xmath42 ( @xmath45 ) then all occurrences of @xmath40 in @xmath43 are replaced by the syntactic truth constant @xmath46 ( @xmath47 ) , respectively .",
    "all constants are eliminated from @xmath44 $ ] by the usual simplifications of boolean algebra and superfluous quantifiers and blocks are deleted from the quantifier prefix of @xmath44 $ ] . given a cube @xmath6 and a pcnf @xmath43 , @xmath48 : = \\psi[a]$ ] is the formula obtained from @xmath43 under the assignment @xmath49 defined by the literals in @xmath6 .",
    "the _ semantics _ of closed pcnfs is defined recursively .",
    "the qbf @xmath46 is satisfiable and the qbf @xmath47 is unsatisfiable .",
    "the qbf @xmath50 is satisfiable if @xmath51 $ ] and @xmath52 $ ] are satisfiable .",
    "the qbf @xmath53 is satisfiable if @xmath51 $ ] or @xmath52 $ ] are satisfiable .",
    "a pcnf @xmath43 is _ satisfied under an assignment _",
    "@xmath37 if @xmath44 = \\top$ ] and _ falsified _ under @xmath37 if @xmath44 = \\bot$ ] .",
    "satisfied and falsified clauses are defined analogously .",
    "given a constraint @xmath6 , @xmath54 for @xmath55 denotes the set of universal and existential literals in @xmath6 .",
    "for a clause @xmath6 , _ universal reduction _ produces the clause @xmath56 .",
    "_ q - resolution _ of clauses is a combination of resolution for propositional logic and universal reduction  @xcite . given two non - tautological clauses @xmath57 and @xmath58 and a pivot variable @xmath59 such that @xmath60 and @xmath61 and @xmath62 .",
    "let @xmath63 be the _ tentative q - resolvent _ of @xmath57 and @xmath58 .",
    "if @xmath64 is non - tautological then it is the _ q - resolvent _ of @xmath57 and @xmath58 and we write @xmath65 .",
    "otherwise , @xmath57 and @xmath58 do not have a q - resolvent .",
    "given a pcnf @xmath9 , a _",
    "q - resolution derivation _ of a clause @xmath6 from @xmath43 is the successive application of q - resolution and universal reduction to clauses in @xmath43 and previously derived clauses resulting in @xmath6 .",
    "we represent a derivation as a directed acyclic graph ( dag ) with edges ( 1 ) @xmath66 if @xmath67 and ( 2 ) @xmath68 and @xmath69 if @xmath65 .",
    "we write @xmath70 if there is a derivation of a clause @xmath6 from @xmath43 .",
    "otherwise , we write @xmath71 .",
    "q - resolution is a sound and refutationally - complete proof system for qbfs  @xcite .",
    "a _ q - resolution proof _ of an unsatisfiable pcnf @xmath43 is a q - resolution derivation of the empty clause .",
    "we briefly describe search - based qbf solving with conflict - driven clause learning and solution - driven cube learning ( qcdcl )  @xcite and related properties . in the context of _ incremental _ qbf solving , clause and cube learning requires a special treatment , which we address in section  [ sec_inc_satisfiability ] .",
    "given a pcnf @xmath43 , a qcdcl - based qbf solver successively assigns the variables to generate an assignment @xmath37 .",
    "if @xmath43 is falsified under @xmath37 , i.e.  @xmath44 = \\bot$ ] , then a new learned clause @xmath6 is derived by q - resolution and added to @xmath43 .",
    "if @xmath43 is unsatisfiable , then finally the empty clause will be derived by clause learning .",
    "if @xmath43 is satisfied under @xmath37 , i.e.  @xmath44 = \\top$ ] , then a new learned _ cube _ is constructed based on the following _ model generation rule _ , _ existential reduction _ and _ cube resolution_.    [ def_model ] given a pcnf @xmath72 , an assignment @xmath37 such that @xmath44 = \\top$ ] is a _ model of @xmath43 .",
    "_ an _ initial cube _",
    "@xmath73 is a conjunction over the literals of a model @xmath37 .",
    "given a cube @xmath6 , _ existential reduction _ produces the reduced cube @xmath74 .",
    "given two non - contradictory cubes @xmath57 and @xmath58 , _ cube resolution _ is defined analogously to q - resolution for clauses , except that existential reduction is applied and the pivot variable must be universal .",
    "the cube resolvent of @xmath57 and @xmath58 ( if it exists ) is denoted by @xmath75 .",
    "if @xmath43 is satisfiable , then finally the empty cube will be derived by cube learning ( theorem  5 in  @xcite ) .",
    "whereas in clause learning initially clauses of the input pcnf @xmath43 can be resolved , in cube learning first initial cubes have to be generated by the model generation rule , which can then be used to produce cube resolvents . similar to q - resolution derivations ( dags ) of clauses and q - resolution proofs",
    ", we define _ cube resolution derivations _ of cubes and _ proofs of satisfiability_.    _ clause derivation : _ _ cube derivation : _    .",
    "the literals in the initial cubes @xmath76 and @xmath77 have been omitted in the figure to save space . ]    .",
    "the literals in the initial cubes @xmath76 and @xmath77 have been omitted in the figure to save space . ]",
    "[ ex_running ] given the satisfiable pcnf @xmath78 , where @xmath79 with @xmath80 , @xmath81 , @xmath82 , @xmath83 , @xmath84 , and @xmath85 .",
    "figure  [ fig_derivations ] shows the derivation of the clauses @xmath86 and @xmath87 by q - resolution and universal reduction .    the assignment @xmath88 is a model of @xmath43 by definition  [ def_model ] .",
    "hence @xmath89 is an initial cube .",
    "existential reduction of @xmath76 produces the cube @xmath90 .",
    "similarly , @xmath91 is a model of @xmath43 and @xmath92 is an initial cube .",
    "existential reduction of @xmath77 produces the cube @xmath93 .",
    "the cube @xmath94 is obtained by resolving @xmath95 and @xmath96 . finally , existential reduction of @xmath97 produces the empty cube @xmath98 , which proves that the pcnf @xmath43 is satisfiable .",
    "a qcdcl - based solver implicitly constructs derivation dags in constraint learning . however , typically only selected constraints of these derivations are kept as learned constraints in an _ augmented cnf _  @xcite .    [ def_aug_cnf ]",
    "let @xmath9 be a pcnf .",
    "the _ augmented cnf ( acnf ) _ of @xmath43 has the form @xmath99 , where @xmath11 is the quantifier prefix , @xmath10 is the set of original clauses , @xmath100 is a cnf containing the learned clauses , and @xmath101 is a dnf containing the learned cubes obtained by clause and cube learning in qcdcl .    given an acnf @xmath102 and an assignment @xmath37 , the notation @xmath103 $ ] is defined similarly to pcnfs .",
    "analogously to clause derivations , we write @xmath104 if there is a derivation of a cube @xmath6 from the pcnf @xmath105 . during a run of a qcdcl - based solver the learned constraints can be derived from the current pcnf .",
    "[ prop_lcl_lcu_properties ] let @xmath106 be the acnf obtained by qcdcl from a pcnf @xmath9 .",
    "it holds that ( 1 ) @xmath107 and ( 2 ) @xmath108 .",
    "proposition  [ prop_lcl_lcu_properties ] follows from the correctness of constraint learning in _ non - incremental _ qcdcl .",
    "that is , we assume that the pcnf @xmath43 is not modified over time",
    ". however , as we point out below , in _ incremental _ qcdcl the constraints learned previously might no longer be derivable after the pcnf has been modified .",
    "[ def_constraint_correct ] given the acnf @xmath106 of the pcnf @xmath9 , a clause @xmath109 ( cube @xmath110 ) is _ derivable _ with respect to @xmath43 if @xmath111 .",
    "otherwise , if @xmath112 , then @xmath6 is _ non - derivable_.    due to the correctness of model generation , existential / universal reduction , and resolution , constraints which are derivable from the pcnf @xmath43 can be added to the acnf @xmath102 of @xmath43 , which results in a satisfiability - equivalent ( @xmath113 ) formula .    [ prop_learning_satequiv ] let @xmath106 be the acnf of the pcnf @xmath9 .",
    "then ( 1 ) @xmath114 and ( 2 ) @xmath115 .",
    "we define _ incremental qbf solving _ as the problem of solving a sequence of @xmath116 using a qcdcl - based solver .",
    "thereby , the goal is to not discard all the learned constraints after the pcnf @xmath117 has been solved .",
    "instead , to the largest extent possible we want to re - use the constraints that were learned from @xmath117 in the process of solving the next pcnf @xmath118 . to this end , the acnf @xmath119 of @xmath118 for @xmath120 , which is maintained by the solver ,",
    "must be initialized with a set @xmath121 of learned clauses and a set @xmath122 of learned cubes such that @xmath123 , @xmath124 and proposition  [ prop_learning_satequiv ] holds with respect to @xmath118 .",
    "the sets @xmath125 and @xmath126 contain the clauses and cubes that were learned from the previous pcnf @xmath117 and potentially can be used to derive further constraints from @xmath118 .",
    "if @xmath127 and @xmath128 at the beginning , then the solver solves the pcnf @xmath118 _",
    "incrementally_. for the first pcnf @xmath129 in the sequence , the solver starts with empty sets of learned constraints in the acnf @xmath130 .",
    "each pcnf @xmath118 for @xmath131 in the sequence @xmath132 has the form @xmath133 .",
    "the cnf part @xmath134 of @xmath118 results from @xmath135 of the previous pcnf @xmath136 in the sequence by addition and deletion of clauses .",
    "we write @xmath137 , where @xmath138 and @xmath139 are the sets of deleted and added clauses .",
    "the quantifier prefix @xmath140 of @xmath118 is obtained from @xmath141 of @xmath142 by deletion and addition of variables and quantifiers , depending on the clauses in @xmath139 and @xmath138 .",
    "that is , we assume that the pcnf @xmath118 is closed and that its prefix @xmath140 does not contain superfluous quantifiers and variables .    when solving the pcnf @xmath117 using a qcdcl - based qbf solver , learned clauses and cubes accumulate in the corresponding acnf @xmath143 .",
    "assume that the learned constraints are derivable with respect to @xmath117 .",
    "the pcnf @xmath117 is modified to obtain the next pcnf @xmath118 to be solved .",
    "the learned constraints in @xmath144 and @xmath145 might become non - derivable with respect to @xmath118 in the sense of definition  [ def_constraint_correct ] .",
    "consequently , proposition  [ prop_learning_satequiv ] might no longer hold for the acnf @xmath146 of the new pcnf @xmath118 if previously learned constraints from @xmath144 and @xmath126 appear in @xmath121 and @xmath122 . in this case , the solver might produce a wrong result when solving @xmath118 .",
    "assume that the pcnf @xmath147 has been solved and learned constraints have been collected in the acnf @xmath148 .",
    "the clauses in @xmath138 are deleted from @xmath149 to obtain the cnf part @xmath150 of the next pcnf @xmath133 .",
    "if the derivation of a learned clause @xmath151 depends on deleted clauses in @xmath138 , then we might have that @xmath152 but @xmath153 . in this case , @xmath6 is non - derivable with respect to the next pcnf @xmath118 . hence @xmath6 must be discarded before solving @xmath118 starts so that @xmath154 in the initial acnf @xmath155 . otherwise ,",
    "if @xmath156 then the solver might construct a bogus q - resolution proof for the pcnf @xmath118 and , if @xmath118 is satisfiable , erroneously conclude that @xmath118 is unsatisfiable .",
    "[ ex_clause_delete_incorrect_clause ] consider the pcnf @xmath43 from example  [ ex_running ] .",
    "the derivation of the clause @xmath157 shown in fig .",
    "[ fig_derivations ] depends on the clause @xmath158 .",
    "we have that @xmath159 .",
    "let @xmath160 be the pcnf obtained from @xmath43 by deleting @xmath161 .",
    "then @xmath162 because @xmath163 is the only clause which contains the literal @xmath164 .",
    "hence a possible derivation of the clause @xmath157 must use @xmath165 .",
    "however , no such derivation exists in @xmath160 .",
    "there is no clause @xmath64 containing a literal @xmath166 which can be resolved with @xmath165 to produce @xmath167 after a sequence of resolution steps .",
    "consider the pcnf @xmath133 with @xmath168 which is obtained from @xmath169 by _ only adding _ the clauses @xmath139 , but not deleting any clauses . assuming that @xmath170 for all @xmath151 in the acnf @xmath148 , also @xmath171 .",
    "hence all the learned clauses in @xmath144 are derivable with respect to the next pcnf @xmath118 and can be added to the acnf @xmath172 .",
    "like above , let @xmath173 be the acnf of the previously solved pcnf @xmath174 .",
    "dual to clause deletions , the addition of clauses to @xmath149 can make learned cubes in @xmath145 non - derivable with respect to the next pcnf @xmath133 to be solved .",
    "the clauses in @xmath139 are added to @xmath149 to obtain the cnf part @xmath150 of @xmath118 .",
    "an initial cube @xmath175 has been obtained from a model @xmath37 of the previous pcnf @xmath117 , i.e.  @xmath176 = \\top$ ] .",
    "we might have that @xmath177 \\not = \\top$ ] with respect to the next pcnf @xmath118 because of an added clause @xmath178 ( and hence also @xmath179 ) such that @xmath180 \\not = \\top$ ] .",
    "therefore , @xmath37 is not a model of @xmath118 and the initial cube @xmath6 is non - derivable with respect to @xmath118 , i.e.  @xmath181 but @xmath182 . hence @xmath6 and every cube whose derivation depends on @xmath6 must be discarded to prevent the solver from generating a bogus cube resolution proof for @xmath118 .",
    "if @xmath118 is unsatisfiable , then the solver might erroneously conclude that @xmath118 is satisfiable .",
    "that is , proposition  [ prop_learning_satequiv ] might not hold with respect to non - derivable cubes and the acnf @xmath172 of @xmath118 .",
    "[ ex_clause_add_incorrect_cube ] consider the pcnf @xmath43 from example  [ ex_running ] .",
    "the derivation of the cube @xmath95 shown in fig .",
    "[ fig_derivations ] depends on the initial cube @xmath183 , which has been generated from the model @xmath184 .",
    "the cube @xmath76 is derivable with respect to @xmath43 since @xmath185 = \\top$ ] , and hence @xmath186 .",
    "the cube @xmath187 is also derivable since @xmath188 .",
    "assume that the clause @xmath189 is added to @xmath43 resulting in the unsatisfiable pcnf @xmath190 .",
    "now @xmath76 is non - derivable with respect to @xmath190 since @xmath191 = \\bot$ ] .",
    "further , @xmath192 .    consider the pcnf @xmath133 with @xmath193 which is obtained from @xmath169 by _ only deleting _",
    "the clauses @xmath138 , but not adding any clauses .",
    "if after the clause deletions some variable @xmath0 does not occur anymore in the resulting pcnf @xmath118 , then @xmath0 is removed from the quantifier prefix of @xmath118 and from every cube @xmath194 which was learned when solving the previous pcnf @xmath142 .",
    "proposition  [ prop_learning_satequiv ] holds for the cleaned up cubes @xmath195 for all @xmath175 with respect to @xmath118 and hence @xmath64 can be added to the acnf @xmath172 .",
    "[ prop_cleaned_up_cubes_sound ] let @xmath196 be the acnf of the pcnf @xmath197 .",
    "let @xmath198 be the pcnf resulting from @xmath142 with @xmath199 , where the variables @xmath200 no longer occur in @xmath134 and are removed from @xmath141 to obtain @xmath140 .",
    "given a cube @xmath201 , let @xmath202 .",
    "proposition  [ prop_learning_satequiv ] holds for @xmath64 with respect to @xmath203 : @xmath204 .    by induction on the structure of the derivations of cubes in @xmath145 .",
    "let @xmath175 be an initial cube due to the assignment @xmath37 with @xmath176 = \\top$ ] . for @xmath205 , we have @xmath206 = \\top$ ] since all the clauses containing the variables in @xmath200 were deleted from @xmath117 to obtain @xmath118 .",
    "then the claim holds for the initial cube @xmath207 since @xmath208 .",
    "let @xmath175 be obtained from @xmath209 by existential reduction such that @xmath210 .",
    "assuming that the claim holds for @xmath211 , it also holds for @xmath212 since existential reduction removes existential literals which are maximal with respect to the prefix ordering .",
    "let @xmath175 be obtained from @xmath213 by resolution on variable @xmath0 with @xmath214 , @xmath215 .",
    "assume that the claim holds for @xmath211 and @xmath216 , i.e.  @xmath217 and @xmath218 .",
    "if @xmath219 then the claim also holds for @xmath220 with @xmath221 , @xmath222 due to the correctness of resolution ( proposition  [ prop_learning_satequiv ] ) . if @xmath223 then the claim also holds for @xmath224 since @xmath225 for all variables @xmath226 , which can be proved by reasoning with tree - like models of qbfs  @xcite .",
    "if a variable @xmath0 no longer occurs in the formula , then cubes where @xmath0 has been removed might become non - derivable .",
    "however , due to propositions  [ prop_learning_satequiv ] and  [ prop_cleaned_up_cubes_sound ] it is sound to keep all the cleaned up cubes ( resolution is not inferentially - complete ) .",
    "moreover , due to the correctness of resolution and existential reduction , proposition  [ prop_learning_satequiv ] also holds for new cubes derived from the cleaned up cubes .    in practice , the goal is to keep as many learned constraints as possible because they prune the search space and can be used to derive further constraints .",
    "therefore , subsets @xmath123 and @xmath124 of the learned clauses @xmath125 and cubes @xmath126 must be selected so that proposition  [ prop_learning_satequiv ] holds with respect to the initial acnf @xmath227 of the pcnf @xmath118 to be solved next .",
    "we describe the implementation of our incremental qcdcl - based solver .",
    "our approach is general and fits any qcdcl - based solver . for incremental",
    "solving we do not apply a sophisticated analysis of variable dependencies by dependency schemes in  @xcite . instead , as many other qbf solvers , we use the linear ordering given by the quantifier prefix .",
    "we implemented a stack - based representation of the cnf part of pcnfs based on selector variables and assumptions .",
    "assumptions were also used for incremental qbf - based bmc of partial designs  @xcite and are common in incremental sat solving  @xcite .",
    "we address the problem of checking which learned constraints can be kept across different solver runs after the current pcnf has been modified . to this end",
    ", we present approaches to check if a constraint learned from the previous pcnf is still derivable from the next one , which makes sure that proposition  [ prop_learning_satequiv ] holds .",
    "similar to incremental sat solving , selector variables are used to handle the learned clauses . regarding learned cubes , selector variables can also be used ( although in a way asymmetric to clauses ) , in addition to an alternative approach relying on full derivation dags , which have to be kept in memory . learned cubes might become non - derivable by the deletion of clauses and superfluous variables , but still can be kept due to proposition  [ prop_cleaned_up_cubes_sound ] .",
    "we implemented a simple approach which , after clauses have been added to the formula , allows to keep only initial cubes but not cubes obtained by resolution or existential reduction .",
    "let @xmath228 be a pcnf .",
    "we define a set @xmath229 of _ assumptions _ as an assignment such that @xmath230 for all literals @xmath39 .",
    "the variables assigned by @xmath37 are from the first block @xmath231 of @xmath43 . solving the pcnf @xmath43 _ under the set @xmath37 of assumptions",
    "_ amounts to solving the pcnf @xmath44 $ ] .",
    "the definition of assumptions can be applied recursively to the pcnf @xmath44 $ ] .",
    "if @xmath37 assigns all the variables in @xmath231 , then variables from @xmath232 can be assigned as assumptions with respect to @xmath44 $ ] , since @xmath232 is the first block in the quantifier prefix of @xmath44 $ ] .",
    "we implemented the handling of assumptions according to the _ literal - based single instance ( ls ) _ approach ( in the terminology of  @xcite ) .",
    "thereby , the assumptions in @xmath37 are treated in a special way so that the variables in @xmath37 are never selected as pivots in the resolution derivation of a learned constraint according to qcdcl - based learning .",
    "similar to sat - solving under assumptions , ls allows to keep all the constraints that were learned from the pcnf @xmath44 $ ] under a set @xmath37 of assumptions when later solving @xmath233 $ ] under a different set @xmath234 of assumptions .      in , the cnf part @xmath10 of an acnf @xmath235 to be solved is represented as a stack of clauses .",
    "the clauses on the stack are grouped into _",
    "frames_. the solver api provides functions to push new frames onto the stack , pop present frames from the stack , and to add new clauses to the current topmost frame .",
    "each _ push _",
    "operation opens a new topmost frame @xmath236 .",
    "new clauses are always added to the topmost frame @xmath236 .",
    "each new frame @xmath236 opened by a _ push _",
    "operation is associated with a fresh _ frame selector variable _ @xmath237 .",
    "frame selector variables are existentially quantified and put into a separate , leftmost quantifier block @xmath238 i.e.  the current acnf @xmath239 has the form @xmath240 . before a new clause @xmath6",
    "is added to frame @xmath236 , the frame selector variable @xmath237 of @xmath236 is inserted into @xmath6 so that in fact the clause @xmath241 is added to @xmath236 . if all the selector variables are assigned to _",
    "false _ then under that assignment every clause @xmath241 is syntactically equivalent to @xmath6 .",
    "the purpose of the frame selector variables is to _ enable _ or _ disable _ the clauses in the cnf part @xmath149 with respect to the _ push _ and _ pop _ operations applied to the clause stack . if the selector variable @xmath237 of a frame @xmath236 is assigned to _ true",
    "_ then all the clauses of @xmath236 are satisfied under that assignment . in this case , these satisfied clauses are considered disabled because they can not be used to derive new learned clauses in qcdcl .",
    "otherwise , the assignment of _ false _ to @xmath237 does not satisfy any clauses in @xmath236 .",
    "therefore these clauses are considered enabled .    before the solving process starts ,",
    "the clauses of frames popped from the stack are disabled and the clauses of frames still on the stack are enabled by assigning the selector variables to _ true _ and _ false _ , respectively .",
    "the selector variables are assigned as assumptions .",
    "this is possible because these variables are in the leftmost quantifier block @xmath238 of the acnf @xmath242 to be solved .",
    "the idea of enabling and disabling clauses by selector variables and assumptions originates from incremental sat solving  @xcite .",
    "this approach was also applied to bounded model checking of partial designs by incremental qbf solving  @xcite . in",
    ", we implemented the _",
    "push _ and _ pop _ operations related to the clause stack by selector variables similarly to the sat solver  @xcite .    in the implementation of ,",
    "frame selector variables are maintained entirely by the solver .",
    "depending on the _ push _ and _ pop _ operations , selector variables are automatically inserted into added clauses and assigned as assumptions .",
    "this approach saves the user the burden of inserting selector variables manually into the qbf encoding of a problem and assigning them as assumptions via the solver api .",
    "manual insertion is typically applied in incremental sat solving based on assumptions as pioneered by  @xcite .",
    "we argue that the usability of an incremental qbf solver is improved considerably if the selector variables are maintained by the solver .",
    "for example , from the perspective of the user , the qbf encoding contains only variables relevant to the encoded problem .    in the following , we consider the problem of maintaining the sets of learned constraints across different solver runs .",
    "as pointed out in section  [ sec_inc_satisfiability ] , proposition  [ prop_learning_satequiv ] still holds for learned clauses ( cubes ) after the addition ( deletion ) of clauses to ( from ) the pcnf .",
    "therefore , we present the maintenance of learned constraints separately for clause additions and deletions .",
    "a clause @xmath151 in the current acnf @xmath243 might become non - derivable if its derivation depends on clauses in @xmath138 which are deleted to obtain the cnf part @xmath137 of the next pcnf @xmath118 .    in , learned clauses in @xmath144 are deleted as follows . as pointed out in the previous section , clauses of popped off frames are disabled by assigning the respective frame selector variables to _",
    "true_. since the formula contains only positive literals of selector variables , these variables can not be chosen as pivots in derivations .",
    "therefore , learned clauses whose derivations depend on disabled clauses of a popped off frame @xmath236 contain the selector variable @xmath237 of @xmath236 .",
    "hence these learned clauses are also disabled by the assignment of @xmath237 .",
    "this approach to handling learned clauses is also applied in incremental sat solving  @xcite .",
    "the disabled clauses are physically deleted in a garbage collection phase if their number exceeds a certain threshold .",
    "variables which no longer occur in the cnf part of the current pcnf are removed from the quantifier prefix and , by proposition  [ prop_cleaned_up_cubes_sound ] , from learned cubes in @xmath145 to produce cleaned up cubes .",
    "we initialize the set @xmath122 of learned cubes in the acnf @xmath227 of the next pcnf @xmath118 to be solved to contain the cleaned up cubes .",
    "the deletion of learned clauses based on selector variables is not optimal in the sense of definition  [ def_constraint_correct ] .",
    "there might be another derivation of a disabled learned clause @xmath6 which does not depend on the deleted clauses @xmath138 .",
    "this observation also applies to the use of selector variables in incremental sat solving .",
    "as illustrated in the context of incremental sat solving , the size of learned clauses might increase considerably due to the additional selector variables  @xcite . in the stack - based cnf representation of ,",
    "the clauses associated to a frame @xmath236 all contain the selector variable @xmath237 of @xmath236 .",
    "therefore , the maximum number of selector variables in a new clause learned from the current pcnf @xmath117 is bounded by the number of currently enabled frames .",
    "the sequence of _ push _ operations introduces a linear ordering @xmath244 on the enabled frames @xmath245 and their clauses in the cnf with respect to the point of time where that frames and clauses have been added . in , we implemented the following optimization based on this temporal ordering .",
    "let @xmath6 and @xmath64 be clauses which are resolved in the course of clause learning .",
    "assume that @xmath246 and @xmath247 are the only selector variables of currently enabled frames @xmath245 and @xmath236 in @xmath6 and @xmath64 . instead of computing the usual q - resolvent @xmath248 ,",
    "we compute @xmath249 .",
    "that is , the selector variable of the frame which is smaller in the temporal ordering is discarded from the resolvent . if @xmath250 then the clauses in @xmath245 were pushed onto the clause stack before the clauses in @xmath236 .",
    "the frame @xmath236 will be popped off the stack before @xmath245 .",
    "therefore , in order to properly disable the learned clause @xmath251 after _ pop _ operations , it is sufficient to keep the selector variable @xmath237 of the frame @xmath236 in @xmath251 . with this optimization ,",
    "_ every _ learned clause contains _ exactly one _ selector variable . in the sat solver , an optimization which has similar effects",
    "is implemented .",
    "assume that the pcnf @xmath252 has been solved and that all learned constraints in the acnf @xmath253 of @xmath117 are derivable with respect to @xmath142 .",
    "the set @xmath139 of clauses is added to @xmath149 to obtain the cnf part @xmath137 of the next pcnf @xmath133 . for learned clauses , we can set @xmath254 in the acnf @xmath255 of @xmath118 .",
    "the following example illustrates the effects of adding @xmath139 on the cubes .",
    "[ ex_incorrect_cubes_clean_dag ] consider the cube derivation shown in fig .",
    "[ fig_derivations ] .",
    "as illustrated in example  [ ex_clause_add_incorrect_cube ] , the cubes @xmath256 and @xmath95 are non - derivable with respect to the pcnf @xmath190 obtained from @xmath43 by adding the clause @xmath189 .",
    "the initial cube @xmath257 still is derivable because the underlying model @xmath258 of @xmath43 is also a model of @xmath190 .",
    "therefore , when solving @xmath190 we can keep the derivable cubes @xmath77 and @xmath259 .",
    "the non - derivable cubes @xmath76 and @xmath187 must be discarded .",
    "otherwise , qcdcl might produce the cube resolution proof shown in fig .",
    "[ fig_derivations ] when solving the _ unsatisfiable _ pcnf @xmath190 , which is incorrect .",
    "we sketch an approach to identify the cubes in a cube derivation dag @xmath260 which are non - derivable with respect to the next pcnf @xmath261 .",
    "starting at the initial cubes , @xmath260 is traversed in a topological order .",
    "an initial cube @xmath6 is marked as derivable if @xmath262 = \\top$ ] , otherwise if @xmath262 \\not = \\top$ ] then @xmath6 is marked as non - derivable .",
    "this test can be carried out syntactically by checking whether every clause of @xmath118 is satisfied under the assignment given by @xmath6 . a cube @xmath6 obtained by existential reduction or cube resolution",
    "is marked as derivable if all its predecessors in @xmath260 are marked as derivable .",
    "otherwise , @xmath6 is marked as non - derivable .",
    "finally , all cubes in @xmath260 marked as non - derivable are deleted .",
    "the above procedure allows to find a subset @xmath263 of the set @xmath126 of cubes in the solved acnf @xmath235 so that all cubes in @xmath122 are derivable and proposition  [ prop_learning_satequiv ] holds for the next acnf @xmath227 .",
    "however , this procedure is not optimal because it might mark a cube @xmath264 as non - derivable with respect to the next pcnf @xmath118 although @xmath265 .    [ ex_cube_check_overapprox ] given the satisfiable pcnf @xmath266 , where @xmath267 with the clauses @xmath268 from example  [ ex_running ] where @xmath80 , @xmath269 , @xmath82 , @xmath270 , @xmath84 . consider the model @xmath271 of @xmath43 and the initial cube @xmath272 generated from @xmath273 . existential reduction of @xmath274 produces the cube @xmath275 .",
    "assume that the clause @xmath276 is added to @xmath43 to obtain the pcnf @xmath277 .",
    "the initial cube @xmath274 is non - derivable with respect to @xmath277 since @xmath278 \\not = \\top$ ] .",
    "however , for the cube @xmath279 derived from @xmath274 it holds that @xmath280 .",
    "the assignment @xmath281 is a model of @xmath277 .",
    "let @xmath282 be the initial cube generated from @xmath283 .",
    "then @xmath284 is derivable with respect to @xmath277 .    in practice , qcdcl - based solvers typically store only the learned cubes , which might be a small part of the derivation dag @xmath260 , and no edges .",
    "therefore , checking the cubes in a traversal of @xmath260 is not feasible . even if the full dag @xmath260 is available , the checking procedure is not optimal as pointed out in example  [ ex_cube_check_overapprox ] .",
    "furthermore , it can not be used to check cubes which have become non - derivable after cleaning up by proposition  [ prop_cleaned_up_cubes_sound ] .",
    "hence , it is desirable to have an approach to checking the derivability of _ individual _ learned cubes which is independent from the derivation dag @xmath260 . to this end",
    ", we need a condition which is sufficient to conclude that some _ arbitrary _ cube @xmath6 is derivable with respect to a pcnf @xmath43 , i.e.  to check whether @xmath285 . however , we are not aware of such a condition .    as an alternative to keeping the full derivation dag in memory ,",
    "a _ fresh _",
    "selector variable can be added to _ each _ newly learned initial cube .",
    "similar to selector variables in clauses , these variables are transferred to all derived cubes .",
    "potentially non - derivable cubes are then disabled by assigning the selector variables accordingly .",
    "however , different from clauses , it must be checked _",
    "explicitly _ which initial cubes are non - derivable by checking the condition in definition  [ def_model ] for all initial cubes in the set @xmath145 of learned cubes .",
    "this amounts to an asymmetric treatment of selector variables in clauses and cubes .",
    "clauses are added to and removed from the cnf part by _ push _ and _ pop _ operations provided by the solver api .",
    "this way , it is known precisely which clauses are removed .",
    "in contrast to that , cubes are added to the set of learned cubes @xmath145 on the fly during cube learning . moreover , the optimization based on the temporal ordering of selector variables from the previous section is not applicable to generate shorter cubes since cubes are not associated to stack frames .    due to the complications illustrated above , we implemented the following simple approach in to keep only initial cubes . every initial cube computed by the solver",
    "is stored in a linked list @xmath286 of bounded capacity , which is increased dynamically .",
    "the list @xmath286 is separate from the set of learned clauses .",
    "assume that a set @xmath139 of clauses is added to the cnf part @xmath149 of the current pcnf to obtain the cnf part @xmath287 of the next pcnf @xmath261 .",
    "all the cubes in the current set @xmath145 of learned cubes are discarded . for every added clause @xmath288 and for every initial cube @xmath289 , it is checked whether the assignment @xmath37 given by @xmath64 is a model of the next pcnf @xmath118 .",
    "initial cubes @xmath64 for which this check succeeds are added to the set @xmath122 of learned cubes in the acnf @xmath172 of the next pcnf @xmath118 after existential reduction has been applied to them .",
    "if the check fails , then @xmath64 is removed from @xmath286 .",
    "it suffices to check the initial cubes in @xmath286 only with respect to the clauses @xmath288 , and not the full cnf part @xmath134 , since the assignments given by the cubes in @xmath286 are models of the _ current _ pcnf @xmath142 . in the end ,",
    "the set @xmath122 contains only initial cubes all of which are derivable with respect to the acnf @xmath172 . if clauses are removed from the formula , then by proposition  [ prop_cleaned_up_cubes_sound ] variables which do not occur anymore in the formula are removed from the initial cubes in @xmath286 .    in the incremental qbf - based approach",
    "to bmc for partial designs  @xcite , all cubes are kept across different solver calls under the restriction that the quantifier prefix is modified only at the left end .",
    "this restriction does not apply to incremental solving of pcnf where the formula can be modified arbitrarily .",
    "the api of  @xcite provides functions to manipulate the prefix and the cnf part of the current pcnf .",
    "clauses are added and removed by the _ push _ and _ pop _ operations described in section  [ sec_cnf_stack ] .",
    "new quantifier blocks can be added at any position in the quantifier prefix .",
    "new variables can be added to any quantifier block .",
    "variables which no longer occur in the formula and empty quantifier blocks can be explicitly deleted .",
    "the quantifier block @xmath238 containing the frame selector variables is invisible to the user .",
    "the solver maintains the learned constraints as described in sections  [ sec_clause_del ] and  [ sec_clause_add ] without any user interaction .",
    "the _ push _ and _ pop _ operations are a feature of . additionally , the api supports the manual insertion of selector variables into the clauses by the user .",
    "similar to incremental sat solving  @xcite , clauses can then be enabled and disabled manually by assigning the selector variables as assumptions via the api . in this case , these variables are part of the qbf encoding and the optimization based on the frame ordering presented in section  [ sec_clause_del ] is not applicable . after a pcnf has been found unsatisfiable ( satisfiable ) under assumptions where the leftmost quantifier block is existential ( universal ) , the set of relevant assumptions which were used by the solver to determine the result can be extracted .",
    "& _ discard lc _ & _ keep lc _ & _",
    "diff.(% ) _ + @xmath290 : & @xmath291 & @xmath292 & -10.88 + @xmath293 : & 3,833,077 & 2,819,492 & -26.44 + @xmath294 : & 139,036 & 116,792 & -16.00 + @xmath295 : & 8,243 & 6,360 & -22.84 + @xmath296 : & 99.03 & 90.90 & -8.19 + @xmath297 : & 28.56 & 15.74 & -44.88 +     & _ discard lc _ & _ keep lc _ & _",
    "diff.(% ) _ + @xmath290 : & @xmath298 & @xmath299 & -14.40 + @xmath293 : & @xmath300 & @xmath301 & -3.62 + @xmath294 : & 117,019 & 91,737 & -21.61 + @xmath295 : & 10,322 & 8,959 & -13.19 + @xmath296 : & 100.15 & 95.36 & -4.64 + @xmath297 : & 4.18 & 2.83 & -32.29 +     & _ discard lc _ & _ keep lc _ & _",
    "diff.(% ) _ + @xmath290 : & @xmath302 & @xmath303 & -86.62 + @xmath293 : & 186,237 & 15,031 & -91.92 + @xmath294 : & 36,826 & 1,228 & -96.67 + @xmath295 : & 424 & 0 & -100.00 + @xmath296 : & 21.94 & 4.32 & -79.43 + @xmath297 : & 0.75 & 0.43 & -42.66 +     & _ discard lc _ &",
    "_ keep lc _ & _",
    "diff.(% ) _ + @xmath290 : & @xmath304 & @xmath305 & -77.94 + @xmath293 : & 103,330 & 8,199 &",
    "-92.06 + @xmath294 : & 31,489 & 3,350 & -89.37 + @xmath295 : & 827 & 5 & -99.39 + @xmath296 : & 30.29 & 9.78 & -67.40 + @xmath297 : & 0.50 & 0.12 & -76.00 +    to demonstrate the basic feasibility of general incremental qbf solving , we evaluated our incremental qbf solver based on the instances from _",
    "qbfeval12 second round ( sr ) _ with and without preprocessing by .",
    "we disabled the sophisticated dependency analysis in terms of dependency schemes in and instead applied the linear ordering of the quantifier prefix in the given pcnfs . for experiments",
    ", we constructed a sequence of related pcnfs for _ each _ pcnf in the benchmark sets as follows .",
    "given a pcnf @xmath43 , we divided the number of clauses in @xmath43 by 10 to obtain the size of a slice of clauses .",
    "the first pcnf @xmath129 in the sequence contains the clauses of one slice .",
    "the clauses of that slice are removed from @xmath43 .",
    "the next pcnf @xmath160 is obtained from @xmath129 by adding another slice of clauses , which is removed from @xmath43 .",
    "the other pcnfs in the sequence @xmath306 are constructed similarly so that finally the last pcnf @xmath307 contains all the clauses from the original pcnf @xmath43 . in our tests , we constructed each pcnf @xmath117 from the previous one @xmath308 in the sequence by adding a slice of clauses to a new frame after a _ push _ operation .",
    "we ran on the sequences of pcnfs constructed this way with a wall clock time limit of 1800 seconds and a memory limit of 7 gb .",
    "tables  [ tab_experiments_eval2012 ] and  [ tab_experiments_eval2012_pop ] show experimental results on sequences @xmath309 of pcnfs and on the reversed ones @xmath310 , respectively .",
    "to generate @xmath311 , we first solved the sequence @xmath312 and then started to discard clauses by popping the frames from the clause stack of depqbf via its api . in one run ( _",
    "discard lc _ ) , we always discarded all the constraints that were learned from the previous pcnf @xmath117 so that the solver solves the next pcnf @xmath118 ( @xmath308 with respect to table  [ tab_experiments_eval2012_pop ] ) starting with empty sets of learned clauses and cubes . in another run ( _",
    "keep lc _ ) , we kept learned constraints as described in sections  [ sec_clause_del ] and [ sec_clause_add ] . this way ,",
    "70 out of 345 total pcnf sequences were fully solved from the set _",
    "qbfeval12-sr _ by both runs , and 112 out of 276 total sequences were fully solved from the set _ qbfeval12-sr - bloqqer_.    the numbers of assignments , backtracks , and wall clock time indicate that keeping the learned constraints is beneficial in incremental qbf solving despite the additional effort of checking the collected initial cubes . in the experiment reported in table  [ tab_experiments_eval2012 ] clauses",
    "are always added but never deleted to obtain the next pcnf in the sequence .",
    "thereby , across all incremental calls of the solver in the set _",
    "qbfeval12-sr _ on average 224 out of 364 ( 61% ) collected initial cubes were identified as derivable and added as learned cubes . for",
    "the set _ qbfeval12-sr - bloqqer _ , 232 out of 1325 ( 17% ) were added .",
    "related to table  [ tab_experiments_eval2012_pop ] , clauses are always removed but never added to obtain the next pcnf to be solved , which allows to keep learned cubes based on proposition  [ prop_cleaned_up_cubes_sound ] . across all incremental calls of the solver in the set _",
    "qbfeval12-sr _ on average 820 out of 1485 ( 55% ) learned clauses were disabled and hence effectively discarded because their q - resolution derivation depended on removed clauses .",
    "for the set _ qbfeval12-sr - bloqqer _ , 704 out of 1399 ( 50% ) were disabled .",
    "we presented a general approach to incremental qbf solving which integrates ideas from incremental sat solving and which can be implemented in any qcdcl - based qbf solver .",
    "the api of our incremental qbf solver provides _ push _ and _ pop _ operations to add and remove clauses in a pcnf .",
    "this increases the usability of our implementation .",
    "our approach is application - independent and applicable to arbitrary qbf encodings .",
    "we illustrated the problem of keeping the learned constraints across different calls of the solver . to improve cube learning in incremental qbf solving ,",
    "it might be beneficial to maintain ( parts of ) the cube derivation in memory .",
    "this would allow to check the cubes more precisely than with the simple approach we implemented .",
    "moreover , the generation of proofs and certificates  @xcite is supported if the derivations are kept in memory rather than in a trace file .",
    "dual reasoning  @xcite and the combination of preprocessing and certificate extraction  @xcite are crucial for the performance and applicability of cnf - based qbf solving .",
    "the combination of incremental solving with these techniques has the potential to further advance the state of qbf solving .",
    "our experimental analysis demonstrates the feasibility of incremental qbf solving in a general setting and motivates further applications , along with the study of bmc of partial designs using incremental qbf solving  @xcite .",
    "related experiments with conformant planning based on incremental solving by showed promising results  @xcite .",
    "further experiments with problems which are inherently incremental can provide more insights and open new research directions .",
    "audemard , g. , lagniez , j.m .",
    ", simon , l. : improving glucose for incremental sat solving with assumptions : application to mus extraction . in : jrvisalo , m. , van  gelder , a. ( eds . ) sat .",
    "lncs , vol .",
    "7962 , pp .",
    "309317 . springer ( 2013 )                  cashmore , m. , fox , m. , giunchiglia , e. : planning as quantified boolean formula . in : raedt , l.d . ,",
    "bessire , c. , dubois , d. , doherty , p. , frasconi , p. , heintz , f. , lucas , p.j.f .",
    "frontiers in artificial intelligence and applications , vol .",
    "242 , pp . 217222 .",
    "ios press ( 2012 )                  hillebrecht , s. , kochte , m.a . ,",
    "erb , d. , wunderlich , h.j . , becker , b. : accurate qbf - based test pattern generation in presence of unknown values . in : macii ,",
    "e. ( ed . ) date .",
    ". 436441 . eda consortium san jose , ca , usa / acm dl ( 2013 )              lonsing , f. , egly , u. : incremental qbf solving by depqbf ( extended abstract ) . in : the 4th international congress on mathematical software , icms 2014 , seoul ,",
    "korea , august 2014 . proceedings .",
    "lncs , vol .",
    "springer ( 2014 ) , to appear .",
    "lonsing , f. , egly , u. , van  gelder , a. : efficient clause learning for quantified boolean formulas via qbf pseudo unit propagation . in : jrvisalo ,",
    "m. , van  gelder , a. ( eds . ) sat .",
    "lncs , vol . 7962 , pp .",
    "100115 . springer ( 2013 )      marin , p. , miller , c. , becker , b. : incremental qbf preprocessing for partial design verification - ( poster presentation ) . in : cimatti , a. , sebastiani , r. ( eds . ) sat .",
    "lncs , vol . 7317 , pp .",
    "473474 . springer ( 2012 )        niemetz , a. , preiner , m. , lonsing , f. , seidl , m. , biere , a. : resolution - based certificate extraction for qbf - ( tool presentation ) . in : cimatti ,",
    "a. , sebastiani , r. ( eds . ) sat .",
    "lncs , vol . 7317 , pp .",
    "430435 . springer ( 2012 )        silva , j.p.m .",
    ", lynce , i. , malik , s. : conflict - driven clause learning sat solvers . in : biere ,",
    "a. , heule , m. , van maaren , h. , walsh , t. ( eds . ) handbook of satisfiability , faia , vol .",
    "ios press ( 2009 )          zhang , l. , malik , s. : towards a symmetric treatment of satisfaction and conflicts in quantified boolean formula evaluation . in : hentenryck , p.v .",
    "( ed . ) cp .",
    "lncs , vol . 2470 , pp .",
    "springer ( 2002 )"
  ],
  "abstract_text": [
    "<S> we consider the problem of incrementally solving a sequence of quantified boolean formulae ( qbf ) . </S>",
    "<S> incremental solving aims at using information learned from one formula in the process of solving the next formulae in the sequence . based on a general overview of the problem and related challenges , we present an approach to incremental qbf solving which is application - independent and hence applicable to qbf encodings of arbitrary problems . </S>",
    "<S> we implemented this approach in our incremental search - based qbf solver and report on implementation details . </S>",
    "<S> experimental results illustrate the potential benefits of incremental solving in qbf - based workflows . </S>"
  ]
}