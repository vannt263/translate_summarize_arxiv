{
  "article_text": [
    "leader election is a classical and fundamental problem in distributed computing .",
    "it originated as the problem of regenerating the `` token '' in a local area _ token ring _",
    "network  @xcite and has since then `` starred '' in major roles in problems across the spectrum , providing solutions for reliability by replication ( or duplicate elimination ) , for locking , synchronization , load balancing , maintaining group memberships and establishing communication primitives .",
    "as an example , the content delivery network giant akamai uses decentralized and distributed leader election as a subroutine to tolerate machine failure and build fault tolerance in its systems  @xcite . in many cases , especially with the advent of large scale networks such as peer - to - peer systems  @xcite ,",
    "it is desirable to achieve low cost and scalable leader election , even though the guarantees may be probabilistic .",
    "informally , the problem of distributed leader election requires a group of processors in a distributed network to elect a unique leader among themselves , i.e. , exactly one processor must output the decision that it is the leader , say , by changing a special _ status _",
    "component of its state to the value _ leader _  @xcite . all the rest of the nodes must change their status component to the value _ non - leader_. these nodes need not be aware of the identity of the leader .",
    "implicit _ variant of leader election is rather standard ( cf .",
    "@xcite ) , and is sufficient in many applications , e.g. , for token generation in a token ring environment . this paper focuses on implicit leader election ( but improves the upper bounds also for the explicit case , by presenting a time and message optimal randomized protocol ) . in another variant ,",
    "all the non - leaders change their status component to the value _ non - leader _ , and moreover , every node must also know the identity of the unique leader",
    ". this formulation may be necessary in problems where nodes coordinate and communicate through a leader , e.g. , implementations of paxos  @xcite . in this variant",
    ", there is an obvious lower bound of @xmath11 messages ( throughout , @xmath0 denotes the number of nodes in the network ) since every node must be informed of the leader s identity .",
    "explicit _ leader election can be achieved by simply executing an ( implicit ) leader election algorithm and then broadcasting the leader s identity using an additional @xmath3 messages and @xmath12 time ( where @xmath13 is the diameter of the graph ) .",
    "the complexity of the leader election problem and algorithms for it , especially deterministic algorithms ( guaranteed to always succeed ) , have been well - studied .",
    "various algorithms and lower bounds are known in different models with synchronous / asynchronous communication and in networks of varying topologies such as a cycle , a complete graph , or some arbitrary topology ( e.g. , see @xcite and the references therein ) . the problem was first studied in context of a ring network by le  lann  @xcite and discussed for general graphs in the influential paper of gallager , humblet , and spira  @xcite .",
    "however , leader election in the class of complete networks has come to occupy a special position of its own and has been extensively studied  @xcite ; see also @xcite for leader election in complete networks where nodes have a sense of direction .",
    "the study of leader election algorithms is usually concerned with both message and time complexity . for complete graphs ,",
    "korach et al .",
    "@xcite and humblet @xcite presented @xmath14 message algorithms .",
    "korach , kutten , and moran  @xcite developed a general method decoupling the issue of the graph family from the design of the leader election algorithm , allowing the development of message efficient leader election algorithms for any class of graphs , given an efficient traversal algorithm for that class .",
    "when this method was applied to complete graphs , it yielded an improved ( but still @xmath15 ) message complexity .",
    "afek and gafni  @xcite presented asynchronous and synchronous algorithms , as well as a tradeoff between the message and the time complexity of synchronous _ deterministic _ algorithms for complete graphs : the results varied from a @xmath1-time , @xmath16-messages algorithm to a @xmath17-time , @xmath18-messages algorithm .",
    "singh @xcite showed another trade - off that saved on time , still for algorithms with a super - linear number of messages .",
    "( sublinear time algorithms were shown in @xcite even for @xmath14 messages algorithms , and even lower times for algorithms with higher messages complexities ) .",
    "afek and gafni , as well as  @xcite showed a lower bound of @xmath15 messages for _ deterministic _ algorithms in the general case .",
    "one specific case where the message complexity could be reduced ( but only as far as linear message complexity ) was at the expense of also having a linear time complexity , see @xcite .",
    "multiple studies showed a different case where it was possible to reduce the number of messages to @xmath3 , by using a _ sense of direction _ - essentially , assuming some kind of a virtual ring , superimposed on the complete graph , such that the order of nodes on a ring is known to the nodes @xcite .",
    "the above results demonstrate that the number of messages needed for deterministic leader election is at least linear or even super - linear ( depending on the time complexity ) .",
    "in particular , existing @xmath1 time deterministic algorithms require @xmath19 messages ( in a complete network ) . at its core ,",
    "leader election is a symmetry breaking problem . for anonymous networks under some reasonable assumptions ,",
    "deterministic leader election was shown to be impossible  @xcite ( using symmetry arguments ) .",
    "randomization comes to the rescue in this case ; random rank assignment is often used to assign unique identifiers , as done herein .",
    "randomization also allows us to beat the lower bounds for deterministic algorithms , albeit at the risk of a small chance of error .    a randomized leader election algorithm ( for the explicit version ) that could err with probability @xmath20",
    "was presented in @xcite with time @xmath17 and linear message complexity . ] .",
    "that paper also surveys some related papers about randomized algorithms in other models that use more messages for performing leader election  @xcite or related tasks ( e.g. , probabilistic quorum systems , malkhi et al  @xcite ) .",
    "in the context of self - stabilization , a randomized algorithm with @xmath14 messages and @xmath17 time until stabilization was presented in @xcite .",
    "the main focus of this paper is on studying how randomization can help in improving the complexity of leader election , especially message complexity in synchronous networks .",
    "we first present an ( implicit ) randomized leader election algorithm for a complete network that runs in @xmath1 time and uses only @xmath21 messages to elect a unique leader with high probability . ] .",
    "this is a significant improvement over the linear number of messages that is needed for any deterministic algorithm .",
    "it is an even larger improvement over the super - linear number of messages needed for deterministic algorithms that have low time complexity ( and especially compared to the @xmath16 messages for deterministic @xmath22-round algorithms ) . for the explicit variant of the problem",
    ", our algorithm implies an algorithm that uses ( w.h.p . ) @xmath3 messages and @xmath1 time , still a significant improvement over the @xmath19 messages used by deterministic algorithms .",
    "we then extend this algorithm to solve leader election on any connected ( non - bipartite ) @xmath0-node graph @xmath4 in @xmath5 time and @xmath6 messages , where @xmath7 is the mixing time of a random walk on @xmath4 .",
    "the above result implies highly efficient ( sublinear running time and messages ) leader election algorithms for networks with small mixing time .",
    "in particular , for important graph classes such as expanders ( used , e.g. , in modeling peer - to - peer networks @xcite ) , which have a logarithmic mixing time , it implies an algorithm of @xmath17 time and @xmath23 messages , and for hypercubes , which have a mixing time of @xmath24 , it implies an algorithm of @xmath24 time and @xmath25 messages .    for our algorithms ,",
    "we assume that the communication is synchronous and follows the standard @xmath26 model  @xcite , where a node can send in each round at most one message of size @xmath17 bits on a single edge . for our algorithm on general graphs",
    ", we also assume that the nodes have an estimate of the network s size ( i.e. , @xmath0 ) and the mixing time .",
    "we do not however assume that the nodes have unique ids , hence the algorithms in this paper apply also for anonymous networks .",
    "we assume that all nodes wake up simultaneously at the beginning of the execution .",
    "( additional details on our distributed computation model are given later on . )",
    "finally we show that , in general , it is not possible to improve over our algorithm substantially , by presenting a lower bound for randomized leader election .",
    "we show that @xmath8 messages are needed for any leader election algorithm in a complete network which succeeds with probability at least @xmath9 for any constant @xmath10 .",
    "this lower bound holds even in the @xmath27 model  @xcite , where there is no restriction on the number of bits that can be sent on each edge in each round . to the best of our knowledge , this is the first non - trivial lower bound for randomized leader election in complete networks .      the main algorithmic tool used by our randomized algorithm involves reducing the message complexity via random sampling .",
    "for general graphs , this sampling is implemented by performing random walks .",
    "informally speaking , a small number of nodes ( about @xmath17 ) , which are the candidates for leadership , initiate random walks .",
    "we show that if sufficiently many random walks are initiated ( about @xmath28 ) , then there is a good probability that random walks originating from different candidates meet ( or collide ) at some node which acts as a referee .",
    "the referee notifies a winner among the colliding random walks .",
    "the algorithms use a birthday paradox type argument to show that a unique candidate node wins all competitions ( i.e. , is elected ) with high probability .",
    "an interesting feature of that birthday paradox argument ( for general graphs ) is that it is applied to a setting with non - uniform selection probabilities .",
    "see section 2 for a simple version of the algorithm that works on a complete graph .",
    "the algorithm of section 3 is a generalization of the algorithm of section 2 that works for any connected graph ; however the algorithm and analysis are more involved .",
    "the main intuition behind our lower bound proof for randomized leader election is that , in some precise technical sense , any algorithm that sends fewer messages than required by our lower bound has a good chance of generating runs where there are multiple potential leader candidates in the network that do not influence each other . in other words , the probability of such `` disjoint '' parts of the network to elect a leader is the same , which implies that there is a good probability that more than one leader is elected .",
    "although this is conceptually easy to state , it is technically challenging to show formally since our result applies to all randomized algorithms without further restrictions .",
    "the high level intuition behind our algorithm is as follows .",
    "the nodes use the number of nodes @xmath0 and the mixing time @xmath29 to generate appropriate probabilities and random walk lengths .",
    "the algorithm has three main phases .",
    "all nodes wake up at the beginning of the election , yet it is not required that every node attempts to be elected . therefore , with a suitably chosen probability , a large number of nodes drop out of the election , setting their status component to _ non - leader _ , thereby leaving , w.h.p .",
    ", a set of only @xmath17 contestants .",
    "each contestant selects a random rank from a sufficiently large space . in the second phase ,",
    "each contestant chooses a random sample of @xmath30 _ referee _ nodes that decide its fate ( in the complete network these are neighbors ; in general networks , multiple random walks are executed to sample the referees ) .",
    "this selection ensures that w.h.p .",
    "every pair of contestants has at least one common referee , and thus , the referee sets act as _",
    "quorums_. finally , each referee declares the highest rank contestant among those it knows about as the winner and notifies it ( directly , in the complete graph , or by retracing a previously executed random walk , in the case of general graphs ) .",
    "if a contestant detects that it has won all of its contests , it declares itself the leader by setting its status to _ leader _ ; w.h.p .",
    "there is only one such winner .",
    "the model we consider is similar to the models of  @xcite , with the main addition of giving processors access to a private unbiased coin .",
    "also , we do not assume unique identities .",
    "we consider a system of @xmath0 nodes , represented as an undirected ( not necessarily complete ) graph @xmath31 .",
    "each node runs an instance of a distributed algorithm .",
    "the computation advances in synchronous rounds where , in every round , nodes can send messages , receive messages that were sent in the same round by neighbors in @xmath4 , and perform some local computation . every node has access to the outcome of unbiased private coin flips .",
    "messages are the only means of communication ; in particular , nodes can not access the coin flips of other nodes , and do not share any memory . throughout this paper",
    ", we assume that all nodes are awake initially and simultaneously start executing the algorithm .",
    "we now formally define the leader election problem .",
    "every node @xmath32 has a special variable @xmath33 that it can set to a value in @xmath34 ; initially we assume @xmath35 .",
    "algorithm @xmath36 solves leader election in @xmath37 rounds _ if , from round @xmath37 on , exactly one node has its status set to @xmath38 while all other nodes are in state @xmath39 .",
    "this is the requirement for standard ( implicit ) leader election .",
    "we also consider a stronger variant of the problem that we call _ explicit leader election _ where every node @xmath32 has a special variable @xmath40 that eventually holds the i d of the node that @xmath32 considers to be the leader .",
    "an algorithm @xmath36 solves explicit leader election in @xmath37 rounds if @xmath41 for all nodes @xmath32 and @xmath42 by round @xmath37 .",
    "+ * dp : should we also require that this is a legal output , namely , the i d of some node ?",
    "ok only for explicit le ... *",
    "to provide the intuition for our general result , let us start by illustrating a simpler version of our leader election algorithm , adapted to complete networks .",
    "more specifically , this section presents an algorithm that , with high probability , solves leader election in complete networks in @xmath1 rounds and sends no more than @xmath21 messages .",
    "let us first briefly describe the main ideas of algorithm  [ alg : leadercomplete ] ( see pseudo - code below ) .",
    "initially , the algorithm attempts to reduce the number of leader candidates as far as possible , while still guaranteeing that there is at least one candidate ( with high probability ) .",
    "non - candidate nodes enter the @xmath39 state immediately , and thereafter only reply to messages initiated by other nodes .",
    "every node @xmath32 becomes a candidate with probability @xmath43 and selects a random rank @xmath44 chosen from some large domain .",
    "each candidate node then randomly selects @xmath45 other nodes as _ referees _ and informs all referees of its rank .",
    "the referees compute the maximum ( say @xmath46 ) of all received ranks , and send a `` winner '' notification to the node @xmath47 .",
    "if a candidate wins all competitions , i.e. , receives `` winner '' notifications from all of its referees , it enters the @xmath38 state and becomes the leader .",
    "every node @xmath32 decides to become a candidate with probability @xmath43 and generates a random rank @xmath44 from @xmath48 .",
    "+ if a node @xmath32 does not become a candidate , then it immediately enters the @xmath39 state ; otherwise it executes the next step .",
    "* choosing referees : * node @xmath32 samples @xmath45 neighbors ( the _ referees _ ) and sends a message @xmath49 to each referee .    *",
    "`` winner '' notification : * a referee @xmath42 considers all received messages and sends a `` winner '' notification to the node @xmath47 of maximum rank , namely , that satisfies @xmath50 for every message @xmath49 . *",
    "decision : * if a node receives `` winner '' notifications from all its referees , then it enters the @xmath38 state ; + otherwise it sets its state to @xmath39 .",
    "[ thm : leadercomplete ] consider a complete network of @xmath0 nodes and assume the @xmath26 model of communication .",
    "with high probability , algorithm  [ alg : leadercomplete ] solves leader election in @xmath1 rounds , while using @xmath2 messages .    since all nodes enter either the @xmath38 or @xmath39 state after two rounds at the latest , the runtime bound of @xmath1 holds trivially .",
    "we now argue the message complexity bound . on expectation , there are @xmath51 candidate nodes . by using a standard chernoff bound ( cf .  theorem  4.4 in @xcite ) , there are at most @xmath52 candidate nodes with probability at least @xmath53 . in step 3 of the algorithm",
    ", each referee only sends messages to the candidate nodes which contacted it .",
    "since there are @xmath17 candidates and each approaches @xmath45 referees , the total number of messages sent is bounded by @xmath2 with high probability .",
    "finally , we show that algorithm 1 solves leader election with high probability .",
    "the probability that no node elects itself as leader is @xmath54 hence the probability that at least one node is elected as leader is at least @xmath53 .",
    "let @xmath55 be the node that generates the highest random rank @xmath56 among all candidate nodes ; with high probability , @xmath55 is unique .",
    "clearly , node @xmath55 enters the @xmath38 state , since it receives `` winner '' notifications from all its referees .",
    "now consider some other candidate node @xmath42 .",
    "this candidate chooses its referees randomly among all nodes .",
    "therefore , the probability that an individual referee selected by @xmath42 is among the referees chosen by @xmath55 , is @xmath57 .",
    "it follows that the probability that @xmath55 and @xmath42 do not choose any common referee node is asymptotically at most @xmath58 which means that with high probability , some node @xmath59 serves as common referee to @xmath55 and @xmath42 . by assumption , we have @xmath60 , which means that node @xmath42 does not receive @xmath45 `` winner '' notifications , and thus it subsequently enters the @xmath39 state . by taking a union bound over all candidate nodes other than @xmath55",
    ", it follows that with probability at least @xmath61 , no other node except @xmath55 wins all of its competitions , and therefore , node @xmath55 is the only node to become a leader .",
    "in this section , we present our main algorithm , which elects a unique leader in @xmath62 rounds ( w.h.p . ) , while using @xmath63 messages ( w.h.p . ) , where @xmath29 is the mixing time of a random walk on @xmath4 ( formally defined later on , in eq . ) .",
    "initially , any node @xmath32 only knows the mixing time ( or a constant factor estimate of ) @xmath29 ; in particular @xmath32 does not have any a priori knowledge about the actual topology of @xmath4 .",
    "the algorithm presented here requires nodes to perform random walks on the network by token forwarding in order to choose sufficiently many referee nodes at random .",
    "thus essentially random walks perform the role of sampling as done in algorithm [ alg : leadercomplete ] and is conceptually similar .",
    "whereas in the complete graph randomly chosen nodes act as referees , here any intermediate node ( in the random walk ) that sees tokens from two competing candidates can act as a referee and notify the winner .",
    "one slight complication we have to deal with in the general setting is that in the @xmath26 model it is impossible to perform too many walks in parallel along an edge .",
    "we solve this issue by sending only the _ count _ of tokens that need to be sent by a particular candidate , and not the tokens themselves .",
    "while using random walks can be viewed as a generalization of the sampling performed in algorithm  [ alg : leadercomplete ] , showing that two candidate nodes intersect in at least one referee leads to an interesting balls - into - bins scenario where balls ( i.e. , random walks ) have a _ non - uniform _ probability to be placed in some bin ( i.e. , reach a referee node ) .",
    "this non - uniformity of the random walk distribution stems from the fact that @xmath4 might not be a regular graph .",
    "we show that the non - uniform case does not worsen the probability of two candidates reaching a common referee , and hence an analysis similar to the one given for complete graphs goes through .",
    "we now introduce some basic notation for random walks .",
    "suppose that @xmath64 and let @xmath65 denote the degree of node @xmath66 .",
    "the @xmath67 _ transition matrix _ @xmath68 of @xmath4 has entries @xmath69 if there is an edge @xmath70 , otherwise @xmath71 . the entry @xmath72 gives the probability that a random walk moves from node @xmath73 to node @xmath74 .",
    "the position of a random walk after @xmath75 steps is represented by a probability distribution @xmath76 determined by @xmath68 .",
    "if some node @xmath73 starts a random walk , the initial distribution @xmath77 of the walk is an @xmath0-dimensional vector having all zeros except at index @xmath66 where it is @xmath78 .",
    "once the node @xmath32 has chosen a random neighbor to forward the token , the distribution of the walk after @xmath78 step is given by @xmath79 and in general we have @xmath80 .",
    "if @xmath4 is non - bipartite and connected , then the distribution of the walk will eventually converge to the _ stationary distribution _",
    "@xmath81 , which has entries @xmath82 and satisfies @xmath83 .",
    "we define the _ mixing time _",
    "@xmath29 of a graph g with @xmath0 nodes as the minimum @xmath75 such that , for all starting distributions @xmath77 , @xmath84 where @xmath85 denotes the usual maximum norm on a vector .",
    "clearly , if @xmath4 is a complete network , then @xmath86 . for expander graphs",
    "it is well known that @xmath87 .",
    "note that mixing time is well - defined only for non - bipartite graphs ; however , by using a lazy random walk strategy ( i.e. , with probability @xmath88 stay in the current node ; otherwise proceed as usual ) our algorithm will work for bipartite graphs as well .",
    "* var * @xmath89 ; @xmath90 node @xmath32 decides to become a candidate with probability @xmath43 and generates a random rank @xmath44 from @xmath48 .",
    "node @xmath32 creates @xmath45 tokens of type @xmath91 .",
    "node @xmath32 starts @xmath45 random walks ( called _ competitions _ ) , each of which is represented by the random walk token @xmath91 ( of @xmath17 bits ) where @xmath44 represents @xmath32 s random rank . the counter @xmath75 is the number ( initially 1 ) of walks that are represented by this token ( explained in line  [ line : counter ] ) .",
    "( note that any intermediate node along the random walk can act as a referee and disqualify the token of a low - rank candidate ) [ line : disqualify ] a node @xmath42 discards every received token @xmath91 if @xmath42 has received ( possibly in the same round ) a token @xmath46 with @xmath92 .",
    "node @xmath42 remembers the port of an arbitrarily chosen neighbor that sent one of the ( possibly merged ) tokens containing @xmath46 in variable @xmath93 and sets its variable @xmath94 to @xmath46 .",
    "[ line : origin ]    let @xmath95 be a token received by @xmath42 and suppose that @xmath96 is not discarded in line  [ line : disqualify ] . for simplicity , we consider all distinct tokens that arrive in the current round containing the same value @xmath44 at @xmath42 to be merged into a single token @xmath91 before processing where @xmath75 holds the accumulated count .",
    "node @xmath42 randomly samples @xmath75 times from its neighbors .",
    "[ line : counter ] if a neighbor @xmath59 was chosen @xmath97 times , @xmath42 sends a token @xmath98 to @xmath59 .",
    "suppose that node @xmath42 has not discarded some token generated by a node @xmath47 . according to line  [ line : disqualify ] , @xmath47 has generated the largest rank among all tokens seen by @xmath42 .",
    "node @xmath42 generates a `` winner '' notification @xmath99 for @xmath46 and sends it to the neighbor stored in @xmath93 ( cf .",
    "line  [ line : origin ] ) .",
    "the field @xmath100 is set to @xmath78 by @xmath42 and contains the number of `` winner '' notifications represented by this token .",
    "if a node @xmath32 receives ( possibly ) multiple `` winner '' notifications for @xmath46 , it simply forwards a token @xmath101 to the neighbor stored in @xmath93 where @xmath102 is the accumulated count of all received tokens .",
    "if a node wins all competitions , i.e. , receives @xmath103 `` winner '' notifications it enters the @xmath38 state ; otherwise it sets its state to @xmath39 .",
    "[ thm : leader ] consider a non - bipartite network @xmath4 of @xmath0 nodes with mixing time @xmath29 , and assume the @xmath26 model of communication .",
    "with high probability , algorithm  [ alg : leader ] solves leader election within @xmath104 rounds , while using @xmath105 messages .",
    "we first argue the message complexity bound . as argued in the proof of thm .",
    "[ thm : leadercomplete ] , there are at most @xmath52 candidate nodes with probability at least @xmath53 .",
    "every candidate node @xmath32 creates @xmath106 tokens and initiates a random walk of length @xmath29 , for each of the @xmath106 tokens . by the description of the algorithm",
    ", there are @xmath2 random walks of length @xmath104 .",
    "in addition , at most one notification message is sent at the last step of each random walk , and it travels a distance of at most @xmath104 .",
    "hence the total number of messages sent throughout the execution is bounded by @xmath63 with high probability .",
    "the running time bound depends on the time that it takes to complete the @xmath45 random walks in parallel and the notification of the winner . by line  [ line : disqualify ] , it follows that a node only forwards at most one token to any neighbor in a round , thus there is no delay due to congestion .",
    "moreover , for notifying the winner , nodes forward the `` winner '' notification for winner @xmath47 to the neighbor stored in @xmath93 . according to line  [ line : origin ] ,",
    "a node sets @xmath93 to a neighbor from which it has received the first token originated from @xmath47 .",
    "thus there can be no loops when forwarding the `` winner '' notifications , which reach the winner @xmath47 in at most @xmath29 rounds .",
    "we now argue that algorithm  [ alg : leader ] solves leader election with high probability . similarly to algorithm  [ alg : leadercomplete ]",
    ", it follows that there will be at least one leader with high probability .",
    "now consider some other candidate node @xmath42 . recall that we have that @xmath60 by assumption . by the description of the algorithm ,",
    "node @xmath42 chooses its referees by performing @xmath107 random walks of length @xmath29 .",
    "we can not argue the same way as in the proof of algorithm  [ alg : leadercomplete ] , since in general , the stationary distribution of @xmath4 might not be the uniform distribution vector @xmath108 .",
    "let @xmath109 be the @xmath66-th entry of the stationary distribution .",
    "let @xmath110 be the indicator random variable that is @xmath78 if there is a collision ( of random walks ) at referee node @xmath66 .",
    "we have @xmath111 } = ( 1 - ( 1-p_i)^\\rho ) ^2.\\ ] ] we want to show that the probability of error ( i.e. , having no collisions ) is small ; in other words , we want to upper bound @xmath112}$ ] .",
    "the following lemma shows that @xmath113}$ ] is maximized for the uniform distribution .",
    "[ lem : poisson ] consider @xmath114 balls that are placed into @xmath0 bins according to some probability distribution @xmath115 and let @xmath109 be the @xmath66-th entry of @xmath115 .",
    "let @xmath110 be the indicator random variable that is @xmath78 if there is a collision ( of random walks ) at referee node @xmath66 .",
    "then @xmath116}$ ] is maximized for the uniform distribution .    by definition",
    ", we have @xmath117 } = ( 1 - ( 1-p_i)^\\rho ) ^2.$ ] note that the events @xmath118 and @xmath119 are not necessarily independent .",
    "a common technique to treat dependencies in balls - into - bins scenarios is the poisson approximation where we consider the number of balls in each bin to be independent poisson random variables with mean @xmath120 .",
    "this means we can apply corollary 5.11 of @xcite , which states that if some event @xmath121 occurs with probability @xmath122 in the poisson case , it occurs with probability at most @xmath123 in the exact case , i.e. , we only lose a constant factor by using the poisson approximation .",
    "a precondition for applying corollary 5.11 , is that the probability for event @xmath121 monotonically decreases ( or increases ) in the number of balls , which is clearly the case when counting the number of collisions of balls .",
    "considering the poisson case , we get @xmath124 }          & = \\prod_{i=1}^n { \\hbox{\\rm i\\kern-2pt p}\\left [ x_i = 0 \\right ] }          = \\prod_{i=1}^n\\left ( 1 - ( 1 - ( 1 - p_i)^\\rho)^2\\right ) \\\\          &",
    "{ \\leqslant}\\prod_{i=1}^n \\left(1 - ( 1 - e^{-p_i \\rho})^2 \\right )          { \\leqslant}\\prod_{i=1}^n \\left(1 - ( p_i \\rho)^2 \\right )           { \\leqslant}\\prod_{i=1}^n e^{-p_i^2 \\rho^2 }          = \\exp\\left(-\\rho^2 \\sum_{i=1}^n p_i^2\\right ) .",
    "\\end{aligned}\\ ] ] to maximize @xmath125}$ ] , it is thus sufficient to minimize @xmath126 under the constraint @xmath127 . using lagrangian optimization it follows that this is minimized for the uniform distribution , which completes the proof of lemma  [ lem : poisson ] .    by , the probability of such a walk hitting any of the referees chosen by @xmath55 , is at least @xmath128 .",
    "it follows that the probability that @xmath55 and @xmath42 do not choose a common referee node is asymptotically at most @xmath129 therefore , the event that node @xmath42 does not receive sufficiently many `` winner '' notifications , happens with probability @xmath130 , which requires @xmath42 to enter the @xmath39 state . by taking a union bound over all other candidate nodes",
    ", it follows that with high probability no other node except @xmath55 will win all of its competitions , and therefore , node @xmath55 is the only node to become a leader with probability at least @xmath61 .",
    "in this section , we prove a lower bound on the number of messages required by any algorithm that solves leader election with probability at least @xmath9 , for any constant @xmath131 .",
    "our model assumes that all processors execute the same algorithm and have access to an unbiased private coin .",
    "so far we have assumed that nodes are _ not _ equipped with unique ids .",
    "nevertheless , our lower bound still holds even if the nodes start with unique ids .",
    "our lower bound applies to all algorithms that send only @xmath132 messages with probability at least @xmath61 . in other words",
    ", the result still holds for algorithms that have small but nonzero probability for producing runs where the number of messages sent is much larger ( e.g. , @xmath133 ) .",
    "we show the result for the @xmath27 model , which implies the same for the @xmath26 model .",
    "[ thm : lb ] consider any algorithm @xmath36 that sends at most @xmath134 messages ( of arbitrary size ) with high probability on a complete network of @xmath0 nodes . if @xmath36 solves leader election with probability at least @xmath9 , for any constant @xmath10 , then @xmath135 .",
    "this holds even if nodes are equipped with unique identifiers ( chosen by an adversary ) .",
    "note that theorem  [ thm : lb ] is essentially tight with respect to the number of messages _ and _ the probability of successfully electing a leader . to see this , first observe that our algorithm  [ alg : leadercomplete ] can be modified such that each node becomes a candidate with probability @xmath136 , for some constant @xmath137 , and where each candidate only contacts @xmath138 referee nodes .",
    "this yields a message complexity of @xmath139 and success with ( large ) constant probability .",
    "furthermore , consider the naive randomized algorithm where each node initially chooses to become leader with probability @xmath140 and then terminates .",
    "this algorithm succeeds with probability @xmath141 without sending any messages at all , which demonstrates that there has to be a sudden `` jump '' in the required message complexity when breaking the @xmath142 barrier in success probability .",
    "the rest of this section is dedicated to proving theorem  [ thm : lb ] .",
    "we first show the result for the case where nodes are anonymous , i.e. , are _ not _ equipped with unique identifiers , and later on extend the impossibility result to the non - anonymous case by an easy reduction .",
    "assume that there exists some algorithm @xmath36 that solves leader election with probability at least @xmath143 but sends only @xmath144 messages .",
    "the remainder of the proof involves showing that this yields a contradiction .",
    "consider a complete network where for every node , the adversary chooses the connections of its ports as a random permutation on @xmath145 .",
    "for a given run @xmath146 of an algorithm , define the _ communication graph _",
    "@xmath147 to be a directed graph on the given set of @xmath0 nodes where there is an edge from @xmath32 to @xmath42 if and only if @xmath32 sends a message to @xmath42 in some round @xmath148 of the run @xmath146 . for any node @xmath32 ,",
    "denote the _ state of @xmath32 in round @xmath149 of the run @xmath146 _ by @xmath150 .",
    "let @xmath151 be the set of all node states possible in algorithm @xmath36 .",
    "( when @xmath146 is known , we may simply write @xmath152 and @xmath153 . ) with each node @xmath154 , associate its state @xmath153 in @xmath152 , the communication graph of round @xmath149 .",
    "we say that node _",
    "@xmath32 influences node @xmath47 by round @xmath149 _ if there is a directed path from @xmath32 to @xmath47 in @xmath152 .",
    "( our notion of influence is more general than the causality based `` happens - before '' relation of @xcite , since a directed path from @xmath32 to @xmath47 is necessary but not sufficient for @xmath47 to be causally influenced by @xmath32 . )",
    "a node @xmath32 is an _ initiator _ if it is not influenced before sending its first message .",
    "that is , if @xmath32 sends its first message in round @xmath149 , then @xmath32 has an outgoing edge in @xmath155 and is an isolated vertex in @xmath156 . for every initiator @xmath32",
    ", we define the _ influence cloud _ @xmath157 as the pair @xmath158 , where @xmath159 is the ordered set of all nodes that are influenced by @xmath32 , namely , that are reachable along a directed path in @xmath152 from @xmath32 .",
    "ordered by the time by which they joined _ joins the cloud of @xmath32 in @xmath149 _ if @xmath160 and @xmath161 . ]",
    "the cloud ( breaking ties arbitrarily ) , and @xmath162 is their configuration after round @xmath149 , namely , their current tuple of states .",
    "( in what follows , we sometimes abuse notation by referring to the ordered node set @xmath163 as the influence cloud of @xmath32 . ) note that a _ passive _ ( non - initiator ) node @xmath42 does not send any messages before receiving the first message from some other node .    since we are only interested in algorithms that send a finite number of messages , in every execution @xmath146",
    "there is some round @xmath164 by which no more messages are sent .    in general , it is possible that in a given execution , two influence clouds @xmath165 and @xmath166 intersect each other over some common node @xmath42 , if @xmath42 happens to be influenced by both @xmath167 and @xmath168 .",
    "the following lemma shows that the low message complexity of algorithm @xmath36 yields a good probability for all influence clouds to be disjoint from each other .",
    "hereafter , we fix a run @xmath146 of algorithm @xmath36 .",
    "let @xmath169 be the event that there is no intersection between ( the node sets of ) the influence clouds existing at the end of run @xmath146 , i.e. , @xmath170 for every two initiators @xmath32 and @xmath171 .",
    "let @xmath172 be the event that algorithm @xmath36 sends no more than @xmath134 messages in the run @xmath146 .",
    "[ lem : noint ] assume that @xmath173 } { \\geqslant}1 - 1/n$ ] .",
    "if @xmath144 , then @xmath174 } { \\geqslant}1 - \\frac{1}{n }   - \\frac{f^2(n)}{n - f(n ) } \\in 1-o(1)$ ] .",
    "consider a round @xmath149 , some cloud @xmath175 and any node @xmath176 .",
    "assuming event @xmath172 , there are at most @xmath134 nodes that have sent or received a message and may thus be be a part of some other cloud except @xmath175 . recall that the port numbering of every node was chosen uniformly at random and ,",
    "since we conditioned on the occurrence of event @xmath172 , any node knows the destinations of at most @xmath134 of its ports in any round .",
    "therefore , to send a message to a node in another cloud , @xmath42 must hit upon one of the ( at most @xmath134 ) ports leading to other clouds , from among its ( at least @xmath177 ) yet unexposed ports .",
    "let @xmath178 be the event that a message sent by node @xmath42 in round @xmath149 reaches a node @xmath32 that is already part of some other ( non - singleton ) cloud .",
    "( recall that if @xmath32 is in a singleton cloud due to not having received or sent any messages yet , it simply becomes a member of @xmath42 s cloud . )",
    "we have @xmath179 } { \\leqslant}\\frac{f(n)}{n - f(n)}$ ] . during the entire run",
    ", @xmath180 messages are sent in total by some nodes @xmath181 ( in possibly distinct clouds ) in rounds @xmath182 , yielding events @xmath183 . taking a union bound shows that @xmath184 } { \\leqslant}\\frac{f^2(n)}{n - f(n)},\\ ] ] which is @xmath185 , for @xmath144 .",
    "observe that @xmath186 } = 1 - { \\hbox{\\rm i\\kern-2pt p}\\left[\\bigvee_{i=1}^\\ell h_{v_i}^{r_i } \\mid m\\right]}$ ] .",
    "since @xmath187 } = { \\hbox{\\rm i\\kern-2pt p}\\left[n\\mid m\\right ] } \\cdot { \\hbox{\\rm i\\kern-2pt p}\\left[m\\right]}$ ] , it follows that @xmath174 } { \\geqslant}\\left(1 - \\frac{f^2(n)}{n - f(n)}\\right)\\left(1-\\frac{1}{n}\\right ) { \\geqslant}1 - \\frac{1}{n } - \\frac{f^2(n)}{n - f(n ) } \\in 1 - o(1)$ ] , as required .",
    "we next consider _ potential cloud configurations _ , namely , @xmath188 , where @xmath189 for every @xmath66 , and more generally ,",
    "_ potential cloud configuration sequences _",
    "@xmath190 , where each @xmath191 is a potential cloud configuration , which may potentially occur as the configuration tuple of some influence clouds in round @xmath66 of some execution of algorithm @xmath36 ( in particular , the lengths of the cloud configurations @xmath191 are monotonely non - decreasing ) .",
    "we study the occurrence probability of potential cloud configuration sequences .",
    "we say that the potential cloud configuration @xmath188 _ is realized _ by the initiator @xmath32 in round @xmath149 of execution @xmath146 if the influence cloud @xmath158 has the same node states in @xmath192 as those of @xmath193 , or more formally , @xmath162 , such that @xmath194 and @xmath195 for every @xmath196 $ ] . in this case , the influence cloud @xmath197 is referred to as a _ realization _ of the potential cloud configuration @xmath193 . ( note that a potential cloud configuration may have many different realizations . )    more generally , we say that the potential cloud configuration sequence @xmath190 is realized by the initiator @xmath32 in execution @xmath146 if for every round @xmath198 , the influence cloud @xmath199 is a realization of the potential cloud configuration @xmath191 . in this case , the sequence of influence clouds of @xmath32 up to round @xmath149 , @xmath200 , is referred to as a realization of @xmath201 .",
    "( again , a potential cloud configuration sequence may have many different realizations . )    for a potential cloud configuration @xmath193 , let @xmath202 be the event that @xmath193 is realized by the initiator @xmath32 in ( round @xmath149 of ) the run of algorithm @xmath36 .",
    "for a potential cloud configuration sequence @xmath201 , let @xmath203 denote the event that @xmath201 is realized by the initiator @xmath32 in ( the first @xmath149 rounds of ) the run of algorithm @xmath36 .",
    "[ lem : clouds ] restrict attention to executions of algorithm @xmath36 that satisfy event @xmath204 , namely , in which all final influence clouds are disjoint . then @xmath205 } = { \\hbox{\\rm i\\kern-2pt p}\\left[e_v({\\bar z}^r)\\right]}$ ] for every @xmath206 $ ] , every potential cloud configuration sequence @xmath207 , and every two initiators @xmath32 and @xmath42 .",
    "the proof is by induction on @xmath149 .",
    "initially , in round @xmath78 , all possible influence clouds of algorithm @xmath36 are singletons , i.e. , their node sets contain just the initiator .",
    "neither @xmath32 nor @xmath42 have received any messages from other nodes .",
    "this means that @xmath208 } = { \\hbox{\\rm i\\kern-2pt p}\\left[\\sigma_1(v)=s\\right]}$ ] for all @xmath209 , thus any potential cloud configuration @xmath210 has the same probability of occuring for any initiator , implying the claim .",
    "assuming that the result holds for round @xmath211 , we show that it still holds for round @xmath149 .",
    "consider a potential cloud configuration sequence @xmath190 and two initiators @xmath32 and @xmath42 .",
    "we need to show that @xmath201 is equally likely to be realized by @xmath32 and @xmath42 , conditioned on the event @xmath204 . by the inductive hypothesis",
    ", the prefix @xmath212 satisfies the claim .",
    "hence it suffices to prove the following .",
    "let @xmath213 be the probability of the event @xmath214 conditioned on the event @xmath215 .",
    "define the probability @xmath216 similarly for @xmath42 .",
    "then it remains to prove that @xmath217 .    to do that we need to show , for any state @xmath218 , that the probability that @xmath219 , the @xmath220th node in @xmath197 , is in state @xmath221 , conditioned on the event @xmath215 , is the same as the probability that @xmath222 , the @xmath220th node in @xmath223 , is in state @xmath221 , conditioned on the event @xmath224 .",
    "there are two cases to be considered .",
    "the first is that the potential influence cloud @xmath225 has @xmath220 or more states . then by our assumption that events @xmath226 and @xmath227 hold , the nodes @xmath219 and @xmath222 were already in @xmath32 s and @xmath42 s influence clouds , respectively , at the end of round @xmath228 .",
    "the node @xmath219 changes its state from its previous state , @xmath229 , to @xmath221 on round @xmath149 as the result of receiving some messages @xmath230 from neighbors @xmath231 in @xmath32 s influence cloud @xmath232 , respectively . in turn , node @xmath233 sends message @xmath234 to @xmath219 on round @xmath149 as the result of being in a certain state @xmath235 at the beginning of round @xmath149 ( or equivalently , on the end of round @xmath228 ) and making a certain random choice ( with a certain probability @xmath236 for sending @xmath234 to @xmath219 ) .",
    "but if one assumes that the event @xmath227 holds , namely , that @xmath237 is realized by the initiator @xmath42 , then the corresponding nodes @xmath238 in @xmath42 s influence cloud @xmath239 will be in the same respective states ( @xmath240 for every @xmath220 ) on the end of round @xmath228 , and therefore will send the messages @xmath230 to the node @xmath222 with the same probabilities @xmath236 . also , on the end of round @xmath228 , the node @xmath222 is in the same state @xmath229 as @xmath219 ( assuming event @xmath227 ) .",
    "it follows that the node @xmath222 changes its state to @xmath221 on round @xmath149 with the same probability as the node @xmath219 .",
    "the second case to be considered is when the potential influence cloud @xmath225 has fewer than @xmath220 states .",
    "this means ( conditioned on the events @xmath226 and @xmath227 respectively ) that the nodes @xmath219 and @xmath222 were not in the respective influence clouds on the end of round @xmath228 .",
    "rather , they were both passive nodes . by an argument similar to that made for round 1 ,",
    "any pair of ( so far ) passive nodes have equal probability of being in any state .",
    "hence @xmath241 } = { \\hbox{\\rm i\\kern-2pt p}\\left[\\sigma_{r-1}(w_{v , j})=s\\right]}$ ] for all @xmath209 . as in the former case ,",
    "the node @xmath219 changes its state from its previous state , @xmath229 , to @xmath221 on round @xmath149 as the result of receiving some messages @xmath230 from neighbors @xmath231 that are already in @xmath32 s influence cloud @xmath232 , respectively . by a similar analysis",
    ", it follows that the node @xmath222 changes its state to @xmath221 on round @xmath149 with the same probability as the node @xmath219 .",
    "we now conclude that for every potential cloud configuration @xmath193 , every execution @xmath146 and every two initiators @xmath32 and @xmath42 , the events @xmath242 and @xmath243 are equally likely .",
    "more specifically , we say that the potential cloud configuration @xmath193 is _ equi - probable for initiators @xmath32 and @xmath42 _ if @xmath244 } = { \\hbox{\\rm i\\kern-2pt p}\\left[e^\\rho_v(z ) \\mid n\\right]}$ ] .",
    "although a potential cloud configuration @xmath193 may be the end - colud of many different potential cloud configuration sequences , and each such potential cloud configuration sequence may have many different realizations , the above lemma implies the following ( integrating over all possible choices ) .",
    "[ cor : clouds ] restrict attention to executions of algorithm @xmath36 that satisfy event @xmath204 , namely , in which all final influence clouds are disjoint .",
    "consider two initiators @xmath32 and @xmath42 and a potential cloud configuration @xmath193 .",
    "then @xmath193 is equi - probable for @xmath32 and @xmath42 .    by assumption ,",
    "algorithm @xmath36 succeeds with probability at least @xmath9 , for some fixed constant @xmath131 .",
    "let @xmath245 be the event that @xmath36 elects exactly one leader .",
    "we have @xmath246 } { \\leqslant}{\\hbox{\\rm i\\kern-2pt p}\\left[s \\mid m \\wedge n\\right ] } { \\hbox{\\rm i\\kern-2pt p}\\left[m \\wedge n\\right ] } + { \\hbox{\\rm i\\kern-2pt p}\\left[\\text{not $ ( m\\wedge n)$}\\right]}.\\ ] ] by lemma  [ lem : noint ] , we know that @xmath247 } \\in 1 - o(1)$ ] and @xmath248 } \\in o(1)$ ] , and thus it follows that @xmath249 } { \\geqslant}\\frac{{1}/{e } + { \\varepsilon}- o(1)}{1 - o(1 ) } > \\frac{1}{e } ,    \\label{eq : succn}\\end{aligned}\\ ] ] for sufficiently large @xmath0 . by cor .",
    "[ cor : clouds ] , each of the initiators has the same probability @xmath122 of realizing a potential cloud configuration where some node is a leader . assuming that events @xmath172 and @xmath204 occur , it is immediate that @xmath250 .",
    "let @xmath251 be the random variable that represents the number of disjoint influence clouds .",
    "recall that algorithm @xmath36 succeeds whenever event @xmath245 occurs .",
    "its success probability assuming that @xmath252 , at most @xmath134 messages are sent , and all influence clouds are disjoint , is given by @xmath253 } = c p ( 1-p)^{c-1}. \\label{eq : succ}\\end{aligned}\\ ] ] for any given @xmath137 , the value of is maximized if @xmath254 , which yields that @xmath255 } { \\leqslant}1/e$ ] for any @xmath256 .",
    "it follows that @xmath257 } { \\leqslant}1/e$ ] as well .",
    "this , however , is a contradiction to and completes the proof of theorem  [ thm : lb ] for algorithms without unique identifiers .",
    "we now argue why our result holds for any algorithm @xmath258 that assumes that nodes are equipped with unique ids ( chosen by the adversary ) .",
    "let @xmath259 be the event that @xmath258 succeeds in leader election .",
    "suppose that @xmath258 sends only @xmath144 messages with high probability but @xmath260 } { \\geqslant}1/e + { \\varepsilon}$ ] , for some constant @xmath10 .",
    "now consider an algorithm @xmath261 that works in a model where nodes do not have ids .",
    "algorithm @xmath261 is identical to @xmath258 with the only difference that before performing any other computation , every node generates a random number from the range @xmath262 $ ] and uses this value in place of the unique i d required by @xmath258 .",
    "let @xmath263 be the event that all node ids are distinct ; clearly @xmath264}{\\geqslant}1 - 1/n$ ] . by definition of @xmath261 , we know that @xmath265 } = { \\hbox{\\rm i\\kern-2pt p}\\left[s_{b ' } \\mid i\\right]}$ ] and , from the anonymous case above , we get @xmath266}{\\hbox{\\rm i\\kern-2pt p}\\left[i\\right ] } { \\leqslant}{\\hbox{\\rm i\\kern-2pt p}\\left[s_{b'}\\right ] } { \\leqslant}1/e + o(1),$ ] since only @xmath132 messages are sent with high probability by @xmath261 .",
    "it follows that @xmath266 } { \\leqslant}\\frac{1/e + o(1)}{1 - 1/n } < 1/e + o(1),$ ] and thus also @xmath265 } { \\leqslant}1/e + o(1)$ ] , which is a contradiction .",
    "this completes the proof of theorem  [ thm : lb ] .",
    "we studied the role played by randomization in distributed leader election .",
    "some open questions on randomized leader election are raised by our work : ( 1 ) can we improve the message complexity and/or running time for general graphs ? ( 2 ) is there a separation between the message complexity for algorithms that succeed with high probability versus algorithms that achieve leader election with large constant probability ?",
    "10            tushar  deepak chandra , robert griesemer , and joshua redstone .",
    "paxos made live - an engineering perspective ( 2006 invited talk ) . in _ proceedings of the 26th annual acm symposium on principles of distributed computing _",
    ", 2007 .",
    "indranil gupta , robbert  van renesse , and kenneth  p. birman . a probabilistically correct leader election protocol for large groups . in _ proceedings of the 14th international conference on distributed computing _",
    ", disc 00 , pages 89103 , 2000 .",
    "maleq khan , fabian kuhn , dahlia malkhi , gopal pandurangan , and kunal talwar .",
    "efficient distributed approximation algorithms via probabilistic tree embeddings . in _ proceedings of the twenty - seventh acm symposium on principles of distributed computing _ , podc 08 , pages 263272 , new york , ny , usa , 2008 .",
    "acm .",
    "antony i.  t. rowstron and peter druschel .",
    "pastry : scalable , decentralized object location , and routing for large - scale peer - to - peer systems . in _ proceedings of the ifip / acm international conference on distributed systems platforms heidelberg _ , middleware 01 , pages 329350 .",
    "springer - verlag , 2001 ."
  ],
  "abstract_text": [
    "<S> this paper concerns _ randomized _ leader election in synchronous distributed networks . </S>",
    "<S> a distributed leader election algorithm is presented for complete @xmath0-node networks that runs in @xmath1 rounds and ( with high probability ) uses only @xmath2 messages to elect a unique leader ( with high probability ) . </S>",
    "<S> when considering the `` explicit '' variant of leader election where eventually every node knows the identity of the leader , our algorithm yields the asymptotically optimal bounds of @xmath1 rounds and @xmath3 messages . </S>",
    "<S> this algorithm is then extended to one solving leader election on any connected non - bipartite @xmath0-node graph @xmath4 in @xmath5 time and @xmath6 messages , where @xmath7 is the mixing time of a random walk on @xmath4 . </S>",
    "<S> the above result implies highly efficient ( sublinear running time and messages ) leader election algorithms for networks with small mixing times , such as expanders and hypercubes . </S>",
    "<S> in contrast , previous leader election algorithms had at least linear message complexity even in complete graphs . moreover </S>",
    "<S> , super - linear message lower bounds are known for time - efficient _ deterministic _ leader election algorithms . finally , we present an almost matching lower bound for randomized leader election , showing that @xmath8 messages are needed for any leader election algorithm that succeeds with probability at least @xmath9 , for any small constant @xmath10 . </S>",
    "<S> we view our results as a step towards understanding the randomized complexity of leader election in distributed networks . </S>"
  ]
}