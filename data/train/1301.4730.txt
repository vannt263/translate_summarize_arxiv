{
  "article_text": [
    "the multi - way relay channel models data exchange among @xmath0 wireless users through a relay ( e.g. , base station or satellite ) .",
    "the _ two - way _ relay channel ( i.e. , @xmath1 ) has been intensively studied  @xcite .",
    "a canonical generalization is the _ multi - way _ relay channel ( mwrc ) , @xmath2 , where each user sends its data to all other users .",
    "the mwrc is commonly studied in the context of independent messages  @xcite .",
    "recently , we investigated the mwrc with arbitrarily correlated messages where the _ uplinks _ ( i.e. , the channels from the users to the relay ) are orthogonal ( i.e. , non - interfering ) @xcite .",
    "the coding scheme proposed therein requires non - interfering uplinks . in this paper",
    ", we study the mwrc with common messages , i.e. , some messages are known to two users .",
    "while common messages is a special form of correlated messages , the uplink here is interfering ( the users inputs to the channel interfere with each other ) , modeled by the finite - field additive channel .",
    "we derive the capacity region of the finite - field mwrc ( ffmwrc ) with common messages . to this end",
    ", we construct an optimal coding scheme based on functional decode - forward  @xcite where the relay decodes functions of the users messages on the uplink , and forwards the functions back to the users on the _ downlink _ ( i.e. , the channel from the relay to the users ) .",
    "the main difficulty is to determine an optimal function that the relay should decode , taking into account that some messages are known to two users .",
    "[ fig ] shows the ffmwrc .",
    "denote the users by 1 , 2 , @xmath3 , @xmath0 , and the relay by 0 .",
    "further denote the channel input from node @xmath4 by @xmath5 , and the channel output received by node @xmath4 by @xmath6 .",
    "the ffmwrc is defined as follows : @xmath7 where the uplink variables @xmath8 , @xmath9 , and @xmath5 for all @xmath10 are elements of a finite field of order @xmath11 , @xmath12 is the addition in the field , and @xmath9 is arbitrarily - distributed noise . for the ffmwrc considered in this paper , we not restrict any channel model for the downlink .",
    "this general model includes the finite - field downlink channel  @xcite as a special case .",
    "the finite - field model simplifies the additive white gaussian noise ( awgn ) channel ",
    "commonly used for the wireless environment  in the following ways : ( i ) there is no input ( power ) constraint for the finite - field model ; and ( ii ) we know an optimal linear coding scheme for the multiple - access finite - field channel .",
    "it nonetheless retains two important characteristics of the awgn channel : ( i ) the channel is corrupted with additive noise ; and ( ii ) the channel inputs interfere linearly with each other , i.e. , the transmitted signals are added up at the receiver .",
    "coding schemes designed for the ffmwrc  @xcite have been applied to  and shown to be optimal in  the symmetrical awgn mwrc  @xcite .",
    "we use the channel @xmath13 times for the users to exchange pairwise common messages in addition to private messages .",
    "the terms `` private '' and `` common '' here are defined with respect to the senders , i.e. , private messages are known to only one sender , and common messages are messages known to two senders .",
    "formally , there are @xmath14 independent messages denoted by @xmath15 , where each @xmath16 .",
    "each user @xmath4 knows its private message @xmath17 and common messages @xmath18 , where each @xmath19 is the message user @xmath4 shares with user @xmath20 . by definition ,",
    "we define a rate tuple as @xmath22 @xmath23 , which is a non - negative real vector of length @xmath24 .",
    "we use square brackets to indicate the variable associated with a channel use .",
    "the noise term @xmath25 $ ] is independent and identically distributed ( iid ) for each channel use @xmath26 .",
    "a length-@xmath13 block code consists of the following :    1 .",
    "encoding functions at each user @xmath27 : + @xmath28 = f_{it } \\big ( w_i , ( w_{i , j})_{j \\in \\{1,2\\dotsc , l\\}\\setminus{i } } , ( y_i[\\tau])_{\\tau \\in \\{1,2,\\dotsc , t-1\\ } } \\big)$ ] , for all @xmath26 .",
    "encoding functions at the relay : + @xmath29 = f_{0 t } \\big ( ( y_0[\\tau])_{\\tau \\in \\{1,2,\\dotsc , t-1\\ } } \\big)$ ] , + for all @xmath26 .",
    "3 .   a decoding function at each user @xmath30 : + @xmath31 + @xmath32)_{\\tau \\in \\ { 1,2 , \\dotsc , n\\ } } \\big)$ ] .    here , @xmath33 is the estimate of @xmath34 by user @xmath4 .",
    "a decoding error occurs if some user wrongly decodes some messages , i.e. , @xmath35 for some @xmath36 and some @xmath4 .",
    "this means each user needs to decode _ all messages_. assuming that each message is uniformly distributed , we denote the probability of decoding error by @xmath37 .",
    "we say that the rate tuple @xmath38 is achievable if the following is true : for any @xmath39 , there exists a block code such that @xmath40 .",
    "the capacity region is the closure of all achievable rate tuples .      for the ffmwrc with only private messages ( i.e. , @xmath41 for all @xmath42 )",
    ", we have the following capacity result , which is a straightforward extension of the ffmwrc with finite - field downlinks  @xcite ( refer to appendix  [ appendix : generalization ] for proof ) :    [ lemma : private ] consider the ffmwrc with only private messages , where each user @xmath4 transmits an independent private message @xmath17 .",
    "the rate @xmath43 is achievable if there exists some @xmath44 such that the following is true for all @xmath30 : @xmath45 conversely , if @xmath46 is achievable , then there exists some @xmath44 such that is satisfied all @xmath47 with a non - strict inequality ( i.e. , @xmath48 instead of @xmath49 ) .    in this paper",
    ", we refer to the coding scheme that achieves the capacity region in lemma  [ lemma : private ] as functional - decode - forward for private messages ( fdf - p ) . in brief",
    ", we let two users transmit at a time and have the relay decode a function ( in this case , the finite - field addition ) of the messages .",
    "we cycle through different user pairs that transmit in the following order : @xmath50 .",
    "although we can use the fdf - p scheme when there are common messages , the scheme is not always optimal .",
    "consider an ffmwrc with three users , where    1 .",
    "@xmath51 , i.e. , @xmath52 , 2 .",
    "@xmath53 , + @xmath54 , 3 .",
    "@xmath55 , 4 .",
    "@xmath56 .    to transmit private and common messages using fdf - p , we first split each common message @xmath19 into two parts , say @xmath57 and @xmath58 , and let user @xmath4 transmit @xmath57 and user @xmath20 transmits @xmath58 as if they were private messages .",
    "more specifically , we split the message @xmath59 into independent sub - messages , i.e. , @xmath60 of rate @xmath61 and @xmath62 of rate @xmath63 , where @xmath64 .",
    "similarly , we split the common messages ( i ) @xmath65 into @xmath66 and @xmath67 with rates @xmath68 and @xmath69 respectively , and ( ii ) @xmath70 into @xmath71 and @xmath72 with rates @xmath73 and @xmath74 respectively . doing this",
    ", each user @xmath4 will need to transmit @xmath75 to the other two users at the rate @xmath76 , where @xmath77 .",
    "suppose that the following rates are achievable by fdf - p : @xmath78 , @xmath79 , @xmath80 for some small @xmath81 .",
    "from lemma  [ lemma : private ] , we have @xmath82",
    "so , @xmath83 .",
    "choosing @xmath84 , we have @xmath85 .",
    "but from lemma  [ lemma : private ] , we must have @xmath86 ( contradiction ) . hence ,",
    "these rates are not achievable using the fdf - p , but they are achievable using the new scheme proposed in this paper .",
    "the shortcoming of using fdf - p to send common messages is that the scheme ignores the fact that another user ( besides the sender ) knows the sub - messages , for example , user 2 knows @xmath60 .",
    "we will propose a nested fdf scheme that rectifies this problem .",
    "we have previously shown that the complete - decode - forward coding scheme , where the relay decodes all the messages , is strictly suboptimal for the ffmwrc with private messages  @xcite . since the ffmwrc with common messages includes that with private messages as a special case , this coding scheme is also strictly suboptimal .",
    "so , in this paper , we propose a new fdf scheme , where the relay decodes some functions of the messages .",
    "the challenge is to design optimal functions that the relay decodes .",
    "each user @xmath87 needs to decode all @xmath88 . to simplify notation",
    ", we define the sum rate associated with node @xmath87 as @xmath89 we will propose a new _ nested _ fdf coding scheme ( see sec",
    ".  [ section : nested - fdf ] ) that achieves the capacity region of the ffwmrc with common messages , given in the following theorem :    [ theorem : main ] consider an ffmwrc with common messages .",
    "the rate tuple @xmath38 is achievable if there exists some @xmath44 such that the following is true for all @xmath90 : @xmath91 conversely , if @xmath38 is achievable , then there exists some @xmath44 such that holds with a non - strict inequality for all @xmath87 .",
    "major differences between the new scheme , i.e. , the nested fdf , and the existing fdf - p are as follows :    1 .   in fdf - p , the function that the relay decodes is pre - defined ; in the nested fdf scheme , a function is chosen and then modified using an algorithm that we propose . as a result , the functions vary with the rates of the sub - messages .",
    "so , we might need different functions to achieve different rate tuples in the capacity region .",
    "2 .   in fdf - p ,",
    "the users transmit their messages , and the relay decodes functions of the messages ; in the nested fdf scheme , the users transmit _ functions _ of their messages , and the relay decodes functions of the user s transmission ( which can be functions of functions of the messages ) .",
    "fdf - p it not always optimal when there are common messages ; the nested fdf is .",
    "the capacity outer bound , i.e. , the converse in theorem  [ theorem : main ] follows directly from the following cut - set bound  ( * ? ? ?",
    "15.10.1 ) :    [ lemma : cut - set ] consider a multiterminal network with nodes @xmath92 where each node @xmath4 sends an independent message @xmath93 at the rate @xmath94 to each other node @xmath20 , for @xmath95 .",
    "if the rates @xmath96 are achievable , then there exists some joint probability distribution @xmath97 such that @xmath98 for all @xmath99 where @xmath100 .    applying lemma  [ lemma : cut - set ] to the ffmwrc with @xmath101 and @xmath102 for some @xmath90 , we have    @xmath103    where is derived as @xmath104 forms a markov chain , conditioning can not increase entropy , and the channel noise @xmath9 is independent of the channel inputs @xmath105 .    similarly , setting @xmath106 and @xmath107 , we have    @xmath108    where is derived because @xmath104 forms a markov chain , and as conditioning can not increase entropy .",
    "if the rate tuples @xmath38 is achievable , then there exists some @xmath109 such that and are true for all @xmath90 .",
    "note that the rhs of depends only on the marginal pmf @xmath44 .",
    "this proves the converse in theorem  [ theorem : main ] .",
    "in this section , we will prove the achievability of theorem  [ theorem : main ] . to simplify notation ,",
    "we assume ( without loss of generality ) that @xmath110 for all @xmath111 .",
    "this means , user 1 needs to decode at the highest total rates . for any rate tuple @xmath38 , we can always re - index the nodes to get . with this simplification ,",
    "we need to show that if @xmath112 and if there exists some @xmath44 such that @xmath113 then the rate tuple @xmath38 is achievable .",
    "note that is a constraint involving the uplink variables , and the downlink variables .",
    "c|c|c|c|c|c|c|c|c|c|c|c|c|c|c| & & & & & & & & & & & & & & + & & & & & & & & & & & & & & + row 1 & @xmath114 & @xmath115 & @xmath116 & @xmath117 & @xmath118 & @xmath119 & @xmath116 & @xmath120 & @xmath121 & @xmath122 & @xmath116 & @xmath123 & @xmath116 & @xmath124 + row 2 & @xmath125 & & & & @xmath125 & @xmath125 & @xmath116 & @xmath125 & & & & & & + row 3 & & @xmath125 & & & @xmath125 & & & & @xmath125 & @xmath125 & @xmath116 & @xmath125 & & + @xmath126 & & + row @xmath0 & & & & @xmath125 & & & & @xmath125 & & & & @xmath125 & & @xmath125 +    we can think of the first constraint as the relay needing to decode at rate @xmath127 . in general , the sum rate of all messages ( i.e. , @xmath128 ) is strictly higher than @xmath127 .",
    "this is why the complete - decode - forward coding scheme is suboptimal  @xcite , as it requires that the relay to decode all the messages , and this imposes a constraint @xmath129 , which is stricter than .",
    "our aim is to design codes such that the relay needs to decode only functions of the messages , i.e. , at a lower rate of @xmath127 .      on the uplink",
    ", we will use linear block codes of the form @xmath130 where the codeword @xmath131 , the message @xmath132 , and the dither @xmath133 are row vectors , and @xmath134 is the generator matrix .",
    "all elements are from the finite field of order @xmath11 . in addition , each element in @xmath134 and in @xmath133 is independently and uniformly chosen over the finite field . here",
    ", @xmath135 denotes matrix multiplication , and @xmath12 symbol - wise addition in the finite field .",
    "we now state a result of random linear block codes on finite - field channels  ( * ? ? ?",
    "3 ) :    [ lemma : finite - field - point - to - point ] consider the uplink .",
    "each user encodes its message @xmath136 ( a length-@xmath137 finite - field vector ) to @xmath138 ( a length-@xmath13 vector ) using the linear code of the form .",
    "the users use different dithers but a common generator matrix .",
    "the receiver can decode @xmath139 from its @xmath13 received channel outputs @xmath140 with an arbitrarily small error probability if @xmath13 is sufficiently large and if @xmath141      in order to utilize the linear block codes , we consider each message @xmath142 to be a finite - field vector of length @xmath143 . we have used the bold - faced symbol to emphasize that the messages are vectors .",
    "the length of the vector is thus related to the rate by @xmath144 .",
    "similar to , we define @xmath145 , i.e. , the total number of finite - field symbols to be decoded by user @xmath87 .",
    "our aim is to construct optimal functions that the relay should decode on the uplink",
    ". we will use linear codes across multiple blocks , where in each block , the relay decodes the addition of the ( finite - field vector ) messages transmitted in that block .",
    "equivalently , we will determine what messages the users transmit in each block .",
    "the transmissions are described using table  [ table : uplink ] . in each block ,",
    "i.e. , vertically - aligned cells from rows 1 to @xmath0 , the users transmit messages assigned to the cells .",
    "each cell contains multiple columns ; each column in the cell corresponds to a message symbol ( columns are not drawn in the table ) .",
    "we refer to the number of columns in each cell as the block size , which is set to be the message length in the cell in row 1 .",
    "we construct table  [ table : uplink ] as follows : in row 1 , we place all the messages that user 1 requires , i.e. , @xmath146 .",
    "we identify each block by the subscript , @xmath36 , of the corresponding message @xmath142 in row 1 ; the block size is thus @xmath143 .",
    "for all the @xmath147 messages in row 1 , user @xmath111 knows @xmath148 of them a priori , namely , @xmath149 ( messages with subscript `` @xmath87 '' ) . for these messages",
    ", we put an asterisk in each corresponding cell ( i.e. , in the same block ) in row @xmath87 . in these asterisked cells",
    ", we will assign messages that ( i ) user @xmath87 requires and ( ii ) user 1 knows . more specifically",
    ", we will assign @xmath150 to these cells ( replacing the each subscript `` @xmath87 '' in row 1 by `` 1 '' ) .",
    "the idea is to let both users 1 and @xmath87 obtain their respective required messages from the sum .",
    "these @xmath148 blocks in rows 1 and @xmath87 are extracted out as follows : +     @xmath151 & @xmath116 & @xmath152 & @xmath153 & @xmath116 & @xmath154 +   +     + we spread the messages @xmath150 across the asterisked cells in row @xmath87 ( because the messages on different rows have different lengths , and they may not align at the block level ) .",
    "we now show that the @xmath147 messages on row @xmath87 can always fit into the corresponding @xmath148 asterisked cells .",
    "from , we have @xmath155 which gives @xmath156 if the above equality is strict , the excess columns in the asterisked cell(s ) will be left empty .",
    "we repeat this for all @xmath111 . doing this , in every block @xmath36 , all rows @xmath157 have asterisked cells .",
    "we now prove a few properties of the aforementioned function construction .",
    "[ prop : user1 ] user 1 knows the messages in rows 2 to @xmath0 a priori .    in each row @xmath87 , we only assign either @xmath158 or @xmath159 in the asterisked cells .",
    "[ prop : user - a ] once user @xmath87 , for some @xmath111 , knows the messages in row @xmath87 , it also knows the messages in all other asterisked cells in all other rows , i.e. , rows @xmath160 for all @xmath161 .",
    "suppose that user @xmath87 has decoded the messages in row @xmath87 , i.e. , @xmath162 . by definition",
    ", it knows @xmath163 a priori .",
    "since , any message in other rows @xmath164 must be either @xmath165 or @xmath166 , user @xmath87 knows those messages .",
    "[ prop : all ] for any @xmath167 , after decoding all messages in rows @xmath87 and 1 , user @xmath87 will have decoded all the messages it requires .",
    "recall that user @xmath87 needs to decode all messages @xmath168 .",
    "clearly , row 1 contains all messages that user 1 needs to decode .",
    "now , we prove the proposition for each @xmath111 . for @xmath169 , @xmath158 appears in row @xmath87 , and @xmath170 appear in row 1 . for @xmath171 , all messages @xmath172 appear in row 1 , and @xmath173 in row @xmath87 .",
    "so , @xmath174 .",
    "the following corollary is a straighforward consequence of proposition  [ prop : user - a ] :    [ corollary : symbols ] for each user @xmath111 , there are exactly @xmath175 message _ symbols _ in rows 2 to @xmath0 in table  [ table : uplink ] that are unknown to user @xmath87 .    we know that the messages @xmath162 are the messages in row @xmath87 , and these messages are unknown to user @xmath87 .",
    "the messages comprise @xmath175 message symbols . from proposition  [ prop : user - a ] , we know that there are no other messages unknown to user @xmath87 in rows 2 to @xmath0",
    ".      with table  [ table : uplink ] constructed , we are ready to construct the uplink codewords . for each block ,",
    "two users transmit  user 1 and another user @xmath111 .    for the first @xmath148 blocks ,",
    "there is only one asterisk per block . for block @xmath87 ,",
    "for @xmath111 , user @xmath87 transmits @xmath176 that corresponds to the cell in row 1 , and simultaneously , user 1 transmits the codeword that corresponds to the asterisked cell . more specifically , user @xmath87 and user 1 transmits the following respectively : @xmath177 where @xmath178 , @xmath179 , @xmath133 , and @xmath180 each are finite - field row vectors of length @xmath181 , @xmath176 and @xmath182 each are row vectors of length @xmath183 , and @xmath134 is an @xmath183-by-@xmath181 matrix .",
    "@xmath182 is the vector defined by the content in the asterisked cell in block @xmath87 ( i.e. , below cell @xmath176 ) in table  [ table : uplink ] . from proposition  [ prop : user1 ] , we know that user 1 knows the content in the asterisked cells , and is able to transmit the codeword .    for the remaining blocks @xmath184 , again two users transmit ( user 1 and some user @xmath111 ) simultaneously in a similar manner .",
    "each user encodes a length-@xmath143 message to a length-@xmath185 codeword as in  by replacing @xmath176 with @xmath186 , and @xmath182 with @xmath187 . as users @xmath4 and @xmath20 both know the message @xmath186 in row 1 , either of them transmit the codeword .",
    "user 1 transmits a function of its messages . in block",
    "@xmath42 , there are _ two _ asterisked cells ",
    "one in row @xmath4 and one in row @xmath20 .",
    "user 1 choose @xmath187 as follows : if the symbols from the two asterisked cells are the same , the symbol is selected , otherwise , the finite - field sum of the symbols is selected .    from lemma  [ lemma : finite - field - point - to - point ] ,",
    "if @xmath188 and if the codelength @xmath185 is sufficiently large , then the relay can reliably decode the function @xmath189 .    the nested fdf scheme is _ nested _ in the sense that user 1 may transmit functions of messages , and hence the relay decodes _ functions of functions _ of the messages .",
    "define the concatenated functions that the relay decodes as @xmath190 ( which is a finite - field vector of length @xmath191 ) .",
    "the relay broadcasts @xmath192 on the downlink .",
    "the idea of the nested fdf scheme is that the functions @xmath192 that the relay decodes and broadcasts must enable each user to obtain all its desired messages from the functions and the messages it knows a priori . to this end , we have selected the messages in the asterisked cells in table  [ table : uplink ] such that the following are true :    1 .",
    "knowing all the messages in the asterisked cells a priori ( proposition  [ prop : user1 ] ) , user 1 can decode all messages in row 1 from @xmath192 , and hence obtain all its intended messages ( proposition  [ prop : all ] ) .",
    "2 .   from @xmath192 , each user @xmath111 will first attempt to decode the messages in the asterisked cells in row @xmath87 .",
    "once user @xmath87 decodes the messages in the asterisked cells in row @xmath87 , it knows the messages in all other asterisked cells ( proposition  [ prop : user - a ] ) . from @xmath192 , it can then decode the messages in row 1 . with this ,",
    "user @xmath87 will have decoded all its intended messages ( proposition  [ prop : all ] ) .",
    "hence , we have the following :    [ proposition : decode - asterisks ] assuming that all users have decoded @xmath192 , if each user @xmath111 can decode the messages in the asterisked cells in row @xmath87 , then all users 1 to @xmath0 can decode their intended messages .",
    "the decoding procedure now hinges on step  2a .",
    "let us focus on one user @xmath87 .",
    "user @xmath87 attempts to decode the messages in the asterisked cells in row @xmath87 , denoted by @xmath193 .",
    "it does so from the relevant parts of @xmath192 , namely , @xmath194 , where @xmath195 are all the blocks with asterisked cells in row @xmath87 .",
    "recall that each symbol in @xmath196 is the sum of distinct symbols in a column from rows 2 to @xmath0 .",
    "the blocks in @xmath197 are shown in the table below : +    c|c|c|c|c|c|c c c row 1 & @xmath176 & @xmath151 & @xmath198 & @xmath116 & @xmath154 & @xmath199 \\boldsymbol{w}_\\theta$ ] & + row 2 & & @xmath125 & & @xmath116 & & + @xmath126 & & + row @xmath87 & & @xmath199 \\boldsymbol{w}_\\lambda$ ] & + @xmath126 & & & @xmath200 + row @xmath0 & & & & @xmath116 & @xmath125 & +     + as user @xmath87 knows @xmath201 , it subtracts these from @xmath202 to obtain @xmath200 .",
    "note that @xmath203 comprises @xmath204 symbols .",
    "denote the first @xmath205 symbols of @xmath200 by @xmath206 , which are functions of only @xmath203 ( proposition  [ prop : user - a ] ) .",
    "so , step  2a is successful if and only if @xmath206 form @xmath205 linearly independent equations .",
    "we now propose an algorithm to rearrange the messages in the asterisked cells to achieve this .",
    "our aim is to get @xmath207 linearly independent equations in @xmath206 ( _ simultaneously _ for all users 2 to @xmath0 ) .",
    "hence , we can ignore row 1 ; we only need to consider asterisked cells in table  [ table : uplink ] .",
    "each block has at most two asterisked cells . for each column from row 2 to row @xmath0",
    ", we denote the _ simplified column _ by @xmath208 , where @xmath209 and @xmath210 are symbols from the asterisked cells .",
    "if there is only one asterisk cell for that column , we have @xmath211 . using this notation",
    ", we now propose the shuffling algorithm .",
    "although swapping the elements for one user may affect the simplified columns for other users , in each swap , we always increase the number of simplified columns with two identical elements , i.e. , @xmath212 .",
    "as there are only a finite number of columns , the algorithm will always terminate after at most @xmath191 cycles of the * foreach * loop .",
    "we will now show that when the algorithm ends , user @xmath111 can decode the messages on row @xmath87 , denoted by @xmath203 ( consisting of @xmath205 symbols ) .",
    "we treat @xmath212 as @xmath211 because only one copy of the same symbol is transmitted to the relay .",
    "when we swap the elements for each user in the algorithm , we always swap the top elements , i.e. , symbols in the same row  the bottom elements may be from different rows .    consider the decoding of user @xmath87 using the @xmath205 non - empty simplified columns .",
    "the user again rearranges each simplified column such that the top element takes the symbol in row @xmath87 .",
    "doing that , the top elements of these simplified columns are distinct  they corresponds to the @xmath205 symbols in @xmath203 .",
    "now , if a symbol @xmath209 appear at the top of a simplified column and the bottom of another , it has to take the form @xmath213 , because all @xmath209 can only appear once at the top , and the case @xmath208 and @xmath214 for any @xmath215 and @xmath216 has been eliminated .",
    "consequently , user @xmath87 can decode @xmath203 .",
    "this is true for all @xmath111 . combining this with proposition  [ proposition : decode - asterisks ]",
    ", we have the following :    [ proposition : decoding ] if a user can decode @xmath192 , then it can decode all its intended messages .",
    "now , we derive the rates at which the users can transmit such that all users can reliably decode @xmath192 .",
    "we first determine the condition for which the relay can reliably decode @xmath192 .",
    "on the uplink , the users transmit @xmath191 aligned symbols in @xmath13 channel uses across all blocks in table  [ table : uplink ] .",
    "we allocate the number of channel uses for each block proportional to the message length , i.e. , @xmath217 for all @xmath218 .",
    "if @xmath219 and if @xmath13 is sufficiently large , then is satisfied for all @xmath36 , and thus the relay can reliably decode @xmath192 .",
    "now , suppose that the relay has successfully decoded @xmath192 .",
    "note that @xmath220 is a finite - field vector of length @xmath191 .",
    "hence , there are at most @xmath221 distinct vectors @xmath192 . on the downlink",
    ", the relay first chooses some @xmath44 , generates @xmath221 sequences @xmath222 , each of length @xmath13 , and indexes them as @xmath223 . upon decoding @xmath192 on the uplink",
    ", the relay transmits @xmath224 on the downlink .",
    "each user @xmath90 attempts to decode @xmath192 on the downlink with the help of its prior messages , @xmath225 . with the correct prior messages , all ambiguities in @xmath192 can only be caused by different @xmath226 . for user @xmath87 ,",
    "let @xmath227 denotes the set of distinct @xmath132 that can be formed by all possible @xmath226 .",
    "we have @xmath228 the set @xmath227 contains all possible @xmath132 user @xmath87 may decode to .    knowing the messages @xmath225 , each user @xmath90 decodes @xmath192 from its received downlink channel outputs @xmath229 if it can find a unique vector @xmath230 such that @xmath231 where @xmath232 is the set of jointly typical sequences @xmath233  @xcite .",
    "otherwise , user @xmath87 declares a decoding error .",
    "so , user @xmath87 makes an error in decoding if the event @xmath234 occurs , where    * @xmath235 : the correct @xmath236 does not satisfy , * @xmath237 : some wrong @xmath238 satisfies .    by definition , @xmath236 . from the joint asymptotic equipartition property ( jaep ) , we know that  ( * ? ? ?",
    "7.6.1 ) @xmath239    we now evaluate the probability of @xmath237 :    @xmath240/n - i(x_0;y_a ) + 3\\epsilon ) } , \\end{aligned}\\ ] ]    where follows from and the jaep  ( * ? ? ?",
    "7.6.1 ) .",
    "this means by choosing a sufficiently small @xmath241 and a sufficiently large @xmath13 , if @xmath242 then @xmath243 can be made arbitrarily small , meaning that user @xmath87 can realibly decode @xmath192 .",
    "consequently , if and are satisfied for all @xmath90 , then all users can reliably decode @xmath192 .",
    "it follows from proposition  [ proposition : decode - asterisks ] that each user can reliably decode its intended messages . with this , we have proven the achievability of theorem  [ theorem : main ] .    in our proposed coding scheme",
    ", the relay transmits after decoding @xmath192 .",
    "this means a total of @xmath244 channel uses ( @xmath13 for the uplink , followed by @xmath13 for the downlink ) .",
    "this issue can be easily fixed by repeating this scheme for multiple messages over multiple _",
    "blocks_. using the uplink and the downlink simultaneously , the relay transmits @xmath192 that it has previously decoded in the previous block , while , at the same time , the users transmits new messages .",
    "this is a commonly - used technique for relay channels ( see , e.g. , @xcite@xcite ) .",
    "we have previously established  ( * ? ? ?",
    "v.a ) that if @xmath245 for all @xmath30 , then the relay can reliably decode a function ( denoted by @xmath192 ) of the users messages . from",
    "( 59),(60),(63f),(64e ) ) , we know that if @xmath246 for all @xmath30 and for some @xmath44 , then each user @xmath4 can reliably decode @xmath192 , and subsequently obtain the other users messages .",
    "this proves the achievability of rates satisfying .",
    "the converse follows from section  [ section : outer ] by setting all @xmath41 .",
    "m.  p. wilson , k.  narayanan , h.  d. pfister , and a.  sprintson , `` joint physical layer coding and network coding for bidirectional relaying , '' _ ieee trans .",
    "inf . theory _ ,",
    "56 , no .  11 , pp . 56415654 , nov . 2010 .",
    "r.  timo , g.  lechner , l.  ong , and s.  j. johnson , `` multi - way relay networks : orthogonal uplink , source - channel separation and code design , '' _ to appear in ieee trans .",
    "_ , feb . , 2013 .",
    "[ online ] .",
    "available : http://arxiv.org/pdf/1210.0271v1.pdf"
  ],
  "abstract_text": [
    "<S> the capacity region of the finite - field multi - way relay channel ( ffmwrc ) with independent private messages was established by ong , johnson , and kellett ( it-2011 ) . in this paper , we extend the capacity results to include pairwise common messages ( each known to two nodes ) in addition to private messages ( known to only one node ) . we first show that the functional - decode - forward coding scheme that achieves the capacity region of the ffmwrc with independent messages is strictly suboptimal when there are common messages . </S>",
    "<S> we then construct a new coding scheme that achieves the capacity region of the ffmwrc with pairwise common messages . </S>"
  ]
}