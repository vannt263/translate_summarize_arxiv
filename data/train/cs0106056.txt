{
  "article_text": [
    "a test - and - set protocol concurrently executed by each process out of a subset of @xmath0 processes selects a _ unique _ process from among them . in a distributed or concurrent system ,",
    "the test - and - set operation is useful and sometimes mandatory in a variety of situations including mutual exclusion , resource allocation , leader election and choice coordination .",
    "it is well - known that in the wait - free setting , @xcite , a deterministic construction from atomic read / write variables is impossible @xcite .",
    "although widely assumed to exist , and referred to , an explicit randomized construction for wait - free test - and - set has not appeared in print yet , apart from a deterministic construction _ assuming _ two - process atomic test - and - set @xcite .",
    "the latter , in the form of a randomized two - process wait - free test - and - set has been circulated in draft form @xcite for a decade .",
    "here we finally present the construction . since such constructions are notoriously prone to hard - to - detect errors , we prove it correct by an exhaustive finite - state proof , thus also presenting a nontrivial application of this proof technique .",
    "* interprocess communication : * the model is interprocess communication through shared memory as commonly used in the theory of distributed algorithms @xcite .",
    "we use atomic single writer single reader registers as primitives .",
    "such primitives can be implemented wait - free from single - reader single - writer `` safe '' bits ( mathematical versions of hardware `` flip - flops '' ) @xcite ) .",
    "a concurrent object is _ constructible _ if it can be implemented deterministically with boundedly many safe bits .",
    "a deterministic protocol executed by @xmath0 processes is _ wait - free _ if there is a finite function @xmath1 such that every non - faulty process terminates its protocol executing a number of at most @xmath2 of accesses to the shared memory primitives , regardless of the other processes execution speeds .",
    "if the execution speed of a process drops to zero then this is indistinguishable from the process having a crash failure . as a consequence ,",
    "a wait - free solution can tolerate up to @xmath3 processes having crash failures ( a property called `` @xmath4-resiliency '' ) , since the surviving non - faulty process correctly executes and terminates its protocol .",
    "below , we also write `` shared variable '' for `` register . ''",
    "* randomization : * the algorithms executed by each process are randomized by having the process flip coins ( access a random number generator ) . in our randomized algorithms the answers are always correct  a unique process gets selected but with small probability the protocol takes a long time to finish .",
    "we use the customary assumption that the coin flip and subsequent write to shared memory are separate atomic actions . to express the computational complexity of our algorithm we use the expected complexity , over all system executions and with respect to the randomization by the processes and the worst - case scheduling strategy of an adaptive adversary .",
    "a _ randomized _ protocol is wait - free if @xmath2 upper bounds the _ expectation _ of the number of elementary steps , where the expectation is taken over all randomized system executions against the worst - case adversary in the class of adversaries considered ( in our results the adaptive adversaries ) .",
    "* complexity measures : * the computational complexity of distributed deterministic algorithms using shared memory is commonly expressed in number and type of intercommunication primitives required and the maximum number of sequential read / writes by any single process in a system execution .",
    "local computation is usually ignored , including coin - flipping in a randomized algorithm .",
    "* related work : * what concurrent wait - free object is the most powerful constructible one ? it has been shown that wait - free atomic multi - user variables , and atomic snapshot objects , are constructible , for example @xcite .",
    "in contrast , the agreement problem in the deterministic model of computation ( shared memory or message passing ) is unsolvable in the presence of faults @xcite .",
    "correspondingly , wait - free consensus  viewed as an object on which each of @xmath0 processes can execute just one operation  is not constructible @xcite , although randomized implementations are possible @xcite .",
    "wait - free concurrent test - and - set can deterministically implement two - process wait - free consensus , and therefore is not deterministically constructible @xcite .",
    "this raises the question of whether randomized algorithms for test - and - set exist .",
    "in @xcite it is shown that repeated use of ` consensus ' on _ unbounded _ hardware can implement ` test - and - set ' . in @xcite",
    "it is argued that a bounded solution can be obtained by combining several intermediate constructions , like so - called `` sticky bits '' , but no explicit construction is presented to back up this claim . to quote @xcite : `` randomized consensus algorithms of chor , israeli , and li @xcite , abrahamson @xcite , aspnes and herlihy @xcite , and attiya , dolev , and shavit @xcite , together with our construction",
    "imply that polynomial number of safe bits is sufficient to convert a safe implementation into a ( randomized ) wait - free one . ''",
    "any such a `` layered '' construction will require orders of magnitude more primitive building blocks like one - writer one - reader bits than the direct construction we present below .",
    "wait - free @xmath0-process test - and - set can be implemented deterministically from wait - free two - process test - and - set , @xcite , showing that the impossibility of a deterministic algorithm for @xmath0-process test - and - set is solely due to the two - process case .",
    "* present results : * despite the frequent use of randomized wait - free test - and - set in the literature , no explicit construction for the basic ingredient , randomized wait - free two - process test - and - set , has appeared in print . our construction , @xcite , has been subsumed and referred to long since , for example in @xcite , but other interests prevented us publishing a final version earlier .",
    "the construction is optimal or close to optimal .",
    "the presented algorithm directly implements wait - free test - and - set between two processes from single - writer single - reader atomic shared registers .",
    "randomization means that the algorithm contains a branch conditioned on the outcome of a fair coin flip ( as in @xcite ) .",
    "we use a finite - state based proof technique for verifying correctness and worst - case expected execution length in the spirit of @xcite .",
    "our construction is very simple : it uses two 4-valued 1-writer 1-reader atomic variables .",
    "the worst - case expected number of elementary steps ( called `` accesses '' in the remainder of the paper ) in a test - and - set operation is @xmath5 , whereas a reset always takes 1 access .",
    "processes are sequentially executed finite programs with bounded local variables communicating through single - writer , multi - reader bounded wait - free atomic registers ( shared variables ) .",
    "the latter are a common model for interprocess communication through shared memory as discussed briefly in section  [ sect.intro ] .",
    "for details see @xcite and for use and motivation in distributed protocols see @xcite .",
    "the basic building blocks of our construction are 4-valued 1-writer 1-reader atomic registers .",
    "every read / write register is _ owned _ by one process . only the owner of a register can write it , while only one other process can read it . in one _ access _ a process can either :    * read the value of a register ; * write a value to one of its own registers ; * moreover , following the read / write of a register the process possibly flips a local coin ( invokes a random number generator that returns a random bit ) , preceded or followed by some local computation .",
    "we require the system to be _ atomic _ : every access of a process can be thought to take place in an indivisible instance of time and in every indivisible time instance at most one access by one process is executed .",
    "the atomicity requirement induces in each actual system execution total orders on the set of all of the accesses by the different processes , on the set of accesses of every individual process , and on the set of read / write operations executed on each individual register .",
    "the _ state _ of the system gives for each process : the contents of the program counter , the contents of the local variables , and the contents of the owned shared registers .",
    "since processes execute sequential programs , in each state every process has at most a single access to be executed next .",
    "such accesses are _ enabled _ in that state .",
    "there is an _ adversarial _ scheduling demon that in each state decides which enabled access is executed next , and thus determines the sequence of accesses of the system execution .",
    "there are two main types of adversaries : the _ oblivious _ adversary that uses a fixed schedule independent of the system execution , and the much stronger _ adaptive _ adversary that dynamically adapts the schedule based on the past initial segment of the system execution .",
    "our results hold against the adaptive adversary  the strongest adversary possible .      the computational complexity of a randomized distributed algorithm in an adversarial setting and the corresponding notion of wait - freeness require careful definitions . for the rigorous novel formulation of adversaries as restricted measures over the set of system executions we refer to the appendix of @xcite . for the simple application in this paper we can assume that the notions of global ( system ) execution , wait - freeness , adaptive adversary , and expected complexity are familiar .",
    "a randomized distributed algorithm is _ wait - free _ if the expected number of read / writes to shared memory by every participating process is bounded by a finite function @xmath2 , where @xmath0 is the number of processes .",
    "the expectation is taken over the probability measure over all randomized global ( system ) executions against the worst - case adaptive adversary .",
    "we first specify the semantics of the target object :    [ def.targetsemantics ] an _ atomic test - and - set object _ @xmath6 is a _",
    "global variable _ , associated with @xmath0 processes @xmath7 , exhibiting the following functionality :    * the value of @xmath6 is 0 or 1 ; * every process @xmath8 has a _ local binary variable _ @xmath9 which it alone can read or write ; * at any time exactly one of @xmath10 has value 0 , all others have value 1 ( we assume the global time model ) ; * a process @xmath8 with @xmath11 can atomically execute a _ test - and - set _",
    "operation @xmath12 : + read @xmath13 ; write @xmath14 ; return @xmath9 . * a process  @xmath8 with @xmath15 can atomically execute a _ reset _",
    "operation @xmath16 : + @xmath17 ; write @xmath18 .",
    "this specification naturally leads to the definition of the _ state _ of the test - and - set object as an element of @xmath19 corresponding to the unique local variable out of @xmath20 that has value 0 . here",
    "@xmath21 is the state that none of the @xmath22 s is 0 .",
    "formally , the specification is given later as a finite automaton in definition  [ def.fa1 ] .",
    "since `` atomicity '' means that the operation is executed in a single indivisible time instant , and , moreover , in every such time instant at most one operation execution takes place , the effect of a test - and - set operation by process @xmath8 is that @xmath23 iff all @xmath24 for all @xmath25 , and @xmath26 otherwise .",
    "the effect of a reset operation by @xmath8 is only defined for initially @xmath27 and @xmath24 for all @xmath25 , and results in @xmath28 . to synthesise the target object from more elementary objects",
    ", we have to use a sequence of atomic accesses to these elementary objects . by adversary scheduling these sequences",
    "may be interleaved arbitrarily .",
    "yet we would like to have the effect of an atomic execution of the test - and - set operations and the reset operations by each process .",
    "to achieve such a `` virtual '' atomic execution we proceed as follows :    an _ implementation _ of a _ test - and - set _",
    "operation @xmath12 or a _ reset _ operation @xmath16 by a process @xmath29 is an algorithm executed by @xmath29 that results in an ordered sequence of accesses of that process to elements of a set @xmath30 of atomic shared variables , interspersed with local computation and/or local coin flips .",
    "the sequence of accesses is determined by the , possibly randomized , algorithm , and the values returned by the `` read '' accesses to shared variables .",
    "we denote an access by @xmath31 , meaning that process @xmath29 executes access @xmath32 ( read or write a `` 0 '' or `` 1 '' ) on shared variable @xmath33 .",
    "the implementation must satisfy the specification of the target test - and - set semantics of definition [ def.targetsemantics ] restricted to process @xmath29 .",
    "formally , the specification is given later as a finite automaton in definition  [ def.fa2 ] .",
    "a _ local execution _ of a process @xmath29 consists of the ( possibly infinite ) sequence of test - and - set operations and reset operations it executes , according to the implementation , each such operation @xmath34 provided with a _",
    "time @xmath35 and a _ finish _ time @xmath36we assume a global time model .",
    "note that @xmath35 coincides with the time of execution of the first access in the ordered sequence consituting @xmath37 , and @xmath36 coincides the time of execution of the last access in the ordered sequence constituting @xmath37 . by the atomicity of the individual accesses in the global time model",
    ", all accesses are executed at different time instants . in certain cases ( which we show to have zero probability )",
    "it is possible that @xmath36 is not finite ( because the algorithm executes infinitely many loops with probability @xmath38 each )",
    ".    let the local execution of process @xmath8 consist of the ordered sequence of operations @xmath39 ( @xmath40 ) . a _ global execution _ consists of the @xmath41 where @xmath42 and @xmath43 is a partial order on the elements of @xmath44 defined by @xmath45 iff @xmath46 ( the last access of @xmath37 precedes the first of @xmath47 ) .",
    "we require that the number of @xmath47 such that @xmath48 is finite for each @xmath37 .",
    "a test - and - set operation or reset operation by a particular process may consist of more than one access , and therefore the local executions by the different processes may happen concurrently and asynchronously .",
    "this has the effect that a _ global execution _ can correspond to many different interleavings .",
    "consider a global execution .",
    "interleaving _ of the accesses by the different processes associated with the global execution is a ( possibly infinite ) totally ordered sequence @xmath49 , where @xmath50 is the @xmath51th access , respecting    * the start times and finish times determined by the local executions ; and * the order of the accesses in the local executions .",
    "the implementation should guarantee that the functionality of the implementation is `` equivalent '' , in an appropriate sense , to the functionality of the target test - and - set object , and in particular satisfies the `` linearizability requirement '' @xcite ( also called `` atomicity '' in @xcite ) .",
    "the system _ implements _ the target test - and - set object if the system is initially in state @xmath21 , and we can extend @xmath43 on @xmath44 to a total order @xmath52 on @xmath44 with an initial element , satisfying :    * from state @xmath21 , a successful test - and - set operation @xmath12 executed by process @xmath8 ( setting @xmath23 ) moves the system to state @xmath51 at some time instant in the interval @xmath53 $ ] ; * from state @xmath51 , a reset operation @xmath16 executed by process @xmath8 moves the system to state @xmath21 at some time instant in the interval @xmath54 $ ] ; * from state @xmath51 , every operation execution different from a reset by process @xmath8 leaves the system invariant in state @xmath51 ; and * no other state transitions than the above are allowed .    the implementation must satisfy the specification of the target test - and - set semantics of definition [ def.targetsemantics ] .",
    "formally , the specification is given later as a finite automaton in definitions  [ def.fa3 ] and [ def.fa4 ] .",
    "to prove that a protocol executed by all processes is an implementation of the target test - and - set object it suffices to show that every possible interleaving that can be produced by the processes executing the protocol in every global execution , starting from the @xmath21 state , satisfies the above requirements .",
    "we give a test - and - set implementation between two processes , process  @xmath55 and process  @xmath56 .",
    "the construction uses two 4-valued shared read / write variables @xmath57 and @xmath58 .",
    "the four values are ` me ' , ` he ' , ` choose ' , ` rst'chosen as a mnemonic aid explained below .",
    "process  @xmath8 solely writes variable @xmath59 , its own variable , and solely reads @xmath60 . for this reason the reads and writes in the protocol do nt need to be qualified by the shared variables they access .",
    "the protocol , for process  @xmath8 ( @xmath61 ) , is presented as both a finite state chart , figure  [ prot2 ] and as the program below .",
    "the state chart representation will simplify the analysis later .",
    "the transitions in the state chart are labeled with reads @xmath62 and writes @xmath63 of the shared variables , where @xmath64 denotes the value read or written .",
    "the 11 states of the state chart are split into 4 groups enclosed by dotted lines .",
    "each group is an equivalence class consisting of the set of states in which process @xmath8 s own shared variable @xmath65 has the same value .",
    "that is , the states in a group are equivalent in the sense that process  @xmath66 can not distinguish between them by reading @xmath59 .",
    "accordingly , the inter - group transitions are writes to @xmath59 , whereas the intra - group transitions are reads of @xmath60 .",
    "each group is named after the corresponding value of the own shared variable @xmath65 .",
    "the state chart is deterministic , but for a coin flip which is modeled by the two inter - group transitions in the `` choose '' group , representing the two outcomes of a fair coin flip .",
    "doubly circled states are `` idle '' states ( no operation execution is in progress ) , and singly circled states are intermediate states in an operation execution that is in progress",
    ".    a program representation of the protocol , for process  @xmath8 , is given below .",
    "an occurrence of @xmath59 not preceded by ` write ' ( similarly , @xmath60 not preceded by ` read ' ) as usual refers to the last value written to it ( resp .",
    "read from it ) .",
    "the conditional ` rnd(true , false ) ' represents the boolean outcome ` true ' or ` false ' of a fair coin flip .",
    "the system is initialized with value ` rst ' in shared variables @xmath67 . in our protocol ,",
    "all assignments to local variables consist of contents read from shared variables .",
    "to simplify , we abbreviate statements like `` @xmath68 ; while @xmath69 do  @xmath68 . ''",
    "to `` while read @xmath70 do  '' . here",
    ", @xmath71 is the local variable containing the value last written to shared variable @xmath65 and @xmath72 is the local variable storing the last read value of shared variable @xmath60 , for process @xmath8 . this way",
    ", our ( writing of the ) protocol can dispense with local variables altogether .",
    "test_and_set : +   + if @xmath73 he and read @xmath74 rst + then return 1 + write @xmath75 me + while read @xmath76 do + write @xmath75 choose + if read @xmath77 he or + ( @xmath77 choose and rnd(true , false ) ) + then write @xmath75 me + else write @xmath75 he + if @xmath73 me + then return 0 + else return 1 +   + reset : +   + write @xmath75 rst    it can be verified in the usual way that the state chart represents the operation of the program . the intuition is easily explained using the state chart . the default situation is where both processes are idle , which corresponds to being in the ` rst ' state .",
    "if process  @xmath8 starts a test - and - set then it writes @xmath78 me ( indicating its desire to take the 0 ) , and checks by reading @xmath60 whether process  @xmath66 agrees ( by _ not _ having @xmath79 me ) .",
    "if so , then @xmath8 has successfully completed a test - and - set by obtaining the 0 and , implicitly , setting the global variable @xmath80 . in this case process  @xmath66",
    "can not get 0 until process  @xmath8 does a reset by writing @xmath78 rst .",
    "while @xmath73 me , process  @xmath66 can only move from state ` me ' to state ` notme ' and on via states ` choose ' , ` tohe ' and ` he ' to ` tst1 ' , where it completes its test - and - set operation by failure to obtain the 0 .",
    "the only complication arises if both processes see each other s variable equal to ` me ' . in this case",
    "they are said to _ disagree _ or to be _ in conflict_. they then proceed to the ` choose ' state from where they decide between going for 0 or 1 , according to what the other process is seen to be doing .",
    "( it is essential that this decision be made in a neutral state , without a claim of preference for either 0 or 1 .",
    "if , for example , on seeing a conflict , a process would change preference at random , then a process can not know for sure whether the other one agrees or is about to write a changed preference . )",
    "the deterministic choices , those made if the other s variable is read to contain a value different from ` choose ' , can be seen to lead to a correct resolution of the conflict .",
    "a process ending up in the ` tst1 ' state makes sure that its test - and - set resulting in obtaining the 1 is justified , by remaining in that state until it can be sure that the other process has taken the 0 . only if the other process is seen to be in the ` rst ' state it resumes trying to take the 0 itself .",
    "suppose now that process  @xmath8 has read @xmath77 choose and is about to flip a coin .",
    "assume that process  @xmath81 has already moved to one of the states ` tome'/`tohe ' ( or else reason with the processes interchanged ) .",
    "with 50 percent chance , process  @xmath8 will move to the opposite state as did process  @xmath66 , and thus the conflict will be resolved .    in the proof of theorem  [ theo.scci ] ( below )",
    "we establish that the probability of each loop through the ` choose ' state is at most one half , and the expected number of ` choices ' ( transitions from state choose ) is at most two .",
    "this indicates that the worst case expected test - and - set length is 11 .",
    "namely , starting from the ` tst1 ' state , it takes 4 accesses to get to state ` choose ' , another 4 accesses to loop back to ` choose ' and 3 more accesses to reach ` tst0'/`tst1 ' .",
    "the reset operation always takes 1 access .",
    "the proof idea is as follows : we give a specification of a correct implementation of two - process test - and - set in the form of a finite automaton ( figure  [ hybrid ] ) .",
    "we then show that all initial segments of every possible interleaving of accesses by two processes @xmath82 and @xmath83 , both executing the algorithm of the state chart ( figure  [ prot2 ] ) , are accepted by the finite automaton .",
    "moreover , the sequence of states of the finite automaton in the acceptance process induces a linear order on the operation execution of the implemented processes that extends the partial order induced by the start and finish times of the individual operation executions .",
    "thus , the implementation is both correct and atomic . essentially , the proof is given by figure  [ tabletje ] , which gives the state of the specification finite automaton for every reachable combination of states which processes @xmath82 and @xmath83 can attain in their respective copies of the state chart ( figure  [ prot2 ] ) . by analysis of the state chart , or figure  [ tabletje ] , we upper bound the expectation of the number of accesses of every operation execution of the implementation by a small constant .",
    "hence the implementation is wait - free .",
    "let @xmath84 be an interleaving corresponding to a global execution @xmath85 of two processes running the protocol starting from the initial state .",
    "let @xmath86 be the set of time instants that start or finish an operation execution , each such time instant corresponding to an access @xmath31 .",
    "let @xmath87 denote the set these accesses . recall that if @xmath37 is a reset , then we have @xmath88 and there is but a single access executing this operation .    by definition ,",
    "@xmath89 , the restriction of @xmath84 to the accesses in @xmath87 , completely determines the partial order @xmath90 . if , for every @xmath91 we can choose a single access @xmath92 in the sequence of accesses constituting the operation execution of @xmath37 , such that if @xmath45 then @xmath92 precedes @xmath93 in @xmath84 , then we are done .",
    "namely , we can imagine an operation @xmath37 as executing atomically at the time instant of atomic access @xmath92 , and the total order @xmath52 defined by @xmath94 iff @xmath92 precedes @xmath93 in @xmath84 , extends the partial order @xmath90 .",
    "denote the set @xmath95 by @xmath96 .",
    "we have to show that for every @xmath84 as defined above such a @xmath96 can be found .",
    "_ specification of two - process atomic test - and - set : _ [ def.fa1 ] the definition of the target atomic test - and - set for two processes , process @xmath82 and process @xmath83 , is captured by finite automaton fa1 in figure  [ atomic ] , which accepts all possible sequences of atomic test - and - set and reset operations ( all states final ) .",
    "the states are labeled with the owner of the 0-bit .",
    "the arcs representing actions of process @xmath83 are labeled , whereas the non - labeled arcs represent the corresponding actions of process @xmath82 : resulting in setting @xmath97 .",
    "_ specification of wait - free atomic test - and - set restricted to a single process : _ [ def.fa2 ] figure [ semantics ] shows the semantics required of a correct implementation of a wait - free test - and - set object as a finite automaton fa2 , that accepts all sequences of accesses by a single process @xmath8 ( @xmath61 ) executing a correct wait - free atomic test - and - set protocol : ( all states final ) :    * the access starting a test - and - set operation execution , denoted s(tas ) , * the atomic occurrence of a test - and - set operation execution returning 0 , denoted tas0 , * the atomic occurrence of a test - and - set operation execution returning 1 , denoted tas1 , * the access finishing a test - and - set operation execution returning 0 , denoted f(tas0 ) , * the access finishing a test - and - set operation execution returning 1 , denoted f(tas1 ) , * the single access corresponding to a complete reset operation execution , denoted rst .",
    "these are the events in @xmath98 restricted to a process @xmath8 .",
    "the reason for not splitting a reset operation execution into start , atomic occurrence , and finish is that it is implemented in our protocol as a single atomic write where the above three transitions coincide .",
    "as before , doubly circled states are `` idle '' states ( no operation execution is in progress ) , and singly circled states are intermediate states in an operation execution that is in progress .",
    "_ specification of two - process wait - free atomic test - and - set : _ [ def.fa3 ] the proof that our implementation is correct consists in demonstrating that it satisfies the specification in the form of the finite automaton fa3 in figure  [ hybrid ] below ( again all states are final ) .",
    "formally @xcite , fa3 is the composition of fa1 with two copies of fa2 , in the i / o automata framework , as follows : it is drawn as a cartesian product of the two component processes  transitions of process  @xmath82 are drawn vertically and those of process  @xmath83 horizontally .",
    "for clarity , the transition names are only given once : only for process  @xmath83 .",
    "identifying the starts and finishes of test - and - set operation executions @xmath37 with their atomic occurrence @xmath92 by collapsing the @xmath99 and @xmath100 arcs , fa3 reduces to the atomic test - and - set diagram fa1 .",
    "identifying all nodes in the same column ( row ) reduces fa3 to fa2 of process  @xmath82 ( process  @xmath83 ) .    in the states labeled ` a ' through ` h ' , neither process owns the @xmath101",
    "; the system is in state @xmath21 . in the states labeled ` i ' through ` n ' , process  @xmath102 owns the @xmath101 ; the system is in state @xmath102 . in the states labeled ` o ' through ` t ' , process  @xmath101 owns the @xmath101 ; and the system is in state @xmath101 .",
    "the broken transitions of figure  [ hybrid ] correspond to the access @xmath103 , required for a correct implementation , where the atomic execution of operation @xmath37 can be virtually situated .",
    "recall that this is only relevant for @xmath37 is a test - and - set operation , since the reset operation is implemented in the protocol already in a single atomic access of a shared primitive variable .",
    "[ def.fa4 ] let fa4 be the ( nondeterministic ) finite automaton obtained from fa3 by turning the broken transitions of figure  [ hybrid ] , which correspond to the unknown but existing access @xmath103 where the execution of @xmath37 can be virtually situated , into @xmath104-moves .",
    "[ lem.1 ] acceptance of @xmath89 by fa4 implies that @xmath85 is linearizable : partial order @xmath90 can be extended to a total order @xmath52 such that the sequence of operation executions in @xmath44 ordered by @xmath52 satisfy the test - and - set semantics specification of definition  [ def.fa1 ] .",
    "if fa4 accepts @xmath89 , then , corresponding to the @xmath104 moves , we can augment the sequence @xmath89 with an access @xmath92 in the interval @xmath105 $ ] of each operation execution @xmath106or select the single access involved if @xmath88 as in the case of a reset operation execution to obtain a new sequence @xmath107 that is accepted by fa3 . by the way fa1 composes fa3",
    ", it accepts @xmath108 , the subsequence of atomic accesses @xmath92 with @xmath106 contained in @xmath107 .",
    "furthermore , letting @xmath109 denote the time of access @xmath92 , we have @xmath110 iff @xmath111 . defining @xmath94 if @xmath112 , the total order of accesses in @xmath108 , then @xmath52 is a total order that extends the partial order @xmath90 .",
    "that is , the sequence of operation executions of @xmath44 , linear ordered by @xmath52 , is accepted by fa1 .    [ cols=\"^,^,^,^,^,^,^,^,^,^,^,^\",options=\"header \" , ]     recall that figure  [ prot2 ] is the state chart of the execution of the implementation of an operation by a single process .",
    "each process can be in a particular state of the state chart .",
    "let @xmath113 denote the state of the system with process @xmath8 in state @xmath114 ( @xmath115 ) .",
    "the _ initial _ system state is @xmath116 .",
    "a system state @xmath113 is _ reachable _ from the initial system state @xmath116 if there is a sequence @xmath84 arising from the execution of our test - and - set implementation , represented by the state chart of figure  [ prot2 ] , starting from the initial state and ending in state @xmath113 .",
    "[ ex.reach1 ] in the initial state both processes are in state ` rst ' . process  @xmath82 can start a test - and - set by executing @xmath117 and entering state @xmath118 .",
    "suppose process  @xmath83 now starts a test - and - set : it executes @xmath117 and moves to state @xmath118 .",
    "hence , system states @xmath119 and @xmath120 are reachable states .    the _ representative set _ of a reachable system state @xmath121 is a nonempty set @xmath122 of fa3/fa4 states , as in figure  [ hybrid ] , such that : for every sequence of accesses @xmath84 starting in the initial state and ending in state @xmath121 , the set @xmath122 is the set of states in which fa4 can be after processing @xmath89 , excluding those states that have outgoing moves that are @xmath104-moves only .",
    "[ ex.reach2 ] we elaborate example  [ ex.reach1 ] . in the initial state",
    "both processes are in state ` rst ' .",
    "the corresponding start state @xmath123 of fa4 gives the associated ( in this case singleton ) representative set @xmath124 .",
    "when process  @xmath82 executes @xmath117 and enters state @xmath118 , the resulting system state is @xmath119 with the associated representative set @xmath125 of fa4 states .",
    "that is , the system is now either in state @xmath126 , meaning that process  @xmath82 has executed @xmath127 , or in state @xmath128 meaning that process  @xmath82 has executed @xmath127 and also @xmath129 atomically . in the scenario of example  [ ex.reach1 ] , process  @xmath83 now executes @xmath117 and moves to state @xmath118 , resulting in the system state @xmath120 .",
    "the corresponding representative set of fa4 states is @xmath130 .",
    "state @xmath131 says process  @xmath83 has executed @xmath127 and @xmath129 atomically , while process  @xmath82 has only executed @xmath127hence the system was previously in state @xmath126 and not in state @xmath128 .",
    "state @xmath51 says process  @xmath83 has executed @xmath127 and @xmath129 atomically , while process  @xmath82 has executed @xmath127 and @xmath132 atomically  and hence the system was previously in state @xmath126 and not state @xmath128 .",
    "states @xmath133 and @xmath134 imply the same state of affairs with the roles of process  @xmath82 and process  @xmath83 interchanged , and the previous system state is either @xmath128 or @xmath126 .",
    "( the correspondence between reachable states and their representative sets is exhaustively established in claim  [ claim.1 ] below . )",
    "[ lem.2 ] let @xmath84 be a sequence of accesses arising from the execution of our test - and - set implementation , represented by the state chart of figure  [ prot2 ] , starting from the initial state ( both processes in state ` rst ' ) .",
    "then , every initial segment of @xmath89 is accepted by fa4 starting from initial state ` d ' .",
    "we show that the set of letters in an entry in the table of figure  [ tabletje ] is a representative set for the state of process @xmath82 , indexing the row , and the state of process @xmath83 , indexing the column .",
    "the entries were chosen excluding all states from the representative sets with all outgoing moves consisting of @xmath104-moves ( but the representative sets contain the states the outgoing @xmath104-moves of the excluded states point to ) .",
    "this gives the most insight into the workings of the protocol by considering only the result of executing @xmath104-moves from a state if its only outgoing moves are @xmath104-moves .",
    "a @xmath135-entry indicates an unreachable state pair .",
    "( the number ending an entry gives the expected number of accesses to finish the current operation execution of process  @xmath82and by symmetry , that for an equivalent state pair with respect to @xmath83 .",
    "we will use this later . ) thus , every state @xmath113 of the implementation execution corresponds with a set of states @xmath136 of fa4 .",
    "[ claim.1 ] the representative sets are given by the entries of figure  [ tabletje ] .    the proof of the claim is contained in the combination of figures  [ prot2 ] , [ hybrid ] , [ tabletje ] .",
    "below we give the inductive argument .",
    "the mechanical verification of the subcases has been done by hand , and again by machine .",
    "the setting up of the exhaustive list subcases and subsequent verification by a computer program is the essennce of a finite - state proof . in this particular case , exceptionally , the finite state machines involved ( and the table of representative sets ) have been minimized so that `` mechanical '' verification by hand by the reader is still feasible .",
    "induction is on the length of the sequence of accesses :    _ base case : _ initially , after an empty sequence of accesses , fa4 is in the state @xmath137 .    _",
    "induction : _ every non - reachable state has a @xmath135-entry in the table of figure [ tabletje ] . consider an arbitrary atomic transition from a reachable state @xmath121 to a state @xmath138 , that is , using a single arc in the state chart in figure  [ prot2 ] for either process @xmath82 or @xmath83 .",
    "this way , either @xmath139 or @xmath140 but not both .",
    "then , for every fa4 state @xmath141 , figure  [ hybrid ] , according to the table of figure  [ tabletje ] , there is an fa4 state @xmath142 according to figure  [ hybrid ] , such that fa4 can move from @xmath143 to @xmath144 by executing : either the access corresponding to the transition in the state chart in figure  [ prot2 ] , if that access belongs to @xmath87 , or no access otherwise ( there is a sequence of @xmath104-moves from @xmath143 to @xmath144 ) .",
    "since every reachable state of the system @xmath113 , with @xmath114 ( @xmath145 a state of the state chart of figure  [ prot2 ] , has a representative set in fa4 , figure  [ hybrid ] , and every state of of fa4 is an accepting state , the lemma follows from claim  [ claim.1 ] .",
    "the algorithm represented by state chart of figure  [ prot2 ] correctly implements an atomic test - and - set object .    by lemma [ lem.2 ]",
    "the implementation by the state chart in figure  [ prot2 ] correctly implements the specification of two - process test - and - set given by figure  [ hybrid ] .",
    "the implementation is linearizable ( atomic ) by lemma  [ lem.2 ] .",
    "the system makes progress ( every operation execution is executed completely except for possibly the last one of each process ) since @xmath89 contains only the start and finish accesses of each operation execution performed by the implementation .",
    "[ theo.scci ] the algorithm represented by state chart of figure  [ prot2 ] is wait - free : the expected number of accesses to shared variables never exceeds 11 during execution of an operation .    in figure  [ prot2 ]",
    "every arc is an access .",
    "double circled states are idle states ( in between completing an operation execution and starting a new one ) .",
    "consider process @xmath82 ( the case for process @xmath83 is symmetrical ) .",
    "the longest path without completing an operation and without cycling is from state ` tst1 ' : tst1 , free , me , notme , choose , tohe , he , tst1 .",
    "this takes 7 accesses .",
    "four of these accesses are parts of a potential cycle of length 4 .",
    "the remainder is 3 accesses outside the potential cycle . in state ` choose ' , the outgoing arrow is a random choice only when process @xmath83 is also in the choose group .",
    "if it is , then with @xmath38 probability @xmath83 makes ( or has already made ) a choice which will cause process @xmath82 to loop back to the ` choose ' state again .",
    "this can happen again and again .",
    "the expected number of iterations of loops is @xmath146 .",
    "since a loop has length 4 , this gives a total of expected accesses of 8 for the loops .",
    "together with 3 non - loop accesses the total is at most @xmath5 accesses .",
    "such a computation holds for every state in the state chart of figure  [ prot2 ] , the only loop being the one discussed but the longest possible path is the one starting from ` tst1 ' . for definiteness ,",
    "we have in fact computed the expected number of accesses for every accessible state @xmath113 according to the state chart of figure  [ prot2 ] , and added that number to the representative set concerned in the table of figure  [ tabletje ] . since the expected number of accesses is between 1 and 11 for all operation executions , the algorithm given by the state chart of figure  [ prot2 ] is wait - free .    to aid intuition , we give an example of checking a few transitions below , as well as giving the interpretation .",
    "we elaborate and continue examples  [ ex.reach1 ] , [ ex.reach2 ] . in the initial state",
    "both processes are in state ` rst ' . in figure",
    "[ hybrid ] , the table entry @xmath147 gives the corresponding start state @xmath123 of fa4 .",
    "the worst - case expected number of accesses for a test - and - set by process  @xmath101 is 10 .",
    "process  @xmath82 can start a test - and - set by executing @xmath117 and entering state @xmath118 .",
    "the corresponding table entry @xmath148 indicates in figure  [ hybrid ] that the system is now either in state @xmath126 meaning that process  @xmath82 has executed @xmath127 , or in state @xmath128 meaning that process  @xmath82 has executed @xmath127 and also @xmath129 atomically .",
    "the expected number of accesses is now @xmath149 .",
    "suppose process  @xmath83 now starts a test - and - set : it executes @xmath117 and moves to state @xmath118 .",
    "the corresponding table entry @xmath150 gives the system state as one possibility in @xmath130 in figure  [ hybrid ] and the expected number of accesses for execution of test - and - set by process  @xmath82 is still 9 .",
    "state @xmath131 says process  @xmath83 has executed @xmath127 and @xmath129 atomically , while process  @xmath82 has only executed @xmath127hence the system was previously in state @xmath126 and not in state @xmath128 .",
    "state @xmath51 says process  @xmath83 has executed @xmath127 and @xmath129 atomically , while process  @xmath82 has executed @xmath127 and @xmath132 atomically  and hence the system was previously in state @xmath126 and not state @xmath128 .",
    "states @xmath133 and @xmath134 imply the same state of affairs with the roles of process  @xmath82 and process  @xmath83 interchanged , and the previous system state is either @xmath128 or @xmath126",
    ".    note that at this point the system can also be in state @xmath84 of fa4both processes having executed @xmath127 but no process having executed @xmath129 or @xmath132 .",
    "however , from @xmath84 there are two @xmath104-moves possible , and no other moves , leading to @xmath134 and @xmath131 .",
    "this corresponds to the fact that if both processes have executed @xmath127 , one of them must return 0 and the other one must return 1 .",
    "we have optimized the table entries by eliminating such spurious intermediate states @xmath84 with outgoing moves that are @xmath104-moves only .",
    "process  @xmath82 might now read @xmath151 , and move via state ` notme ' ( table entry @xmath152 ) by writing @xmath153 , to state ` choose ' .",
    "process  @xmath83 is idle in the meantime .",
    "the table entry is now @xmath154 .",
    "this says that process  @xmath83 has atomically executed @xmath155 , and process  @xmath82 has atomically executed @xmath156 .",
    "namely , all subsequent schedules lead in 3 accesses of process  @xmath82 to state ` tst1'hence the expectation 3 .    the expected number of remaining accesses of process  @xmath82 s test - and - set has dropped from 8 to 3 by the last access since 8 was the worst - case which could be forced by the adversary .",
    "namely , from the system in state @xmath157 , the adversary can schedule process  @xmath83 to move to @xmath158 with table entry @xmath152 , followed by a move of process  @xmath83 to state @xmath159 with table entry @xmath152 , followed by a move of process  @xmath82 to state @xmath160 with table entry @xmath161 .",
    "suppose the adversary now schedules process  @xmath82 .",
    "it now flips a fair coin to obtain the conditional boolean @xmath162 .",
    "if the outcome is @xmath163 , then the system moves to state @xmath164 with entry @xmath165 .",
    "if the outcome is @xmath166 , then the system moves to state @xmath167 with table entry @xmath165 . given a fair coin , this access of process  @xmath82",
    "correctly decrements the expected number of accesses .",
    "suppose the adversary schedules process  @xmath83 in state @xmath168 .",
    "process  @xmath83 flips a fair coin .",
    "if the outcome is @xmath163 the system moves to state @xmath169 with table entry @xmath161 ; if the outcome is @xmath166 then the system moves to state @xmath170 with table entry @xmath161 .",
    "the obvious way to extend the given solution to more than two processes would be to arrange them at the leaves of a binary tree . then , a process wishing to execute an @xmath0-process test - and - set , would enter a tournament , as in @xcite , by executing a separate two - process test - and - set for each node on the path up to the root .",
    "when one of these fails , it would again descend , resetting all the tas - bits on which it succeeded , and return 1 .",
    "when it succeeds ascending up to the root , it would return 0 and leave the resetting descend to its @xmath0-process reset .",
    "the intuition behind this tree approach is that if a process @xmath51 fails the test - and - set at some node @xmath171 , then another process @xmath172 will get to the root successfully and thus justify the value 1 returned by the former .",
    "unfortunately , this straightforward extension does not work .",
    "the problem is that the other process @xmath172 need not be the one responsible for the failure at node @xmath171 , and might have started its @xmath0-process test - and - set only after process @xmath51 completes its own .",
    "clearly , the resulting history can not be linearized .",
    "nonetheless , it turns out that with a somewhat more complicated construction we can _ deterministically _ implement @xmath0-process test - and - set using two - process test - and - set as primitives @xcite .",
    "this shows that the impossibility of deterministic wait - free atomic @xmath0-process test - and - set is completely due to the impossibility of deterministic wait - free atomic two - process test - and - set .",
    "this latter problem we have just solved by a simple direct randomized algorithm .",
    "y. afek , e. gafni , j. tromp , p.m.b .",
    "vitnyi , wait - free test - and - set , pp .",
    "85 - 94 in : _ proc .",
    "6th workshop on distributed algorithms ( wdag-6 ) _ , lecture notes in computer science , vol . 647 , springer verlag , berlin , 1992 .",
    "a. bar - noy and d. dolev , a partial equivalence between shared - memory and message - passing in an asynchronous fail - stop distributed environment , _ mathematical systems theory _ , 26(1993 ) , 2139 .",
    "e. borowsky and e. gafni , immediate atomic snapshots and fast renaming , _ proc .",
    "11th acm symp . on principles of distributed computing _ , 1992 , pp .",
    "h. buhrman , a. panconesi , r. silvestri , and p. vitanyi on the importance of having an identity or , is consensus really universal ?",
    ", _ distributed computing conference ( disc00 ) _ , lecture notes in computer science , vol .",
    "1914 , springer - verlag , berlin , 2000 , 134148 .",
    "j.e burns , p.jackson , n.a .",
    "lynch , m.j .",
    "fischer , g.l .",
    "peterson , data requirements for implementation of n - process mutual exclusion using a single shared variable , _ j. assoc .",
    "_ , 29(1982),183205 .",
    "w. eberly , l. higham , j. warpechowska - gruca , long - lived , fast , waitfree renaming with optimal name space and high throughput , _ proc .",
    "12th intnl distributed computing conference ( disc98 ) _ , lecture notes in computer science , 1499 , springer - verlag , berlin , 1998 ."
  ],
  "abstract_text": [
    "<S> we present the first explicit , and currently simplest , randomized algorithm for two - process wait - free test - and - set . </S>",
    "<S> it is implemented with two 4-valued single writer single reader atomic variables </S>",
    "<S> . a test - and - set takes at most 11 expected elementary steps , while a reset takes exactly 1 elementary step . based on a finite - state analysis , the proofs of correctness and expected length </S>",
    "<S> are compressed into one table .    </S>",
    "<S> test - and - set objects , symmetry breaking , asynchronous distributed protocols , fault - tolerance , shared memory , wait - free read / write registers , atomicity , randomized algorithms , adaptive adversary . </S>"
  ]
}