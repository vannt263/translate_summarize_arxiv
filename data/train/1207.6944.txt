{
  "article_text": [
    "this work is a sequel to the stacs paper @xcite and its journal version @xcite .",
    "however , we try to keep it self - contained by reiterating everything of importance from the two preceeding papers .",
    "we extend their results to a more general version of power circuits . as a consequence",
    ", we can apply them to larger classes of groups .",
    "the group @xmath10 was introduced by higman in 1951 and served to provide the first known example of a finitely generated infinite simple group @xcite .",
    "it belongs to a family @xmath11 ( @xmath12 ) of groups with @xmath13 generators and @xmath13 relators : @xmath14    for @xmath15 these groups are trivial , which is easy to see for @xmath16 , but suprisingly hard for @xmath17 .",
    "the latter case was proven by hirsch @xcite , see also  23 in @xcite and @xcite . if @xmath6 , then @xmath11 is infinite , see @xcite , section 1.4 . since @xmath11 has no non - trivial normal subgroups of finite index , taking a minimal non - trivial quotient results in a finitely generated infinite simple group .    until recently ,",
    "higman s group @xmath10 was a candidate for a `` natural '' group with non - elementary word problem .",
    "this was suggested by the huge compression that this group allows .",
    "in fact , there are words of length @xmath18 over the generators @xmath19 and their inverses , which in the group are equal to @xmath20 , where @xmath21 is the tower function ( also called `` tetration '' ) defined by @xmath22 and @xmath23 . however , in @xcite it was shown that the word problem of @xmath10 is decidable in @xmath24 time and @xcite improved this bound to @xmath8 .",
    "both results rely on a data structure called `` power circuit '' which was introduced by miasnikov , ushakov , and won in @xcite .",
    "power circuits had already proven useful in algorithmic group theory .",
    "in fact , their invention was entailed by the wish to efficiently solve the word problem in the baumslag - gersten group @xmath25 ( see @xcite and section [ sec : bg ] ) which shares with @xmath10 the property of huge compression .",
    "( in @xcite the group @xmath25 is called `` baumslag group '' .",
    "we use the equally common name `` baumslag - gersten group '' to avoid confusion with the baumslag - solitar group . ) for @xmath2 , power circuits have been implemented @xcite and there is a computer program solving the word problem in @xmath25 .",
    "this paper builds on the work of diekert , ushakov , and the author conducted in @xcite and @xcite .",
    "its contributions are twofold : in section [ sec : pc ] , we extend power circuits to allow arbitrary bases @xmath0 .",
    "this necessitates changes in the reduction procedure , the core component of power circuits . in section [ sec : higman ] , we generalize higman s group @xmath10 by replacing the underlying group @xmath4 by @xmath26",
    ". power circuits with base @xmath1 are naturally suited for computations in this group .",
    "furthermore , with the help of rewriting systems , we give a constructive method of treating any group @xmath11 ( @xmath6 ) rather that just @xmath10 .",
    "combining this with base @xmath1 power circuits leads to an algorithm for the word problem in generalized higman groups @xmath7 which retains the @xmath8 time bound proved in @xcite for @xmath2 and @xmath27 .",
    "[ [ sec : notation ] ] notation and preliminaries + + + + + + + + + + + + + + + + + + + + + + + + + +    algorithms and decision problems are classified by their time complexity on a random - access machine ( ram ) .",
    "we use the notion of amortized analysis with respect to a potential function , see section 17.3 in @xcite .    with regard to group theory , we use standard notation and facts that can be found in any textbook on the subject , e.g. @xcite .",
    "in particular , we apply the technique of britton reductions for solving the word problem in hnn extensions and amalgamated products .    rewriting systems are of particular importance for this work .",
    "we assume that the reader is familiar with the basic notions of ( local ) confluence and termination .",
    "see for example the textbook @xcite for a quick introduction .",
    "power circuits were introduced by miasnikov , ushakov , and won in @xcite . while the underlying ideas presented in this chapter originate from their work , there are some important differences .",
    "first , we use a different ( and hopefully more accessible ) notation , following @xcite and @xcite .",
    "we also allow multiple markings in one circuit .",
    "the most important modification , which also distinguishes this paper from @xcite and @xcite , is the generalization from base @xmath28 to arbitrary bases @xmath0 .      for the rest of this paper , we fix an integer @xmath0 for the base and the interval @xmath29 ( the set of digits ) .",
    "we start with a directed acyclic edge - labelled graph without multi - edges , given by @xmath30 . here",
    ", @xmath31 is a finite set which will act as the set of nodes ( or vertices ) .",
    "the labelled edges ( or arcs ) are given by the map @xmath32 where @xmath33 means that there is no edge from @xmath34 to @xmath35 and @xmath36 implies an edge from @xmath34 to @xmath35 labelled with the number @xmath37 . in other words ,",
    "the edge set is @xmath38 , the support of the map @xmath39 .",
    "in addition , we require that the directed graph @xmath40 is acyclic",
    ". we shall make this assumption throughout this paper without mentioning it again . for any operation on graphs introduced in this chapter",
    ", it will be obvious that acyclicity is preserved .",
    "a marking of @xmath30 is a mapping @xmath41 .",
    "often we regard @xmath42 as a labelled subset of the nodes of @xmath43 , where the subset is @xmath44 and the labels are given by @xmath45 . in this sense , @xmath46",
    "( the constant zero marking ) and @xmath47 ( the empty marking ) are the same .",
    "each node @xmath48 induces in a natural way its successor marking @xmath49 defined by @xmath50 intuitively , the successor marking of a node @xmath34 consists of the target nodes of edges starting at @xmath34 and their labels are given by those of the edges .",
    "the evaluation function @xmath51 assigns a real number to each node and each marking of a graph @xmath43 . as @xmath43 is acyclic we can give an inductive definition of @xmath51 : @xmath52 note that this implies @xmath53 for all leaves @xmath34 ( nodes without outgoing edges ) . for every node @xmath48 we have @xmath54    figure [ fig : graph_eval ]",
    "shows an example of such a graph for @xmath55 .",
    "the set of nodes is @xmath56 and @xmath39 is given by @xmath57 the nodes evaluate to @xmath58    [ lem : pc_condition ] let @xmath30 be as described above .",
    "the following statements are equivalent :    [ prop : pc_condition : node ] @xmath59 for every node @xmath48    [ prop : pc_condition : succ ] @xmath60 for every node @xmath48    [ prop : pc_condition : mark ] @xmath61 for every marking possible marking @xmath42 in @xmath43    this is easily seen by noetherian induction with respect to a topological order of @xmath31 ( i.e. , an order compatible with the edges ) .",
    "a _ power circuit _ is a finite acyclic edge - labelled graph @xmath30 without multiple edges that meets the equivalent conditions of lemma [ lem : pc_condition ] .",
    "the graph in figure [ fig : graph_eval ] is not a power circuit due to @xmath62 .",
    "in contrast , figure [ fig : pc_mark_eval ] depicts a power circuit for @xmath2 .",
    "the values of the nodes are given for illustrative purposes only .",
    "in general , these number become too large to be computed .",
    "the marking @xmath42 evaluates to @xmath63 .    in corollary",
    "[ cor : test_graph_pc ] we will show that it can be efficiently tested whether a given graph is a power circuit . in @xcite , a power circuit does not have to satisfy the criteria of lemma [ lem : pc_condition ] , but if it does , it is called proper . in this sense",
    ", we only deal with proper power circuits .",
    "figure [ fig : pc_tower ] shows that a power circuit of linear size can contain markings with values the magnitude of the tower function .",
    "\\(4 ) at ( 4.5,0 )  ;      let @xmath30 be a power circuit and @xmath48 a node .",
    "the operation clonewith result @xmath64 creates a new node @xmath35 with the same successor marking as @xmath34 , but no incoming arcs .",
    "we extend this operation to markings @xmath42 , by cloning every single node in @xmath44 .",
    "the resulting marking @xmath65 is defined as the marking consisting of all these clones , and the signs are copied from @xmath42 : @xmath66    in figure [ fig : pc_clone ] , the marking @xmath42 consisting of two nodes is cloned .",
    "now we can define arithmetic operations .",
    "let @xmath30 be a power circuit and let @xmath67 and @xmath42 be markings in @xmath43 . if the supports of @xmath67 and @xmath42 are disjoint , the mapping @xmath68 defined by @xmath69 is a marking with @xmath70 . in general , however , the operands @xmath67 and @xmath42 will not be disjoint . in this case",
    "we have nodes @xmath71 with @xmath72 , hence @xmath68 is not a valid marking .",
    "we solve this problem by cloning : for every node @xmath34 with @xmath72 , we create a clone @xmath73 and modify @xmath68 by putting @xmath74 and @xmath75 .",
    "we obtain a valid marking in the ( now enlarged ) circuit with value @xmath76 .    in figure",
    "[ fig : pc_add ] , @xmath77 and @xmath78 are added . in the resulting marking",
    ", the node with value @xmath79 cancels out , whereas both the original node with value @xmath80 and its newly created clone are included .    the second operation that we need",
    "is multiplication by a power of @xmath1 .",
    "we observe that @xmath81 so in principle we would just have to introduce new edges from each node in @xmath82 to each node in @xmath44 .",
    "the label of such an edge would be the value that @xmath42 assigns to the respective target node .",
    "this operation works as long as    1 .",
    "no cycles are introduced into the circuit , 2 .",
    "no multi - edges between two nodes are introduced , 3 .",
    "there are no edges between nodes in @xmath82 , and 4 .   no other marking in the circuit is affected .",
    "( note here , that the original value of @xmath67 is lost in any case . )",
    "again , the solution is cloning .",
    "create clones @xmath83 and @xmath84 and introduce new edges by putting @xmath85 for all @xmath86 , @xmath87 .",
    "being clones , nodes in @xmath88 and @xmath89 have no incoming edges , which prevents cycles and multi - edges . also , no other marking in the circuit depends on @xmath90 or @xmath91 directly ( by containing these nodes ) or indirectly ( by containing nodes that are topologically above any node in @xmath90 or @xmath91 ) .",
    "an example ( in which no further cloning is necessary ) is shown in figure [ fig : pc_mult_power ] .",
    "finally , note that the operation @xmath92 which negates the value of @xmath42 is easy to conduct without any complications or the need for cloning .",
    "the operations @xmath68 and @xmath93 introduced in the previous section are quite efficient . assuming that the graph is stored using adjacency lists",
    ", the time they take depends only on the size of the markings @xmath42 and @xmath67 , not on the size of the circuit .",
    "the price for this efficieny is that the structure of a power circuit can quickly become rather intransparent . in particular , it is unclear how ( in)equality of the values of two markings can be determined in an arbitrary circuit .",
    "again , note that evaluating the nodes or markings is not an option , due to the vast growth permitted by power circuits . for this reason ,",
    "we restrict ourselves to a subclass of circuits and augment them with some additional data :    [ def : reduced_pc ] a _ reduced power circuit _ is a power circuit @xmath30 together with a list @xmath94 of its nodes and a bit vector @xmath95 such that    different nodes evaluate to different numbers , i.e. , for all @xmath96 with @xmath97 , @xmath98 ,    the list of nodes is sorted by value , i.e. , @xmath99 ,    @xmath100 if and only if @xmath101 .",
    "[ prop : compare_in_red_pc](cf .",
    "prop . 5 in @xcite and",
    "section 2.1 in @xcite ) given a reduced circuit and two markings @xmath67 and @xmath42 , the values @xmath102 and @xmath103 can be compared ( yielding @xmath104 , @xmath105 , or @xmath106 as the result ) in @xmath107 time .",
    "the algorithm can also determine whether @xmath108 .",
    "assume that we want to determine whether for a sum @xmath109 with @xmath110 we have @xmath111 , @xmath112 , @xmath113 , @xmath114 or @xmath115 .",
    "we can do this inductively using the following procedure :    if @xmath116 , use induction on @xmath117 .    if @xmath118 , then @xmath119 and the sign of @xmath120 is the same as the sign of @xmath121 .    if @xmath122 , look at @xmath123 . if @xmath124 or if it has the same sign as @xmath121 , then @xmath125 since @xmath0 .",
    "again , @xmath120 has the same sign as @xmath121 . if @xmath123 has the opposite sign of @xmath121 , use induction on @xmath126 , where @xmath127 .",
    "the answer to the original question can be found by applying this algorithm to the mapping @xmath128 given by @xmath129 .",
    "note , that the absolute indices @xmath130 of the @xmath131 are not actually needed .",
    "instead one can use the information provided by the reduced circuit .",
    "[ cor : divisibility_in_red_pc ] for two markings @xmath67 and @xmath42 in a reduced circuit , it can be tested in @xmath107 time whether @xmath132 divides @xmath103 .",
    "let @xmath34 be the node of minimal value in @xmath44 .",
    "then @xmath133 if and only if @xmath134 .",
    "using proposition [ prop : compare_in_red_pc ] , we can check the equivalent condition @xmath135 .",
    "power circuits arising from a sequence of arithmetic operations are usually far from being reduced .",
    "every cloning creates a pair of nodes with the same value .",
    "therefore , we need an algorithm that given an arbitrary circuit produces an equivalent reduced circuit . in this context , equivalence means that for each node and each marking in the old circuit , there is one with the same value in the reduced circuit . before giving the algorithm",
    ", we need some preparations .",
    "[ def : chain ] a list @xmath136 of nodes in a power circuit is called a _ chain _ ( starting at @xmath137 ) , if @xmath101 for all @xmath138 .",
    "it is called a maximal chain ( starting at @xmath137 ) , if it is not part of a longer chain ( starting at @xmath137 ) .    note",
    "that chains have nothing to do with paths in the graph . in arbitrary power circuits ,",
    "chains are difficult to spot . however , in a reduced power circuit , they can be easily identified using the bit vector .    in a reduced circuit ,",
    "the maximal chain starting at the unique node of value @xmath79 is of particular interest .",
    "it is called the _ base chain _ of the power circuit . for later use ,",
    "we define in algorithm [ alg : prolong_base_chain ] a procedure prolongbasechainprolonging this chain by one node without destroying the reducedness property of a circuit .",
    "the procedure prolongbasechaintakes @xmath107 time .",
    "[ alg : prolong_base_chain ] let @xmath139 be the ordered list of the nodes of the reduced circuit @xmath31 . using this list and the bit vector , find the smallest @xmath140 such that @xmath141 .",
    "write @xmath130 as a @xmath1-ary number @xmath142 and use this to define the marking @xmath143 with value @xmath144 . insert a new node @xmath34 with @xmath145 into the circuit .",
    "place @xmath34 in the ordered list of nodes between @xmath146 and @xmath147 .",
    "check whether @xmath148 by applying proposition [ prop : compare_in_red_pc ] to @xmath49 and @xmath149 ( both are contained in the reduced circuit @xmath43 ) . set the bit vector for @xmath34 accordingly .",
    "now we can give an algorithm that reduces power circuits .",
    "reduction is done node by node .",
    "this means that at any point during the reduction procedure , the circuit consists of a reduced part and a part that is not yet reduced .",
    "the nodes in the non - reduced part are processed in topological order . in this way",
    ", the procedure only has to work for nodes all of whose successors are already in the reduced part .",
    "this approach allows us to generalize the reduction procedure . instead of reducing the entire circuit",
    ", we can take into account that parts of it might already be reduced .",
    "this will turn out to be useful in applications .",
    "the procedure extendreductiondescribed in algorithm [ alg : extend_reduce ] takes as input not only the power circuit but also a list @xmath150 of markings that need to be adjusted during reduction in order to preserve their value .",
    "[ alg : extend_reduce ] compute a topological order of @xmath151 , i.e. , @xmath152 such that @xmath153 implies @xmath154 .",
    "[ prop : extend_reduce](cf .",
    "@xcite , thm .",
    "6 ) the procedure extendreductionis correct and takes @xmath155 time . the circuit growth @xmath156 is bounded by @xmath157 .",
    "at first , a topological order is computed .",
    "the time for this is bounded by the size of the subgraph @xmath151 ( nodes and edges ) , which is @xmath158 . in the main loop starting at line [ alg : extend_reduce : main_loop ] ,",
    "the nodes are eliminated from @xmath151 one by one .",
    "let @xmath159 be the initial size of the whole graph .",
    "since @xmath31 grows by @xmath160 during the procedure ( although we keep calling it @xmath31 for convenience ) , @xmath161 is the correct bound for the size of @xmath31 .    for each node @xmath162 ,",
    "its position in the ordering of @xmath31 has to be found in step [ alg : extend_reduce : bin_search ] .",
    "since @xmath163 is chosen to be topologically minimal , the successor marking @xmath49 is contained in the reduced circuit @xmath31 , so @xmath34 can be compared to any node @xmath164 in @xmath161 time . using binary search ,",
    "@xmath165 comparisons are sufficient , taking @xmath166 time in total .    for the insertion of @xmath167 in @xmath31 ,",
    "we distiguish two cases . in the first one ( step [ alg : extend_reduce : no_collision ] )",
    ", there is no node in @xmath31 with the same value as @xmath167 . in this case , @xmath167 is moved from @xmath151 to @xmath31 without any modification .",
    "markings containing @xmath167 ( including successor markings , i.e. , edges with target @xmath167 ) are not affected either .",
    "the second case ( step [ alg : extend_reduce : collision ] ) , where there is a node @xmath168 with the same value as @xmath167 is more difficult .",
    "figure [ fig : pc_reduction ] shows an example .",
    "the idea is to delete @xmath167 and replace it in all markings @xmath42 ( both markings from @xmath42 and successor markings of nodes in @xmath151 ) by @xmath168 .",
    "this may cause @xmath168 to by `` overmarked '' by @xmath42 , i.e. , @xmath169 .",
    "for example , in the simplest case @xmath2 , if @xmath170 , then @xmath171 after the replacement .",
    "the solution is inspired by the idea of carry digits used when adding two @xmath1-ary numbers : if @xmath172 , subtract the appropriate number @xmath173 and add @xmath174 to the value that @xmath42 assigns to the next node @xmath175 in the chain , which has @xmath1 times the value of @xmath168 .",
    "the carry might propagate to the end of the chain , which is why we preventively prolonged it by one node @xmath176 .",
    "note that the time bound for one execution of step [ alg : extend_reduce : adjust_markings ] is not @xmath177 , but rather @xmath178 .",
    "since this is not sufficient to prove the claimed bound , instead we count the total amount of time spent in step [ alg : extend_reduce : adjust_markings ] during the whole procedure .",
    "the key observation is that for every carry that has to be moved to the next node in the chain , the number @xmath179 decreases . initially @xmath180 , so the total time complexity of step [ alg : extend_reduce : adjust_markings ] is @xmath181 .",
    "( -2,-0.5 ) rectangle ( 3,6.5 ) ; ( 1,-0.5 )  ( 1,6.5 ) ; at ( 1,6.5 ) @xmath31 ; at ( 1,6.5 ) @xmath151 ;    ( -2,-0.5 ) rectangle ( 3,6.5 ) ; ( 1,-0.5 )  ( 1,6.5 ) ; at ( 1,6.5 ) @xmath31 ; at ( 1,6.5 ) @xmath151 ;     +    ( -2,-0.5 ) rectangle ( 3,6.5 ) ; ( 1,-0.5 )  ( 1,6.5 ) ; at ( 1,6.5 ) @xmath31 ; at ( 1,6.5 ) @xmath151 ;    ( -2,-0.5 ) rectangle ( 3,6.5 ) ; ( 1,-0.5 )  ( 1,6.5 ) ; at ( 1,6.5 ) @xmath31 ; at ( 1,6.5 ) @xmath151 ;    not all markings need to be included in @xmath150 .",
    "since @xmath43 remains a subcircuit of @xmath182 and the values of nodes in @xmath31 do not change , all markings whose support is completely contained in @xmath31 are automatically preserved .",
    "only markings using nodes in @xmath151 have to be put into @xmath150 . in most applications , @xmath150 consists only of a constant number of markings .",
    "the bound for the circuit growth given in proposition [ prop : extend_reduce ] is a rather crude one .",
    "a more detailed analysis shows that calling prolongbasechainis only necessary once every time @xmath183 grows by a factor @xmath1 .",
    "if one does some `` cleaning up '' in the circuit ( for instance delete unmarked nodes with no incoming edges ) , @xcite shows that the growth during reduction is even bounded by @xmath79 .",
    "however , this bound is of no importance in our applications since cloning during arithmetic operations increases the size by @xmath160 anyway .    in practice ,",
    "the circuit size rarely ever increases at all during reduction .",
    "usually , the cicuit even shrinks .",
    "[ thm : reduce](cf .",
    "@xcite , cor .",
    "7 ) there is a procedure reducewhich given a power circuit @xmath30 and a list @xmath184 of markings in @xmath43 , returns a reduced circuit @xmath185 and a list @xmath186 of markings in @xmath182 such that @xmath187 ( @xmath188 ) . reducetakes @xmath189 time and the size of @xmath190 is bounded by @xmath191 .",
    "invoke extendreductiontaking @xmath192 as the reduced part and the whole circuit as @xmath151 .",
    "step [ alg : extend_reduce : abort ] in extendreductiontests whether @xmath60 .",
    "this is one of the equivalent conditions specified in lemma [ lem : pc_condition ] for a graph to be a power circuit .",
    "therefore , reduction is at the same time a test whether a graph is a power circuit :    [ cor : test_graph_pc](@xcite , cor .",
    "8) given a dag @xmath30 it can be determined in @xmath193 time whether @xmath43 is a power circuit .      in this section , we will show that using a richer data structure for reduced circuits , the time complexity of extendreductioncan be reduced to @xmath194 .",
    "this eliminates the logarithmic factors both for reduceand for the test presented in corollary [ cor : test_graph_pc ] .",
    "we start by taking a closer look at power sums .",
    "a power sum is a formal sum @xmath195 whose coefficients @xmath196 are in @xmath197 and only finitely many of them are non - zero .",
    "the value @xmath198 of the power sum @xmath199 is defined in the obvious way .",
    "on the set of all power sums , we define a rewriting system @xmath200 generated by the rules @xmath201 and for @xmath202 @xmath203 none of these rules changes the value of the power sum .",
    "we omit the proof for the following lemma , since it consists of a long but simple enumeration of cases .",
    "[ lem : power_sum_system_confluent ] the rewriting system @xmath200 is locally confluent .    [ lem : power_sum_system_terminating ] the rewriting system @xmath200 is terminating ( noetherian ) and hence confluent ( @xcite , thm .",
    "1.1.13 ) .",
    "let @xmath204 be a sequence of rewritings .",
    "since none of the rules of @xmath200 increases the number of non - zero coefficients , this number must eventually reach a minimum .",
    "thus , ignoring a finite number of terms , we can assume that the number of non - zeros is constant within the sequence .",
    "no rule in @xmath200 moves a non - zero coefficient to the left ( in the direction of smaller exponents ) . as the value of the @xmath205",
    "is fixed , non - zeros can not be moved indefinitely to the right either .",
    "again , by disregarding a finite prefix of the sequence , we assume that the positions of the non - zero coefficients are fixed . at this point ,",
    "no application of @xmath206 or @xmath207 is possible any more .",
    "finally , rules of type @xmath208 and @xmath209 move pairs of consecutive coefficients with opposite signs to the left ( or remove them ) , which can also occur only finitely often .",
    "thus , the sequence @xmath210 is eventually constant .",
    "we call power sums that are irreducible with respect to @xmath200 compact",
    ". if @xmath211 is compact , then so is @xmath212 .",
    "[ prop : power_sum_properties ]     [ prop : power_sum_properties : unique ] for each power sum there is a unique compact power sum of the same value .    [ prop : power_sum_properties : min ] compact power sums have the minimal number of non - zero coefficients among all power sums of the same value .",
    "[ prop : power_sum_properties : inc ] if @xmath199 and @xmath213 are compact power sums , then @xmath214 if and only if @xmath215 for some power sum @xmath151 , @xmath216 , and for each @xmath217 either @xmath218 and @xmath219 or @xmath220 and @xmath221 .",
    "[ prop : power_sum_properties : lex ] the usual order on @xmath197 gives rise to a lexicographical order on power sums ( where coefficients of higher powers of @xmath1 are compared before those of lower powers ) . restricted to compact power sums , this lexicographical order coincides with the order by values .    for [ prop : power_sum_properties : unique ] it suffices to show that for two power sums @xmath199 and @xmath213 of the same value , we have @xmath222 .",
    "this is true , since applying the rules of @xmath200 forward or backward , one can turn any power sum into an ordinary @xmath1-ary number with coefficients from @xmath223 .",
    "( for instance , for positive values of @xmath199 , use rules of type @xmath208 backward and rules of type @xmath209 forward to push negative coefficients to the right . )    claim [ prop : power_sum_properties : min ] follows from the fact that no rule increases the number of non - zero coefficients .    for the ``",
    "if '' part of [ prop : power_sum_properties : inc ] , we observe that component - wise subtraction yields @xmath224 which evaluates to @xmath79 .",
    "for the `` only if '' part , let @xmath225 be compact . consider @xmath226 . if @xmath227 is a valid power sum ( i.e. @xmath228 ) and @xmath227 is compact , it already has the desired form ( for @xmath229 ) .",
    "otherwise we have one of the following cases :    @xmath227 is not a valid power sum , since @xmath230 .",
    "let @xmath231 be the maximum number such that @xmath232 .",
    "we transform @xmath227 into @xmath233 and use induction on @xmath234",
    ".    a rule of type @xmath208 can be applied .",
    "we have @xmath235 and @xmath236 .",
    "applying the rule gives @xmath237 use induction on @xmath238 .",
    "a rule of type @xmath206 can be applied .",
    "we have @xmath235 and @xmath239 and @xmath240 for some @xmath241 .",
    "this yields @xmath242 and induction applies to @xmath243 .",
    "finally , [ prop : power_sum_properties : lex ] is a consequence of [ prop : power_sum_properties : inc ] .",
    "the notion of compactness was introduced in @xcite for @xmath2 and subsequently used in @xcite .",
    "our definition is a generalization that inherits most of the original characteristics .",
    "there is , however , one important difference : it is much less obvious for @xmath244 how to make a power sum compact in linear time . in the case",
    "@xmath2 it suffices to apply the rules of @xmath200 from left to right . yet , if for instance @xmath55 , the application of rule @xmath208 to @xmath245 turns the previously compact prefix @xmath246 into the @xmath200-reducible sum @xmath247 .",
    "[ prop : compactify_power_sum ] any power sum @xmath248 can be transformed into a compact power sum with the same value in @xmath161 time .",
    "any two power sums @xmath199 and @xmath213 with @xmath249 can be transformed into each other using only replacements of the form @xmath250 moreover , at most one application of @xmath251 or @xmath252 is needed for each @xmath130 .",
    "in fact , whether @xmath251 or @xmath252 or neither is needed , depends only on @xmath199 and @xmath213 .",
    "this can be seen using induction on @xmath130 .",
    "let @xmath253 be the compact power sum with @xmath249 .",
    "define @xmath254 ( @xmath255 ) depending on whether the replacement @xmath251 or @xmath252 or neither of them occurs in the sequence @xmath256 . for notational conveniance",
    ", we define @xmath257 and @xmath258",
    ". then we have @xmath259 for @xmath260 .",
    "it remains to compute the values @xmath261 ( @xmath262 ) .",
    "these are the unique solution of the following system of conditions ( @xmath260 ) : @xmath263 for @xmath264 and for all @xmath265 we define @xmath266 $ ] to be the set of possible values for @xmath261 , provided that @xmath267 and @xmath268 : @xmath269:=\\{j_i\\>:\\>&\\text{there are $ j_1,\\ldots , j_{i-3}$ such that}\\cr      & \\text{$j_0=0,j_1,\\ldots , j_{i-3},j_{i-2}=j , j_{i-1}=k , j_i$ satisfy $ ( \\meddiamond_0),\\ldots,(\\meddiamond_{i-1})$}\\}\\end{aligned}\\ ] ] since @xmath270 only affects @xmath271 , the sets @xmath272 $ ] can be computed in constant time using @xmath273 $ ] . after this , the solution @xmath274 can be read from right to left .",
    "[ ex : compactify_power_sum ] suppose that @xmath55 and we want to make @xmath275 compact . we get :    lcccccc@xmath266 $ ] & @xmath276 & @xmath277 & @xmath278 & @xmath279 & @xmath280 & @xmath281@xmath282 & @xmath192 & @xmath192 & @xmath192 & @xmath283 & @xmath192 & @xmath192@xmath284 & @xmath192 & @xmath192 & @xmath192 & @xmath192 & @xmath285 & @xmath192@xmath286 & @xmath192 & @xmath192 & @xmath192 & @xmath192 & @xmath192 & @xmath192@xmath287 & @xmath192 & @xmath192 & @xmath288 & @xmath192 & @xmath192 & @xmath192@xmath289 & @xmath283 & @xmath288 & @xmath192 & @xmath192 & @xmath192 & @xmath283 @xmath290 & @xmath291 & @xmath192 & @xmath192 & @xmath192 & @xmath192 & @xmath192@xmath292 & @xmath192 & @xmath192 & @xmath192 & @xmath192 & @xmath192 & @xmath192@xmath293 & @xmath192 & @xmath192 & @xmath192 & @xmath192 & @xmath192 & @xmath192@xmath294 & @xmath192 & @xmath283 & @xmath192 & @xmath192 & @xmath192 & @xmath192    since @xmath295 , we deduce from the last column that @xmath296 as well .",
    "the only @xmath297 in the column for @xmath280 with @xmath298 yields @xmath299 and so on .",
    "we end up with @xmath300 which results in @xmath301 .",
    "property [ prop : power_sum_properties : lex ] of proposition [ prop : power_sum_properties ] is the main motivation for the following definition .",
    "[ def : treed_pc](cf .",
    "@xcite , def .",
    "5 ) a power @xmath30 circuit is called _ treed _ ( a convenient shorthand for `` reduced and equipped with additional data in the form of a tree '' ) , if    [ def : treed_pc : red ] @xmath43 is reduced ( i.e. , different nodes evaluate to different values and it is equipped with an ordered list @xmath302 and a bit vector , see definition [ def : reduced_pc ] )    [ def : treed_pc : tree ] @xmath43 is equipped with a directed tree @xmath213 in which each node has up to @xmath303 outgoing edges , labelled with pairwise distinct values from @xmath197 ( and ordered from left to right by increasing values ) . for",
    "each leaf in @xmath213 , the unique path from the root to this leaf must consist of exactly @xmath304 edges .",
    "the sequence of labels @xmath305 of such a path ( read from the leaf to the root ) corresponds to a marking @xmath306 . for all leaves",
    ", the power sum @xmath307 ( which evaluates to @xmath103 ) must be compact .",
    "any marking represented as a leaf in this way is called compact .",
    "[ def : treed_pc : comp ] all successor markings @xmath49 ( @xmath48 ) are compact .    [ def : treed_pc : mark ] any node @xmath164 that is contained in the support of some marking ( compact or not ) is not the top node of a maximal chain .",
    "[ def : treed_pc : lev ] for each level in the tree , there is a list containing the nodes of this level .",
    "figure [ fig : treed_circuit ] shows an example of a treed circuit ( for @xmath2 ) alongside the tree containing its markings .",
    "note that the order of the nodes is implicitly given by the lowest level of the tree .",
    "\\(e ) at ( 0,0 ) ; ( 0 ) at ( 0,-1 ) ; ( 00 ) at ( 0,-2 ) ; ( 00 m ) at ( -1.5,-3 ) ; ( 000 ) at ( 0,-3 ) ; ( 00p ) at ( 3.5,-3 ) ; ( 00m0 ) at ( -1.5,-4 ) ; ( 0000 ) at ( 0,-4 ) ; ( 000p ) at ( 2,-4 ) ; ( 00p0 ) at ( 3.5,-4 ) ; ( 00m0p ) at ( -1,-5 ) ; ( 00000 ) at ( 0,-5 ) ; ( 0000p ) at ( 1,-5 ) ; ( 000p0 ) at ( 2,-5 ) ; ( 00p0 m ) at ( 3,-5 ) ; ( 00p0p ) at ( 4,-5 ) ; ( e ) edge node[right ] @xmath297 ( 0 ) ( 0 ) edge node[right ] @xmath297 ( 00 ) ( 00 ) edge node[above left=-0.1 ] @xmath308 ( 00 m ) ( 00 ) edge node[right ] @xmath297 ( 000 ) ( 00 ) edge node[above right=-0.1 ] @xmath309 ( 00p )",
    "( 00 m ) edge node[right ] @xmath297 ( 00m0 ) ( 000 ) edge node[right ] @xmath297 ( 0000 ) ( 000 ) edge node[above right=-0.1 ] @xmath309 ( 000p ) ( 00p ) edge node[right ] @xmath297 ( 00p0 ) ( 00m0 ) edge node[right ] @xmath309 ( 00m0p ) ( 0000 ) edge node[left ] @xmath297 ( 00000 ) ( 0000 ) edge node[right ] @xmath309 ( 0000p ) ( 000p ) edge node[left ] @xmath297 ( 000p0 ) ( 00p0 ) edge node[left ] @xmath308 ( 00p0 m ) ( 00p0 ) edge node[right ] @xmath309 ( 00p0p ) ; ( u1 ) at ( -2,-4.5 ) @xmath137 ; ( u2 ) at ( -2,-3.5 ) @xmath310 ; ( u3 ) at ( -2,-2.5 ) @xmath311 ; ( u4 ) at ( -2,-1.5 ) @xmath312 ; ( u5 ) at ( -2,-0.5 ) @xmath313 ; ( li0 ) at ( -2.5,0 ) ; ( li1 ) at ( -2.5,-1 ) ; ( li2 ) at ( -2.5,-2 ) ; ( li3 ) at ( -2.5,-3 ) ; ( li4 ) at ( -2.5,-4 ) ; ( li5 ) at ( -2.5,-5 ) ; ( lt0 ) at ( 5,0 ) ; ( lt1 ) at ( 5,-1 ) ; ( lt2 ) at ( 5,-2 ) ; ( lt3 ) at ( 5,-3 ) ; ( lt4 ) at ( 5,-4 ) ; ( lt5 ) at ( 5,-5 ) ; ( li0 ) edge ( e ) ( e ) edge ( lt0 ) ( li1 ) edge ( 0 ) ( 0 ) edge ( lt1 ) ( li2 ) edge ( 00 ) ( 00 ) edge ( lt2 ) ( li3 ) edge ( 00 m ) ( 00 m ) edge ( 000 ) ( 000 ) edge ( 00p ) ( 00p ) edge ( lt3 ) ( li4 ) edge ( 00m0 ) ( 00m0 ) edge ( 0000 ) ( 0000 ) edge ( 000p ) ( 000p ) edge ( 00p0 ) ( 00p0 ) edge ( lt4 ) ( li5 ) edge ( 00m0p ) ( 00m0p ) edge ( 00000 ) ( 00000 ) edge ( 0000p ) ( 0000p ) edge ( 000p0 ) ( 000p0 ) edge ( 00p0 m ) ( 00p0 m ) edge ( 00p0p ) ( 00p0p ) edge ( lt5 ) ; ( m ) at ( -1,-5 ) @xmath42 ; ( lv1 ) at ( 0,-5 ) @xmath314 ; ( lv2 ) at ( 1,-5 ) @xmath315 ; ( lv3 ) at ( 2,-5 ) @xmath316 ; ( lv4 ) at ( 3,-5 ) @xmath317 ; ( lv5 ) at ( 4,-5 ) @xmath318 ;    the most time consuming step in extendreductionwas to find the position of a new node in the sorted list of @xmath31 . using binary search ,",
    "this took @xmath319 time .",
    "if @xmath31 is treed and @xmath49 is compact , we can improve this to @xmath161 : the position of the leaf corresponding to @xmath49 already tells the position of @xmath34 in @xmath31 . in order to adjust the bit vector",
    ", we have to read the paths from the root of the tree to the respective leaves and check the condition given by proposition [ prop : power_sum_properties ] [ prop : power_sum_properties : inc ] . yet , making a circuit treed is more complicated than just reducing it .    for the time analysis ,",
    "we use amortization with respect to a potential function @xmath320 , mapping power circuits to numbers , see 17.3 in @xcite . an algorithm on power circuits",
    "is said to run in amortized time @xmath321 , if the real running time is bounded by @xmath322 , where @xmath43 is the input and @xmath182 is the resulting circuit .",
    "thus , an algorithm may take longer than its indicated amortized time , as long as it decreases the potential by the same amount .",
    "the potential can be thought of as a debt which is accumulated whenever the algorithm does not terminate in time .    for a power circuit @xmath30 , the number of maximal chains",
    "is denoted @xmath323 .",
    "the _ potential _ of @xmath43 is @xmath324 .    in a situation where @xmath325 is a graph with an embedded power circuit @xmath326",
    ", we define @xmath327 and @xmath328 .",
    "[ lem : insert_node ] there is a procedure insertnode , which takes a treed power circuit @xmath30 and a compact marking @xmath42 in @xmath43 and which inserts a new node @xmath34 with @xmath145 into @xmath43 .",
    "insertnoderuns in amortized time @xmath107 .",
    "since @xmath42 is compact , the position of @xmath35 in the ordered list of nodes is determined by the position of the leaf corresponding to @xmath42 in the tree .",
    "the bit vector can be adjusted by comparing @xmath42 to the successor markings of the nodes immediately before and after @xmath35 .",
    "the tree has to be `` stretched '' by inserting a new level corresponding to @xmath35 .",
    "all edges on this level are labelled @xmath297 , since no marking contains the new node @xmath35 . using the lists of nodes of the same level",
    ", this takes @xmath107 time .",
    "the insertion of @xmath35 increases @xmath183 and in some cases also @xmath323 .",
    "thus , the potential grows by up to @xmath329 .",
    "incrementing a compact marking by @xmath79 is easier than doing the same with an arbitrary marking .",
    "let @xmath42 be a compact marking in a treed circuit , in which @xmath330 are the unique nodes with values @xmath79 and @xmath28 respectively ( assuming they exist ) .",
    "if @xmath331 , @xmath332 can be incremented directly . if @xmath333 , then @xmath334 thanks to compactness .",
    "set @xmath335 and increment @xmath336 .",
    "however , the resulting marking is not always compact .",
    "[ lem : compactify_marking ] there is a procedure compactifymarkingwhich , given an arbitrary marking @xmath42 in a treed circuit @xmath30 , computes a compact marking @xmath91 with @xmath337 in @xmath107 time .",
    "this is based on the following observation : if @xmath338 is a power sum , then in the corresponding compact power sum @xmath213 only the coefficients of @xmath339 can be non - zero .",
    "hence , for each individual chain @xmath340 , we can apply the algorithm from proposition [ prop : compactify_power_sum ] to the power sum defined by @xmath341 .",
    "note that a node for @xmath342 exists due to property [ def : treed_pc : mark ] of the treed circuit @xmath43 .",
    "strictly speaking , we have not proved that the resulting circuit is treed .",
    "in fact , condition [ def : treed_pc : mark ] demanding an unmarked node at the top of every chain might have been lost during compactification .",
    "we will fix this shortly . for now , we content ourselves with the observation that the problem does not arise when compactifymarkingis called during prolongbasechain . in this special case ,",
    "the successor marking of the new node with value @xmath343 only uses nodes with much smaller values from the base chain ( approximately the first @xmath344 ) .",
    "this shows :    [ cor : prolong_base_chain_treed ] the procedure prolongbasechaingiven in algorithm [ alg : prolong_base_chain ] can be adapted for treed power circuits .",
    "the amortized time complexity is @xmath107 .",
    "[ cor : increment_compact_marking ] there is a procedure incrementmarkingwhich , given a compact marking @xmath42 in a treed power circuit @xmath30 , computes a compact marking @xmath91 with @xmath345 and leaves @xmath43 treed .",
    "incrementmarkingtakes @xmath107 amortized time and increases the circuit size by @xmath346 .    as discussed above ,",
    "incrementing @xmath42 by @xmath79 only affects the two nodes with values @xmath79 and @xmath28 . as a consequence ,",
    "the compactification process of the incremented marking is limited to the base chain of @xmath43 .    in order to fulfill condition [ def : treed_pc : mark ] of definition [ def : treed_pc ] , we invoke prolongbasechainwhich creates a new node @xmath34 . if @xmath34 is the new top node of the base chain , we are done .",
    "otherwise the insertion of @xmath34 has linked two maximal chains , decreasing @xmath323 by one .",
    "we use the released potential to pay for the @xmath107 time used so far and repeat .    for treed circuits ,",
    "the procedure extendtreegiven in algorithm [ alg : extend_tree ] replaces extendreduction .",
    "[ alg : extend_tree ] compute a topological order @xmath152 .",
    "[ prop : extend_tree ] the procedure extendtreeis correct and runs in amortized time @xmath347 . the circuit growth @xmath156 is bounded by @xmath348 .    the basic structure of extendtreeis the same as that of extendreduction , so we focus on the differences .",
    "let @xmath159 . between cycles of the main loop ,",
    "we keep up the following invariants for all markings @xmath349 :    [ prop : extend_tree : inv_comp ] if the support of @xmath42 is completely contained in @xmath31 , @xmath42 is compact .",
    "[ prop : extend_tree : inv_top ] @xmath31 is treed . in particular , condition [ def : treed_pc : mark ] holds , which means that for all nodes @xmath350 , the top node of the maximal chain starting at @xmath35 is not marked by @xmath42 .    at the beginning ,",
    "both invariants are true by definition .",
    "the time complexity for finding @xmath168 in step [ alg : extend_tree : search ] is reduced to @xmath161 due to the representation of the markings in the tree .",
    "if @xmath31 contains no node with the same value as @xmath167 , we can insert it as we did in extendreduction . remember that @xmath351 is compact due to [ prop : extend_tree : inv_comp ] .",
    "the case when @xmath352 also ressembles extendreductionand has the same ( now amortized ) time bound .",
    "all markings @xmath42 whose support is completely contained in @xmath31 after the processing of @xmath167 must be made compact in order to regain [ prop : extend_tree : inv_comp ] .",
    "this is done in step [ alg : extend_tree : comp_marks ] .",
    "after that , we have to restore condition [ def : treed_pc : mark ] .",
    "using the same argument as in corollary [ cor : increment_compact_marking ] , step [ alg : extend_tree : restore_inv_top ] takes @xmath161 amortized time and causes the circuit to grow by at most @xmath353 nodes .",
    "together with step [ alg : extend_tree : prolong_chain ] , the overall circuit growth during extendtreeis bounded by @xmath348 .",
    "[ thm : make_tree](treed analogon of theorem [ thm : reduce ] ) there is a procedure maketreewhich given a power circuit @xmath30 and a list @xmath184 of markings in @xmath43 , returns a treed circuit @xmath185 and a list @xmath186 of compact markings in @xmath182 such that @xmath187 ( @xmath188 ) .",
    "maketreetakes @xmath354 time and the size of @xmath190 is bounded by @xmath355 .",
    "[ rem : pc_strategy](working with treed power circuits ) + the usual strategy when solving a problem using power circuits is to create one power circuit and keep all integers as markings in this circuit .",
    "the power circuit is kept in treed form in order that comparisons can be done efficiently at any time . for each arithmetic operation , the markings corresponding to the operands are cloned , and the operation ( addition or multiplication by a power of two ) is performed on the clones . finally , extendtreeis called with the set of clones as @xmath151 to regain a treed circuit .",
    "this takes @xmath194 time and this time bound also absorbs everything else done during the operation .    for an estimate of the time complexity of an entire algorithm , we need to keep track of the circuit size @xmath183 as well as the size @xmath356 of the supports of the markings .",
    "the latter is usually called the `` weight '' of the ciruit and determines the growth during each operation .",
    "the cost for one operation is @xmath357 .",
    "if we start with a comparatively small circuit and @xmath356 remains constant during the algorithm ( which is normally the case ) , then after @xmath358 operations the circuit size is bounded by @xmath359 and the time by @xmath360 . in our main application ",
    "the solution of the word problem in higman s group  @xmath358 will turn out to be quadratic and @xmath356 linear in the input size @xmath18 , leading to an @xmath8 time algorithm .",
    "seen from the outside , extendreductionand extendtreeas well as reduceand maketreebehave very much alike . in applications ,",
    "all four procedures are used as `` black boxes '' and of the resulting circuits only the weaker property of reducedness is used .",
    "therefore , in order to simplify nomenclature , we will speak of `` reduction '' and `` reduced '' circuits , subsuming both concepts .",
    "the reader may then choose whether to use the simpler reduction concept at the cost of logarithmic factors or to go through the more complicated procedures for treed power circuits with better asymptotic time complexity .",
    "although the main goal of this paper is to solve the word problem in higmans groups , we sidetrack briefly to present another generalization that is made possible by power circuits with arbitrary base @xmath1 .    the baumslag - gersten group is defined as @xmath361    this is an hnn extension of @xmath4 generated by @xmath362 and @xmath321 . replacing @xmath4 by @xmath3 ( for @xmath0 )",
    ", we get a family of generalized baumslag - gersten groups : @xmath363    [ thm : wp_bg ] the word problem for the generalized baumslag - gersten group @xmath364 is solvable in @xmath365 time .",
    "the proof of theorem [ thm : wp_bg ] is literally the same as that for @xmath25 which was given in @xcite and @xcite , except that the new base @xmath1 power circuits from section [ sec : pc ] are used .",
    "we generalize the groups @xmath11 defined in the introduction by replacing the underlying baumslag - solitar group @xmath4 by @xmath3 .",
    "[ def : higman_group ] the ( generalized ) higman group @xmath366 is defined as @xmath367    while @xmath368 ( @xmath369 ) retains all the important properties of @xmath10 ( infinite , huge compression , no non - trivial normal subgroup of finite index ) , this is not entirely true for @xmath366 in general .",
    "for example , for all @xmath12 , the homomorphism given by @xmath370 sends @xmath371 onto a finite non - trivial group .    in this section",
    ", we will prove :    [ thm : wp_hig ] let @xmath372 .",
    "the word problem for the generalized higman group @xmath366 can be solved in @xmath8 time .",
    "the key observation for the solution of the word problem is the decomposition of @xmath366 into a series of amalgamations of @xmath13 copies of the baumslag - solitar group @xmath373 , see @xcite .    @xmath374    where @xmath375 and in both cases @xmath376 is the subgroup generated by @xmath377 and @xmath378 , which in fact freely generate @xmath376 ( if @xmath6 ) .",
    "furthermore , we can break @xmath379 and @xmath380 down to @xmath381 where @xmath382 and the indices are read in @xmath383 .",
    "each group @xmath384 is a copy of the baumslag - solitar group @xmath3 and thus isomorphic to the semidirect product @xmath385\\rtimes{\\ensuremath{\\mathbb{z}}}$ ] which consists of pairs @xmath386\\rtimes{\\ensuremath{\\mathbb{z}}}$ ] .",
    "the isomorphism is given by @xmath387 and @xmath388 . in @xmath385\\rtimes{\\ensuremath{\\mathbb{z}}}$ ] , we have the following formulae for multiplication and inversion : @xmath389    when dealing with more than one group @xmath384 , we add @xmath130 as a subscript to those pairs designating an element of @xmath384 .    in order to solve the word problem for @xmath366",
    ", we first need a solution for the subgroup membership problem of @xmath390 in @xmath391 ( with @xmath392 ; this covers both @xmath379 and @xmath380 ) .",
    "furthermore , we have to do this in an effective way , i.e. , given a sequence of pairs @xmath393 which represents an element of @xmath390 , we have to find a corresponding sequence of pairs of the form @xmath394 and @xmath395 .",
    "we start by giving a reduction system @xmath396 for @xmath391 : @xmath397    the system @xmath396 is not confluent in general , but the following property holds :    [ prop : britton_g_1_f ] if @xmath398 is an @xmath396-reduced word that equals @xmath79 in @xmath391 , then @xmath398 is the empty word .",
    "this ressembles britton s lemma for hnn extensions .",
    "in fact , bass - serre theory provides a unifying notion ( and proof ) for both phenomena .",
    "we give no further proof here , but instead apply the system @xmath396 to the subgroup membership problem .",
    "let @xmath399 be the system @xmath396 extended by the rules @xmath400 where all @xmath401 .",
    "the new rules respect the group structure , and hence proposition [ prop : britton_g_1_f ] holds for @xmath399 as well .",
    "the new rules are not length - increasing , since @xmath392 .    starting with an arbitrary sequence @xmath398 of pairs @xmath393 representing an element in @xmath391",
    ", one can compute an equivalent @xmath399-reduced word @xmath402 with linearly many operations : first , compute an @xmath396-reduced word @xmath403 , then apply rules @xmath404 and @xmath405 . note that the latter leave @xmath403 @xmath396-reduced . only the second pair generated by either of these rules",
    "can be part of another application of @xmath404 or @xmath405 .",
    "therefore , @xmath403 can be @xmath399-reduced with one pass from left to right .",
    "let @xmath398 be a sequence of pairs @xmath393 which represents an element of the subgroup @xmath406 . if @xmath398 is @xmath399-reduced , then @xmath398 is already an alternating sequence of pairs of types @xmath394 and @xmath395 .",
    "let @xmath407 .",
    "we assume that @xmath408 and that @xmath403 contains no trivial pairs @xmath409 which makes @xmath403 @xmath396-reduced .",
    "the case where @xmath403 starts with @xmath410 is similar .",
    "the sequence @xmath411 equals @xmath79 in @xmath391 and must therefore @xmath396-reduce to the empty sequence .",
    "note that both @xmath412 and @xmath398 are @xmath396-reduced , so any @xmath396-reduction can only occur at the border between the two words .",
    "clearly , we can not have @xmath413 or else @xmath414 would be @xmath396-reduced .",
    "if @xmath415 , then a reduction of type @xmath209 is possible if @xmath416 and @xmath417 , in which case we get @xmath418 .",
    "but after that , the sequence is @xmath396-reduced since @xmath416 and @xmath417 imply @xmath419 .",
    "hence , we are left with @xmath420 . in that case",
    ", we get @xmath421 .",
    "if this is @xmath422 , we have @xmath423 and we proceed inductively with the remaining sequence .",
    "otherwise , we must have @xmath424 in order to continue applying rules .",
    "if @xmath425 , the next rule can only apply to @xmath426 , so @xmath427 and we get @xmath428 .",
    "again , the sequence is @xmath396-reduced unless @xmath429 .",
    "we iterate this argument until we arrive at @xmath430 on the way , we have found @xmath431 , and @xmath432 for @xmath433 .",
    "one further reduction of type @xmath207 brings us to @xmath434 since @xmath435 , the next reduction requires @xmath436 .",
    "thus , rule ( 6 ) of @xmath399 can be applied to the prefix @xmath437 of the original word @xmath398 .",
    "for the amalgamated product @xmath438 , a property similar to [ prop : britton_g_1_f ] holds :    [ prop : britton_h ] let @xmath439 be a non - empty sequence with @xmath440 or @xmath441 , alternatingly .",
    "if @xmath398 equals @xmath79 in @xmath366 , then @xmath442 for some index @xmath130 .",
    "[ alg : wp_hig ] rewrite the input @xmath398 by replacing each @xmath443 by @xmath444.[alg : wp_hig : init ] break @xmath398 into subsequences @xmath445 such that in each @xmath446 the subscripts of all pairs are either in @xmath447 or in @xmath448 .",
    "let @xmath449 . whether @xmath450 .    from this proposition",
    ", we can derive algorithm [ alg : wp_hig ] which solves the word problem in @xmath366 . in this algorithm , the word @xmath445 is split into @xmath451 and @xmath452 .",
    "the first part is an @xmath399-reduced alternating sequence of group elements from @xmath379 or @xmath380 with no @xmath453 ( @xmath454 ) being in the subgroup @xmath376 . in each loop cycle",
    "either @xmath321 increases , or @xmath321 decreases by one and at the same time , some @xmath453 is merged with @xmath455 , which means that @xmath358 decreases .",
    "thus , the loop is executed only linearly often .    in order to get a time bound for algorithm [ alg : wp_hig ] , it remains to show how to perform the tests arithmetic operations on the pairs @xmath393 efficiently .",
    "since power circuits are designed to work with integers , we have to avoid fractions for the first components of pairs @xmath456\\rtimes{\\ensuremath{\\mathbb{z}}}$ ] .",
    "therefore , we use the triple notation introduced in @xcite . for @xmath457 with @xmath458 , let @xmath459_i:=(u\\cdot q^x , x+k)_i\\in g_{i , i+1}.\\ ] ]    if @xmath151 , @xmath460 , and @xmath67 are markings in a base @xmath1 power circuit , we call @xmath461_i$ ] a triple marking and define its value by @xmath462_i\\in g_{i , i+1}$ ] .    any element of @xmath384 can be written as a triple , but not in a unique way .",
    "for instance , @xmath463_i=(2,0)_i=[4,-1,1]_i$ ] , if @xmath2 . the group operations translate to formulae for multiplication and inversion of triples : @xmath464\\cdot[v , y,\\ell]&=[u\\cdot q^{-y}+v\\cdot q^k , x+y , k+\\ell]\\cr      [ u , x , k]^{-1}&=[-u ,- k ,- x]\\end{aligned}\\ ] ] furthermore , @xmath465_i\\in{\\ensuremath{\\langle a_i\\rangle}}\\le g_{i , i+1}$ ] if and only if @xmath466 and @xmath467 .",
    "similarly , @xmath465_i\\in{\\ensuremath{\\langle a_{i+1}\\rangle}}\\le g_{i , i+1}$ ] if and only if @xmath468 , and finally @xmath465_i$ ] is the group identity if and only if @xmath468 and @xmath466 .    at the beginning of algorithm [ alg : wp_hig ] , we create a power circuit with base @xmath1 consisting of a single node @xmath34 with @xmath53 .",
    "we represent each pair @xmath393 by a triple marking .",
    "of the three markings in each initial triple , two are zero ( empty ) and the third has either value @xmath309 or @xmath308 and can be created using @xmath34 .",
    "let @xmath356 be the sum of the sizes of ( the supports of ) all these markings .",
    "we call @xmath356 the weight of the circuit . from the multiplication formula for triples",
    "we see that @xmath356 never increases during the algorithm , keeping in mind that after an operation we can `` forget '' the operand and just keep the result .",
    "the initial value of @xmath356 is exactly @xmath469 .",
    "after step [ alg : wp_hig : init ] , we reduce the circuit , which takes @xmath470 time . from now on ,",
    "we keep @xmath43 reduced following the strategy proposed in remark [ rem : pc_strategy ] .",
    "the swapping operation @xmath471 works in the following way for triples : @xmath464&\\mapsto      \\begin{cases }          [ 0,0,u\\cdot q^x]&\\text{if $ x =- k$ and $ q^x\\mid u$ and $ u\\ge 0$}\\cr          [ 0,u\\cdot q^x,0]&\\text{if $ x =- k$ and $ q^x\\mid u$ and $ u<0 $ }      \\end{cases}\\cr      [ 0,x , k]&\\mapsto[x+k,0,0]\\end{aligned}\\ ] ]    the whole algorithm computes @xmath161 many times an @xmath399-irreducible word .",
    "each of these computations necessitates @xmath161 arithmetic operations ( and subsequent calls to extendreduction ) .",
    "the circuit size remains bounded by @xmath472 .",
    "thus , one call of extendreductiontakes @xmath473 time .",
    "we get a total time bound of @xmath8 .",
    "this concludes the proof of theorem [ thm : wp_hig ] .",
    "we have shown that the word problem for the generalized higman groups @xmath366 is solvable in polynomial time .",
    "an important ingredient for this result was the extension of the power circuit data structure to arbitrary bases @xmath0 . from an algorithmic point of view , this is an interesting result in itself and may provide a useful tool in group theory as well as other areas .",
    "the techniques used in this paper do not apply to the even more general groups @xmath474 and @xmath475 , where the underlying baumslag - solitar group @xmath3 is replaced by @xmath476 for some @xmath477 .",
    "this is because @xmath478 is not a semi - direct product when @xmath479 .",
    "the word problem for these groups is open .",
    "note that even for @xmath15 the group @xmath474 can be non - trivial if @xmath479 ."
  ],
  "abstract_text": [
    "<S> this paper continues the 2012 stacs contribution by diekert , ushakov , and the author . </S>",
    "<S> we extend the results published in the proceedings in two ways .    </S>",
    "<S> first , we show that the data structure of power circuits can be generalized to work with arbitrary bases @xmath0 . </S>",
    "<S> this results in a data structure that can hold huge integers , arising by iteratively forming powers of @xmath1 . </S>",
    "<S> we show that the properties of power circuits known for @xmath2 translate to the general case . </S>",
    "<S> this generalization is non - trivial and additional techniques are required to preserve the time bounds of arithmetic operations that were shown for the case @xmath2 .    </S>",
    "<S> the extended power circuit model permits us to conduct operations in the baumslag - solitar group @xmath3 as efficiently as in @xmath4 . </S>",
    "<S> this allows us to solve the word problem in the generalization @xmath5 of higman s group , which is an amalgamated product of four copies of the baumslag - solitar group @xmath3 rather than @xmath4 in the original form .    as a second result </S>",
    "<S> , we allow arbitrary numbers @xmath6 of copies of @xmath3 , leading to an even more generalized notion of higman groups @xmath7 . </S>",
    "<S> we prove that the word problem of the latter can still be solved within the @xmath8 time bound that was shown for @xmath9 .    </S>",
    "<S> keywords : data structures ; compression ; algorithmic group theory ; word problem . </S>"
  ]
}