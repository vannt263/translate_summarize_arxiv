{
  "article_text": [
    "let @xmath8 be the @xmath9-atom boolean lattice , i.e. , the partially ordered set of subsets of @xmath10=\\{1,2,\\ldots , n\\}$ ] , ordered by inclusion .",
    "the hasse diagram of @xmath8 is isomorphic to the @xmath9-cube , whose vertices are the @xmath9-bit binary numbers , with two numbers adjacent if they differ in one bit position ( figure  [ mm2_5 ] )",
    ". the @xmath11th level of @xmath12 can thus be viewed as the set of @xmath9-bit binary numbers with @xmath11 ones .",
    "the _ middle levels  problem _ is to determine if there is a hamilton cycle in the subgraph @xmath0 of @xmath13 induced by the middle levels  @xmath4 and @xmath14 .",
    "the heavier lines in figure  [ mm2_5 ] show a hamilton cycle in @xmath15 .",
    "the graph @xmath0 gained notoriety as an example of a connected , vertex transitive graph , all of which were conjectured by lovsz @xcite to have hamilton paths .",
    "the middle levels  problem remains open , in spite of the efforts of many @xcite . in 1990 , in unpublished work , moews and reid verified that @xmath0 is hamiltonian for @xmath16 . in 1999",
    ", we extended this for @xmath17 @xcite . in this note",
    "we announce that @xmath6 and @xmath7 are hamiltonian .",
    "the new results are due to an algorithmic improvement that made it possible to find a hamilton path in a reduced graph of complementary necklace pairs having 129,644,790 vertices , using a 64-bit personal computer .     showing a hamilton cycle in @xmath15 . ]",
    "it is known that any connected vertex transitive graph @xmath18 with @xmath19 vertices has a cycle of length at least @xmath20 @xcite . for @xmath0 , the best absolute lower bound",
    "is given by the following theorem in @xcite .",
    "[ thm : savagewinkler ] the middle levels graph , @xmath0 , has a cycle of length at least @xmath21 if for every @xmath22 , @xmath23 has a hamilton cycle .",
    "since our new results show @xmath0 hamiltonian for @xmath24 , it follows that @xmath0 has a cycle of length at least @xmath25 .",
    "recently , it was shown that @xmath0 is `` asymptotically hamiltonian '' in the following sense @xcite : _ there is a constant @xmath26 such that for all @xmath4 , @xmath0 has a cycle of length at least @xmath27 . _ in the other direction , it has been shown that @xmath0 has a closed spanning walk in which no edge and no vertex occurs more than twice @xcite .    in section  [ sec : middle2prob ] we describe a reduction of the problem which lessens the memory and computation requirements . in section  [ sec : oldheur ]",
    "we review the hamilton cycle heuristic ( ss ) from  @xcite . in section  [",
    "sec : newheur ] we describe the improved sss heuristic which made the present results possible .",
    "we sketch here the reduction of the middle levels  problem that was was used in the earlier work of dejter  @xcite and of moews and reid .    given a string @xmath28 of @xmath9 symbols ,",
    "define the cyclic shift @xmath29 by @xmath30 let @xmath31 and for @xmath32 , @xmath33 .",
    "define a relation @xmath34 on the set of @xmath9-bit binary numbers ( regarded as @xmath9-bit strings ) by @xmath35 if and only if @xmath36 for some integer @xmath11 .",
    "the relation @xmath37 is an equivalence relation and the equivalence classes are called _",
    "necklaces_. denote the necklace of @xmath38 by @xmath39 .",
    "fix @xmath40 .",
    "we use necklaces to define a quotient graph of the middle levels graph @xmath41 .",
    "let @xmath42 be the graph whose vertices are the necklaces of the vertices of @xmath41 ( i.e. , necklaces of @xmath2-bit strings with @xmath4 or @xmath14 ones ) .",
    "the edges of @xmath42 are those pairs @xmath43 such that @xmath44 for some @xmath45 . note that the necklace of a @xmath2-bit binary number with @xmath4 or @xmath14 ones has exactly @xmath2 elements , so @xmath42 is smaller than @xmath41 by a factor of @xmath9 .",
    "the _ complement _ @xmath46 of a binary digit @xmath47 is 1 if @xmath48 and 0 if @xmath49 .",
    "extend this to binary strings by bitwise complement and to necklaces by by @xmath50 .",
    "note that this is well - defined since @xmath51 if and only if @xmath52 .",
    "we use these complementary necklace pairs to further reduce the problem size by a factor of 2 by observing that @xmath53 if and only if @xmath54 .",
    "now define an equivalence relation @xmath55 on the necklaces in @xmath56 by @xmath57 if either @xmath58 or @xmath59 and denote the equivalence class of @xmath55 containing @xmath60 by @xmath61 . since every string in @xmath60 has odd length , @xmath62 , and every equivalence class @xmath61 has exactly 2 elements .",
    "construct the reduced graph , @xmath63 , whose vertices are the equivalence classes @xmath64 with edges @xmath65 if @xmath66 or @xmath67 .",
    "observe that if @xmath68 then @xmath69 , and so @xmath70 .",
    "hence @xmath71 and @xmath63 has loops , so it is not a simple graph .",
    "we exploit the fact that @xmath63 has loops to show that a hamilton path from the distinguished vertex @xmath72 to the distinguished vertex @xmath73 in @xmath63 can be used to construct a cycle in @xmath42 which can be lifted to a cycle in @xmath41 .",
    "the path in @xmath63 gives rise naturally to a pair of paths in @xmath42 where corresponding pairs of vertices from each path are complements of each other .",
    "because the distinguished vertices in @xmath63 each have incident loops , these paths link to form a cycle in @xmath42 .",
    "finally , since @xmath4 and @xmath2 are relatively prime , we can use suitably chosen necklace representatives to extend the cycle in @xmath42 to a cycle in @xmath41 . the case for @xmath15 is illustrated in figure  [ reductionfig ] , where for @xmath74 , @xmath75 $ ] denotes the necklace @xmath76 and for necklace @xmath77 , @xmath78 denotes @xmath61 in @xmath79 .",
    "given a graph @xmath18 and vertices @xmath80 we would like to find , if possible , a hamilton path starting at @xmath81 and ending at @xmath82 .",
    "a standard backtrack search attempts to construct such a path by starting at @xmath81 and extending the path to a new vertex as long as possible . whenever it is impossible to further extend the path from a vertex @xmath38 , the search `` backs up '' to the predecessor , @xmath83 , of @xmath38 on the path and the path is extended ( if possible ) from @xmath83 to one of its other neighbors .",
    "figure  [ rot1 ] illustrates a path @xmath84 from a starting vertex @xmath81 to a vertex @xmath85 whose only neighbors in @xmath18 are @xmath81 , @xmath38 and @xmath86 , which are already on @xmath84 . in this case , backtrack search would back up to @xmath87 , then @xmath86 and eventually back to @xmath88 , at which time @xmath82 would be added to the path .",
    "has reached @xmath85 and can not continue . ]",
    "psa  @xcite observed that reaching a dead end in backtrack search could be used as an opportunity to modify the current path by a _ rotation _ and thus possibly to continue .",
    "if @xmath89 is a path in @xmath18 and there is an edge @xmath90 for some @xmath91 , then the _ rotation of @xmath92 at @xmath93 _ is the path @xmath94 obtained by deleting edge @xmath95 from @xmath84 and inserting @xmath96 .",
    "path @xmath97 has the same length as @xmath84 , but a different endpoint .",
    "figure  [ bad1:a ] shows the rotation at @xmath38 of the path in figure  [ rot1 ] .",
    "define _ posasearch _ to be the hamilton path heuristic which constructs a path @xmath84 by starting at a vertex @xmath81 and iterating the following : extend @xmath84 , avoiding @xmath82 until the end , until no longer possible ; when @xmath84 can not be extended from an endpoint @xmath85 , select a neighbor @xmath86 of @xmath85 and perform a rotation of @xmath84 at @xmath86 .",
    "posasearch may not succeed in finding a hamilton path even if one exists .",
    "furthermore , it may run indefinitely .    for the path @xmath84 in figure  [ rot1 ]",
    ", posasearch can only transform @xmath84 into one of the paths shown in figure  [ bad1 ] .",
    "none of these transformations will ever allow the vertex , @xmath82 , to be added to the path .",
    "rotations transform a path and alter the order of vertices on it . for a path @xmath84 , let @xmath98 be the @xmath11th vertex of @xmath84 ,",
    "let @xmath99 be the position of vertex @xmath86 on @xmath84 , and let @xmath100 be the number of vertices on @xmath84 . if @xmath84 is a path with endpoint @xmath85 and if @xmath101 is adjacent to @xmath85 , we can rotate @xmath84 at @xmath101 to arrive at a new path @xmath97 . the position of a vertex @xmath86 on @xmath97",
    "is then given by @xmath102 similarly , the vertex now in position @xmath11 on @xmath97 is @xmath103    the ss heuristic from @xcite uses a variation of posasearch that looks ahead before performing any rotation .",
    "ss extends the path as is done in posasearch until all neighbors of the endpoint are already on the path .",
    "if the path is not already a hamilton path , it then uses breadth - first search ( bfs ) , and repeated application of eqs .",
    "( [ eq : newpos ] ) and ( [ eq : newsucc ] ) to search for a sequence of one or more rotations guaranteed to result in a path which can be further extended .",
    "if such a sequence is found , the sequence of rotations is performed and the path is extended .",
    "if no such sequence exists , the ss heuristic terminates without having found a hamilton path .",
    "figure  [ bad1 ] shows four paths obtainable by one or more rotations from the path shown in figure  [ rot1 ] , in this example , there are only four possible endpoints , @xmath85 , @xmath86 , @xmath87 , and @xmath38 .",
    "the path can not be extended from any of these , so ss would terminate after evaluating all four .",
    "the original work on the ss heuristic @xcite used a 400mhz intel pentium - ii system with 192 mb ram .",
    "results were later run on a 2.4ghz intel pentium 4 system with 512 mb of ram ( see  @xcite).we recently acquired an amd athlon 3500 + system with 2 gb of ram and converted the program to use 64-bit values for most internal computations . with this system and the ss heuristic",
    "we were able to find a hamilton path in @xmath104 in about 3.5 weeks .",
    "the program ran entirely in memory , using approximately 1 gb of ram .",
    "however , it was unlikely that @xmath105 would be feasible .    therefore , using performance profiling tools , we analyzed the code performance and discovered that , contrary to expectations , a large part of the time was spent on performing the rotation operations , rather than on the bfs to find promising sequences of rotations . as a result , we made the following changes to the heuristic that resulted in dramatic speed improvements .    first , when bfs finds a sequence of rotations that will enable an extension of the path , instead of actually performing each rotation of the path the sss heuristic encodes the sequence of rotations as a list of ordered pairs , each representing the number of vertices on the path at time of rotation and the rotation point .",
    "this list , together with repeated application of eqs .",
    "( [ eq : newpos ] ) and ( [ eq : newsucc ] ) , suffices to calculate the actual vertex in a given position or the current position of a given vertex , when the sequence of rotations represented by the list of ordered pairs has not been explicitly performed .",
    "secondly , the sss heuristic periodically ( but rarely ) goes ahead and performs all the rotations encoded by the list of ordered pairs .",
    "given a path @xmath106 , if we perform a rotation at @xmath107 to make @xmath108 the new endpoint , then there is a section of @xmath109 vertices up to @xmath107 that will not be moved and a section of @xmath110 vertices after @xmath107 that will be reversed .",
    "we may describe each of these sections ( or _ blocks _ ) of the path by a triple , @xmath111 , where @xmath81 is the index of the first vertex in the block , @xmath9 is the number of vertices in the block and @xmath112 is a direction indicating whether the block is now in original ( forward ) order or reversed .",
    "our single rotation at @xmath107 is represented by the triples @xmath113 and @xmath114 .",
    "as we process a rotation from the list of ordered pairs we first add a block in the forward direction , representing any vertices added by extension since the last rotation .",
    "next we determine the block containing the new endpoint and ( possibly ) split it into two blocks .",
    "all blocks before the new endpoint remain unchanged , while the sequence of blocks after the new endpoint , as well as the direction indicator of each such block , is reversed .",
    "after the list of blocks has been created representing all the stored rotations , the path can be copied block by block to effect the series of rotations in a single copy operation .",
    "these modifications allow a sequence of rotations to be accumulated , without being performed , at the relatively smaller cost of increasing time for calculation of vertex position or vertex in a given position .",
    "the accumulated sequence of rotations is performed on a schedule discussed in the next subsection .",
    "this significantly reduced the average work per rotation .",
    "figure  [ blockfig ] illustrates the process for a list of three rotations , as seen in one run of the program .",
    "the subscripts in each block indicate the order of creation of the block . for computational convenience , a rotation point , @xmath86 , is actually represented in the list of rotations by its position on the path .",
    "ll +   + & create initial block 0 + & + & split block 0 , into blocks 0 and 1 + & + & rotate block 1 + & +   + & add block 2 + & + & split block 0 , into blocks 0 and 3 + & + & rotate blocks 3 through 2 + & +   + & add block 4 + & + & split block 3 , into blocks 3 and 5 + & + & rotate blocks 5 and 4 + & +   + & @xmath115,@xmath116,@xmath117,@xmath118,@xmath119,@xmath120      in the middle levels of @xmath121 , the reduced graph , @xmath105 , has over 129 million vertices .",
    "an array of 32-bit integers with one entry per vertex takes approximately half a gigabyte of memory .",
    "our system had only 2 gb of ram , so storage for basic information on vertices and paths was limited . in this environment , it is infeasible to store adjacency lists , so we recalculate adjacency lists as needed rather than storing them ( see  @xcite ) .",
    "we reduced all arrays to the smallest native size ( char , short , int , or long ) that was sufficient for the data and still experienced unacceptable levels of memory swapping .",
    "the vertices of @xmath105 are represented by the lexicographically least elements ( as sets ) of each @xmath122-bit necklace with @xmath123 ones .",
    "thus the two higher order bits will always be 0 and we need only use 33 bits for the internal representation . however , we store the lower 32 bits in 32-bit integer arrays and add the high - order bit according to the position of a vertex in the array",
    ". this saves half a gigabyte of ram as compared to using 64-bit long integers .",
    "we still use 64-bit long integers for internal calculations , but none of our major storage arrays needs larger than 32-bit entries .    when copying the path to execute a series of rotations , we copy it to the position array ( pos ) and then rebuild the position array after the copy as this results in less swapping than using memory that has not recently been referenced , such as the parent array used in building a bfs tree .",
    "fine tuning in this way resulted in the program using approximately 85% to 90% of the cpu for most of the run while finding a path in @xmath105 .",
    "somewhat higher cpu usage was observed toward the end of the run , even though bfs trees , with their storage requirement , were being computed much more frequently .",
    "the sss heuristic was applied to search the reduced middle levels graphs @xmath124 , @xmath125 , to try to find a hamilton path from vertex @xmath126 to vertex @xmath127 , and therefore a hamilton cycle in @xmath128 .",
    "a hamilton path meeting these requirements was found for each @xmath129 .",
    "the results are summarized in table  [ runtimes ] .",
    "we measured elapsed time using a timer with a resolution of 1 second .",
    "runs that start and complete in the same second show a time of 0 seconds .",
    "table  [ runtimes ] also shows earlier results obtained with the ss heuristic on a 2.4ghz intel pentium 4 system with 512 mb of ram .",
    "many factors affect the difference in performance between the two systems , including operating system and compiler differences as well as processor , ram , and disk speed . the newer system ran the ss heuristic approximately twice as fast as the older system .",
    "thus for @xmath5 , the largest value for which we have both results , we see that hardware doubled the speed and the switch to the sss algorithm achieved a further 16-fold increase .",
    "as noted earlier , the deferral of rotations also involves a cost .",
    "we experimented with the number of deferred rotations using values ranging from @xmath130 to @xmath131 .",
    "our results were obtained using a value of @xmath131 , or 11,387 for the reduced graph , @xmath105 .",
    "there is some evidence to suggest that a small performance improvement could be obtained by varying this number during the running of the program , particularly in very large graphs .",
    "i.  shields , c.  d. savage , a hamilton path heuristic with applications to the middle two levels problem , in : proceedings of the thirtieth southeastern international conference on combinatorics , graph theory , and computing ( boca raton , fl , 1999 ) , vol . 140 , 1999 , pp ."
  ],
  "abstract_text": [
    "<S> the middle levels  problem is to find a hamilton cycle in the middle levels , @xmath0 , of the hasse diagram of @xmath1 ( the partially ordered set of subsets of a @xmath2-element set ordered by inclusion ) . </S>",
    "<S> previously , the best known , from @xcite , was that @xmath3 is hamiltonian for all positive @xmath4 through @xmath5 . in this note </S>",
    "<S> we announce that @xmath6 and @xmath7 have hamilton cycles . </S>",
    "<S> the result was achieved by an algorithmic improvement that made it possible to find a hamilton path in a reduced graph ( of complementary necklace pairs ) having 129,644,790 vertices , using a 64-bit personal computer .    </S>",
    "<S> hamilton cycles , middle levels , boolean lattice , necklaces </S>"
  ]
}