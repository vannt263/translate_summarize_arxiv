{
  "article_text": [
    "dft is the base of modern signal and information processing .",
    "no dft , no modern signal and information processing @xcite .",
    "let    @xmath4 = \\left ( \\begin{array}{c } \\overrightarrow{w_{0 } } \\\\ \\overrightarrow{w_{1 } } \\\\ \\vdots \\\\",
    "\\overrightarrow{w_{n-1}}% \\end{array}% \\right )   \\label{eqdftmatrix}\\ ] ]    , where @xmath5 and @xmath6 , @xmath7 , @xmath8 , @xmath9 is the line vector of the matrix .",
    "the matrix @xmath10 defined in eq.[eqdftmatrix ] is called * fourier transform matrix * @xcite .",
    "* 1-dimensional dft ( 1d dft ) * @xcite is defined as    @xmath11    , where vector @xmath12 , @xmath13 ( @xmath14 denotes the transpose of vector ) , and @xmath15  denotes the inner product between two vectors .",
    "each component of vector @xmath16 is called * fourier coefficient*.    for any input matrix @xmath17_{n\\times n}$ ] , * 2d dft * @xcite is defined as @xmath18 , where @xmath19 denotes the matrix of dft coefficients .",
    "dft has two important properties , that will be applied to design quantum algorithm in this paper .",
    "one property is that dft is energy conservation transform ( i.e. , @xmath20 , or @xmath21 ) .",
    "the other property is that , typical data sequence , such as digital image , has high redundance , many of its dft coefficients have values close to zero , and these coefficients can be discarded without seriously affecting the estimated value of @xmath22 ( e.g. , without seriously affecting the quality of the restored image ) .",
    "therefore , inverse dft acting on the few big coefficients retained can restore the original data approximatively .",
    "fig.figdft shows the properties of dft .",
    "fast fourier transforms ( fft ) with time complexity @xmath0 and @xmath23 for 1d and 2d dft respectively were presented at 1965 @xcite . and",
    "the desire for designing more fast dft algorithm is still very strong .",
    "however , there is no more fast algorithm is presented up till now .",
    "classical computation can not improve the efficiency of dft any more maybe , and the principle of classical computation becomes the bottleneck of designing fast dft algorithm maybe .",
    "can quantum computation be applied to design more fast dft algorithm with classical output to break the bottleneck ?      * introduction of quantum fourier transform ( qft ) : * qft shor , galindo on an orthonormal basis @xmath24 , @xmath25 , @xmath8 , @xmath26 is defined to be a linear operator @xmath27 .",
    "qft is the key of the famous shor s order - finding and factoring algorithm shor .",
    "qft has time complexity @xmath28 .",
    "however , qft is not suitable to signal and information processing because the result of dft defined in eq.[eq1ddft ] ( or eq.[eq2ddft ] ) can _ not _ be generated and measured out by this qft @xcite .",
    "* introduction of * * grover s algorithm : * grover s algorithm @xcite solves the problem of searching for an element with a unique index @xmath29 in a list of @xmath30 unsorted elements , similar to searching a database like a telephone directory when we know the number but not the person s name @xcite .",
    "grover s algorithm has time complexity @xmath31 @xcite .",
    "long proposes a modified grover s algorithm , that has the probability of success 100% even for the case that the number of elements is very small @xcite .",
    "boyer , brassard , h@xmath32yer , and tap present the modified grover s algorithm named bbht algorithm in this paper for the case that the number of solutions is unknown @xcite .",
    "bbht algorithm is a very smart algorithm because it saves many quantum circuits .    *",
    "introduction of quantum loading scheme * @xmath33 @xcite * * : * * grover s algorithm has the function that find the index @xmath29 of a special database record @xmath34 from the index superposition of state @xmath35 .",
    "and the record @xmath34  is the genuine answer wanted by us .",
    "however , the corresponding record @xmath34 can not be measured out unless the 1 - 1mapping relationship between index @xmath36 and the corresponding record @xmath37 is bound in the entangled state @xmath38 .",
    "that is , we need a unitary@xmath39operation @xmath40 to load all records that are stored in a classical database into quantum state .",
    "the function of unitary@xmath39operation @xmath33 can be described as @xmath41    , where ancillary state @xmath42 is known .",
    "pang proposes a design method of the unitary operation @xmath33 , that has time complexity @xmath43 ( unit time : phase transform and flipping the qubits of registers ) @xcite .",
    "operator @xmath33 is so fast that its running time can be ignored when analyzing the time complexity of a algorithm .",
    "* introduction of quantum search algorithm with complex computation ( i.e. , the method of rotation at subspace ) @xcite : *    grover s algorithm can find a database record according to the given index .",
    "however , database search is complex in general .",
    "e.g. , police often hopes to find a mug shot from the database in which many sample photos are stored by the method of matching every sample photo and the photo captured by the vidicon at the entrance of airport real - time .",
    "grover s algorithm is invalid for this kind of search case because the coupling between search and other computation ( e.g. , image matching ) is required at this case .",
    "pang et.al .",
    "presents a quantum method named `` * * rotation at subspace * * '' qvq1,qdct , qvq2,qic to generalize grover s algorithm to the search case with arbitrary complex computation , that is derived from the research of quantum image compression @xcite .",
    "the method of rotation at subspace is described as following briefly :    first , all input datum are stored in classical memory as database records .",
    "assume that total number of records is @xmath30 .",
    "all these records can be loaded into a superposition of state using quantum loading scheme @xmath33 .",
    "second , construct the * general grover iteration ( ggi ) * @xmath44 as    @xmath45    , where @xmath46 denotes computation oracle such as image matching , @xmath47denotes the judge function ( i.e. , if the output of @xmath46 satisfies some conditions , let @xmath48 , else @xmath49),@xmath50 is the oracle of the judge function , and @xmath51 .",
    "third , similar to grover s algorithm , let unitary operation @xmath44 act on initial state @xmath52 @xmath53 times , we will find the optimal solution .",
    "* first , construct the following data structure ( ds ) and unitary operations :*    * ds1 . *",
    "save dft matrix @xmath54 defined in eq.[eqdftmatrix ] in classical memory as a database . and",
    "each line vector @xmath55 of the matrix is regard as a record , and these records have indices @xmath56 .    * ds2 . * construct six registers that have data format @xmath57 . that is ,",
    "1st , 2nd , 3rd , 4th , 5th , and 6th register are used to save input parameter @xmath58 , input parameter @xmath59 , input vector @xmath60 , index @xmath36 , line vector @xmath55 , and squared inner product respectively .",
    "* design oracle @xmath61 to compute the squared inner product between vector @xmath55 and @xmath62 , i.e. ,    @xmath63    we can design very simple parallel circuit to calculate squared inner product , and has time complexity @xmath64 , where @xmath65 and @xmath66 denote the unit running time of multiplication and addition respectively . because addition is more fast than multiplication",
    "( @xmath67 in general ) and @xmath68 in general , the running time of @xmath69 can be regarded as few times of multiplication ( i.e. , @xmath70 ) .",
    "* design oracle @xmath71 :    @xmath72    , where @xmath731@xmath74if@xmath74()^2@xmath750@xmath76 .",
    "oracle @xmath71 is used to mark the dft coefficients @xmath77 that satisfy the condition @xmath78 .",
    "define 1d  qdft  iteration @xmath79 :    according to eq.[eqgeneralgroveriteration ] ,  1d  qdftiteration  @xmath79  is    @xmath80    * second , design the following subroutine 1 to find a coefficient * @xmath81 * *  that satisfies the condition * * @xmath82 * * : * *    * subroutine 1 : *    * step1 . * initialize @xmath83 and set @xmath84 .",
    "( any value of @xmath85 strictly between 1 and 4/3 would do . )    * step2 . *",
    "choose @xmath86 uniformly at random among the nonnegative integers smaller than @xmath87 .",
    "* apply @xmath86 iterations of @xmath79  acting on initial state latexmath:[$|\\psi _ { 0}\\rangle = \\frac{1}{\\sqrt{n}}|\\alpha \\rangle |\\beta \\rangle |% \\overrightarrow{x}\\rangle ( \\sum\\limits_{i=0}^{n-1}|i\\rangle ) |0\\rangle     * step4 . *",
    "observe the 4th register : let @xmath29 be the outcome .",
    "* step5 . * calculate value @xmath89 using classical computation .",
    "if @xmath90 , preserve @xmath29 , and exit .",
    "* otherwise , set @xmath87 to @xmath91 and go back to step 2 .",
    "subroutine 1 is similar to bbht algorithm @xcite , and the main difference between them is that grover iteration is replaced by 1d  qdftiteration @xmath79 that realizes the coupling between quantum search and the computation of inner product .",
    "subroutine 1 has time complexity @xmath92 @xcite , where @xmath93 denotes the number of coefficients @xmath94 that satisfy the condition @xmath95 .    *",
    "third , design the following 1d qdft algorithm : *    * step 0 .",
    "* let @xmath96 , @xmath97 , @xmath98 , @xmath99 .",
    "we can design a very simple parallel circuit to calculate value@xmath100 , and the parallel circuit has computation complexity @xmath101 ( unit time : multiplication ) approximately .    *",
    "generate the initial state @xmath102 .",
    "this can be achieved in @xmath103 steps using a @xmath104 hadamard transform , which is so fast that the running time can be ignored .    * step 2 .",
    "* while(@xmath105 )    , where @xmath106 is the given threshold .    \\",
    "{    * step 2.1 : * apply subroutine 1 to find a coefficient @xmath107=% \\overrightarrow{w_{i_{0}}}\\bullet \\overrightarrow{x}$ ] that satisfies the condition @xmath108)^{2}\\leq \\beta $ ] ;    * step 2.2 : * if the dft coefficient @xmath107 $ ] is the result that is not be found previously by this algorithm , preserve it , and let @xmath109)^{2}$ ] , @xmath110 , @xmath111 , and @xmath112 , where @xmath58 denotes the average residual energy per dft  coefficient which is not be obtained still by this algorithm , @xmath113 denotes the total residual energy that is preserved by the dft coefficients which are not be obtained still by this algorithm , and @xmath114 denotes the number of the coefficients which have been obtained by this algorithm .    }",
    "it s the main idea of step 2.1 that apply subroutine 1 to find a coefficient which energy is bigger than the average residual energy ( i.e. , value @xmath115 ) and smaller than the total residual energy ( i.e. , value @xmath59 ) .",
    "because dft is energy conversation transform ( i.e. , @xmath116 ) , the stop criterion @xmath105 shows that the above algorithm will find all big coefficients that preserve nearly all energy and information if threshold @xmath106 is enough small .",
    "in addition , almost signal sequences have high redundance and the main task of dft is to find and retain big coefficients to eliminate this redundance ( see fig.[figdft ] ) .",
    "therefore , 1d qdft algorithm realizes 1d dft computation approximately .",
    "1d qdft has time complex @xmath117 approximately , where @xmath87 denotes the number of the big coefficients .",
    "because signal sequences have high redundance in general , the case @xmath118 often happens ( see fig.[figdft ] ) .",
    "thus , we regard 1d qdft has time complexity @xmath53 ( unit : multiplication and addition ) , while classical 1d fft has time complexity @xmath119 ( unit : multiplication and addition ) and even parallel dft computation has time complexity @xmath3 .",
    "qdft can process long signal sequence at a time , while classical computer requires that long signal sequence must be divded into many small sections ( such as @xmath120 or @xmath121 section ) on which dft acts sequentially to evade the efficiency bottleneck of loading data @xcite .",
    "2-d dft ( see eq.[eq2ddft ] ) is a separable linear transformation .",
    "that is , the result of 2-d dft may be obtained by first taking transforms along the columns of @xmath122 and then along the rows of that result @xcite .",
    "that is , @xmath123 .",
    "we define @xmath124 , where @xmath55 is the line vector of matrix @xmath10 and @xmath125 is the column vector of input matrix @xmath122 .",
    "the main task of 2d qdft is to calculate out matrix @xmath126 and matrix @xmath127 ( i.e. , @xmath19 ) .",
    "2d qdt is described as following :    * first , * construct the following data structures ( ds ) and unitary operations :    * ds1 : * store all of line vector @xmath55 in a database , and each index of line vector is denoted by @xmath36 .",
    "store all of column vector @xmath128 of matrix @xmath122 in the database , and each index of column vector is denoted by @xmath86 .    * ds2 : * construct seven registers that has data format @xmath129 .",
    "* ds3 : * design two loading operation @xmath130 and @xmath131 according to eq.[equl ] and ref.@xcite , where @xmath130 and @xmath131 are applied to load vector @xmath55 and @xmath132 into registers from classical database respectively .",
    "that is ,    @xmath133    * ds4 : * design oracle @xmath134 to calculate squared inner product . that is ,    @xmath135    * ds5 : * design oracle @xmath136 :    @xmath137    , where @xmath1381@xmath74if@xmath74()^2@xmath750@xmath76 .",
    "* ds6 : * design 2d qdft iteration @xmath139 :    @xmath140    , where @xmath141 .    *",
    "second , * generate the initial state @xmath142 . and apply the method of 1d qdft , we will calculate out all elements of matrix @xmath126 .",
    "apply the same method again , we can calculate out all elements of matrix @xmath19 .",
    "2d qdft has time complexity @xmath3 , while classical 2d fft has time complexity @xmath143 .",
    "for the given two n - dimensional vectors @xmath144 and @xmath145 , let @xmath146 , where @xmath147",
    ". then vector @xmath148 is called the * periodic convolution of vectors * @xmath149 * *  and * * @xmath150 .",
    "we often denote the convolution by symbol @xmath151 .",
    "if @xmath149 and @xmath150 have different dimensions , add zero components to each vector such that both vectors have the same dimension .",
    "the periodic convolution of the new vectors can be regarded as the result .",
    "algebraically , convolution is the same operation as multiplying the polynomials whose coefficients are the elements of @xmath149 and @xmath150 @xcite .",
    "holding the view of signal processing , we can regard vector @xmath152 as input signal sequence and vector @xmath150 is the function of a physical apparatus .",
    "after vector @xmath149 passing through the apparatus , convolution @xmath153 is came out .",
    "furthermore , the output sequence @xmath153 becomes smoother than the input sequence @xmath149 in general .",
    "therefore , convolution is very important for signal or information processing @xcite .      in general ,",
    "the big coefficients of @xmath155 are few and other coefficients have little contribution to the result .",
    "that is , we can calculate only big coefficients of @xmath156 and @xmath157 and discard small coefficients to speedup the computation of convolution . according to this property , *",
    "quantum algorithm for convolution estimation * is described as following :          it should be noticed that the efficiency of the above algorithm depends on the redundancy ( or smooth property ) of the signal sequences .",
    "the more higher the redundancy is , the more fast the quantum algorithm runs .",
    "fortunately , many digital signal sequences have high redundancy , that is just the existence reason of modern signal processing technique .    the first author thanks his teacher prof .",
    "guo and the key lab . of quantum information , ustc",
    ", p. r. of china for the author is brought up from the lab .",
    "the first author thanks prof",
    ". z. f. han s for he encouraging and helping the author up till now .",
    "the first author thanks dr .",
    "zhou s help and useful discussion from 2004 to 2006 .",
    "the first author thanks prof . v.",
    "n. gorbachev who is at st .- petersburg state uni . of aerospace instrumentation for the discussion about quantum discrete cosine transform at 2006 .",
    "the first author thanks assistant prof .",
    "xudong huang who is at harvard uni . for his interest at the author s research topic of quantum image compression and the discussion .",
    "the author thanks dr . j .-",
    "cai for his help and discussion .",
    "the author thanks prof .",
    "j. zhang and prof .",
    "pu who are at sichuan normal uni . for their help .",
    "algorithms for quantum computation discretelog and factoring . in _ proc . of the 35th annual symposium on the foundations of computer science _ , pages 2024 , los alamitos , ca , 1994 .",
    "ieee computer society press ."
  ],
  "abstract_text": [
    "<S> discrete fourier transform ( dft ) is the base of modern signal or information processing . </S>",
    "<S> 1-dimensional fast fourier transform ( 1d fft ) and 2d fft have time complexity @xmath0 and @xmath1 respectively . </S>",
    "<S> quantum 1d and 2d dft algorithms with classical output ( 1d qdft and 2d qdft ) are presented in this paper . and quantum algorithm for convolution estimation </S>",
    "<S> is also presented in this paper . compared with fft , qdft has two advantages at least . </S>",
    "<S> one of advantages is that 1d and 2d qdft has time complexity @xmath2 and @xmath3 respectively . </S>",
    "<S> the other advantage is that qdft can process very long signal sequence at a time . </S>",
    "<S> qdft and quantum convolution demonstrate that quantum signal processing with classical output is possible . </S>"
  ]
}