{
  "article_text": [
    "the demand for large scale data storage has increased significantly in recent years with applications demanding seamless storage , access , and security for massive amounts of data .",
    "when the deployed nodes of a storage network are individually unreliable , as is the case in modern data centers , or peer - to - peer networks , redundancy through erasure coding can be introduced to offer reliability against node failures .",
    "however , increased reliability does not come for free : the encoded representation needs to be maintained posterior to node erasures . to maintain the same redundancy",
    "when a storage node leaves the system , a new node has to join the array , access some existing nodes , and regenerate the contents of the departed node .",
    "this problem is known as the _ code repair problem _ @xcite , @xcite .",
    "the interest in the code repair problem , and specifically in designing repair optimal @xmath2 erasure codes , stems from the fact that there exists a fundamental minimum repair bandwidth needed to regenerate a lost node that is substantially less than the size of the encoded data object .",
    "mds erasure storage codes have generated particular interest since they offer maximum reliability for a given storage capacity ; such an example is the evenodd construction @xcite .",
    "however , most practical solutions for storage use existing off - the - shelf erasure codes that are repair inefficient : a single node repair generates network traffic equal to the size of the _ entire _ stored information .",
    "designing repair optimal mds codes , i.e. , ones achieving the minimum repair bandwidth bound that was derived in @xcite , seems to be challenging especially for high rates @xmath3 .",
    "recent works by cadambe _",
    "_ @xcite and suh _ et al . _",
    "@xcite used the symbol extension ia technique of cadambe _ et al .",
    "_ @xcite to establish the existence , for all @xmath4 , @xmath5 , of asymptotically optimal mds storage codes , that come arbitrarily close to the theoretic minimum repair bandwidth . however , these asymptotic schemes are impractical due to the arbitrarily large file size and field size that they require .",
    "explicit and practical designs for optimal mds storage codes are constructed roughly for rates @xmath6 @xcite-@xcite , @xcite , and most of them are based upon the concept of interference alignment .",
    "interestingly , as of now no explicit mds storage code constructions exist with optimal repair properties for the high data rate regime .    * our contribution",
    "* : in this work we introduce a new high - rate , explicit , @xmath0 storage code over @xmath1 .",
    "our storage code exploits fundamental properties of hadamard designs and perfect ia instances pronounced by the use of a lattice representation for the symbol extension ia of cadambe _ et al .",
    "this representation gives hints for coding structures that allow _ exact _ instead of asymptotic alignment .",
    "our code exploits these structures and achieves perfect ia without requiring the file size or field size to scale to infinity .",
    "any single systematic node failure can be repaired with bandwidth matching the theoretic minimum and any single parity node failure generates ( at most ) the same repair bandwidth as any systematic node repair .",
    "our code has two parities but can not tolerate any two failures : the form presented here can tolerate any single failure and any pair of failures that involves at most one systematic node failure - parity mds codes that can optimally repair any systematic or parity node failure and @xmath7-parity mds codes that can optimally repair any systematic node failure @xcite . ] . here , in contrast to mds codes ,",
    "slightly more than @xmath5 , that is , @xmath8 , encoded pieces are required to reconstruct the file object .",
    "in this section , we consider the code repair problem for storage codes with @xmath9 parity nodes .",
    "let a file of size @xmath10 denoted by the vector @xmath11 be partitioned in @xmath5 parts @xmath12^t$ ] , each of size @xmath13 . denotes the finite field over which all operations are performed . ]",
    "we wish to store this file with rate @xmath14 across @xmath5 systematic and @xmath9 parity storage units each having storage capacity @xmath15 . to achieve this level of redundancy , the file",
    "is encoded using a @xmath0 distributed storage code .",
    "the structure of the storage array is given in fig .",
    "1 , where @xmath16 and @xmath17 are @xmath18 matrices of coding coefficients used by the parity nodes @xmath19 and @xmath20 , respectively , to `` mix '' the contents of the @xmath21th file piece @xmath22 . observe that the code is in systematic form : @xmath5 nodes store the @xmath5 parts of the file and each of the @xmath9 parity nodes stores a linear combination of the @xmath5 file pieces .",
    "@xmath23    to maintain the same level of redundancy when a node fails or leaves the system , the code repair process has to take place to exactly restore the lost data in a _ newcomer _ storage component .",
    "let for example a systematic node @xmath24 fail .",
    "then , a newcomer joins the storage network , connects to the remaining @xmath25 nodes , and has to download sufficient data to reconstruct @xmath26 .",
    "observe that the missing piece @xmath26 exists as a term of a linear combination _ only _ at each parity node , as seen in fig . 1 .",
    "to regenerate it , the newcomer has to download from the parity nodes at least the size of what was lost , i.e. , @xmath13 linearly independent data elements .",
    "the downloaded contents from the parity nodes can be represented as a stack of @xmath13 equations @xmath27\\hspace{-0.1cm}&{\\stackrel{\\triangle}{=}}\\hspace{-0.1cm}\\underbrace{\\left [ \\begin{array}{@{}c@ { } } \\left({\\bf a}_{i}{\\bf v}^{(a)}_i\\right)^t\\\\ \\left({\\bf b}_i{\\bf v}^{(b)}_i\\right)^t \\end{array } \\right]\\hspace{-0.1cm}{\\bf f}_i}_{\\text{useful data}}\\hspace{-0.1cm}+\\hspace{-0.35cm}\\sum_{j=1,j\\ne i}^k\\hspace{-0.1 cm } \\underbrace{\\left [ \\begin{array}{@{}c@ { } } \\left({\\bf a}_{j}{\\bf v}^{(a)}_i\\right)^t\\\\ \\left({\\bf b}_j{\\bf v}^{(b)}_i\\right)^t\\label{yrep } \\end{array } \\right]\\hspace{-0.1cm}{\\bf f}_j}_{\\text{interference by $ { \\bf f}_j$}}\\end{aligned}\\ ] ] where @xmath28 are the equations downloaded from parity nodes @xmath19 and @xmath20 respectively . here ,",
    "@xmath29 denote the _ repair matrices _ used to mix the parity contents . retrieving @xmath26 from ( [ yrep ] ) is equivalent to solving an underdetermined set of @xmath13 equations in the @xmath30 unknowns of @xmath31 , with respect to only the @xmath13 desired unknowns of @xmath26 .",
    "however , this is not possible due to the additive _ interference _ components that corrupt the desired information in the received equations .",
    "these terms are generated by the undesired unknowns @xmath32 , @xmath33 , as noted in ( [ yrep ] ) .",
    "additional data need to be downloaded from the systematic nodes , which will `` replicate '' the interference terms and will be subtracted from the downloaded equations . to erase a single interference term ,",
    "a download of a basis of equations that generates the corresponding interference term , say @xmath34\\hspace{-0.1cm}{\\bf f}_j$ ] , suffices . eventually , when all undesired terms are subtracted , a full rank system of @xmath13 equations in @xmath13 unknowns @xmath35{\\bf f}_i$ ] has to be formed .",
    "thus , it can be proven that the _ repair bandwidth _ to exactly regenerate systematic node @xmath21 is given by @xmath36\\right),\\nonumber\\end{aligned}\\ ] ] where the sum rank term is the aggregate of interference dimensions .",
    "interference alignment plays a key role since the lower the interference dimensions are , the less repair data need to be downloaded .",
    "we would like to note that the theoretical minimum repair bandwidth of any node for optimal @xmath0 mds codes is exactly @xmath37 , i.e. half of the remaining contents ; this corresponds to each interference spaces having rank @xmath38 .",
    "this is also true for the systematic parts of non - mds codes , as long as they have the same problem parameters that were discussed in the beginning of this section , and all the coding matrices have full rank @xmath13 .",
    "an abstract example of a code repair instance for a @xmath39 storage code is given in fig .",
    "2 , where interference terms are marked in red .     code . ]    to minimize the repair bandwidth @xmath40 , we need to carefully design both the storage code and the repair matrices . in the following ,",
    "we provide a @xmath9-parity code that achieves optimal systematic and near optimal parity repair .",
    "@xmath41 \\right ) , \\;\\ ; { \\bf x}_2 = { \\text{diag}}\\left ( \\left [ \\begin{smallmatrix }   1\\\\       1\\\\      -1\\\\      -1\\\\",
    "1\\\\       1\\\\      -1\\\\      -1 \\end{smallmatrix } \\right ] \\right ) , \\;\\ ; { \\bf x}_3 = { \\text{diag}}\\left ( \\left [ \\begin{smallmatrix }   1\\\\      -1\\\\       1\\\\      -1\\\\       1\\\\",
    "-1\\\\       1\\\\      -1 \\end{smallmatrix } \\right ] \\right)\\nonumber   \\ ] ]",
    "we introduce a @xmath0 storage storage code over @xmath1 , for file sizes @xmath42 , with coding matrices @xmath43 where @xmath44 , @xmath45 , and @xmath24 . in fig .",
    "3 , we give the coding matrices of the @xmath46 version of the code .",
    "the code in ( [ code ] ) has optimally repairable systematic nodes and its parity nodes can be repaired by generating as much repair bandwidth as a systematic repair does .",
    "it can tolerate any single node failure , and any pair of failures that contains at most one systematic failure .",
    "moreover , to reconstruct the file at most @xmath47 coded blocks are required .    in the following ,",
    "we present the tools that we use in our derivations .",
    "then , in sections v and vi we prove theorem 1 .",
    "optimality during a systematic repair , requires interference spaces collapsing down to the minimum of @xmath38 , out of the total @xmath13 , dimensions . at the same time",
    ", useful data equations have to span @xmath13 dimensions . for the constructions presented here ,",
    "we consider that the same repair matrix is used by both parities , i.e. , @xmath48 . hence ,",
    "for the repair of systematic node @xmath24 we optimally require @xmath49\\right)=\\frac{n}{2},\\ ] ] for all @xmath50 , and at the same time @xmath51\\right)=n.\\ ] ] the key ingredient of our approach that eventually provides the above is hadamard matrices .    to motivate our construction , we start by briefly discussing the repair properties of the asymptotic coding schemes of @xcite , @xcite . consider a @xmath9-parity mds storage code that requires file sizes @xmath52 , i.e. , @xmath53 .",
    "its @xmath18 diagonal coding matrices @xmath54 have i.i.d .",
    "elements drawn uniformly at random from some arbitrarily large finite field @xmath55 . during the repair of a systematic node @xmath24 , the repair matrix @xmath56 that is used by both parity nodes to mix their contents , has as columns the @xmath57 elements of the set @xmath58 then , we define a map",
    "@xmath59 from vectors in the set @xmath60 to points on the integer lattice @xmath61 : @xmath62 , where @xmath63 is the @xmath64-th column of @xmath65 . now , consider the induced lattice representation of @xmath56 @xmath66 observe that the @xmath21-th dimension of the lattice where @xmath67 lies on , indicates all possible exponents @xmath68 of @xmath69 .    , @xmath70 , and @xmath71 .",
    "moreover , @xmath72 , @xmath73 , and @xmath74 . ]",
    "then , the products @xmath75 , @xmath33 , and @xmath76 map to @xmath77 respectively . in fig .",
    "2 , we give an illustrative example for @xmath78 , and @xmath71 .",
    "observe how matrix multiplication of @xmath69 and elements of @xmath79 manifests itself through the dots - on - a - lattice representation : the product of @xmath69 with the elements of @xmath79 shifts the corresponding arrangement of dots along the @xmath68-axis , i.e. , the @xmath68-coordinate of the initial points gets increased by one .",
    "asymptotically optimal repair of node @xmath21 is possible due to the fact that interference spaces asymptotically align @xmath80\\right)}{\\frac{n}{2}}&=\\frac{\\left|\\mathcal{l}({\\bf v}_i)\\cup\\mathcal{l}({\\bf x}_j{\\bf v}_i)\\right|}{{\\delta^{k-1}}}\\nonumber\\\\ & = \\frac{\\left|\\mathcal{l}({\\bf v}_i)\\right|+o(\\delta^{k-1})}{{\\delta^{k-1 } } } \\overset{\\delta\\rightarrow\\infty}{\\longrightarrow } 1,\\end{aligned}\\ ] ] and useful spaces span @xmath13 dimensions , that is , @xmath81\\right ) = \\left|\\mathcal{l}({\\bf v}_i)\\cup\\mathcal{l}({\\bf x}_i{\\bf v}_i)\\right| = 2\\delta^{k-1}$ ] , with arbitrarily high probability for sufficiently large field sizes .",
    "the question that we answer here is the following : how can we design the coding and the repair matrices such that _ i ) _ _ exact _ interference alignment is possible and _ ii ) _ the full rank property is satisfied , for fixed in @xmath5 file size and field size ?",
    "we first address the first part .",
    "we want to design the code such that the space of the repair matrix is invariant to any transformation by matrices generating its columns , i.e. , @xmath82 .",
    "this is possible when @xmath83 that is , when the matrix powers `` wrap around '' upon reaching their modulus @xmath84 .",
    "this wrap - around property is obtained when the diagonal coding matrices have elements that are roots of unity .    for diagonal matrices , @xmath85 ,",
    "whose elements are @xmath84-th roots of unity , i.e. , @xmath86 , for all @xmath87 , we have that @xmath82 , for all @xmath88 .    however , arbitrary diagonal matrices whose elements are roots of unity are not sufficient to ensure the full rank property of the useful data repair space @xmath89 $ ] . in the following we",
    "prove that the full rank property along with perfect ia is guaranteed when we set @xmath44 , @xmath45 , and consider the set @xmath90 interestingly , there is a one - to - one correspondence between the elements of @xmath91 and the columns of a hadamard matrix .",
    "let an @xmath18 hadamard matrix of the sylvester s construction @xmath92,\\ ] ] with @xmath93 .",
    "then , @xmath94 is full - rank with mutually orthogonal columns , that are the @xmath13 elements of @xmath91 .",
    "moreover , any two columns of @xmath94 differ in @xmath38 positions .",
    "[ hadamardlem ]    the proof is omitted due to lack of space .",
    "to illustrate the connection between @xmath91 and @xmath94 we `` decompose '' the hadamard matrix of order @xmath95 @xmath96 = \\left[{\\bf w}\\;\\;{\\bf x}_2{\\bf w}\\;\\;{\\bf x}_1{\\bf w}\\;\\;{\\bf x}_2{\\bf x}_1{\\bf w}\\right],\\end{aligned}\\ ] ] where @xmath97 . due to the commutativity of @xmath98 and @xmath99 ,",
    "the columns of @xmath100 are also the elements of @xmath101 . by using @xmath102 as our `` base '' set ,",
    "we are able to obtain perfect alignment condition due to the wrap around property of it elements ; the full rank condition will be also satisfied due to the mutual orthogonality of these elements .",
    "code are given .",
    "we illustrate the `` absorbing '' properties of the repair matrix for systematic node @xmath103 .",
    "the column space of the repair matrices is invariant to the corresponding blue blocks .",
    "this results in interference spaces aligning in exactly half of the dimensions available . ]",
    "let systematic node @xmath24 fail . then , we pick the columns of the repair matrix as a set of @xmath38 vectors whose lattice representation is invariant to all @xmath104s but to one key matrix @xmath69 .",
    "we specifically construct the @xmath105 repair matrix @xmath56 whose columns have a one - to - one correspondence with the elements of the set @xmath106 first , observe that @xmath56 is full column rank since it is a collection of @xmath38 distinct columns from @xmath91 .",
    "then , we have the following lemma .    for any @xmath107",
    ", we have that @xmath108)&=\\left|\\mathcal{l}({\\bf v}_i)\\cup\\mathcal{l}\\left({\\bf x}_j{\\bf v}_i\\right)\\right|\\nonumber\\\\ & = \\left\\ { \\begin{array}{lc } n , & i = j\\\\ \\frac{n}{2 } , & i \\ne j \\end{array } \\right .. \\end{aligned}\\ ] ]    the above holds due to each element of @xmath102 being associated with a unique power tuple .",
    "then , the columns of @xmath109 $ ] are exactly the elements of @xmath102 , since @xmath110 moreover , the set of columns in @xmath56 are identical to the set of columns of @xmath75 , i.e. , @xmath111 , for @xmath33 , due to lemmata 1 and 2 .",
    "therefore , the interference spaces span @xmath38 dimensions , which is the theoretic minimum , and the desired data space during any systematic node repair is full - rank , since it has as columns all columns of @xmath112 .",
    "hence , we conclude that a single systematic node of the code can be repaired with bandwidth @xmath113 . in fig .",
    "4 , we depict a @xmath114 code of our construction , along with the illustration of the repair spaces .      here , we prove that a single parity node repair generates at most the repair bandwidth of a single systematic repair .",
    "let parity node @xmath19 fail .",
    "then , observe that if the newcomer uses the @xmath18 repair matrix @xmath115 to multiply the contents of parity node @xmath20 , then it downloads @xmath116 .",
    "observe , that the component corresponding to systematic part @xmath117 appears the same in the linear combination stored at the lost parity . by lemma 2 , each of the remaining blocks , @xmath118 share exactly @xmath38 indices with equal elements to the same @xmath38 indices of @xmath119 which was lost , for any @xmath120 .",
    "this is due to the fact that the diagonal elements of matrices @xmath121 and @xmath69 are the elements of some two columns of @xmath94 .",
    "therefore , the newcomer has to download from systematic node @xmath122 , the @xmath38 entries that parity @xmath19 s component @xmath123 differs from the term @xmath124 of the downloaded linear combination .",
    "hence , the first parity can be repaired with bandwidth at most @xmath125 .",
    "the repair of parity node @xmath20 can be performed in the same manner .",
    "our code can tolerate any single node failure and any two failures with at most one of them being a systematic one .",
    "a double systematic and parity node failure can be treated by first reconstructing the lost systematic node from the remaining parity , and then reconstructing the lost parity from all the systematic nodes . however , two simultaneous systematic node failures can not be tolerated .",
    "consider for example the corresponding matrix when we connect to nodes @xmath126 and both parities : @xmath127{\\bf f}. \\label{dc_2}\\ ] ] the rank of this @xmath128 matrix is @xmath129 due to the submatrix @xmath130 $ ] having rank @xmath131 .",
    "for these cases , an extra download of @xmath38 equations is required to decode the file , i.e. , an aggregate download of @xmath132 equations , or @xmath47 encoded pieces .",
    "v.  cadambe , s.  jafar , and h.  maleki , `` distributed data storage with minimum storage regenerating codes - exact and functional repair are asymptotically equally efficient , '' in _ 2010 ieee intern .",
    "workshop on wireless network coding ( winc ) _ , apr 2010 .",
    "k.  rashmi , n.  b. shah , and p.  v. kumar , `` optimal exact - regenerating codes for distributed storage at the msr and mbr points via a product - matrix construction , '' submitted to ieee transactions on information theory , preprint available online at http://arxiv.org/pdf/1005.4178 .      v. r. cadambe , c. huang , and j. li , `` permutation codes : optimal exact - repair of a single failed node in mds code based distributed storage systems , '' _ to appear at isit 2011 _ , preprint available at http://newport.eecs.uci.edu/@xmath134vcadambe/permutations.pdf"
  ],
  "abstract_text": [
    "<S> in distributed storage systems that employ erasure coding , the issue of minimizing the total _ repair bandwidth _ required to exactly regenerate a storage node after a failure arises . </S>",
    "<S> this repair bandwidth depends on the structure of the storage code and the repair strategies used to restore the lost data . minimizing it </S>",
    "<S> requires that undesired data during a repair align in the smallest possible spaces , using the concept of interference alignment ( ia ) . here , a points - on - a - lattice representation of the symbol extension ia of cadambe _ et al . </S>",
    "<S> _ provides cues to perfect ia instances which we combine with fundamental properties of hadamard matrices to construct a new storage code with favorable repair properties . </S>",
    "<S> specifically , we build an explicit @xmath0 storage code over @xmath1 , whose single systematic node failures can be repaired with bandwidth that matches exactly the theoretical minimum </S>",
    "<S> . moreover , the repair of single parity node failures generates at most the same repair bandwidth as any systematic node failure . </S>",
    "<S> our code can tolerate any single node failure and any pair of failures that involves at most one systematic failure . </S>"
  ]
}