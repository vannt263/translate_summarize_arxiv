{
  "article_text": [
    "the _ synthesis operator _ of a sequence of vectors @xmath0 in @xmath1 is @xmath2 , @xmath3 .",
    "that is , @xmath4 is the @xmath5 matrix whose columns are the @xmath6 s . here and throughout , we make no notational distinction between the vectors themselves and the synthesis operator they induce . the vectors @xmath4 are said to be a _ frame _ for @xmath1 if there exists _ frame bounds _",
    "@xmath7 such that @xmath8 for all @xmath9 . in this finite - dimensional",
    "setting , the optimal frame bounds @xmath10 and @xmath11 of an arbitrary @xmath4 are the least and greatest eigenvalues of the _ frame operator _ : @xmath12 respectively . here , @xmath13 is the linear functional @xmath14 , @xmath15 . in particular , we have that @xmath4 is a frame if and only if the @xmath6 s span @xmath1 , which necessitates @xmath16 .",
    "frames provide numerically stable methods for finding overcomplete decompositions of vectors , and as such are useful tools in various signal processing applications  @xcite .",
    "indeed , if @xmath4 is a frame , then any @xmath9 can be decomposed as : @xmath17 where @xmath18 is a _ dual frame _ of @xmath4 , meaning it satisfies @xmath19 .",
    "the most often - used dual frame is the _",
    "canonical _ dual , namely the pseudoinverse @xmath20 .",
    "note that computing a canonical dual involves the inversion of the frame operator .",
    "as such , when designing a frame for a given application , it is important to retain control over the spectrum @xmath21 of @xmath22 . here and throughout , such spectra are arranged in nonincreasing order , with the optimal frame bounds @xmath10 and @xmath11 being @xmath23 and @xmath24 , respectively .",
    "the _ mean square error _ is one way to measure the quality of a given dual frame @xmath25 .",
    "in particular , consider the problem of reconstructing @xmath26 from @xmath27 , where @xmath28 is an additive error term . applying any given dual @xmath25 to @xmath27",
    "gives @xmath29 .",
    "the magnitude of the error between the original vector @xmath26 and its reconstructed approximation @xmath30 is @xmath31 . treating @xmath28 as a random variable , the corresponding _",
    "mean square error _ ( mse ) is the expectation of @xmath32 with respect to @xmath28 s probability density function @xmath33 : @xmath34 : = \\int_{{\\mathbb{r}}^n}{\\|{\\tilde{f}\\epsilon}\\|}^2 p(\\epsilon)\\,{\\mathrm{d}}\\epsilon.\\ ] ] in the special case where @xmath25 is the canonical dual @xmath35 and the entries of @xmath28 are independently distributed with each having mean zero and variance @xmath36 , the mse can be simplified  @xcite in terms of the trace of the inverse of the frame operator : @xmath37 = \\sigma^2{\\mathrm{tr}}[(ff^*)^{-1 } ] = \\sigma^2\\sum_{m=1}^m \\frac{1}{\\lambda_m}.\\ ] ] in order to construct reconstruction systems that are robust to noise , we try to design frames for which the mse is as small as possible .",
    "one ( nonrealistic ) way to do this is to simply scale one s frame vectors @xmath4 . indeed for any @xmath38 , the frame operator @xmath39 of @xmath40 has eigenvalues @xmath41 and so the corresponding mse tends to zero as @xmath42 becomes large .",
    "however , this method for lessening mse is unrealistic in real - world communications applications , since there the magnitudes @xmath43 of the entries of the transmitted signal @xmath44 are bounded in terms of the signal - to - noise ratio of the given channel . as such , the problem of minimizing the mse is usually considered in the context of frames @xmath4 in which the @xmath45th frame element @xmath6 is required to have a given prescribed length @xmath46 .    in particular , choosing @xmath47 for all @xmath48 , one may consider the problem of minimizing the mse over all @xmath5 matrices @xmath4 with unit norm columns .",
    "this problem has been solved  @xcite , the answer being that such an @xmath4 is necessarily a _",
    "tight frame _ , meaning its lower and upper frame bounds @xmath10 and @xmath11 can be taken to be equal , namely @xmath49 for some @xmath50 .",
    "unit norm tight frames _",
    "( untfs ) have the property that their @xmath51 _ gram matrices _ @xmath52 have ones along their diagonal , and so their @xmath53 frame operators @xmath49 satisfy : @xmath54 thus , the tight frame constant @xmath10 of a untf is necessarily @xmath55 . as such ,",
    "the mse of a untf @xmath4 is : @xmath56 note that due to the @xmath57 term in , for any fixed @xmath58 and @xmath59 this mse will tend to zero as @xmath60 grows large .",
    "that is , for a given signal @xmath26 and a fixed signal - to - noise - per - transmitted - coefficient parameter @xmath59 , one may expect to communicate @xmath26 with arbitrarily high levels of reliability even through a noisy channel , provided one is willing to first encode @xmath26 via an @xmath61 matrix @xmath62 of a correspondingly high level of redundancy .",
    "that is , this reliability is purchased at the cost of computing and transmitting @xmath44 , which is a longer signal than @xmath26 itself .",
    "we are interested in generalizing these ideas to the realm of information fusion .",
    "there , we assume that we have already been given @xmath63 where @xmath64 is a fixed known @xmath65 matrix .",
    "that is , we assume that we are given a set of inner products @xmath66 .",
    "if @xmath67 is a frame , then @xmath26 can be reconstructed from these measurements . however , this reconstruction may lack stability if @xmath67 is poorly conditioned ; in such cases the mse of the canonical dual of @xmath67 is large .",
    "we therefore seek to add measurement vectors to this frame  to _ complete _ @xmath64 to a longer matrix @xmath68 where @xmath69in a manner so that the mse of the canonical dual of @xmath70 is minimal . here",
    ", we again formulate the problem realistically by prescribing the norms of these new measurements . to be precise ,",
    "we are interested in solving the following problem :    [ problem.main problem ] given vectors @xmath64 in @xmath1 , an integer @xmath69 and a sequence of desired norms @xmath71 , find vectors @xmath72 in @xmath1 that have the property that the mean square error @xmath73 $ ] of the resulting completed frame @xmath74 is minimal .    in the remainder of this paper",
    ", we discuss some of our recent progress towards solving this problem .",
    "solving problem  [ problem.main problem ] will require us to have a good understanding of how the spectrum of a frame operator can change as a result of the inclusion of new frame elements of known prescribed norms .",
    "we have recently made progress  @xcite in solving a less - difficult version of this problem : given nonnegative nonincreasing sequences @xmath21 and @xmath75 , construct all frames @xmath76 with the property that @xmath22 has spectrum @xmath21 and that @xmath46 for all @xmath45 .",
    "this work is based on the classical notion of eigenvalue interlacing .    to be precise",
    ", we say that a given nonnegative sequence @xmath77 _ interlaces _ on another such sequence @xmath78 , denoted @xmath79 , provided @xmath80 for all @xmath81 .",
    "this notion of interlacing can be extended to sequences of identical length : we say that @xmath82 provided @xmath83 and @xmath80 for all @xmath84 .",
    "it is classically known that if @xmath85 is self - adjoint , then the spectrum of @xmath86 interlaces on that of @xmath85 ; given a sequence of vectors @xmath76 , we apply this fact to the frame operators of the partial sequences @xmath87 : @xmath88 letting @xmath89 denote the spectrum of @xmath90 , we have that @xmath91 and so @xmath92 interlaces on @xmath89 . such a sequence of interlacing spectra is known  @xcite as a sequence of _ ( outer ) eigensteps _ :    [ definition.outer eigensteps ] let @xmath21 and @xmath75 be nonnegative and nonincreasing .",
    "a corresponding sequence of _ outer eigensteps _ is a sequence of sequences @xmath93 which satisfies the following four properties :    1 .",
    "@xmath94 for every @xmath95 , 2 .",
    "@xmath96 for every @xmath95 , 3 .",
    "@xmath97 for every @xmath98 , 4 .",
    "@xmath99 for every @xmath98 .    the following result",
    ", namely theorem  @xmath100 of cahill _ et al _ s work  @xcite , characterizes the existence of a sequence of vectors whose frame operator possesses a given desired spectrum and whose elements have given desired lengths :    [ theorem.necessity and sufficiency of eigensteps ] for any nonnegative nonincreasing sequences @xmath21 and @xmath75 , every sequence of vectors @xmath76 in @xmath1 whose frame operator @xmath22 has spectrum @xmath21 and which satisfies @xmath46 for all @xmath45 can be constructed by the following process :    1 .",
    "pick outer eigensteps @xmath93 as in definition  [ definition.outer eigensteps ] .",
    "2 .   for each @xmath48 , consider the polynomial : @xmath101 take any @xmath102 such that @xmath103 .",
    "+ for each @xmath104 , choose any @xmath105 such that : @xmath106 here , @xmath107 denotes the orthogonal projection operator onto the eigenspace @xmath108 of the frame operator of @xmath109 .",
    "the limit in   necessarily exists and is nonpositive .",
    "conversely , any @xmath4 constructed by this process has @xmath21 as the spectrum of @xmath22 and @xmath46 for all @xmath45 , and moreover , @xmath110 has spectrum @xmath89 .",
    "the method of theorem  [ theorem.necessity and sufficiency of eigensteps ] is the first known algorithm for producing all such frames .",
    "however , there are two issues with this method with respect to implementation .",
    "we discuss the first issue in section @xmath111 and the second issue in section @xmath112 .",
    "our first issue with the algorithm of theorem  [ theorem.necessity and sufficiency of eigensteps ] is that step  a is vague .",
    "indeed , for a given @xmath21 and @xmath75 , it is not clear whether or not a given sequence of outer eigensteps even exists , let alone how one should find them all .",
    "fortunately , these issues can be addressed  @xcite .",
    "the key idea is to transition from the eigenvalues @xmath89 of the @xmath53 frame operator @xmath90 to the eigenvalues @xmath113 of the @xmath114 gram matrix @xmath115 .",
    "these two spectra are zero - padded versions of each other . under this transition ,",
    "the notion of a sequence of outer eigensteps ( definition [ definition.outer eigensteps ] ) transforms into an alternative but equivalent notion of _ inner eigensteps _ :    [ definition.inner eigensteps ] let @xmath116 and @xmath75 be nonnegative nonincreasing sequences .",
    "a corresponding sequence of _ inner eigensteps _ is a sequence of sequences @xmath117 which satisfies the following three properties :    1 .",
    "@xmath96 for every @xmath118 , 2 .",
    "@xmath119 for every @xmath120 , 3 .",
    "@xmath121 for every @xmath48 .",
    "note the terms  outer \" and  inner \" follow from the matrices that they are derived from : outer eigensteps arise as spectra of frame operators , which are sums of outer products ; inner eigensteps arise from gram matrices , which are tables of inner products . in the next result",
    ", we formally verify that one may naturally identify a sequence of outer eigensteps with a sequence of inner eigensteps , and vice versa , provided one zero - pads appropriately :    [ theorem.inner vs outer ] given nonnegative nonincreasing sequences @xmath122 and @xmath123 , where @xmath124 for every @xmath125 , every choice of inner eigensteps corresponds to a unique choice of outer eigensteps and vice versa , the two being zero - padded versions of each other .",
    "specifically , inner eigensteps @xmath126 correspond to outer eigensteps @xmath127 , where @xmath128 whenever @xmath129 or @xmath130 .",
    "conversely , outer eigensteps @xmath127 correspond to inner eigensteps @xmath126 , where @xmath128 whenever @xmath131 .    moreover , for every @xmath98 , @xmath132 is the spectrum of the frame operator @xmath110 of @xmath133 if and only if @xmath134 is the spectrum of the gram matrix @xmath115 .",
    "first , take outer eigensteps @xmath127 , and consider @xmath126 , where we define @xmath135 then definition  [ definition.inner eigensteps].i follows from definition  [ definition.outer eigensteps].ii when @xmath136 , and from and the assumption that @xmath124 for every @xmath125 when @xmath131 .",
    "next , we note that definition  [ definition.outer eigensteps].iii gives @xmath137 for every @xmath98 . to prove definition  [ definition.inner eigensteps].ii , pick any @xmath138 .",
    "we need to show @xmath139 for every @xmath140 .",
    "this follows directly from when @xmath141 or when @xmath125 and @xmath142 . if @xmath125 and @xmath143 , then and together give @xmath144 also , gives that @xmath139 becomes @xmath145 whenever @xmath125 and @xmath131 . for definition  [ definition.inner eigensteps].iii , note that when @xmath146 , and definition  [ definition.outer eigensteps].iv together give @xmath147 furthermore , if @xmath148 , then definition  [ definition.outer eigensteps].i and definition  [ definition.outer eigensteps].iii together give @xmath149 and so and definition  [ definition.outer eigensteps].iv together give",
    "now take inner eigensteps @xmath126 , and consider @xmath127 , where we define @xmath150 then definition  [ definition.outer eigensteps].i follows directly from by taking @xmath129 . also , definition  [ definition.outer eigensteps].ii follows from definition  [ definition.inner eigensteps].i since @xmath16 .",
    "next , definition  [ definition.inner eigensteps].ii gives @xmath151 using the nonnegativity of @xmath122 along with definition  [ definition.inner eigensteps].i and an iterative application of the left - hand inequality of then gives @xmath152 combining this with an iterative application of the right - hand inequality of then gives @xmath153 for definition  [ definition.outer eigensteps].iii , we need to show and for every @xmath98 . considering , when @xmath154 , and together become @xmath155 , which follows from . also , when @xmath125 , immediately gives , while follows from both and : @xmath156 for the case @xmath157 , note that gives the inequalities in whenever @xmath158 .",
    "furthermore when @xmath159 , gives @xmath160 , and so the inequalities in become @xmath161 , which follows from .",
    "otherwise when @xmath130 , the inequalities in become @xmath145 by .",
    "to finish the case @xmath157 , we need to prove . when @xmath162 , becomes @xmath163 , which follows from .",
    "otherwise when @xmath148 , becomes @xmath145 by .",
    "we now have only to prove definition  [ definition.outer eigensteps].iv . for @xmath141 , and definition  [ definition.inner eigensteps].iii together",
    "imply @xmath164 next , note that , definition  [ definition.inner eigensteps].i , and our assumption that @xmath124 for every @xmath125 gives @xmath165 thus , @xmath128 whenever @xmath166 ; when @xmath125 , we can combine this with definition  [ definition.inner eigensteps].iii to get .",
    "this result , when coupled with a complete constructive characterization of all valid outer eigensteps  itself a nontrivial result  provides a systematic method for constructing any and all valid inner eigensteps  @xcite , thereby making step  a of theorem  [ theorem.necessity and sufficiency of eigensteps ] explicit .",
    "our second issue with the algorithm of theorem  [ theorem.necessity and sufficiency of eigensteps ] is that step  b apparently requires a large amount of tedious linear algebra . to be precise , in order to implement step  b , one appears forced to compute the eigenvectors of @xmath110 for each @xmath104 . though this is not difficult  by construction , the eigenvalues of @xmath90 are known to be @xmath89this",
    "does not lend itself to elegant closed - form expressions for the frame vectors themselves . fortunately",
    ", this process can be made surprisingly explicit : see theorem  @xmath167 of cahill _ et al _ s work  @xcite .",
    "we do not present these details here .",
    "however , for the sake of the interested reader , we do provide the following matlab code that implements this improved version of step  b.    here , for the sake of simplicity , @xmath168 for all @xmath45 .",
    "the following two functions must be placed in the same directory in order to execute the code .",
    "the first function ` constructu.m ` implements step  b. here the output of the function is a slightly modified version of steps  b.4 and b.5 .",
    "the function ` constructu.m ` returns @xmath169 and @xmath170 .",
    "we recursively call ` constructu.m ` and then multiply the ouputs at each iteration in order to calculate @xmath171 and @xmath172 for @xmath173",
    ". this step is accomplished by the function ` constructframe.m ` which outputs the final sequence of vectors @xmath0 whose frame operator @xmath22 has spectrum @xmath174 and which satisfies @xmath175 for all @xmath45 .",
    ".... function [ u , uf ] = constructu(e1 , e2 ) % description :   this function implements steps b.1 - 5 of the algorithm to   %                explicitly construct any and all sequences of vectors whose %                partial - frame operator spectra match the eigensteps chosen %                in step a. here , we assume v1, ... ,vn are the identity .",
    "% call :          [ u , uf ] = constructu(e1 , e2 )   %                    e1 = spectrum at ( n ) %                    e2 = spectrum at ( n+1 ) % output :        u = u_(n ) * u_(n+1 ) %",
    "uf = u_(n ) * f_(n+1 ) % file :          constructu.m    % spectra must be row vectors and listed in descending order * * * * * * * * * * * * * * * * * if ~isrow(e1 ) , e1=e1 ' ; end if ~isrow(e2 ) , e2=e2 ' ; end e1 = sort(e1 , ' descend ' ) ; e2 = sort(e2 , ' descend ' ) ;    m = length(e1 ) ;           % find indices of unique elements ( step b.2 ) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * r1 = e1 ; % unique set of eigenvalues of e1 r2 = e2 ; % unique set of eigenvalues of e2 for i = 1:m      [ tf , loc ] = ismember(e1(i ) , r2 ) ;      if tf = = 1          [ tf , loclast]=ismember(e1(i ) , r1 ) ;          r1(loclast ) = -1 ;          r2(loc)=-1 ;      end end    % index sets of unique elements of e1 and e2 , respectively .",
    "i = find(r1 > = 0 ) ; j = find(r2",
    "> = 0 ) ;    m1 = length(i ) ; m2 = m - m1 ;    r1 = r1(i ) ; r2 = r2(j ) ;    % construct column and row vectors ( step b.3 ) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * for i = 1:m1      p(i ) = sqrt(-prod(r1(i)-r2)/prod(r1(i)-r1(find(r1~=r1(i ) ) ) ) ) ;      q(i ) = sqrt(prod(r2(i)-r1)/prod(r2(i)-r2(find(r2~=r2(i ) ) ) ) ) ; end    % construct difference matrix for i = 1:m1      d(i , : ) = 1./(r2-r1(i ) ) ; end w = ( p'*q).*d ;    % create block diagonal matrix uu = blkdiag(w , eye(m2 ) ) ;    % permute row and columns ; prow = permmat(i , m ) ; pcol = permmat(j , m ) ;    % compute u and uf ( modified steps b.4 and b.5 ) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * u = prow*uu*inv(pcol ) ; uf = zeros(m,1 ) ; uf(i ) = p ; % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % define permutation matrix given the unique index set i   function p = permmat(i , m ) m = 1:m ; pi = [ i setdiff(m , i ) ] ; i d = eye(m ) ; p = id(1:m , pi ) ;    % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * function tf = isrow(e ) [ rows , cols]=size(e ) ; if rows==1      tf=1 ; else      tf=0 ; end ....    .... function f = constructframe(e , u1 ) % description :   this function implements step b of the algorithm to   %                explicitly construct any and all sequences of vectors whose %                partial - frame operator spectra match the eigensteps chosen %                in step a. here , we assume v1, ... ,vn are the identity .",
    "% call :          f = constructframe(e , u1 )   %                    e = matrix of eigensteps   %                    u1 = initial unitary matrix % output :        the frame , f. % file :          constructframe.m    uu(:,:,1 ) = u1 ; u(:,:,1 ) = uu(:,:,1 ) ; f(:,1 ) = u(:,1,1 ) ; [ m ,",
    "n ] = size(e ) ;    for i = 2:n      [ uu(:,:,i ) , uf(:,i ) ] = constructu(e(:,i-1),e(:,i ) ) ;      u(:,:,i ) = eye(m ) ;        % multiply matrices to find new u      for j = 1:i , u(:,:,i ) = u(:,:,i)*uu(:,:,j);end           % multiply to find new f      temp = eye(m ) ;      for j = 1:i-1 ; temp = temp*uu(:,:,j ) ; end      f(:,i ) = temp*uf(:,i ) ; end ....    the following example reproduces the results of example  @xmath176 of cahill _ et al _ s work  @xcite .    ....",
    "> > e = [ 0 0 0 2/3 5/3;0 1/3 4/3 5/3 5/3;1 5/3 5/3 5/3 5/3 ]    e =             0          0          0     0.6667     1.6667           0     0.3333     1.3333     1.6667     1.6667      1.0000     1.6667     1.6667     1.6667     1.6667    > > u1=eye(3 )    u1 =         1      0      0       0      1      0       0      0      1    > > f = constructframe(e , u1 )    f =        1.0000     0.6667    -0.4082    -0.1667",
    "0.1667           0     0.7454     0.9129     0.3727    -0.3727           0          0          0     0.9129     0.9129 ....",
    "this work was supported by nsf dms 1042701 , nsf ccf 1017278 , afosr f1ata01103j001 , afosr f1ata00183g003 and the a.  b.  krongard fellowship .",
    "the views expressed in this article are those of the authors and do not reflect the official policy or position of the united states air force , department of defense , or the u.s .  government ."
  ],
  "abstract_text": [
    "<S> in information fusion , one is often confronted with the following problem : given a preexisting set of measurements about an unknown quantity , what new measurements should one collect in order to accomplish a given fusion task with optimal accuracy and efficiency . </S>",
    "<S> we illustrate just how difficult this problem can become by considering one of its more simple forms : when the unknown quantity is a vector in a hilbert space , the task itself is vector reconstruction , and the measurements are linear functionals , that is , inner products of the unknown vector with given measurement vectors . </S>",
    "<S> such reconstruction problems are the subject of frame theory . here </S>",
    "<S> , we can measure the quality of a given frame by the average reconstruction error induced by noisy measurements ; the mean square error is known to be the trace of the inverse of the frame operator . </S>",
    "<S> we discuss preliminary results which help indicate how to add new vectors to a given frame in order to reduce this mean square error as much as possible . </S>"
  ]
}