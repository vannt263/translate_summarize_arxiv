{
  "article_text": [
    "the problem of finding maximum flows and minimum cuts has been studied extensively in algorithmic graph theory and combinatorial optimization .",
    "it led to important tools in algorithm design such as augmenting paths  @xcite , blocking flows  @xcite , dynamic trees  @xcite , dual algorithms  @xcite , scaling algorithms  @xcite , graph sparsification  @xcite , and electrical flows  @xcite . in its simplest form , the maximum flow problem asks to route the most flow from a source to a sink while obeying edge capacities .",
    "its dual , the minimum cut problem , asks for the minimum capacity of edges whose removal disconnects the sink from the source .    approximating maximum flows in undirected graphs",
    "has received much attention recently due to its tighter interactions with randomized and numerical tools  @xcite .",
    "algorithms for this variant have applications in graph partitioning  @xcite , image processing  @xcite , and as we will describe , the construction of oblivious routing schemes  @xcite .",
    "recently , algorithms that approximate undirected maximum flows in @xmath2 time were given by sherman  @xcite and kelner  _ et . al . _",
    "@xcite . at the core of these algorithms",
    "are congestion - approximators  @xcite and oblivious routing schemes respectively  @xcite .",
    "congestion - approximators can be viewed as a small set of representative cuts in the graph , and oblivious routing schemes are more powerful in that they preserve flows as well as cuts .",
    "the runtime of these algorithms stems from both the quality of these approximators as well as the cost of constructing them .",
    "a natural question stemming from them is to further improve this running time .",
    "oblivious routing schemes are of independent interest in the study of graph partitioning and routing .",
    "schemes with quality @xmath1 were shown to exist by rcke  @xcite , and invoking them would lead to a better running time of @xmath3 after preprocessing . however",
    ", finding these schemes requires solving an intricate sequence of ratio cut problems  @xcite .",
    "the current best algorithms for approximating ratio cuts are based on invoking ( approximate ) maximum flows  @xcite . following the break - through on approximate maximum flows , rcke _ et al . _",
    "@xcite gave a more efficient algorithm for constructing oblivious routing schemes .",
    "this result can be viewed as producing a @xmath1-quality oblivious routing scheme by computing maximum flows on graphs of total size @xmath0 .",
    "this leads to a chick - and - egg situation when approximators and maximum flow algorithms are viewed as black boxes : either gives the other via an overhead of @xmath1 , but to get the calls started we need to invoke routines that run in @xmath4 time and produce @xmath5-approximations .    in this paper",
    ", we complete this cycle of algorithmic invocations by resolving this chicken - and - egg situation , leading to improved algorithms to all intermediate problems .",
    "the key observation is that the oblivious routing schemes produced by the rcke  _ et al .",
    "_ algorithm have fixed size : producing them via recursive calls does not affect the cost of invoking them , and any error introduced in the recursion will only show up as a slightly larger overhead on this fixed size .",
    "the main steps of our algorithm on a graph @xmath6 are :    1 .",
    "produce a graph @xmath7 with size @xmath8 that can @xmath1-approximate @xmath6 .",
    "2 .   construct an approximator for @xmath7 using the rcke  _ et .",
    "algorithm , making more recursive maximum flow calls .",
    "3 .   convert this scheme to one for @xmath6 , and use it to solve approximate maximum flows .",
    "the size reduction allows us to bound the total size of the maximum flow instances computed recursively by at most @xmath9 , giving a total size bound of @xmath10 . as @xmath7 @xmath1-approximates @xmath6 , the approximator for @xmath7 returned by the recursive calls is still a @xmath1-quality approximator for @xmath6 .",
    "the fact that its size is @xmath11 then allows us to bound the overall cost by @xmath0 .",
    "this recursive scheme allows us to bypass the more expensive approximators used to initiate this sequence of algorithmic calls .",
    "the total cost in turn reduces from @xmath4 to @xmath0 .",
    "furthermore , these size reductions can be directly obtained via ultra - sparsifiers from solvers for linear systems in graph laplacians  @xcite .",
    "this results in a short pseudocode when the pieces are viewed as black - boxes .",
    "our algorithm is also analogous to iterative schemes for computing row samples of matrices  @xcite : the congestion - approximator plays a similar role to the small row sample , and the call structure is analogous to what we use here , with ultra - sparsifiers being the size reductions",
    ".    we will introduce the algorithmic tools that we invoke in section  [ sec : background ] , and describe our algorithm in section  [ sec : algo ] . for simplicity",
    ", we will limit our presentation to the cut setting and utilize the oblivious routing schemes as congestion - approximators . as the oblivious routing construction by rcke  _ et al . _",
    "@xcite also produces embeddings , and size reductions similar to ultra - sparsifiers were used in the flow based algorithm by kelner  _ et al .",
    "_ , we believe this scheme can be extended to the flow setting as well",
    ".    we will also not optimize for the exponent in @xmath12 because further runtime improvements based on this approach are likely .",
    "however , major obstacles remain in obtaining running times of @xmath13 or faster :    1 .   random sampling based ultra - sparsifiers incur an overhead of @xmath14 in error .",
    "current oblivious routing constructions are based on top - down divide - and - conquer with @xmath12 levels , each making a sequence of @xmath12 maximum flow calls through rebalancings  @xcite . at present",
    "these routines also incur several additional log factors due to error accumulations over levels of recursion .",
    "oblivious routing schemes incur a distortion of at least @xmath12  @xcite .",
    "4 .   producing balanced cuts using maximum flows requires @xmath12 maximum flow invocation  @xcite .",
    "the invocation of congestion - approximators to produce approximate maximum flows requires an iteration count that s at least quadratic in the distortion , as well as incurring another @xmath12 factor overhead .",
    "@xcite .    directly combining these estimates leads to a total cost of about @xmath15 .",
    "an optimistic view is that the algorithms using congestion - approximators can depend linearly on the distortion , and reusing maximum flow calls across the construction scheme leads to recursion on graphs with total size @xmath16 . even in this case , the overall cost is still about @xmath17 .",
    "therefore , we believe obtaining a running time of @xmath18 will require significant improvements to both algorithms that construct oblivious routings and iterative methods that utilize them .",
    "our presentation follows the notations from  @xcite and  @xcite .",
    "a flow @xmath19 meets demands @xmath20 if for all vertices @xmath21 , the total amount of flow enter / leaving @xmath21 is @xmath22 . for edge capacities",
    "@xmath23 , the congestion of @xmath19 is the maximum of @xmath24 over all edges . by a standard reduction via binary search ( e.g. sections 2.2 and 3.1 of  @xcite ) , we can focus on the decision version . for a fixed demand , the problem asks to either route it with congestion at most @xmath25 , or certify via a cut that it can not be routed with congestion less than @xmath26 .",
    "a cut is defined by a subset of vertices @xmath27 : its demand , @xmath28 , is the total demand of vertices in @xmath27 , and its capacity , @xmath29 , is the total capacity of edges leaving @xmath27 .",
    "the ratio between demand and capacity is a lower bound for the minimum congestion , and the maxflow - mincut theorem states that the minimum congestion needed to route a demand is in fact equal to the maximum demand / capacity ratio over all cuts @xmath27 .    the connections between flows , cuts , congestion , and demand brings us to the notion of @xmath30-approximate flow / cut solutions , which will be our standard notion of approximate solutions .",
    "for a demand @xmath20 and an error @xmath31 , such a pair consists of a flow and cut whose congestion and demand / capacity value are within a factor of @xmath25 of each other .",
    "we will make extensive use of approximations , and denote them using the @xmath32 notation .",
    "for two scalar quantities , @xmath33 and @xmath34 , we use @xmath35 to mean that there exist parameters @xmath36 and @xmath37 such that @xmath38 .",
    "we will use an algorithm by sherman  @xcite on using congestion - approximators to compute approximate maximum flows .",
    "an @xmath39-congestion - approximator of @xmath6 is a matrix @xmath40 such that for any demand vector @xmath20 , @xmath41 where @xmath42 is the minimum congestion required to route the demands @xmath20 in @xmath6 .",
    "[ theorem 1.2 . from  @xcite ] [ thm : maxflow ] there is a routine approximatormaxflow that , given demands @xmath20 and access to an @xmath39-congestion - approximator @xmath40 , makes @xmath43 iterations and returns an @xmath30-approximate flow / cut solution for these demands .",
    "each iteration takes @xmath10 time , plus computing matrix - vector products involving @xmath40 and @xmath44 .",
    "rcke  _ et .",
    "@xcite showed that these congestion approximators can be efficiently computed using approximate maximum flow routines .",
    "this result can be pharaphrased as :    [ main result of  @xcite ] [ thm : cutapprox ] there is a routine congestionapproximator that takes a graph @xmath6 , returns with high probability an @xmath45-congestion - approximator @xmath40 such that matrix - vector products in @xmath40 and @xmath46 can be performed in @xmath11 time .",
    "furthermore , this approximator is computed via a series of approximate flow / cut solutions with error @xmath47 on graphs of sizes @xmath48 such that @xmath49 plus an additional running time overhead of @xmath50 .",
    "this summarizes several aspects of the algorithm for constructing oblivious routings by rcke  _ et .",
    "@xcite : the fact that the oblivious routing scheme produced gives a congestion - approximator was observed in the second paragraph of the abstract .",
    "the approximation guarantee is from theorem 4.1 .",
    "the invocation costs of @xmath40 and @xmath46 also follow from oblivious routing scheme being a tree .",
    "the error tolerance in the maximum flow calls of @xmath47 is stated in the abstract and utilized in the rebalancing step of the proof of lemma 3.1 .",
    "overall the algorithm performs @xmath51 levels of partition based recursion , and the total sizes of graphs at each level is @xmath10 .",
    "each partition step may adjust the partition @xmath51 times using the cut - matching game by khandekar  _ et .",
    "@xcite , which in turn needs @xmath52 approximate flow / cut solutions .",
    "combining these bounds gives a total size of @xmath53 .",
    "the running time overhead comes from applying the @xmath52 matchings produced in the cut - matching game to a random vector before routing it using approximate maximum flows .",
    "ultra - sparsifiers are controlled ways of reducing graphs to tree - like structures .",
    "as they involve pairs of graphs on the same vertex set , we will use scripts to denote the graph in question in our notations .",
    "the following construction can be obtained from  @xcite and  @xcite .",
    "[ thm : ultrasparsify ] there is a routine ultra - sparsify that takes a graph @xmath54 with @xmath55 vertices and @xmath56 edges , and any parameter @xmath57 , returns in @xmath58 time a graph @xmath59 on the same set of vertices with @xmath60 edges such that with high probability we have @xmath61 for all subsets of vertices",
    "@xmath62 .",
    "since minimum cut seeks to minimize @xmath63 , @xmath64 for all @xmath27 implies @xmath65 , and an @xmath39-congestion - approximator for @xmath7 is also a @xmath66-congestion - approximator for @xmath6 .",
    "note that since we only need to preserve cuts , the spielman - teng construction of ultra - sparsifiers  @xcite with spectral sparsifiers replaced by cut - sparsifiers  @xcite also gives a similar bound .",
    "these edge reductions are complemented by vertex reductions , which also are crucial in algorithms using ultra - sparsifiers  @xcite .",
    "[ lem : reduce ] when given a graph @xmath7 with @xmath55 vertices and @xmath67 edges , we can produce a graph @xmath68 with @xmath69 edges such that any @xmath39-congestion - approximator @xmath70 for @xmath71 can be converted into an @xmath72-congestion - approximator @xmath73 for @xmath7 .",
    "furthermore , matrix - vector products involving @xmath73 or @xmath74 can be computed by performing a single matrix - vector product in @xmath70 or @xmath75 respectively plus an overhead of @xmath10 .",
    "combining these two steps for edge and vertex reductions gives our key size reduction routines :    [ cor : ultrareduce ] there are routines ultrasparsifyandreduce and convert so that when given a graph @xmath6 with @xmath55 vertices and @xmath56 edges , and an approximation factor @xmath76 , @xmath77 produces @xmath78 such that with high probability .    1",
    ".   @xmath78 has at most @xmath79 edges , and 2 .   given an @xmath39-congestion - approximator @xmath80 for @xmath78 , @xmath81 1 .",
    "is an @xmath82-congestion - approximator for @xmath6 , and 2 .",
    "matrix - vector products involving @xmath83 or @xmath84 can each be performed using one matrix - vector product involving @xmath80 or @xmath85 plus an overhead of @xmath10 .",
    "our algorithm recursively calls the two routines for utilizing and constructing congestion - approximators , while reducing sizes using ultrasparsifyandreduce .",
    "its pseudocode is given in figure  [ fig : algo ]      1 .",
    "set @xmath87 for some absolute constant @xmath88 .",
    "2 .   @xmath89 [ ln : reduce ] 3 .",
    "@xmath90 , which in turm makes recursive calls to recursiveapproxmaxflow .",
    "[ ln : convenstion - approximator ] 4 .",
    "@xmath91 [ ln : convert ] 5 .",
    "return @xmath92 [ ln : finish ] .",
    "we can then follow the call structure of this algorithm and accumulate failure probabilities . at each step , theorem  [ thm : cutapprox ] gives that the total size of the graphs recursed on is bounded by @xmath96 .",
    "therefore , a sufficiently large @xmath88 means the total number of recursive calls is bounded by @xmath10 with high probability .",
    "accumulating the failure probabilities over these steps using the union bound then gives the overall success probability .",
    "we remark that to bound the failure probability of each recursive call by @xmath97 , the routines also need to use @xmath98 , the initial vertex count , instead of the size of the current instance .",
    "this is a situation that occur frequently in analyses of recursive invocations of monte - carlo randomized algorithms  @xcite .",
    "we omit the details here due to the large number of routines used in black - box manners .",
    "the guarantees of congestionapproximator from theorem  [ thm : cutapprox ] gives that @xmath80 is an @xmath45-congestion - approximator for @xmath78 , and matrix - vector products involving @xmath80 and @xmath80 cost @xmath11 . combining this with corollary  [ cor : ultrareduce ]",
    "gives that @xmath83 as returned by @xmath100 on line  [ ln : convert ] of recursiveapproxmaxflow is an @xmath101-congestion - approximator for @xmath6 , and the cost of matrix - vector products @xmath83 and @xmath84 is @xmath10 .",
    "the running time and error guarantees then follow from theorem  [ thm : maxflow ] .",
    "theorem  [ thm : cutapprox ] guarantees that the error parameter in all intermediate calls is at most @xmath103 .",
    "let the running time of @xmath104 on a graph with @xmath56 edges and error @xmath105 be @xmath106 .",
    "we will show by induction , or guess - and - check , that we can choose @xmath107 to ensure @xmath108 .",
    "the base case of @xmath109 , where @xmath98 is the top level vertex count , follows from invoking existing approximate maximum flow algorithms  @xcite . for the inductive case ,",
    "let the graphs that we recurse on have sizes @xmath110 .",
    "theorem  [ thm : cutapprox ] and lemma  [ lem : laststep ] give the following recurrence : @xmath111      the total sizes of the graphs that we recurse on can in turn be bounded via theorem  [ thm : cutapprox ] and corollary  [ cor : ultrareduce ] .",
    "@xmath113 choosing @xmath88 appropriately then allows us to bound this by @xmath9 , giving a total of @xmath114 the inductive hypothesis then follows by picking @xmath107 to be twice the constant of the trailing term .",
    "this gives the bound of @xmath115 when @xmath31 is set to @xmath116 .",
    "for the general case of arbitrary @xmath31 , lemma  [ lem : laststep ] gives a bound of @xmath99 .",
    "note that the first term is still present , since the second to last call is made on a graph of size @xmath9 with @xmath117 .",
    "summing over both terms then gives the overall runtime bound ."
  ],
  "abstract_text": [
    "<S> we give the first @xmath0 time algorithms for approximating maximum flows in undirected graphs and constructing @xmath1-quality cut - approximating hierarchical tree decompositions . </S>",
    "<S> our algorithm invokes existing algorithms for these two problems recursively while gradually incorporating size reductions . </S>",
    "<S> these size reductions are in turn obtained via ultra - sparsifiers , which are key tools in solvers for symmetric diagonally dominant ( sdd ) linear systems . </S>"
  ]
}