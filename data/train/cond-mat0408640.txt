{
  "article_text": [
    "self - avoiding walk and lattice animals(la ) are simple lattice models of linear and branched polymers in dilute solutions . in order to study the thermodynamic properties of these polymers",
    ", one has to average over all allowed configurations of the polymer of a given number of monomers .",
    "the averages are defined with all configurations considered to be equally likely .",
    "since the total number of possible configurations grow exponentially fast with size of the polymer , brute - force exact calculation is possible only for small polymers .",
    "monte - carlo methods allows us to study much larger sizes by obtaining a representative sample of the set of configurations and estimate the ensemble averages from the sample average .",
    "the ie algorithm is a simple modification of exact enumeration algorithm for generating polymers .",
    "a good exact enumeration algorithm generates all possible configurations exactly once @xcite .",
    "this is ensured by defining a rule which , given an @xmath0-site configuration of a polymer , identifies uniquely one of these sites as the ` last added site ' .",
    "removing this site must result in an allowed polymer configuration of @xmath17 sites .",
    "the @xmath17-site polymer is called the parent of the @xmath0-site configuration .",
    "we start by imagining that we have arranged all configurations in a genealogical tree , whose nodes are the different configurations of the polymer , such that all polymer configurations of @xmath0 sites are at level @xmath0 and are connected to their parent at level @xmath17 . clearly , the tree depends on the rule used to define parenthood .",
    "for example , fig .",
    "[ extree ] shows a genealogical tree for directed lattice animals on a square lattice for @xmath18 , using one such choice ( see appendix for details ) . in the actual implementation of the algorithm ,",
    "the whole genealogical tree is not constructed first , and tree is constructed and the pruning is decided as we proceed in a depth first search .    as the number of configurations of polymer of size @xmath0 increases exponentially with @xmath0 , the time required to construct the genealogical tree up - to level @xmath0 in the exact enumeration algorithm increases exponentially with @xmath0 .",
    "the basic idea of the ie algorithm is to decrease this time by randomly pruning the genealogical tree .    in ie",
    "we choose a set of @xmath17 real numbers @xmath19 ( @xmath20 ) , for @xmath21 to @xmath17 .",
    "any bond in the genealogical tree connecting level @xmath22 to level @xmath23 is removed with probability @xmath24 independent of the other bonds .",
    "if a configuration gets disconnected from the root node , automatically all its descendants are also removed .",
    "we make a depth first search of the pruned genealogical tree up - to depth @xmath0 to determine the different configurations that remain at level @xmath0 .",
    "we run the algorithm several times to generate a large sample .",
    "the probability of enumeration of a particular @xmath22 site configuration in a given run is @xmath25    this is same for all configurations of size @xmath22 .",
    "this ensures that the sample of configurations obtained is unbiased . as a configuration can occur at most once in a single monte - carlo run , ie samples the population without replacement .",
    "the different runs are mutually uncorrelated .",
    "however , the number of configurations produced within one run varies from run to run , and different configurations produced in the same run are correlated .",
    "also , the fraction of runs in which one generates at least one configuration of size @xmath0 goes down with increasing @xmath0 .    in case of saws which model linear polymers , there is a natural labelling scheme in which one just labels the first point of walk by @xmath26 , the second by @xmath27 and so on . in case of branched polymers there are several different choices of labelling possible corresponding to different possible rules of removing a site from a @xmath0-site cluster to generate a @xmath17-site connected cluster .",
    "we have used the martin s labelling scheme @xcite for our cluster counting algorithms .",
    "a brief description of this can be found in the appendix .",
    "in general , in monte - carlo methods , the time needed to estimate an ensemble average @xmath28 of some observable @xmath29 over all clusters of size @xmath0 averaged over @xmath30 independent samples would give estimate as @xmath31 , where @xmath32 is the variance of @xmath29 .",
    "if correlations are present , the average time required to estimate @xmath33 within the fractional error @xmath34 varies as @xmath35 , where @xmath36 is a measure of correlations in the data . for metropolis evolution , @xmath36 is the auto - correlation time of the observable @xmath29 . in the case of ie",
    ", the efficiency depends on the average time taken by the monte carlo algorithm to generate a single run and the degree of correlations present in the different samples produced in the same run .",
    "it is difficult to determine the latter exactly for ie .",
    "it depends also on the quantity we want to average .",
    "consider a set of configurations generated by @xmath30 independent runs of the ie algorithm .",
    "let the probability that a single run produces at least one sample be @xmath37 , and the average number of configurations produced per run be @xmath38 .",
    "then for large @xmath30 , we will generate approximately @xmath39 configurations , which will be made of approximately @xmath40 mutually uncorrelated groups .",
    "thus the average size of a correlated group is @xmath41 .",
    "it seems reasonable to measure the efficiency of the algorithm in terms of the average cpu time required to produce one independent group of configurations .",
    "this overestimates correlations as this treats all samples produced within one run as fully correlated .",
    "and the standard deviation @xmath42 is @xmath43 for the radius of gyration of animals of size @xmath44 for the full population .",
    "the average number of samples produced per successful run of mc simulation was @xmath45 .",
    "if we calculate the average radius of gyration of 100 samples of @xmath4 consecutive runs , the standard deviation @xmath46 , of the mean calculated is @xmath47 .",
    "this would have been @xmath48 if they were uncorrelated .",
    "similarly , for saw of size @xmath44 on a square lattice the average number of samples produced per successful run is @xmath49 and @xmath50 , and @xmath51 for @xmath52 samples of @xmath4 consecutive runs . ]",
    "other definitions of efficiency are possible , and may be advantageous in specific contexts .",
    "for example , one may be interested in some asymptotic properties of the polymer problem , like the branching number @xmath53 , or the critical exponent @xmath54 . in this case , the value of @xmath0 is not decided beforehand , and the desired estimate is obtained by suitable extrapolation of data for different @xmath0 .",
    "we can study average number of descendants @xmath55 to estimate @xmath53 and @xmath54 .",
    "analysis of errors in such quantities is more complicated , and will not be discussed here .",
    "let @xmath7 be the average cpu time required to obtain one run which generates at least one configuration of size @xmath0 .",
    "if @xmath56 is the average cpu time for one monte - carlo run , then we have    @xmath57    the average cpu time required for one run is estimated easily in terms of the time taken to add or delete a configuration on the genealogical tree .",
    "we define this to be one unit of cpu time .",
    "the total cpu time for one mc run is proportional to the number of nodes in the pruned genealogical tree .",
    "let @xmath58 denote the random number of @xmath59 site configurations generated in a single run .",
    "the time to visit sites of the randomly pruned tree up - to depth @xmath0 is @xmath60 .",
    "the cpu time in a run is then proportional to the number of nodes in the pruned tree .",
    "the average cpu time per run @xmath56 , would be equal to the sum of average values @xmath61 , averaged over all runs .",
    "@xmath62    for linear and branched polymers , the total number of configurations @xmath63 of a given size @xmath0 is known to vary as    @xmath64    for large @xmath0 .",
    "here @xmath65 is a constant , @xmath53 is called the growth constant and @xmath54 is a critical exponent . since each configuration with @xmath0 sites",
    "has a probability @xmath66 ( eq .",
    "( [ pin ] ) ) of being generated , and there are @xmath63 total number of configurations , @xmath67 , giving    @xmath68    since @xmath69 can be directly estimated in ie , we get a way to estimate the number of configurations @xmath69 by simulations .",
    "this can be used to estimate the @xmath53 and @xmath54 .",
    "a study of the efficiency of the algorithm is complicated as @xmath37 depends on the structure of the genealogical tree , and is difficult to determine theoretically .",
    "an upper bound on working of these algorithm is the time for exact enumeration of all the samples , which is exponential in @xmath0 . consider the case in which @xmath70 for all @xmath71 .",
    "so long as @xmath72 , @xmath69 will grow exponentially with @xmath0 .",
    "as @xmath73 , this implies that @xmath7 increases exponentially with @xmath0 if @xmath74 . also , if @xmath75 , then @xmath37 varies as @xmath76 to leading order , but @xmath56 remains finite ( @xmath77 ) @xcite .",
    "thus again @xmath7 increases exponentially with @xmath0 .",
    "these two considerations together imply that a good choice of @xmath78 is that it should be approximately equal to @xmath79 .",
    "however , finding the optimal choice of @xmath80 for a given problem is non trivial .",
    "we investigate this in the next section for some illustrative cases .",
    "the simplest of enumeration problems is the enumeration on a uniform genealogical tree .",
    "for example , random walks which are models for linear polymers without self exclusion correspond to a uniform genealogical tree of branching number @xmath53 .",
    "the number of nodes at level @xmath0 is @xmath81 .",
    "consider a uniform genealogical tree with two descendants per node . in this case",
    "number of nodes at level @xmath0 would be @xmath82 . for the choice of @xmath80 , the probability of connection of root with level @xmath22 , denoted by @xmath83 follows a simple recursion relation    @xmath84    with @xmath85 .",
    "the average cpu time per run @xmath56 is given by    @xmath86    first we try to find out as to what choice of @xmath87 minimises @xmath7 for small @xmath0 .    for small sizes one can try systematic optimisation .",
    "let us choose @xmath88 . then on the binary tree , @xmath89 and @xmath90 .",
    "this gives    @xmath91    minimising with respect to @xmath92 , we get the minimum value of @xmath93 to be @xmath94 for @xmath95 .",
    "similarly , the time ( @xmath96 ) of ie for reaching level @xmath97 from level @xmath26 , is given by    @xmath98    it is easy to check that @xmath96 in this case takes its minimum value for @xmath99 and @xmath100 . similarly for @xmath101 , the minimum occurs at @xmath102 , @xmath103 and @xmath104 . for large @xmath0",
    ", the best choice of @xmath19 tends to @xmath105 . by optimising till @xmath106 ,",
    "we find that the best choice of @xmath19 is quite well described by the approximate formula @xmath107 .    for large @xmath22 , if @xmath108 , eq . ( [ urec ] ) can be approximated by @xmath109 . for @xmath110 ,",
    "we get @xmath111 decreases exponentially with @xmath22 . for @xmath112",
    ", it leads to @xmath113 .",
    "we have already argued that @xmath19 should be close to @xmath79 , else the algorithm is inefficient , @xmath7 varies as @xmath114 .",
    "consider now the case where @xmath115 , where @xmath116 and @xmath117 are parameters that we can vary to find the optimal values . in this case ,",
    "@xmath118 , and @xmath37 is approximately given by    @xmath119    then , if @xmath120 , we see that @xmath69 tends to a constant for large @xmath0 , and @xmath56 is proportional to @xmath0 .",
    "also , @xmath37 varies as @xmath121 , and we have @xmath11 .",
    "if @xmath122 , and @xmath123 , then @xmath69 varies as @xmath124 , and hence @xmath125 .",
    "also , eq . ( [ udiff ] ) gives @xmath126 .",
    "interestingly , in the @xmath7 , these powers cancel and we get @xmath127 . we find that @xmath128 , hence the best choice of @xmath116 is @xmath129 .    if @xmath130 , then @xmath69 varies as @xmath131 , and @xmath37 varies as @xmath132 , and hence @xmath7 varies as @xmath131 to leading order , thus in this case @xmath130 leads to a suboptimal performance of the algorithm .    on a binary tree for @xmath133 , we get @xmath134 . from systematic",
    "optimisation we saw that there exist a nontrivial optimal value for each @xmath19 which depends on the depth of the genealogical tree to be reached .",
    "this value for uniform binary tree was @xmath135 .",
    "but even with this choice for large @xmath0 we get @xmath136",
    ". this result is generalised straight forwardly to @xmath10-node uniform tree . for the choice , @xmath137 @xmath138",
    ", we get @xmath139 .",
    "it is necessary to check how non - uniformity of trees can change the above conclusions .",
    "the simplest of non - uniform trees are the recursively defined trees .",
    "the number of branches from a given node still follow a definite pattern which repeats and depends on the coordination number of the parent node .",
    "we consider some examples    a node with @xmath10 descendants will be called a @xmath10-node . consider a tree specified by the rule that the descendants of a @xmath27-node are a @xmath27-node and a @xmath97-node , and the descendants of a @xmath97-node are one @xmath27-node and two @xmath97-nodes .",
    "we specify such a tree by the notation @xmath140 tree ( fig.[extree ] ) . if @xmath141 and @xmath142 are respectively the number of nodes at level @xmath143 which have @xmath27 and @xmath97 descendants respectively , then    @xmath144    from these linear recursion equations it is easy to see that @xmath141 , @xmath142 and also the total number of nodes at depth @xmath0 , @xmath63 , all grow as @xmath145 for large @xmath0 , where @xmath146 .",
    "we now look at the efficiency of ie on this tree .",
    "take all @xmath147 .",
    "we define @xmath148 and @xmath149 as the probabilities that a 2-node and a @xmath97-node respectively are connected to at least one node @xmath22 levels  below .",
    "clearly they have the following recursions @xmath150 with @xmath151 .    for large @xmath22 , near the fixed point",
    "we get @xmath152 . substituting in the second equation",
    ", we find the linear term vanishes for @xmath153 and the difference equation can be approximated by @xmath154 , which implies that @xmath155 and @xmath156 decay as @xmath121 for large @xmath0 .",
    "we get @xmath157 .",
    "the total cpu time at @xmath153 is @xmath158 .",
    "it gives the upper bound on time per independent run to be @xmath159 .",
    "we can similarly analyse the other recursively defined trees . consider for example , the tree given by the rule @xmath160 .",
    "we find that growth constant @xmath53 is @xmath161 and for @xmath162 for ie this gives @xmath163 . on a @xmath164 with growth constant 2.732 for @xmath162 for ie this gives @xmath165 .",
    "it is easy to convince oneself that for all recursively defined trees we get @xmath166 .",
    "it is instructive to see the results of systematic optimisation over @xmath80 in case of non uniform trees .",
    "similar analysis for ( 23,233 ) tree ( fig .",
    "[ extree ] ) between level 1 and 2 gives @xmath167 .",
    "similarly optimising @xmath96 between level 1 and 3 gives @xmath168 and @xmath169 .",
    "an optimisation between level @xmath26 and @xmath170 gives the best values of @xmath87 to be @xmath171 , @xmath172 and @xmath173 .",
    "we see that the optimal value of @xmath19 in this case depends on @xmath0 . by optimising till @xmath106 , where @xmath0 is the depth of the genealogical tree ,",
    "we find that for tree levels away from root and bottom , optimal value of @xmath19 approaches @xmath79 with increasing @xmath71 and the asymptotic behaviour of algorithm remains the same as long as we choose @xmath174 .",
    "the optimal @xmath19 values as a function of @xmath71 are plotted in fig.[ran32 ] .",
    "the optimising value of @xmath19 are a bit higher than @xmath79 near the two ends @xmath21 and @xmath175 .",
    "this extra optimisation does not change the @xmath176 dependence , and infact does not change the asymptotic value of @xmath177 either .",
    "the incomplete enumeration algorithm generates a bond percolation process on the genealogical tree , where each link is present independently with a probability @xmath78 .",
    "we define the percolation threshold @xmath178 on the tree to be such that for all @xmath179 , there is a non zero probability that the starting node belongs to an infinite cluster . for @xmath180",
    "the probability of connection between root and level @xmath0 usually goes down exponentially in @xmath0 . at @xmath178",
    "it is expected to decrease as a power law in @xmath0 and for @xmath179 it takes a finite value in the limit of @xmath181 .",
    "the @xmath178 on a tree is bounded from below by @xmath79 @xcite . for the genealogical trees which we discussed ,",
    "the @xmath178 was equal to @xmath79 and the optimal behaviour of the algorithm was achieved for @xmath182 .",
    "we now consider ie for saw . for a saw on a @xmath183 dimensional lattice ,",
    "the number of configurations @xmath184 , where @xmath53 is a lattice dependent constant and @xmath185 depends only on the dimension .",
    "the exponent @xmath185 is known to be @xmath26 for @xmath186 , and @xmath187 for @xmath188 @xcite .",
    "the exact value of @xmath53 is known for the hexagonal lattice @xcite , and fairly precise numerical estimate , which matches well with root of a quartic equation with integer coefficients is known on the square lattice @xcite .    the genealogical tree for saw is not uniform .",
    "for example , for rooted saw(one end fixed at origin ) on a square lattice , the number of different allowed choices of the @xmath189 step for @xmath190 varies from 0 to 3 , depending on the walk . in this case",
    "it is difficult to determine the probabilities of connection up - to level @xmath0 analytically but we have estimated @xmath37 numerically by simulations .",
    "we choose @xmath191 , so that on the average we get order one configurations of size @xmath0 per run for large @xmath0 . with this choice of @xmath19",
    "our numerical simulations show that the probability of reaching level @xmath0 goes down as @xmath121 and hence whenever level @xmath0 is reached , on an average @xmath192 saws of size @xmath0 are generated .",
    "this also implies that @xmath178 is indeed @xmath79 on the saw genealogical tree .",
    "we did @xmath193 monte - carlo simulations and generated walks up - to size @xmath194 on a square lattice .",
    "we have plotted @xmath7 in fig [ sawin ] .",
    "our numerical fit suggests @xmath7 for ie to be @xmath195 .    in 3 dimensions @xmath196 and @xmath197 @xcite and",
    "nearly @xmath198 nodes have coordination number @xmath199 .",
    "hence the tree is more uniform than the @xmath200 case and we get @xmath201 ( fig . [ sawin ] ) .    the genealogical tree becomes more and more uniform as we go to higher dimensions .",
    "in general on a @xmath183 dimensional hyper - cubic lattice the maximum branching possible is @xmath202 and in the limit @xmath203 the growth constant has an expansion @xcite    @xmath204    hence the dominant branching is @xmath202 and probability of a node branching into @xmath202 branches increases with dimension , and the lower branching numbers occur with much smaller frequencies .",
    "the probability of connection to level @xmath0 is hard to obtain analytically for any @xmath183 .    in fig .",
    "[ sawin ] we have also shown a plot of efficiency of ie in @xmath97 and @xmath170 dimensions for saw . in few hours one can simulate @xmath205 monte - carlo runs for walks of size @xmath206 on a pentium-4 machine .",
    "we get @xmath11 for @xmath27,@xmath97 and @xmath170 dimensions .",
    "this leads us to conclude that the small non uniformity of the genealogical tree is unimportant and @xmath7 varies as @xmath1 in all dimensions for saw .",
    "we note that for saws , other algorithms like pivot are known to be more efficient . for pivot algorithm the correlation time for end to end length varies as @xmath207 with @xmath208 in two dimensions @xcite .",
    "however , if we want to study some variable like correlations in the directions of consecutive steps of the walk , the correlation time will have to satisfy the inequality , @xmath209 , as one would need to update each step about @xmath210 times to affect the nearest neighbour correlations .",
    "the main limitation of ie is attrition : the probability of generating @xmath0-site configurations in a given monte - carlo run goes down with @xmath0 . one way to increase",
    "the probability of survival is to redistribute weight amongst the descendants in such a way that while the probability that a particular node is selected remains same as before , the probability that at - least one of the descendants is chosen is increased .",
    "we call this ` improved incomplete enumeration(iie ) ' .",
    "suppose in the implementation of ie as outlined in section 1 , we come to a node with degree @xmath59 . then in ie ,",
    "each link is independently deleted with a probability @xmath211 , and the probability that all links are deleted is @xmath212 , which is non zero , even if the expected number of descendants of this node is @xmath213 . in iie ,",
    "the links are not deleted independently .",
    "the probability that any given node is selected remain @xmath78 , but the probability that at least one node is selected increases .",
    "this is implemented as follow : if there are @xmath59 descendants of a node and each link downward is present with probability @xmath78 , then we choose int@xmath214 edges at random and give them weight one , and select one of the edge out of the remaining @xmath59 at random and give it a weight one with probability frac(@xmath215 ) and delete all the other edges .",
    "hence we see that in iie , though the average probability of selection of an edge remains @xmath78 , but it enhances the probability of connection between two level of the genealogical tree and hence the probability of success in a given monte carlo run . for example , as will be discussed in the next section , on a regular tree with @xmath153 , the probability of connection up - to @xmath0 levels below in iie is exactly one whereas it goes as @xmath121 in ie .      in iie one",
    "redistributes the sum of probabilities of connection from a node to the next level . on a uniform binary tree",
    "@xmath216 @xmath217 and with @xmath218 , @xmath219 and hence for @xmath218 with iie probability of reaching any level @xmath0 of the tree after @xmath0 steps is exactly @xmath26 and exactly one configuration of any given size is generated in the process and hence @xmath220 . with @xmath221",
    "this result holds for any @xmath10 node uniform tree .",
    "clearly @xmath221 is the best choice in this case , as an absolute lower bound on time @xmath7 of the algorithm is @xmath0 .",
    "if we use the improved algorithm for a ( 23,233 ) tree , @xmath69 and hence the average cpu time per run will remain the same .",
    "we can also determine the connection probabilities @xmath155 and @xmath156 . the coupled difference equations for @xmath148 and @xmath149 have no cubic term .",
    "the recursions are    @xmath222    which at @xmath223 gives @xmath155 varying as @xmath121 for large @xmath0 .",
    "the time per independent run comes out to be @xmath224 times that in incomplete enumeration .",
    "that is , iie is nearly three times more efficient than ie .    iie certainly works better than ie .",
    "but , except for the uniform tree , the difference between ie and iie is only in the coefficient of @xmath1 . while performance of iie improves as the genealogical tree becomes more and more uniform , there is no qualitative difference in the efficiency of ie and iie on a recursively defined non uniform tree .",
    "we studied iie on a @xmath183 dimensional hyper - cubic lattice for @xmath225 to 10 .",
    "iie enhances the performance of the algorithm by increasing the probability of connection between root and level @xmath0 . for saw on a square lattice ,",
    "[ saw2d ] shows the probability of connection @xmath37 for ie and iie both .",
    "@xmath37 is roughly @xmath226 times bigger for iie . in two dimensions ,",
    "@xmath7 is of order @xmath227 for iie . in three dimensions",
    "the performance is even better and @xmath228 , which is roughly a factor of @xmath229 less than the time taken by ie .",
    "in general we find on a d dimensional hypercube iie has a efficiency @xmath230 where @xmath14 is a decreasing function of dimension for generating saws .",
    "fig.[sawen ] shows the plot of iie for dimensions 2 to 10 .",
    "the memory requirement of the algorithm just increases linearly with system size in all dimensions and we could perform @xmath205 mc runs for walks up - to sizes @xmath206 in few hours of computer time on a pentium-@xmath170 machine . we find that @xmath14 decreases as @xmath231 approximately , i.e the algorithm performs better with increasing dimension .",
    "we conclude that for ie and iie for saw , @xmath230 .",
    "the probability of connection between root and level @xmath0 does not depend on @xmath185 .",
    "it depends only on the non - uniformity of the tree .",
    "the genealogical tree is more uniform in higher dimensions and the constant @xmath14 depends on dimension . for ie",
    ", the change in @xmath14 with dimension is quite insignificant . but @xmath14 can be decreased significantly by redistributing weights .",
    "this is a strong numerical evidence that the performance is always @xmath232 independent of the dimension and @xmath185 for linear polymers .",
    "a further enhancement can be achieved by choosing the pruning only after looking deeper , but we found that because of the increase both in the memory requirement and in the cpu time to generate one configuration , there is no net gain over iie .",
    "in this section we will study the ie algorithm for branched polymers .",
    "since the efficiency of ie is polynomial in @xmath0 for linear polymers , it seems plausible that it will be so also for branched polymers .",
    "there are two important ways in which the genealogical tree for branched polymers differ from that for linear polymers .",
    "there are several equally reasonable , computationally easy to implement choices of rules to define parentage , and in all of them the degree of a node is not bounded .",
    "the number of possible descendants of a node is of the order of its perimeter sites and hence the maximum of the degree of nodes at level @xmath0 increases linearly with @xmath0 .",
    "the average number of descendants @xmath53 is of @xmath210 , and the number of nodes with large branching number is exponentially small . but this makes an important difference in the fluctuations of the number of animals of a given size generated in a given run .",
    "the structure of genealogical tree for lattice animals is more complex than for self - avoiding walks .",
    "we studied the algorithm on genealogical tree obtained by using martin s labelling scheme @xcite .",
    "we have tried two or three variations of the priority rules , and our results are insensitive to these changes .",
    "we first discuss our results for the animals on a binary tree .",
    "this simple case is more analytically tractable . the generating function of total number of lattice animals on a binary tree is well known @xcite and it is @xmath233 , where @xmath234 is the total number of animals with @xmath22 sites .",
    "@xmath234 are the catalan numbers , which come up in many other contexts in combinatorics @xcite . for large @xmath22",
    "this gives @xmath235 .",
    "the growth constant @xmath53 in this case is @xmath170 .",
    "the number of descendants of a node at level @xmath22 in the genealogical tree for this problem lies between @xmath27 to @xmath23 . in this case",
    "the genealogical tree is easily characterised : the root site is a @xmath236node .",
    "a @xmath10-node has @xmath10 descendants , and the degree of these descendants are @xmath237 respectively .",
    "this is seen as follows : the node corresponds to a branched polymer with @xmath10 unblocked perimeter sites , which are ordered by some priority rule .",
    "the @xmath238 descendant of this node is a node of degree @xmath239 and corresponds to first @xmath240 perimeter sites blocked , @xmath238 site occupied and @xmath241 allowed for further occupation . since on a binary tree",
    "every site has two downward neighbours , hence we see that a @xmath10-node will give rise to nodes with @xmath242 descendants . for example , in fig .",
    "[ rtree ] , the top node corresponds to an animal of one site , and has two growth sites .",
    "if first of these two sites is occupied , then the corresponding animal has three growth sites .",
    "if it is blocked it has two growth sites and so on .",
    "the total number of nodes at a level @xmath22 is equal to @xmath234 .",
    "let @xmath243 is the number of @xmath10-nodes at level @xmath244 .",
    "we can determine the distribution of the branching number .",
    "we find that @xmath243 satisfy the following relation    @xmath245    as @xmath246 , @xmath247 of the nodes at a level have @xmath27 offsprings and @xmath247 of the total nodes have @xmath97 offsprings . and",
    "level @xmath22 has exactly one node with degree @xmath23 . for @xmath248 , it can be shown that in the asymptotic limit ( @xmath246 ) , the fraction of nodes having @xmath10 offsprings is @xmath249 for @xmath250 .    to find the efficiency factor @xmath7",
    ", we have to determine the probability of connection of root to a level .",
    "if @xmath251 is the probability of a node with @xmath10 offsprings to be connected to at - least one node @xmath22 levels below it , then @xmath251 has a recursion    @xmath252    with initial conditions    @xmath253    and @xmath78 is the probability with which we choose any edge of the tree .",
    "@xmath254 will give the probability of connection of root to level @xmath22 on the genealogical tree .",
    "( [ nrec ] ) is a nonlinear equation .",
    "this equation can also be written as    @xmath255    this equation is also valid for @xmath256 if we choose the convention that @xmath257 .    these equations have the following properties :    1 .   for @xmath258 , @xmath251 tends to zero as @xmath22 tends to infinity exponentially fast for any fixed @xmath10 .",
    "in fact , if we consider @xmath22 as a time like variable and @xmath10 as space like variable , then @xmath251 has a travelling front solution in this regime ( @xmath259 ) .",
    "2 .   for @xmath260",
    ", the velocity of travelling front goes to zero .",
    "the distance moved by the front increases as @xmath261 and @xmath262 . as @xmath263 for @xmath264 , this implies that @xmath265 for large @xmath266 .",
    "3 .   for @xmath267 ,",
    "as @xmath22 goes to infinity , @xmath268 tends to a non trivial fixed point function @xmath269 greater than zero .",
    "this may be seen as follows .",
    "the fixed point equation in terms of fixed point variables @xmath269 is    @xmath270    clearly , @xmath271 @xmath272 is a trivial fixed point of this equation . for @xmath273 , there is a non trivial fixed point with @xmath269 non zero monotonic increasing , with @xmath274 for large @xmath10 .",
    "however , a closed form solution for any @xmath267 is difficult .    on numerically iterating eq .",
    "( [ nrec ] ) in @xmath22 , we find that the equation has a travelling front solutions for @xmath275 and has nontrivial fixed point for @xmath276 .",
    "eq ( [ fp ] ) has two stationary solutions , i.e @xmath277 and @xmath278 . for @xmath275 , @xmath271 is the stable solution while @xmath279 is an unstable solution .",
    "our initial conditions given by eq ( [ ic ] ) are steep . starting with these initial conditions , on numerical iteration",
    "we find that as @xmath22 increases , a front separating stable solution @xmath280 and unstable solution @xmath281 moves in the forward direction . from the translational invariance of eq .",
    "( [ nrec ] ) one expects a running wave solution .",
    "we find that the front moves with a constant velocity and hence , @xmath251 for large @xmath10 and @xmath282 must tend to the asymptotic form    @xmath283    we define @xmath284 , the width of the front by the equation ,    @xmath285    fig .",
    "[ trfr ] shows a plot of numerically determined @xmath251 with respect to @xmath286 for @xmath78 near @xmath247 .",
    "curves for @xmath78 below , above and at @xmath260 all collapse on the same line . actually , a travelling front for @xmath251 as defined by eq .",
    "( [ nrec1 ] ) exists for all @xmath10 , @xmath287 , if we take boundary conditions such that @xmath288 and @xmath289 .    at @xmath260 ,",
    "the velocity of the travelling front is zero .",
    "if we plot @xmath290 as a function of @xmath251 , we find that as @xmath22 increases the graph approaches a limiting form .",
    "thus for the asymptotic wavefront , @xmath290 is a single valued nonlinear function of @xmath251 .",
    "we have plotted these values for different @xmath22 in fig .",
    "[ pk1pk ] and they all are very close and seem to lie on the same curve .",
    "hence if we start from a point on this curve and iterate the fixed point equation eq .",
    "( [ fp ] ) with @xmath260 , we generate a travelling front . we have not been able to deduce the functional form of this function , which corresponds to a first order difference equation for @xmath291 from the second order equation eq .",
    "( [ fp ] ) .",
    "( [ fp ] ) turns out to be a stiff equation and one has to be careful while iterating it in increasing @xmath10 direction .",
    "we iterated eq .",
    "( [ fp ] ) starting with different sets of values of @xmath292 and @xmath291 given by fig .",
    "[ pk1pk ] and found the equation yields a travelling front same as the one shown in fig .",
    "[ trfr ] .",
    "we could not solve the full non - linear difference equation eq .",
    "( [ nrec ] ) . keeping only the terms linear in @xmath293 will give an upper - bound on @xmath294 ,",
    "i.e    @xmath295    we can represent this set of equations in matrix form also . hence if @xmath296 represents the infinite column array with @xmath297 entry being @xmath251 then    @xmath298    where @xmath299 is the transition matrix .",
    "if @xmath300 is the largest eigenvalue of @xmath299 then for @xmath301 , in the limit of @xmath302 , @xmath303 will be @xmath304 , i.e @xmath305 for all @xmath10 , and for @xmath306 .",
    "the elements @xmath307 of the transition matrix @xmath299 are such that , @xmath308 for @xmath309 and @xmath304 otherwise .",
    "if we truncate @xmath299 beyond @xmath310 ( @xmath311 ) , then the determinant @xmath312 of @xmath311 comes out to be    @xmath313\\ ] ]    with @xmath314 , and @xmath315 is a coefficient which does not depend on @xmath0 .",
    "then equating @xmath316 in the @xmath317 limit gives @xmath318 .",
    "this implies that for @xmath319 , @xmath251 will decay exponentially with increasing @xmath22 and eq ( [ lrec ] ) will work well .",
    "hence , by definition percolation threshold @xmath178 of this tree is @xmath247 .",
    "the linearised recursion can be solved explicitly , and we get ,    @xmath320}{\\gamma[k+r-1 ] \\gamma[r+1]}\\ ] ]    which for large @xmath22 gives @xmath321                \\label{sl}\\ ] ]    if we assume a travelling front solution of kind @xmath322 to be valid in the tail of the distribution , then substituting in linearised recursion ( eq.([lrec ] ) ) , for a given @xmath78 we get a spectrum of travelling wave like solutions parametrised by @xmath53 with the velocity @xmath282 of the front given by    @xmath323    in this case , it is known that the front actually chooses a unique velocity given by minimum of right hand side of eq .",
    "( [ vel ] ) with respect to @xmath53 @xcite .",
    "the front velocity is given by    @xmath324    where @xmath325 is the solution of the transcendental equation    @xmath326    near @xmath260 , we can take @xmath327 and @xmath328 . travelling front solutions",
    "have been found in a large variety of problems in physics @xcite .",
    "the linearisation of eq ( [ nrec ] ) would be valid only for @xmath329 and @xmath330 .",
    "beyond that , linear solution will grow beyond one whereas the solution of the full nonlinear equation will saturate to @xmath26 . here",
    "@xmath331 is the value of @xmath10 at which @xmath251 given by eq .",
    "( [ sl ] ) becomes of @xmath210 and is equal to    @xmath332    at @xmath260 , the asymptotic velocity of the front is zero and the front advances as a sub linear power of @xmath22 .",
    "this is the critical point of the percolation on this tree , and eq .",
    "( [ sl ] ) gives a algebraic decaying solution for sufficiently small @xmath10 .",
    "this is only an upper bound to the actual value . on numerically iterating eq .",
    "( [ nrec ] ) for @xmath22 upto order @xmath4 , we found unexpectedly that it decays as a stretched exponential in @xmath22 .",
    "the fixed point equation as given by eq .",
    "( [ fp ] ) is again a nonlinear equation . to find the dependence of probability of connection of root , @xmath254 , on the width of the front we solved the linearised fixed point equation . on solving , we find that it goes as @xmath333 for large @xmath22 , where @xmath284 is the width of the distribution . hence in general ,",
    "@xmath334 .",
    "we further studied the width @xmath284 of the front as a function of @xmath22 for different values of @xmath78 .",
    "at @xmath260 we found @xmath335 .",
    "[ kr ] shows a plot of @xmath336 as a function of @xmath261 . for @xmath260 ,",
    "the plot is a straight line .",
    "this implies that @xmath337 at @xmath260 . for @xmath258",
    ", @xmath336 varies linearly with @xmath22 and tends to a constant for @xmath267 .",
    "we can directly iterate eq .",
    "( [ nrec ] ) . in fig [ p2rt ]",
    "we have plotted @xmath338 as a function of @xmath261 which comes out to be a straight line .",
    "fig [ kr ] and fig .",
    "[ p2rt ] are strong numerical evidence that the probability of connection goes as @xmath339 for branched polymers on binary tree .",
    "our numerical studies give @xmath5 and @xmath340 .",
    "we now present a heuristic argument to understand why @xmath341 varies as @xmath261 at @xmath178 .",
    "let us consider a genealogical tree of lattice animals on a binary tree , in which nodes with more than @xmath10 descendants are deleted .",
    "we denote the probability that the maximum degree of a node connected to root down to level @xmath22 is @xmath342 , by @xmath343 and the probability that a @xmath342 node is connected to at least one node @xmath22 level down on the truncated genealogical tree by @xmath344 .    now on a truncated tree , transition matrix @xmath299 is no longer infinite .",
    "it is now a @xmath345 matrix with @xmath346 for @xmath347 and @xmath304 otherwise . here",
    "@xmath307 represents the @xmath348 row and @xmath349 column entry of @xmath299 , and we find the critical value of @xmath78 which is just inverse of the largest eigenvalue of @xmath299 to be a function of @xmath342 and is equal to    @xmath350    for @xmath351 , @xmath344 decays exponentially with @xmath22 . in large @xmath22 limit it",
    "is given by    @xmath352    at @xmath260 , we get @xmath353 , where @xmath354 is a constant .",
    "it is easy to get a lower bound on @xmath343 , as a order @xmath342 node occurs first time at level @xmath342 and probability of connection of root to this node is @xmath355 .",
    "hence    @xmath356    hence , since @xmath260 is less than @xmath357 for any finite @xmath342 , @xmath358 , where @xmath359 .",
    "since @xmath360 , for large @xmath22 we get    @xmath361\\ ] ]    which gives    @xmath362 \\geq exp(-c r^{1/3})\\ ] ]    where @xmath363 .",
    "if we take @xmath343 to be as given by eq .",
    "( [ upb ] ) , we get an lower bound on @xmath254 . taking @xmath364 and @xmath365",
    "we get @xmath366 .",
    "this should be compared with the numerical estimate @xmath367 .",
    "thus our numerical simulations and qualitative arguments show that probability of connection goes down as a stretched exponential at @xmath260 , the @xmath178 of the genealogical tree of lattice animals on binary tree as opposed to @xmath368 decay for linear polymers .",
    "so if we chose @xmath369 @xmath138 , then @xmath370 and hence the average computer time to generate one statistically independent sample of size @xmath22 , @xmath371 would go as @xmath372 to leading order .",
    "clearly the algorithm is not working well and one would like to enhance its efficiency if possible .",
    "we tried to study the algorithm by choosing @xmath19 such that its asymptotic value is @xmath247 .",
    "we chose @xmath373 and studied @xmath371 as a function of @xmath266 and @xmath117 .",
    "as argued earlier , taking @xmath122 , we can change @xmath374 and @xmath83 by multiplicative factors which are powers of @xmath22 .",
    "this will not make much of a difference , as the leading dependence remains @xmath375 .",
    "using @xmath130 , seems to be more interesting .    for @xmath130 , the average cpu time per monte - carlo run would vary as @xmath376 . in case of linear polymers , we saw that time complexity of the algorithm for @xmath122 for any @xmath266 is polynomial in @xmath22 .",
    "hence , @xmath130 was clearly a bad choice .",
    "but in the case of lattice animals , this increase in numerator is exactly cancelled by a corresponding increase in @xmath83 . for @xmath377",
    ", @xmath374 increases as @xmath378 and @xmath83 varies as @xmath379 to leading order for large @xmath22 .",
    "these cancel to give @xmath380 independent of @xmath117 . to monitor the behaviour of various prefactors , we study this numerically . fig .",
    "[ plax ] shows plot of @xmath371 for @xmath381 , for @xmath382 and @xmath26 as a function of @xmath266 . for @xmath383 , to leading order @xmath371 goes as @xmath375 , but there exist a non trivial value of @xmath266 at which @xmath371 is minimum for a given @xmath117 .",
    "if we look at @xmath371 at best value of @xmath266 for @xmath382 and @xmath26 , we find that as @xmath22 increases the difference is not significant .",
    "hence we conclude that to leading order , @xmath384 , for the best choice of @xmath78 . for all @xmath385 ,",
    "there exist a range of @xmath266 for which the time complexity of the algorithm will remain qualitatively the same .",
    "we also studied the efficiency for lattice animals on a square lattice . from exact series enumeration",
    "the @xmath234 is known to vary as @xmath386 with @xmath387 @xcite . in this case also the number of offsprings a node at level @xmath22 can have is @xmath388 and the genealogical tree in this case though more complicated , is qualitatively similar .",
    "numerically , we find that the probability distribution of number of descendants @xmath10 ( of a randomly chosen node ) has a maximum at @xmath389 , with @xmath390 .",
    "we enumerated lattice animals up - to sizes 1000 using ie with @xmath193 monte - carlo runs .",
    "it took time of order one day on a pentium-4 machine . with iie we generated samples of size 2000 with @xmath391 monte - carlo runs in 2 - 3 days time .",
    "these sizes are of same order as those produced using the cut and paste type algorithms .    in this case",
    ", we find that @xmath83 has the stretched exponential form @xmath392 , with @xmath393 for both ie and iie . fig .",
    "[ la2d ] shows @xmath394 $ ] varies approximately linearly with @xmath395 .",
    "we also studied the directed lattice animals ( da ) on a square lattice . in this case",
    "we find that , @xmath396 ( fig .",
    "[ da2d ] ) .",
    "we find the efficiency of ie to be different for linear and branched polymers .",
    "this is due to the fact that genealogical tree for the latter is much more non uniform .    for self avoiding walks , in any dimension , the time to generate an independent sample of @xmath0 steps @xmath13 , independent of dimension for both ie and iie . for ie",
    "there is no significant change in @xmath14 with dimension .",
    "but for iie @xmath397 . in the limiting case of saw on binary tree @xmath220 for iie .    for branched polymers @xmath7 increases as @xmath2 with @xmath3 in all dimensions for both ie and iie",
    "redistributing weight does not change the value of @xmath116 .",
    "iie works better than ie , but the difference is only in the coefficient @xmath398 .",
    "the exponent @xmath116 depends weakly on the dimension , its relation to the usually studied exponents of the branched polymer problem eg .",
    "@xmath54 , @xmath399 is not clear at present .    as discussed earlier , the genealogical tree for cluster enumeration is not unique and one might argue that martin s scheme is not the optimal choice .",
    "we tried to generate the genealogical tree using some variations of this rule , but we did not find any significant change in efficiency of the algorithm .    for branched polymers , the degree of a node in the genealogical tree is not bounded , and the maximum degree increases with depth of the genealogical tree .",
    "however , the fractional number of nodes with high degree is very small . for genealogical tree corresponding to animals on a binary tree",
    "we find the fractional number of @xmath10-nodes goes down exponentially with @xmath10 for large @xmath10(eq .",
    "( [ nodes ] ) ) .",
    "similar , behaviour was observed for branched polymers and directed branched polymers on a square lattice numerically .",
    "it is surprising that even an exponentially rare distribution of nodes with large degree seems to be enough to change the behaviour of efficiency of the algorithm on the tree .    in the case of branched polymers",
    ", we found that the @xmath7 for ie varies as @xmath400 with @xmath401 .",
    "while this is not very good , one can find problems for which ie s performance is even worse with @xmath402 .",
    "as an example , consider self avoiding walks on a disordered lattice , obtained by removing a fraction @xmath403 of bonds at random from a square lattice .",
    "it is known that the average number of self avoiding walks of length @xmath0 varies as @xmath404 @xcite , where @xmath53 is the growth constant of the self avoiding walks on the same lattice with @xmath405 .",
    "hence the growth constant of the corresponding genealogical tree would also be @xmath406 .",
    "now if we consider a square lattice , the @xmath407 and the bond percolation threshold is @xmath105 . for @xmath408 , all clusters would be finite with probability 1 , and the probability that cluster contains @xmath0 sites would decrease exponentially with @xmath0 . in this case , ie will be inefficient and even for best choice , @xmath7 will vary as @xmath409 .",
    "one could argue that ie is a rather inefficient algorithm , which gives reasonable performance only for a small selected set of problems .",
    "we do not think so .",
    "in fact , the causes that make ie inefficient are also operative in the much larger class of genetic type algorithms .",
    "the high degree of correlations between different samples generated is a common feature of many of these algorithms which employ pruning and enrichment .",
    "for example , one could expect a similar behaviour to occur in the berreti - sokal algorithm @xcite , for branched polymers .",
    "the correlations arise because in all such ` evolutionary ' type algorithms different samples generated often share a common ancestor in the past .",
    "whether our results can be generalised to a larger class of perm type algorithms seems to be an interesting question for further study .",
    "* acknowledgements *    we thank m.barma for a careful reading of the manuscript , and the referee for many helpful remarks , which have helped improve our presentation .",
    "as discussed in sec.1 , to enumerate all allowed configurations on a computer , one need a good exact enumeration algorithm which would generate all possible configurations exactly once , without needing to refer to what has been generated previously .",
    "hence , one has to label the @xmath0-point configurations such that for any @xmath0-point configuration the labelling is unique and on removing the last added site we must get an allowed @xmath17-point configuration",
    ". for the self avoiding walks this can be easily achieved by labelling the first point of walk as 1 , the second 2 , and so on .",
    "but usually such natural choice of labelling does nt exist for most problems . for lattice trees and animals",
    ", martin discusses this in detail @xcite .",
    "here we describe briefly his algorithm for labelling a @xmath0-cluster .",
    "* choose a rule for ordering the neighbours of any given site .",
    "for example , for da on a square lattice ( fig.1 ) , we chose the rule that the upward neighbour is labelled before the right neighbour . for lattice animals on the binary tree",
    "we choose left neighbour before the right neighbour(fig .",
    "* we label the root as @xmath26 and its neighbours are labelled @xmath410 in the order according to the priority rule .",
    "* when all points adjacent to point @xmath26 have been labelled , label any still unlabelled points adjacent to point @xmath27 according to the priority rule and then of point @xmath97 and so on .",
    "this labeling hence induces a tree structure on the cluster which is the genealogical tree .",
    "the labelling described above is just one way of labelling the configurations .",
    "one can invent many other labelling schemes , which would give rise to different genealogical tree .",
    "but we find that the nature of genealogical tree depends on the underlying problem and not on the rules of labelling .",
    "999    a d sokal , monte - carlo methods for the self avoiding walk 1995 , in monte carlo and molecular dynamics simulations in polymer science , ed . k. binder , oxford university press new york 47 - 124 , hep - lat/9405016    m doi and s f edwards 1986 , the theroy of polymer dynamics , clarendon press - oxford .",
    "f t wall and f mandel 1975 , macromolecular dimensions obtained by an efficient monte carlo method without sample attrition j. chem .",
    "* 63 * 4592 - 4595 .",
    "n madras and a d sokal 1988 , the pivot algorithm : a highly efficient monte carlo method for the self - avoiding walk , j. stat . phys . * 50 * 109    s caracciolo , a. pelissetto and a d sokal 1990 , a nonlocal monte carlo algorithm for self - avoiding walks with fixed endpoints , j. stat . phys .",
    "* 60 * 1    f t wall and j j erpenbeck 1959 , new method for the statistical computation of polymer dimensions , j. chem .",
    "phys . * 30 * 634 - 637 .",
    "p grassberger and w nadler 2000 , go with the winners - simulations , cond - mat/0010265 , proceedings der heraeus - ferienschule `` vom billiardtisch bis monte carlo : spielfelder der statistischen physik '' , chemnitz , october 2000 ;    e j janse van rensburg , s.g.whittington , and n. madras 1990 , the pivot algorithm and polygons : results on the fcc lattice , j. phys . a,*23 * 1589 .",
    "t kennedy 2002 , a faster implementation of the pivot algorithm for self - avoiding walks , j. stat .",
    "phys . * 106 * 407 - 429    a berreti and a.d.sokal 1985 , new monte carlo method for self - avoiding walk , j. stat .",
    "* 40 * 483    e j janse van rensburg and n madras , a nonlocal monte carlo algorithm for lattice trees , j. phys . a : math",
    "* 25 * 303 - 333(1992 ) ; metropolis monte carlo simulation of lattice animals , j phys .",
    "a : math . gen . * 30 * 8035 - 8066 ( 1997 ) ; e j janse van rensburg and a rechnitzer 2003 , high precision canonical monte carlo determination of the growth constant of square lattice trees , phys .",
    "rev e * 67 * 0361161 - 0361169    s you and e j janse van rensburg 2001 , adsorbing trees in two dimensions : a monte carlo study , phys .",
    "* 64 * 0461011 - 0461019 .",
    "h p hsu , w nadler and p grassberger 2004 , simulations of lattice animals and trees , cond - mat/0408061    s redner and p.j . reynolds 1981 , position - space renormalisation group for isolated polymer chains , j. phys .",
    "a * 14 * 2679 .",
    "d dhar and p m lam 1986 , a monte carlo method for series expansions , j. phys . a : math",
    "* 19 * l1057 - 1061    p m lam 1986 , monte carlo study of lattice animals in @xmath183 dimensions , phys .",
    "rev . a , vol . * 34 * 2339 - 2345 .",
    "j. l. martin 1974 , computer techniques for evaluating lattice constants , phase transitions and critical phenomena , eds .",
    "domb and green , vol . * 3*.    t e harris 1963 , theory of branching processes , springer - verlag berlin .",
    "g grimmett 1989 , percolation , springer - verlag    n madras and g slade 1993 , the self avoiding walk , birkhauser boston .",
    "b. nienhuis 1982 , exact critical point and critical exponents of o(n ) models in two dimensions , phys .",
    "* 49 * , 1062    i jensen and a j guttmann 1999 , self - avoiding polygons on the square lattice , cond - mat/9905291    r p stanley 1999 , enumerative combinatorics , vol.2 chapter 6 , cambridge university press , cambridge - new york .    wim van saarloos 2003 , front propagation into unstable states , phys . rep . *",
    "386 * 29    e brunet and b derrida 1997 , shift in the velocity of a front due to a cutoff , phys .",
    "e * 56 * 2597 ; s n majumdar and p.l kaprivsky 2003 , extreme value statistics and travelling fronts : various applications , physica a * 318 * 161    i jensen 2001 , enumerations of lattice animals and trees , j. stat .",
    ". vol . * 102 * 865 - 881 .",
    "k. barat and b. k. chakrabarti 1995 , statistics of self - avoiding walks on random lattices , phys .",
    "rep . * 258 * 377 .",
    "* figure1:an example of a genealogical tree .",
    "the numbers labelling the sites indicate the order in which they are added ( @xmath26 represents the root site ) .",
    "the tree shown is for directed lattice site animals on a square lattice .",
    "* figure2:plot of optimum values of @xmath19 on a @xmath140 tree of depth @xmath411 * figure3 : @xmath412 of ie as a function of size @xmath0 for saw on a @xmath27 , @xmath97 and @xmath170 dimensional hyper cubic lattice .",
    "the lower most graph is for saw on a square lattice and middle one in @xmath413 and the topmost is for @xmath414 .",
    "* figure4:probability of getting a walk of size n on a square lattice for ie and iie . * figure5:@xmath415 of iie vs size n for saw on a @xmath416 and @xmath417 dimensional hyper cubic lattice .",
    "* figure6:first few levels of the genealogical tree for lattice animals on a binary tree .",
    "solid circles represent the occupied sites and crossed circles denote blocked sites on the bethe lattice .",
    "dotted lines sketch the underlying bethe lattice , whereas solid lines represent the bonds present .",
    "* figure7:plot of @xmath251 vs scaled @xmath418 , for @xmath419 and @xmath420 and @xmath421 and @xmath422 .",
    "all the nine curves collapse to the same front profile .",
    "* figure8:plot of @xmath423 as a function of @xmath268 at @xmath260 for @xmath424 and @xmath425 .",
    "all the curves are very close and approach a limiting form with increasing @xmath22 .",
    "the dotted line is just the line @xmath426 .",
    "* figure9:the width @xmath284 of the travelling front as a function of @xmath261 for different values of @xmath78 .",
    "the value of @xmath78 increases from left to right .",
    "curves of left of @xmath260 are for @xmath258 and the ones on right are for @xmath267 . for @xmath260",
    "the graph approaches a straight line as @xmath246 .",
    "* figure10:thick line is the plot of @xmath427 as a function of @xmath261 , when @xmath78 is taken to be @xmath247 .",
    "the dotted line is a straight line of slope @xmath428 .",
    "* figure11:plot of @xmath429 for @xmath382 and @xmath26 as a function of @xmath266 for @xmath430 . *",
    "figure12:plot of @xmath338 vs @xmath395 for lattice animals on a square lattice with ie and iie . * figure13:plot of @xmath431 vs @xmath432 for directed animals with iie ."
  ],
  "abstract_text": [
    "<S> we study the efficiency of the incomplete enumeration algorithm for linear and branched polymers . </S>",
    "<S> there is a qualitative difference in the efficiency in these two cases . the average time to generate </S>",
    "<S> an independent sample of configuration of polymer with @xmath0 monomers varies as @xmath1 for linear polymers for large @xmath0 , but as @xmath2 for branched ( undirected and directed ) polymers , where @xmath3 . on the binary tree , </S>",
    "<S> our numerical studies for @xmath0 of order @xmath4 gives @xmath5 . </S>",
    "<S> we argue that @xmath6 exactly in this case .    </S>",
    "<S> -.5 cm .125 cm    3.9ex    monte - carlo(mc ) simulations are a very important tool for studying polymers , as exact results are hard to come by , and are available only for the simplest models . broadly speaking , </S>",
    "<S> mc algorithms fall in two classes @xcite : the metropolis type and the genetic type . </S>",
    "<S> the metropolis type algorithms generate a time sequence of configurations of the polymer using a markovian evolution . </S>",
    "<S> the transition probabilities from one configuration to the next are so chosen that the time average of properties of the system are equal to that from the desired distribution . </S>",
    "<S> these may use local moves as in rouse dynamics @xcite , bi - local moves as in the reptation algorithm @xcite or nonlocal moves as in the pivot @xcite and cut - and - paste @xcite algorithms . </S>",
    "<S> there is inevitably some correlation between different configurations generated in an evolution . </S>",
    "<S> these algorithms become inefficient if the correlation time becomes very large , eg . when simulating polymers in a random medium .    in the genetic algorithms , </S>",
    "<S> one randomly generates a small random number of configurations in each run . </S>",
    "<S> the probability that a given configuration is obtained in a run is proportional to the desired distribution . </S>",
    "<S> one repeats the process for many runs to get a large sample . </S>",
    "<S> examples of this type are the enrichment @xcite and the pruned - enriched rosenbluth method(perm)-like @xcite algorithms .    </S>",
    "<S> while there have been many studies of linear polymers using various monte - carlo techniques like pivot @xcite , perm @xcite , berreti - sokal algorithms @xcite , branched polymers have been less studied . </S>",
    "<S> algorithms used for simulating linear polymers can often be adapted for branched polymers , but they are usually found to be less efficient . </S>",
    "<S> for example , in the pivot algorithm , the acceptance probability of the transformed configuration is found to be much less for branched polymers than for linear polymers @xcite . </S>",
    "<S> the algorithm does not perform well for branched polymers adsorbed on a surface@xcite . </S>",
    "<S> the perm algorithm also seems to work less well for branched polymers than for linear polymers @xcite . </S>",
    "<S> incomplete enumeration(ie ) is an algorithm belonging to the genetic class of algorithms . </S>",
    "<S> it has been used for simulating linear polymers@xcite , and for branched polymers @xcite .    </S>",
    "<S> a better understanding of the efficiency of monte carlo algorithms for generating branched polymers seems desirable . </S>",
    "<S> we will study ie for linear and branched polymers in this paper . </S>",
    "<S> we choose the average computer time @xmath7 needed to generate one statistically independent sample of desired size @xmath0 as a reasonable measure of efficiency of the algorithm . </S>",
    "<S> the dependence of @xmath7 on @xmath0 is very different for ie for linear and branched polymers . </S>",
    "<S> we find for the linear polymers @xmath8 , but for branched polymers @xmath9 , @xmath3 . </S>",
    "<S> we also discuss an improvement of ie which we call improved incomplete enumeration ( iie ) , in this paper . </S>",
    "<S> we find that the improvement does not change the asymptotic dependence of @xmath7 on @xmath0 in general . </S>",
    "<S> iie works better than ie but the difference is only in the coefficient @xmath10 .    </S>",
    "<S> the plan of the paper is as follows . </S>",
    "<S> we describe the ie algorithm in section 1 . in section 2 </S>",
    "<S> we discuss the efficiency criterion for mc algorithms in general , and for ie in particular . in section 3 </S>",
    "<S> we study the efficiency of ie analytically for some simple cases where the genealogical tree has a simple recursive structure . </S>",
    "<S> we also study ie for self avoiding walks(saw ) in this section . in all cases </S>",
    "<S> we find that @xmath11 . in section 4 </S>",
    "<S> we propose an improved version of the ie algorithm , iie . for simple </S>",
    "<S> random walks @xmath12 for the iie algorithm as compared to @xmath11 for ie . for saws , iie is significantly more efficient and becomes better in higher dimensions , but asymptotic efficiency remains the same and @xmath13 in all dimensions , though the coefficient @xmath14 decreases with increasing dimension . in section 5 we study ie for branched polymers or lattice animals on a binary tree . </S>",
    "<S> we give heuristic arguments and numerical evidence to show that @xmath15 for large @xmath0 for branched polymers on a binary tree . </S>",
    "<S> we also study ie and iie numerically for undirected and directed branched polymers on a square lattice in this section . </S>",
    "<S> we find that in both cases @xmath16 , @xmath3 . </S>",
    "<S> we summarise our results in section 6 . </S>"
  ]
}