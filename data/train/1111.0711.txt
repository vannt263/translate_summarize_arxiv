{
  "article_text": [
    "two broad classes of methods have emerged for the construction of low - density parity - check ( ldpc ) codes  @xcite .",
    "one set of methods is based on highly random graph constructions , while the other is based on structured algebraic constructions .",
    "it is now well - known that random constructions ( see , e.g. , @xcite ) can produce ldpc codes that closely approach the shannon capacity",
    ". however , highly random constructions are not easy to implement in hardware as the irregular connections between check and variable nodes in the code graph imply high wiring complexity . in actual implementations ,",
    "more structured constructions have been strongly preferred because they result in much more practical wiring and more straightforward parallelism in the decoders .",
    "quasi - cyclic ldpc ( qc ldpc ) codes are a particularly practical and widely - used class of structured ldpc codes .",
    "these codes have a parity check matrix which is broken into sub - matrices that have a circulant structure .",
    "qc ldpc codes are featured in a variety of communications system standards , such as ieee 802.16e @xcite , dvb - s2@xcite and 802.11 @xcite . in view of their practicality",
    ", we focus in this paper on the design of qc ldpc codes that have good decoding performance .    for nearly any application",
    ", it is important to optimize decoding performance in the `` water - fall '' regime where the signal - to - noise ratio ( snr ) is relatively low .",
    "the standard way to do that for irregular random constructions is to use `` density - evolution '' or `` exit chart '' techniques to obtain the degree distribution that optimizes the code threshold in the asymptotic limit of long block lengths @xcite .",
    "these techniques can also be adapted to qc ldpc codes @xcite .",
    "however , for some applications , optimizing water - fall performance is not sufficient , and one must also avoid the `` error floors '' that plague many ldpc codes in the higher snr regime .",
    "an `` error floor '' in the performance curve means that the decoding failure rate does not continue to decrease rapidly as the snr increases .",
    "eliminating or lowering error floors is particularly important for applications that have extreme reliability demands , including magnetic recording and fiber - optic communication systems .    in the past ,",
    "qc ldpc codes have been constructed based on a wide variety of mathematical ideas , including finite geometries , finite fields , and combinatorial designs @xcite .",
    "recently , there has also been great interest in the class of `` convolutional '' @xcite or `` spatially - coupled '' @xcite ldpc codes .",
    "these codes have much more structured than traditional random constructions .",
    "they have also been shown , using density evolution techniques , to approach shannon capacity closely , or even provably to achieve it on the binary erasure channel ( bec ) @xcite .",
    "these codes are significant here , because they can be implemented using quasi - cyclic constructions , and they should thus be able to achieve very good performance while retaining the practicality of other structured qc ldpc codes . in this paper , we will focus on the design of qc ldpc codes based on structures that let them perform near the shannon limit in the waterfall regime ( such as spatially coupled codes ) but we also aim for excellent error floor performance .",
    "error floor issues for ldpc codes are investigated in @xcite , which shows that error floors in belief propagation ( bp ) ldpc decoders are generally caused by `` trapping sets . ''",
    "a trapping set is a set of a small number of bits that reinforce each other in their incorrect beliefs . trapping sets of bits",
    "are invariably arranged in clustered short cycles in a code s tanner graph  @xcite . therefore , one way to try to remove trapping sets is to design the code s tanner graph carefully so that the dangerous clusters of short cycles do not exist .",
    "an alternative , and at least conceptually simpler approach , is to design codes with larger girths  the `` girth '' of a code is the length of the shortest cycle in the code graph . by removing short cycles ,",
    "we remove large swaths of potentially dangerous configurations of cycles and , at one fell swoop , hopefully lower the error floor .",
    "motivated by this idea , in this paper , we focus on optimizing the girth of qc ldpc codes that have also been optimized for waterfall performance . in this way",
    "we hope to design a practical code that simultaneously has good waterfall and error floor performance .",
    "there has been considerable work on optimizing girth in ldpc codes .",
    "in  @xcite a progressive - edge growth ( peg ) algorithm is proposed for random ldpc codes .",
    "the peg technique is generalized to qc ldpc codes in  @xcite .",
    "another approach to optimizing the girth of qc ldpc codes is studied in  @xcite , where high - girth qc ldpc codes are obtained using a random `` guess - and - test '' algorithm .",
    "shortened array codes with large girth are proposed in  @xcite .",
    "however , after shortening , the resulting codes no longer have a quasi - cyclic structure . in  @xcite",
    ", another class of large girth qc ldpc codes is designed , where the methodology is mainly for regular ldpc codes .    in this paper",
    ", we propose a hill - climbing search algorithm for optimizing girth that is more efficient than previous techniques .",
    "the hill - climbing algorithm greedily adjusts an initial qc ldpc code ( hopefully ) to find a code of short length that meets the specified code and girth parameters .",
    "since the algorithm is greedy , it can get stuck in local minima .",
    "however , given a set of parameters , the algorithm finds qc ldpc codes of shorter length and in less time than guess - and - test or peg .",
    "codes with good water - fall performance inevitably have some irregularity in the degree - distribution of the factor or variable nodes of the code graph . for the case of qc ldpc codes",
    ", these irregular distributions are most easily described in terms of `` protographs '' @xcite .",
    "protographs are variants of tanner graphs where bits and checks of the same type are represented by a single `` proto - bit '' or `` proto - check . '' in the case of qc ldpc codes , proto - bits can , for example , represent sets of bits belonging to the same circulant sub - matrices .    the protographs that arise in codes that have been optimized for waterfall performance typically have some pairs of proto - bits and proto - checks that are connected by multiple edges . a straightforward way to handle this would be to use qc ldpc codes where the circulant matrices had rows and columns of weight greater than one .",
    "however , as we shall see , this direct approach inevitably introduces short cycles into the graph .",
    "the tricky problem of creating qc ldpc codes with good girth and that correspond to protographs optimized for waterfall performance is solved in this paper by a somewhat complicated procedure .",
    "first , we need to introduce a new family of generalized qc ldpc codes , which we call `` hierarchical '' qc ldpc ( hqc ldpc ) codes .",
    "the parity check matrices of these hierarchical codes consist of circulant sub - matrices , which in turn consist of of circulant sub - sub - matrices , and so on for multiple `` levels . ''",
    "we show that we can directly transform any protograph with multiple edges between proto - checks and proto - bits into a _ two - level _ hqc ldpc code with circulant matrices with higher weight at second level .",
    "it turns out that many different hierarchical qc ldpc codes correspond to a particular protograph , and thus many degrees of freedom exist following the `` direct '' transformation .",
    "we use our hill - climbing algorithm to choose from this family to get rid of as many short cycles as possible . however , hqc ldpc codes with weights greater than one at higher levels will also automatically have some short cycles , just as non - hierarchical qc ldpcs do",
    ". our hill - climbing algorithm can do nothing about these `` inevitable '' cycles but it can , hopefully , eliminate all short non - inevitable cycles . to get ride of the inevitable cycles we introduce a `` squashing '' procedure .",
    "the squashing step destroys the hierarchical structure of the code , but the squashed code nevertheless remains a qc ldpc code that corresponds to the desired protograph .",
    "the squashing procedure is computationally trivial .",
    "this makes the two - step procedure ",
    "first hqc ldpc then squash into a qc ldpc code ",
    "much more computationally efficient than directly applying our hill - climbing procedure to maximize the girth of higher - weight qc ldpc codes with the desired protograph structure .",
    "thus hierarchical qc ldpc codes are a necessary intermediate stage in the design of practical qc ldpc codes that will simultaneously have good waterfall and error floor performance .",
    "the rest of the paper will explain in much more detail the ideas outlined above .",
    "we begin in section  [ sec.defqc_ldpc ] by reviewing the standard construction of qc ldpc codes in terms of their parity check matrices .",
    "then in section  [ sec.protographs ] , we review the standard tanner graph representation of ldpc codes and the `` protograph '' representation of structured codes . in section  [ sec.findcycles ]",
    "we show how short cycles can be identified from the parity check matrix of a qc ldpc code .",
    "we discuss why the most direct transformation of the protographs of interesting ldpc codes , such as spatially coupled codes , into qc ldpc codes will lead to inevitable short cycles in the tanner graph of the resulting codes .",
    "this leads us to the heart of our paper , where we introduce hierarchical qc ldpc codes that can be used to solve the problem of inevitable short cycles . in section  [ sec.defhierqc_ldpc ]",
    "we introduce the most general form of hqc ldpc codes and show that they can be described both in terms of a multi - variate polynomial parity check matrix in multiple variables and in terms of a tree structure . in section  [ sec.condforcycles ] , we explain how to find cycles in the tanner graphs of hqc ldpc codes . in section  [ sec.girthmax ]",
    "we describe our hill - climbing algorithm for finding high girth qc ldpc codes and hqc ldpc codes . in section  [ sec.pipeline ] ,",
    "we discuss restricted two - level hqc ldpc codes , the direct transformation of protographs into such codes , and the `` squashing '' procedure that efficiently eliminates inevitable cycles . finally , in section  [ sec.results ] , we exhibit high - girth qc ldpc codes that simultaneously have good waterfall behavior ( because they are spatially - coupled codes ) and have good error - floor behavior resulting from their high girth ( which in turn is a result of the fact that they are squashed versions of hqc ldpc codes ) .",
    "many details and lemmas are deferred to the appendices .",
    "we begin by reviewing the construction of standard quasi - cyclic low - density parity - check ( qc ldpc ) codes as previously described in the literature @xcite . in section  [ sec.defhierqc_ldpc ]",
    "we will generalize these codes and introduce a novel _ hierarchical _ family of qc ldpc codes .    before considering the general case of standard qc ldpc codes ,",
    "it is helpful to start with an important special case , that we will call `` weight - i @xmath0 regular '' qc ldpc codes .",
    "the parity check matrix of these codes consists of @xmath1 sub - matrices , each of which is a @xmath2 circulant permutation matrix .",
    "let @xmath3 denote the circulant permutation matrix , or `` cyclic shift matrix , '' obtained by cyclically right - shifting a @xmath4 identity matrix by @xmath5 positions , where @xmath6 ; @xmath7 is thus the @xmath2 identity matrix .",
    "we often suppress the dependence on @xmath8 , writing @xmath9 instead of @xmath10 . as an example , if @xmath11 , then @xmath12.\\ ] ]    we can write the parity check matrix of a weight - i @xmath0 regular qc ldpc code using @xmath13 rows and @xmath14 columns of @xmath2 cyclic shift sub - matrices : @xmath15 . \\label{eq.parchkexainit}\\ ] ] the blocklength of such a code is @xmath16 .    using @xmath17 , we can re - write  ( [ eq.parchkexainit ] ) as @xmath18 . \\label{eq.parchkexa}\\ ] ]    we can now abstractly represent @xmath19 as a matrix whose entries are powers of a dummy variable @xmath20 : @xmath21 . \\label{eq.polyparchkexa}\\ ] ]    the point of all these trivial re - writings will now become clear : we can generalize such a matrix @xmath22 to a parity check matrix whose entries are _ polynomials _ in @xmath20 , giving us the _ polynomial _ parity check matrix of a standard qc ldpc code : @xmath23 , \\label{eq.polyparchkgeneral}\\ ] ] where @xmath24 x^s \\label{eq.standardcoefficients}\\ ] ] for @xmath25 , @xmath26 .    for _ binary _ qc ldpc codes , which will be our focus for the rest of this paper ,",
    "the polynomial coefficients @xmath27 $ ] must all be 0 or 1 .",
    "[ ex.qcldpc ] let @xmath28 be a length-@xmath29 qc ldpc code described by    @xmath30.\\ ] ]    for this code @xmath31 , @xmath32 , and @xmath33 , and @xmath19 can equivalently be written as @xmath34.\\ ] ] the polynomial version of the parity check matrix is @xmath35 = \\left [ \\begin{array}{ccc } 1 & 1 & 1 \\\\ 0 & 1 &      x^1 + x^2 \\end{array } \\right ] .",
    "\\label{eq.polychkmatexa}\\ ] ]    in  @xcite , smarandache and vontobel classified qc ldpc codes according to the maximum weight among the circulant sub - matrices in their parity check matrix , or equivalently , according to the maximum weight of the polynomials in their polynomial parity check matrix .",
    "( the weight of a polynomial as simply the number of non - zero terms in that polynomial . ) they defined a `` type-@xmath36 '' qc ldpc code as one for which the maximum weight among all polynomial entries @xmath37 in @xmath22 is @xmath36 .",
    "we will change their terminology slightly and call such a code a _",
    "weight-@xmath36 _ qc - ldpc code    since @xmath38 in the code of example [ ex.qcldpc]that is , @xmath39 is a binomial  and because @xmath40 for all @xmath41 , @xmath26 , the code in example  [ ex.qcldpc ] is a weight - ii qc ldpc code .    for any qc ldpc code",
    ", we define the vector of weight sums @xmath42 for @xmath26 , to be the `` column weight sum , '' @xmath43 , of @xmath22 .",
    "we define the row weight sum @xmath44 of @xmath22 similarly .",
    "thus , the code of example [ ex.qcldpc ] has column and row weight sums @xmath45 ; \\hskip 1.0em { \\rm wt}_{\\rm    row}({\\textbf{h}}(x ) ) = [ 3 \\ ; 3].\\ ] ]    it should now be clear why we previously referred to codes of the form of equation  ( [ eq.parchkexainit ] ) or ( [ eq.polyparchkexa ] ) as `` weight - i '' codes , as all the entries in the polynomial parity check matrix are monomials .",
    "the class of weight - i codes is more general than that shown in equation  ( [ eq.parchkexainit ] ) though : some of the cyclic shift sub - matrices could be replaced with all - zeros matrices .    as we often work with weight - i qc ldpc codes , and these codes are particularly important in practice , we introduce some additional useful notation for them .",
    "we define the _ base matrix _ of a weight - i qc ldpc code to be the @xmath46 matrix of powers ( circulant shifts ) that defines the code , i.e. , @xmath47 where logarithms are taken entry - by - entry , and where we define @xmath48 to be @xmath49 , used to indicate an all - zero sub - matrix . for example",
    ", the base matrix corresponding to the parity check matrix ( [ eq.polyparchkexa ] ) is simply @xmath50.\\end{aligned}\\ ] ]",
    "as is very well known , an ldpc code can either be represented by its parity check matrix @xmath19 , or equivalently by its tanner graph @xcite .",
    "a tanner graph for an ldpc code is a bi - partite graph consisting of `` variable '' nodes representing the codeword bits , and `` check '' nodes representing the parity checks , where a variable node is connected to a check node by an edge if and only if the corresponding entry in @xmath19 is nonzero .",
    "the degree of a node is defined as the number of edges incident to that node .",
    "a `` protograph , '' as introduced by thorpe in @xcite , is a template that can be used to derive a class of tanner graphs .",
    "each node in a protograph represents a `` type '' of node in a tanner graph .",
    "the nodes will all be duplicated @xmath8 times in the tanner graph derived from the protograph .        as an example , consider fig .",
    "[ fig : proto1 ] , which shows a simple example of a protograph that has three types of variable nodes and two types of check nodes .",
    "this protograph tells us that each check of type a should be connected to one variable of each of the three types , and each check of type b should be connected to one variable of type 2 and two variables of type 3 .",
    "similarly , each variable of type 1 should be connected to one check of type a , and so on .    .",
    "the tanner graph in ( a ) does not have a quasi - cyclic structure ; the one in ( b ) does , and in fact has the parity check matrix of the qc ldpc code given in example  [ ex.qcldpc].,width=307 ]    fig .",
    "[ fig : proto2 ] shows two tanner graphs derived from the protograph of fig .",
    "1 , with @xmath51 . note that there are many possible tanner graphs that one can construct that correspond to a particular protograph , and they need not necessarily have a quasi - cyclic structure . the tanner graph shown in fig .",
    "[ fig : proto2 ]  ( a ) is not quasi - cyclic .",
    "but it is always easy to construct a quasi - cyclic version of any protograph .",
    "in fact , protographs can equivalently be described by a `` connectivity matrices . ''",
    "a connectivity matrix has a number of rows equal to the number of types of checks in the protograph and a number of columns equal to the number of types of variables .",
    "each entry in the connectivity matrix tells you how many edges there are connecting a type of check node to a type of variable node in the protograph .",
    "for example , the connectivity matrix @xmath52 for the protograph in fig .",
    "[ fig : proto1 ] would be @xmath53 .",
    "\\label{eq : cmatrix}\\ ] ]    to derive a quasi - cyclic parity - check matrix @xmath22 from the template specified by a particular protograph , one can simply replace each entry in the equivalent connectivity matrix with a polynomial of weight equal to the entry .",
    "we will call this procedure a `` direct transformation '' of a protograph into a qc ldpc code .    for example , the protograph in fig .",
    "[ fig : proto1 ] which has the connectivity matrix @xmath52 given in ( [ eq : cmatrix ] ) , can be directly transformed into a qc ldpc code with parity check matrix @xmath54,\\ ] ] where @xmath55 , @xmath56 , @xmath57 , @xmath58 , @xmath59 and @xmath60 are integer exponents between @xmath61 and @xmath62 , with @xmath63 .",
    "there are many possible direct transformations of a protograph into a qc ldpc code , depending on what exponents one chooses for the polynomials ; one particular direct transformation would convert this protograph into the qc ldpc code with parity check matrix @xmath64.\\ ] ] which would correspond to the tanner graph shown in fig .",
    "[ fig : proto2 ]  ( b ) and the code given in example  [ ex.qcldpc ] .",
    "in this section we discuss how to identify cycles in qc ldpc codes from their parity check matrices .",
    "each check node in the tanner graph of a code corresponds to a row in its parity check matrix , and each variable node corresponds to a column .",
    "a cycle is a path through nodes in the tanner graph , alternating between check and variable nodes , that starts and ends at the same node . in terms of the code s parity check matrix ,",
    "a cycle can be visualized as a sequence of alternating vertical horizontal moves through the matrix starting and ending on the same row of the matrix .",
    "a vertical move ( along a column ) corresponds to choosing a second edge connected to the same variable node that will form the next step in the cycle .",
    "a horizontal move ( along a row ) corresponds to choosing two edges connected to the same check node that form part of the path .    for qc ldpc codes",
    "there are efficient ways to describe sets of cycles in terms of the code s polynomial parity check matrix . in section  [ sec.findcyclesintro ]",
    "we introduce the basic ideas behind identifying cycles in weight - i qc ldpc codes . in section  [ sec.findcyclesnonhier ] ,",
    "we show how to identify cycles in qc ldpc codes of arbitrary weight",
    ". then , in section  [ sec.inevitable ] , we show that higher - weight qc ldpc codes with certain characteristics inevitably have short cycles , and point out that this poses an obstacle to constructing qc ldpc codes with good girth and good waterfall performance ",
    "an obstacle that we will overcome by introducing hierarchical qc ldpc codes .      to make the logic of the section introduction more concrete ,",
    "consider fig .",
    "[ fig.findcycle ] which depicts the parity check matrix of a weight - i qc ldpc code with parameters @xmath65 , @xmath66 , and @xmath33 .",
    "we focus in on the four @xmath67 cyclic shift matrices ( represented by the black squares ) @xmath68 , @xmath69 , @xmath70 , and @xmath71 .",
    "two choices for the parameters of these four matrices are shown in the sub - figures : @xmath72 , @xmath73 , @xmath74 , and @xmath75 on the left , and @xmath72 , @xmath76 on the right .",
    "circulant permutation matrices ( @xmath68 , @xmath69 , @xmath70 and @xmath71 ) selected from it .",
    "one set of parameters ( lower left , @xmath72 , @xmath73 , @xmath77 , @xmath75 ) results in a cycle of length four . an alternate set ( lower right , @xmath78 , @xmath76 ) results in a cycle of length twelve . ]    consider any path through the base matrix of the code . due to the way we generate the code s parity check matrix by replacement of each base matrix entry by a @xmath2 circulant matrix , a path through the base matrix corresponds to @xmath8 paths through the tanner graph of the code . for any of these paths through the tanner graph to be a cycle",
    ", the path must end at the same variable node from which it started .",
    "for this to happen in a weight - i qc ldpc code , it is necessary for the path through the base matrix to form a cycle , without passing through any all - zeros matrices .",
    "but this is not sufficient , since each cyclic shift matrix corresponds to @xmath8 parity and @xmath8 variable nodes .",
    "the path could end up at a different variable node in the same cyclic shift matrix and not complete a cycle .",
    "the necessary and sufficient condition for cycles to exist is that when the path through the base matrix returns to the starting entry , it returns to the same column of the cyclic shift matrix from which it started . in the example of fig .",
    "[ fig.findcycle ] , consider the path through the base matrix starting at the entry labeled @xmath55 , then progressing through the entries labeled @xmath56 , @xmath57 , and @xmath58 in turn , and terminating at the entry labeled @xmath55 .",
    "the corresponding path through the parity check matrix , with parameter settings @xmath78 , @xmath73 , @xmath79 , @xmath75 , is depicted in the left - hand example of fig .",
    "[ fig.findcycle ] and results in a cycle of length four .",
    "however , with the slightly different choice of circulant shifts of the right - hand example , a return to the same column of the cyclic shift matrix occurs only after two more passes around the base matrix and an overall cycle of length @xmath80 .",
    "we now specify the conditions on the @xmath81 that result in a cycle ( in fact in a set of @xmath8 cycles ) .",
    "calculate an alternating sum of the shift indices associated with neighboring permutation matrices along a given path , where every odd shift index is subtracted rather than added .",
    "for example , consider the left - hand path of fig .",
    "[ fig.findcycle ] .",
    "the sum is @xmath82 .",
    "each difference between neighboring shift indices in the sum corresponds to the shift in what column ( i.e. , what variable node ) of the cyclic permutation matrices the path passes through .",
    "only if the differences sum to zero ( mod-@xmath8 ) at the end of the path will the path return to the same variable node in the starting permutation matrix , thereby forming a cycle .",
    "for the example of fig .",
    "[ fig.findcycle ] , the condition for a length - four cycle to exist is : @xmath83 which is satisfied for @xmath72 , @xmath73 , @xmath74 , @xmath75 , but is not satisfied by @xmath72 , @xmath84 .",
    "we now take a step up in complexity from weight - i qc ldpc codes , and consider the more involved example of the weight - ii code of example  [ ex.qcldpc ] from section  [ sec.defqc_ldpc ] .",
    "recall that this code is defined by the @xmath85 polynomial parity - check matrix @xmath35 . \\label{eq.polychkmatexa2}\\ ] ]    in terms of the coefficients @xmath27 $ ] defined by @xmath86 x^s$ ] ( see ( [ eq.standardcoefficients ] ) ) , we have that all the coefficients @xmath27 $ ] are equal to zero except for @xmath27 = 1 $ ] when @xmath87 and @xmath88 equals @xmath89 , @xmath90 , @xmath91 or @xmath92 , and for @xmath93 or @xmath94 , when @xmath95 .",
    "now , consider the following ordered series : @xmath96 where each pair @xmath88 in @xmath97 satisfies @xmath98 and @xmath99 .",
    "this ordered series specifies a sequence of rectilinear moves through @xmath22 .",
    "these moves are analogous to those in fig .",
    "[ fig.findcycle ] with the important distinction that if the polynomial in position @xmath88 has more than one term ( that is , @xmath100 $ ] is non - zero for more than one value of @xmath101 ) , then the next pair in the sequence _ can _ be the same .",
    "for example , in  ( [ eq.ordserex ] ) the third , fourth , and fifth pairs are identical .    to specify a candidate cycle through the tanner graph , we associate a coefficient index @xmath101 with each pair @xmath88 in @xmath97 , such that @xmath27 \\ne 0 $ ] .",
    "we denote this series of coefficient indices by @xmath102 . to ensure that each step in the series corresponds to traversing a distinct edge in the tanner graph we require the following of neighboring pairs @xmath103 and @xmath104 in @xmath97 and the corresponding neighboring coefficient indices @xmath105 and @xmath106 in @xmath102 : if @xmath107 , then the corresponding indices @xmath108 .",
    "the candidate cycle will actually be a cycle if the alternating sum of coefficient indices in @xmath102 modulo @xmath8 equals zero .    in our example",
    ", consider the two following choices for the respective ( ordered ) sets of coefficient indices : @xmath109 each of these choices corresponds to a cycle of length-@xmath110 through the tanner graph of the code , illustrated in fig .",
    "[ fig.weightiicycles ] .",
    "the alternating sums modulo-@xmath111 can be verified to be equal to zero . respectively",
    "these sums are : @xmath112     cycles through the tanner graph of the weight - ii qc ldpc code of example  [ ex.qcldpc ] . ]",
    "unfortunately , the logic described in the previous section implies that higher - weight qc ldpc codes will inevitably contain short cycles .",
    "let us begin with a straightforward and important theorem , already proven by smarandache and vontobel @xcite , that states that any weight - iii qc ldpc code will inevitably contain cycles of length six . to prove this",
    ", we note that we can choose a cycle with an ordered series @xmath113 of six identical entries such that each pair @xmath88 gives the row @xmath114 and column @xmath115 of the same weight - iii polynomial in the parity check matrix @xmath22 .",
    "suppose , without loss of generality , that the weight - iii polynomial has the form @xmath116 .",
    "then we can choose for the cycle an ordered set of coefficient indices @xmath117 and we will find that @xmath118 automatically for any @xmath8 .",
    "smarandache and vontobel also proved ( see their theorem 17 ) that if the parity check matrix @xmath22 of a weight - ii qc ldpc code contains two weight - two polynomials in the same row or the same column , that code will inevitably have eight - cycles . again , this is easy to verify using our approach .",
    "suppose for example that the two weight-2 polynomials are in the same row @xmath114 and two different columns @xmath119 and @xmath120 , and that the polynomial at @xmath121 is @xmath122 , while the polynomial at @xmath123 is @xmath124 .",
    "we can find an eight - cycle that has the ordered series @xmath125 and the ordered set of indices @xmath126 so that we find @xmath127 regardless of the value of @xmath8 .",
    "these inevitable six - cycles and eight - cycles at first sight appear to put serious limitations on what protographs can be converted into quasi - cyclic codes with high girth .",
    "we noted in section  [ sec.protographs ] that a protograph could be equivalently described using a connectivity matrix , and that a parity check matrix of a quasi - cyclic code could be derived from the connectivity matrix by the `` direct transformation '' which replaces the entries of the connectivity matrix by polynomials with weight equal to the entry .",
    "we now see that if , for example , the protograph has a type of variable that is connected to a type of check by three edges , a direct transformation will inevitably lead to six - cycles in the obtained qc ldpc code .        furthermore , protographs with higher edge weights are not particularly exotic .",
    "consider for example the protographs shown in fig .",
    "[ fig.onesided ] , which are the protographs for `` one - sided '' spatially coupled codes as described by kudekar et al .",
    "notice that if we used a direct transformation to convert these protographs into qc ldpc codes , the qc ldpc codes corresponding to the protographs in fig .",
    "[ fig.onesided ]  ( a ) would inevitably have eight - cycles , while those in fig .",
    "[ fig.onesided ]  ( b ) would inevitably have six - cycles .",
    "it turns out that there do exist techniques to construct qc ldpc codes corresponding to these protographs that have girth of 10 or greater , but to understand these techniques , we need to make an apparent detour , and introduce _ hierarchical _ qc ldpc codes .",
    "@xmath128 \\label{eq.polyparchkb } \\\\",
    "\\nonumber\\\\ { \\textbf{h}}(x , y ) & = \\left[\\begin{array}{c|c|c|c } x^2 + ( x+x^7)y^2 &      x^7y+ ( 1+x^6)y^2 & 0 & x^2 + x^5y + y^2\\\\ \\hline      x^7y+ ( 1+x^6)y^2 & x^2 + ( x+x^7)y^2 & x^2 + x^5y + y^2 & 0 \\end{array } \\right ] \\label{eq.polyparchktwovarb }",
    "\\\\ \\nonumber \\\\ { \\textbf{h}}(x , y , z ) & = \\big [ x^2 + ( x+x^7)y^2 + ( x^7y+(1+x^6)y^2)z \\ ; \\big|    \\ ; ( x^2+x^5y+y^2)z\\big ] \\label{eq.polyparchkthreevarb}\\end{aligned}\\ ] ]",
    "we now introduce _ hierarchical _ qc ldpc codes ( hqc ldpc codes ) , motivated by the fact that these codes will ultimately enable us to solve the problem of constructing qc ldpc codes corresponding to protographs with multiple edges between check and variable types , without creating inevitable short cycles in the tanner graph of the code .",
    "however , because these codes may eventually have other applications , we present their construction in a form that is actually more general than we will need for the purpose of eliminating inevitable short cycles .",
    "a hierarchical qc ldpc code is formed from `` levels '' that each have a quasi - cyclic structure .",
    "the structure can be specified in two equivalent , complementary forms : one in terms of the polynomial parity check matrices of these codes , and another in terms of the `` tree structure '' of these codes .      before fully defining hqc ldpc codes formally",
    ", it is easier to have a concrete example in mind .",
    ".1 cm    [ ex.hierqcldpc ] consider the polynomial parity check matrix specified in equation  ( [ eq.polyparchkb ] ) with @xmath129 . because the highest weight of any of the polynomial entries is @xmath130 , ( e.g. , @xmath131 ) , and",
    "because there are @xmath80 columns in the matrix , this is a length-96 weight - ii qc ldpc code .",
    "but note that this parity check matrix has additional structure which makes it a _ hierarchical _ qc ldpc code .",
    "in particular , in this example , each @xmath67 sub - matrix of polynomials in  ( [ eq.polyparchkb ] ) has a circulant structure , as do both the left - hand and right - hand sets of @xmath132 sub - matrices of @xmath133 sub - matrices .",
    "just as we use polynomials in the dummy variable @xmath20 to represent the underlying circulant sub - matrices in a standard qc ldpc code , we can use a bi - variate polynomial in the two dummy variables @xmath20 and @xmath134 to represent both the circulant matrices represented by the variable @xmath20 in  ( [ eq.polyparchkb ] ) as well as the circulant arrangements within each @xmath67 sub - matrix of polynomials in @xmath20 .",
    "the latter circulant structure we represent using the dummy variable @xmath134 .",
    "we can further represent the @xmath132 circulant structure of @xmath67 circulant sub - matrices using the additional dummy variable @xmath135 .",
    "thus , in equation  ( [ eq.polyparchktwovarb ] ) we contract the @xmath136 polynomial parity check matrix @xmath22 of equation  ( [ eq.polyparchkb ] ) into the @xmath137 bi - variate polynomial parity check matrix @xmath138 .",
    "as we use this example to illustrate many aspects of the ensuing discussion , please make sure you think about and understand why , e.g. , the upper right @xmath133 sub - matrix in @xmath22 is represented by the bi - variate polynomial @xmath139 in @xmath138 .",
    "we can repeat the process to contract @xmath138 into the @xmath140 tri - variate polynomial parity check matrix @xmath141 given in equation  ( [ eq.polyparchkthreevarb ] ) .",
    "each of the three contractions of the parity check matrix of this code into the polynomial parity check matrices represented by  ( [ eq.polyparchkb ] ) , ( [ eq.polyparchktwovarb ] ) , and  ( [ eq.polyparchkthreevarb ] ) , corresponds to a `` level '' in the hierarchy of this 3-level hqc ldpc code .",
    ".1 cm    in this example , we started with a polynomial parity check matrix @xmath22 , and contracted it first to @xmath138 and then to @xmath141 .",
    "when constructing an hqc ldpc code , it is often more natural to go in the other direction  expanding a matrix like @xmath141 into @xmath22 and then ultimately into the full parity check matrix whose entries are ones and zeroes . to expand a polynomial matrix",
    ", we obviously need to know the size of the circulant matrices at every level .",
    "we now present a formal definition of the family of @xmath142-level hierarchical qc ldpc codes which generalizes our example .",
    ".1 cm    [ def.hierqc_ldpc ] a hierarchical qc ldpc code with @xmath142 levels is defined by a @xmath143 } } \\times { l_{[k]}}$ ] multi - variate polynomial parity check matrix @xmath144 in @xmath142 variables .",
    "the entry in the @xmath114th row and @xmath115th column of @xmath144 , @xmath145}}$ ] , @xmath146}}$ ] is a @xmath142-variate polynomial @xmath147 over the @xmath142 variables , @xmath148 } } , \\ldots , { x_{[k]}}$ ] .",
    "the maximum exponent of any of these polynomials in @xmath149}}$ ] , @xmath150 , is @xmath151}}-1 $ ] .",
    "the coefficient associated with the term @xmath148}}^{{{s}_{1 } } } \\cdot { x_{[2]}}^{{{s}_{2 } } } \\cdots { x_{[k]}}^{{{s}_{k}}}$ ] where @xmath152}}-1 $ ] for all @xmath153 is @xmath154}$ ] . with these definitions we defined the code by the @xmath143 } } \\cdot { l_{[k]}}$ ] polynomials @xmath155 } } , \\ldots , & { x_{[k ] } } ) = \\nonumber \\\\ & \\sum_{{{s}_{k } } =    0}^{{p_{[k]}}-1 } \\ldots \\sum_{{{s}_{1 } } = 0}^{{p_{[1]}}-1 } { { c}_{{{s}_{1 } } ,    \\ldots , { { s}_{k}}}[j , l ] } \\left ( \\prod_{k=1}^{k } { x_{[k]}}^{{{s}_{k}}}\\right).\\end{aligned}\\ ] ] the parity check matrix of such a code is obtained by replacing each of the @xmath143 } } \\cdot { l_{[k]}}$ ] entries of @xmath156 } } , \\ldots , { x_{[k]}})$ ] with the sub - matrix @xmath157}}-1 } \\!\\!\\ !",
    "\\ldots \\sum_{{{s}_{1 } } = 0}^{{p_{[1]}}-1 } { { c}_{{{s}_{1 } } , \\ldots { { s}_{k}}}[j , l ] } \\left ( { \\textbf{i}_{1,{p_{[k]}}}}^{{{s}_{k } } } { \\raisebox{1pt}{\\ensuremath{\\:\\otimes\\:}}}\\ldots { \\raisebox{1pt}{\\ensuremath{\\:\\otimes\\:}}}{\\textbf{i}_{1,{p_{[1]}}}}^{{{s}_{1}}}\\right ) , \\label{eq.constpolyparcheck}\\ ] ] where @xmath158 denotes a kronecker product . defining the recursive relations @xmath159 } } = { j_{[k ] } } \\cdot { p_{[k]}}$ ] and @xmath160 } } = { l_{[k ] } } \\cdot { p_{[k]}}$ ] , where @xmath161 , the parity check matrix thus constructed has @xmath162 } } = { j_{[k ] } } \\cdot \\prod_{k=1}^{k } { p_{[k]}}$ ] rows and @xmath163 } } = { l_{[k ] } } \\cdot \\prod_{k=1}^{k } { p_{[k]}}$ ] columns .",
    ".1 cm    while the definition of hqc ldpc codes holds more generally for codes defined in fields other than gf(2 ) , in this paper we exclusively consider _ binary _ qc ldpc codes wherein all @xmath154}$ ] are binary .",
    "we return to our previous example to illustrate our definitions .    _",
    "example  [ ex.hierqcldpc ] ( continued ) : _ the code of this example is a three - level hqc ldpc code . to cast this example into the language of definition  [ def.hierqc_ldpc ] we first identify @xmath20 with @xmath148}}$ ] , @xmath134 with @xmath164}}$ ] , and @xmath135 with @xmath165}}$ ] .    in this example @xmath166",
    "} } = 8 $ ] , @xmath167 } } = 3 $ ] , @xmath168 } } = 2 $ ] .",
    "therefore , @xmath169 } } = 1 $ ] , @xmath170 } } = 2 $ ] ; @xmath171 } } = 2 $ ] , @xmath172 } } = 4 $ ] ; @xmath173 } } = 6 $ ] , @xmath174 } } = 12 $ ] ; and @xmath162 } } = 48 $ ] , @xmath163 } } = 96 $ ] .",
    "we can rewrite , e.g. , the term @xmath175 of  ( [ eq.polyparchkthreevarb ] ) as @xmath176 } } , { x_{[2 ] } } , { x_{[3 ] } } ) \\\\ & = { x_{[1]}}^2 +    \\left({x_{[1]}}+{x_{[1]}}^7\\right){x_{[2]}}^2 +    \\left({x_{[1]}}^7{x_{[2]}}+\\left(1+{x_{[1]}}^6\\right){x_{[2]}}^2\\right){x_{[3]}}\\\\   & = \\sum_{{{s}_{3 } } = 0}^{1 } \\sum_{{{s}_{2 } } = 0}^{2 } \\sum_{{{s}_{1 } } =      0}^{7 } { { c}_{{{s}_{1 } } , { { s}_{2 } } , { { s}_{3}}}[1,1 ] } { x_{[1]}}^{{{s}_{1 } } }    { x_{[2]}}^{{{s}_{2 } } } { x_{[3]}}^{{{s}_{3}}},\\end{aligned}\\ ] ] where all coefficients @xmath177}$ ] are zero except for @xmath178}={{c}_{1,2,0}[1,1]}={{c}_{7,2,0}[1,1 ] } = { { c}_{7,1,1}[1,1 ] } = { { c}_{0,2,1}[1,1 ] } = { { c}_{6,2,1}[1,1 ] } = 1 $ ] .",
    ".1 cm    rather than expanding @xmath156 } } , \\ldots , { x_{[k]}})$ ] into a full parity check matrix as in  ( [ eq.constpolyparcheck ] ) , one often wants to generate the form given in equation  ( [ eq.polyparchkgeneral ] ) of the polynomial parity check matrix @xmath156}})$ ] of a qc ldpc code _ in one variable_. to do this we use the construction of  ( [ eq.constpolyparcheck ] ) for all but the first level .",
    "we replace each @xmath179}},\\ldots , { x_{[k]}})$ ] with the polynomial matrix in @xmath148}}$ ] @xmath180}}-1 } \\!\\!\\!\\ !",
    "\\sum_{{{s}_{1 } } =    0}^{{p_{[1]}}-1 } \\ !   \\ ! { { c}_{{{s}_{1 } } , \\ldots , { { s}_{k}}}[j , l ] } \\!\\ ! \\left ( { \\textbf{i}_{1,{p_{[k]}}}}^{{{s}_{k } } } \\!\\ ! { \\raisebox{1pt}{\\ensuremath{\\:\\otimes\\:}}}\\ ! \\cdots \\ ! { \\raisebox{1pt}{\\ensuremath{\\:\\otimes\\:}}}{\\textbf{i}_{1,{p_{[2]}}}}^{{{s}_{2 } } } \\right ) { x_{[1]}}^{{{s}_{1}}}. \\label{eq.constpolyparcheckb}\\end{aligned}\\ ] ] the matrix @xmath156}})$ ] is of size @xmath173 } } \\times { l_{[1]}}$ ] .",
    "we return once more to our example to illustrate this idea .    _",
    "example  [ ex.hierqcldpc ] ( continued ) : _ consider the final term of @xmath181 } } , { x_{[2 ] } } , { x_{[3]}})$ ] , namely @xmath182}}^6){x_{[2]}}^2{x_{[3]}}$ ] , corresponding to the non - zero coefficients @xmath183}$ ] and @xmath184}$ ] . according to equation  ( [ eq.constpolyparcheckb ] ) , the contribution of this term to @xmath156}})$ ] is @xmath185 } \\left ( { \\textbf{i}_{1,2 } } { \\raisebox{1pt}{\\ensuremath{\\:\\otimes\\:}}}{\\textbf{i}_{1,3}}^2\\right){x_{[1]}}^0 + { { c}_{6,2,1}[1,1 ] } \\left ( { \\textbf{i}_{1,2 } } { \\raisebox{1pt}{\\ensuremath{\\:\\otimes\\:}}}{\\textbf{i}_{1,3}}^2 \\right ) { x_{[1]}}^6,\\ ] ] where @xmath148}}^0 = 1 $ ] , @xmath186 } = { { c}_{6,2,1}[1,1 ] } = 1 $ ] and @xmath187 .",
    "\\label{eq.6x6matrix}\\ ] ] referring back to the left - hand six - by - six sub - matrix of @xmath141 in  ( [ eq.polyparchkb ] ) we can confirm the correctness of this pattern , as a @xmath188 term appears in each of the non - zero entries in the matrix of equation ( [ eq.6x6matrix ] ) .    having worked this example , we can now see how the form of equation  ( [ eq.constpolyparcheckb ] ) nicely reveals the structure of hqc ldpc codes . each row and each column of the matrix @xmath189}}}}^{{{s}_{k } } } { \\raisebox{1pt}{\\ensuremath{\\:\\otimes\\:}}}\\cdots { \\raisebox{1pt}{\\ensuremath{\\:\\otimes\\:}}}{\\textbf{i}_{1,{p_{[2]}}}}^{{{s}_{2}}}$ ] has exactly one non - zero element .",
    "if the coefficient @xmath190}$ ] is non - zero , the permutation matrix @xmath191}}}}^{{{s}_{1}}}$ ] ( equivalent to the term @xmath192}^{i_1}$ ] ) is added at the location of each of these non - zero elements .",
    ".1 cm    finally , we note that the polynomial parity check matrix of a @xmath142-level hqc ldpc code can more generally be expanded into a parity check polynomial @xmath156 } } , \\ldots , { x_{[\\tilde{k}]}})$ ] in @xmath193 variables where @xmath194 .",
    "we call this the `` level-@xmath193 '' polynomial parity check matrix of the code .",
    "we derive this matrix by expanding out all but the last @xmath193 levels .",
    "replace each @xmath179}},\\ldots , { x_{[k]}})$ ] with the polynomial matrix in @xmath148 } } , \\ldots , { x_{[\\tilde{k}]}}$ ] @xmath180}}-1 } \\!\\!\\!\\ !",
    "\\sum_{{{s}_{1 } } =    0}^{{p_{[1]}}-1 } \\ !   \\ !",
    "{ { c}_{{{s}_{1 } } , \\ldots , { { s}_{k}}}[j , l ] } \\!\\ ! \\left ( { \\textbf{i}_{1,{p_{[k]}}}}^{{{s}_{k } } } \\!\\ ! { \\raisebox{1pt}{\\ensuremath{\\:\\otimes\\:}}}\\ ! \\cdots \\ ! { \\raisebox{1pt}{\\ensuremath{\\:\\otimes\\:}}}{\\textbf{i}_{1,{p_{[\\tilde{k}+1]}}}}^{{{s}_{\\tilde{k}+1 } } } \\right ) \\prod_{k=1}^{\\tilde{k } } { x_{[k]}}^{{{s}_{k}}}.\\end{aligned}\\ ] ] the matrix @xmath156 } } , \\ldots , { x_{[\\tilde{k}]}})$ ] has dimension @xmath195 } } \\times { l_{[\\tilde{k}]}}$ ] .",
    "we now show that we can alternately describe an hqc ldpc code by specifying the code s _",
    "tree structure_. the tree structure of any hqc ldpc code is defined by a matrix of _ labeled trees _ , defined in definition  [ def.conntree ] .",
    "these labeled trees quite naturally reveal the hierarchical structure of the code .",
    "we will show that there is a complete equivalence between definition  [ def.hierqc_ldpc ] of the last section and the definitions of this section .",
    "we can start with definition  [ def.hierqc_ldpc ] and easily find the unique set of labeled trees that specify the code or , starting from a tree structure , find the unique hqc ldpc code that has that structure .    the reasons to consider this alternate description are two - fold .",
    "first , the representations of this section help reveal the hierarchical structure within the algebraic description of definition  [ def.hierqc_ldpc ] .",
    "second , we will use _ unlabeled _ trees to define a family of hqc ldpc codes , and then will want to search for a labeling within that family to optimize girth .",
    "the basic observation that motivates the following definitions is that the non - zero terms of the polynomials that define any hqc ldpc code have a _",
    "hierarchical clustering _ that can be represented by a labeled tree .",
    "we formally define such a _ labeled tree _ as follows .",
    "[ def.conntree ] a _ labeled tree _",
    "@xmath196 , corresponding to an entry in the @xmath143 } } \\times { l_{[k]}}$ ] multi - variate polynomial parity check matrix @xmath144 in @xmath142 variables defining a @xmath142-level hqc ldpc code , is a depth-@xmath142 tree .",
    "the root node of the tree is the single node at the top ( @xmath142th ) level .",
    "each node at level @xmath153 , @xmath197 , has a number of edges connecting it to nodes in the next level down .",
    "the number of edges must be an integer in the set @xmath198}}-1\\}$ ] .",
    "each edge below a node at level @xmath153 is labeled by an integer in the set @xmath199}}-1\\}$ ] .",
    "edges are termed `` siblings '' if they share the same parent ( i.e. , are connected to the same node at the higher level ) .",
    "the edge labels of sibling nodes are constrained to be distinct .",
    "we refer to the edges below the lowest nodes as `` leaves . ''",
    "we will have need to index the edges at each level of the tree , so use @xmath200|$ ] to denote the number of edges in @xmath196 at level @xmath153 , i.e. , the set of edges that have a parent node at level @xmath153 .",
    "the code discussed in example  [ ex.hierqcldpc ] is characterized by the matrix of two labeled trees shown in figure  [ fig.trees ] .",
    "the left - hand tree characterizes the polynomial @xmath175 and the right - hand tree characterizes @xmath201 , both specified in  ( [ eq.polyparchkthreevarb ] ) . before understanding how these labeled trees relate to the structure of the code",
    "we note that for this code @xmath166 } } = 8 $ ] , @xmath167 } } = 3 $ ] and @xmath168 } } = 2 $ ] , and node and edge labels are within the ranges specified by definition  [ def.conntree ] .",
    "the next definition relates these trees to the structure of the code .",
    ", the right - hand tree is @xmath202 . ]",
    "[ def.connstruct ] the _ tree structure _ of a @xmath142-level hqc ldpc code is specified by a matrix of labeled trees @xmath203 ,",
    "@xmath204}}$ ] , @xmath205}}$ ] . to each leaf of @xmath206",
    "we associate a single non - zero coefficient @xmath154}$ ] in a one - to - one manner . if the edge labels on the unique path from the leaf to the root node are @xmath207 then the non - zero coefficient associated with the leaf is @xmath208 } = 1 $ ] .    in certain cases ( corresponding to all - zero polynomials ) we want to define a `` null '' tree .",
    "this is a non - existent tree ( and therefore no edges exist so all coefficients are zero ) .",
    "we use the special symbol @xmath209 to denote the null tree .",
    "e.g. , @xmath210 for the code specified in  ( [ eq.polychkmatexa ] ) .",
    "the number of edges below level @xmath142 of tree @xmath206 indicates the number of _ distinct _ powers of @xmath211}}$ ] that appear in @xmath179 } } , \\ldots , { x_{[k]}})$ ] .",
    "each node at level @xmath212 corresponds to one of these terms .",
    "the number of edges below each of the nodes at level @xmath212 indicates the number of distinct powers of @xmath213}}$ ] associated with that term , and so on down the tree .",
    "the number of leaves in the tree equals the number of terms in the polynomial @xmath179 } } , \\ldots , { x_{[k]}})$ ] .",
    "the maximum number of leaves below any of the lowest level nodes ( across all @xmath88 pairs ) tells us the weight of the code ( weight - i , weight - ii , etc . ) .",
    "the edge labels indicate the exponents that define the non - zero polynomials .",
    "we can also define a more fine - grained `` weight at level @xmath153 '' of a hierarchical code by the maximum number of edges below any of the nodes at level @xmath153 .",
    "a hierarchical code can have different weights at different levels ; for example , the code from example  [ ex.hierqcldpc ] with tree structure shown in figure  [ fig.trees ] is weight - ii at level 1 ( the lowest level ) , weight - iii at level 2 , and weight - ii at level 3 .",
    "the following lemma shows that the two ways of conceptualizing hqc ldpc codes ( definition  [ def.hierqc_ldpc ] or definition  [ def.connstruct ] ) are equivalent .    there is a one - to - one mapping between any hqc ldpc codes as defined in definition  [ def.hierqc_ldpc ] and a tree structure , as defined in definition  [ def.connstruct ] .",
    "we first show that any hqc ldpc code has a tree structure that can be read off from the form of the polynomials that make up its polynomial parity - check matrix . to see this , start with definition  [ def.hierqc_ldpc ] .",
    "the @xmath143 } } { l_{[k]}}$ ] polynomials each define one labeled tree .",
    "using the distributive law , we cluster the terms of each polynomial as much as possible ( i.e. , into the least - factored form of the polynomial ) .",
    "the resulting ( hierarchical ) clustering of terms specifies a labeled tree .",
    "conversely , we now show that any set of labeled trees can be uniquely mapped to an hqc ldpc code . starting with the set of labeled trees , we first solve for the non - zero coefficients by concatenating edge labels on all paths from distinct leaves to the root . using the resulting set of non - zero coefficients in definition  [ def.hierqc_ldpc ]",
    "specifies the code .    to understand the structure on the code imposed by the tree topology , consider again the two trees shown in fig .",
    "[ fig.trees ] . by `` tree topology",
    ", '' we simply mean the unlabeled versions of these trees .",
    "each unlabeled tree has three levels and there are two of them . from this",
    "we infer that these unlabeled trees specify a family of three - level hqc ldpc codes where @xmath169 } } = 1 $ ] and @xmath170 } } = 2 $ ] .",
    "since the maximum number of leaves below a node at the first level is two , these trees specifies a family of weight - ii qc ldpc codes .",
    "now focus on the left - hand tree . to simplify notation ,",
    "let us again use @xmath20 for @xmath148}}$ ] , @xmath134 for @xmath164}}$ ] , and @xmath135 for @xmath165}}$ ] .",
    "since the number of leaves is six , we deduce that @xmath175 has six terms , i.e. , @xmath214 where , using @xmath166 } } = 8 $ ] , @xmath167 } } = 3 $ ] and @xmath168 } } = 2 $ ] , @xmath215 , @xmath216 , and @xmath217 .",
    "since the root node has two edges , we deduce that these six terms are clustered into two sets of polynomials defined by @xmath218 and @xmath219 , thus @xmath220 where @xmath221 .",
    "( since @xmath222 and @xmath223 are both binary , without loss of generality we could set @xmath224 and @xmath225 at this point . ) now from the second level in the tree we deduce that the terms in @xmath226 group into two sets , one with two terms so @xmath227 . the same happens with the terms in @xmath228 where @xmath229 .",
    "this tells us that the polynomials compatible with this tree have the form @xmath230 where @xmath221 , @xmath231 , @xmath232 , @xmath233 and @xmath234 ( but , e.g. , @xmath235 is allowed ) .",
    "one can now see that the topology of the unlabeled version of the trees of fig .",
    "[ fig.trees ] specifies a family of hqc ldpc codes , of which the code considered in example  [ ex.hierqcldpc ] , and specified in  ( [ eq.polyparchkthreevarb ] ) , is one member .",
    "as the last example illustrates , many degrees of freedom remain within the specified family . in particular",
    "these are the choice of the @xmath236 , @xmath237 and @xmath238 in  ( [ eq.choosepowers ] ) , subject to the constraints @xmath239 . in the algorithms of section  [ sec.girthmax ] , were we maximize the girth of our codes , we search among these degrees of freedom , keeping the code s unlabeled tree structure fixed .    finally , we note that in a non - hierarchical weight - i qc ldpc code , the trees in @xmath240 are quite simple .",
    "each is either the null tree or a tree that consists of a single root node with a single leaf below it .",
    "no leaf has a sibling so no constraints are placed on the choice of edge labels .",
    "we now state the necessary and sufficient conditions on the polynomial parity check matrix of an hqc ldpc code for that code to have a cycle of a particular length .",
    "these conditions generalize those specified by fossorier in  @xcite for weight - i qc ldpc codes .",
    "they are also formalizations and generalizations of the examples we gave for higher - weight qc ldpc codes in section [ sec.findcyclesnonhier ] ; the main important new requirement compared to those examples is that our cycles now need to be cycles at all levels of the hierarchy simultaneously .",
    "we start by defining a path ( or `` candidate cycle '' ) through a @xmath142-variate polynomial parity check matrix .",
    "[ def.path ] a length-@xmath241 path @xmath242 through a @xmath142-variate @xmath143 } } \\times { l_{[k]}}$ ] polynomial parity check matrix matrix @xmath144 of an hqc ldpc code is specified by two sets , @xmath97 and @xmath102 , i.e. , @xmath243 .",
    "the first set @xmath97 is an ordered series @xmath244 such that    1 .",
    "@xmath245}}$ ] and @xmath246}}$ ] for all @xmath247 , @xmath248 , 2 .",
    "@xmath249 , 3 .",
    "@xmath250 for @xmath251 ( even integers ) , 4 .",
    "@xmath252 for @xmath253 ( odd integers ) , 5 .",
    "@xmath254| > 0 $ ] for all @xmath255 , where the set @xmath256 $ ] is defined to be the set of coefficients in the polynomial in the @xmath114th row and @xmath115th column of @xmath144 that are non - zero : @xmath257 = \\{{{c}_{{{s}_{1 } } , \\ldots , { { s}_{k}}}[j , l ] } : { { c}_{{{s}_{1 } } , \\ldots , { { s}_{k}}}[j , l ] } \\neq 0\\}.\\ ] ]    the second set @xmath102 is a set of length-@xmath142 vectors of coefficient indices @xmath258 , { \\bf s}[j_2,l_2 ] , \\ldots , { \\bf s}[j_{2 \\lambda},l_{2 \\lambda}]\\ } \\label{eq.coeffset}\\ ] ] where , as implied by the notation , @xmath259 for all @xmath260 , and @xmath261 .",
    "furthermore ,    1 .",
    "the @xmath153th coordinate @xmath262 $ ] of @xmath263 $ ] satisfies @xmath264 \\leq { p_{[k]}}-1 $ ] for all @xmath255 , 2 .",
    "@xmath265}[j , l ] } \\in { { \\cal c}}[j , l]$ ] for all @xmath266 , where @xmath265}[j , l]}$ ] is a compact notation for @xmath267}$ ] .",
    "3 .   if consecutive elements of @xmath97 are identical , i.e. , @xmath268 for some @xmath247 , @xmath248 , then @xmath269 \\neq { \\bf s}[j_{t+1 } , l_{t+1}]$ ] .",
    "the above definition generalizes those definitions made and used in sections  [ sec.findcyclesintro ] and  [ sec.inevitable ] for finding cycles in higher - weight qc ldpc codes . in those sections",
    "the ordered set @xmath97 and coefficient indices @xmath102 were first introduced and their characteristics were described . for examples of @xmath97 see  ( [ eq.ordserex ] ) , ( [ eq.ordserexb ] ) , and  ( [ eq.ordserexc ] ) , and for those of @xmath102 see  ( [ eq.pathcoeffex ] ) , ( [ eq.pathcoeffexb ] ) , and  ( [ eq.pathcoeffexc ] ) .",
    "these examples illustrate the reasoning behind criteria ( 1)(8 ) in the definition above .",
    "we now state the conditions for a length-@xmath270 path @xmath271 actually to correspond to length-@xmath270 cycles in the tanner graph .",
    "consider the following alternating sums , one for each @xmath153 , @xmath272 : @xmath273 = \\sum_{t=1}^{2 \\lambda } ( -1)^t s_k[j_t , l_t ] .",
    "\\label{def.pathsum}\\ ] ] as reflected in the following theorem , these sums are the generalization of the sum in  ( [ p4cycle ] ) to hqc ldpc codes .",
    "[ thm.condpathiscycle ] a path length-@xmath241 path @xmath243 through the @xmath142-variate @xmath143 } } \\times { l_{[k]}}$ ] polynomial parity check matrix matrix @xmath144 correspond to length-@xmath270 cycles in the tanner graph if and only if _ for every _ @xmath153 , @xmath274 , @xmath275 \\ ; \\textmd{mod } \\ ; \\ ; { p_{[k ] } }   = 0.\\end{aligned}\\ ] ]    first consider the case where @xmath276 , i.e. , a _ non - hierarchical",
    "_ qc ldpc code for which  ( [ girthcon ] ) corresponds to fossorier s condition .",
    "recall the logic of section  [ sec.findcycles ] . in this",
    "setting if condition  ( [ girthcon ] ) is _ not _ satisfied , then the column of the polynomial parity check matrix from which the path originates is distinct from the one on which the path terminates .",
    "since distinct columns of the polynomial parity check matrix correspond to distinct sets of variable nodes in the tanner graph , this means that if  ( [ girthcon ] ) is not satisfied the path does not correspond to a set of cycles .",
    "in general , what condition  ( [ girthcon ] ) is helping us to understand is whether , in the expanded parity check matrix at the _ next lower level _ , the path through the polynomial parity check matrix corresponds to a set of path through the parity check matrix that all correspond to cycles in the tanner graph . in the case of a non - hierarchical qc ldpc code",
    "there is only one level of expansion , from the polynomial parity check matrix to the parity check matrix .",
    "however , in an hqc ldpc code there are multiple levels of expansion .",
    "now consider hqc ldpc codes where @xmath277",
    ". given any path consider whether condition  ( [ girthcon ] ) holds for @xmath278 .",
    "if the condition does not hold then , similar to fossorier s logic , the path through the parity - check matrix at the next lower level , i.e. , through the level-@xmath279 polynomial parity check matrix , will not start and end in the same column . in the hierarchical setting each column at level",
    "@xmath212 corresponds to a set of variable nodes .",
    "however , due to the way we expand out the parity - check matrix using kronecker products in definition  [ def.hierqc_ldpc ] , the sets of variable nodes corresponding to distinct columns of the level-@xmath153 polynomial parity check matrix for any given @xmath153 are non - intersecting",
    ". a path that originates and terminates in distinct subsets of the variable nodes can not correspond to a set of cycles .",
    "thus , if  ( [ girthcon ] ) does not hold for @xmath280 , the path can not correspond to a set of cycles .    on the other hand ,",
    "if  ( [ girthcon ] ) is satisfied for @xmath278 then cycles _ may _ exist , depending on what happens at the lower levels .",
    "using the same argument we recurse down the levels from @xmath278 to @xmath281 .",
    "if there is any @xmath153 for which  ( [ girthcon ] ) is not satisfied then the path originates from and terminate at distinct variable nodes and therefore does not correspond to a set of cycles .",
    "however , if  ( [ girthcon ] ) is satisfied for all @xmath153 , @xmath282 , then the path originates and terminates on the same variable node and cycles exists .",
    "we immediately have the following theorem .",
    "[ thm.girthcond ] a necessary and sufficient condition for a @xmath142-level hierarchical qc ldpc code to have girth at least @xmath283 is the following .",
    "for all paths through the polynomial parity check matrix of length at most @xmath270 ( path length at least four and at most @xmath270 ) , condition  ( [ girthcon ] ) does not hold for at least one @xmath153 , @xmath274 .",
    "we now give examples of two paths through the polynomial parity check matrix of the code of example  [ ex.hierqcldpc ] . in the first we describe a path that corresponds to cycles through the tanner graph .",
    "we first consider the code as a qc ldpc code ( ignoring its hierarchical structure ) and use fossorier s condition to verify the existence of cycles .",
    "we then look at the same code from a hierarchical perspective to illustrate theorem  [ thm.girthcond ] . in the second example we consider a path through the same code that does not correspond to a cycle through the tanner graph .",
    "[ sec.exampleofcycles ] consider again the polynomial parity check matrices @xmath22 and @xmath138 , respectively specified in  ( [ eq.polyparchkb ] ) and  ( [ eq.polyparchktwovarb ] ) .",
    "first consider the non - hierarchical description of the code specified by @xmath22 .",
    "a cycle of length - four exists traversing the path @xmath243 where @xmath284 this corresponds to , in order , the four polynomials @xmath285 } \\ , x^2,\\\\ x + x^7 & = & { { c}_{1}[1,0 ] } \\ , x + { { c}_{7}[1,0 ] } \\ , x^7,\\\\ x^7 & = & { { c}_{7}[1,5 ] } \\ , x^7 , \\\\ 1 + x^6 & = & { { c}_{0}[0,5 ] } \\ , x^0 + { { c}_{6}[0,5 ] } \\ , x^6 .",
    "\\end{array}\\end{aligned}\\ ] ] selecting out @xmath286}$ ] , @xmath287}$ ] , @xmath288}$ ] and @xmath289}$ ] means we choose @xmath290 we calculate the sum in  ( [ def.pathsum ] ) to be @xmath291 \\ ; { \\rm mod } \\ ; 8 = ( -2 + 1 -7 + 0 ) \\ ; { \\rm mod } \\ ; 8 = 0,\\ ] ] where @xmath166 } } = 8 $ ] for this code .",
    "this example confirms , in the general notation , the test for cycles in non - hierarchical qc ldpc codes already discussed in sec .",
    "[ sec.findcyclesintro ] .    now , consider the same cycle from the hierarchical perspective .",
    "with respect to the two - level representation @xmath138 of  ( [ eq.polyparchktwovarb ] ) the same cycle through the tanner graph corresponds to the ordered series @xmath292 now we have polynomials @xmath293 and @xmath294 which , respectively , are @xmath295 } \\ , x^2 + { { c}_{1,2}[0,0 ] } \\ , x y^2 + { { c}_{7,2}[0,0 ] } \\ , x^7 y^2 , \\end{array}\\ ] ] and @xmath296 } \\",
    ", x^2 + { { c}_{0,2}[0,1 ] } \\ , x y^2 + { { c}_{6,2}[0,1 ] } \\ , x^7 y^2.\\\\ \\end{array}\\ ] ] the same cycles correspond to the coefficient indices @xmath297 , \\left[\\begin{array}{c}1\\\\2\\end{array } \\right ] , \\left[\\begin{array}{c}7\\\\1\\end{array } \\right ] , \\left[\\begin{array}{c}0\\\\2\\end{array } \\right ] \\right\\}.\\ ] ] note that the first sub - index of each coefficient corresponds to the sub - index of the coefficients selected at the one - level view .",
    "the alternating sums along the path are @xmath298 \\ ; { \\rm mod } \\ ; 8 = ( -2 + 1 - 7 + 0 ) \\ ; \\ ; { \\rm mod } \\ ; 8 = 0 \\\\ & \\sigma[2 ] \\ ; { \\rm mod } \\ ; 3 = ( -0 + 2 - 1 + 2 ) \\ ; \\ ; { \\rm mod } \\ ; 3 = 0\\end{aligned}\\ ] ] where @xmath166 } } = 8 $ ] and @xmath167 } } = 3 $ ] for this code .",
    "while we do not work out the example for the three - level representation @xmath141 of  ( [ eq.polyparchkthreevarb ] ) , we note that the ordered traversed by this cycle would be @xmath299 .",
    "we now provide an example of a path through @xmath138 for which @xmath300 = 0 \\ ; \\textmd{mod } \\ ; { p_{[1]}}$ ] but @xmath301 \\neq 0 \\ ; \\textmd{mod } \\ ; { p_{[2]}}$ ] .",
    "let the ordered set be @xmath302 .",
    "of  ( [ eq.polyparchktwovarb ] ) be @xmath303 , @xmath304 , @xmath89 , @xmath305 .",
    "this corresponds to polynomials @xmath306 , @xmath307 , @xmath308 , and @xmath309 .",
    "we select the set of set coefficient indices to be @xmath297 , \\left[\\begin{array}{c}6\\\\2\\end{array } \\right ] , \\left[\\begin{array}{c}2\\\\0\\end{array } \\right ] , \\left[\\begin{array}{c}6\\\\2\\end{array } \\right ] \\right\\},\\ ] ] from which we can verify that @xmath300 = 0 \\ ; \\textmd{mod } \\ ; 8 $ ] but @xmath301 \\neq 0 \\ ; \\textmd{mod } \\ ; 3 $ ] .",
    "hence while condition  ( [ girthcon ] ) holds at level one , it does not hold at level two . referring to the expanded @xmath22 in  ( [ eq.polyparchkb ] )",
    "one can confirm this conclusion using the logic of sec .",
    "[ sec.findcyclesintro ] .",
    "in particular , @xmath310 is located in the sixth column of the first row of @xmath22 , while the polynomial @xmath311 traversed by the path is located in the fifth column of the fifth row of @xmath22 .",
    "since hqc ldpc codes are a generalization of qc ldpc codes , they also have inevitable cycles . in this section",
    "we describe how the logic and results of sec .",
    "[ sec.inevitable ] regarding inevitable cycles extend to hqc ldpc codes .",
    "we illustrate the logic for specific examples of hqc ldpc codes that we will use in our design pipeline presented in sec .",
    "[ sec.pipeline ] .    recall that in sec .",
    "[ sec.inevitable ] we discussed two classes of inevitable cycles .",
    "we first saw that there will inevitably be cycles of length six in any weight - iii qc ldpc code .",
    "we also saw that the code will have eight - cycles if the polynomial parity check matrix @xmath144 of a weight - ii qc ldpc code contains two weight - two polynomials in any row or in any column .",
    "we analogously find that there will inevitably be cycles of length six for an hqc ldpc code if any labeled tree @xmath206 in the tree matrix defining the code has _",
    "three leaves_. there will inevitably be eight - cycles if , in any row or in any column of the matrix of labeled trees defining the hqc ldpc code , there is a _ pair _ of labeled trees _ both having two leaves_.    the logic behind these statements is almost identical to the earlier case .",
    "we describe it completely for the first situation .",
    "we pick a length - six ordered series @xmath97 equal to  ( [ eq.ordserexb ] ) , i.e. , @xmath312 , where @xmath88 is the index of the labeled tree @xmath206 that has three leaves .",
    "let the three length-@xmath142 coefficient vectors correspond to the three leaves be @xmath313 and select the coefficient set @xmath314 . then , because each element is both an even and an odd element of the set , ( [ girthcon ] ) is satisfied for every @xmath153 , just as it was in the qc ldpc example of  ( [ eq.automaticcycleex ] ) .",
    "the logic for automatic eight - cycles follows from the analogous extensions of the choices made in  ( [ eq.ordserexc ] ) and  ( [ eq.pathcoeffexc ] ) .",
    "we now illustrate these points about inevitable cycles for a subclass of two - level hqc ldpc codes that are described solely by labeled trees with weight - one at the bottom level .",
    "that is , none of the leaves of the trees have siblings . in sec .",
    "[ sec.restricted ] we name such codes _ restricted two - level hqc ldpc codes_. an example of such a tree is given in fig .",
    "[ fig.restricted ]        [ ex.inevitablesixcycle ] first consider any code containing a tree of the type illustrated in fig .",
    "[ fig.restricted ] .",
    "this code has three leaves and so , according to our discussion , the code must contain six cycles . without loss of generality ,",
    "let such a tree be located in row @xmath114 and column @xmath115 of the parity check matrix @xmath138 .",
    "the polynomial has the form @xmath315 as discussed above , choose the ordered series @xmath97 to be @xmath316 and the ordered set of coefficient vectors to be @xmath317}\\ ! , { \\left [ \\ ! \\begin{array}{c } \\!\\ ! a_2 \\!\\ ! \\\\ \\!\\ !",
    "\\end{array } \\ !",
    "\\right]}\\ ! , { \\left [ \\ ! \\begin{array}{c } \\!\\",
    "! a_3 \\!\\ ! \\\\ \\!\\ !",
    "\\end{array } \\ !",
    "\\right]}\\ ! , { \\left [ \\ ! \\begin{array}{c } \\!\\ ! a_1 \\!\\ ! \\\\ \\!\\",
    "!        a_1 \\!\\ !",
    "\\end{array } \\ !",
    ", { \\left [ \\ ! \\begin{array}{c } \\!\\ ! a_2 \\!\\ ! \\\\ \\!\\",
    "!        a_2 \\!\\ !",
    "\\end{array } \\ !",
    "\\right]}\\ ! , { \\left [ \\ ! \\begin{array}{c } \\!\\ !",
    "a_3 \\!\\ ! \\\\ \\!\\ !",
    "\\end{array } \\ !",
    "\\right]}\\right\\}. \\label{eq.sixcycleinevpath}\\ ] ] cycles inevitably exist because @xmath318 }   & = 0,\\\\   ( -a_1 + a_2 - a_3 + a_1 - a_2 + a_3 ) \\ ; \\ ;   \\textmd{mod } \\ ; \\ ; p_{[2 ] }   & = 0,\\end{aligned}\\ ] ] regardless of the values of the coefficients or of @xmath319}$ ] or @xmath320}$ ] .",
    "[ ex.inevitableeightcycle ] now suppose that the parity check matrix of a restricted two - level hqc ldpc code contains two labeled trees in the same row or column where both trees are similar to the one depicted in fig .",
    "[ fig.restricted ] , but with only two leaves each .",
    "suppose that the two weight - two polynomials are in the same row @xmath114 but in two different columns @xmath119 and @xmath120 .",
    "let the polynomial at @xmath121 be @xmath321 and let the polynomial at @xmath123 be @xmath322 .",
    "consider the same ordered series as in  ( [ eq.ordserexc ] ) , i.e. , @xmath323 , and choose the ordered set of coefficient indices to be @xmath317}\\ !",
    ", { \\left [ \\ ! \\begin{array}{c } \\!\\ ! a_2 \\!\\ ! \\\\ \\!\\",
    "!        a_2 \\!\\ !",
    "\\end{array } \\ !",
    "\\right]}\\ ! , { \\left [ \\ ! \\begin{array}{c } \\!\\",
    "! b_1 \\!\\ ! \\\\ \\!\\",
    "!        b_1 \\!\\ !",
    "\\end{array } \\ !",
    "\\right]}\\ ! , { \\left [ \\ ! \\begin{array}{c } \\!\\",
    "! b_2 \\!\\ ! \\\\ \\!\\",
    "!        b_2 \\!\\ !",
    "\\end{array } \\ !",
    "\\right]}\\ ! , { \\left [ \\ ! \\begin{array}{c } \\!\\ !",
    "a_2 \\!\\ ! \\\\ \\!\\ !",
    "\\end{array } \\ !",
    "\\right]}\\ ! , { \\left [ \\ ! \\begin{array}{c } \\!\\ !",
    "a_1 \\!\\ ! \\\\ \\!\\ !",
    "\\end{array } \\ !",
    "\\right]}\\ ! , { \\left [ \\ ! \\begin{array}{c } \\!\\",
    "! b_2 \\!\\ ! \\\\ \\!\\",
    "!        b_2 \\!\\ !",
    "\\end{array } \\ !",
    "\\right]}\\ ! , { \\left [ \\ ! \\begin{array}{c } \\!\\",
    "! b_1 \\!\\ ! \\\\ \\!\\",
    "!        b_1 \\!\\ !",
    "\\end{array } \\",
    "! \\right ] } \\right\\}. \\label{eq.eightcycleinevpath}\\ ] ] eight cycles are inevitable because @xmath324 } & = 0,\\\\ ( - \\ !    a_1 \\ ! + \\ ! a_2 \\ ! - \\ ! b_1 \\",
    "b_2 \\ ! - \\ !",
    "a_2 \\ ! + \\ ! a_1 \\ !    - \\",
    "! b_2 \\ ! + \\ !",
    "b_1 ) \\ ; \\textmd{mod } \\",
    "; p_{[2 ] } & = 0,\\end{aligned}\\ ] ] regardless of the values of the coefficients or of @xmath319}$ ] or @xmath320}$ ] .",
    "in this section we present the ideas behind our girth - maximizing algorithms for qc ldpc and for hqc ldpc codes .",
    "the latter is a generalization of the former .",
    "these algorithms can rid the codes of all non - inevitable cycles . in sec .",
    "[ sec.pipeline ] we will describe a secondary procedure for ridding the codes of their inevitable cycles . as the details of the algorithms",
    "are somewhat involved , we choose only to describe the basic ideas in the main text , and defer to the appendices the details .",
    "the overall algorithms are described in appendix  [ sec.girthmaxalgs ] while in appendices  [ app.maxgirth][app.costhqcldpc ] we describe the subroutines that contain much of the computational complexity ( and descriptive intricacies ) .    in section  [ sec.genhillidea ]",
    "we describe the general idea of the algorithms , which applies both to qc and to hqc ldpc codes .",
    "then , in section  [ sec.hillnonhier ] we give more detail for the case of weight - i qc ldpc codes .",
    "the discussion of the generalization to hqc ldpc codes ( which includes higher - weight qc ldpc codes as a special case ) is deferred to the appendices .      the general idea of our algorithm ( for both qc and hqc ldpc codes ) is as follows .",
    "we start by specify the desired tree topology of the code by specifying a set of @xmath325 _ unlabeled _ trees .",
    "we initialize our algorithm with a code chosen randomly from the ensemble of codes that have the desired tree topology .",
    "this means that we randomly assign labels to the trees @xmath240 subject to the constraints that sibling edges must have distinct labels .",
    "our algorithm iteratively updates a sequence of edge labels . at each iteration",
    "it changes the single edge label to the value that effects the greatest reduction in a cost function .",
    "the cost function we use depends on the number of cycles in the current code that have length less than the desired girth .",
    "shorter cycles are weighted to be more costly than longer cycles .",
    "the algorithm terminates when either ( a ) the current values of all coefficients give zero cost ( and thus the code has the desired girth ) , or ( b ) when we can no longer change any single coefficient to a value that further reduces the cost ( and thus the number of undesired cycles ) .",
    "when the tree topology of the code implies the existence of inevitable cycles ( b ) will always be the stopping criterion .",
    "updates are performed subject to the sibling constraint on edge labels .",
    "this preserves the tree topology of the code and thus , e.g. , the protograph structure of the code is an invariant under the updates .",
    "we note that a change in a single edge label will , in general , have a trickle - down effect on a number of code coefficients ( equal to the number of leaves in the tree that are a descendent of that edge ) .    the main challenge in implementing the algorithm lies in book - keeping : tracking how many cycles of each length the current code contains , and what the resulting number of cycles will be if each edge label is changed to each of its other possible value .",
    "the calculation becomes particularly involved when one searches for codes of girth @xmath326 ( which is the largest girth for which we have so far implemented our algorithm ) because of the many possible ways that eight - cycles can form .      in this section",
    "we present the main algorithmic ideas in the simplified setting of weight - i qc ldpc codes .",
    "this simplification also reduces notation . for the duration of this section , we set @xmath166 } } = p$ ] , @xmath174 } }",
    "= l$ ] , @xmath173 } } = j$ ] .",
    "further , path elements are scalars so @xmath327 } = { s}[j , l]$ ] . in a weight - i",
    "qc ldpc each tree @xmath206 has a single edge and @xmath328 } \\neq 0 $ ] for at most one value of @xmath329 ( if @xmath330 then @xmath328 } = 0 $ ] for all @xmath329 ) .",
    "the set of _ other _ possible edge labels are the set of @xmath135 , @xmath331 , such that @xmath332 ( there are no sibling edges so there are no further constraints on the choice of @xmath135 ) .",
    "we now define a set of cost vectors , each of which tracks the cost ( in terms of the weighted sum of the number of cycles ) of changing any edge label to each of its other possible values . in particular , for each edge in each @xmath333 we define @xmath334 , \\label{def.costvec}\\ ] ] where @xmath335 is the cost we pay for assigning @xmath336 } = 1 $ ] for each value of @xmath135 for @xmath331 .",
    "if the desired code girth is @xmath337 then the cost @xmath338 is a linear function of the number of cycles of each length that results from each possible choice for @xmath135 .",
    "the weight vector @xmath339 $ ] defines the cost function , where @xmath340 is the cost assigned to each length-@xmath241 cycles .",
    "it is useful to visualize the set of cost vectors as a matrix of vectors .",
    "for example , a regular @xmath341 ldpc code can be represented as @xmath342 . \\label{eq.costmatrix}\\end{aligned}\\ ] ]    given a parity check matrix @xmath19 and desired girth @xmath343 , the cost vectors are calculated via the following argument .",
    "we consider the set of all possible and distinct length-@xmath241 paths per def .",
    "[ def.path ] , i.e. , @xmath344 for @xmath345 . for each path",
    "@xmath346 and each @xmath347 we consider the corresponding coefficient @xmath348 \\in { { \\cal s}}$ ] .",
    "assuming all other _ distinct _",
    "coefficients @xmath349 $ ] for @xmath350 are kept fixed we note the `` guilty '' value(s ) of @xmath348 $ ] to be the value @xmath135 , @xmath331 , such that if @xmath348 $ ] were changed to @xmath135 , then condition  ( [ girthcon ] ) would be satisfied . in other words , a cycle would result .",
    "for example , for a potential six - cycle , we know that a cycle will exist if and only if @xmath351 + { s}[j_2,l_2 ] - { s}[j_3,l_3 ] + { s}[j_4,l_4 ] - { s}[j_5,l_5 ] + { s}[j_6,l_6 ] \\;\\textmd{mod } \\ ; p = 0 $ ] .",
    "suppose , for example , that the current summed value of @xmath351 + { s}[j_2,l_2 ] - { s}[j_3,l_3 ] + { s}[j_4,l_4 ] - { s}[j_5,l_5 ] + { s}[j_6,l_6 ] \\ ; \\textmd{mod } \\ ; p$ ] is equal to one",
    ". then , the guilty values for @xmath352 $ ] , @xmath353 $ ] , and @xmath354 $ ] would be one less than their respective current values , and the guilty values for @xmath355 $ ] , @xmath356 $ ] , and @xmath357 $ ] would be one greater than their respective current values .",
    "computing `` guilty '' values is relatively uncomplicated for paths consisting of @xmath241 _ distinct _ elements .",
    "it becomes more complicated if some elements of the path appear more than once .",
    "this can occur in potential eight - cycles and occurs , e.g. , in the second example of fig .",
    "[ fig.findcycle ] . in such cases",
    ", we must keep in mind that when such coefficients are changed , the contribution to alternating sum can double , triple ( e.g. , in the length-12 cycle of fig .  [ fig.findcycle ] because the path passes through each sub - matrix three times ) , or contribute even more times . alternately , repeated elements can also cancel ( if they enter modulated by both @xmath358 and @xmath49 ) , not contributing at all to the sum .",
    "we deal with this complexity in appendix  [ app.maxgirth ] by defining the `` multiplicity '' @xmath359 of a path element ; used in the cost calculating algorithms subsequently specified in appendices  [ app.costqcldpc ] and  [ app.costhqcldpc ] .",
    "in this section we describe our design procedure for high - girth qc ldpc codes .",
    "we want to be able to map any interesting protograph into a high - girth qc code .",
    "as mentioned earlier , the protographs that motivate us have multiple edges between variable types and check nodes ( such as those shown in fig .",
    "[ fig.onesided ] ) and thus qc ldpc codes created from them using a direct transformation would suffer from inevitable cycles .    in this section",
    "we show how to map such a protograph into an `` inflated '' hqc ldpc code structure , on which we can use the girth maximizing algorithm of sec .",
    "[ sec.girthmax ] to remove all non - inevitable cycles .",
    "we then show how the resulting hqc ldpc codes can be `` squashed '' down to yield a non - hierarchical qc ldpc code which no longer contains the inevitable cycles and which is a member of the family of codes described by our protograph .",
    "the subclass of hqc ldpc codes with with we work are the _ restricted two - level hqc ldpc codes _ , already mentioned briefly in the examples of sec .",
    "[ sec.hqcldpcinevitable ] .",
    "the outline of the section is as follows . in sec .",
    "[ sec.restricted ] we fully define the class of restricted two - level hqc ldpc codes . in sec .",
    "[ sec.protorestricted ] we show how to directly transform any protograph into such a code . in sec .",
    "[ sec.squashingprocedure ] , we describe the squashing procedure , and finally in sec .  [ sec.squashing ] , we explain the full design pipeline , including `` inflating '' the connectivity matrix corresponding to the protograph , directly transforming the inflated connectivity matrix into a family of restricted two - level hqc ldpc codes , maximizing the girth over that family , and squashing the resulting hqc ldpc code .      as `` restricted two - level '' implies ,",
    "the hierarchy in restricted two - level hqc ldpc codes has only two levels .",
    "the additional `` restriction '' is that the weight of the first ( lowest ) level must be one . in terms of the tree structure description of these codes",
    ", the labeled trees will all have a form like that shown in fig .  [",
    "fig.restricted ] , with the nodes at the bottom level each having exactly one leaf , i.e. , leafs have no siblings . in comparison , there are leaves in left - hand tree of fig .",
    "[ fig.trees ] that do have siblings .",
    "nodes at the second level can have an arbitrary number of edges .",
    "the fact that these codes have two levels means that they are described by a polynomial parity check matrix in two dummy variables @xmath138 .",
    "the restriction to the lowest level having weight one means that any weight-@xmath360 polynomial in the matrix @xmath138 must have the form @xmath361 where all the @xmath362 exponents must be distinct . as usual , the exponents are integers which range between @xmath61 and @xmath319}-1 $ ] for the @xmath20 exponents and @xmath61 and @xmath320}-1 $ ] for the @xmath134 exponents .    because the weight at the lowest level is restricted to be one , these codes , when described as standard qc ldpc codes , look like weight - i qc ldpc codes , whose base matrix is composed of circulant sub - matrices of size @xmath320}$ ] by @xmath320}$ ] . in  @xcite",
    "smarandache and vontobel briefly introduce a further restricted class of such qc ldpc codes ( they also required that the codes be weight - ii at the second level and that @xmath320}=2 $ ] ) which they term `` type - i qc codes based on double - covers of type - ii qc codes . ''      recall that in sec .",
    "[ sec.protographs ] , we introduce a `` direct transformation '' to convert a protograph into an ordinary qc ldpc code .",
    "the direct transformation replaces the connectivity matrix equivalent to the protograph with a polynomial parity check matrix @xmath22 whose polynomial entries had weight equal to the entries in the connectivity matrix . a completely analogous direct transformation exists for converting protographs into restricted two - level hqc ldpc codes .",
    "one replaces the connectivity matrix with a bi - variate polynomial parity check matrix @xmath138 whose polynomial entries each have the restricted form of  ( [ eq.restrictedform ] ) and have weight equal to the entries in the connectivity matrix .",
    "for example , the connectivity matrix corresponding to the protograph depicted in fig .",
    "[ fig : proto1 ] is @xmath53 .",
    "\\label{eq.maptoconnectmat}\\ ] ] this matrix is directly transformed into a two - level restricted hqc ldpc code with polynomial parity check matrix @xmath363,\\ ] ] where @xmath55 , @xmath56 , @xmath57 , @xmath58 , @xmath59 , and @xmath60 are integer exponents between @xmath61 and @xmath319}-1 $ ] , and @xmath364 , @xmath365 , @xmath52 , @xmath366 , @xmath367 , and @xmath368 are integer exponents between @xmath61 and @xmath320}-1 $ ] that satisfy @xmath369 .",
    "because restricted two - level hqc ldpc codes are weight - i at the lowest level , they can also be considered weight - i qc ldpc codes , and can therefore be described in terms of their base matrix . that the base matrix is the matrix of powers of the polynomial parity check matrix expressed in a single dummy variable . ] in this section we develop a technique that selectively removes rows or columns from the base matrix describing a restricted two - level hqc ldpc code in a way that eliminates all inevitable six- and eight - cycles from the corresponding tanner graphs of the code .",
    "there are two underlying assumptions in this section .",
    "first , that via a girth - maximization procedure the base matrix entries involved have already been optimized to eliminate all non - inevitable cycles .",
    "second , we concentrate on restricted two - level hqc ldpc codes where @xmath167 } } = 4 $ ] , which implies that the base matrix is composed of circulant sub - matrices of size four by four .",
    "there are two situations we will want to consider . respectively",
    "they will correspond to ex .",
    "[ ex.inevitablesixcycle ] and  [ ex.inevitableeightcycle ] of sec .",
    "[ sec.hqcldpcinevitable ] .",
    "the full connection to these examples will only become clear in the next section , when we explain our `` inflation '' procedure , which has the effect of placing pairs of similarly structured four by four sub - matrices on top of each other ( or besides each other ) .",
    "the first situation involves a polynomial of weight 3 in the polynomial parity check matrix * h*(x , y ) , which after inflation will be converted into two polynomials of weight 3 , e.g. , @xmath370 and @xmath371 , with identical @xmath134 exponents , in the same column of the polynomial parity check matrix . assuming a restricted two - level code with @xmath167 } } = 4 $ ]",
    ", the corresponding sub - matrices in the base matrix would respectively look something like @xmath372 \\vspace{2ex}\\\\ \\left [ \\begin{array}{cccc }   d   &   e   &   f   & -1 \\\\ -1 &   d   &   e   &   f \\\\ f   &   -1 &   d   &   e \\\\",
    "e   &   f   & -1   &   d\\end{array}\\right ] \\end{array } , \\label{eq.squashsixcycle}\\ ] ] where we recall that @xmath49 represents the @xmath166 } } \\times { p_{[1]}}$ ] all - zeros matrix .",
    "the second situation involves four polynomials of weight 2 arranged rectilinearly , e.g. , @xmath370 , @xmath371 , @xmath373 and @xmath374 , .",
    "furthermore , after inflation , the @xmath134 exponents of the polynomials in the same column will have the same exponents , so that the corresponding sub - matrices would look something like @xmath375 &   \\left [ \\begin{array}{cccc }   -1 & c   &   d   &   -1   \\\\ -1 & -1 &   c   &   d   \\\\ d & -1   &   -1 &   c   \\\\ c & d   &   -1   & -1   \\end{array}\\right ] \\vspace{2ex } \\\\ \\left [ \\begin{array}{cccc }   e &   f   &   -1   & -1\\\\ -1 &   e   &   f   & -1 \\\\",
    "-1   &   -1 &   e   & f \\\\ f   &   -1   & -1   & e \\end{array}\\right ] &   \\left [ \\begin{array}{cccc }   -1 & g &   h   &   -1   \\\\ -1 & -1 &   g   &   h   \\\\ h & -1   &   -1 &   g   \\\\ g & h   &   -1   & -1 \\end{array}\\right ]   \\end{array}. \\label{eq.squasheightcycle}\\ ] ]    by the results of sec .",
    "[ sec.hqcldpcinevitable ] the first situation contains six - cycles within each sub - matrix and the second situation contains inevitable eight - cycles between the pair of sub - matrices in each row and in each column .",
    "we argue that if we `` squash '' the two matrices in the first example  by stacking the first two rows of the upper matrix on the last two rows of the lower matrix  then the matrix produced @xmath376 \\label{eq.postsquashsixcycle}\\ ] ] contains no six - cycles .",
    "similar if we squash the matrices in the second example then the resulting pair of matrices @xmath377 \\hspace{1em } \\left [ \\begin{array}{cccc }   -1 & c   &   d   & -1 \\\\ -1 & -1 &   c   &   d   \\\\ h & -1   &   -1 &   g   \\\\ g & h   &   -1   & -1   \\end{array}\\right ] \\label{eq.postsquasheightcycle}\\ ] ] contains no eight - cycles .",
    "since by assumption there were no non - inevitable six- or eight - cycles between the original matrices , to show our assertion we need solely to demonstrate that the squashing procedure removes all inevitable cycles .",
    "we argue this based on the following lemma , proved in appendix  [ app.squash ] .",
    "[ lemma.squash ] +    * any inevitable six - cycle within a polynomial of the form @xmath378 traverses three distinct rows and three distinct columns of the corresponding base matrix . *",
    "any inevitable eight - cycles between a pair of polynomials of the form @xmath321 and @xmath379 located in the same row ( column ) of the polynomial parity check matrix traverses three distinct rows ( columns ) of the corresponding base matrix .",
    "now , consider the squashing of the matrices in  ( [ eq.squashsixcycle ] ) into the matrix in  ( [ eq.postsquashsixcycle ] ) .",
    "note that the latter matrix has only _ two _ rows from each of the matrices in  ( [ eq.squashsixcycle ] ) .",
    "however , by lemma  [ lemma.squash]-(i ) all inevitable cycles pass through three rows .",
    "therefore , the matrix in  ( [ eq.postsquashsixcycle ] ) does not contain any inevitable six - cycles .",
    "next , consider the squashing of the matrices in  ( [ eq.squasheightcycle ] ) into the matrices in  ( [ eq.postsquasheightcycle ] ) .",
    "first we a show that the squashing procedure eliminate the automatic cycles between pairs of matrices arising from pairs of weight-2 polynomials on the same row of the polynomial parity check matrix .",
    "this follows from lemma  [ lemma.squash]-(ii ) which tells us that these eight - cycles traverse three distinct rows , because only two rows of each of the matrices is retained .",
    "next consider the inevitable cycles between pairs of matrices arising from pairs of weight-2 polynomials in the same column of the polynomial parity check matrix .",
    "since we squash vertically , parts of all columns of the base matrix are retained . however",
    ", if one examines  ( [ eq.postsquasheightcycle ] ) one sees that the second and fourth columns of the left - hand matrix only includes contributions from the upper left - hand and bottom - left - hand matrices of  ( [ eq.squasheightcycle ] ) , respectively .",
    "the remaining inevitable cycles from  ( [ eq.squasheightcycle ] ) therefore can not include these columns .",
    "but , that leaves only two columns in the left - hand matrix and by lemma  [ lemma.squash]-(ii ) we know that these inevitable cycles require three columns .",
    "therefore the inevitable cycles have been eliminated .",
    "the same logic holds for the right - hand side of  ( [ eq.postsquasheightcycle ] ) .",
    "note that for the above logic regarding eight - cycles to hold it is important that the @xmath134-exponents of the two matrices to be squashed together ( those in the same column ) are the same .",
    "thus , e.g. , @xmath380 @xmath381 correspond to any two polynomials of the form @xmath382 and @xmath383 .",
    "note also that the same squashing procedure would work in the horizontal direction as long as the matrices on the same row have the same @xmath134-exponents .",
    "the logic is the same with the argument for rows and columns reversed .",
    "we now turn to demonstrating how to construct a weight - i qc ldpc code that does not have any six - cycles or eight - cycles .",
    "we first sketch the procedure , depicted in fig .",
    "[ fig.designpipeline ] and then illustrate the details with a worked design example .        roughly speaking",
    "the procedure will start with a desired protograph and code parameter @xmath166}}$ ] ( our procedure assumes @xmath167 } } = 4 $ ] ) .",
    "we first map the protograph into a connectivity matrix , cf .",
    "( [ eq.maptoconnectmat ] ) .",
    "depending on the weight and relative locations of the entries in the connectivity matrix , we `` inflate '' the connectivity matrix .",
    "we then use the direct mapping of sec .",
    "[ sec.protorestricted ] to produce a polynomial parity check matrix for a restricted two - level hqc ldpc code .",
    "next , using our max girth algorithm we eliminate all non - inevitable six- and eight - cycles .",
    "finally , we use the squashing procedure of sec .",
    "[ sec.squashingprocedure ] to eliminate inevitable cycles .",
    "of course , the way in which we inflate the code must be compatible with the way we squash the code to produce a valid parity check matrix that meets the parameters of interest .",
    "it should be emphasized that the ldpc code resulting from this procedure will be a qc ldpc and not a _ hierarchical _ qc ldpc code , although the final structure will be quite similar to that of an hqc ldpc code .",
    "* 1 ) inflate connectivity matrix : * as indicated , the procedure first produces the connectivity matrix @xmath52 of the protograph , which we assume has no entries greater than 3 .",
    "( we make no effort here to deal with inevitable cycles caused by weights greater than 3 ) .",
    "the `` inflation '' procedure works as follows .",
    "we fist mark for duplication each row of the matrix with two or more elements of value 2 or greater or a single element of value 3 .",
    "we also mark for duplication each column that has two or more elements of value 2 or greater .",
    "then we inflate @xmath52 to produce a new connectivity matrix @xmath384 in which each of the rows in @xmath52 marked for duplication are duplicated .",
    "we then inflate again to produce @xmath385 from @xmath384 by duplicating each of the marked columns . as will be evident when we get to squashing",
    ", we must track in the matrices @xmath384 and @xmath385 which rows and columns are duplicated versions of each other .",
    "the following example illustrates the inflating procedure .    [ ex.squashing ]",
    "suppose we start with a protograph that has the connectivity matrix @xmath386 .",
    "\\label{eq : cmatrix2}\\ ] ] the first row in this connectivity matrix contains an element with value 3 ( and also two elements of value 2 or greater ) , so we mark it , and we also mark the second column because it has two elements with value 2 or greater . duplicating the first row , we obtain @xmath387 .",
    "\\label{eq : cmatrix2fat}\\ ] ] now duplicating the second column , we obtain the inflated connectivity matrix @xmath388 .",
    "\\label{eq : cmatrix2inflated}\\ ] ] in @xmath385 , the first and second rows , and also the second and third columns , are tracked as duplicated versions of each other .",
    ".1 cm    * 2 ) directly transformation @xmath385 into @xmath389 : * next we make a direct transformation of the inflated connectivity matrix @xmath385 into the polynomial parity check matrix @xmath389 for a two - level restricted hqc ldpc code with @xmath320}=4 $ ] .",
    "we perform this transformation under one additional restriction .",
    "the restriction is that the @xmath134 exponents in pairs of duplicated rows or pairs of duplicated columns must be identical to each other .",
    "the value of @xmath319}$ ] is left as a design parameter .    _",
    "example  [ ex.squashing ] ( continued ) : _ the inflated connectivity matrix @xmath385 is directly transformed into a polynomial parity check matrix @xmath389 , yielding the form @xmath390 . \\ ] ] notice that the @xmath134 exponents in the first and second row and in the second and third columns of this matrix have been restricted to be identical to each other .",
    "otherwise , all the exponents are free parameters that satisfy @xmath391}-1 $ ] for any @xmath20 exponent @xmath236 and @xmath392}-1 = 3 $ ] for any @xmath134 exponent @xmath362 .",
    ".1 cm    * 3 ) maximize the code s girth : * in the next step we apply the girth - maximization algorithm of sec .",
    "[ sec.girthmax ] to produce a set of @xmath20-exponents @xmath236 and @xmath134-exponents @xmath362 such that no short cycles exist except those that are inevitable .",
    "of course , the hill - climbing algorithm of sec .  [ sec.girthmax ] is just one possible approach .",
    "other algorithms could be used in its place .",
    "the polynomial parity - check matrix @xmath389 obtained in this manner can be converted into an equivalent base matrix @xmath393 for a weight - i qc ldpc code .    _",
    "example  [ ex.squashing ] ( continued ) : _ using our girth - maximizing algorithm , we find that with @xmath319}=200 $ ] the following choices for the @xmath20 and @xmath134 exponents in @xmath389 will create no six - cycles or eight - cycles except for inevitable short cycles : @xmath394 . \\ ] ] the code with the above polynomial parity check matrix is equivalent to a standard weight - i qc ldpc code with base matrix @xmath393 given by @xmath395 .",
    "\\label{eq.binflated}\\ ] ] notice that the base matrix @xmath393 is composed of @xmath396 by @xmath396 circulant sub - matrices .",
    ".1 cm    * 4 ) squash the base matrix to remove inevitable cycles : * we now have a base matrix @xmath393 corresponding to the inflated connectivity matrix @xmath385 .",
    "the next steps in our procedure will remove columns and rows from @xmath393 to obtain a base matrix corresponding to our original connectivity matrix @xmath52 .",
    "first , we note that each column of the connectivity matrix @xmath385 corresponds to four columns in the base matrix @xmath393 . in the next step of our procedure ,",
    "we focus on the columns that have been marked as duplicates in @xmath385 .",
    "we retain the left two columns and remove the right two columns in @xmath393 from the four that correspond to the left column of a duplicated pair in @xmath385 , and also remove the left two columns but retain the right two columns in @xmath393 from the four that correspond to the right column of a duplicated pair in @xmath385 .",
    "we call the thinned - out base matrix that is obtained from this procedure @xmath397 .",
    "_ example  [ ex.squashing ] ( continued ) : _ recall that the second and third columns of @xmath385 given in equation ( [ eq : cmatrix2inflated ] ) have been marked as duplicates of each other .",
    "so to obtain @xmath397 from the base matrix @xmath393 given in equation ( [ eq.binflated ] ) , we retain the left two columns from the second four in @xmath397 , and the right two columns from the third four in @xmath397 , so that @xmath397 is given by    @xmath398 . \\ ] ]    .1 cm    now note that each row in the connectivity matrix @xmath384 corresponds to four rows in the base matrix @xmath397 . in the final step of our procedure , we focus on the rows that have been marked as duplicates in @xmath384 .",
    "we retain the top two rows in @xmath397 from the four that correspond to the top row in a duplicated pair in @xmath384 , and we retain the bottom two rows in @xmath397 from the four that correspond to the bottom row of a duplicated pair in @xmath384 .",
    "we call the base matrix obtained by this further thinning - out procedure @xmath399 ; this is the base matrix that will correspond to our original connectivity matrix @xmath52 .    _",
    "example  [ ex.squashing ] ( continued ) : _ the first and second rows of @xmath384 given in equation ( [ eq : cmatrix2fat ] ) have been marked as duplicates .",
    "that means that we should retain the top two rows of the first group of four rows from @xmath397 , and the bottom two rows from the second group of four rows .",
    "thus , we obtain @xmath400 . \\ ] ]    notice that the code defined by the final base matrix @xmath399 is not a hierarchical qc ldpc code , because that base matrix is constructed from 4 by 4 sub - matrices that are not circulant .",
    "still , the code is a member of the class defined by the original protograph . in our example",
    ", each group of four rows and four columns in the base matrix defines a type of check or bit .",
    "so in our example , from the structure of @xmath399 , each check of the first type will be connected to three bits of the first type , and two bits of the second type , and so on , just as required by the protograph .",
    "in fact , any code defined by a base matrix of a form similar to our @xmath399 , for example of the form @xmath401 , \\label{eq.barbitrary}\\ ] ] where the @xmath236 parameters are arbitrary , would also be a member of the class defined by our protograph .",
    "so the question might be raised , why not simply try to find suitable parameters for a weight - i qc ldpc defined by a base matrix like that in equation ( [ eq.barbitrary ] ) directly , instead of using the squashing procedure ?",
    "this question will be answered in more detail in section [ sec.results ] , but the short answer is that the squashing procedure is more practical because it enforces useful additional structure in the base matrix , and thus normally involves far fewer parameters for the hill - climbing algorithm to optimize .",
    "when one tries to optimize over more parameters , there is a greater chance that the hill - climbing algorithms will get stuck in an unfortunate local optimum .",
    "in this section we present a set of numerical results illustrating our design methodology and associated performance results . in sec .",
    "[ sec.wersims ] we present performance results for a pair of girth-10 one - sided spatially - coupled codes and compare them to those of girth-6 codes . in sec .",
    "[ sec.girthmaxvsguessandtest ] we give a sense of the effectiveness of the hill - climbing approach to girth maximization .",
    "we do this by comparing the time required to find a code of a certain girth by hill - climbing and by the guess - and - test algorithm  @xcite . finally , in sec .  [ sec.effectsquashing ] we demonstrate the effectiveness of the squashing procedure by comparing to other candidate approaches .",
    "in this section we present word - error - rate ( wer ) and bit - error - rate ( ber ) results for a pair of girth-10 one - sided spatially - coupled codes .",
    "we plot analogous results for girth-6 codes for comparison .",
    "the first code is a rate-@xmath402 length-@xmath403 qc ldpc code .",
    "the protograph structure of the code is a lengthened version of the one depicted in fig .",
    "[ fig.onesided](a ) . as in that protograph",
    ", each variable has degree three and check nodes have degree six , four or two .",
    "the protograph of the code we present has 20 variable nodes and 11 check nodes ( in contrast the protograph in fig",
    ".  [ fig.onesided](a ) has 14 variable and 8 check nodes ) . in other words",
    "@xmath404 } = 20 $ ] and @xmath405 } = 11 $ ] .",
    "the connectivity matrix of the code is @xmath406 .",
    "\\label{eq.code1conn}\\ ] ] setting @xmath320}=4 $ ] and using our design approach ( girth maximization and squashing ) we found a girth 10 qc ldpc code with @xmath319 } = 100 $ ] .",
    "the code length is @xmath404}\\times p_{[2]}\\times p_{[1 ] } = 8000 $ ] and its base matrix , @xmath407 , is specified in app .",
    "[ sec.basematrixapp ] .",
    "the second code is a rate-@xmath408 length-@xmath409 qc ldpc code .",
    "the protograph structure of the second code is a shortened version of the structure depicted in fig .",
    "[ fig.onesided](b ) . as in that protograph",
    "the variables are all of degree four .",
    "there are six variable nodes and four check node , i.e. , @xmath404 } = 6 $ ] and @xmath405 } = 4 $ ] ( in contrast the protograph in fig .  [ fig.onesided](b ) has 14 variable and 8 check nodes ) .",
    "the connectivity matrix of the code @xmath410 . \\label{eq.code2conn}\\ ] ] again we use @xmath320}=4 $ ] and find a girth 10 qc ldpc code with @xmath319 } = 1000 $ ] .",
    "this code s length is @xmath404}\\times p_{[2]}\\times p_{[1 ] } = 24000 $ ] .",
    "the base matrix , @xmath411 , of this code is also specified in app .",
    "[ sec.basematrixapp ] .    in figs .",
    "[ n8000_wer_ber ] and  [ n24000_wer_ber ] we plot the respective error rate performance for the two codes on the binary symmetric channel ( bsc ) . for purposes of comparison",
    "we plot analogous results for three randomly generated girth-6 qc ldpc codes .",
    "these codes have the same length , same rate , and same non - zero positions in the base matrix as the girth-10 codes to which they are compared .    , length-@xmath403 girth-6 and girth-10 qc ldpc codes.,width=330 ]    , length-@xmath409 girth-6 and girth-10 qc ldpc codes.,width=330 ]    in all cases , we plot the wer and ber as a function of the signal - to - noise ratio ( snr ) , using the gallager - b decoding algorithm  @xcite running for a maximum of @xmath412 iterations to guarantee the convergence of decoding . while there is a significant difference between the error rates of a standard sum - product decoder and gallager - b , the performance trends of gallager - b and sum - product are mostly quite similar .",
    "that said , computational complexity is our main reason to plot results for gallager - b rather than sum - product .",
    "the error floor of gallager - b occurs at a higher wer and thus is easier to attain .",
    "in addition , the gallager - b algorithm runs very fast .",
    "this further helps to collect useful statistics about the error floor regime .    in the plots the snrs",
    "are calculated assuming that the bsc results from hard - decision demodulation of a binary phase - shift keying ( bpsk ) @xmath413 sequence transmitted over an additive white gaussian noise ( awgn ) channel .",
    "the resulting relation between the crossover probability @xmath8 of the equivalent bsc-@xmath8 and the snr of the awgn channel is @xmath414 where @xmath415 is the rate of the code and @xmath416 is the q - function .",
    "figure  [ n8000_wer_ber ] plots the results of the rate-@xmath402 length-@xmath403 codes and illustrates the general improvement to error floor behavior provided by larger girth . at the highest snr ( around 7.8 db )",
    "the wers and bers of the girth-10 code is about two orders of magnitude larger than those of the girth-6 codes .",
    "furthermore , the three girth-6 codes plotted do show some variability in their error rates .",
    "this illustrates that the error floor is not only a function of girth , though higher girth certainly helps .",
    "figure  [ n24000_wer_ber ] plots the results of the rate-@xmath408 length-@xmath409 codes and illustrates some of the same points as were made for the shorter code , as well as some new ones .",
    "first , we note that at these lengths the error floor effect is very abrupt , initiating just below @xmath29 db . again",
    ", higher girth yields a marked improvement , most clearly seen in the wer plots . and again , as also noted in fig .",
    "[ n8000_wer_ber ] , we see some variability in the girth-6 codes .    a new observation comes from observing that the snrs at which the error floor of the girth-6 codes becomes noticeable is different for the wer and ber plots .",
    "it occurs at a higher snr for ber .",
    "first consider the highest snr at which we have results for the girth-6 codes , roughly @xmath417 db . here",
    "the difference between wer and ber is about four orders of magnitude .",
    "recalling that the codes are of length @xmath409 this means that the post - decoding error patterns in this regime consist of only a few erroneous bits , consistent with failures caused by small trapping sets .",
    "in contrast , if we consider the last data point prior to the error floor , at around @xmath418 db , the ratio between word- and bit - error rate is only about one order of magnitude .",
    "this implies that the ber is still dominated by much heavier weight error patterns , consistent with the decoder being in the waterfall regime .",
    "now , consider the final data point for the girth-10 code that we were able to obtain at just over @xmath29 db . while by considering the wer plots of the girth-6 codes we confirm that those codes are already in their error floor regime , the same is not true of the girth-10 code , for which the difference between its wer and ber is less than an order of magnitude .      in this section",
    "we develop a sense of how much the hill - climbing type of girth maximization algorithm presented in sec .",
    "[ sec.girthmax ] helps in finding high girth codes .",
    "we compare our algorithm to the baseline guess - and - test algorithm  @xcite . to understand guess - and - test , consider a regular weight - i qc ldpc code specified by a @xmath419 base matrix and a desired girth .",
    "guess - and - test fixes all entries in the first row and the first column of the base matrix to be zero .",
    "the rest it chooses independently and uniformly between @xmath61 and @xmath62 .",
    "this process is continued until a set is found such that the condition for the existence of a cycle , e.g. , ( [ p4cycle ] ) , is verified not to hold for all cycles shorter than the desired girth .",
    "the problem with guess - and - test is that it is time - consuming and does nt exploit the structure of the cycles in its search , in contrast to our hill - climbing algorithm .    to make an informative comparison with guess - and - test , we define `` success rate '' to be the fraction of times that a run of either algorithm ( guess - and - test or hill - climbing ) results in a base matrix that has the desired girth and circulant matrices size @xmath166}}$ ] .",
    "figure  [ comparej3l9 ] depicts the success rate of the guess - and - test and hill climbing in generating girth-@xmath420 weight - i regular qc ldpc codes with base matrices of size @xmath421 .",
    "we observe that for the guess - and - test to find a parity check matrix with girth-@xmath420 at a circulant size @xmath166}}=50 $ ] we need , on average , to test @xmath422 random matrices .",
    "in contrast , hill climbing has near certain success .",
    ".,width=330 ]      we conclude our discussion of numerical examples by discussing the computational motivations for the squashing procedure .",
    "recall that in sec .",
    "[ sec.squashing ] we raised the following question .",
    "why do we not simply try directly to find suitable parameters for a weight - i qc ldpc code , rather than constructing an hqc code and using the squashing procedure ?",
    "we now show that it is much harder to find a suitable code using the direct method .    to show this we present results on the following experiment .",
    "first we construct several protographs with structures similar to fig .",
    "[ fig.onesided](a ) with the number of check nodes ranging from three to nine .",
    "we set @xmath320 } = 4 $ ] which means that the number of rows in the corresponding base matrices ranges from 12 to 36 .",
    "for each protograph , we construct girth-10 qc ldpc codes with @xmath319 } = 100 $ ] using the girth maximization algorithm and the squashing procedure .",
    "we also try to construct girth-10 weight - i qc ldpc codes with base matrices having the same size and same non - zero positions as those obtained from the squashing procedure using the direct method .",
    "the same hill climbing algorithm is applied to this design problem as is used in conjunction with the hqc ldpc approach .",
    "we record the time of designing ten codes for each configuration .",
    "figure  [ timing ] depicts the average time required to construct one girth-10 qc ldpc code using each of these two schemes .        for both schemes , the time required to find a girth-10 code increases with the number of rows in the base matrix .",
    "when the squashing procedure is used , we can find a suitable base matrix in reasonable time even for large base matrices ( large number of rows ) .",
    "in contrast , when using the direct method , we have to spend an extremely long time searching even for a small base matrices . from this comparison ,",
    "we conclude that the squashing method is quite a bit more efficient .",
    "in this paper we present a methodology for designing high - girth qc ldpc codes that match a given protograph structure . in developing our methodology , we introduce a new class of _ hierarchical _ qc ldpc codes and explain how to determine the girth of such codes .",
    "the hierarchical qc ldpc codes can be represented using parity check matrices over multi - variate polynomials , or in terms of a tree structure .",
    "we show that higher - weight versions of hierarchical codes suffer from inevitable cycles in analogous ways to non - hierarchical qc ldpc codes , but that a straightforward _ squashing _ procedure can remove these cycles .",
    "we introduce a hill - climbing procedure to eliminate the non - inevitable cycles from the code , and subsequently remove the inevitable cycles by squashing .",
    "thus the main use of the hierarchical codes in this paper is to reduce the number of free parameters in the codes in an effort to make the girth maximization procedure computationally tractable and fast , while knowing that the inevitable cycles can be removed by squashing . in our numerical results",
    "we illustrate the computational advantage of the hill - climbing and squashing procedures in comparison with other standard approaches .",
    "we demonstrate our concepts and design procedure for the case of one - sided spatially - coupled qc ldpc codes .",
    "we present designs for two such codes , of different rates and block lengths , both of girth-10 .",
    "we compare their performance to girth-6 codes and observe a significant decrease in the error floor .",
    "we note that the second code , whose variable nodes are of weight four , does not demonstrate any error floor tendencies down to a wer of about @xmath423 , i.e. , the slope of the wer as a function of snr is still steepening .",
    "computational effort limited us from simulating lower wers .",
    "but we note that the gallager - b algorithm we chose to simulate displays much higher error floors than the standard sum - product or min - sum algorithms .",
    "( in fact , this is why we choose to simulate this algorithm . ) given that the class of one - sided spatially coupled codes has already been theoretically shown to have excellent waterfall performance , we believe the evidence presented strongly indicates that the techniques introduced herein can produce practical codes with very good performance in both the waterfall and error floor regimes .",
    "in this appendix we present our girth maximizing algorithms .",
    "as discussed in the text the objective of these algorithms is to remove all _ non - inevitable _ cycles from the quasi - cyclic codes .",
    "we first present our algorithm for weight-1 qc ldpc codes , and then for general heavier - weight or hqc ldpc codes .",
    "we do this for simplicity of explanation as the latter algorithm is a generalization of the former .            *",
    "( ii ) calculate cost vector of current code : * use subroutine  1 , described in appendix  [ app.costqcldpc ] , to calculate the cost vectors of the current code , i.e. , @xmath428 .",
    "then for each element of @xmath429 we calculate the change in edge label that most reduces cost , and the resulting cost , respectively : @xmath430 recalling that @xmath431 $ ] is the value of the of the coefficient of the current code @xmath328}$ ] , let @xmath432 ) \\nonumber\\end{aligned}\\ ] ] be the cost of the coefficient if it remains unchanged .          *",
    "if @xmath438)=0 $ ] for all @xmath88 such that @xmath333 , then we have found a code that satisfies the desired parameters . * else if there is a @xmath88 such that @xmath438)\\neq 0 $ ] the algorithm has converged to a local minimum .",
    "we now present the generalized algorithm for heavier - weight qc ldpc and hqc ldpc codes .",
    "in contrast to the first algorithm , the trees @xmath439 that define these codes have more than one edge .",
    "therefore , for each edge of each tree we define a cost vector .",
    "we index the cost vectors both by their level in the tree and by their position within each level , as well as by @xmath114 and @xmath115 , thus @xmath440}}-1}}]\\ ] ] for @xmath441|$ ] and @xmath282 where we recall that @xmath442|$ ] is the number of edges at level @xmath153 in @xmath206 .        for each pair",
    "@xmath88 such that @xmath424 , randomly initialize the values for each edge label ( while obeying the requirement that sibling edges must have distinct labels ) .",
    "probably the most straightforward way to do this is to work down the tree from level @xmath142 to the first level , picking the edge labels for each set of sibling edges at level @xmath153 uniformly without replacement from @xmath443}}-1\\}$ ] . given the initial edge labels , compute all non - zero code coefficients , i.e. , those associated with each leaf .",
    "* ( ii ) calculate cost vector of current code : * use subroutine  2 , described in appendix  [ app.costhqcldpc ] , to calculate the cost vectors of the current code , i.e. , @xmath444 .",
    "then for each element of @xmath429 we calculate the change in edge label that most reduces cost , and the resulting cost , respectively : @xmath445}}-1 } { { \\gamma}_{j , l , i , k}}(z ) , \\\\ { \\tilde{{\\gamma}}_{j , l , i , k } } & = \\min_{z : 0 \\leq z",
    "\\leq { p_{[k]}}-1 } { { \\gamma}_{j , l , i , k}}(z).\\end{aligned}\\ ] ]    recalling that @xmath446 $ ] is the value of the of the @xmath153th coordinate of the current code coefficient @xmath447}$ ] , let @xmath448 ) \\nonumber\\end{aligned}\\ ] ] be the cost if the coefficient value at the @xmath153th level remains unchanged .    *",
    "( iii ) identify best edge label to change : * identify the edge label to change that would most greatly reduces the cost , i.e. , @xmath449 } } ,   1 \\leq l \\leq { l_{[k]}}\\\\           & \\hspace{-1em } { { \\bf t}}_{j , l } \\neq { \\ast } ,   1 \\leq i \\leq          |{{\\bf t}}_{j , l}[k]|\\\\ & \\hspace{-1em } 1 \\leq k \\leq k        \\end{array } \\end{footnotesize } }    \\hspace{-3em } { { \\gamma}_{j , l , i , k}^{-}}-{\\tilde{{\\gamma}}_{j , l , i , k}},\\ ] ] where we break ties randomly .",
    "there are two possible outcomes .    *",
    "if @xmath450 , we update the code by setting the value of the @xmath451th edge at the @xmath452th level of @xmath453 equal to @xmath454 .",
    "+ we iterate by now returning to step ( ii ) . *",
    "if @xmath455 , the algorithm terminates .",
    "+      * if for all @xmath456 we have @xmath457 when @xmath135 is set to equal the current label of the @xmath5th edge at level @xmath153 in tree @xmath206 , then we have found a code that satisfies the desired parameters .",
    "* else there is a @xmath456 such that @xmath458 and the algorithm has converged to a local minimum .",
    "recall from the discussion of section  [ sec.hillnonhier ] that the determination of guilty values becomes complicated when there are repeated elements in a path . to aid in dealing with these repeated elements , in this appendix",
    ", we define the `` multiplicity '' of each path element .",
    "this definition is needed for for the cost vector calculation subroutines of both qc and hqc ldpc codes , described in appendices  [ app.costqcldpc ] and  [ app.costhqcldpc ] , respectively .",
    "[ def.multiplicity ] given a path @xmath243 , any coefficient in @xmath102 is said to be _ repeated _ @xmath459 times if there are @xmath459 elements of @xmath242 , indexed by @xmath460 , for which @xmath461 and for which @xmath462 } = \\ldots = { { \\bf { s}}[j_{i_r},l_{i_r}]}$ ] .",
    "the _ multiplicity _",
    "@xmath359 of the element is computed as @xmath463 for path elements where @xmath464 , @xmath465 is termed the _ first occurrence _ of the element .    the multiplicity can be a positive integer , a negative integer , or zero . when a path element has multiplicity zero the value of the coefficient has no effect on whether ( that particular ) path corresponds to a cycle .      in this appendix",
    "we present the subroutine for the calculation of the cost vectors of a weight - i qc ldpc code . in other words ,",
    "given a set of labeled trees we calculate the matrix specified in  ( [ eq.costmatrix ] ) .",
    "the subroutine takes as inputs the current tree structure @xmath240 ( i.e. , the set of labeled trees or , equivalently , the current parity check matrix @xmath19 ) , the desired girth @xmath343 , and a vector of costs @xmath466 .    *",
    "( i ) define helper variables : * define @xmath467 to be the number of cycles of length-@xmath241 that would result if edge label @xmath431 $ ] were set to equal value @xmath135 .",
    "in other words , the code was modified to be one in which @xmath336 } = 1 $ ] and @xmath426 } = 0 $ ] for all @xmath427 .",
    "initialize all @xmath468 .    *",
    "( ii ) iterate through path lengths , paths , and path elements : * consider in turn : ( a ) each path length @xmath469 where @xmath470 and @xmath337 is the desired girth ; ( b ) each path of length @xmath469 , @xmath471 where @xmath472 and @xmath473 ; and ( c ) the first occurrence of each path element ( indexed by @xmath474 ) in @xmath242 that has non - zero multiplicity .    *",
    "( iii ) calculate guilty values and adjust helper variables : * let @xmath475 $ ] be the first occurrence of a path element of multiplicity @xmath476 .",
    "we want to compute the set of possible values for @xmath477 $ ] that would satisfy the condition for the existence of a cycle .",
    "recall from  ( [ girthcon ] ) that a cycle exists for the current path values if @xmath478 \\ ; \\textmd{mod } \\ ; p = 0 .",
    "\\label{eq.doescycleexist}\\ ] ] to check if a value @xmath479 to which @xmath480 $ ] could be changed would satisfy  ( [ eq.doescycleexist ] ) , we subtract the contribution of the current value of @xmath480 $ ] , add in the contribution of the candidate value @xmath481 , and see if the result is equal to zero .",
    "that is , we check whether or not the relation @xmath482 - \\kappa s[j_\\tau ,    l_\\tau ] + \\kappa \\beta \\right\\}\\ ; \\textmd{mod } \\ ; p = 0\\ ] ] holds .",
    "equivalently , we ask is @xmath483 - \\sum_{t=1}^{2 \\lambda } ( -1)^{t } s[j_t , l_t ] , \\label{eq.condonbeta}\\ ] ] where the congruence is modulo-@xmath8 ?      _",
    "remarks : _ by only computing the @xmath481 for the first occurrence of each path element , we avoid double - counting the contribution to cycles of elements with @xmath464 . allowing @xmath359 , defined in  ( [ def.kappa ] ) , to take on either positive or negative values lets the multiplicity of the element indicate its `` aggregate polarity '' , i.e. , whether it enters the sum  ( [ eq.doescycleexist ] ) as a positive or a negative contribution . since the calculations of @xmath481 in  ( [ eq.condonbeta ] ) are over a ring , multiple values of @xmath481 can satisfy the condition . to be prime , which we do not , then the calculations would be over a field and there would be a unique solution @xmath481 . we do not choose to do this due to the greater limitation on the possible resulting block lengths of the code .",
    "] however , at most there are @xmath487 such values of @xmath481 .",
    "this is because the set of satisfying values of @xmath481 forms a coset of @xmath488 with respect to the subgroup @xmath489 , the cardinality of which is upper bounded by @xmath359 .",
    "finally , we note that if @xmath490 , a @xmath481 satisfying  ( [ eq.condonbeta ] ) exists and it is the unique such @xmath481 .    * ( iv ) compute cost vectors : * after considering all paths lengths @xmath469 , @xmath491 , all @xmath471 , and all elements of each path @xmath242 , calculate the cost vectors element - by - element as @xmath492          the subroutine takes as inputs the current tree structure @xmath240 ( i.e. , set of labeled trees or , equivalently , the current parity check matrix @xmath19 ) , the desired girth @xmath343 , and a vector of costs @xmath466 .    *",
    "( i ) define helper variables : * define @xmath493 $ ] to be the number of cycles of length-@xmath241 that would result if the @xmath5th edge at level @xmath153 in @xmath206 were set to equal value @xmath135 , @xmath494}}-1 $ ] .    _",
    "remark : _ modification of a single edge has in a hierarchical code will , in general , change a number of code coefficients .",
    "in particular , all coefficients associated with leaves that are descendents of that edge will change in their @xmath153th coordinate .",
    "these coefficients will change from ones in which @xmath495 } & = 1 \\hspace{1em } \\mbox{and}\\\\ { { c}_{{{s}_{1 } } , \\ldots , { { s}_{k-1 } } , z , { { s}_{k+1 } } , \\ldots { { s}_{k}}}[j , l ] } & = 0\\end{aligned}\\ ] ] to ones in which @xmath496 } & = 1 \\hspace{1em } \\mbox { and}\\\\ { { c}_{{{s}_{1 } } , \\ldots , { { s}_{k-1 } } ,    { { s}_{k } } , { { s}_{k+1 } } , \\ldots { { s}_{k}}}[j , l ] } & = 0.\\end{aligned}\\ ] ] initialize all @xmath493 = 0 $ ] .    *",
    "( ii ) set infinite costs : * for each @xmath497 , each pair @xmath88 , @xmath145}}$ ] , @xmath498}}$ ] , each level @xmath153 , @xmath282 , and each level-@xmath153 edge index @xmath5 , @xmath441|$ ] , let @xmath499 be the set of labels of sibling edges",
    ". for each @xmath500 set @xmath501 =   \\infty.\\ ] ]    _ remark : _ recall from the algorithms described in section  [ sec.girthmax ] that our approach to code optimization is to identify the change in the single edge label that most reduces a weighted sum of cycle counts .",
    "in the special case of weight - i qc ldpc codes there was a one - to - one mapping between code coefficients and tree edges ( since each tree has only a single edge ) . in the generalized",
    "setting we are now considering we seek to identify the change in a single edge of one of the trees that will most reduce the cost . by setting certain costs to infinity , certain changes in code structure will never be made .",
    "the changes thus barred are those that would change the tree topology . by setting those costs to infinity",
    "we ensure that the unlabeled trees that describe our code remains an invariant under our algorithm .    *",
    "( iii ) iterate through path lengths , paths , and path elements : * consider in turn : ( a ) each path length @xmath469 where @xmath470 ; ( b ) each path of length @xmath469 , @xmath471 where @xmath243 and @xmath502 ; ( c ) the first occurrence of each path element ( indexed by @xmath503 ) in @xmath242 that has non - zero multiplicity .    *",
    "( iv ) determine whether a particular path element can have `` guilty '' vales : * let @xmath504}$ ] be the first occurrence of a path element of multiplicity @xmath476 .",
    "recall that @xmath505 $ ] corresponds to the label of an edge of tree @xmath506 at level @xmath153 .",
    "now , for the coefficient @xmath504}$ ] under consideration , iterate through each level of the code . for each level @xmath153 , @xmath282 compute @xmath507 \\ ; \\textmd{mod } \\ ; { p_{[k]}}.\\end{aligned}\\ ] ] unless @xmath508 _ for all but one _ value of @xmath153 , there are no guilty values",
    ". if there are no guilty values , proceed to the next path element . if there is a single level @xmath509 such that @xmath510 proceed to step ( v ) .",
    "_ remark : _ the reason for the all - but - one condition is that we change at most one edge label per iteration . therefore , unless @xmath511 for all but one value of @xmath153 there is no single change in an edge label that would result in a cycle in this iteration .    * ( v ) calculate guilty values and adjust helper variables : * now consider coordinate @xmath509 of the path element @xmath504}$ ] whose multiplicity @xmath476 .",
    "the same logic as led to  ( [ eq.condonbeta ] ) can again be used to identify the guilty values , now at level @xmath153 .",
    "that is , compute the set of values of @xmath481 , @xmath512}}-1 $ ] such that @xmath513 - \\sum_{t=1}^{2    \\lambda } ( -1)^{t } { { s}_{k}}[j_t , l_t ] .",
    "\\label{eq.condonbetahier}\\ ] ]    for each value of @xmath481 , @xmath512 } } - 1 $ ] satisfying  ( [ eq.condonbetahier ] ) we increment @xmath514 $ ] as @xmath515 = x_{j_t , l_t , i,\\beta}^{({\\lambda})}[k]+1.\\ ] ] where @xmath5 , @xmath516|$ ] , is the index of the level-@xmath153 edge in @xmath517 whose label is @xmath505 $ ] .    _",
    "remarks : _ one of the added complications of the generalized algorithm is that there is not a one - to - one mapping between the code parameters that we are adjusting ( the tree edge values ) and the code coefficients ( each of which is associated with one leaf of the tree ) . when an edge value is adjusted there is a ripple effect , changing the coefficients associated with all descendent leaves .",
    "however , each change in a edge label effects only one of the @xmath142 sums  ( [ def.pathsum ] ) , all of which theorem  [ thm.girthcond ] requires to be equal to zero for a cycle to exist .",
    "thus , although there is a ripple effect on the code coefficient when adjusting edge labels , the values of the @xmath518 $ ] at other levels is not effected .",
    "thus , considering the tree structure of the code nicely decouples the question of girth and the search for high - girths from the algebraic structure of the code .      to prove part ( i ) of the lemma consider the ordered set of coefficients  ( [ eq.sixcycleinevpath ] ) that describes the inevitable cycle .",
    "note that the first and last coefficient must be in the same row of the base matrix since the path defines a cycle .",
    "the second and third and the fourth and fifth coefficients must also each be in the same row .",
    "since , when viewed at the first level of the code , successive rows in a path must be distinct , three distinct rows are traversed . in fig .",
    "[ fig.illustrativepaththroughbasemat_six ] we illustrate this logic for a matrix corresponding to the polynomial @xmath519 , @xmath520,and @xmath521^t , [ a_2\\;1]^t , [ a_3\\;2]^t , [ a_1\\;0]^t , [ a_2\\;1]^t , [ a_3\\;2]^t\\}$ ]        the logic of part ( ii ) is the same for rows and columns , hence we provide the proof only for part the former .",
    "consider the ordered set of coefficients of  ( [ eq.eightcycleinevpath ] ) .",
    "we assert that again the path must traverse at least three rows of the base matrix . as before the first and last coefficients must be in the same row since this path defines an inevitable cycle .",
    "each other sequential pair of elements  @xmath522^t , [ b_1\\;b_1]^t)$ ] , @xmath523^t , [ a_2\\;a_2]^t)$ ] , and @xmath524^t , [ b_2\\;b_2]^t)$ ]  must also lie in the same rows .",
    "consider the pair @xmath523^t , [ a_2\\;a_2]^t)$ ] .",
    "the row this pair lies in can either be distinct from the starting row or it can be the same . if this row is distinct from the starting row then , since successive rows are distinct , the row in which @xmath522^t , [ b_1\\;b_1]^t)$ ] lies must be distinct both from this row and from the starting row and the lemma is proved for this case . on the other hand ,",
    "say @xmath523^t , [ a_2\\;a_2]^t)$ ] lies in the starting row .",
    "we assert that in this case @xmath522^t , [ b_1\\;b_1]^t)$ ] and @xmath524^t , [ b_2\\;b_2]^t)$ ] must lie in distinct rows and so the total number of rows again is at least three . to see this last assertion note first that the first @xmath525^t$ ] and the fifth coefficient @xmath526^t$ ] are , by assumption , in the same row .",
    "next observe that the second and sixth coefficients are @xmath526^t$ ] and @xmath527^t$ ] , respectively , both in distinct rows from the first .",
    "as long as @xmath167 } } > 2 $ ] these latter two coefficients ( the second and sixth ) must be in distinct rows of the base matrix .",
    "this follows from the cyclic nature of the code .",
    "the only way a pair of coefficients could appear in two distinct rows and two distinct columns in swapped order would be if @xmath167 } } = 2 $ ] , but we have assumed that @xmath167 } } = 4 $ ] .    the logic of the second case is illustrated in fig .",
    "[ fig.illustrativepaththroughbasemat_eight ] for the pair of polynomials @xmath528 and @xmath529 .",
    "the path illustrated corresponds to @xmath530 and @xmath531 } , { \\left [ \\ ! \\begin{array}{c } \\!\\ ! a_2 \\!\\ ! \\\\ \\!\\ !        1 \\!\\ ! \\end{array } \\ !",
    "\\right ] } , { \\left [ \\ ! \\begin{array}{c } \\!\\ ! b_1 \\!\\ ! \\\\ \\!\\",
    "0 \\!\\ ! \\end{array } \\ ! \\right ] } , { \\left [ \\ ! \\begin{array}{c } \\!\\ ! b_2 \\!\\ ! \\\\ \\!\\",
    "!        3 \\!\\",
    "\\end{array } \\",
    "! \\right ] } , { \\left [ \\ ! \\begin{array}{c } \\!\\ ! a_2 \\!\\ ! \\\\ \\!\\ !        1 \\!\\ !",
    "\\end{array } \\ ! \\right ] } , { \\left [ \\ ! \\begin{array}{c } \\!\\ !",
    "a_1 \\!\\ ! \\\\ \\!\\ !        0",
    "\\end{array } \\ ! \\right ] } , { \\left [ \\ ! \\begin{array}{c } \\!\\ ! b_2 \\!\\ ! \\\\ \\!\\",
    "!        3 \\!\\",
    "\\end{array } \\ !",
    "\\right ] } , { \\left [ \\ ! \\begin{array}{c } \\!\\ ! b_1 \\!\\ ! \\\\ \\!\\",
    "!        0 \\!\\ !",
    "\\end{array } \\ !",
    "\\right]}\\right\\}.\\end{aligned}\\ ] ]          in this appendix , the base matrices of the two girth 10 qc ldpc codes discussed in sec .",
    "[ sec.results ] are specified below .",
    "the base matrix of the first code , @xmath407 is written in the transposed format due to space .",
    "s. y. chung , g. d. forney , t. j. richardson , and r. l. urbanke , `` on the design of low - density parity check codes within 0.0045 db of the shannon limit , '' _ ieee commun .",
    "_ , vol . 5 , pp",
    "58 - 60 , feb . 2001 .",
    "i. djurdjevic , j. xu , k. abdel - ghaffar , and s. lin , `` a class of low - den- sity parity - check codes constructed based on reed - solomon codes with two information symbols , '' _ ieee commun .",
    "_ , vol . 7 , pp",
    "317319 , july 2003 .",
    "m. lentaier , a. sridharan , k. s. zingangirov , and d. j. costello , jr .",
    ", `` iterative decoding threshold analysis for ldpc convolutional codes , '' _ ieee trans .",
    "inform . theory _",
    "5274 - 5289 , oct .",
    "2010 .",
    "z. li and b.v.k.v .",
    "kumar , `` a class of good quasi - cyclic low - density parity check codes based on progressive edge growth graph , '' _ eighth asilomar conference on signals , systems , and computers _",
    ", 2004 , pp .",
    "1990 - 1994 .",
    "r.  smarandache and p.  o.  vontobel , `` quasi - cyclic ldpc codes : ifluence of proto- and tanner - graph structure on minimum hamming distance upper bounds , '' _ ieee trans . inform . theory _ , submitted [ arxiv:0901.4129v1 ] .",
    "i.  e.  bocharova , f.  hug , r.  johannesson , b.  d.  kudryashov , and r.  v.  satyukov `` searching for voltage graph - based ldpc tailbiting codes with large girth , '' _ ieee trans .",
    "inform . theory _ , submitted [ arxiv:1108.0840v1 ] ."
  ],
  "abstract_text": [
    "<S> we present a general approach to designing capacity - approaching high - girth low - density parity - check ( ldpc ) codes that are friendly to hardware implementation . </S>",
    "<S> our methodology starts by defining a new class of _ hierarchical _ quasi - cyclic ( hqc ) ldpc codes that generalizes the structure of quasi - cyclic ( qc ) ldpc codes . whereas the parity check matrices of qc ldpc codes are composed of circulant sub - matrices , those of hqc ldpc codes are composed of a hierarchy of circulant sub - matrices that are in turn constructed from circulant sub - matrices , and so on , through some number of levels . </S>",
    "<S> we show how to map any class of codes defined using a protograph into a family of hqc ldpc codes . </S>",
    "<S> next , we present a girth - maximizing algorithm that optimizes the degrees of freedom within the family of codes to yield a high - girth hqc ldpc code . finally , we discuss how certain characteristics of a code protograph will lead to inevitable short cycles , and show that these short cycles can be eliminated using a `` squashing '' procedure that results in a high - girth qc ldpc code , although not a hierarchical one . </S>",
    "<S> we illustrate our approach with designed examples of girth-10 qc ldpc codes obtained from protographs of one - sided spatially - coupled codes . </S>"
  ]
}