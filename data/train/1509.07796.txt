{
  "article_text": [
    "there are two different approaches to fabricating a large - scale universal quantum computer .",
    "one is to create a single ` monolithic ' architecture in which each qubit is directly and deterministically connected to its neighbours .",
    "an alternative is the network architecture  @xcite , where a single quantum computer is formed from numerous interlinked small devices , _ modules _ , each having only a modest number qubits and correspondingly little computational power .",
    "this approach may prove to be well suited to ion trap systems  @xcite or colour centres in diamond  @xcite , where optical activity can be directly harnessed to create a photonic link ; modules comprised of superconducting qubits can also be networked either via microwave links  @xcite or by exploiting microwave to optical converters .",
    "it is likely that the size of a module , i.e.  the number of physical qubits within it , may vary dramatically according to the technology : whereas a colour centre might have at most a dozen or so satellite nuclear spins , a superconducting module could easily be envisaged as a grid of hundreds of qubits .",
    "it is therefore interesting to ask what impact the module size has on performance characteristics such as the fault tolerance threshold , and thus the total number of physical qubits needed per logical qubit .",
    "an advantage of the network architecture is its manifest scalability .",
    "however , based on experimental results to - date it is reasonable to assume that inter - module communications will only provide low - quality entanglement  @xcite compared with intra - module quantum gates  @xcite .",
    "whatever approach one adopts to mitigate the noise on the links , there will inevitably be a resource cost versus an idealised monolithic architecture were all gates are of comparable fidelity to the intra - module operations .",
    "in other words , to implement the same quantum algorithm , more qubits are required on the network architecture to overcome network noise .",
    "a goal of this paper is to quantify this difference .",
    "we investigate quantum computing with a network architecture involving modules containing from only two qubits to about a thousand qubits . in our study",
    ", we exploit two methods to negate errors : entanglement purification  @xcite and error correction via the surface code  @xcite . entanglement purification is a low - level process that corrects errors in inter - module links and is carried out individually within each module with the help of classical communications .",
    "we use the term ` broker unit ' for the dedicated hardware ( comprising one or more qubits ) associated with entanglement purification .    for small modules with only a few qubits in total ,",
    "each module only provides one qubit participating the surface code while the rest are involved in purification .",
    "this is equivalent to architectures that have been studied in earlier papers  @xcite .",
    "the challenge we tackle here is to efficiently exploit large modules with at least tens of qubits ; our solution retains the purification but additionally introduces a hierarchical variant of the surface code .",
    "a piece of surface code ( or ` patch ' ) exists in every module , such that each module can be effectively regarded as a single qubit in a higher ( logical level ) surface code .",
    "there are interesting consequences for the localisation and correction of errors , given that such errors tend to occur at the boundaries between the modular patches .",
    "in essence the errors live in a two - dimensional space , one spatial and one temporal dimension , so that the relevant threshold is _ equivalent _ that of a two spatial dimension system with perfect noise - free stabiliser measurement . in this way the hierarchical surface code tolerates network errors up to @xmath2 , and",
    "purification techniques need only bring the network noise within this limit .",
    "one might expect that the performance of a network computer will approach that of a monolithic computer as the module size increases . to compare the resource requirements we study the number of qubits required for encoding a single logical qubit .",
    "we find that the total number of physical qubits required per logical qubit does indeed decrease with the size of modules .",
    "for a practical level of network noise and modules containing hundreds of qubits , the cost of encoding a logical qubit on the network architecture is still about nine times higher than the cost on the monolithic architecture .",
    "meanwhile we find that for a ` fine grained ' network comprised of small modules containing only @xmath1 qubits , the overhead versus the monolithic system is a factor of about fifteen .",
    "it is perhaps surprising that the resource cost associated with adopting the flexible network paradigm varies so little over a wide range of module sizes , i.e.  network granularity does not strongly affect the total resource cost .",
    "client - qubit array as well as @xmath3 broker units on the perimeter , where @xmath4 is the dimension of module .",
    "the modules in this figure have @xmath5 .",
    "broker units achieve entanglement with one another via inter - module optical couplings .",
    "typically the raw entanglement will be generated by a joint measurement on photons emitted from optically active broker qubits . inside a broker unit , there are additional ancilla qubits which are used to purify raw entanglement to a higher fidelity .",
    "( b ) each simple module only contains one client qubit and one broker unit .",
    "a simple module is coupled with four neighbouring modules via a switch for rerouting the optical connection . ]",
    "we consider a quantum computer built with networked quantum modules as shown in fig .",
    "[ fig : module ] .",
    "we focus on the case that each module contains an array of _ client _ qubits and a series of entanglement - purifying _ broker units _ on the perimeter of the client array ; each broker unit contains several qubits as we presently discuss [ see fig .  [",
    "fig : module ]  ( a ) ] .",
    "quantum information is stored in client qubits , and brokers are used to generate entanglements between neighbouring modules . in each broker unit , there must be at least one qubit that is optically coupled with another module .",
    "raw entanglement prepared with the optical coupling is purified with the help of other qubits in broker units ; the qubits forming the surface code ` patch ' therefore never ` see ' the raw entanglement , only the purified form . to provide a context for assessing the performance of the hierarchical surface code",
    ", we also consider the limit of small modules where each module may contain only one client qubit and one broker unit [ see fig .",
    "[ fig : module ]  ( b ) ] , in which case the sole broker unit services links to all connected modules by rerouting the optical connection as required .",
    "these small modules do not use hierarchical surface code , instead relying on a single surface code layer .    :",
    "solid edges correspond to intra - module gates , and gates of dashed lines are implemented with inter - module entanglement , i.e.  distributed cnot gates .",
    "errors arising from imperfectly purified remote entanglement will only affect qubits on the perimeter of a module , these are marked with bold edges .",
    "@xmath6 and @xmath7 denote pauli operators of module qubits . ]",
    "intra - module cnot gates are performed via interactions between qubits within the module .",
    "we assume that these cnot gates are available for any pair of nearest - neighbouring qubits in the same module",
    ". for client qubits in different modules , _ distributed _ cnot gates are performed by consuming entanglement that has been generated between brokers .",
    "the circuit for the distributed cnot gate  @xcite is shown in fig .",
    "[ fig : circuit ]  ( a ) .    with the geometry of modules in fig .",
    "[ fig : module ] , client qubits on the perimeters of neighbouring modules are indirectly coupled through brokers .",
    "therefore , ultimately a square lattice is formed by all client qubits of the network , in which ( intra - module or distributed ) cnot gates are available for any pair of nearest - neighbouring qubits . with such a lattice , we can implement the surface code across the entire module network .    within the surface - code lattice ( fig .",
    "[ fig : code ] ) , qubits are divided into three groups : data qubits ( circles ) , and measurement - enabling qubits of two kinds : x ancillary qubits ( crosses ) and z ancillary qubits ( squares ) .",
    "the subspace for encoding information in the collective is defined by enforcing sets of stabilisers @xmath8 and @xmath9 , which are products of pauli operators on four data qubits surrounding x ancillaries and z ancillaries , respectively  @xcite .",
    "errors are detected by repeatedly measuring stabilisers  @xcite with circuits shown in fig .",
    "[ fig : circuit ]  ( d )  and  ( e ) .",
    "( @xmath10 , which is prepared by a hadamard gate on the state @xmath11 ) and measured in the @xmath12 basis ( @xmath13 basis , which can be realised with the measurement in the @xmath12 basis after a hadamard gate ) after @xmath14 rounds of physical - qubit stabiliser measurements .",
    "when measurements of module - qubit x ( z ) stabilisers are in progress , z ( x ) modules are not involved in physical - qubit stabiliser measurements . between each set of module - qubit stabiliser measurements ,",
    "physical - qubit stabiliser measurements are performed on only q modules for @xmath14 rounds . ]    in our modular network , errors associated with the entanglement generated over network links are first reduced by entanglement purification . after the purification , there are still some residual errors in the inter - module entanglement because of the limited resources of each broker unit .",
    "these residual entanglement errors , together with errors arising from intra - module operations , are finally corrected by the surface code . assuming the entanglement is ideally in the form @xmath15 , we model the error - burdened entangled state as @xmath16 + p_\\text{x}[x ] + p_\\text{z}[z ] + p_\\text{z}[z ] , \\label{eq : enterror}\\end{aligned}\\ ] ] where @xmath17 is the fidelity , the superoperator @xmath18\\rho = u\\rho u^\\dag$ ] , and @xmath19 are pauli operators on one of two entangled qubits . for intra - module operations ,",
    "we assume a qubit may be initialised in the incorrect state with the probability @xmath20 ; the measurement may report an incorrect outcome with the probability @xmath21 ; and each single - qubit gate and cnot gate may induce an error with the probability @xmath22 and @xmath23 , respectively .",
    "a noisy gate is modelled as a perfect gate followed by single - qubit depolarizing noise for single - qubit gates and two - qubit depolarizing noise for the cnot gate  @xcite .    as one might expect",
    ", we find that if we consider modules containing a larger client array then more residual entanglement errors can be corrected with the surface code .",
    "this would be true even if we were to simply regard all the ` patches ' of surface code as part of a single surface without giving any special status to the borders between patches .",
    "however , in doing so we would be failing to exploit our knowledge that errors are more common along the perimeters . to properly exploit the potential advantage of large modules , instead of continuously performing stabiliser measurements on the entire surface - code lattice , we introduce an intermediate encoding based on the client array of each module .",
    "similar to physical qubits on the surface - code lattice , modules are also divided into three groups : q modules , x modules and z modules ( see fig .  [",
    "fig : code ] ) .",
    "the client array of each q module itself is a piece of complete surface - code lattice , hence one informational qubit can be encoded in each q module , and we refer to this as a _ module qubit_. moreover , the x modules and z modules have roles similar to x ancillary qubits and z ancillary qubits in the basic surface code : they perform x - stabiliser and z - stabiliser measurements on neighbouring module qubits , respectively .",
    "therefore , a network of modules forms a surface code on a higher level where each module - qubit now constitutes a basic unit .",
    "a logical qubit of the algorithm being executed on the computer will be encoded at this level , thus spanning multiple modules .    the protocol for performing stabiliser measurements on the module - qubit level is shown in fig .",
    "[ fig : flow ] .",
    "the stabiliser @xmath8 of four module qubits equals the product of all physical - qubit stabilisers @xmath8 within the x module . to measure the x",
    "- stabiliser of four module qubits , firstly data qubits in the the corresponding x module are all initialised in the state @xmath11 ; secondly physical - qubit stabiliser measurements across the x module and measured q modules ( see fig .  [",
    "fig : flowii ] ) are performed for several rounds ; finally all data qubits in the x module are measured in the @xmath12 basis ( see fig .  [",
    "fig : flow ] ) .",
    "the module - qubit z - stabiliser measurement is analogous . between each set of module - qubit stabiliser measurements ,",
    "physical - qubit stabiliser measurements are performed on only q modules for several rounds .",
    "commensurate with our two - tier encoding , the error correction includes two tiers . in the first tier the outcomes of physical - qubit stabiliser measurements are used to correct errors on the physical - qubit level . as we describe below",
    ", this process can exploit the highly inhomogeneous nature of the physical errors i.e.  the high error density at the border of each module s ` patch ' of surface code .",
    "once this step is complete , only sequences of errors ( error chains ) that span entire module qubits can survive . for q modules , such an error is a bit or phase flip of that specific module qubit . for the x and z modules ,",
    "whose role is to provide stabiliser measurement on the surrounding four q modules , the consequence of such an error chain is that the stabiliser outcome is incorrectly evaluated ( i.e.  it is the inverse of the correct outcome ) .",
    "both types of errors are handled in the second tier of the process , where one simply regards each q module as a data qubit , and errors on these qubits are determined by analysis of the imperfect stabiliser measurements in the standard way ( regardless of the fact that those measurements derive from entire x and z modules ) .    ) for modules with different dimensions @xmath4 . here",
    "@xmath24 is the fidelity _ subsequent _ to any purification within broker units , so that we are seeing the corrective power of the hierarchical surface code alone . for context",
    ", thresholds for simple modules are marked with the empty circle and square on the left vertical axis .",
    "we have assumed that entanglement errors are unpolarised , i.e.  @xmath25 , and all intra - module operations have the same error rate @xmath26 .",
    "these thresholds are obtained by counting errors on logical qubits encoded in @xmath27 module arrays ( see appendix  [ sec : appthreshold ] for details ) .",
    "the inset shows logical error rates for @xmath28 and @xmath29 . with an entanglement error rate",
    "lower than the threshold ( the dotted line in the inset ) , the logical error rate decreases with @xmath30 ( the left side of the threshold in the inset ) .",
    "the dashed line denotes inferred thresholds according to the difference ( which is @xmath31 ) between two solid lines . ]    to understand how the inhomogeneity in the distribution of errors is exploited , consider first the artificial case that intra - module operations are perfect ( i.e.  @xmath32 ) .",
    "then all errors are due to imperfectly - purified inter - module entanglement , and so errors occur strictly on perimeters of client arrays ( bold lines in fig .",
    "[ fig : code ] ) . during x - stabiliser measurements of module qubits , in a q module bit errors and stabiliser - measurement errors occur with the rate @xmath33 on the two boundaries facing x modules ( red bold lines ) , and in an x module phase errors and stabiliser - measurement errors occur with the rate @xmath34 on the entire perimeter ( black bold lines ) .",
    "we note that on the corner of x modules , error rates are approximately doubled .",
    "it is similar for z - stabiliser measurements of module qubits . here , @xmath35 are error rates in the inter - module entanglement _",
    "after _ any purification has taken place .",
    "errors are restricted to the one - dimensional perimeter of modules , but the correction process involves @xmath14 rounds and therefore the syndrome matching occurs in a two - dimensional space : one spatial and one temporal .",
    "this is in contrast to a standard surface code approach with homogeneous errors in gates and measurements , where we would need to match syndrome outcomes in a three - dimensional array .",
    "there is a very significant advantage in terms of the threshold : whereas the 3d threshold is in the region of @xmath36 , for the restricted 2d case it is @xmath37  @xcite .",
    "therefore , if entanglement error rates satisfy @xmath38 , we are below threshold and thus the rates of module - qubit errors after the first step of error correction decrease with the dimension of modules ( i.e.  size of two - dimensional error - correction lattices ) . moreover ,",
    "if indeed the module - qubit error rates decrease with the module dimension , then the threshold for errors in the inter - module entanglement increases with the module dimension . in the limit of large modules ,",
    "the threshold of entanglement error rate should approach @xmath2 for depolarising errors , i.e.  @xmath25 .",
    "if we now allow for a small but finite rate of errors for intra - module operations and measurements , the proceeding remarks all apply except that occasional errors will occur within the perimeter of the ` patches ' with the consequence that the tolerance of noise on the inter - module links will be somewhat reduced .        in fig .",
    "[ fig : threshold ] we show the results of a series of numerical simulations which verify this analysis .",
    "the figure shows the fault tolerance threshold for the rate of errors on the inter - module entanglement , assuming that ( purified ) entanglement errors are uniform over the @xmath13 , @xmath39 and @xmath12 channels .",
    "note that this is not a favourable assumption : if the errors were not uniform , this would be an opportunity to enhance the threshold by exploiting this knowledge in the decoder .",
    "the numerical results reveal that the threshold indeed increases with the module dimension , which coincides with expectations from the preceding analysis . for comparison",
    "we also find thresholds for simple modules , i.e.  each module only contains one client qubit as so we do not use the hierarchical approach .",
    "the observed thresholds vary from @xmath40 to @xmath41 depending on the size of modules .",
    "when we allow for errors induced by intra - module operations , the ability to correct errors on the inter - module operations is reduced as expected , i.e.  the threshold rate of tolerable inter - module errors decreases with the error rate of intra - module operations . taking all intra - module operations to have the same error rate @xmath42",
    ", we find that the threshold of entanglement error rate is reduced by @xmath43 .",
    "as shown in the figure , this reduction varies only very slightly with the module dimension .",
    "in the preceding analysis , we considered the structure of the hierarchical surface code and its threshold in terms of the rate of errors on inter - module entanglement ; the error rate was taken to be post - purification . now in order to find the optimal structure for a network architecture , we must consider the power and cost of the brokering units and optimise the number of qubits assigned to that role .",
    "we can then find the overall resource cost of fault tolerant computing given a specific error rate on the ` raw ' inter - module entanglement .    in a quantum computer based on the surface code ,",
    "the unit of quantum computing is a logical qubit encoded in a @xmath27 qubit ( module ) array , where the array distance @xmath30 is the minimum number of data qubits ( q modules ) for defining a logical pauli operator . given that operations are performed with an error rate lower than the system s threshold , the rate of logical errors decreases with the size of the logical qubit .",
    "the logical error rate per surface code cycle , i.e.  a full round of stabiliser measurements , scales with the distance @xmath30 as  @xcite @xmath44 where parameters @xmath45 and @xmath46 are determined by error rates of operations .    in our network architecture , qubits used for entanglement generation and purification do not participate forming logical qubits , i.e.  these qubits assigned to the ` broker units ' are an additional cost due to the modular architecture .",
    "it is non - trivial to optimise the partitioning of qubits between broker units and the internal client arrays , in such a way as to minimise the total number of qubits needed to achieve a given logical error rate .",
    "the size of logical qubits ( determined by parameters @xmath45 and @xmath46 ) depends on the inter - module entanglement error rate _ after _ purification , and this rate will improve as more qubits are dedicated to purification .    by numerically obtaining parameters @xmath45 and @xmath46",
    ", we can find the cost of physical qubits per logical qubit ( logical - qubit size ) .",
    "we have considered error rates of intra - module operations @xmath42 and two possible values for the error rate on the _ raw _ entanglement : @xmath47 and @xmath2 . the logical - qubit size for achieving the logical error rate @xmath48",
    "is shown in fig .",
    "[ fig : cost ] .",
    "the ` raw ' entanglement error rate @xmath47 is tenth of the theoretical threshold in the large module limit . for this small entanglement error rate",
    ", we expect that the purification is not necessary for large modules .",
    "however a raw entanglement error rate @xmath49 is more practical for current technologies .",
    "for such a large error rate , we see that entanglement purification is always necessary .",
    "in general , the qubit cost decreases with the size of modules ( total number of qubits in each module ) .",
    "when the size of modules approaches a thousand qubits , the qubit cost is about nine times higher than the cost on the monolithic architecture .",
    "we note that a factor of two is due to the two - tier encoding considered in this paper . in this encoding ,",
    "approximately half of modules ( i.e.  the x and z modules ) are ancillaries for stabiliser measurements . without the overhead cost due to x and z modules , and if physical - qubit stabiliser measurements are continuously performed across the whole module network , isolated two - dimensional error - correction lattices of entanglement errors merge into a single connected lattice . the error correction on the connected lattice , which is essentially three - dimensional , will be harder than the error correction on isolated lattices . however , this disadvantage may be tolerable for very large modules , in which case the overhead cost due to x and z modules may not be necessary",
    ". it would be interesting to perform an analysis of this case where modules are very large , exceeding the size required for storing logical qubits , in order to determine whether the hierarchical code introduced in this paper remains useful in that domain .    in our analysis",
    ", we contrasted the performance of a network of substantial modules with that of a network of small modules , each containing one data qubit of a simple surface code . in terms of the total number of physical qubits needed to achieve a given low error rate at the logical level ,",
    "our somewhat surprising conclusion was that simple modules are only marginally inferior to large modules containing nearly a thousand qubits . in this sense",
    ", our result is that _ the granularity of a network does not strongly influence the resource costs_. thus experimentalists are free to build systems with whatever module size suits their particular technologies without paying a significant penalty in total qubit count .",
    "however as a caveat we must remark that in our study we have assumed that physical qubits have a long memory time , so that memory errors are negligible on the timescale required to perform the entanglement purification ( see appendix  [ sec : apptime ] ) . if this is not the case , then a significant advantage for large modules could emerge because less purification tiers are necessary .",
    "an analysis of this scenario would open the way to a full audit of the time cost of network quantum computing , where the time needed for the multiple rounds of stabilisation in the hierarchical picture is contrasted with the time needed for deep purification circuits .",
    "in this paper , we have introduced a variant of the surface code approach to fault tolerant quantum information processing .",
    "our variant is intended to support the network paradigm for quantum computing : the machine is divided into many modules which are connected by noisy inter - links , and each module contains a plurality of well - controlled ( low noise ) qubits .",
    "our approach is a two - tier hierarchical surface code , where the lower tier involves assigning a ` patch ' of surface code to each physical module .",
    "errors then occur primarily at patch boundaries and this reduces the dimensionality of the syndrome matching task , thus boosting the threshold .",
    "we consider a general scenario where errors occurring on the inter - module links are first purified by broker units and then handled by the hierarchical code .",
    "both analytical reasoning and numerical results show that larger modules have advantages : the threshold is higher and the qubit cost is lower . however , the advantage in qubit cost is not significant enough to conclude that large modules are preferred platforms of quantum computing , taking into account the difficulty of building large modules . for small modules , we find that the size @xmath1 qubits per module is optimal for practical entanglement noise purification , and the total qubit cost per logical qubit is only fifteen times larger than the cost on a monolithic architecture .",
    "broadly our conclusion is that the granularity of a network - based quantum computer does not strongly affect the total resource costs , with the consequence that experimental efforts can target whatever module size is most convenient for the particular technology .",
    "this work was supported by the epsrc platform grant ` molecular quantum devices ' ( ep / j015067/1 ) , and the epsrc national quantum technology hub in networked quantum information processing .",
    "the authors would like to acknowledge the use of the university of oxford advanced research computing ( arc ) facility in carrying out this work .",
    "http://dx.doi.org/10.5281/zenodo.22558 .",
    "9    w. dr and h .- j .",
    "briegel , phys .",
    "* 90 * , 067901 ( 2003 ) .",
    "s. c. benjamin , d. e. browne , j. fitzsimons , and j. j. l. morton , new j. phys . * 8 * , 141 ( 2006 ) .",
    "e. t. campbell , phys .",
    "a * 76 * , 040302(r ) ( 2007 ) .",
    "l. jiang , j. m. taylor , a. s. srensen , and m. d. lukin , phys .",
    "a * 76 * , 062323 ( 2007 ) .",
    "s. c. benjamin , b. w. lovett , and j. m. smith , laser photon .",
    "rev . * 3 * , 556 ( 2009 ) .",
    "y. li and s. c. benjamin , new j. phys . * 14 * , 093008 ( 2012 ) .",
    "k. fujii , t. yamamoto , m. koashi , and n. imoto , arxiv:1202.6588 .",
    "c. monroe , r. raussendorf , a. ruthven , k. r. brown , p. maunz , l .- m .",
    "duan , and j. kim , phys .",
    "rev . a * 89 * , 022317 ( 2014 ) .",
    "t. p. harty , d. t. c. allcock , c. j. ballance , l. guidoni , h. a. janacek , n. m. linke , d. n. stacey , and d. m. lucas , phys .",
    "lett . * 113 * , 220501 ( 2014 ) .    c. j. ballance , t. p. harty , n. m. linke and d. m. lucas , arxiv:1406.5473 .",
    "h. bernien , b. hensen , w. pfaff , g. koolstra , m. s. blok , l. robledo , t. h. taminiau , m. markham , d. j. twitchen , l. childress , and r. hanson , nature * 497 * , 86 ( 2013 ) .",
    "n. roch , m. e. schwartz , f. motzoi , c. macklin , r. vijay , a. w. eddins , a. n. korotkov , k. b. whaley , m. sarovar , and i. siddiqi , phys .",
    "* 112 * , 170501 ( 2014 ) .",
    "d. l. moehring , p. maunz , s. olmschenk , k. c. younge , d. n. matsukevich , l .- m .",
    "duan , and c. monroe , nature * 449 * , 68 ( 2007 ) .",
    "d. hucul , i. v. inlek , g. vittorini , c. crocker , s. debnath , s. m. clark and c. monroe , nature phys . * 11 * , 37 ( 2015 ) .    k. r. brown , a. c. wilson , y. colombe , c. ospelkaus , a. m. meier , e. knill , d. leibfried , and d. j. wineland , phys .",
    "rev . a * 84 * , 030303(r ) ( 2011 ) .",
    "r. barends , j. kelly , a. megrant , a. veitia , d. sank , e. jeffrey , t. c. white , j. mutus , a. g. fowler , b. campbell , y. chen , z. chen , b. chiaro , a. dunsworth , c. neill , p. omalley , p. roushan , a. vainsencher , j. wenner , a. n. korotkov , a. n. cleland , and john m. martinis , nature * 508 * , 500 ( 2014 ) .",
    "a. kitaev , annals phys .",
    "* 303 * , 2 ( 2003 ) .",
    "e. dennis , a. kitaev , a. landahl , and j. preskill , j. math .",
    "phys . * 43 * , 4452 ( 2002 ) .",
    "n. h. nickerson , y. li , and s. c. benjamin , nat .",
    "commun . * 4 * , 1756 ( 2013 ) .",
    "n. h. nickerson , j. f. fitzsimons , and s. c. benjamin , phys .",
    "x * 4 * , 041041 ( 2014 ) .",
    "j. eisert , k. jacobs , p. papadopoulos , and m. b. plenio , phys . rev .",
    "a * 62 * , 052317 ( 2000 ) .",
    "a. g. fowler , a. m. stephens , and p. groszkowski , phys .",
    "a * 80 * , 052312 ( 2009 ) .",
    "r. raussendorf and j. harrington , phys .",
    "lett . * 98 * , 190504 ( 2007 ) .",
    "a. g. fowler , m. mariantoni , j. m. martinis , and a. n. cleland , phys .",
    "a * 86 * , 032324 ( 2012 ) .",
    "v. kolmogorov , in mathematical programming computation * 1 * , 43 ( 2009 ) .    d. s. wang , a. g. fowler , and l. c. l. hollenberg , phys . rev . a * 83",
    "* , 020302(r ) ( 2011 ) .",
    "circuits for performing the distributed cnot gate , entanglement purifications and stabiliser measurements , are shown in fig .  [",
    "fig : circuit ] .     and @xmath50 depending on measurement outcomes .",
    "( b ) and ( c ) if the ideal entangled state is in the form @xmath51 , the output entanglement is discarded if two measurement outcomes are different . in the bit - error purification ,",
    "the bit - error rate is reduced from @xmath52 for input entanglement to @xmath53 for the post - selected output entanglement , but the phase - error rate is increased from @xmath54 to @xmath55 .",
    "it is similar for the phase - error purification .",
    "( d ) and ( e ) each full round of stabiliser measurements involves both x - stabiliser measurements and z - stabiliser measurements .",
    "labels of data qubits ( see fig .  [",
    "fig : code ] ) indicate the sequence of cnot gates ( cnot gates with the same orientation are performed in parallel ) . ]",
    "the layout of module - qubit stabiliser measurements is shown in fig .",
    "[ fig : flowii ] .",
    "logical - qubit error rates are obtained using the monte carlo method by simulating errors occurring on a logical qubit encoded in a @xmath27 module array during @xmath30 rounds of module - qubit stabiliser measurements .",
    "we have used the edmonds s minimum weight matching algorithm  @xcite in the surface - code error correction . in our simulations",
    ", we have set @xmath56 ( see fig .  [",
    "fig : flow ] ) . for simple modules ,",
    "the error correction is directly performed on a conventional surface code error correction lattice . for large modules ( @xmath57 ) , the error correction has two steps .",
    "firstly , physical - qubit errors are corrected on the error correction lattice shown in fig .",
    "[ fig : lattice](a ) , which is a three - dimensional lattice formed by cubes with the side length @xmath58 . after the first step , there are only module - qubit errors left , which are further corrected on a conventional surface code error correction lattice representing the array of module qubits .        when intra - module operations are ideal , i.e.  @xmath59 ( see fig .  [",
    "fig : threshold ] ) , errors ( due to entanglement errors ) only occur on boundaries of connected cubes [ see fig .",
    "[ fig : lattice](a ) ] .",
    "these boundary surfaces are separated , hence errors on each boundary surface can be individually corrected and simulated . by simulating errors on the surface of a x - module cube [ black surface of the red cube in fig .",
    "[ fig : lattice](a ) ] , we can find the rate @xmath60 of measurement errors of module - qubit x stabilisers ( measurement errors after the physical - qubit error correction ) . by simulating errors on the surface of a q - module cube connected with a z - module cube [ black surface of the purple cube in fig .",
    "[ fig : lattice](a ) ] , we can find the rate @xmath61 of module - qubit phase errors during one round of module - qubit stabiliser measurements .",
    "it is similar for measurement errors of module - qubit z stabilisers and module - qubit bit errors . with error rates",
    "@xmath60 and @xmath61 , we can simulate module - qubit errors on the conventional surface code error correction lattice to find the rate of logical - qubit errors .     and the rate of module - qubit phase errors @xmath61 are obtained with individual cubes ( black solid marks ) and triple - size lattices ( red empty marks ) .",
    "we have assumed that the ( purified ) entanglement fidelity @xmath62 , entanglement errors are unpolarised , i.e.  @xmath25 , and all intra - module operations have the same error rate @xmath42 . ]    when intra - module operations are not ideal , e.g.  @xmath63 ( see fig .  [",
    "fig : threshold ] ) , errors are not restricted to boundary surfaces . in this case , the first step of the error correction ( correcting physical - qubit errors ) must be performed on the entire lattice [ see fig .  [",
    "fig : lattice](a ) ] .",
    "however , for large modules ( @xmath57 ) , the entire lattice is too large to be directly simulated .",
    "therefore , we individually simulate errors in each cube to approximately calculate the rate of module - qubit errors .",
    "we note that , when intra - module operations are not ideal , module - qubit errors also occur when module qubits are stabilised ( corresponding to q - module cubes without contact with x - module or z - module cubes ) , which must be taken into account . because we are interested in the case that intra - module operations have the error rate @xmath63 , which is much smaller than @xmath36 the error - rate threshold for intra - module operations  @xcite , probabilities of error chains ( after the physical - qubit error correction ) decrease rapidly with their lengths .",
    "therefore , by simulating cubes individually , only the effect of errors ( induced by intra - module operations ) near boundary surfaces are approximately considered . in fig .",
    "[ fig : triple ] , we compare module - qubit error rates obtained with individual cubes and error rates obtained on triple - size lattices [ see fig .  [",
    "fig : lattice](b ) ] .",
    "each triple - size lattice has the dimension @xmath64 , in which the boundary effect has been sufficiently considered . even in the case of the smallest cube ( @xmath5 ) , neglecting the boundary effect only slightly changes error rates of module qubits .",
    "and @xmath46 for entanglement error rates @xmath65 [ ( a ) and ( c ) ] and @xmath2 [ ( b ) and ( d ) ] .",
    "marks consist with fig .",
    "[ fig : cost ] . for simple modules ,",
    "the module dimension is always @xmath66 , and the number of purification tiers increases form left to right . ]",
    "the qubit cost is calculated with parameters @xmath45 and @xmath46 . for a given logical error rate @xmath67",
    ", one can find the minimum @xmath30 satisfying @xmath68 .",
    "this minimum @xmath30 determines the size of the logical qubit .",
    "the total number of qubits in each logical qubit is @xmath69 , where @xmath70 is the number of qubits in each module ( module size ) .",
    "parameters @xmath45 and @xmath46 are shown in fig .",
    "[ fig : parameters ] . for simple modules , parameters @xmath45 and @xmath46 are obtained by directly fitting logical qubit error rates for @xmath29 with the function @xmath71 for large modules with @xmath57 , because module - qubit error rates are very small , it is hard to directly find logical - qubit error rates in simulations .",
    "therefore , we firstly obtain the module - qubit error rates @xmath72 , and then we find logical - qubit error rates for module - qubit error rates @xmath73 . here , the ratio @xmath74 is chosen so that @xmath73 are large enough for simulating logical - qubit error rates ( not far below the threshold ) .",
    "then , we fit logical - qubit error rates for @xmath29 with the function  @xcite @xmath75 with fitting parameters @xmath76 , @xmath77 and @xmath78 , we can obtain parameters @xmath79 and @xmath80 .",
    "in our simulations , we have considered the purification protocol proposed in ref .",
    "@xcite , in which phase errors and bit errors are corrected alternatively , i.e.  in each tier of the purification either only phases errors or only bit errors are corrected .",
    "circuits for bit - error purification and phase - error purification are shown in fig .",
    "[ fig : circuit ]  ( b )  and  ( c ) . the overall purification protocol is shown in fig .",
    "[ fig : purification ] .",
    "note that in our simulations , for distributed cnot gates involving an x ( z ) ancillary qubits , phase ( bit ) errors are corrected in the first tier .     &",
    "+ @xmath81 & @xmath82 & @xmath81 & @xmath82 + @xmath83 & @xmath84 & @xmath83 & @xmath84 + @xmath84 & @xmath85 & @xmath84 & @xmath85 + @xmath86 & @xmath87 & @xmath86 & @xmath88 + @xmath89 & @xmath90 & @xmath89 & @xmath91 + @xmath85 & @xmath92 & @xmath85 & @xmath93 + @xmath94 & @xmath95 & @xmath94 & @xmath96 + @xmath97 & @xmath98 & @xmath97 & @xmath99 + @xmath100 & @xmath101 & @xmath100 & @xmath102 + @xmath87 & @xmath103 & @xmath87 & @xmath104 +     & + @xmath81 & @xmath82 & @xmath81 & @xmath82 + @xmath83 & @xmath84 & @xmath83 & @xmath84 + @xmath84 & @xmath97 & @xmath84 & @xmath105 + @xmath86 & @xmath106 & @xmath86 & @xmath107 + @xmath89 & @xmath92 & @xmath89 & @xmath108 + @xmath85 & @xmath109 & @xmath85 & @xmath110 + @xmath94 & @xmath111 & @xmath94 & @xmath112 + @xmath97 & @xmath113 & @xmath97 & @xmath114 + @xmath100 & @xmath115 & @xmath100 & @xmath116 + @xmath87 & @xmath117 & @xmath87 & @xmath118 +    if the time cost of generating raw inter - module entanglement is much higher than the time cost of intra - module operations , the time cost of one round of module - qubit stabiliser measurements is @xmath119 , where half of the @xmath120 rounds of physical - qubit stabiliser measurements ( see fig .  [",
    "fig : flow ] ) need inter - module entanglement , @xmath82 is the number of raw entanglement pairs for preparing one pair of purified entanglement ( see table  [ tab : number ] ) , and @xmath121 is the time cost of preparing one pair of raw entanglement .",
    "we note that we have taken @xmath56 in our simulations . for simple modules , if each module has only one broker , the time cost is amplified by a factor of @xmath86 .",
    "the overall time cost of the computing , i.e.  the total rounds of module - qubit stabiliser measurements , depends on the algorithm , which beyond the scope of this paper ."
  ],
  "abstract_text": [
    "<S> the network paradigm for quantum computing involves interconnecting many modules to form a scalable machine . </S>",
    "<S> typically it is assumed that the links between modules are prone to noise while operations within modules have significantly higher fidelity . to optimise fault tolerance in such architectures </S>",
    "<S> we introduce a hierarchical generalisation of the surface code : a small ` patch ' of the code exists within each module , and constitutes a single effective qubit of the logic - level surface code . </S>",
    "<S> errors primarily occur in a two - dimensional subspace , i.e.  patch perimeters extruded over time , and the resulting noise threshold for inter - module links can exceed @xmath0 even in the absence of purification . increasing the number of qubits within each module decreases the number of qubits necessary for encoding a logical qubit . but this advantage is relatively modest , and broadly speaking a ` fine grained ' network of small modules containing only @xmath1 qubits is competitive in _ total _ qubit count versus a ` course ' network with modules containing many hundreds of qubits . </S>"
  ]
}