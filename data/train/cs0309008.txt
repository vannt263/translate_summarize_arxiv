{
  "article_text": [
    "while automatic verification methods ( s.a . model checking , etc . ) permit quite accurate formulation of rules describing concurrent systems , the coverage problem is still open .",
    "this problem can be stated as ones ability to know that a certain set of rules covers all possible behaviors of the system and if so , whether this set is optimal , in the sense that it does not contain redundancies .",
    "+ this problem , besides being a very challenging research problem , also plays a crucial role in industrial implementation of verification methods , in aspects of manpower , time and , ( of course , finance . + while different methods to attack this problem where proposed ( see @xcite , @xcite , @xcite ) , it is still largely open .",
    "+ in this paper we present a novel scheme to the _ coverage problem _ , introducing a quantitative way to estimate the interaction between a block an its environment .",
    "this is achieved by setting a discrete version of green s theorem , specially adapted for model checking based verification . +",
    "this work was inspired by the well known principle of model checking that a well written environment dictates the formulation of the system s rules ; indeed the rules governing the system and the description of its physical proprieties should be regarded as almost mirror images of each other . on a more theoretical level , resides the idea of viewing a flow of information in an analogous way to the electromagnetic ( or energy ) flow and the computation of its mean flux , i.e. pressure .",
    "the main idea behind the results presented herein is the adaptation of the symmetry principle to the flow setting , adaptation which states that the mean pressure of information is constant , ( i.e. the informational system is in dynamic equilibrium ) . +",
    "this method is best suited for the coverage problem since it enables one to quantify the incompleteness or , on the other hand , the redundancy of a set of rules , describing the model under verification .",
    "moreover this can be done continuously throughout the verification process , thus enabling the user to pinpoint the stages at which incompleteness / redundancy occurs .",
    "the method we present here does not permit the complete automation of the coverage - checking process ( thus making the verifier s role redundant ) , since it does nt guarantee completeness of coverage , but only that inconsistencies or redundancies are discovered .",
    "thus it is yet another instrument in the arsenal of the experienced verifier , and one that is extremely easily to use without any further specialization .",
    "moreover , it can be readily added as supplementary feature , to any existing industrial machine .",
    "+ the paper is organized as follows : in section 2 we give the basic preliminaries and show how to formulate green s theorem in the context of pressure of information . in this section this is done in a basic , local setting of individual blocks composing a system ( i.e. silicone `` chip '' ) . in section 3",
    "we compare this method to the one presented in @xcite , by applying it to the same test - cases presented therein . in section 4",
    "we show how this method naturally extends globally to large scale units and can be implemented up to the level of integrated circuits .",
    "this extending ability enables one to get the most out of this method , since it makes it possible to unify all stages of the development , from the architect , through the designer , to the verifier .",
    "moreover , this method relieves the verifier from the need of unnecessary presumption that the verification of a neighboring unit has been done correctly ; instead it gives verifying tools to easily quantify this correctness .",
    "finally , in section 5 we gives outlines for future research .",
    "in this section we give the basic background and notations . a brief discussion on green s theorem is given in the appendix .",
    "a _ block _ @xmath0 is a punctured topological disk @xmath1 ; where @xmath2 denotes the closed unit disk @xmath3 .",
    "+ the _ environment _ of a block @xmath0 , @xmath4 is the complement of @xmath5 .",
    "a block and its environment share a common boundary and communicate with each other via _ input / output _ messages .",
    "an _ information unit _ is a _ signal _ @xmath6 that may have the values @xmath7 . + a _ message _ is a pair @xmath8 , where @xmath9 is the unit normal vector pointing outward form the block , toward @xmath4 , and @xmath10 is a set of information units .",
    "+ an _ input _ is a message of the form : @xmath11 ; while an _ output _ is a message of the form : @xmath12 .",
    "the punctures also connect with the block via sending / recieving messages where the directions are @xmath13 with respect to the boundary of a small disk neighborhood of a puncture point .",
    "a puncture will be called a _ sink _ if all its messages are _ outputs _ , and a _ source _ if all its messages are _ inputs _ ( where the orientations of the normal vectors are considered with respect to the block @xmath0 ) .",
    "we refer mainly to typical punctures of sink or source types , but of course , `` mixed '' punctures are also possible ( therefore they are to be considered ) .",
    "[ eq : exmp]the block illustrated in fig.1 has ",
    "relatively ) to the outer boundary  an input message : @xmath14 and output message @xmath15 .",
    "it also has a puncture @xmath16 of type source ; its messages being : @xmath17 and @xmath18 .",
    "+ it should be noted that a message is appears only if its signals are _ asserted _ , i.e. as unit signals ; that is we identify @xmath15 with the vector @xmath19 ( or @xmath20 ) .",
    "@xmath21      for each message ( i.e. input , output , sink / source ) we define a _ measure _ @xmath22  the _ information pressure _",
    " according to : @xmath23    again , we allow the existence of `` mixed '' punctures . in this case",
    "the measure associated which such a puncture is the arithmetic sum of its signals , considered with sign `` @xmath24 '' if they relate to a output , and with a `` @xmath25 '' if they correspond to an input .",
    "consider the puncture @xmath26 with messages : @xmath27 . then : @xmath28 .    with these notations we are in a position to formulate green s theorem for blocks :    [ thm : thm ]",
    "let @xmath0 be a block of(with ) outputs @xmath29 , inputs @xmath30 and sink / sources @xmath31 , where @xmath32 denotes the set of punctures of the block @xmath0 .",
    "then the following holds : @xmath33    given a block @xmath0 , every input / output signal is uniquely identified with a point on the boundary @xmath34 with a length element given by the measure @xmath22 of the signal .",
    "since overall - time information is conserved , applying grenn s formula on such a block gives : @xmath35    the following simple rule relative to the block of example [ eq : exmp ] illustrates the method of implementing formula  [ eq : thm ] : @xmath36 since @xmath37 and @xmath38 are outputs , they both contribute with a `` @xmath39 '' , while @xmath40 , being an input , adds a `` @xmath41 '' to the general balance , so the measure _ variance _ associated to the rule @xmath42 is @xmath43 .",
    "note that - as stated before - we count only the asserted signals .",
    "+ we shall show in _ section 3 _ how to add the variances of individual rules in order to get the _",
    "global variance _ @xmath44 .",
    "formula  [ eq : thm ] should be understood as a qualitative indicator for the coverage of a given set of rules , hence this set is assumed to satisfy the following postulates :    1 .",
    "every input / output appears _ at least _ once in the set of rules , otherwise one could have , for instance the following set of rules , which consists of only one formula : @xmath45 which satisfies  [ eq : thm ] , but evidently will not represent a complete set of rules for a realistic arbiter .",
    "if a set of rules does not satisfy  [ eq : thm ] , it is guaranteed to be either incomplete or to have redundancies . on the other hand",
    ", sets of rules may satisfy  [ eq : thm ] , but still be inconsistent , such as the following : @xmath46 indeed , if `` ack '' is - as it normally does - a `` pulse '' signal , then @xmath47 and @xmath48 will not be always satisfied in tandem by any normal system .",
    "+ also , the following system contains a redundant rule : @xmath49 since if @xmath47 holds , then @xmath50 is obviously redundant .",
    "however it still obviously satisfies  [ eq : thm ] , so a direct application of theorem  [ thm : thm ] will not reveal this fact .",
    "+ therefore , it is imperative that the formalist satisfies the following : +   +  the set of rules consists only of relevant rules and does not contain deliberate redundancies .",
    "although , as shown in the previous note , the given method does not give a completely automatic tool to solve the _ coverage problem _ , it gives the user , especially the skilled verifier , a numerical assessment of the block s complexity .",
    "two important conclusions ensue from this : + on one hand , a well formulated set of rules enables one to actually compute the complexity of the internal structure of the block , as this is expressed by the pressures contributed by the punctures , thus allowing a paradigm shift from the _ black - box _ concept to that of _ semi - transparent _ blocks .",
    "+ on the other hand , it gives the verifier of neighboring blocks a computational tool for checking relative correctness along the common interface .",
    "this advantage becomes even more effective in pipelining units , for which the boundary interface is the simplest possible .",
    "this work was partially motivated by the work of katz , grumberg and geist ( see @xcite ) .",
    "we will demonstrate the application of  [ eq : thm ] to the examples given in the paper mentioned above , and compare the results obtained and the efficiency of both methods .",
    "+ their main example consists of a synchronous arbiter @xmath51 having two inputs : @xmath52 and @xmath53 and two outputs : @xmath54 and @xmath55 ( see fig .",
    "2 ) .         +",
    "this arbiter s behavior is ( cf .",
    "@xcite ) is described by the following _ complete _ set of rules that contains _ no redundancies _ :",
    "@xmath56 & \\qquad \\rho_1 \\\\ { \\bf ag}\\,[({\\tt req1 } \\wedge   \\neg{\\tt req2 } ) \\rightarrow { \\bf ax}{\\tt ack1 } ] & \\qquad \\rho_2 \\\\ { \\bf ag}\\,(\\neg{\\tt req1 } \\wedge { \\tt req2 } ) \\rightarrow { \\bf ax}{\\tt ack2 } ] & \\qquad \\rho_3 \\\\ { \\bf ag}\\,[({\\tt req1 } \\wedge { \\tt ack2 } ) \\rightarrow { \\bf ax}{\\tt ack1 } ] & \\qquad \\rho_4 \\\\ { \\bf ag}\\,[({\\tt req2 } \\wedge { \\tt ack1 } ) \\rightarrow { \\bf ax}{\\tt ack2 } ] & \\qquad \\rho_5 \\\\ { \\bf a}\\,[(\\neg{\\tt req1 } \\vee \\neg{\\tt req2 }   \\vee { \\tt ack1 } \\vee { \\tt ack2}){\\bf w } ( { \\tt req1 } \\wedge { \\tt req2 } \\wedge \\neg{\\tt ack1 }   \\wedge \\neg{\\tt ack2 } \\wedge { \\bf ax}{\\tt ack1 } ) ] & \\qquad \\rho_6 \\\\   ( { \\tt req1}\\wedge { \\tt req2 } \\wedge \\neg{\\tt ack1 }   \\wedge \\neg{\\tt ack2 } ) \\rightarrow { \\bf ax}[{\\tt ack1}\\rightarrow \\\\ { \\bf a}\\,[(\\neg{\\tt req1 } \\vee \\neg{\\tt req2 }   \\vee { \\tt ack1 } \\vee { \\tt ack2}){\\bf w }   ( { \\tt req1 } \\wedge { \\tt req2 } \\wedge \\neg{\\tt ack1 }   \\wedge \\neg{\\tt ack2 } \\wedge { \\bf ax}{\\tt ack2 } ) ] ] & \\qquad \\rho_7 \\\\   ( { \\tt req1}\\wedge { \\tt req2 } \\wedge \\neg{\\tt ack1 }   \\wedge \\neg{\\tt ack2 } ) \\rightarrow { \\bf ax}[{\\tt ack2 } \\rightarrow \\\\ { \\bf a}\\,[(\\neg{\\tt req1 } \\vee \\neg{\\tt req2 }   \\vee { \\tt ack1 } \\vee { \\tt ack2}){\\bf w }   ( { \\tt req1 } \\wedge { \\tt req2 } \\wedge \\neg{\\tt ack1 }   \\wedge \\neg{\\tt ack2 } \\wedge { \\bf ax}{\\tt ack1 } ) ] ] & \\qquad \\rho_8 \\\\ \\end{array } \\right.\\ ] ] the computation of the variances for the rules above is summarized in the table bellow :    [ cols=\"^,^,^,^,^,^ \" , ]     then @xmath57 . that is : @xmath58 thus , in order for  [ eq : thm ] to hold , the arbiter also must have a puncture , responsible resulting from the logical complexity of the block .",
    "+ indeed , expressed in the @xmath59 language , the inner structure of the arbiter is given ( again cf .",
    "@xcite ) by : @xmath60 therefore , a more realistic representation of the arbiter would be given by fig.4 :        since `` robin '' is asserted iff `` ack1 '' or `` ack2 '' are asserted , the signal `` robin '' will appear three times and , since it is emitted by the puncture towards the arbiter , its sign will be `` - '' .",
    "thus @xmath61 , as required and , indeed , the fact that the system @xmath62 is complete and contains no redundancies is expressed by the fact that the variance we have found ( @xmath63 = 3 ) exactly balances with the contribution of the internal logic due to the `` robin '' puncture . + we further test our method by applying it on the same variations of the main example as considered in @xcite and concisely comparing the results .",
    "+ the first variation is produced by replacing rule @xmath64 by @xmath65 , thus considering the modified system @xmath66 , and also modifying the internal structure of the arbiter by inserting the new lines bellow : ( here and in the following examples the new / modified rules appear in bold characters . ) @xmath67 & \\qquad \\rho_1 \\\\ { \\bf ag}\\,[({\\tt req1 } \\wedge   \\neg{\\tt req2 } ) \\rightarrow { \\bf ax}{\\tt ack1 } ] & \\qquad \\rho_2 \\\\ { \\bf ag}\\,(\\neg{\\tt req1 } \\wedge { \\tt req2 } ) \\rightarrow { \\bf ax}{\\tt ack2 } ] & \\qquad \\rho_3 \\\\ { \\bf ag}\\,[({\\tt req1 } \\wedge { \\tt ack2 } ) \\rightarrow { \\bf ax}({\\tt ack1 \\vee ack2 } ) ] & \\qquad \\huge{\\mathbf{\\rho_4 ' } } \\\\ { \\bf ag}\\,[({\\tt req2 } \\wedge { \\tt ack1 } ) \\rightarrow { \\bf ax}{\\tt ack2 } ] & \\qquad \\rho_5 \\\\ { \\bf a}\\,[(\\neg{\\tt req1 } \\vee \\neg{\\tt req2 }   \\vee { \\tt ack1 } \\vee { \\tt ack2}){\\bf w } ( { \\tt req1 } \\wedge { \\tt req2 } \\wedge \\neg{\\tt ack1 }   \\wedge \\neg{\\tt ack2 } \\wedge { \\bf ax}{\\tt ack1 } ) ] & \\qquad \\rho_6 \\\\   ( { \\tt req1}\\wedge { \\tt req2 } \\wedge \\neg{\\tt ack1 }   \\wedge \\neg{\\tt ack2 } ) \\rightarrow { \\bf ax}[{\\tt ack1}\\rightarrow \\\\ { \\bf a}\\,[(\\neg{\\tt req1 } \\vee \\neg{\\tt req2 }   \\vee { \\tt ack1 } \\vee { \\tt ack2}){\\bf w }   ( { \\tt req1 } \\wedge { \\tt req2 } \\wedge \\neg{\\tt ack1 }   \\wedge \\neg{\\tt ack2 } \\wedge { \\bf ax}{\\tt ack2 } ) ] ] & \\qquad \\rho_7 \\\\   ( { \\tt req1}\\wedge { \\tt req2 } \\wedge \\neg{\\tt ack1 }   \\wedge \\neg{\\tt ack2 } ) \\rightarrow { \\bf ax}[{\\tt ack2 } \\rightarrow \\\\ { \\bf a}\\,[(\\neg{\\tt req1 } \\vee \\neg{\\tt req2 }   \\vee { \\tt ack1 } \\vee { \\tt ack2}){\\bf w }   ( { \\tt req1 } \\wedge { \\tt req2 } \\wedge \\neg{\\tt ack1 }   \\wedge \\neg{\\tt ack2 } \\wedge { \\bf ax}{\\tt ack1 } ) ] ] & \\qquad \\rho_8 \\\\ \\end{array } \\right.\\ ] ] @xmath68 these changes produce a positive overall variance @xmath69 ; thus indicating the unbalance introduced due to redundancy the system of laws fitting , to the `` _ unimplemented transition evidence _ ''",
    "considered in @xcite ) .",
    "the next example relates to the so called `` _ unimplemented state evidence _ '' of @xcite .",
    "it is produced by introducing an internal auxiliary variable of `` input '' type , thus augumenting the internal complexity of the arbiter , in a way that can not be detected and balanced by the rules . in this case",
    "the modifications bellow indeed generate a negative @xmath70 , as expected .",
    "@xmath71 + finally , we consider the modification bellow : @xmath72 since it is basically produced by multiplying the true original signals , the resulting @xmath73 is a indeed a multiple of the original ( corresponding to the `` _ many to one _ '' ( cf .",
    "@xcite ) .    while the existence of punctures is remarked in @xcite ( the so - called `` _ non - observable implementation variables _ '' ) , the approach described in the mentioned article can not detect them .",
    "this emphasizes one of the strengths of the method proposed here : it not only detects the above mentioned punctures , but it also estimates them numerically .",
    "since the coverage problem is more crucial in large scale systems , i.e. for units composed of several blocks , it is natural to try to extend the method presented here to such systems as well .",
    "+ this is possible in the same way that green s theorem extends from simply - connected regions to multiply connected regions . in this manner we obtain the following :    let @xmath74 be a unit with bounded environment components @xmath75 , each of which corresponds to some block component of @xmath74 . for each @xmath75 let @xmath76 denote the difference @xmath77 .",
    "+ then @xmath74 satisfies : @xmath78 where @xmath79 are the information measures of @xmath74 w.r.t . its external environment component . in short ,",
    "if we denote @xmath80 , then the following holds : @xmath81    the example described in fig .",
    "5 represents schematically the control unit of a _ a bus interface unit _",
    "@xcite ) and its component blocks .    ) ]    then @xmath82    given the technique above , it is evident how to proceed `` upward '' for larger and larger units : we consider an integrated circuit @xmath83 as top level @xmath84 , its composing units as the first level @xmath85 , their structural subunits as the 2-nd level @xmath86 , and so on , where , at the `` @xmath87''-th level `` @xmath88 '' denote the elementary blocks , so eventually we have the following generalization of theorem  [ thm : thm ] :    @xmath89    the example presented in fig .",
    "6 shows a _ a bus interface unit _",
    "the whole processor @xmath83 is designated as level 0(@xmath90 ) , the @xmath91 @xmath92 being one of he components of level 1(@xmath93 ) .",
    "the drawing(scheme ) also shows the building blocks of @xmath92 , which belong to level 2(@xmath94 ) .    ) ]    theorem 4.3 . gives the verifier the ability to encompass a global estimate viewpoint of the complexity of a large system , `` from top to bottom '' , as the formula can be readily used at the architectural stage , through the design faze , down to the verification stage where . at each stage",
    "the more complex units are being characterized by having large pressure contributions . thus permitting the immediate extension of model checking methods to very large scale systems in a manner which is point - wise precise .",
    "since punctures , blocks , units , etc . , display the same arithmetic behavior , it is only natural to regard each component at any given level as a puncture of the unit of the component containing it and which belongs to next upper level",
    ". therefore it appears that the appropriate and promising way to study the intrinsic nature of integrated circuits would be by means of networks and graph theory .",
    "such study is currently in progress .",
    "* ( green ) * let @xmath95 be an open set in the plane and let @xmath96 continuously differentiable functions .",
    "let @xmath97 be a piecewise smooth simple , closed curve , and let @xmath98 ( i.e. @xmath99 ) .",
    "+ then :      in vectorial notation ( 6.1 ) has the following form : @xmath101 where @xmath102 , @xmath103 is the _ divergence _ of the vector field @xmath104 , @xmath105 is the unit outer normal to @xmath106 , and @xmath107 represents the length element of @xmath106 .",
    "+ the classical interpretation of ( 6.2 ) above is the following : @xmath104 represents the _ flux density _ of an incompressible fluid , then @xmath108 measures the amount of mass transported away from each point per time unit .",
    "this quantity differs from zero only then there are sinks and/or sources .",
    "thus @xmath109 measures the amount of fluid escaping from ( respectively entering ) the region @xmath110 through @xmath106 .",
    "therefore ( 6.2 ) expresses the mass conservation law for @xmath110 .",
    "99 clarke , e.m .",
    "grumberg , o. and peled d.a . _ model checking _ , the mit press , 1999 .",
    "geist , d. landver , a. and singer , b.w .",
    "_ formal verification of a processor s bus interface unit _ ,",
    "ibm technical report , 1996 .",
    "katz , s. , grumberg , o. and geist , d. _ `` have i written enough proprieties ? '' - a method of comparison between specification and implementation _ , charme99 , bad herrenalb , germany , september 27 - 29 , 1999 .",
    "mcmillan , k.l .",
    "_ symbolic model checking _ , kluwer academic publishers , 1993 .",
    "parash , a. _ formal verification of an mpeg decoder chip : a case study in the industrial use of formal methods _ , wave 2000 - a cav2000 workshop .",
    "apelboim , e. and saucan , e. _ the axiomatic approach to model checking _ in preparation .",
    "hoskote , y. kam , t. ho , p .- s . and zhao , x. _ coverage estimation for symbolic model checking _ , in `` proceedings of the 36-rd design automation conference ( dac99 ) '' , ieee computer society press , june 1999 .",
    "apostol , tom m. , _ calculus _ , volume ii , blaisdell , new york , third edition , 1965 ."
  ],
  "abstract_text": [
    "<S> we present a novel scheme to the coverage problem , introducing a quantitative way to estimate the interaction between a block an its environment . </S>",
    "<S> this is achieved by setting a discrete version of green s theorem , specially adapted for model checking based verification of integrated circuits . </S>",
    "<S> + this method is best suited for the coverage problem since it enables one to quantify the incompleteness or , on the other hand , the redundancy of a set of rules , describing the model under verification . </S>",
    "<S> moreover this can be done continuously throughout the verification process , thus enabling the user to pinpoint the stages at which incompleteness / redundancy occurs . </S>",
    "<S> + although the method is presented locally on a small hardware example , we additionally show its possibility to provide precise coverage estimation also for large scale systems . </S>",
    "<S> we compare this method to others by checking it on the same test - cases . </S>"
  ]
}