{
  "article_text": [
    "polar codes , first discovered by arkan @xcite , are the first capacity - achieving codes for binary - input discrete memoryless channels with an explicit and deterministic structure .",
    "in addition , it was shown that a simple successive cancellation ( sc ) decoder asymptotically achieves the capacity with low complexity , of order @xmath2 where @xmath3 is the block - length @xcite . due to these extraordinary properties ,",
    "polar codes have captured the attention of both academia and industry alike .    motivated by the fact that the sc decoder tends to exhibit less promising performance with finite - length block codes , an important line of current research is to seek efficient decoders with better performance for polar codes . in @xcite and @xcite ,",
    "the authors proposed the successive cancellation list ( scl ) decoder , which was shown to approach the performance of maximum - likelihood ( ml ) decoding in the high signal - to - noise ratio ( snr ) regime , albeit at the cost of higher processing complexity of @xmath4 , where @xmath5 is the list size . later in @xcite",
    ", it was further demonstrated that polar codes concatenated with a high rate cyclic redundancy check ( crc ) code outperform turbo and ldpc codes by applying an adaptive scl decoder with sufficiently large list size .",
    "trading storage complexity for computational reduction , the authors in @xcite and @xcite proposed the successive cancellation stack ( scs ) decoder , which was shown to have much lower computational complexity compared with the scl decoder , especially in the high snr regime , where its complexity becomes close to that of the sc decoder . more recently ,",
    "a novel successive cancellation hybrid decoder was proposed in @xcite , which essentially combines the ideas of scl and scs decoders and provides a fine balance between the computational complexity and storage complexity .    as discussed above",
    ", the scl decoder achieves superior performance compared to the sc decoder at the price of increased complexity , especially when the list size @xmath5 is very large , which has prohibited its widespread implementation in practice . as such , reducing the computational complexity of the scl decoder is of considerable importance , motivating the current research . for the conventional scl decoder , each decoding path",
    "will be split into two paths when decoding an unfrozen bit and the number of `` best paths '' remains at @xmath5 until the termination of decoding , which causes an increased complexity of @xmath4 . to reduce the decoding complexity",
    ", we argue that it is unnecessary to split all the decoding paths , supported by the key observation that splitting can be avoided if the reliability of deciding the unfrozen bit @xmath6 or @xmath7 is sufficiently high .",
    "a direct consequence of such a split - reduced approach is that many fewer paths are likely to survive after pruning , i.e. , the number of `` best paths '' is much smaller than the list size , which results in further complexity reduction .",
    "the main contributions of this paper are summarized as follows :    1 .",
    "taking advantage of the fact that splitting is unnecessary if the unfrozen bit can be decoded with high reliability , a novel splitting rule is defined . moreover ,",
    "the behavior of the correct and incorrect decoding paths are characterized under the new splitting rule .",
    "based on which , a split - reduced scl decoder is proposed . by avoiding unnecessary path splitting as well as efficiently reducing the number of surviving paths ,",
    "the proposed split - reduced scl decoder can achieve significant reduction of complexity while retaining a similar error performance compared with the conventional scl decoder .",
    "2 .   furthermore , we prove the existence of a particular unfrozen bit @xmath1 , after which the sc decoder achieves the same error performance as the ml decoder if all the prior unfrozen bits are correct , and show how to locate the particular unfrozen bit .",
    "then , exploiting this crucial property , an enhanced version of the split - reduced scl decoder is proposed .",
    "the rest of the paper is organized below . in section",
    ", we provide some basic concepts and notation for polar codes and the scl decoder . in section",
    ", we present a novel split - reduced scl decoder and provide an analysis of its decoding behavior .",
    "an enhanced version of the split - reduced scl decoder is proposed in section while the simulation results are provided in section .",
    "finally , section gives a brief summary of the paper .",
    "in this section , we provide a brief introduction to polar codes , the sc decoder and the scl decoder , and explain the notation adopted in the paper .      for a polar code with block - length @xmath8 and dimension @xmath9",
    ", the generator matrix can be written as @xmath10 , where @xmath11 $ ] , @xmath12 is an @xmath13 bit - reversal permutation matrix , and @xmath14 denotes the @xmath15-th kronecker power .",
    "we use @xmath16 to represent the sequence @xmath17 , and as such , any codeword of a polar code can be expressed as @xmath18 , where @xmath19 is the information sequence consisting of @xmath20 frozen bits and @xmath9 unfrozen bits .",
    "let @xmath21 denote a binary discrete memoryless channel with input alphabet @xmath22 , output alphabet @xmath23 , and channel transition probabilities @xmath24 .",
    "after channel polarization , the transition probability of the @xmath25-th subchannel is given by @xmath26 where @xmath27    to implement the encoding , the @xmath9 most reliable subchannels are selected to transmit the unfrozen bits while the remaining subchannels are used for sending the frozen bits which are set to some fixed values ( see @xcite ) . without loss of generality , we assume that the frozen bits are zero valued .      define the logarithmic likelihood ratio ( llr ) of @xmath28 as @xmath29 where @xmath30 and @xmath31 denote an estimate of @xmath32 and the received sequence from the channel , respectively .",
    "we use base-@xmath33 logarithms throughout this paper unless otherwise specified .    for standard sc decoding ,",
    "bit - by - bit information decoding is performed . as such ,",
    "if @xmath28 is an unfrozen bit , @xmath34 is set to either @xmath35 or @xmath36 according to the sign of @xmath37 , i.e. , @xmath38    unlike the sc decoder which employs a hard - decision for each bit , the scl decoder inspects both options for the estimate of any unfrozen bit @xmath28 and splits each decoding path into two paths . nevertheless ,",
    "at each decoding stage , only the best @xmath5 paths survive in order to reduce the complexity .",
    "this section presents a simple split - reduced scl decoder .",
    "we start by first introducing a new splitting rule , and then examine the error performance under this rule . based on this",
    ", a novel scl decoding algorithm is proposed .",
    "finally , a brief discussion of the complexity comparison between the proposed algorithm and the conventional scl decoding algorithm is provided .      as mentioned above , the proposed split - reduced scl decoder exploits the fact that splitting is unnecessary if the reliability of decoding the unfrozen bit is high enough .",
    "therefore , to implement such a decoder , the first step is to define the rule of splitting , i.e. , how to decide whether the current decoding path shall split or not , and under what conditions . in the following ,",
    "we first choose a metric to measure the decoding reliability , then define an appropriate threshold for this metric to establish the rule .    according to polarization , each unfrozen",
    "bit @xmath28 would observe a subchannel @xmath39 and can be considered that @xmath28 is transmitted through such a synthetic channel .",
    "thus , the reliability of decoding @xmath28 actually depends on @xmath40 .",
    "although for binary erasure channel ( bec ) , the reliability can be explicitly described by @xmath41 ( see @xcite ) and computed in a recursive manner , the same approach does not appear to be applicable to other channels including binary symmetric channel ( bsc ) .",
    "therefore , we adopt the _ a posteriori _ probability as the metric of reliability for each subchannel , mainly inspired by @xcite , where the gaussian approximation was used to give an estimate for the error probability of @xmath40 .    having determined the measure of reliability , we now proceed to find an appropriate threshold . for subchannel @xmath40 and",
    "any given input @xmath28 , suppose that all prior bits have been correctly decoded . now let @xmath42 denote the estimation error probability of @xmath28 averaged over all possible outputs @xmath43 , i.e. , @xmath44 then @xmath42 in fact describes the probability that @xmath28 is incorrectly estimated in terms of the subchannel @xmath39 , given the correct prior bits @xmath45 . once each @xmath42 is computed , one has obtained some ` prior ' knowledge which implies that if the correct path reaches stage @xmath25 ( decode @xmath28 ) , the probability that @xmath28 is correctly estimated should not be too smaller than @xmath46 . in other words ,",
    "@xmath46 can be regarded as the confidence level of decoding reliability of the @xmath25-th subchannel .",
    "hence , it is a natural choice for threshold . in general , analytical evaluation of @xmath42",
    "is difficult .",
    "nevertheless , it can be computed via monte carlo simulation or the method introduced in @xcite .",
    "for the particular case of additive white gaussian noise ( awgn ) channels , @xmath42 can also be evaluated by assuming that the llr follows gaussian distribution with mean @xmath47 and variance @xmath48 @xcite .",
    "while the gaussian approximation assumption is used for analytical tractability , there are in fact theoretical supports to corroborate such assumption , as elaborated in the following .    without loss of generality , assuming an all - zero codeword is transmitted over an awgn channel with noise variance @xmath49 using binary phase shift keying ( bpsk ) , i.e. , the codeword @xmath50 is mapped to signal @xmath51 by @xmath52 , it is easy to show that the llr @xmath53 of each received symbol @xmath54 follows the @xmath55 distribution .",
    "recall that equations ( 75 ) and ( 76 ) in @xcite can be rewritten from an llr perspective as @xmath56 and @xmath57 where @xmath58 .",
    "note that we have used @xmath28 instead of the estimate @xmath34 since the real values of @xmath45 are provided when we compute @xmath42 and the coefficient @xmath59 in front of @xmath60 is omitted as well since all - zero codeword is transmitted . to simplify notations ,",
    "we denote @xmath61 and @xmath62 .",
    "it was demonstrated in @xcite that if the symmetry condition , which can be expressed as @xmath63 with @xmath64 being the density of an llr message , is satisfied , the probability density function ( pdf ) of the output of the check node is approximately a gaussian density which satisfies the symmetry condition as well .",
    "therefore , if both @xmath65 and @xmath66 are gaussian random variables that satisfy the symmetry condition , according to the result of @xcite , @xmath67 is approximately gaussian distributed and satisfies the symmetry condition . also , if @xmath65 and @xmath66 have the same pdf , i.e. , @xmath68 , it is easy to check that @xmath69 follows gaussian distribution with @xmath70 and satisfies the symmetry condition as well .",
    "now let us take a look at the received llr @xmath71 where @xmath72 , and it is easy to show that @xmath73 which indicates that the density of all the received llr messages satisfy the symmetry condition . with some simple algebraic manipulations , it can be shown that each llr @xmath37 can be expressed as a compound function of @xmath74 and @xmath75 with @xmath76 as the input . since @xmath53 has the same pdf @xmath68 ,",
    "it is easy to verify that all the intermediate outcomes of @xmath67 and @xmath69 are approximately gaussian distributed and satisfy the symmetry condition . therefore , @xmath37 can be approximated by the gaussian distribution .",
    "now by expressing equations ( 75 ) and ( 76 ) in [ 1 ] in the form of expectation , we have @xcite : @xmath77\\\\&=\\phi^{-1}\\big(1-\\big(1-\\phi(\\textbf{e}[l(y_1)])\\big)\\big(1-\\phi(\\textbf{e}[l(y_2)])\\big)\\big),\\\\ & \\textbf{e}[l(u_2)]\\\\&=\\textbf{e}[l(y_1)]+\\textbf{e}[l(y_2 ) ] , \\end{aligned}\\end{aligned}\\ ] ] where @xmath78 denotes expectation and @xmath79    as the likelihood ratios ( lr ) are recursively calculated by equations ( 75 ) and ( 76 ) in @xcite , the expectation of the llrs , i.e. , @xmath80 $ ] , can be calculated in a similar manner .",
    "then , based on the assumption that @xmath37 satisfies the gaussian distribution , the error probability of each subchannel @xmath39 can be calculated by using the @xmath81-function as @xmath82/2}),\\end{aligned}\\ ] ] where @xmath83 . since @xmath80 $ ] depends on @xmath84 $ ] with @xmath85 , where @xmath49 is the noise variance , it becomes clear that @xmath42 is also snr dependent .",
    "in addition , it is worth pointing out that , given @xmath49 , @xmath42 can be calculated in an off - line manner .",
    "having defined both the measure of reliability and the threshold , the splitting rule is given as follows : if either of the following two inequalities holds : @xmath86 @xmath87 the @xmath88-th path does not split , otherwise , the @xmath88-th path splits into two paths . for instance , if eq .",
    "( [ p_e(u_i0 ) ] ) holds , then we directly set @xmath89 instead of splitting the @xmath88-th path . according to bayes rule , a more convenient splitting rule can be found , as follows @xmath90 where @xmath91 denotes the llr of @xmath28 in the @xmath88-th decoding path and can be calculated in a recursive manner @xcite . for simplicity , we drop the subscript @xmath88 in the ensuing analysis .",
    "we now investigate the implications of the newly defined splitting rule . as we mainly focus on awgn channels ,",
    "the gaussian approximation method is adopted in the ensuing analytical derivation , i.e. , all the propositions in this subsection are based on the assumption that the llr @xmath37 follows gaussian distribution . for the purpose of clear exposition , we assume that an all - zero codeword is transmitted . please note that , according to the following proposition , using the all - zero codeword does not cause any loss of generality of the ensuing analysis , since the distribution of @xmath37 is symmetric for @xmath6 and @xmath7 .    under the gaussian approximation , i.e. , @xmath92,2|\\textbf{e}[l(u_i)]|)$ ] , for any codeword @xmath19 ,",
    "if @xmath93 , then we have    @xmath80=\\left\\ {   \\begin{aligned}%\\nonumber      & \\textbf{e}[l_0(u_i ) ] , \\ \\text{if }",
    "\\ u_i=0\\\\      & -\\textbf{e}[l_0(u_i ) ] , \\",
    "\\text{if } \\",
    "u_i=1\\\\   \\end{aligned }   \\right.,$ ]    where @xmath94 $ ] denotes the mean of @xmath37 for the all - zero codeword transmitted over an awgn channel with noise variance @xmath49 .",
    "[ proposition_mean ]    see appendix [ proofproposition_mean ] .",
    "we start by examining the error performance of the scl decoder with the newly defined splitting rule .",
    "the gaussian distributed @xmath37 is illustrated in fig .",
    "the two vertical lines correspond to two threshold values @xmath95 , cutting the entire range of @xmath37 into three separate parts , i.e. , @xmath96 , @xmath97 @xmath98 $ ] , and @xmath99 .",
    "the first interval denotes the event in which no splitting is performed and @xmath28 is incorrectly decoded , i.e. , @xmath100 .",
    "the probability of such event occurring can be computed as @xmath101+\\mathrm{log}(1-p_e(u_i))-\\mathrm{log}(p_e(u_i))}{\\sqrt{2\\textbf{e}[l_0(u_i)]}}\\big)\\\\ & = q\\big(\\sqrt{\\frac{\\textbf{e}[l_0(u_i)]}{2}}+\\frac{\\mathrm{log}(1/q(\\sqrt{\\frac{\\textbf{e}[l_0(u_i)]}{2}})-1)}{\\sqrt{2\\textbf{e}[l_0(u_i)]}}\\big)\\\\\\label{perror } & = q\\big(q^{-1}(p_e(u_i))+\\frac{\\mathrm{log}(1/p_e(u_i)-1)}{2q^{-1}(p_e(u_i))}\\big ) .",
    "\\end{aligned}\\ ] ]     under the gaussian approximation . ]",
    "similarly , the last interval corresponds to the event in which no splitting is performed and @xmath28 is correctly decoded , i.e. , @xmath102 , and the probability associated with such event can be computed as @xmath103 now , let @xmath47 and @xmath104 be the mean and standard deviation of @xmath37 when the all - zero codeword is transmitted , respectively , i.e. , @xmath105 $ ] and @xmath106}$ ]",
    ". then we have @xmath107    since the proposed splitting rule becomes activated when the decoding reliability is high , i.e. , @xmath42 is small , it is of particular interest to see the error performance in this regime , and we have the following important results .    [ lemmap ] under the gaussian approximation , i.e. , @xmath92,2|\\textbf{e}[l(u_i)]|)$ ] , we have 1 ) @xmath108 , i.e. , @xmath109 , and 2 ) @xmath110",
    ".    see appendix [ prooflemmap ] .",
    "( left ) and @xmath111 ( right ) as functions of @xmath42 . ]",
    "the essential message of proposition [ lemmap ] is that if the subchannel is sufficiently reliable , then with high probability , the correct path will not split and the unfrozen bit @xmath28 will be correctly decoded . as depicted in fig .",
    "[ pe ] ( left ) , when the subchannel reliability improves , i.e. , @xmath42 becomes smaller , the decoding error @xmath112 decreases rapidly , and it is much smaller than @xmath42 . similarly , fig .",
    "[ pe ] ( right ) shows that the probability of correct decoding @xmath111",
    "approaches @xmath36 quickly when @xmath42 becomes smaller , corroborating the claims of proposition [ lemmap ]",
    ".    armed with proposition 2 , we are ready to conjecture the behavior of the correct path in list decoding , which is in general hard to achieve a quantitative and explicit result since that number of error patterns increases exponentially and that the pruning operations involved in list decoding introduce very complicated coupling between paths .",
    "suppose that the correct decoding path survives until @xmath45 . under the gaussian approximation , as @xmath42 approaches zero , with high probability",
    ", the current path will survive at @xmath113 without splitting and @xmath28 will be correctly decoded .",
    "in addition , with the increasing reliability of the subsequent subchannels corresponding to @xmath114 , the correct path will survive till termination without splitting with high probability .",
    "some empirical evidences are provided in appendix [ proofproposition_correct ] .",
    "having characterized the behavior of the correct path , we now turn to examine the behavior of the incorrect path , and we have the following conjecture :    under the gaussian approximation , for any incorrect path that survives at some unfrozen bit @xmath28 , it will split at some stage within @xmath115 with high probability .",
    "some empirical evidences are provided in appendix [ proofproposition_incorrect ] .",
    "it was observed in @xcite that by inverting the first erroneous bit decision , the performance of the sc decoder can be significantly improved , which implies that the decoding error occurring in @xmath116 will elevate the estimate error of @xmath117 due to severe error propagation .",
    "this observation indeed provides concrete support for conjecture 2 .",
    "now , exploiting these desirable features presented in conjecture 1 and conjecture 2 , in combination with the proposed novel splitting rule , a low - complexity decoding procedure can be devised as detailed in the following subsection .",
    "the above arguments imply that all the decoding paths can be classified into two different types according to their splitting behaviors : _ type a ) _ surviving with almost no splitting , and _ type b ) _ splitting frequently . ideally , a",
    "_ type a ) _ path is unique , which corresponds to the correct codeword , while all other paths are supposed to belong to _ type b)_. to reduce the decoding complexity , the key thing is to reduce the number of surviving paths at each stage .",
    "we first introduce a counter @xmath118 $ ] for the @xmath88-th path at stage @xmath25 ( corresponding to @xmath28 ) , which counts the number of stages that the @xmath88-th path survives without splitting . for the @xmath88-th path ,",
    "if it proceeds to @xmath28 without splitting , then @xmath118=\\omega_l[i-1]+1 $ ] . while if the @xmath88-th path splits into two paths @xmath119 and @xmath120 , then @xmath121=\\omega_{l''}[i]=0 $ ] . now , utilizing the fact that the correct path seldom splits , while the incorrect path tends to split at a certain stage",
    ", we argue that if @xmath118 $ ] exceeds a predefined threshold @xmath0 , then the @xmath88-th path is more likely to be the correct path . as such , other remaining paths with corresponding counter values less than @xmath0 can be pruned , thereby reducing the number of surviving paths .    under the above rationale , we propose the following split - reduced scl algorithm :      in terms of complexity , the split - reduced scl decoder outperforms the scl decoder in two aspects .    1 .",
    "recall that for the conventional scl decoder , the number of decoding paths doubles after each unfrozen bit is processed .",
    "thus , the number of paths grows to the specified list size @xmath5 after @xmath122 unfrozen bits are processed . after which , at each stage , @xmath123 paths will be pruned to obtain the surviving @xmath5 paths .",
    "for the split - reduced scl decoder , as the splitting is avoided when the reliability of the subchannel is high enough , the speed of reaching the specified list size @xmath5 is relatively slower .",
    "in addition , @xmath124 paths ( @xmath125 ) are pruned on average at each stage .",
    "2 .   for the conventional scl decoder ,",
    "the number of surviving paths remains fixed at @xmath5 after the initial @xmath122 unfrozen bits are processed . for the split - reduced scl decoder , if the counter value of some path @xmath88 exceeds the predefined threshold @xmath0 , the number of surviving paths can be smaller than @xmath5 . in the extreme case , only the correct path survives while all other paths are pruned .",
    "it is worth pointing out that , the choice of the threshold @xmath0 affects both the decoding complexity and the error performance . in particular",
    ", it specifies the number of stages allowed at the decoder to identify the correct path . due to the error introduced by the underlying channel",
    ", the correct path might need several stages to accumulate its reliability . during this period",
    ", there may exist incorrect paths which appears to be more reliable and are mistaken as the ` correct ' path by the decoder .",
    "therefore , if @xmath0 is small , it is more likely that there will be incorrect paths exceeding the llr threshold and does not split while the correct one keeps splitting , which leads to an irreversible loss in performance if the real correct path is eliminated . as @xmath0 increases ,",
    "the correct path is given more time to accumulate its reliability , hence has a higher chance to win over the incorrect paths , thereby achieving a better performance .",
    "regarding the complexity , note that before any path arrives at the @xmath0 threshold , all candidate paths keep splitting with a high probability since at most one of them is the correct one .",
    "therefore , the decoder has to wait for at least @xmath0 stages until some path achieves the threshold @xmath0 . within this period ,",
    "the number of paths remains similar to that of scl decoder . in this regard ,",
    "it is desirable to have a smaller @xmath0 in terms of complexity savings .",
    "this section presents an enhanced split - reduced scl decoder , by exploiting conjecture 1 , that the correct decoding path tends to survive till termination without splitting after some unfrozen bit @xmath126 , which suggests the key idea of replacing the scl decoder with the sc decoder after this particular unfrozen bit .",
    "nevertheless , it is in general quite difficult to determine the exact index @xmath127 because the distribution of frozen and unfrozen bits is highly dependent on the underlying channel and no simple rules can be derived explicitly .",
    "however , it turns out that an upper bound , denoted by @xmath128 , can be found for the index @xmath127 , after which , splitting is completely avoided for the subsequent unfrozen bits .",
    "we now provide a simple polar code with block - length @xmath130 and rate @xmath131 as an example to illustrate how to find @xmath128 .",
    "we start by constructing a full binary tree with @xmath130 leaf nodes ( as mentioned in @xcite ) , as shown in fig .",
    "[ concrete_ideage ] .",
    "polar code with @xmath132 . ]",
    "each leaf node corresponds to either a frozen bit or an unfrozen bit with an index in @xmath133 counted from left to right , and a frozen bit is denoted by a white disk while the other leaf nodes are denoted by black ones . in this particular example , @xmath134 are frozen bits while @xmath135 are unfrozen bits .",
    "then , for a non - leaf node , if its two descendants have the same color it will also be colored the same , otherwise it is colored gray .",
    "the coloring process starts from the bottom leaf nodes until the root node is reached .",
    "after that , we start from the root node and check its right child node until the first black disk is found . in fig . [ concrete_ideage ] , we will find node @xmath136 which has @xmath137 and @xmath138 as its child nodes , and @xmath129 is equal to the number of leaf nodes that node @xmath136 has , i.e. , @xmath132 .",
    "since @xmath129 always has an exponential form of @xmath139 , instead of generating fig .",
    "[ concrete_ideage ] , one could also count the number of unfrozen bits from the last bit @xmath140 to @xmath141 until the first frozen bit is reached , the largest number of consecutive unfrozen bits , @xmath142 , will be the desired @xmath129 .",
    "we now present the following important relationship between sc decoding and ml decoding after the unfrozen bit @xmath1 , which will be used to design the enhanced split - reduced decoding algorithm .",
    "[ theorem_mlvssc ] suppose that the desired @xmath129 has been found , and all the unfrozen bits with indices @xmath143 have been supplied correctly by a genie , then sc decoder will achieve exactly the same performance as ml decoder .",
    "see appendix [ prooftheorem_mlvssc ] .    according to @xcite and @xcite ,",
    "the quality of a subchannel @xmath144 depends heavily on the first few least significant bits of the binary expansion of @xmath145 .",
    "now , recalling the process of locating node @xmath136 in fig .",
    "[ concrete_ideage ] , it is observed that such a node @xmath136 always corresponds to a subchannel with bhattacharyya parameter @xmath146 , where @xmath147 is the depth of node @xmath136 . in general , @xmath148 should take a rather small value , since @xmath149 and the power exponent @xmath150 grows exponentially , which implies the feasibility of using sc decoding for the unfrozen bits after @xmath1 without splitting .",
    "based on the above observation , the enhanced split - reduced scl decoding algorithm can then be summarized as follows :    fig .",
    "[ intuitive ] illustrates the decoding procedure of the enhanced split - reduced scl decoder .",
    "for the unfrozen bits before @xmath1 , the splitting rule as per ( [ l(u_i)threshold ] ) is used , while for the unfrozen bits @xmath151 , simplified sc decoding is implemented instead .",
    "it is easy to see that the complexity is further reduced by the enhanced split - reduced scl decoder , due to the elimination of path - splitting after @xmath1 , nevertheless , the achievable error performance is not clear . in the following ,",
    "we show that the enhanced split - reduced scl decoder outperforms the original version in terms of error rate as well .",
    "[ theorem_enhanced_performance ] the decoding error performance achieved by the enhanced split - reduced scl decoder is no worse than the original version .",
    "see appendix [ prooftheorem_enhanced_performance ] .",
    "it is also of interest to consider the worst case complexity of the proposed scheme .",
    "since the worst case appears when every path splits , where the llr threshold and @xmath0 threshold are never achieved , hence the proposed scheme reduces to the original scl decoder .",
    "however , the upper bound @xmath128 after which sc decoding can be implemented always exists .",
    "therefore , even for the worst case , the proposed algorithm can reduce the complexity by @xmath152 compared with the scl decoding scheme without degrading performance .",
    "in this section , numerical simulation results are presented to illustrate the performance of the proposed decoding algorithms . since the enhanced split - reduced scl decoder requires lower complexity , but achieves no worse decoding error performance compared to the simple split - reduced scl decoder , we consider only the enhanced split - reduced scl decoder in simulations ( we will use esr - scl as the shorthand for enhanced split - reduced scl decoder in the following figures ) .        fig . [ per ] shows the block error rate of scl decoder , enhanced split - reduced scl decoder with different @xmath0 and crc - aided scl decoder with generator polynomial @xmath153 [ 18 ] , where @xmath154 , @xmath155 and list size @xmath156 . as expected , when @xmath0 increases , the performance of enhanced split - reduced scl decoder improves .",
    "in addition , we see that the crc - aided scl decoder significantly outperforms the scl decoder .    , with @xmath157 .",
    "]    define @xmath158 as the average number of decoding paths that are split when @xmath28 is processed , and let @xmath159 be the total number of independent trials ; then @xmath160 , where @xmath161 is defined as the number of splitting paths at stage @xmath25 in the @xmath162-th experiment .",
    "the average number of paths before and after pruning are defined similarly .    , with @xmath163 . ]",
    "[ db2_omega ] illustrates @xmath158 for scl decoder and enhanced split - reduced scl decoder with different @xmath0 at snr@xmath164 when @xmath154 , @xmath155 and list size @xmath156 , after pruning operation .",
    "since scl decoder always splits decoding paths for each unfrozen bit , the number of decoding paths increases to the specified list size @xmath156 at an exponential rate , i.e. , from 0 to 1 , 2 , 4 , 8 , and remains at 8 till termination . on the other hand , for enhanced split - reduced scl decoder , it can be observed that the average number of paths after pruning operation keeps smaller than @xmath165 for most indices .",
    "as @xmath0 increases , less complexity can be saved , since the decoder has to wait for some longer stages until some path achieves the @xmath0 threshold , and during this period , the number of paths still stays at a large value .",
    "besides , recall that enhanced split - reduced scl decoder degrades to sc decoding after the index @xmath128 . for this particular case , @xmath166 , hence @xmath167 , which indicates that 25% of the unfrozen bits can be decoded by sc decoding rather than list decoding .",
    "it has been observed in @xcite that scl decoder with list size @xmath168 almost achieves the same performance .",
    "thus , to achieve a better performance , the list size should be at least @xmath169 .",
    "[ db3_omega ] shows the number of paths after pruning with @xmath163 . for small @xmath0 ,",
    "the average number of paths remains smaller than @xmath170 , which implies that it can not retain some similar performance as scl decoder . on the other hand , with large @xmath171 ,",
    "the performance significantly improves and becomes closer to that of the scl decoder , yet with reduced complexity .",
    "[ omega45_db ] plots the average number of decoding paths after pruning for different snrs with @xmath172 .",
    "it can be observed that as snr increases , the average number of decoding paths after pruning decreases .",
    "since the received symbols are more reliable for high snrs , the llr threshold ( see ( [ l(u_i)threshold ] ) ) will be achieved with a higher probability , and once the @xmath0 threshold is achieved , the other paths will be eliminated without splitting , as analyzed by using gaussian approximation .",
    "besides , as the average number of paths after pruning decreases for higher snrs , it will lead to some performance further deviating from scl decoding ( see fig . [ per ] ) .     with different snrs .",
    "in this paper , we have proposed low complexity split - reduced scl decoders for polar codes . by exploiting the fact that splitting can be avoided if the reliability of decoding the unfrozen bit is high enough ,",
    "a new splitting rule was defined . under this splitting rule ,",
    "it was conjectured that , if the correct path survived at some stage , it tends to survive till termination without splitting , while the incorrect path is more likely to split in the following stages .",
    "this critical behavior was then used to design a new low complexity scl decoder .",
    "furthermore , it was explicitly shown that there exists a particular unfrozen bit @xmath1 for any polar codes , and sc decoding can be implemented instead to decode the following unfrozen bits without degradation of error performance .",
    "we first focus on the basic decoding element defined by @xmath173 , and consider the case @xmath174 .",
    "this leads to @xmath175=-\\frac{2}{\\sigma_n^2}$ ] and @xmath176=\\frac{2}{\\sigma_n^2}$ ] .",
    "then , @xmath177)&=1-\\big(1-\\phi(-\\frac{2}{\\sigma_n^2})\\big)\\big(1-\\phi(\\frac{2}{\\sigma_n^2})\\big)\\\\ & \\overset{(a)}=1+\\big(1-\\phi(\\frac{2}{\\sigma_n^2})\\big)\\big(1-\\phi(\\frac{2}{\\sigma_n^2})\\big)\\\\ & = 2-\\phi(\\textbf{e}[l_0(u_1)])\\overset{(b)}=\\phi(-\\textbf{e}[l_0(u_1 ) ] ) .",
    "\\end{aligned}\\ ] ] steps ( a ) and ( b ) come from the fact that @xmath178 .",
    "thus , @xmath179=-\\textbf{e}[l_0(u_1)]$ ] and @xmath180=-(-\\frac{2}{\\sigma_n^2})+\\frac{2}{\\sigma_n^2}=\\textbf{e}[l_0(u_2)]$ ] . for all other possible values of @xmath181 ,",
    "similar results hold . as polar codes",
    "are recursively constructed based on @xmath173 , by simple induction , the claim follows",
    ".      denote @xmath182 , and thus from ( [ perror ] ) we have @xmath183 . for the following derivation",
    ", we will use @xmath184 to denote the lhpital s rule .",
    "then , we have @xmath185    one can also check that @xmath186 and @xmath187 thus @xmath108 holds .    next , recall @xmath188/2})$ ] , i.e. , @xmath189/2}=\\sigma/2 $ ]",
    ". then we have @xmath190 note that @xmath191 thus @xmath192 , and we have @xmath110 .",
    "the first two statements are straightforward results due to proposition [ lemmap ] . according to @xcite ,",
    "the metric for each path could be computed in a recursive manner according to @xmath193 for the correct path , @xmath194 which implies that the reliability of this path after choosing @xmath89 hardly degrades .",
    "thus , as the correct path survives at @xmath195 , it would not be pruned and continue to survive at @xmath28 with high probability . by induction on @xmath25",
    ", the correct path would survive to the last without splitting if the following subchannels are reliable enough .",
    "the sc decoding process can be interpreted based on a full binary tree with @xmath8 leaf nodes , where postorder traversal is implemented .",
    "we use fig .",
    "[ proof ] to give a simple illustration , where @xmath196 and @xmath197 denote the child nodes of node @xmath198 while @xmath199 denotes the parent node .",
    "when node @xmath198 is activated , it would first receive an llr vector @xmath200 from @xmath199 .",
    "suppose that the length of @xmath200 is @xmath201 .",
    "then , node @xmath198 would compute the llr vector @xmath202 of length @xmath203 according to sc decoding and passes @xmath202 to node @xmath196 .",
    "after node @xmath196 produces its own codeword @xmath204 of length @xmath203 and passes it back to node @xmath198 , another llr vector @xmath205 of length @xmath203 would be computed at node @xmath198 and sent to node @xmath197 .",
    "after node @xmath198 receives codeword @xmath206 , it would produce its own codeword @xmath207 by associating @xmath204 and @xmath206 according to @xmath173 .",
    "the above description defines a recursive algorithm .",
    "the initialization is done by assigning the llrs received from the underlying channel to the root node , while the recursion returns at each leaf node since leaf nodes correspond to the sequence @xmath19 and hard decisions are implemented .",
    "suppose that @xmath208 errors occur at node @xmath196 , i.e. , @xmath208 bits are set to @xmath36 in @xmath204 ( assuming the all - zero codeword transmitted ) . with a slight abuse of notation",
    ", we use @xmath209 $ ] to denote the component with index @xmath25 , and we have @xmath210=(1 - 2\\beta_{v_1}[i])\\textbf{e}[\\alpha_{v}[2i]]+\\textbf{e}[\\alpha_v[2i+1]]$ ] . note that @xmath211=\\textbf{e}[\\alpha_v[j]]$ ] holds for any @xmath212 , and thus @xmath210=0 $ ] if @xmath213=1 $ ] . in ( [ elu ] ) , one can check that if only @xmath175 $ ] ( or @xmath176 $ ] ) is zero , we have @xmath179=0 $ ] and @xmath180=\\textbf{e}[l(y_2)]$ ] ( or @xmath180=\\textbf{e}[l(y_1)]$ ] ) ; while if both @xmath175=0 $ ] and @xmath176=0 $ ] hold , we have @xmath179=\\textbf{e}[l(u_2)]=0 $ ] .",
    "thus , the number of llrs whose means are zero - valued remains the same after the calculation defined by ( [ elu ] ) .",
    "as node @xmath197 would pass another two llr vectors computed according to ( [ elu ] ) to its left child node and right child node respectively , by some simple induction , we can conclude that there would be at least @xmath208 leaf nodes that have zero - valued means .",
    "for an unfrozen bit @xmath28 , @xmath80=0 $ ] implies a significant degradation to the original subchannel , and it is more difficult to achieve the thresholds @xmath95 ( @xmath214 usually stays far away from zero if @xmath28 is an unfrozen bit ) .",
    "as there would be at least @xmath208 leaf nodes having zero - valued means , this incorrect path is quite likely to split at the following stages .",
    "we first provide a lemma , which will be invoked in the proof of theorem [ theorem_mlvssc ] .",
    "[ lemma_ml ] for a symmetric b - dmc with received llrs @xmath215 , the ml decoder will output the codeword @xmath216    @xmath217    as @xmath31 denotes the symbols received from the underlying channel , @xmath218 is just a constant which is independent of @xmath51 .",
    "thus , @xmath219 note that @xmath220 is also a constant once @xmath31 is determined .",
    "thus , @xmath221    now we establish a full binary tree as illustrated in fig .",
    "[ concrete_ideage ] for the proof .",
    "use @xmath222 to denote the codeword associated with a node @xmath198 and @xmath223,l_v[2], ... ,l_v[m])$ ] to denote the related llrs .",
    "the codeword @xmath224 of root node @xmath225 just corresponds to @xmath51 , the last stage output of the encoder , while @xmath226,l_a[2], ... ,l_a[n])$ ] represents the received llrs from the underlying channel .",
    "let @xmath227 and @xmath228 be the left and right child node of the root node @xmath225 , respectively . then considering the basic encoding operation with the matrix @xmath173 we have @xmath229 and @xmath230 , for @xmath231 .",
    "as @xmath232 are correctly known , the ml decoder will select the estimate @xmath233 to maximize ( see lemma [ lemma_ml ] ) : @xmath234 \\\\ & = \\mathop{\\mathrm{argmax}}_{u_{n - k_1 + 1}^n}\\big(\\sum_{i=1}^{n/2}(1 - 2(d_i \\oplus c_i))l_a[2i-1]\\\\ & +",
    "\\sum_{i=1}^{n/2}(1 - 2c_i)l_a[2i]\\big)\\\\ & = \\mathop{\\mathrm{argmax}}_{u_{n - k_1 + 1}^n}\\sum_{i=1}^{n/2}(1 - 2c_i)\\big((1 - 2d_i)l_a[2i-1]+l_a[2i]\\big ) .",
    "\\end{aligned}\\ ] ] the sc decoder calculates the llrs at node @xmath228 according to equation ( 76 ) in @xcite , and one can check that @xmath235=(1 - 2d_i)l_a[2i-1]+l_a[2i]$ ] , which is known since @xmath236 $ ] is the received llr and @xmath237 only depends on @xmath232 .",
    "thus we have @xmath238.\\ ] ]    then we consider the child nodes of node @xmath228 and repeat the above steps , until the first black node @xmath136 is reached .",
    "similarly , we can have @xmath239 , \\label{llr_metric_for ml_decoding } \\end{aligned}\\ ] ] where @xmath240 $ ] equals the llr calculated by the sc decoder according to equation ( 76 ) in @xcite .",
    "obviously , to maximize the summation in ( [ llr_metric_for ml_decoding ] ) , it requires that the binary codeword of @xmath241 are decided according to the signs of @xmath242 , l_b[2 ] , ... , l_b[k_1])$ ] , which are just equivalent to the one - by - one hard decisions in sc decoding , except that an inverse encoding operation is needed to obtain the desired @xmath243 .",
    "therefore , sc decoder achieves exactly the same performance as ml decoder provided the real values of @xmath232 are known .",
    "it is obvious that before @xmath1 is processed , the enhanced split - reduced scl decoder achieves exactly the same performance as the original one .",
    "suppose that @xmath88 paths survive when @xmath1 is reached . for each surviving path , there should be @xmath244 possible paths which all originate from the nodes at the @xmath245-th level ( just corresponds to the @xmath245-th bit , see @xcite ) in the list decoding framework .",
    "according to theorem [ theorem_mlvssc ] , for any particular path , the conventional sc decoding suffices to achieve the ml decoding performance ( note that this is not the overall ml decoding performance since the estimated unfrozen bits before @xmath1 are not guaranteed to be correct ) .",
    "thus , for each particular path arriving at @xmath1 , the conventional sc decoding algorithm would select the best path among all @xmath244 possible ones , i.e. , the best estimate @xmath233 for each surviving path can be obtained directly .",
    "thus , the overall best estimate of @xmath19 must be involved in these @xmath88 surviving candidate codewords .",
    "finally , the candidate codeword that has the smallest distance from the received symbols @xmath31 is selected as the decoding output .",
    "the authors sincerely thank the guest editor and the anonymous reviewers for their constructive suggestions which helped us to improve the manuscript .",
    "e. arkan , `` channel polarization : a method for constructing capacity - achieving codes for symmetric binary - input memoryless channels , '' _ ieee trans .",
    "inf . theory _ ,",
    "55 , no . 7 , pp . 3051 - 3073 , jul .",
    "i. tal and a. vardy ,  list decoding of polar codes , \" in _ proc .",
    "inf . theory ( isit ) _ , pp . 1 - 5 , aug .",
    "2011 .",
    "i. tal and a. vardy ,  how to construct polar codes , \" _ ieee trans .",
    "inf . theory _ ,",
    "6562 - 6582 , oct .",
    "p. trifonov ,  efficient design and decoding of polar codes , \" _ ieee trans . commun .",
    "60 , no . 11 , pp .",
    "3221 - 3227 , nov .",
    "d. wu , y. li , and y. sun ,  construction and block error rate analysis of polar codes over awgn channel based on gaussian approximation , \" _ ieee commun .",
    "18 , no . 7 , pp .",
    "1099 - 1102 , jul . 2014 . t. j. richardson , a. shokrollahi , and r. urbanke ,  design of capacity - approaching low - density parity - check codes , \" _ ieee trans .",
    "inf . theory _ ,",
    "47 , pp . 619 - 637 , feb . 2001 .",
    "chung , t. j. richardson , and r. urbanke ,  analysis of sum - product decoding of low - density parity - check codes using a gaussian approximation , \" _ ieee trans .",
    "inf . theory _ ,",
    "657 - 670 , feb . 2001 .",
    "a. alamdar - yazdi and f. r. kschischang ,  a simplified successive - cancellation decoder for polar codes , \" _ ieee commun .",
    "1378 - 1380 , dec . 2011",
    "s. h. hassani and r. urbanke ,  on the scaling of polar codes : i. the behavior of polarized channels , \" in _ proc .",
    "inf . theory ( isit ) _ , pp .",
    "874 - 878 , jun . 2010 .",
    "s. h. hassani , k. alishahi , and r. urbanke ,  on the scaling of polar codes : ii .",
    "the behavior of un - polarized channels , \" in _ proc .",
    "inf . theory ( isit ) _ , pp .",
    "879 - 883 , jun . 2010 .",
    "j. g. proakis , _ digital communications .",
    "_ mcgraw hill , 1995 ."
  ],
  "abstract_text": [
    "<S> this paper focuses on low complexity successive cancellation list ( scl ) decoding of polar codes . in particular , using the fact that splitting may be unnecessary when the reliability of decoding the unfrozen bit is sufficiently high , a novel splitting rule is proposed . </S>",
    "<S> based on this rule , it is conjectured that , if the correct path survives at some stage , it tends to survive till termination without splitting with high probability . on the other hand , </S>",
    "<S> the incorrect paths are more likely to split at the following stages . </S>",
    "<S> motivated by these observations , a simple counter that counts the successive number of stages without splitting is introduced for each decoding path to facilitate the identification of correct and incorrect path . specifically , any path with counter value larger than a predefined threshold @xmath0 is deemed to be the correct path , which will survive at the decoding stage , while other paths with counter value smaller than the threshold will be pruned , thereby reducing the decoding complexity . </S>",
    "<S> furthermore , it is proved that there exists a unique unfrozen bit @xmath1 , after which the successive cancellation decoder achieves the same error performance as the maximum likelihood decoder if all the prior unfrozen bits are correctly decoded , which enables further complexity reduction . </S>",
    "<S> simulation results demonstrate that the proposed low complexity scl decoder attains performance similar to that of the conventional scl decoder , while achieving substantial complexity reduction .    </S>",
    "<S> polar codes , gaussian approximation , split - reduced successive cancellation list decoder . </S>"
  ]
}